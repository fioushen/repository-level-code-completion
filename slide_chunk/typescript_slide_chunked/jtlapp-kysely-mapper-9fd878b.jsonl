{"filename": "comparison/mapperless-UserRepo-embedded-transforms.ts", "chunked_list": ["import { Kysely } from 'kysely';\nimport { User, UserID } from '@fieldzoo/model';\nimport { Database } from '../tables/table-interfaces';\n\nexport class UserRepo {\n  constructor(readonly db: Kysely<Database>) {}\n\n  async add(user: User): Promise<User> {\n    const returns = await this.db\n      .insertInto('users')\n      .values(this.upsertTransform(user))\n      .returning(['id', 'createdAt', 'modifiedAt'])\n      .executeTakeFirst();\n    return User.castFrom({ ...user, ...returns });\n  }\n\n  async deleteByID(id: UserID): Promise<boolean> {\n    const result = await this.db\n      .deleteFrom('users')\n      .where('id', '=', id)\n      .executeTakeFirst();\n    return result.numDeletedRows > 0;\n  }\n\n  async getByID(id: UserID): Promise<User | null> {\n    const row = await this.db\n      .selectFrom('users')\n      .selectAll()\n      .where('id', '=', id)\n      .executeTakeFirst();\n    return row ? User.castFrom(row) : null;\n  }\n\n  async update(user: User): Promise<boolean> {\n    const returns = await this.db\n      .updateTable('users')\n      .set(this.upsertTransform(user))\n      .where('id', '=', user.id)\n      .returning(['modifiedAt'])\n      .executeTakeFirst();", "    if (returns === undefined) {\n      return false;\n    }\n    Object.assign(user, returns) as User;\n    return true;\n  }\n\n  private upsertTransform(user: User) {\n    const values = { ...user } as any;\n    delete values['id'];\n    delete values['createdAt'];\n    delete values['modifiedAt'];\n    return values;\n  }\n}\n"]}
{"filename": "comparison/mapperless-UserRepo-calling-transforms.ts", "chunked_list": ["import { Kysely, Selectable, Selection } from 'kysely';\nimport { User, UserID } from '@fieldzoo/model';\nimport { Database, Users } from '../tables/table-interfaces';\n\nexport class UserRepo {\n  constructor(readonly db: Kysely<Database>) {}\n\n  async add(user: User): Promise<User> {\n    const returns = await this.db\n      .insertInto('users')\n      .values(this.upsertTransform(user))\n      .returning(['id', 'createdAt', 'modifiedAt'])\n      .executeTakeFirst();\n    return this.insertReturnTransform(user, returns!);\n  }\n\n  async deleteByID(id: UserID): Promise<boolean> {\n    const result = await this.db\n      .deleteFrom('users')\n      .where('id', '=', id)\n      .executeTakeFirst();\n    return result.numDeletedRows > 0;\n  }\n\n  async getByID(id: UserID): Promise<User | null> {\n    const row = await this.db\n      .selectFrom('users')\n      .selectAll()\n      .where('id', '=', id)\n      .executeTakeFirst();\n    return row ? this.selectTransform(row) : null;\n  }\n\n  async update(user: User): Promise<boolean> {\n    const returns = await this.db\n      .updateTable('users')\n      .set(this.upsertTransform(user))\n      .where('id', '=', user.id)\n      .returning(['modifiedAt'])\n      .executeTakeFirst();", "    if (returns === undefined) {\n      return false;\n    }\n    this.updateReturnTransform(user, returns!);\n    return true;\n  }\n\n  private upsertTransform(user: User) {\n    const values = { ...user } as any;\n    delete values['id'];\n    delete values['createdAt'];\n    delete values['modifiedAt'];\n    return values;\n  }\n\n  private insertReturnTransform(\n    user: User,\n    returns: Selection<Database, 'users', 'id' | 'createdAt' | 'modifiedAt'>\n  ) {\n    return User.castFrom({ ...user, ...returns });\n  }\n\n  private updateReturnTransform(\n    user: User,\n    returns: Selection<Database, 'users', 'modifiedAt'>\n  ) {\n    return Object.assign(user, returns) as User;\n  }\n\n  private selectTransform(row: Selectable<Users>) {\n    return User.castFrom(row);\n  }\n}\n"]}
{"filename": "comparison/UserRepo-using-mapper.ts", "chunked_list": ["import { Kysely } from 'kysely';\nimport { TableMapper } from 'kysely-mapper';\nimport { User, UserID } from '@fieldzoo/model';\nimport { Database } from '../tables/table-interfaces';\n\nexport class UserRepo {\n  readonly #table: ReturnType<UserRepo['getMapper']>;\n\n  constructor(readonly db: Kysely<Database>) {\n    this.#table = this.getMapper(db);\n  }\n\n  async add(user: User): Promise<User> {\n    return this.#table.insert().returnOne(user);\n  }\n\n  async deleteByID(id: UserID): Promise<boolean> {\n    return this.#table.delete(id).run();\n  }\n\n  async getByID(id: UserID): Promise<User | null> {\n    return this.#table.select(id).returnOne();\n  }\n\n  async update(user: User): Promise<boolean> {\n    return (await this.#table.update(user.id).returnOne(user)) !== null;\n  }\n\n  private getMapper(db: Kysely<Database>) {\n    const upsertTransform = (user: User) => {\n      const values = { ...user } as any;\n      delete values['id'];\n      delete values['createdAt'];\n      delete values['modifiedAt'];\n      return values;\n    };\n\n    return new TableMapper(db, 'users', {\n      keyColumns: ['id'],\n      insertReturnColumns: ['id', 'createdAt', 'modifiedAt'],\n      updateReturnColumns: ['modifiedAt'],\n    }).withTransforms({\n      insertTransform: upsertTransform,\n      insertReturnTransform: (user: User, returns) =>\n        User.castFrom({ ...user, ...returns }),\n      updateTransform: upsertTransform,\n      updateReturnTransform: (user: User, returns) =>\n        Object.assign(user, returns) as User,\n      selectTransform: (row) => User.castFrom(row),\n    });\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './mappers/abstract-table-mapper';\nexport * from './mappers/table-mapper';\nexport * from './mappers/table-mapper-settings';\nexport * from './mappers/table-mapper-transforms';\nexport * from './mappers/entire-row-transforms';\nexport * from './lib/query-filter';\n"]}
{"filename": "src/queries/compiling-update-query.ts", "chunked_list": ["import { Kysely, UpdateQueryBuilder, UpdateResult, Updateable } from 'kysely';\n\nimport { SelectionColumn } from '../lib/type-utils';\nimport { CompilingValuesQuery } from './compiling-values-query';\nimport { ParametersObject } from 'kysely-params';\nimport {\n  CountTransform,\n  UpdateTransforms,\n} from '../mappers/table-mapper-transforms';\n", "} from '../mappers/table-mapper-transforms';\n\n/**\n * Compiling mapping query for updating rows in a database table.\n */\nexport class CompilingMappingUpdateQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n  UpdatingObject,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  ReturnCount,\n  UpdateReturn,\n  Parameters extends ParametersObject<Parameters>\n> extends CompilingValuesQuery<\n  DB,\n  TB,\n  QB,\n  UpdateReturnColumns,\n  Parameters,\n  Updateable<DB[TB]>\n> {\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    protected readonly columnsToUpdate: Readonly<\n      (keyof Updateable<DB[TB]> & string)[]\n    >,\n    protected readonly transforms: Readonly<\n      CountTransform<ReturnCount> &\n        UpdateTransforms<\n          DB,\n          TB,\n          UpdatingObject,\n          UpdateReturnColumns,\n          UpdateReturn\n        >\n    >,\n    returnColumns: Readonly<UpdateReturnColumns>\n  ) {\n    super(db, returnColumns);\n    const parameterizedValues = this.getParameterizedObject(columnsToUpdate);\n    this.qb = qb.set(parameterizedValues) as QB;\n  }\n\n  /**\n   * Runs the query, returning the number of rows updated, in the required\n   * client representation. Accepts values for any parameters embedded in\n   * the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param obj The object which which to update the rows.\n   * @returns Number of rows updated, in client-requested representation.\n   */\n  async returnCount(\n    params: Parameters,\n    obj: UpdatingObject\n  ): Promise<ReturnCount> {\n    const transformedObj = this.applyUpdateTransform(obj);\n    const compiledQuery = this.instantiateNoReturns(params, transformedObj);\n    const result = await this.db.executeQuery(compiledQuery);\n    return this.transforms.countTransform === undefined\n      ? (result.numAffectedRows as ReturnCount)\n      : this.transforms.countTransform(result.numAffectedRows!);\n  }\n\n  /**\n   * Updates rows with the values that result from transforming the object via\n   * `insertTransform` (if defined). For each row updated, retrieves the\n   * columns specified in `returnColumns` (if defined), returning them to the\n   * caller as an `UpdateReturn`, after transformation by any provided\n   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @returns If `returnColumns` is not empty, returns an array containing one\n   *  object for each row updated; otherwise returns `undefined`.\n   */\n  returnAll(\n    params: Parameters,\n    obj: UpdatingObject\n  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn[]>;\n\n  async returnAll(\n    params: Parameters,\n    obj: UpdatingObject\n  ): Promise<UpdateReturn[] | void> {", "    if (this.returnColumns.length === 0) {\n      await this.run(params, obj as UpdatingObject);\n      return;\n    }\n    const transformedObj = this.applyUpdateTransform(obj as UpdatingObject);\n    const compiledQuery = this.instantiateWithReturns(params, transformedObj);\n    const result = await this.db.executeQuery(compiledQuery);\n    return this.transforms.updateReturnTransform === undefined\n      ? (result.rows as any)\n      : result.rows.map((row) =>\n          this.applyUpdateReturnTransform(obj as UpdatingObject, row as any)\n        );\n  }\n\n  /**\n   * Updates rows with the values that result from transforming the object via\n   * `updateTransform` (if defined). For the first row updated, retrieves the\n   * columns specified in `returnColumns` (if defined), returning them to the\n   * caller as an `UpdateReturn`, after transformation by any provided\n   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @returns If `returnColumns` is empty, returns `undefined`. Otherwise,\n   *  returns the first object if at least one row was updated, or `null` if\n   *  no rows were updated.\n   */\n  returnOne(\n    params: Parameters,\n    obj: UpdatingObject\n  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn | null>;\n\n  async returnOne(\n    params: Parameters,\n    obj: UpdatingObject\n  ): Promise<UpdateReturn | null | void> {", "    if (this.returnColumns.length === 0) {\n      await this.run(params, obj as UpdatingObject);\n      return;\n    }\n    const transformedObj = this.applyUpdateTransform(obj as UpdatingObject);\n    const compiledQuery = this.instantiateWithReturns(params, transformedObj);\n    const result = await this.db.executeQuery(compiledQuery);\n    if (result.rows.length === 0) {\n      return null;\n    }\n    return this.applyUpdateReturnTransform(\n      obj as UpdatingObject,\n      result.rows[0] as any\n    );\n  }\n\n  /**\n   * Runs the query, updating rows, without returning any columns. Accepts\n   * values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param obj The object which which to update the rows.\n   * @returns `true` if any rows were updated, `false` otherwise.\n   */\n  async run(params: Parameters, obj: UpdatingObject): Promise<boolean> {\n    return (await this.returnCount(params, obj)) !== 0;\n  }\n\n  protected applyUpdateTransform(obj: UpdatingObject): Updateable<DB[TB]> {\n    return this.transforms.updateTransform === undefined\n      ? (obj as Updateable<DB[TB]>)\n      : this.transforms.updateTransform(obj, this.columnsToUpdate);\n  }\n\n  protected applyUpdateReturnTransform(source: UpdatingObject, returns: any) {\n    return this.transforms.updateReturnTransform === undefined\n      ? (returns as any)\n      : this.transforms.updateReturnTransform(source, returns);\n  }\n}\n"]}
{"filename": "src/queries/delete-query.ts", "chunked_list": ["import { DeleteQueryBuilder, DeleteResult, Kysely } from 'kysely';\nimport { ParameterizableMappingQuery } from './parameterizable-query';\nimport { ParametersObject } from 'kysely-params';\nimport { CompilingMappingDeleteQuery } from './compiling-delete-query';\nimport { CountTransform } from '../mappers/table-mapper-transforms';\n\n/**\n * Mapping query for deleting rows from a database table.\n */\nexport class MappingDeleteQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends DeleteQueryBuilder<DB, TB, DeleteResult>,\n  ReturnCount\n> implements ParameterizableMappingQuery\n{\n  constructor(\n    protected readonly db: Kysely<DB>,\n    protected readonly qb: QB,\n    protected readonly transforms: Readonly<CountTransform<ReturnCount>>\n  ) {}\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling delete query.\n   */\n  compile<\n    Parameters extends ParametersObject<Parameters> = {}\n  >(): CompilingMappingDeleteQuery<DB, TB, QB, ReturnCount, Parameters> {\n    return new CompilingMappingDeleteQuery(this.db, this.qb, this.transforms);\n  }\n\n  /**\n   * Runs the query, returning the number of rows deleted, converted to\n   * the required client representation.\n   * @returns Number of rows deleted, in client-requested representation.\n   */\n  async returnCount(): Promise<ReturnCount> {\n    const result = await this.qb.executeTakeFirst();\n    return this.transforms.countTransform === undefined\n      ? (result.numDeletedRows as ReturnCount)\n      : this.transforms.countTransform(result.numDeletedRows);\n  }\n\n  /**\n   * Modifies the underlying Kysely query builder.", " */\nexport class MappingDeleteQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends DeleteQueryBuilder<DB, TB, DeleteResult>,\n  ReturnCount\n> implements ParameterizableMappingQuery\n{\n  constructor(\n    protected readonly db: Kysely<DB>,\n    protected readonly qb: QB,\n    protected readonly transforms: Readonly<CountTransform<ReturnCount>>\n  ) {}\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling delete query.\n   */\n  compile<\n    Parameters extends ParametersObject<Parameters> = {}\n  >(): CompilingMappingDeleteQuery<DB, TB, QB, ReturnCount, Parameters> {\n    return new CompilingMappingDeleteQuery(this.db, this.qb, this.transforms);\n  }\n\n  /**\n   * Runs the query, returning the number of rows deleted, converted to\n   * the required client representation.\n   * @returns Number of rows deleted, in client-requested representation.\n   */\n  async returnCount(): Promise<ReturnCount> {\n    const result = await this.qb.executeTakeFirst();\n    return this.transforms.countTransform === undefined\n      ? (result.numDeletedRows as ReturnCount)\n      : this.transforms.countTransform(result.numDeletedRows);\n  }\n\n  /**\n   * Modifies the underlying Kysely query builder.", "   * @param factory A function that takes the current query builder and\n   *  returns a new query builder.\n   */\n  modify<NextQB extends DeleteQueryBuilder<DB, any, DeleteResult>>(\n    factory: (qb: QB) => NextQB\n  ): MappingDeleteQuery<DB, TB, NextQB, ReturnCount> {\n    return new MappingDeleteQuery(this.db, factory(this.qb), this.transforms);\n  }\n\n  /**\n   * Runs the query, deleting the indicated rows, returning nothing.\n   * @returns `true` if any rows were deleted, `false` otherwise.\n   */\n  async run(): Promise<boolean> {\n    const results = await this.qb.executeTakeFirst();\n    return results.numDeletedRows !== BigInt(0);\n  }\n}\n"]}
{"filename": "src/queries/compiling-delete-query.ts", "chunked_list": ["import { DeleteQueryBuilder, Kysely, QueryResult } from 'kysely';\nimport { ParameterizedQuery, ParametersObject } from 'kysely-params';\n\nimport { CountTransform } from '../mappers/table-mapper-transforms';\nimport { ParameterizableMappingQuery } from './parameterizable-query';\n\n/**\n * Compiling mapping query for deleting rows from a database table.\n */\nexport class CompilingMappingDeleteQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends DeleteQueryBuilder<DB, TB, any>,\n  ReturnCount,\n  Parameters extends ParametersObject<Parameters>\n> implements ParameterizableMappingQuery\n{\n  #parameterizedQuery: ParameterizedQuery<Parameters, QueryResult<any>>;\n\n  constructor(\n    protected readonly db: Kysely<DB>,\n    protected readonly qb: QB,\n    protected readonly transforms: Readonly<CountTransform<ReturnCount>>\n  ) {\n    this.#parameterizedQuery = new ParameterizedQuery(qb);\n  }\n\n  /**\n   * Runs the query, returning the number of rows deleted, converted to\n   * the required client representation. Accepts values for any parameters\n   * embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns Number of rows deleted, in client-requested representation.\n   */\n  async returnCount(params: Parameters): Promise<ReturnCount> {\n    const result = await this.#parameterizedQuery.execute(this.db, params);\n    return this.transforms.countTransform === undefined\n      ? (result.numAffectedRows! as ReturnCount)\n      : this.transforms.countTransform(result.numAffectedRows!);\n  }\n\n  /**\n   * Runs the query, deleting the indicated rows, returning nothing.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns `true` if any rows were deleted, `false` otherwise.\n   */\n  async run(params: Parameters): Promise<boolean> {\n    const results = await this.#parameterizedQuery.execute(this.db, params);\n    return results.numAffectedRows !== BigInt(0);\n  }\n}\n", " */\nexport class CompilingMappingDeleteQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends DeleteQueryBuilder<DB, TB, any>,\n  ReturnCount,\n  Parameters extends ParametersObject<Parameters>\n> implements ParameterizableMappingQuery\n{\n  #parameterizedQuery: ParameterizedQuery<Parameters, QueryResult<any>>;\n\n  constructor(\n    protected readonly db: Kysely<DB>,\n    protected readonly qb: QB,\n    protected readonly transforms: Readonly<CountTransform<ReturnCount>>\n  ) {\n    this.#parameterizedQuery = new ParameterizedQuery(qb);\n  }\n\n  /**\n   * Runs the query, returning the number of rows deleted, converted to\n   * the required client representation. Accepts values for any parameters\n   * embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns Number of rows deleted, in client-requested representation.\n   */\n  async returnCount(params: Parameters): Promise<ReturnCount> {\n    const result = await this.#parameterizedQuery.execute(this.db, params);\n    return this.transforms.countTransform === undefined\n      ? (result.numAffectedRows! as ReturnCount)\n      : this.transforms.countTransform(result.numAffectedRows!);\n  }\n\n  /**\n   * Runs the query, deleting the indicated rows, returning nothing.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns `true` if any rows were deleted, `false` otherwise.\n   */\n  async run(params: Parameters): Promise<boolean> {\n    const results = await this.#parameterizedQuery.execute(this.db, params);\n    return results.numAffectedRows !== BigInt(0);\n  }\n}\n"]}
{"filename": "src/queries/parameterizable-query.ts", "chunked_list": ["/**\n * Interface tagging a query as parameterizable. When parameterizing a query,\n * the caller provides a function that must return a query having this tag.\n */\nexport interface ParameterizableMappingQuery {}\n"]}
{"filename": "src/queries/subsetting-update-query.ts", "chunked_list": ["import { Kysely, UpdateQueryBuilder, UpdateResult, Updateable } from 'kysely';\nimport { SelectionColumn } from '../lib/type-utils';\nimport { MappingUpdateQuery } from './update-query';\nimport { ParameterizableMappingQuery } from './parameterizable-query';\nimport { ParametersObject } from 'kysely-params';\nimport { CompilingMappingUpdateQuery } from './compiling-update-query';\nimport {\n  CountTransform,\n  UpdateTransforms,\n} from '../mappers/table-mapper-transforms';", "  UpdateTransforms,\n} from '../mappers/table-mapper-transforms';\nimport { restrictValues } from '../lib/restrict-values';\n\n/**\n * Mapping query for updating rows into a database table,\n * updating a specified subset of the updateable columns.\n */\nexport class SubsettingMappingUpdateQuery<\n    DB,\n    TB extends keyof DB & string,\n    QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    UpdatingObject,\n    UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n    ReturnCount,\n    UpdateReturn\n  >\n  extends MappingUpdateQuery<\n    DB,\n    TB,\n    QB,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  >\n  implements ParameterizableMappingQuery\n{\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    protected readonly columnsToUpdate: Readonly<\n      (keyof Updateable<DB[TB]> & string)[]\n    >,\n    transforms: Readonly<\n      CountTransform<ReturnCount> &\n        UpdateTransforms<\n          DB,\n          TB,\n          UpdatingObject,\n          UpdateReturnColumns,\n          UpdateReturn\n        >\n    >,\n    returnColumns: Readonly<UpdateReturnColumns>\n  ) {\n    super(db, qb, transforms, returnColumns);\n  }\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling update query.\n   */\n  compile<\n    Parameters extends ParametersObject<Parameters> = {}\n  >(): CompilingMappingUpdateQuery<\n    DB,\n    TB,\n    QB,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn,\n    Parameters\n  > {\n    return new CompilingMappingUpdateQuery(\n      this.db,\n      this.qb,\n      this.columnsToUpdate,\n      this.transforms,\n      this.returnColumns\n    );\n  }\n\n  protected override getUpdateColumns():\n    | Readonly<(keyof Updateable<DB[TB]> & string)[]>\n    | ['*'] {\n    return this.columnsToUpdate;\n  }\n\n  protected override setColumnValues(\n    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    obj: Updateable<DB[TB]>\n  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n    return qb.set(restrictValues(obj, this.columnsToUpdate));\n  }\n}\n", "export class SubsettingMappingUpdateQuery<\n    DB,\n    TB extends keyof DB & string,\n    QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    UpdatingObject,\n    UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n    ReturnCount,\n    UpdateReturn\n  >\n  extends MappingUpdateQuery<\n    DB,\n    TB,\n    QB,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  >\n  implements ParameterizableMappingQuery\n{\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    protected readonly columnsToUpdate: Readonly<\n      (keyof Updateable<DB[TB]> & string)[]\n    >,\n    transforms: Readonly<\n      CountTransform<ReturnCount> &\n        UpdateTransforms<\n          DB,\n          TB,\n          UpdatingObject,\n          UpdateReturnColumns,\n          UpdateReturn\n        >\n    >,\n    returnColumns: Readonly<UpdateReturnColumns>\n  ) {\n    super(db, qb, transforms, returnColumns);\n  }\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling update query.\n   */\n  compile<\n    Parameters extends ParametersObject<Parameters> = {}\n  >(): CompilingMappingUpdateQuery<\n    DB,\n    TB,\n    QB,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn,\n    Parameters\n  > {\n    return new CompilingMappingUpdateQuery(\n      this.db,\n      this.qb,\n      this.columnsToUpdate,\n      this.transforms,\n      this.returnColumns\n    );\n  }\n\n  protected override getUpdateColumns():\n    | Readonly<(keyof Updateable<DB[TB]> & string)[]>\n    | ['*'] {\n    return this.columnsToUpdate;\n  }\n\n  protected override setColumnValues(\n    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    obj: Updateable<DB[TB]>\n  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n    return qb.set(restrictValues(obj, this.columnsToUpdate));\n  }\n}\n"]}
{"filename": "src/queries/any-update-query.ts", "chunked_list": ["import { Kysely, UpdateQueryBuilder, UpdateResult, Updateable } from 'kysely';\nimport { SelectionColumn } from '../lib/type-utils';\nimport { MappingUpdateQuery } from './update-query';\nimport { SubsettingMappingUpdateQuery } from './subsetting-update-query';\nimport {\n  CountTransform,\n  UpdateTransforms,\n} from '../mappers/table-mapper-transforms';\n\n/**", "\n/**\n * Mapping query for updating rows from a database table, where the\n * columns to be updated have not been restricted.\n */\nexport class AnyColumnsMappingUpdateQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n  UpdatingObject,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  ReturnCount,\n  UpdateReturn\n> extends MappingUpdateQuery<\n  DB,\n  TB,\n  QB,\n  UpdatingObject,\n  UpdateReturnColumns,\n  ReturnCount,\n  UpdateReturn\n> {\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    transforms: Readonly<\n      CountTransform<ReturnCount> &\n        UpdateTransforms<\n          DB,\n          TB,\n          UpdatingObject,\n          UpdateReturnColumns,\n          UpdateReturn\n        >\n    >,\n    returnColumns: Readonly<UpdateReturnColumns>\n  ) {\n    super(db, qb, transforms, returnColumns);\n  }\n\n  /**\n   * Returns a mapping query that only updates a specified subset of columns.\n   * @param columns The columns to update. All are required, but this", "   *  constraint is only enforced at runtime, not by the type system.\n   * @returns A mapping query that only updates the specified columns.\n   */\n  columns(\n    columnsToUpdate: Readonly<(keyof Updateable<DB[TB]> & string)[]>\n  ): SubsettingMappingUpdateQuery<\n    DB,\n    TB,\n    QB,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  > {\n    return new SubsettingMappingUpdateQuery(\n      this.db,\n      this.qb,\n      columnsToUpdate,\n      this.transforms,\n      this.returnColumns\n    );\n  }\n}\n"]}
{"filename": "src/queries/update-query.ts", "chunked_list": ["import {\n  Kysely,\n  Selectable,\n  UpdateQueryBuilder,\n  UpdateResult,\n  Updateable,\n} from 'kysely';\nimport { SelectionColumn } from '../lib/type-utils';\nimport {\n  CountTransform,", "import {\n  CountTransform,\n  UpdateTransforms,\n} from '../mappers/table-mapper-transforms';\n\n/**\n * Mapping query for updating rows from a database table.\n */\nexport class MappingUpdateQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n  UpdatingObject,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  ReturnCount,\n  UpdateReturn\n> {\n  #returningQB: UpdateQueryBuilder<DB, TB, TB, any> | null = null;\n\n  constructor(\n    readonly db: Kysely<DB>,\n    readonly qb: QB,\n    protected readonly transforms: Readonly<\n      CountTransform<ReturnCount> &\n        UpdateTransforms<\n          DB,\n          TB,\n          UpdatingObject,\n          UpdateReturnColumns,\n          UpdateReturn\n        >\n    >,\n    protected readonly returnColumns: Readonly<UpdateReturnColumns>\n  ) {}\n\n  /**\n   * Modifies the underlying Kysely query builder.", "export class MappingUpdateQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n  UpdatingObject,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  ReturnCount,\n  UpdateReturn\n> {\n  #returningQB: UpdateQueryBuilder<DB, TB, TB, any> | null = null;\n\n  constructor(\n    readonly db: Kysely<DB>,\n    readonly qb: QB,\n    protected readonly transforms: Readonly<\n      CountTransform<ReturnCount> &\n        UpdateTransforms<\n          DB,\n          TB,\n          UpdatingObject,\n          UpdateReturnColumns,\n          UpdateReturn\n        >\n    >,\n    protected readonly returnColumns: Readonly<UpdateReturnColumns>\n  ) {}\n\n  /**\n   * Modifies the underlying Kysely query builder.", "   * @param factory A function that takes the current query builder and\n   *  returns a new query builder.\n   */\n  modify<NextQB extends UpdateQueryBuilder<DB, TB, TB, any>>(\n    factory: (qb: QB) => NextQB\n  ): MappingUpdateQuery<\n    DB,\n    TB,\n    NextQB,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  > {\n    return new MappingUpdateQuery(\n      this.db,\n      factory(this.qb),\n      this.transforms,\n      this.returnColumns\n    );\n  }\n\n  /**\n   * Runs the query, returning the number of rows updated, in\n   * the required client representation.\n   * @param obj The object which which to update the rows.\n   * @returns Number of rows updated, in client-requested representation.\n   */\n  async returnCount(obj: UpdatingObject): Promise<ReturnCount> {\n    const result = await this.loadUpdatingObject(\n      this.qb,\n      obj\n    ).executeTakeFirst();\n    return this.transforms.countTransform === undefined\n      ? (result.numUpdatedRows as ReturnCount)\n      : this.transforms.countTransform(result.numUpdatedRows);\n  }\n\n  /**\n   * Updates rows with the values that result from transforming the object via\n   * `updateTransform` (if defined). For each row updated, retrieves the\n   * columns specified in `returnColumns` (if defined), returning them to the\n   * caller as an `UpdateReturn`, after transformation by any provided\n   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n   * @returns If `returnColumns` is not empty, returns an array containing one\n   *  object for each row updated; otherwise returns `undefined`.\n   */\n  returnAll(\n    obj: UpdatingObject\n  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn[]>;\n\n  async returnAll(obj: UpdatingObject): Promise<UpdateReturn[] | void> {", "    if (this.returnColumns.length === 0) {\n      await this.loadUpdatingObject(this.qb, obj as UpdatingObject).execute();\n      return;\n    }\n    const returns = await this.loadUpdatingObject(\n      this.getReturningQB(),\n      obj as UpdatingObject\n    ).execute();\n    return this.transforms.updateReturnTransform === undefined\n      ? (returns as any)\n      : returns.map((row) =>\n          this.transforms.updateReturnTransform!(\n            obj as UpdatingObject,\n            row as any\n          )\n        );\n  }\n\n  /**\n   * Updates rows with the values that result from transforming the object via\n   * `updateTransform` (if defined). For the first row updated, retrieves the\n   * columns specified in `returnColumns` (if defined), returning them to the\n   * caller as an `UpdateReturn`, after transformation by any provided\n   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n   * @returns If `returnColumns` is empty, returns `undefined`. Otherwise,\n   *  returns the first object if at least one row was updated, or `null` if\n   *  no rows were updated.\n   */\n  returnOne(\n    obj: UpdatingObject\n  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn | null>;\n\n  async returnOne(obj: UpdatingObject): Promise<UpdateReturn | null | void> {", "    if (this.returnColumns.length === 0) {\n      await this.loadUpdatingObject(this.qb, obj as UpdatingObject).execute();\n      return;\n    }\n    const returns = await this.loadUpdatingObject(\n      this.getReturningQB(),\n      obj as UpdatingObject\n    ).execute();\n    if (returns.length === 0) {\n      return null;\n    }\n    return this.transforms.updateReturnTransform === undefined\n      ? (returns[0] as any)\n      : this.transforms.updateReturnTransform!(\n          obj as UpdatingObject,\n          returns[0] as any\n        );\n  }\n\n  /**\n   * Runs the query, updating rows, without returning any columns.\n   * @param obj The object which which to update the rows.\n   * @returns `true` if any rows were updated, `false` otherwise.\n   */\n  async run(obj: UpdatingObject): Promise<boolean> {\n    const results = await this.loadUpdatingObject(\n      this.qb,\n      obj\n    ).executeTakeFirst();\n    return results.numUpdatedRows !== BigInt(0);\n  }\n\n  /**\n   * Returns an array of the columns to be updated, with\n   * `['*']` indicating that all columns will be updated.\n   * @returns An array of the columns to be updated.\n   */\n  protected getUpdateColumns():\n    | Readonly<(keyof Updateable<DB[TB]> & string)[]>\n    | ['*'] {\n    return ['*'];\n  }\n\n  /**\n   * Returns a query builder for updating rows in the table and\n   * returning values, caching the query builder for future use.\n   * @returns A query builder for updating rows in the table and\n   *  returning values.\n   */\n  protected getReturningQB(): UpdateQueryBuilder<DB, TB, TB, any> {", "    if (returns.length === 0) {\n      return null;\n    }\n    return this.transforms.updateReturnTransform === undefined\n      ? (returns[0] as any)\n      : this.transforms.updateReturnTransform!(\n          obj as UpdatingObject,\n          returns[0] as any\n        );\n  }\n\n  /**\n   * Runs the query, updating rows, without returning any columns.\n   * @param obj The object which which to update the rows.\n   * @returns `true` if any rows were updated, `false` otherwise.\n   */\n  async run(obj: UpdatingObject): Promise<boolean> {\n    const results = await this.loadUpdatingObject(\n      this.qb,\n      obj\n    ).executeTakeFirst();\n    return results.numUpdatedRows !== BigInt(0);\n  }\n\n  /**\n   * Returns an array of the columns to be updated, with\n   * `['*']` indicating that all columns will be updated.\n   * @returns An array of the columns to be updated.\n   */\n  protected getUpdateColumns():\n    | Readonly<(keyof Updateable<DB[TB]> & string)[]>\n    | ['*'] {\n    return ['*'];\n  }\n\n  /**\n   * Returns a query builder for updating rows in the table and\n   * returning values, caching the query builder for future use.\n   * @returns A query builder for updating rows in the table and\n   *  returning values.\n   */\n  protected getReturningQB(): UpdateQueryBuilder<DB, TB, TB, any> {", "    if (this.#returningQB === null) {\n      this.#returningQB =\n        this.returnColumns[0 as number] == '*'\n          ? this.qb.returningAll()\n          : this.qb.returning(\n              this.returnColumns as Readonly<\n                (keyof Selectable<DB[TB]> & string)[]\n              >\n            );\n    }\n    return this.#returningQB;\n  }\n\n  /**\n   * Loads the object with which to update rows.\n   * @param qb The query builder to load the objects into.\n   * @param obj The object with which to update rows.\n   * @returns The query builder with the object loaded.\n   */\n  protected loadUpdatingObject(\n    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    obj: UpdatingObject\n  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n    const updateColumns = this.getUpdateColumns();\n    const transformedObj =\n      this.transforms.updateTransform === undefined\n        ? (obj as Updateable<DB[TB]>)\n        : this.transforms.updateTransform(obj, updateColumns);\n    return this.setColumnValues(qb, transformedObj);\n  }\n\n  /**\n   * Sets the values of the updated columns.\n   * @param qb The query builder to set the values into.\n   * @param obj The object of column-value pairs to be updated.\n   */\n  protected setColumnValues(\n    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    obj: Updateable<DB[TB]>\n  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n    return qb.set(obj);\n  }\n}\n"]}
{"filename": "src/queries/insert-query.ts", "chunked_list": ["import {\n  Kysely,\n  InsertQueryBuilder,\n  InsertResult,\n  Selectable,\n  Insertable,\n} from 'kysely';\n\nimport { SelectionColumn } from '../lib/type-utils';\nimport { InsertTransforms } from '../mappers/table-mapper-transforms';", "import { SelectionColumn } from '../lib/type-utils';\nimport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\n/**\n * Mapping query for inserting rows into a database table.\n */\nexport class MappingInsertQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends InsertQueryBuilder<DB, TB, InsertResult>,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> {\n  #returningQB: InsertQueryBuilder<DB, TB, any> | null = null;\n\n  constructor(\n    protected readonly db: Kysely<DB>,\n    protected readonly qb: QB,\n    protected readonly transforms: Readonly<\n      InsertTransforms<\n        DB,\n        TB,\n        InsertedObject,\n        InsertReturnColumns,\n        InsertReturn\n      >\n    >,\n    protected readonly returnColumns: Readonly<InsertReturnColumns>\n  ) {}\n\n  /**\n   * Modifies the underlying Kysely query builder.", "   * @param factory A function that takes the current query builder and\n   *  returns a new query builder.\n   */\n  modify<NextQB extends InsertQueryBuilder<DB, TB, any>>(\n    factory: (qb: QB) => NextQB\n  ): MappingInsertQuery<\n    DB,\n    TB,\n    NextQB,\n    InsertedObject,\n    InsertReturnColumns,\n    InsertReturn\n  > {\n    return new MappingInsertQuery(\n      this.db,\n      factory(this.qb),\n      this.transforms,\n      this.returnColumns\n    );\n  }\n\n  /**\n   * Inserts the provided objects into the table as rows, first transforming\n   * them into rows via `insertTransform` (if defined). For each row inserted,\n   * retrieves the columns specified in `returnColumns`, returning them to\n   * the caller as `InsertReturn`, after transformation by\n   * `insertReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n   * @returns If `returnColumns` is not empty, returns an array containing one\n   *  object for each inserted object; otherwise returns `undefined`.\n   */\n  returnAll(\n    objs: InsertedObject[]\n  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn[]>;\n\n  async returnAll(objs: InsertedObject[]): Promise<InsertReturn[] | void> {", "    if (this.returnColumns.length === 0) {\n      await this.loadInsertedObjects(this.qb, objs).execute();\n      return;\n    }\n    const returns = await this.loadInsertedObjects(\n      this.getReturningQB(),\n      objs\n    ).execute();\n    return this.transforms.insertReturnTransform === undefined\n      ? (returns as any)\n      : returns.map((row, i) =>\n          this.transforms.insertReturnTransform!(objs[i], row as any)\n        );\n  }\n\n  /**\n   * Inserts the provided object into the table as a row, first transforming\n   * it into a row via `insertTransform` (if defined). Also retrieves the\n   * columns specified in `returnColumns`, returning them to the caller as\n   * `InsertReturn`, after transformation by `insertReturnTransform`.\n   * If `returnColumns` is empty, returns `undefined`.\n   * @returns If `returnColumns` is not empty, returns an object;\n   *  otherwise returns `undefined`.\n   */\n  returnOne(\n    obj: InsertedObject\n  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn>;\n\n  async returnOne(obj: InsertedObject): Promise<InsertReturn | void> {", "    if (this.returnColumns.length === 0) {\n      await this.loadInsertedObjects(this.qb, obj).execute();\n      return;\n    }\n    const result = await this.loadInsertedObjects(\n      this.getReturningQB(),\n      obj\n    ).executeTakeFirst();\n    return this.transforms.insertReturnTransform === undefined\n      ? (result as any)\n      : this.transforms.insertReturnTransform(obj, result as any);\n  }\n\n  /**\n   * Runs the query, inserting rows into the table without returning any columns.\n   * @param objOrObjs The object or objects to be inserted.\n   * @returns Returns `true`; throws an exception on error.\n   */\n  async run(objOrObjs: InsertedObject | InsertedObject[]): Promise<boolean> {\n    await this.loadInsertedObjects(this.qb, objOrObjs).execute();\n    return true;\n  }\n\n  /**\n   * Returns an array of the columns to be inserted, with\n   * `['*']` indicating that all columns will be inserted.\n   * @returns An array of the columns to be inserted.\n   */\n  protected getInsertColumns():\n    | Readonly<(keyof Insertable<DB[TB]> & string)[]>\n    | ['*'] {\n    return ['*'];\n  }\n\n  /**\n   * Returns a query builder for inserting rows into the table and\n   * returning values, caching the query builder for future use.\n   * @returns A query builder for inserting rows into the table and\n   *  returning values.\n   */\n  protected getReturningQB(): InsertQueryBuilder<DB, TB, any> {", "    if (this.#returningQB === null) {\n      this.#returningQB =\n        this.returnColumns[0 as number] == '*'\n          ? this.qb.returningAll()\n          : this.qb.returning(\n              this.returnColumns as Readonly<\n                (keyof Selectable<DB[TB]> & string)[]\n              >\n            );\n    }\n    return this.#returningQB;\n  }\n\n  /**\n   * Loads the objects to be inserted into the query builder.\n   * @param qb The query builder to load the objects into.\n   * @param objOrObjs The object or objects to be inserted.\n   * @returns The query builder with the objects loaded.\n   */\n  protected loadInsertedObjects(\n    qb: InsertQueryBuilder<DB, TB, InsertResult>,\n    objOrObjs: InsertedObject | InsertedObject[]\n  ): InsertQueryBuilder<DB, TB, InsertResult> {\n    const insertColumns = this.getInsertColumns();", "    if (Array.isArray(objOrObjs)) {\n      const transformedObjs =\n        this.transforms.insertTransform === undefined\n          ? (objOrObjs as Insertable<DB[TB]>[])\n          : objOrObjs.map((obj) =>\n              this.transforms.insertTransform!(obj, insertColumns)\n            );\n      // TS requires separate calls to values() for different arg types.\n      return this.setColumnValues(qb, transformedObjs);\n    }\n    const transformedObj =\n      this.transforms.insertTransform === undefined\n        ? (objOrObjs as Insertable<DB[TB]>)\n        : this.transforms.insertTransform(objOrObjs, insertColumns);\n    // TS requires separate calls to values() for different arg types.\n    return this.setColumnValues(qb, transformedObj);\n  }\n\n  /**\n   * Sets the values of the inserted columns.\n   * @param qb The query builder to set the values into.\n   * @param objOrObjs The object or objects of column-value pairs\n   *  to be inserted.\n   */\n  protected setColumnValues(\n    qb: InsertQueryBuilder<DB, TB, InsertResult>,\n    objOrObjs: Insertable<DB[TB]> | Insertable<DB[TB]>[]\n  ): InsertQueryBuilder<DB, TB, InsertResult> {\n    return qb.values(objOrObjs);\n  }\n}\n"]}
{"filename": "src/queries/subsetting-insert-query.ts", "chunked_list": ["import { Kysely, InsertQueryBuilder, InsertResult, Insertable } from 'kysely';\n\nimport { SelectionColumn } from '../lib/type-utils';\nimport { MappingInsertQuery } from './insert-query';\nimport { CompilingMappingInsertQuery } from './compiling-insert-query';\nimport { InsertTransforms } from '../mappers/table-mapper-transforms';\nimport { restrictValues } from '../lib/restrict-values';\n\n/**\n * Mapping query for inserting rows into a database table,", "/**\n * Mapping query for inserting rows into a database table,\n * inserting a specified subset of the insertable columns.\n */\nexport class SubsettingMappingInsertQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends InsertQueryBuilder<DB, TB, InsertResult>,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> extends MappingInsertQuery<\n  DB,\n  TB,\n  QB,\n  InsertedObject,\n  InsertReturnColumns,\n  InsertReturn\n> {\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    protected readonly columnsToInsert: Readonly<\n      (keyof Insertable<DB[TB]> & string)[]\n    >,\n    transforms: Readonly<\n      InsertTransforms<\n        DB,\n        TB,\n        InsertedObject,\n        InsertReturnColumns,\n        InsertReturn\n      >\n    >,\n    returnColumns: Readonly<InsertReturnColumns>\n  ) {\n    super(db, qb, transforms, returnColumns);\n  }\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling insert query.\n   */\n  compile(): CompilingMappingInsertQuery<\n    DB,\n    TB,\n    QB,\n    InsertedObject,\n    InsertReturnColumns,\n    InsertReturn\n  > {\n    return new CompilingMappingInsertQuery(\n      this.db,\n      this.qb,\n      this.columnsToInsert,\n      this.transforms,\n      this.returnColumns\n    );\n  }\n\n  protected override getInsertColumns():\n    | Readonly<(keyof Insertable<DB[TB]> & string)[]>\n    | ['*'] {\n    return this.columnsToInsert;\n  }\n\n  protected override setColumnValues(\n    qb: InsertQueryBuilder<DB, TB, InsertResult>,\n    objOrObjs: Insertable<DB[TB]> | Insertable<DB[TB]>[]\n  ): InsertQueryBuilder<DB, TB, InsertResult> {", "    if (Array.isArray(objOrObjs)) {\n      return qb.values(\n        objOrObjs.map((obj) => restrictValues(obj, this.columnsToInsert))\n      );\n    }\n    return qb.values(restrictValues(objOrObjs, this.columnsToInsert));\n  }\n}\n"]}
{"filename": "src/queries/compiling-insert-query.ts", "chunked_list": ["import { Kysely, InsertQueryBuilder, Insertable } from 'kysely';\n\nimport { SelectionColumn } from '../lib/type-utils';\nimport { CompilingValuesQuery } from './compiling-values-query';\nimport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\n/**\n * Compiling mapping query for inserting rows into a database table.\n */\nexport class CompilingMappingInsertQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends InsertQueryBuilder<DB, TB, any>,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> extends CompilingValuesQuery<\n  DB,\n  TB,\n  QB,\n  InsertReturnColumns,\n  {},\n  Insertable<DB[TB]>\n> {\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    protected readonly columnsToInsert: Readonly<\n      (keyof Insertable<DB[TB]> & string)[]\n    >,\n    protected readonly transforms: Readonly<\n      InsertTransforms<\n        DB,\n        TB,\n        InsertedObject,\n        InsertReturnColumns,\n        InsertReturn\n      >\n    >,\n    returnColumns: Readonly<InsertReturnColumns>\n  ) {\n    super(db, returnColumns);\n    const parameterizedValues = this.getParameterizedObject(columnsToInsert);\n    this.qb = qb.values(parameterizedValues) as QB;\n  }\n\n  /**\n   * Inserts the provided object into the table as a row, first transforming\n   * it into a row via `insertTransform` (if defined). Also retrieves the\n   * columns specified in `returnColumns`, returning them to the caller as\n   * `InsertReturn`, after transformation by `insertReturnTransform`.\n   * If `returnColumns` is empty, returns `undefined`.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @returns If `returnColumns` is not empty, returns an object;\n   *  otherwise returns `undefined`.\n   */\n  returnOne(\n    obj: InsertedObject\n  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn>;\n\n  async returnOne(obj: InsertedObject): Promise<InsertReturn | void> {", " */\nexport class CompilingMappingInsertQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends InsertQueryBuilder<DB, TB, any>,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> extends CompilingValuesQuery<\n  DB,\n  TB,\n  QB,\n  InsertReturnColumns,\n  {},\n  Insertable<DB[TB]>\n> {\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    protected readonly columnsToInsert: Readonly<\n      (keyof Insertable<DB[TB]> & string)[]\n    >,\n    protected readonly transforms: Readonly<\n      InsertTransforms<\n        DB,\n        TB,\n        InsertedObject,\n        InsertReturnColumns,\n        InsertReturn\n      >\n    >,\n    returnColumns: Readonly<InsertReturnColumns>\n  ) {\n    super(db, returnColumns);\n    const parameterizedValues = this.getParameterizedObject(columnsToInsert);\n    this.qb = qb.values(parameterizedValues) as QB;\n  }\n\n  /**\n   * Inserts the provided object into the table as a row, first transforming\n   * it into a row via `insertTransform` (if defined). Also retrieves the\n   * columns specified in `returnColumns`, returning them to the caller as\n   * `InsertReturn`, after transformation by `insertReturnTransform`.\n   * If `returnColumns` is empty, returns `undefined`.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @returns If `returnColumns` is not empty, returns an object;\n   *  otherwise returns `undefined`.\n   */\n  returnOne(\n    obj: InsertedObject\n  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn>;\n\n  async returnOne(obj: InsertedObject): Promise<InsertReturn | void> {", "    if (this.returnColumns.length === 0) {\n      await this.run(obj);\n      return;\n    }\n    const transformedObj = this.applyInsertTransform(obj);\n    const compiledQuery = this.instantiateWithReturns({}, transformedObj);\n    const result = await this.db.executeQuery(compiledQuery);\n    if (result.rows.length === 0) {\n      throw Error(\n        'No row returned from compiled insert expecting returned columns'\n      );\n    }\n    return this.transforms.insertReturnTransform === undefined\n      ? (result.rows[0] as any)\n      : this.transforms.insertReturnTransform(obj, result.rows[0] as any);\n  }\n\n  /**\n   * Runs the query, inserting rows into the table without returning any\n   * columns.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param objOrObjs The object or objects to be inserted.\n   * @returns Returns `true`; throws an exception on error.\n   */\n  async run(obj: InsertedObject): Promise<boolean> {\n    const transformedObj = this.applyInsertTransform(obj);\n    const compiledQuery = this.instantiateNoReturns({}, transformedObj);\n    await this.db.executeQuery(compiledQuery);\n    return true;\n  }\n\n  protected applyInsertTransform(obj: InsertedObject): Insertable<DB[TB]> {\n    return this.transforms.insertTransform === undefined\n      ? (obj as Insertable<DB[TB]>)\n      : this.transforms.insertTransform(obj, this.columnsToInsert);\n  }\n}\n"]}
{"filename": "src/queries/any-insert-query.ts", "chunked_list": ["import { Kysely, InsertQueryBuilder, InsertResult, Insertable } from 'kysely';\n\nimport { SelectionColumn } from '../lib/type-utils';\nimport { SubsettingMappingInsertQuery } from './subsetting-insert-query';\nimport { MappingInsertQuery } from './insert-query';\nimport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\n/**\n * Mapping query for inserting rows into a database table, where the\n * columns to be inserted have not been restricted.", " * Mapping query for inserting rows into a database table, where the\n * columns to be inserted have not been restricted.\n */\nexport class AnyColumnsMappingInsertQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends InsertQueryBuilder<DB, TB, InsertResult>,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> extends MappingInsertQuery<\n  DB,\n  TB,\n  QB,\n  InsertedObject,\n  InsertReturnColumns,\n  InsertReturn\n> {\n  constructor(\n    db: Kysely<DB>,\n    qb: QB,\n    transforms: Readonly<\n      InsertTransforms<\n        DB,\n        TB,\n        InsertedObject,\n        InsertReturnColumns,\n        InsertReturn\n      >\n    >,\n    returnColumns: Readonly<InsertReturnColumns>\n  ) {\n    super(db, qb, transforms, returnColumns);\n  }\n\n  /**\n   * Returns a mapping query that only inserts a specified subset of columns.\n   * @param columns The columns to insert. All are required, but this", "   *  constraint is only enforced at runtime, not by the type system.\n   * @returns A mapping query that only inserts the specified columns.\n   */\n  columns(\n    columnsToInsert: Readonly<(keyof Insertable<DB[TB]> & string)[]>\n  ): SubsettingMappingInsertQuery<\n    DB,\n    TB,\n    QB,\n    InsertedObject,\n    InsertReturnColumns,\n    InsertReturn\n  > {\n    return new SubsettingMappingInsertQuery(\n      this.db,\n      this.qb,\n      columnsToInsert,\n      this.transforms,\n      this.returnColumns\n    );\n  }\n}\n"]}
{"filename": "src/queries/compiling-select-query.ts", "chunked_list": ["import { Kysely, SelectQueryBuilder } from 'kysely';\nimport { SelectionColumn } from '../lib/type-utils';\nimport { ParameterizableMappingQuery } from './parameterizable-query';\nimport { ParameterizedQuery, ParametersObject } from 'kysely-params';\nimport { SelectTransform } from '../mappers/table-mapper-transforms';\n\n/**\n * Compiling mapping query for selecting rows from a database table.\n */\nexport class CompilingMappingSelectQuery<\n  DB,\n  TB extends keyof DB & string,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject,\n  QB extends SelectQueryBuilder<DB, TB, any>,\n  Parameters extends ParametersObject<Parameters>\n> implements ParameterizableMappingQuery\n{\n  #parameterizedQuery: ParameterizedQuery<Parameters, SelectedObject>;\n\n  constructor(\n    readonly db: Kysely<DB>,\n    qb: QB,\n    protected readonly transforms: Readonly<\n      SelectTransform<DB, TB, SelectedColumns, SelectedObject>\n    >\n  ) {\n    this.#parameterizedQuery = new ParameterizedQuery(qb);\n  }\n\n  /**\n   * Retrieves zero or more rows from the table, using `selectTransform`\n   * (if provided) to map the rows to objects of type `SelectedObject`.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns An array of objects for the selected rows, possibly empty.\n   */\n  async returnAll(params: Parameters): Promise<SelectedObject[]> {\n    const results = await this.#parameterizedQuery.execute(this.db, params);\n    return this.transforms.selectTransform === undefined\n      ? (results.rows as SelectedObject[])\n      : (results.rows as any[]).map(this.transforms.selectTransform);\n  }\n\n  /**\n   * Retrieves a single row from the table, using `selectTransform` (if\n   * provided) to map the row to an object of type `SelectedObject`.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns An object for the selected rows, or null if not found.\n   */\n  async returnOne(params: Parameters): Promise<SelectedObject | null> {\n    const result = await this.#parameterizedQuery.executeTakeFirst(\n      this.db,\n      params\n    );", " */\nexport class CompilingMappingSelectQuery<\n  DB,\n  TB extends keyof DB & string,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject,\n  QB extends SelectQueryBuilder<DB, TB, any>,\n  Parameters extends ParametersObject<Parameters>\n> implements ParameterizableMappingQuery\n{\n  #parameterizedQuery: ParameterizedQuery<Parameters, SelectedObject>;\n\n  constructor(\n    readonly db: Kysely<DB>,\n    qb: QB,\n    protected readonly transforms: Readonly<\n      SelectTransform<DB, TB, SelectedColumns, SelectedObject>\n    >\n  ) {\n    this.#parameterizedQuery = new ParameterizedQuery(qb);\n  }\n\n  /**\n   * Retrieves zero or more rows from the table, using `selectTransform`\n   * (if provided) to map the rows to objects of type `SelectedObject`.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns An array of objects for the selected rows, possibly empty.\n   */\n  async returnAll(params: Parameters): Promise<SelectedObject[]> {\n    const results = await this.#parameterizedQuery.execute(this.db, params);\n    return this.transforms.selectTransform === undefined\n      ? (results.rows as SelectedObject[])\n      : (results.rows as any[]).map(this.transforms.selectTransform);\n  }\n\n  /**\n   * Retrieves a single row from the table, using `selectTransform` (if\n   * provided) to map the row to an object of type `SelectedObject`.\n   * Accepts values for any parameters embedded in the query.\n   *\n   * On the first execution, compiles and discards the underlying Kysely\n   * query builder. Subsequent executions reuse the compiled query.\n   * @param params Record characterizing the parameter names and types.\n   *  Pass in `{}` if the query has no parameters.\n   * @returns An object for the selected rows, or null if not found.\n   */\n  async returnOne(params: Parameters): Promise<SelectedObject | null> {\n    const result = await this.#parameterizedQuery.executeTakeFirst(\n      this.db,\n      params\n    );", "    if (!result) return null;\n    return result === undefined\n      ? null\n      : this.transforms.selectTransform === undefined\n      ? (result as SelectedObject)\n      : this.transforms.selectTransform(result as any);\n  }\n}\n"]}
{"filename": "src/queries/select-query.ts", "chunked_list": ["import { Kysely, SelectQueryBuilder } from 'kysely';\nimport { SelectionColumn } from '../lib/type-utils';\nimport { ParameterizableMappingQuery } from './parameterizable-query';\nimport { ParametersObject } from 'kysely-params';\nimport { CompilingMappingSelectQuery } from './compiling-select-query';\nimport { SelectTransform } from '../mappers/table-mapper-transforms';\n\n/**\n * Mapping query for selecting rows from a database table.\n */\nexport class MappingSelectQuery<\n  DB,\n  TB extends keyof DB & string,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject,\n  QB extends SelectQueryBuilder<DB, TB, any>\n> implements ParameterizableMappingQuery\n{\n  constructor(\n    readonly db: Kysely<DB>,\n    readonly qb: QB,\n    protected readonly transforms: Readonly<\n      SelectTransform<DB, TB, SelectedColumns, SelectedObject>\n    >\n  ) {}\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling select query.\n   */\n  compile<\n    Parameters extends ParametersObject<Parameters> = {}\n  >(): CompilingMappingSelectQuery<\n    DB,\n    TB,\n    SelectedColumns,\n    SelectedObject,\n    SelectQueryBuilder<DB, TB, Parameters>,\n    Parameters\n  > {\n    return new CompilingMappingSelectQuery(this.db, this.qb, this.transforms);\n  }\n\n  /**\n   * Modifies the underlying Kysely query builder. All columns given in\n   * `SelectedColumns` are already selected, but you can select additional\n   * columns or add column aliases.", " * Mapping query for selecting rows from a database table.\n */\nexport class MappingSelectQuery<\n  DB,\n  TB extends keyof DB & string,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject,\n  QB extends SelectQueryBuilder<DB, TB, any>\n> implements ParameterizableMappingQuery\n{\n  constructor(\n    readonly db: Kysely<DB>,\n    readonly qb: QB,\n    protected readonly transforms: Readonly<\n      SelectTransform<DB, TB, SelectedColumns, SelectedObject>\n    >\n  ) {}\n\n  /**\n   * Returns a compiling query that can be executed multiple times with\n   * different parameters (if any parameters were provided), but which only\n   * compiles the underlying Kysely query builder on the first execution.\n   * Frees the query builder on the first execution to reduce memory usage.\n   * @typeParam Parameters Record characterizing the parameter names and\n   *  types that were previously embedded in the query, if any.\n   * @returns A compiling select query.\n   */\n  compile<\n    Parameters extends ParametersObject<Parameters> = {}\n  >(): CompilingMappingSelectQuery<\n    DB,\n    TB,\n    SelectedColumns,\n    SelectedObject,\n    SelectQueryBuilder<DB, TB, Parameters>,\n    Parameters\n  > {\n    return new CompilingMappingSelectQuery(this.db, this.qb, this.transforms);\n  }\n\n  /**\n   * Modifies the underlying Kysely query builder. All columns given in\n   * `SelectedColumns` are already selected, but you can select additional\n   * columns or add column aliases.", "   * @param factory A function that takes the current query builder and\n   *  returns a new query builder.\n   */\n  modify<NextQB extends SelectQueryBuilder<DB, TB, any>>(\n    factory: (qb: QB) => NextQB\n  ): MappingSelectQuery<DB, TB, SelectedColumns, SelectedObject, NextQB> {\n    return new MappingSelectQuery(this.db, factory(this.qb), this.transforms);\n  }\n\n  /**\n   * Retrieves zero or more rows from the table, using `selectTransform`\n   * (if provided) to map the rows to objects of type `SelectedObject`.\n   * @returns An array of objects for the selected rows, possibly empty.\n   */\n  async returnAll(): Promise<SelectedObject[]> {\n    const results = await this.qb.execute();\n    return this.transforms.selectTransform === undefined\n      ? results\n      : (results as any[]).map(this.transforms.selectTransform);\n  }\n\n  /**\n   * Retrieves a single row from the table, using `selectTransform`\n   * (if provided) to map the row to an object of type `SelectedObject`.\n   * @returns An object for the selected rows, or null if not found.\n   */\n  async returnOne(): Promise<SelectedObject | null> {\n    const result = await this.qb.executeTakeFirst();", "    if (!result) return null;\n    return this.transforms.selectTransform === undefined\n      ? result\n      : this.transforms.selectTransform(result);\n  }\n}\n"]}
{"filename": "src/queries/compiling-values-query.ts", "chunked_list": ["import {\n  Kysely,\n  Selectable,\n  CompiledQuery,\n  Compilable,\n  ReturningInterface,\n} from 'kysely';\n\nimport { SelectionColumn } from '../lib/type-utils';\nimport { ParametersObject, ParameterizedValue } from 'kysely-params';", "import { SelectionColumn } from '../lib/type-utils';\nimport { ParametersObject, ParameterizedValue } from 'kysely-params';\n\n/**\n * Parameterized value placeholder for inserted or added column values.\n */\nclass ColumnParameter<Values> {\n  constructor(public readonly columnName: keyof Values & string) {}\n}\n\n/**", " * Base class for compilable inserting and updating mapping queriees.\n */\nexport class CompilingValuesQuery<\n  DB,\n  TB extends keyof DB & string,\n  QB extends ReturningInterface<DB, TB, any> & Compilable<any>,\n  ReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  Parameters extends ParametersObject<Parameters>,\n  Values extends Record<string, any>\n> {\n  protected qb: QB | null = null;\n  #compiledQueryNoReturns?: CompiledQuery<any>;\n  #compiledQueryWithReturns?: CompiledQuery<any>;\n\n  constructor(\n    protected readonly db: Kysely<DB>,\n    protected readonly returnColumns: Readonly<ReturnColumns>\n  ) {}\n\n  protected getParameterizedObject(\n    columnsToAllow: Readonly<(keyof Values & string)[]>\n  ) {\n    return Object.fromEntries(\n      columnsToAllow.map((col) => [col, new ColumnParameter<Values>(col)])\n    ) as Values;\n  }\n\n  protected instantiateNoReturns(\n    params: Parameters,\n    obj: Values\n  ): CompiledQuery<any> {\n    this.compileQueries();\n    return this.instantiate(this.#compiledQueryNoReturns!, params, obj);\n  }\n\n  protected instantiateWithReturns(\n    params: Parameters,\n    obj: Values\n  ): CompiledQuery<any> {\n    this.compileQueries();\n    return this.instantiate(this.#compiledQueryWithReturns!, params, obj);\n  }\n\n  private compileQueries(): void {", "    if (this.qb !== null) {\n      this.#compiledQueryNoReturns = this.qb!.compile();\n      this.#compiledQueryWithReturns = this.getReturningQB().compile();\n      this.qb = null;\n    }\n  }\n\n  private getReturningQB(): QB {\n    return this.returnColumns[0 as number] == '*'\n      ? (this.qb!.returningAll() as QB)\n      : (this.qb!.returning(\n          this.returnColumns as Readonly<(keyof Selectable<DB[TB]> & string)[]>\n        ) as QB);\n  }\n\n  private instantiate(\n    compiledQuery: CompiledQuery<any>,\n    params: Parameters,\n    obj: Values\n  ): CompiledQuery<any> {\n    return {\n      query: compiledQuery.query,\n      sql: compiledQuery.sql,\n      parameters: compiledQuery.parameters.map((value) =>\n        value instanceof ColumnParameter\n          ? this.verifiedValue(obj, value.columnName)\n          : value instanceof ParameterizedValue\n          ? params[value.parameterName as keyof Parameters]\n          : value\n      ),\n    };\n  }\n\n  private verifiedValue(obj: any, column: string): any {\n    const value = obj[column];\n    // ensure the output of the applied transform works for the present query", "    if (value === undefined) {\n      throw new Error(\n        `Specified column '${column}' missing from values object (compiled)`\n      );\n    }\n    return value;\n  }\n}\n"]}
{"filename": "src/tests/update-general.test.ts", "chunked_list": ["import { Kysely, sql } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport {\n  createUserMapperReturningDefault,\n  createUserMapperReturningID,\n  createUserMapperReturningIDAndHandleAsH,\n  createUserMapperReturningAll,\n  createUserMapperReturningNothing,", "  createUserMapperReturningAll,\n  createUserMapperReturningNothing,\n} from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\n\nlet db: Kysely<Database>;\nlet userMapperReturningDefault: ReturnType<\n  typeof createUserMapperReturningDefault\n>;", "  typeof createUserMapperReturningDefault\n>;\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\nlet userMapperReturningIDAndHandleAsH: ReturnType<\n  typeof createUserMapperReturningIDAndHandleAsH\n>;\nlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;", ">;\nlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningDefault = createUserMapperReturningDefault(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n  userMapperReturningID = createUserMapperReturningID(db);\n  userMapperReturningIDAndHandleAsH =\n    createUserMapperReturningIDAndHandleAsH(db);", "  userMapperReturningIDAndHandleAsH =\n    createUserMapperReturningIDAndHandleAsH(db);\n  userMapperReturningAll = createUserMapperReturningAll(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('general update', () => {\n  it('updates nothing returning zero update count', async () => {\n    const updateValues = { email: 'new.email@xyz.pdq' };", "  it('updates nothing returning zero update count', async () => {\n    const updateValues = { email: 'new.email@xyz.pdq' };\n\n    const success = await userMapperReturningAll\n      .update({ id: 1 })\n      .run(updateValues);\n    expect(success).toBe(false);\n\n    const updateCount = await userMapperReturningAll\n      .update({ id: 1 })", "    const updateCount = await userMapperReturningAll\n      .update({ id: 1 })\n      .returnCount(updateValues);\n    expect(updateCount).toEqual(0);\n\n    const updates = await userMapperReturningID\n      .update({ id: 1 })\n      .returnAll(updateValues);\n    expect(updates.length).toEqual(0);\n", "    expect(updates.length).toEqual(0);\n\n    const update = await userMapperReturningID\n      .update({ id: 1 })\n      .returnOne(updateValues);\n    expect(update).toBeNull();\n  });\n\n  it('updates something returning non-zero update count', async () => {\n    const updateValues = { email: 'new.email@xyz.pdq' };", "  it('updates something returning non-zero update count', async () => {\n    const updateValues = { email: 'new.email@xyz.pdq' };\n    const insertReturn0 = await userMapperReturningID\n      .insert()\n      .returnOne(USERS[0]);\n    await userMapperReturningID.insert().run(USERS[1]);\n    await userMapperReturningID.insert().run(USERS[2]);\n\n    const updateCount1 = await userMapperReturningAll\n      .update({ id: insertReturn0.id })", "    const updateCount1 = await userMapperReturningAll\n      .update({ id: insertReturn0.id })\n      .returnCount(updateValues);\n    expect(updateCount1).toEqual(1);\n\n    const readUser1 = await userMapperReturningID\n      .select('id', '=', insertReturn0.id)\n      .returnOne();\n    expect(readUser1?.email).toEqual(updateValues.email);\n", "    expect(readUser1?.email).toEqual(updateValues.email);\n\n    const updateCount2 = await userMapperReturningAll\n      .update({ name: 'Sue' })\n      .returnCount(updateValues);\n    expect(updateCount2).toEqual(2);\n\n    const readUsers = await userMapperReturningID\n      .select('name', '=', 'Sue')\n      .returnAll();", "      .select('name', '=', 'Sue')\n      .returnAll();\n    expect(readUsers.length).toEqual(2);\n    expect(readUsers[0].email).toEqual(updateValues.email);\n    expect(readUsers[1].email).toEqual(updateValues.email);\n\n    const updates = await userMapperReturningID.update().returnAll({\n      name: 'Every User 1',\n    });\n    expect(updates).toEqual([{ id: 1 }, { id: 2 }, { id: 3 }]);", "    });\n    expect(updates).toEqual([{ id: 1 }, { id: 2 }, { id: 3 }]);\n\n    const update = await userMapperReturningID\n      .update({ id: readUsers[0].id })\n      .returnOne({\n        name: 'Every User 2',\n      });\n    expect(update).toEqual({ id: 1 });\n    const readUser2 = await userMapperReturningID", "    expect(update).toEqual({ id: 1 });\n    const readUser2 = await userMapperReturningID\n      .select('id', '=', 1)\n      .returnOne();\n    expect(readUser2?.name).toEqual('Every User 2');\n\n    const updateCount = await userMapperReturningID.update().returnCount({\n      name: 'Every User 3',\n    });\n    expect(updateCount).toEqual(3);", "    });\n    expect(updateCount).toEqual(3);\n\n    const success = await userMapperReturningID.update().run({\n      name: 'Every User 4',\n    });\n    expect(success).toBe(true);\n  });\n\n  it('updates returning configured return columns', async () => {", "\n  it('updates returning configured return columns', async () => {\n    await userMapperReturningID.insert().run(USERS[0]);\n    const insertReturn = await userMapperReturningID\n      .insert()\n      .returnOne(USERS[1]);\n    await userMapperReturningID.insert().run(USERS[2]);\n\n    // Verify that update performs the correct change on the correct row.\n    const updateValues1 = { email: 'new.email@xyz.pdq' };", "    // Verify that update performs the correct change on the correct row.\n    const updateValues1 = { email: 'new.email@xyz.pdq' };\n    const updateReturns1 = await userMapperReturningID\n      .update({ id: insertReturn.id })\n      .returnAll(updateValues1);\n    expect(updateReturns1).toEqual([{ id: insertReturn.id }]);\n    let readUser = await userMapperReturningID\n      .select('id', '=', insertReturn.id)\n      .returnOne();\n    expect(readUser?.email).toEqual(updateValues1.email);", "      .returnOne();\n    expect(readUser?.email).toEqual(updateValues1.email);\n\n    // Verify a different change on the same row, returning multiple columns.\n    const updateValues2 = { name: 'Sue' };\n    const updateReturns2 = await userMapperReturningIDAndHandleAsH\n      .update({ email: updateValues1.email })\n      .returnAll(updateValues2);\n    updateReturns2[0].id; // ensure key is accessible\n    updateReturns2[0].h; // ensure key is accessible", "    updateReturns2[0].id; // ensure key is accessible\n    updateReturns2[0].h; // ensure key is accessible\n    expect(updateReturns2).toEqual([\n      {\n        id: insertReturn.id,\n        h: USERS[1].handle,\n      },\n    ]);\n    readUser = await userMapperReturningID\n      .select('id', '=', insertReturn.id)", "    readUser = await userMapperReturningID\n      .select('id', '=', insertReturn.id)\n      .returnOne();\n    expect(readUser?.name).toEqual(updateValues2.name);\n\n    // Verify that update changes all required rows.\n    const updateValues3 = { name: 'Replacement Sue' };\n    const updateReturns3 = await userMapperReturningIDAndHandleAsH\n      .update({ name: 'Sue' })\n      .returnAll(updateValues3);", "      .update({ name: 'Sue' })\n      .returnAll(updateValues3);\n    expect(updateReturns3.length).toEqual(3);\n    expect(updateReturns3[0].h).toEqual(USERS[0].handle);\n    expect(updateReturns3[1].h).toEqual(USERS[1].handle);\n    expect(updateReturns3[2].h).toEqual(USERS[2].handle);\n    const readUsers = await userMapperReturningID\n      .select('name', '=', updateValues3.name)\n      .returnAll();\n    expect(readUsers.length).toEqual(3);", "      .returnAll();\n    expect(readUsers.length).toEqual(3);\n\n    ignore('check return types', () => {\n      // @ts-expect-error - check return types\n      updateReturns2[0].title;\n      // @ts-expect-error - check return types\n      updateReturns2[0].userId;\n    });\n  });", "    });\n  });\n\n  it('update returns void when defaulting to no return columns', async () => {\n    await userMapperReturningID.insert().run(USERS);\n\n    const updates = await userMapperReturningDefault\n      .update({ name: 'Sue' })\n      .returnAll({ email: 'new.email@xyz.pdq' });\n    expect(updates).toBeUndefined();", "      .returnAll({ email: 'new.email@xyz.pdq' });\n    expect(updates).toBeUndefined();\n\n    const readUsers = await userMapperReturningID\n      .select({\n        email: 'new.email@xyz.pdq',\n      })\n      .returnAll();\n    expect(readUsers.length).toEqual(2);\n  });", "    expect(readUsers.length).toEqual(2);\n  });\n\n  it('update returns void when explicitly no return columns', async () => {\n    await userMapperReturningID.insert().run(USERS);\n\n    const updates = await userMapperReturningNothing\n      .update({ name: 'Sue' })\n      .returnAll({ email: 'new.email@xyz.pdq' });\n    expect(updates).toBeUndefined();", "      .returnAll({ email: 'new.email@xyz.pdq' });\n    expect(updates).toBeUndefined();\n\n    const readUsers = await userMapperReturningID\n      .select({\n        email: 'new.email@xyz.pdq',\n      })\n      .returnAll();\n    expect(readUsers.length).toEqual(2);\n", "    expect(readUsers.length).toEqual(2);\n\n    const update = await userMapperReturningNothing\n      .update({ name: 'Sue' })\n      .returnOne({ email: 'new2.email@xyz.pdq' });\n    expect(update).toBeUndefined();\n\n    const readUser = await userMapperReturningID\n      .select({\n        email: 'new2.email@xyz.pdq',", "      .select({\n        email: 'new2.email@xyz.pdq',\n      })\n      .returnOne();\n    expect(readUser!.id).toEqual(1);\n\n    ignore('type errors', () => {\n      // @ts-expect-error - check return types\n      updates[0].id;\n      // @ts-expect-error - check return types\n      update!.id;\n    });\n  });\n\n  it('updates configured to return all columns', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues1 = { email: 'new.email@xyz.pdq' };\n    const updateReturns = await userMapperReturningAll\n      .update({ name: 'Sue' })\n      .returnAll(updateValues1);\n\n    const expectedUsers = [\n      Object.assign({}, USERS[0], updateValues1, { id: insertReturns[0].id }),\n      Object.assign({}, USERS[2], updateValues1, { id: insertReturns[2].id }),\n    ];\n    expect(updateReturns).toEqual(expectedUsers);\n    // Ensure that the returned value can be accessed as a row.\n    ((_: string) => {})(updateReturns[0].name);\n    ((_: string | null) => {})(updateReturns[0].email);\n\n    const updateValues2 = { email: 'another.email@xyz.pdq' };\n    const updateReturn = await userMapperReturningAll\n      .update({ name: 'Sue' })\n      .returnOne(updateValues2);\n\n    const expectedUser = Object.assign({}, USERS[0], updateValues2, {\n      id: insertReturns[0].id,\n    });\n    expect(updateReturn).toEqual(expectedUser);\n    // Ensure that the returned value can be accessed as a row.\n    ((_: string) => {})(updateReturn!.name);\n    ((_: string | null) => {})(updateReturn!.email);\n  });\n\n  it('updates all rows when no filter is given', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues = { email: 'new.email@xyz.pdq' };\n    const updateReturns = await userMapperReturningIDAndHandleAsH\n      .update()\n      .returnAll(updateValues);\n\n    const expectedUsers = USERS.map((user, i) => ({\n      id: insertReturns[i].id,\n      h: user.handle,\n    }));\n    expect(updateReturns).toEqual(expectedUsers);\n\n    const readUsers = await userMapperReturningID.select().returnAll();\n    expect(readUsers.length).toEqual(3);", "    for (const user of readUsers) {\n      expect(user.email).toEqual(updateValues.email);\n    }\n  });\n\n  it('updates rows indicated by a binary operator', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues = { email: 'new.email@xyz.pdq' };\n    const updateCount = await userMapperReturningAll\n      .update('id', '>', insertReturns[0].id)\n      .returnCount(updateValues);\n    expect(updateCount).toEqual(2);\n\n    const readUsers = await userMapperReturningID\n      .select('id', '>', insertReturns[0].id)\n      .returnAll();\n    expect(readUsers.length).toEqual(2);", "    for (const user of readUsers) {\n      expect(user.email).toEqual(updateValues.email);\n    }\n  });\n\n  it('updates rows indicated by a kysely expression', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues = { email: 'new.email@xyz.pdq' };\n    const updateCount = await userMapperReturningDefault\n      .update(sql`id > ${insertReturns[0].id}`)\n      .returnCount(updateValues);\n    expect(updateCount).toEqual(BigInt(2));\n\n    const readUsers = await userMapperReturningID\n      .select('id', '>', insertReturns[0].id)\n      .returnAll();\n    expect(readUsers.length).toEqual(2);", "    for (const user of readUsers) {\n      expect(user.email).toEqual(updateValues.email);\n    }\n  });\n\n  it('updates rows indicated by a where expression filter', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues1 = { email: 'foo@xyz.pdq' };\n    const updateCount = await userMapperReturningAll\n      .update(({ or, cmpr }) =>\n        or([\n          cmpr('id', '=', insertReturns[0].id),\n          cmpr('id', '=', insertReturns[2].id),\n        ])\n      )\n      .returnCount(updateValues1);\n    expect(updateCount).toEqual(2);\n\n    const updateValues2 = { email: 'bar@xyz.pdq' };\n    const updateReturns = await userMapperReturningID\n      .update(({ or, cmpr }) =>\n        or([\n          cmpr('id', '=', insertReturns[0].id),\n          cmpr('id', '=', insertReturns[2].id),\n        ])\n      )\n      .returnAll(updateValues2);\n    expect(updateReturns).toEqual([\n      { id: insertReturns[0].id },\n      { id: insertReturns[2].id },\n    ]);\n  });\n", "  ignore('detects update type errors', async () => {\n    userMapperReturningID.update(\n      // @ts-expect-error - table must have all filter fields\n      { notThere: 'xyz' }\n    );\n    // @ts-expect-error - table must have all filter fields\n    userMapperReturningID.update('notThere', '=', 'foo');\n    userMapperReturningID.update(({ or, cmpr }) =>\n      // @ts-expect-error - only table columns are accessible via anyOf()\n      or([cmpr('notThere', '=', 'xyz'), cmpr('alsoNotThere', '=', 'Sue')])\n    );\n    // @ts-expect-error - ID filter must have correct type\n    userMapperReturningID.update('str');\n    // @ts-expect-error - ID filter must have correct type\n    userMapperReturningID.update(['str']);\n    // @ts-expect-error - ID filter not allowed when when no ID column\n    userMapperReturningNothing.update(1);\n    // @ts-expect-error - ID filter not allowed when when no ID column\n    userMapperReturningNothing.update([1]);\n\n    userMapperReturningID.update({ id: 32 }).returnAll(\n      // @ts-expect-error - update must only have table columns\n      { notThere: 'xyz@pdq.xyz' }\n    );\n    // @ts-expect-error - only requested columns are accessible\n    // prettier-ignore\n    (await userMapperReturningID.update({ id: 32 }).returnAll(USERS[0]))[0].name;\n\n    userMapperReturningID.update({ id: 32 }).returnOne(\n      // @ts-expect-error - update must only have table columns\n      { notThere: 'xyz@pdq.xyz' }\n    );\n    // @ts-expect-error - only requested columns are accessible\n    // prettier-ignore\n    (await userMapperReturningID.update({ id: 32 }).returnOne(USERS[0]))[0].name;\n\n    userMapperReturningID.update({ id: 32 }).returnCount(\n      // @ts-expect-error - update must only have table columns\n      { notThere: 'xyz@pdq.xyz' }\n    );\n    // @ts-expect-error - only requested columns are accessible\n    // prettier-ignore\n    (await userMapperReturningID.update({ id: 32 }).returnCount(USERS[0]))[0].name;\n\n    userMapperReturningID.update({ id: 32 }).run(\n      // @ts-expect-error - update must only have table columns\n      { notThere: 'xyz@pdq.xyz' }\n    );\n    // @ts-expect-error - only requested columns are accessible\n    // prettier-ignore\n    (await userMapperReturningID.update({ id: 32 }).run(USERS[0]))[0].name;\n  });\n});\n"]}
{"filename": "src/tests/insert-array.test.ts", "chunked_list": ["import { Insertable, Kysely, Selectable, Updateable } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database, Posts } from './utils/test-tables';\nimport {\n  createUserMapperReturningDefault,\n  createUserMapperReturningID,\n  createUserMapperReturningAll,\n  createUserMapperReturningNothing,", "  createUserMapperReturningAll,\n  createUserMapperReturningNothing,\n  createUserMapperReturningDifferently,\n} from './utils/test-mappers';\nimport { USERS, POSTS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\n\nlet db: Kysely<Database>;\n\nlet userMapperReturningDefault: ReturnType<", "\nlet userMapperReturningDefault: ReturnType<\n  typeof createUserMapperReturningDefault\n>;\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\nlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n", "let userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\nlet postTableMapperReturningIDAndTitleAsT: TableMapper<\n  Database,\n  'posts',\n  [],\n  ['*'],\n  Selectable<Posts>,\n  Insertable<Posts>,\n  Updateable<Posts>,", "  Insertable<Posts>,\n  Updateable<Posts>,\n  number,\n  ['id', 'title as t']\n>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningDefault = createUserMapperReturningDefault(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);", "  userMapperReturningDefault = createUserMapperReturningDefault(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n  userMapperReturningID = createUserMapperReturningID(db);\n  userMapperReturningAll = createUserMapperReturningAll(db);\n  postTableMapperReturningIDAndTitleAsT = new TableMapper(db, 'posts', {\n    insertReturnColumns: ['id', 'title as t'],\n  }).withTransforms({\n    countTransform: (count) => Number(count),\n  });\n});", "  });\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('inserting an array of objects without transformation', () => {\n  it('inserts readonly objects', async () => {\n    const obj = {\n      name: 'John Doe' as const,\n      handle: 'johndoe' as const,", "      name: 'John Doe' as const,\n      handle: 'johndoe' as const,\n      email: 'abc@def.ghi' as const,\n    } as const;\n    await userMapperReturningAll.insert().run(obj);\n    await userMapperReturningAll.insert().returnAll([obj]);\n    await userMapperReturningAll.insert().returnOne(obj);\n  });\n\n  it('inserts multiple via run() without returning columns', async () => {", "\n  it('inserts multiple via run() without returning columns', async () => {\n    const success = await userMapperReturningDefault.insert().run(USERS);\n    expect(success).toBe(true);\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(3);\n    for (let i = 0; i < USERS.length; i++) {\n      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n    }\n\n    ignore(\"can't access columns when returning nothing\", () => {\n      // @ts-expect-error - can't access columns when returning nothing\n      result.id;\n      // @ts-expect-error - can't access columns when returning nothing\n      result[0].id;\n    });\n  });\n\n  it('inserts multiple via returnAll() without returning columns', async () => {\n    const results = await userMapperReturningDefault.insert().returnAll(USERS);\n    expect(results).toBeUndefined();\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(3);", "    for (let i = 0; i < USERS.length; i++) {\n      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n    }\n\n    ignore(\"can't access columns when returning nothing\", () => {\n      // @ts-expect-error - can't access columns when returning nothing\n      results.id;\n      // @ts-expect-error - can't access columns when returning nothing\n      results[0].id;\n    });\n  });\n\n  it('inserts multiple via returnOne() without returning columns', async () => {\n    const results = await userMapperReturningDefault\n      .insert()\n      .returnOne(USERS[0]);\n    expect(results).toBeUndefined();\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(1);\n    expect(readUsers[0].handle).toEqual(USERS[0].handle);\n\n    ignore(\"can't access columns when returning nothing\", () => {\n      // @ts-expect-error - can't access columns when returning nothing\n      results.id;\n      // @ts-expect-error - can't access columns when returning nothing\n      results[0].id;\n    });\n  });\n\n  it('inserts multiple returning configured return columns', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n    expect(insertReturns.length).toEqual(3);", "    for (let i = 0; i < USERS.length; i++) {\n      expect(insertReturns[i].id).toBeGreaterThan(0);\n      expect(Object.keys(insertReturns[i]).length).toEqual(1);\n    }\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(3);\n    for (let i = 0; i < USERS.length; i++) {\n      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n    }\n\n    const post0 = Object.assign({}, POSTS[0], { userId: insertReturns[0].id });\n    const post1 = Object.assign({}, POSTS[1], { userId: insertReturns[1].id });\n    const post2 = Object.assign({}, POSTS[2], { userId: insertReturns[2].id });\n    const updateReturns = await postTableMapperReturningIDAndTitleAsT\n      .insert()\n      .returnAll([post0, post1, post2]);\n    expect(updateReturns.length).toEqual(3);", "    for (let i = 0; i < updateReturns.length; i++) {\n      expect(updateReturns[i].id).toBeGreaterThan(0);\n      expect(updateReturns[i].t).toEqual(POSTS[i].title);\n      expect(Object.keys(updateReturns[i]).length).toEqual(2);\n    }\n\n    ignore('check return types', () => {\n      // @ts-expect-error - check return types\n      updateReturns[0].title;\n      // @ts-expect-error - check return types\n      updateReturns[0].userId;\n    });\n  });\n\n  it('inserts multiple returning no columns by default', async () => {\n    const insertReturns = await userMapperReturningDefault\n      .insert()\n      .returnAll(USERS);\n    expect(insertReturns).toBeUndefined();\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(3);", "    for (let i = 0; i < USERS.length; i++) {\n      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n    }\n  });\n\n  it('inserts multiple explicitly returning no columns', async () => {\n    const insertReturns = await userMapperReturningNothing\n      .insert()\n      .returnAll(USERS);\n    expect(insertReturns).toBeUndefined();\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(3);", "    for (let i = 0; i < USERS.length; i++) {\n      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n    }\n\n    ignore(\"can't access columns when returning nothing\", () => {\n      // @ts-expect-error - can't access columns when returning nothing\n      insertReturns[0].id;\n    });\n  });\n\n  it('inserts multiple returning differently for inserts and updates', async () => {\n    const mapper = createUserMapperReturningDifferently(db);\n\n    const insertReturns = await mapper.insert().returnAll(USERS);\n    expect(insertReturns.length).toEqual(3);\n    expect(insertReturns[0]).toEqual({\n      id: insertReturns[0].id,\n      handle: USERS[0].handle,\n    });\n    // Ensure that returned objects can be accessed as expected.\n    ((_: number) => {})(insertReturns[0].id);\n    ((_: string) => {})(insertReturns[0].handle);\n\n    const newHandle = 'newHandle';\n    const updateReturns = await mapper\n      .update(1)\n      .returnAll({ handle: newHandle });\n    expect(updateReturns.length).toEqual(1);\n    expect(updateReturns[0]).toEqual({\n      name: USERS[0].name,\n    });\n    // Ensure that returned objects can be accessed as expected.\n    ((_: string) => {})(updateReturns[0].name);\n", "    ignore('type errors', () => {\n      // @ts-expect-error - check return types\n      insertReturns[0].name;\n      // @ts-expect-error - check return types\n      updateReturns[0].id;\n    });\n  });\n\n  it('inserts multiple configured to return all columns', async () => {\n    const insertReturns = await userMapperReturningAll\n      .insert()\n      .returnAll(USERS);", "    for (let i = 0; i < USERS.length; i++) {\n      expect(insertReturns[i].id).toBeGreaterThan(0);\n    }\n    expect(insertReturns).toEqual(\n      USERS.map((user, i) =>\n        Object.assign({}, user, { id: insertReturns[i].id })\n      )\n    );\n    // Ensure that returned objects can be accessed as expected.\n    ((_: string) => {})(insertReturns[0].name);\n  });\n", "  ignore('detects inserting an array of objects type errors', async () => {\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().returnAll([{}]);\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().run([{}]);\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().returnAll([{ email: 'xyz@pdq.xyz' }]);\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().run([{ email: 'xyz@pdq.xyz' }]);\n    // @ts-expect-error - only configured columns are returned\n    (await userMapperReturningID.insert().returnAll([USERS[0]]))[0].handle;\n    // @ts-expect-error - only configured columns are returned\n    (await userMapperReturningID.insert().run([USERS[0]]))[0].handle;\n  });\n});\n"]}
{"filename": "src/tests/select-all.test.ts", "chunked_list": ["/**\n * Tests TableMapper.selectMany(), TableMapper.selectOne(), and query filters.\n */\n\nimport { Kysely, sql } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport { createUserMapperReturningID } from './utils/test-mappers';", "import { Database } from './utils/test-tables';\nimport { createUserMapperReturningID } from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\n\nlet db: Kysely<Database>;\nlet userMapper: ReturnType<typeof createUserMapperReturningID>;\n\nbeforeAll(async () => {\n  db = await createDB();", "beforeAll(async () => {\n  db = await createDB();\n  userMapper = createUserMapperReturningID(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('selecting all returns', () => {\n  it('accepts readonly filters', async () => {\n    const filter1 = { name: 'Not There' as const } as const;", "  it('accepts readonly filters', async () => {\n    const filter1 = { name: 'Not There' as const } as const;\n    await userMapper.select(filter1).returnAll();\n    await userMapper.select(filter1).returnOne();\n\n    const filter2 = { name: ['name1', 'name2'] as const } as const;\n    await userMapper.select(filter2).returnAll();\n    await userMapper.select(filter2).returnOne();\n  });\n", "  });\n\n  it('selects nothing when nothing matches filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    const users = await userMapper.select({ name: 'Not There' }).returnAll();\n    expect(users.length).toEqual(0);\n  });\n\n  it('selects all rows with no filter', async () => {", "\n  it('selects all rows with no filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    // Test selecting all\n    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(USERS.length);\n    for (let i = 0; i < USERS.length; i++) {\n      expect(users[i].handle).toEqual(USERS[i].handle);\n    }\n  });\n\n  it('selects via key column values', async () => {\n    await userMapper.insert().run(USERS);\n\n    // Test selecting via key value\n    const users1 = await userMapper.select(2).returnAll();\n    expect(users1.length).toEqual(1);\n    expect(users1[0].handle).toEqual(USERS[1].handle);\n\n    // Test selecting via key tuple\n    const users2 = await userMapper.select([2]).returnAll();\n    expect(users2.length).toEqual(1);\n    expect(users2[0].handle).toEqual(USERS[1].handle);\n  });\n\n  it('selects with a matching field filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    let users = await userMapper\n      .select({\n        name: USERS[0].name,\n      })\n      .returnAll();\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[0].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n\n    users = await userMapper\n      .select({\n        name: USERS[0].name,\n        handle: USERS[2].handle,\n      })\n      .returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[2].handle);\n\n    users = await userMapper\n      .select({\n        handle: [USERS[1].handle, USERS[2].handle],\n      })\n      .returnAll();\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n  });\n\n  it('selects with a binary operation filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    // Test selecting by condition (with results)\n    let users = await userMapper.select('name', '=', USERS[0].name).returnAll();\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[0].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n\n    // Test selecting by condition (no results)\n    users = await userMapper.select('name', '=', 'nonexistent').returnAll();\n    expect(users.length).toEqual(0);\n  });\n\n  it('selects with a binary operation filter using .ref()', async () => {\n    await userMapper.insert().run(USERS);\n\n    // Test selecting by condition (with results)\n    let users = await userMapper\n      .select(userMapper.ref('name'), '=', USERS[0].name)\n      .returnAll();\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[0].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n\n    // Test selecting by condition (no results)\n    users = await userMapper\n      .select(userMapper.ref('email'), '=', 'nonexistent')\n      .returnAll();\n    expect(users.length).toEqual(0);\n  });\n\n  it('selects with a query expression filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    const users = await userMapper\n      .select(sql`name != ${USERS[0].name}`)\n      .returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n  });\n\n  it('selects many returning selected columns and aliases', async () => {\n    const ids = await userMapper.insert().returnAll(USERS);\n    const mapper = new TableMapper(db, 'users', {\n      selectedColumns: ['id', 'handle as h'],\n    });\n\n    // Should allow access to aliased columns\n    (await mapper.select().returnAll())[0].h;\n\n    const users = await mapper.select({ name: USERS[0].name }).returnAll();\n    expect(users).toEqual([\n      {\n        id: ids[0].id,\n        h: USERS[0].handle,\n      },\n      {\n        id: ids[2].id,\n        h: USERS[2].handle,\n      },\n    ]);\n\n    ignore('inaccessible types are not allowed', async () => {\n      // @ts-expect-error - aliases are not allowed in filter expressions\n      mapper.select({ h: USERS[0].handle });\n      // @ts-expect-error - unselected columns are not allowed\n      (await mapper.select().returnAll())[0].name;\n    });\n  });\n\n  ignore(", "    'detects selecting returnAll() simple filter type errors',\n    async () => {\n      // @ts-expect-error - only table columns are accessible unfiltered\n      (await userMapper.select().returnAll())[0].notThere;\n      // @ts-expect-error - only table columns are accessible unfiltered\n      (await userMapper.select({}).returnAll())[0].notThere;\n      // @ts-expect-error - only table columns are accessible w/ object filter\n      // prettier-ignore\n      (await userMapper.select({ name: \"Sue\" }).returnAll())[0].notThere;\n      // @ts-expect-error - only table columns are accessible w/ op filter\n      // prettier-ignore\n      (await userMapper.select(\"name\", \"=\", \"Sue\").returnAll())[0].notThere;\n      // prettier-ignore\n      (\n        await userMapper\n          .select((qb) => qb)\n          .returnAll()\n        // @ts-expect-error - only table columns are accessible w/ QB filter\n      )[0].notThere;\n      // prettier-ignore\n      (\n        await userMapper\n          .select(sql`name = 'Sue'`)\n          .returnAll()\n        // @ts-expect-error - only table columns are accessible w/ expr filter\n      )[0].notThere;\n    }\n  );\n});\n"]}
{"filename": "src/tests/insert-compile.test.ts", "chunked_list": ["import { Insertable, Kysely } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database, Users } from './utils/test-tables';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\nimport { User } from './utils/test-types';\nimport {\n  createUserMapperReturningAll,", "import {\n  createUserMapperReturningAll,\n  createUserMapperReturningNothing,\n} from './utils/test-mappers';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningNothing = createUserMapperReturningNothing(db);", "  db = await createDB();\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n  userMapperReturningAll = createUserMapperReturningAll(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;", "  typeof createUserMapperReturningNothing\n>;\nlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\ndescribe('compiled insertions', () => {\n  it('compiles a non-returning insert query without transformation', async () => {\n    const compilation = userMapperReturningNothing\n      .insert()\n      .columns(['name', 'handle'])\n      .compile();", "      .columns(['name', 'handle'])\n      .compile();\n\n    // test run()\n    const success1 = await compilation.run(USERS[1]);\n    expect(success1).toBe(true);\n\n    // test returnOne()\n    const success2 = await compilation.returnOne(USERS[2]);\n    expect(success2).toBeUndefined();", "    const success2 = await compilation.returnOne(USERS[2]);\n    expect(success2).toBeUndefined();\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(2);\n    expect(readUsers[0].handle).toEqual(USERS[1].handle);\n    expect(readUsers[0].email).toEqual(null);\n    expect(readUsers[1].handle).toEqual(USERS[2].handle);\n    expect(readUsers[1].email).toEqual(null);\n  });", "    expect(readUsers[1].email).toEqual(null);\n  });\n\n  it('compiles a returning insert query without transformation', async () => {\n    const compilation = userMapperReturningAll\n      .insert()\n      .columns(['name', 'handle', 'email'])\n      .compile();\n\n    // test returnOne()", "\n    // test returnOne()\n    const insertReturn = await compilation.returnOne(USERS[0]);\n    expect(insertReturn).toEqual({ ...USERS[0], id: 1 });\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(insertReturn!.name);\n\n    // test run()\n    const success1 = await compilation.run(USERS[1]);\n    expect(success1).toBe(true);", "    const success1 = await compilation.run(USERS[1]);\n    expect(success1).toBe(true);\n\n    // test that non-specified columns are not inserted\n    const success2 = await compilation.run({ ...USERS[2], id: 100 });\n    expect(success2).toBe(true);\n\n    const readUsers = await userMapperReturningAll.select().returnAll();\n    expect(readUsers.length).toEqual(3);\n    expect(readUsers[0].handle).toEqual(USERS[0].handle);", "    expect(readUsers.length).toEqual(3);\n    expect(readUsers[0].handle).toEqual(USERS[0].handle);\n    expect(readUsers[1].handle).toEqual(USERS[1].handle);\n    expect(readUsers[2].handle).toEqual(USERS[2].handle);\n    expect(readUsers[2].id).toEqual(3);\n\n    ignore('check compile-time types', () => {\n      compilation.returnOne({\n        name: 'xyz',\n        handle: 'pdq',", "        name: 'xyz',\n        handle: 'pdq',\n        email: 'abc@def.hij',\n        // @ts-expect-error - only insertable columns are allowed\n        notThere: 32,\n      });\n      // @ts-expect-error - only expected columns are returned\n      insertReturn!.notThere;\n    });\n  });", "    });\n  });\n\n  it('compiles an insert query with transformation', async () => {\n    expect.assertions(7);\n\n    const columnSubset: (keyof Insertable<Users>)[] = [\n      'name',\n      'handle',\n      'email',", "      'handle',\n      'email',\n    ];\n    const transformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n    }).withTransforms({\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return new User(row.id, names[0], names[1], row.handle, row.email);\n      },", "        return new User(row.id, names[0], names[1], row.handle, row.email);\n      },\n      insertTransform: (source: User, columns) => {\n        expect(columns).toEqual(columnSubset);\n        return {\n          name: `${source.firstName} ${source.lastName}`,\n          handle: source.handle,\n          email: source.email,\n        };\n      },", "        };\n      },\n      insertReturnTransform: (source: User, returns) =>\n        new User(\n          returns.id,\n          source.firstName,\n          source.lastName,\n          source.handle,\n          source.email\n        ),", "          source.email\n        ),\n      countTransform: (count) => Number(count),\n    });\n    const user1: Readonly<User> = new User(\n      0,\n      'John',\n      'Doe',\n      'johndoe',\n      'jdoe@abc.def'", "      'johndoe',\n      'jdoe@abc.def'\n    );\n    const user2: Readonly<User> = new User(\n      0,\n      'Sam',\n      'Gamgee',\n      'sg',\n      'sg@abc.def'\n    );", "      'sg@abc.def'\n    );\n    const user3 = new User(100, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n\n    const compilation = transformMapper\n      .insert()\n      .columns(columnSubset)\n      .compile();\n\n    // test returnOne()", "\n    // test returnOne()\n    const insertReturn = await compilation.returnOne(user1);\n    expect(insertReturn).toEqual(User.create(1, user1));\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(insertReturn!.firstName);\n\n    // test run()\n    const success1 = await compilation.run(user2);\n    expect(success1).toBe(true);", "    const success1 = await compilation.run(user2);\n    expect(success1).toBe(true);\n\n    // test that non-specified columns are not inserted\n    const success2 = await compilation.run(user3);\n    expect(success2).toBe(true);\n\n    const readUsers = await transformMapper.select().returnAll();\n    expect(readUsers).toEqual([\n      User.create(1, user1),", "    expect(readUsers).toEqual([\n      User.create(1, user1),\n      User.create(2, user2),\n      User.create(3, user3),\n    ]);\n\n    ignore('check compile-time types', () => {\n      // @ts-expect-error - only insertable objecs are allowed\n      compilation.returnOne(USERS[0]);\n      // @ts-expect-error - only insertable objecs are allowed", "      compilation.returnOne(USERS[0]);\n      // @ts-expect-error - only insertable objecs are allowed\n      compilation.run(USERS[0]);\n    });\n  });\n\n  it('requires all indicated columns to be inserted', async () => {\n    const compilation = userMapperReturningAll\n      .insert()\n      .columns(['name', 'handle', 'email'])", "      .insert()\n      .columns(['name', 'handle', 'email'])\n      .compile();\n\n    const insertValues = { name: 'John Doe', handle: 'johndoe' };\n\n    expect(() => compilation.returnOne(insertValues)).rejects.toThrow(\n      `column 'email' missing`\n    );\n", "    );\n\n    const success = await compilation.run({ ...insertValues, email: null });\n    expect(success).toBe(true);\n  });\n});\n"]}
{"filename": "src/tests/update-transform.test.ts", "chunked_list": ["import { Kysely, Updateable } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database, Users } from './utils/test-tables';\nimport {\n  userObject1,\n  userRow1,\n  userRow2,\n  userRow3,", "  userRow2,\n  userRow3,\n} from './utils/test-objects';\nimport { ReturnedUser, UpdatingUser } from './utils/test-types';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {\n  db = await createDB();\n});", "  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('updating with transformation', () => {\n  it('transforms users for update without transforming return', async () => {\n    const mapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],", "      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      updateTransform: (source: UpdatingUser) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n    });\n", "    });\n\n    const insertReturns = await mapper\n      .insert()\n      .returnAll([userRow1, userRow2, userRow3]);\n    const updatingUser1 = UpdatingUser.create(\n      0,\n      Object.assign({}, userObject1, { firstName: 'Suzanne' })\n    );\n", "    );\n\n    const updateReturns = await mapper\n      .update(({ or, cmpr }) =>\n        or([\n          cmpr('id', '=', insertReturns[0].id),\n          cmpr('id', '=', insertReturns[2].id),\n        ])\n      )\n      .returnAll(updatingUser1);", "      )\n      .returnAll(updatingUser1);\n    expect(updateReturns).toEqual([\n      { id: insertReturns[0].id },\n      { id: insertReturns[2].id },\n    ]);\n\n    const readUsers = await mapper\n      .select()\n      .modify((qb) => qb.orderBy('id'))", "      .select()\n      .modify((qb) => qb.orderBy('id'))\n      .returnAll();\n    expect(readUsers).toEqual([\n      Object.assign({}, userRow1, {\n        id: insertReturns[0].id,\n        name: 'Suzanne Smith',\n      }),\n      Object.assign({}, userRow2, { id: insertReturns[1].id }),\n      Object.assign({}, userRow1, {", "      Object.assign({}, userRow2, { id: insertReturns[1].id }),\n      Object.assign({}, userRow1, {\n        id: insertReturns[2].id,\n        name: 'Suzanne Smith',\n      }),\n    ]);\n  });\n\n  it('transforms update return into object without transforming update', async () => {\n    const updateReturnTransformMapper = new TableMapper(db, 'users', {", "  it('transforms update return into object without transforming update', async () => {\n    const updateReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      updateReturnTransform: (source, returns) =>\n        new ReturnedUser(\n          returns.id,\n          source.name ? source.name.split(' ')[0] : '(first)',\n          source.name ? source.name.split(' ')[1] : '(last)',", "          source.name ? source.name.split(' ')[0] : '(first)',\n          source.name ? source.name.split(' ')[1] : '(last)',\n          source.handle ? source.handle : '(handle)',\n          source.email ? source.email : '(email)'\n        ),\n    });\n\n    const insertReturn = await updateReturnTransformMapper\n      .insert()\n      .returnOne(userRow1);", "      .insert()\n      .returnOne(userRow1);\n\n    const updateReturn1 = await updateReturnTransformMapper\n      .update({ id: insertReturn.id })\n      .returnAll({ name: 'Suzanne Smith' });\n    expect(updateReturn1).toEqual([\n      new ReturnedUser(\n        insertReturn.id,\n        'Suzanne',", "        insertReturn.id,\n        'Suzanne',\n        'Smith',\n        '(handle)',\n        '(email)'\n      ),\n    ]);\n    // Ensure the returned value is accessible as a ReturnedUser\n    ((_: string) => {})(updateReturn1[0].firstName);\n", "    ((_: string) => {})(updateReturn1[0].firstName);\n\n    const updateReturn2 = await updateReturnTransformMapper\n      .update({ id: insertReturn.id })\n      .returnOne({ name: 'Suzanne Smithy' });\n    expect(updateReturn2).toEqual(\n      new ReturnedUser(\n        insertReturn.id,\n        'Suzanne',\n        'Smithy',", "        'Suzanne',\n        'Smithy',\n        '(handle)',\n        '(email)'\n      )\n    );\n    // Ensure the returned value is accessible as a ReturnedUser\n    ((_: string) => {})(updateReturn2!.firstName);\n  });\n", "  });\n\n  it('transforms update return into primitive without transforming update', async () => {\n    const updateReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      insertReturnTransform: (_source, returns) => returns.id,\n      updateReturnTransform: (_source, returns) => returns.id,\n    });", "      updateReturnTransform: (_source, returns) => returns.id,\n    });\n\n    const insertReturn = await updateReturnTransformMapper\n      .insert()\n      .returnOne(userRow1);\n\n    const updateReturn1 = await updateReturnTransformMapper\n      .update({ id: insertReturn })\n      .returnAll({ name: 'Suzanne Smith' });", "      .update({ id: insertReturn })\n      .returnAll({ name: 'Suzanne Smith' });\n    expect(updateReturn1).toEqual([1]);\n    // Ensure the returned value is accessible as a number\n    ((_: number) => {})(updateReturn1[0]);\n\n    const updateReturn2 = await updateReturnTransformMapper\n      .update({ id: insertReturn })\n      .returnOne({ name: 'Suzanne Smithy' });\n    expect(updateReturn2).toEqual(1);", "      .returnOne({ name: 'Suzanne Smithy' });\n    expect(updateReturn2).toEqual(1);\n    // Ensure the returned value is accessible as a number\n    ((_: number) => {})(updateReturn2!);\n  });\n\n  it(\"transforms update and update return, columns is ['*']\", async () => {\n    expect.assertions(2);\n    const updateAndReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],", "    const updateAndReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      updateTransform: (source: UpdatingUser, columns) => {\n        expect(columns).toEqual(['*']);\n        return {\n          name: `${source.firstName} ${source.lastName}`,\n          handle: source.handle,\n          email: source.email,", "          handle: source.handle,\n          email: source.email,\n        };\n      },\n      updateReturnTransform: (source: UpdatingUser, returns) =>\n        new ReturnedUser(\n          returns.id,\n          source.firstName,\n          source.lastName,\n          source.handle,", "          source.lastName,\n          source.handle,\n          source.email\n        ),\n    });\n\n    const insertReturn = await updateAndReturnTransformMapper\n      .insert()\n      .returnOne(userRow1);\n    const updateReturn = await updateAndReturnTransformMapper", "      .returnOne(userRow1);\n    const updateReturn = await updateAndReturnTransformMapper\n      .update({ id: insertReturn.id })\n      .returnAll(UpdatingUser.create(0, userObject1));\n    expect(updateReturn).toEqual([\n      new ReturnedUser(\n        insertReturn.id,\n        userObject1.firstName,\n        userObject1.lastName,\n        userObject1.handle,", "        userObject1.lastName,\n        userObject1.handle,\n        userObject1.email\n      ),\n    ]);\n    // Ensure the returned value is accessible as a ReturnedUser\n    ((_: string) => {})(updateReturn[0].firstName);\n  });\n\n  it('transforms a union of updating object types', async () => {", "\n  it('transforms a union of updating object types', async () => {\n    const mapper = new TableMapper(db, 'users', {\n      keyColumns: ['id'],\n    }).withTransforms({\n      updateTransform: (source: UpdatingUser | Updateable<Users>) =>\n        source instanceof UpdatingUser\n          ? {\n              name: `${source.firstName} ${source.lastName}`,\n              handle: source.handle,", "              name: `${source.firstName} ${source.lastName}`,\n              handle: source.handle,\n              email: source.email,\n            }\n          : source,\n    });\n    const insertReturn = await mapper.insert().returnOne(userRow1);\n\n    // test with UpdatingUser\n    await mapper", "    // test with UpdatingUser\n    await mapper\n      .update({ id: insertReturn.id })\n      .columns(['name'])\n      .run(UpdatingUser.create(0, userObject1));\n    const readUser1 = await mapper.select(insertReturn.id).returnOne();\n    expect(readUser1).toEqual({\n      id: insertReturn.id,\n      name: `${userObject1.firstName} ${userObject1.lastName}`,\n      email: userRow1.email,", "      name: `${userObject1.firstName} ${userObject1.lastName}`,\n      email: userRow1.email,\n      handle: userRow1.handle,\n    });\n\n    // test with Updateable<Users>\n    const newName = 'Suzanne Smith Something';\n    await mapper.update({ id: insertReturn.id }).run({ name: newName });\n    const readUser2 = await mapper.select(insertReturn.id).returnOne();\n    expect(readUser2).toEqual({", "    const readUser2 = await mapper.select(insertReturn.id).returnOne();\n    expect(readUser2).toEqual({\n      id: insertReturn.id,\n      name: newName,\n      email: userRow1.email,\n      handle: userRow1.handle,\n    });\n  });\n});\n", "});\n"]}
{"filename": "src/tests/update-columns.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport { createUserMapperReturningID } from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { TableMapper } from '../mappers/table-mapper';\n\nlet db: Kysely<Database>;\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;", "let db: Kysely<Database>;\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningID = createUserMapperReturningID(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n", "afterAll(() => destroyDB(db));\n\ndescribe('updating specific columns', () => {\n  it('subsets updating columns, excluding ID', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues = { id: 100, name: 'Sue Rex', email: 'rex@abc.def' };\n    const subsetQuery = userMapperReturningID\n      .update('id', '=', insertReturns[0].id)\n      .columns(['name'] as const); // allows readonly array", "      .update('id', '=', insertReturns[0].id)\n      .columns(['name'] as const); // allows readonly array\n    const updateReturns = await subsetQuery.returnAll(updateValues);\n    expect(updateReturns).toEqual([{ id: insertReturns[0].id }]);\n\n    const readUsers = await userMapperReturningID\n      .select('id', '=', insertReturns[0].id)\n      .returnOne();\n    expect(readUsers).toEqual({\n      id: insertReturns[0].id,", "    expect(readUsers).toEqual({\n      id: insertReturns[0].id,\n      name: 'Sue Rex',\n      email: USERS[0].email,\n      handle: USERS[0].handle,\n    });\n  });\n\n  it('subsets updating columns, including ID', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);", "  it('subsets updating columns, including ID', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues = { id: 100, name: 'Sue Rex', email: 'rex@abc.def' };\n    const subsetQuery = userMapperReturningID\n\n      .update('id', '=', insertReturns[0].id)\n      .columns(['id', 'name', 'email']);\n    const updateReturns = await subsetQuery.returnAll(updateValues);\n    expect(updateReturns).toEqual([{ id: 100 }]);", "    const updateReturns = await subsetQuery.returnAll(updateValues);\n    expect(updateReturns).toEqual([{ id: 100 }]);\n\n    const readUsers = await userMapperReturningID\n      .select('id', '=', 100)\n      .returnOne();\n    expect(readUsers).toEqual({\n      id: 100,\n      name: 'Sue Rex',\n      email: 'rex@abc.def',", "      name: 'Sue Rex',\n      email: 'rex@abc.def',\n      handle: USERS[0].handle,\n    });\n  });\n\n  it('requires all subsetted columns to be updated', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const updateValues = { name: 'Sue Rex' };", "\n    const updateValues = { name: 'Sue Rex' };\n\n    const subsetQuery = userMapperReturningID\n      .update('id', '=', insertReturns[0].id)\n      .columns(['name', 'email']);\n    expect(() => subsetQuery.returnAll(updateValues)).rejects.toThrow(\n      `column 'email' missing`\n    );\n", "    );\n\n    const success = await subsetQuery.run({ ...updateValues, email: null });\n    expect(success).toBe(true);\n  });\n\n  it('provides updateTransform with column subset', async () => {\n    expect.assertions(1);\n    const mapper = new TableMapper(db, 'users').withTransforms({\n      updateTransform: (source, columns) => {", "    const mapper = new TableMapper(db, 'users').withTransforms({\n      updateTransform: (source, columns) => {\n        expect(columns).toEqual(['name', 'handle']);\n        return source;\n      },\n    });\n    await mapper.update().columns(['name', 'handle']).run({\n      name: 'John Doe',\n      handle: 'johndoe',\n      email: 'jdoe@abc.def',", "      handle: 'johndoe',\n      email: 'jdoe@abc.def',\n    });\n  });\n});\n"]}
{"filename": "src/tests/insert-single.test.ts", "chunked_list": ["import { Insertable, Kysely, Selectable, Updateable } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database, Posts } from './utils/test-tables';\nimport {\n  createUserMapperReturningDefault,\n  createUserMapperReturningID,\n  createUserMapperReturningAll,\n  createUserMapperReturningNothing,", "  createUserMapperReturningAll,\n  createUserMapperReturningNothing,\n  createUserMapperReturningDifferently,\n} from './utils/test-mappers';\nimport { USERS, POSTS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\n\nlet db: Kysely<Database>;\n\nlet userMapperReturningDefault: ReturnType<", "\nlet userMapperReturningDefault: ReturnType<\n  typeof createUserMapperReturningDefault\n>;\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\nlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n", "let userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\nlet postTableMapper: TableMapper<\n  Database,\n  'posts',\n  [],\n  ['*'],\n  Selectable<Posts>,\n  Insertable<Posts>,\n  Updateable<Posts>,", "  Insertable<Posts>,\n  Updateable<Posts>,\n  number,\n  ['*']\n>;\nlet postTableMapperReturningIDAndTitleAsT: TableMapper<\n  Database,\n  'posts',\n  [],\n  ['*'],", "  [],\n  ['*'],\n  Selectable<Posts>,\n  Insertable<Posts>,\n  Updateable<Posts>,\n  number,\n  ['id', 'title as t']\n>;\n\nbeforeAll(async () => {", "\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningDefault = createUserMapperReturningDefault(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n  userMapperReturningID = createUserMapperReturningID(db);\n  userMapperReturningAll = createUserMapperReturningAll(db);\n  postTableMapper = new TableMapper(db, 'posts', {\n    insertReturnColumns: ['*'],\n  }).withTransforms({", "    insertReturnColumns: ['*'],\n  }).withTransforms({\n    countTransform: (count) => Number(count),\n  });\n  postTableMapperReturningIDAndTitleAsT = new TableMapper(db, 'posts', {\n    insertReturnColumns: ['id', 'title as t'],\n  }).withTransforms({\n    countTransform: (count) => Number(count),\n  });\n});", "  });\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('inserting a single object without transformation', () => {\n  it('inserts one returning no columns by default', async () => {\n    const success = await userMapperReturningDefault.insert().run(USERS[0]);\n    expect(success).toBe(true);\n", "    expect(success).toBe(true);\n\n    const readUser0 = await userMapperReturningAll\n      .select('email', '=', USERS[0].email!)\n      .returnOne();\n    expect(readUser0?.email).toEqual(USERS[0].email);\n  });\n\n  it('inserts one explicitly returning no columns', async () => {\n    const insertReturn = await userMapperReturningNothing", "  it('inserts one explicitly returning no columns', async () => {\n    const insertReturn = await userMapperReturningNothing\n      .insert()\n      .returnOne(USERS[0]);\n    expect(insertReturn).toBe(undefined);\n\n    const readUser0 = await userMapperReturningAll\n      .select('email', '=', USERS[0].email!)\n      .returnOne();\n    expect(readUser0?.email).toEqual(USERS[0].email);", "      .returnOne();\n    expect(readUser0?.email).toEqual(USERS[0].email);\n\n    ignore('type errors', () => {\n      // @ts-expect-error - check return type\n      insertReturn.id;\n    });\n  });\n\n  it('inserts one returning configured return columns', async () => {\n    const insertReturn1 = await userMapperReturningID\n      .insert()\n      .returnOne(USERS[0]);\n    expect(insertReturn1.id).toBeGreaterThan(0);\n    expect(Object.keys(insertReturn1).length).toEqual(1);\n\n    const readUser0 = await userMapperReturningAll\n      .select('id', '=', insertReturn1.id)\n      .returnOne();\n    expect(readUser0?.email).toEqual(USERS[0].email);\n\n    const post0 = Object.assign({}, POSTS[0], { userId: insertReturn1.id });\n    const insertReturn2 = await postTableMapperReturningIDAndTitleAsT\n      .insert()\n      .returnOne(post0);\n    expect(insertReturn2.id).toBeGreaterThan(0);\n    expect(insertReturn2.t).toEqual(POSTS[0].title);\n    expect(Object.keys(insertReturn2).length).toEqual(2);\n\n    const readPost0 = await postTableMapper\n      .select(({ and, cmpr }) =>\n        and([\n          cmpr('id', '=', insertReturn2.id),\n          cmpr('title', '=', insertReturn2.t),\n        ])\n      )\n      .returnOne();\n    expect(readPost0?.likeCount).toEqual(post0.likeCount);\n\n    ignore('check return types', () => {\n      // @ts-expect-error - check return types\n      insertReturn1.title;\n      // @ts-expect-error - check return types\n      insertReturn1.userId;\n      // @ts-expect-error - check return types\n      insertReturn2.title;\n      // @ts-expect-error - check return types\n      insertReturn2.userId;\n    });\n  });\n\n  it('inserts multiple returning differently for inserts and updates', async () => {\n    const mapper = createUserMapperReturningDifferently(db);\n\n    const insertReturn = await mapper.insert().returnOne(USERS[0]);\n    expect(insertReturn).toEqual({\n      id: 1,\n      handle: USERS[0].handle,\n    });\n    // Ensure that returned objects can be accessed as expected.\n    ((_: number) => {})(insertReturn.id);\n    ((_: string) => {})(insertReturn.handle);\n\n    const newHandle = 'newHandle';\n    const updateReturn = await mapper\n      .update(1)\n      .returnOne({ handle: newHandle });\n    expect(updateReturn).toEqual({\n      name: USERS[0].name,\n    });\n    // Ensure that returned objects can be accessed as expected.\n    ((_: string) => {})(updateReturn!.name);\n", "    ignore('type errors', () => {\n      // @ts-expect-error - check return types\n      insertReturn.name;\n      // @ts-expect-error - check return types\n      updateReturn!.id;\n    });\n  });\n\n  it('inserts one configured to return all columns', async () => {\n    const insertReturn = await userMapperReturningAll\n      .insert()\n      .returnOne(USERS[0]);\n    expect(insertReturn.id).toBeGreaterThan(0);\n    expect(insertReturn.email).toEqual(USERS[0].email);\n    const expectedUser = Object.assign({}, USERS[0], { id: insertReturn.id });\n    expect(insertReturn).toEqual(expectedUser);\n  });\n", "  ignore('detects type errors inserting a single object', async () => {\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().returnOne({});\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().run({});\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().returnOne({ email: 'xyz@pdq.xyz' });\n    // @ts-expect-error - inserted object must have all required columns\n    userMapperReturningAll.insert().run({ email: 'xyz@pdq.xyz' });\n    // @ts-expect-error - only requested columns are returned\n    (await userMapperReturningID.insert().returnOne(USERS[0])).name;\n    // @ts-expect-error - only requested columns are returned\n    (await userMapperReturningDefault.insert().run(USERS[0])).name;\n  });\n});\n"]}
{"filename": "src/tests/update-compile.test.ts", "chunked_list": ["import { Kysely, Updateable } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database, Users } from './utils/test-tables';\nimport {\n  createUserMapperReturningID,\n  createUserMapperReturningIDAndHandleAsH,\n  createUserMapperReturningNothing,\n} from './utils/test-mappers';", "  createUserMapperReturningNothing,\n} from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\nimport { User } from './utils/test-types';\n\nlet db: Kysely<Database>;\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;", "  typeof createUserMapperReturningNothing\n>;\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\nlet userMapperReturningIDAndHandleAsH: ReturnType<\n  typeof createUserMapperReturningIDAndHandleAsH\n>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningNothing = createUserMapperReturningNothing(db);", "  db = await createDB();\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n  userMapperReturningID = createUserMapperReturningID(db);\n  userMapperReturningIDAndHandleAsH =\n    createUserMapperReturningIDAndHandleAsH(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('compiled updates', () => {", "\ndescribe('compiled updates', () => {\n  it('updates nothing returning zero update count', async () => {\n    const updateValues = { email: 'new.email@xyz.pdq' };\n\n    const compilation = userMapperReturningID\n      .update({ id: 1 })\n      .columns(['email'])\n      .compile();\n", "      .compile();\n\n    const success2 = await compilation.run({}, updateValues);\n    expect(success2).toBe(false);\n\n    const updateCount2 = await compilation.returnCount({}, updateValues);\n    expect(updateCount2).toEqual(0);\n\n    const updates2 = await compilation.returnAll({}, updateValues);\n    expect(updates2.length).toEqual(0);", "    const updates2 = await compilation.returnAll({}, updateValues);\n    expect(updates2.length).toEqual(0);\n\n    const update2 = await compilation.returnOne({}, updateValues);\n    expect(update2).toBeNull();\n  });\n\n  it('compilations accept readonly updating objects', async () => {\n    const compilation = userMapperReturningNothing\n      .update('id', '=', 1)", "    const compilation = userMapperReturningNothing\n      .update('id', '=', 1)\n      .columns(['name', 'email'])\n      .compile();\n    const updateValues1 = {\n      name: 'Sue Rex' as const,\n      email: 'srex@abc.def' as const,\n    } as const;\n    await compilation.run({}, updateValues1);\n  });", "    await compilation.run({}, updateValues1);\n  });\n\n  it('compiles a non-returning update query without transformation', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n    const compilation = userMapperReturningNothing\n      .update('id', '=', insertReturns[0].id)\n      .columns(['name', 'email'])\n      .compile();\n", "      .compile();\n\n    // test run()\n    const updateValues1 = {\n      name: 'Sue Rex' as const,\n      email: 'srex@abc.def' as const,\n    } as const;\n    const updateReturns1 = await compilation.run({}, updateValues1);\n    expect(updateReturns1).toBe(true);\n    const readUser1 = await userMapperReturningID", "    expect(updateReturns1).toBe(true);\n    const readUser1 = await userMapperReturningID\n      .select({ id: insertReturns[0].id })\n      .returnOne();\n    expect(readUser1?.name).toEqual(updateValues1.name);\n    expect(readUser1?.email).toEqual(updateValues1.email);\n\n    // test returnOne()\n    const updateValues2 = {\n      name: 'Johnny Rex' as const,", "    const updateValues2 = {\n      name: 'Johnny Rex' as const,\n      email: 'jrex@abc.def' as const,\n    } as const;\n    const updateReturns2 = await compilation.returnOne({}, updateValues2);\n    expect(updateReturns2).toBeUndefined();\n    const readUser2 = await userMapperReturningID\n      .select({ id: insertReturns[0].id })\n      .returnOne();\n    expect(readUser2?.name).toEqual(updateValues2.name);", "      .returnOne();\n    expect(readUser2?.name).toEqual(updateValues2.name);\n    expect(readUser2?.email).toEqual(updateValues2.email);\n\n    // test returnAll()\n    const updateReturns3 = await compilation.returnAll({}, updateValues1);\n    expect(updateReturns3).toBeUndefined();\n\n    // test returnCount()\n    const updateReturns4 = await compilation.returnCount({}, updateValues2);", "    // test returnCount()\n    const updateReturns4 = await compilation.returnCount({}, updateValues2);\n    expect(updateReturns4).toEqual(1);\n  });\n\n  it('compiles a returning update query without transformation', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n    const compilation = userMapperReturningIDAndHandleAsH\n      .update('id', '=', insertReturns[0].id)\n      .columns(['name', 'email'])", "      .update('id', '=', insertReturns[0].id)\n      .columns(['name', 'email'])\n      .compile();\n\n    // test run()\n    const updateValues1 = { name: 'Sue Rex', email: 'srex@abc.def' };\n    const updateReturns1 = await compilation.run({}, updateValues1);\n    expect(updateReturns1).toBe(true);\n    const readUser1 = await userMapperReturningID\n      .select({ id: insertReturns[0].id })", "    const readUser1 = await userMapperReturningID\n      .select({ id: insertReturns[0].id })\n      .returnOne();\n    expect(readUser1?.name).toEqual(updateValues1.name);\n    expect(readUser1?.email).toEqual(updateValues1.email);\n\n    // test returnOne()\n    const updateValues2 = { name: 'Johnny Rex', email: 'jrex@abc.def' };\n    const updateReturns2 = await compilation.returnOne({}, updateValues2);\n    expect(updateReturns2?.id).toEqual(insertReturns[0].id);", "    const updateReturns2 = await compilation.returnOne({}, updateValues2);\n    expect(updateReturns2?.id).toEqual(insertReturns[0].id);\n    expect(updateReturns2?.h).toEqual(USERS[0].handle);\n    const readUser2 = await userMapperReturningID\n      .select({ id: insertReturns[0].id })\n      .returnOne();\n    expect(readUser2?.name).toEqual(updateValues2.name);\n    expect(readUser2?.email).toEqual(updateValues2.email);\n\n    // test returnAll()", "\n    // test returnAll()\n    const updateReturns3 = await compilation.returnAll({}, updateValues1);\n    expect(updateReturns3[0].id).toEqual(insertReturns[0].id);\n    expect(updateReturns3[0].h).toEqual(USERS[0].handle);\n\n    // test returnCount()\n    const updateReturns4 = await compilation.returnCount({}, updateValues2);\n    expect(updateReturns4).toEqual(1);\n", "    expect(updateReturns4).toEqual(1);\n\n    ignore('check compile-time types', () => {\n      compilation.returnOne(\n        {},\n        {\n          name: 'xyz',\n          handle: 'pdq',\n          email: 'abc@def.hij',\n          // @ts-expect-error - only insertable columns are allowed", "          email: 'abc@def.hij',\n          // @ts-expect-error - only insertable columns are allowed\n          notThere: 32,\n        }\n      );\n      // @ts-expect-error - only expected columns are returned\n      updateReturns2!.handle;\n      // @ts-expect-error - only expected columns are returned\n      updateReturns3[0].handle;\n    });", "      updateReturns3[0].handle;\n    });\n  });\n\n  it('accepts readonly parameters and updating objects', async () => {\n    const parameterization = userMapperReturningIDAndHandleAsH.parameterize<{\n      id: number;\n    }>(({ mapper, param }) =>\n      mapper.update({ id: param('id') }).columns(['name'])\n    );", "      mapper.update({ id: param('id') }).columns(['name'])\n    );\n\n    const params = { id: 1 as const } as const;\n    const updateValues = {\n      name: 'Sue Rex' as const,\n      email: 'srex@abc.def' as const,\n    } as const;\n    await parameterization.run(params, updateValues);\n    await parameterization.returnAll(params, updateValues);", "    await parameterization.run(params, updateValues);\n    await parameterization.returnAll(params, updateValues);\n    await parameterization.returnOne(params, updateValues);\n    await parameterization.returnCount(params, updateValues);\n  });\n\n  it('parameterizes a returning update query without transformation', async () => {\n    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\n    const parameterization = userMapperReturningIDAndHandleAsH.parameterize<{", "\n    const parameterization = userMapperReturningIDAndHandleAsH.parameterize<{\n      id: number;\n    }>(({ mapper, param }) =>\n      mapper.update({ id: param('id') }).columns(['name'])\n    );\n\n    // test run()\n    const updateValues1 = { name: 'Sue Rex' };\n    const updateReturns1 = await parameterization.run(", "    const updateValues1 = { name: 'Sue Rex' };\n    const updateReturns1 = await parameterization.run(\n      { id: insertReturns[0].id },\n      updateValues1\n    );\n    expect(updateReturns1).toBe(true);\n\n    // test returnOne()\n    const updateValues2 = { name: 'Johnny Rex' };\n    const updateReturns2 = await parameterization.returnOne(", "    const updateValues2 = { name: 'Johnny Rex' };\n    const updateReturns2 = await parameterization.returnOne(\n      { id: insertReturns[1].id },\n      updateValues2\n    );\n    expect(updateReturns2?.id).toEqual(insertReturns[1].id);\n    expect(updateReturns2?.h).toEqual(USERS[1].handle);\n\n    // test returnAll()\n    const updateReturns3 = await parameterization.returnAll(", "    // test returnAll()\n    const updateReturns3 = await parameterization.returnAll(\n      { id: insertReturns[2].id },\n      updateValues1\n    );\n    expect(updateReturns3[0].id).toEqual(insertReturns[2].id);\n    expect(updateReturns3[0].h).toEqual(USERS[2].handle);\n\n    // verify updates\n    const readUsers = await userMapperReturningID.select().returnAll();", "    // verify updates\n    const readUsers = await userMapperReturningID.select().returnAll();\n    expect(readUsers[0].name).toEqual(updateValues1.name);\n    expect(readUsers[1].name).toEqual(updateValues2.name);\n    expect(readUsers[2].name).toEqual(updateValues1.name);\n\n    // test returnCount()\n    const updateReturns4 = await parameterization.returnCount(\n      { id: insertReturns[0].id },\n      updateValues2", "      { id: insertReturns[0].id },\n      updateValues2\n    );\n    expect(updateReturns4).toEqual(1);\n    const readUser = await userMapperReturningID\n      .select({ id: insertReturns[0].id })\n      .returnOne();\n    expect(readUser?.name).toEqual(updateValues2.name);\n\n    ignore('parameterization type errors', () => {\n      // @ts-expect-error - errors on invalid parameter names\n      parameterization.returnAll({ handle: 'foo' }, updateValues1);\n      // @ts-expect-error - errors on invalid column names\n      updateReturns2!.handle;\n      // @ts-expect-error - errors on invalid column names\n      updateReturns3[0].handle;\n      userMapperReturningIDAndHandleAsH.parameterize<{ id: number }>(\n        ({ mapper, param }) =>\n          // @ts-expect-error - errors on invalid parameter name\n          mapper.update({ id: param('handle') }).columns(['name'])\n      );\n      userMapperReturningIDAndHandleAsH.parameterize<{ id: string }>(\n        ({ mapper, param }) =>\n          // @ts-expect-error - errors on invalid parameter type\n          mapper.update({ id: param('id') }).columns(['name'])\n      );\n      // @ts-expect-error - errors on invalid parameter value name\n      parameterization.returnOne({ handle: 'foo' }, updateValues1);\n      // @ts-expect-error - errors on invalid parameter value type\n      parameterization.returnOne({ id: 'foo' }, updateValues1);\n      parameterization.returnOne(\n        { id: 1 },\n        {\n          name: 'xyz',\n          handle: 'pdq',\n          email: 'abc@def.hij',\n          // @ts-expect-error - only updateable columns are allowed\n          notThere: 32,\n        }\n      );\n    });\n  });\n\n  it('compiles an update query with transformation', async () => {\n    expect.assertions(12);\n\n    const columnSubset: (keyof Updateable<Users>)[] = ['name'];\n    const transformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['*'],\n      updateReturnColumns: ['*'],\n    }).withTransforms({\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return new User(row.id, names[0], names[1], row.handle, row.email);\n      },\n      insertTransform: (source: User) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n      insertReturnTransform: (_source, returns) => {\n        const names = returns.name.split(' ');\n        return new User(\n          returns.id,\n          names[0],\n          names[1],\n          returns.handle,\n          returns.email\n        );\n      },\n      updateTransform: (source: User, columns) => {\n        expect(columns).toEqual(columnSubset);\n        return {\n          name: `${source.firstName} ${source.lastName}`,\n          handle: source.handle,\n          email: source.email,\n        };\n      },\n      updateReturnTransform: (_source, returns) => {\n        const names = returns.name.split(' ');\n        return new User(\n          returns.id,\n          names[0],\n          names[1],\n          returns.handle,\n          returns.email\n        );\n      },\n      countTransform: (count) => Number(count),\n    });\n\n    const user1 = new User(0, 'John', 'Doe', 'johndoe', 'jdoe@abc.def');\n    const user2 = new User(0, 'Sam', 'Gamgee', 'sg', 'sg@abc.def');\n    const user3 = new User(0, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n    const insertReturns = await transformMapper\n      .insert()\n      .returnAll([user1, user2, user3]);\n\n    const compilation = transformMapper\n      .update({ id: insertReturns[2].id })\n      .columns(columnSubset)\n      .compile();\n\n    // test returnOne()\n    const updateReturn1 = await compilation.returnOne({}, user1);\n    const expectedUser1 = User.create(insertReturns[2].id, {\n      firstName: user1.firstName,\n      lastName: user1.lastName,\n      handle: user3.handle,\n      email: user3.email,\n    });\n    expect(updateReturn1).toEqual(expectedUser1);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn1!.firstName);\n    const readUser1 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser1).toEqual(expectedUser1);\n\n    // test returnAll()\n    const updateReturn2 = await compilation.returnAll({}, user2);\n    const expectedUser2 = User.create(insertReturns[2].id, {\n      firstName: user2.firstName,\n      lastName: user2.lastName,\n      handle: user3.handle,\n      email: user3.email,\n    });\n    expect(updateReturn2[0]).toEqual(expectedUser2);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn2[0]!.firstName);\n    const readUser2 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser2).toEqual(expectedUser2);\n\n    // test run()\n    const success1 = await compilation.run({}, user1);\n    expect(success1).toBe(true);\n    const readUser3 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser3).toEqual(expectedUser1);\n\n    // test returnCount()\n    const count = await compilation.returnCount({}, user2);\n    expect(count).toEqual(1);\n    const readUser4 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser4).toEqual(expectedUser2);\n\n    ignore('check compile-time types', async () => {\n      // @ts-expect-error - only update objects are allowed\n      compilation.returnOne({}, USERS[0]);\n      // @ts-expect-error - only update objects are allowed\n      compilation.returnAll({}, USERS[0]);\n      // @ts-expect-error - only update objects are allowed\n      compilation.returnCount({}, USERS[0]);\n      // @ts-expect-error - only update objects are allowed\n      compilation.run({}, USERS[0]);\n      // @ts-expect-error - correct return is expected\n      (await compilation.returnOne({}, user1))!.name;\n      // @ts-expect-error - correct return is expected\n      (await compilation.returnAll({}, user2))[0].name;\n    });\n  });\n\n  it('parameterizes an update query with transformation', async () => {\n    const transformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return new User(row.id, names[0], names[1], row.handle, row.email);\n      },\n      insertTransform: (source: User) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n      insertReturnTransform: (source: User, returns) => ({\n        id: returns.id,\n        firstName: source.firstName,\n        lastName: source.lastName,\n      }),\n      updateTransform: (source: User) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n      updateReturnTransform: (source: User, returns) => ({\n        id: returns.id,\n        firstName: source.firstName,\n        lastName: source.lastName,\n      }),\n      countTransform: (count) => Number(count),\n    });\n\n    const user1 = new User(0, 'John', 'Doe', 'johndoe', 'jdoe@abc.def');\n    const user2 = new User(0, 'Sam', 'Gamgee', 'sg', 'sg@abc.def');\n    const user3 = new User(0, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n    const insertReturns = await transformMapper\n      .insert()\n      .returnAll([user1, user2, user3]);\n\n    const parameterization = transformMapper.parameterize<{ id: number }>(\n      ({ mapper, param }) =>\n        mapper.update({ id: param('id') }).columns(['name'])\n    );\n\n    // test returnOne()\n    const updateReturn1 = await parameterization.returnOne(\n      { id: insertReturns[0].id },\n      user2\n    );\n    const expectedReturn1 = {\n      id: insertReturns[0].id,\n      firstName: user2.firstName,\n      lastName: user2.lastName,\n    };\n    expect(updateReturn1).toEqual(expectedReturn1);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn1!.firstName);\n\n    // test returnAll()\n    const updateReturn2 = await parameterization.returnAll(\n      { id: insertReturns[1].id },\n      user3\n    );\n    const expectedReturn2 = {\n      id: insertReturns[1].id,\n      firstName: user3.firstName,\n      lastName: user3.lastName,\n    };\n    expect(updateReturn2[0]).toEqual(expectedReturn2);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn2[0]!.firstName);\n\n    // test run()\n    const success1 = await parameterization.run(\n      { id: insertReturns[2].id },\n      user1\n    );\n    const expectedReturn3 = {\n      id: insertReturns[2].id,\n      firstName: user1.firstName,\n      lastName: user1.lastName,\n    };\n    expect(success1).toBe(true);\n\n    // verify updates\n    const readUsers = await transformMapper.select().returnAll();\n    expect(readUsers).toEqual([\n      User.create(expectedReturn1.id, {\n        ...expectedReturn1,\n        handle: user1.handle,\n        email: user1.email!,\n      }),\n      User.create(expectedReturn2.id, {\n        ...expectedReturn2,\n        handle: user2.handle,\n        email: user2.email!,\n      }),\n      User.create(expectedReturn3.id, {\n        ...expectedReturn3,\n        handle: user3.handle,\n        email: user3.email!,\n      }),\n    ]);\n\n    // test returnCount()\n    const count = await parameterization.returnCount(\n      { id: insertReturns[2].id },\n      user2\n    );\n    expect(count).toEqual(1);\n    const readUser = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser).toEqual(\n      User.create(insertReturns[2].id, {\n        ...expectedReturn1,\n        handle: user3.handle,\n        email: user3.email!,\n      })\n    );\n", "\n    ignore('parameterization type errors', () => {\n      // @ts-expect-error - errors on invalid parameter names\n      parameterization.returnAll({ handle: 'foo' }, updateValues1);\n      // @ts-expect-error - errors on invalid column names\n      updateReturns2!.handle;\n      // @ts-expect-error - errors on invalid column names\n      updateReturns3[0].handle;\n      userMapperReturningIDAndHandleAsH.parameterize<{ id: number }>(\n        ({ mapper, param }) =>\n          // @ts-expect-error - errors on invalid parameter name\n          mapper.update({ id: param('handle') }).columns(['name'])\n      );\n      userMapperReturningIDAndHandleAsH.parameterize<{ id: string }>(\n        ({ mapper, param }) =>\n          // @ts-expect-error - errors on invalid parameter type\n          mapper.update({ id: param('id') }).columns(['name'])\n      );\n      // @ts-expect-error - errors on invalid parameter value name\n      parameterization.returnOne({ handle: 'foo' }, updateValues1);\n      // @ts-expect-error - errors on invalid parameter value type\n      parameterization.returnOne({ id: 'foo' }, updateValues1);\n      parameterization.returnOne(\n        { id: 1 },\n        {\n          name: 'xyz',\n          handle: 'pdq',\n          email: 'abc@def.hij',\n          // @ts-expect-error - only updateable columns are allowed\n          notThere: 32,\n        }\n      );\n    });\n  });\n\n  it('compiles an update query with transformation', async () => {\n    expect.assertions(12);\n\n    const columnSubset: (keyof Updateable<Users>)[] = ['name'];\n    const transformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['*'],\n      updateReturnColumns: ['*'],\n    }).withTransforms({\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return new User(row.id, names[0], names[1], row.handle, row.email);\n      },\n      insertTransform: (source: User) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n      insertReturnTransform: (_source, returns) => {\n        const names = returns.name.split(' ');\n        return new User(\n          returns.id,\n          names[0],\n          names[1],\n          returns.handle,\n          returns.email\n        );\n      },\n      updateTransform: (source: User, columns) => {\n        expect(columns).toEqual(columnSubset);\n        return {\n          name: `${source.firstName} ${source.lastName}`,\n          handle: source.handle,\n          email: source.email,\n        };\n      },\n      updateReturnTransform: (_source, returns) => {\n        const names = returns.name.split(' ');\n        return new User(\n          returns.id,\n          names[0],\n          names[1],\n          returns.handle,\n          returns.email\n        );\n      },\n      countTransform: (count) => Number(count),\n    });\n\n    const user1 = new User(0, 'John', 'Doe', 'johndoe', 'jdoe@abc.def');\n    const user2 = new User(0, 'Sam', 'Gamgee', 'sg', 'sg@abc.def');\n    const user3 = new User(0, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n    const insertReturns = await transformMapper\n      .insert()\n      .returnAll([user1, user2, user3]);\n\n    const compilation = transformMapper\n      .update({ id: insertReturns[2].id })\n      .columns(columnSubset)\n      .compile();\n\n    // test returnOne()\n    const updateReturn1 = await compilation.returnOne({}, user1);\n    const expectedUser1 = User.create(insertReturns[2].id, {\n      firstName: user1.firstName,\n      lastName: user1.lastName,\n      handle: user3.handle,\n      email: user3.email,\n    });\n    expect(updateReturn1).toEqual(expectedUser1);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn1!.firstName);\n    const readUser1 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser1).toEqual(expectedUser1);\n\n    // test returnAll()\n    const updateReturn2 = await compilation.returnAll({}, user2);\n    const expectedUser2 = User.create(insertReturns[2].id, {\n      firstName: user2.firstName,\n      lastName: user2.lastName,\n      handle: user3.handle,\n      email: user3.email,\n    });\n    expect(updateReturn2[0]).toEqual(expectedUser2);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn2[0]!.firstName);\n    const readUser2 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser2).toEqual(expectedUser2);\n\n    // test run()\n    const success1 = await compilation.run({}, user1);\n    expect(success1).toBe(true);\n    const readUser3 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser3).toEqual(expectedUser1);\n\n    // test returnCount()\n    const count = await compilation.returnCount({}, user2);\n    expect(count).toEqual(1);\n    const readUser4 = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser4).toEqual(expectedUser2);\n\n    ignore('check compile-time types', async () => {\n      // @ts-expect-error - only update objects are allowed\n      compilation.returnOne({}, USERS[0]);\n      // @ts-expect-error - only update objects are allowed\n      compilation.returnAll({}, USERS[0]);\n      // @ts-expect-error - only update objects are allowed\n      compilation.returnCount({}, USERS[0]);\n      // @ts-expect-error - only update objects are allowed\n      compilation.run({}, USERS[0]);\n      // @ts-expect-error - correct return is expected\n      (await compilation.returnOne({}, user1))!.name;\n      // @ts-expect-error - correct return is expected\n      (await compilation.returnAll({}, user2))[0].name;\n    });\n  });\n\n  it('parameterizes an update query with transformation', async () => {\n    const transformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return new User(row.id, names[0], names[1], row.handle, row.email);\n      },\n      insertTransform: (source: User) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n      insertReturnTransform: (source: User, returns) => ({\n        id: returns.id,\n        firstName: source.firstName,\n        lastName: source.lastName,\n      }),\n      updateTransform: (source: User) => ({\n        name: `${source.firstName} ${source.lastName}`,\n        handle: source.handle,\n        email: source.email,\n      }),\n      updateReturnTransform: (source: User, returns) => ({\n        id: returns.id,\n        firstName: source.firstName,\n        lastName: source.lastName,\n      }),\n      countTransform: (count) => Number(count),\n    });\n\n    const user1 = new User(0, 'John', 'Doe', 'johndoe', 'jdoe@abc.def');\n    const user2 = new User(0, 'Sam', 'Gamgee', 'sg', 'sg@abc.def');\n    const user3 = new User(0, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n    const insertReturns = await transformMapper\n      .insert()\n      .returnAll([user1, user2, user3]);\n\n    const parameterization = transformMapper.parameterize<{ id: number }>(\n      ({ mapper, param }) =>\n        mapper.update({ id: param('id') }).columns(['name'])\n    );\n\n    // test returnOne()\n    const updateReturn1 = await parameterization.returnOne(\n      { id: insertReturns[0].id },\n      user2\n    );\n    const expectedReturn1 = {\n      id: insertReturns[0].id,\n      firstName: user2.firstName,\n      lastName: user2.lastName,\n    };\n    expect(updateReturn1).toEqual(expectedReturn1);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn1!.firstName);\n\n    // test returnAll()\n    const updateReturn2 = await parameterization.returnAll(\n      { id: insertReturns[1].id },\n      user3\n    );\n    const expectedReturn2 = {\n      id: insertReturns[1].id,\n      firstName: user3.firstName,\n      lastName: user3.lastName,\n    };\n    expect(updateReturn2[0]).toEqual(expectedReturn2);\n    // Ensure that the provided columns are accessible\n    ((_: string) => {})(updateReturn2[0]!.firstName);\n\n    // test run()\n    const success1 = await parameterization.run(\n      { id: insertReturns[2].id },\n      user1\n    );\n    const expectedReturn3 = {\n      id: insertReturns[2].id,\n      firstName: user1.firstName,\n      lastName: user1.lastName,\n    };\n    expect(success1).toBe(true);\n\n    // verify updates\n    const readUsers = await transformMapper.select().returnAll();\n    expect(readUsers).toEqual([\n      User.create(expectedReturn1.id, {\n        ...expectedReturn1,\n        handle: user1.handle,\n        email: user1.email!,\n      }),\n      User.create(expectedReturn2.id, {\n        ...expectedReturn2,\n        handle: user2.handle,\n        email: user2.email!,\n      }),\n      User.create(expectedReturn3.id, {\n        ...expectedReturn3,\n        handle: user3.handle,\n        email: user3.email!,\n      }),\n    ]);\n\n    // test returnCount()\n    const count = await parameterization.returnCount(\n      { id: insertReturns[2].id },\n      user2\n    );\n    expect(count).toEqual(1);\n    const readUser = await transformMapper\n      .select({ id: insertReturns[2].id })\n      .returnOne();\n    expect(readUser).toEqual(\n      User.create(insertReturns[2].id, {\n        ...expectedReturn1,\n        handle: user3.handle,\n        email: user3.email!,\n      })\n    );\n", "    ignore('parameterization type errors', () => {\n      // @ts-expect-error - errors on invalid parameter names\n      parameterization.returnAll({ handle: 'foo' }, user1);\n      // @ts-expect-error - errors on invalid column names\n      updateReturn1!.handle;\n      // @ts-expect-error - errors on invalid column names\n      updateReturn2[0].handle;\n      transformMapper.parameterize<{ id: number }>(({ mapper, param }) =>\n        // @ts-expect-error - errors on invalid parameter name\n        mapper.update({ id: param('handle') }).columns(['name'])\n      );\n      transformMapper.parameterize<{ id: string }>(({ mapper, param }) =>\n        // @ts-expect-error - errors on invalid parameter type\n        mapper.update({ id: param('id') }).columns(['name'])\n      );\n      // @ts-expect-error - errors on invalid parameter value name\n      parameterization.returnOne({ handle: 'foo' }, user1);\n      // @ts-expect-error - errors on invalid parameter value type\n      parameterization.returnOne({ id: 'foo' }, user1);\n      parameterization.returnOne(\n        { id: 1 },\n        {\n          // @ts-expect-error - only updateable columns are allowed\n          name: 'xyz',\n          handle: 'pdq',\n          email: 'abc@def.hij',\n        }\n      );\n    });\n  });\n\n  it('requires all indicated columns to be updated', async () => {\n    await userMapperReturningID.insert().run(USERS);\n\n    const compilation = userMapperReturningID\n      .update()\n      .columns(['name', 'handle', 'email'])\n      .compile();\n\n    const updateValues = { name: 'John Doe', handle: 'johndoe' };\n\n    expect(() => compilation.returnOne({}, updateValues)).rejects.toThrow(\n      `column 'email' missing`\n    );\n\n    const success = await compilation.run({}, { ...updateValues, email: null });\n    expect(success).toBe(true);\n  });\n});\n"]}
{"filename": "src/tests/insert-transforms.test.ts", "chunked_list": ["import { Kysely, Updateable } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport { createInsertTransformMapper } from './utils/test-mappers';\nimport {\n  userRow1,\n  userRow2,\n  userRow3,", "  userRow2,\n  userRow3,\n  insertedUser1,\n  insertedUser2,\n  insertedUser3,\n  insertReturnedUser1,\n  insertReturnedUser2,\n  insertReturnedUser3,\n} from './utils/test-objects';\nimport { InsertedUser, ReturnedUser, SelectedUser } from './utils/test-types';", "} from './utils/test-objects';\nimport { InsertedUser, ReturnedUser, SelectedUser } from './utils/test-types';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));", "beforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('inserting with transformation', () => {\n  it('transforms users for insertion without transforming return', async () => {\n    const insertTransformMapper = createInsertTransformMapper(db);\n\n    const insertReturn = await insertTransformMapper\n      .insert()\n      .returnOne(insertedUser1);", "      .insert()\n      .returnOne(insertedUser1);\n    const readUser1 = await insertTransformMapper\n      .select({\n        id: insertReturn.id,\n      })\n      .returnOne();\n    expect(readUser1?.name).toEqual(\n      `${insertedUser1.firstName} ${insertedUser1.lastName}`\n    );", "      `${insertedUser1.firstName} ${insertedUser1.lastName}`\n    );\n\n    await insertTransformMapper\n      .insert()\n      .returnAll([insertedUser2, insertedUser3]);\n    const readUsers = await insertTransformMapper\n      .select('id', '>', insertReturn.id)\n      .returnAll();\n    expect(readUsers.length).toEqual(2);", "      .returnAll();\n    expect(readUsers.length).toEqual(2);\n    expect(readUsers[0].name).toEqual(\n      `${insertedUser2.firstName} ${insertedUser2.lastName}`\n    );\n    expect(readUsers[1].name).toEqual(\n      `${insertedUser3.firstName} ${insertedUser3.lastName}`\n    );\n  });\n", "  });\n\n  it('transforms insertion return into object without transforming insertion', async () => {\n    const insertReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id', 'name'],\n      updateReturnColumns: ['id', 'name'],\n    }).withTransforms({\n      insertReturnTransform: (source, returns) => {\n        const names = returns.name.split(' ');\n        return new ReturnedUser(", "        const names = returns.name.split(' ');\n        return new ReturnedUser(\n          returns.id,\n          names[0],\n          names[1],\n          source.handle,\n          source.email || null\n        );\n      },\n      countTransform: (count) => Number(count),", "      },\n      countTransform: (count) => Number(count),\n    });\n\n    const insertReturn = await insertReturnTransformMapper\n      .insert()\n      .returnOne(userRow1);\n    expect(insertReturn).toEqual(insertReturnedUser1);\n\n    const insertReturns = await insertReturnTransformMapper", "\n    const insertReturns = await insertReturnTransformMapper\n      .insert()\n      .returnAll([userRow2, userRow3]);\n    expect(insertReturns).toEqual([insertReturnedUser2, insertReturnedUser3]);\n\n    // test that updates return table rows\n    const updatedUser = await insertReturnTransformMapper\n      .update({ id: insertReturn.id })\n      .returnOne({ name: 'Updated Name' });", "      .update({ id: insertReturn.id })\n      .returnOne({ name: 'Updated Name' });\n    expect(updatedUser).toEqual({ id: insertReturn.id, name: 'Updated Name' });\n    // ensure return type can be accessed as a row\n    ((_: string) => {})(updatedUser!.name);\n  });\n\n  it('transforms insertion return into primitive without transforming insertion', async () => {\n    const insertReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n    }).withTransforms({\n      insertReturnTransform: (_source, returns) => returns.id,\n      countTransform: (count) => Number(count),\n    });\n\n    const insertReturn = await insertReturnTransformMapper\n      .insert()\n      .returnOne(userRow1);\n    expect(insertReturn).toEqual(1);", "    // ensure return type can be accessed as a number\n    ((_: number) => {})(insertReturn);\n\n    const insertReturns = await insertReturnTransformMapper\n      .insert()\n      .returnAll([userRow2, userRow3]);\n    expect(insertReturns).toEqual([2, 3]);\n    // ensure return type can be accessed as a number\n    ((_: number) => {})(insertReturns[0]);\n  });\n\n  it(\"transforms insertion and insertion return, columns is ['*']\", async () => {\n    expect.assertions(5);\n    const insertAndReturnTransformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id'],\n    }).withTransforms({\n      insertTransform: (source: InsertedUser, columns) => {\n        expect(columns).toEqual(['*']);\n        return {\n          name: `${source.firstName} ${source.lastName}`,\n          handle: source.handle,\n          email: source.email,\n        };\n      },\n      insertReturnTransform: (source: InsertedUser, returns) =>\n        new ReturnedUser(\n          returns.id,\n          source.firstName,\n          source.lastName,\n          source.handle,\n          source.email\n        ),\n      countTransform: (count) => Number(count),\n    });\n\n    const insertReturn = await insertAndReturnTransformMapper\n      .insert()\n      .returnOne(insertedUser1);\n    expect(insertReturn).toEqual(insertReturnedUser1);", "    // ensure return type can be accessed as a ReturnedUser\n    ((_: string) => {})(insertReturn.firstName);\n\n    const insertReturns = await insertAndReturnTransformMapper\n      .insert()\n      .returnAll([insertedUser2, insertedUser3]);\n    expect(insertReturns).toEqual([insertReturnedUser2, insertReturnedUser3]);\n    // ensure return type can be accessed as a ReturnedUser\n    ((_: string) => {})(insertReturns[0].firstName);\n  });\n\n  it('returns SelectedObject with updates returning rows', async () => {\n    const transformMapper = new TableMapper(db, 'users', {\n      insertReturnColumns: ['id', 'name'],\n      updateReturnColumns: ['id', 'name'],\n    }).withTransforms({\n      insertReturnTransform: (source, results) => {\n        const names = results.name.split(' ');\n        return SelectedUser.create(results.id, {\n          firstName: names[0],\n          lastName: names[1],\n          handle: source.handle,\n          email: source.email || null,\n        });\n      },\n      updateTransform: (\n        source: SelectedUser | Updateable<Database['users']>\n      ) => {", "        if (source instanceof SelectedUser) {\n          return {\n            name: `${source.firstName} ${source.lastName}`,\n            handle: source.handle,\n            email: source.email,\n          };\n        }\n        return source;\n      },\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return SelectedUser.create(row.id, {\n          firstName: names[0],\n          lastName: names[1],\n          handle: row.handle,\n          email: row.email,\n        });\n      },\n    });\n\n    // test returnOne()\n    const names1 = userRow1.name.split(' ');\n    const expectedUser1 = SelectedUser.create(1, {\n      firstName: names1[0],\n      lastName: names1[1],\n      handle: userRow1.handle,\n      email: userRow1.email,\n    });\n    const insertReturn = await transformMapper.insert().returnOne(userRow1);\n    expect(insertReturn).toEqual(expectedUser1);", "    // ensure return type can be accessed as a SelectedUser\n    ((_: string) => {})(insertReturn.firstName);\n\n    const readUser = await transformMapper\n      .select({\n        id: insertReturn.id,\n      })\n      .returnOne();\n    expect(readUser).toEqual(expectedUser1);\n\n    // test returnAll()\n    const names2 = userRow2.name.split(' ');\n    const expectedUser2 = SelectedUser.create(2, {\n      firstName: names2[0],\n      lastName: names2[1],\n      handle: userRow2.handle,\n      email: userRow2.email,\n    });\n    const names3 = userRow3.name.split(' ');\n    const expectedUser3 = SelectedUser.create(3, {\n      firstName: names3[0],\n      lastName: names3[1],\n      handle: userRow3.handle,\n      email: userRow3.email,\n    });\n    const insertReturns = await transformMapper\n      .insert()\n      .returnAll([userRow2, userRow3]);\n    expect(insertReturns).toEqual([expectedUser2, expectedUser3]);", "    // ensure return type can be accessed as a SelectedUser\n    ((_: string) => {})(insertReturns[0].firstName);\n    ((_: string) => {})(insertReturns[1].firstName);\n\n    const readUsers = await transformMapper\n      .select('id', '>', insertReturn.id)\n      .returnAll();\n    expect(readUsers).toEqual([expectedUser2, expectedUser3]);\n\n    // test that updates return rows\n    const updateReturn = await transformMapper\n      .update({ id: 1 })\n      .returnOne(expectedUser2);\n    expect(updateReturn).toEqual({\n      id: 1,\n      name: `${expectedUser2.firstName} ${expectedUser2.lastName}`,\n    });", "    // ensure return type can be accessed as a row\n    ((_: string) => {})(updateReturn!.name);\n  });\n});\n"]}
{"filename": "src/tests/delete.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport {\n  createUserMapperReturningAll,\n  createUserMapperReturningDefault,\n  createUserMapperReturningNothing,\n} from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';", "} from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\nimport { TableMapper } from '../mappers/table-mapper';\n\nlet db: Kysely<Database>;\nlet userMapper: ReturnType<typeof createUserMapperReturningAll>;\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;", "  typeof createUserMapperReturningNothing\n>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapper = createUserMapperReturningAll(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));", "beforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('deleting rows via TableMapper', () => {\n  it('accepts readonly filters', async () => {\n    const filter = { name: 'Not There' as const } as const;\n    await userMapper.delete(filter).run();\n    await userMapper.delete(filter).returnCount();\n  });\n", "  });\n\n  it(\"doesn't delete anything if no rows match\", async () => {\n    const count = await userMapper\n      .delete({ name: USERS[0].name })\n      .returnCount();\n    expect(count).toEqual(0);\n\n    const success = await userMapper.delete({ name: USERS[0].name }).run();\n    expect(success).toEqual(false);", "    const success = await userMapper.delete({ name: USERS[0].name }).run();\n    expect(success).toEqual(false);\n  });\n\n  it('deletes rows without returning a count', async () => {\n    const testMapper = new TableMapper(db, 'users').withTransforms({\n      countTransform: (count) => Number(count),\n    });\n    await testMapper.insert().run(USERS);\n", "    await testMapper.insert().run(USERS);\n\n    const success = await testMapper.delete({ name: USERS[0].name }).run();\n    expect(success).toBe(true);\n\n    const users = await testMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n  });\n", "  });\n\n  it('deletes rows returning the deletion count as bigint default', async () => {\n    const defaultMapper = createUserMapperReturningDefault(db);\n\n    const count1 = await defaultMapper\n      .delete({ name: USERS[0].name })\n      .returnCount();\n    expect(count1).toEqual(BigInt(0));\n", "    expect(count1).toEqual(BigInt(0));\n\n    await defaultMapper.insert().run(USERS);\n\n    const count2 = await defaultMapper\n      .delete({ name: USERS[0].name })\n      .returnCount();\n    expect(count2).toEqual(BigInt(2));\n    const users = await defaultMapper.select().returnAll();\n    expect(users.length).toEqual(1);", "    const users = await defaultMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n  });\n\n  it('deletes rows returning the deletion count inferred as a number', async () => {\n    const testMapper = new TableMapper(db, 'users').withTransforms({\n      countTransform: (count) => Number(count),\n    });\n    await testMapper.insert().run(USERS);", "    });\n    await testMapper.insert().run(USERS);\n\n    const count = await testMapper\n      .delete({ name: USERS[0].name })\n      .returnCount();\n    expect(count).toEqual(2);\n  });\n\n  it('deletes rows returning the deletion count as number', async () => {", "\n  it('deletes rows returning the deletion count as number', async () => {\n    const count1 = await userMapper\n      .delete({ name: USERS[0].name })\n      .returnCount();\n    expect(count1).toEqual(0);\n\n    await userMapper.insert().run(USERS);\n\n    const count2 = await userMapper", "\n    const count2 = await userMapper\n      .delete({ name: USERS[0].name })\n      .returnCount();\n    expect(count2).toEqual(2);\n    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n  });\n", "  });\n\n  it('deletes all rows without a filter', async () => {\n    await userMapper.insert().run(USERS);\n    const count1 = await userMapper.delete().returnCount();\n    expect(count1).toEqual(3);\n    const users1 = await userMapper.select().returnAll();\n    expect(users1.length).toEqual(0);\n\n    await userMapper.insert().run(USERS);", "\n    await userMapper.insert().run(USERS);\n    const success = await userMapper.delete().run();\n    expect(success).toBe(true);\n    const users2 = await userMapper.select().returnAll();\n    expect(users2.length).toEqual(0);\n  });\n\n  it('deletes rows specified via compound filter', async () => {\n    await userMapper.insert().run(USERS);", "  it('deletes rows specified via compound filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    const count1 = await userMapper\n      .delete(({ and, cmpr }) =>\n        and([\n          cmpr('name', '=', USERS[0].name),\n          cmpr('handle', '=', USERS[0].handle),\n        ])\n      )", "        ])\n      )\n      .returnCount();\n    expect(count1).toEqual(1);\n\n    const count2 = await userMapper\n      .delete(({ or, cmpr }) =>\n        or([\n          cmpr('name', '=', USERS[0].name),\n          cmpr('handle', '=', USERS[0].handle),", "          cmpr('name', '=', USERS[0].name),\n          cmpr('handle', '=', USERS[0].handle),\n        ])\n      )\n      .returnCount();\n    expect(count2).toEqual(1);\n  });\n\n  it('deletes rows specified via binary operation', async () => {\n    await userMapper.insert().run(USERS);", "  it('deletes rows specified via binary operation', async () => {\n    await userMapper.insert().run(USERS);\n\n    const count1 = await userMapper\n      .delete('name', '=', USERS[0].name)\n      .returnCount();\n    expect(count1).toEqual(2);\n\n    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(1);", "    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n  });\n\n  it('modifies a delete query builder', async () => {\n    await userMapper.insert().run(USERS);\n    await userMapper.insert().run({ ...USERS[1], handle: 'user4' });\n\n    const count1 = await userMapper", "\n    const count1 = await userMapper\n      .delete()\n      .modify((qb) => qb.where('name', '=', USERS[0].name))\n      .returnCount();\n    expect(count1).toEqual(2);\n\n    const count2 = await userMapper\n      .delete({ name: USERS[1].name })\n      .modify((qb) => qb.where('handle', '=', 'user4'))", "      .delete({ name: USERS[1].name })\n      .modify((qb) => qb.where('handle', '=', 'user4'))\n      .returnCount();\n    expect(count2).toEqual(1);\n\n    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n  });\n\n  it('compiles an unparameterized delete query', async () => {", "\n  it('compiles an unparameterized delete query', async () => {\n    await userMapper.insert().run(USERS);\n\n    const compilation = userMapper.delete({ name: USERS[0].name }).compile();\n    const count1 = await compilation.returnCount({});\n    expect(count1).toEqual(2);\n    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);", "    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n\n    await userMapper.insert().run(USERS[2]);\n\n    const success = await compilation.run({});\n    expect(success).toBe(true);\n    const users2 = await userMapper.select().returnAll();\n    expect(users2.length).toEqual(1);\n    expect(users2[0].handle).toEqual(USERS[1].handle);", "    expect(users2.length).toEqual(1);\n    expect(users2[0].handle).toEqual(USERS[1].handle);\n  });\n\n  it('parameterizes and compiles a delete query', async () => {\n    const parameterization = userMapper.parameterize<{ targetName: string }>(\n      ({ mapper, param }) => mapper.delete({ name: param('targetName') })\n    );\n\n    const count1 = await parameterization.returnCount({", "\n    const count1 = await parameterization.returnCount({\n      targetName: USERS[0].name,\n    });\n    expect(count1).toEqual(0);\n\n    await userMapper.insert().run(USERS);\n\n    const count2 = await parameterization.returnCount({\n      targetName: USERS[0].name,", "    const count2 = await parameterization.returnCount({\n      targetName: USERS[0].name,\n    });\n    expect(count2).toEqual(2);\n    const users = await userMapper.select().returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].handle).toEqual(USERS[1].handle);\n\n    const count3 = await parameterization.returnCount({\n      targetName: USERS[1].name,", "    const count3 = await parameterization.returnCount({\n      targetName: USERS[1].name,\n    });\n    expect(count3).toEqual(1);\n    const users2 = await userMapper.select().returnAll();\n    expect(users2.length).toEqual(0);\n\n    ignore('parameterization type errors', () => {\n      // @ts-expect-error - errors on invalid parameter names\n      parameterization.run({ notThere: 'foo' });\n      userMapper.parameterize<{ name: string }>(\n        // @ts-expect-error - errors on invalid parameter name\n        ({ mapper, param }) => mapper.select({ name: param('notThere') })\n      );\n      userMapper.parameterize<{ name: number }>(\n        // @ts-expect-error - errors on invalid parameter type\n        ({ mapper, param }) => mapper.select({ name: param('name') })\n      );\n      // @ts-expect-error - errors on invalid parameter value name\n      parameterization.run({ notThere: 'foo' });\n      // @ts-expect-error - errors on invalid parameter value type\n      parameterization.run({ targetName: 123 });\n    });\n  });\n", "  ignore('detects deletion type errors', async () => {\n    // @ts-expect-error - table must have all filter fields\n    userMapper.delete({ notThere: 'xyz' });\n    // @ts-expect-error - table must have all filter fields\n    userMapper.delete('notThere', '=', 'foo');\n    userMapper.delete(({ or, cmpr }) =>\n      // @ts-expect-error - only table columns are accessible via anyOf()\n      or([cmpr('notThere', '=', 'xyz'), cmpr('alsoNotThere', '=', 'Sue')])\n    );\n    userMapper.delete(({ or, cmpr }) =>\n      // @ts-expect-error - only table columns are accessible via allOf()\n      or([cmpr('notThere', '=', 'xyz'), cmpr('alsoNotThere', '=', 'Sue')])\n    );\n    // @ts-expect-error - ID filter must have correct type\n    userMapper.delete('str');\n    // @ts-expect-error - ID filter must have correct type\n    userMapper.delete(['str']);\n    // @ts-expect-error - ID filter not allowed when when no ID column\n    userMapperReturningNothing.delete(1);\n    // @ts-expect-error - ID filter not allowed when when no ID column\n    userMapperReturningNothing.delete([1]);\n  });\n});\n"]}
{"filename": "src/tests/select-general.test.ts", "chunked_list": ["/**\n * Tests TableMapper.selectMany(), TableMapper.selectOne(), and query filters.\n */\n\nimport { Kysely } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport {", "import { Database } from './utils/test-tables';\nimport {\n  createUserMapperReturningID,\n  createUserMapperReturningNothing,\n} from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\n\nlet db: Kysely<Database>;\nlet userMapper: ReturnType<typeof createUserMapperReturningID>;", "let db: Kysely<Database>;\nlet userMapper: ReturnType<typeof createUserMapperReturningID>;\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;\n\nbeforeAll(async () => {\n  db = await createDB();\n  userMapper = createUserMapperReturningID(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);", "  userMapper = createUserMapperReturningID(db);\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('general selection', () => {\n  it('compiles an unparameterized select query', async () => {\n    await userMapper.insert().run(USERS);\n", "    await userMapper.insert().run(USERS);\n\n    const compilation = userMapper.select({ name: USERS[0].name }).compile();\n\n    const users = await compilation.returnAll({});\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[0].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n    // Ensure that the provided columns are not optional\n    ((_: string) => {})(users[0].handle);", "    // Ensure that the provided columns are not optional\n    ((_: string) => {})(users[0].handle);\n\n    const user = await compilation.returnOne({});\n    expect(user?.handle).toEqual(USERS[0].handle);\n    // Ensure that the provided columns are not optional\n    ((_: string) => {})(user!.name);\n\n    ignore('compilation type errors', () => {\n      // @ts-expect-error - errors on invalid column names\n      users[0].notThere;\n      // @ts-expect-error - errors on invalid column names\n      user!.notThere;\n    });\n  });\n\n  it('parameterizes and compiles a select query', async () => {\n    await userMapper.insert().run(USERS);\n\n    const parameterization = userMapper.parameterize<{ name: string }>(\n      ({ mapper, param }) => mapper.select({ name: param('name') })\n    );\n\n    // test returnAll() returning multiple\n    const users = await parameterization.returnAll({ name: USERS[0].name });\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[0].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n    // Ensure that the provided columns are not optional\n    ((_: string) => {})(users[0].handle);\n\n    // test returnAll() returning none\n    const users2 = await parameterization.returnAll({ name: 'not there' });\n    expect(users2.length).toEqual(0);\n\n    // test returnOne() returning one\n    const user = await parameterization.returnOne({ name: USERS[1].name });\n    expect(user?.handle).toEqual(USERS[1].handle);\n    // Ensure that the provided columns are not optional\n    ((_: string) => {})(user!.name);\n\n    // test returnOne() returning none\n    const user2 = await parameterization.returnOne({ name: 'not there' });\n    expect(user2).toBeNull();\n", "    ignore('compilation type errors', () => {\n      // @ts-expect-error - errors on invalid column names\n      users[0].notThere;\n      // @ts-expect-error - errors on invalid column names\n      user!.notThere;\n    });\n  });\n\n  it('parameterizes and compiles a select query', async () => {\n    await userMapper.insert().run(USERS);\n\n    const parameterization = userMapper.parameterize<{ name: string }>(\n      ({ mapper, param }) => mapper.select({ name: param('name') })\n    );\n\n    // test returnAll() returning multiple\n    const users = await parameterization.returnAll({ name: USERS[0].name });\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[0].handle);\n    expect(users[1].handle).toEqual(USERS[2].handle);\n    // Ensure that the provided columns are not optional\n    ((_: string) => {})(users[0].handle);\n\n    // test returnAll() returning none\n    const users2 = await parameterization.returnAll({ name: 'not there' });\n    expect(users2.length).toEqual(0);\n\n    // test returnOne() returning one\n    const user = await parameterization.returnOne({ name: USERS[1].name });\n    expect(user?.handle).toEqual(USERS[1].handle);\n    // Ensure that the provided columns are not optional\n    ((_: string) => {})(user!.name);\n\n    // test returnOne() returning none\n    const user2 = await parameterization.returnOne({ name: 'not there' });\n    expect(user2).toBeNull();\n", "    ignore('parameterization type errors', () => {\n      // @ts-expect-error - errors on invalid parameter names\n      parameterization.returnAll({ notThere: 'foo' });\n      // @ts-expect-error - errors on invalid column names\n      users[0].notThere;\n      // @ts-expect-error - errors on invalid column names\n      user!.notThere;\n      userMapper.parameterize<{ name: string }>(\n        // @ts-expect-error - errors on invalid parameter name\n        ({ mapper, param }) => mapper.select({ name: param('notThere') })\n      );\n      userMapper.parameterize<{ name: number }>(\n        // @ts-expect-error - errors on invalid parameter type\n        ({ mapper, param }) => mapper.select({ name: param('name') })\n      );\n      // @ts-expect-error - errors on invalid parameter value name\n      parameterization.returnOne({ notThere: 'foo' });\n      // @ts-expect-error - errors on invalid parameter value type\n      parameterization.returnOne({ name: 123 });\n    });\n  });\n\n  it('modifies the underlying query builder', async () => {\n    await userMapper.insert().run(USERS);\n\n    const users = await userMapper\n      .select()\n      .modify((qb) =>\n        qb.where('name', '=', USERS[0].name).orderBy('handle', 'desc')\n      )\n      .returnAll();\n    expect(users.length).toEqual(2);\n    expect(users[0].handle).toEqual(USERS[2].handle);\n    expect(users[1].handle).toEqual(USERS[0].handle);\n\n    const user = await userMapper\n      .select()\n      .modify((qb) =>\n        qb.where('name', '=', USERS[0].name).orderBy('handle', 'desc')\n      )\n      .returnOne();\n    expect(user?.handle).toEqual(USERS[2].handle);\n  });\n\n  it('does not modify the underlying selected columns', async () => {\n    await userMapper.insert().run(USERS);\n\n    const users = await userMapper\n      .select()\n      .modify((qb) => qb.select('name').orderBy('handle', 'desc'))\n      .returnAll();\n    expect(users).toEqual([\n      { ...USERS[2], id: 3 },\n      { ...USERS[1], id: 2 },\n      { ...USERS[0], id: 1 },\n    ]);\n    // Ensure that columns can be addressed by name.\n    ((_: number) => {})(users[0].id);\n    ((_: string) => {})(users[0].handle);\n    ((_: string) => {})(users[0].name);\n    ((_: string) => {})(users[0].email!);\n\n    const user = await userMapper\n      .select()\n      .modify((qb) => qb.select('name').orderBy('handle', 'desc'))\n      .returnOne();\n    expect(user).toEqual({ ...USERS[2], id: 3 });\n    // Ensure that columns can be addressed by name.\n    ((_: number) => {})(user!.id);\n    ((_: string) => {})(user!.handle);\n    ((_: string) => {})(user!.name);\n    ((_: string) => {})(user!.email!);\n", "    ignore('detects modify() type errors', async () => {\n      // @ts-expect-error - cannot access invalid columns\n      users[0].notThere;\n      // @ts-expect-error - cannot access invalid columns\n      user!.notThere;\n    });\n  });\n\n  it('selects via a multi-column key tuple (definition order)', async () => {\n    const mapper = new TableMapper(db, 'users', {\n      keyColumns: ['id', 'name'],\n    });\n    await mapper.insert().run(USERS);\n\n    const users = await mapper.select([3, 'Sue']).returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].name).toEqual(USERS[2].name);\n", "    ignore('detects key colum tuple type errors', () => {\n      // @ts-expect-error - key tuple must have correct length\n      mapper.select(['Sue']);\n      // @ts-expect-error - key tuple must have correct length\n      mapper.select(['Sue', 3, 'foo']);\n      // @ts-expect-error - key tuple must have correct types\n      mapper.select(['Sue', 'foo']);\n      // @ts-expect-error - primitive key values are not allowed\n      mapper.select('Sue');\n      // @ts-expect-error - primitive key values are not allowed\n      mapper.select(1);\n    });\n  });\n\n  it('selects via a multi-column key tuple (different order)', async () => {\n    const mapper = new TableMapper(db, 'users', {\n      keyColumns: ['name', 'id'],\n    });\n    await mapper.insert().run(USERS);\n\n    const users = await mapper.select(['Sue', 3]).returnAll();\n    expect(users.length).toEqual(1);\n    expect(users[0].name).toEqual(USERS[2].name);\n", "    ignore('detects key colum tuple type errors', () => {\n      // @ts-expect-error - key tuple must have correct length\n      mapper.select(['Sue']);\n      // @ts-expect-error - key tuple must have correct length\n      mapper.select(['Sue', 3, 'foo']);\n      // @ts-expect-error - key tuple must have correct types\n      mapper.select(['Sue', 'foo']);\n      // @ts-expect-error - primitive key values are not allowed\n      mapper.select('Sue');\n      // @ts-expect-error - primitive key values are not allowed\n      mapper.select(1);\n    });\n  });\n", "  ignore('detects select(filter) type errors', async () => {\n    // @ts-expect-error - doesn't allow only two arguments\n    userMapper.select('name', '=');\n    // @ts-expect-error - object filter fields must be valid\n    userMapper.select({ notThere: 'xyz' });\n    userMapper.select(({ or, cmpr }) =>\n      // @ts-expect-error - where expression columns must be valid\n      or([cmpr('notThere', '=', 'Sue')])\n    );\n    // @ts-expect-error - binary op filter fields must be valid\n    userMapper.select('notThere', '=', 'foo');\n    // @ts-expect-error - binary op filter fields must be valid\n    userMapper.select('users.notThere', '=', 'foo');\n    // @ts-expect-error - ID filter must have correct type\n    userMapper.select('str');\n    // @ts-expect-error - ID filter must have correct type\n    userMapper.select(['str']);\n    // @ts-expect-error - ID filter not allowed when when no ID column\n    userMapperReturningNothing.select(1);\n    // @ts-expect-error - ID filter not allowed when when no ID column\n    userMapperReturningNothing.select([1]);\n  });\n});\n"]}
{"filename": "src/tests/transform-types.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport { User } from './utils/test-types';\nimport { ignore } from './utils/test-utils';\nimport { createInsertTransformMapper } from './utils/test-mappers';\n\nlet db: Kysely<Database>;", "\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('table mapper transform type checks', () => {\n  ignore('detects invalid select transform configuration', () => {\n    new TableMapper(db, 'users').withTransforms({\n      // @ts-expect-error - invalid select transform\n      selectTransform: (user: User) => user,\n    });\n  });\n\n  ignore('detects invalid insert transform configuration', () => {\n    new TableMapper(db, 'users').withTransforms({\n      // @ts-expect-error - invalid insert transform\n      insertTransform: (user: User) => user,\n    });\n  });\n\n  ignore('detects invalid update transform configuration', () => {\n    new TableMapper(db, 'users').withTransforms({\n      // @ts-expect-error - invalid update transform\n      updateTransform: (_user) => ({ noId: 1 }),\n    });\n  });\n\n  ignore('detects invalid update return transform return', async () => {\n    const mapper = new TableMapper(db, 'users', { keyColumns: ['id'] });\n\n    mapper.withTransforms({\n      selectTransform: (_user) => new User(1, 'John', 'Doe', 'jdoe', 'x@y.z'),\n      updateTransform: (user: User) => ({\n        id: user.id,\n        name: `${user.firstName} ${user.lastName}`,\n        handle: user.handle,\n        email: user.email,\n      }),\n      updateReturnTransform: (_user, returns) => returns,\n    });\n    (await mapper\n      .update({ id: 1 })", "\ndescribe('table mapper transform type checks', () => {\n  ignore('detects invalid select transform configuration', () => {\n    new TableMapper(db, 'users').withTransforms({\n      // @ts-expect-error - invalid select transform\n      selectTransform: (user: User) => user,\n    });\n  });\n\n  ignore('detects invalid insert transform configuration', () => {\n    new TableMapper(db, 'users').withTransforms({\n      // @ts-expect-error - invalid insert transform\n      insertTransform: (user: User) => user,\n    });\n  });\n\n  ignore('detects invalid update transform configuration', () => {\n    new TableMapper(db, 'users').withTransforms({\n      // @ts-expect-error - invalid update transform\n      updateTransform: (_user) => ({ noId: 1 }),\n    });\n  });\n\n  ignore('detects invalid update return transform return', async () => {\n    const mapper = new TableMapper(db, 'users', { keyColumns: ['id'] });\n\n    mapper.withTransforms({\n      selectTransform: (_user) => new User(1, 'John', 'Doe', 'jdoe', 'x@y.z'),\n      updateTransform: (user: User) => ({\n        id: user.id,\n        name: `${user.firstName} ${user.lastName}`,\n        handle: user.handle,\n        email: user.email,\n      }),\n      updateReturnTransform: (_user, returns) => returns,\n    });\n    (await mapper\n      .update({ id: 1 })", "      // @ts-expect-error - ensure that return type is User\n      .returnOne(new User(1, 'John', 'Doe', 'jdoe', 'jdoe@abc.def')))!.name;\n  });\n\n  ignore('detects insertion transformation type errors', async () => {\n    const insertTransformMapper = createInsertTransformMapper(db);\n\n    // @ts-expect-error - requires InsertedObject as input\n    await insertTransformMapper.insert().returnOne(USERS[0]);\n    // @ts-expect-error - requires InsertedObject as input\n    await insertTransformMapper.insert().run(USERS[0]);\n    // @ts-expect-error - requires InsertedObject as input\n    await insertTransformMapper.insert().returnOne(selectedUser1);\n    // @ts-expect-error - requires InsertedObject as input\n    await insertTransformMapper.insert().run(selectedUser1);\n  });\n\n  it('accepts readonly transforms', () => {\n    const transforms = {\n      countTransform: (count: bigint) => count,\n    } as const;\n\n    new TableMapper(db, 'users', {}).withTransforms(transforms);\n  });\n});\n"]}
{"filename": "src/tests/select-one.test.ts", "chunked_list": ["/**\n * Tests TableMapper.selectMany(), TableMapper.selectOne(), and query filters.\n */\n\nimport { Kysely, sql } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport { createUserMapperReturningID } from './utils/test-mappers';", "import { Database } from './utils/test-tables';\nimport { createUserMapperReturningID } from './utils/test-mappers';\nimport { USERS } from './utils/test-objects';\nimport { ignore } from './utils/test-utils';\n\nlet db: Kysely<Database>;\nlet userMapper: ReturnType<typeof createUserMapperReturningID>;\n\nbeforeAll(async () => {\n  db = await createDB();", "beforeAll(async () => {\n  db = await createDB();\n  userMapper = createUserMapperReturningID(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('selecting one return', () => {\n  it('selects the first row with no filter', async () => {\n    await userMapper.insert().run(USERS);", "  it('selects the first row with no filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    let user = await userMapper.select().returnOne();\n    expect(user?.handle).toEqual(USERS[0].handle);\n\n    user = await userMapper.select({}).returnOne();\n    expect(user?.handle).toEqual(USERS[0].handle);\n  });\n", "  });\n\n  it('selects the first row with a matching field filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    let user = await userMapper.select({ name: USERS[0].name }).returnOne();\n    expect(user?.handle).toEqual(USERS[0].handle);\n\n    user = await userMapper\n      .select({", "    user = await userMapper\n      .select({\n        name: USERS[0].name,\n        handle: USERS[2].handle,\n      })\n      .returnOne();\n    expect(user?.handle).toEqual(USERS[2].handle);\n\n    user = await userMapper\n      .select({", "    user = await userMapper\n      .select({\n        id: [1, 2],\n        handle: [USERS[1].handle, USERS[2].handle],\n      })\n      .returnOne();\n    expect(user?.handle).toEqual(USERS[1].handle);\n  });\n\n  it('selects the first row with a binary operation filter', async () => {", "\n  it('selects the first row with a binary operation filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    // Test selecting by condition (with result)\n    let user = await userMapper.select('name', '=', USERS[0].name).returnOne();\n    expect(user?.handle).toEqual(USERS[0].handle);\n\n    // Test selecting by condition (no result)\n    user = await userMapper.select('name', '=', 'nonexistent').returnOne();", "    // Test selecting by condition (no result)\n    user = await userMapper.select('name', '=', 'nonexistent').returnOne();\n    expect(user).toBeNull();\n  });\n\n  it('selects the first row with a query expression filter', async () => {\n    await userMapper.insert().run(USERS);\n\n    const user = await userMapper\n      .select(sql`name != ${USERS[0].name}`)", "    const user = await userMapper\n      .select(sql`name != ${USERS[0].name}`)\n      .returnOne();\n    expect(user?.handle).toEqual(USERS[1].handle);\n  });\n\n  it('selects the first row with a compound filter', async () => {\n    const userIDs = await userMapper.insert().returnAll(USERS);\n\n    const user = await userMapper", "\n    const user = await userMapper\n      .select(({ and, cmpr }) =>\n        and([cmpr('name', '=', USERS[0].name), cmpr('id', '>', userIDs[0].id)])\n      )\n      .returnOne();\n    expect(user?.handle).toEqual(USERS[2].handle);\n  });\n\n  it('selects one returning selected columns and aliases', async () => {", "\n  it('selects one returning selected columns and aliases', async () => {\n    const ids = await userMapper.insert().returnAll(USERS);\n    const mapper = new TableMapper(db, 'users', {\n      selectedColumns: ['id', 'handle as h'],\n    });\n\n    // Should allow access to aliased columns\n    (await mapper.select().returnOne())!.h;\n", "    (await mapper.select().returnOne())!.h;\n\n    const user = await mapper.select({ handle: USERS[0].handle }).returnOne();\n    expect(user).toEqual({ id: ids[0].id, h: USERS[0].handle });\n\n    ignore('inaccessible types are not allowed', async () => {\n      // @ts-expect-error - unselected columns are not allowed\n      (await mapper.select().returnAll())[0].name;\n    });\n  });", "    });\n  });\n\n  ignore('detects selecting returnOne() type errors', async () => {\n    // @ts-expect-error - only table columns are accessible unfiltered\n    (await userMapper.select({}).returnOne()).notThere;\n    // @ts-expect-error - only table columns are accessible w/ object filter\n    (await userMapper.select({ name: 'Sue' }).returnOne()).notThere;\n    // @ts-expect-error - only table columns are accessible w/ op filter\n    // prettier-ignore\n    (await userMapper.select(\"name\", \"=\", \"Sue\").returnOne()).notThere;\n    // prettier-ignore\n    (\n      await userMapper\n        .select((qb) => qb)\n        .returnOne()\n      // @ts-expect-error - only table columns are accessible w/ QB filter\n    )!.notThere;\n    // prettier-ignore\n    (\n      await userMapper\n        .select(sql`name = 'Sue'`)\n        .returnOne()\n      // @ts-expect-error - only table columns are accessible w/ expr filter\n    )!.notThere;\n  });\n});\n"]}
{"filename": "src/tests/sample-mappers.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport { USERS, insertedUser1 } from './utils/test-objects';\nimport { TableMapper } from '../mappers/table-mapper';\nimport { EntireRowTransforms } from '../mappers/entire-row-transforms';\n\nlet db: Kysely<Database>;\n", "let db: Kysely<Database>;\n\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('mappers that input and output the same type of object', () => {\n  it('inserts/updates/deletes with default transforms', async () => {\n    class MappedUser {\n      constructor(\n        public id: number,\n        public name: string,\n        public handle: string,\n        public email: string | null\n      ) {}\n    }\n\n    const keyColumns = ['id'] as const;\n    const userMapper = new TableMapper(db, 'users', {\n      keyColumns,\n      updateReturnColumns: ['id', 'name'],\n    }).withTransforms(new EntireRowTransforms(keyColumns));\n\n    // test updating a non-existent user\n    const userWithID = new MappedUser(\n      1,\n      USERS[0].name,\n      USERS[0].handle,\n      USERS[0].email!\n    );\n    const updateReturn1 = await userMapper\n      .update({ id: 1 })\n      .returnOne(userWithID);\n    expect(updateReturn1).toEqual(null);\n\n    // test inserting a user with falsy id\n    const insertedUser1 = new MappedUser(\n      0,\n      USERS[0].name,\n      USERS[0].handle,\n      USERS[0].email!\n    );\n    const insertReturn1 = (await userMapper.insert().returnOne(insertedUser1))!;\n    expect(insertReturn1).not.toBeNull();\n    expect(insertReturn1.id).toBeGreaterThan(0);\n    insertReturn1.name; // ensure 'name' is accessible\n\n    // test getting a user by ID\n    const selectedUser1 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser1).toEqual({ ...insertedUser1, id: insertReturn1.id });\n    // ensure 'id' is accessible\n    expect(selectedUser1?.id).toEqual(insertReturn1.id);\n    selectedUser1?.name; // ensure 'name' is accessible\n\n    // test inserting a user with truthy id\n    const insertedUser2 = new MappedUser(\n      10,\n      USERS[1].name,\n      USERS[1].handle,\n      USERS[1].email!\n    );\n    const insertReturn2 = (await userMapper.insert().returnOne(insertedUser2))!;\n    expect(insertReturn2).toEqual(insertedUser2);\n    insertReturn2?.name; // ensure 'name' is accessible\n    const selectedUser2 = await userMapper\n      .select({ id: insertReturn2.id })\n      .returnOne();\n    expect(selectedUser2).toEqual(insertedUser2);\n\n    // test updating a user, with returned row\n    const updatingUser = new MappedUser(\n      selectedUser1!.id,\n      'Xana',\n      selectedUser1!.handle,\n      selectedUser1!.email\n    );\n    const updateReturn = await userMapper\n      .update({ id: updatingUser.id })\n      .returnOne(updatingUser);\n    updateReturn?.id; // ensure 'id' is accessible\n    updateReturn?.name; // ensure 'name' is accessible\n    expect(updateReturn).toEqual(updatingUser);\n    const selectedUser3 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser3).toEqual(updatingUser);\n\n    // test updating a user, without returned row\n    const updatingUser2 = new MappedUser(\n      selectedUser3!.id,\n      'Freddy',\n      selectedUser3!.handle,\n      selectedUser3!.email\n    );\n    const updateReturn2 = await userMapper\n      .update({ id: updatingUser2.id })\n      .run(updatingUser2);\n    expect(updateReturn2).toBe(true);\n    const selectedUser4 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser4).toEqual(updatingUser2);\n\n    // test updating multiple users returning rows\n    const updatingUser3 = new MappedUser(\n      selectedUser1!.id,\n      'Everyone',\n      selectedUser1!.handle,\n      selectedUser1!.email\n    );\n    const updateReturn3 = await userMapper\n      .update()\n      .columns(['name', 'handle', 'email'])\n      .returnAll(updatingUser3);\n    expect(updateReturn3).toEqual([\n      { ...updatingUser3, id: 1 },\n      { ...updatingUser3, id: 10 },\n    ]);\n    updateReturn3[0].id; // ensure 'id' is accessible\n    updateReturn3[0].name; // ensure 'name' is accessible\n\n    // test deleting a user\n    const deleted = await userMapper.delete({ id: insertReturn1.id }).run();\n    expect(deleted).toEqual(true);\n    const selectedUser5 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser5).toBeNull();\n  });\n\n  it('inserts/updates/deletes with all custom transforms', async () => {", "describe('mappers that input and output the same type of object', () => {\n  it('inserts/updates/deletes with default transforms', async () => {\n    class MappedUser {\n      constructor(\n        public id: number,\n        public name: string,\n        public handle: string,\n        public email: string | null\n      ) {}\n    }\n\n    const keyColumns = ['id'] as const;\n    const userMapper = new TableMapper(db, 'users', {\n      keyColumns,\n      updateReturnColumns: ['id', 'name'],\n    }).withTransforms(new EntireRowTransforms(keyColumns));\n\n    // test updating a non-existent user\n    const userWithID = new MappedUser(\n      1,\n      USERS[0].name,\n      USERS[0].handle,\n      USERS[0].email!\n    );\n    const updateReturn1 = await userMapper\n      .update({ id: 1 })\n      .returnOne(userWithID);\n    expect(updateReturn1).toEqual(null);\n\n    // test inserting a user with falsy id\n    const insertedUser1 = new MappedUser(\n      0,\n      USERS[0].name,\n      USERS[0].handle,\n      USERS[0].email!\n    );\n    const insertReturn1 = (await userMapper.insert().returnOne(insertedUser1))!;\n    expect(insertReturn1).not.toBeNull();\n    expect(insertReturn1.id).toBeGreaterThan(0);\n    insertReturn1.name; // ensure 'name' is accessible\n\n    // test getting a user by ID\n    const selectedUser1 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser1).toEqual({ ...insertedUser1, id: insertReturn1.id });\n    // ensure 'id' is accessible\n    expect(selectedUser1?.id).toEqual(insertReturn1.id);\n    selectedUser1?.name; // ensure 'name' is accessible\n\n    // test inserting a user with truthy id\n    const insertedUser2 = new MappedUser(\n      10,\n      USERS[1].name,\n      USERS[1].handle,\n      USERS[1].email!\n    );\n    const insertReturn2 = (await userMapper.insert().returnOne(insertedUser2))!;\n    expect(insertReturn2).toEqual(insertedUser2);\n    insertReturn2?.name; // ensure 'name' is accessible\n    const selectedUser2 = await userMapper\n      .select({ id: insertReturn2.id })\n      .returnOne();\n    expect(selectedUser2).toEqual(insertedUser2);\n\n    // test updating a user, with returned row\n    const updatingUser = new MappedUser(\n      selectedUser1!.id,\n      'Xana',\n      selectedUser1!.handle,\n      selectedUser1!.email\n    );\n    const updateReturn = await userMapper\n      .update({ id: updatingUser.id })\n      .returnOne(updatingUser);\n    updateReturn?.id; // ensure 'id' is accessible\n    updateReturn?.name; // ensure 'name' is accessible\n    expect(updateReturn).toEqual(updatingUser);\n    const selectedUser3 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser3).toEqual(updatingUser);\n\n    // test updating a user, without returned row\n    const updatingUser2 = new MappedUser(\n      selectedUser3!.id,\n      'Freddy',\n      selectedUser3!.handle,\n      selectedUser3!.email\n    );\n    const updateReturn2 = await userMapper\n      .update({ id: updatingUser2.id })\n      .run(updatingUser2);\n    expect(updateReturn2).toBe(true);\n    const selectedUser4 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser4).toEqual(updatingUser2);\n\n    // test updating multiple users returning rows\n    const updatingUser3 = new MappedUser(\n      selectedUser1!.id,\n      'Everyone',\n      selectedUser1!.handle,\n      selectedUser1!.email\n    );\n    const updateReturn3 = await userMapper\n      .update()\n      .columns(['name', 'handle', 'email'])\n      .returnAll(updatingUser3);\n    expect(updateReturn3).toEqual([\n      { ...updatingUser3, id: 1 },\n      { ...updatingUser3, id: 10 },\n    ]);\n    updateReturn3[0].id; // ensure 'id' is accessible\n    updateReturn3[0].name; // ensure 'name' is accessible\n\n    // test deleting a user\n    const deleted = await userMapper.delete({ id: insertReturn1.id }).run();\n    expect(deleted).toEqual(true);\n    const selectedUser5 = await userMapper\n      .select({ id: insertReturn1.id })\n      .returnOne();\n    expect(selectedUser5).toBeNull();\n  });\n\n  it('inserts/updates/deletes with all custom transforms', async () => {", "    class MappedUser {\n      constructor(\n        public serialNo: number,\n        public firstName: string,\n        public lastName: string,\n        public handle: string,\n        public email: string | null\n      ) {}\n    }\n\n    const userMapper = new TableMapper(db, 'users', {\n      keyColumns: ['id'],\n      updateReturnColumns: ['id'],\n    }).withTransforms({\n      insertTransform: (user: MappedUser) => ({\n        name: `${user.firstName} ${user.lastName}`,\n        handle: user.handle,\n        email: user.email,\n      }),\n      insertReturnTransform: (user, returns) =>\n        new MappedUser(\n          returns.id,\n          user.firstName,\n          user.lastName,\n          user.handle,\n          user.email\n        ),\n      updateTransform: (user: MappedUser) => {", "        if (!(user instanceof MappedUser)) {\n          return user;\n        }\n        return {\n          name: `${user.firstName} ${user.lastName}`,\n          handle: user.handle + '2',\n          email: user.email,\n        };\n      },\n      updateReturnTransform: (user, returns) => {\n        return new MappedUser(\n          returns.id,\n          user.firstName,\n          user.lastName,\n          user.handle,\n          user.email\n        );\n      },\n      selectTransform: (row) => {\n        const names = row.name.split(' ');\n        return new MappedUser(\n          row.id,\n          names[0],\n          names[1],\n          row.handle,\n          row.email\n        );\n      },\n    });\n\n    // test updating a non-existent user\n    const updateReturn1 = await userMapper\n      .update({ id: 1 })\n      .returnOne(\n        new MappedUser(\n          1,\n          insertedUser1.firstName,\n          insertedUser1.lastName,\n          insertedUser1.handle,\n          insertedUser1.email\n        )\n      );\n    expect(updateReturn1).toEqual(null);\n\n    // test inserting a user\n    const insertedUser = new MappedUser(\n      0,\n      insertedUser1.firstName,\n      insertedUser1.lastName,\n      insertedUser1.handle,\n      insertedUser1.email\n    );\n    const insertReturn = (await userMapper.insert().returnOne(insertedUser))!;\n    insertReturn?.firstName; // ensure 'firstName' is accessible\n    expect(insertReturn).not.toBeNull();\n    expect(insertReturn.serialNo).toBeGreaterThan(0);\n\n    // test getting a user by ID\n    const selectedUser1 = await userMapper\n      .select({ id: insertReturn.serialNo })\n      .returnOne();\n    selectedUser1?.firstName; // ensure 'firstName' is accessible\n    expect(selectedUser1).toEqual(insertReturn);\n    expect(selectedUser1?.serialNo).toEqual(insertReturn.serialNo);\n\n    // test updating a user\n    const updatingUser = new MappedUser(\n      selectedUser1!.serialNo,\n      selectedUser1!.firstName,\n      'Xana',\n      selectedUser1!.handle,\n      selectedUser1!.email\n    );\n    const updateReturn2 = await userMapper\n      .update({ id: updatingUser.serialNo })\n      .returnOne(updatingUser);\n    updateReturn2?.firstName; // ensure 'firstName' is accessible\n    expect(updateReturn2).toEqual(updatingUser);\n    const selectedUser2 = await userMapper\n      .select({ id: insertReturn.serialNo })\n      .returnOne();\n    selectedUser2?.firstName; // ensure 'firstName' is accessible\n    expect(selectedUser2?.serialNo).toEqual(selectedUser1!.serialNo);\n    expect(selectedUser2?.handle).toEqual(selectedUser1!.handle + '2');\n\n    // test updating multiple users\n    const updatingUser3 = new MappedUser(\n      selectedUser1!.serialNo,\n      'Every',\n      'One',\n      selectedUser1!.handle,\n      selectedUser1!.email\n    );\n    const updateReturn3 = await userMapper.update().returnAll(updatingUser3);\n    expect(updateReturn3).toEqual([updatingUser3]);\n    updateReturn3[0].serialNo; // ensure 'serialNo' is accessible\n    const updateReturn4 = await userMapper.update().returnOne(updatingUser3);\n    expect(updateReturn4).toEqual(updatingUser3);\n    updateReturn4?.serialNo; // ensure 'serialNo' is accessible\n\n    // test deleting a user\n    const deleted = await userMapper\n      .delete({ id: insertReturn.serialNo })\n      .run();\n    expect(deleted).toEqual(true);\n    const selectedUser3 = await userMapper\n      .select({ id: insertReturn.serialNo })\n      .returnOne();\n    expect(selectedUser3).toBeNull();\n  });\n});\n"]}
{"filename": "src/tests/insert-columns.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database } from './utils/test-tables';\nimport {\n  createUserMapperReturningID,\n  createUserMapperReturningNothing,\n} from './utils/test-mappers';\n\nlet db: Kysely<Database>;", "\nlet db: Kysely<Database>;\n\nlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\nlet userMapperReturningNothing: ReturnType<\n  typeof createUserMapperReturningNothing\n>;\n\nbeforeAll(async () => {", "\nbeforeAll(async () => {\n  db = await createDB();\n  userMapperReturningNothing = createUserMapperReturningNothing(db);\n  userMapperReturningID = createUserMapperReturningID(db);\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\ndescribe('inserting specific columns', () => {\n  it('subsets inserted columns, excluding ID', async () => {", "describe('inserting specific columns', () => {\n  it('subsets inserted columns, excluding ID', async () => {\n    const subsetQuery = userMapperReturningID\n      .insert()\n      .columns(['name', 'handle'] as const); // allows readonly array\n    const insertReturn = await subsetQuery.returnOne({\n      id: 10,\n      name: 'John Doe',\n      handle: 'johndoe',\n      email: 'jdoe@abc.def',", "      handle: 'johndoe',\n      email: 'jdoe@abc.def',\n    });\n    expect(insertReturn).toEqual({ id: expect.any(Number) });\n\n    const readUser = await userMapperReturningID.select().returnAll();\n    expect(readUser).toEqual([\n      { id: 1, name: 'John Doe', handle: 'johndoe', email: null },\n    ]);\n  });", "    ]);\n  });\n\n  it('subsets inserted columns, including ID', async () => {\n    const subsetQuery = userMapperReturningNothing\n      .insert()\n      .columns(['id', 'name', 'handle']);\n    await subsetQuery.run({\n      id: 10,\n      name: 'John Doe',", "      id: 10,\n      name: 'John Doe',\n      handle: 'johndoe',\n      email: 'jdoe@abc.def',\n    });\n\n    const readUser = await userMapperReturningID.select().returnAll();\n    expect(readUser).toEqual([\n      { id: 10, name: 'John Doe', handle: 'johndoe', email: null },\n    ]);", "      { id: 10, name: 'John Doe', handle: 'johndoe', email: null },\n    ]);\n  });\n\n  it('requires all subsetted columns to be inserted', async () => {\n    const subsetQuery = userMapperReturningID\n      .insert()\n      .columns(['name', 'handle', 'email']);\n\n    const insertValues = { name: 'John Doe', handle: 'johndoe' };", "\n    const insertValues = { name: 'John Doe', handle: 'johndoe' };\n\n    expect(() => subsetQuery.returnOne(insertValues)).rejects.toThrow(\n      `column 'email' missing`\n    );\n\n    const success = await subsetQuery.run({ ...insertValues, email: null });\n    expect(success).toBe(true);\n  });", "    expect(success).toBe(true);\n  });\n\n  it('provides insertTransform with column subset', async () => {\n    expect.assertions(1);\n    const mapper = userMapperReturningID.withTransforms({\n      insertTransform: (source, columns) => {\n        expect(columns).toEqual(['name', 'handle']);\n        return source;\n      },", "        return source;\n      },\n    });\n    await mapper.insert().columns(['name', 'handle']).run({\n      name: 'John Doe',\n      handle: 'johndoe',\n      email: 'jdoe@abc.def',\n    });\n  });\n});", "  });\n});\n"]}
{"filename": "src/tests/setting-types.test.ts", "chunked_list": ["import { Insertable, Kysely, Selectable, Updateable } from 'kysely';\n\nimport { TableMapper } from '../mappers/table-mapper';\nimport { createDB, resetDB, destroyDB } from './utils/test-setup';\nimport { Database, Users } from './utils/test-tables';\nimport { ignore } from './utils/test-utils';\nimport { SelectionColumn } from '../lib/type-utils';\n\nlet db: Kysely<Database>;\n", "let db: Kysely<Database>;\n\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\ndescribe('table mapper setting type checks', () => {\n  ignore('detects invalid return columns configurations', () => {\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: ['notThere'],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: ['notThere'],\n    });\n\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - actual and declared return types must match\n      insertReturnColumns: ['id', 'name'],\n      // @ts-expect-error - actual and declared return types must match\n      updateReturnColumns: ['id', 'name'],\n    });\n\n    new TableMapper<\n      Database,\n      'users',\n      [],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      bigint,\n      // @ts-expect-error - invalid return column configuration\n      ['notThere']\n    >(db, 'users', {});\n\n    new TableMapper<\n      Database,\n      'users',\n      [],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      bigint,\n      ['name'],\n      // @ts-expect-error - invalid return column configuration\n      ['name', 'notThere']\n    >(db, 'users', {});\n\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: [''],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: [''],\n    });\n\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: ['notThere'],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: ['notThere'],\n    });\n", "describe('table mapper setting type checks', () => {\n  ignore('detects invalid return columns configurations', () => {\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: ['notThere'],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: ['notThere'],\n    });\n\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - actual and declared return types must match\n      insertReturnColumns: ['id', 'name'],\n      // @ts-expect-error - actual and declared return types must match\n      updateReturnColumns: ['id', 'name'],\n    });\n\n    new TableMapper<\n      Database,\n      'users',\n      [],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      bigint,\n      // @ts-expect-error - invalid return column configuration\n      ['notThere']\n    >(db, 'users', {});\n\n    new TableMapper<\n      Database,\n      'users',\n      [],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      bigint,\n      ['name'],\n      // @ts-expect-error - invalid return column configuration\n      ['name', 'notThere']\n    >(db, 'users', {});\n\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: [''],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: [''],\n    });\n\n    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: ['notThere'],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: ['notThere'],\n    });\n", "    class TestMapper6<\n      InsertReturnColumns extends\n        | SelectionColumn<Database, 'users'>[]\n        | ['*'] = [],\n      UpdateReturnColumns extends\n        | SelectionColumn<Database, 'users'>[]\n        | ['*'] = []\n    > extends TableMapper<\n      Database,\n      'users',\n      [],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      number,\n      InsertReturnColumns,\n      UpdateReturnColumns\n    > {}\n    new TestMapper6(db, 'users', {\n      // @ts-expect-error - invalid return column configuration\n      insertReturnColumns: ['notThere'],\n      // @ts-expect-error - invalid return column configuration\n      updateReturnColumns: ['notThere'],\n    });\n\n    new TableMapper<\n      Database,\n      'users',\n      [],\n      any,\n      any,\n      any,\n      any,\n      number,\n      ['id', 'name']\n    >(db, 'users', {\n      // @ts-expect-error - actual and declared return types must match\n      insertReturnColumns: ['id'],\n      // @ts-expect-error - actual and declared return types must match\n      updateReturnColumns: ['id'],\n    });\n\n    new TableMapper<\n      Database,\n      'users',\n      [],\n      any,\n      any,\n      any,\n      any,\n      number,\n      ['*'],\n      ['*']\n    >(db, 'users', {\n      // @ts-expect-error - actual and declared return types must match\n      insertReturnColumns: ['id'],\n      // @ts-expect-error - actual and declared return types must match\n      updateReturnColumns: ['id'],\n    });\n\n    new TableMapper<Database, 'users', [], any, any, any, any, number, [], []>(\n      db,\n      'users',\n      {\n        // @ts-expect-error - actual and declared return types must match\n        insertReturnColumns: ['id'],\n        // @ts-expect-error - actual and declared return types must match\n        updateReturnColumns: ['id'],\n      }\n    );\n  });\n\n  ignore('detects invalid return count configuration', () => {", "    class TestMapper extends TableMapper<\n      Database,\n      'users',\n      ['id'],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      number\n    > {}\n    new TestMapper(db, 'users', {\n      // @ts-expect-error - invalid return count\n      countTransform: (count: bigint) => BigInt(count),\n    });\n  });\n\n  it('accepts readonly KeyColumns', () => {\n    new TableMapper<\n      Database,\n      'users',\n      Readonly<['id']> // should not error\n    >(db, 'users', {});\n  });\n\n  it('accepts readonly SelectedColumns', () => {\n    new TableMapper<\n      Database,\n      'users',\n      ['id'],\n      Readonly<['id', 'name']> // should not error\n    >(db, 'users', {});\n  });\n\n  it('accepts readonly return columns', () => {\n    new TableMapper<\n      Database,\n      'users',\n      ['id'],\n      ['*'],\n      Selectable<Users>,\n      Insertable<Users>,\n      Updateable<Users>,\n      bigint,\n      Readonly<['id']>, // should not error\n      Readonly<['name']> // should not error\n    >(db, 'users', {});\n  });\n\n  it('accepts readonly settings', () => {\n    const settings = {\n      insertReturnColumns: ['id'] as const,\n      updateReturnColumns: ['name'] as const,\n    } as const;\n    new TableMapper(db, 'users', settings);\n  });\n});\n"]}
{"filename": "src/tests/utils/test-types.ts", "chunked_list": ["/**\n * Types and classes used in tests.\n */\n\ntype VariableFieldsOf<T> = Omit<T, 'id' | '__type'>;\n\nexport class User {\n  constructor(\n    public id: number,\n    public firstName: string,\n    public lastName: string,\n    public handle: string,\n    public email: string | null\n  ) {}\n\n  static create(id: number, obj: VariableFieldsOf<User>): User {\n    return new User(id, obj.firstName, obj.lastName, obj.handle, obj.email);\n  }\n}\n", "export class InsertedUser extends User {\n  readonly __type = 'InsertedUser';\n\n  static override create(\n    id: number,\n    obj: VariableFieldsOf<InsertedUser>\n  ): InsertedUser {\n    return new InsertedUser(\n      id,\n      obj.firstName,\n      obj.lastName,\n      obj.handle,\n      obj.email\n    );\n  }\n}\n", "export class SelectedUser extends User {\n  readonly __type = 'SelectedUser';\n\n  static override create(\n    id: number,\n    obj: VariableFieldsOf<SelectedUser>\n  ): SelectedUser {\n    return new SelectedUser(\n      id,\n      obj.firstName,\n      obj.lastName,\n      obj.handle,\n      obj.email\n    );\n  }\n}\n", "export class UpdatingUser extends User {\n  readonly __type = 'UpdatingUser';\n\n  static override create(\n    id: number,\n    obj: VariableFieldsOf<UpdatingUser>\n  ): UpdatingUser {\n    return new UpdatingUser(\n      id,\n      obj.firstName,\n      obj.lastName,\n      obj.handle,\n      obj.email\n    );\n  }\n}\n", "export class ReturnedUser extends User {\n  readonly __type = 'ReturnedUser';\n\n  static override create(\n    id: number,\n    obj: VariableFieldsOf<ReturnedUser>\n  ): ReturnedUser {\n    return new ReturnedUser(\n      id,\n      obj.firstName,\n      obj.lastName,\n      obj.handle,\n      obj.email\n    );\n  }\n}\n"]}
{"filename": "src/tests/utils/test-setup.ts", "chunked_list": ["import Sqlite3 from 'better-sqlite3';\nimport { Kysely, SqliteDialect } from 'kysely';\n\nimport { Database, createTables, dropTables } from './test-tables';\n\nexport async function createDB() {\n  return new Kysely<Database>({\n    dialect: new SqliteDialect({\n      database: new Sqlite3(':memory:'),\n    }),\n  });\n}\n", "export async function resetDB(db: Kysely<Database>) {\n  await dropTables(db);\n  await createTables(db);\n}\n\nexport async function destroyDB<DB>(db: Kysely<DB>) {\n  return db.destroy();\n}\n"]}
{"filename": "src/tests/utils/test-mappers.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { TableMapper } from '../../mappers/table-mapper';\nimport { Database } from './test-tables';\nimport { InsertedUser } from './test-types';\n\nconst countTransform = (count: bigint) => Number(count);\n\nexport function createUserMapperReturningDefault(db: Kysely<Database>) {\n  return new TableMapper(db, 'users');\n}\n\nconst noColumns = [] as const;", "export function createUserMapperReturningDefault(db: Kysely<Database>) {\n  return new TableMapper(db, 'users');\n}\n\nconst noColumns = [] as const;\nexport function createUserMapperReturningNothing(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    keyColumns: noColumns,\n    updateReturnColumns: noColumns,\n  }).withTransforms({\n    countTransform,\n  });\n}\n", "export function createUserMapperReturningID(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    keyColumns: ['id'],\n    updateReturnColumns: ['id'],\n  }).withTransforms({\n    countTransform,\n  });\n}\n\nexport function createUserMapperReturningIDAndHandleAsH(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    keyColumns: ['id'],\n    insertReturnColumns: ['id', 'handle as h'],\n    updateReturnColumns: ['id', 'handle as h'],\n  }).withTransforms({ countTransform });\n}\n", "export function createUserMapperReturningIDAndHandleAsH(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    keyColumns: ['id'],\n    insertReturnColumns: ['id', 'handle as h'],\n    updateReturnColumns: ['id', 'handle as h'],\n  }).withTransforms({ countTransform });\n}\n\nexport function createUserMapperReturningDifferently(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    keyColumns: ['id'],\n    insertReturnColumns: ['id', 'handle'],\n    updateReturnColumns: ['name'],\n  }).withTransforms({ countTransform });\n}\n", "export function createUserMapperReturningDifferently(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    keyColumns: ['id'],\n    insertReturnColumns: ['id', 'handle'],\n    updateReturnColumns: ['name'],\n  }).withTransforms({ countTransform });\n}\n\nexport function createUserMapperReturningAll(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    insertReturnColumns: ['*'],\n    updateReturnColumns: ['*'],\n  }).withTransforms({\n    countTransform,\n  });\n}\n", "export function createUserMapperReturningAll(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    insertReturnColumns: ['*'],\n    updateReturnColumns: ['*'],\n  }).withTransforms({\n    countTransform,\n  });\n}\n\nexport function createInsertTransformMapper(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    insertReturnColumns: ['id'],\n    updateReturnColumns: ['id'],\n  }).withTransforms({\n    insertTransform: (source: InsertedUser) => ({\n      name: `${source.firstName} ${source.lastName}`,\n      handle: source.handle,\n      email: source.email,\n    }),\n    countTransform: (count) => Number(count),\n  });\n}\n", "export function createInsertTransformMapper(db: Kysely<Database>) {\n  return new TableMapper(db, 'users', {\n    insertReturnColumns: ['id'],\n    updateReturnColumns: ['id'],\n  }).withTransforms({\n    insertTransform: (source: InsertedUser) => ({\n      name: `${source.firstName} ${source.lastName}`,\n      handle: source.handle,\n      email: source.email,\n    }),\n    countTransform: (count) => Number(count),\n  });\n}\n"]}
{"filename": "src/tests/utils/test-utils.ts", "chunked_list": ["/**\n * Generic testing utilities\n */\n\n/**\n * Retrieve an error for examination. Modified from\n * https://stackoverflow.com/a/49512933/650894\n *\n * @param call Function that may throw an error; can be async\n * @returns The thrown error if one was thrown, otherwise returns", " * @param call Function that may throw an error; can be async\n * @returns The thrown error if one was thrown, otherwise returns\n *   the error NoErrorThrownError\n */\nexport async function getError<E>(call: () => unknown): Promise<E | null> {\n  try {\n    await call(); // need not be async\n    return null;\n  } catch (err: unknown) {\n    return err as E;\n  }\n}\n\n/**\n * Embeds code that will never run within a callback. Useful for", "  } catch (err: unknown) {\n    return err as E;\n  }\n}\n\n/**\n * Embeds code that will never run within a callback. Useful for\n * testing expected type errors.\n * @param description Description of the code that will never run\n * @param callback Callback that will never run\n */", "export function ignore(_description: string, _: () => void) {}\n"]}
{"filename": "src/tests/utils/test-tables.ts", "chunked_list": ["import { Kysely, Generated, sql } from 'kysely';\n\n// list tables after those they depend on\nconst TABLE_NAMES = ['posts', 'users'];\n\nexport interface Users {\n  id: Generated<number>;\n  handle: string;\n  name: string;\n  email: string | null;\n}\n", "export interface Posts {\n  id: Generated<number>;\n  userId: number;\n  title: string;\n  likeCount: number;\n  createdAt: Generated<Date>;\n}\n\nexport interface Database {\n  users: Users;\n  posts: Posts;\n}\n", "export interface Database {\n  users: Users;\n  posts: Posts;\n}\n\nexport async function createTables(db: Kysely<Database>) {\n  await _createTableWithId(db, 'users')\n    .addColumn('handle', 'varchar(255)', (col) => col.notNull())\n    .addColumn('name', 'varchar(255)', (col) => col.notNull())\n    .addColumn('email', 'varchar(255)')\n    .execute();\n\n  await _createTableWithId(db, 'posts')\n    .addColumn('userId', 'integer', (col) =>\n      col.references('users.id').onDelete('cascade').notNull()\n    )\n    .addColumn('title', 'varchar(255)', (col) => col.unique().notNull())\n    .addColumn('likeCount', 'integer', (col) => col.notNull())\n    .addColumn('createdAt', 'timestamp', (col) =>\n      col.defaultTo(sql`current_timestamp`).notNull()\n    )\n    .execute();\n\n  return db;\n}\n", "export async function dropTables(db: Kysely<Database>): Promise<void> {\n  for (const table of TABLE_NAMES) {\n    await db.schema.dropTable(table).ifExists().execute();\n  }\n}\n\nfunction _createTableWithId(db: Kysely<Database>, tableName: string) {\n  return db.schema\n    .createTable(tableName)\n    .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey());\n}\n"]}
{"filename": "src/tests/utils/test-objects.ts", "chunked_list": ["import { Insertable } from 'kysely';\n\nimport { Users, Posts } from './test-tables';\nimport { InsertedUser, ReturnedUser, SelectedUser } from './test-types';\n\nexport const USERS: Insertable<Users>[] = [\n  {\n    handle: 'handle1',\n    name: 'Sue',\n    email: 'foo1@bar.com',", "    name: 'Sue',\n    email: 'foo1@bar.com',\n  },\n  {\n    handle: 'handle2',\n    name: 'Fred',\n    email: 'foo2@bar.com',\n  },\n  {\n    handle: 'handle3',", "  {\n    handle: 'handle3',\n    name: 'Sue',\n    email: 'foo3@bar.com',\n  },\n];\n\nexport const POSTS: Insertable<Posts>[] = [\n  {\n    userId: 0,", "  {\n    userId: 0,\n    title: 'About Something',\n    likeCount: 0,\n  },\n  {\n    userId: 0,\n    title: 'And Another Thing',\n    likeCount: 10,\n  },", "    likeCount: 10,\n  },\n  {\n    userId: 0,\n    title: 'Still One More Thing',\n    likeCount: 1000,\n  },\n];\n\nexport const userRow1 = {", "\nexport const userRow1 = {\n  name: 'John Smith',\n  handle: 'jsmith',\n  email: 'jsmith@xyz.pdq',\n};\nexport const userRow2 = {\n  name: 'Jane Doe',\n  handle: 'jdoe',\n  email: 'jdoe@xyz.pdq',", "  handle: 'jdoe',\n  email: 'jdoe@xyz.pdq',\n};\nexport const userRow3 = {\n  name: 'Mary Sue',\n  handle: 'msue',\n  email: 'msue@xyz.pdq',\n};\n\nexport const userObject1 = {", "\nexport const userObject1 = {\n  firstName: 'John',\n  lastName: 'Smith',\n  handle: userRow1.handle,\n  email: userRow1.email,\n};\nexport const userObject2 = {\n  firstName: 'Jane',\n  lastName: 'Doe',", "  firstName: 'Jane',\n  lastName: 'Doe',\n  handle: userRow2.handle,\n  email: userRow2.email,\n};\nexport const userObject3 = {\n  firstName: 'Mary',\n  lastName: 'Sue',\n  handle: userRow3.handle,\n  email: userRow3.email,", "  handle: userRow3.handle,\n  email: userRow3.email,\n};\n\nexport const selectedUser1 = SelectedUser.create(1, userObject1);\nexport const selectedUser2 = SelectedUser.create(2, userObject2);\nexport const selectedUser3 = SelectedUser.create(3, userObject3);\n\nexport const insertedUser1 = InsertedUser.create(0, userObject1);\nexport const insertedUser2 = InsertedUser.create(0, userObject2);", "export const insertedUser1 = InsertedUser.create(0, userObject1);\nexport const insertedUser2 = InsertedUser.create(0, userObject2);\nexport const insertedUser3 = InsertedUser.create(0, userObject3);\n\nexport const insertReturnedUser1 = ReturnedUser.create(1, userObject1);\nexport const insertReturnedUser2 = ReturnedUser.create(2, userObject2);\nexport const insertReturnedUser3 = ReturnedUser.create(3, userObject3);\n"]}
{"filename": "src/lib/parameterizable-query-factory.ts", "chunked_list": ["import { ParametersObject, QueryParameterMaker } from 'kysely-params';\nimport { AbstractTableMapper } from '../mappers/abstract-table-mapper';\nimport { SelectableColumnTuple, SelectionColumn } from './type-utils';\nimport { ParameterizableMappingQuery } from '../queries/parameterizable-query';\n\n/**\n * Definition of the function that a caller provides to parameterize a\n * compilable query.\n */\nexport interface ParameterizableMappingQueryFactory<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject,\n  InsertedObject,\n  UpdatingObject,\n  ReturnCount,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn,\n  UpdateReturn,\n  M extends AbstractTableMapper<\n    DB,\n    TB,\n    KeyColumns,\n    SelectedColumns,\n    SelectedObject,\n    InsertedObject,\n    UpdatingObject,\n    ReturnCount,\n    InsertReturnColumns,\n    UpdateReturnColumns,\n    InsertReturn,\n    UpdateReturn\n  >,\n  Parameters extends ParametersObject<Parameters>,\n  Q extends ParameterizableMappingQuery\n> {\n  (factory: { mapper: M; param: QueryParameterMaker<Parameters>['param'] }): Q;\n}\n", "export interface ParameterizableMappingQueryFactory<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject,\n  InsertedObject,\n  UpdatingObject,\n  ReturnCount,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn,\n  UpdateReturn,\n  M extends AbstractTableMapper<\n    DB,\n    TB,\n    KeyColumns,\n    SelectedColumns,\n    SelectedObject,\n    InsertedObject,\n    UpdatingObject,\n    ReturnCount,\n    InsertReturnColumns,\n    UpdateReturnColumns,\n    InsertReturn,\n    UpdateReturn\n  >,\n  Parameters extends ParametersObject<Parameters>,\n  Q extends ParameterizableMappingQuery\n> {\n  (factory: { mapper: M; param: QueryParameterMaker<Parameters>['param'] }): Q;\n}\n"]}
{"filename": "src/lib/restrict-values.ts", "chunked_list": ["/**\n * Restrict the values of an object to the specified columns, requiring that\n * all of the specified columns be present in the object.\n * @param obj The object to restrict.\n * @param toColumns The columns to restrict the object to.\n * @returns A new object with only the specified columns.\n */\nexport function restrictValues(obj: any, toColumns: Readonly<string[]>) {\n  const values = {} as any;\n  for (const column of toColumns) {\n    const value = obj[column];\n    // ensure the output of the applied transform works for the present query", "  for (const column of toColumns) {\n    const value = obj[column];\n    // ensure the output of the applied transform works for the present query\n    if (value === undefined) {\n      throw Error(`Specified column '${column}' missing from values object`);\n    }\n    values[column] = value;\n  }\n  return values;\n}\n"]}
{"filename": "src/lib/query-filter.ts", "chunked_list": ["/**\n * The type and implementation of the query filter object, which can\n * be passed as an argument to query functions to constrain results.\n */\n\nimport {\n  Expression,\n  ExtractTypeFromStringReference,\n  ReferenceExpression,\n  SelectType,\n  Selectable,\n  WhereExpressionFactory,\n} from 'kysely';\nimport { KeyTuple, SelectableColumnTuple } from './type-utils';\n\n/**\n * Type of the query filter object, which can be passed as an argument\n * to query functions to constrain results. A filter can be any of the\n * following:\n *\n * - A key column value, which matches a single key column, if\n *   `KeyColumns` is a tuple with a single element.\n * - A key tuple, which matches multiple key columns, if `KeyColumns`\n *   is a tuple with multiple elements.\n * - An object, which matches columns against the object's fields. A\n *   field value may be an array, in which case the associated column ]\n *   matches any of the elements of the array.\n * - A raw SQL expression using Kysely's `sql` template literal tag.\n * - An arbitrary Kysely query expression.\n *\n * A filter is represented as a single value, but the methods that use\n * filters also accept three-argument binary operations.\n */", "export type QueryFilter<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n  RE extends ReferenceExpression<DB, TB>\n> =\n  | (KeyColumns extends [string]\n      ? KeyColumnFilter<DB, TB, KeyColumns[0]>\n      : never)\n  | (KeyColumns extends [] ? never : Readonly<KeyTuple<DB[TB], KeyColumns>>)\n  | FieldMatchingFilter<DB, TB, RE>\n  | WhereExpressionFactory<DB, TB>\n  | Expression<any>;\n\n/**\n * A filter that matches columns against the fields of an object.\n */", "export type FieldMatchingFilter<\n  DB,\n  TB extends keyof DB & string,\n  RE extends ReferenceExpression<DB, TB>\n> = {\n  [K in RE & string]?:\n    | SelectType<ExtractTypeFromStringReference<DB, TB, K>>\n    | Readonly<SelectType<ExtractTypeFromStringReference<DB, TB, K>>[]>;\n};\n\n/**\n * A filter that matches a single key column.\n */", "type KeyColumnFilter<\n  DB,\n  TB extends keyof DB,\n  K extends keyof Selectable<DB[TB]> & string\n> = NonNullable<Selectable<DB[TB]>[K]>;\n"]}
{"filename": "src/lib/type-utils.ts", "chunked_list": ["/**\n * Type utilities.\n */\n\nimport { Selectable, SelectArg, SelectExpression, Selection } from 'kysely';\n\n/**\n * Type of the key tuple whose column names are given by `KA` and are\n * found in the table interface `T`. Supports up to 4 columns.\n * @typeParam T Table interface.", " * found in the table interface `T`. Supports up to 4 columns.\n * @typeParam T Table interface.\n * @typeParam KA Array of the key column names.\n */\nexport type KeyTuple<\n  T,\n  KA extends Readonly<(keyof Selectable<T> & string)[]>\n> = KA[3] extends string\n  ? [\n      Selectable<T>[KA[0]],\n      Selectable<T>[KA[1]],\n      Selectable<T>[KA[2]],\n      Selectable<T>[KA[3]]\n    ]\n  : KA[2] extends string\n  ? [Selectable<T>[KA[0]], Selectable<T>[KA[1]], Selectable<T>[KA[2]]]\n  : KA[1] extends string\n  ? [Selectable<T>[KA[0]], Selectable<T>[KA[1]]]\n  : KA[0] extends string\n  ? [Selectable<T>[KA[0]]]\n  : never;\n\n/**\n * Require specified properties of a type, leaving the rest optional.\n * @typeParam T Type to require properties from.\n * @typeParam K Keys of the properties to require.\n */", "export type RequireSome<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>;\n\n/**\n * Shorthand type for a selectable column, restricted to a column name.\n */\nexport type SelectableColumn<T> = keyof Selectable<T> & string;\n\n/**\n * Selectable column name or column alias.\n */", "export type SelectionColumn<DB, TB extends keyof DB & string> =\n  | SelectableColumn<DB[TB]>\n  | (SelectExpression<DB, TB> & `${SelectableColumn<DB[TB]>} as ${string}`);\n\n/**\n * Type of a selected row, evaluating to all columns if `S` is `['*']`.\n */\nexport type SelectedRow<\n  DB,\n  TB extends keyof DB & string,\n  SE extends SelectExpression<DB, TB>,\n  S extends SelectArg<DB, TB, any> | ['*']\n> = S extends ['*'] ? Selectable<DB[TB]> : Selection<DB, TB, SE>;\n\n/**\n * Tuple of up to four selectable columns.\n */", "export type SelectableColumnTuple<T> =\n  | [SelectableColumn<T>]\n  | [SelectableColumn<T>, SelectableColumn<T>]\n  | [SelectableColumn<T>, SelectableColumn<T>, SelectableColumn<T>]\n  | [\n      SelectableColumn<T>,\n      SelectableColumn<T>,\n      SelectableColumn<T>,\n      SelectableColumn<T>\n    ];\n"]}
{"filename": "src/lib/apply-query-filter.ts", "chunked_list": ["import {\n  ComparisonOperatorExpression,\n  Kysely,\n  OperandValueExpressionOrList,\n  ReferenceExpression,\n  WhereInterface,\n} from 'kysely';\nimport { SelectableColumnTuple } from './type-utils';\nimport { QueryFilter } from './query-filter';\n\ntype AnyWhereInterface = WhereInterface<any, any>;\n\n/**\n * Returns a query builder that constrains the provided query builder\n * according to the provided query filter or binary operation.\n * @param base The Kysely mapper that is used to create references.\n * @param qb The query builder to constrain.\n * @param filterOrLHS The query filter or left-hand side of a binary operation.\n * @param op The operator of a binary operation.\n * @param rhs The right-hand side of a binary operation.\n * @returns A query builder constrained for the provided query filter\n *  or binary operation.\n */", "import { QueryFilter } from './query-filter';\n\ntype AnyWhereInterface = WhereInterface<any, any>;\n\n/**\n * Returns a query builder that constrains the provided query builder\n * according to the provided query filter or binary operation.\n * @param base The Kysely mapper that is used to create references.\n * @param qb The query builder to constrain.\n * @param filterOrLHS The query filter or left-hand side of a binary operation.\n * @param op The operator of a binary operation.\n * @param rhs The right-hand side of a binary operation.\n * @returns A query builder constrained for the provided query filter\n *  or binary operation.\n */", "export function applyQueryFilter<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n  QB extends AnyWhereInterface,\n  RE extends ReferenceExpression<DB, TB>\n>(\n  db: Kysely<DB>,\n  qb: QB,\n  keyColumns: KeyColumns,\n  filterOrLHS: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n  op?: ComparisonOperatorExpression,\n  rhs?: OperandValueExpressionOrList<DB, TB, RE>\n): QB {\n  // Process a binary operation.", "  if (op !== undefined) {\n    return qb.where(filterOrLHS as RE, op, rhs!) as QB;\n  }\n  const filter = filterOrLHS as QueryFilter<DB, TB, KeyColumns, RE>;\n\n  if (typeof filter === 'object') {\n    // Process a key tuple filter.\n    if (Array.isArray(filter)) {\n      keyColumns.forEach((column, i) => {\n        qb = qb.where(db.dynamic.ref(column), '=', filter[i]) as QB;\n      });\n      return qb;\n    }\n\n    // Process a query expression filter. Check for expressions\n    // first because they could potentially be plain objects.", "    if ('expressionType' in filter) {\n      return qb.where(filter) as QB;\n    }\n\n    // Process a field matching filter. `{}` matches all rows.\n    if (filter.constructor === Object) {\n      for (const [column, value] of Object.entries(filter)) {\n        if (Array.isArray(value)) {\n          qb = qb.where(db.dynamic.ref(column), 'in', value) as QB;\n        } else {\n          qb = qb.where(db.dynamic.ref(column), '=', value) as QB;\n        }\n      }\n      return qb as unknown as QB;\n    }\n  }\n\n  // Process a where expression factory.", "  if (typeof filter === 'function') {\n    return qb.where(filter as any) as QB;\n  }\n\n  // Process a single key filter, expressed as a primitive value.\n  if (keyColumns.length === 1) {\n    return qb.where(db.dynamic.ref(keyColumns[0]), '=', filter) as QB;\n  }\n\n  throw Error('Unrecognized query filter');\n}\n"]}
{"filename": "src/mappers/table-mapper.ts", "chunked_list": ["import { Insertable, Selectable, Selection, Updateable } from 'kysely';\n\nimport {\n  SelectableColumnTuple,\n  SelectedRow,\n  SelectionColumn,\n} from '../lib/type-utils';\nimport { TableMapperTransforms } from './table-mapper-transforms';\nimport { AbstractTableMapper } from './abstract-table-mapper';\n", "import { AbstractTableMapper } from './abstract-table-mapper';\n\n/**\n * Table mapper that defaults to passing through all query inputs and output\n * unchanged, allowing the selective overloading of transforms.\n * @typeParam DB Interface whose fields are table names defining tables.\n * @typeParam TB Name of the table.\n * @typeParam KeyColumns Tuple of the names of the table's key columns.\n *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam SelectedColumns Columns to return from selection queries.", " *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam SelectedColumns Columns to return from selection queries.\n *  Defaults to `['*']`, returning all columns. May specify aliases.\n * @typeParam SelectedObject Type of objects returned by select queries.\n * @typeParam InsertedObject Type of objects inserted into the table.\n * @typeParam UpdatingObject Type of objects used to update rows of the table.\n * @typeParam Type of the count of the number of affected rows.\n * @typeParam InsertReturnColumns Columns to return from the table on insert\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.", " *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.\n * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none and is the default. May specify aliases.\n * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n *  whose properties are the columns of `InsertReturnColumns`.\n * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n *  whose properties are the columns of `UpdateReturnColumns`.\n */\nexport class TableMapper<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  SelectedObject = SelectedRow<\n    DB,\n    TB,\n    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n    SelectedColumns\n  >,\n  InsertedObject = Insertable<DB[TB]>,\n  UpdatingObject = Updateable<DB[TB]>,\n  ReturnCount = bigint,\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n  InsertReturn = InsertReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, InsertReturnColumns[number]>,\n  UpdateReturn = UpdateReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, UpdateReturnColumns[number]>\n> extends AbstractTableMapper<\n  DB,\n  TB,\n  KeyColumns,\n  SelectedColumns,\n  SelectedObject,\n  InsertedObject,\n  UpdatingObject,\n  ReturnCount,\n  InsertReturnColumns,\n  UpdateReturnColumns,\n  InsertReturn,\n  UpdateReturn\n> {\n  /**\n   * Returns a new table mapper that uses the provided transformations, along\n   * with the settings of the current table mapper.\n   * @param transforms The transforms to use.\n   * @returns A new table mapper that uses the provided transforms.\n   */\n  withTransforms<\n    SelectedObject = SelectedRow<\n      DB,\n      TB,\n      SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n      SelectedColumns\n    >,\n    InsertedObject = Insertable<DB[TB]>,\n    UpdatingObject = Updateable<DB[TB]>,\n    ReturnCount = bigint,\n    InsertReturn = InsertReturnColumns extends ['*']\n      ? Selectable<DB[TB]>\n      : Selection<DB, TB, InsertReturnColumns[number]>,\n    UpdateReturn = UpdateReturnColumns extends ['*']\n      ? Selectable<DB[TB]>\n      : Selection<DB, TB, UpdateReturnColumns[number]>\n  >(\n    transforms: Readonly<\n      TableMapperTransforms<\n        DB,\n        TB,\n        KeyColumns,\n        SelectedColumns,\n        SelectedObject,\n        InsertedObject,\n        UpdatingObject,\n        ReturnCount,\n        InsertReturnColumns,\n        UpdateReturnColumns,\n        InsertReturn,\n        UpdateReturn\n      >\n    >\n  ) {\n    const transformingTableMapper = new TableMapper<\n      DB,\n      TB,\n      KeyColumns,\n      SelectedColumns,\n      SelectedObject,\n      InsertedObject,\n      UpdatingObject,\n      ReturnCount,\n      InsertReturnColumns,\n      UpdateReturnColumns,\n      InsertReturn,\n      UpdateReturn\n    >(this.db, this.tableName, this.settings);\n    transformingTableMapper.transforms = transforms;\n    return transformingTableMapper;\n  }\n}\n", " *  whose properties are the columns of `UpdateReturnColumns`.\n */\nexport class TableMapper<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  SelectedObject = SelectedRow<\n    DB,\n    TB,\n    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n    SelectedColumns\n  >,\n  InsertedObject = Insertable<DB[TB]>,\n  UpdatingObject = Updateable<DB[TB]>,\n  ReturnCount = bigint,\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n  InsertReturn = InsertReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, InsertReturnColumns[number]>,\n  UpdateReturn = UpdateReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, UpdateReturnColumns[number]>\n> extends AbstractTableMapper<\n  DB,\n  TB,\n  KeyColumns,\n  SelectedColumns,\n  SelectedObject,\n  InsertedObject,\n  UpdatingObject,\n  ReturnCount,\n  InsertReturnColumns,\n  UpdateReturnColumns,\n  InsertReturn,\n  UpdateReturn\n> {\n  /**\n   * Returns a new table mapper that uses the provided transformations, along\n   * with the settings of the current table mapper.\n   * @param transforms The transforms to use.\n   * @returns A new table mapper that uses the provided transforms.\n   */\n  withTransforms<\n    SelectedObject = SelectedRow<\n      DB,\n      TB,\n      SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n      SelectedColumns\n    >,\n    InsertedObject = Insertable<DB[TB]>,\n    UpdatingObject = Updateable<DB[TB]>,\n    ReturnCount = bigint,\n    InsertReturn = InsertReturnColumns extends ['*']\n      ? Selectable<DB[TB]>\n      : Selection<DB, TB, InsertReturnColumns[number]>,\n    UpdateReturn = UpdateReturnColumns extends ['*']\n      ? Selectable<DB[TB]>\n      : Selection<DB, TB, UpdateReturnColumns[number]>\n  >(\n    transforms: Readonly<\n      TableMapperTransforms<\n        DB,\n        TB,\n        KeyColumns,\n        SelectedColumns,\n        SelectedObject,\n        InsertedObject,\n        UpdatingObject,\n        ReturnCount,\n        InsertReturnColumns,\n        UpdateReturnColumns,\n        InsertReturn,\n        UpdateReturn\n      >\n    >\n  ) {\n    const transformingTableMapper = new TableMapper<\n      DB,\n      TB,\n      KeyColumns,\n      SelectedColumns,\n      SelectedObject,\n      InsertedObject,\n      UpdatingObject,\n      ReturnCount,\n      InsertReturnColumns,\n      UpdateReturnColumns,\n      InsertReturn,\n      UpdateReturn\n    >(this.db, this.tableName, this.settings);\n    transformingTableMapper.transforms = transforms;\n    return transformingTableMapper;\n  }\n}\n"]}
{"filename": "src/mappers/entire-row-transforms.ts", "chunked_list": ["import { Insertable, Selectable, Updateable } from 'kysely';\nimport {\n  SelectableColumnTuple,\n  SelectedRow,\n  SelectionColumn,\n} from '../lib/type-utils';\nimport { TableMapperTransforms } from './table-mapper-transforms';\n\n/**\n * Transforms for a table mapper that only receives and returns", "/**\n * Transforms for a table mapper that only receives and returns\n * entire table rows, given by type `Selectable<DB[TB]>`.\n * @typeParam DB Interface whose fields are table names defining tables.\n * @typeParam TB Name of the table.\n * @typeParam KeyColumns Tuple of the names of the table's key columns.\n *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam InsertReturnColumns Columns to return from the table on insert\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.", " *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.\n * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none and is the default. May specify aliases.\n */\nexport class EntireRowTransforms<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*']\n> implements\n    Required<\n      TableMapperTransforms<\n        DB,\n        TB,\n        KeyColumns,\n        ['*'],\n        Selectable<DB[TB]>,\n        Selectable<DB[TB]>,\n        Selectable<DB[TB]>,\n        number,\n        InsertReturnColumns,\n        UpdateReturnColumns,\n        Selectable<DB[TB]>,\n        Selectable<DB[TB]>\n      >\n    >\n{\n  /**\n   * Constructs an object providing transforms for entire table rows.\n   */\n  constructor(readonly keyColumns: KeyColumns) {}\n\n  /**\n   * Transform a count of the number of rows affected into a number.\n   */\n  countTransform(count: bigint) {\n    return Number(count);\n  }\n\n  /**\n   * Transforms inserted objects into inserted rows, removing the columns\n   * that are keys having falsy values.\n   */\n  insertTransform(\n    obj: Selectable<DB[TB]>,\n    _columns: Readonly<(keyof Insertable<DB[TB]>)[]> | ['*']\n  ) {\n    const insertedValues = { ...obj };\n    this.keyColumns.forEach((column) => {", "      if (!obj[column as unknown as keyof Selectable<DB[TB]>]) {\n        delete insertedValues[column as unknown as keyof Selectable<DB[TB]>];\n      }\n    });\n    return insertedValues as unknown as Insertable<DB[TB]>;\n  }\n\n  /**\n   * Transforms the returns of an insert query into the the object returned\n   * to the caller, merging the returned values into the inserted object.\n   */\n  insertReturnTransform(\n    source: Selectable<DB[TB]>,\n    returns: InsertReturnColumns extends []\n      ? never\n      : SelectedRow<\n          DB,\n          TB,\n          InsertReturnColumns extends ['*']\n            ? never\n            : InsertReturnColumns[number],\n          InsertReturnColumns\n        >\n  ) {", "    if (returns === undefined) return source;\n    return { ...source, ...returns };\n  }\n\n  /**\n   * Returns selected rows to the caller as selected objects, unchanged.\n   */\n  selectTransform(row: Selectable<DB[TB]>) {\n    return row;\n  }\n\n  /**\n   * Provides updating objects as the update values for an update query.\n   */\n  updateTransform(\n    source: Selectable<DB[TB]>,\n    _columns: Readonly<(keyof Updateable<DB[TB]>)[]> | ['*']\n  ) {\n    return source as Updateable<DB[TB]>;\n  }\n\n  /**\n   * Transforms the returns of an update query into the the object returned\n   * to the caller, merging the returned values into the updating object.\n   */\n  updateReturnTransform(\n    source: Selectable<DB[TB]>,\n    returns: UpdateReturnColumns extends []\n      ? never\n      : SelectedRow<\n          DB,\n          TB,\n          UpdateReturnColumns extends ['*']\n            ? never\n            : UpdateReturnColumns[number],\n          UpdateReturnColumns\n        >\n  ) {", "    if (returns === undefined) return source;\n    return { ...source, ...returns };\n  }\n}\n"]}
{"filename": "src/mappers/table-mapper-settings.ts", "chunked_list": ["import { SelectableColumnTuple, SelectionColumn } from '../lib/type-utils';\n\n/**\n * Settings governing table mapper behavior, excluding transformations.\n * @typeParam DB Interface whose fields are table names defining tables.\n * @typeParam TB Name of the table.\n * @typeParam KeyColumns Tuple of the names of the table's key columns.\n *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam SelectedColumns Columns to return from selection queries.\n *  Defaults to `['*']`, returning all columns. May specify aliases.", " * @typeParam SelectedColumns Columns to return from selection queries.\n *  Defaults to `['*']`, returning all columns. May specify aliases.\n * @typeParam InsertReturnColumns Columns to return from the table on insert\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.\n * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none and is the default. May specify aliases.\n */\nexport interface TableMapperSettings<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = []\n> {\n  /**\n   * Tuple of the columns that make up the table's key. Defaults to `[]`,\n   * indicating that no columns are keys.\n   */\n  keyColumns?: KeyColumns;\n\n  /**\n   * Columns to return from selection queries. Defaults to `[*]`, selecting\n   * all columns. May contain aliases.\n   */\n  selectedColumns?: SelectedColumns;\n\n  /**\n   * Columns to return from insert queries that return columns. `['*']`\n   * returns all columns; `[]` returns none. May specify aliases. Defaults\n   * to `KeyColumns`.\n   */\n\n  insertReturnColumns?: InsertReturnColumns;\n\n  /**\n   * Columns to return from update queries that return columns. `['*']` returns\n   * all columns; `[]` returns none and is the default. May specify aliases.\n   */\n  updateReturnColumns?: UpdateReturnColumns;\n}\n", " */\nexport interface TableMapperSettings<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = []\n> {\n  /**\n   * Tuple of the columns that make up the table's key. Defaults to `[]`,\n   * indicating that no columns are keys.\n   */\n  keyColumns?: KeyColumns;\n\n  /**\n   * Columns to return from selection queries. Defaults to `[*]`, selecting\n   * all columns. May contain aliases.\n   */\n  selectedColumns?: SelectedColumns;\n\n  /**\n   * Columns to return from insert queries that return columns. `['*']`\n   * returns all columns; `[]` returns none. May specify aliases. Defaults\n   * to `KeyColumns`.\n   */\n\n  insertReturnColumns?: InsertReturnColumns;\n\n  /**\n   * Columns to return from update queries that return columns. `['*']` returns\n   * all columns; `[]` returns none and is the default. May specify aliases.\n   */\n  updateReturnColumns?: UpdateReturnColumns;\n}\n"]}
{"filename": "src/mappers/table-mapper-transforms.ts", "chunked_list": ["import { Insertable, Selectable, Selection, Updateable } from 'kysely';\nimport {\n  SelectableColumnTuple,\n  SelectedRow,\n  SelectionColumn,\n} from '../lib/type-utils';\n\n/**\n * Transformations to apply to values provided to and received from queries.\n * All transformations are optional. When no transformation is provided, the", " * Transformations to apply to values provided to and received from queries.\n * All transformations are optional. When no transformation is provided, the\n * value is passed through unchanged.\n * @typeParam DB Interface whose fields are table names defining tables.\n * @typeParam TB Name of the table.\n * @typeParam KeyColumns Tuple of the names of the table's key columns.\n *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam SelectedColumns Columns to return from selection queries.\n *  Defaults to `['*']`, returning all columns. May specify aliases.\n * @typeParam SelectedObject Type of objects returned by select queries.", " *  Defaults to `['*']`, returning all columns. May specify aliases.\n * @typeParam SelectedObject Type of objects returned by select queries.\n * @typeParam InsertedObject Type of objects inserted into the table.\n * @typeParam UpdatingObject Type of objects used to update rows of the table.\n * @typeParam Type of the count of the number of affected rows.\n * @typeParam InsertReturnColumns Columns to return from the table on insert\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.\n * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns", " * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none and is the default. May specify aliases.\n * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n *  whose properties are the columns of `InsertReturnColumns`.\n * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n *  whose properties are the columns of `UpdateReturnColumns`.\n */\nexport interface TableMapperTransforms<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  SelectedObject = SelectedRow<\n    DB,\n    TB,\n    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n    SelectedColumns\n  >,\n  InsertedObject = Insertable<DB[TB]>,\n  UpdatingObject = Updateable<DB[TB]>,\n  ReturnCount = bigint,\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n  InsertReturn = InsertReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, InsertReturnColumns[number]>,\n  UpdateReturn = UpdateReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, UpdateReturnColumns[number]>\n> extends CountTransform<ReturnCount>,\n    InsertTransforms<DB, TB, InsertedObject, InsertReturnColumns, InsertReturn>,\n    SelectTransform<DB, TB, SelectedColumns, SelectedObject>,\n    UpdateTransforms<\n      DB,\n      TB,\n      UpdatingObject,\n      UpdateReturnColumns,\n      UpdateReturn\n    > {}\n", "export interface TableMapperTransforms<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  SelectedObject = SelectedRow<\n    DB,\n    TB,\n    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n    SelectedColumns\n  >,\n  InsertedObject = Insertable<DB[TB]>,\n  UpdatingObject = Updateable<DB[TB]>,\n  ReturnCount = bigint,\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n  InsertReturn = InsertReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, InsertReturnColumns[number]>,\n  UpdateReturn = UpdateReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, UpdateReturnColumns[number]>\n> extends CountTransform<ReturnCount>,\n    InsertTransforms<DB, TB, InsertedObject, InsertReturnColumns, InsertReturn>,\n    SelectTransform<DB, TB, SelectedColumns, SelectedObject>,\n    UpdateTransforms<\n      DB,\n      TB,\n      UpdatingObject,\n      UpdateReturnColumns,\n      UpdateReturn\n    > {}\n", "export interface CountTransform<ReturnCount> {\n  /**\n   * Transformation to apply to bigint count results indicating the number of\n   * rows affected, before returning the count to the client. `count` is the\n   * count returned by the query.\n   */\n  countTransform?: (count: bigint) => ReturnCount;\n}\n\nexport interface InsertTransforms<\n  DB,\n  TB extends keyof DB & string,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> {\n  /**\n   * Transformation to apply to inserted objects before insertion. `source`\n   * is the object provided for insertion. Only the columns in `columns` will\n   * actually be inserted, with `[*]` indicating all columns.\n   */\n  insertTransform?: (\n    source: InsertedObject,\n    columns: Readonly<(keyof Insertable<DB[TB]>)[]> | ['*']\n  ) => Insertable<DB[TB]>;\n\n  /**\n   * Transformation to apply to column values returned from inserts before", "export interface InsertTransforms<\n  DB,\n  TB extends keyof DB & string,\n  InsertedObject,\n  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  InsertReturn\n> {\n  /**\n   * Transformation to apply to inserted objects before insertion. `source`\n   * is the object provided for insertion. Only the columns in `columns` will\n   * actually be inserted, with `[*]` indicating all columns.\n   */\n  insertTransform?: (\n    source: InsertedObject,\n    columns: Readonly<(keyof Insertable<DB[TB]>)[]> | ['*']\n  ) => Insertable<DB[TB]>;\n\n  /**\n   * Transformation to apply to column values returned from inserts before", "   * returning values to the client. When inferring type parameters, specify\n   * a type for the `source` parameter. `source` is the object that was provided\n   * for insertion, and `returns` are the values returned from the insert.\n   */\n  insertReturnTransform?: (\n    source: InsertedObject,\n    returns: InsertReturnColumns extends []\n      ? never\n      : SelectedRow<\n          DB,\n          TB,\n          InsertReturnColumns extends ['*']\n            ? never\n            : InsertReturnColumns[number],\n          InsertReturnColumns\n        >\n  ) => InsertReturn;\n}\n", "export interface SelectTransform<\n  DB,\n  TB extends keyof DB & string,\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  SelectedObject\n> {\n  /**\n   * Transformation to apply to selected objects after retrieval from the\n   * database and before returning to the client. `row` is the selected\n   * row, as returned by the Kysely query.\n   */\n  selectTransform?: (\n    row: SelectedRow<\n      DB,\n      TB,\n      SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n      SelectedColumns\n    >\n  ) => SelectedObject;\n}\n", "export interface UpdateTransforms<\n  DB,\n  TB extends keyof DB & string,\n  UpdatingObject,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n  UpdateReturn\n> {\n  /**\n   * Transformation to apply to objects provided for updating rows. `source`\n   * is the object containing the values which which to update the table row.\n   * Only the columns in `columns` will actually be updated, with `[*]`\n   * indicating all columns.\n   */\n  updateTransform?: (\n    source: UpdatingObject,\n    columns: Readonly<(keyof Updateable<DB[TB]>)[]> | ['*']\n  ) => Updateable<DB[TB]>;\n\n  /**\n   * Transformation to apply to column values returned from updates before", "   * returning values to the client. When inferring type parameters, specify\n   * a type for the `source` parameter. `source` is the object that contained\n   * the valiues with which the table row was updated, and `returns` are the\n   * values returned from the update.\n   */\n  updateReturnTransform?: (\n    source: UpdatingObject,\n    returns: UpdateReturnColumns extends []\n      ? never\n      : SelectedRow<\n          DB,\n          TB,\n          UpdateReturnColumns extends ['*']\n            ? never\n            : UpdateReturnColumns[number],\n          UpdateReturnColumns\n        >\n  ) => UpdateReturn;\n}\n"]}
{"filename": "src/mappers/abstract-table-mapper.ts", "chunked_list": ["import {\n  Kysely,\n  Insertable,\n  ReferenceExpression,\n  Selectable,\n  InsertQueryBuilder,\n  InsertResult,\n  SelectQueryBuilder,\n  Selection,\n  DeleteQueryBuilder,", "  Selection,\n  DeleteQueryBuilder,\n  DeleteResult,\n  UpdateResult,\n  UpdateQueryBuilder,\n  ComparisonOperatorExpression,\n  OperandValueExpressionOrList,\n  Updateable,\n} from 'kysely';\n", "} from 'kysely';\n\nimport { QueryFilter } from '../lib/query-filter';\nimport { applyQueryFilter } from '../lib/apply-query-filter';\nimport {\n  SelectableColumnTuple,\n  SelectedRow,\n  SelectionColumn,\n} from '../lib/type-utils';\nimport { MappingDeleteQuery } from '../queries/delete-query';", "} from '../lib/type-utils';\nimport { MappingDeleteQuery } from '../queries/delete-query';\nimport { MappingSelectQuery } from '../queries/select-query';\nimport { MappingUpdateQuery } from '../queries/update-query';\nimport { AnyColumnsMappingInsertQuery } from '../queries/any-insert-query';\nimport { AnyColumnsMappingUpdateQuery } from '../queries/any-update-query';\nimport { ParametersObject, QueryParameterMaker } from 'kysely-params';\nimport { ParameterizableMappingQueryFactory } from '../lib/parameterizable-query-factory';\nimport { CompilingMappingSelectQuery } from '../queries/compiling-select-query';\nimport { CompilingMappingDeleteQuery } from '../queries/compiling-delete-query';", "import { CompilingMappingSelectQuery } from '../queries/compiling-select-query';\nimport { CompilingMappingDeleteQuery } from '../queries/compiling-delete-query';\nimport { SubsettingMappingUpdateQuery } from '../queries/subsetting-update-query';\nimport { CompilingMappingUpdateQuery } from '../queries/compiling-update-query';\nimport { TableMapperSettings } from './table-mapper-settings';\nimport { TableMapperTransforms } from './table-mapper-transforms';\n\n/**\n * Abstract base class for table mappers. It is abstract because it does not\n * provide a way to specify query input and output transforms. Custom table\n * mappers should extend this class with means for providing transforms.\n * @typeParam DB Interface whose fields are table names defining tables.\n * @typeParam TB Name of the table.\n * @typeParam KeyColumns Tuple of the names of the table's key columns.\n *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam SelectedColumns Columns to return from selection queries.\n *  Defaults to `['*']`, returning all columns. May specify aliases.\n * @typeParam SelectedObject Type of objects returned by select queries.\n * @typeParam InsertedObject Type of objects inserted into the table.\n * @typeParam UpdatingObject Type of objects used to update rows of the table.\n * @typeParam ReturnCount Type of the count of the number of affected rows.\n * @typeParam InsertReturnColumns Columns to return from the table on insert\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.\n * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none and is the default. May specify aliases.\n * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n *  whose properties are the columns of `InsertReturnColumns`.\n * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n *  whose properties are the columns of `UpdateReturnColumns`.\n */", " * Abstract base class for table mappers. It is abstract because it does not\n * provide a way to specify query input and output transforms. Custom table\n * mappers should extend this class with means for providing transforms.\n * @typeParam DB Interface whose fields are table names defining tables.\n * @typeParam TB Name of the table.\n * @typeParam KeyColumns Tuple of the names of the table's key columns.\n *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n * @typeParam SelectedColumns Columns to return from selection queries.\n *  Defaults to `['*']`, returning all columns. May specify aliases.\n * @typeParam SelectedObject Type of objects returned by select queries.\n * @typeParam InsertedObject Type of objects inserted into the table.\n * @typeParam UpdatingObject Type of objects used to update rows of the table.\n * @typeParam ReturnCount Type of the count of the number of affected rows.\n * @typeParam InsertReturnColumns Columns to return from the table on insert\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none. May specify aliases. Defaults to `KeyColumns`.\n * @typeParam UpdateReturnColumns Columns to return from the table on update\n *  queries that return columns. `['*']` returns all columns; `[]` returns\n *  none and is the default. May specify aliases.\n * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n *  whose properties are the columns of `InsertReturnColumns`.\n * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n *  whose properties are the columns of `UpdateReturnColumns`.\n */", "export abstract class AbstractTableMapper<\n  DB,\n  TB extends keyof DB & string,\n  KeyColumns extends\n    | Readonly<SelectableColumnTuple<DB[TB]>>\n    | Readonly<[]> = [],\n  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n  SelectedObject = SelectedRow<\n    DB,\n    TB,\n    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n    SelectedColumns\n  >,\n  InsertedObject = Insertable<DB[TB]>,\n  UpdatingObject = Updateable<DB[TB]>,\n  ReturnCount = bigint,\n  InsertReturnColumns extends\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'] = Readonly<KeyColumns>,\n  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n  InsertReturn = InsertReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, InsertReturnColumns[number]>,\n  UpdateReturn = UpdateReturnColumns extends ['*']\n    ? Selectable<DB[TB]>\n    : Selection<DB, TB, UpdateReturnColumns[number]>\n> {\n  #baseDeleteQB: DeleteQueryBuilder<DB, TB, DeleteResult> | null = null;\n  #baseInsertQB: InsertQueryBuilder<DB, TB, InsertResult> | null = null;\n  #baseSelectQB: SelectQueryBuilder<DB, TB, object> | null = null;\n  #baseUpdateQB: UpdateQueryBuilder<DB, TB, TB, UpdateResult> | null = null;\n\n  /** Columns that compose the table's primary key. */\n  protected readonly keyColumns: KeyColumns;\n\n  /** Columns to return from selection queries. `[]` => all columns. */\n  protected readonly selectedColumns: SelectionColumn<DB, TB>[];\n\n  /** Columns to return from the table on insert. */\n  protected readonly insertReturnColumns:\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'];\n\n  /** Columns to return from the table on update. */\n  protected readonly updateReturnColumns:\n    | Readonly<SelectionColumn<DB, TB>[]>\n    | ['*'];\n\n  /** Query input and output value transforms. */\n  protected transforms: TableMapperTransforms<\n    DB,\n    TB,\n    KeyColumns,\n    SelectedColumns,\n    SelectedObject,\n    InsertedObject,\n    UpdatingObject,\n    ReturnCount,\n    InsertReturnColumns,\n    UpdateReturnColumns,\n    InsertReturn,\n    UpdateReturn\n  > = {};\n\n  /**\n   * Constructs a new abstract table mapper.\n   * @param db The Kysely database.\n   * @param tableName The name of the table.\n   * @param options Options governing mapper behavior. Default to selecting\n   *  all columns and to returning no columns on insert or update.\n   */\n  constructor(\n    readonly db: Kysely<DB>,\n    readonly tableName: TB,\n    readonly settings: Readonly<\n      TableMapperSettings<\n        DB,\n        TB,\n        KeyColumns,\n        SelectedColumns,\n        InsertReturnColumns,\n        UpdateReturnColumns\n      >\n    > = {}\n  ) {\n    this.keyColumns = settings.keyColumns ?? ([] as any);\n\n    this.selectedColumns =\n      settings.selectedColumns === undefined\n        ? ([] as any)\n        : settings.selectedColumns[0] === '*'\n        ? ([] as any)\n        : settings.selectedColumns;\n\n    this.insertReturnColumns =\n      settings.insertReturnColumns ?? this.keyColumns ?? ([] as any);\n\n    this.updateReturnColumns = settings.updateReturnColumns ?? ([] as any);\n  }\n\n  /**\n   * Returns a mapping query for deleting the rows of the table that match\n   * the provided filter or Kysely binary operation.\n   * @param filter Optional filter to apply to the query or the left-hand-side\n   *  of a Kysely binary operation.\n   * @returns A mapping query for deleting rows.\n   */\n  delete<RE extends ReferenceExpression<DB, TB>>(\n    lhs: RE,\n    op: ComparisonOperatorExpression,\n    rhs: OperandValueExpressionOrList<DB, TB, RE>\n  ): MappingDeleteQuery<\n    DB,\n    TB,\n    DeleteQueryBuilder<DB, TB, DeleteResult>,\n    ReturnCount\n  >;\n\n  delete<RE extends ReferenceExpression<DB, TB>>(\n    filter?: QueryFilter<DB, TB, KeyColumns, RE>\n  ): MappingDeleteQuery<\n    DB,\n    TB,\n    DeleteQueryBuilder<DB, TB, DeleteResult>,\n    ReturnCount\n  >;\n\n  delete<RE extends ReferenceExpression<DB, TB>>(\n    filterOrLHS?: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n    op?: ComparisonOperatorExpression,\n    rhs?: OperandValueExpressionOrList<DB, TB, RE>\n  ): MappingDeleteQuery<\n    DB,\n    TB,\n    DeleteQueryBuilder<DB, TB, DeleteResult>,\n    ReturnCount\n  > {\n    return new MappingDeleteQuery(\n      this.db,\n      filterOrLHS === undefined\n        ? this.getDeleteQB()\n        : applyQueryFilter(\n            this.db,\n            this.getDeleteQB(),\n            this.keyColumns,\n            filterOrLHS,\n            op,\n            rhs\n          ),\n      this.transforms\n    );\n  }\n\n  /**\n   * Returns a query for inserting rows into the table.\n   * @returns A mapping query for inserting rows.\n   */\n  insert(): AnyColumnsMappingInsertQuery<\n    DB,\n    TB,\n    InsertQueryBuilder<DB, TB, InsertResult>,\n    InsertedObject,\n    InsertReturnColumns,\n    InsertReturn\n  > {\n    return new AnyColumnsMappingInsertQuery(\n      this.db,\n      this.getInsertQB(),\n      this.transforms,\n      this.insertReturnColumns as InsertReturnColumns\n    );\n  }\n\n  /**\n   * Creates and returns a parameterized mapping query, which can be repeatedly\n   * executed with different parameter values, but which only ever compiles\n   * the underlying Kysely query once (on the first execution).\n   * @paramtype Parameters Record characterizing the available parameter names\n   *  and types.\n   * @param factory Function that receives an object of the form `{ mapper,\n   *  param }`, where `mapper` is the present table mapper and `param` is a", "   *  function for creating parameters. The argument to `param` is the name of\n   *  the parameter, which must occur as a property of `Parameters`. You may\n   *  parameterize inserted values, updated values, and right-hand-side values\n   *  of filters. Parameters may not be arrays, but you can parameterize the\n   *  individual elements of an array. Returns a parameterized mapping query.\n   * @returns A parameterized mapping query\n   */\n  parameterize<Parameters extends ParametersObject<Parameters>>(\n    factory: ParameterizableMappingQueryFactory<\n      DB,\n      TB,\n      KeyColumns,\n      SelectedColumns,\n      SelectedObject,\n      InsertedObject,\n      UpdatingObject,\n      ReturnCount,\n      InsertReturnColumns,\n      UpdateReturnColumns,\n      InsertReturn,\n      UpdateReturn,\n      this,\n      Parameters,\n      MappingDeleteQuery<\n        DB,\n        TB,\n        DeleteQueryBuilder<DB, TB, DeleteResult>,\n        ReturnCount\n      >\n    >\n  ): CompilingMappingDeleteQuery<\n    DB,\n    TB,\n    DeleteQueryBuilder<DB, TB, DeleteResult>,\n    ReturnCount,\n    Parameters\n  >;\n\n  parameterize<Parameters extends ParametersObject<Parameters>>(\n    factory: ParameterizableMappingQueryFactory<\n      DB,\n      TB,\n      KeyColumns,\n      SelectedColumns,\n      SelectedObject,\n      InsertedObject,\n      UpdatingObject,\n      ReturnCount,\n      InsertReturnColumns,\n      UpdateReturnColumns,\n      InsertReturn,\n      UpdateReturn,\n      this,\n      Parameters,\n      MappingSelectQuery<\n        DB,\n        TB,\n        SelectedColumns,\n        SelectedObject,\n        SelectQueryBuilder<DB, TB, object>\n      >\n    >\n  ): CompilingMappingSelectQuery<\n    DB,\n    TB,\n    SelectedColumns,\n    SelectedObject,\n    SelectQueryBuilder<DB, TB, object>,\n    Parameters\n  >;\n\n  parameterize<Parameters extends ParametersObject<Parameters>>(\n    factory: ParameterizableMappingQueryFactory<\n      DB,\n      TB,\n      KeyColumns,\n      SelectedColumns,\n      SelectedObject,\n      InsertedObject,\n      UpdatingObject,\n      ReturnCount,\n      InsertReturnColumns,\n      UpdateReturnColumns,\n      InsertReturn,\n      UpdateReturn,\n      this,\n      Parameters,\n      SubsettingMappingUpdateQuery<\n        DB,\n        TB,\n        UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n        UpdatingObject,\n        UpdateReturnColumns,\n        ReturnCount,\n        UpdateReturn\n      >\n    >\n  ): CompilingMappingUpdateQuery<\n    DB,\n    TB,\n    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn,\n    Parameters\n  >;\n\n  parameterize<Parameters extends ParametersObject<Parameters>>(\n    factory: ParameterizableMappingQueryFactory<\n      DB,\n      TB,\n      KeyColumns,\n      SelectedColumns,\n      SelectedObject,\n      InsertedObject,\n      UpdatingObject,\n      ReturnCount,\n      InsertReturnColumns,\n      UpdateReturnColumns,\n      InsertReturn,\n      UpdateReturn,\n      this,\n      Parameters,\n      any\n    >\n  ): any {\n    const parameterMaker = new QueryParameterMaker<Parameters>();\n    return factory({\n      mapper: this,\n      param: parameterMaker.param.bind(parameterMaker),\n    }).compile();\n  }\n\n  /**\n   * Returns a reference to a column, which can be a generated string.\n   * (Shorthand for `db.dynamic.ref(column)`.)\n   * @param column The column name being referenced.\n   * @returns A reference to the given column.\n   */\n  ref(column: string) {\n    return this.db.dynamic.ref(column);\n  }\n\n  /**\n   * Returns a mapping query for selecting rows of the table that match\n   *  the provided filter or Kysely binary operation.\n   * @param filter Optional filter to apply to the query or the left-hand-side\n   *  of a Kysely binary operation.\n   * @returns A mapping query for retrieving rows as objects.\n   */\n  select<RE extends ReferenceExpression<DB, TB>>(\n    lhs: RE,\n    op: ComparisonOperatorExpression,\n    rhs: OperandValueExpressionOrList<DB, TB, RE>\n  ): MappingSelectQuery<\n    DB,\n    TB,\n    SelectedColumns,\n    SelectedObject,\n    SelectQueryBuilder<DB, TB, object>\n  >;\n\n  select<RE extends ReferenceExpression<DB, TB>>(\n    filter?: QueryFilter<DB, TB, KeyColumns, RE>\n  ): MappingSelectQuery<\n    DB,\n    TB,\n    SelectedColumns,\n    SelectedObject,\n    SelectQueryBuilder<DB, TB, object>\n  >;\n\n  select<RE extends ReferenceExpression<DB, TB>>(\n    filterOrLHS?: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n    op?: ComparisonOperatorExpression,\n    rhs?: OperandValueExpressionOrList<DB, TB, RE>\n  ): MappingSelectQuery<\n    DB,\n    TB,\n    SelectedColumns,\n    SelectedObject,\n    SelectQueryBuilder<DB, TB, object>\n  > {\n    return new MappingSelectQuery(\n      this.db,\n      filterOrLHS === undefined\n        ? this.getSelectQB()\n        : applyQueryFilter(\n            this.db,\n            this.getSelectQB(),\n            this.keyColumns,\n            filterOrLHS,\n            op,\n            rhs\n          ),\n      this.transforms\n    );\n  }\n\n  /**\n   * Returns a mapping query for updating rows of the table that match\n   *  the provided filter or Kysely binary operation.\n   * @param filter Optional filter to apply to the query or the left-hand-side\n   *  of a Kysely binary operation.\n   * @returns A mapping query for updating table rows.\n   */\n  update<RE extends ReferenceExpression<DB, TB>>(\n    lhs: RE,\n    op: ComparisonOperatorExpression,\n    rhs: OperandValueExpressionOrList<DB, TB, RE>\n  ): AnyColumnsMappingUpdateQuery<\n    DB,\n    TB,\n    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  >;\n\n  update<RE extends ReferenceExpression<DB, TB>>(\n    filter?: QueryFilter<DB, TB, KeyColumns, RE>\n  ): AnyColumnsMappingUpdateQuery<\n    DB,\n    TB,\n    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  >;\n\n  update<RE extends ReferenceExpression<DB, TB>>(\n    filterOrLHS?: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n    op?: ComparisonOperatorExpression,\n    rhs?: OperandValueExpressionOrList<DB, TB, RE>\n  ): MappingUpdateQuery<\n    DB,\n    TB,\n    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n    UpdatingObject,\n    UpdateReturnColumns,\n    ReturnCount,\n    UpdateReturn\n  > {\n    return new AnyColumnsMappingUpdateQuery(\n      this.db,\n      filterOrLHS === undefined\n        ? this.getUpdateQB()\n        : applyQueryFilter(\n            this.db,\n            this.getUpdateQB(),\n            this.keyColumns,\n            filterOrLHS,\n            op,\n            rhs\n          ),\n      this.transforms,\n      this.updateReturnColumns as UpdateReturnColumns\n    );\n  }\n\n  /**\n   * Returns a query builder for deleting rows from the table, caching the\n   * query builder for use with future deletions.\n   * @returns A query builder for deleting rows from the table.\n   */\n  protected getDeleteQB(): DeleteQueryBuilder<DB, TB, DeleteResult> {", "    if (this.#baseDeleteQB === null) {\n      this.#baseDeleteQB = this.db.deleteFrom(\n        this.tableName\n      ) as DeleteQueryBuilder<DB, TB, DeleteResult>;\n    }\n    return this.#baseDeleteQB;\n  }\n\n  /**\n   * Returns a query builder for inserting rows into the table, caching the\n   * query builder for use with future insertions.\n   * @returns A query builder for inserting rows into the table.\n   */\n  protected getInsertQB(): InsertQueryBuilder<DB, TB, InsertResult> {", "    if (this.#baseInsertQB === null) {\n      this.#baseInsertQB = this.db.insertInto(\n        this.tableName\n      ) as InsertQueryBuilder<DB, TB, InsertResult>;\n    }\n    return this.#baseInsertQB;\n  }\n\n  /**\n   * Returns a query builder for selecting rows from the table, caching the\n   * query builder for use with future selection. The query builder returns\n   * the columns and aliases specified in `SelectedColumns`.\n   * @returns A query builder for selecting rows from the table.\n   */\n  protected getSelectQB(): SelectedColumns extends ['*']\n    ? never\n    : SelectQueryBuilder<\n        DB,\n        TB,\n        object & Selection<DB, TB, SelectedColumns[number]>\n      >;\n\n  protected getSelectQB(): SelectQueryBuilder<DB, TB, object> {", "    if (this.#baseSelectQB === null) {\n      const selectQB = this.db.selectFrom(this.tableName) as SelectQueryBuilder<\n        DB,\n        TB,\n        object\n      >;\n      this.#baseSelectQB =\n        this.selectedColumns.length == 0\n          ? selectQB.selectAll()\n          : selectQB.select(this.selectedColumns);\n    }\n    return this.#baseSelectQB;\n  }\n\n  /**\n   * Returns a query builder for updating rows from the table, caching the\n   * query builder for use with future updates.\n   * @returns A query builder for updating rows from the table.\n   */\n  protected getUpdateQB(): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {", "    if (this.#baseUpdateQB === null) {\n      this.#baseUpdateQB = this.db.updateTable(this.tableName) as any;\n    }\n    return this.#baseUpdateQB!;\n  }\n}\n"]}
