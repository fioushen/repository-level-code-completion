{"filename": "src/defenitions.ts", "chunked_list": ["import { Request } from 'express';\n\ninterface RequestDefenition extends Request {\n  user: {\n    id: string;\n  };\n}\n\nexport default RequestDefenition;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import express from 'express';\nimport dotenv from 'dotenv';\nimport cors from 'cors';\nimport morgan from 'morgan';\nimport http from 'http';\nimport cookieParser from 'cookie-parser';\nimport rateLimit from 'express-rate-limit';\nimport socket from './utils/socket.io/socketio.js';\n\n//* Routers", "\n//* Routers\nimport userRouter from './router/user.js';\nimport adminRouter from './router/admin.js';\nimport doctorRouter from './router/doctor.js';\nimport router from './router/router.js';\nimport conversationRouter from './router/conversation.js';\nimport messageRouter from './router/message.js';\nimport connection from './config/mongodbConnection.js';\n", "import connection from './config/mongodbConnection.js';\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst app = express();", "\nconst app = express();\napp.use(limiter);\ndotenv.config();\n\n/*\n *connect mongodb\n */\nconnection();\n", "connection();\n\n/*\n *Use Middlewares\n */\napp.use(express.json());\napp.use(cookieParser());\napp.use(morgan('dev'));\napp.use(\n  cors({", "app.use(\n  cors({\n    origin: [\n      process.env.DOCTOR_URL,\n      process.env.USER_URL,\n      process.env.ADMIN_URL,\n    ],\n  }),\n);\n", ");\n\n/*\n *API Routes]\n */\n\napp.use('/api', router);\napp.use('/api/user', userRouter);\napp.use('/api/admin', adminRouter);\napp.use('/api/doctor', doctorRouter);", "app.use('/api/admin', adminRouter);\napp.use('/api/doctor', doctorRouter);\napp.use('/api/conversation', conversationRouter);\napp.use('/api/message', messageRouter);\n\n/*\n *Start Server\n */\n\napp.use((req, res) => {", "\napp.use((req, res) => {\n  res.send('Hey thats a 404');\n});\n\n/*\n *socket io\n */\n\nconst server = http.createServer(app);", "\nconst server = http.createServer(app);\n\nsocket(server);\n\nconst port = process.env.PORT || 8080;\n// eslint-disable-next-line no-console\nserver.listen(port, () => console.log(`Server Started on http://localhost:${port}`));\n", ""]}
{"filename": "src/Types/interface.ts", "chunked_list": ["export interface IAdmin {\n  name: string;\n  email: string;\n  password: string;\n}\n\nexport interface Ioptions {\n  page: number;\n  limit: number;\n}\nexport interface IAppointment {\n  userId: string;\n  firstName: string;\n  lastName: string;\n  age: string;\n  gender: string;\n  email: string;\n  mobile: string;\n  department: string;\n  symptoms: Array<string>;\n  date: string;\n  time: string;\n  doctorName: string;\n  doctorId: string;\n  price: string;\n  cancelled: boolean;\n  payment: boolean;\n  payment_intent: string;\n  active: boolean;\n}", "export interface IAppointment {\n  userId: string;\n  firstName: string;\n  lastName: string;\n  age: string;\n  gender: string;\n  email: string;\n  mobile: string;\n  department: string;\n  symptoms: Array<string>;\n  date: string;\n  time: string;\n  doctorName: string;\n  doctorId: string;\n  price: string;\n  cancelled: boolean;\n  payment: boolean;\n  payment_intent: string;\n  active: boolean;\n}", "export interface IBlog {\n  title: string;\n  content: string;\n  imageURL: string;\n}\n\nexport interface IConversation {\n  members: Array<string>;\n}\n\nexport interface IDept {\n  name: string;\n}\n", "export interface IDept {\n  name: string;\n}\n\nexport interface IDoctor {\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: number;\n  address: string;\n  profile: string;\n  photoURL: string;\n  dob: string;\n  department: string;\n  workTime: string;\n  fees: string;\n  leave: Array<string>;\n  password: string;\n}\n", "export interface IFeedback {\n  doctorId: string;\n  userId: string;\n  rating: number;\n  feedback: string;\n}\n\nexport interface IMessage {\n  conversationId: string;\n  sender: string;\n  text: string;\n}\n", "export interface IReportDoctor {\n  doctorId: string;\n  userId: string;\n  reason: string;\n}\n\nexport interface IUser {\n  name: string;\n  email: string;\n  profileURL: string;\n  blocked: boolean;\n  prescription: Array<object>;\n}\n"]}
{"filename": "src/utils/nodemailer.ts", "chunked_list": ["import nodemailer from 'nodemailer';\nimport fs from 'fs/promises';\nimport dotenv from 'dotenv';\n\nconst { readFile } = fs;\ndotenv.config();\n\nconst sendMail = async (mailType: string, email: string) => {\n  try {\n    let html: string | Buffer;\n    if (mailType === 'welcome') {\n      html = await readFile('./src/utils/mailHtml/welcome-mail.html', 'utf8');", "  try {\n    let html: string | Buffer;\n    if (mailType === 'welcome') {\n      html = await readFile('./src/utils/mailHtml/welcome-mail.html', 'utf8');\n    } else if ('appointment') {\n      html = await readFile('./src/utils/mailHtml/appointment-mail.html', 'utf8');\n    }\n\n    const transporter = nodemailer.createTransport({\n      service: 'gmail',\n      host: 'smtp.gmail.email',\n      port: 465,\n      auth: {\n        type: 'login',\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASS,\n      },\n    });\n\n    const info = await transporter.sendMail({\n      from: process.env.SMTP_USER, // sender address\n      to: email, // list of receivers\n      subject: 'Welcome To Halo-Doc', // Subject line\n      html,\n    });", "  } catch (error) {\n    console.log(error);\n    throw error;\n  }\n};\n\nexport default sendMail;\n"]}
{"filename": "src/utils/socket.io/socketio.ts", "chunked_list": ["import { Server } from 'socket.io';\nimport mongoose from 'mongoose';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport default function socketIo(server: any) {\n  const io = new Server(server, {\n    cors: {\n      origin: [process.env.DOCTOR_URL, process.env.USER_URL, process.env.ADMIN_URL],\n      methods: ['GET', 'POST'],\n    },\n  });\n\n  let users = [];\n\n  const addUser = (userId: mongoose.Types.ObjectId, socketId: string) => {\n    const userExists = users.some((user) => user.userId === userId);", "    if (!userExists) {\n      users.push({ userId, socketId });\n    }\n  };\n\n  const removeUser = (socketId: string) => {\n    users = users.filter((user) => user.socketId !== socketId);\n  };\n\n  const getUser = (userId: string) => {\n    const user = users.find((data) => data.userId === userId);\n    return user;\n  };\n\n  io.on('connection', (socket) => {\n    socket.on('addUser', (userId) => {\n      addUser(userId, socket.id);\n    });\n\n    io.emit('allUsers', users);\n\n    socket.on('sendMessage', ({ senderId, recieverId, text }) => {\n      const user = getUser(recieverId);\n      io.to(user?.socketId).emit('getMessage', {\n        senderId,\n        text,\n      });\n    });\n\n    socket.on('disconnect', () => {\n      removeUser(socket.id);\n    });\n  });\n}\n"]}
{"filename": "src/config/firebase.ts", "chunked_list": ["import { initializeApp, applicationDefault } from 'firebase-admin/app';\nimport { getAuth } from 'firebase-admin/auth';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\ninitializeApp({\n  credential: applicationDefault(),\n});\n", "});\n\nconst verifyFirebaseToken = async ({ idToken }: { idToken: string }) => {\n  // eslint-disable-next-line no-useless-catch\n  try {\n    // uid\n    const { uid } = await getAuth().verifyIdToken(idToken);\n\n    // user data\n    return await getAuth().getUser(uid);\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport default verifyFirebaseToken;\n", "  } catch (error) {\n    throw error;\n  }\n};\n\nexport default verifyFirebaseToken;\n"]}
{"filename": "src/config/mongodbConnection.ts", "chunked_list": ["import mongoose from 'mongoose';\n\nmongoose.connection.once('connected', () => {\n  console.log('db connected successfully');\n});\n\nconst connection = async () => {\n  try {\n    await mongoose.connect(process.env.MONGODB_URL);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nexport default connection;\n", "  } catch (error) {\n    console.log(error);\n  }\n};\n\nexport default connection;\n"]}
{"filename": "src/model/messageSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport { IMessage } from '../Types/interface.js';\n\ninterface MessageDocument extends IMessage, Document {}\n\nconst messageSchema = new Schema<MessageDocument>(\n  {\n    conversationId: {\n      type: String,\n      required: true,\n    },\n    sender: {\n      type: String,\n      required: true,\n    },\n    text: {\n      type: String,\n      required: true,\n    },\n  },\n  {\n    timestamps: true,\n  },\n);\n\nconst messageModel = mongoose.model<IMessage>('message', messageSchema);\nexport default messageModel;\n"]}
{"filename": "src/model/appointmentSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IAppointment } from '../Types/interface.js';\n\ninterface AppointmentDocument extends IAppointment, Document {}\n\nconst appointmentSchema = new Schema<AppointmentDocument>({\n  userId: {\n    type: String,\n    required: true,\n  },\n  firstName: {\n    type: String,\n    required: true,\n  },\n  lastName: {\n    type: String,\n    required: true,\n  },\n  age: {\n    type: String,\n    required: true,\n  },\n  gender: {\n    type: String,\n    required: true,\n  },\n  email: {\n    type: String,\n    required: true,\n  },\n  mobile: {\n    type: String,\n    required: true,\n  },\n  department: {\n    type: String,\n    required: true,\n  },\n  symptoms: {\n    type: [String],\n    required: true,\n  },\n  date: {\n    type: String,\n    required: true,\n  },\n  time: {\n    type: String,\n    required: true,\n  },\n  doctorName: {\n    type: String,\n    required: true,\n  },\n  doctorId: {\n    type: String,\n    required: true,\n  },\n  price: {\n    type: String,\n    required: true,\n  },\n  cancelled: {\n    type: Boolean,\n    default: false,\n  },\n  payment: {\n    type: Boolean,\n    default: true,\n  },\n  active: {\n    type: Boolean,\n    default: true,\n  },\n  payment_intent: {\n    type: String,\n  },\n});\n\nappointmentSchema.plugin(paginate);\nconst appointmentModel = mongoose.model<AppointmentDocument, mongoose.PaginateModel<AppointmentDocument>>('appointment', appointmentSchema);\nexport default appointmentModel;\n"]}
{"filename": "src/model/adminSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IAdmin } from '../Types/interface.js';\n\ninterface AdminDocument extends IAdmin, Document {}\n\nconst adminSchema = new Schema<AdminDocument>({\n  name: {\n    type: String,\n    required: true,\n  },\n  email: {\n    type: String,\n    required: true,\n  },\n  password: {\n    type: String,\n    required: true,\n  },\n});\n\nadminSchema.plugin(paginate);\n\nconst adminModel = mongoose.model<AdminDocument, mongoose.PaginateModel<AdminDocument>>('admin', adminSchema);\nexport default adminModel;\n"]}
{"filename": "src/model/reportDoctorSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IReportDoctor } from '../Types/interface.js';\n\ninterface ReportDocument extends IReportDoctor, Document {}\n\nconst reportDoctorSchema = new Schema<ReportDocument>({\n  doctorId: {\n    type: String,\n    required: true,\n  },\n  userId: {\n    type: String,\n    required: true,\n  },\n  reason: {\n    type: String,\n    required: true,\n  },\n});\n\nreportDoctorSchema.plugin(paginate);\nconst reportDoctorModel = mongoose.model<IReportDoctor>('ReportDoctor', reportDoctorSchema);\nexport default reportDoctorModel;\n"]}
{"filename": "src/model/conversationSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport { IConversation } from '../Types/interface.js';\n\ninterface ConversationDocument extends IConversation, Document {}\n\nconst conversationSchema = new Schema<ConversationDocument>(\n  {\n    members: {\n      type: [String],\n      required: true,\n    },\n  },\n  {\n    timestamps: true,\n  },\n);\n\nconst conversationModel = mongoose.model<IConversation>('conversation', conversationSchema);\nexport default conversationModel;\n"]}
{"filename": "src/model/feedback.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IFeedback } from '../Types/interface.js';\n\ninterface FeedbackDocument extends IFeedback, Document {}\n\nconst feedbackSchema = new Schema<FeedbackDocument>({\n  doctorId: {\n    type: String,\n    required: true,\n  },\n  userId: {\n    type: String,\n    required: true,\n  },\n  rating: {\n    type: Number,\n    required: true,\n  },\n  feedback: {\n    type: String,\n  },\n});\n\nfeedbackSchema.plugin(paginate);\nconst feedbackModel = mongoose.model<FeedbackDocument, mongoose.PaginateModel<FeedbackDocument>>('Feedback', feedbackSchema);\nexport default feedbackModel;\n"]}
{"filename": "src/model/blogSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IBlog } from '../Types/interface.js';\n\ninterface BlogDocument extends IBlog, Document {}\n\nconst blogSchema = new Schema<BlogDocument>({\n  title: {\n    type: String,\n    required: true,\n  },\n  content: {\n    type: String,\n    required: true,\n  },\n  imageURL: {\n    type: String,\n    required: true,\n  },\n});\n\nblogSchema.plugin(paginate);\nconst blogModel = mongoose.model<BlogDocument, mongoose.PaginateModel<BlogDocument>>('Blog', blogSchema);\nexport default blogModel;\n"]}
{"filename": "src/model/index.ts", "chunked_list": ["import USER from './userSchema.js';\nimport ADMIN from './adminSchema.js';\nimport DOCTOR from './doctorSchema.js';\nimport DEPARTMENT from './departmentSchema.js';\nimport BLOG from './blogSchema.js';\nimport APPOINTMENT from './appointmentSchema.js';\nimport MESSAGE from './messageSchema.js';\nimport CONVERSATION from './conversationSchema.js';\nimport REPORT_DOCTOR from './reportDoctorSchema.js';\nimport FEEDBACK from './feedback.js';", "import REPORT_DOCTOR from './reportDoctorSchema.js';\nimport FEEDBACK from './feedback.js';\n\nexport {\n  USER,\n  ADMIN,\n  DOCTOR,\n  DEPARTMENT,\n  BLOG,\n  APPOINTMENT,", "  BLOG,\n  APPOINTMENT,\n  MESSAGE,\n  CONVERSATION,\n  REPORT_DOCTOR,\n  FEEDBACK,\n};\n"]}
{"filename": "src/model/userSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IUser } from '../Types/interface.js';\n\ninterface UserDocument extends IUser, Document {}\n\nconst userSchema = new Schema<UserDocument>({\n  name: {\n    type: String,\n    required: true,\n  },\n  email: {\n    type: String,\n    required: true,\n  },\n  profileURL: {\n    type: String,\n    required: true,\n  },\n  prescription: {\n    type: [Object],\n  },\n});\n\nuserSchema.plugin(paginate);\nconst userModel = mongoose.model<UserDocument, mongoose.PaginateModel<UserDocument>>('user', userSchema);\nexport default userModel;\n"]}
{"filename": "src/model/doctorSchema.ts", "chunked_list": ["import mongoose, { Schema, Document } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IDoctor } from '../Types/interface.js';\n\ninterface DoctorDocument extends IDoctor, Document {}\n\nconst doctorSchema = new Schema<DoctorDocument>({\n  firstName: {\n    type: String,\n    required: true,\n  },\n  lastName: {\n    type: String,\n    required: true,\n  },\n  email: {\n    type: String,\n    required: true,\n  },\n  phone: {\n    type: Number,\n    required: true,\n  },\n  address: {\n    type: String,\n    required: true,\n  },\n  profile: {\n    type: String,\n    requied: true,\n  },\n  photoURL: {\n    type: String,\n    required: true,\n  },\n  dob: {\n    type: String,\n    required: true,\n  },\n  department: {\n    type: String,\n    required: true,\n  },\n  workTime: {\n    type: String,\n    required: true,\n  },\n  fees: {\n    type: String,\n    required: true,\n  },\n  leave: {\n    type: [String],\n  },\n  password: {\n    type: String,\n    required: true,\n  },\n});\n\ndoctorSchema.plugin(paginate);\n\nconst doctorModel = mongoose.model<DoctorDocument, mongoose.PaginateModel<DoctorDocument>>('Doctor', doctorSchema);\nexport default doctorModel;\n"]}
{"filename": "src/model/departmentSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\nimport paginate from 'mongoose-paginate-v2';\nimport { IDept } from '../Types/interface.js';\n\ninterface DepartmentDocument extends IDept, Document {}\n\nconst departmentSchema = new Schema<DepartmentDocument>({\n  name: {\n    type: String,\n    required: true,\n  },\n});\n\ndepartmentSchema.plugin(paginate);\nconst departmentModel = mongoose.model<IDept>('department', departmentSchema);\nexport default departmentModel;\n"]}
{"filename": "src/middlewares/auth.ts", "chunked_list": ["import jwt, { JwtPayload, VerifyErrors } from 'jsonwebtoken';\nimport { Response, NextFunction } from 'express';\nimport dotenv from 'dotenv';\nimport RequestDefenition from '../defenitions.js';\n\ndotenv.config();\n\nconst auth = async (req: RequestDefenition, res: Response, next: NextFunction) => {\n  try {\n    const token = req.headers.authorization?.split(' ')?.[1];\n", "  try {\n    const token = req.headers.authorization?.split(' ')?.[1];\n\n    if (!token) return res.status(401).send({ success: false, message: 'Missing Token' });\n\n    // eslint-disable-next-line max-len\n    jwt.verify(token, process.env.JWT_SECRET, (err: VerifyErrors | null, decoded: string | JwtPayload) => {\n      if (err) return res.status(401).send({ success: false, message: 'Invalid Token' });\n      req.user = { id: decoded?.['id'] };\n\n      next();\n    });", "  } catch (error) {\n    console.error('Error in auth midleware :- ', error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\nexport default auth;\n"]}
{"filename": "src/controller/doctorController.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport Stripe from 'stripe';\nimport mongoose from 'mongoose';\nimport {\n  APPOINTMENT, BLOG, DOCTOR, USER,\n} from '../model/index.js';\nimport { IBlog } from '../Types/interface.js';\n", "import { IBlog } from '../Types/interface.js';\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET, {\n  apiVersion: '2022-11-15',\n});\n\n//* Login\n\ninterface IDoctor {\n  _id: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: number;\n  address: string;\n  profile: string;\n  photoURL: string;\n  dob: string;\n  department: string;\n  workTime: string;\n  fees: string;\n  leave: Array<string>;\n  password: string;\n}\n\nexport const login = async (req: Request, res: Response) => {", "interface IDoctor {\n  _id: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: number;\n  address: string;\n  profile: string;\n  photoURL: string;\n  dob: string;\n  department: string;\n  workTime: string;\n  fees: string;\n  leave: Array<string>;\n  password: string;\n}\n\nexport const login = async (req: Request, res: Response) => {", "  try {\n    const { email, password } = req.body;\n    const doctor: IDoctor = await DOCTOR.findOne({ email });\n\n    if (!doctor) {\n      return res.status(200).send({ success: false, message: 'Doctor does not exist' });\n    }\n\n    const match = await bcrypt.compare(password, doctor.password);\n\n    if (match) {\n      const token: string = jwt.sign({ id: doctor._id }, process.env.JWT_SECRET, {\n        expiresIn: '15d',\n      });\n      doctor.password = null;\n      return res.status(200).send({\n        success: true,\n        message: 'Doctor login successfull',\n        doctor,\n        token,\n      });\n    }\n    return res.status(200).send({ success: false, message: 'Wrong Password' });", "    if (match) {\n      const token: string = jwt.sign({ id: doctor._id }, process.env.JWT_SECRET, {\n        expiresIn: '15d',\n      });\n      doctor.password = null;\n      return res.status(200).send({\n        success: true,\n        message: 'Doctor login successfull',\n        doctor,\n        token,\n      });\n    }\n    return res.status(200).send({ success: false, message: 'Wrong Password' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* add-blog\n\nexport const addBlog = async (req: Request, res: Response) => {\n  try {\n    const blogData: IBlog = {\n      title: req.body.title,\n      content: req.body.content,\n      imageURL: req.body.imageURL,\n    };\n\n    const blog = new BLOG(blogData);\n    await blog.save();\n\n    return res.status(200).send({ success: true, message: 'Blog adding successfull' });", "  try {\n    const blogData: IBlog = {\n      title: req.body.title,\n      content: req.body.content,\n      imageURL: req.body.imageURL,\n    };\n\n    const blog = new BLOG(blogData);\n    await blog.save();\n\n    return res.status(200).send({ success: true, message: 'Blog adding successfull' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* get-appointment\n\nexport const getAppointments = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const data = await APPOINTMENT.find({ doctorId: id });\n\n    return res.status(200).send({ success: true, message: 'Get Appointments Successful', data });", "  try {\n    const { id } = req.params;\n    const data = await APPOINTMENT.find({ doctorId: id });\n\n    return res.status(200).send({ success: true, message: 'Get Appointments Successful', data });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* cancel-appointment\n\nexport const cancelAppointment = async (req: Request, res: Response) => {", "  try {\n    const { id } = req.params;\n\n    const appointment = await APPOINTMENT.findOne({ _id: id });\n    if (!appointment) return res.status(404).send({ success: false, message: 'Appointment not found' });\n\n    await stripe.refunds.create({\n      payment_intent: appointment.payment_intent,\n    });\n\n    await APPOINTMENT.updateOne({ _id: id }, { cancelled: true, active: false });\n\n    return res.status(200).send({ success: true, message: 'Appointment cancelled successfully' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* get Doctor\n\nexport const getDoctor = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const doctor = await DOCTOR.find({ _id: id });\n    return res.status(200).send({ success: true, message: 'get doctor Successful', doctor });", "  try {\n    const { id } = req.params;\n    const doctor = await DOCTOR.find({ _id: id });\n    return res.status(200).send({ success: true, message: 'get doctor Successful', doctor });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* edit doctor\n\nexport const editDoctor = async (req: Request, res: Response) => {", "  try {\n    const { id } = req.params;\n\n    //* Destructuring Data from request body\n\n    const {\n      firstName,\n      fees,\n      workTime,\n      lastName,\n      email,\n      phone,\n      address,\n      department,\n      dob,\n      profile,\n      photoURL,\n    }: IDoctor = req.body;\n\n    const doctor = {\n      firstName,\n      lastName,\n      email,\n      phone,\n      address,\n      profile,\n      department,\n      dob,\n      fees,\n      workTime,\n      photoURL,\n    };\n\n    //  Updating Doctor Profile\n    const result = await DOCTOR.updateOne({ email }, doctor);\n    console.log(result);\n\n    return res.status(200).json({ success: true, message: 'Doctor profile edited succesfully' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).json({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Get-All-Doctors\n\nexport const getAllDoctors = async (req: Request, res: Response) => {\n  try {\n    const doctors = await DOCTOR.find({});\n    res.status(200).send({ success: true, message: 'get All doctors succesfull', data: doctors });", "  try {\n    const doctors = await DOCTOR.find({});\n    res.status(200).send({ success: true, message: 'get All doctors succesfull', data: doctors });\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* get Patients Stat\n\nexport const getPatients = async (req: Request, res: Response) => {", "  try {\n    const id = req.params?.id;\n    const patients = await APPOINTMENT.aggregate([\n      {\n        $group: {\n          _id: '$doctorId',\n          male: {\n            $sum: {\n              $cond: [{ $eq: ['$gender', 'male'] }, 1, 0],\n            },\n          },\n          female: {\n            $sum: {\n              $cond: [{ $eq: ['$gender', 'female'] }, 1, 0],\n            },\n          },\n          total: { $sum: 1 },\n        },\n      },\n      {\n        $project: {\n          _id: 0,\n          doctorId: '$_id',\n          male: 1,\n          female: 1,\n          total: 1,\n        },\n      },\n    ]);\n    res.status(200).send({ success: true, message: 'get patients successful', patients });", "  } catch (error) {\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* get total revenue\n\nexport const getTotalRevenue = async (req: Request, res: Response) => {\n  try {\n    const id = req.params?.id;\n    const revenue = await APPOINTMENT.aggregate([\n      {\n        $group: {\n          _id: null,\n          totalPrice: { $sum: { $toInt: '$price' } },\n        },\n      },\n    ]);\n\n    res.status(200).send({ success: true, message: 'get revenue successful', revenue: revenue[0].totalPrice });", "  try {\n    const id = req.params?.id;\n    const revenue = await APPOINTMENT.aggregate([\n      {\n        $group: {\n          _id: null,\n          totalPrice: { $sum: { $toInt: '$price' } },\n        },\n      },\n    ]);\n\n    res.status(200).send({ success: true, message: 'get revenue successful', revenue: revenue[0].totalPrice });", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Apply Leave\n\nexport const applyLeave = async (req: Request, res: Response) => {\n  try {\n    const { leaveDate, doctorId } = req.body;\n\n    const doctor = await DOCTOR.findOne({ _id: doctorId });\n", "  try {\n    const { leaveDate, doctorId } = req.body;\n\n    const doctor = await DOCTOR.findOne({ _id: doctorId });\n\n    if (!doctor) return res.status(404).send({ success: false, message: 'user not found' });\n\n    if (doctor?.leave?.includes(leaveDate)) {\n      return res.status(200).json({ success: false, message: 'Leave Already Applied on the Same Date' });\n    }\n\n    await DOCTOR.updateOne({ _id: doctorId }, { $push: { leave: leaveDate } });\n\n    return res.status(200).send({ success: true, message: 'Leave Applied Successfully' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Apply Leave\n\nexport const cancelLeave = async (req: Request, res: Response) => {\n  try {\n    const { leaveDate, doctorId } = req.body;\n\n    const doctor = await DOCTOR.findOne({ _id: doctorId });\n", "  try {\n    const { leaveDate, doctorId } = req.body;\n\n    const doctor = await DOCTOR.findOne({ _id: doctorId });\n\n    if (!doctor) return res.status(404).send({ success: false, message: 'user not found' });\n\n    if (doctor?.leave?.includes(leaveDate) === false) {\n      return res.status(200).json({ success: false, message: 'No Leave on the Same Date' });\n    }\n\n    const date = doctor.leave.filter((data) => data !== leaveDate);\n\n    await DOCTOR.updateOne({ _id: doctorId }, { leave: date });\n\n    const result = await DOCTOR.findOne({ _id: doctorId });\n\n    return res.status(200).send({ success: true, message: 'Leave Cancelled Successfully', result: result.leave });", "  } catch (error) {\n    console.log('Error in doctor:: cancel leave :- ', error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Add Prescription\n\nexport const addPrescription = async (req: Request, res: Response) => {\n  try {\n    const {\n      id, medicine, dosage, notes, doctor, date,\n    } = req.body;\n\n    const user = await USER.findOne({ _id: new mongoose.Types.ObjectId(id) });", "  try {\n    const {\n      id, medicine, dosage, notes, doctor, date,\n    } = req.body;\n\n    const user = await USER.findOne({ _id: new mongoose.Types.ObjectId(id) });\n    if (!user) return res.status(404).send({ success: false, message: 'Prescription not found with id' });\n\n    user.prescription.push({\n      id: user.prescription.length + 1,\n      medicine,\n      dosage,\n      notes,\n      doctor,\n      date,\n    });\n\n    await user.save();\n\n    return res.status(200).send({ success: true, message: 'Prescription added Successfully' });", "  } catch (error) {\n    console.error('Error in doctor: add prescription :-', error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* get monthly revenue\n\nexport const getMontlyRevenue = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    const result = await APPOINTMENT.aggregate([\n      {\n        $group: {\n          _id: {\n            month: { $month: { $toDate: '$date' } },\n            year: { $year: { $toDate: '$date' } },\n          },\n          revenue: { $sum: { $toDouble: '$price' } },\n        },\n      },\n      {\n        $sort: {\n          '_id.year': 1,\n          '_id.month': 1,\n        },\n      },\n    ]);\n\n    const monthlyRevenueArray = Array(12).fill(0);\n\n    result.forEach((item) => {\n      const monthIndex = item._id.month - 1;\n      monthlyRevenueArray[monthIndex] = item.revenue;\n    });\n\n    res.status(200).send({ success: true, message: 'get Revenue Successfull', data: result });", "  try {\n    const { id } = req.params;\n\n    const result = await APPOINTMENT.aggregate([\n      {\n        $group: {\n          _id: {\n            month: { $month: { $toDate: '$date' } },\n            year: { $year: { $toDate: '$date' } },\n          },\n          revenue: { $sum: { $toDouble: '$price' } },\n        },\n      },\n      {\n        $sort: {\n          '_id.year': 1,\n          '_id.month': 1,\n        },\n      },\n    ]);\n\n    const monthlyRevenueArray = Array(12).fill(0);\n\n    result.forEach((item) => {\n      const monthIndex = item._id.month - 1;\n      monthlyRevenueArray[monthIndex] = item.revenue;\n    });\n\n    res.status(200).send({ success: true, message: 'get Revenue Successfull', data: result });", "  } catch (error) {\n    console.log('error in get monthly revenue', error);\n    res.status(500).json({ error: 'Unable to retrieve the data' });\n  }\n};\n"]}
{"filename": "src/controller/message.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport { MESSAGE } from '../model/index.js';\n\nexport const newMessage = async (req: Request, res: Response) => {\n  try {\n    const { conversationId, sender, text } = req.body;\n    const newMsg = new MESSAGE({ conversationId, sender, text });\n    const messages = await newMsg.save();\n    return res.status(200).send({ success: true, message: 'New Message Successful', messages });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\nexport const getMessage = async (req: Request, res: Response) => {", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\nexport const getMessage = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const messages: object = await MESSAGE.find({ conversationId: id });\n    return res.status(200).send({ success: true, message: 'Get Message Successful', messages });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n"]}
{"filename": "src/controller/conversation.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport { CONVERSATION } from '../model/index.js';\n\n//* conversation controller\n\nexport const newConversation = async (req: Request, res: Response) => {\n  try {\n    const { senderId, recieverId } = req.body;\n\n    const newConvs = await new CONVERSATION({ members: [recieverId, senderId] });\n    const data = await newConvs.save();\n\n    return res.status(200).send({ success: true, message: 'Conversation Created Successfully', convId: data._id });", "  } catch (error) {\n    console.error(error);\n    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n  }\n};\n\nexport const getConversation = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const conversation = await CONVERSATION.find({\n      members: { $in: [id] },\n    });\n    return res.status(200).send({ success: true, message: 'get conversation successfull', conversation });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n"]}
{"filename": "src/controller/controllers.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport { BLOG, DEPARTMENT, DOCTOR } from '../model/index.js';\nimport { Ioptions } from '../Types/interface.js';\n\n//* Get-all-blogs\n\nexport const getAllBlogs = async (req: Request, res: Response) => {\n  try {\n    const { page } = req.query;\n\n    const options: Ioptions = {\n      page: Number(page) || 1,\n      limit: 12,\n    };\n\n    const data = await BLOG.paginate({}, options);\n\n    res.status(200).send({ success: true, message: 'get all blog successfull', data });", "  } catch (error) {\n    console.log('Error in common controller: Get-All-blogs :-', error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\nexport const getBlogs = async (req: Request, res: Response) => {\n  try {\n    const id = req.params;\n\n    const blog = BLOG.find({ _id: id });\n\n    return res.status(200).send({ success: true, message: 'get blog successful', data: blog });", "  } catch (error) {\n    console.log('Error in common controller: Get-blog :-', error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\nexport const getAllDoctors = async (req: Request, res: Response) => {\n  try {\n    const { page } = req.query;\n\n    const options: Ioptions = {\n      page: Number(page) || 1,\n      limit: 12,\n    };\n    const data = await DOCTOR.paginate({}, options);\n\n    return res.status(200).send({ success: true, message: 'get all Doctors Successful', data });", "  } catch (error) {\n    console.log('Error in common contoller - Get-all-doctors :-', error);\n    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n  }\n};\n\nexport const getDepartments = async (req: Request, res: Response) => {\n  try {\n    const department = await DEPARTMENT.find({});\n    return res.status(200).send({ success: true, message: 'get department successful', data: department });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n  }\n};\n\nexport const searchDoctors = async (req: Request, res: Response) => {", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n  }\n};\n\nexport const searchDoctors = async (req: Request, res: Response) => {\n  try {\n    const { keyword } = req.query;\n    const regex = new RegExp(keyword.toString(), 'i');\n\n    const result = await DOCTOR.find({ firstName: { $regex: regex } });\n    return res.status(200).send({ success: true, message: 'search doctor successful', result });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n  }\n};\n"]}
{"filename": "src/controller/userController.ts", "chunked_list": ["import dotenv from 'dotenv';\nimport { Request, Response } from 'express';\nimport Stripe from 'stripe';\nimport jwt from 'jsonwebtoken';\nimport * as exportJs from '../model/index.js';\nimport verifyFirebaseToken from '../config/firebase.js';\nimport mailService from '../utils/nodemailer.js';\nimport { IUser } from '../Types/interface.js';\n\ndotenv.config();", "\ndotenv.config();\nconst stripe = new Stripe(process.env.STRIPE_SECRET, {\n  apiVersion: '2022-11-15',\n});\n\n//* User SignUp\n\nexport const signup = async (req: Request, res: Response) => {\n  try {\n    /**\n     * * Getting user detiails from idToken\n     */\n\n    const { idToken } = req.body;\n    const user = await verifyFirebaseToken({ idToken });\n\n    const userData = {\n      name: user.displayName,\n      email: user.email,\n      profileURL: user?.photoURL ? user?.photoURL : false,\n    };\n\n    // * Saving userData to Database\n\n    const newUser = new exportJs.USER(userData);\n    const response = await newUser.save();\n    const id = response?._id;\n    const token = jwt.sign({ id }, process.env.JWT_SECRET, {\n      expiresIn: '15d',\n    });\n\n    mailService('welcome', user.email);\n\n    res.status(200).send({\n      success: true,\n      message: user?.photoURL ? 'google login succesful' : 'email login succesfull',\n      token,\n    });", "export const signup = async (req: Request, res: Response) => {\n  try {\n    /**\n     * * Getting user detiails from idToken\n     */\n\n    const { idToken } = req.body;\n    const user = await verifyFirebaseToken({ idToken });\n\n    const userData = {\n      name: user.displayName,\n      email: user.email,\n      profileURL: user?.photoURL ? user?.photoURL : false,\n    };\n\n    // * Saving userData to Database\n\n    const newUser = new exportJs.USER(userData);\n    const response = await newUser.save();\n    const id = response?._id;\n    const token = jwt.sign({ id }, process.env.JWT_SECRET, {\n      expiresIn: '15d',\n    });\n\n    mailService('welcome', user.email);\n\n    res.status(200).send({\n      success: true,\n      message: user?.photoURL ? 'google login succesful' : 'email login succesfull',\n      token,\n    });", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n\n//* User Login\n\nexport const login = async (req: Request, res: Response) => {\n  try {\n    /**\n     * * Getting user Details from idToken\n     */\n\n    const { idToken } = req.body;\n    const user = await verifyFirebaseToken({ idToken });\n", "  try {\n    /**\n     * * Getting user Details from idToken\n     */\n\n    const { idToken } = req.body;\n    const user = await verifyFirebaseToken({ idToken });\n\n    if (user) {\n      const userData = await exportJs.USER.findOne({ email: user?.email });\n\n      const id = userData?._id;\n      const token = jwt.sign({ id }, process.env.JWT_SECRET, {\n        expiresIn: '1d',\n      });\n\n      res.status(200).send({\n        success: true,\n        message: user?.photoURL ? 'google login succesful' : 'email login succesfull',\n        token,\n        user: userData,\n      });\n    }", "    if (user) {\n      const userData = await exportJs.USER.findOne({ email: user?.email });\n\n      const id = userData?._id;\n      const token = jwt.sign({ id }, process.env.JWT_SECRET, {\n        expiresIn: '1d',\n      });\n\n      res.status(200).send({\n        success: true,\n        message: user?.photoURL ? 'google login succesful' : 'email login succesfull',\n        token,\n        user: userData,\n      });\n    }", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Get User Info\n\nexport const getUserInfo = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const user = await exportJs.USER.findById(id).exec();\n\n    return res.status(200).send({ success: true, message: 'get user successful', data: user });", "  try {\n    const { id } = req.params;\n    const user = await exportJs.USER.findById(id).exec();\n\n    return res.status(200).send({ success: true, message: 'get user successful', data: user });\n  } catch (error) {\n    console.log('Error in userController : get user info :-', error);\n    return res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Get Doctors\n\nexport const getDoctorsbyDept = async (req: Request, res: Response) => {", "  try {\n    const { department } = req.query;\n    const doctors = await exportJs.DOCTOR.find({ department });\n    return res.status(200).send({ success: true, message: 'Get doctors by department successful', data: doctors });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n\n//* WEB-HOOK (! For Stripe Payment )\n\nexport const webHooks = async (req: Request, res: Response) => {", "  try {\n    const sig = req.headers['stripe-signature'];\n    const endpointSecret = null;\n    let event;\n    const jsonStringify = JSON.stringify(req.body);\n    const payloadBuffer = Buffer.from(jsonStringify);\n    let data;\n    let eventType;\n\n    if (endpointSecret) {\n      try {\n        event = stripe.webhooks.constructEvent(payloadBuffer, sig, endpointSecret);\n        // console.log('webhook verified');", "    if (endpointSecret) {\n      try {\n        event = stripe.webhooks.constructEvent(payloadBuffer, sig, endpointSecret);\n        // console.log('webhook verified');\n      } catch (err) {\n        console.log(`Webhook Error: ${err.message}`);\n        return res.status(400).send(`Webhook Error: ${err.message}`);\n      }\n      data = event.data.object;\n      eventType = event.type;\n    } else {\n      data = req.body.data.object;\n      eventType = req.body.type;\n    }\n", "    try {\n      if (eventType === 'checkout.session.completed') {\n        const customer = await stripe.customers.retrieve(data.customer);\n        // eslint-disable-next-line @typescript-eslint/dot-notation\n        const appointments = customer?.['metadata']?.appointments;\n        const newAppointment = new exportJs.APPOINTMENT(JSON.parse(appointments));\n        newAppointment.save();\n      }\n    } catch (error) {\n      console.log(`Webhook Error: ${error.message}`);\n    }\n    return res.send().end();", "    } catch (error) {\n      console.log(`Webhook Error: ${error.message}`);\n    }\n    return res.send().end();\n  } catch (error) {\n    console.log(`Webhook Error: ${error.message}`);\n  }\n};\n\n//* Creating Stripe Payment\n\nexport const payment = async (req: Request, res: Response) => {", "  try {\n    const bodyData = req.body;\n    try {\n      const newAppointment = new exportJs.APPOINTMENT(bodyData);\n      newAppointment.save();\n\n      const customer = await stripe.customers.create({\n        metadata: {\n          userId: bodyData.userId,\n          appointments: JSON.stringify(bodyData),\n        },\n      });\n\n      const session = await stripe.checkout.sessions.create({\n        line_items: [\n          {\n            price_data: {\n              currency: 'inr',\n              product_data: {\n                name: bodyData?.doctorName,\n                metadata: {\n                  id: bodyData.doctorId,\n                  appointments: JSON.stringify(bodyData),\n                },\n              },\n              unit_amount: bodyData.price * 100,\n            },\n            quantity: 1,\n          },\n        ],\n        customer: customer.id,\n        mode: 'payment',\n        success_url: `${process.env.CLIENT_URL}/success`,\n        cancel_url: `${process.env.CLIENT_URL}/failure`,\n      });\n\n      return res.status(200).send({ success: true, message: 'payment successful', url: session.url });", "    } catch (error) {\n      console.log(error);\n      return res.status(500).send({ success: false, message: 'Internal Server Error' });\n    }\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Cancel Appointment\n\nexport const cancelAppointment = async (req: Request, res: Response) => {", "  try {\n    const { id } = req.params;\n\n    const appointment: any = await exportJs.APPOINTMENT.find({ _id: id });\n    if (!appointment) return res.status(200).send({ success: false, message: 'Appointment not found' });\n\n    await stripe.refunds.create({\n      payment_intent: appointment?.payment_intent,\n      amount: appointment?.price,\n    });\n\n    return res.status(200).send({ success: true, message: 'Appointment cancelled successfully' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Check Available Timing\n\nexport const checkAvailableTiming = async (req: Request, res: Response) => {\n  try {\n    const { date, doctorId } = req.body;\n    const response = await exportJs.APPOINTMENT.find({ date, doctorId }).select('time').exec();\n    return res.status(200).send({ success: true, message: 'Check Availability Successful', data: response });", "  try {\n    const { date, doctorId } = req.body;\n    const response = await exportJs.APPOINTMENT.find({ date, doctorId }).select('time').exec();\n    return res.status(200).send({ success: true, message: 'Check Availability Successful', data: response });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Report Doctor\n\nexport const reportDoctor = async (req: Request, res: Response) => {", "  try {\n    const { userId, doctorId, reason } = req.body;\n\n    const newReport = await new exportJs.REPORT_DOCTOR({ userId, doctorId, reason });\n    await newReport.save();\n\n    return res.status(200).send({ success: true, message: 'doctor reported Successfully' });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* feedback\n\nexport const createFeedback = async (req: Request, res: Response) => {", "  try {\n    const { doctorId, userId, rating, feedback } = req.body;\n\n    const newFeedback = await new exportJs.FEEDBACK({\n      doctorId,\n      userId,\n      rating,\n      feedback,\n    });\n    await newFeedback.save();\n\n    return res.status(200).send({ success: true, message: 'Feedback added successfully' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\nexport const updateProfile = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    if (!id) return res.status(406).send({ success: false, message: 'Invalid token' });\n\n    const user: IUser | null = await exportJs.USER.findById(id);", "    if (!id) return res.status(406).send({ success: false, message: 'Invalid token' });\n\n    const user: IUser | null = await exportJs.USER.findById(id);\n    if (!user) return res.status(404).send({ success: false, message: 'User not found' });\n\n    const { name, email } = req.body;\n\n    const data = {\n      name: name || user.name,\n      email: email || user.email,\n    };\n\n    await exportJs.USER.findByIdAndUpdate(id, data);\n\n    return res.status(200).send({ success: true, message: 'Update profile successful' });", "  } catch (error) {\n    console.error('Error in user controller: Update Profile :-', error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\nexport const getAppointment = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    const appointments = await exportJs.APPOINTMENT.find({ userId: id });\n\n    res.status(200).send({ success: true, message: 'get user appointments successful', data: appointments });", "  } catch (error) {\n    console.log('Error in get user Appointment', error);\n    res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n"]}
{"filename": "src/controller/adminController.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport dotenv from 'dotenv';\nimport Stripe from 'stripe';\nimport { v2 as cloudinary } from 'cloudinary';\nimport { ADMIN, APPOINTMENT, BLOG, DEPARTMENT, DOCTOR, FEEDBACK, REPORT_DOCTOR, USER } from '../model/index.js';\nimport { Ioptions } from '../Types/interface.js';\n\ndotenv.config();", "\ndotenv.config();\n\n//* Initialize Cloudinary API\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});", "  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET, {\n  apiVersion: '2022-11-15',\n});\n\n/*\n *Admin Controllers\n */", " *Admin Controllers\n */\n\n//* ADMIN-LOGIN\n\nexport const login = async (req: Request, res: Response) => {\n  try {\n    //* validating email *\n\n    const user = await ADMIN.findOne({ email: req.body.email });\n    if (!user) {\n      // If no user returning error response with code 200\n      return res.status(200).send({ success: false, message: 'user does not exist', error: 'email' });\n    }\n\n    // comparing hashed password with bcrypt\n    const match = await bcrypt.compare(req.body.password, user.password);", "    if (!user) {\n      // If no user returning error response with code 200\n      return res.status(200).send({ success: false, message: 'user does not exist', error: 'email' });\n    }\n\n    // comparing hashed password with bcrypt\n    const match = await bcrypt.compare(req.body.password, user.password);\n    if (!match) {\n      // If the password is incorrect returning error with code 200\n      return res.status(200).send({ success: false, message: \"password doesn't match\", error: 'password' });\n    }\n\n    // Credential verified\n    // Creating a JWT token\n    const token: string = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {\n      expiresIn: '15d',\n    });\n\n    // Sending succes a succesful login response with token\n    return res.status(200).send({ success: true, message: 'login succesful', token });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).json({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Add-Doctor\n\ninterface IUserReqBody {\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  department: string;\n  dob: Date;\n  fees: string;\n  workTime: string;\n  photoURL: string;\n  password: string;\n  profile?: string;\n  address: string;\n}\n\nexport const addDoctor = async (req: Request, res: Response) => {", "interface IUserReqBody {\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  department: string;\n  dob: Date;\n  fees: string;\n  workTime: string;\n  photoURL: string;\n  password: string;\n  profile?: string;\n  address: string;\n}\n\nexport const addDoctor = async (req: Request, res: Response) => {", "  try {\n    //* Destructuring Data from request body\n\n    const {\n      firstName,\n      fees,\n      workTime,\n      lastName,\n      email,\n      phone,\n      address,\n      department,\n      dob,\n      profile,\n      photoURL,\n    }: IUserReqBody = req.body;\n\n    const doctorExists = await DOCTOR.findOne({ email });", "    if (doctorExists) {\n      // if doctor already exists with same email returning error with response code 200\n      return res.status(200).send({ success: false, message: 'Doctor already exists' });\n    }\n\n    const doctor = {\n      firstName,\n      lastName,\n      email,\n      phone,\n      address,\n      profile,\n      department,\n      dob,\n      fees,\n      workTime,\n      password: await bcrypt.hash(req.body.password, 10),\n      photoURL,\n    };\n\n    // Adding New Doctor to Database\n    const newDoctor = new DOCTOR(doctor);\n    newDoctor.save();\n\n    return res.status(200).json({ success: true, message: 'Doctor added succesfully' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).json({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Get-All-Doctors\n\nexport const getAllDoctors = async (req: Request, res: Response) => {\n  try {\n    const { page } = req.query;\n    const options: Ioptions = {\n      page: Number(page) || 1,\n      limit: 8,\n    };\n\n    const data = await DOCTOR.paginate({}, options);\n    res.status(200).send({ success: true, message: 'get All doctors succesfull', data });", "  try {\n    const { page } = req.query;\n    const options: Ioptions = {\n      page: Number(page) || 1,\n      limit: 8,\n    };\n\n    const data = await DOCTOR.paginate({}, options);\n    res.status(200).send({ success: true, message: 'get All doctors succesfull', data });\n  } catch (error) {\n    console.error('Error in admin: Get-Doctors :-', error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Delete-doctors\n\nexport const deleteDoctor = async (req: Request, res: Response) => {", "  } catch (error) {\n    console.error('Error in admin: Get-Doctors :-', error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Delete-doctors\n\nexport const deleteDoctor = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const doctor = await DOCTOR.findOne({ _id: id });\n    const result = await DOCTOR.deleteOne({ _id: id });\n", "  try {\n    const { id } = req.params;\n    const doctor = await DOCTOR.findOne({ _id: id });\n    const result = await DOCTOR.deleteOne({ _id: id });\n\n    if (result.acknowledged) {\n      res.status(200).send({ success: true, message: `DR. ${doctor.firstName} deleted succesfully` });\n    }\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Add-Department\n\nexport const addDepartment = async (req: Request, res: Response) => {", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'internal server error' });\n  }\n};\n\n//* Add-Department\n\nexport const addDepartment = async (req: Request, res: Response) => {\n  try {\n    //* Finding if the Department already exists or not\n    const { name } = req.body;\n    const deptExists = await DEPARTMENT.findOne({ name });", "  try {\n    //* Finding if the Department already exists or not\n    const { name } = req.body;\n    const deptExists = await DEPARTMENT.findOne({ name });\n    if (deptExists) {\n      //* if department exists returning error with code 200\n      return res.status(200).send({ success: false, message: 'Department already exists' });\n    }\n\n    //* Adding To Database\n\n    const newDept = new DEPARTMENT({ name });\n    const result = await newDept.save();\n", "    if (result) {\n      return res.status(200).send({ success: true, message: 'Department adding successful' });\n    }\n    return res.status(400).send({ success: false, message: 'Department adding failed' });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Add-Blog\n\nexport const addBlog = async (req: Request, res: Response) => {", "  try {\n    console.log(req.body);\n\n    const blogData = {\n      title: req.body.title,\n      content: req.body.content,\n      imageURL: req.body.imageURL,\n    };\n\n    const blog = new BLOG(blogData);\n    await blog.save();\n\n    return res.status(200).send({ success: true, message: 'Blog adding successfull' });", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Get Single Blog\n\nexport const getSingleBlog = async (req: Request, res: Response) => {\n  try {\n    const id = req.params?.id;\n    console.log(req.params?.id);\n\n    const blogData = await BLOG.findOne({ _id: id });\n", "  try {\n    const id = req.params?.id;\n    console.log(req.params?.id);\n\n    const blogData = await BLOG.findOne({ _id: id });\n\n    if (!blogData) return res.status(401).send({ success: false, message: 'no blog data found' });\n\n    return res.status(200).send({ success: true, message: 'Get Single Blog Successfull', data: blogData });\n  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* edit blog\n\nexport const editBlog = async (req: Request, res: Response) => {", "  } catch (error) {\n    console.log(error);\n    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* edit blog\n\nexport const editBlog = async (req: Request, res: Response) => {\n  try {\n    const { id }: { id?: string } = req.params;\n\n    const data = req.body;\n    const result = await BLOG.updateOne({ _id: id }, data);", "  try {\n    const { id }: { id?: string } = req.params;\n\n    const data = req.body;\n    const result = await BLOG.updateOne({ _id: id }, data);\n    if (result.acknowledged) res.status(200).send({ success: true, message: 'Edit Blog Successfull' });\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Delete Blog\n\nexport const deleteBlog = async (req: Request, res: Response) => {", "  try {\n    const { id } = req.params;\n    const result = await BLOG.deleteOne({ _id: id });\n\n    if (result.acknowledged) {\n      res.status(200).send({ success: true, message: 'delete blog Successful' });\n    }\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal server Error' });\n  }\n};\n\n//* Get-All-Users\n\nexport const getAllUsers = async (req: Request, res: Response) => {", "  try {\n    const { page } = req.query;\n\n    const options: Ioptions = {\n      page: Number(page) || 1,\n      limit: 6,\n    };\n\n    const data = await USER.paginate({}, options);\n\n    res.status(200).send({ success: true, message: 'get all users succesfull', data });", "  } catch (error) {\n    console.log('Error in admin - Get All Users :-', error);\n    res.status(500).send({ success: false, message: 'Internal server error' });\n  }\n};\n\n//* Get Doctor reports\n\nexport const getDoctorReports = async (req: Request, res: Response) => {\n  try {\n    const doctorReports = await REPORT_DOCTOR.find({});\n    res.status(200).send({ success: true, message: 'get doctor reports successfull', doctorReports });", "  try {\n    const doctorReports = await REPORT_DOCTOR.find({});\n    res.status(200).send({ success: true, message: 'get doctor reports successfull', doctorReports });\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Get User Feedbacks\n\nexport const getUserFeedbacks = async (req: Request, res: Response) => {", "  try {\n    const feedbacks = await FEEDBACK.find({});\n    res.status(200).send({ success: true, message: 'Get Feedbacks Successfull', feedbacks });\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Get Payments List\n\nexport const getPaymentsList = async (req: Request, res: Response) => {", "  try {\n    const PAGE_SIZE = 8;\n    const options = {\n      limit: PAGE_SIZE,\n    };\n    let charges;\n    const { page } = req.query;\n\n    if (page === 'next' && req.query.lastPaymentId) {\n      //* To get the next page of charges\n\n      charges = await stripe.charges.list({\n        ...options,\n        starting_after: req.query.lastPaymentId as string,\n      });", "    if (page === 'next' && req.query.lastPaymentId) {\n      //* To get the next page of charges\n\n      charges = await stripe.charges.list({\n        ...options,\n        starting_after: req.query.lastPaymentId as string,\n      });\n    } else if (page === 'prev' && req.query.firstPaymentId) {\n      //* To get the previous page of charges\n\n      charges = await stripe.charges.list({\n        ...options,\n        ending_before: req.query.firstPaymentId as string,\n      });\n    } else {\n      //* To get the first page of charges\n\n      charges = await stripe.charges.list(options);\n    }\n\n    res.status(200).send({ success: true, message: 'Get Payments Successful', payments: charges });", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* Get Payments refund List\n\nexport const getPaymentsRefundList = async (req: Request, res: Response) => {\n  try {\n    const PAGE_SIZE = 3;\n    const options = {\n      limit: PAGE_SIZE,\n    };\n    let refunds;\n    const { page } = req.query;\n", "  try {\n    const PAGE_SIZE = 3;\n    const options = {\n      limit: PAGE_SIZE,\n    };\n    let refunds;\n    const { page } = req.query;\n\n    if (page === 'next' && req.query.lastRefundId) {\n      //* To get the next page of refunds\n\n      refunds = await stripe.refunds.list({\n        ...options,\n        starting_after: req.query.lastRefundId as string,\n      });", "    if (page === 'next' && req.query.lastRefundId) {\n      //* To get the next page of refunds\n\n      refunds = await stripe.refunds.list({\n        ...options,\n        starting_after: req.query.lastRefundId as string,\n      });\n    } else if (page === 'prev' && req.query.firstRefundId) {\n      //* To get the previous page of refunds\n\n      refunds = await stripe.refunds.list({\n        ...options,\n        ending_before: req.query.firstRefundId as string,\n      });\n    } else {\n      //* To get the first page of refunds\n\n      refunds = await stripe.refunds.list(options);\n    }\n\n    res.status(200).send({ success: true, message: 'Get Refunds Successful', refunds });", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* get revenue\n\nexport const getRevenue = async (req: Request, res: Response) => {\n  try {\n    const revenue = await APPOINTMENT.aggregate([\n      { $match: { cancelled: false } },\n      { $group: { _id: null, totalPrice: { $sum: { $toInt: '$price' } } } },\n    ]);\n\n    // get today's date\n    const today = new Date();\n    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());\n    const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);\n\n    // group appointments by date and sum up prices\n    const result = await APPOINTMENT.aggregate([\n      {\n        $match: {\n          date: { $gte: startOfDay, $lt: endOfDay },\n        },\n      },\n      {\n        $group: {\n          _id: '$date',\n          totalPrice: { $sum: { $toDouble: '$price' } },\n        },\n      },\n    ]);\n\n    res.status(200).send({ success: true, message: 'get revenue successfull', revenue: revenue[0].totalPrice });", "  try {\n    const revenue = await APPOINTMENT.aggregate([\n      { $match: { cancelled: false } },\n      { $group: { _id: null, totalPrice: { $sum: { $toInt: '$price' } } } },\n    ]);\n\n    // get today's date\n    const today = new Date();\n    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());\n    const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);\n\n    // group appointments by date and sum up prices\n    const result = await APPOINTMENT.aggregate([\n      {\n        $match: {\n          date: { $gte: startOfDay, $lt: endOfDay },\n        },\n      },\n      {\n        $group: {\n          _id: '$date',\n          totalPrice: { $sum: { $toDouble: '$price' } },\n        },\n      },\n    ]);\n\n    res.status(200).send({ success: true, message: 'get revenue successfull', revenue: revenue[0].totalPrice });", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* get number of appointment\n\nexport const totalAppoinmtent = async (req: Request, res: Response) => {\n  try {\n    const maleCount: number = await APPOINTMENT.countDocuments({ gender: 'male' });\n    const femaleCount: number = await APPOINTMENT.countDocuments({ gender: 'female' });\n    const total: number = maleCount + femaleCount;\n    const data = {\n      maleCount,\n      femaleCount,\n      total,\n    };\n\n    res.status(200).send({ success: true, message: 'get revenue successfull', data });", "  try {\n    const maleCount: number = await APPOINTMENT.countDocuments({ gender: 'male' });\n    const femaleCount: number = await APPOINTMENT.countDocuments({ gender: 'female' });\n    const total: number = maleCount + femaleCount;\n    const data = {\n      maleCount,\n      femaleCount,\n      total,\n    };\n\n    res.status(200).send({ success: true, message: 'get revenue successfull', data });", "  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\n//* get number of doctors\n\nexport const getTotalDoctors = async (req: Request, res: Response) => {\n  try {\n    const doctorsCount: number = await DOCTOR.countDocuments({}, {});\n\n    res.status(200).send({ success: true, message: 'get revenue successfull', doctorsCount });", "  try {\n    const doctorsCount: number = await DOCTOR.countDocuments({}, {});\n\n    res.status(200).send({ success: true, message: 'get revenue successfull', doctorsCount });\n  } catch (error) {\n    console.log(error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n\nexport const getMonthlyRevenue = async (req: Request, res: Response) => {", "  try {\n    const result = await APPOINTMENT.aggregate([\n      {\n        $match: {\n          cancelled: false,\n        },\n      },\n      {\n        $group: {\n          _id: {\n            month: { $month: { $toDate: '$date' } },\n            year: { $year: { $toDate: '$date' } },\n          },\n          revenue: { $sum: { $toDouble: '$price' } },\n        },\n      },\n      {\n        $sort: {\n          '_id.year': 1,\n          '_id.month': 1,\n        },\n      },\n    ]);\n\n    const monthlyRevenueArray = Array(12).fill(0);\n\n    result.forEach((item) => {\n      const monthIndex = item._id.month - 1;\n      monthlyRevenueArray[monthIndex] = item.revenue;\n    });\n\n    return res.status(200).send({ success: true, message: 'get revenue successfull', data: monthlyRevenueArray });", "  } catch (error) {\n    console.error('Error:', error);\n    res.status(500).send({ success: false, message: 'Internal Server Error' });\n  }\n};\n"]}
{"filename": "src/router/message.ts", "chunked_list": ["import { Router } from 'express';\nimport * as controller from '../controller/message.js';\n\nconst router = Router();\n\nrouter.route('/').post(controller.newMessage);\nrouter.route('/:id').get(controller.getMessage);\n\nexport default router;\n", "export default router;\n"]}
{"filename": "src/router/conversation.ts", "chunked_list": ["import { Router } from 'express';\nimport * as conversationController from '../controller/conversation.js';\n\nconst router = Router();\n\nrouter.route('/').post(conversationController.newConversation);\nrouter.route('/:id').get(conversationController.getConversation);\n\nexport default router;\n", "export default router;\n"]}
{"filename": "src/router/doctor.ts", "chunked_list": ["import express from 'express';\nimport * as controller from '../controller/doctorController.js';\nimport auth from '../middlewares/auth.js';\n\nconst router = express.Router();\n\n//* login\n\nrouter.route('/login').post(controller.login);\n", "router.route('/login').post(controller.login);\n\n//* appointments\n\nrouter.route('/appointment/get-appointments/:id').get(auth, controller.getAppointments);\nrouter.route('/appointment/cancel-appointment/:id').patch(controller.cancelAppointment);\n\n//* get data\nrouter.route('/get-doctor/:id').get(controller.getDoctor);\nrouter.route('/edit-doctor/:id').patch(controller.editDoctor);", "router.route('/get-doctor/:id').get(controller.getDoctor);\nrouter.route('/edit-doctor/:id').patch(controller.editDoctor);\nrouter.route('/patients/:id').get(controller.getPatients);\n\n//* Add Prescription\n\nrouter.route('/add-prescription').post(controller.addPrescription);\n\n//* apply for Leave\n", "//* apply for Leave\n\nrouter.route('/apply-leave').patch(controller.applyLeave);\nrouter.route('/cancel-leave').patch(controller.cancelLeave);\n\n//* analytics\n\nrouter.route('/get-total-revenue/:id').get(controller.getTotalRevenue);\nrouter.route('/get-monthly-revenue/:id').get(controller.getMontlyRevenue);\n", "router.route('/get-monthly-revenue/:id').get(controller.getMontlyRevenue);\n\nexport default router;\n"]}
{"filename": "src/router/admin.ts", "chunked_list": ["import express from 'express';\nimport * as controller from '../controller/adminController.js';\n// import auth from '../middlewares/auth.js';\n\nconst router = express.Router();\n\n//* Login\n\nrouter.route('/login').post(controller.login);\n", "router.route('/login').post(controller.login);\n\n//* User Management\n\nrouter.route('/users/get-all-users').get(controller.getAllUsers);\n\n//* Doctors Management\n\nrouter.route('/doctors/add-doctors').post(controller.addDoctor);\nrouter.route('/doctors/get-all-doctors').get(controller.getAllDoctors);", "router.route('/doctors/add-doctors').post(controller.addDoctor);\nrouter.route('/doctors/get-all-doctors').get(controller.getAllDoctors);\nrouter.route('/doctors/add-new-department').post(controller.addDepartment);\nrouter.route('/doctors/delete-doctor/:id').delete(controller.deleteDoctor);\n\n//* Blog Management\n\nrouter.route('/blogs/add-blog').post(controller.addBlog);\nrouter.route('/blogs/edit-blog/:id').get(controller.editBlog);\nrouter.route('/blogs/get-single-blog/:id').get(controller.getSingleBlog);", "router.route('/blogs/edit-blog/:id').get(controller.editBlog);\nrouter.route('/blogs/get-single-blog/:id').get(controller.getSingleBlog);\nrouter.route('/blogs/delete-blog/:id').delete(controller.deleteBlog);\n\n//* report / feedback\n\nrouter.route('/get-doctor-reports').get(controller.getDoctorReports);\nrouter.route('/get-user-feedbacks').get(controller.getUserFeedbacks);\n\n//* Payments Data", "\n//* Payments Data\n\nrouter.route('/get-payments').get(controller.getPaymentsList);\nrouter.route('/get-payment-refunds').get(controller.getPaymentsRefundList);\n\n//* analytics\n\nrouter.route('/get-revenue').get(controller.getRevenue);\nrouter.route('/get-total-appointments').get(controller.totalAppoinmtent);", "router.route('/get-revenue').get(controller.getRevenue);\nrouter.route('/get-total-appointments').get(controller.totalAppoinmtent);\nrouter.route('/get-total-doctors').get(controller.getTotalDoctors);\nrouter.route('/get-monthly-revenue').get(controller.getMonthlyRevenue);\nexport default router;\n"]}
{"filename": "src/router/router.ts", "chunked_list": ["import express from 'express';\nimport * as controller from '../controller/controllers.js';\n\nconst router = express.Router();\n\n//* blogs\n\nrouter.route('/blogs/get-all-blogs').get(controller.getAllBlogs);\nrouter.route('/blogs/get-blog/:id').get(controller.getBlogs)\nrouter.route('/get-department').get(controller.getDepartments);", "router.route('/blogs/get-blog/:id').get(controller.getBlogs)\nrouter.route('/get-department').get(controller.getDepartments);\nrouter.route('/get-doctors').get(controller.getAllDoctors);\nrouter.route('/search-doctors').get(controller.searchDoctors);\n\nexport default router;\n"]}
{"filename": "src/router/user.ts", "chunked_list": ["import express from 'express';\nimport * as controller from '../controller/userController.js';\nimport auth from '../middlewares/auth.js';\n\nconst router = express.Router();\n\n//* Signup Login\n\nrouter.route('/signup').post(controller.signup);\nrouter.route('/login').post(controller.login);", "router.route('/signup').post(controller.signup);\nrouter.route('/login').post(controller.login);\n\n//* get doctors\n\nrouter.route('/get-user-info/:id').get(auth, controller.getUserInfo);\nrouter.route('/doctors-by-department').get(auth, controller.getDoctorsbyDept);\n\n//* Payment\n", "//* Payment\n\nrouter.route('/payment').post(auth, controller.payment);\nrouter.route('/webhook').post(auth, controller.webHooks);\n\n//* Appoinment\n\nrouter.route('/appointment/cancel-appointment/:id').patch(auth, controller.cancelAppointment);\nrouter.route('/check-available-timing').post(auth, controller.checkAvailableTiming);\nrouter.route('/get-appointments/:id').get(auth, controller.getAppointment);", "router.route('/check-available-timing').post(auth, controller.checkAvailableTiming);\nrouter.route('/get-appointments/:id').get(auth, controller.getAppointment);\n\n//* report / feedback\n\nrouter.route('/report-doctor').post(auth, controller.reportDoctor);\nrouter.route('/feedback').post(auth, controller.createFeedback);\n\n//* update Profile\n", "//* update Profile\n\nrouter.route('/update-profile').patch(auth, controller.updateProfile);\n\nexport default router;\n"]}
