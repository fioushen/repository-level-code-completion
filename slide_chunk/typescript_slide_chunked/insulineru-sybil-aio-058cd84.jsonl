{"filename": "src/utils/get-clients.ts", "chunked_list": ["import type { Chain, Hex, HttpTransport, PrivateKeyAccount, PublicClient, WalletClient } from 'viem'\nimport { createPublicClient, createWalletClient, http } from 'viem'\nimport { privateKeyToAccount } from 'viem/accounts'\nimport { NETWORKS } from '../data/config.js'\nimport type { Chains } from '../data/constants.js'\n\n// TODO: Singleton maybe?\nfunction getPublicClient({ network }: { network: Chains }): PublicClient {\n  const { rpc, viemChain } = NETWORKS[network]\n\n  return createPublicClient({ chain: viemChain, transport: http(rpc) })\n}\n", "function getWalletClient({ network, privateKey }: { network: Chains; privateKey: Hex }): WalletClient<HttpTransport, Chain, PrivateKeyAccount> {\n  const { rpc, viemChain } = NETWORKS[network]\n\n  return createWalletClient({ chain: viemChain, account: privateKeyToAccount(privateKey), transport: http(rpc) })\n}\n\nexport { getPublicClient, getWalletClient }\n"]}
{"filename": "src/utils/split-array.ts", "chunked_list": ["function splitArray<T>(array: T[], x: number): T[][] {\n  const result: T[][] = []\n\n  for (let i = 0; i < x; i++) {\n    const subArray = array.filter((_, index) => index % x === i)\n    result.push(subArray)\n  }\n\n  return result\n}\n\nexport { splitArray }\n"]}
{"filename": "src/utils/get-evm-wallet.ts", "chunked_list": ["import type { Address } from 'viem/accounts'\nimport { privateKeyToAccount } from 'viem/accounts'\n\nexport function getEvmWallet(privateKey: Address) {\n  const account = privateKeyToAccount(privateKey)\n\n  return account.address\n}\n"]}
{"filename": "src/data/config.ts", "chunked_list": ["import { arbitrum, avalanche, bsc, fantom, mainnet, optimism, polygon, polygonZkEvm, zkSync } from 'viem/chains'\nimport type { CexKeys, CexKeysWithPassword } from '../models/cex.js'\nimport type { NetworkConfiguration } from '../models/network.js'\n\n// \u0422\u043e\u043a\u0435\u043d \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0431\u043e\u0442\u0430. \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043c\u043e\u0436\u043d\u043e \u0443 @BotFather \u0432 Telegram.\nconst TELEGRAM_BOT_TOKEN = ''\n// \u041a\u0443\u0434\u0430 \u0431\u0443\u0434\u0443\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c\u0441\u044f \u043b\u043e\u0433\u0438. \u041c\u043e\u0436\u043d\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0433\u0440\u0443\u043f\u043f\u0443, \u043a\u043e\u043d\u0442\u0430\u043a\u0442, \u043a\u0430\u043d\u0430\u043b.\nconst TELEGRAM_USER_ID = ''\n\n// \u0417\u0434\u0435\u0441\u044c \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u043f\u043e\u0434\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0441\u0432\u043e\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f RPC.", "\n// \u0417\u0434\u0435\u0441\u044c \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f \u043f\u043e\u0434\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0441\u0432\u043e\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f RPC.\nconst NETWORKS: NetworkConfiguration = {\n  ethereum: {\n    rpc: 'https://eth.rpc.blxrbdn.com',\n    scan: 'https://etherscan.io/tx',\n    token: 'ETH',\n    chain_id: 1,\n    viemChain: mainnet,\n  },", "    viemChain: mainnet,\n  },\n\n  optimism: {\n    rpc: 'https://mainnet.optimism.io',\n    scan: 'https://optimistic.etherscan.io/tx',\n    token: 'ETH',\n    chain_id: 10,\n    viemChain: optimism,\n  },", "    viemChain: optimism,\n  },\n\n  bsc: {\n    rpc: 'https://bsc-dataseed1.ninicoin.io',\n    scan: 'https://bscscan.com/tx',\n    token: 'BNB',\n    chain_id: 56,\n    viemChain: bsc,\n  },", "    viemChain: bsc,\n  },\n\n  polygon: {\n    rpc: 'https://rpc.ankr.com/polygon',\n    scan: 'https://polygonscan.com/tx',\n    token: 'MATIC',\n    chain_id: 137,\n    viemChain: polygon,\n  },", "    viemChain: polygon,\n  },\n\n  polygonZkEvm: {\n    rpc: 'https://zkevm-rpc.com',\n    scan: 'https://zkevm.polygonscan.com/tx',\n    token: 'ETH',\n    chain_id: 1101,\n    viemChain: polygonZkEvm,\n  },", "    viemChain: polygonZkEvm,\n  },\n\n  arbitrum: {\n    rpc: 'https://arb1.croswap.com/rpc',\n    scan: 'https://arbiscan.io/tx',\n    token: 'ETH',\n    chain_id: 42161,\n    viemChain: arbitrum,\n  },", "    viemChain: arbitrum,\n  },\n\n  avalanche: {\n    rpc: 'https://rpc.ankr.com/avalanche',\n    scan: 'https://snowtrace.io/tx',\n    token: 'AVAX',\n    chain_id: 43114,\n    viemChain: avalanche,\n  },", "    viemChain: avalanche,\n  },\n\n  fantom: {\n    rpc: 'https://rpc.ankr.com/fantom',\n    scan: 'https://ftmscan.com/tx',\n    token: 'FTM',\n    chain_id: 250,\n    viemChain: fantom,\n  },", "    viemChain: fantom,\n  },\n\n  nova: {\n    rpc: 'https://nova.arbitrum.io/rpc',\n    scan: 'https://nova.arbiscan.io/tx',\n    token: 'ETH',\n    chain_id: 42170,\n    viemChain: undefined, // TODO: Add nova chain\n  },", "    viemChain: undefined, // TODO: Add nova chain\n  },\n\n  zksync: {\n    rpc: 'https://mainnet.era.zksync.io',\n    scan: 'https://explorer.zksync.io/tx',\n    token: 'ETH',\n    chain_id: 324,\n    viemChain: zkSync,\n  },", "    viemChain: zkSync,\n  },\n}\n\n// \u0410\u043f\u0438 \u043a\u043b\u044e\u0447\u0438 \u043e\u0442 \u0431\u0438\u0440\u0436. \u0435\u0441\u043b\u0438 \u0431\u0438\u0440\u0436\u0435\u0439 \u043d\u0435 \u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0448\u044c\u0441\u044f, \u043c\u043e\u0436\u043d\u043e \u043d\u0435 \u0432\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c\nconst CEX_KEYS: {\n  [key: string]: CexKeys\n} = {\n  // binance: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n  // mexc: { api_key: 'your_api_key', api_secret: 'your_api_secret' },", "  // binance: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n  // mexc: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n  // kucoin: { api_key: 'your_api_key', api_secret: 'your_api_secret', password: 'your_api_password' },\n  // huobi: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n  // bybit: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n}\n\n// \u043c\u043e\u0436\u0435\u0448\u044c \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043b\u044e\u0431\u043e\u0435 \u043a\u043e\u043b-\u0432\u043e \u0430\u043a\u043a\u0430\u0443\u043d\u0442\u043e\u0432, \u0441\u0434\u0435\u043b\u0430\u043b \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u043e \u0434\u0430\u043d\u043d\u044b\u0435 \u043e\u0442 \u043d\u043e\u0432\u044b\u0445 \u0430\u043a\u043a\u043e\u0432 \u043d\u0435 \u0432\u0432\u043e\u0434\u0438\u0442\u044c, \u0430 \u043f\u0440\u043e\u0441\u0442\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u043f\u043e \u0438\u043c\u0435\u043d\u0438 \u0430\u043a\u043a\u0430\u0443\u043d\u0442\u0430\nconst OKX_KEYS: {\n  [account_name: string]: CexKeysWithPassword", "const OKX_KEYS: {\n  [account_name: string]: CexKeysWithPassword\n} = {\n  account_1: {\n    api_key: 'your_api_key',\n    api_secret: 'your_api_secret',\n    password: 'your_api_password',\n  },\n  account_2: {\n    api_key: 'your_api_key',", "  account_2: {\n    api_key: 'your_api_key',\n    api_secret: 'your_api_secret',\n    password: 'your_api_password',\n  },\n}\n\nexport { TELEGRAM_BOT_TOKEN, TELEGRAM_USER_ID, NETWORKS, CEX_KEYS, OKX_KEYS }\n", ""]}
{"filename": "src/data/wallets.ts", "chunked_list": ["import type { Hex } from 'viem'\n\n// \u0417\u0434\u0435\u0441\u044c \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0445 \u043a\u043b\u044e\u0447\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0431\u0443\u0434\u0443\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0432 \u043c\u043e\u0434\u0443\u043b\u0435.\nconst WALLETS: Hex[] = [\n]\n\nexport { WALLETS }\n"]}
{"filename": "src/data/abi.ts", "chunked_list": ["const ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string',\n      },", "        type: 'string',\n      },\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: false,\n    inputs: [", "    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address',\n      },\n      {\n        name: '_value',\n        type: 'uint256',\n      },", "        type: 'uint256',\n      },\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool',\n      },\n    ],", "      },\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',", "    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    payable: false,\n    stateMutability: 'view',", "    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address',", "        name: '_from',\n        type: 'address',\n      },\n      {\n        name: '_to',\n        type: 'address',\n      },\n      {\n        name: '_value',\n        type: 'uint256',", "        name: '_value',\n        type: 'uint256',\n      },\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool',\n      },", "        type: 'bool',\n      },\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [],", "    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8',\n      },\n    ],\n    payable: false,", "    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',", "      {\n        name: '_owner',\n        type: 'address',\n      },\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256',", "        name: 'balance',\n        type: 'uint256',\n      },\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: true,", "  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string',\n      },\n    ],", "      },\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    constant: false,\n    inputs: [\n      {", "    inputs: [\n      {\n        name: '_to',\n        type: 'address',\n      },\n      {\n        name: '_value',\n        type: 'uint256',\n      },\n    ],", "      },\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool',\n      },\n    ],\n    payable: false,", "    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',", "      {\n        name: '_owner',\n        type: 'address',\n      },\n      {\n        name: '_spender',\n        type: 'address',\n      },\n    ],\n    name: 'allowance',", "    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    payable: false,\n    stateMutability: 'view',", "    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback',\n  },\n  {", "  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address',\n      },\n      {", "      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256',", "        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'Approval',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [", "    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        name: 'to',", "        indexed: true,\n        name: 'to',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256',\n      },\n    ],", "      },\n    ],\n    name: 'Transfer',\n    type: 'event',\n  },\n] as const\n\nexport { ERC20_ABI }\n", ""]}
{"filename": "src/data/constants.ts", "chunked_list": ["enum Chains {\n  Ethereum = 'ethereum',\n  Optimism = 'optimism',\n  Bsc = 'bsc',\n  Polygon = 'polygon',\n  PolygonZkEvm = 'polygonZkEvm',\n  Arbitrum = 'arbitrum',\n  Avalanche = 'avalanche',\n  Fantom = 'fantom',\n  Nova = 'nova',\n  Zksync = 'zksync',\n}\n\nexport { Chains }\n"]}
{"filename": "src/data/settings.ts", "chunked_list": ["import type { Web3CheckerAlert, Web3CheckerParameters, Web3CheckerTokens } from '../models/web3-checker.js'\nimport { Chains } from './constants.js'\n\n// \u041c\u043e\u0434\u0443\u043b\u044c \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u043e\u043a\u0435\u043d\u044b, \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0435 \u0432 \u044d\u0442\u043e\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u0435.\nconst ONCHAIN_BALANCES_TOKENS: Web3CheckerTokens = {\n  [Chains.Bsc]: [\n    '', // BNB\n    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC\n    '0x55d398326f99059ff775485246999027b3197955', // USDT\n  ],", "    '0x55d398326f99059ff775485246999027b3197955', // USDT\n  ],\n  [Chains.Arbitrum]: [\n    '', // ETH\n    '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9', // USDT\n    '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8', // USDC\n  ],\n  [Chains.Optimism]: [\n    '', // ETH\n    '0x7f5c764cbc14f9669b88837ca1490cca17c31607', // USDC", "    '', // ETH\n    '0x7f5c764cbc14f9669b88837ca1490cca17c31607', // USDC\n    '0x4200000000000000000000000000000000000042', // OP\n    // '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT\n  ],\n  // [Chains.Polygon]: [\n  //   '', // MATIC\n  // ],\n  // [Chains.Avalanche]: [\n  //   '', // AVAX", "  // [Chains.Avalanche]: [\n  //   '', // AVAX\n  // ],\n  [Chains.Ethereum]: [\n    '', // ETH\n    // '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT\n  ],\n  // [Chains.zkSync]: [\n  //   '', // ETH\n  // ],", "  //   '', // ETH\n  // ],\n  // [Chains.Nova]: [\n  //   '', // ETH\n  // ],\n  // [Chains.Fantom]: [\n  //   '', // FTM\n  // ],\n}\n", "}\n\n// \u0417\u0434\u0435\u0441\u044c \u043c\u043e\u0436\u043d\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u043a\u0440\u0438\u0442\u0435\u0440\u0438\u0439 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430.\n// \u0415\u0441\u043b\u0438 \u0431\u0430\u043b\u0430\u043d\u0441 \u043c\u0435\u043d\u044c\u0448\u0435 \u044d\u0442\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f, \u0442\u043e \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d \u0430\u043b\u0435\u0440\u0442 \u0432 \u0442\u0435\u043b\u0435\u0433\u0440\u0430\u043c.\n// \u0414\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043d\u0430\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0442\u043e\u043a\u0435\u043d\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443.\n// \u0414\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u0441\u0435\u0442\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0443 Chains \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 constants.ts.\nconst ONCHAIN_BALANCES_ALERTS: Web3CheckerAlert[] = [\n  // {\n  //   chain: Chains.Ethereum,\n  //   coin: '',", "  //   chain: Chains.Ethereum,\n  //   coin: '',\n  //   amount: 0.1, // Amount \u0431\u0435\u0437 \u0443\u0447\u0435\u0442\u0430 decimals.\n  // },\n]\n\n// \u0421\u043a\u0440\u0438\u043f\u0442\u044b \u043d\u0435 \u0431\u0443\u0434\u0443\u0442 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0442\u044c\u0441\u044f, \u0435\u0441\u043b\u0438 \u0433\u0430\u0437 \u0431\u0443\u0434\u0435\u0442 \u0441\u0442\u043e\u0438\u0442\u044c \u0432 \u0434\u043e\u043b\u043b\u0430\u0440\u0430\u0445 \u0434\u043e\u0440\u043e\u0436\u0435 \u044d\u0442\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f.\n// const GAS_AMOUNT_LIMITS: Web3CheckerGasAmountLimit = {\n//   // [Chains.Ethereum]: 10,\n//   // [Chains.Zksync]: 2,", "//   // [Chains.Ethereum]: 10,\n//   // [Chains.Zksync]: 2,\n// }\n\nconst ONCHAIN_BALANCES_PARAMETERS: Web3CheckerParameters = {\n  tokens: ONCHAIN_BALANCES_TOKENS,\n  alerts: ONCHAIN_BALANCES_ALERTS,\n  isNeedSaveToFile: true,\n  fileName: 'web3-balances',\n}", "  fileName: 'web3-balances',\n}\n\nexport { ONCHAIN_BALANCES_PARAMETERS }\n"]}
{"filename": "src/models/web3-checker.ts", "chunked_list": ["import type { Address } from 'viem'\nimport type { Chains } from '../data/constants.js'\n\ntype Web3CheckerTokens = {\n  [key in Chains]?: Array<Address | ''>\n}\n\ninterface Web3ChekerTokenInfo {\n  [key: string]: {\n    [key: string]: {\n      symbol: string\n      decimals: number\n      address: Address\n      price?: number\n    }\n  }\n}\n", "interface Web3CheckerTokensResult {\n  [wallet: string]: {\n    [chain in Chains]?: {\n      [token: string]: bigint\n    }\n  }\n}\n\ninterface Web3CheckerAlert {\n  chain: Chains\n  coin: Address | ''\n  amount: number\n}\n", "interface Web3CheckerAlert {\n  chain: Chains\n  coin: Address | ''\n  amount: number\n}\n\ntype Web3CheckerGasAmountLimit = {\n  [key in Chains]?: number\n}\n\ninterface Web3CheckerParameters {\n  tokens: Web3CheckerTokens\n  alerts: Web3CheckerAlert[]\n  fileName: string\n  isNeedSaveToFile: boolean\n  // maxGwei?: number\n  // gasLimits: Web3CheckerGasAmountLimit\n  // isNeedTgAlerts: boolean\n  // isNeedTgBalances: boolean\n  // isCheckGweiEnabled: boolean\n}\n\nexport type { Web3CheckerTokens, Web3ChekerTokenInfo, Web3CheckerTokensResult, Web3CheckerAlert, Web3CheckerGasAmountLimit, Web3CheckerParameters }\n", "interface Web3CheckerParameters {\n  tokens: Web3CheckerTokens\n  alerts: Web3CheckerAlert[]\n  fileName: string\n  isNeedSaveToFile: boolean\n  // maxGwei?: number\n  // gasLimits: Web3CheckerGasAmountLimit\n  // isNeedTgAlerts: boolean\n  // isNeedTgBalances: boolean\n  // isCheckGweiEnabled: boolean\n}\n\nexport type { Web3CheckerTokens, Web3ChekerTokenInfo, Web3CheckerTokensResult, Web3CheckerAlert, Web3CheckerGasAmountLimit, Web3CheckerParameters }\n"]}
{"filename": "src/models/network.ts", "chunked_list": ["import type { Chain } from 'viem'\nimport type { Chains } from '../data/constants.js'\n\ntype NetworkConfiguration = {\n  [key in Chains]: {\n    rpc: string\n    scan: string\n    token: string\n    chain_id: number\n    viemChain?: Chain\n  }\n}\n\nexport type { NetworkConfiguration }\n"]}
{"filename": "src/models/cex.ts", "chunked_list": ["interface CexKeys {\n  api_key: string\n  api_secret: string\n  password?: string\n}\n\ninterface CexKeysWithPassword extends CexKeys {\n  password: string\n}\n\nexport { CexKeys, CexKeysWithPassword }\n"]}
{"filename": "src/modules/web3-checker.ts", "chunked_list": ["// Here is a brief technical description of each function in the Python script:\nimport { createWriteStream } from 'node:fs'\nimport { dirname, join } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport Table from 'cli-table3'\nimport type { Address, Hex } from 'viem'\nimport { formatUnits } from 'viem'\nimport { got } from 'got'\nimport { splitArray } from '../utils/split-array.js'\nimport { NETWORKS } from '../data/config.js'\nimport { getEvmWallet } from '../utils/get-evm-wallet.js'\nimport { ERC20_ABI } from '../data/abi.js'\nimport type { Chains } from '../data/constants.js'\nimport { WALLETS } from '../data/wallets.js'\nimport type { Web3CheckerTokens, Web3CheckerTokensResult, Web3ChekerTokenInfo } from '../models/web3-checker.js'\nimport { getPublicClient } from '../utils/get-clients.js'\nimport { ONCHAIN_BALANCES_PARAMETERS } from '../data/settings.js'\n", "async function getTokenInfo(tokens: Web3CheckerTokens): Promise<Web3ChekerTokenInfo> {\n  const chains = Object.keys(tokens) as Chains[]\n  const clients = chains.map(chain => getPublicClient({ network: chain }))\n\n  const symbolParams = {\n    abi: ERC20_ABI,\n    functionName: 'symbol',\n  }\n\n  const decimalsParams = {\n    abi: ERC20_ABI,\n    functionName: 'decimals',\n  }\n\n  const erc20Requests = clients.map(async (client, index) => {\n    const chain = chains[index]\n    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\n    const contracts = chainTokens.flatMap(token => [\n      {\n        address: token,\n        ...symbolParams,\n      },\n      {\n        address: token,\n        ...decimalsParams,\n      },\n    ])\n\n    return await client.multicall({\n      contracts,\n    })\n  })\n\n  const erc20Results = (await Promise.all(erc20Requests)).map((chainResults, chainIndex) => {\n    const chain = chains[chainIndex]\n    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\n    const chainInfo: any = {}\n    chainResults.flat().forEach((el, index) => {\n      const isSymbol = index % 2 === 0\n      const tokenIndex = Math.floor(index / 2)\n      const tokenAddress = chainTokens[tokenIndex]\n", "      if (!chainInfo[tokenAddress])\n        chainInfo[tokenAddress] = {}\n      if (isSymbol)\n        chainInfo[tokenAddress].symbol = el.result as string\n\n      else\n        chainInfo[tokenAddress].decimals = el.result as number\n    })\n\n    // check and process gas token\n    if (tokens[chain]?.includes('')) {\n      chainInfo[''] = {\n        symbol: NETWORKS[chain].token,\n        decimals: 18,\n      }\n    }\n\n    return { [chain]: chainInfo }\n  })\n\n  const tokenInfo: Web3ChekerTokenInfo = Object.assign({}, ...erc20Results)\n\n  // Fetching prices\n  const uniqueSymbols = new Set<string>()", "    if (tokens[chain]?.includes('')) {\n      chainInfo[''] = {\n        symbol: NETWORKS[chain].token,\n        decimals: 18,\n      }\n    }\n\n    return { [chain]: chainInfo }\n  })\n\n  const tokenInfo: Web3ChekerTokenInfo = Object.assign({}, ...erc20Results)\n\n  // Fetching prices\n  const uniqueSymbols = new Set<string>()", "  for (const chain of Object.values(tokenInfo)) {\n    for (const token of Object.values(chain))\n      uniqueSymbols.add(token.symbol)\n  }\n\n  const priceRequests = Array.from(uniqueSymbols).map(async (symbol) => {\n    try {\n      const response = await got(`https://min-api.cryptocompare.com/data/price?fsym=${symbol}&tsyms=USDT`).json<{ USDT: number }>()\n      return { [symbol]: response.USDT }\n    }\n    catch (error: any) {\n      console.error(`Failed to fetch price for ${symbol}: ${error.message}`)\n      return { [symbol]: 0 }\n    }\n  })\n\n  const prices = Object.assign({}, ...(await Promise.all(priceRequests)))\n\n  // Adding prices to token info", "    catch (error: any) {\n      console.error(`Failed to fetch price for ${symbol}: ${error.message}`)\n      return { [symbol]: 0 }\n    }\n  })\n\n  const prices = Object.assign({}, ...(await Promise.all(priceRequests)))\n\n  // Adding prices to token info\n  for (const chain of Object.keys(tokenInfo) as Chains[]) {\n    for (const token of Object.keys(tokenInfo[chain]!))\n      tokenInfo[chain]![token].price = prices[tokenInfo![chain]![token].symbol] || 0\n  }\n\n  return tokenInfo\n}\n", "  for (const chain of Object.keys(tokenInfo) as Chains[]) {\n    for (const token of Object.keys(tokenInfo[chain]!))\n      tokenInfo[chain]![token].price = prices[tokenInfo![chain]![token].symbol] || 0\n  }\n\n  return tokenInfo\n}\n\nasync function getBalances(tokens: Web3CheckerTokens) {\n  const chains = Object.keys(tokens) as Chains[]\n\n  const clients = chains.map(chain => getPublicClient({ network: chain }))\n\n  const balanceParams = {\n    abi: ERC20_ABI,\n    functionName: 'balanceOf',\n  }\n\n  const erc20Requests = clients.map(async (client, index) => {\n    const chain = chains[index]\n    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\n    const contracts = WALLETS.map((wallet) => {\n      return chainTokens.map((token) => {\n        return {\n          address: token,\n          args: [getEvmWallet(wallet)],\n          ...balanceParams,\n        }\n      })\n    }).flat()\n\n    return await client.multicall({\n      contracts,\n    })\n  })\n\n  const erc20Results = (await Promise.all(erc20Requests)).flatMap((result) => {\n    return result.flat().map(el => el.result as bigint)\n  })\n\n  const gasRequests = Object.entries(tokens).map(async ([chain, tokens]) => {", "async function getBalances(tokens: Web3CheckerTokens) {\n  const chains = Object.keys(tokens) as Chains[]\n\n  const clients = chains.map(chain => getPublicClient({ network: chain }))\n\n  const balanceParams = {\n    abi: ERC20_ABI,\n    functionName: 'balanceOf',\n  }\n\n  const erc20Requests = clients.map(async (client, index) => {\n    const chain = chains[index]\n    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\n    const contracts = WALLETS.map((wallet) => {\n      return chainTokens.map((token) => {\n        return {\n          address: token,\n          args: [getEvmWallet(wallet)],\n          ...balanceParams,\n        }\n      })\n    }).flat()\n\n    return await client.multicall({\n      contracts,\n    })\n  })\n\n  const erc20Results = (await Promise.all(erc20Requests)).flatMap((result) => {\n    return result.flat().map(el => el.result as bigint)\n  })\n\n  const gasRequests = Object.entries(tokens).map(async ([chain, tokens]) => {", "    if (tokens.includes('')) {\n      const client = getPublicClient({ network: chain as Chains })\n\n      const balances = await Promise.all(\n        WALLETS.map(async (wallet) => {\n          return await client.getBalance({ address: getEvmWallet(wallet) })\n        }),\n      )\n\n      return balances.flat()\n    }\n  }).filter(Boolean)\n\n  const gasResults = await (await Promise.all(gasRequests as Promise<bigint[]>[])).flat()\n\n  return [...erc20Results, ...gasResults]\n}\n", "function formatResults(walletBalances: bigint[][], wallets: Hex[], tokens: Web3CheckerTokens) {\n  const finalBalances: Web3CheckerTokensResult = {}\n  wallets.forEach((privateKey, walletIndex) => {\n    const wallet = getEvmWallet(privateKey)\n    const walletBalance = walletBalances[walletIndex]\n    let balanceIndex = 0\n\n    for (const chain of Object.keys(tokens) as Chains[]) {\n      if (!finalBalances[wallet])\n        finalBalances[wallet] = {}\n\n      const chainTokens = tokens[chain]", "      if (!finalBalances[wallet])\n        finalBalances[wallet] = {}\n\n      const chainTokens = tokens[chain]\n      if (chainTokens) {\n        if (!finalBalances[wallet][chain])\n          finalBalances[wallet][chain] = {}\n\n        for (const token of chainTokens) {\n          if (token) { // if not gas token\n            finalBalances![wallet]![chain]![token] = walletBalance[balanceIndex++]\n          }\n        }\n      }\n    }\n", "        for (const token of chainTokens) {\n          if (token) { // if not gas token\n            finalBalances![wallet]![chain]![token] = walletBalance[balanceIndex++]\n          }\n        }\n      }\n    }\n\n    for (const chain of Object.keys(tokens) as Chains[]) {\n      if (!finalBalances[wallet])\n        finalBalances[wallet] = {}\n\n      const chainTokens = tokens[chain]", "    for (const chain of Object.keys(tokens) as Chains[]) {\n      if (!finalBalances[wallet])\n        finalBalances[wallet] = {}\n\n      const chainTokens = tokens[chain]\n      if (chainTokens) {\n        if (!finalBalances[wallet][chain])\n          finalBalances[wallet][chain] = {}\n\n        if (chainTokens.includes(''))\n          finalBalances![wallet]![chain]![''] = walletBalance[balanceIndex++]\n      }\n    }\n  })\n\n  return finalBalances\n}\n", "        if (chainTokens.includes(''))\n          finalBalances![wallet]![chain]![''] = walletBalance[balanceIndex++]\n      }\n    }\n  })\n\n  return finalBalances\n}\n\nfunction printBalancesTable(formattedBalances: Web3CheckerTokensResult, tokens: Web3CheckerTokens, tokenInfo: Web3ChekerTokenInfo) {\n  let csvData = 'number,wallet,'\n  const chainsList: Chains[] = []\n  const totalBalances: { [chain: string]: { [token: string]: bigint } } = {}\n", "function printBalancesTable(formattedBalances: Web3CheckerTokensResult, tokens: Web3CheckerTokens, tokenInfo: Web3ChekerTokenInfo) {\n  let csvData = 'number,wallet,'\n  const chainsList: Chains[] = []\n  const totalBalances: { [chain: string]: { [token: string]: bigint } } = {}\n\n  for (const chain of Object.keys(tokens) as Chains[]) {\n    chainsList.push(chain)\n    for (const token of tokens[chain]!) {\n      csvData += `${tokenInfo[chain][token].symbol}-${chain},`\n      totalBalances[chain] = totalBalances[chain] || {}\n      totalBalances[chain][token] = BigInt(0) // Initialize total balance\n    }\n  }\n\n  csvData = csvData.slice(0, -1) // Remove trailing comma\n  csvData += '\\n'\n\n  // Add wallet balances\n  let walletNumber = 1", "  for (const wallet of Object.keys(formattedBalances)) {\n    // let shortAddress = wallet.substring(0, 6) + '...' + wallet.substring(address.length - 4);\n    const formattedWallet = `${wallet.substring(0, 6)}...${wallet.substring(wallet.length - 4)}`\n    csvData += `${walletNumber++},${formattedWallet},`\n    for (const chain of chainsList) {\n      for (const token of tokens[chain]!) {\n        const balance = formattedBalances[wallet]![chain]![token]\n        const decimals = tokenInfo[chain][token].decimals\n        const readableBalance = formatUnits(balance, decimals)\n        csvData += `${parseFloat(readableBalance).toFixed(4)},`\n        totalBalances[chain][token] += balance\n      }\n    }\n    csvData = csvData.slice(0, -1) // Remove trailing comma\n    csvData += '\\n'\n  }\n\n  // Add total balances\n  csvData += ',TOTAL,'\n  let totalValueUSD = 0\n  const totalValuesPerTokenUSD: { [token: string]: number } = {}", "  for (const chain of chainsList) {\n    for (const token of tokens[chain]!) {\n      const totalBalance = totalBalances[chain][token]\n      const decimals = tokenInfo[chain][token].decimals\n      const price = tokenInfo[chain][token].price\n      const readableBalance = formatUnits(totalBalance, decimals)\n      csvData += `${parseFloat(readableBalance).toFixed(4)},`\n      const valueUSD = Number(readableBalance) * price!\n      totalValueUSD += valueUSD\n      const tokenSymbolWithChain = `${tokenInfo[chain][token].symbol}-${chain}`\n      totalValuesPerTokenUSD[tokenSymbolWithChain] = (totalValuesPerTokenUSD[tokenSymbolWithChain] || 0) + valueUSD\n    }\n  }\n  csvData = csvData.slice(0, -1) // Remove trailing comma\n  csvData += '\\n'\n\n  // Add total value in USD\n  csvData += `TOTAL_VALUE:,${totalValueUSD.toFixed(2)} $,`\n", "  for (const chain of chainsList) {\n    for (const token of tokens[chain]!) {\n      const tokenValueUSD = totalValuesPerTokenUSD[`${tokenInfo[chain][token].symbol}-${chain}`]\n      csvData += `${tokenValueUSD.toFixed(2)} $,`\n    }\n  }\n\n  csvData = csvData.slice(0, -1) // Remove trailing comma\n  csvData += '\\n'\n\n  // Convert CSV data to table format\n  const lines = csvData.split('\\n')\n  const headers = lines[0].split(',')\n  const tableData = lines.slice(1, -1).map(line => line.split(',')) // exclude the last line since it could be empty\n\n  // Transpose the table data\n  const transposedData = headers.map((header, i) => [header, ...tableData.map(row => row[i])])\n\n  // Create a new table and push the transposed data into the table\n  const table = new Table()\n  transposedData.forEach(row => table.push(row))\n\n  // Print the table to the console\n  console.log(table.toString())\n\n  // Write data to CSV file\n  const directory = dirname(fileURLToPath(import.meta.url))\n  const path = join(directory, `../../results/${ONCHAIN_BALANCES_PARAMETERS.fileName}.csv`)\n  const csvStream = createWriteStream(path)\n  csvStream.write(csvData)\n  csvStream.end()\n}\n", "async function main() {\n  const { tokens } = ONCHAIN_BALANCES_PARAMETERS\n  const allBalances = await getBalances(tokens)\n  const walletBalances = splitArray(allBalances, WALLETS.length)\n\n  const formattedBalances = formatResults(walletBalances, WALLETS, tokens)\n\n  const tokenInfo = await getTokenInfo(tokens)\n\n  printBalancesTable(formattedBalances, tokens, tokenInfo)\n}\n\nmain()\n"]}
