{"filename": "src/index.ts", "chunked_list": ["export * from './abstract/abstract-validator';\nexport * from './abstract/abstract-standard-validator';\nexport * from './abstract/abstract-typed-union-validator';\nexport * from './standard/index';\nexport * from './heterogeneous/index';\nexport * from './discriminated/index';\nexport * from './lib/validation-exception';\n\nexport { ValueError } from '@sinclair/typebox/value';\n", "export { ValueError } from '@sinclair/typebox/value';\n"]}
{"filename": "src/test/discriminated-union-validators-valid.test.ts", "chunked_list": ["import { TObject, TSchema, TUnion, Type } from '@sinclair/typebox';\n\nimport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\nimport { DiscriminatedUnionValidator } from '../discriminated/discriminated-union-validator';\nimport { CompilingDiscriminatedUnionValidator } from '../discriminated/compiling-discriminated-union-validator';\nimport {\n  ValidUnionTestSpec,\n  ValidatorKind,\n  MethodKind,\n  ValidatorCache,", "  MethodKind,\n  ValidatorCache,\n  ValidTestSpec,\n} from './test-utils';\nimport { testValidSpecs } from './test-valid-specs';\nimport { AbstractValidator } from '../abstract/abstract-validator';\n\nconst onlyRunValidator = ValidatorKind.All;\nconst onlyRunMethod = MethodKind.All;\n", "const onlyRunMethod = MethodKind.All;\n\nconst wellFormedUnion1 = Type.Union([\n  Type.Object({\n    kind: Type.Literal('s'),\n    str1: Type.String(),\n    str2: Type.Optional(Type.String()),\n  }),\n  Type.Object({\n    kind: Type.Literal('i'),", "  Type.Object({\n    kind: Type.Literal('i'),\n    int1: Type.Integer(),\n    int2: Type.Optional(Type.Integer()),\n  }),\n]);\n\nconst wellFormedUnion2 = Type.Union(\n  [\n    Type.Object({", "  [\n    Type.Object({\n      str1: Type.String(),\n      t: Type.Literal('s'),\n      str2: Type.Optional(Type.String()),\n    }),\n    Type.Object({\n      int1: Type.Integer(),\n      int2: Type.Optional(Type.Integer()),\n      t: Type.Literal('i'),", "      int2: Type.Optional(Type.Integer()),\n      t: Type.Literal('i'),\n    }),\n  ],\n  { discriminantKey: 't', errorMessage: 'Unknown type' }\n);\n\nconst wellFormedUnion3 = Type.Union(\n  [\n    Type.Object({", "  [\n    Type.Object({\n      \"s'quote\": Type.Literal(100),\n      str1: Type.String(),\n    }),\n    Type.Object({\n      \"s'quote\": Type.Literal(200),\n      int1: Type.Integer(),\n    }),\n  ],", "    }),\n  ],\n  { discriminantKey: \"s'quote\" }\n);\n\nconst validatorCache = new ValidatorCache();\n\ndescribe('discriminated union validators - valid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('DiscriminatedUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new DiscriminatedUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('DiscriminatedUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new DiscriminatedUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "  if (runThisValidator(ValidatorKind.Compiling)) {\n    describe('CompilingDiscriminatedUnionValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getCompiling(\n          schema,\n          () =>\n            new CompilingDiscriminatedUnionValidator(\n              schema as TUnion<TObject[]>\n            )\n        )\n      );\n    });\n  }\n});\n", "function testValidator(\n  createValidator: (schema: TSchema) => AbstractValidator<TSchema>\n) {\n  testValidSpecs(runThisTest, createValidator, verifyCleaning, [\n    {\n      description: 'valid discrim union 1, no unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { kind: 's', str1: 'hello' },\n      selectedIndex: 0,\n    },\n    {\n      description: 'valid discrim union 2, no unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { kind: 'i', int1: 1 },\n      selectedIndex: 1,\n    },\n    {\n      description: 'valid discrim union 3, with unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: {\n        kind: 's',\n        str1: 'hello',\n        int1: 1,\n        unrecognized1: 1,\n        unrecognized2: 'abc',\n      },\n      selectedIndex: 0,\n    },\n    {\n      description: 'valid discrim union 4, with unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: {\n        kind: 'i',\n        str1: 'hello',\n        int1: 1,\n        unrecognized1: 1,\n        unrecognized2: 'abc',\n      },\n      selectedIndex: 1,\n    },\n    {\n      description: 'valid discrim union 5, different discriminant key',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { t: 's', str1: 'hello' },\n      selectedIndex: 0,\n    },\n    {\n      description: 'valid discrim union 6, different discriminant key',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { t: 'i', str1: 'hello', int1: 1 },\n      selectedIndex: 1,\n    },\n    {\n      description: 'valid discrim union 7, quoted discriminant key',\n      onlySpec: false,\n      schema: wellFormedUnion3,\n      value: { \"s'quote\": 200, int1: 1 },\n      selectedIndex: 1,\n    },\n  ]);\n}\n", "function verifyCleaning(spec: ValidTestSpec<TSchema>, value: any): void {\n  const unionSpec = spec as ValidUnionTestSpec;\n  const validProperties = Object.keys(\n    unionSpec.schema.anyOf[unionSpec.selectedIndex].properties\n  );\n  for (const key in value) {\n    expect(validProperties.includes(key)).toBe(true);\n  }\n  expect(Object.keys(value).length).toBeLessThanOrEqual(validProperties.length);\n}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n\nfunction runThisTest(methodKind: MethodKind): boolean {\n  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n}\n"]}
{"filename": "src/test/test-invalid-specs.ts", "chunked_list": ["import { TSchema } from '@sinclair/typebox';\n\nimport { AbstractValidator } from '../abstract/abstract-validator';\nimport {\n  InvalidTestSpec,\n  MethodKind,\n  ValidatorMethodOfClass,\n  specsToRun,\n} from './test-utils';\nimport { DEFAULT_OVERALL_MESSAGE } from '../lib/error-utils';", "} from './test-utils';\nimport { DEFAULT_OVERALL_MESSAGE } from '../lib/error-utils';\nimport { ValidationException } from '../lib/validation-exception';\n\nexport function testInvalidSpecs<S extends InvalidTestSpec<TSchema>>(\n  runThisTest: (method: MethodKind) => boolean,\n  createValidator: (schema: TSchema) => AbstractValidator<TSchema>,\n  invalidSpecs: S[]\n) {\n  if (runThisTest(MethodKind.Test)) {\n    describe('test() rejections', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('test() should reject ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          expect(validator.test(spec.value)).toBe(false);\n        });\n      });\n    });\n  }", "  if (runThisTest(MethodKind.Test)) {\n    describe('test() rejections', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('test() should reject ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          expect(validator.test(spec.value)).toBe(false);\n        });\n      });\n    });\n  }\n  if (runThisTest(MethodKind.TestReturningErrors)) {\n    describe('testReturningErrors()', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('testReturningErrors() for ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          const result = validator.testReturningErrors(spec.value);\n          expect(result).not.toBeNull();\n          const errors = [...result!];\n          expect(errors.length).toEqual(spec.errors.length);\n          errors.forEach((error, i) => {\n            expect(error.path).toEqual(spec.errors[i].path);\n            expect(error.message).toContain(spec.errors[i].message);\n          });\n        });\n      });\n    });\n  }", "  if (runThisTest(MethodKind.TestReturningErrors)) {\n    describe('testReturningErrors()', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('testReturningErrors() for ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          const result = validator.testReturningErrors(spec.value);\n          expect(result).not.toBeNull();\n          const errors = [...result!];\n          expect(errors.length).toEqual(spec.errors.length);\n          errors.forEach((error, i) => {\n            expect(error.path).toEqual(spec.errors[i].path);\n            expect(error.message).toContain(spec.errors[i].message);\n          });\n        });\n      });\n    });\n  }", "  if (runThisTest(MethodKind.TestReturningFirstError)) {\n    describe('testReturningFirstError()', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('testReturningFirstError() for ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          const firstError = validator.firstError(spec.value);\n          expect(firstError).not.toBeNull();\n          expect(firstError?.path).toEqual(spec.errors[0].path);\n          expect(firstError?.message).toContain(spec.errors[0].message);\n        });\n      });\n    });\n  }\n", "  if (runThisTest(MethodKind.Assert)) {\n    testAssertMethodRejection('assert', invalidSpecs);\n  }\n  if (runThisTest(MethodKind.AssertAndClean)) {\n    testAssertMethodRejection('assertAndClean', invalidSpecs);\n  }\n  if (runThisTest(MethodKind.AssertAndCleanCopy)) {\n    testAssertMethodRejection('assertAndCleanCopy', invalidSpecs);\n  }\n  if (runThisTest(MethodKind.Validate)) {\n    testValidateMethodRejection('validate', invalidSpecs);\n  }", "  if (runThisTest(MethodKind.Validate)) {\n    testValidateMethodRejection('validate', invalidSpecs);\n  }\n  if (runThisTest(MethodKind.ValidateAndClean)) {\n    testValidateMethodRejection('validateAndClean', invalidSpecs);\n  }\n  if (runThisTest(MethodKind.ValidateAndCleanCopy)) {\n    testValidateMethodRejection('validateAndCleanCopy', invalidSpecs);\n  }\n\n  if (runThisTest(MethodKind.Errors)) {\n    describe('errors()', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('errors() for ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          const errors = [...validator.errors(spec.value)];\n          expect(errors.length).toEqual(spec.errors.length);\n          errors.forEach((error, i) => {\n            expect(error.path).toEqual(spec.errors[i].path);\n            expect(error.message).toContain(spec.errors[i].message);\n          });\n        });\n      });\n    });\n  }", "  if (runThisTest(MethodKind.Errors)) {\n    describe('errors()', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('errors() for ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          const errors = [...validator.errors(spec.value)];\n          expect(errors.length).toEqual(spec.errors.length);\n          errors.forEach((error, i) => {\n            expect(error.path).toEqual(spec.errors[i].path);\n            expect(error.message).toContain(spec.errors[i].message);\n          });\n        });\n      });\n    });\n  }", "  if (runThisTest(MethodKind.FirstError)) {\n    describe('firstError()', () => {\n      specsToRun(invalidSpecs).forEach((spec) => {\n        it('firstError() for ' + spec.description, () => {\n          const validator = createValidator(spec.schema);\n          const firstError = validator.firstError(spec.value);\n          expect(firstError?.path).toEqual(spec.errors[0].path);\n          expect(firstError?.message).toContain(spec.errors[0].message);\n        });\n      });\n    });\n  }\n", "  function testAssertMethodRejection<S extends TSchema>(\n    method: ValidatorMethodOfClass<AbstractValidator<S>>,\n    specs: InvalidTestSpec<TSchema>[]\n  ) {\n    describe(`${method}() rejections`, () => {\n      specsToRun(specs).forEach((spec) => {\n        it(`${method}() should reject ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          try {\n            (validator[method] as any)(spec.value, spec.overallMessage);\n            expect(false).toBe(true);", "          try {\n            (validator[method] as any)(spec.value, spec.overallMessage);\n            expect(false).toBe(true);\n          } catch (e: any) {\n            if (!(e instanceof ValidationException)) throw e;\n\n            const details = e.details;\n            const errors = spec.errors;\n            expect(details.length).toEqual(1);\n            expect(details[0].path).toEqual(errors[0].path);\n            expect(details[0].message).toContain(errors[0].message);\n", "            if (spec.assertMessage !== undefined) {\n              expect(e.message).toEqual(spec.assertMessage);\n            }\n            if (spec.assertString !== undefined) {\n              expect(e.toString()).toEqual(spec.assertString);\n            }\n          }\n        });\n      });\n    });\n  }\n", "  function testValidateMethodRejection<S extends TSchema>(\n    method: ValidatorMethodOfClass<AbstractValidator<S>>,\n    specs: InvalidTestSpec<TSchema>[]\n  ) {\n    describe(`${method}() rejections`, () => {\n      specsToRun(specs).forEach((spec) => {\n        it(`${method}() should reject ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const overallMessage = spec.overallMessage\n            ? spec.overallMessage.replace('{error}', '').trim()\n            : undefined;", "          try {\n            (validator[method] as any)(spec.value, overallMessage);\n            expect(false).toBe(true);\n          } catch (e: any) {\n            if (!(e instanceof ValidationException)) throw e;\n\n            const details = e.details;\n            const errors = spec.errors;\n            expect(details.length).toEqual(errors.length);\n            errors.forEach((error, i) => {\n              expect(details[i]?.path).toEqual(error.path);\n              expect(details[i]?.message).toContain(error.message);\n            });\n\n            expect(e.message).toEqual(\n              overallMessage ?? DEFAULT_OVERALL_MESSAGE\n            );", "            if (spec.validateString !== undefined) {\n              expect(e.toString()).toEqual(spec.validateString);\n            }\n          }\n        });\n      });\n    });\n  }\n}\n"]}
{"filename": "src/test/standard-validators-invalid.test.ts", "chunked_list": ["import { TSchema, Type } from '@sinclair/typebox';\n\nimport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\nimport { StandardValidator } from '../standard/standard-validator';\nimport { CompilingStandardValidator } from '../standard/compiling-standard-validator';\nimport { DEFAULT_OVERALL_MESSAGE } from '../lib/error-utils';\nimport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';\nimport { testInvalidSpecs } from './test-invalid-specs';\n\nconst onlyRunValidator = ValidatorKind.All;", "\nconst onlyRunValidator = ValidatorKind.All;\nconst onlyRunMethod = MethodKind.All;\n\nconst schema0 = Type.String({\n  minLength: 5,\n  maxLength: 10,\n  pattern: '^[a-zA-Z]+$',\n});\n", "});\n\nconst schema1 = Type.String({\n  minLength: 5,\n  maxLength: 10,\n  pattern: '^[a-zA-Z]+$',\n  errorMessage: 'name should consist of 5-10 letters',\n});\n\nconst schema2 = Type.Object({", "\nconst schema2 = Type.Object({\n  delta: Type.Integer(),\n  count: Type.Integer({ exclusiveMinimum: 0 }),\n  name: schema1,\n});\n\nconst schema3 = Type.Object({\n  int1: Type.Integer({ errorMessage: 'must be an int' }),\n  int2: Type.Integer({ errorMessage: 'must be an int' }),", "  int1: Type.Integer({ errorMessage: 'must be an int' }),\n  int2: Type.Integer({ errorMessage: 'must be an int' }),\n  alpha: Type.String({ pattern: '^[a-zA-Z]+$', maxLength: 4 }),\n});\n\nconst schema4 = Type.Object({\n  int1: Type.Integer(),\n  whatever: Type.Any(),\n});\n", "});\n\nconst schema5 = Type.Object({\n  int1: Type.Integer(),\n  whatever: Type.Unknown({ errorMessage: 'Missing whatever' }),\n});\n\nconst validatorCache = new ValidatorCache();\n\ndescribe('standard validators - invalid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('StandardValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getNonCompiling(\n          schema,\n          () => new StandardValidator(schema)\n        )\n      );\n    });\n  }\n", "\ndescribe('standard validators - invalid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('StandardValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getNonCompiling(\n          schema,\n          () => new StandardValidator(schema)\n        )\n      );\n    });\n  }\n", "  if (runThisValidator(ValidatorKind.Compiling)) {\n    describe('CompilingStandardValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getCompiling(\n          schema,\n          () => new CompilingStandardValidator(schema)\n        )\n      );\n    });\n  }\n});\n", "function testValidator(\n  createValidator: (schema: TSchema) => AbstractStandardValidator<TSchema>\n) {\n  testInvalidSpecs(runThisTest, createValidator, [\n    {\n      description: 'multiple errors for string literal',\n      onlySpec: false,\n      schema: schema0,\n      value: '1',\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [\n        {\n          path: '',\n          message: 'greater or equal to 5',\n        },\n        {\n          path: '',\n          message: 'match pattern',\n        },\n      ],\n      assertString:\n        'Invalid value:\\n * Expected string length greater or equal to 5',\n      validateString:\n        'Invalid value:\\n' +\n        ' * Expected string length greater or equal to 5\\n' +\n        ' * Expected string to match pattern ^[a-zA-Z]+$',\n    },\n    {\n      description: 'custom overall and error messages for string literal',\n      onlySpec: false,\n      schema: schema1,\n      value: '1',\n      overallMessage: 'Oopsie',\n      assertMessage: 'Oopsie',\n      errors: [\n        {\n          path: '',\n          message: 'name should consist of 5-10 letters',\n        },\n      ],\n      assertString: 'Oopsie:\\n * name should consist of 5-10 letters',\n      validateString: 'Oopsie:\\n * name should consist of 5-10 letters',\n    },\n    {\n      description: 'single invalid field with one error',\n      onlySpec: false,\n      schema: schema2,\n      value: { delta: 0.5, count: 1, name: 'ABCDE' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '/delta', message: 'Expected integer' }],\n      assertString: 'Invalid value:\\n * delta - Expected integer',\n      validateString: 'Invalid value:\\n * delta - Expected integer',\n    },\n    {\n      description:\n        'single invalid field with one error, custom overall message 1',\n      onlySpec: false,\n      schema: schema2,\n      value: { delta: 0.5, count: 1, name: 'ABCDE' },\n      overallMessage: 'Custom message',\n      assertMessage: 'Custom message',\n      errors: [{ path: '/delta', message: 'Expected integer' }],\n      assertString: 'Custom message:\\n * delta - Expected integer',\n      validateString: 'Custom message:\\n * delta - Expected integer',\n    },\n    {\n      description:\n        'single invalid field with one error, custom overall message 2',\n      onlySpec: false,\n      schema: schema2,\n      value: { delta: 0.5, count: 1, name: 'ABCDE' },\n      overallMessage: 'Oopsie: {error}',\n      assertMessage: 'Oopsie: delta - Expected integer',\n      errors: [{ path: '/delta', message: 'Expected integer' }],\n      assertString:\n        'Oopsie: delta - Expected integer:\\n * delta - Expected integer',\n      validateString: 'Oopsie:\\n * delta - Expected integer',\n    },\n    {\n      description: 'custom error message makes it into custom overall message',\n      onlySpec: false,\n      schema: schema2,\n      value: { delta: 1, count: 1, name: '1' },\n      overallMessage: 'Oopsie: {error}',\n      assertMessage: 'Oopsie: name - name should consist of 5-10 letters',\n      errors: [\n        { path: '/name', message: 'name should consist of 5-10 letters' },\n      ],\n      assertString:\n        'Oopsie: name - name should consist of 5-10 letters:\\n' +\n        ' * name - name should consist of 5-10 letters',\n      validateString: 'Oopsie:\\n * name - name should consist of 5-10 letters',\n    },\n    {\n      description: 'single invalid field with multiple errors',\n      onlySpec: false,\n      schema: schema3,\n      value: { int1: 1, int2: 1, alpha: '12345' },\n      errors: [\n        {\n          path: '/alpha',\n          message: 'less or equal to 4',\n        },\n        {\n          path: '/alpha',\n          message: 'match pattern',\n        },\n      ],\n    },\n    {\n      description: 'multiple invalid fields with multiple errors',\n      onlySpec: false,\n      schema: schema3,\n      value: { int1: 1.5, int2: 1.5, alpha: '12345' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [\n        {\n          path: '/int1',\n          message: 'must be an int',\n        },\n        {\n          path: '/int2',\n          message: 'must be an int',\n        },\n        {\n          path: '/alpha',\n          message: 'less or equal to 4',\n        },\n        {\n          path: '/alpha',\n          message: 'match pattern',\n        },\n      ],\n    },\n    {\n      description: 'one custom error message for multiple errors',\n      onlySpec: false,\n      schema: schema2,\n      value: { delta: 0.5, count: 1, name: '1' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [\n        {\n          path: '/delta',\n          message: 'integer',\n        },\n        {\n          path: '/name',\n          message: 'name should consist of 5-10 letters',\n        },\n      ],\n      assertString: 'Invalid value:\\n * delta - Expected integer',\n      validateString:\n        'Invalid value:\\n' +\n        ' * delta - Expected integer\\n' +\n        ' * name - name should consist of 5-10 letters',\n    },\n    {\n      description:\n        'invalid overall value with one error, custom overall message 1',\n      onlySpec: false,\n      schema: schema2,\n      value: 'not an object',\n      overallMessage: 'Oopsie: {error}',\n      assertMessage: 'Oopsie: Expected object',\n      errors: [{ path: '', message: 'Expected object' }],\n      assertString: 'Oopsie: Expected object:\\n * Expected object',\n      validateString: 'Oopsie:\\n * Expected object',\n    },\n    {\n      description: \"reports default required message for 'any' field\",\n      onlySpec: false,\n      schema: schema4,\n      value: { int1: 32 },\n      errors: [\n        {\n          path: '/whatever',\n          message: 'Expected required property',\n        },\n      ],\n      assertString: 'Invalid value:\\n * whatever - Expected required property',\n      validateString:\n        'Invalid value:\\n * whatever - Expected required property',\n    },\n    {\n      description: \"reports custom required message for 'unknown' field\",\n      onlySpec: false,\n      schema: schema5,\n      value: { int1: 'not an integer' },\n      errors: [\n        {\n          path: '/int1',\n          message: 'Expected integer',\n        },\n        {\n          path: '/whatever',\n          message: 'Missing whatever',\n        },\n      ],\n      assertString: 'Invalid value:\\n * int1 - Expected integer',\n      validateString:\n        'Invalid value:\\n' +\n        ' * int1 - Expected integer\\n' +\n        ' * whatever - Missing whatever',\n    },\n  ]);\n}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n\nfunction runThisTest(methodKind: MethodKind): boolean {\n  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n}\n"]}
{"filename": "src/test/maxItems-maxLength.test.ts", "chunked_list": ["/**\n * As of Typebox version 0.28.13,`maxLength` and `maxItems` are checked before\n * checking other constraints, but the TypeBox docs say nothing about this, so\n * this feature may not be part of the public contract. These tests confirm\n * that this remains the case, as this feature is important for securing APIs.\n */\n\nimport { TSchema, Type } from '@sinclair/typebox';\nimport { Value, ValueErrorIterator } from '@sinclair/typebox/value';\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler';", "import { Value, ValueErrorIterator } from '@sinclair/typebox/value';\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler';\n//import { performance } from 'node:perf_hooks';\n\nconst MAX_SIZE = 4;\nconst ERROR_SUBSTRING = `less or equal to ${MAX_SIZE}`;\nconst PATTERN = '^[a-z]+$';\n\n// const uncompiledIterations = [400, 10000] as const;\n// const compiledIterations = [400, 20000] as const;", "// const uncompiledIterations = [400, 10000] as const;\n// const compiledIterations = [400, 20000] as const;\n\ndescribe('TypeBox value size checks', () => {\n  describe('maxLength checks', () => {\n    const schema = Type.Object({\n      lengthFirstStr: Type.String({ maxLength: 4, pattern: PATTERN }),\n      lengthLastStr: Type.String({ pattern: PATTERN, maxLength: MAX_SIZE }),\n    });\n    const badSizeValue = {", "    });\n    const badSizeValue = {\n      lengthFirstStr: '1'.repeat(MAX_SIZE + 1),\n      lengthLastStr: '1'.repeat(MAX_SIZE + 1),\n    };\n    // const badRegexValue = {\n    //   lengthFirstStr: '1',\n    //   lengthLastStr: '1',\n    // };\n", "    // };\n\n    const compiledType = TypeCompiler.Compile(schema);\n\n    // it('should have uncompiled Check() test maxLength first', () => {\n    //   const check = Value.Check.bind(Value, schema);\n    //   testCheckViaTiming(\n    //     check,\n    //     badSizeValue,\n    //     badRegexValue,", "    //     badSizeValue,\n    //     badRegexValue,\n    //     uncompiledIterations\n    //   );\n    // });\n\n    it('should have compiled Check() test maxLength first', () => {\n      testCheckViaCode(compiledType);\n      // const check = compiledType.Check.bind(compiledType);\n      // testCheckViaTiming(", "      // const check = compiledType.Check.bind(compiledType);\n      // testCheckViaTiming(\n      //   check,\n      //   badSizeValue,\n      //   badRegexValue,\n      //   compiledIterations\n      // );\n    });\n\n    it('should have First() return a maxLength error', () => {", "\n    it('should have First() return a maxLength error', () => {\n      let error = Value.Errors(schema, badSizeValue).First();\n      expect(error?.message).toContain(ERROR_SUBSTRING);\n\n      error = compiledType.Errors(badSizeValue).First();\n      expect(error?.message).toContain(ERROR_SUBSTRING);\n    });\n\n    it('should have Errors() return a maxLength error first', () => {", "\n    it('should have Errors() return a maxLength error first', () => {\n      const verifyErrors = (errors: ValueErrorIterator) => {\n        let priorPath = '';\n        for (const error of errors) {\n          if (error.path !== priorPath) {\n            expect(error.message).toContain(ERROR_SUBSTRING);\n            priorPath = error.path;\n          }\n        }\n      };\n      verifyErrors(Value.Errors(schema, badSizeValue));\n      verifyErrors(compiledType.Errors(badSizeValue));\n    });\n  });\n\n  describe('maxItems checks', () => {\n    const schema = Type.Object({\n      array: Type.Array(Type.String({ pattern: PATTERN }), {\n        maxItems: MAX_SIZE,\n      }),\n    });\n    const badSizeValue = {\n      array: Array.from({ length: MAX_SIZE + 1 }).fill('1'),\n    };\n    // const badRegexValue = {\n    //   array: Array.from({ length: 1 }).fill('1'),\n    // };\n    const compiledType = TypeCompiler.Compile(schema);\n\n    // it('should have uncompiled Check() test maxItems first', () => {\n    //   const check = Value.Check.bind(Value, schema);\n    //   testCheckViaTiming(\n    //     check,\n    //     badSizeValue,\n    //     badRegexValue,\n    //     uncompiledIterations\n    //   );\n    // });\n\n    it('should have compiled Check() test maxItems first', () => {\n      testCheckViaCode(compiledType);\n      // const check = compiledType.Check.bind(compiledType);\n      // testCheckViaTiming(\n      //   check,\n      //   badSizeValue,\n      //   badRegexValue,\n      //   compiledIterations\n      // );\n    });\n\n    it('should have First() return a maxItems error', () => {\n      let error = Value.Errors(schema, badSizeValue).First();\n      expect(error?.message).toContain(ERROR_SUBSTRING);\n\n      error = compiledType.Errors(badSizeValue).First();\n      expect(error?.message).toContain(ERROR_SUBSTRING);\n    });\n\n    it('should have Errors() return a maxItems error first', () => {", "      for (const error of compiledType.Errors(badSizeValue)) {\n        expect(error.message).toContain(ERROR_SUBSTRING);\n        break; // only check first error\n      }\n    });\n  });\n});\n\nfunction testCheckViaCode(compiledType: TypeCheck<TSchema>) {\n  // Not guaranteed to work for all versions of TypeBox,\n  // but it's faster than doing another timing test.\n  const code = compiledType.Code();\n  const maxSizeOffset = code.indexOf(`${MAX_SIZE}`);\n  const patternOffset = code.indexOf('.test(');\n  expect(maxSizeOffset).toBeGreaterThanOrEqual(0);\n  expect(patternOffset).toBeGreaterThanOrEqual(0);\n  expect(maxSizeOffset).toBeLessThan(patternOffset);\n}\n", "function testCheckViaCode(compiledType: TypeCheck<TSchema>) {\n  // Not guaranteed to work for all versions of TypeBox,\n  // but it's faster than doing another timing test.\n  const code = compiledType.Code();\n  const maxSizeOffset = code.indexOf(`${MAX_SIZE}`);\n  const patternOffset = code.indexOf('.test(');\n  expect(maxSizeOffset).toBeGreaterThanOrEqual(0);\n  expect(patternOffset).toBeGreaterThanOrEqual(0);\n  expect(maxSizeOffset).toBeLessThan(patternOffset);\n}\n", "// This function works most of the time, but produces a false negative\n// often enough to make it too unreliable to include in the test suite.\n\n// function testCheckViaTiming(\n//   check: (value: unknown) => boolean,\n//   badSizeValue: unknown,\n//   badRegexValue: unknown,\n//   iterations: Readonly<[number, number]>\n// ) {\n//   let badSizeTimes: number[] = [];\n//   let badRegexTimes: number[] = [];\n\n//   // Mix the two tests to equally apply system slowdowns across them.", "//   for (let i = 0; i < iterations[0]; ++i) {\n//     badSizeTimes.push(timeCheckFunction(check, badSizeValue, iterations[1]));\n//     badRegexTimes.push(timeCheckFunction(check, badRegexValue, iterations[1]));\n//   }\n//   badSizeTimes.sort();\n//   badRegexTimes.sort();\n\n//   const sum = (times: number[]) =>\n//     times.slice(0, iterations[0] / 2).reduce((a, b) => a + b, 0);\n//   expect(sum(badSizeTimes)).toBeLessThan(sum(badRegexTimes));\n// }\n", "// function timeCheckFunction(\n//   check: (value: unknown) => boolean,\n//   badValue: unknown,\n//   iterations: number\n// ): number {\n//   let start = performance.now();\n//   for (let i = 0; i < iterations; ++i) {\n//     check(badValue);\n//   }\n//   return performance.now() - start;\n// }\n"]}
{"filename": "src/test/key-iteration-performance.ts", "chunked_list": ["import { TSchema, Type } from '@sinclair/typebox';\n\nconst iterations = [1000, 10000] as const;\n\nconst schema = Type.Object({\n  key1: Type.String(),\n  key2: Type.String(),\n  key3: Type.String(),\n  key4: Type.String(),\n  key5: Type.String(),", "  key4: Type.String(),\n  key5: Type.String(),\n  key6: Type.String(),\n  key7: Type.String(),\n  key8: Type.String(),\n  key9: Type.String(),\n  key10: Type.String(),\n});\n\nconsole.log('key iteration performance');", "\nconsole.log('key iteration performance');\n{\n  console.log('  key iteration speed\\n');\n  let forInTime = 0;\n  let objectKeysTime = 0;\n  let objectKeysForEachTime = 0;\n  let objectGetOwnPropertyNamesTime = 0;\n  let objectGetOwnPropertyNamesForEachTime = 0;\n", "  let objectGetOwnPropertyNamesForEachTime = 0;\n\n  // Mix the two tests to equally apply system slowdowns across them.\n  for (let i = 0; i < iterations[0]; ++i) {\n    forInTime += timeFunction(() => {\n      let count = 0;\n      for (const _ in schema.properties) {\n        count++;\n      }\n      return count;\n    });\n    objectKeysTime += timeFunction(() => {\n      let count = 0;", "      for (const _ of Object.keys(schema.properties)) {\n        count++;\n      }\n      return count;\n    });\n    objectKeysForEachTime += timeFunction(() => {\n      let count = 0;\n      Object.keys(schema.properties).forEach(() => {\n        count++;\n      });\n      return count;\n    });\n    objectGetOwnPropertyNamesTime += timeFunction(() => {\n      let count = 0;", "      for (const _ of Object.getOwnPropertyNames(schema.properties)) {\n        count++;\n      }\n      return count;\n    });\n    objectGetOwnPropertyNamesForEachTime += timeFunction(() => {\n      let count = 0;\n      Object.getOwnPropertyNames(schema.properties).forEach(() => {\n        count++;\n      });\n      return count;\n    });\n  }\n\n  const results: [string, number][] = [];\n  results.push(['for in', forInTime]);\n  results.push(['Object.keys of', objectKeysTime]);\n  results.push(['Object.keys.forEach', objectKeysForEachTime]);\n  results.push([\n    'Object.getOwnPropertyNames of',\n    objectGetOwnPropertyNamesTime,\n  ]);\n  results.push([\n    'Object.getOwnPropertyNames.forEach',\n    objectGetOwnPropertyNamesForEachTime,\n  ]);\n  showResults(results);\n", "  function timeFunction(func: () => number): number {\n    let start = performance.now();\n    for (let i = 0; i < iterations[1]; ++i) {\n      func();\n    }\n    return performance.now() - start;\n  }\n}\n\n{\n  console.log('  key lookup speed\\n');\n  let inTime = 0;\n  let objectKeysIncludesTime = 0;\n  let objectGetOwnPropertyIncludesTime = 0;\n\n  // Mix the two tests to equally apply system slowdowns across them.", "  for (let i = 0; i < iterations[0]; ++i) {\n    const lookupKeys = ['key1', 'key5', 'key10'];\n    inTime += timeFunction((schema) => {\n      let count = 0;\n      for (const key of lookupKeys) {\n        if (key in schema.properties) {\n          count++;\n        }\n      }\n      return count;\n    });\n    objectKeysIncludesTime += timeFunction((schema) => {\n      let count = 0;", "      for (const key of lookupKeys) {\n        if (Object.keys(schema.properties).includes(key)) {\n          count++;\n        }\n      }\n      return count;\n    });\n    objectGetOwnPropertyIncludesTime += timeFunction((schema) => {\n      let count = 0;\n      for (const key of lookupKeys) {\n        if (Object.getOwnPropertyNames(schema.properties).includes(key)) {\n          count++;\n        }\n      }\n      return count;\n    });\n  }\n\n  const results: [string, number][] = [];\n  results.push(['in', inTime]);\n  results.push(['Object.keys.includes', objectKeysIncludesTime]);\n  results.push([\n    'Object.getOwnPropertyNames.includes',\n    objectGetOwnPropertyIncludesTime,\n  ]);\n  showResults(results);\n", "      for (const key of lookupKeys) {\n        if (Object.getOwnPropertyNames(schema.properties).includes(key)) {\n          count++;\n        }\n      }\n      return count;\n    });\n  }\n\n  const results: [string, number][] = [];\n  results.push(['in', inTime]);\n  results.push(['Object.keys.includes', objectKeysIncludesTime]);\n  results.push([\n    'Object.getOwnPropertyNames.includes',\n    objectGetOwnPropertyIncludesTime,\n  ]);\n  showResults(results);\n", "  function timeFunction(func: (schema: TSchema) => number): number {\n    let start = performance.now();\n    for (let i = 0; i < iterations[1]; ++i) {\n      func(schema);\n    }\n    return performance.now() - start;\n  }\n}\n\nfunction showResults(results: [string, number][]) {\n  results.sort((a, b) => b[1] - a[1]);", "function showResults(results: [string, number][]) {\n  results.sort((a, b) => b[1] - a[1]);\n  for (const [name, time] of results) {\n    console.log(\n      `${\n        Math.round((time / results[results.length - 1][1]) * 100) / 100\n      }x - ${name} (${time}ms)`\n    );\n  }\n  console.log();\n}\n"]}
{"filename": "src/test/test-utils.ts", "chunked_list": ["import { TObject, TSchema, TUnion } from '@sinclair/typebox';\nimport { AbstractValidator } from '../abstract/abstract-validator';\n\nexport enum ValidatorKind {\n  All,\n  Compiling,\n  NonCompiling,\n}\n\nexport enum MethodKind {\n  All,\n  Test,\n  TestReturningErrors,\n  TestReturningFirstError,\n  Assert,\n  AssertAndClean,\n  AssertAndCleanCopy,\n  Validate,\n  ValidateAndClean,\n  ValidateAndCleanCopy,\n  Errors,\n  FirstError,\n  InvalidSchema,\n}\n", "export enum MethodKind {\n  All,\n  Test,\n  TestReturningErrors,\n  TestReturningFirstError,\n  Assert,\n  AssertAndClean,\n  AssertAndCleanCopy,\n  Validate,\n  ValidateAndClean,\n  ValidateAndCleanCopy,\n  Errors,\n  FirstError,\n  InvalidSchema,\n}\n", "export type ValidatorMethodOfClass<T> = {\n  [K in keyof T]: T[K] extends (value: any, errorMessage?: string) => any\n    ? K\n    : never;\n}[keyof T];\n\nexport interface TestSpec {\n  onlySpec: boolean;\n}\n\nexport interface ValidTestSpec<S extends TSchema> extends TestSpec {\n  description: string;\n  schema: S;\n  value: any;\n}\n", "export interface ValidTestSpec<S extends TSchema> extends TestSpec {\n  description: string;\n  schema: S;\n  value: any;\n}\n\nexport interface ValidUnionTestSpec extends ValidTestSpec<TUnion<TObject[]>> {\n  selectedIndex: number;\n}\n\nexport interface InvalidTestSpec<S extends TSchema> extends TestSpec {\n  description: string;\n  schema: S;\n  value: any;\n  overallMessage?: string;\n  assertMessage?: string;\n  errors: { path: string; message: string }[];\n  assertString?: string;\n  validateString?: string;\n}\n", "export interface InvalidTestSpec<S extends TSchema> extends TestSpec {\n  description: string;\n  schema: S;\n  value: any;\n  overallMessage?: string;\n  assertMessage?: string;\n  errors: { path: string; message: string }[];\n  assertString?: string;\n  validateString?: string;\n}\n", "export function specsToRun<S extends TestSpec>(specs: S[]): S[] {\n  for (const spec of specs) {\n    if (spec.onlySpec) {\n      return [spec];\n    }\n  }\n  return specs;\n}\n\nexport class ValidatorCache {\n  compilingValidators = new Map<TSchema, AbstractValidator<TSchema>>();\n  nonCompilingValidators = new Map<TSchema, AbstractValidator<TSchema>>();\n\n  getCompiling<S extends TSchema>(\n    schema: S,\n    createValidator: (schema: S) => AbstractValidator<S>\n  ): AbstractValidator<TSchema> {\n    return this._getCachedValidator(\n      this.compilingValidators,\n      schema,\n      createValidator\n    );\n  }\n\n  getNonCompiling<S extends TSchema>(\n    schema: S,\n    createValidator: (schema: S) => AbstractValidator<S>\n  ): AbstractValidator<TSchema> {\n    return this._getCachedValidator(\n      this.nonCompilingValidators,\n      schema,\n      createValidator\n    );\n  }\n\n  private _getCachedValidator<S extends TSchema>(\n    cache: Map<TSchema, AbstractValidator<TSchema>>,\n    schema: S,\n    createValidator: (schema: S) => AbstractValidator<S>\n  ): AbstractValidator<TSchema> {\n    let validator = cache.get(schema);", "export class ValidatorCache {\n  compilingValidators = new Map<TSchema, AbstractValidator<TSchema>>();\n  nonCompilingValidators = new Map<TSchema, AbstractValidator<TSchema>>();\n\n  getCompiling<S extends TSchema>(\n    schema: S,\n    createValidator: (schema: S) => AbstractValidator<S>\n  ): AbstractValidator<TSchema> {\n    return this._getCachedValidator(\n      this.compilingValidators,\n      schema,\n      createValidator\n    );\n  }\n\n  getNonCompiling<S extends TSchema>(\n    schema: S,\n    createValidator: (schema: S) => AbstractValidator<S>\n  ): AbstractValidator<TSchema> {\n    return this._getCachedValidator(\n      this.nonCompilingValidators,\n      schema,\n      createValidator\n    );\n  }\n\n  private _getCachedValidator<S extends TSchema>(\n    cache: Map<TSchema, AbstractValidator<TSchema>>,\n    schema: S,\n    createValidator: (schema: S) => AbstractValidator<S>\n  ): AbstractValidator<TSchema> {\n    let validator = cache.get(schema);", "    if (validator === undefined) {\n      validator = createValidator(schema);\n      cache.set(schema, validator);\n    }\n    return validator;\n  }\n}\n"]}
{"filename": "src/test/heterogeneous-union-validators-valid.test.ts", "chunked_list": ["import { TObject, TSchema, TUnion, Type } from '@sinclair/typebox';\n\nimport { AbstractValidator } from '../abstract/abstract-validator';\nimport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\nimport { HeterogeneousUnionValidator } from '../heterogeneous/heterogeneous-union-validator';\nimport { CompilingHeterogeneousUnionValidator } from '../heterogeneous/compiling-heterogeneous-union-validator';\nimport { TypeIdentifyingKey } from '../heterogeneous/type-identifying-key';\nimport {\n  ValidUnionTestSpec,\n  ValidatorKind,", "  ValidUnionTestSpec,\n  ValidatorKind,\n  MethodKind,\n  ValidatorCache,\n  ValidTestSpec,\n} from './test-utils';\nimport { testValidSpecs } from './test-valid-specs';\n\nconst onlyRunValidator = ValidatorKind.All;\nconst onlyRunMethod = MethodKind.All;", "const onlyRunValidator = ValidatorKind.All;\nconst onlyRunMethod = MethodKind.All;\n\nconst wellFormedUnion1 = Type.Union([\n  Type.Object({\n    unique1: TypeIdentifyingKey(Type.String()),\n    str1: Type.String(),\n    str2: Type.Optional(Type.String()),\n  }),\n  Type.Object({", "  }),\n  Type.Object({\n    unique2: TypeIdentifyingKey(Type.Integer()),\n    int1: Type.Integer(),\n    int2: Type.Optional(Type.Integer()),\n  }),\n  Type.Object({\n    \"s'quote\": TypeIdentifyingKey(Type.String()),\n    str1: Type.String(),\n  }),", "    str1: Type.String(),\n  }),\n]);\n\nconst wellFormedUnion2 = Type.Union(\n  [\n    Type.Object({\n      str1: Type.String(),\n      str2: Type.String(),\n      unique3: Type.String(),", "      str2: Type.String(),\n      unique3: Type.String(),\n      unique1: TypeIdentifyingKey(Type.String()),\n      opt: Type.Optional(Type.String()),\n    }),\n    Type.Object({\n      str1: Type.String(),\n      unique2: TypeIdentifyingKey(Type.String()),\n      str2: Type.String(),\n      opt: Type.Optional(Type.Integer()),", "      str2: Type.String(),\n      opt: Type.Optional(Type.Integer()),\n    }),\n  ],\n  { errorMessage: 'Unknown type' }\n);\n\nconst validatorCache = new ValidatorCache();\n\ndescribe('heterogenous union validators - valid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('HeterogeneousUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new HeterogeneousUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "\ndescribe('heterogenous union validators - valid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('HeterogeneousUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new HeterogeneousUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "  if (runThisValidator(ValidatorKind.Compiling)) {\n    describe('CompilingHeterogeneousUnionValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getCompiling(\n          schema,\n          () =>\n            new CompilingHeterogeneousUnionValidator(\n              schema as TUnion<TObject[]>\n            )\n        )\n      );\n    });\n  }\n});\n", "function testValidator(\n  createValidator: (schema: TSchema) => AbstractValidator<TSchema>\n) {\n  testValidSpecs(runThisTest, createValidator, verifyCleaning, [\n    {\n      description: 'valid hetero union 1, no unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { unique1: 'hello', str1: 'hello' },\n      selectedIndex: 0,\n    },\n    {\n      description: 'valid hetero union 2, no unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { unique2: 1, int1: 1 },\n      selectedIndex: 1,\n    },\n    {\n      description: 'valid hetero union 3, with unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: {\n        unique1: 'hello',\n        str1: 'hello',\n        int1: 1,\n        unrecognized1: 1,\n        unrecognized2: 'abc',\n      },\n      selectedIndex: 0,\n    },\n    {\n      description: 'valid hetero union 4, with unrecognized fields',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: {\n        unique2: 1,\n        str1: 'hello',\n        int1: 1,\n        unrecognized1: 1,\n        unrecognized2: 'abc',\n      },\n      selectedIndex: 1,\n    },\n    {\n      description: 'valid hetero union 5, selecting by member keys',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { str1: 'a', str2: 'b', unique1: 'c', unique3: 'd', opt: 'e' },\n      selectedIndex: 0,\n    },\n    {\n      description: 'valid hetero union 6, selecting by member keys',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: {\n        str1: 'a',\n        unique2: 'b',\n        str2: 'c',\n        opt: 32,\n      },\n      selectedIndex: 1,\n    },\n    {\n      description: 'valid hetero union 7, selecting quoted key',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { \"s'quote\": 'a', str1: 'b' },\n      selectedIndex: 2,\n    },\n  ]);\n}\n", "function verifyCleaning(spec: ValidTestSpec<TSchema>, value: any): void {\n  const unionSpec = spec as ValidUnionTestSpec;\n  const validProperties = Object.keys(\n    unionSpec.schema.anyOf[unionSpec.selectedIndex].properties\n  );\n  for (const key in value) {\n    expect(validProperties.includes(key)).toBe(true);\n  }\n  expect(Object.keys(value).length).toBeLessThanOrEqual(validProperties.length);\n}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n\nfunction runThisTest(methodKind: MethodKind): boolean {\n  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n}\n"]}
{"filename": "src/test/discriminated-union-validators-invalid.test.ts", "chunked_list": ["import { TSchema, TObject, Type, TUnion } from '@sinclair/typebox';\n\nimport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\nimport { DiscriminatedUnionValidator } from '../discriminated/discriminated-union-validator';\nimport { CompilingDiscriminatedUnionValidator } from '../discriminated/compiling-discriminated-union-validator';\nimport {\n  DEFAULT_OVERALL_MESSAGE,\n  DEFAULT_UNKNOWN_TYPE_MESSAGE,\n} from '../lib/error-utils';\nimport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';", "} from '../lib/error-utils';\nimport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';\nimport { testInvalidSpecs } from './test-invalid-specs';\n\nconst onlyRunValidator = ValidatorKind.All;\nconst onlyRunMethod = MethodKind.All;\n\nconst wellFormedUnion1 = Type.Union([\n  Type.Object({\n    kind: Type.Literal('s'),", "  Type.Object({\n    kind: Type.Literal('s'),\n    str1: Type.String(),\n    str2: Type.Optional(Type.String()),\n  }),\n  Type.Object({\n    kind: Type.Literal('i'),\n    int1: Type.Integer(),\n    int2: Type.Optional(\n      Type.Integer({", "    int2: Type.Optional(\n      Type.Integer({\n        errorMessage: 'must be an int',\n      })\n    ),\n  }),\n]);\n\nconst wellFormedUnion2 = Type.Union(\n  [", "const wellFormedUnion2 = Type.Union(\n  [\n    Type.Object({\n      str1: Type.String(),\n      t: Type.Literal('s'),\n      str2: Type.Optional(Type.String()),\n    }),\n    Type.Object({\n      int1: Type.Integer(),\n      int2: Type.Optional(Type.Integer()),", "      int1: Type.Integer(),\n      int2: Type.Optional(Type.Integer()),\n      t: Type.Literal('i'),\n    }),\n  ],\n  { discriminantKey: 't', errorMessage: 'Unknown type' }\n);\n\nconst illFormedUnion = Type.Union(\n  [", "const illFormedUnion = Type.Union(\n  [\n    Type.Object({\n      t: Type.Literal('s'),\n      str1: Type.String(),\n      str2: Type.Optional(Type.String()),\n    }),\n    Type.Object({\n      kind: Type.Literal('i'),\n      int1: Type.Integer(),", "      kind: Type.Literal('i'),\n      int1: Type.Integer(),\n      int2: Type.Optional(Type.Integer()),\n    }),\n  ],\n  { discriminantKey: 't' }\n);\n\nconst validatorCache = new ValidatorCache();\n", "const validatorCache = new ValidatorCache();\n\ndescribe('discriminated union validators - invalid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('DiscriminatedUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new DiscriminatedUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "  if (runThisValidator(ValidatorKind.Compiling)) {\n    describe('CompilingDiscriminatedUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getCompiling(\n            schema,\n            () =>\n              new CompilingDiscriminatedUnionValidator(\n                schema as TUnion<TObject[]>\n              )\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }\n});\n", "function testValidator(\n  createValidator: (\n    schema: TSchema\n  ) => AbstractTypedUnionValidator<TUnion<TObject[]>>\n) {\n  const defaultString = `${DEFAULT_OVERALL_MESSAGE}:\\n * ${DEFAULT_UNKNOWN_TYPE_MESSAGE}`;\n  testInvalidSpecs(runThisTest, createValidator, [\n    {\n      description: 'selects 1st union member, single error',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { kind: 's', int1: 1 },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '/str1', message: 'Expected string' }],\n      assertString: 'Invalid value:\\n * str1 - Expected string',\n      validateString: 'Invalid value:\\n * str1 - Expected string',\n    },\n    {\n      description: 'selects 2nd union member, multiple errors',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { kind: 'i', int1: '1', int2: 'hello' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [\n        { path: '/int1', message: 'Expected integer' },\n        { path: '/int2', message: 'must be an int' },\n      ],\n      assertString: 'Invalid value:\\n * int1 - Expected integer',\n      validateString:\n        'Invalid value:\\n' +\n        ' * int1 - Expected integer\\n' +\n        ' * int2 - must be an int',\n    },\n    {\n      description: 'discriminant key value not selecting any union member',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { kind: 'not-there', str1: 'hello' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'value lacking discriminant key',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { str1: 'hello', int1: 1 },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'empty object value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: {},\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'undefined value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: undefined,\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'null value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: null,\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'simple literal value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: 'hello',\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description:\n        'selects 1st union member, non-1st discriminant, invalid, with overall message',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { t: 's', str1: 32 },\n      overallMessage: 'Custom message',\n      assertMessage: 'Custom message',\n      errors: [{ path: '/str1', message: 'Expected string' }],\n      assertString: 'Custom message:\\n * str1 - Expected string',\n      validateString: 'Custom message:\\n * str1 - Expected string',\n    },\n    {", "      description: 'not selecting any union member, with custom type error',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { t: 'not-there', str1: 'hello' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: 'Unknown type' }],\n      assertString: 'Invalid value:\\n * Unknown type',\n      validateString: 'Invalid value:\\n * Unknown type',\n    },\n    {\n      description:", "        'not selecting any union member, with custom overall and type errors',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { int1: 32 },\n      overallMessage: 'Oopsie: {error}',\n      assertMessage: 'Oopsie: Unknown type',\n      errors: [{ path: '', message: 'Unknown type' }],\n      assertString: 'Oopsie: Unknown type:\\n * Unknown type',\n      validateString: 'Oopsie:\\n * Unknown type',\n    },\n  ]);\n", "  if ([MethodKind.All, MethodKind.InvalidSchema].includes(onlyRunMethod)) {\n    const errorMessage = `Discriminant key 't' not present in all members of discriminated union`;\n\n    describe('errors on invalid union schemas', () => {\n      it('union having members lacking the discriminant key, valid value', () => {\n        const validator = createValidator(illFormedUnion);\n        const validObject = { t: 's', str1: 'hello' };\n\n        expect(() => validator.test(validObject)).toThrow(errorMessage);\n        expect(() => validator.assert(validObject)).toThrow(errorMessage);\n        expect(() => validator.assertAndClean(validObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.assertAndCleanCopy(validObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.validate(validObject)).toThrow(errorMessage);\n        expect(() => validator.validateAndClean(validObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.validateAndCleanCopy(validObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.errors(validObject)).toThrow(errorMessage);\n      });\n\n      it('union having members lacking the discriminant key, invalid value', () => {\n        const validator = createValidator(illFormedUnion);\n        const invalidObject = { s: 'hello', str1: 32 };\n\n        expect(() => validator.test(invalidObject)).toThrow(errorMessage);\n        expect(() => validator.assert(invalidObject)).toThrow(errorMessage);\n        expect(() => validator.assertAndClean(invalidObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.assertAndCleanCopy(invalidObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.validate(invalidObject)).toThrow(errorMessage);\n        expect(() => validator.validateAndClean(invalidObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.validateAndCleanCopy(invalidObject)).toThrow(\n          errorMessage\n        );\n        expect(() => validator.errors(invalidObject)).toThrow(errorMessage);\n      });\n    });\n  }\n}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n\nfunction runThisTest(methodKind: MethodKind): boolean {\n  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n}\n"]}
{"filename": "src/test/heterogeneous-union-validators-invalid.test.ts", "chunked_list": ["import { TSchema, TObject, Type, TUnion } from '@sinclair/typebox';\n\nimport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\nimport { HeterogeneousUnionValidator } from '../heterogeneous/heterogeneous-union-validator';\nimport { CompilingHeterogeneousUnionValidator } from '../heterogeneous/compiling-heterogeneous-union-validator';\nimport { TypeIdentifyingKey } from '../heterogeneous//type-identifying-key';\nimport {\n  DEFAULT_OVERALL_MESSAGE,\n  DEFAULT_UNKNOWN_TYPE_MESSAGE,\n} from '../lib/error-utils';", "  DEFAULT_UNKNOWN_TYPE_MESSAGE,\n} from '../lib/error-utils';\nimport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';\nimport { testInvalidSpecs } from './test-invalid-specs';\nimport {\n  MESSAGE_MEMBERS_MISSING_KEY,\n  MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY,\n  MESSAGE_MEMBER_WITH_MULTIPLE_KEYS,\n  MESSAGE_OPTIONAL_TYPE_ID_KEY,\n} from '../heterogeneous/type-identifying-key-index';", "  MESSAGE_OPTIONAL_TYPE_ID_KEY,\n} from '../heterogeneous/type-identifying-key-index';\n\nconst onlyRunValidator = ValidatorKind.NonCompiling;\nconst onlyRunMethod = MethodKind.InvalidSchema;\n\nconst wellFormedUnion1 = Type.Union([\n  Type.Object({\n    unique1: TypeIdentifyingKey(Type.String()),\n    str1: Type.String(),", "    unique1: TypeIdentifyingKey(Type.String()),\n    str1: Type.String(),\n    str2: Type.Optional(Type.String()),\n  }),\n  Type.Object({\n    unique2: TypeIdentifyingKey(Type.Integer()),\n    int1: Type.Integer(),\n    int2: Type.Optional(\n      Type.Integer({\n        errorMessage: 'must be an int',", "      Type.Integer({\n        errorMessage: 'must be an int',\n      })\n    ),\n  }),\n]);\n\nconst wellFormedUnion2 = Type.Union(\n  [\n    Type.Object({", "  [\n    Type.Object({\n      str1: Type.String(),\n      str2: Type.String(),\n      unique3: Type.String(),\n      unique1: TypeIdentifyingKey(Type.String()),\n      opt: Type.Optional(Type.String()),\n    }),\n    Type.Object({\n      str1: Type.String(),", "    Type.Object({\n      str1: Type.String(),\n      unique2: TypeIdentifyingKey(Type.String()),\n      str2: Type.String(),\n      opt: Type.Optional(Type.Integer()),\n    }),\n  ],\n  { errorMessage: 'Unknown type' }\n);\n", ");\n\nconst unionDupTypeKeysMultipleMembers = Type.Union([\n  Type.Object({\n    s: TypeIdentifyingKey(Type.String()),\n    str1: Type.Optional(Type.String()),\n  }),\n  Type.Object({\n    s: TypeIdentifyingKey(Type.Integer()),\n    int1: Type.Optional(Type.Integer()),", "    s: TypeIdentifyingKey(Type.Integer()),\n    int1: Type.Optional(Type.Integer()),\n  }),\n]);\n\nconst unionDupTypeKeysSingleMembers = Type.Union([\n  Type.Object({\n    s1: TypeIdentifyingKey(Type.String()),\n    s3: TypeIdentifyingKey(Type.String()),\n    str1: Type.Optional(Type.String()),", "    s3: TypeIdentifyingKey(Type.String()),\n    str1: Type.Optional(Type.String()),\n  }),\n  Type.Object({\n    s2: TypeIdentifyingKey(Type.Integer()),\n    int1: Type.Optional(Type.Integer()),\n  }),\n]);\n\nconst unionMissingTypeKeys = Type.Union([", "\nconst unionMissingTypeKeys = Type.Union([\n  Type.Object({\n    s1: TypeIdentifyingKey(Type.String()),\n    str1: Type.Optional(Type.String()),\n  }),\n  Type.Object({\n    s2: Type.String(),\n    int1: Type.Optional(Type.Integer()),\n  }),", "    int1: Type.Optional(Type.Integer()),\n  }),\n]);\n\nconst unionOptionalTypeKey = Type.Union([\n  Type.Object({\n    s1: TypeIdentifyingKey(Type.String()),\n    str1: Type.Optional(Type.String()),\n  }),\n  Type.Object({", "  }),\n  Type.Object({\n    s2: TypeIdentifyingKey(Type.Optional(Type.Integer())),\n    int1: Type.Optional(Type.Integer()),\n  }),\n]);\n\nconst validatorCache = new ValidatorCache();\n\ndescribe('heterogenous union validators - invalid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('HeterogeneousUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new HeterogeneousUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "\ndescribe('heterogenous union validators - invalid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('HeterogeneousUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getNonCompiling(\n            schema,\n            () => new HeterogeneousUnionValidator(schema as TUnion<TObject[]>)\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }", "  if (runThisValidator(ValidatorKind.Compiling)) {\n    describe('CompilingHeterogeneousUnionValidator', () => {\n      testValidator(\n        (schema: TSchema) =>\n          validatorCache.getCompiling(\n            schema,\n            () =>\n              new CompilingHeterogeneousUnionValidator(\n                schema as TUnion<TObject[]>\n              )\n          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n      );\n    });\n  }\n});\n", "function testValidator(\n  createValidator: (\n    schema: TSchema\n  ) => AbstractTypedUnionValidator<TUnion<TObject[]>>\n) {\n  const defaultString = `${DEFAULT_OVERALL_MESSAGE}:\\n * ${DEFAULT_UNKNOWN_TYPE_MESSAGE}`;\n  testInvalidSpecs(runThisTest, createValidator, [\n    {\n      description: 'selects 1st union member, 1st key unique, single error',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { unique1: 'hello', int1: 1 },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '/str1', message: 'Expected string' }],\n      assertString: 'Invalid value:\\n * str1 - Expected string',\n      validateString: 'Invalid value:\\n * str1 - Expected string',\n    },\n    {\n      description: 'selects 2nd union member, 1st key unique, multiple errors',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { unique2: 1, str1: 'hello', int2: 'hello' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [\n        { path: '/int1', message: 'Expected integer' },\n        { path: '/int2', message: 'must be an int' },\n      ],\n      assertString: 'Invalid value:\\n * int1 - Expected integer',\n      validateString:\n        'Invalid value:\\n' +\n        ' * int1 - Expected integer\\n' +\n        ' * int2 - must be an int',\n    },\n    {\n      description: 'unique field not selecting any union member',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { x: 'hello', str1: 'hello', int1: 1 },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'unique fields selecting multiple union members',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: { str1: 'hello', int1: 1 },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'empty object value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: {},\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'undefined value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: undefined,\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'null value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: null,\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description: 'simple literal value',\n      onlySpec: false,\n      schema: wellFormedUnion1,\n      value: 'hello',\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n      assertString: defaultString,\n      validateString: defaultString,\n    },\n    {\n      description:\n        'selects 1st union member, non-1st key unique, invalid, with overall message',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: {\n        str1: 'a',\n        str2: 'b',\n        unique1: 'c',\n        unique3: 'd',\n        opt: 32,\n      },\n      overallMessage: 'Custom message',\n      assertMessage: 'Custom message',\n      errors: [{ path: '/opt', message: 'Expected string' }],\n      assertString: 'Custom message:\\n * opt - Expected string',\n      validateString: 'Custom message:\\n * opt - Expected string',\n    },\n    {\n      description:\n        'selects 2nd union member, non-1st key unique, invalid key value',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { str1: 'a', unique2: 1, str2: 'c', opt: 32 },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '/unique2', message: 'Expected string' }],\n      assertString: 'Invalid value:\\n * unique2 - Expected string',\n      validateString: 'Invalid value:\\n * unique2 - Expected string',\n    },\n    {", "      description: 'not selecting any union member, with custom type error',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { x: 'not-there' },\n      assertMessage: DEFAULT_OVERALL_MESSAGE,\n      errors: [{ path: '', message: 'Unknown type' }],\n      assertString: 'Invalid value:\\n * Unknown type',\n      validateString: 'Invalid value:\\n * Unknown type',\n    },\n    {\n      description:", "        'not selecting any union member, with custom overall and type errors',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { opt: 32 },\n      overallMessage: 'Oopsie: {error}',\n      assertMessage: 'Oopsie: Unknown type',\n      errors: [{ path: '', message: 'Unknown type' }],\n      assertString: 'Oopsie: Unknown type:\\n * Unknown type',\n      validateString: 'Oopsie:\\n * Unknown type',\n    },\n    {\n      description: 'not selecting any union member, but having a unique key',\n      onlySpec: false,\n      schema: wellFormedUnion2,\n      value: { unique3: 'hello' },\n      overallMessage: 'Oopsie: {error}',\n      assertMessage: 'Oopsie: Unknown type',\n      errors: [{ path: '', message: 'Unknown type' }],\n      assertString: 'Oopsie: Unknown type:\\n * Unknown type',\n      validateString: 'Oopsie:\\n * Unknown type',\n    },\n  ]);\n", "  if ([MethodKind.All, MethodKind.InvalidSchema].includes(onlyRunMethod)) {\n    describe('errors on invalid union schemas', () => {\n      it('union with members missing keys', () => {\n        const validator = createValidator(unionMissingTypeKeys);\n        expect(() => validator.test({})).toThrow(MESSAGE_MEMBERS_MISSING_KEY);\n      });\n\n      it('union with multiple members having same key', () => {\n        const validator = createValidator(unionDupTypeKeysMultipleMembers);\n        expect(() => validator.assert({})).toThrow(\n          MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY\n        );\n      });\n\n      it('union with single member having multiple keys', () => {\n        const validator = createValidator(unionDupTypeKeysSingleMembers);\n        expect(() => validator.validate({})).toThrow(\n          MESSAGE_MEMBER_WITH_MULTIPLE_KEYS\n        );\n      });\n", "      it('union with optional type identifying key', () => {\n        const validator = createValidator(unionOptionalTypeKey);\n        expect(() => validator.errors({})).toThrow(\n          MESSAGE_OPTIONAL_TYPE_ID_KEY\n        );\n      });\n    });\n  }\n}\n\nfunction runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n\nfunction runThisTest(methodKind: MethodKind): boolean {\n  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n}\n"]}
{"filename": "src/test/standard-validators-valid.test.ts", "chunked_list": ["import { TSchema, Type } from '@sinclair/typebox';\n\nimport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\nimport { StandardValidator } from '../standard/standard-validator';\nimport { CompilingStandardValidator } from '../standard/compiling-standard-validator';\nimport {\n  ValidTestSpec,\n  ValidatorKind,\n  MethodKind,\n  ValidatorCache,", "  MethodKind,\n  ValidatorCache,\n} from './test-utils';\nimport { testValidSpecs } from './test-valid-specs';\n\nconst onlyRunValidator = ValidatorKind.All;\nconst onlyRunMethod = MethodKind.All;\n\nconst schema0 = Type.String({\n  minLength: 5,", "const schema0 = Type.String({\n  minLength: 5,\n  maxLength: 10,\n  pattern: '^[a-zA-Z]+$',\n});\n\nconst schema1 = Type.Object({\n  delta: Type.Integer(),\n  count: Type.Integer({ exclusiveMinimum: 0 }),\n  name: schema0,", "  count: Type.Integer({ exclusiveMinimum: 0 }),\n  name: schema0,\n});\n\nconst validatorCache = new ValidatorCache();\n\ndescribe('standard validators - valid values', () => {\n  if (runThisValidator(ValidatorKind.NonCompiling)) {\n    describe('StandardValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getNonCompiling(\n          schema,\n          () => new StandardValidator(schema)\n        )\n      );\n    });\n  }", "  if (runThisValidator(ValidatorKind.Compiling)) {\n    describe('CompilingStandardValidator', () => {\n      testValidator((schema: TSchema) =>\n        validatorCache.getCompiling(\n          schema,\n          () => new CompilingStandardValidator(schema)\n        )\n      );\n    });\n  }\n});\n", "function testValidator(\n  createValidator: (schema: TSchema) => AbstractStandardValidator<TSchema>\n) {\n  testValidSpecs(runThisTest, createValidator, verifyCleaning, [\n    {\n      description: 'valid value 0, string literal',\n      onlySpec: false,\n      schema: schema0,\n      value: 'ABCDEDEFGH',\n    },\n    {\n      description: 'valid value 1, no unrecognized fields',\n      onlySpec: false,\n      schema: schema1,\n      value: { delta: 0, count: 1, name: 'ABCDE' },\n    },\n    {\n      description: 'valid value 2, with unrecognized fields',\n      onlySpec: false,\n      schema: schema1,\n      value: {\n        delta: -5,\n        count: 125,\n        name: 'ABCDEDEFGH',\n        unrecognized1: 1,\n        unrecognized2: 'abc',\n      },\n    },\n  ]);\n}\n", "function verifyCleaning(spec: ValidTestSpec<TSchema>, value: any): void {\n  if (spec.schema.properties !== undefined) {\n    for (const key in value) {\n      expect(key in spec.schema.properties).toBe(true);\n    }\n    expect(Object.keys(value).length).toBeLessThanOrEqual(\n      Object.keys(spec.schema.properties).length\n    );\n  }\n}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n}\n\nfunction runThisTest(methodKind: MethodKind): boolean {\n  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n}\n"]}
{"filename": "src/test/test-valid-specs.ts", "chunked_list": ["import { TSchema } from '@sinclair/typebox';\nimport { MethodKind, ValidTestSpec, specsToRun } from './test-utils';\nimport { AbstractValidator } from '../abstract/abstract-validator';\n\nexport function testValidSpecs<S extends ValidTestSpec<TSchema>>(\n  runThisTest: (method: MethodKind) => boolean,\n  createValidator: (schema: TSchema) => AbstractValidator<TSchema>,\n  verifyCleaning: (spec: S, value: any) => void,\n  validSpecs: S[]\n) {\n  specsToRun(validSpecs).forEach((spec) => {", "    if (runThisTest(MethodKind.Test)) {\n      describe('test()', () => {\n        it(`test() should accept ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          expect(validator.test(spec.value)).toBe(true);\n        });\n      });\n    }\n    if (runThisTest(MethodKind.TestReturningErrors)) {\n      describe('testReturningErrors()', () => {\n        specsToRun(validSpecs).forEach((spec) => {\n          it('testReturningErrors() for ' + spec.description, () => {\n            const validator = createValidator(spec.schema);\n            const errors = validator.testReturningErrors(spec.value);\n            expect(errors).toBeNull();\n          });\n        });\n      });\n    }", "    if (runThisTest(MethodKind.TestReturningErrors)) {\n      describe('testReturningErrors()', () => {\n        specsToRun(validSpecs).forEach((spec) => {\n          it('testReturningErrors() for ' + spec.description, () => {\n            const validator = createValidator(spec.schema);\n            const errors = validator.testReturningErrors(spec.value);\n            expect(errors).toBeNull();\n          });\n        });\n      });\n    }", "    if (runThisTest(MethodKind.TestReturningFirstError)) {\n      describe('testReturningFirstError()', () => {\n        specsToRun(validSpecs).forEach((spec) => {\n          it('testReturningFirstError() for ' + spec.description, () => {\n            const validator = createValidator(spec.schema);\n            const firstError = validator.testReturningFirstError(spec.value);\n            expect(firstError).toBeNull();\n          });\n        });\n      });\n    }\n\n    describe('no cleaning', () => {", "      if (runThisTest(MethodKind.Assert)) {\n        it(`assert() should accept ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          expect(() => validator.assert(spec.value)).not.toThrow();\n        });\n      }\n\n      if (runThisTest(MethodKind.Validate)) {\n        it(`validate() should accept ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          expect(() => validator.validate(spec.value)).not.toThrow();\n        });\n      }\n    });\n\n    describe('cleaning provided value', () => {", "      if (runThisTest(MethodKind.AssertAndClean)) {\n        it(`assertAndClean() should clean provided ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const value =\n            typeof spec.value == 'object' ? { ...spec.value } : spec.value;\n          expect(() => validator.assertAndClean(value)).not.toThrow();\n          verifyCleaning(spec, value);\n        });\n      }\n\n      if (runThisTest(MethodKind.ValidateAndClean)) {\n        it(`validateAndClean() should clean provided ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const value =\n            typeof spec.value == 'object' ? { ...spec.value } : spec.value;\n          expect(() => validator.validateAndClean(value)).not.toThrow();\n          verifyCleaning(spec, value);\n        });\n      }\n    });\n\n    describe('cleaning copy of value', () => {", "      if (runThisTest(MethodKind.ValidateAndClean)) {\n        it(`validateAndClean() should clean provided ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const value =\n            typeof spec.value == 'object' ? { ...spec.value } : spec.value;\n          expect(() => validator.validateAndClean(value)).not.toThrow();\n          verifyCleaning(spec, value);\n        });\n      }\n    });\n\n    describe('cleaning copy of value', () => {", "      if (runThisTest(MethodKind.AssertAndCleanCopy)) {\n        it(`assertAndCleanCopy() should clean copy of ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const value = validator.assertAndCleanCopy(spec.value) as object;\n          verifyCleaning(spec, value);\n        });\n      }\n\n      if (runThisTest(MethodKind.ValidateAndCleanCopy)) {\n        it(`validateAndCleanCopy() should clean copy of ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const value = validator.validateAndCleanCopy(spec.value) as object;\n          verifyCleaning(spec, value);\n        });\n      }\n    });\n", "      if (runThisTest(MethodKind.ValidateAndCleanCopy)) {\n        it(`validateAndCleanCopy() should clean copy of ${spec.description}`, () => {\n          const validator = createValidator(spec.schema);\n          const value = validator.validateAndCleanCopy(spec.value) as object;\n          verifyCleaning(spec, value);\n        });\n      }\n    });\n\n    if (runThisTest(MethodKind.Errors)) {\n      describe('errors()', () => {\n        specsToRun(validSpecs).forEach((spec) => {\n          it('errors() for ' + spec.description, () => {\n            const validator = createValidator(spec.schema);\n            const errors = [...validator.errors(spec.value)];\n            expect(errors.length).toEqual(0);\n          });\n        });\n      });\n    }", "    if (runThisTest(MethodKind.Errors)) {\n      describe('errors()', () => {\n        specsToRun(validSpecs).forEach((spec) => {\n          it('errors() for ' + spec.description, () => {\n            const validator = createValidator(spec.schema);\n            const errors = [...validator.errors(spec.value)];\n            expect(errors.length).toEqual(0);\n          });\n        });\n      });\n    }", "    if (runThisTest(MethodKind.FirstError)) {\n      describe('firstError()', () => {\n        specsToRun(validSpecs).forEach((spec) => {\n          it('firstError() for ' + spec.description, () => {\n            const validator = createValidator(spec.schema);\n            const firstError = validator.firstError(spec.value);\n            expect(firstError).toBeNull();\n          });\n        });\n      });\n    }\n  });\n}\n"]}
{"filename": "src/abstract/abstract-typed-union-validator.ts", "chunked_list": ["import { Static, TObject, TUnion } from '@sinclair/typebox';\n\nimport { AbstractValidator } from './abstract-validator';\n\n/**\n * The key providing the object type in discriminated unions, if not\n * specified in the schema's `discriminantKey` option.\n */\nexport const DEFAULT_DISCRIMINANT_KEY = 'kind';\n\n/**\n * Abstract validator for values that are typed member unions of objects.\n */", "export abstract class AbstractTypedUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractValidator<S> {\n  constructor(schema: S) {\n    super(schema);\n  }\n\n  /** @inheritdoc */\n  override assert(value: Readonly<unknown>, overallError?: string): void {\n    this.assertReturningSchema(value, overallError);\n  }\n\n  /** @inheritdoc */\n  override assertAndClean(value: unknown, overallError?: string): void {\n    const schema = this.assertReturningSchema(value as any, overallError);\n    this.cleanValue(schema, value);\n  }\n\n  /** @inheritdoc */\n  override assertAndCleanCopy(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): Static<S> {\n    const schema = this.assertReturningSchema(value, overallError);\n    return this.cleanCopyOfValue(schema, value);\n  }\n\n  /** @inheritdoc */\n  override validate(value: Readonly<unknown>, overallError?: string): void {\n    this.validateReturningSchema(value, overallError);\n  }\n\n  /** @inheritdoc */\n  override validateAndClean(value: unknown, overallError?: string): void {\n    const schema = this.validateReturningSchema(value as any, overallError);\n    this.cleanValue(schema, value);\n  }\n\n  /** @inheritdoc */\n  override validateAndCleanCopy(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): Static<S> {\n    const schema = this.validateReturningSchema(value, overallError);\n    return this.cleanCopyOfValue(schema, value);\n  }\n\n  protected abstract assertReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject;\n\n  protected abstract validateReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject;\n\n  protected toValueKeyDereference(key: string): string {\n    return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(key)\n      ? `value.${key}`\n      : `value['${key.replace(/'/g, \"\\\\'\")}']`;\n  }\n}\n"]}
{"filename": "src/abstract/abstract-standard-validator.ts", "chunked_list": ["import type { Static, TSchema } from '@sinclair/typebox';\n\nimport { AbstractValidator } from './abstract-validator';\n\n/**\n * Abstract validator for standard TypeBox values.\n */\nexport abstract class AbstractStandardValidator<\n  S extends TSchema\n> extends AbstractValidator<S> {\n  /** @inheritdoc */\n  constructor(schema: Readonly<S>) {\n    super(schema);\n  }\n\n  /** @inheritdoc */\n  override assertAndClean(value: unknown, overallError?: string): void {\n    this.assert(value as any, overallError);\n    this.cleanValue(this.schema, value);\n  }\n\n  /** @inheritdoc */\n  override assertAndCleanCopy(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): Static<S> {\n    this.assert(value, overallError);\n    return this.cleanCopyOfValue(this.schema, value);\n  }\n\n  /** @inheritdoc */\n  override validateAndClean(value: unknown, overallError?: string): void {\n    this.validate(value as any, overallError);\n    this.cleanValue(this.schema, value);\n  }\n\n  /** @inheritdoc */\n  override validateAndCleanCopy(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): Static<S> {\n    this.validate(value, overallError);\n    return this.cleanCopyOfValue(this.schema, value);\n  }\n}\n"]}
{"filename": "src/abstract/abstract-compiling-typed-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\nimport { Value, ValueError } from '@sinclair/typebox/value';\nimport { TypeCompiler } from '@sinclair/typebox/compiler';\n\nimport { AbstractTypedUnionValidator } from './abstract-typed-union-validator';\nimport {\n  createErrorsIterable,\n  createUnionTypeError,\n  createUnionTypeErrorIterable,\n  throwInvalidAssert,", "  createUnionTypeErrorIterable,\n  throwInvalidAssert,\n  throwInvalidValidate,\n} from '../lib/error-utils';\n\nexport type FindSchemaMemberIndex = (value: unknown) => number | null;\nexport type SchemaMemberTest = (value: object) => boolean;\n\n/**\n * Abstract validatory for typed unions, performing lazy compilation.\n */", "export abstract class AbstractCompilingTypedUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractTypedUnionValidator<S> {\n  #compiledSchemaMemberTests: (SchemaMemberTest | undefined)[];\n\n  /** @inheritdoc */\n  constructor(schema: Readonly<S>) {\n    super(schema);\n    this.#compiledSchemaMemberTests = new Array(schema.anyOf.length);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    const memberIndex = this.compiledFindSchemaMemberIndex(value);\n    return this.compiledSchemaMemberTest(memberIndex, value);\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    const indexOrError = this.compiledFindSchemaMemberIndexOrError(value);", "    if (typeof indexOrError !== 'number') {\n      return createUnionTypeErrorIterable(indexOrError);\n    }\n    return createErrorsIterable(\n      Value.Errors(this.schema.anyOf[indexOrError], value)\n    );\n  }\n\n  protected override assertReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.compiledFindSchemaMemberIndexOrError(value);", "    if (typeof indexOrError !== 'number') {\n      throwInvalidAssert(overallError, indexOrError);\n    }\n    const memberSchema = this.schema.anyOf[indexOrError];\n    if (!this.compiledSchemaMemberTest(indexOrError, value)) {\n      throwInvalidAssert(\n        overallError,\n        Value.Errors(memberSchema, value).First()!\n      );\n    }\n    return memberSchema;\n  }\n\n  protected override validateReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.compiledFindSchemaMemberIndexOrError(value);", "    if (typeof indexOrError !== 'number') {\n      throwInvalidValidate(overallError, indexOrError);\n    }\n    const memberSchema = this.schema.anyOf[indexOrError];\n    if (!this.compiledSchemaMemberTest(indexOrError, value)) {\n      throwInvalidValidate(overallError, Value.Errors(memberSchema, value));\n    }\n    return memberSchema;\n  }\n\n  protected compiledFindSchemaMemberIndexOrError(\n    value: Readonly<unknown>\n  ): number | ValueError {\n    const memberIndex = this.compiledFindSchemaMemberIndex(value);", "    if (memberIndex === null) {\n      return createUnionTypeError(this.schema, value);\n    }\n    return memberIndex;\n  }\n\n  protected abstract compiledFindSchemaMemberIndex(\n    value: Readonly<unknown>\n  ): number | null;\n\n  private compiledSchemaMemberTest(\n    memberIndex: number | null,\n    value: Readonly<unknown>\n  ): boolean {", "    if (memberIndex === null) {\n      return false;\n    }\n    if (this.#compiledSchemaMemberTests[memberIndex] === undefined) {\n      let code = TypeCompiler.Compile(this.schema.anyOf[memberIndex]).Code();\n      code = code.replace(\n        `(typeof value === 'object' && value !== null && !Array.isArray(value)) &&`,\n        ''\n      );\n      // provide some resilience to change in TypeBox compiled code formatting\n      const startOfFunction = code.indexOf('function');\n      const startOfReturn = code.indexOf('return', startOfFunction);\n      code =\n        'return ' +\n        code.substring(code.indexOf('(', startOfReturn), code.length - 1);\n      this.#compiledSchemaMemberTests[memberIndex] = new Function(\n        'value',\n        code\n      ) as SchemaMemberTest;\n    }\n    return this.#compiledSchemaMemberTests[memberIndex]!(value);\n  }\n}\n"]}
{"filename": "src/abstract/abstract-validator.ts", "chunked_list": ["import type { TSchema, Static } from '@sinclair/typebox';\nimport { Value, ValueError } from '@sinclair/typebox/value';\n\nimport { throwInvalidAssert, throwInvalidValidate } from '../lib/error-utils';\n\n/**\n * Abstract base class for validators, providing validation services for a\n * JSON schema, offering both short-circuting and full validation, supporting\n * custom error messages, and optionally removing unrecognized properties.\n *\n * As of TypeBox version 0.28.13, when validating any given value, TypeBox\n * checks the value's `maxItems` and `maxLength` constraints before testing\n * any other constraints. An API endpoint can therefore protect itself from\n * faulty and malicious clients by short-circuting validation after the\n * first validation error. The `test` method does this, but it does not\n * return any errors. If you want to short-circuit validation and return the\n * first error, use one of the `assert` methods. These methods protect the\n * server from running regex checks on excessively long strings and from\n * running regex checks on all the items of excessively long arrays.\n *\n * @typeParam S Type for a JSON schema, expressed as a TypeBox type.\n */", "export abstract class AbstractValidator<S extends TSchema> {\n  /**\n   * @param schema JSON schema against which to validate values. When a schema\n   *  provides an `errorMessage` string option, all errors occurring for that\n   *  schema (but not for nested schemas) collapse into a single error having\n   *  this message. The `errorMessage` option allows you to provide a custom\n   *  error message for a schema. For example, an `errorMessage` on a schema\n   *  for a property of an object replaces TypeBox's built-in error messages\n   *  for errors that occur on that property.\n   */\n  constructor(readonly schema: Readonly<S>) {}\n\n  /**\n   * Tests whether a value conforms to the schema. For performance reasons, it\n   * is best to call this method before calling `errors()` or `firstError()`,\n   * should you also need to information about the errors. This method does not\n   * throw `ValidationException` and does not clean values of unrecognized\n   * properties.\n   *\n   * @param value Value to validate against the schema.\n   * @returns `true` when the value conforms to the schema, `false` otherwise.\n   */\n  abstract test(value: Readonly<unknown>): boolean;\n\n  /**\n   * Tests whether a value conforms to the schema, returning an iterable whose\n   * iterator yields the validation errors, or returning `null` if there are no\n   * validation errors. This method is equivalent to calling `test()` and then\n   * `errors()` and exists only for convenience. The method does not throw\n   * `ValidationException` and does not clean values of unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @returns An iteratable yielding all validation errors, if any, otherwise\n   *  `null`. Upon detecting one or more errors for a particular schema\n   *  (possibly a nested schema), if the schema provides an `errorMessage`\n   *  property, only a single error is reported for the schema, and the\n   *  `message` property of this error is set to `errorMessage`'s value. Also,\n   *  the TypeBox error \"Expected required property\" is dropped when at least\n   *  one other error is reported for the property. Consequently, only the\n   *  `Type.Any` and `Type.Unknown` schemas can yield \"Expected required\n   *  property\" errors.\n   */\n  testReturningErrors(value: Readonly<unknown>): Iterable<ValueError> | null {\n    return this.test(value) ? null : this.errors(value);\n  }\n\n  /**\n   * Tests whether a value conforms to the schema, returning the first error,\n   * or returning `null` if there is no error. This method is equivalent to\n   * calling `test()` and then `firstError()` and exists only for convenience.\n   * The method does not throw `ValidationException` and does not clean values\n   * of unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @returns The first validation error, if there is a validation error,\n   *  otherwise `null`.\n   */\n  testReturningFirstError(value: Readonly<unknown>): ValueError | null {\n    const iterable = this.testReturningErrors(value);", "    if (iterable === null) {\n      return null;\n    }\n    const result = iterable[Symbol.iterator]().next();\n    return result.done ? null : result.value;\n  }\n\n  /**\n   * Validates a value against the schema, halting validation at the first\n   * validation error with a `ValidationException`. Does not clean values of\n   * unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @param errorMessage Overall eror message to report in the exception.\n   *  The substring `{error}`, if present, will be replaced with a string\n   *  representation of the error. Defaults to \"Invalid value\".\n   * @throws ValidationException when the value is invalid, reporting only\n   *  the first validation error in the `details` property. The `errorMessage`\n   *  parameter provides the exception's overall error message.\n   */\n  abstract assert(value: Readonly<unknown>, errorMessage?: string): void;\n\n  /**\n   * Validates a value against the schema, halting validation at the first\n   * validation error with a `ValidationException`. On successful validation,\n   * removes unrecognized properties from the provided value.\n   *\n   * @param value Value to validate against the schema.\n   * @param errorMessage Overall eror message to report in the exception.\n   *  The substring `{error}`, if present, will be replaced with a string\n   *  representation of the error. Defaults to \"Invalid value\".\n   * @throws ValidationException when the value is invalid, reporting only\n   *  the first validation error in the `details` property. The `errorMessage`\n   *  parameter provides the exception's overall error message.\n   */\n  abstract assertAndClean(value: unknown, errorMessage?: string): void;\n\n  /**\n   * Validates a value against the schema, halting validation at the first\n   * validation error with a `ValidationException`. On successful validation,\n   * returns a copy of the value with unrecognized properties removed, but\n   * returns the original value if there are no unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @param errorMessage Overall eror message to report in the exception.\n   *  The substring `{error}`, if present, will be replaced with a string\n   *  representation of the error. Defaults to \"Invalid value\".\n   * @returns The provided value itself if the value is not an object or if\n   *  the value is an object having no unrecognized properties. If the value\n   *  is an object having at least one unrecognized property, returns a copy\n   *  of the value with unrecognized properties removed.\n   * @throws ValidationException when the value is invalid, reporting only\n   *  the first validation error in the `details` property. The `errorMessage`\n   *  parameter provides the exception's overall error message.\n   */\n  abstract assertAndCleanCopy(\n    value: Readonly<unknown>,\n    errorMessage?: string\n  ): Static<S>;\n\n  /**\n   * Validates a value against the schema, detecting all validation errors\n   * and reporting them by throwing `ValidationException`. Does not clean\n   * values of unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @param errorMessage Overall error message to report in the exception.\n   * @throws ValidationException when the value is invalid, reporting all\n   *  validation errors in the `details` property. The `errorMessage`\n   *  parameter provides the exception's overall error message.\n   */\n  abstract validate(value: Readonly<unknown>, errorMessage?: string): void;\n\n  /**\n   * Validates a value against the schema, detecting all validation errors\n   * and reporting them by throwing `ValidationException`. On successful\n   * validation, removes unrecognized properties from the provided value.\n   *\n   * @param value Value to validate against the schema.\n   * @param errorMessage Overall error message to report in the exception.=\n   * @throws ValidationException when the value is invalid, reporting all\n   *  validation errors in the `details` property. The `errorMessage`\n   *  parameter provides the exception's overall error message.\n   */\n  abstract validateAndClean(value: unknown, errorMessage?: string): void;\n\n  /**\n   * Validates a value against the schema, detecting all validation errors\n   * and reporting them with a `ValidationException`. On successful validation,\n   * returns a copy of the value with unrecognized properties removed, but\n   * returns the original value if there are no unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @param errorMessage Overall error message to report in the exception.\n   * @returns The provided value itself if the value is not an object or if\n   *  the value is an object having no unrecognized properties. If the value\n   *  is an object having at least one unrecognized property, returns a copy\n   *  of the value with unrecognized properties removed.\n   * @throws ValidationException when the value is invalid, reporting all\n   *  validation errors in the `details` property. The `errorMessage`\n   *  parameter provides the exception's overall error message.\n   */\n  abstract validateAndCleanCopy(\n    value: Readonly<unknown>,\n    errorMessage?: string\n  ): Static<S>;\n\n  /**\n   * Validates a value against the schema and returns an iteratable whose\n   * iterator yields the validation errors. The iterator tests the value for the\n   * next error on each call to `next()`, returning a `ValueError` for the error\n   * until done. It does not evaluate errors in advance of their being\n   * requested, allowing you to short-circuit validation by stopping iteration\n   * early. For performance reasons, it is best to call `test()` before calling\n   * this method. This method does not throw `ValidationException` and does not\n   * clean values of unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @returns An iteratable yielding all validation errors. Upon detecting one\n   *  or more errors for a particular schema (possibly a nested schema), if the\n   *  schema provides an `errorMessage` property, only a single error is\n   *  reported for the schema, and the `message` property of this error is set\n   *  to `errorMessage`'s value. Also, the TypeBox error \"Expected required\n   *  property\" is dropped when at least one other error is reported for the\n   *  property. Consequently, only the `Type.Any` and `Type.Unknown` schemas can\n   *  yield \"Expected required property\" errors.\n   */\n  abstract errors(value: Readonly<unknown>): Iterable<ValueError>;\n\n  /**\n   * Validates a value against the schema and returns the first error,\n   * returning `null` if there is no error. No validation is performed beyond\n   * the first error, allowing you to protect the server from wasting time and\n   * memory validating excessively long strings. It is equivalent to calling\n   * `next()` exactly once on the iterator returned by `errors()`, serving\n   * only as a convenience method. For performance reasons, it is best to call\n   * `test()` before calling this method. This method does not throw\n   * `ValidationException` and does not clean values of unrecognized properties.\n   *\n   * @param value Value to validate against the schema.\n   * @returns The first validation error, if there is a validation error,\n   *  otherwise `null`.\n   */\n  firstError(value: Readonly<unknown>): ValueError | null {\n    const iterator = this.errors(value)[Symbol.iterator]();\n    const result = iterator.next();\n    return result.done ? null : result.value;\n  }\n\n  protected cleanCopyOfValue<VS extends TSchema>(\n    schema: Readonly<VS>,\n    value: Readonly<unknown>\n  ): Static<VS> {", "    if (schema.type === 'object' && typeof value === 'object') {\n      const cleanedValue: Record<string, any> = {};\n      Object.keys(schema.properties).forEach((key) => {\n        cleanedValue[key] = (value as Record<string, any>)[key];\n      });\n      return cleanedValue;\n    }\n    return value;\n  }\n\n  protected cleanValue<VS extends TSchema>(\n    schema: Readonly<VS>,\n    value: unknown\n  ): void {", "    if (schema.type === 'object' && typeof value === 'object') {\n      const schemaKeys = Object.keys(schema.properties);\n      Object.getOwnPropertyNames(value).forEach((key) => {\n        if (!schemaKeys.includes(key)) {\n          delete (value as Record<string, any>)[key];\n        }\n      });\n    }\n  }\n\n  protected uncompiledAssert(\n    schema: Readonly<TSchema>,\n    value: Readonly<unknown>,\n    overallError?: string\n  ): void {", "    if (!Value.Check(schema, value)) {\n      throwInvalidAssert(overallError, Value.Errors(schema, value).First()!);\n    }\n  }\n\n  protected uncompiledValidate(\n    schema: Readonly<TSchema>,\n    value: Readonly<unknown>,\n    overallError?: string\n  ): void {\n    if (!Value.Check(schema, value)) {\n      throwInvalidValidate(overallError, Value.Errors(schema, value));\n    }\n  }\n}\n", "    if (!Value.Check(schema, value)) {\n      throwInvalidValidate(overallError, Value.Errors(schema, value));\n    }\n  }\n}\n"]}
{"filename": "src/heterogeneous/heterogeneous-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\nimport { Value, ValueError } from '@sinclair/typebox/value';\n\nimport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\nimport {\n  createErrorsIterable,\n  createUnionTypeError,\n  createUnionTypeErrorIterable,\n  throwInvalidAssert,\n  throwInvalidValidate,", "  throwInvalidAssert,\n  throwInvalidValidate,\n} from '../lib/error-utils';\nimport { TypeIdentifyingKeyIndex } from './type-identifying-key-index';\n\n/**\n * Non-compiling validator for heterogeneous unions of objects. To improve\n * performance, list the more frequently used types earlier in the union, and\n * list each object's unique key first in its properties.\n */\nexport class HeterogeneousUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractTypedUnionValidator<S> {\n  #typeIdentifyingKeyIndex: TypeIdentifyingKeyIndex;\n\n  /** @inheritdoc */\n  constructor(schema: S) {\n    super(schema);\n    this.#typeIdentifyingKeyIndex = new TypeIdentifyingKeyIndex(schema);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    const indexOrError = this.findSchemaMemberIndex(value);", " * list each object's unique key first in its properties.\n */\nexport class HeterogeneousUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractTypedUnionValidator<S> {\n  #typeIdentifyingKeyIndex: TypeIdentifyingKeyIndex;\n\n  /** @inheritdoc */\n  constructor(schema: S) {\n    super(schema);\n    this.#typeIdentifyingKeyIndex = new TypeIdentifyingKeyIndex(schema);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      return false;\n    }\n    return Value.Check(this.schema.anyOf[indexOrError], value);\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    const indexOrError = this.findSchemaMemberIndex(value);\n    if (typeof indexOrError !== 'number') {\n      return createUnionTypeErrorIterable(indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    return createErrorsIterable(Value.Errors(schema, value));\n  }\n\n  override assertReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      return createUnionTypeErrorIterable(indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    return createErrorsIterable(Value.Errors(schema, value));\n  }\n\n  override assertReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      throwInvalidAssert(overallError, indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    this.uncompiledAssert(schema, value, overallError);\n    return schema;\n  }\n\n  override validateReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      throwInvalidValidate(overallError, indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    this.uncompiledValidate(schema, value, overallError);\n    return schema;\n  }\n\n  private findSchemaMemberIndex(value: Readonly<any>): number | ValueError {\n    if (this.#typeIdentifyingKeyIndex.keyByMemberIndex === undefined) {\n      // only incur cost if validator is actually used\n      this.#typeIdentifyingKeyIndex.cacheKeys();\n    }\n", "    if (this.#typeIdentifyingKeyIndex.keyByMemberIndex === undefined) {\n      // only incur cost if validator is actually used\n      this.#typeIdentifyingKeyIndex.cacheKeys();\n    }\n\n    if (typeof value === 'object' && value !== null) {\n      for (let i = 0; i < this.schema.anyOf.length; ++i) {\n        const uniqueKey = this.#typeIdentifyingKeyIndex.keyByMemberIndex![i];\n        if (value[uniqueKey] !== undefined) {\n          return i;\n        }\n      }\n    }\n    return createUnionTypeError(this.schema, value);\n  }\n}\n", "        if (value[uniqueKey] !== undefined) {\n          return i;\n        }\n      }\n    }\n    return createUnionTypeError(this.schema, value);\n  }\n}\n"]}
{"filename": "src/heterogeneous/type-identifying-key.ts", "chunked_list": ["import { TSchema } from '@sinclair/typebox';\n\n/**\n * Marks an occurrence of a schema as being the property of a key that\n * uniquely identifies its containing object within a heterogeneous union.\n */\nexport function TypeIdentifyingKey(schema: Readonly<TSchema>): TSchema {\n  return {\n    ...schema,\n    typeIdentifyingKey: true,\n  };\n}\n"]}
{"filename": "src/heterogeneous/index.ts", "chunked_list": ["export * from './heterogeneous-union-validator';\nexport * from './compiling-heterogeneous-union-validator';\nexport * from './type-identifying-key';\n"]}
{"filename": "src/heterogeneous/compiling-heterogeneous-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\nimport {\n  AbstractCompilingTypedUnionValidator,\n  FindSchemaMemberIndex,\n} from '../abstract/abstract-compiling-typed-union-validator';\nimport { TypeIdentifyingKeyIndex } from './type-identifying-key-index';\n\n/**\n * Lazily compiled validator for heterogeneous unions of objects. To improve", "/**\n * Lazily compiled validator for heterogeneous unions of objects. To improve\n * performance, list the more frequently used types earlier in the union, and\n * list each object's unique key first in its properties.\n */\nexport class CompilingHeterogeneousUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractCompilingTypedUnionValidator<S> {\n  #typeIdentifyingKeyIndex: TypeIdentifyingKeyIndex;\n  #compiledFindSchemaMemberIndex?: FindSchemaMemberIndex;\n\n  /** @inheritdoc */\n  constructor(schema: Readonly<S>) {\n    super(schema);\n    this.#typeIdentifyingKeyIndex = new TypeIdentifyingKeyIndex(schema);\n  }\n\n  protected override compiledFindSchemaMemberIndex(\n    value: Readonly<unknown>\n  ): number | null {", "    if (this.#compiledFindSchemaMemberIndex === undefined) {\n      this.#typeIdentifyingKeyIndex.cacheKeys();\n      const codeParts: string[] = [\n        `return ((typeof value !== 'object' || value === null || Array.isArray(value)) ? null : `,\n      ];\n      for (let i = 0; i < this.schema.anyOf.length; ++i) {\n        const uniqueKey = this.#typeIdentifyingKeyIndex.keyByMemberIndex![i];\n        codeParts.push(\n          `${this.toValueKeyDereference(uniqueKey)} !== undefined ? ${i} : `\n        );\n      }\n      this.#compiledFindSchemaMemberIndex = new Function(\n        'value',\n        codeParts.join('') + 'null)'\n      ) as FindSchemaMemberIndex;\n    }\n    return this.#compiledFindSchemaMemberIndex(value);\n  }\n}\n"]}
{"filename": "src/heterogeneous/type-identifying-key-index.ts", "chunked_list": ["import { Optional, TObject, TUnion } from '@sinclair/typebox';\n\nexport const MESSAGE_OPTIONAL_TYPE_ID_KEY =\n  'Type identifying key cannot be optional';\nexport const MESSAGE_MEMBER_WITH_MULTIPLE_KEYS =\n  'Union has member with multiple identifying keys';\nexport const MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY =\n  'Union has multiple members with same identifying key';\nexport const MESSAGE_MEMBERS_MISSING_KEY =\n  'Union has members missing identifying keys';", "export const MESSAGE_MEMBERS_MISSING_KEY =\n  'Union has members missing identifying keys';\n\n// Note: The type identifying keys of heterogeneous unions are assigned via\n// the typeIdentifyingKey schema option instead of being inferred, because\n// inferrence requires a lot of computation, especially because multiple\n// keys might be unique within a given member schema.\n\nexport class TypeIdentifyingKeyIndex {\n  keyByMemberIndex?: string[];\n\n  constructor(readonly schema: Readonly<TUnion<TObject[]>>) {}\n\n  cacheKeys(): void {\n    const unionSize = this.schema.anyOf.length;\n    const takenKeys = new Set<string>();\n    this.keyByMemberIndex = new Array<string>(unionSize);\n", "export class TypeIdentifyingKeyIndex {\n  keyByMemberIndex?: string[];\n\n  constructor(readonly schema: Readonly<TUnion<TObject[]>>) {}\n\n  cacheKeys(): void {\n    const unionSize = this.schema.anyOf.length;\n    const takenKeys = new Set<string>();\n    this.keyByMemberIndex = new Array<string>(unionSize);\n\n    for (let i = 0; i < unionSize; ++i) {\n      const memberSchema = this.schema.anyOf[i];", "    for (let i = 0; i < unionSize; ++i) {\n      const memberSchema = this.schema.anyOf[i];\n      for (const [key, schema] of Object.entries(memberSchema.properties)) {\n        if (schema.typeIdentifyingKey) {\n          if (schema[Optional] == 'Optional') {\n            throw Error(MESSAGE_OPTIONAL_TYPE_ID_KEY);\n          }\n          if (this.keyByMemberIndex[i] !== undefined) {\n            throw Error(MESSAGE_MEMBER_WITH_MULTIPLE_KEYS);\n          }\n          if (takenKeys.has(key)) {\n            throw Error(MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY);\n          }\n          this.keyByMemberIndex[i] = key;\n          takenKeys.add(key);\n        }\n      }\n    }\n", "          if (takenKeys.has(key)) {\n            throw Error(MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY);\n          }\n          this.keyByMemberIndex[i] = key;\n          takenKeys.add(key);\n        }\n      }\n    }\n\n    if (takenKeys.size < unionSize) {\n      this.keyByMemberIndex = undefined; // reset for next attempt\n      throw Error(MESSAGE_MEMBERS_MISSING_KEY);\n    }\n  }\n}\n", "    if (takenKeys.size < unionSize) {\n      this.keyByMemberIndex = undefined; // reset for next attempt\n      throw Error(MESSAGE_MEMBERS_MISSING_KEY);\n    }\n  }\n}\n"]}
{"filename": "src/discriminated/compiling-discriminated-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\nimport { DEFAULT_DISCRIMINANT_KEY } from '../abstract/abstract-typed-union-validator';\nimport {\n  AbstractCompilingTypedUnionValidator,\n  FindSchemaMemberIndex,\n} from '../abstract/abstract-compiling-typed-union-validator';\n\n/**\n * Lazily compiled validator for discriminated-union unions. To improve", "/**\n * Lazily compiled validator for discriminated-union unions. To improve\n * performance, list the more frequently used types earlier in the union,\n * and list each object's discriminant key first in its properties.\n */\nexport class CompilingDiscriminatedUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractCompilingTypedUnionValidator<S> {\n  #discriminantKey: string;\n  #compiledFindSchemaMemberIndex?: FindSchemaMemberIndex;\n\n  /** @inheritdoc */\n  constructor(schema: Readonly<S>) {\n    super(schema);\n    this.#discriminantKey =\n      this.schema.discriminantKey ?? DEFAULT_DISCRIMINANT_KEY;\n  }\n\n  protected override compiledFindSchemaMemberIndex(\n    value: Readonly<unknown>\n  ): number | null {", "    if (this.#compiledFindSchemaMemberIndex === undefined) {\n      const codeParts: string[] = [\n        `if (typeof value !== 'object' || value === null || Array.isArray(value)) return null;\n          switch (${this.toValueKeyDereference(this.#discriminantKey)}) {\\n`,\n      ];\n      for (let i = 0; i < this.schema.anyOf.length; ++i) {\n        const discriminantSchema =\n          this.schema.anyOf[i].properties[this.#discriminantKey];\n        if (discriminantSchema === undefined) {\n          throw Error(\n            `Discriminant key '${\n              this.#discriminantKey\n            }' not present in all members of discriminated union`\n          );\n        }\n        const literal = discriminantSchema.const;", "        if (discriminantSchema === undefined) {\n          throw Error(\n            `Discriminant key '${\n              this.#discriminantKey\n            }' not present in all members of discriminated union`\n          );\n        }\n        const literal = discriminantSchema.const;\n        if (typeof literal === 'string') {\n          codeParts.push(\n            `case '${literal.replace(/'/g, \"\\\\'\")}': return ${i};\\n`\n          );\n        } else {\n          codeParts.push(`case ${literal}: return ${i};\\n`);\n        }\n      }\n      const code = codeParts.join('') + 'default: return null; }';\n      this.#compiledFindSchemaMemberIndex = new Function(\n        'value',\n        code\n      ) as FindSchemaMemberIndex;\n    }\n    return this.#compiledFindSchemaMemberIndex(value);\n  }\n}\n", "        if (typeof literal === 'string') {\n          codeParts.push(\n            `case '${literal.replace(/'/g, \"\\\\'\")}': return ${i};\\n`\n          );\n        } else {\n          codeParts.push(`case ${literal}: return ${i};\\n`);\n        }\n      }\n      const code = codeParts.join('') + 'default: return null; }';\n      this.#compiledFindSchemaMemberIndex = new Function(\n        'value',\n        code\n      ) as FindSchemaMemberIndex;\n    }\n    return this.#compiledFindSchemaMemberIndex(value);\n  }\n}\n"]}
{"filename": "src/discriminated/discriminated-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\nimport { Value, ValueError } from '@sinclair/typebox/value';\n\nimport {\n  AbstractTypedUnionValidator,\n  DEFAULT_DISCRIMINANT_KEY,\n} from '../abstract/abstract-typed-union-validator';\nimport {\n  createErrorsIterable,\n  createUnionTypeError,", "  createErrorsIterable,\n  createUnionTypeError,\n  createUnionTypeErrorIterable,\n  throwInvalidAssert,\n  throwInvalidValidate,\n} from '../lib/error-utils';\n\n/**\n * Non-compiling validator for discriminated unions. To improve performance,\n * list the more frequently used types earlier in the union, and list each", " * Non-compiling validator for discriminated unions. To improve performance,\n * list the more frequently used types earlier in the union, and list each\n * object's discriminant key first in its properties.\n */\nexport class DiscriminatedUnionValidator<\n  S extends TUnion<TObject[]>\n> extends AbstractTypedUnionValidator<S> {\n  discriminantKey: string;\n  #unionIsWellformed: boolean = false;\n\n  /** @inheritdoc */\n  constructor(schema: S) {\n    super(schema);\n    this.discriminantKey =\n      this.schema.discriminantKey ?? DEFAULT_DISCRIMINANT_KEY;\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      return false;\n    }\n    return Value.Check(this.schema.anyOf[indexOrError], value);\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    const indexOrError = this.findSchemaMemberIndex(value);\n    if (typeof indexOrError !== 'number') {\n      return createUnionTypeErrorIterable(indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    return createErrorsIterable(Value.Errors(schema, value));\n  }\n\n  override assertReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      return createUnionTypeErrorIterable(indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    return createErrorsIterable(Value.Errors(schema, value));\n  }\n\n  override assertReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      throwInvalidAssert(overallError, indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    this.uncompiledAssert(schema, value, overallError);\n    return schema;\n  }\n\n  override validateReturningSchema(\n    value: Readonly<unknown>,\n    overallError?: string\n  ): TObject {\n    const indexOrError = this.findSchemaMemberIndex(value);", "    if (typeof indexOrError !== 'number') {\n      throwInvalidValidate(overallError, indexOrError);\n    }\n    const schema = this.schema.anyOf[indexOrError] as TObject;\n    this.uncompiledValidate(schema, value, overallError);\n    return schema;\n  }\n\n  private findSchemaMemberIndex(subject: Readonly<any>): number | ValueError {\n    if (!this.#unionIsWellformed) {\n      // only incur cost if validator is actually used", "    if (!this.#unionIsWellformed) {\n      // only incur cost if validator is actually used\n      for (const memberSchema of this.schema.anyOf) {\n        if (memberSchema.properties[this.discriminantKey] === undefined) {\n          throw Error(\n            `Discriminant key '${this.discriminantKey}' not present in all members of discriminated union`\n          );\n        }\n      }\n      this.#unionIsWellformed = true;\n    }\n", "    if (typeof subject === 'object' && subject !== null) {\n      const subjectKind = subject[this.discriminantKey];\n      if (subjectKind !== undefined) {\n        for (let i = 0; i < this.schema.anyOf.length; ++i) {\n          const memberKind =\n            this.schema.anyOf[i].properties[this.discriminantKey];\n          if (memberKind !== undefined && memberKind.const === subjectKind) {\n            return i;\n          }\n        }\n      }\n    }\n    return createUnionTypeError(this.schema, subject);\n  }\n}\n"]}
{"filename": "src/discriminated/index.ts", "chunked_list": ["export * from './discriminated-union-validator';\nexport * from './compiling-discriminated-union-validator';\n"]}
{"filename": "src/lib/validation-exception.ts", "chunked_list": ["/**\n * Classes representing the validation errors of a single value.\n */\n\nimport { ValueError } from '@sinclair/typebox/value';\n\n/**\n * Exception reporting the occurrence of one or more validation errors.\n */\nexport class ValidationException {\n  /**\n   * @param message Overall error message\n   * @param details The individual validation errors\n   */\n  constructor(\n    readonly message: string,\n    readonly details: Readonly<ValueError[]> = []\n  ) {}\n\n  /**\n   * Returns a string representation of the error. Provides the overall\n   * error message, followed by the specific error messages, one per line.\n   * @returns a string representation of the error.\n   */\n  toString(): string {\n    let message = this.message;", " */\nexport class ValidationException {\n  /**\n   * @param message Overall error message\n   * @param details The individual validation errors\n   */\n  constructor(\n    readonly message: string,\n    readonly details: Readonly<ValueError[]> = []\n  ) {}\n\n  /**\n   * Returns a string representation of the error. Provides the overall\n   * error message, followed by the specific error messages, one per line.\n   * @returns a string representation of the error.\n   */\n  toString(): string {\n    let message = this.message;", "    if (this.details.length > 0) {\n      if (!message.endsWith(':')) {\n        message += ':';\n      }\n      for (const detail of this.details) {\n        message += '\\n * ' + ValidationException.errorToString(detail);\n      }\n    }\n    return message;\n  }\n\n  /**\n   * Returns a string representation of a validation error, which precedes\n   * the error with its reference path if it occurs in an object.\n   */\n  static errorToString(error: ValueError): string {\n    return error.path != ''\n      ? `${error.path.substring(1)} - ${error.message}`\n      : error.message;\n  }\n}\n"]}
{"filename": "src/lib/error-utils.ts", "chunked_list": ["import { Kind, TObject, TUnion } from '@sinclair/typebox';\nimport {\n  ValueError,\n  ValueErrorIterator,\n  ValueErrorType,\n} from '@sinclair/typebox/errors';\n\nimport { ValidationException } from './validation-exception';\n\nexport const DEFAULT_OVERALL_MESSAGE = 'Invalid value';\nexport const DEFAULT_UNKNOWN_TYPE_MESSAGE = 'Object type not recognized';\n\nconst TYPEBOX_REQUIRED_ERROR_MESSAGE = 'Expected required property';\n", "\nexport const DEFAULT_OVERALL_MESSAGE = 'Invalid value';\nexport const DEFAULT_UNKNOWN_TYPE_MESSAGE = 'Object type not recognized';\n\nconst TYPEBOX_REQUIRED_ERROR_MESSAGE = 'Expected required property';\n\nexport function adjustErrorMessage(error: ValueError): ValueError {\n  if (error.schema.errorMessage !== undefined) {\n    error.message = error.schema.errorMessage;\n  }\n  return error;\n}\n", "export function createErrorsIterable(\n  typeboxErrorIterator: ValueErrorIterator\n): Iterable<ValueError> {\n  return {\n    [Symbol.iterator]: function* () {\n      const errors = typeboxErrorIterator[Symbol.iterator]();\n      let result = errors.next();\n      let customErrorPath = '???'; // signals no prior path ('' can be root path)\n      while (result.value !== undefined) {\n        const error = result.value;\n        const standardMessage = error.message;", "      while (result.value !== undefined) {\n        const error = result.value;\n        const standardMessage = error.message;\n        if (error.path !== customErrorPath) {\n          adjustErrorMessage(error);\n          if (error.message != standardMessage) {\n            customErrorPath = error.path;\n            yield error;\n          } else if (\n            // drop 'required' errors for values that have constraints\n            error.message != TYPEBOX_REQUIRED_ERROR_MESSAGE ||\n            ['Any', 'Unknown'].includes(error.schema[Kind])\n          ) {\n            yield error;\n          }\n        }\n        result = errors.next();\n      }\n    },\n  };\n}\n", "          } else if (\n            // drop 'required' errors for values that have constraints\n            error.message != TYPEBOX_REQUIRED_ERROR_MESSAGE ||\n            ['Any', 'Unknown'].includes(error.schema[Kind])\n          ) {\n            yield error;\n          }\n        }\n        result = errors.next();\n      }\n    },\n  };\n}\n", "export function createUnionTypeError(\n  unionSchema: Readonly<TUnion<TObject[]>>,\n  value: Readonly<unknown>\n): ValueError {\n  return {\n    type: ValueErrorType.Union,\n    path: '',\n    schema: unionSchema,\n    value,\n    message: unionSchema.errorMessage ?? DEFAULT_UNKNOWN_TYPE_MESSAGE,\n  };\n}\n", "export function createUnionTypeErrorIterable(\n  typeError: ValueError\n): Iterable<ValueError> {\n  return {\n    [Symbol.iterator]: function* () {\n      yield typeError;\n    },\n  };\n}\n\nexport function throwInvalidAssert(\n  overallError: string | undefined,\n  firstError: ValueError\n): never {\n  adjustErrorMessage(firstError);\n  throw new ValidationException(\n    overallError === undefined\n      ? DEFAULT_OVERALL_MESSAGE\n      : overallError.replace(\n          '{error}',\n          ValidationException.errorToString(firstError)\n        ),\n    [firstError]\n  );\n}\n", "export function throwInvalidAssert(\n  overallError: string | undefined,\n  firstError: ValueError\n): never {\n  adjustErrorMessage(firstError);\n  throw new ValidationException(\n    overallError === undefined\n      ? DEFAULT_OVERALL_MESSAGE\n      : overallError.replace(\n          '{error}',\n          ValidationException.errorToString(firstError)\n        ),\n    [firstError]\n  );\n}\n", "export function throwInvalidValidate(\n  overallError: string | undefined,\n  errorOrErrors: ValueError | ValueErrorIterator\n): never {\n  throw new ValidationException(\n    overallError ?? DEFAULT_OVERALL_MESSAGE,\n    errorOrErrors instanceof ValueErrorIterator\n      ? [...createErrorsIterable(errorOrErrors)]\n      : [errorOrErrors]\n  );\n}\n"]}
{"filename": "src/standard/standard-validator.ts", "chunked_list": ["import type { TSchema } from '@sinclair/typebox';\n\nimport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\nimport { ValueError } from '@sinclair/typebox/errors';\nimport { Value } from '@sinclair/typebox/value';\nimport { createErrorsIterable } from '../lib/error-utils';\n\n/**\n * Non-compiling validator for standard TypeBox values.\n */\nexport class StandardValidator<\n  S extends TSchema\n> extends AbstractStandardValidator<S> {\n  /** @inheritdoc */\n  constructor(schema: S) {\n    super(schema);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    return Value.Check(this.schema, value);\n  }\n\n  /** @inheritdoc */\n  override assert(value: Readonly<unknown>, overallError?: string): void {\n    this.uncompiledAssert(this.schema, value, overallError);\n  }\n\n  /** @inheritdoc */\n  override validate(value: Readonly<unknown>, overallError?: string): void {\n    this.uncompiledValidate(this.schema, value, overallError);\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    return createErrorsIterable(Value.Errors(this.schema, value));\n  }\n}\n", " * Non-compiling validator for standard TypeBox values.\n */\nexport class StandardValidator<\n  S extends TSchema\n> extends AbstractStandardValidator<S> {\n  /** @inheritdoc */\n  constructor(schema: S) {\n    super(schema);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    return Value.Check(this.schema, value);\n  }\n\n  /** @inheritdoc */\n  override assert(value: Readonly<unknown>, overallError?: string): void {\n    this.uncompiledAssert(this.schema, value, overallError);\n  }\n\n  /** @inheritdoc */\n  override validate(value: Readonly<unknown>, overallError?: string): void {\n    this.uncompiledValidate(this.schema, value, overallError);\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    return createErrorsIterable(Value.Errors(this.schema, value));\n  }\n}\n"]}
{"filename": "src/standard/index.ts", "chunked_list": ["export * from './standard-validator';\nexport * from './compiling-standard-validator';\n"]}
{"filename": "src/standard/compiling-standard-validator.ts", "chunked_list": ["import type { TSchema } from '@sinclair/typebox';\nimport {\n  TypeCheck,\n  TypeCompiler,\n  ValueError,\n} from '@sinclair/typebox/compiler';\n\nimport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\nimport {\n  createErrorsIterable,", "import {\n  createErrorsIterable,\n  throwInvalidAssert,\n  throwInvalidValidate,\n} from '../lib/error-utils';\n\n/**\n * Lazily compiled validator for standard TypeBox values.\n */\nexport class CompilingStandardValidator<\n  S extends TSchema\n> extends AbstractStandardValidator<S> {\n  #compiledType?: TypeCheck<S>;\n\n  /** @inheritdoc */\n  constructor(schema: Readonly<S>) {\n    super(schema);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    const compiledType = this.getCompiledType();\n    return compiledType.Check(value);\n  }\n\n  /** @inheritdoc */\n  override assert(value: Readonly<unknown>, overallError?: string): void {\n    const compiledType = this.getCompiledType();", " */\nexport class CompilingStandardValidator<\n  S extends TSchema\n> extends AbstractStandardValidator<S> {\n  #compiledType?: TypeCheck<S>;\n\n  /** @inheritdoc */\n  constructor(schema: Readonly<S>) {\n    super(schema);\n  }\n\n  /** @inheritdoc */\n  override test(value: Readonly<unknown>): boolean {\n    const compiledType = this.getCompiledType();\n    return compiledType.Check(value);\n  }\n\n  /** @inheritdoc */\n  override assert(value: Readonly<unknown>, overallError?: string): void {\n    const compiledType = this.getCompiledType();", "    if (!compiledType.Check(value)) {\n      throwInvalidAssert(overallError, compiledType.Errors(value).First()!);\n    }\n  }\n\n  /** @inheritdoc */\n  override validate(value: Readonly<unknown>, overallError?: string): void {\n    const compiledType = this.getCompiledType();\n    if (!compiledType.Check(value)) {\n      throwInvalidValidate(overallError, compiledType.Errors(value));\n    }\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    const compiledType = this.getCompiledType();\n    return createErrorsIterable(compiledType.Errors(value));\n  }\n\n  private getCompiledType(): TypeCheck<S> {", "    if (!compiledType.Check(value)) {\n      throwInvalidValidate(overallError, compiledType.Errors(value));\n    }\n  }\n\n  /** @inheritdoc */\n  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n    const compiledType = this.getCompiledType();\n    return createErrorsIterable(compiledType.Errors(value));\n  }\n\n  private getCompiledType(): TypeCheck<S> {", "    if (this.#compiledType === undefined) {\n      this.#compiledType = TypeCompiler.Compile(this.schema);\n    }\n    return this.#compiledType;\n  }\n}\n"]}
