{"filename": "src/extension.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport path from \"path\";\nimport {\n  createOZAccount,\n  deleteAccount,\n  deployAccount,\n  selectDeployedAccount,\n  selectNotDeployedAccount,\n} from \"./config/account\";", "  selectNotDeployedAccount,\n} from \"./config/account\";\nimport {\n  declareContract,\n  deployContract,\n  executeContractFunction,\n  executeContractFunctionFromTreeView,\n  getContractInfo,\n  isCairo1Contract,\n  loadAllCompiledContract,", "  isCairo1Contract,\n  loadAllCompiledContract,\n  selectCompiledContract,\n  setContract,\n} from \"./config/contract\";\nimport { updateSelectedNetwork } from \"./config/network\";\nimport { logger } from \"./lib\";\nimport { ContractTreeDataProvider } from \"./treeView/ContractTreeView/ContractTreeDataProvider\";\nimport { editContractAddress, refreshContract } from \"./treeView/ContractTreeView/function\";\n", "import { editContractAddress, refreshContract } from \"./treeView/ContractTreeView/function\";\n\nimport { Contract as ContractTreeItem } from \"./treeView/ContractTreeView/ContractTreeDataProvider\";\nimport { AbiTreeDataProvider } from \"./treeView/ABITreeView/AbiTreeDataProvider\";\nimport { editInput } from \"./treeView/ABITreeView/functions\";\nimport { AccountTreeDataProvider } from \"./treeView/AccountTreeView/AccountTreeDataProvider\";\n\n\nexport function activate(context: vscode.ExtensionContext) {\n\n  if (vscode.workspace.workspaceFolders === undefined) {\n    logger.error(\"Error: Please open your solidity project to vscode\");\n    return;\n  }\n\n  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n  const watcher = vscode.workspace.createFileSystemWatcher(`${path_}/starkode/**`);\n\n  watcher.onDidChange((event: vscode.Uri) => {\n    const contractName: string | undefined = context.workspaceState.get(\"selectedContract\");", "export function activate(context: vscode.ExtensionContext) {\n\n  if (vscode.workspace.workspaceFolders === undefined) {\n    logger.error(\"Error: Please open your solidity project to vscode\");\n    return;\n  }\n\n  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n  const watcher = vscode.workspace.createFileSystemWatcher(`${path_}/starkode/**`);\n\n  watcher.onDidChange((event: vscode.Uri) => {\n    const contractName: string | undefined = context.workspaceState.get(\"selectedContract\");", "    if (contractName === undefined) {\n      abiTreeView.message = \"Select a contract and its ABI functions will appear here.\";\n    } else {\n      abiTreeView.message = undefined;\n      const contractInfo = getContractInfo(path_, contractName);\n      abiTreeView.description = `${contractName.slice(0, -5)} @ ${contractInfo.address}`;\n    }\n    abiTreeDataProvider.refresh();\n  });\n\n  // Contract Tree View\n  const contractTreeDataProvider = new ContractTreeDataProvider(\n    vscode.workspace.workspaceFolders?.[0].uri.fsPath\n  );\n\n  let contractTreeView = vscode.window.createTreeView(\"starkode.contracts\", {\n    treeDataProvider: contractTreeDataProvider,\n  });\n\n  // if contract tree view is empty\n  const contracts = loadAllCompiledContract();", "  if (contracts === undefined || contracts.length === 0) {\n    contractTreeView.message = \"No contract found. Please compile your contract.\";\n  }\n\n  contractTreeView.onDidChangeSelection(event => {\n    const selectedNodes = event.selection;\n    if (selectedNodes && selectedNodes.length > 0) {\n      console.log('Selected nodes:', selectedNodes[0].label);\n    }\n  });\n\n  // Account Tree View\n  const accountTreeDataProvider = new AccountTreeDataProvider(\n    context\n  );\n\n  const accountTreeView = vscode.window.createTreeView(\"starkode.account\", {\n    treeDataProvider: accountTreeDataProvider,\n  });\n\n  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\n  const selectedAccount: string | undefined = context.workspaceState.get(\"account\") as string;\n\n  accountTreeView.message = selectedAccount ? `Account : ${selectedAccount.slice(0, 5) + \"...\" + selectedAccount.slice(-5)} | ${selectedNetwork}` : \"Select a deployed account , or create an account and deploy it\";\n\n  // ABI Tree View\n  const abiTreeDataProvider = new AbiTreeDataProvider(\n    context\n  );\n\n  const abiTreeView = vscode.window.createTreeView(\"starkode.abis\", {\n    treeDataProvider: abiTreeDataProvider,\n  });\n  const contractName: string | undefined = context.workspaceState.get(\"selectedContract\");", "  if (!contractName || contractName === undefined) {\n    abiTreeView.message = \"Select a contract and its ABI functions will appear here.\";\n  }\n  else {\n    const contractInfo = getContractInfo(path_, contractName);\n    if (contractInfo !== undefined) {\n      abiTreeView.description = `${contractName.slice(0, -5)} @ ${contractInfo.address}`;\n    } else {\n      abiTreeView.message = \"Select a contract and its ABI functions will appear here.\";\n    }\n  }\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"starkode.activate\", () => {", "      try {\n        if (!fs.existsSync(path.join(path_, \"starkode\"))) {\n          fs.mkdirSync(path.join(path_, \"starkode\"));\n        }\n        vscode.window.showInformationMessage(\"Starkode activated.\");\n      } catch (error) {\n        console.log(error);\n      }\n    }),\n\n    vscode.commands.registerCommand(\"starkode.refreshContracts\", async (node: ContractTreeItem) => {\n      contractTreeView = await refreshContract(node, contractTreeDataProvider);\n      contractTreeView.message = undefined;\n    }),\n\n    vscode.commands.registerCommand(\"starkode.useContract\", async (node: ContractTreeItem) => {\n      setContract(context, node.label);\n      abiTreeView.message = undefined;\n\n      const contractInfo = getContractInfo(path_, `${node.label}.json`);", "      if (contractInfo !== undefined) {\n        abiTreeView.description = `${node.label} @ ${contractInfo.address}`;\n      }\n      abiTreeDataProvider.refresh();\n    }),\n\n    vscode.commands.registerCommand(\"starkode.useAccount\", async (node: any) => {\n      console.log(node);\n      if (node.context === \"deployedAccount\") {\n        void context.workspaceState.update(\"account\", node.account.accountAddress);\n        logger.log(`${node.account.accountAddress} selected`);\n        const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n        const selectedAccount = context.workspaceState.get(\"account\") as string;", "      if (node.context === \"deployedAccount\") {\n        void context.workspaceState.update(\"account\", node.account.accountAddress);\n        logger.log(`${node.account.accountAddress} selected`);\n        const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n        const selectedAccount = context.workspaceState.get(\"account\") as string;\n        if (selectedAccount !== undefined) {\n          accountTreeView.message = `Account : ${selectedAccount.slice(0, 5) + \"...\" + selectedAccount.slice(-5)} | ${selectedNetwork}`;\n        }\n        abiTreeDataProvider.refresh();\n      } else {\n        vscode.window.showErrorMessage(\"Please deploy the account first.\");\n      }\n    }),\n\n    vscode.commands.registerCommand(\"starkode.createAccountTreeView\", async () => {\n      createOZAccount(context);\n      accountTreeDataProvider.refresh();\n    }),\n\n    vscode.commands.registerCommand(\"starkode.selectNetwork\", async () => {\n      await updateSelectedNetwork(context, accountTreeView, accountTreeDataProvider);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.deployAccountTreeView\", async (node: any) => {\n      void context.workspaceState.update(\"undeployedAccount\", node.account.accountAddress);\n      logger.log(`${node.account.accountAddress} selected`);\n      await deployAccount(context, accountTreeDataProvider);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.copyAccountAddress\", async (node: any) => {\n      vscode.env.clipboard.writeText(node.account.accountAddress);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.deleteAccount\", async (node: any) => {\n      await deleteAccount(context, node);\n      accountTreeDataProvider.refresh();\n    }),\n\n    vscode.commands.registerCommand(\"starkode.editContractAddress\", async (node: ContractTreeItem) => {\n      await editContractAddress(node, context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.editInput\", async (node: any) => {\n      const selectedContract: string = context.workspaceState.get(\n        \"selectedContract\"\n      ) as string;\n      await editInput(node, abiTreeDataProvider, selectedContract);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.deploycontract\", async (node: any) => {\n      const selectedContract: string = context.workspaceState.get(\n        \"selectedContract\"\n      ) as string;", "      if (selectedContract === undefined) {\n        logger.log(\"No Contract selected\");\n        return;\n      }\n      if (selectedContract.slice(0, -5) !== node.label) {\n        logger.log(\"Please select the contract first.\");\n      } else {\n        if (isCairo1Contract(selectedContract)) {\n          await vscode.commands.executeCommand(\"starkode.declareContract\");\n        } else {\n          await vscode.commands.executeCommand(\"starkode.deployContract\");\n        }\n      }\n    }),\n\n    vscode.commands.registerCommand(\"starkode.selectnetwork\", async () => {\n      await updateSelectedNetwork(context, accountTreeView, accountTreeDataProvider);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.createaccount\", async () => {\n      createOZAccount(context);\n      contractTreeDataProvider.refresh();\n    }),\n\n    vscode.commands.registerCommand(\"starkode.unDeployedAccount\", async () => {\n      selectNotDeployedAccount(context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.declareContract\", async () => {\n      await declareContract(context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.deployaccount\", async () => {\n      await deployAccount(context, accountTreeDataProvider);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.selectaccount\", async () => {\n      await selectDeployedAccount(context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.selectContract\", async () => {\n      selectCompiledContract(context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.deployContract\", async () => {\n      await deployContract(context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.callFunction\", async () => {\n      await executeContractFunction(context);\n    }),\n\n    vscode.commands.registerCommand(\"starkode.callContract\", async (node: any) => {\n      await executeContractFunctionFromTreeView(context, node.abi);\n    })\n\n  );\n}\n"]}
{"filename": "src/treeView/ABITreeView/functions.ts", "chunked_list": ["\nimport * as vscode from 'vscode';\nimport { Abi } from './AbiTreeItem';\nimport { logger } from '../../lib';\nimport path from 'path';\n\nasync function search(filePath: string, searchString: string, startLine = 0) {\n    const document = await vscode.workspace.openTextDocument(filePath);\n    const text = document.getText();\n    const start = text.indexOf(searchString, document.offsetAt(new vscode.Position(startLine, 0)));\n    const startPosition = document.positionAt(start);\n    return startPosition;\n}\n\nexport const editInput = async (input: Abi, abiTreeDataProvider: any, fileName: string) => {\n    let filePath = \"\";", "    if (vscode.workspace.workspaceFolders === undefined) {\n        logger.error(\"Error: Please open your solidity project to vscode\");\n        return [];\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const file = fileName.substring(0, fileName.length - 5);\n    filePath = path.join(path_, \"starkode\", file, `${file}_abi.json`);\n\n    const document = await vscode.workspace.openTextDocument(filePath);\n    const lineNumber = await search(filePath, `\"name\": \"${input.parent?.label}\"`);\n    const line = await search(filePath, `\"name\": \"${input.abi.name}\"`, lineNumber.line);\n\n    const cursorPosition = new vscode.Position(line.line + 2, line.character + 10);\n    const editor = await vscode.window.showTextDocument(document);\n    editor.selection = new vscode.Selection(cursorPosition, cursorPosition);\n    editor.revealRange(new vscode.Range(cursorPosition, cursorPosition));\n\n    abiTreeDataProvider.refresh(input);\n};"]}
{"filename": "src/treeView/ABITreeView/AbiTreeItem.ts", "chunked_list": ["import { TreeItem, TreeItemCollapsibleState, ThemeIcon } from 'vscode';\n\nexport class Abi extends TreeItem {\n  public value: any;\n  constructor(\n    public readonly label: string,\n    public readonly abi: any,\n    contextValue: string,\n    public parent: Abi | null,\n    public children: Abi[],\n    public readonly collapsibleState: TreeItemCollapsibleState\n  ) {\n    super(label, collapsibleState);\n    this.contextValue = contextValue;", "    if (abi.type === \"function\") {\n      this.iconPath = new ThemeIcon(\"symbol-method\");\n    } else {\n      this.description = abi.type + \" : \" + abi.value;\n      this.iconPath = new ThemeIcon(\"symbol-parameter\");\n    }\n  }\n}"]}
{"filename": "src/treeView/ABITreeView/AbiTreeDataProvider.ts", "chunked_list": ["import vscode, { TreeDataProvider, TreeItem, TreeItemCollapsibleState, EventEmitter, Event } from 'vscode';\nimport { Abi } from './AbiTreeItem';\nimport { ABIFragment } from '../../types';\nimport { getContractABI } from '../../config/contract';\nimport { logger } from '../../lib';\nexport class AbiTreeDataProvider implements TreeDataProvider<Abi> {\n\n  context: vscode.ExtensionContext;\n\n  constructor(context: vscode.ExtensionContext) {\n    this.context = context;\n  }\n\n  getTreeItem(element: Abi): TreeItem {\n    return element;\n  }\n\n  async getChildren(element?: Abi): Promise<Abi[] | undefined> {\n    const leaves: Abi[] = [];", "    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return undefined;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const selectedContract: string | undefined = this.context.workspaceState.get(\"selectedContract\") as string;\n    const data = getContractABI(path_,selectedContract);\n    const inputFunction: Array<ABIFragment> | undefined = selectedContract !== undefined ? data === undefined ? undefined : data.abi :\n      [];\n    if (inputFunction === undefined) {\n      return undefined;\n    } \n    else {", "    if (inputFunction === undefined) {\n      return undefined;\n    } \n    else {\n      if (!element) {\n        for (const entry of inputFunction) {\n          if (entry.type === \"function\") {\n            const colapse = (entry.inputs && entry.inputs.length > 0)\n              ? TreeItemCollapsibleState.Expanded\n              : TreeItemCollapsibleState.None;\n            leaves.push(\n              new Abi(\n                entry.name,\n                entry,\n                entry.stateMutability === \"view\" || entry.stateMutability === \"external\" ? \"abiReadFunction\" : \"abiFunction\",\n                null,\n                [],\n                colapse\n              )\n            );\n          }\n        }", "      } else if (element.abi.type === \"function\") {\n        const value: any = inputFunction.find((i: any) => i.name === element.abi.name);\n        for (const input of value.inputs) {\n          leaves.push(\n            new Abi(\n              input.name,\n              input,\n              \"abiInput\",\n              element,\n              [],\n              TreeItemCollapsibleState.None\n            )\n          );\n        }\n        element.children = leaves;\n      }\n    }\n    return leaves;\n  }\n\n  private _onDidChangeTreeData: EventEmitter<Abi | undefined> = new EventEmitter<Abi | undefined>();\n  readonly onDidChangeTreeData: Event<Abi | undefined> = this._onDidChangeTreeData.event;\n\n  refresh(item?: Abi): void {\n    this._onDidChangeTreeData.fire(item);\n  }\n}\n"]}
{"filename": "src/treeView/AccountTreeView/AccountTreeDataProvider.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport { loadAllCompiledContract } from \"../../config/contract\";\nimport { JSONAccountType } from \"../../types\";\nimport { getDeployedAccounts, getNotDeployedAccounts } from \"../../config/account\";\nimport { getNetworkProvider } from \"../../config/network\";\n\nexport class AccountTreeDataProvider\n  implements vscode.TreeDataProvider<Account>\n{\n  constructor(public context: vscode.ExtensionContext) { }\n\n  getTreeItem(element: Account): vscode.TreeItem {\n    return element;\n  }\n\n  async getChildren(element?: Account): Promise<Account[]> {\n    const accounts: Array<JSONAccountType> | undefined = getDeployedAccounts(this.context);\n    const undeployedAccounts: Array<JSONAccountType> | undefined = await getNotDeployedAccounts(this.context);", "    if ((accounts === undefined && undeployedAccounts === undefined)){\n      return [];\n    } else {\n      const leaves = [];\n      if (accounts !== undefined) {\n        for (const account of accounts) {\n          leaves.push(new Account(\n            account.accountAddress.slice(0, 5) + \"...\" + account.accountAddress.slice(-5),\n            vscode.TreeItemCollapsibleState.None,\n            \"deployedAccount\",\n            account,\n            \"verified\"\n          ));\n        }\n      }", "      if (undeployedAccounts !== undefined) {\n        for (const account of undeployedAccounts) {\n          leaves.push(new Account(\n            account.accountAddress.slice(0, 5) + \"...\" + account.accountAddress.slice(-5),\n            vscode.TreeItemCollapsibleState.None,\n            \"undeployedAccount\",\n            account,\n            \"unverified\"\n          ));\n        }\n      }\n      return leaves;\n    }\n  }\n\n  private _onDidChangeTreeData: vscode.EventEmitter<Account | undefined> =\n    new vscode.EventEmitter<Account | undefined>();\n  readonly onDidChangeTreeData: vscode.Event<Account | undefined> =\n    this._onDidChangeTreeData.event;\n\n  refresh(): void {\n    this._onDidChangeTreeData.fire(undefined);\n  }\n}\n", "export class Account extends vscode.TreeItem {\n  contextValue: string;\n  constructor(\n    public readonly label: string,\n    public readonly collapsibleState: vscode.TreeItemCollapsibleState,\n    public readonly context: string,\n    public account: JSONAccountType | undefined,\n    public readonly icon: string\n  ) {\n    super(label, collapsibleState);\n    this.contextValue = context;\n  }\n\n  command = {\n    title: \"Use Account\",\n    command: \"starkode.useAccount\",\n    arguments: [this],\n  };\n\n  iconPath = new vscode.ThemeIcon(this.icon);\n}\n\n\n"]}
{"filename": "src/treeView/ContractTreeView/ContractTreeDataProvider.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport { isCairo1Contract, loadAllCompiledContract } from \"../../config/contract\";\n\nexport class ContractTreeDataProvider implements vscode.TreeDataProvider<Contract> {\n  constructor(private workspaceRoot: string | undefined) { }\n\n  getTreeItem(element: Contract): vscode.TreeItem {\n    return element;\n  }\n\n  async getChildren(element?: Contract): Promise<Contract[]> {\n    const contracts = loadAllCompiledContract();\n", "    if (contracts === undefined || contracts.length === 0) {\n      vscode.window.showInformationMessage(\"No Contracts in workspace\");\n      return [];\n    } else {\n      const leaves = [];\n      for (const file of contracts) {\n        leaves.push(new Contract(\n          file.slice(0, -5),\n          vscode.TreeItemCollapsibleState.None,\n          \"contract\",\n          isCairo1Contract(file) ? \"file-code\" : \"file-text\"\n        ));\n      }\n      return leaves;\n    }\n  }\n\n  private _onDidChangeTreeData: vscode.EventEmitter<Contract | undefined> =\n    new vscode.EventEmitter<Contract | undefined>();\n  readonly onDidChangeTreeData: vscode.Event<Contract | undefined> =\n    this._onDidChangeTreeData.event;\n\n  refresh(): void {\n    this._onDidChangeTreeData.fire(undefined);\n  }\n}\n", "export class Contract extends vscode.TreeItem {\n  contextValue: string;\n  constructor(\n    public readonly label: string,\n    public readonly collapsibleState: vscode.TreeItemCollapsibleState,\n    public readonly context: string,\n    public icon: string\n  ) {\n    super(label, collapsibleState);\n    this.contextValue = context;\n  }\n\n  command = {\n    title: \"Use Contract\",\n    command: \"starkode.useContract\",\n    arguments: [this],\n  };\n\n  iconPath = new vscode.ThemeIcon(this.icon);\n}\n\n"]}
{"filename": "src/treeView/ContractTreeView/function.ts", "chunked_list": ["\nimport * as vscode from \"vscode\";\nimport { Contract as ContractTreeItem } from \"./ContractTreeDataProvider\";\nimport { logger } from \"../../lib\";\nimport path = require(\"path\");\nexport const refreshContract = async (node: ContractTreeItem, contractTreeDataProvider: any): Promise<vscode.TreeView<ContractTreeItem>> => {\n    return vscode.window.createTreeView(\"starkode.contracts\", { treeDataProvider: contractTreeDataProvider, });\n};\n\nexport const editContractAddress = async (input : any,context: vscode.ExtensionContext) => {\n    if (vscode.workspace.workspaceFolders === undefined) {\n        logger.error(\"Error: Open or Create a cairo project.\");\n        return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const filePath = path.join(path_, \"starkode\", input.label, `${input.label}_address.json`);\n    const document = await vscode.workspace.openTextDocument(filePath);\n    const editor = await vscode.window.showTextDocument(document);\n};\n\n", "\nexport const editContractAddress = async (input : any,context: vscode.ExtensionContext) => {\n    if (vscode.workspace.workspaceFolders === undefined) {\n        logger.error(\"Error: Open or Create a cairo project.\");\n        return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const filePath = path.join(path_, \"starkode\", input.label, `${input.label}_address.json`);\n    const document = await vscode.workspace.openTextDocument(filePath);\n    const editor = await vscode.window.showTextDocument(document);\n};\n\n"]}
{"filename": "src/utils/functions.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport path from \"path\";\nimport { logger } from \"../lib\";\nimport { ABIFragment, JSONAccountType, TIsAccountDeployed } from \"../types\";\n\nexport const createABIFile = (file: string) => {\n  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const fileName = file.substring(0, file.length - 5);\n", "    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const fileName = file.substring(0, file.length - 5);\n\n    if (!fs.existsSync(path.join(path_, \"starkode\", fileName))) {\n      fs.mkdirSync(path.join(path_, \"starkode\", fileName),{recursive: true});\n    }\n", "    if (\n      !fs.existsSync(\n        path.join(path_, \"starkode\", fileName, `${fileName}_abi.json`)\n      )\n    ) {\n      const filePath = path.join(path_, file);\n      const fileData = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n\n      const isCairo1Contract =\n        JSON.parse(fileData).contract_class_version === \"0.1.0\" ? true : false;\n\n      const abi: Array<ABIFragment> = JSON.parse(fileData).abi;\n\n      const abiFunctions = abi.filter((e) => e.type === \"function\");\n\n      const functionsValue = abiFunctions.map((func) => {\n        return {\n          type: func.type,\n          name: func.name,\n          inputs: func.inputs.map((e) => {\n            return { ...e, value: \"\" };\n          }),\n          stateMutability: func.stateMutability\n            ? func.stateMutability\n            : func.state_mutability,\n          outputs: func.outputs,\n        };\n      });\n\n      fs.writeFileSync(\n        path.join(path_, \"starkode\", fileName, `${fileName}_abi.json`),\n        JSON.stringify({ isCairo1: isCairo1Contract, abi: functionsValue }, null, 2)\n      );\n      logger.log(\"ABI file created successfully.\");\n    } else {\n      logger.log(`${fileName}_abi.json already exist.`);\n    }", "  } catch (error) {\n    logger.log(`Error while writing to file: ${error}`);\n  }\n};\n\nexport const createAddressFile = (file: string) => {\n  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const fileName = file.substring(0, file.length - 5);\n", "    if (\n      !fs.existsSync(\n        path.join(path_, \"starkode\", fileName, `${fileName}_address.json`)\n      )\n    ) {\n      fs.writeFileSync(\n        path.join(path_, \"starkode\", fileName, `${fileName}_address.json`),\n        JSON.stringify({\n          name: fileName,\n          address: \"\",\n          classHash: \"\",\n        }, null, 2)\n      );\n      logger.log(\"Address file created successfully.\");\n    } else {\n      logger.log(`${fileName}_address.json already exist.`);\n    }", "  } catch (error) {\n    logger.log(`Error while writing to file: ${error}`);\n  }\n};\n\nexport const accountDeployStatus = (\n  accounts: Array<JSONAccountType>,\n  selectedNetwork: string,\n  status: boolean\n) => {\n  const networks = [\"goerli-alpha\", \"goerli-alpha-2\", \"mainnet-alpha\"];\n  let result: Array<JSONAccountType> | undefined;\n  switch (selectedNetwork) {\n    case networks[0]: {\n      result = accounts.filter((e) => e.isDeployed.gAlpha === status);\n      break;\n    }\n    case networks[1]: {\n      result = accounts.filter((e) => e.isDeployed.gAlpha2 === status);\n      break;\n    }\n    case networks[2]: {\n      result = accounts.filter((e) => e.isDeployed.mainnet === status);\n      break;\n    }\n    default:\n      break;\n  }\n  return result;\n};\n"]}
{"filename": "src/config/network.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport { logger } from \"../lib\";\nimport { INetworkQP } from \"../types\";\nimport { Provider, SequencerProviderOptions } from \"starknet\";\nimport { Account } from \"../treeView/AccountTreeView/AccountTreeDataProvider\";\n\nexport const NETWORKS = [\"goerli-alpha\", \"goerli-alpha-2\", \"mainnet-alpha\"];\n\nexport const updateSelectedNetwork = async (\n  context: vscode.ExtensionContext,", "export const updateSelectedNetwork = async (\n  context: vscode.ExtensionContext,\n  accountTreeView: vscode.TreeView<Account>,\n  accountTreeDataProvider: any\n) => {\n  const quickPick = vscode.window.createQuickPick<INetworkQP>();\n\n  quickPick.items = NETWORKS.map((name: string) => ({\n    label: name,\n  }));", "    label: name,\n  }));\n  quickPick.onDidChangeActive(() => {\n    quickPick.placeholder = \"Select network\";\n  });\n  quickPick.onDidChangeSelection((selection: any) => {\n    if (selection[0] != null) {\n      const { label } = selection[0];\n      void context.workspaceState.update(\"selectedNetwork\", label);\n      quickPick.dispose();\n\n      logger.success(`Selected network is ${label}`);\n      const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n      const selectedAccount = context.workspaceState.get(\"account\") as string;", "      if (selectedAccount !== undefined) {\n        accountTreeView.message = `Account : ${selectedAccount.slice(0, 5) + \"...\" + selectedAccount.slice(-5)} | ${selectedNetwork}`;\n      }\n      accountTreeDataProvider.refresh();\n    }\n  });\n  quickPick.onDidHide(() => {\n    quickPick.dispose();\n  });\n  quickPick.show();\n};\n\nexport const getNetworkProvider = (\n  context: vscode.ExtensionContext\n): Provider | undefined => {\n  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n  let networkBaseUrl: string | undefined = undefined;\n\n  switch (selectedNetwork) {\n    case NETWORKS[0]: {\n      networkBaseUrl = \"https://alpha4.starknet.io\";\n      break;\n    }\n    case NETWORKS[1]: {\n      networkBaseUrl = \"https://alpha4-2.starknet.io\";\n      break;\n    }\n    case NETWORKS[2]: {\n      networkBaseUrl = \"https://alpha-mainnet.starknet.io\";\n      break;\n    }\n    default: {\n      break;\n    }\n  }", "  if (networkBaseUrl === undefined) {\n    // logger.log(\"No network selected.\");\n    return;\n  }\n\n  const provider = new Provider({\n    sequencer: { baseUrl: networkBaseUrl },\n  });\n  return provider;\n};\n"]}
{"filename": "src/config/account.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport {\n  Account,\n  ec,\n  json,\n  stark,\n  Provider,\n  hash,\n  CallData,", "  hash,\n  CallData,\n  Signer,\n} from \"starknet\";\nimport { logger } from \"../lib\";\nimport { IAccountQP, JSONAccountType } from \"../types\";\nimport { NETWORKS, getNetworkProvider } from \"./network\";\nimport { accountDeployStatus } from \"../utils/functions\";\n\nexport const createOZAccount = async (context: vscode.ExtensionContext) => {\n  try {\n    const privateKey = stark.randomAddress();\n    const publicKey = await new Signer(privateKey).getPubKey();\n\n    const OZaccountClassHash =\n      \"0x06f3ec04229f8f9663ee7d5bb9d2e06f213ba8c20eb34c58c25a54ef8fc591cb\";\n    const OZaccountConstructorCallData = CallData.compile({\n      publicKey: publicKey,\n    });\n    const OZcontractAddress = hash.calculateContractAddressFromHash(\n      publicKey,\n      OZaccountClassHash,\n      OZaccountConstructorCallData,\n      0\n    );\n", "\nexport const createOZAccount = async (context: vscode.ExtensionContext) => {\n  try {\n    const privateKey = stark.randomAddress();\n    const publicKey = await new Signer(privateKey).getPubKey();\n\n    const OZaccountClassHash =\n      \"0x06f3ec04229f8f9663ee7d5bb9d2e06f213ba8c20eb34c58c25a54ef8fc591cb\";\n    const OZaccountConstructorCallData = CallData.compile({\n      publicKey: publicKey,\n    });\n    const OZcontractAddress = hash.calculateContractAddressFromHash(\n      publicKey,\n      OZaccountClassHash,\n      OZaccountConstructorCallData,\n      0\n    );\n", "    if (fs.existsSync(`${context.extensionPath}/accounts.json`)) {\n      const filedata = fs.readFileSync(\n        `${context.extensionPath}/accounts.json`,\n        {\n          encoding: \"utf-8\",\n        }\n      );\n      const parsedFileData = JSON.parse(filedata);\n      const writeNewAccount: Array<JSONAccountType> = [\n        ...parsedFileData,\n        {\n          accountHash: OZaccountClassHash,\n          constructorCallData: OZaccountConstructorCallData,\n          accountPubKey: publicKey,\n          accountAddress: OZcontractAddress,\n          privateKey: privateKey,\n          isDeployed: {\n            gAlpha: false,\n            gAlpha2: false,\n            mainnet: false,\n          },\n        },\n      ];\n      fs.writeFileSync(\n        `${context.extensionPath}/accounts.json`,\n        JSON.stringify(writeNewAccount)\n      );\n    } else {\n      const writeNewAccount: Array<JSONAccountType> = [\n        {\n          accountHash: OZaccountClassHash,\n          constructorCallData: OZaccountConstructorCallData,\n          accountPubKey: publicKey,\n          accountAddress: OZcontractAddress,\n          privateKey: privateKey,\n          isDeployed: {\n            gAlpha: false,\n            gAlpha2: false,\n            mainnet: false,\n          },\n        },\n      ];\n      fs.writeFileSync(\n        `${context.extensionPath}/accounts.json`,\n        JSON.stringify(writeNewAccount)\n      );\n    }\n    logger.log(`New account created: ${OZcontractAddress}`);", "  } catch (error) {\n    logger.error(`Error while creating new account: ${error}`);\n  }\n};\n\nexport const getNotDeployedAccounts = async (context: vscode.ExtensionContext) => {\n  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n  if (selectedNetwork === undefined) {\n    logger.log(\"Network not selected\");\n    return;\n  }", "  if (!fs.existsSync(`${context.extensionPath}/accounts.json`)) {\n    logger.log(\"No account exist.\");\n    return;\n  }\n  const fileData = fs.readFileSync(`${context.extensionPath}/accounts.json`, {\n    encoding: \"utf-8\",\n  });\n  const parsedFileData: Array<JSONAccountType> = JSON.parse(fileData);\n  const accounts: Array<JSONAccountType> | undefined = accountDeployStatus(\n    parsedFileData,\n    selectedNetwork,\n    false\n  );", "  if (accounts === undefined || accounts.length === 0) {\n    logger.log(`No undeployed account available on ${selectedNetwork}`);\n    return;\n  }\n  return accounts;\n};\nexport const selectNotDeployedAccount = async (\n  context: vscode.ExtensionContext\n) => {\n  const accounts: Array<JSONAccountType> | undefined =\n    await getNotDeployedAccounts(context);", "  if (accounts === undefined) return;\n  const quickPick = vscode.window.createQuickPick<IAccountQP>();\n\n  quickPick.items = accounts.map((account: JSONAccountType) => ({\n    label: account.accountAddress,\n  }));\n  quickPick.onDidChangeActive(() => {\n    quickPick.placeholder = \"Select account\";\n  });\n  quickPick.onDidChangeSelection((selection: any) => {\n    if (selection[0] != null) {\n      const { label } = selection[0];\n      void context.workspaceState.update(\"undeployedAccount\", label);\n      logger.log(`${label} selected`);\n      quickPick.dispose();\n    }\n  });\n  quickPick.onDidHide(() => {\n    quickPick.dispose();\n  });\n  quickPick.show();\n};\n\nexport const deployAccount = async (context: vscode.ExtensionContext , accountTreeDataProvider: any) => {\n  const presentAccounts: Array<JSONAccountType> | undefined =\n    await getNotDeployedAccounts(context);\n\n  const unDeployedAccount = await context.workspaceState.get(\n    \"undeployedAccount\"\n  );", "    if (selection[0] != null) {\n      const { label } = selection[0];\n      void context.workspaceState.update(\"undeployedAccount\", label);\n      logger.log(`${label} selected`);\n      quickPick.dispose();\n    }\n  });\n  quickPick.onDidHide(() => {\n    quickPick.dispose();\n  });\n  quickPick.show();\n};\n\nexport const deployAccount = async (context: vscode.ExtensionContext , accountTreeDataProvider: any) => {\n  const presentAccounts: Array<JSONAccountType> | undefined =\n    await getNotDeployedAccounts(context);\n\n  const unDeployedAccount = await context.workspaceState.get(\n    \"undeployedAccount\"\n  );", "  if (presentAccounts === undefined) return;\n  const isAccountPresent: any = presentAccounts.filter(\n    (account) => account.accountAddress === unDeployedAccount\n  );\n  const selectedAccount: JSONAccountType = isAccountPresent[0];\n\n  const selectedNetwork = context.workspaceState.get(\"selectedNetwork\");\n  const provider = getNetworkProvider(context);\n  console.log(`Account address: ${selectedAccount.accountAddress}`);\n  if (provider === undefined) return;\n  const account = new Account(\n    provider,\n    selectedAccount.accountAddress,\n    selectedAccount.privateKey,\n    \"1\"\n  );\n  logger.log(\n    `Deploying account ${selectedAccount.accountAddress} on ${selectedNetwork}`\n  );\n  const { contract_address, transaction_hash } = await account.deployAccount({\n    classHash: selectedAccount.accountHash,\n    constructorCalldata: selectedAccount.constructorCallData,\n    addressSalt: selectedAccount.accountPubKey,\n  });\n\n  logger.log(`Transaction hash: ${transaction_hash}`);\n  await provider.waitForTransaction(transaction_hash);\n  await updateAccountJSON( context, `${context.extensionPath}/accounts.json`, selectedAccount);\n  logger.log(`Account deployed successfully at address: ${contract_address}`);\n  accountTreeDataProvider.refresh();\n\n};\n\nconst updateAccountJSON = async ( context: vscode.ExtensionContext , path: string, selectedAccount:JSONAccountType ) => {\n  const selectedNetwork = context.workspaceState.get(\"selectedNetwork\");\n  fs.readFile(path, 'utf8', (err, data) => {", "  if (provider === undefined) return;\n  const account = new Account(\n    provider,\n    selectedAccount.accountAddress,\n    selectedAccount.privateKey,\n    \"1\"\n  );\n  logger.log(\n    `Deploying account ${selectedAccount.accountAddress} on ${selectedNetwork}`\n  );\n  const { contract_address, transaction_hash } = await account.deployAccount({\n    classHash: selectedAccount.accountHash,\n    constructorCalldata: selectedAccount.constructorCallData,\n    addressSalt: selectedAccount.accountPubKey,\n  });\n\n  logger.log(`Transaction hash: ${transaction_hash}`);\n  await provider.waitForTransaction(transaction_hash);\n  await updateAccountJSON( context, `${context.extensionPath}/accounts.json`, selectedAccount);\n  logger.log(`Account deployed successfully at address: ${contract_address}`);\n  accountTreeDataProvider.refresh();\n\n};\n\nconst updateAccountJSON = async ( context: vscode.ExtensionContext , path: string, selectedAccount:JSONAccountType ) => {\n  const selectedNetwork = context.workspaceState.get(\"selectedNetwork\");\n  fs.readFile(path, 'utf8', (err, data) => {", "    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n  \n    const accounts = JSON.parse(data);\n  \n    const indexToUpdate = accounts.findIndex((account: { accountAddress: string; }) => account.accountAddress === selectedAccount.accountAddress);\n  \n    if (indexToUpdate !== -1) {\n      accounts[indexToUpdate].isDeployed = {\n        gAlpha: selectedNetwork === NETWORKS[0] ? true : false,\n        gAlpha2: selectedNetwork === NETWORKS[1] ? true : false,\n        mainnet: selectedNetwork === NETWORKS[2] ? true : false,\n      };\n  \n      fs.writeFile(path, JSON.stringify(accounts, null, 2), 'utf8', (err) => {", "    if (indexToUpdate !== -1) {\n      accounts[indexToUpdate].isDeployed = {\n        gAlpha: selectedNetwork === NETWORKS[0] ? true : false,\n        gAlpha2: selectedNetwork === NETWORKS[1] ? true : false,\n        mainnet: selectedNetwork === NETWORKS[2] ? true : false,\n      };\n  \n      fs.writeFile(path, JSON.stringify(accounts, null, 2), 'utf8', (err) => {\n        if (err) {\n          console.error('Error writing file:', err);\n          return;\n        }\n        console.log('JSON file successfully updated.');\n      });\n    } else {\n      console.error('Element not found in JSON file.');\n    }\n  });\n};\n\nexport const getDeployedAccounts = (context: vscode.ExtensionContext) => {\n  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");", "        if (err) {\n          console.error('Error writing file:', err);\n          return;\n        }\n        console.log('JSON file successfully updated.');\n      });\n    } else {\n      console.error('Element not found in JSON file.');\n    }\n  });\n};\n\nexport const getDeployedAccounts = (context: vscode.ExtensionContext) => {\n  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");", "  if (selectedNetwork === undefined){\n    // logger.log(\"Network not selected\");\n    return;\n  }\n  if (!fs.existsSync(`${context.extensionPath}/accounts.json`)) {\n    logger.log(\"No deployed account exist.\");\n    return;\n  }\n  const fileData = fs.readFileSync(`${context.extensionPath}/accounts.json`, {\n    encoding: \"utf-8\",\n  });\n  const parsedFileData: Array<JSONAccountType> = JSON.parse(fileData);\n  const accounts: Array<JSONAccountType> | undefined = accountDeployStatus(\n    parsedFileData,\n    selectedNetwork,\n    true\n  );", "  if (accounts === undefined || accounts.length === 0) {\n    logger.log(`No deployed account available on ${selectedNetwork}`);\n    return;\n  }\n  return accounts;\n};\n\nexport const deleteAccount = async (context: vscode.ExtensionContext,node: any) => {\n  const fileData = fs.readFileSync(`${context.extensionPath}/accounts.json`, {\n    encoding: \"utf-8\",\n  });\n  const parsedFileData: Array<JSONAccountType> = JSON.parse(fileData);\n  const filteredData = parsedFileData.filter(obj => obj.accountAddress !== node.account.accountAddress);\n  fs.writeFileSync(`${context.extensionPath}/accounts.json`, JSON.stringify(filteredData, null, 2));\n};\n\nexport const selectDeployedAccount = async (\n  context: vscode.ExtensionContext\n) => {\n  const accounts: Array<JSONAccountType> | undefined =\n    await getDeployedAccounts(context);", "  if (accounts === undefined) return;\n  const quickPick = vscode.window.createQuickPick<IAccountQP>();\n\n  quickPick.items = accounts.map((account: JSONAccountType) => ({\n    label: account.accountAddress,\n  }));\n  quickPick.onDidChangeActive(() => {\n    quickPick.placeholder = \"Select account\";\n  });\n  quickPick.onDidChangeSelection((selection: any) => {\n    if (selection[0] != null) {\n      const { label } = selection[0];\n      void context.workspaceState.update(\"account\", label);\n      logger.log(`${label} selected`);\n      quickPick.dispose();\n    }\n  });\n  quickPick.onDidHide(() => {\n    quickPick.dispose();\n  });\n  quickPick.show();\n};\n\nexport const getAccountInfo = (\n  context: vscode.ExtensionContext,\n  accountAddress: string\n) => {\n  const accounts = getDeployedAccounts(context) as JSONAccountType[];\n  const selectedAccountInfo = accounts.filter(\n    (account) => account.accountAddress === accountAddress\n  );\n  return selectedAccountInfo[0];\n};\n", "    if (selection[0] != null) {\n      const { label } = selection[0];\n      void context.workspaceState.update(\"account\", label);\n      logger.log(`${label} selected`);\n      quickPick.dispose();\n    }\n  });\n  quickPick.onDidHide(() => {\n    quickPick.dispose();\n  });\n  quickPick.show();\n};\n\nexport const getAccountInfo = (\n  context: vscode.ExtensionContext,\n  accountAddress: string\n) => {\n  const accounts = getDeployedAccounts(context) as JSONAccountType[];\n  const selectedAccountInfo = accounts.filter(\n    (account) => account.accountAddress === accountAddress\n  );\n  return selectedAccountInfo[0];\n};\n"]}
{"filename": "src/config/contract.ts", "chunked_list": ["import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport path, { resolve } from \"path\";\nimport { logger } from \"../lib\";\nimport { ABIFragment, IContractQP, IFunctionQP } from \"../types\";\nimport { createABIFile, createAddressFile } from \"../utils/functions\";\nimport { getAccountInfo } from \"./account\";\nimport { Account, CairoAssembly, Contract, ec, Provider } from \"starknet\";\nimport { getNetworkProvider } from \"./network\";\n", "import { getNetworkProvider } from \"./network\";\n\nexport const loadAllCompiledContract = () => {\n  if (vscode.workspace.workspaceFolders === undefined) {\n    logger.error(\"Error: Please open your solidity project to vscode\");\n    return;\n  }\n  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n  const compiledCairoContract = fs\n    .readdirSync(path_)\n    .filter((file) => exportPathOfJSONfiles(path_, file));\n\n  return compiledCairoContract;\n};\n\nconst exportPathOfJSONfiles = (path_: string, file: string) => {\n  const filePath = path.join(path_, file);", "  if (path.extname(filePath) === \".json\") {\n    const fileData = fs.readFileSync(filePath, {\n      encoding: \"utf-8\",\n    });\n    if (JSON.parse(fileData).program) return filePath;\n    if (JSON.parse(fileData).contract_class_version) {\n      return filePath;\n    }\n  }\n};\n\nexport const setContract = async (context: vscode.ExtensionContext, label: string) => {", "  if (label === undefined) {\n    // logger.log(\"No Contract selected.\");\n    return;\n  }\n  void context.workspaceState.update(\"selectedContract\", `${label}.json`);\n  logger.log(`${label} contract selected`);\n  createABIFile(`${label}.json`);\n  createAddressFile(`${label}.json`);\n};\n\nexport const selectCompiledContract = (context: vscode.ExtensionContext) => {\n  const contracts = loadAllCompiledContract();", "  if (contracts === undefined) {\n    logger.log(\"No Contract available.\");\n    return;\n  }\n  const quickPick = vscode.window.createQuickPick<IContractQP>();\n\n  quickPick.items = contracts.map((contract: string) => ({\n    label: contract.substring(0, contract.length - 5),\n  }));\n  quickPick.onDidChangeActive(() => {\n    quickPick.placeholder = \"Select Contract\";\n  });\n  quickPick.onDidChangeSelection((selection: any) => {", "    if (selection[0] != null) {\n      const { label } = selection[0];\n      setContract(context, label);\n      quickPick.dispose();\n    }\n  });\n  quickPick.onDidHide(() => {\n    quickPick.dispose();\n  });\n  quickPick.show();\n};\n\nexport const getContractInfo = (path_: string, fileName: string) => {", "  try {\n    const file = fileName.substring(0, fileName.length - 5);\n    const fileData = fs.readFileSync(\n      path.join(path_, \"starkode\", file, `${file}_address.json`),\n      { encoding: \"utf-8\" }\n    );\n    const parsedFileData = JSON.parse(fileData);\n    return parsedFileData;\n  } catch (error) {\n    // console.log(error);\n    return undefined;\n  }\n};\n\nexport const getContractABI = (path_: string, fileName: string) => {", "  } catch (error) {\n    // console.log(error);\n    return undefined;\n  }\n};\n\nexport const getContractABI = (path_: string, fileName: string) => {\n  try {\n    const file = fileName.substring(0, fileName.length - 5);\n    const fileData = fs.readFileSync(\n      path.join(path_, \"starkode\", file, `${file}_abi.json`),\n      { encoding: \"utf-8\" }\n    );\n    const parsedFileData = JSON.parse(fileData);\n    return parsedFileData;", "  } catch (error) {\n    // console.log(error);\n    return undefined;\n  }\n};\n\nexport const isCairo1Contract = (fileName: string): boolean => {\n  if (vscode.workspace.workspaceFolders === undefined) {\n    logger.error(\"Error: Please open your solidity project to vscode\");\n    return false;\n  }\n  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n  const fileData = fs.readFileSync(\n    path.join(path_, fileName),\n    { encoding: \"utf-8\" }\n  );\n  return JSON.parse(fileData).contract_class_version === \"0.1.0\" ? true : false;\n};\n\nexport const declareContract = async (context: vscode.ExtensionContext) => {", "  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const provider = getNetworkProvider(context) as Provider;\n    const selectedContract: string = context.workspaceState.get(\n      \"selectedContract\"\n    ) as string;\n    const selectedAccount = context.workspaceState.get(\"account\") as string;", "    if (selectedAccount === undefined) {\n      logger.log(\"No account selected.\");\n      return;\n    }\n    const accountInfo = getAccountInfo(context, selectedAccount);\n\n    const account = new Account(\n      provider,\n      accountInfo.accountAddress,\n      accountInfo.privateKey,\n      \"0\"\n    );\n    const fileName = selectedContract.substring(0, selectedContract.length - 5);\n", "    if (\n      !fs.existsSync(path.join(path_, selectedContract)) ||\n      !fs.existsSync(path.join(path_, `${fileName}.casm`))\n    ) {\n      logger.log(`${fileName}.json or ${fileName}.casm must be present.`);\n      return;\n    }\n\n    const compiledContract = fs.readFileSync(\n      path.join(path_, selectedContract),\n      {\n        encoding: \"ascii\",\n      }\n    );\n\n    const casmFileData = fs\n      .readFileSync(path.join(path_, `${fileName}.casm`))\n      .toString(\"ascii\");\n\n    const casmAssembly: CairoAssembly = JSON.parse(casmFileData);\n\n    logger.log(\"Declaring contract...\");\n\n    const declareResponse = await account.declareAndDeploy({\n      contract: compiledContract,\n      casm: casmAssembly,\n    });\n\n    logger.log(\n      `declare transaction hash: ${declareResponse.deploy.transaction_hash}`\n    );\n\n    logger.log(`declare classHash: ${declareResponse.deploy.classHash}`);\n\n    logger.log(\"transaction successful\");", "  } catch (error) {\n    logger.log(`Error while contract declaration: ${error}`);\n  }\n};\n\nexport const deployContract = async (context: vscode.ExtensionContext) => {\n  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const provider = getNetworkProvider(context) as Provider;\n    const selectedContract: string = context.workspaceState.get(\n      \"selectedContract\"\n    ) as string;\n    const selectedAccount = context.workspaceState.get(\"account\") as string;", "    if (selectedAccount === undefined) {\n      logger.log(\"No account selected.\");\n      return;\n    }\n    const accountInfo = getAccountInfo(context, selectedAccount);\n    logger.log(\"Deploying contract...\");\n    const account = new Account(\n      provider,\n      accountInfo.accountAddress,\n      accountInfo.privateKey,\n      \"0\"\n    );\n    const contractInfo = getContractInfo(path_, selectedContract);", "    if (contractInfo.classHash === \"\") {\n      logger.log(\"No classHash available for selected contract.\");\n      return;\n    }\n    const deployResponse = await account.deployContract({\n      classHash: contractInfo.classHash,\n    });\n\n    logger.log(`transaction hash: ${deployResponse.transaction_hash}`);\n\n    logger.log(\"waiting for transaction success...\");\n\n    await provider.waitForTransaction(deployResponse.transaction_hash);\n\n    const { abi: testAbi } = await provider.getClassAt(\n      deployResponse.contract_address\n    );", "    if (testAbi === undefined) {\n      throw new Error(\"no abi.\");\n    }\n    const myTestContract = new Contract(\n      testAbi,\n      deployResponse.contract_address,\n      provider\n    );\n\n    await provider.waitForTransaction(myTestContract.transaction_hash);\n    logger.log(`contract deployed successfully: ${myTestContract.address}`);", "  } catch (error) {\n    logger.log(`Error while contract deployment: ${error}`);\n  }\n};\n\nexport const executeContractFunction = async (\n  context: vscode.ExtensionContext\n) => {\n  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const provider = getNetworkProvider(context) as Provider;\n    const selectedContract: string = context.workspaceState.get(\n      \"selectedContract\"\n    ) as string;\n    const selectedAccount = context.workspaceState.get(\"account\") as string;", "  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const provider = getNetworkProvider(context) as Provider;\n    const selectedContract: string = context.workspaceState.get(\n      \"selectedContract\"\n    ) as string;\n    const selectedAccount = context.workspaceState.get(\"account\") as string;", "    if (selectedAccount === undefined) {\n      logger.log(\"No account selected.\");\n      return;\n    }\n    const accountInfo = getAccountInfo(context, selectedAccount);\n    const functionABI = await getSelectedFunction(path_, selectedContract);\n    const contractInfo = getContractInfo(path_, selectedContract);\n\n    const params_: Array<any> = functionABI.inputs.map((e) => {\n      return e.value;\n    });\n\n    const params: Array<any> = params_ !== undefined ? params_ : [];\n", "    if (\n      functionABI.stateMutability === \"view\" ||\n      functionABI.state_mutability === \"view\"\n    ) {\n      const Abi = getContractABI(path_, selectedContract).abi;\n      const contract = new Contract(Abi, contractInfo.address, provider);\n      logger.log(`calling function: ${functionABI.name}`);\n      const functionCall: any = await contract.call(`${functionABI.name}`);\n      logger.log(`result: ${functionCall.res.toString()}`);\n    } else {\n      const Abi = getContractABI(path_, selectedContract).abi;\n\n      logger.log(`calling function: ${functionABI.name}`);\n\n      const account = new Account(\n        provider,\n        accountInfo.accountAddress,\n        accountInfo.privateKey,\n        \"0\"\n      );\n      const contract = new Contract(Abi, contractInfo.address, provider);\n      contract.connect(account);\n      const result = await contract.invoke(functionABI.name, params);\n\n      logger.log(`transaction hash: ${result.transaction_hash}`);\n\n      logger.log(\"waiting for transaction success...\");\n\n      await provider.waitForTransaction(result.transaction_hash);\n\n      logger.log(\"transaction successfull\");\n    }", "  } catch (error) {\n    logger.log(error);\n  }\n};\n\nexport const executeContractFunctionFromTreeView = async (\n  context: vscode.ExtensionContext,\n  functionabi: ABIFragment\n) => {\n  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const provider = getNetworkProvider(context) as Provider;\n    const selectedContract: string = context.workspaceState.get(\n      \"selectedContract\"\n    ) as string;\n    const selectedAccount = context.workspaceState.get(\"account\") as string;", "  try {\n    if (vscode.workspace.workspaceFolders === undefined) {\n      logger.error(\"Error: Please open your solidity project to vscode\");\n      return;\n    }\n    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const provider = getNetworkProvider(context) as Provider;\n    const selectedContract: string = context.workspaceState.get(\n      \"selectedContract\"\n    ) as string;\n    const selectedAccount = context.workspaceState.get(\"account\") as string;", "    if (selectedAccount === undefined) {\n      logger.log(\"No account selected.\");\n      return;\n    }\n    const accountInfo = getAccountInfo(context, selectedAccount);\n    const functionABI = functionabi;\n    const contractInfo = getContractInfo(path_, selectedContract);\n\n    const params_: Array<any> = functionABI.inputs.map((e) => {\n      return e.value;\n    });\n\n    const params: Array<any> = params_ !== undefined ? params_ : [];\n", "    if (\n      functionABI.stateMutability === \"view\" ||\n      functionABI.state_mutability === \"view\"\n    ) {\n      const Abi = getContractABI(path_, selectedContract).abi;\n      const contract = new Contract(Abi, contractInfo.address, provider);\n      logger.log(`calling function: ${functionABI.name}`);\n      const functionCall: any = await contract.call(`${functionABI.name}`);\n      logger.log(`result: ${functionCall.res.toString()}`);\n    } else {\n      const Abi = getContractABI(path_, selectedContract).abi;\n\n      logger.log(`calling function: ${functionABI.name}`);\n\n      const account = new Account(\n        provider,\n        accountInfo.accountAddress,\n        accountInfo.privateKey,\n        \"0\"\n      );\n      const contract = new Contract(Abi, contractInfo.address, provider);\n      contract.connect(account);\n      const result = await contract.invoke(functionABI.name, params);\n\n      logger.log(`transaction hash: ${result.transaction_hash}`);\n\n      logger.log(\"waiting for transaction success...\");\n\n      await provider.waitForTransaction(result.transaction_hash);\n\n      logger.log(\"transaction successfull\");\n    }", "  } catch (error) {\n    logger.log(error);\n  }\n};\n\nconst getSelectedFunction = (\n  path_: string,\n  selectedContract: string\n): Promise<ABIFragment> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const contractInfo: Array<ABIFragment> = getContractABI(\n        path_,\n        selectedContract\n      ).abi;\n", "    try {\n      const contractInfo: Array<ABIFragment> = getContractABI(\n        path_,\n        selectedContract\n      ).abi;\n\n      if (contractInfo === undefined) return;\n      const quickPick = vscode.window.createQuickPick<IFunctionQP>();\n\n      quickPick.items = contractInfo.map((account: ABIFragment) => ({\n        label: account.name,\n      }));\n      quickPick.onDidChangeActive(() => {\n        quickPick.placeholder = \"Select Function\";\n      });\n      quickPick.onDidChangeSelection((selection: any) => {", "        if (selection[0] != null) {\n          const { label } = selection[0];\n          quickPick.dispose();\n          const functionItem = contractInfo.filter(\n            (i: ABIFragment) => i.name === label\n          );\n          if (functionItem.length === 0)\n            throw new Error(\"No function is selected\");\n          resolve(functionItem[0]);\n        }\n      });\n      quickPick.onDidHide(() => {\n        quickPick.dispose();\n      });\n      quickPick.show();", "    } catch (error) {\n      reject(error);\n    }\n  });\n};\n"]}
{"filename": "src/lib/logger.ts", "chunked_list": ["import { window, OutputChannel } from \"vscode\";\n\nconst successToast = (msg: string) => {\n  window.showInformationMessage(msg, \"Dismiss\");\n};\n\nconst warningToast = (msg: string) => {\n  window.showWarningMessage(msg, \"Dismiss\");\n};\nconst errorToast = (msg: string) => {", "};\nconst errorToast = (msg: string) => {\n  window.showErrorMessage(msg, \"Dismiss\");\n};\n\nconst actionToast = (msg: string, actionName: string) => {\n  return window.showInformationMessage(msg, actionName, \"Dismiss\");\n};\n\nexport class Logger {\n  private outputChannel: OutputChannel;\n\n  constructor(name?: string) {\n    this.outputChannel = window.createOutputChannel(name || \"Starkode\");\n  }\n\n  private getNow = (): string => {\n    const date = new Date(Date.now());\n    return date.toLocaleTimeString();\n  };\n\n  public log(...m: Array<any>) {\n    const now = this.getNow();\n    this.outputChannel.appendLine(`[${now}]: ${m}`);\n    this.outputChannel.show();\n  }\n\n  public error(e: any) {\n    const now = this.getNow();\n    this.outputChannel.appendLine(`[${now}] Error: ${e.message}`);\n    this.outputChannel.appendLine(`[${now}] stack: ${e.stack}`);\n    this.outputChannel.show();\n    errorToast(`Error: ${e.message}`);\n  }\n\n  public success(m: string) {\n    const now = this.getNow();\n    this.outputChannel.appendLine(`[${now}]: ${m}`);\n    this.outputChannel.show();\n    successToast(m);\n  }\n}\n", "\nexport class Logger {\n  private outputChannel: OutputChannel;\n\n  constructor(name?: string) {\n    this.outputChannel = window.createOutputChannel(name || \"Starkode\");\n  }\n\n  private getNow = (): string => {\n    const date = new Date(Date.now());\n    return date.toLocaleTimeString();\n  };\n\n  public log(...m: Array<any>) {\n    const now = this.getNow();\n    this.outputChannel.appendLine(`[${now}]: ${m}`);\n    this.outputChannel.show();\n  }\n\n  public error(e: any) {\n    const now = this.getNow();\n    this.outputChannel.appendLine(`[${now}] Error: ${e.message}`);\n    this.outputChannel.appendLine(`[${now}] stack: ${e.stack}`);\n    this.outputChannel.show();\n    errorToast(`Error: ${e.message}`);\n  }\n\n  public success(m: string) {\n    const now = this.getNow();\n    this.outputChannel.appendLine(`[${now}]: ${m}`);\n    this.outputChannel.show();\n    successToast(m);\n  }\n}\n"]}
{"filename": "src/lib/index.ts", "chunked_list": ["import { Logger } from \"./logger\";\n\nexport const logger = new Logger();"]}
{"filename": "src/types/index.ts", "chunked_list": ["import { Calldata } from \"starknet\";\nimport { QuickPickItem } from \"vscode\";\n\nexport interface INetworkQP extends QuickPickItem {\n  label: string;\n}\n\nexport interface TIsAccountDeployed {\n  gAlpha: boolean;\n  gAlpha2: boolean;\n  mainnet: boolean;\n}", "export interface JSONAccountType {\n  accountHash: string;\n  constructorCallData: Calldata;\n  accountPubKey: string;\n  accountAddress: string;\n  privateKey: string;\n  isDeployed: TIsAccountDeployed;\n}\n\nexport interface IAccountQP extends QuickPickItem {\n  label: string;\n}\n", "export interface IAccountQP extends QuickPickItem {\n  label: string;\n}\n\nexport interface IContractQP extends QuickPickItem {\n  label: string;\n}\n\nexport interface IFunctionQP extends QuickPickItem {\n  label: string;\n}\n", "export interface IFunctionQP extends QuickPickItem {\n  label: string;\n}\n\ninterface inputType {\n  name: string;\n  type: string;\n  value: string;\n}\ninterface outputType {\n  name: string;\n  type: string;\n}", "interface outputType {\n  name: string;\n  type: string;\n}\nexport interface ABIFragment {\n  inputs: Array<inputType>;\n  name: string;\n  stateMutability: string;\n  type: string;\n  outputs: Array<outputType>;\n  state_mutability?: string;\n}\n"]}
