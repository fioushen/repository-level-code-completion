{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from './../src/app.module';\n\ndescribe('AppController (e2e)', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({", "  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.setGlobalPrefix('v1');\n    await app.init();\n  });\n", "  });\n\n  afterEach(async () => {\n    await app.close(); // close the app instance after each test\n  });\n\n  it('/v1 (GET)', async () => {\n    return await request(app.getHttpServer()).get('/v1').expect(404);\n  });\n});", "  });\n});\n"]}
{"filename": "test/developers.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication, ValidationPipe } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from '../src/app.module';\n\ndescribe('DeveloperController (e2e)', () => {\n  let app: INestApplication;\n  const headers = {\n    'Content-Type': 'application/json',\n  };", "    'Content-Type': 'application/json',\n  };\n  let id: string;\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();", "\n    app = moduleFixture.createNestApplication();\n    app.setGlobalPrefix('v1');\n    app.useGlobalPipes(new ValidationPipe());\n    await app.init();\n  });\n\n  afterEach(async () => {\n    await app.close();\n  });", "    await app.close();\n  });\n\n  // create a developer\n  describe('POST /v1/developers', () => {\n    it('should create a new developer with valid request', async () => {\n      const response = await request(app.getHttpServer())\n        .post(`/v1/developers`)\n        .set(headers)\n        .send({", "        .set(headers)\n        .send({\n          name: 'Olha Gaievska',\n          email: 'tester@mail.com',\n          level: 'senior',\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body).toBeInstanceOf(Object);\n      expect(response.body._id).toBeDefined();", "      expect(response.body).toBeInstanceOf(Object);\n      expect(response.body._id).toBeDefined();\n      id = response.body._id;\n    });\n\n    it('should return failed with invalid request to create developer', async () => {\n      const response = await request(app.getHttpServer())\n        .post(`/v1/developers`)\n        .set(headers)\n        .send({", "        .set(headers)\n        .send({\n          name: '',\n          email: '',\n          level: 'backend',\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body).toBeInstanceOf(Object);\n      expect(response.body).toEqual({", "      expect(response.body).toBeInstanceOf(Object);\n      expect(response.body).toEqual({\n        statusCode: 400,\n        message: [\n          'name must be longer than or equal to 3 characters',\n          'email should not be empty',\n          'email must be an email',\n          'level must be one of the following values: junior, senior',\n        ],\n        error: 'Bad Request',", "        ],\n        error: 'Bad Request',\n      });\n    });\n  });\n\n  // return all developers\n  describe('GET /v1/developers', () => {\n    it('should return all the developers with valid request', async () => {\n      const response = await request(app.getHttpServer())", "    it('should return all the developers with valid request', async () => {\n      const response = await request(app.getHttpServer())\n        .get(`/v1/developers`)\n        .set(headers)\n        .send();\n\n      expect(response.status).toBe(200);\n      expect(response.body).toBeInstanceOf(Array);\n    });\n  });", "    });\n  });\n\n  // return a specific developer\n  describe('GET /v1/developers/{id}', () => {\n    it('should return the specific developer with valid id', async () => {\n      const response = await request(app.getHttpServer())\n        .get(`/v1/developers/${id}`)\n        .set(headers)\n        .send();", "        .set(headers)\n        .send();\n\n      expect(response.status).toBe(200);\n      expect(response.body).toBeInstanceOf(Object);\n      expect(response.body._id).toBeDefined();\n      expect(response.body.name).toBeDefined();\n      expect(response.body.email).toBeDefined();\n      expect(response.body.level).toBeDefined();\n    });", "      expect(response.body.level).toBeDefined();\n    });\n\n    it('should return failed for the wrong developer id', async () => {\n      const response = await request(app.getHttpServer())\n        .get(`/v1/developers/${id}e404`)\n        .set(headers)\n        .send();\n\n      expect(response.status).toBe(404);", "\n      expect(response.status).toBe(404);\n      expect(response.body.error).toEqual('Not Found');\n      expect(response.body.message).toEqual('developer not found!');\n    });\n  });\n\n  // filter by level\n  describe('POST /v1/developers/filter', () => {\n    it('should return the filtered developers by level', async () => {", "  describe('POST /v1/developers/filter', () => {\n    it('should return the filtered developers by level', async () => {\n      const response = await request(app.getHttpServer())\n        .post(`/v1/developers/filter`)\n        .set(headers)\n        .send({ level: 'senior' });\n\n      expect(response.status).toBe(201);\n      expect(response.body).toBeInstanceOf(Array);\n    });", "      expect(response.body).toBeInstanceOf(Array);\n    });\n  });\n\n  // edit a developer\n  describe('PUT /v1/developers/{id}', () => {\n    it('should update the developer information with valid request', async () => {\n      const response = await request(app.getHttpServer())\n        .put(`/v1/developers/${id}`)\n        .set(headers)", "        .put(`/v1/developers/${id}`)\n        .set(headers)\n        .send({ email: 'olhag@mail.com', level: 'junior' });\n\n      expect(response.status).toBe(200);\n      expect(response.body).toBeInstanceOf(Object);\n    });\n\n    it('should return failed to update for a wrong developer id', async () => {\n      const response = await request(app.getHttpServer())", "    it('should return failed to update for a wrong developer id', async () => {\n      const response = await request(app.getHttpServer())\n        .put(`/v1/developers/${id}e404`)\n        .set(headers)\n        .send({ email: 'olhag@mail.com', level: 'junior' });\n\n      expect(response.status).toBe(404);\n      expect(response.body.error).toEqual('Not Found');\n    });\n", "    });\n\n    it('should return failed with invalid request to update developer', async () => {\n      const response = await request(app.getHttpServer())\n        .put(`/v1/developers/${id}`)\n        .set(headers)\n        .send({ level: 'lead' });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toEqual('Bad Request');", "      expect(response.status).toBe(400);\n      expect(response.body.error).toEqual('Bad Request');\n      expect(response.body.message[0]).toEqual(\n        'level must be one of the following values: junior, senior',\n      );\n    });\n  });\n\n  // delete a developer\n  describe('DELETE /v1/developers/{id}', () => {", "  // delete a developer\n  describe('DELETE /v1/developers/{id}', () => {\n    it('should delete successfully the developer with valid id', async () => {\n      const response = await request(app.getHttpServer())\n        .delete(`/v1/developers/${id}`)\n        .set(headers)\n        .send();\n\n      expect(response.status).toBe(200);\n      expect(response.body.message).toEqual('The data has been deleted successfully');", "      expect(response.status).toBe(200);\n      expect(response.body.message).toEqual('The data has been deleted successfully');\n    });\n\n    it('should return failed to delete for a wrong developer id', async () => {\n      const response = await request(app.getHttpServer())\n        .delete(`/v1/developers/${id}`)\n        .set(headers)\n        .send();\n", "        .send();\n\n      expect(response.status).toBe(404);\n      expect(response.body.error).toEqual('Not Found');\n      expect(response.body.message).toEqual('failed to delete developer!');\n    });\n  });\n});\n", ""]}
{"filename": "src/main.ts", "chunked_list": ["import { NestFactory } from '@nestjs/core';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { ValidationPipe } from '@nestjs/common';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.setGlobalPrefix('v1');\n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true,\n    }),\n  );\n\n  // port initialize\n  const port = process.env.PORT || 3000;\n  await app.listen(port, () => {\n    console.log(`Listening on port ${port}!`);\n  });\n}\nbootstrap();\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { CacheInterceptor, CacheModule, CacheStore } from '@nestjs/cache-manager';\nimport { DeveloperModule } from './developer/developer.module';\nimport { APP_INTERCEPTOR } from '@nestjs/core';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { redisStore } from 'cache-manager-redis-store';\nimport type { RedisClientOptions } from 'redis';\n\n@Module({", "\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n\n    ...(process.env.NODE_ENV !== 'development'\n      ? [\n          MongooseModule.forRootAsync({\n            imports: [ConfigModule],\n            inject: [ConfigService],", "            imports: [ConfigModule],\n            inject: [ConfigService],\n            useFactory: async (config: ConfigService) => ({\n              uri: config.get<string>('MONGODB_URI', 'mongodb://localhost:27017/test'),\n            }),\n          }),\n        ]\n      : []),\n\n    CacheModule.registerAsync<RedisClientOptions>({", "\n    CacheModule.registerAsync<RedisClientOptions>({\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: async (config: ConfigService) => {\n        const options = {\n          store: redisStore as unknown as CacheStore,\n          url: config.get<string>('REDIS_URL', 'redis://localhost:6379'),\n          ttl: config.get<number>('CACHE_TTL', 180), // 3 * 60 = 3 minutes\n        };", "          ttl: config.get<number>('CACHE_TTL', 180), // 3 * 60 = 3 minutes\n        };\n        // set a different TTL for development environment\n        if (config.get<string>('NODE_ENV') === 'development') {\n          options.ttl = 1800; // 30 minutes\n        }\n        return options;\n      },\n      isGlobal: true,\n    }),\n\n    DeveloperModule,\n  ],\n\n  providers: [\n    {\n      provide: APP_INTERCEPTOR,\n      useFactory: () => {", "        if (process.env.NODE_ENV === 'development') {\n          return null;\n        }\n        return CacheInterceptor;\n      },\n    },\n  ],\n})\nexport class AppModule {}\n", "export class AppModule {}\n"]}
{"filename": "src/developer/in-memory-developer.service.ts", "chunked_list": ["import { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Cache } from 'cache-manager';\nimport {\n  HttpException,\n  HttpStatus,\n  Inject,\n  Injectable,\n  NotFoundException,\n} from '@nestjs/common';\n", "} from '@nestjs/common';\n\nimport { DeveloperDTO, PartialDeveloperDTO } from './dto';\nimport { randomUUID } from 'crypto';\nimport { IDeveloperService, IDeveloper } from 'src/core/interfaces/IDeveloperService';\n\n@Injectable()\nexport class InMemoryDeveloperService implements IDeveloperService {\n  private key = 'developers';\n  constructor(@Inject(CACHE_MANAGER) private readonly cacheManager: Cache) {}\n\n  async create(dto: DeveloperDTO): Promise<object> {\n    const data: IDeveloper = {\n      _id: this.uuid(),\n      name: dto.name,\n      email: dto.email,\n      level: dto.level,\n    };\n\n    const cached = await this.cacheManager.get(this.key);", "    if (cached) {\n      const jsonArray = JSON.parse(cached as unknown as string);\n      jsonArray.push(data);\n      await this.cacheManager.del(this.key);\n      await this.cacheManager.set(this.key, JSON.stringify(jsonArray), 0);\n      return data;\n    }\n\n    const developers = [];\n    developers.push(data);\n    await this.cacheManager.set(this.key, JSON.stringify(developers), 0);\n    return data;\n  }\n\n  async readBatch(): Promise<object[]> {\n    const cached = await this.cacheManager.get(this.key);\n    return JSON.parse(cached as unknown as string);\n  }\n\n  async read(id: string): Promise<object> {\n    const cached = await this.cacheManager.get(this.key);\n", "    if (cached) {\n      const developers = JSON.parse(cached as unknown as string);\n\n      const developer = developers.find(\n        (developer: { _id: string }) => developer._id === id,\n      );\n\n      if (!developer) throw new NotFoundException(`developer not found!`);\n\n      return developer;\n    }\n\n    throw new NotFoundException(`developer not found!`);\n  }\n\n  async filterByLevel(dto: PartialDeveloperDTO): Promise<object[]> {\n    const cached = await this.cacheManager.get(this.key);\n    const developers = JSON.parse(cached as unknown as string);\n\n    return developers.filter(\n      (developer: { level: string }) => developer.level === dto.level,\n    );\n  }\n\n  async update(id: string, dto: PartialDeveloperDTO): Promise<object> {\n    const cached = await this.cacheManager.get(this.key);\n    const developers = JSON.parse(cached as unknown as string);\n\n    const index = developers.findIndex(\n      (developer: { _id: { toString: () => string } }) => developer._id.toString() === id,\n    );\n", "    if (index < 0) throw new NotFoundException(`failed to update developer!`);\n\n    const updated = Object.assign(developers[index], dto);\n    developers[index] = updated;\n\n    await this.cacheManager.del(this.key);\n    await this.cacheManager.set(this.key, JSON.stringify(developers), 0);\n    return updated;\n  }\n\n  async delete(id: string): Promise<HttpException> {\n    const cached = await this.cacheManager.get(this.key);\n    const developers = JSON.parse(cached as unknown as string);\n\n    const index = developers.findIndex((developer) => developer._id === id);", "    if (index === -1) throw new NotFoundException(`failed to delete developer!`);\n\n    developers.splice(index, 1);\n    await this.cacheManager.del(this.key);\n    await this.cacheManager.set(this.key, JSON.stringify(developers), 0);\n\n    throw new HttpException('The data has been deleted successfully', HttpStatus.OK);\n  }\n\n  private uuid(): string {\n    return randomUUID();\n  }\n}\n"]}
{"filename": "src/developer/developer.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { DeveloperController } from './developer.controller';\nimport { DeveloperService } from './developer.service';\nimport { Developer, DeveloperSchema } from './schemas/developer.schema';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { InMemoryDeveloperService } from './in-memory-developer.service';\n\n@Module({\n  imports: [\n    ...(process.env.NODE_ENV !== 'development'", "  imports: [\n    ...(process.env.NODE_ENV !== 'development'\n      ? [MongooseModule.forFeature([{ name: Developer.name, schema: DeveloperSchema }])]\n      : []),\n  ],\n\n  controllers: [DeveloperController],\n  providers: [\n    ...(process.env.NODE_ENV !== 'development'\n      ? [DeveloperService]", "    ...(process.env.NODE_ENV !== 'development'\n      ? [DeveloperService]\n      : [InMemoryDeveloperService]),\n  ],\n})\nexport class DeveloperModule {}\n"]}
{"filename": "src/developer/developer.controller.ts", "chunked_list": ["import { Body, Controller, Inject, Param, Get, Post, Put, Delete } from '@nestjs/common';\nimport { DeveloperDTO, PartialDeveloperDTO } from './dto';\nimport { DeveloperService } from './developer.service';\nimport { InMemoryDeveloperService } from './in-memory-developer.service';\n\n@Controller('developers')\nexport class DeveloperController {\n  constructor(\n    @Inject(\n      process.env.NODE_ENV === 'development'\n        ? InMemoryDeveloperService\n        : DeveloperService,\n    )\n    private readonly developerService: DeveloperService,\n  ) {}\n\n  @Post()\n  postDeveloper(@Body() dto: DeveloperDTO): object {\n    return this.developerService.create(dto);\n  }\n\n  @Post('filter')\n  filterDevelopersByLevel(@Body() dto: PartialDeveloperDTO): object {\n    return this.developerService.filterByLevel(dto);\n  }\n\n  @Get()\n  getDevelopers(): object {\n    return this.developerService.readBatch();\n  }\n\n  @Get(':id')\n  getDeveloper(@Param('id') id: string): object {\n    return this.developerService.read(id);\n  }\n\n  @Put(':id')\n  putDeveloper(@Param('id') id: string, @Body() dto: PartialDeveloperDTO): object {\n    return this.developerService.update(id, dto);\n  }\n\n  @Delete(':id')\n  deleteDeveloper(@Param('id') id: string): object {\n    return this.developerService.delete(id);\n  }\n}\n"]}
{"filename": "src/developer/developer.service.ts", "chunked_list": ["import {\n  HttpException,\n  HttpStatus,\n  Inject,\n  Injectable,\n  NotFoundException,\n} from '@nestjs/common';\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Cache } from 'cache-manager';\nimport { InjectModel } from '@nestjs/mongoose';", "import { Cache } from 'cache-manager';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { DeveloperDTO, PartialDeveloperDTO } from './dto';\nimport { Developer, DeveloperDocument } from './schemas/developer.schema';\nimport { IDeveloperService } from '../core/interfaces/IDeveloperService';\n\n@Injectable()\nexport class DeveloperService implements IDeveloperService {\n  constructor(\n    @InjectModel(Developer.name)\n    private developerModel: Model<DeveloperDocument>,\n    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,\n  ) {}\n\n  async create(dto: DeveloperDTO): Promise<DeveloperDocument> {", "export class DeveloperService implements IDeveloperService {\n  constructor(\n    @InjectModel(Developer.name)\n    private developerModel: Model<DeveloperDocument>,\n    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,\n  ) {}\n\n  async create(dto: DeveloperDTO): Promise<DeveloperDocument> {\n    try {\n      const developer = await this.developerModel.create(dto);\n      if (!developer) throw new NotFoundException(`failed to create developer!`);\n      return developer;", "    try {\n      const developer = await this.developerModel.create(dto);\n      if (!developer) throw new NotFoundException(`failed to create developer!`);\n      return developer;\n    } catch (error) {\n      throw new NotFoundException(`failed to create developer for duplicate email!`);\n    }\n  }\n\n  async readBatch(): Promise<DeveloperDocument[]> {\n    return await this.developerModel.find().exec();\n  }\n\n  async read(id: string): Promise<DeveloperDocument> {", "    try {\n      const cacheKey = `developer:${id}`;\n      const cached = await this.cacheManager.get(cacheKey);\n\n      if (cached) {\n        return JSON.parse(cached as unknown as string);\n      }\n\n      const developer = await this.developerModel.findById(id);\n      if (!developer) throw new NotFoundException(`developer not found!`);\n      await this.cacheManager.set(cacheKey, JSON.stringify(developer), 0);\n      return developer;", "      if (!developer) throw new NotFoundException(`developer not found!`);\n      await this.cacheManager.set(cacheKey, JSON.stringify(developer), 0);\n      return developer;\n    } catch (error) {\n      throw new NotFoundException(`developer not found!`);\n    }\n  }\n\n  async filterByLevel(dto: PartialDeveloperDTO): Promise<DeveloperDocument[]> {\n    try {\n      const cacheKey = `developers:${dto.level}`;\n      const cached = await this.cacheManager.get(cacheKey);", "    try {\n      const cacheKey = `developers:${dto.level}`;\n      const cached = await this.cacheManager.get(cacheKey);\n      if (cached) return JSON.parse(cached as unknown as string);\n      const developers = await this.developerModel.find({ level: dto.level }).exec();\n      if (developers) {\n        await this.cacheManager.set(cacheKey, JSON.stringify(developers), 0);\n      }\n      return developers;\n    } catch (error) {\n      throw new NotFoundException(`failed to filter developer!`);\n    }\n  }\n\n  async update(id: string, dto: PartialDeveloperDTO): Promise<DeveloperDocument> {\n    const { _id } = await this.read(id);\n    const developer = await this.developerModel.findByIdAndUpdate(_id, dto, {\n      new: true,\n    });\n", "    } catch (error) {\n      throw new NotFoundException(`failed to filter developer!`);\n    }\n  }\n\n  async update(id: string, dto: PartialDeveloperDTO): Promise<DeveloperDocument> {\n    const { _id } = await this.read(id);\n    const developer = await this.developerModel.findByIdAndUpdate(_id, dto, {\n      new: true,\n    });\n", "    if (!developer) throw new NotFoundException(`failed to update developer!`);\n    const cacheKey = `developer:${id}`;\n    await this.cacheManager.set(cacheKey, JSON.stringify(developer), 0);\n    return developer;\n  }\n\n  async delete(id: string): Promise<HttpException> {\n    const developer = await this.developerModel.findByIdAndDelete(id);\n    if (!developer) throw new NotFoundException(`failed to delete developer!`);\n\n    const cacheKey = `developer:${id}`;\n    const cached = await this.cacheManager.get(cacheKey);", "    if (!developer) throw new NotFoundException(`failed to delete developer!`);\n\n    const cacheKey = `developer:${id}`;\n    const cached = await this.cacheManager.get(cacheKey);\n    if (cached) await this.cacheManager.del(cacheKey);\n\n    throw new HttpException('The data has been deleted successfully', HttpStatus.OK);\n  }\n}\n"]}
{"filename": "src/developer/schemas/developer.schema.ts", "chunked_list": ["import { EDeveloperLevel } from './../../core/enums/EDeveloper';\nimport { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { HydratedDocument } from 'mongoose';\n\nexport type DeveloperDocument = HydratedDocument<Developer>;\n\n@Schema()\nexport class Developer {\n  @Prop()\n  name: string;\n\n  @Prop({ unique: true })\n  email: string;\n\n  @Prop({ type: String, enum: EDeveloperLevel, default: EDeveloperLevel.JUNIOR })\n  level: EDeveloperLevel;\n}\n\nexport const DeveloperSchema = SchemaFactory.createForClass(Developer);\n"]}
{"filename": "src/developer/dto/developer.dto.ts", "chunked_list": ["import {\n  IsEmail,\n  IsEnum,\n  IsNotEmpty,\n  IsOptional,\n  IsString,\n  Length,\n} from 'class-validator';\nimport { PartialType } from '@nestjs/mapped-types';\nimport { EDeveloperLevel } from './../../core/enums/EDeveloper';", "import { PartialType } from '@nestjs/mapped-types';\nimport { EDeveloperLevel } from './../../core/enums/EDeveloper';\n\nexport class DeveloperDTO {\n  @IsString()\n  @Length(3)\n  name: string;\n\n  @IsEmail()\n  @IsNotEmpty()\n  email: string;\n\n  @IsString()\n  @IsEnum(EDeveloperLevel)\n  @IsOptional()\n  level: EDeveloperLevel;\n}\n", "export class PartialDeveloperDTO extends PartialType(DeveloperDTO) {}\n"]}
{"filename": "src/developer/dto/index.ts", "chunked_list": ["export * from './developer.dto';\n"]}
{"filename": "src/core/interfaces/IDeveloperService.ts", "chunked_list": ["import { EDeveloperLevel } from '../enums/EDeveloper';\nimport { IService } from './IService';\nimport { DeveloperDocument } from '../../developer/schemas/developer.schema';\nimport { DeveloperDTO, PartialDeveloperDTO } from 'src/developer/dto';\nimport { HttpException } from '@nestjs/common';\n\nexport interface IDeveloperService extends IService<DeveloperDTO, PartialDeveloperDTO> {\n  developer?: IDeveloper;\n\n  /**\n   * create record\n   */\n  create(dto: DeveloperDTO): Promise<DeveloperDocument | object>;\n\n  /**\n   * get the full records\n   */\n  readBatch(): Promise<DeveloperDocument[] | object[]>;\n\n  /**\n   * get a single record\n   */\n  read(id: string): Promise<DeveloperDocument | object>;\n\n  /**\n   * get all the developers by level\n   */\n  filterByLevel(dto: PartialDeveloperDTO): Promise<DeveloperDocument[] | object[]>;\n\n  /**\n   * update a single record\n   */\n  update(id: string, dto: PartialDeveloperDTO): Promise<DeveloperDocument | object>;\n\n  /**\n   * delete a single record\n   */\n  delete(id: string): Promise<HttpException>;\n}\n", "export interface IDeveloper {\n  readonly _id: string;\n  name: string;\n  email: string;\n  level: EDeveloperLevel.JUNIOR | EDeveloperLevel.SENIOR;\n}\n"]}
{"filename": "src/core/interfaces/IService.ts", "chunked_list": ["export interface IService<T, PT> {\n  /**\n   * create record\n   */\n  create(dto?: T);\n\n  /**\n   * get the full records\n   */\n  readBatch();\n\n  /**\n   * get a single record\n   */\n  read(id?: string);\n\n  /**\n   * update a single record\n   */\n  update(id?: string, dto?: PT);\n\n  /**\n   * delete a single record\n   */\n  delete(id?: string);\n}\n"]}
{"filename": "src/core/enums/EDeveloper.ts", "chunked_list": ["export enum EDeveloperLevel {\n  JUNIOR = 'junior',\n  SENIOR = 'senior',\n}\n"]}
