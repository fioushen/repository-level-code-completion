{"filename": "scripts/test.ts", "chunked_list": ["import { apiWithLog } from '../src/apiWithLog';\n\n\nconst run = async () => {\n  const url = 'https://cat-fact.herokuapp.com/facts'\n  await apiWithLog(url);\n};\n\n(async () => {\n  try {\n    await run();", "(async () => {\n  try {\n    await run();\n  } catch (err) {\n    // eslint-disable-next-line\n    console.log({\n      err,\n    });\n    process.exit(1);\n  }\n\n  process.exit(0);\n})();\n"]}
{"filename": "src/apiWithLog.ts", "chunked_list": ["import { RequestInfo, RequestInit, Response } from 'node-fetch';\n\nimport { cloneResponse } from './cloneResponse';\nimport { timeSpan } from './timeSpan';\nimport { apiDebug }from './apiDebug';\nimport { apiReport } from './apiReport';\nimport { getRequestMock, saveRequestMock } from './apiCache';\n\nconst fetch = (url: URL | RequestInfo, init?: RequestInit) =>\n  import('node-fetch').then(({ default: fetch }) => fetch(url, init));", "const fetch = (url: URL | RequestInfo, init?: RequestInit) =>\n  import('node-fetch').then(({ default: fetch }) => fetch(url, init));\n\ntype RequestOptions = RequestInit & {\n  shouldReport?: boolean;\n};\n\nexport const apiWithLog = async (\n  init: RequestInfo,\n  optionsApi: RequestOptions = { method: 'GET' },\n): Promise<Response> => {\n  const end = timeSpan();\n\n  const options = {\n    ...optionsApi,\n    headers: {\n      ...(optionsApi.headers || {}),\n      'user-agent': 'node-fetch',\n    },\n  };\n\n  const requestMock = await getRequestMock(init, options);\n", "  if (requestMock) {\n    return requestMock;\n  }\n\n  return fetch(init, options).then(async (response) => {\n    const durationTime = end();\n\n    const text = await response.text();\n\n    let json: any = null;\n", "    try {\n      json = JSON.parse(text);\n    } catch (err) {\n      // eslint-disable-next-line\n    }\n\n    const getBody = (): Record<string, string> => {\n      if (json) {\n        return {\n          json,\n        };\n      }\n\n      return {\n        text,\n      };\n    };\n\n    await saveRequestMock(init, options, text, response);\n\n    apiDebug({\n      init,\n      options,\n      durationTime,\n      getBody,\n      response,\n    });\n\n    await apiReport({\n      init,\n      options,\n      getBody,\n      response,\n      json,\n      text,\n    });\n\n    const { responseCopy } = await cloneResponse(response, text);\n\n    return responseCopy;\n  });\n};\n"]}
{"filename": "src/apiCache.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport util from 'util';\nimport writeFileAtomicCallback from 'write-file-atomic';\n\nimport { RequestInfo, RequestInit, Response } from 'node-fetch';\n\nimport { cloneResponse } from './cloneResponse';\nimport { debugConsole } from './debugConsole';\nimport { getCurl } from './getCurl';", "import { debugConsole } from './debugConsole';\nimport { getCurl } from './getCurl';\n\nconst readFile = util.promisify(fs.readFile);\nconst writeFile = util.promisify(fs.writeFile);\nconst writeFileAtomic = util.promisify(writeFileAtomicCallback);\n\nconst cwd = process.cwd();\nconst dirPath = 'mock-requests.json';\nconst output = path.join(cwd, dirPath);", "const dirPath = 'mock-requests.json';\nconst output = path.join(cwd, dirPath);\n\nexport const getRequestKey = (init: RequestInfo, options: RequestInit) => {\n  if (!options?.body) {\n    return `${options.method}:${init}`;\n  }\n\n  return `${options.method}:${init}:${JSON.stringify(options.body)}`;\n};\n\nexport const saveRequestMock = async (\n  init: RequestInfo,\n  options: RequestInit,\n  text: string,\n  response: Response,\n) => {", "  if (process.env.WRITE_MOCK !== 'true') {\n    return;\n  }\n\n  // only save ok requests 200\n  if (!response.ok) {\n    return;\n  }\n\n  const requestKey = getRequestKey(init, options);\n\n  let dataString = null;\n", "  try {\n    if (fs.existsSync(output)) {\n      dataString = await readFile(output, 'utf8');\n      console.log(dataString);\n    } else {\n      await writeFile(output, '');\n    }\n  } catch (err) {\n    // eslint-disable-next-line\n    console.log({ err });\n  }\n", "  try {\n    const currentMock = dataString ? JSON.parse(dataString) : {};\n\n    const newRequest = {\n      text,\n      response: {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        ok: response?.ok,\n        size: response?.size,\n        url: response?.url,\n      },\n    };\n\n    const newMock = {\n      ...currentMock,\n      [requestKey]: newRequest,\n    };\n\n    const newMockString = JSON.stringify(newMock);\n\n    await writeFileAtomic(output, newMockString);\n\n    //eslint-disable-next-line\n    console.log(`saved to ${output}`);", "  } catch (err) {\n    // eslint-disable-next-line\n    console.log({ err });\n  }\n};\n\nexport const getRequestMock = async (\n  init: RequestInfo,\n  options: RequestInit,\n) => {\n  if (process.env.USE_MOCK !== 'true') {\n    return;\n  }\n\n  const requestKey = getRequestKey(init, options);\n", "  if (process.env.USE_MOCK !== 'true') {\n    return;\n  }\n\n  const requestKey = getRequestKey(init, options);\n\n  try {\n    const dataString = await readFile(output, 'utf8');\n\n    if (!dataString) {\n      return null;\n    }\n\n    const currentMock = JSON.parse(dataString);\n\n    const mock = currentMock[requestKey];\n", "    if (!dataString) {\n      return null;\n    }\n\n    const currentMock = JSON.parse(dataString);\n\n    const mock = currentMock[requestKey];\n\n    if (!mock) {\n      return null;\n    }\n\n    const { text, response } = mock;\n\n    const { responseCopy } = await cloneResponse(response, text);\n\n    // eslint-disable-next-line\n    console.log('mock-cache: ', requestKey);\n", "    if (!mock) {\n      return null;\n    }\n\n    const { text, response } = mock;\n\n    const { responseCopy } = await cloneResponse(response, text);\n\n    // eslint-disable-next-line\n    console.log('mock-cache: ', requestKey);\n", "    if (process.env.DEBUG === 'true') {\n      // eslint-disable-next-line\n      const { agent, ...optionsWithoutAgent } = options;\n\n      const curl = getCurl(init, options);\n\n      const getBody = () => {\n        let json = null;\n\n        try {\n          json = JSON.parse(text);", "        try {\n          json = JSON.parse(text);\n        } catch (err) {}\n\n        if (json) {\n          return {\n            json,\n          };\n        }\n\n        return {\n          text,\n        };\n      };\n\n      // eslint-disable-next-line\n      debugConsole({\n        init,\n        options: optionsWithoutAgent,\n        ...getBody(),\n        ok: response.ok,\n        status: response.status,\n        curl,\n      });\n    }\n\n    return responseCopy;", "  } catch (err) {\n    // eslint-disable-next-line\n    console.log({ err });\n  }\n\n  return null;\n};\n"]}
{"filename": "src/logSecurity.ts", "chunked_list": ["// find a b\nexport const ignoredHeaders = ['host', 'method', 'path', 'scheme', 'version', 'Api-Access-Key', 'Authorization'];"]}
{"filename": "src/timeSpan.ts", "chunked_list": ["type timeMeasureProps = \n  | \"milliseconds\"\n  | \"nanoseconds\"\n  | \"seconds\"\n\nconst conversionFactors: Record<timeMeasureProps, number> = {\n  'nanoseconds': 1,\n  'milliseconds': 1e6,\n  'seconds': 1e9,\n};\n\nexport const timeSpan = () => {\n  const start = process.hrtime.bigint();\n\n  const end = (timeMeasure: timeMeasureProps) => {\n    const diff = process.hrtime.bigint() - start;\n    const factor = conversionFactors[timeMeasure];\n    return Number(diff) / factor;\n  };\n\n  const returnValue = () => end('milliseconds');\n  returnValue.rounded = () => Math.round(end('milliseconds'));\n  returnValue.seconds = () => end('seconds');\n  returnValue.nanoseconds = () => end('nanoseconds');\n\n  return returnValue;\n};\n"]}
{"filename": "src/apiReport.ts", "chunked_list": ["import * as Sentry from '@sentry/node';\n\nimport { RequestInfo, RequestInit, Response } from 'node-fetch';\nimport prettyFormat from 'pretty-format';\n\nimport { getCurl } from './getCurl';\n\n// TODO: implement\nconst shouldReport = (..._: unknown[]) => false;\n// TODO: implement", "const shouldReport = (..._: unknown[]) => false;\n// TODO: implement\nconst sendtoSlack = (..._: unknown[]) => {};\n\ntype RequestOptions = RequestInit & {\n  shouldReport?: boolean;\n};\n\ntype ApiReport = {\n  init: RequestInfo;\n  options: RequestOptions;\n  // durationTime: number;\n  getBody: () => Record<string, string>;\n  response: Response;\n  json: Record<string, string>;\n  text: string;\n};\n\nexport const apiReport = async ({\n  init,\n  options,\n  getBody,\n  response,\n  json,\n  text,\n}: ApiReport) => {\n  const canReport =\n    typeof options?.shouldReport === 'boolean' ? options.shouldReport : true;\n", "type ApiReport = {\n  init: RequestInfo;\n  options: RequestOptions;\n  // durationTime: number;\n  getBody: () => Record<string, string>;\n  response: Response;\n  json: Record<string, string>;\n  text: string;\n};\n\nexport const apiReport = async ({\n  init,\n  options,\n  getBody,\n  response,\n  json,\n  text,\n}: ApiReport) => {\n  const canReport =\n    typeof options?.shouldReport === 'boolean' ? options.shouldReport : true;\n", "  if (canReport && shouldReport(init, response, json, text)) {\n    const info = {\n      url: init,\n      method: options.method,\n      body: options.body,\n      status: response.status,\n      ...getBody(),\n    };\n\n    const curl = getCurl(init, options);\n\n    // do not send to slack error 500", "    if (response.status >= 500) {\n      // some external api is not working well\n      await sendtoSlack({\n        channel: 'pix',\n        icon_emoji: 'bug',\n        attachments: [\n          {\n            text: prettyFormat(info),\n          },\n          {\n            text: curl,\n          },\n        ],\n      });\n    }\n\n    const error = new Error(prettyFormat(info));\n\n    Sentry.setExtra('error', error);\n    Sentry.setExtra('curl', curl);\n    Sentry.captureException(error);\n  }\n};\n"]}
{"filename": "src/debugConsole.ts", "chunked_list": ["import util from 'util';\n// import prettyFormat from 'pretty-format';\n\nexport const debugConsole = (obj: Record<string, unknown>) => {\n  // eslint-disable-next-line\n  console.log(\n    util.inspect(obj, {\n      showHidden: false,\n      depth: null,\n      colors: true,", "      depth: null,\n      colors: true,\n      showProxy: false,\n    }),\n  );\n  // eslint-disable-next-line\n  // console.log(prettyFormat(obj));\n};\n", ""]}
{"filename": "src/apiDebug.ts", "chunked_list": ["import chalk from 'chalk';\n\nimport { RequestInfo, RequestInit, Response } from 'node-fetch';\n\nimport { getCurl } from './getCurl';\nimport { debugConsole } from './debugConsole';\nimport { ignoredHeaders } from './logSecurity';\n\ntype ApiDebug = {\n  init: RequestInfo;\n  options: RequestInit;\n  durationTime: number;\n  getBody: () => Record<string, string>;\n  response: Response;\n};\nexport const apiDebug = ({\n  init,\n  options,\n  durationTime,\n  getBody,\n  response,\n}: ApiDebug) => {", "type ApiDebug = {\n  init: RequestInfo;\n  options: RequestInit;\n  durationTime: number;\n  getBody: () => Record<string, string>;\n  response: Response;\n};\nexport const apiDebug = ({\n  init,\n  options,\n  durationTime,\n  getBody,\n  response,\n}: ApiDebug) => {", "  if (process.env.DEBUG !== 'true') {\n    return;\n  }\n\n  // eslint-disable-next-line\n  const { agent, headers, ...optionsWithoutAgent } = options;\n\n  const cleanHeaders = Object.keys(headers || {}).reduce((acc, key) => {\n    if (!headers || ignoredHeaders.includes(key)) {\n      return acc;\n    }\n  \n    return {\n      ...acc,\n      [key]: (headers as Record<string, string>)[key],\n    };\n  }, {});\n\n  const cleanOptions = {\n    ...optionsWithoutAgent,\n    headers: cleanHeaders,\n  };\n\n  const curl = getCurl(init, options);\n  // eslint-disable-next-line\n  console.log(chalk.yellow(options.method || 'GET'), chalk.blue(init));\n  // eslint-disable-next-line\n  debugConsole({\n    time: `${durationTime}ms`,\n    init,\n    options: cleanOptions,\n    // text,\n    // json,\n    ...getBody(),\n    ok: response.ok,\n    status: response.status,\n    curl,\n  });\n};\n", "    if (!headers || ignoredHeaders.includes(key)) {\n      return acc;\n    }\n  \n    return {\n      ...acc,\n      [key]: (headers as Record<string, string>)[key],\n    };\n  }, {});\n\n  const cleanOptions = {\n    ...optionsWithoutAgent,\n    headers: cleanHeaders,\n  };\n\n  const curl = getCurl(init, options);\n  // eslint-disable-next-line\n  console.log(chalk.yellow(options.method || 'GET'), chalk.blue(init));\n  // eslint-disable-next-line\n  debugConsole({\n    time: `${durationTime}ms`,\n    init,\n    options: cleanOptions,\n    // text,\n    // json,\n    ...getBody(),\n    ok: response.ok,\n    status: response.status,\n    curl,\n  });\n};\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { apiWithLog } from \"./apiWithLog\""]}
{"filename": "src/getCurl.ts", "chunked_list": ["import { Headers, Request, RequestInfo, RequestInit } from \"node-fetch\";\n\n// find a b\nexport const ignoredHeaders = [\n  'host',\n  'method',\n  'path',\n  'scheme',\n  'version',\n  'Api-Access-Key',", "  'version',\n  'Api-Access-Key',\n  'Authorization',\n];\n\n/**\n * see https://fetch.spec.whatwg.org/#methods\n *\n * @export\n * @param {any} options", " * @export\n * @param {any} options\n * @returns {string}\n */\nexport const generateMethod = (options: Request | RequestInit): string => {\n  const method = options.method;\n\n  if (!method) return '';\n\n  const type: Record<string, string> = {\n    GET: ' -X GET',\n    POST: ' -X POST',\n    PUT: ' -X PUT',\n    PATCH: ' -X PATCH',\n    DELETE: ' -X DELETE',\n    HEAD: ' -X HEAD',\n    OPTIONS: ' -X OPTIONS',\n  };\n\n  return type[method.toUpperCase()] || '';\n};\n\n/**\n * @export\n * @param {any} val\n * @returns true if the envirtonment supports Headers and val is of instance Headers\n */\nexport const isInstanceOfHeaders = (val: any): val is Headers => {", "  if (typeof Headers !== 'function') {\n    /**\n     * Environment does not support the Headers constructor\n     * old internet explorer?\n     */\n    return false;\n  }\n\n  return val instanceof Headers;\n};\n\n/**\n * @typedef {Object} HeaderParams\n * @property {Boolean} isEncode - A flag which is set to true if the request should set the --compressed flag\n * @property {String} params - The header params as string\n */\n\nconst getHeaderString = (name: string, val: string) => {", "  if (!val) {\n    return '';\n  }\n\n  return ` -H \"${name}: ${val.replace(/(\\\\|\")/g, '\\\\$1')}\"`;\n};\n\n/**\n * @export\n * @param {object={}} options\n * @param {object|Headers} options.headers\n * @returns {HeaderParams} An Object with the header info\n */\nexport const generateHeader = (options = {} as any) => {\n  const { headers } = options;\n  \n  let isEncode = false;\n  let headerParam = '';\n", "  if (isInstanceOfHeaders(headers)) {\n    headers.forEach((val: string, name: string) => {\n      if (ignoredHeaders.indexOf(name) === -1) {\n        if (name.toLocaleLowerCase() !== 'content-length') {\n          headerParam += getHeaderString(name, val);\n        }\n\n        if (name.toLocaleLowerCase() === 'accept-encoding') {\n          isEncode = true;\n        }\n      }\n    });", "  } else if (headers) {\n    Object.keys(headers)\n      .filter((name) => ignoredHeaders.indexOf(name) === -1)\n      .map((name) => {\n        if (name.toLocaleLowerCase() !== 'content-length') {\n          headerParam += getHeaderString(name, headers[name]);\n        }\n\n        if (name.toLocaleLowerCase() === 'accept-encoding') {\n          isEncode = true;\n        }\n      });\n  }\n\n  return {\n    params: headerParam,\n    isEncode,\n  };\n};\n\n/**\n *\n *\n * @export\n * @param {Object} body\n * @returns {string}\n */", "        if (name.toLocaleLowerCase() === 'accept-encoding') {\n          isEncode = true;\n        }\n      });\n  }\n\n  return {\n    params: headerParam,\n    isEncode,\n  };\n};\n\n/**\n *\n *\n * @export\n * @param {Object} body\n * @returns {string}\n */", "export function generateBody(body: string | object | null | undefined): string {\n  if (!body) return '';\n  if (typeof body === 'object') {\n    if (body.hasOwnProperty('has')) {\n      return ` --data-urlencode '${body.toString()}'`;\n    }\n\n    return ` --data-binary '${JSON.stringify(body)}'`;\n  }\n\n  return ` --data-binary '${body}'`;\n}\n\n/**\n *\n *\n * @export\n * @param {boolean} isEncode\n * @return {string}\n */", "export function generateCompress(isEncode: boolean): string {\n  return isEncode ? ' --compressed' : '';\n}\n\n/**\n *\n *\n * @export\n * @param {string|object} requestInfo\n * @param {object={}} requestInit\n */\nexport const getCurl = (requestInfo: RequestInfo, requestInit: RequestInit) => {\n  let url;\n  let options;\n\n  /**\n   * initialization with an empty object is done here to\n   * keep everything backwards compatible to 0.4.0 and below\n   */", "  if (typeof requestInfo === 'string') {\n    url = requestInfo;\n    options = requestInit || {};\n  } else {\n    url = (requestInfo || {}).url;\n    options = requestInfo || {};\n  }\n\n  const { body } = options;\n  const headers = generateHeader(options);\n\n  return `curl '${url}'${generateMethod(options)}${\n    headers.params || ''\n  }${generateBody(body)}${generateCompress(headers.isEncode)}`;\n};\n"]}
{"filename": "src/jsonOrText.ts", "chunked_list": ["import { Response } from \"node-fetch\";\n\nexport const jsonOrText = async (\n  response: Response,\n): Promise<string | Record<string, unknown>> => {\n  const text = await response.text();\n\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return text;\n  }\n};\n", "  } catch (err) {\n    return text;\n  }\n};\n"]}
{"filename": "src/cloneResponse.ts", "chunked_list": ["import { Response } from \"node-fetch\";\n\n// This function clone the response consume your body and return the same response\n// `clone()` is broken in `node-fetch` and results in a stalled Promise\n// for responses above a certain size threshold. So construct a similar\n// clone ourselves...\ntype CloneResponse = {\n  responseCopy: Response;\n  text: string;\n  json: string;\n};\n\nexport const cloneResponse = async (\n  response: Response,\n  responseText?: string | null,\n): Promise<CloneResponse> => {\n  const text = responseText ?? (await response.text());\n\n  let json = null;\n", "  try {\n    json = JSON.parse(text);\n  } catch (err) {\n    // eslint-disable-next-line\n  }\n\n  // eslint-disable-next-line\n  // @ts-ignore\n  const ResponseConstructor = fetch.Response || global.Response || response.constructor;\n\n  const responseCopy = new ResponseConstructor(text, {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers,\n    // These are not spec-compliant `Response` options, but `node-fetch`\n    // has them.\n    ok: response?.ok,\n    size: response?.size,\n    url: response?.url,\n  });\n\n  return {\n    responseCopy,\n    text,\n    json,\n  };\n};\n"]}
{"filename": "src/isMainScript.ts", "chunked_list": ["import path from 'path';\n\nconst cwd = process.cwd();\n\n// make it stable for all\n// node\n// yarn w\n// yarn b\n// yarn es\nexport const isMainScript = (require: NodeJS.Require, module: NodeJS.Module, filename: string) => {", "// yarn es\nexport const isMainScript = (require: NodeJS.Require, module: NodeJS.Module, filename: string) => {\n  // webpack_entry is the real\n  if (process.env.WEBPACK_ENTRY) {\n    const fullEntry = path.join(cwd, process.env.WEBPACK_ENTRY);\n    const fullFilename = path.join(cwd, filename);\n\n    if (fullEntry === fullFilename) {\n      return true;\n    }\n\n    return false;\n  }\n", "  if (!module.parent) {\n    return true;\n  }\n\n  if (process.env.DEBUG === 'true') {\n    // eslint-disable-next-line\n    console.log('not main script, check your script code');\n  }\n\n  return false;\n};\n"]}
