{"filename": "tsup.config.ts", "chunked_list": ["import type { Options } from 'tsup';\n\nconst tsupConfig: Options = {\n  entryPoints: ['src/index.ts'],\n  clean: true,\n  format: ['cjs', 'esm'],\n  dts: true,\n};\n\nexport default tsupConfig;", "\nexport default tsupConfig;\n"]}
{"filename": "src/Watcher.ts", "chunked_list": ["import * as chokidar from 'chokidar';\nimport * as fs from 'fs';\nimport { Compiler } from './Compiler';\n\ninterface WatchOptions extends chokidar.WatchOptions {}\n\nexport class Watcher {\n  compiler: Compiler;\n\n  watcher: chokidar.FSWatcher | null;\n  watcherPath: string;\n  watchOptions: WatchOptions;\n\n  initial: boolean;\n  initialAssetPaths: Set<string>;\n\n  constructor(compiler: Compiler, watcherPath: string, watchOptions: WatchOptions) {\n    this.compiler = compiler;\n\n    this.watcher = null;\n    this.watcherPath = watcherPath;\n    this.watchOptions = watchOptions;\n\n    this.initial = true;\n    this.initialAssetPaths = new Set<string>();\n  }\n\n  start() {", "    if (this.watchOptions.persistent) {\n      // Chokidar is not really watching without `persistent` being `true` so we do not want\n      // to call the `watcherStart` hook in this case.\n      this.compiler.hooks.watcherStart.call();\n    }\n\n    this.watcher = chokidar.watch(this.watcherPath, this.watchOptions);\n\n    this.watcher.on('add', (path: string, stats: fs.Stats) => {\n      if (this.initial) {\n        this.initialAssetPaths.add(path);\n\n        return;\n      }\n\n      this.compiler.compile('add', new Set([path]));\n    });\n\n    this.watcher.on('change', (path: string, stats: fs.Stats) => {\n      this.compiler.compile('update', new Set([path]));\n    });\n\n    this.watcher.on('unlink', (path: string, stats: fs.Stats) => {\n      this.compiler.compile('remove', new Set([path]));\n    });\n\n    this.watcher.on('ready', () => {\n      this.initial = false;\n\n      this.compiler.compile('add', this.initialAssetPaths);\n    });\n  }\n\n  async close() {", "      if (this.initial) {\n        this.initialAssetPaths.add(path);\n\n        return;\n      }\n\n      this.compiler.compile('add', new Set([path]));\n    });\n\n    this.watcher.on('change', (path: string, stats: fs.Stats) => {\n      this.compiler.compile('update', new Set([path]));\n    });\n\n    this.watcher.on('unlink', (path: string, stats: fs.Stats) => {\n      this.compiler.compile('remove', new Set([path]));\n    });\n\n    this.watcher.on('ready', () => {\n      this.initial = false;\n\n      this.compiler.compile('add', this.initialAssetPaths);\n    });\n  }\n\n  async close() {", "    if (this.watcher) {\n      await this.watcher.close();\n\n      this.compiler.hooks.watcherClose.call();\n    }\n  }\n}\n"]}
{"filename": "src/Asset.ts", "chunked_list": ["import * as fs from 'fs-extra';\nimport { CompilerEvent } from './Compiler';\n\nexport type AssetType =\n  | 'assets'\n  | 'config'\n  | 'layout'\n  | 'locales'\n  | 'sections'\n  | 'snippets'\n  | 'templates';\n", "export type AssetPath = {\n  absolute: string;\n  relative: string;\n};\n\nexport class Asset {\n  /**\n   * The type of the asset.\n   */\n  type: AssetType;\n\n  /**\n   * The absolute and relative path to the asset's file.\n   */\n  source: AssetPath;\n\n  /**\n   * The absolute and relative path to the asset's file.\n   */\n  target?: AssetPath;\n\n  /**\n   * A set of assets the asset is linked with.\n   */\n  links: Set<Asset>;\n\n  /**\n   * The asset's content.\n   */\n  content: Buffer;\n\n  /**\n   * The action that created this asset.\n   */\n  action: CompilerEvent;\n\n  constructor(type: AssetType, source: AssetPath, links: Set<Asset>, action: CompilerEvent) {\n    this.type = type;\n    this.source = source;\n    this.links = new Set<Asset>(links);\n\n    this.content = this.getContent();\n\n    this.action = action;\n  }\n\n  private getContent() {", "    try {\n      return fs.readFileSync(this.source.absolute);\n    } catch {\n      return Buffer.from('');\n    }\n  }\n}\n"]}
{"filename": "src/Logger.ts", "chunked_list": ["export type LoggerDataType = 'warning' | 'error';\n\nexport class Logger {\n  success(message: string) {\n    console.log(this.formatSuccess(message));\n    console.log('');\n  }\n\n  warning(message: string, data: string[]) {\n    console.log(this.formatWarning(message));\n", "    if (data.length > 0) {\n      console.log('');\n      console.log(this.formatLogData('warning', data));\n      console.log('');\n    }\n  }\n\n  error(message: string, data: string[]) {\n    console.log(this.formatError(message));\n\n    if (data.length > 0) {\n      console.log('');\n      console.log(this.formatLogData('error', data));\n      console.log('');\n    }\n  }\n\n  private formatSuccess(message: string): string {\n    return `\\x1b[32m${message}\\x1b[0m`;\n  }\n\n  private formatWarning(message: string): string {\n    return `\\x1b[33m${message}\\x1b[0m`;\n  }\n\n  private formatError(message: string): string {\n    return `\\x1b[31m${message}\\x1b[0m`;\n  }\n\n  private formatLogData(type: LoggerDataType, data: string[]) {\n    const prefix = this.getPrefix(type);\n\n    return data.map((item) => `  ${prefix} ${item}`).join('\\n');\n  }\n\n  private getPrefix(type: LoggerDataType) {\n    const prefix = {\n      warning: this.formatWarning('\u26a0'),\n      error: this.formatError('\u2716'),\n    };\n\n    return prefix[type];\n  }\n}\n", "    if (data.length > 0) {\n      console.log('');\n      console.log(this.formatLogData('error', data));\n      console.log('');\n    }\n  }\n\n  private formatSuccess(message: string): string {\n    return `\\x1b[32m${message}\\x1b[0m`;\n  }\n\n  private formatWarning(message: string): string {\n    return `\\x1b[33m${message}\\x1b[0m`;\n  }\n\n  private formatError(message: string): string {\n    return `\\x1b[31m${message}\\x1b[0m`;\n  }\n\n  private formatLogData(type: LoggerDataType, data: string[]) {\n    const prefix = this.getPrefix(type);\n\n    return data.map((item) => `  ${prefix} ${item}`).join('\\n');\n  }\n\n  private getPrefix(type: LoggerDataType) {\n    const prefix = {\n      warning: this.formatWarning('\u26a0'),\n      error: this.formatError('\u2716'),\n    };\n\n    return prefix[type];\n  }\n}\n"]}
{"filename": "src/melter.ts", "chunked_list": ["import { Compiler } from './Compiler';\nimport { MelterConfig } from './config';\nimport { applyConfigDefaults } from './config/defaults';\n\nexport function melter(config: MelterConfig) {\n  const compilerConfig = applyConfigDefaults(config);\n  const compiler = new Compiler(compilerConfig);\n\n  if (Array.isArray(compilerConfig.plugins)) {\n    for (const plugin of compilerConfig.plugins) {\n      plugin.apply(compiler);\n    }\n  }\n\n  return compiler;\n}\n", "  if (Array.isArray(compilerConfig.plugins)) {\n    for (const plugin of compilerConfig.plugins) {\n      plugin.apply(compiler);\n    }\n  }\n\n  return compiler;\n}\n"]}
{"filename": "src/Compilation.ts", "chunked_list": ["import * as path from 'path';\nimport { SyncHook } from 'tapable';\nimport { Asset } from './Asset';\nimport { Compiler, CompilerEvent } from './Compiler';\n\nexport type CompilationStats = {\n  /**\n   * The compilation time in milliseconds.\n   */\n  time: number;\n\n  /**\n   * A list of asset objects.\n   */\n  assets: Asset[];\n\n  /**\n   * A list of warnings.\n   */\n  warnings: string[];\n\n  /**\n   * A list of errors.\n   */\n  errors: string[];\n};\n", "export type CompilationHooks = {\n  beforeAddAsset: SyncHook<[Asset]>;\n  afterAddAsset: SyncHook<[Asset]>;\n};\n\nexport class Compilation {\n  compiler: Compiler;\n  event: CompilerEvent;\n  assetPaths: Set<string>;\n  assets: Set<Asset>;\n\n  stats: CompilationStats;\n\n  hooks: Readonly<CompilationHooks>;\n\n  /**\n   * Creates an instance of `Compilation`.\n   *\n   * @param compiler The compiler which created the compilation.\n   * @param assetPaths A set of paths to assets that should be compiled.\n   */\n  constructor(compiler: Compiler, event: CompilerEvent, assetPaths: Set<string>) {\n    this.compiler = compiler;\n    this.event = event;\n    this.assetPaths = assetPaths;\n    this.assets = new Set<Asset>();\n\n    this.stats = {\n      time: 0,\n\n      assets: [],\n\n      warnings: [],\n      errors: [],\n    };\n\n    this.hooks = Object.freeze<CompilationHooks>({\n      beforeAddAsset: new SyncHook(['asset']),\n      afterAddAsset: new SyncHook(['asset']),\n    });\n  }\n\n  create() {\n    const startTime = performance.now();\n\n    this.assetPaths.forEach((assetPath) => {\n      const assetType = 'sections';\n\n      const sourcePath = {\n        absolute: path.resolve(this.compiler.cwd, assetPath),\n        relative: assetPath,\n      };\n\n      const asset = new Asset(assetType, sourcePath, new Set(), this.event);\n\n      this.hooks.beforeAddAsset.call(asset);\n\n      this.assets.add(asset);\n      this.stats.assets.push(asset);\n\n      this.hooks.afterAddAsset.call(asset);\n    });\n\n    const endTime = performance.now();\n\n    this.stats.time = Number((endTime - startTime).toFixed(2));\n  }\n\n  addWarning(warning: string) {\n    this.stats.warnings.push(warning);\n  }\n\n  addError(error: string) {\n    this.stats.errors.push(error);\n  }\n}\n"]}
{"filename": "src/Plugin.ts", "chunked_list": ["import { Compiler } from './Compiler';\n\nexport class Plugin {\n  apply(compiler: Compiler): void {}\n}\n"]}
{"filename": "src/Compiler.ts", "chunked_list": ["import { SyncHook } from 'tapable';\nimport { Compilation, CompilationStats } from './Compilation';\nimport { Emitter } from './Emitter';\nimport { Logger } from './Logger';\nimport { Watcher } from './Watcher';\nimport { CompilerConfig } from './config';\n\nexport type CompilerHooks = {\n  beforeCompile: SyncHook<[]>;\n  compilation: SyncHook<[Compilation]>;\n  afterCompile: SyncHook<[Compilation]>;\n  beforeEmit: SyncHook<[Compilation]>;\n  emitter: SyncHook<[Emitter]>;\n  afterEmit: SyncHook<[Compilation]>;\n  done: SyncHook<[CompilationStats]>;\n\n  watcherStart: SyncHook<[]>;\n  watcherClose: SyncHook<[]>;\n};\n", "export type CompilerEvent = 'add' | 'update' | 'remove';\n\nexport class Compiler {\n  cwd: Readonly<string>;\n  config: Readonly<CompilerConfig>;\n\n  hooks: Readonly<CompilerHooks>;\n\n  watcher: Readonly<Watcher | null>;\n\n  logger: Readonly<Logger>;\n\n  constructor(config: CompilerConfig) {\n    this.cwd = process.cwd();\n    this.config = config;\n\n    this.hooks = Object.freeze<CompilerHooks>({\n      beforeCompile: new SyncHook(),\n      compilation: new SyncHook(['compilation']),\n      afterCompile: new SyncHook(['compilation']),\n      beforeEmit: new SyncHook(['compilation']),\n      emitter: new SyncHook(['emitter']),\n      afterEmit: new SyncHook(['compilation']),\n      done: new SyncHook(['stats']),\n\n      watcherStart: new SyncHook(),\n      watcherClose: new SyncHook(),\n    });\n\n    this.watcher = null;\n\n    this.logger = new Logger();\n  }\n\n  build() {\n    const watcher = new Watcher(this, this.config.input, {\n      cwd: this.cwd,\n\n      // Trigger build.\n      ignoreInitial: false,\n\n      // Do not listen for changes.\n      persistent: false,\n    });\n\n    watcher.start();\n  }\n\n  watch() {\n    this.watcher = new Watcher(this, this.config.input, {\n      cwd: this.cwd,\n\n      // Trigger an initial build.\n      ignoreInitial: false,\n\n      // Continously watch for changes.\n      persistent: true,\n    });\n\n    this.watcher.start();\n  }\n\n  compile(event: CompilerEvent, assetPaths: Set<string>) {\n    this.hooks.beforeCompile.call();\n\n    const compilation = new Compilation(this, event, assetPaths);\n\n    this.hooks.compilation.call(compilation);\n\n    compilation.create();\n\n    this.hooks.afterCompile.call(compilation);\n\n    // If no output directory is specified we do not want to emit assets.", "    if (this.config.output) {\n      this.hooks.beforeEmit.call(compilation);\n\n      const emitter = new Emitter(this, compilation);\n\n      this.hooks.emitter.call(emitter);\n\n      emitter.emit();\n\n      this.hooks.afterEmit.call(compilation);\n    }\n\n    this.hooks.done.call(compilation.stats);\n  }\n\n  close() {", "    if (this.watcher) {\n      // Close active watcher if compiler has one.\n      this.watcher.close();\n    }\n\n    process.exit();\n  }\n}\n"]}
{"filename": "src/Emitter.ts", "chunked_list": ["import * as fs from 'fs-extra';\nimport { SyncHook } from 'tapable';\nimport { Asset, AssetPath } from './Asset';\nimport { Compilation } from './Compilation';\nimport { Compiler } from './Compiler';\n\nexport type EmitterHooks = Readonly<{\n  beforeAssetAction: SyncHook<[Asset]>;\n  afterAssetAction: SyncHook<[Asset]>;\n}>;\n", "export class Emitter {\n  compiler: Compiler;\n  compilation: Compilation;\n\n  hooks: EmitterHooks;\n\n  constructor(compiler: Compiler, compilation: Compilation) {\n    this.compiler = compiler;\n    this.compilation = compilation;\n\n    this.hooks = {\n      beforeAssetAction: new SyncHook(['asset']),\n      afterAssetAction: new SyncHook(['asset']),\n    };\n  }\n\n  emit() {\n    this.compilation.assets.forEach((asset) => {\n      this.hooks.beforeAssetAction.call(asset);\n", "      if (typeof asset.target === 'undefined') {\n        this.compilation.addWarning(`Missing target path: '${asset.source.relative}'`);\n\n        return;\n      }\n\n      switch (asset.action) {\n        case 'add':\n        case 'update': {\n          this.writeFile(asset.target.absolute, asset.content);\n\n          break;\n        }\n\n        case 'remove': {\n          this.removeFile(asset.target.absolute);\n\n          break;\n        }\n\n        // No default.\n      }\n\n      this.hooks.afterAssetAction.call(asset);\n    });\n  }\n\n  private writeFile(targetPath: AssetPath['absolute'], content: Asset['content']) {", "    try {\n      fs.ensureFileSync(targetPath);\n      fs.writeFileSync(targetPath, content);\n    } catch (error: any) {\n      this.compilation.addError(error.message);\n    }\n  }\n\n  private removeFile(targetPath: AssetPath['absolute']) {\n    try {\n      fs.removeSync(targetPath);", "    try {\n      fs.removeSync(targetPath);\n    } catch (error: any) {\n      this.compilation.addError(error.message);\n    }\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './Asset';\nexport * from './Compilation';\nexport * from './Compiler';\nexport * from './Emitter';\nexport * from './Logger';\nexport * from './Plugin';\nexport * from './Watcher';\nexport * from './config';\nexport * from './melter';\n", "export * from './melter';\n"]}
{"filename": "src/plugins/StatsPlugin.ts", "chunked_list": ["import { CompilationStats } from '../Compilation';\nimport { Compiler } from '../Compiler';\nimport { Plugin } from '../Plugin';\n\nexport type StatsPluginConfig = {\n  stats?: boolean;\n};\n\nexport class StatsPlugin extends Plugin {\n  config: StatsPluginConfig;\n\n  constructor(config: StatsPluginConfig = {}) {\n    super();\n\n    this.config = config;\n  }\n\n  apply(compiler: Compiler): void {", "export class StatsPlugin extends Plugin {\n  config: StatsPluginConfig;\n\n  constructor(config: StatsPluginConfig = {}) {\n    super();\n\n    this.config = config;\n  }\n\n  apply(compiler: Compiler): void {\n    if (this.config.stats === false) return;\n\n    compiler.hooks.done.tap('StatsPlugin', (compilationStats: CompilationStats) => {", "    if (this.config.stats === false) return;\n\n    compiler.hooks.done.tap('StatsPlugin', (compilationStats: CompilationStats) => {\n      if (compilationStats.errors.length > 0) {\n        compiler.logger.error('Compilation failed', compilationStats.errors);\n      } else if (compilationStats.warnings.length > 0) {\n        compiler.logger.warning(\n          `Compiled with ${compilationStats.warnings.length} warnings`,\n          compilationStats.warnings,\n        );\n      } else {\n        compiler.logger.success(`Successfully compiled in ${compilationStats.time} ms`);\n      }\n    });\n  }\n}\n"]}
{"filename": "src/plugins/PathsPlugin.ts", "chunked_list": ["import * as path from 'path';\nimport { Asset, AssetPath, AssetType } from '../Asset';\nimport { Compiler } from '../Compiler';\nimport { Emitter } from '../Emitter';\nimport { Plugin } from '../Plugin';\n\ntype Paths = {\n  /**\n   * An array of paths pointing to files that should be processed as `assets`.\n   */\n  assets?: RegExp[];\n\n  /**\n   * An array of paths pointing to files that should be processed as `config`.\n   */\n  config?: RegExp[];\n\n  /**\n   * An array of paths pointing to files that should be processed as `layout`.\n   */\n  layout?: RegExp[];\n\n  /**\n   * An array of paths pointing to files that should be processed as `locales`.\n   */\n  locales?: RegExp[];\n\n  /**\n   * An array of paths pointing to files that should be processed as `sections`.\n   */\n  sections?: RegExp[];\n\n  /**\n   * An array of paths pointing to files that should be processed as `snippets`.\n   */\n  snippets?: RegExp[];\n\n  /**\n   * An array of paths pointing to files that should be processed as `templates`.\n   */\n  templates?: RegExp[];\n};\n\n/**\n * Path plugin configuration object.\n */", "export type PathsPluginConfig = {\n  /**\n   * A map of Shopify's directory structure and component types.\n   *\n   * @see [Shopify Docs Reference](https://shopify.dev/docs/themes/architecture#directory-structure-and-component-types)\n   */\n  paths?: Paths | false;\n};\n\nconst defaultPathsPluginConfig: PathsPluginConfig = {\n  paths: {\n    assets: [/assets\\/[^\\/]*\\.*$/],\n    config: [/config\\/[^\\/]*\\.json$/],\n    layout: [/layout\\/[^\\/]*\\.liquid$/],\n    locales: [/locales\\/[^\\/]*\\.json$/],\n    sections: [/sections\\/[^\\/]*\\.liquid$/],\n    snippets: [/snippets\\/[^\\/]*\\.liquid$/],\n    templates: [\n      /templates\\/[^\\/]*\\.liquid$/,\n      /templates\\/[^\\/]*\\.json$/,\n      /templates\\/customers\\/[^\\/]*\\.liquid$/,\n      /templates\\/customers\\/[^\\/]*\\.json$/,\n    ],\n  },\n};\n", "export class PathsPlugin extends Plugin {\n  config: PathsPluginConfig;\n\n  constructor(config: PathsPluginConfig) {\n    super();\n\n    this.config =\n      config.paths !== false\n        ? {\n            paths: {\n              ...defaultPathsPluginConfig.paths,\n              ...config.paths,\n            },\n          }\n        : {};\n  }\n\n  apply(compiler: Compiler): void {\n    const output = compiler.config.output;\n", "    if (!output) return;\n\n    const paths = this.config.paths;\n\n    if (!paths) return;\n\n    compiler.hooks.emitter.tap('PathsPlugin', (emitter: Emitter) => {\n      emitter.hooks.beforeAssetAction.tap('PathsPlugin', (asset: Asset) => {\n        const assetType = this.determineAssetType(paths, asset.source.relative);\n\n        if (!assetType) return;\n        asset.type = assetType;\n\n        const assetSourcePathParts = asset.source.relative.split('/');\n\n        let assetFilename: string = '';\n", "        if (!assetType) return;\n        asset.type = assetType;\n\n        const assetSourcePathParts = asset.source.relative.split('/');\n\n        let assetFilename: string = '';\n\n        if (assetSourcePathParts.at(-2) === 'customers') {\n          assetFilename = assetSourcePathParts.slice(-2).join('/');\n        } else {\n          assetFilename = assetSourcePathParts.at(-1)!;\n        }\n\n        const assetTargetPath = this.resolveAssetTargetPath(\n          compiler.cwd,\n          output,\n          assetType,\n          assetFilename,\n        );\n\n        asset.target = assetTargetPath;\n      });\n    });\n  }\n\n  private determineAssetType(paths: Paths, assetPath: string): AssetType | null {\n    const pathEntries = Object.entries(paths);\n", "    for (let i = 0; i < pathEntries.length; i += 1) {\n      const [name, patterns] = pathEntries[i];\n\n      for (let j = 0; j < patterns.length; j++) {\n        if (assetPath.match(patterns[j])) {\n          return name as AssetType;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  private resolveAssetTargetPath(\n    cwd: string,\n    output: string,\n    assetType: AssetType,\n    filename: string,\n  ): AssetPath {\n    const relativeAssetTargetPath = path.resolve(output, assetType, filename);\n    const absoluteAssetTargetPath = path.resolve(cwd, relativeAssetTargetPath);\n\n    return {\n      absolute: absoluteAssetTargetPath,\n      relative: relativeAssetTargetPath,\n    };\n  }\n}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export function getFilenameFromPath(path: string): string {\n  return path.split('/').at(-1)!;\n}\n\n/**\n * Parses provided value and returns data if succeeded. Otherwise the corresponding error\n * will be returned.\n */\nexport function parseJSON<T>(value: string): { data: T | null; error?: string } {\n  try {\n    return {\n      data: JSON.parse(value),\n    };", "export function parseJSON<T>(value: string): { data: T | null; error?: string } {\n  try {\n    return {\n      data: JSON.parse(value),\n    };\n  } catch (error: any) {\n    return {\n      data: null,\n      error: error.message,\n    };\n  }\n}\n"]}
{"filename": "src/config/defaults.ts", "chunked_list": ["import { CompilerConfig, MelterConfig, defaultBaseCompilerConfig } from '.';\nimport { Plugin } from '../Plugin';\nimport { PathsPlugin } from '../plugins/PathsPlugin';\nimport { StatsPlugin } from '../plugins/StatsPlugin';\n\nfunction applyDefaultPlugins(config: CompilerConfig): Plugin[] {\n  const plugins = [];\n\n  plugins.push(\n    ...[\n      new StatsPlugin({\n        stats: config.stats,\n      }),\n\n      new PathsPlugin({\n        paths: config.paths,\n      }),\n    ],\n  );\n\n  return plugins;\n}\n", "export function applyConfigDefaults(config: MelterConfig): CompilerConfig {\n  const compilerConfig = {\n    ...defaultBaseCompilerConfig,\n    ...config,\n  };\n\n  compilerConfig.plugins = [...applyDefaultPlugins(compilerConfig), ...compilerConfig.plugins];\n\n  return compilerConfig;\n}\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import { Plugin } from '../Plugin';\nimport { PathsPluginConfig } from '../plugins/PathsPlugin';\nimport { StatsPluginConfig } from '../plugins/StatsPlugin';\n\nexport * from './load';\n\nexport type BaseCompilerConfig = {\n  /**\n   * Where to look for files to compile.\n   */\n  input: string;\n\n  /**\n   * Where to write the compiled files to. The emitter won't emit any assets if undefined.\n   */\n  output: string;\n\n  /**\n   * A list of additional plugins to add to the compiler.\n   */\n  plugins: Plugin[];\n};\n\nexport const defaultBaseCompilerConfig: BaseCompilerConfig = {\n  input: 'src',\n  output: 'dist',\n  plugins: [],\n};\n\n/**\n * Compiler configuration object.\n */", "export type CompilerConfig = {} & BaseCompilerConfig & StatsPluginConfig & PathsPluginConfig;\n\n/**\n * Melter configuration object.\n *\n * @see [Configuration documentation](https://github.com/unshopable/melter#configuration)\n */\nexport type MelterConfig = Partial<CompilerConfig>;\n"]}
{"filename": "src/config/load.ts", "chunked_list": ["import fg from 'fast-glob';\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { BaseCompilerConfig, MelterConfig, defaultBaseCompilerConfig } from '.';\nimport { getFilenameFromPath, parseJSON } from '../utils';\n\nfunction getConfigFiles(cwd: string): string[] {\n  const configFilePattern = 'melter.config.*';\n  // flat-glob only supports POSIX path syntax, so we use convertPathToPattern() for windows\n  return fg.sync(fg.convertPathToPattern(cwd) + '/' + configFilePattern);\n}\n", "function parseConfigFile(file: string): { config: MelterConfig | null; errors: string[] } {\n  if (file.endsWith('json')) {\n    const content = fs.readFileSync(file, 'utf8');\n\n    const { data, error } = parseJSON<MelterConfig>(content);\n\n    if (error) {\n      return {\n        config: null,\n        errors: [error],\n      };\n    }\n\n    return {\n      config: data,\n      errors: [],\n    };\n  }\n\n  return {\n    config: require(file).default || require(file),\n    errors: [],\n  };\n}\n", "export function loadConfig(): {\n  config: MelterConfig | BaseCompilerConfig | null;\n  warnings: string[];\n  errors: string[];\n} {\n  const configFiles = getConfigFiles(process.cwd());\n\n  if (configFiles.length === 0) {\n    return {\n      config: defaultBaseCompilerConfig,\n      warnings: [\n        'No config found. Loaded default config. To disable this warning create a custom config.',\n      ],\n      errors: [],\n    };\n  }\n\n  const firstConfigFile = configFiles[0];\n\n  const warnings: string[] = [];\n", "  if (configFiles.length > 1) {\n    warnings.push(\n      `Multiple configs found. Loaded '${getFilenameFromPath(\n        firstConfigFile,\n      )}'. To disable this warning remove unused configs.`,\n    );\n  }\n\n  const { config, errors } = parseConfigFile(firstConfigFile);\n\n  return {\n    config,\n    warnings,\n    errors,\n  };\n}\n"]}
