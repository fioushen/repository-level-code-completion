{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from 'vite';\nimport { crx } from '@crxjs/vite-plugin';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\nimport path from 'path';\nimport sveltePreprocess from 'svelte-preprocess';\n\nimport manifest from './src/manifest';\n\nexport default defineConfig(({ mode }) => {\n  const production = mode === 'production';", "export default defineConfig(({ mode }) => {\n  const production = mode === 'production';\n\n  return {\n    build: {\n      emptyOutDir: true,\n      outDir: 'build',\n      rollupOptions: {\n        input: {\n          charge: 'charge.html',", "        input: {\n          charge: 'charge.html',\n        },\n        output: {\n          chunkFileNames: 'assets/chunk-[hash].js',\n        },\n      },\n    },\n    plugins: [\n      crx({ manifest }),", "    plugins: [\n      crx({ manifest }),\n      svelte({\n        compilerOptions: {\n          dev: !production,\n        },\n        preprocess: sveltePreprocess(),\n      }),\n    ],\n    resolve: {", "    ],\n    resolve: {\n      alias: {\n        '@': path.resolve(__dirname, 'src'),\n      },\n    },\n  };\n});\n", ""]}
{"filename": "src/global.d.ts", "chunked_list": ["/// <reference types=\"svelte\" />\n/// <reference types=\"vite/client\" />\n\ndeclare const __APP_VERSION__: string;\n"]}
{"filename": "src/manifest.ts", "chunked_list": ["import { defineManifest } from '@crxjs/vite-plugin';\n\nexport default defineManifest({\n  name: 'create-chrome-ext',\n  description: '',\n  version: '0.0.0',\n  manifest_version: 3,\n  icons: {\n    '16': 'img/logo-16.png',\n    '32': 'img/logo-34.png',", "    '16': 'img/logo-16.png',\n    '32': 'img/logo-34.png',\n    '48': 'img/logo-48.png',\n    '128': 'img/logo-128.png',\n  },\n  action: {\n    default_popup: 'popup.html',\n    default_icon: 'img/logo-48.png',\n  },\n  options_page: 'options.html',", "  },\n  options_page: 'options.html',\n  background: {\n    service_worker: 'src/background/index.ts',\n    type: 'module',\n  },\n  content_scripts: [\n    {\n      matches: ['http://*/*', 'https://*/*'],\n      js: ['src/content/index.ts'],", "      matches: ['http://*/*', 'https://*/*'],\n      js: ['src/content/index.ts'],\n    },\n  ],\n  web_accessible_resources: [\n    {\n      resources: ['img/logo-16.png', 'img/logo-34.png', 'img/logo-48.png', 'img/logo-128.png'],\n      matches: [],\n    },\n    {", "    },\n    {\n      resources: ['js/nip07-provider.js'],\n      matches: ['https://*/*', 'http://localhost:*/*'],\n    },\n  ],\n  permissions: ['storage', 'tabs', 'activeTab'],\n});\n", ""]}
{"filename": "src/pages/options/index.ts", "chunked_list": ["import App from './Options.svelte';\nimport '../../lib/svelte-material-ui';\n\nconst app = new (App as any)({\n  target: document.getElementById('app')!,\n});\n\nexport default app;\n", ""]}
{"filename": "src/pages/popup/index.ts", "chunked_list": ["import App from './Popup.svelte';\nimport '../../lib/svelte-material-ui';\n\nconst app = new (App as any)({\n  target: document.getElementById('app')!,\n});\n\nexport default app;\n", ""]}
{"filename": "src/pages/charge/index.ts", "chunked_list": ["import App from './Charge.svelte';\nimport '../../lib/svelte-material-ui';\n\nconst app = new (App as any)({\n  target: document.getElementById('app')!,\n});\n\nexport default app;\n", ""]}
{"filename": "src/lib/nostr.ts", "chunked_list": ["import * as secp256k1 from '@noble/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bech32 } from 'bech32';\n\nconst utf8Encoder = new TextEncoder();\nsecp256k1.utils.sha256Sync = (...msgs) => sha256(secp256k1.utils.concatBytes(...msgs));\n\nexport async function calcPubkey(seckey: string): Promise<string> {\n  return secp256k1.utils.bytesToHex(secp256k1.schnorr.getPublicKey(seckey));\n}\n", "export async function signEvent(\n  { seckey, pubkey }: KeyPair,\n  unsignedEvent: UnsignedEvent,\n): Promise<SignedEvent> {\n  const { created_at, kind, tags, content } = unsignedEvent;\n\n  const id = secp256k1.utils.bytesToHex(\n    sha256(utf8Encoder.encode(JSON.stringify([0, pubkey, created_at, kind, tags, content]))),\n  );\n  const sig = secp256k1.utils.bytesToHex(secp256k1.schnorr.signSync(id, seckey));\n\n  return {\n    id,\n    pubkey,\n    sig,\n    ...unsignedEvent,\n  };\n}\n", "export function bech32encode(str: string) {\n  return hexEncode(fromWords(bech32.decode(str).words));\n}\n\nfunction hexEncode(buf: number[]) {\n  let str = '';\n  for (let i = 0; i < buf.length; i++) {\n    const c = buf[i];\n    str += hexChar(c >> 4);\n    str += hexChar(c & 0xf);\n  }\n  return str;\n}\n", "function hexChar(val: number) {\n  if (val < 10) return String.fromCharCode(48 + val);\n  else return String.fromCharCode(97 + val - 10);\n}\n\nfunction fromWords(words: number[]) {\n  const res = convertbits(words, 5, 8, false);\n  if (Array.isArray(res)) return res;\n  throw new Error(res);\n}\n", "function convertbits(data: number[], inBits: number, outBits: number, pad: boolean) {\n  let value = 0;\n  let bits = 0;\n  const maxV = (1 << outBits) - 1;\n  const result = [];\n  for (let i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i];\n    bits += inBits;\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push((value >> bits) & maxV);\n    }\n  }", "    while (bits >= outBits) {\n      bits -= outBits;\n      result.push((value >> bits) & maxV);\n    }\n  }\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV);\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding';", "    if (bits >= inBits) return 'Excess padding';\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding';\n  }\n  return result;\n}\n\nexport function isValidHex(hex: string): boolean {\n  return /^[a-f0-9]{64}$/.test(hex);\n}\n"]}
{"filename": "src/lib/messaging.ts", "chunked_list": ["export const ext: ExtName = 'nostronger';\nexport function generateMessageId() {\n  return Math.floor(Math.random() * 1000000);\n}\n\nexport function wait<E, T>(\n  createListener: (resolve: (val: T) => void) => (event: E) => void,\n  params: {\n    addEventListener: (listener: (event: E) => void) => void;\n    removeEventListener: (listener: (event: E) => void) => void;\n    prepare?: () => void;\n    timeout?: number;\n  },\n) {\n  return new Promise<T>((resolve, reject) => {\n    const timeoutId = params.timeout\n      ? setTimeout(() => {\n          params.removeEventListener(listener);\n          reject('timed out');\n        })\n      : -1;\n\n    const listener = createListener((val) => {\n      clearTimeout(timeoutId);\n      params.removeEventListener(listener);\n      resolve(val);\n    });\n\n    params.addEventListener(listener);\n    params.prepare?.();\n  });\n}\n", "export function handleCrxRpcRequest(\n  msg: CrxRpcRequestMessage,\n  origin: CrxMessageOrigin,\n): { next?: CrxMessageOrigin; shouldBeHandled: boolean } {\n  if (msg.ext !== 'nostronger' || !('request' in msg.payload) || msg.path[0] !== origin) {\n    return {\n      shouldBeHandled: false,\n    };\n  }\n\n  msg.path.shift();\n  const next = msg.path[0];\n\n  return {\n    next,\n    shouldBeHandled: true,\n  };\n}\n"]}
{"filename": "src/lib/svelte-material-ui.ts", "chunked_list": ["import 'svelte-material-ui/bare.css';\nimport 'svelte-material-ui/themes/svelte.css';\nimport 'material-icons/iconfont/material-icons.css';\n"]}
{"filename": "src/lib/store.ts", "chunked_list": ["import { calcPubkey } from '../lib/nostr';\n\nconst LOCAL_STORAGE_KEY = {\n  KEY_PAIR: 'KEY_PAIR',\n  SIGN_POWER: 'SIGN_POWER',\n} as const;\n\nasync function get(key: string): Promise<any> {\n  const { [key]: val } = await chrome.storage.local.get(key);\n  return val;\n}\n", "async function set(key: string, val: any): Promise<void> {\n  await chrome.storage.local.set({ [key]: val });\n}\n\nexport async function getKeyPair(): Promise<KeyPair> {\n  const { seckey, pubkey } = await get(LOCAL_STORAGE_KEY.KEY_PAIR);\n  return { seckey, pubkey };\n}\n\nexport async function setKeyPair(seckey: string) {\n  const pubkey = await calcPubkey(seckey);\n  await set(LOCAL_STORAGE_KEY.KEY_PAIR, { seckey, pubkey });\n}\n", "export async function setKeyPair(seckey: string) {\n  const pubkey = await calcPubkey(seckey);\n  await set(LOCAL_STORAGE_KEY.KEY_PAIR, { seckey, pubkey });\n}\n\nexport async function getSignPower(): Promise<number> {\n  const signPower = (await get(LOCAL_STORAGE_KEY.SIGN_POWER)) ?? 0;\n  return Number(signPower) || 0;\n}\n\nexport async function setSignPower(signPower: number) {\n  await set(LOCAL_STORAGE_KEY.SIGN_POWER, signPower);\n}\n", "export async function setSignPower(signPower: number) {\n  await set(LOCAL_STORAGE_KEY.SIGN_POWER, signPower);\n}\n"]}
{"filename": "src/lib/ring-con.ts", "chunked_list": ["import { wait } from './messaging';\n\nexport async function getJoyconDevice() {\n  const [device] = await navigator.hid.requestDevice({\n    filters: [\n      {\n        vendorId: 0x057e, // Nintendo vendor ID\n        productId: 0x2007, // joy-con R\n      },\n    ],\n  });", "  if (!device) {\n    throw new Error('device not found.');\n  }\n\n  if (!device.opened) {\n    await device.open();\n  }\n\n  await setupJoycon(device);\n\n  return device;\n}\n", "export async function setupJoycon(joycon: HIDDevice) {\n  // set_input_report_mode_to_0x30\n  await communicate(joycon, [0x03, 0x30], [[14, 0x03]]);\n  // enabling_MCU_data_22_1\n  await communicate(\n    joycon,\n    [0x22, 0x01],\n    [\n      [13, 0x80],\n      [14, 0x22],\n    ],\n  );\n  // enabling_MCU_data_21_21_1_1\n  await communicate(\n    joycon,\n    [\n      0x21, 0x21, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3,\n    ],\n    [[14, 0x21]],\n  );\n  // get_ext_data_59\n  await communicate(\n    joycon,\n    [0x59],\n    [\n      [14, 0x59],\n      [16, 0x20],\n    ],\n  );\n  // get_ext_dev_in_format_config_5C\n  await communicate(\n    joycon,\n    [\n      0x5c, 0x06, 0x03, 0x25, 0x06, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x16, 0xed, 0x34, 0x36, 0x00,\n      0x00, 0x00, 0x0a, 0x64, 0x0b, 0xe6, 0xa9, 0x22, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x90, 0xa8, 0xe1, 0x34, 0x36,\n    ],\n    [[14, 0x5c]],\n  );\n  // start_external_polling_5A\n  await communicate(joycon, [0x5a, 0x04, 0x01, 0x01, 0x02], [[14, 0x5a]]);\n\n  // blink LED\n  await communicate(joycon, [0x30, 0x90], [[14, 0x30]]);\n}\n", "async function communicate(device: HIDDevice, subcommand: number[], expected: [number, number][]) {\n  await wait<HIDInputReportEvent, void>(\n    (resolve) => (event) => {\n      if (event.reportId !== 0x21) {\n        return;\n      }\n\n      const data = new Uint8Array(event.data.buffer);\n      if (expected.every(([pos, val]) => data[pos - 1] === val)) {\n        resolve();\n      }\n    },\n    {\n      addEventListener: (listener) => device.addEventListener('inputreport', listener),\n      removeEventListener: (listener) => device.removeEventListener('inputreport', listener),\n      prepare: () => {\n        device.sendReport(\n          0x01,\n          new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...subcommand]),\n        );\n      },\n      // timeout: 5000,\n    },\n  );\n}\n", "      if (expected.every(([pos, val]) => data[pos - 1] === val)) {\n        resolve();\n      }\n    },\n    {\n      addEventListener: (listener) => device.addEventListener('inputreport', listener),\n      removeEventListener: (listener) => device.removeEventListener('inputreport', listener),\n      prepare: () => {\n        device.sendReport(\n          0x01,\n          new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...subcommand]),\n        );\n      },\n      // timeout: 5000,\n    },\n  );\n}\n", "export async function getNextStrain(joycon: HIDDevice) {\n  return wait<HIDInputReportEvent, number>(\n    (resolve) => (event) => {\n      const strain = getStrain(event);\n      if (strain) {\n        resolve(strain);\n      }\n    },\n    {\n      addEventListener: (listener) => joycon.addEventListener('inputreport', listener),\n      removeEventListener: (listener) => joycon.removeEventListener('inputreport', listener),\n      // timeout: 5000,\n    },\n  );\n}\n", "export function getStrain(event: HIDInputReportEvent) {\n  if (event.reportId === 0x30) {\n    return new DataView(event.data.buffer, 38, 2).getInt16(0, true);\n  } else {\n    return null;\n  }\n}\n"]}
{"filename": "src/background/index.ts", "chunked_list": ["import { handleCrxRpcRequest } from '../lib/messaging';\nimport { signEvent } from '../lib/nostr';\nimport { getKeyPair, getSignPower, setSignPower } from '../lib/store';\n\n// * -> ...\nchrome.runtime.onMessage.addListener((msg: CrxRpcRequestMessage, sender, _sendResponse) => {\n  const { next, shouldBeHandled } = handleCrxRpcRequest(msg, 'background');\n  if (!shouldBeHandled) {\n    return;\n  }\n\n  const payload = msg.payload;\n", "  if (next === 'content' && payload.kind === 'leaveChargeMode') {\n    chrome.tabs.sendMessage(payload.request.senderTabId, msg);\n    return;\n  } else if (!!next) {\n    console.warn('Unexpected message', msg);\n    return;\n  }\n\n  const sendResponse = (val: any) => {\n    const res: CrxRpcResponseMessage = {\n      ...msg,\n      payload: {\n        kind: payload.kind,\n        response: val,\n      },\n    };\n    _sendResponse(res);\n  };\n\n  // ... -> HERE\n  switch (payload.kind) {\n    case 'getPubkey':\n      getKeyPair().then(({ pubkey }) => {\n        sendResponse(pubkey);\n      });\n      return true; // For async response\n    case 'signEvent':\n      getKeyPair().then(async (keypair) => {\n        const signed = await signEvent(keypair, payload.request);\n        sendResponse(signed);\n      });\n      return true;\n    case 'getSignPower':\n      getSignPower().then((power) => {\n        sendResponse(power);\n      });\n      return true;\n    case 'setSignPower':\n      setSignPower(payload.request.value).then(() => {\n        sendResponse(void 0);\n      });\n      return true;\n    case 'openChargeWindow':\n      chrome.windows\n        .create({\n          url: chrome.runtime.getURL('charge.html'),\n          type: 'popup',\n        })\n        .then((res) => {\n          const tabId = res.tabs?.[0].id;\n          sendResponse(tabId);\n        });\n      return true;\n    default:\n      break;\n  }\n});\n"]}
{"filename": "src/@types/common/index.d.ts", "chunked_list": ["// crx-rpc ------------------------------------------------\n\ntype ExtName = 'nostronger';\n\ntype CrxRpcMessage = CrxRpcRequestMessage | CrxRpcResponseMessage;\ninterface CrxRpcRequestMessage extends _CrxRpcMessageBase {\n  src: CrxMessageOrigin;\n  path: CrxMessageOrigin[];\n  payload: CrxRpcRequestPayload;\n}\ninterface CrxRpcResponseMessage extends _CrxRpcMessageBase {\n  payload: CrxRpcResponsePayload;\n}\n", "interface CrxRpcResponseMessage extends _CrxRpcMessageBase {\n  payload: CrxRpcResponsePayload;\n}\n\ninterface _CrxRpcMessageBase {\n  ext: ExtName;\n  messageId: number;\n}\n\ntype CrxMessageOrigin = 'nip07-provider' | 'content' | 'background' | 'charge';\n", "type CrxMessageOrigin = 'nip07-provider' | 'content' | 'background' | 'charge';\n\ntype CrxRpc =\n  | {\n      // possible paths:\n      // - 'nip07-provider' -> 'content' -> 'background'\n      kind: 'getPubkey';\n      request: {};\n      response: string;\n    }\n  | {\n      // possible paths:\n      // - 'nip07-provider' -> 'content' -> 'background'\n      kind: 'signEvent';\n      request: UnsignedEvent;\n      response: SignedEvent;\n    }\n  | {\n      // possible paths:\n      // - 'nip07-provider' -> 'content' -> 'background'\n      // - 'charge' -> 'background'\n      kind: 'getSignPower';\n      request: {};\n      response: number;\n    }\n  | {\n      // possible paths:\n      // - 'nip07-provider' -> 'content' -> 'background'\n      // - 'charge' -> 'background'\n      kind: 'setSignPower';\n      request: { value: number };\n      response: void;\n    }\n  | {\n      // possible paths:\n      // - 'nip07-provider' -> 'content'\n      kind: 'enterChargeMode';\n      request: {};\n      response: boolean;\n    }\n  | {\n      // possible paths:\n      // - 'content' -> 'background'\n      kind: 'openChargeWindow';\n      request: {};\n      response: number; // tabId\n    }\n  | {\n      // possible paths:\n      // - 'content' -> 'charge'\n      kind: 'sendStrain';\n      request: {\n        value: number;\n        neutral: number;\n      };\n      response: void;\n    }\n  | {\n      // possible paths:\n      // - 'charge' -> 'background' -> 'content'\n      kind: 'leaveChargeMode';\n      request: {\n        senderTabId: number;\n      };\n      response: void;\n    };\n", "type CrxRpcRequestPayload = _CrxRpcRequestPayload<CrxRpc>;\ntype CrxRpcResponsePayload = _CrxRpcResponsePayload<CrxRpc>;\ntype CrxRpcResponse<Req extends CrxRpcRequestPayload> = _CrxRpc<CrxRpc, Req['kind']>['response'];\n\ntype _CrxRpcRequestPayload<T extends CrxRpc> = T extends T ? Omit<T, 'response'> : never;\ntype _CrxRpcResponsePayload<T extends CrxRpc> = T extends T ? Omit<T, 'request'> : never;\ntype _CrxRpc<T extends CrxRpc, K extends CrxRpc['kind']> = T extends { kind: K } ? T : never;\n\n// nostr --------------------------------------------------\n\ninterface KeyPair {\n  seckey: string;\n  pubkey: string;\n}\n", "interface KeyPair {\n  seckey: string;\n  pubkey: string;\n}\n\ninterface UnsignedEvent {\n  kind: number;\n  tags: string[][];\n  content: string;\n  created_at: number;\n}\n", "interface SignedEvent extends UnsignedEvent {\n  id: string;\n  sig: string;\n  pubkey: string;\n}\n"]}
{"filename": "src/resource/nip07-provider.ts", "chunked_list": ["// Note that web accessible scripts cannot import or export because they must be compiled into a single file by tsc.\n\n(window as any).nostr = {\n  async getPublicKey(): Promise<string> {\n    return rpc(\n      {\n        kind: 'getPubkey',\n        request: {},\n      },\n      ['content', 'background'],", "      },\n      ['content', 'background'],\n    );\n  },\n  async signEvent(event: UnsignedEvent): Promise<SignedEvent | undefined> {\n    let signPower = await rpc(\n      {\n        kind: 'getSignPower',\n        request: {},\n      },", "        request: {},\n      },\n      ['content', 'background'],\n    );\n\n    if (signPower <= 0) {\n      await rpc(\n        {\n          kind: 'enterChargeMode',\n          request: {},\n        },\n        ['content'],\n      );\n      signPower = await rpc(\n        {\n          kind: 'getSignPower',\n          request: {},\n        },\n        ['content', 'background'],\n      );\n    }\n", "    if (signPower > 0) {\n      rpc(\n        {\n          kind: 'setSignPower',\n          request: { value: signPower - 1 },\n        },\n        ['content', 'background'],\n      );\n      return rpc(\n        {\n          kind: 'signEvent',\n          request: event,\n        },\n        ['content', 'background'],\n      );\n    }\n  },\n};\n\nconst ext: ExtName = 'nostronger';\n", "function rpc<T extends CrxRpcRequestPayload>(\n  req: T,\n  path: CrxMessageOrigin[],\n  timeout?: number,\n): Promise<CrxRpcResponse<T>> {\n  return new Promise((resolve, reject) => {\n    const messageId = Math.floor(Math.random() * 1000000);\n    const message: CrxRpcRequestMessage = {\n      ext,\n      messageId,\n      src: 'nip07-provider',\n      path,\n      payload: req,\n    };\n\n    window.addEventListener('message', listener);\n    window.postMessage(message, '*');\n\n    const timeoutId = timeout\n      ? setTimeout(() => {\n          window.removeEventListener('message', listener);\n          reject(`Request \\`${req.kind}\\` timed out`);\n        }, timeout)\n      : -1;\n", "    function listener(ev: MessageEvent<CrxRpcResponseMessage>) {\n      const data = ev.data;\n      if (\n        data.ext !== 'nostronger' ||\n        data.messageId !== messageId ||\n        data.payload.kind !== req.kind ||\n        !('response' in data.payload)\n      ) {\n        return;\n      }\n\n      // Assumed by `data.payload.kind !== req.kind`\n      const response = data.payload.response as CrxRpcResponse<T> | PromiseLike<CrxRpcResponse<T>>;\n\n      window.removeEventListener('message', listener);\n      clearInterval(timeoutId);\n      resolve(response);\n    }\n  });\n}\n"]}
{"filename": "src/content/index.ts", "chunked_list": ["import { ext, generateMessageId, handleCrxRpcRequest, wait } from '../lib/messaging';\nimport { getJoyconDevice, getNextStrain, getStrain, setupJoycon } from '../lib/ring-con';\n\ninjectResourceScript('js/nip07-provider.js');\n\n// 'nip07-provider' -> ...\nwindow.addEventListener('message', async ({ data }: MessageEvent<CrxRpcRequestMessage>) => {\n  const { next, shouldBeHandled } = handleCrxRpcRequest(data, 'content');\n  if (!shouldBeHandled) {\n    return;\n  }\n", "  if (!shouldBeHandled) {\n    return;\n  }\n\n  if (next === 'background') {\n    // ... -> HERE -> 'background'\n    const response: CrxRpcResponseMessage = await chrome.runtime.sendMessage(data);\n    window.postMessage(response);\n    return;\n  } else if (!!next) {\n    console.warn('Unexpected message', data);\n    return;\n  }\n\n  //...  -> HERE\n  switch (data.payload.kind) {\n    case 'enterChargeMode':\n      {", "  } else if (!!next) {\n    console.warn('Unexpected message', data);\n    return;\n  }\n\n  //...  -> HERE\n  switch (data.payload.kind) {\n    case 'enterChargeMode':\n      {\n        try {\n          const response = await enterChargeMode(data);\n          window.postMessage(response);", "        try {\n          const response = await enterChargeMode(data);\n          window.postMessage(response);\n        } catch (err) {\n          console.error(err);\n          window.postMessage({\n            ext,\n            messageId: data.messageId,\n            payload: {\n              kind: 'enterChargeMode',\n              response: false,\n            },\n          });\n          throw err;\n        }\n      }\n      break;\n    default:\n      break;\n  }\n});\n", "async function enterChargeMode({\n  messageId,\n  payload,\n}: CrxRpcRequestMessage): Promise<CrxRpcResponseMessage> {\n  if (payload.kind !== 'enterChargeMode') {\n    throw 'Unexpected message';\n  }\n\n  const openChargeWindowReq: CrxRpcMessage = {\n    ext,\n    messageId: generateMessageId(),\n    src: 'content',\n    path: ['background'],\n    payload: {\n      kind: 'openChargeWindow',\n      request: {},\n    },\n  };\n  const { payload: result }: CrxRpcResponseMessage = await chrome.runtime.sendMessage(\n    openChargeWindowReq,\n  );\n", "  if (result.kind !== 'openChargeWindow') {\n    throw 'Unexpected message';\n  }\n\n  // Keep sending strain signals.\n  const joycon = await getJoyconDevice();\n  await setupJoycon(joycon);\n  const neutral = await getNextStrain(joycon);\n  const sendStrain = (value: number) => {\n    const req: CrxRpcMessage = {\n      ext,\n      messageId: generateMessageId(),\n      src: 'content',\n      path: ['charge'],\n      payload: {\n        kind: 'sendStrain',\n        request: {\n          value,\n          neutral,\n        },\n      },\n    };\n    chrome.runtime.sendMessage(req);\n  };\n  const reportListener = (ev: HIDInputReportEvent) => {\n    const value = getStrain(ev);", "    if (value) {\n      sendStrain(value);\n    }\n  };\n  joycon.addEventListener('inputreport', reportListener);\n\n  // Wait for `leaveChargeMode` signal.\n  await wait<CrxRpcRequestMessage, void>(\n    (resolve) => (msg) => {\n      const { next, shouldBeHandled } = handleCrxRpcRequest(msg, 'content');\n      if (!shouldBeHandled) {\n        return;\n      }", "      if (!shouldBeHandled) {\n        return;\n      }\n      if (!!next) {\n        console.warn('Unexpected message', msg);\n        return;\n      }\n      if (msg.payload.kind === 'leaveChargeMode') {\n        resolve();\n      }\n    },\n    {\n      addEventListener: (listener) => {\n        chrome.runtime.onMessage.addListener(listener);\n      },\n      removeEventListener: (listener) => {\n        chrome.runtime.onMessage.removeListener(listener);\n      },\n    },\n  );\n\n  // Stop sending strain signals.\n  joycon.removeEventListener('inputreport', reportListener);\n\n  return {\n    ext,\n    messageId,\n    payload: {\n      kind: 'enterChargeMode',\n      response: true,\n    },\n  };\n}\n", "function injectResourceScript(path: string) {\n  const script = document.createElement('script');\n  script.setAttribute('async', 'false');\n  script.setAttribute('type', 'text/javascript');\n  script.setAttribute('src', chrome.runtime.getURL(path));\n  document.head.appendChild(script);\n}\n"]}
