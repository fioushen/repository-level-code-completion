{"filename": "index.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport { Compiler } from './src/compiler/main.js'", "\nexport { Compiler } from './src/compiler/main.js'\nexport { refsBuilder } from './src/refs_builder.js'\n"]}
{"filename": "bin/test.ts", "chunked_list": ["import { AssertionError } from 'node:assert'\nimport { assert, Assert } from '@japa/assert'\nimport { processCLIArgs, configure, run } from '@japa/runner'\nimport { beautifyCode } from '../factories/code_beautifier.js'\n\nAssert.macro('assertFormatted', function assertFormatted(this: Assert, actual, expected) {\n  try {\n    this.deepEqual(beautifyCode(actual).toArray(), beautifyCode(expected).toArray())\n  } catch (error) {\n    throw new AssertionError({\n      message: error.message,\n      actual: error.actual,\n      expected: error.expected,\n      stackStartFn: assertFormatted,\n    })\n  }\n})\n\n/*\n|--------------------------------------------------------------------------\n| Configure tests\n|--------------------------------------------------------------------------\n|\n| The configure method accepts the configuration to configure the Japa\n| tests runner.\n|\n| The first method call \"processCliArgs\" process the command line arguments\n| and turns them into a config object. Using this method is not mandatory.\n|\n| Please consult japa.dev/runner-config for the config docs.\n*/\nprocessCLIArgs(process.argv.slice(2))\nconfigure({\n  plugins: [assert()],\n  suites: [\n    {\n      name: 'unit',\n      files: ['tests/unit/**/*.spec.ts'],\n    },\n    {\n      name: 'integration',\n      files: ['tests/integration/**/*.spec.ts'],\n    },\n  ],\n})\n\n/*\n|--------------------------------------------------------------------------\n| Run tests\n|--------------------------------------------------------------------------\n|\n| The following \"run\" method is required to execute all the tests.\n|\n*/\nrun()\n", "  } catch (error) {\n    throw new AssertionError({\n      message: error.message,\n      actual: error.actual,\n      expected: error.expected,\n      stackStartFn: assertFormatted,\n    })\n  }\n})\n\n/*\n|--------------------------------------------------------------------------\n| Configure tests\n|--------------------------------------------------------------------------\n|\n| The configure method accepts the configuration to configure the Japa\n| tests runner.\n|\n| The first method call \"processCliArgs\" process the command line arguments\n| and turns them into a config object. Using this method is not mandatory.\n|\n| Please consult japa.dev/runner-config for the config docs.\n*/\nprocessCLIArgs(process.argv.slice(2))\nconfigure({\n  plugins: [assert()],\n  suites: [\n    {\n      name: 'unit',\n      files: ['tests/unit/**/*.spec.ts'],\n    },\n    {\n      name: 'integration',\n      files: ['tests/integration/**/*.spec.ts'],\n    },\n  ],\n})\n\n/*\n|--------------------------------------------------------------------------\n| Run tests\n|--------------------------------------------------------------------------\n|\n| The following \"run\" method is required to execute all the tests.\n|\n*/\nrun()\n"]}
{"filename": "bin/japa_types.ts", "chunked_list": ["import '@japa/assert'\n\ndeclare module '@japa/assert' {\n  interface Assert {\n    assertFormatted(actual: string | string[], expected: string | string[]): void\n  }\n}\n"]}
{"filename": "tests/integration/compiler/object_node.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '../../../index.js'\nimport { ValidationRule } from '../../../src/types.js'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ntest.group('Object node', () => {\n  test('process an object field', async ({ assert }) => {", "test.group('Object node', () => {\n  test('process an object field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '',\n        validations: [],", "        fieldName: '',\n        validations: [],\n        propertyName: '',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n", "    })\n\n    const data: any = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)", "    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n\n    // Mutation test:\n    data.profile = {}\n    assert.deepEqual(output, {})\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {", "\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,", "        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },", "        properties: [],\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow non-object values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid object'])\n    }\n  })\n\n  test('ignore object properties when children nodes are not defined', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = { username: 'virk', age: 34 }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n\n    // Mutation test:\n    data.age = 22\n    assert.deepEqual(output, {})\n  })\n\n  test('validate object children', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'age',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'age',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required', 'value is required'])\n    }\n  })\n\n  test('process children nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'age',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'age',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = { username: 'virk', age: 34 }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, { userName: 'virk', age: 34 })\n\n    // Mutation test:\n    data.age = 22\n    assert.deepEqual(output, { userName: 'virk', age: 34 })\n  })\n\n  test('process nested object nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'object',\n            groups: [],\n            bail: true,\n            fieldName: 'social',\n            validations: [],\n            propertyName: 'social',\n            allowNull: false,\n            isOptional: false,\n            allowUnknownProperties: false,\n            properties: [\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: 'twitter_handle',\n                allowNull: false,\n                isOptional: false,\n                propertyName: 'twitterHandle',\n                validations: [],\n              },\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: 'github_username',\n                allowNull: false,\n                isOptional: false,\n                propertyName: 'githubUsername',\n                validations: [],\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data = {\n      social: {\n        github_username: 'thetutlage',\n        twitter_handle: 'AmanVirk1',\n      },\n    }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {\n      social: {\n        githubUsername: 'thetutlage',\n        twitterHandle: 'AmanVirk1',\n      },\n    })\n\n    // Mutation test:\n    data.social.github_username = 'foo'\n    assert.deepEqual(output, {\n      social: {\n        githubUsername: 'thetutlage',\n        twitterHandle: 'AmanVirk1',\n      },\n    })\n  })\n\n  test('run object validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowUnknownProperties: false,\n        allowNull: false,\n        isOptional: false,\n        properties: [],\n      },\n    })\n\n    const data = {}\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, {})\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, {})\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n  })\n\n  test('stop validations after first error', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowUnknownProperties: false,\n        allowNull: false,\n        isOptional: false,\n        properties: [],\n      },\n    })\n\n    const data = {}\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, {})\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n    assert.plan(8)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowUnknownProperties: false,\n        allowNull: false,\n        isOptional: false,\n        properties: [],\n      },\n    })\n\n    const data = {}\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, {})\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, {})\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: false,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('do not process children when object is invalid', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'age',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'age',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data = { username: 'virk', age: 34 }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { username: 'virk', age: 34 })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('process children for invalid object when bail mode is disabled', async ({ assert }) => {\n    assert.plan(11)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'age',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'age',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data = { username: 'virk', age: 34 }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { username: 'virk', age: 34 })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {", "          if (field.name === 'username') {\n            assert.equal(value, 'virk')\n            assert.isUndefined(options)\n            assert.containsSubset(field, {\n              name: 'username',\n              wildCardPath: 'username',\n              isArrayMember: false,\n              isValid: true,\n              meta: {},\n              parent: { username: 'virk', age: 34 },\n              data,\n            })\n          } else {\n            assert.equal(value, 34)\n            assert.isUndefined(options)\n            assert.containsSubset(field, {\n              name: 'age',\n              wildCardPath: 'age',\n              isArrayMember: false,\n              isValid: true,\n              meta: {},\n              parent: { username: 'virk', age: 34 },\n              data,\n            })\n          }\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('process object groups', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [\n          {\n            type: 'group',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://1',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'username',\n                      propertyName: 'username',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://2',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'email',\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        ],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data: any = {\n      username: 'virk',\n    }\n    const meta = {}\n    const refs = {\n      'ref://1': () => true,\n      'ref://2': () => false,\n    }\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, { username: 'virk' })\n\n    // Mutation test:\n    data.username = 'foo'\n    assert.deepEqual(output, { username: 'virk' })\n  })\n\n  test('allow unknowProperties when object groups are defined', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [\n          {\n            type: 'group',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://1',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'username',\n                      propertyName: 'userName',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://2',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'email',\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        ],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [],\n      },\n    })\n\n    const data: any = {\n      username: 'virk',\n      foo: 'bar',\n      baz: 'bam',\n    }\n    const meta = {}\n    const refs = {\n      'ref://1': () => true,\n      'ref://2': () => false,\n    }\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, { userName: 'virk', foo: 'bar', baz: 'bam' })\n\n    // Mutation test:\n    data.username = 'foo'\n    assert.deepEqual(output, { userName: 'virk', foo: 'bar', baz: 'bam' })\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'object',\n          groups: [],\n          bail: true,\n          fieldName: '',\n          validations: [],\n          propertyName: '',\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          properties: [],\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('call parse fn', async ({ assert }) => {\n    assert.plan(3)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '',\n        validations: [],\n        propertyName: '',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        parseFnId: 'ref://1',\n        properties: [],\n      },\n    })\n\n    const data: any = {}\n    const meta = {}\n\n    const refs = refsBuilder()\n    refs.trackParser((value) => {\n      assert.deepEqual(value, {})\n      return value\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n\n    // Mutation test:\n    data.profile = {}\n    assert.deepEqual(output, {})\n  })\n})\n\ntest.group('Object node | optional: true', () => {\n  test('process an object field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n  })\n\n  test('allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('dis-allow non-object values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid object'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'object',\n          groups: [],\n          bail: true,\n          fieldName: '',\n          validations: [],\n          propertyName: '',\n          allowNull: false,\n          isOptional: true,\n          allowUnknownProperties: false,\n          properties: [],\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n})\n\ntest.group('Object node | allowNull: true', () => {\n  test('process an object field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, null)\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow non-object values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid object'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'object',\n          groups: [],\n          bail: true,\n          fieldName: '',\n          validations: [],\n          propertyName: '',\n          allowNull: true,\n          isOptional: false,\n          allowUnknownProperties: false,\n          properties: [],\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isNull(output)\n  })\n})\n\ntest.group('Object node | allowUnknownProperties', () => {\n  test('keep object properties when unknown properties are allowed', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [],\n      },\n    })\n\n    const data = { username: 'virk', age: 34 }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, { username: 'virk', age: 34 })\n\n    // Mutation test:\n    data.age = 22\n    assert.deepEqual(output, { username: 'virk', age: 34 })\n  })\n\n  test('validate known properties when unknown properties are allowed', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = { age: 34 }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('process known properties when unknown properties are allowed', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: 'username',\n            allowNull: false,\n            isOptional: false,\n            propertyName: 'userName',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = { username: 'virk', age: 34 }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {\n      userName: 'virk',\n      age: 34,\n    })\n\n    // Mutation test:\n    data.age = 22\n    assert.deepEqual(output, {\n      userName: 'virk',\n      age: 34,\n    })\n  })\n\n  test('allow unknown properties with nested object', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [\n          {\n            type: 'object',\n            groups: [],\n            bail: true,\n            fieldName: 'social',\n            validations: [],\n            propertyName: 'social',\n            allowNull: false,\n            isOptional: false,\n            allowUnknownProperties: true,\n            properties: [\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: 'twitter_handle',\n                allowNull: false,\n                isOptional: false,\n                propertyName: 'twitterHandle',\n                validations: [],\n              },\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: 'github_username',\n                allowNull: false,\n                isOptional: false,\n                propertyName: 'githubUsername',\n                validations: [],\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data = {\n      social: {\n        github_username: 'thetutlage',\n        twitter_handle: 'AmanVirk1',\n        soundcloud_account: 'foobar',\n      },\n      username: 'foo',\n    }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {\n      social: {\n        githubUsername: 'thetutlage',\n        soundcloud_account: 'foobar',\n        twitterHandle: 'AmanVirk1',\n      },\n      username: 'foo',\n    })\n\n    // Mutation test:\n    data.social.github_username = 'foo'\n    data.username = 'bar'\n    assert.deepEqual(output, {\n      social: {\n        githubUsername: 'thetutlage',\n        soundcloud_account: 'foobar',\n        twitterHandle: 'AmanVirk1',\n      },\n      username: 'foo',\n    })\n  })\n})\n"]}
{"filename": "tests/integration/compiler/union_node.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Refs } from '../../../src/types.js'\nimport { refsBuilder } from '../../../index.js'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ntest.group('Union node', () => {\n  test('create a union of literal values', async ({ assert }) => {", "test.group('Union node', () => {\n  test('create a union of literal values', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {", "        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'literal',\n              bail: true,\n              fieldName: 'uid',\n              propertyName: 'uid',\n              allowNull: false,\n              isOptional: false,", "              allowNull: false,\n              isOptional: false,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },", "              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'literal',\n              bail: true,\n              fieldName: 'uid',\n              propertyName: 'uid',", "              fieldName: 'uid',\n              propertyName: 'uid',\n              allowNull: false,\n              isOptional: false,\n              validations: [],\n            },\n          },\n        ],\n      },\n    })", "      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n      'ref://3': {", "      'ref://2': () => true,\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()", "    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), 'virk')\n  })\n\n  test('create a union of objects', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {", "            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'object',\n              groups: [],\n              bail: true,\n              fieldName: 'profile',\n              validations: [],\n              propertyName: 'profile',\n              allowNull: false,\n              isOptional: false,", "              allowNull: false,\n              isOptional: false,\n              allowUnknownProperties: false,\n              properties: [\n                {\n                  type: 'literal',\n                  bail: true,\n                  fieldName: 'username',\n                  allowNull: false,\n                  isOptional: false,", "                  allowNull: false,\n                  isOptional: false,\n                  propertyName: 'userName',\n                  validations: [],\n                },\n                {\n                  type: 'literal',\n                  bail: true,\n                  fieldName: 'age',\n                  allowNull: false,", "                  fieldName: 'age',\n                  allowNull: false,\n                  isOptional: false,\n                  propertyName: 'age',\n                  validations: [],\n                },\n              ],\n            },\n          },\n          {", "          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'object',\n              groups: [],\n              bail: true,\n              fieldName: 'profile',\n              validations: [],\n              propertyName: 'profile',", "              validations: [],\n              propertyName: 'profile',\n              allowNull: false,\n              isOptional: false,\n              allowUnknownProperties: false,\n              properties: [\n                {\n                  type: 'literal',\n                  bail: true,\n                  fieldName: 'email',", "                  bail: true,\n                  fieldName: 'email',\n                  allowNull: false,\n                  isOptional: false,\n                  propertyName: 'email',\n                  validations: [],\n                },\n              ],\n            },\n          },", "            },\n          },\n        ],\n      },\n    })\n\n    const data = { email: 'foo@bar.com' }\n    const meta = {}\n\n    const refs = {", "\n    const refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n      email: 'foo@bar.com',\n    })\n  })\n\n  test('create a union of arrays', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {", "            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'array',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              each: {", "              isOptional: false,\n              each: {\n                type: 'object',\n                groups: [],\n                allowNull: false,\n                allowUnknownProperties: false,\n                bail: false,\n                fieldName: '*',\n                isOptional: false,\n                propertyName: '*',", "                isOptional: false,\n                propertyName: '*',\n                validations: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    bail: true,\n                    fieldName: 'email',\n                    allowNull: false,\n                    isOptional: false,", "                    allowNull: false,\n                    isOptional: false,\n                    propertyName: 'email',\n                    validations: [],\n                  },\n                ],\n              },\n            },\n          },\n          {", "          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'array',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,", "              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              each: {\n                type: 'object',\n                groups: [],\n                allowNull: false,\n                allowUnknownProperties: false,\n                bail: false,\n                fieldName: '*',", "                bail: false,\n                fieldName: '*',\n                isOptional: false,\n                propertyName: '*',\n                validations: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    bail: true,\n                    fieldName: 'phone',", "                    bail: true,\n                    fieldName: 'phone',\n                    allowNull: false,\n                    isOptional: false,\n                    propertyName: 'phone',\n                    validations: [],\n                  },\n                ],\n              },\n            },", "              },\n            },\n          },\n        ],\n      },\n    })\n\n    const data = [{ phone: '123456789' }]\n    const meta = {}\n", "    const meta = {}\n\n    const refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), [\n      { phone: '123456789' },\n    ])\n  })\n\n  test('create a union of unions', async ({ assert }) => {\n    const compiler = new Compiler({", "  test('create a union of unions', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',", "          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'union',\n              fieldName: '*',\n              propertyName: '*',\n              conditions: [\n                {\n                  conditionalFnRefId: 'ref://3',\n                  schema: {", "                  conditionalFnRefId: 'ref://3',\n                  schema: {\n                    type: 'object',\n                    groups: [],\n                    allowNull: false,\n                    allowUnknownProperties: false,\n                    bail: true,\n                    validations: [],\n                    fieldName: '*',\n                    propertyName: '*',", "                    fieldName: '*',\n                    propertyName: '*',\n                    isOptional: false,\n                    properties: [\n                      {\n                        type: 'literal',\n                        fieldName: 'twitter_handle',\n                        allowNull: false,\n                        isOptional: false,\n                        bail: true,", "                        isOptional: false,\n                        bail: true,\n                        propertyName: 'twitter_handle',\n                        validations: [],\n                      },\n                    ],\n                  },\n                },\n                {\n                  conditionalFnRefId: 'ref://4',", "                {\n                  conditionalFnRefId: 'ref://4',\n                  schema: {\n                    type: 'object',\n                    groups: [],\n                    allowNull: false,\n                    allowUnknownProperties: false,\n                    bail: true,\n                    validations: [],\n                    fieldName: '*',", "                    validations: [],\n                    fieldName: '*',\n                    propertyName: '*',\n                    isOptional: false,\n                    properties: [\n                      {\n                        type: 'literal',\n                        fieldName: 'github_username',\n                        allowNull: false,\n                        isOptional: false,", "                        allowNull: false,\n                        isOptional: false,\n                        bail: true,\n                        propertyName: 'github_username',\n                        validations: [],\n                      },\n                    ],\n                  },\n                },\n              ],", "                },\n              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'union',\n              fieldName: '*',\n              propertyName: '*',", "              fieldName: '*',\n              propertyName: '*',\n              conditions: [\n                {\n                  conditionalFnRefId: 'ref://5',\n                  schema: {\n                    type: 'object',\n                    groups: [],\n                    allowNull: false,\n                    allowUnknownProperties: false,", "                    allowNull: false,\n                    allowUnknownProperties: false,\n                    bail: true,\n                    validations: [],\n                    fieldName: '*',\n                    propertyName: '*',\n                    isOptional: false,\n                    properties: [\n                      {\n                        type: 'literal',", "                      {\n                        type: 'literal',\n                        fieldName: 'email',\n                        allowNull: false,\n                        isOptional: false,\n                        bail: true,\n                        propertyName: 'email',\n                        validations: [],\n                      },\n                    ],", "                      },\n                    ],\n                  },\n                },\n                {\n                  conditionalFnRefId: 'ref://6',\n                  schema: {\n                    type: 'object',\n                    groups: [],\n                    allowNull: false,", "                    groups: [],\n                    allowNull: false,\n                    allowUnknownProperties: false,\n                    bail: true,\n                    validations: [],\n                    fieldName: '*',\n                    propertyName: '*',\n                    isOptional: false,\n                    properties: [\n                      {", "                    properties: [\n                      {\n                        type: 'literal',\n                        fieldName: 'phone',\n                        allowNull: false,\n                        isOptional: false,\n                        bail: true,\n                        propertyName: 'phone',\n                        validations: [],\n                      },", "                        validations: [],\n                      },\n                    ],\n                  },\n                },\n              ],\n            },\n          },\n        ],\n      },", "        ],\n      },\n    })\n\n    const data = {\n      email: 'foo@bar.com',\n    }\n    const meta = {}\n\n    const refs = {", "\n    const refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n      'ref://3': () => false,\n      'ref://4': () => false,\n      'ref://5': () => true,\n      'ref://6': () => false,\n    }\n", "    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n      email: 'foo@bar.com',\n    })\n  })", "    })\n  })\n\n  test('create a union of records', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'record',\n              bail: true,\n              fieldName: '*',\n              validations: [],", "              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              each: {\n                type: 'literal',\n                bail: true,\n                fieldName: '*',\n                allowNull: false,", "                fieldName: '*',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '*',\n                validations: [],\n              },\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',", "          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'record',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,", "              allowNull: false,\n              isOptional: false,\n              each: {\n                type: 'literal',\n                bail: true,\n                fieldName: '*',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '*',\n                validations: [],", "                propertyName: '*',\n                validations: [],\n                transformFnId: 'ref://3',\n              },\n            },\n          },\n        ],\n      },\n    })\n", "    })\n\n    const data = { white: '#ffffff', black: '#000000' }\n    const meta = {}\n\n    const refs: Refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n      'ref://3': (hex: unknown) => {\n        if (typeof hex === 'string') {\n          const r = Number.parseInt(hex.slice(1, 3), 16)\n          const g = Number.parseInt(hex.slice(3, 5), 16)\n          const b = Number.parseInt(hex.slice(5, 7), 16)\n          return { r, g, b }\n        }\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n      white: { r: 255, g: 255, b: 255 },\n      black: { r: 0, g: 0, b: 0 },\n    })\n  })\n\n  test('create a union of tuples', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'tuple',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              allowUnknownProperties: false,\n              properties: [\n                {\n                  type: 'object',\n                  groups: [],\n                  allowNull: false,\n                  allowUnknownProperties: false,\n                  bail: false,\n                  fieldName: '0',\n                  isOptional: false,\n                  propertyName: '0',\n                  validations: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      bail: true,\n                      fieldName: 'email',\n                      allowNull: false,\n                      isOptional: false,\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'tuple',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              allowUnknownProperties: false,\n              properties: [\n                {\n                  type: 'object',\n                  groups: [],\n                  allowNull: false,\n                  allowUnknownProperties: false,\n                  bail: false,\n                  fieldName: '0',\n                  isOptional: false,\n                  propertyName: '0',\n                  validations: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      bail: true,\n                      fieldName: 'phone',\n                      allowNull: false,\n                      isOptional: false,\n                      propertyName: 'phone',\n                      validations: [],\n                    },\n                  ],\n                },\n              ],\n            },\n          },\n        ],\n      },\n    })\n\n    const data = [{ phone: '123456789' }]\n    const meta = {}\n\n    const refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), [\n      { phone: '123456789' },\n    ])\n  })\n\n  test('call parse function', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'literal',\n              bail: true,\n              fieldName: 'uid',\n              propertyName: 'uid',\n              allowNull: false,\n              isOptional: false,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://4',\n                },\n              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'literal',\n              bail: true,\n              fieldName: 'uid',\n              propertyName: 'uid',\n              parseFnId: 'ref://3',\n              allowNull: false,\n              isOptional: false,\n              validations: [],\n            },\n          },\n        ],\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs = refsBuilder()\n    refs.trackConditional(() => false)\n    refs.trackConditional(() => true)\n    refs.trackParser((value) => {\n      return typeof value === 'string' ? value.toUpperCase() : value\n    })\n    refs.trackValidation({\n      validator() {\n        throw new Error('Never expected to be called')\n      },\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter), 'VIRK')\n  })\n})\n", "      'ref://3': (hex: unknown) => {\n        if (typeof hex === 'string') {\n          const r = Number.parseInt(hex.slice(1, 3), 16)\n          const g = Number.parseInt(hex.slice(3, 5), 16)\n          const b = Number.parseInt(hex.slice(5, 7), 16)\n          return { r, g, b }\n        }\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n      white: { r: 255, g: 255, b: 255 },\n      black: { r: 0, g: 0, b: 0 },\n    })\n  })\n\n  test('create a union of tuples', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'tuple',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              allowUnknownProperties: false,\n              properties: [\n                {\n                  type: 'object',\n                  groups: [],\n                  allowNull: false,\n                  allowUnknownProperties: false,\n                  bail: false,\n                  fieldName: '0',\n                  isOptional: false,\n                  propertyName: '0',\n                  validations: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      bail: true,\n                      fieldName: 'email',\n                      allowNull: false,\n                      isOptional: false,\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'tuple',\n              bail: true,\n              fieldName: '*',\n              validations: [],\n              propertyName: '*',\n              allowNull: false,\n              isOptional: false,\n              allowUnknownProperties: false,\n              properties: [\n                {\n                  type: 'object',\n                  groups: [],\n                  allowNull: false,\n                  allowUnknownProperties: false,\n                  bail: false,\n                  fieldName: '0',\n                  isOptional: false,\n                  propertyName: '0',\n                  validations: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      bail: true,\n                      fieldName: 'phone',\n                      allowNull: false,\n                      isOptional: false,\n                      propertyName: 'phone',\n                      validations: [],\n                    },\n                  ],\n                },\n              ],\n            },\n          },\n        ],\n      },\n    })\n\n    const data = [{ phone: '123456789' }]\n    const meta = {}\n\n    const refs = {\n      'ref://1': () => false,\n      'ref://2': () => true,\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), [\n      { phone: '123456789' },\n    ])\n  })\n\n  test('call parse function', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'literal',\n              bail: true,\n              fieldName: 'uid',\n              propertyName: 'uid',\n              allowNull: false,\n              isOptional: false,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://4',\n                },\n              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'literal',\n              bail: true,\n              fieldName: 'uid',\n              propertyName: 'uid',\n              parseFnId: 'ref://3',\n              allowNull: false,\n              isOptional: false,\n              validations: [],\n            },\n          },\n        ],\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs = refsBuilder()\n    refs.trackConditional(() => false)\n    refs.trackConditional(() => true)\n    refs.trackParser((value) => {\n      return typeof value === 'string' ? value.toUpperCase() : value\n    })\n    refs.trackValidation({\n      validator() {\n        throw new Error('Never expected to be called')\n      },\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter), 'VIRK')\n  })\n})\n"]}
{"filename": "tests/integration/compiler/tuple_node.spec.ts", "chunked_list": ["/*\n * @adonisjs/validator\n *\n * (c) Validator\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '../../../index.js'\nimport { ValidationRule } from '../../../src/types.js'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ntest.group('Tuple node', () => {\n  test('process children nodes', async ({ assert }) => {", "test.group('Tuple node', () => {\n  test('process children nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',", "        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',", "            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,", "            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },", "        ],\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })", "    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',", "        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },", "            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()", "    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow non-array values', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid array'])\n    }\n  })\n\n  test('ignore additional array items', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '',\n        validations: [],\n        propertyName: '',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world'])\n  })\n\n  test('keep additional array items when unknown properties are allowed', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n\n  test('process nested children nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'tuple',\n            bail: true,\n            fieldName: '0',\n            validations: [],\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            allowUnknownProperties: false,\n            properties: [\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '0',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '0',\n                validations: [],\n              },\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '1',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '1',\n                validations: [],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            bail: true,\n            fieldName: '1',\n            validations: [],\n            propertyName: '1',\n            allowNull: false,\n            isOptional: false,\n            allowUnknownProperties: false,\n            properties: [\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '0',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '0',\n                validations: [],\n              },\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '1',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '1',\n                validations: [],\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data = [\n      ['hello world', 'hi world'],\n      ['hi world', 'hello world'],\n    ]\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [\n      ['hello world', 'hi world'],\n      ['hi world', 'hello world'],\n    ])\n\n    // Mutation test\n    data[0][0] = 'foo'\n    assert.deepEqual(output, [\n      ['hello world', 'hi world'],\n      ['hi world', 'hello world'],\n    ])\n  })\n\n  test('allow unknown properties in nested tuple', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: true,\n        properties: [\n          {\n            type: 'tuple',\n            bail: true,\n            fieldName: '0',\n            validations: [],\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            allowUnknownProperties: true,\n            properties: [\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '0',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '0',\n                validations: [],\n              },\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '1',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '1',\n                validations: [],\n              },\n            ],\n          },\n          {\n            type: 'tuple',\n            bail: true,\n            fieldName: '1',\n            validations: [],\n            propertyName: '1',\n            allowNull: false,\n            isOptional: false,\n            allowUnknownProperties: true,\n            properties: [\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '0',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '0',\n                validations: [],\n              },\n              {\n                type: 'literal',\n                bail: true,\n                fieldName: '1',\n                allowNull: false,\n                isOptional: false,\n                propertyName: '1',\n                validations: [],\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data = [\n      ['hello world', 'hi world', 'foo bar'],\n      ['hi world', 'hello world', 'foo bar'],\n      ['hi world', 'hello world', 'foo bar'],\n    ]\n\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [\n      ['hello world', 'hi world', 'foo bar'],\n      ['hi world', 'hello world', 'foo bar'],\n      ['hi world', 'hello world', 'foo bar'],\n    ])\n\n    // Mutation test\n    data[0][0] = 'foo'\n    assert.deepEqual(output, [\n      ['hello world', 'hi world', 'foo bar'],\n      ['hi world', 'hello world', 'foo bar'],\n      ['hi world', 'hello world', 'foo bar'],\n    ])\n  })\n\n  test('run array validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data: any[] = []\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, [])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, [])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [])\n  })\n\n  test('stop validation after first error', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data: any[] = []\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, [])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n    assert.plan(8)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [],\n      },\n    })\n\n    const data: any[] = []\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, [])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, [])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: false,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('do not process properties when array is invalid', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data: any[] = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('process properties of invalid array when bail mode is disabled', async ({ assert }) => {\n    assert.plan(11)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [\n              {\n                ruleFnId: 'ref://3',\n                implicit: false,\n                isAsync: false,\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    const data: any[] = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {", "          if (field.name === 0) {\n            assert.equal(value, 'hello world')\n            assert.isUndefined(options)\n            assert.containsSubset(field, {\n              name: 0,\n              wildCardPath: '0',\n              isArrayMember: true,\n              isValid: true,\n              meta: {},\n              parent: ['hello world', 'hi world'],\n              data,\n            })\n          } else {\n            assert.equal(value, 'hi world')\n            assert.isUndefined(options)\n            assert.containsSubset(field, {\n              name: 1,\n              wildCardPath: '1',\n              isArrayMember: true,\n              isValid: true,\n              meta: {},\n              parent: ['hello world', 'hi world'],\n              data,\n            })\n          }\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'tuple',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          properties: [\n            {\n              type: 'literal',\n              bail: true,\n              fieldName: '0',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '0',\n              validations: [],\n            },\n            {\n              type: 'literal',\n              bail: true,\n              fieldName: '1',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '1',\n              validations: [],\n            },\n          ],\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('call parse function', async ({ assert }) => {\n    assert.plan(3)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        parseFnId: 'ref://1',\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs = refsBuilder()\n    refs.trackParser((value) => {\n      assert.deepEqual(value, data)\n      return value\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n})\n\ntest.group('Tuple node | optional: true', () => {\n  test('process children nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n\n  test('allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n\n  test('dis-allow non-array values', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid array'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'tuple',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: true,\n          allowUnknownProperties: false,\n          properties: [\n            {\n              type: 'literal',\n              bail: true,\n              fieldName: '0',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '0',\n              validations: [],\n            },\n            {\n              type: 'literal',\n              bail: true,\n              fieldName: '1',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '1',\n              validations: [],\n            },\n          ],\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n})\n\ntest.group('Tuple node | allowNull: true', () => {\n  test('process children nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isNull(output)\n  })\n\n  test('dis-allow non-array values', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        allowUnknownProperties: false,\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '0',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '0',\n            validations: [],\n          },\n          {\n            type: 'literal',\n            bail: true,\n            fieldName: '1',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '1',\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid array'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'tuple',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: true,\n          isOptional: false,\n          allowUnknownProperties: false,\n          properties: [\n            {\n              type: 'literal',\n              bail: true,\n              fieldName: '0',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '0',\n              validations: [],\n            },\n            {\n              type: 'literal',\n              bail: true,\n              fieldName: '1',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '1',\n              validations: [],\n            },\n          ],\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isNull(output)\n  })\n})\n"]}
{"filename": "tests/integration/compiler/literal_node.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '../../../index.js'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport type { ValidationRule } from '../../../src/types.js'\nimport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ntest.group('Literal node', () => {\n  test('process value for a field', async ({ assert }) => {", "test.group('Literal node', () => {\n  test('process value for a field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',", "        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n    const refs = {}", "    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n", "  })\n\n  test('allow empty string value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '*',\n        validations: [],", "        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = ''\n    const meta = {}", "    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, '')\n  })", "    assert.deepEqual(output, '')\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',", "      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: false,\n      },\n    })", "      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "\n    const fn = compiler.compile()\n\n    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('run validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n\n  test('stop validations after first error', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref://2', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n    assert.plan(8)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref://2', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: false,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('do not call transform when field is invalid', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        transformFnId: 'ref://1',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs = refsBuilder()\n    refs.trackTransformer(() => {\n      throw new Error('Never expected to reach here')\n    })\n    refs.trackValidation({\n      validator(value, options, field) {\n        assert.equal(value, 'virk')\n        assert.isUndefined(options)\n        assert.containsSubset(field, {\n          name: '',\n          isArrayMember: false,\n          isValid: true,\n          meta: {},\n          parent: data,\n          data,\n        })\n        field.report('ref://2 failed', 'ref', field)\n      },\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 failed'])\n    }\n  })\n\n  test('call transform when field is valid', async ({ assert }) => {\n    assert.plan(4)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '*',\n        transformFnId: 'ref://1',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n    const refs = refsBuilder()\n\n    refs.trackTransformer((value: string) => {\n      return value.toUpperCase()\n    })\n    refs.trackValidation({\n      validator(value, options, field) {\n        assert.equal(value, 'virk')\n        assert.isUndefined(options)\n        assert.containsSubset(field, {\n          name: '',\n          isArrayMember: false,\n          isValid: true,\n          meta: {},\n          parent: data,\n          data,\n        })\n      },\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    assert.deepEqual(await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter), 'VIRK')\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('call parse function', async ({ assert }) => {\n    assert.plan(3)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        parseFnId: 'ref://1',\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n    const refs = refsBuilder()\n    refs.trackParser((value, ctx) => {\n      assert.equal(value, 'virk')\n      assert.deepEqual(ctx, {\n        data: 'virk',\n        meta: {},\n        parent: 'virk',\n      })\n      return value\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n})\n\ntest.group('Literal node | optional: true', () => {\n  test('process value for an optional field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n\n  test('allow empty string value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, '')\n  })\n\n  test('allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('run validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'userName',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n\n  test('do not run validations when value is undefined', async ({ assert }) => {\n    assert.plan(1)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('run validations for implicit rules when value is undefined', async ({ assert }) => {\n    assert.plan(4)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: true,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.equal(value, undefined)\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: true,\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n})\n\ntest.group('Literal node | allowNull: true', () => {\n  test('process value for a nullable field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n\n  test('allow empty string value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, '')\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, null)\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [],\n        propertyName: 'userName',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('run validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = 'virk'\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.equal(value, 'virk')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, 'virk')\n  })\n\n  test('do not run validations when value is null', async ({ assert }) => {\n    assert.plan(1)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'userName',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = null\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, null)\n  })\n\n  test('run validations for implicit rules when value is null', async ({ assert }) => {\n    assert.plan(4)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        bail: true,\n        fieldName: 'username',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: true,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'userName',\n        allowNull: true,\n        isOptional: false,\n      },\n    })\n\n    const data = null\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.isNull(value)\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, null)\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: true,\n          isOptional: false,\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isNull(output)\n  })\n})\n"]}
{"filename": "tests/integration/compiler/record_node.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '../../../index.js'\nimport { ValidationRule } from '../../../src/types.js'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ntest.group('Record node', () => {\n  test('process a record field', async ({ assert }) => {", "test.group('Record node', () => {\n  test('process a record field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',", "        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',", "          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any = {}\n    const meta = {}", "    const data: any = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n", "    assert.deepEqual(output, {})\n\n    // Mutation test:\n    data.colors = { white: '#fff' }\n    assert.deepEqual(output, {})\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n", "    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',", "        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',", "          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = undefined\n    const meta = {}", "    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow non-object values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid object'])\n    }\n  })\n\n  test('process each element', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, { white: '#fff', black: '#000' })\n\n    // Mutation test:\n    data.white = 'white'\n    assert.deepEqual(output, { white: '#fff', black: '#000' })\n  })\n\n  test('validate nested each elements', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'record',\n          bail: true,\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          validations: [],\n          each: {\n            type: 'literal',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, [\n        'value is not a valid object',\n        'value is not a valid object',\n      ])\n    }\n  })\n\n  test('process nested each elements', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'record',\n          bail: true,\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          validations: [],\n          each: {\n            type: 'literal',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n    })\n\n    const data = {\n      white: { bg: '#f3f3f3', fg: '#fff' },\n      black: { bg: '#000', fg: '#000' },\n    }\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {\n      white: { bg: '#f3f3f3', fg: '#fff' },\n      black: { bg: '#000', fg: '#000' },\n    })\n\n    // Mutation test:\n    data.white.bg = 'white'\n    assert.deepEqual(output, {\n      white: { bg: '#f3f3f3', fg: '#fff' },\n      black: { bg: '#000', fg: '#000' },\n    })\n  })\n\n  test('run validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, { white: '#fff', black: '#000' })\n  })\n\n  test('stop validations after first error', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to reach here')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n    assert.plan(8)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: false,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('do not process children when record is invalid', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [\n            {\n              ruleFnId: 'ref://3',\n              implicit: false,\n              isAsync: false,\n            },\n          ],\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('process children for invalid record when bail mode is disabled', async ({ assert }) => {\n    assert.plan(15)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [\n            {\n              ruleFnId: 'ref://3',\n              implicit: false,\n              isAsync: false,\n            },\n          ],\n        },\n      },\n    })\n\n    const data = { white: '#fff', black: '#000' }\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, { white: '#fff', black: '#000' })\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.oneOf(field.name, ['white', 'black'])\n          assert.equal(field.wildCardPath, '*')\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: { white: '#fff', black: '#000' },\n            data,\n          })\n", "          if (!field.isArrayMember) {\n            assert.equal(field.parent[field.name], value)\n          }\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'record',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          each: {\n            type: 'literal',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('call parse function', async ({ assert }) => {\n    assert.plan(3)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        parseFnId: 'ref://1',\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any = {}\n    const meta = {}\n\n    const refs = refsBuilder()\n    refs.trackParser((value) => {\n      assert.deepEqual(value, {})\n      return value\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n\n    // Mutation test:\n    data.colors = { white: '#fff' }\n    assert.deepEqual(output, {})\n  })\n})\n\ntest.group('Record node | optional: true', () => {\n  test('process a record field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n  })\n\n  test('allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('dis-allow non-object values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid object'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'record',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: true,\n          each: {\n            type: 'literal',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n})\n\ntest.group('Record node | allowNull: true', () => {\n  test('process a record field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = {}\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, {})\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, null)\n  })\n\n  test('dis-allow non-object values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid object'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'record',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: true,\n          isOptional: false,\n          each: {\n            type: 'literal',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isNull(output)\n  })\n})\n"]}
{"filename": "tests/integration/compiler/array_node.spec.ts", "chunked_list": ["/*\n * @adonisjs/validator\n *\n * (c) Validator\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '../../../index.js'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport type { ValidationRule } from '../../../src/types.js'\nimport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ntest.group('Array node', () => {\n  test('process an array field', async ({ assert }) => {", "test.group('Array node', () => {\n  test('process an array field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',", "        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',", "          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any[] = []\n    const meta = {}", "    const data: any[] = []\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [])\n", "    assert.deepEqual(output, [])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, [])\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    assert.plan(2)\n", "    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',", "        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',", "          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = undefined\n    const meta = {}", "    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow null value', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('dis-allow non-array values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid array'])\n    }\n  })\n\n  test('validate each node', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = [undefined]\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('process each node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n\n  test('process nested array nodes', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'array',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          each: {\n            type: 'literal',\n            bail: true,\n            fieldName: '*',\n            allowNull: false,\n            isOptional: false,\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n    })\n\n    const data: any = [['hello world'], ['hi world']]\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [['hello world'], ['hi world']])\n\n    // Mutation test\n    data[0][0] = 'foo'\n    assert.deepEqual(output, [['hello world'], ['hi world']])\n  })\n\n  test('run validations', async ({ assert }) => {\n    assert.plan(7)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, ['hello world', 'hi world'])\n  })\n\n  test('stop validations after first error', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n    assert.plan(8)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: false,\n        fieldName: '*',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n          {\n            ruleFnId: 'ref://3',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: false,\n            meta: {},\n            parent: data,\n            data,\n          })\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('do not process children when array is invalid', async ({ assert }) => {\n    assert.plan(5)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [\n            {\n              ruleFnId: 'ref://3',\n              implicit: false,\n              isAsync: false,\n            },\n          ],\n        },\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator() {\n          throw new Error('Never expected to be called')\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('process children for invalid array when bail mode is disabled', async ({ assert }) => {\n    assert.plan(17)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: false,\n        fieldName: 'contacts',\n        validations: [\n          {\n            ruleFnId: 'ref://2',\n            implicit: false,\n            isAsync: false,\n          },\n        ],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          bail: true,\n          fieldName: '*',\n          allowNull: false,\n          isOptional: false,\n          propertyName: '*',\n          validations: [\n            {\n              ruleFnId: 'ref://3',\n              implicit: false,\n              isAsync: false,\n            },\n          ],\n        },\n      },\n    })\n\n    const data = ['hello world', 'hi world']\n    const meta = {}\n\n    const refs: Record<string, ValidationRule> = {\n      'ref://2': {\n        validator(value, options, field) {\n          assert.deepEqual(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            name: '',\n            isArrayMember: false,\n            isValid: true,\n            meta: {},\n            parent: data,\n            data,\n          })\n          field.report('ref://2 validation failed', 'ref', field)\n        },\n      },\n      'ref://3': {\n        validator(value, options, field) {\n          assert.oneOf(value, ['hello world', 'hi world'])\n          assert.isUndefined(options)\n          assert.containsSubset(field, {\n            isArrayMember: true,\n            isValid: true,\n            meta: {},\n            parent: ['hello world', 'hi world'],\n            data,\n          })\n          assert.oneOf(field.name, [0, 1])\n          assert.equal(field.wildCardPath, '*')\n", "          if (field.isArrayMember) {\n            assert.equal(field.parent[field.name], value)\n          }\n        },\n      },\n    }\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'array',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          each: {\n            type: 'literal',\n            allowNull: false,\n            bail: true,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('call parse function', async ({ assert }) => {\n    assert.plan(3)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: '*',\n        validations: [],\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        parseFnId: 'ref://1',\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any[] = []\n    const meta = {}\n    const refs = refsBuilder()\n    refs.trackParser((value) => {\n      assert.deepEqual(value, [])\n      return value\n    })\n\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n    assert.deepEqual(output, [])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, [])\n  })\n})\n\ntest.group('Array node | optional: true', () => {\n  test('process an array field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any = []\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [])\n\n    // Mutation test\n    data[0] = 'foo'\n    assert.deepEqual(output, [])\n  })\n\n  test('allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, undefined)\n  })\n\n  test('dis-allow non-array values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: false,\n        isOptional: true,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid array'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'array',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: false,\n          isOptional: true,\n          each: {\n            type: 'literal',\n            allowNull: false,\n            bail: true,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isUndefined(output)\n  })\n})\n\ntest.group('Array node | allowNull: true', () => {\n  test('process an array field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any = []\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, [])\n  })\n\n  test('dis-allow undefined value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = undefined\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is required'])\n    }\n  })\n\n  test('allow null value', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data: any = null\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.deepEqual(output, null)\n  })\n\n  test('dis-allow non-array values', async ({ assert }) => {\n    assert.plan(2)\n\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        bail: true,\n        fieldName: 'contacts',\n        validations: [],\n        propertyName: 'contacts',\n        allowNull: true,\n        isOptional: false,\n        each: {\n          type: 'literal',\n          allowNull: false,\n          bail: true,\n          isOptional: false,\n          fieldName: '*',\n          propertyName: '*',\n          validations: [],\n        },\n      },\n    })\n\n    const data = 'hello world'\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()", "    try {\n      await fn(data, meta, refs, messagesProvider, errorReporter)\n    } catch (error) {\n      assert.equal(error.message, 'Validation failure')\n      assert.deepEqual(error.messages, ['value is not a valid array'])\n    }\n  })\n\n  test('convert empty string to null', async ({ assert }) => {\n    const compiler = new Compiler(\n      {\n        type: 'root',\n        schema: {\n          type: 'array',\n          bail: true,\n          fieldName: '*',\n          validations: [],\n          propertyName: '*',\n          allowNull: true,\n          isOptional: false,\n          each: {\n            type: 'literal',\n            allowNull: false,\n            bail: true,\n            isOptional: false,\n            fieldName: '*',\n            propertyName: '*',\n            validations: [],\n          },\n        },\n      },\n      { convertEmptyStringsToNull: true }\n    )\n\n    const data: any = ''\n    const meta = {}\n    const refs = {}\n    const messagesProvider = new MessagesProviderFactory().create()\n    const errorReporter = new ErrorReporterFactory().create()\n\n    const fn = compiler.compile()\n    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n    assert.isNull(output)\n  })\n})\n"]}
{"filename": "tests/unit/move_properties.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { defineInlineFunctions } from '../../src/scripts/define_inline_functions.js'\n\nconst fn = new Function(\n  'data',\n  'output',\n  'ignoreProperties',\n  `\n  ${defineInlineFunctions({ convertEmptyStringsToNull: false })}", "  `\n  ${defineInlineFunctions({ convertEmptyStringsToNull: false })}\n  moveProperties(data, output, ignoreProperties)\n  `\n)\n\ntest.group('Move properties', () => {\n  test('move properties from a flat object', ({ assert }) => {\n    const data = {\n      username: 'virk',", "    const data = {\n      username: 'virk',\n      password: 'secret',\n      age: 32,\n    }\n\n    const output = {\n      username: 'VIRK',\n    }\n", "    }\n\n    fn(data, output, ['username'])\n    assert.deepEqual(output, {\n      username: 'VIRK',\n      password: 'secret',\n      age: 32,\n    })\n\n    // Mutating source", "\n    // Mutating source\n    data.age = 34\n    assert.deepEqual(output, {\n      username: 'VIRK',\n      password: 'secret',\n      age: 32,\n    })\n  })\n", "  })\n\n  test('move properties from a nested object', ({ assert }) => {\n    const data = {\n      username: 'virk',\n      password: 'secret',\n      meta: {\n        age: 32,\n        password: 'secret',\n        sigfile: 'file://foobar',", "        password: 'secret',\n        sigfile: 'file://foobar',\n      },\n    }\n\n    const output = {\n      username: 'VIRK',\n      password: 'SECRET',\n    }\n", "    }\n\n    fn(data, output, ['username', 'password'])\n    assert.deepEqual(output, {\n      username: 'VIRK',\n      password: 'SECRET',\n      meta: {\n        age: 32,\n        password: 'secret',\n        sigfile: 'file://foobar',", "        password: 'secret',\n        sigfile: 'file://foobar',\n      },\n    })\n\n    // Mutating source\n    data.meta.age = 34\n    assert.deepEqual(output, {\n      username: 'VIRK',\n      password: 'SECRET',", "      username: 'VIRK',\n      password: 'SECRET',\n      meta: {\n        age: 32,\n        password: 'secret',\n        sigfile: 'file://foobar',\n      },\n    })\n  })\n", "  })\n\n  test('dereference arrays', ({ assert }) => {\n    const data = {\n      username: 'virk',\n      password: 'secret',\n      meta: [\n        {\n          age: 32,\n          password: 'secret',", "          age: 32,\n          password: 'secret',\n          sigfile: 'file://foobar',\n        },\n      ],\n    }\n\n    const output = {\n      username: 'VIRK',\n      password: 'SECRET',", "      username: 'VIRK',\n      password: 'SECRET',\n    }\n\n    fn(data, output, ['username', 'password'])\n    assert.deepEqual(output, {\n      username: 'VIRK',\n      password: 'SECRET',\n      meta: [\n        {", "      meta: [\n        {\n          age: 32,\n          password: 'secret',\n          sigfile: 'file://foobar',\n        },\n      ],\n    })\n\n    // Mutating source", "\n    // Mutating source\n    data.meta[0].age = 34\n    data.meta.push({ age: 34, password: 'foo', sigfile: 'file://foo' })\n    assert.deepEqual(output, {\n      username: 'VIRK',\n      password: 'SECRET',\n      meta: [\n        {\n          age: 32,", "        {\n          age: 32,\n          password: 'secret',\n          sigfile: 'file://foobar',\n        },\n      ],\n    })\n  })\n})\n", "})\n"]}
{"filename": "tests/unit/nodes/union.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { validateCode } from '../../../factories/code_validator.js'\nimport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ntest.group('Union node', () => {\n  test('create JS output for a union node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {", "            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'literal',\n              fieldName: '*',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '*',\n              bail: true,\n              validations: [\n                {", "              validations: [\n                {\n                  ruleFnId: 'ref://2',\n                  implicit: false,\n                  isAsync: false,\n                },\n              ],\n            },\n          },\n          {", "          },\n          {\n            conditionalFnRefId: 'ref://3',\n            schema: {\n              type: 'literal',\n              fieldName: '*',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '*',\n              bail: true,", "              propertyName: '*',\n              bail: true,\n              validations: [\n                {\n                  ruleFnId: 'ref://4',\n                  implicit: false,\n                  isAsync: false,\n                },\n              ],\n            },", "              ],\n            },\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n", "    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `data: root,`,\n      `meta: meta,`,\n      `name: '',`,\n      `wildCardPath: '',`,\n      `mutate: defineValue,`,", "      `wildCardPath: '',`,\n      `mutate: defineValue,`,\n      `report: report,`,\n      `isValid: true,`,\n      `parent: root,`,\n      `isArrayMember: false,`,\n      '});',\n      `if(refs['ref://1'](root_item.value, root_item)) {`,\n      `ensureExists(root_item);`,\n      `if (root_item.isValid && root_item.isDefined) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,", "      `if (root_item.isValid && root_item.isDefined) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `out = root_item.value;`,\n      `}`,\n      `}`,\n      `else if(refs['ref://3'](root_item.value, root_item)) {`,\n      `ensureExists(root_item);`,\n      `if (root_item.isValid && root_item.isDefined) {`,\n      `refs['ref://4'].validator(root_item.value, refs['ref://4'].options, root_item);`,\n      `}`,", "      `if (root_item.isValid && root_item.isDefined) {`,\n      `refs['ref://4'].validator(root_item.value, refs['ref://4'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `out = root_item.value;`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('define union else block', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'union',\n        fieldName: '*',\n        propertyName: '*',\n        elseConditionalFnRefId: 'ref://10',\n        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'literal',\n              fieldName: '*',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '*',\n              bail: true,\n              validations: [\n                {\n                  ruleFnId: 'ref://2',\n                  implicit: false,\n                  isAsync: false,\n                },\n              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://3',\n            schema: {\n              type: 'literal',\n              fieldName: '*',\n              allowNull: false,\n              isOptional: false,\n              propertyName: '*',\n              bail: true,\n              validations: [\n                {\n                  ruleFnId: 'ref://4',\n                  implicit: false,\n                  isAsync: false,\n                },\n              ],\n            },\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `data: root,`,\n      `meta: meta,`,\n      `name: '',`,\n      `wildCardPath: '',`,\n      `mutate: defineValue,`,\n      `report: report,`,\n      `isValid: true,`,\n      `parent: root,`,\n      `isArrayMember: false,`,\n      '});',", "      `if(refs['ref://1'](root_item.value, root_item)) {`,\n      `ensureExists(root_item);`,\n      `if (root_item.isValid && root_item.isDefined) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `out = root_item.value;`,\n      `}`,\n      `}`,\n      `else if(refs['ref://3'](root_item.value, root_item)) {`,\n      `ensureExists(root_item);`,", "      `else if(refs['ref://3'](root_item.value, root_item)) {`,\n      `ensureExists(root_item);`,\n      `if (root_item.isValid && root_item.isDefined) {`,\n      `refs['ref://4'].validator(root_item.value, refs['ref://4'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `out = root_item.value;`,\n      `}`,\n      `} else {`,\n      `refs['ref://10'](root_item.value, root_item);`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/nodes/literal.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { validateCode } from '../../../factories/code_validator.js'\nimport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ntest.group('Literal node', () => {\n  test('create JS output for a literal node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [", "        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n      },\n    })", "      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,", "      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,", "      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,\n      `if (root_item.isValid && root_item.isDefined) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `  out = root_item.value;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for nullable field', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (root_item.isValid && root_item.isDefined) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `  out = root_item.value;`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'literal',\n        allowNull: true,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (root_item.isDefined) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isDefined && root_item.isValid) {`,\n      `  out = root_item.value;`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/nodes/object.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { validateCode } from '../../../factories/code_validator.js'\nimport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ntest.group('Object node', () => {\n  test('create JS output for an object node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [],", "        ],\n        properties: [],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [", "\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,", "      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,\n      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,", "      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      '}',\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for a nullable object node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'profile',\n        propertyName: 'userProfile',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output without object validations', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [],\n        properties: [],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output without object validations', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [],\n        properties: [],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for object children', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'profile',\n        propertyName: 'userProfile',\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: false,\n            bail: true,\n            fieldName: 'username',\n            propertyName: 'username',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const username_2 = defineValue(root_item.value['username'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'username',`,\n      `  wildCardPath: 'username',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(username_2);`,", "      `if (username_2.isValid && username_2.isDefined) {`,\n      `  refs['ref://2'].validator(username_2.value, refs['ref://2'].options, username_2);`,\n      `}`,\n      `if (username_2.isDefined && username_2.isValid) {`,\n      `  root_item_out['username'] = username_2.value;`,\n      `}`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for object with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: true,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for object with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: true,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for node object with unknownProperties allowed', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        groups: [],\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [],\n        allowUnknownProperties: true,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `moveProperties(root_item.value, root_item_out, []);`,\n      '}',\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for object groups', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: false,\n            bail: true,\n            fieldName: 'password',\n            propertyName: 'password',\n            validations: [],\n          },\n        ],\n        groups: [\n          {\n            type: 'group',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://1',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'username',\n                      propertyName: 'username',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://2',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'email',\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        ],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const password_2 = defineValue(root_item.value['password'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'password',`,\n      `  wildCardPath: 'password',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(password_2);`,", "      `if (password_2.isDefined && password_2.isValid) {`,\n      `  root_item_out['password'] = password_2.value;`,\n      `}`,\n      `if (refs['ref://1'](root_item.value, root_item)) {`,\n      `  const username_3 = defineValue(root_item.value['username'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'username',`,\n      `  wildCardPath: 'username',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(username_3);`,", "      `if (username_3.isDefined && username_3.isValid) {`,\n      `  root_item_out['username'] = username_3.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n      `  const email_4 = defineValue(root_item.value['email'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'email',`,\n      `  wildCardPath: 'email',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(email_4);`,", "      `if (email_4.isDefined && email_4.isValid) {`,\n      `  root_item_out['email'] = email_4.value;`,\n      `}`,\n      `}`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for multiple object groups', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'login',\n        propertyName: 'login',\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: false,\n            bail: true,\n            fieldName: 'password',\n            propertyName: 'password',\n            validations: [],\n          },\n        ],\n        groups: [\n          {\n            type: 'group',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://1',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'username',\n                      propertyName: 'username',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://2',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'email',\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n          {\n            type: 'group',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://3',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'oauth_token',\n                      propertyName: 'oauthToken',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://4',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'secret_key',\n                      propertyName: 'secretKey',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        ],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const password_2 = defineValue(root_item.value['password'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'password',`,\n      `  wildCardPath: 'password',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(password_2);`,", "      `if (password_2.isDefined && password_2.isValid) {`,\n      `  root_item_out['password'] = password_2.value;`,\n      `}`,\n      `if (refs['ref://1'](root_item.value, root_item)) {`,\n      `  const username_3 = defineValue(root_item.value['username'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'username',`,\n      `  wildCardPath: 'username',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(username_3);`,", "      `if (username_3.isDefined && username_3.isValid) {`,\n      `  root_item_out['username'] = username_3.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n      `  const email_4 = defineValue(root_item.value['email'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'email',`,\n      `  wildCardPath: 'email',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(email_4);`,", "      `if (email_4.isDefined && email_4.isValid) {`,\n      `  root_item_out['email'] = email_4.value;`,\n      `}`,\n      `}`,\n      `if (refs['ref://3'](root_item.value, root_item)) {`,\n      `  const oauthToken_5 = defineValue(root_item.value['oauth_token'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'oauth_token',`,\n      `  wildCardPath: 'oauth_token',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(oauthToken_5);`,", "      `if (oauthToken_5.isDefined && oauthToken_5.isValid) {`,\n      `  root_item_out['oauthToken'] = oauthToken_5.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://4'](root_item.value, root_item)) {`,\n      `  const secretKey_6 = defineValue(root_item.value['secret_key'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'secret_key',`,\n      `  wildCardPath: 'secret_key',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(secretKey_6);`,", "      `if (secretKey_6.isDefined && secretKey_6.isValid) {`,\n      `  root_item_out['secretKey'] = secretKey_6.value;`,\n      `}`,\n      `}`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for nested object groups', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'login',\n        propertyName: 'login',\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: false,\n            bail: true,\n            fieldName: 'password',\n            propertyName: 'password',\n            validations: [],\n          },\n        ],\n        groups: [\n          {\n            type: 'group',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://1',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'username',\n                      propertyName: 'username',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://2',\n                schema: {\n                  type: 'sub_object',\n                  properties: [],\n                  groups: [\n                    {\n                      type: 'group',\n                      conditions: [\n                        {\n                          conditionalFnRefId: 'ref://3',\n                          schema: {\n                            type: 'sub_object',\n                            groups: [],\n                            properties: [\n                              {\n                                type: 'literal',\n                                allowNull: false,\n                                isOptional: false,\n                                bail: true,\n                                fieldName: 'hotmail',\n                                propertyName: 'hotmail',\n                                validations: [],\n                              },\n                            ],\n                          },\n                        },\n                        {\n                          conditionalFnRefId: 'ref://4',\n                          schema: {\n                            type: 'sub_object',\n                            groups: [],\n                            properties: [\n                              {\n                                type: 'literal',\n                                allowNull: false,\n                                isOptional: false,\n                                bail: true,\n                                fieldName: 'email',\n                                propertyName: 'email',\n                                validations: [],\n                              },\n                            ],\n                          },\n                        },\n                      ],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        ],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const password_2 = defineValue(root_item.value['password'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'password',`,\n      `  wildCardPath: 'password',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(password_2);`,", "      `if (password_2.isDefined && password_2.isValid) {`,\n      `  root_item_out['password'] = password_2.value;`,\n      `}`,\n      `if (refs['ref://1'](root_item.value, root_item)) {`,\n      `  const username_3 = defineValue(root_item.value['username'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'username',`,\n      `  wildCardPath: 'username',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(username_3);`,", "      `if (username_3.isDefined && username_3.isValid) {`,\n      `  root_item_out['username'] = username_3.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n      `if (refs['ref://3'](root_item.value, root_item)) {`,\n      `  const hotmail_4 = defineValue(root_item.value['hotmail'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'hotmail',`,\n      `  wildCardPath: 'hotmail',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(hotmail_4);`,", "      `if (hotmail_4.isDefined && hotmail_4.isValid) {`,\n      `  root_item_out['hotmail'] = hotmail_4.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://4'](root_item.value, root_item)) {`,\n      `  const email_5 = defineValue(root_item.value['email'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'email',`,\n      `  wildCardPath: 'email',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(email_5);`,", "      `if (email_5.isDefined && email_5.isValid) {`,\n      `  root_item_out['email'] = email_5.value;`,\n      `}`,\n      `}`,\n      `}`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('define else block for conditions', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'object',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'login',\n        propertyName: 'login',\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: false,\n            bail: true,\n            fieldName: 'password',\n            propertyName: 'password',\n            validations: [],\n          },\n        ],\n        groups: [\n          {\n            type: 'group',\n            elseConditionalFnRefId: 'ref://10',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://1',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'username',\n                      propertyName: 'username',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://2',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'email',\n                      propertyName: 'email',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n          {\n            type: 'group',\n            elseConditionalFnRefId: 'ref://11',\n            conditions: [\n              {\n                conditionalFnRefId: 'ref://3',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'oauth_token',\n                      propertyName: 'oauthToken',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n              {\n                conditionalFnRefId: 'ref://4',\n                schema: {\n                  type: 'sub_object',\n                  groups: [],\n                  properties: [\n                    {\n                      type: 'literal',\n                      allowNull: false,\n                      isOptional: false,\n                      bail: true,\n                      fieldName: 'secret_key',\n                      propertyName: 'secretKey',\n                      validations: [],\n                    },\n                  ],\n                },\n              },\n            ],\n          },\n        ],\n        allowUnknownProperties: false,\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const password_2 = defineValue(root_item.value['password'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'password',`,\n      `  wildCardPath: 'password',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(password_2);`,", "      `if (password_2.isDefined && password_2.isValid) {`,\n      `  root_item_out['password'] = password_2.value;`,\n      `}`,\n      `if (refs['ref://1'](root_item.value, root_item)) {`,\n      `  const username_3 = defineValue(root_item.value['username'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'username',`,\n      `  wildCardPath: 'username',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(username_3);`,", "      `if (username_3.isDefined && username_3.isValid) {`,\n      `  root_item_out['username'] = username_3.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n      `  const email_4 = defineValue(root_item.value['email'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'email',`,\n      `  wildCardPath: 'email',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(email_4);`,", "      `if (email_4.isDefined && email_4.isValid) {`,\n      `  root_item_out['email'] = email_4.value;`,\n      `}`,\n      `} else {`,\n      `refs['ref://10'](root_item.value, root_item);`,\n      `}`,\n      `if (refs['ref://3'](root_item.value, root_item)) {`,\n      `  const oauthToken_5 = defineValue(root_item.value['oauth_token'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'oauth_token',`,\n      `  wildCardPath: 'oauth_token',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(oauthToken_5);`,", "      `if (oauthToken_5.isDefined && oauthToken_5.isValid) {`,\n      `  root_item_out['oauthToken'] = oauthToken_5.value;`,\n      `}`,\n      `}`,\n      `else if (refs['ref://4'](root_item.value, root_item)) {`,\n      `  const secretKey_6 = defineValue(root_item.value['secret_key'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'secret_key',`,\n      `  wildCardPath: 'secret_key',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(secretKey_6);`,", "      `if (secretKey_6.isDefined && secretKey_6.isValid) {`,\n      `  root_item_out['secretKey'] = secretKey_6.value;`,\n      `}`,\n      `} else {`,\n      `refs['ref://11'](root_item.value, root_item);`,\n      `}`,\n      '}',\n      `}`,\n      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n})\n", "      'else if(root_item.value === null) {',\n      `  out = null;`,\n      '}',\n      ...getClosingOutput(),\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/nodes/record.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { validateCode } from '../../../factories/code_validator.js'\nimport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ntest.group('Record node', () => {\n  test('create JS output for record node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [", "        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',", "        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },", "        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,", "      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,", "      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,\n      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const root_item_keys = Object.keys(root_item.value);`,\n      `const root_item_keys_size = root_item_keys.length;`,", "      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const root_item_keys = Object.keys(root_item.value);`,\n      `const root_item_keys_size = root_item_keys.length;`,\n      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n      `const root_item_i = root_item_keys[root_item_key_i];`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for nullable record node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const root_item_keys = Object.keys(root_item.value);`,\n      `const root_item_keys_size = root_item_keys.length;`,\n      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n      `const root_item_i = root_item_keys[root_item_key_i];`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n      `const root_item_i = root_item_keys[root_item_key_i];`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      `else if(root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output without record validations', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'colors',\n        propertyName: 'colorPalette',\n        validations: [],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const root_item_keys = Object.keys(root_item.value);`,\n      `const root_item_keys_size = root_item_keys.length;`,\n      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n      `const root_item_i = root_item_keys[root_item_key_i];`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      `else if(root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output with record children validations', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: 'colors',\n        propertyName: 'colorPalette',\n        validations: [],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const root_item_keys = Object.keys(root_item.value);`,\n      `const root_item_keys_size = root_item_keys.length;`,\n      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n      `const root_item_i = root_item_keys[root_item_key_i];`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined) {`,\n      `  refs['ref://2'].validator(root_item_item.value, refs['ref://2'].options, root_item_item);`,\n      `}`,\n      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      `else if(root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for record node with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        allowNull: true,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `else if(root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for record node with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'record',\n        allowNull: true,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsObject(root_item)) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `const root_item_out = {};`,\n      `out = root_item_out;`,\n      `const root_item_keys = Object.keys(root_item.value);`,\n      `const root_item_keys_size = root_item_keys.length;`,\n      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n      `const root_item_i = root_item_keys[root_item_key_i];`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `else if(root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/nodes/tuple.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { validateCode } from '../../../factories/code_validator.js'\nimport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ntest.group('Tuple node', () => {\n  test('create JS output for tuple node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        allowUnknownProperties: false,", "        propertyName: '*',\n        allowUnknownProperties: false,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [", "        ],\n        properties: [\n          {\n            type: 'literal',\n            fieldName: '0',\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            bail: false,\n            validations: [],", "            bail: false,\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)", "\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,", "      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,\n      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 0,`,\n      `  wildCardPath: '0',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item_0);`,", "      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n      `root_item_out[0] = root_item_item_0.value;`,\n      `}`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for nullable tuple node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        allowUnknownProperties: false,\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            fieldName: '0',\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            bail: false,\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 0,`,\n      `  wildCardPath: '0',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item_0);`,", "      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n      `root_item_out[0] = root_item_item_0.value;`,\n      `}`,\n      `}`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for tuple node when unknownProperties are allowed', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        allowUnknownProperties: true,\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            fieldName: '0',\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            bail: false,\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = copyProperties(root_item.value);`,\n      `out = root_item_out;`,\n      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 0,`,\n      `  wildCardPath: '0',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item_0);`,", "      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n      `root_item_out[0] = root_item_item_0.value;`,\n      `}`,\n      `}`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for tuple node without array validations', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        allowUnknownProperties: false,\n        validations: [],\n        properties: [\n          {\n            type: 'literal',\n            fieldName: '0',\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            bail: false,\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 0,`,\n      `  wildCardPath: '0',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item_0);`,", "      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n      `root_item_out[0] = root_item_item_0.value;`,\n      `}`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for tuple node with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'tuple',\n        allowNull: false,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        allowUnknownProperties: false,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        properties: [\n          {\n            type: 'literal',\n            fieldName: '0',\n            propertyName: '0',\n            allowNull: false,\n            isOptional: false,\n            bail: false,\n            validations: [],\n          },\n        ],\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 0,`,\n      `  wildCardPath: '0',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item_0);`,", "      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n      `root_item_out[0] = root_item_item_0.value;`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/nodes/array.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Compiler } from '../../../src/compiler/main.js'\nimport { validateCode } from '../../../factories/code_validator.js'\nimport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ntest.group('Array node', () => {\n  test('create JS output for array node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',", "    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [", "        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',", "        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },", "        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,", "      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,", "      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,\n      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_items_size = root_item.value.length;`,", "      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_items_size = root_item.value.length;`,\n      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for nullable array node', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_items_size = root_item.value.length;`,\n      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output without array validations', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        allowNull: true,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_items_size = root_item.value.length;`,\n      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('create JS output for array with bail mode disabled', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        allowNull: true,\n        isOptional: false,\n        bail: false,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'literal',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n\n    validateCode(compiledOutput)\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureIsDefined(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_items_size = root_item.value.length;`,\n      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n      `  root_item_out[root_item_i] = root_item_item.value;`,\n      `}`,\n      `}`,\n      `} else if (root_item.value === null) {`,\n      `  out = null;`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n\n  test('compute wildcard path to nested arrays', async ({ assert }) => {\n    const compiler = new Compiler({\n      type: 'root',\n      schema: {\n        type: 'array',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        fieldName: '*',\n        propertyName: '*',\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://2',\n          },\n        ],\n        each: {\n          type: 'object',\n          fieldName: '*',\n          propertyName: '*',\n          allowNull: false,\n          isOptional: false,\n          bail: false,\n          validations: [],\n          groups: [],\n          allowUnknownProperties: false,\n          properties: [\n            {\n              type: 'array',\n              fieldName: 'contacts',\n              propertyName: 'contacts',\n              allowNull: false,\n              isOptional: false,\n              bail: false,\n              each: {\n                type: 'literal',\n                fieldName: '*',\n                propertyName: '*',\n                allowNull: false,\n                isOptional: false,\n                bail: false,\n                validations: [],\n              },\n              validations: [],\n            },\n          ],\n        },\n      },\n    })\n\n    const compiledOutput = compiler.compile().toString()\n    validateCode(compiledOutput)\n\n    assert.assertFormatted(compiledOutput, [\n      ...getInitialOutput(),\n      `const root_item = defineValue(root, {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: '',`,\n      `  wildCardPath: '',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n      `ensureExists(root_item);`,", "      `if (ensureIsArray(root_item)) {`,\n      `if (root_item.isValid) {`,\n      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n      `}`,\n      `if (root_item.isValid) {`,\n      `const root_item_out = [];`,\n      `out = root_item_out;`,\n      `const root_item_items_size = root_item.value.length;`,\n      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: root_item_i,`,\n      `  wildCardPath: '*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item.value,`,\n      `  isArrayMember: true,`,\n      '});',\n      `ensureExists(root_item_item);`,", "      `if (ensureIsObject(root_item_item)) {`,\n      `const root_item_item_out = {};`,\n      `root_item_out[root_item_i] = root_item_item_out;`,\n      `const contacts_3 = defineValue(root_item_item.value['contacts'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'contacts',`,\n      `  wildCardPath: '*.contacts',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root_item_item.value,`,\n      `  isArrayMember: false,`,\n      `});`,\n      `ensureExists(contacts_3);`,", "      `if (ensureIsArray(contacts_3)) {`,\n      `const contacts_3_out = [];`,\n      `root_item_item_out['contacts'] = contacts_3_out;`,\n      `const contacts_3_items_size = contacts_3.value.length;`,\n      `for (let contacts_3_i = 0; contacts_3_i < contacts_3_items_size; contacts_3_i++) {`,\n      `const contacts_3_item = defineValue(contacts_3.value[contacts_3_i], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: contacts_3_i,`,\n      `  wildCardPath: '*.contacts.*',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: contacts_3.value,`,\n      `  isArrayMember: true,`,\n      `});`,\n      `ensureExists(contacts_3_item);`,", "      `if (contacts_3_item.isDefined && contacts_3_item.isValid) {`,\n      `contacts_3_out[contacts_3_i]  = contacts_3_item.value;`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      `}`,\n      ...getClosingOutput(),\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/object/guard.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineObjectGuard } from '../../../../src/scripts/object/guard.js'\n\ntest.group('Scripts | define object guard', () => {\n  test('wrap code inside object guard conditional', ({ assert }) => {\n    const jsOutput = defineObjectGuard({\n      variableName: 'profile',\n      guardedCodeSnippet: 'console.log(profile)',", "      variableName: 'profile',\n      guardedCodeSnippet: 'console.log(profile)',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `if (ensureIsObject(profile)) {`,\n      `console.log(profile)`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/object/initial_output.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineObjectInitialOutput } from '../../../../src/scripts/object/initial_output.js'\n\ntest.group('Scripts | define object initial output', () => {\n  test('define initial object for object', ({ assert }) => {\n    const jsOutput = defineObjectInitialOutput({\n      outputExpression: `out['profile']`,\n      variableName: 'profile',", "      outputExpression: `out['profile']`,\n      variableName: 'profile',\n      outputValueExpression: `{}`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [`const profile_out = {};`, `out['profile'] = profile_out;`])\n  })\n})\n", "})\n"]}
{"filename": "tests/unit/scripts/union/call_parse.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { callParseFunction } from '../../../../src/scripts/union/parse.js'\n\ntest.group('Scripts | call parse function', () => {\n  test('get snippet to mutate the field value', ({ assert }) => {\n    const jsOutput = callParseFunction({\n      variableName: 'colors',\n      parseFnRefId: 'ref://1',", "      variableName: 'colors',\n      parseFnRefId: 'ref://1',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [`colors.value = refs['ref://1'](colors.value);`])\n  })\n\n  test('return empty string when parseFnRefId is not defined', ({ assert }) => {\n    const jsOutput = callParseFunction({", "  test('return empty string when parseFnRefId is not defined', ({ assert }) => {\n    const jsOutput = callParseFunction({\n      variableName: 'colors',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [''])\n  })\n})\n", "})\n"]}
{"filename": "tests/unit/scripts/record/loop.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineRecordLoop } from '../../../../src/scripts/record/loop.js'\n\ntest.group('Scripts | define record loop', () => {\n  test('wrap code inside record loop', ({ assert }) => {\n    const jsOutput = defineRecordLoop({\n      variableName: 'colors',\n      loopCodeSnippet: 'console.log(colors_i)',", "      variableName: 'colors',\n      loopCodeSnippet: 'console.log(colors_i)',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `const colors_keys = Object.keys(colors.value);`,\n      `const colors_keys_size = colors_keys.length;`,\n      `for (let colors_key_i = 0; colors_key_i < colors_keys_size; colors_key_i++) {`,\n      `const colors_i = colors_keys[colors_key_i];`,\n      `console.log(colors_i)`,\n      `}`,\n    ])\n  })\n})\n", "      `for (let colors_key_i = 0; colors_key_i < colors_keys_size; colors_key_i++) {`,\n      `const colors_i = colors_keys[colors_key_i];`,\n      `console.log(colors_i)`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/array/guard.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineArrayGuard } from '../../../../src/scripts/array/guard.js'\n\ntest.group('Scripts | define array guard', () => {\n  test('wrap code inside array guard conditional', ({ assert }) => {\n    const jsOutput = defineArrayGuard({\n      variableName: 'contacts',\n      guardedCodeSnippet: 'console.log(contacts)',", "      variableName: 'contacts',\n      guardedCodeSnippet: 'console.log(contacts)',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `if (ensureIsArray(contacts)) {`,\n      `console.log(contacts)`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/array/loop.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineArrayLoop } from '../../../../src/scripts/array/loop.js'\n\ntest.group('Scripts | define array loop', () => {\n  test('wrap code inside array loop', ({ assert }) => {\n    const jsOutput = defineArrayLoop({\n      variableName: 'contacts',\n      loopCodeSnippet: 'console.log(contacts_i)',", "      variableName: 'contacts',\n      loopCodeSnippet: 'console.log(contacts_i)',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `const contacts_items_size = contacts.value.length;`,\n      `for (let contacts_i = 0; contacts_i < contacts_items_size; contacts_i++) {`,\n      `console.log(contacts_i)`,\n      `}`,\n    ])\n  })\n\n  test('wrap code inside array loop with a custom starting index', ({ assert }) => {\n    const jsOutput = defineArrayLoop({\n      variableName: 'contacts',\n      startingIndex: 3,\n      loopCodeSnippet: 'console.log(contacts_i)',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `const contacts_items_size = contacts.value.length;`,", "      `for (let contacts_i = 3; contacts_i < contacts_items_size; contacts_i++) {`,\n      `console.log(contacts_i)`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/array/initial_output.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineArrayInitialOutput } from '../../../../src/scripts/array/initial_output.js'\n\ntest.group('Scripts | define array initial output', () => {\n  test('define initial output for array', ({ assert }) => {\n    const jsOutput = defineArrayInitialOutput({\n      outputExpression: `out['contacts']`,\n      variableName: 'root_item',", "      outputExpression: `out['contacts']`,\n      variableName: 'root_item',\n      outputValueExpression: `[]`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `const root_item_out = [];`,\n      `out['contacts'] = root_item_out;`,\n    ])", "      `out['contacts'] = root_item_out;`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/field/existence_validation.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineFieldExistenceValidations } from '../../../../src/scripts/field/existence_validations.js'\n\ntest.group('Scripts | define field existence valitions', () => {\n  test('get JS output for field existence validations', ({ assert }) => {\n    const jsOutput = defineFieldExistenceValidations({\n      variableName: 'username',\n      isOptional: false,", "      variableName: 'username',\n      isOptional: false,\n      allowNull: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [`ensureExists(username);`])\n  })\n\n  test('get JS output for optional field', ({ assert }) => {", "\n  test('get JS output for optional field', ({ assert }) => {\n    const jsOutput = defineFieldExistenceValidations({\n      variableName: 'username',\n      isOptional: true,\n      allowNull: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [''])", "    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [''])\n  })\n\n  test('get JS output for nullable field', ({ assert }) => {\n    const jsOutput = defineFieldExistenceValidations({\n      variableName: 'username',\n      isOptional: false,\n      allowNull: true,\n    })", "      allowNull: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, ['ensureIsDefined(username);'])\n  })\n\n  test('get JS output for optional and nullable field', ({ assert }) => {\n    const jsOutput = defineFieldExistenceValidations({\n      variableName: 'username',", "    const jsOutput = defineFieldExistenceValidations({\n      variableName: 'username',\n      isOptional: true,\n      allowNull: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [''])\n  })\n})", "  })\n})\n"]}
{"filename": "tests/unit/scripts/field/null_output.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EOL } from 'node:os'", "\nimport { EOL } from 'node:os'\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineFieldNullOutput } from '../../../../src/scripts/field/null_output.js'\n\ntest.group('Scripts | define field null output', () => {\n  test('get JS output for writing null output value', ({ assert }) => {\n    const jsOutput = defineFieldNullOutput({\n      variableName: 'username',", "    const jsOutput = defineFieldNullOutput({\n      variableName: 'username',\n      allowNull: true,\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `if(username.value === null) {`,\n      `  out['username'] = null;`,\n      `}`,\n    ])\n  })\n\n  test('get JS output when allowNull is disabled', ({ assert }) => {\n    const jsOutput = defineFieldNullOutput({\n      variableName: 'username',\n      allowNull: false,\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput.split(EOL), [``])\n  })\n\n  test('transform null value using transform ref id', ({ assert }) => {\n    const jsOutput = defineFieldNullOutput({\n      variableName: 'username',\n      allowNull: true,\n      transformFnRefId: 'ref://1',\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if(username.value === null) {`,\n      `  out['username'] = null;`,\n      `}`,\n    ])\n  })\n\n  test('get JS output when allowNull is disabled', ({ assert }) => {\n    const jsOutput = defineFieldNullOutput({\n      variableName: 'username',\n      allowNull: false,\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput.split(EOL), [``])\n  })\n\n  test('transform null value using transform ref id', ({ assert }) => {\n    const jsOutput = defineFieldNullOutput({\n      variableName: 'username',\n      allowNull: true,\n      transformFnRefId: 'ref://1',\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if(username.value === null) {`,\n      `out['username'] = refs['ref://1'](null, username);`,\n      `}`,\n    ])\n  })\n\n  test('generate else if conditional', ({ assert }) => {\n    const jsOutput = `if (foo) {} ${defineFieldNullOutput({\n      variableName: 'username',\n      allowNull: true,\n      transformFnRefId: 'ref://1',\n      conditional: 'else if',\n      outputExpression: `out['username']`,\n    })}`\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (foo) {} else if(username.value === null) {`,\n      `out['username'] = refs['ref://1'](null, username);`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/field/variables.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineFieldVariables } from '../../../../src/scripts/field/variables.js'\n\ntest.group('Scripts | define field variables', () => {\n  test('get JS output for field variables', ({ assert }) => {\n    const jsOutput = defineFieldVariables({\n      variableName: 'username',\n      valueExpression: `root['username']`,", "      variableName: 'username',\n      valueExpression: `root['username']`,\n      fieldNameExpression: `'username'`,\n      parentValueExpression: 'root',\n      wildCardPath: 'username',\n      isArrayMember: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `const username = defineValue(root['username'], {`,\n      `data: root,`,\n      `meta: meta,`,\n      `name: 'username',`,\n      `wildCardPath: 'username',`,\n      `mutate: defineValue,`,\n      `report: report,`,\n      `isValid: true,`,", "      `report: report,`,\n      `isValid: true,`,\n      `parent: root,`,\n      `isArrayMember: false,`,\n      '});',\n    ])\n  })\n\n  test('get JS output with parse function', ({ assert }) => {\n    const jsOutput = defineFieldVariables({", "  test('get JS output with parse function', ({ assert }) => {\n    const jsOutput = defineFieldVariables({\n      variableName: 'username',\n      valueExpression: `root['username']`,\n      fieldNameExpression: `'username'`,\n      parentValueExpression: 'root',\n      wildCardPath: 'username',\n      isArrayMember: false,\n      parseFnRefId: 'ref://1',\n    })", "      parseFnRefId: 'ref://1',\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `const username = defineValue(refs['ref://1'](root['username'], {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  parent: root`,\n      `}), {`,", "      `  parent: root`,\n      `}), {`,\n      `  data: root,`,\n      `  meta: meta,`,\n      `  name: 'username',`,\n      `  wildCardPath: 'username',`,\n      `  mutate: defineValue,`,\n      `  report: report,`,\n      `  isValid: true,`,\n      `  parent: root,`,", "      `  isValid: true,`,\n      `  parent: root,`,\n      `  isArrayMember: false,`,\n      '});',\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/field/validations.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineFieldValidations } from '../../../../src/scripts/field/validations.js'\n\ntest.group('Scripts | define field validations', () => {\n  test('get JS output for validations', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,", "      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: false,\n          ruleFnId: 'ref://1',\n          implicit: false,\n        },\n      ],\n      bail: true,", "      ],\n      bail: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `if (username.isValid && username.isDefined) {`,\n      `refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n    ])\n  })\n\n  test('get JS output with bail disabled', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: false,\n          ruleFnId: 'ref://1',\n          implicit: false,\n        },\n      ],\n      bail: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isDefined) {`,\n      `  refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n    ])\n  })\n\n  test('get JS output for implict rule', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: false,\n          ruleFnId: 'ref://1',\n          implicit: true,\n        },\n      ],\n      bail: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isValid) {`,\n      `  refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n    ])\n  })\n\n  test('get JS output with bail disabled and for implict rule', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: false,\n          ruleFnId: 'ref://1',\n          implicit: true,\n        },\n      ],\n      bail: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n    ])\n  })\n\n  test('get JS output for multiple validations', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: false,\n          ruleFnId: 'ref://1',\n          implicit: false,\n        },\n        {\n          isAsync: false,\n          ruleFnId: 'ref://2',\n          implicit: false,\n        },\n      ],\n      bail: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isValid && username.isDefined) {`,\n      `refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n      `if (username.isValid && username.isDefined) {`,\n      `refs['ref://2'].validator(username.value, refs['ref://2'].options, username);`,\n      `}`,\n    ])\n  })\n})\n\ntest.group('Scripts | async | define field validations', () => {\n  test('get JS output for validations', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: true,\n          ruleFnId: 'ref://1',\n          implicit: false,\n        },\n      ],\n      bail: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isValid && username.isDefined) {`,\n      `  await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n    ])\n  })\n\n  test('get JS output with bail disabled', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: true,\n          ruleFnId: 'ref://1',\n          implicit: false,\n        },\n      ],\n      bail: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isDefined) {`,\n      ` await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n    ])\n  })\n\n  test('get JS output for implict rule', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: true,\n          ruleFnId: 'ref://1',\n          implicit: true,\n        },\n      ],\n      bail: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isValid) {`,\n      `await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n    ])\n  })\n\n  test('get JS output with bail disabled and for implict rule', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: true,\n          ruleFnId: 'ref://1',\n          implicit: true,\n        },\n      ],\n      bail: false,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n    ])\n  })\n\n  test('get JS output for multiple validations', ({ assert }) => {\n    const jsOutput = defineFieldValidations({\n      variableName: 'username',\n      dropMissingCheck: false,\n      validations: [\n        {\n          isAsync: true,\n          ruleFnId: 'ref://1',\n          implicit: false,\n        },\n        {\n          isAsync: true,\n          ruleFnId: 'ref://2',\n          implicit: false,\n        },\n      ],\n      bail: true,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isValid && username.isDefined) {`,\n      `  await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n      `}`,\n      `if (username.isValid && username.isDefined) {`,\n      `  await refs['ref://2'].validator(username.value, refs['ref://2'].options, username);`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "tests/unit/scripts/field/value_output.spec.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validateCode } from '../../../../factories/code_validator.js'\nimport { defineFieldValueOutput } from '../../../../src/scripts/field/value_output.js'\n\ntest.group('Scripts | define field value output', () => {\n  test('get JS output for writing output value', ({ assert }) => {\n    const jsOutput = defineFieldValueOutput({\n      variableName: 'username',\n      outputExpression: `out['username']`,", "      variableName: 'username',\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [\n      `if (username.isDefined && username.isValid) {`,\n      `out['username'] = username.value;`,\n      `}`,\n    ])\n  })\n\n  test('get JS output for writing output value with transform function', ({ assert }) => {\n    const jsOutput = defineFieldValueOutput({\n      variableName: 'username',\n      transformFnRefId: 'ref://2',\n      outputExpression: `out['username']`,\n    })\n\n    assert.doesNotThrows(() => validateCode(jsOutput))\n    assert.assertFormatted(jsOutput, [", "      `if (username.isDefined && username.isValid) {`,\n      `out['username'] = refs['ref://2'](username.value, username);`,\n      `}`,\n    ])\n  })\n})\n"]}
{"filename": "benchmarks/nested_object.ts", "chunked_list": ["import { z } from 'zod'\n// @ts-ignore\nimport Benchmark from 'benchmark'\nimport Ajv, { AsyncValidateFunction } from 'ajv'\nimport { Compiler } from '../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../factories/messages_provider.js'\n\nconst suite = new Benchmark.Suite()\n", "const suite = new Benchmark.Suite()\n\nconst data = { profile: { username: 'virk' } }\nconst meta = {}\nconst refs = {\n  'ref://1': {\n    validator(value: unknown, _: any, field: any) {\n      if (typeof value !== 'string') {\n        field.report('Value is not a string')\n      }\n    },\n    options: {},\n  },\n}\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst zodSchema = z.object({\n  profile: z.object({\n    username: z.string(),\n  }),\n})\n\nconst compiler = new Compiler({\n  type: 'root',\n  schema: {\n    type: 'object',\n    allowNull: false,\n    isOptional: false,\n    fieldName: '*',\n    allowUnknownProperties: false,\n    bail: true,\n    properties: [\n      {\n        type: 'object',\n        propertyName: 'profile',\n        allowNull: false,\n        allowUnknownProperties: false,\n        isOptional: false,\n        fieldName: 'profile',\n        bail: true,\n        groups: [],\n        properties: [\n          {\n            type: 'literal',\n            bail: true,\n            allowNull: false,\n            fieldName: 'username',\n            propertyName: 'userName',\n            isOptional: false,\n            validations: [\n              {\n                isAsync: false,\n                ruleFnId: 'ref://1',\n                implicit: false,\n              },\n            ],\n          },\n        ],\n        validations: [],\n      },\n    ],\n    groups: [],\n    propertyName: '*',\n    validations: [],\n  },\n})\n\ncompiler.compile()\nconst fn = compiler.compile()\n\nconst ajv = new Ajv.default()\nconst ajvSchema = {\n  $async: true,\n  type: 'object',\n  properties: {\n    profile: {\n      type: 'object',\n      properties: {\n        username: { type: 'string' },\n      },\n      required: ['username'],\n    },\n  },\n  required: ['profile'],\n  additionalProperties: false,\n}\n\nconst ajvValidate = ajv.compile(ajvSchema) as AsyncValidateFunction<any>\n\nsuite\n  .add('VineJS compiler', {\n    defer: true,\n\n    // benchmark test function\n    fn: function (deferred: any) {\n      fn(data, meta, refs, messagesProvider, errorReporter).then(() => deferred.resolve())\n    },\n  })\n  .add('Ajv', {\n    defer: true,\n\n    // benchmark test function\n    fn: function (deferred: any) {\n      ajvValidate(data).then(() => deferred.resolve())\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn(deferred: any) {\n      zodSchema.parseAsync(data).then(() => deferred.resolve())\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: true })\n"]}
{"filename": "benchmarks/object_with_arrays.ts", "chunked_list": ["import { z } from 'zod'\n// @ts-ignore\nimport Benchmark from 'benchmark'\nimport Ajv, { AsyncValidateFunction } from 'ajv'\nimport { Compiler } from '../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../factories/messages_provider.js'\n\nconst suite = new Benchmark.Suite()\n", "const suite = new Benchmark.Suite()\n\nconst data = { contacts: [{ email: 'foo@bar.com' }] }\nconst meta = {}\nconst refs = {\n  'ref://1': {\n    validator(value: unknown, _: any, field: any) {\n      if (typeof value !== 'string') {\n        field.report('Value is not a string', field)\n      }\n    },\n    options: {},\n  },\n}\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst zodSchema = z.object({\n  contacts: z.array(\n    z.object({\n      email: z.string(),\n    })\n  ),\n})\n\nconst compiler = new Compiler({\n  type: 'root',\n  schema: {\n    type: 'object',\n    allowNull: false,\n    isOptional: false,\n    fieldName: '*',\n    allowUnknownProperties: false,\n    bail: true,\n    properties: [\n      {\n        type: 'array',\n        fieldName: 'contacts',\n        propertyName: 'contacts',\n        allowNull: false,\n        bail: true,\n        isOptional: false,\n        each: {\n          type: 'object',\n          propertyName: '*',\n          allowNull: false,\n          allowUnknownProperties: false,\n          isOptional: false,\n          fieldName: '*',\n          bail: true,\n          groups: [],\n          properties: [\n            {\n              type: 'literal',\n              bail: true,\n              allowNull: false,\n              fieldName: 'email',\n              propertyName: 'email',\n              isOptional: false,\n              validations: [\n                {\n                  isAsync: false,\n                  ruleFnId: 'ref://1',\n                  implicit: false,\n                },\n              ],\n            },\n          ],\n          validations: [],\n        },\n        validations: [],\n      },\n    ],\n    groups: [],\n    propertyName: '*',\n    validations: [],\n  },\n})\n\ncompiler.compile()\nconst fn = compiler.compile()\n\nconst ajv = new Ajv.default({ removeAdditional: true })\nconst ajvSchema = {\n  $async: true,\n  type: 'object',\n  properties: {\n    contacts: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          email: { type: 'string' },\n        },\n        required: ['email'],\n      },\n    },\n  },\n  required: ['contacts'],\n}\n\nconst ajvValidate = ajv.compile(ajvSchema) as AsyncValidateFunction<any>\n\nsuite\n  .add('VineJS compiler', {\n    defer: true,\n\n    // benchmark test function\n    fn: function (deferred: any) {\n      fn(data, meta, refs, messagesProvider, errorReporter).then(() => deferred.resolve())\n    },\n  })\n  .add('Ajv', {\n    defer: true,\n\n    // benchmark test function\n    fn: function (deferred: any) {\n      ajvValidate(data).then(() => deferred.resolve())\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn(deferred: any) {\n      zodSchema.parseAsync(data).then(() => deferred.resolve())\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: true })\n"]}
{"filename": "benchmarks/flat_object.ts", "chunked_list": ["import { z } from 'zod'\n// @ts-ignore\nimport Benchmark from 'benchmark'\nimport Ajv, { AsyncValidateFunction } from 'ajv'\nimport { Compiler } from '../src/compiler/main.js'\nimport { ErrorReporterFactory } from '../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../factories/messages_provider.js'\n\nconst suite = new Benchmark.Suite()\n", "const suite = new Benchmark.Suite()\n\nconst data = { username: 'virk' }\nconst meta = {}\nconst refs = {\n  'ref://1': {\n    validator(value: unknown, _: any, field: any) {\n      if (typeof value !== 'string') {\n        field.report('Value is not a string')\n      }\n    },\n    options: {},\n  },\n}\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst zodSchema = z.object({\n  username: z.string(),\n})\n\nconst compiler = new Compiler({\n  type: 'root',\n  schema: {\n    type: 'object',\n    allowNull: false,\n    isOptional: false,\n    fieldName: '*',\n    allowUnknownProperties: false,\n    bail: true,\n    properties: [\n      {\n        type: 'literal',\n        bail: true,\n        allowNull: false,\n        fieldName: 'username',\n        propertyName: 'userName',\n        isOptional: false,\n        validations: [\n          {\n            isAsync: false,\n            ruleFnId: 'ref://1',\n            implicit: false,\n          },\n        ],\n      },\n    ],\n    groups: [],\n    propertyName: '*',\n    validations: [],\n  },\n})\n\ncompiler.compile()\nconst fn = compiler.compile()\n\nconst ajv = new Ajv.default()\nconst ajvSchema = {\n  $async: true,\n  type: 'object',\n  properties: {\n    username: { type: 'string' },\n  },\n  required: ['username'],\n  additionalProperties: false,\n}\n\nconst ajvValidate = ajv.compile(ajvSchema) as AsyncValidateFunction<any>\n\nsuite\n  .add('VineJS compiler', {\n    defer: true,\n\n    // benchmark test function\n    fn: function (deferred: any) {\n      fn(data, meta, refs, messagesProvider, errorReporter).then(() => deferred.resolve())\n    },\n  })\n  .add('Ajv', {\n    defer: true,\n\n    // benchmark test function\n    fn: function (deferred: any) {\n      ajvValidate(data).then(() => deferred.resolve())\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn(deferred: any) {\n      zodSchema.parseAsync(data).then(() => deferred.resolve())\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: true })\n"]}
{"filename": "factories/create_root.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ObjectNode, RootNode } from '../src/types.js'", "\nimport { ObjectNode, RootNode } from '../src/types.js'\n\nexport function createRoot(schema: ObjectNode): RootNode {\n  return {\n    type: 'root',\n    schema: schema,\n  }\n}\n\nexport function createObjectRoot(nodes: ObjectNode['properties']): RootNode {\n  return createRoot({\n    type: 'object',\n    fieldName: '*',\n    propertyName: '*',\n    isOptional: false,\n    allowNull: false,\n    allowUnknownProperties: false,\n    bail: true,\n    properties: nodes,\n    groups: [],\n    validations: [],\n  })\n}\n", "export function createObjectRoot(nodes: ObjectNode['properties']): RootNode {\n  return createRoot({\n    type: 'object',\n    fieldName: '*',\n    propertyName: '*',\n    isOptional: false,\n    allowNull: false,\n    allowUnknownProperties: false,\n    bail: true,\n    properties: nodes,\n    groups: [],\n    validations: [],\n  })\n}\n"]}
{"filename": "factories/output.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EOL } from 'node:os'", "\nimport { EOL } from 'node:os'\nimport type { CompilerOptions } from '../src/types.js'\nimport { defineInlineErrorMessages } from '../src/scripts/define_error_messages.js'\nimport { defineInlineFunctions } from '../src/scripts/define_inline_functions.js'\n\n/**\n * Returns code for the initial output\n */\nexport function getInitialOutput(options?: CompilerOptions) {\n  return [", " */\nexport function getInitialOutput(options?: CompilerOptions) {\n  return [\n    `async function anonymous(root,meta,refs,messagesProvider,errorReporter) {`,\n    ...defineInlineErrorMessages({\n      required: 'value is required',\n      object: 'value is not a valid object',\n      array: 'value is not a valid array',\n    }).split(EOL),\n    ...defineInlineFunctions(options || { convertEmptyStringsToNull: false }).split(EOL),\n    'let out;',\n  ]\n}\n\n/**\n * Returns code for the closing output.\n */", "export function getClosingOutput() {\n  return [\n    `if(errorReporter.hasErrors) {`,\n    `  throw errorReporter.createError();`,\n    `}`,\n    `return out;`,\n    '}',\n  ]\n}\n"]}
{"filename": "factories/messages_provider.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { MessagesProviderContact } from '../src/types.js'", "\nimport { MessagesProviderContact } from '../src/types.js'\n\nexport class MessagesProviderFactory {\n  create() {\n    const provider: MessagesProviderContact = {\n      getMessage(defaultMessage) {\n        return defaultMessage\n      },\n    }\n\n    return provider\n  }\n}\n"]}
{"filename": "factories/code_validator.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { parse } from 'acorn'", "\nimport { parse } from 'acorn'\n\n/**\n * Validates a JS snippet using acorn\n */\nexport function validateCode(input: string) {\n  parse(input, { ecmaVersion: 2020, allowAwaitOutsideFunction: true })\n}\n"]}
{"filename": "factories/code_beautifier.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n// @ts-expect-error", "\n// @ts-expect-error\nimport js from 'js-beautify'\n\n/**\n * Validates a JS snippet using acorn\n */\nexport function beautifyCode(input: string | string[]) {\n  return {\n    value: js(Array.isArray(input) ? input.join('\\n') : input, {\n      indent_size: '2',\n      indent_char: ' ',\n      max_preserve_newlines: '-1',\n      preserve_newlines: false,\n      keep_array_indentation: false,\n      break_chained_methods: false,\n      indent_scripts: 'normal',\n      brace_style: 'collapse',\n      space_before_conditional: true,\n      unescape_strings: false,\n      jslint_happy: false,\n      end_with_newline: false,\n      wrap_line_length: '0',\n      indent_inner_html: false,\n      comma_first: false,\n      e4x: false,\n      indent_empty_lines: false,\n    }),\n    toString() {\n      return this.value\n    },\n    toArray() {\n      return this.value.split('\\n')\n    },\n  }\n}\n"]}
{"filename": "factories/error_reporter.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ErrorReporterContract } from '../src/types.js'", "\nimport { ErrorReporterContract } from '../src/types.js'\n\nclass ValidationError extends Error {\n  declare messages: string[]\n}\n\nexport class ErrorReporterFactory {\n  create() {\n    const reporter = {\n      messages: [] as string[],\n      hasErrors: false,\n      report(message: string) {\n        this.hasErrors = true\n        this.messages.push(message)\n      },\n      createError() {\n        const error = new ValidationError('Validation failure')\n        error.messages = this.messages\n        return error\n      },\n    }\n\n    return reporter satisfies ErrorReporterContract\n  }\n}\n"]}
{"filename": "examples/object_groups/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\nimport { beautifyCode } from '../../factories/code_beautifier.js'\nimport { refs, schema } from './schema.js'\nimport { ErrorReporterFactory } from '../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\nconst compiler = new Compiler(schema)\nconst fn = compiler.compile()\n\nconsole.log('========= COMPILED OUTPUT =========')", "\nconsole.log('========= COMPILED OUTPUT =========')\nconsole.log(beautifyCode(fn.toString()).toString())\nconsole.log('========= END COMPILED OUTPUT =========')\n\nconst data = {\n  email: 'foo',\n  password: 'secret',\n}\nconst messagesProvider = new MessagesProviderFactory().create()", "}\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\nconsole.log('')\nconsole.log('========= VALIDATED OUTPUT =========')\nconsole.log(output)\nconsole.log('========= END VALIDATED OUTPUT =========')", "console.log(output)\nconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/object_groups/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\nexport const schema: RootNode = {\n  type: 'root',\n  schema: {\n    type: 'object',\n    fieldName: '*',\n    propertyName: '*',\n    allowNull: false,\n    isOptional: false,", "    allowNull: false,\n    isOptional: false,\n    allowUnknownProperties: false,\n    bail: true,\n    validations: [],\n    groups: [\n      {\n        type: 'group',\n        conditions: [\n          {", "        conditions: [\n          {\n            conditionalFnRefId: 'ref://1',\n            schema: {\n              type: 'sub_object',\n              groups: [],\n              properties: [\n                {\n                  type: 'literal',\n                  fieldName: 'email',", "                  type: 'literal',\n                  fieldName: 'email',\n                  propertyName: 'email',\n                  allowNull: false,\n                  isOptional: false,\n                  bail: true,\n                  validations: [],\n                },\n              ],\n            },", "              ],\n            },\n          },\n          {\n            conditionalFnRefId: 'ref://2',\n            schema: {\n              type: 'sub_object',\n              groups: [],\n              properties: [\n                {", "              properties: [\n                {\n                  type: 'literal',\n                  fieldName: 'username',\n                  propertyName: 'username',\n                  allowNull: false,\n                  isOptional: false,\n                  bail: true,\n                  validations: [],\n                },", "                  validations: [],\n                },\n              ],\n            },\n          },\n        ],\n      },\n    ],\n    properties: [\n      {", "    properties: [\n      {\n        type: 'literal',\n        fieldName: 'password',\n        propertyName: 'password',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        validations: [],\n      },", "        validations: [],\n      },\n    ],\n  },\n}\n\nexport const refs = {\n  'ref://1': () => true,\n  'ref://2': () => false,\n}", "  'ref://2': () => false,\n}\n"]}
{"filename": "examples/nested_object/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\nimport { beautifyCode } from '../../factories/code_beautifier.js'\nimport { refs, schema } from './schema.js'\nimport { ErrorReporterFactory } from '../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\nconst compiler = new Compiler(schema)\nconst fn = compiler.compile()\n\nconsole.log('========= COMPILED OUTPUT =========')", "\nconsole.log('========= COMPILED OUTPUT =========')\nconsole.log(beautifyCode(fn.toString()).toString())\nconsole.log('========= END COMPILED OUTPUT =========')\n\nconst data = {\n  id: 1,\n  profile: {\n    twitter_handle: 'foo',\n    github_username: 'foo',", "    twitter_handle: 'foo',\n    github_username: 'foo',\n  },\n}\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\nconsole.log('')", "\nconsole.log('')\nconsole.log('========= VALIDATED OUTPUT =========')\nconsole.log(output)\nconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/nested_object/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\nexport const schema: RootNode = {\n  type: 'root',\n  schema: {\n    type: 'object',\n    allowNull: false,\n    isOptional: false,\n    fieldName: '*',\n    propertyName: '*',", "    fieldName: '*',\n    propertyName: '*',\n    allowUnknownProperties: false,\n    bail: true,\n    properties: [\n      {\n        type: 'literal',\n        fieldName: 'id',\n        propertyName: 'id',\n        allowNull: false,", "        propertyName: 'id',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        validations: [],\n      },\n      {\n        type: 'object',\n        fieldName: 'profile',\n        propertyName: 'profile',", "        fieldName: 'profile',\n        propertyName: 'profile',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        validations: [],\n        groups: [],\n        allowUnknownProperties: false,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: true,\n            bail: true,\n            fieldName: 'twitter_handle',\n            propertyName: 'twitterHandle',\n            validations: [],\n          },", "            validations: [],\n          },\n          {\n            type: 'literal',\n            allowNull: false,\n            isOptional: false,\n            bail: true,\n            fieldName: 'github_username',\n            propertyName: 'githubUsername',\n            validations: [],", "            propertyName: 'githubUsername',\n            validations: [],\n          },\n        ],\n      },\n    ],\n    groups: [],\n    validations: [],\n  },\n}", "  },\n}\nexport const refs = {}\n"]}
{"filename": "examples/array_union/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\nimport { beautifyCode } from '../../factories/code_beautifier.js'\nimport { refs, schema } from './schema.js'\nimport { ErrorReporterFactory } from '../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\nconst compiler = new Compiler(schema)\nconst fn = compiler.compile()\n\nconsole.log('========= COMPILED OUTPUT =========')", "\nconsole.log('========= COMPILED OUTPUT =========')\nconsole.log(beautifyCode(fn.toString()).toString())\nconsole.log('========= END COMPILED OUTPUT =========')\n\nconst data = [\n  {\n    phone: '1234',\n  },\n  {", "  },\n  {\n    phone: '5678',\n  },\n]\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n", "const output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\nconsole.log('')\nconsole.log('========= VALIDATED OUTPUT =========')\nconsole.log(output)\nconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/array_union/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\nexport const schema: RootNode = {\n  type: 'root',\n  schema: {\n    type: 'array',\n    fieldName: '*',\n    propertyName: '*',\n    allowNull: false,\n    isOptional: false,", "    allowNull: false,\n    isOptional: false,\n    bail: true,\n    validations: [],\n    each: {\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n      conditions: [\n        {", "      conditions: [\n        {\n          conditionalFnRefId: 'ref://1',\n          schema: {\n            type: 'object',\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            groups: [],\n            properties: [", "            groups: [],\n            properties: [\n              {\n                type: 'literal',\n                fieldName: 'phone',\n                propertyName: 'phone',\n                allowNull: false,\n                isOptional: false,\n                bail: true,\n                validations: [],", "                bail: true,\n                validations: [],\n              },\n            ],\n            fieldName: '*',\n            propertyName: '*',\n            isOptional: false,\n            validations: [],\n          },\n        },", "          },\n        },\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            type: 'object',\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            groups: [],", "            bail: true,\n            groups: [],\n            properties: [\n              {\n                type: 'literal',\n                fieldName: 'email',\n                propertyName: 'email',\n                allowNull: false,\n                isOptional: false,\n                bail: true,", "                isOptional: false,\n                bail: true,\n                validations: [],\n              },\n            ],\n            fieldName: '*',\n            propertyName: '*',\n            isOptional: false,\n            validations: [],\n          },", "            validations: [],\n          },\n        },\n      ],\n    },\n  },\n}\n\nexport const refs = {\n  'ref://1': () => true,", "export const refs = {\n  'ref://1': () => true,\n  'ref://2': () => false,\n}\n"]}
{"filename": "examples/flat_object/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\nimport { beautifyCode } from '../../factories/code_beautifier.js'\nimport { refs, schema } from './schema.js'\nimport { ErrorReporterFactory } from '../../factories/error_reporter.js'\nimport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\nconst compiler = new Compiler(schema)\nconst fn = compiler.compile()\n\nconsole.log('========= COMPILED OUTPUT =========')", "\nconsole.log('========= COMPILED OUTPUT =========')\nconsole.log(beautifyCode(fn.toString()).toString())\nconsole.log('========= END COMPILED OUTPUT =========')\n\nconst data = {\n  username: 'virk',\n  email: 'foo@bar.com',\n  password: 'secret',\n  additionalProperty: 'foo',", "  password: 'secret',\n  additionalProperty: 'foo',\n}\nconst messagesProvider = new MessagesProviderFactory().create()\nconst errorReporter = new ErrorReporterFactory().create()\n\nconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\nconsole.log('')\nconsole.log('========= VALIDATED OUTPUT =========')", "console.log('')\nconsole.log('========= VALIDATED OUTPUT =========')\nconsole.log(output)\nconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/flat_object/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\nexport const schema: RootNode = {\n  type: 'root',\n  schema: {\n    type: 'object',\n    fieldName: '*',\n    propertyName: '*',\n    allowNull: false,\n    isOptional: false,", "    allowNull: false,\n    isOptional: false,\n    allowUnknownProperties: false,\n    bail: true,\n    properties: [\n      {\n        type: 'literal',\n        fieldName: 'username',\n        propertyName: 'userName',\n        allowNull: false,", "        propertyName: 'userName',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        validations: [],\n      },\n      {\n        type: 'literal',\n        fieldName: 'email',\n        propertyName: 'email',", "        fieldName: 'email',\n        propertyName: 'email',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        validations: [],\n      },\n      {\n        type: 'literal',\n        fieldName: 'password',", "        type: 'literal',\n        fieldName: 'password',\n        propertyName: 'password',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        validations: [],\n      },\n    ],\n    groups: [],", "    ],\n    groups: [],\n    validations: [],\n  },\n}\n\nexport const refs = {}\n"]}
{"filename": "src/refs_builder.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type {", "\nimport type {\n  Refs,\n  ParseFn,\n  RefsStore,\n  TransformFn,\n  ConditionalFn,\n  RefIdentifier,\n  ValidationRule,\n} from './types.js'", "  ValidationRule,\n} from './types.js'\n\n/**\n * Creates a refs store for parsing the schema\n */\nexport function refsBuilder(): RefsStore {\n  let counter = 0\n  const refs: Refs = {}\n\n  return {\n    toJSON() {\n      return refs\n    },\n\n    /**\n     * Track a value inside refs\n     */\n    track(value: Refs[keyof Refs]): RefIdentifier {\n      counter++\n      const ref = `ref://${counter}` as const\n      refs[ref] = value\n      return ref\n    },\n\n    /**\n     * Track a validation inside refs\n     */\n    trackValidation(validation: ValidationRule): RefIdentifier {\n      return this.track(validation)\n    },\n\n    /**\n     * Track input value parser inside refs\n     */\n    trackParser(fn: ParseFn): RefIdentifier {\n      return this.track(fn)\n    },\n\n    /**\n     * Track output value transformer inside refs\n     */\n    trackTransformer(fn: TransformFn<any, any>): RefIdentifier {\n      return this.track(fn)\n    },\n\n    /**\n     * Track a conditional inside refs\n     */\n    trackConditional(fn: ConditionalFn<any>): RefIdentifier {\n      return this.track(fn)\n    },\n  }\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Represenation of a ref id\n */\nexport type RefIdentifier = `ref://${number}`\n\n/**\n * Allowed values for refs\n */\nexport type Refs = Record<\n  RefIdentifier,\n  ValidationRule | TransformFn<any, any> | ParseFn | ConditionalFn<any>\n>\n\n/**\n * Refs store to track runtime values as refs with", "export type Refs = Record<\n  RefIdentifier,\n  ValidationRule | TransformFn<any, any> | ParseFn | ConditionalFn<any>\n>\n\n/**\n * Refs store to track runtime values as refs with\n * type safety\n */\nexport type RefsStore = {\n  toJSON(): Refs\n\n  /**\n   * Track a value inside refs\n   */\n  track(value: Refs[keyof Refs]): RefIdentifier\n\n  /**\n   * Track a validation inside refs\n   */\n  trackValidation(validation: ValidationRule): RefIdentifier\n\n  /**\n   * Track input value parser inside refs\n   */\n  trackParser(fn: ParseFn): RefIdentifier\n\n  /**\n   * Track output value transformer inside refs\n   */\n  trackTransformer(fn: TransformFn<any, any>): RefIdentifier\n\n  /**\n   * Track a conditional inside refs\n   */\n  trackConditional(fn: ConditionalFn<any>): RefIdentifier\n}\n\n/**\n * The context shared with the entire validation pipeline.\n * Each field gets its own context object.\n */", "export type RefsStore = {\n  toJSON(): Refs\n\n  /**\n   * Track a value inside refs\n   */\n  track(value: Refs[keyof Refs]): RefIdentifier\n\n  /**\n   * Track a validation inside refs\n   */\n  trackValidation(validation: ValidationRule): RefIdentifier\n\n  /**\n   * Track input value parser inside refs\n   */\n  trackParser(fn: ParseFn): RefIdentifier\n\n  /**\n   * Track output value transformer inside refs\n   */\n  trackTransformer(fn: TransformFn<any, any>): RefIdentifier\n\n  /**\n   * Track a conditional inside refs\n   */\n  trackConditional(fn: ConditionalFn<any>): RefIdentifier\n}\n\n/**\n * The context shared with the entire validation pipeline.\n * Each field gets its own context object.\n */", "export type FieldContext = {\n  /**\n   * Field value\n   */\n  value: unknown\n\n  /**\n   * The data property is the top-level object under validation.\n   */\n  data: any\n\n  /**\n   * Shared metadata across the entire validation lifecycle. It can be\n   * used to pass data between validation rules\n   */\n  meta: Record<string, any>\n\n  /**\n   * Mutate the value of field under validation.\n   */\n  mutate(newValue: any, field: FieldContext): void\n\n  /**\n   * Report error to the error reporter\n   */\n  report: ErrorReporterContract['report']\n\n  /**\n   * Is this field valid. Default: true\n   */\n  isValid: boolean\n\n  /**\n   * Is this field has value defined.\n   */\n  isDefined: boolean\n\n  /**\n   * Wildcard path for the field. The value is a nested\n   * pointer to the field under validation.\n   *\n   * In case of arrays, the `*` wildcard is used.\n   */\n  wildCardPath: string\n\n  /**\n   * The parent property is the parent of the field. It could be an\n   * array or an object.\n   */\n  parent: any\n\n  /**\n   * Name of the field under validation. In case of an array, the field\n   * name will be a number\n   */\n  name: string | number\n\n  /**\n   * Is this field an array member\n   */\n  isArrayMember: boolean\n}\n\n/**\n * The shape of validation rule picked from the\n * refs\n */", "export type ValidationRule = {\n  /**\n   * Performs validation\n   */\n  validator(value: unknown, options: any, field: FieldContext): any\n\n  /**\n   * Options to pass\n   */\n  options?: any\n}\n\n/**", " * The shape of parse function picked from the refs\n */\nexport type ParseFn = (value: unknown, ctx: Pick<FieldContext, 'data' | 'parent' | 'meta'>) => any\n\n/**\n * The shape of transform function picked from the refs\n */\nexport type TransformFn<Input, Output> = (value: Input, field: FieldContext) => Output\n\n/**\n * The shape of conditional function used for narrowing down unions.\n */", " * The shape of conditional function used for narrowing down unions.\n */\nexport type ConditionalFn<Input> = (value: Input, field: FieldContext) => boolean\n\n/**\n * Shape of a validation rule accepted by the compiler\n */\nexport type ValidationNode = {\n  /**\n   * Rule implementation function id.\n   */\n  ruleFnId: RefIdentifier\n\n  /**\n   * Is this an async rule. This flag helps creating an optimized output\n   */\n  isAsync: boolean\n\n  /**\n   * The rules are skipped when the value of a field is \"null\" or \"undefined\".\n   * Unless, the \"implicit\" flag is true\n   */\n  implicit: boolean\n}\n\n/**\n * Shape of field inside a schema.\n */", "   * Rule implementation function id.\n   */\n  ruleFnId: RefIdentifier\n\n  /**\n   * Is this an async rule. This flag helps creating an optimized output\n   */\n  isAsync: boolean\n\n  /**\n   * The rules are skipped when the value of a field is \"null\" or \"undefined\".\n   * Unless, the \"implicit\" flag is true\n   */\n  implicit: boolean\n}\n\n/**\n * Shape of field inside a schema.\n */", "export type FieldNode = {\n  /**\n   * Should the validation cycle stop after the first error.\n   * Defaults to true\n   */\n  bail: boolean\n\n  /**\n   * Field name refers to the name of the field under the data\n   * object\n   */\n  fieldName: string\n\n  /**\n   * Name of the output property. This allows validating a field with a different name, but\n   * storing its output value with a different name.\n   */\n  propertyName: string\n\n  /**\n   * Are we expecting this field to be undefined or null\n   */\n  isOptional: boolean\n\n  /**\n   * Are we expecting this field to be null\n   */\n  allowNull: boolean\n\n  /**\n   * The reference id for the parse method. Parse method is called to mutate the", "   * initial value. The function is executed always even when value is undefined\n   * or null.\n   *\n   * @see [[ParseFn]]\n   */\n  parseFnId?: RefIdentifier\n\n  /**\n   * A set of validations to apply on the field\n   */\n  validations: ValidationNode[]\n}\n\n/**\n * Shape of a single field accepted by the compiler\n */", "export type LiteralNode = FieldNode & {\n  type: 'literal'\n\n  /**\n   * Transform the output value of a field. The output of this method is the\n   * final source of truth. The function is executed at the time of writing the\n   * value to the output.\n   */\n  transformFnId?: RefIdentifier\n}\n\n/**\n * Shape of the object node accepted by the compiler\n */", "export type ObjectNode = FieldNode & {\n  type: 'object'\n\n  /**\n   * Whether or not to allow unknown properties. When disabled, the\n   * output object will have only validated properties.\n   *\n   * Default: false\n   */\n  allowUnknownProperties: boolean\n\n  /**\n   * Object known properties\n   */\n  properties: CompilerNodes[]\n\n  /**\n   * A collection of object groups to merge into the main object.\n   * Each group is a collection of conditionals with a sub-object\n   * inside them.\n   */\n  groups: ObjectGroupNode[]\n}\n\n/**\n * A compiler object group produces a single sub object based upon\n * the defined conditions.\n */", "export type ObjectGroupNode = {\n  type: 'group'\n\n  /**\n   * An optional function to call when all of the conditions\n   * are false.\n   */\n  elseConditionalFnRefId?: RefIdentifier\n\n  /**\n   * Conditions to evaluate\n   */\n  conditions: {\n    /**", "     * The conditional function reference id\n     */\n    conditionalFnRefId: RefIdentifier\n\n    /**\n     * Schema to use when condition is true\n     */\n    schema: {\n      type: 'sub_object'\n\n      /**\n       * Object known properties\n       */\n      properties: CompilerNodes[]\n\n      /**\n       * A collection of object groups to merge into the main object.\n       * Each group is a collection of conditionals with a sub-object\n       * inside them.\n       */\n      groups: ObjectGroupNode[]\n    }\n  }[]\n}\n\n/**\n * Shape of the tuple node accepted by the compiler\n */", "export type TupleNode = FieldNode & {\n  type: 'tuple'\n\n  /**\n   * Whether or not to allow unknown properties. When disabled, the\n   * output array will have only validated properties.\n   *\n   * Default: false\n   */\n  allowUnknownProperties: boolean\n\n  /**\n   * Tuple known properties\n   */\n  properties: CompilerNodes[]\n}\n\n/**\n * Shape of the record node accepted by the compiler\n */", "export type RecordNode = FieldNode & {\n  type: 'record'\n\n  /**\n   * Captures object elements\n   */\n  each: CompilerNodes\n}\n\n/**\n * Shape of the array node accepted by the compiler\n */", "export type ArrayNode = FieldNode & {\n  type: 'array'\n\n  /**\n   * Captures array elements\n   */\n  each: CompilerNodes\n}\n\n/**\n * Shape of the union node accepted by the compiler. A union is a combination\n * of conditionals.\n */", "export type UnionNode = {\n  type: 'union'\n\n  /**\n   * Field name refers to the name of the field under the data\n   * object\n   */\n  fieldName: string\n\n  /**\n   * Name of the output property. This allows validating a field with a different name, but\n   * storing its value with a different name.\n   */\n  propertyName: string\n\n  /**", "   * An optional function to call when all of the conditions\n   * are false.\n   */\n  elseConditionalFnRefId?: RefIdentifier\n\n  /**\n   * Conditions to evaluate\n   */\n  conditions: {\n    /**\n     * The conditional function reference id\n     */\n    conditionalFnRefId: RefIdentifier\n\n    /**\n     * Schema to use when condition is true\n     */\n    schema: CompilerNodes\n  }[]\n}\n\n/**\n * The root of the schema\n */", "     * The conditional function reference id\n     */\n    conditionalFnRefId: RefIdentifier\n\n    /**\n     * Schema to use when condition is true\n     */\n    schema: CompilerNodes\n  }[]\n}\n\n/**\n * The root of the schema\n */", "export type RootNode = {\n  type: 'root'\n\n  /**\n   * Schema at the root level\n   */\n  schema: CompilerNodes\n}\n\n/**\n * Known tree nodes accepted by the compiler\n */", "export type CompilerNodes =\n  | LiteralNode\n  | ObjectNode\n  | ArrayNode\n  | UnionNode\n  | RecordNode\n  | TupleNode\n\n/**\n * Properties of a parent node as the compiler loops through the\n * rules tree and constructs JS code.\n */", "export type CompilerParent = {\n  type: 'array' | 'object' | 'tuple' | 'record' | 'root'\n\n  /**\n   * Wildcard path to the field\n   */\n  wildCardPath: string\n\n  /**\n   * Name of the variable for the parent property. The variable name\n   * is used to lookup values from the parent\n   */\n  variableName: string\n\n  /**\n   * Nested path to the parent field. If the parent is nested inside\n   * an object or array.\n   */\n  fieldPathExpression: string\n\n  /**\n   * The expression for the output value.\n   */\n  outputExpression: string\n}\n\n/**\n * Compiler field is used to compute the variable and property\n * names for the JS output.\n */", "export type CompilerField = {\n  parentValueExpression: string\n  fieldNameExpression: string\n  fieldPathExpression: string\n  variableName: string\n  wildCardPath: string\n  valueExpression: string\n  outputExpression: string\n  isArrayMember: boolean\n}\n\n/**\n * The error reporter is used for reporting validation\n * errors.\n */", "export interface ErrorReporterContract {\n  /**\n   * A boolean to known if there are one or more\n   * errors.\n   */\n  hasErrors: boolean\n\n  /**\n   * Creates an instance of an exception to throw\n   */\n  createError(): Error\n\n  /**\n   * Report error for a field\n   */\n  report(message: string, rule: string, field: FieldContext, args?: Record<string, any>): any\n}\n\n/**\n * Messages provider is used to resolve validation error messages\n * during validation.\n */", "export interface MessagesProviderContact {\n  /**\n   * Returns a validation message for a given field + rule. The args\n   * may get passed by a validation rule to share additional context.\n   */\n  getMessage(\n    defaultMessage: string,\n    rule: string,\n    field: FieldContext,\n    args?: Record<string, any>\n  ): string\n}\n\n/**\n * Options accepted by the compiler\n */", "export type CompilerOptions = {\n  /**\n   * Convert empty string values to null for sake of\n   * normalization\n   */\n  convertEmptyStringsToNull: boolean\n\n  /**\n   * Provide messages to use for required, object and\n   * array validations.\n   */\n  messages?: Partial<{\n    required: string\n    object: string\n    array: string\n  }>\n}\n"]}
{"filename": "src/scripts/define_inline_functions.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Returns JS fragment for inline function needed by the\n * validation runtime code.\n */", "\n/**\n * Returns JS fragment for inline function needed by the\n * validation runtime code.\n */\nexport function defineInlineFunctions(options: { convertEmptyStringsToNull: boolean }) {\n  return `function report(message, rule, field, args) {\n  field.isValid = false;\n  errorReporter.report(messagesProvider.getMessage(message, rule, field, args), rule, field, args);\n};\nfunction defineValue(value, field) {", "function defineValue(value, field) {\n  ${options.convertEmptyStringsToNull ? `if (value === '') { value = null; }` : ''}\n  field.value = value;\n  field.isDefined = value !== undefined && value !== null;\n  return field;\n};\nfunction ensureExists(field) {\n  if (field.value === undefined || field.value === null) {\n    field.report(REQUIRED, 'required', field);\n    return false;\n  }\n  return true;\n};", "function ensureIsDefined(field) {\n  if (field.value === undefined) {\n    field.report(REQUIRED, 'required', field);\n    return false;\n  }\n  return true;\n};\nfunction ensureIsObject(field) {\n  if (!field.isDefined) {\n    return false;\n  }", "  if (!field.isDefined) {\n    return false;\n  }\n  if (typeof field.value == 'object' && !Array.isArray(field.value)) {\n    return true;\n  }\n  field.report(NOT_AN_OBJECT, 'object', field);\n  return false;\n};\nfunction ensureIsArray(field) {\n  if (!field.isDefined) {\n    return false;\n  }", "function ensureIsArray(field) {\n  if (!field.isDefined) {\n    return false;\n  }\n  if (Array.isArray(field.value)) {\n    return true;\n  }\n  field.report(NOT_AN_ARRAY, 'array', field);\n  return false;\n};\nfunction copyProperties(val) {\n  let k, out, tmp;\n", "function copyProperties(val) {\n  let k, out, tmp;\n\n  if (Array.isArray(val)) {\n    out = Array((k = val.length))\n    while (k--) out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp\n    return out\n  }\n\n  if (Object.prototype.toString.call(val) === '[object Object]') {\n    out = {} // null", "  if (Object.prototype.toString.call(val) === '[object Object]') {\n    out = {} // null\n    for (k in val) {\n      out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp\n    }\n    return out\n  }\n  return val\n};\nfunction moveProperties(source, destination, ignoreKeys) {\n  for (let key in source) {", "function moveProperties(source, destination, ignoreKeys) {\n  for (let key in source) {\n    if (!ignoreKeys.includes(key)) {\n      const value = source[key]\n      destination[key] = copyProperties(value)\n    }\n  }\n};`\n}\n"]}
{"filename": "src/scripts/define_else_conditon.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ConditionalGuardOptions = {\n  variableName: string\n  conditionalFnRefId: string\n}\n\n/**", "\ntype ConditionalGuardOptions = {\n  variableName: string\n  conditionalFnRefId: string\n}\n\n/**\n * Returns JS fragment to invoke a function inside else block\n */\nexport function defineElseCondition({ variableName, conditionalFnRefId }: ConditionalGuardOptions) {\n  return `else {\nrefs['${conditionalFnRefId}'](${variableName}.value, ${variableName});\n}`\n}\n", "export function defineElseCondition({ variableName, conditionalFnRefId }: ConditionalGuardOptions) {\n  return `else {\nrefs['${conditionalFnRefId}'](${variableName}.value, ${variableName});\n}`\n}\n"]}
{"filename": "src/scripts/report_errors.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Returns JS fragment to report errors\n */\nexport function reportErrors() {\n  return `if(errorReporter.hasErrors) {\n  throw errorReporter.createError();\n}`\n}\n"]}
{"filename": "src/scripts/define_error_messages.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { CompilerOptions } from '../types.js'", "\nimport { CompilerOptions } from '../types.js'\n\n/**\n * Returns JS fragment for inline error messages for errors raised\n * by the compiler.\n */\nexport function defineInlineErrorMessages(\n  messages: Required<Exclude<CompilerOptions['messages'], undefined>>\n) {\n  return `const REQUIRED = '${messages.required}';\nconst NOT_AN_OBJECT = '${messages.object}';\nconst NOT_AN_ARRAY = '${messages.array}';`\n}\n"]}
{"filename": "src/scripts/define_conditional_guard.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ConditionalGuardOptions = {\n  variableName: string\n  conditionalFnRefId: string\n  guardedCodeSnippet: string\n  conditional: 'if' | 'else if'\n}\n\n/**\n * Returns JS fragment to wrap code inside a conditional guard\n */", "\ntype ConditionalGuardOptions = {\n  variableName: string\n  conditionalFnRefId: string\n  guardedCodeSnippet: string\n  conditional: 'if' | 'else if'\n}\n\n/**\n * Returns JS fragment to wrap code inside a conditional guard\n */", "export function defineConditionalGuard({\n  conditional,\n  variableName,\n  conditionalFnRefId,\n  guardedCodeSnippet,\n}: ConditionalGuardOptions) {\n  return `${conditional}(refs['${conditionalFnRefId}'](${variableName}.value, ${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n"]}
{"filename": "src/scripts/object/initial_output.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  variableName: string\n  outputExpression: string\n  outputValueExpression: string\n}\n\n/**\n * Returns JS fragment for writing the initial output for an object\n */", "export function defineObjectInitialOutput({\n  variableName,\n  outputExpression,\n  outputValueExpression,\n}: OutputOptions) {\n  return `const ${variableName}_out = ${outputValueExpression};\n${outputExpression} = ${variableName}_out;`\n}\n"]}
{"filename": "src/scripts/object/move_unknown_properties.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { inspect } from 'node:util'", "\nimport { inspect } from 'node:util'\n\n/**\n * Options accepts by the output script\n */\ntype MovePropertiesOptions = {\n  variableName: string\n  allowUnknownProperties: boolean\n  fieldsToIgnore: string[]\n}\n\n/**\n * Returns JS fragment for moving properties from the source\n * to destination\n */", "export function defineMoveProperties({\n  variableName,\n  fieldsToIgnore,\n  allowUnknownProperties,\n}: MovePropertiesOptions) {\n  if (!allowUnknownProperties) {\n    return ''\n  }\n  return `moveProperties(${variableName}.value, ${variableName}_out, ${inspect(fieldsToIgnore)});`\n}\n"]}
{"filename": "src/scripts/object/guard.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ObjectGuardOptions = {\n  variableName: string\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside an object conditional\n */", "\ntype ObjectGuardOptions = {\n  variableName: string\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside an object conditional\n */\nexport function defineObjectGuard({ variableName, guardedCodeSnippet }: ObjectGuardOptions) {\n  return `if (ensureIsObject(${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n", "export function defineObjectGuard({ variableName, guardedCodeSnippet }: ObjectGuardOptions) {\n  return `if (ensureIsObject(${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n"]}
{"filename": "src/scripts/union/parse.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { RefIdentifier } from '../../types.js'", "\nimport type { RefIdentifier } from '../../types.js'\n\ntype FieldOptions = {\n  variableName: string\n  parseFnRefId?: RefIdentifier\n}\n\n/**\n * Returns JS fragment to call the parse function on the union conditional\n * schema.\n */", " * Returns JS fragment to call the parse function on the union conditional\n * schema.\n */\nexport function callParseFunction({ parseFnRefId, variableName }: FieldOptions) {\n  if (parseFnRefId) {\n    return `${variableName}.value = refs['${parseFnRefId}'](${variableName}.value);`\n  }\n  return ''\n}\n"]}
{"filename": "src/scripts/record/loop.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Options accepts by the loop script\n */\ntype RecordLoopOptions = {\n  variableName: string\n  loopCodeSnippet: string\n}\n\n/**\n * Returns JS fragment for wrapping code inside an record loop\n */", "export function defineRecordLoop({ variableName, loopCodeSnippet }: RecordLoopOptions) {\n  return `const ${variableName}_keys = Object.keys(${variableName}.value);\nconst ${variableName}_keys_size = ${variableName}_keys.length;\nfor (let ${variableName}_key_i = 0; ${variableName}_key_i < ${variableName}_keys_size; ${variableName}_key_i++) {\nconst ${variableName}_i = ${variableName}_keys[${variableName}_key_i];\n${loopCodeSnippet}\n}`\n}\n"]}
{"filename": "src/scripts/array/loop.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Options accepts by the loop script\n */\ntype ArrayLoopOptions = {\n  variableName: string\n  loopCodeSnippet: string\n  startingIndex?: number\n}\n\n/**\n * Returns JS fragment for wrapping code inside an array loop\n */", "export function defineArrayLoop({\n  variableName,\n  loopCodeSnippet,\n  startingIndex,\n}: ArrayLoopOptions) {\n  startingIndex = startingIndex || 0\n  return `const ${variableName}_items_size = ${variableName}.value.length;\nfor (let ${variableName}_i = ${startingIndex}; ${variableName}_i < ${variableName}_items_size; ${variableName}_i++) {\n${loopCodeSnippet}\n}`\n}\n"]}
{"filename": "src/scripts/array/initial_output.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  variableName: string\n  outputExpression: string\n  outputValueExpression: string\n}\n\n/**\n * Returns JS fragment for writing the initial output for an array\n */", "export function defineArrayInitialOutput({\n  variableName,\n  outputExpression,\n  outputValueExpression,\n}: OutputOptions) {\n  return `const ${variableName}_out = ${outputValueExpression};\n${outputExpression} = ${variableName}_out;`\n}\n"]}
{"filename": "src/scripts/array/guard.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ArrayGuardOptions = {\n  variableName: string\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside an array conditional\n */", "\ntype ArrayGuardOptions = {\n  variableName: string\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside an array conditional\n */\nexport function defineArrayGuard({ variableName, guardedCodeSnippet }: ArrayGuardOptions) {\n  return `if (ensureIsArray(${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n", "export function defineArrayGuard({ variableName, guardedCodeSnippet }: ArrayGuardOptions) {\n  return `if (ensureIsArray(${variableName})) {\n${guardedCodeSnippet}\n}`\n}\n"]}
{"filename": "src/scripts/field/existence_validations.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype FieldOptions = {\n  variableName: string\n  isOptional: boolean\n  allowNull: boolean\n}\n\n/**\n * Returns JS fragment to validate a field's value for existence.\n */", "\ntype FieldOptions = {\n  variableName: string\n  isOptional: boolean\n  allowNull: boolean\n}\n\n/**\n * Returns JS fragment to validate a field's value for existence.\n */\nexport function defineFieldExistenceValidations({\n  allowNull,\n  isOptional,\n  variableName,\n}: FieldOptions): string {\n  /**\n   * Validations are only performed when `isOptional` flag\n   * is disabled.\n   */", "export function defineFieldExistenceValidations({\n  allowNull,\n  isOptional,\n  variableName,\n}: FieldOptions): string {\n  /**\n   * Validations are only performed when `isOptional` flag\n   * is disabled.\n   */\n  if (isOptional === false) {\n    /**\n     * When `allowNull` flag is disabled, we should ensure the value\n     * is not null and neither undefined.\n     */", "  if (isOptional === false) {\n    /**\n     * When `allowNull` flag is disabled, we should ensure the value\n     * is not null and neither undefined.\n     */\n    if (allowNull === false) {\n      return `ensureExists(${variableName});`\n    } else {\n      /**\n       * Otherwise ensure the value is not undefined.\n       */\n      return `ensureIsDefined(${variableName});`\n    }\n  }\n\n  return ''\n}\n"]}
{"filename": "src/scripts/field/variables.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RefIdentifier } from '../../types.js'", "\nimport { RefIdentifier } from '../../types.js'\n\ntype FieldOptions = {\n  variableName: string\n  valueExpression: string\n  fieldNameExpression: string\n  wildCardPath: string\n  parentValueExpression: string\n  isArrayMember: boolean\n  parseFnRefId?: RefIdentifier\n}\n\n/**\n * Returns JS fragment for defining the field variables. It includes, the field\n * value variable, context variable, and a boolean to know if the field\n * exists.\n */", "export function defineFieldVariables({\n  parseFnRefId,\n  variableName,\n  wildCardPath,\n  isArrayMember,\n  valueExpression,\n  fieldNameExpression,\n  parentValueExpression,\n}: FieldOptions) {\n  const inValueExpression = parseFnRefId\n    ? `refs['${parseFnRefId}'](${valueExpression}, {\n      data: root,\n      meta: meta,\n      parent: ${parentValueExpression}\n    })`\n    : valueExpression\n\n  return `const ${variableName} = defineValue(${inValueExpression}, {\n  data: root,\n  meta: meta,\n  name: ${fieldNameExpression},\n  wildCardPath: '${wildCardPath}',\n  mutate: defineValue,\n  report: report,\n  isValid: true,\n  parent: ${parentValueExpression},\n  isArrayMember: ${isArrayMember},\n});`\n}\n"]}
{"filename": "src/scripts/field/is_valid_guard.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\ntype ObjectGuardOptions = {\n  variableName: string\n  bail: boolean\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside a valid guard\n */", "\ntype ObjectGuardOptions = {\n  variableName: string\n  bail: boolean\n  guardedCodeSnippet: string\n}\n\n/**\n * Returns JS fragment to wrap code inside a valid guard\n */\nexport function defineIsValidGuard({ variableName, bail, guardedCodeSnippet }: ObjectGuardOptions) {", "export function defineIsValidGuard({ variableName, bail, guardedCodeSnippet }: ObjectGuardOptions) {\n  if (!bail) {\n    return guardedCodeSnippet\n  }\n\n  return `if (${variableName}.isValid) {\n${guardedCodeSnippet}\n}`\n}\n"]}
{"filename": "src/scripts/field/value_output.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RefIdentifier } from '../../types.js'", "\nimport { RefIdentifier } from '../../types.js'\n\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  outputExpression: string\n  variableName: string\n  transformFnRefId?: RefIdentifier\n}\n\n/**\n * Returns JS fragment for writing the validated value to the output.\n */", "export function defineFieldValueOutput({\n  variableName,\n  outputExpression,\n  transformFnRefId,\n}: OutputOptions) {\n  const outputValueExpression = transformFnRefId\n    ? `refs['${transformFnRefId}'](${variableName}.value, ${variableName})`\n    : `${variableName}.value`\n\n  return `if (${variableName}.isDefined && ${variableName}.isValid) {\n  ${outputExpression} = ${outputValueExpression};\n}`\n}\n", "  return `if (${variableName}.isDefined && ${variableName}.isValid) {\n  ${outputExpression} = ${outputValueExpression};\n}`\n}\n"]}
{"filename": "src/scripts/field/null_output.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RefIdentifier } from '../../types.js'", "\nimport { RefIdentifier } from '../../types.js'\n\n/**\n * Options accepts by the output script\n */\ntype OutputOptions = {\n  outputExpression: string\n  variableName: string\n  allowNull: boolean\n  transformFnRefId?: RefIdentifier\n  conditional?: 'if' | 'else if'\n}\n\n/**\n * Returns JS fragment for writing the null value to the output.\n */", "export function defineFieldNullOutput({\n  allowNull,\n  conditional,\n  variableName,\n  outputExpression,\n  transformFnRefId,\n}: OutputOptions) {\n  if (!allowNull) {\n    return ''\n  }\n\n  return `${conditional || 'if'}(${variableName}.value === null) {\n  ${outputExpression} = ${\n    transformFnRefId ? `refs['${transformFnRefId}'](null, ${variableName});` : 'null;'\n  }\n}`\n}\n"]}
{"filename": "src/scripts/field/validations.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ValidationNode } from '../../types.js'", "\nimport { ValidationNode } from '../../types.js'\n\n/**\n * Options accepts by the validation script\n */\ntype ValidationOptions = {\n  bail: boolean\n  variableName: string\n  validations: ValidationNode[]\n\n  /**\n   * Drop missing conditional check regardless of whether\n   * rule is implicit or not\n   */\n  dropMissingCheck: boolean\n}\n\n/**\n * Helper to generate a conditional based upon enabled conditions.\n */", "function wrapInConditional(conditions: [string, string], wrappingCode: string) {\n  const [first, second] = conditions\n  if (first && second) {\n    return `if (${first} && ${second}) {\n  ${wrappingCode}\n}`\n  }\n\n  if (first) {\n    return `if (${first}) {\n  ${wrappingCode}\n}`\n  }\n", "  if (first) {\n    return `if (${first}) {\n  ${wrappingCode}\n}`\n  }\n\n  if (second) {\n    return `if (${second}) {\n  ${wrappingCode}\n}`\n  }\n\n  return wrappingCode\n}\n\n/**\n * Emits code for executing a validation function\n */", "function emitValidationSnippet(\n  { isAsync, implicit, ruleFnId }: ValidationNode,\n  variableName: string,\n  bail: boolean,\n  dropMissingCheck: boolean\n) {\n  const rule = `refs['${ruleFnId}']`\n  const callable = `${rule}.validator(${variableName}.value, ${rule}.options, ${variableName});`\n\n  /**\n   * Add \"isValid\" condition when the bail flag is turned on.\n   */\n  const bailCondition = bail ? `${variableName}.isValid` : ''\n\n  /**\n   * Add the \"!is_[variableName]_missing\" conditional when the rule is not implicit.\n   */\n  const implicitCondition = implicit || dropMissingCheck ? '' : `${variableName}.isDefined`\n\n  /**\n   * Wrapping the validation invocation inside conditionals based upon\n   * enabled flags.\n   */\n  return wrapInConditional(\n    [bailCondition, implicitCondition],\n    isAsync ? `await ${callable}` : `${callable}`\n  )\n}\n\n/**\n * Returns JS fragment for executing validations for a given field.\n */", "export function defineFieldValidations({\n  bail,\n  validations,\n  variableName,\n  dropMissingCheck,\n}: ValidationOptions) {\n  return `${validations\n    .map((one) => emitValidationSnippet(one, variableName, bail, dropMissingCheck))\n    .join('\\n')}`\n}\n"]}
{"filename": "src/compiler/buffer.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Compiler buffer to collect JS fragments in memory\n */\nexport class CompilerBuffer {\n  #content: string = ''\n\n  /**\n   * The character used to create a new line\n   */\n  newLine = '\\n'\n\n  /**\n   * Write statement ot the output\n   */\n  writeStatement(statement: string) {\n    this.#content = `${this.#content}${this.newLine}${statement}`\n  }\n\n  /**\n   * Creates a child buffer\n   */\n  child() {\n    return new CompilerBuffer()\n  }\n\n  /**\n   * Returns the buffer contents as string\n   */\n  toString() {\n    return this.#content\n  }\n\n  /**\n   * Flush in-memory string\n   */\n  flush() {\n    this.#content = ''\n  }\n}\n"]}
{"filename": "src/compiler/main.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { CompilerBuffer } from './buffer.js'", "\nimport { CompilerBuffer } from './buffer.js'\nimport { TupleNodeCompiler } from './nodes/tuple.js'\nimport { ArrayNodeCompiler } from './nodes/array.js'\nimport { UnionNodeCompiler } from './nodes/union.js'\nimport { RecordNodeCompiler } from './nodes/record.js'\nimport { ObjectNodeCompiler } from './nodes/object.js'\nimport { createRootField } from './fields/root_field.js'\nimport { LiteralNodeCompiler } from './nodes/literal.js'\nimport { createArrayField } from './fields/array_field.js'", "import { LiteralNodeCompiler } from './nodes/literal.js'\nimport { createArrayField } from './fields/array_field.js'\nimport { createTupleField } from './fields/tuple_field.js'\nimport { reportErrors } from '../scripts/report_errors.js'\nimport { createObjectField } from './fields/object_field.js'\nimport { createRecordField } from './fields/record_field.js'\nimport { defineInlineFunctions } from '../scripts/define_inline_functions.js'\nimport { defineInlineErrorMessages } from '../scripts/define_error_messages.js'\nimport type {\n  Refs,", "import type {\n  Refs,\n  RootNode,\n  CompilerField,\n  CompilerNodes,\n  CompilerParent,\n  CompilerOptions,\n  ErrorReporterContract,\n  MessagesProviderContact,\n} from '../types.js'", "  MessagesProviderContact,\n} from '../types.js'\n\n/**\n * Representation of an async function\n */\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\n\n/**\n * Compiler is used to compile an array of schema nodes into a re-usable", "/**\n * Compiler is used to compile an array of schema nodes into a re-usable\n * JavaScript.\n */\nexport class Compiler {\n  /**\n   * Variables counter is used to generate unique variable\n   * names with a counter suffix.\n   */\n  variablesCounter: number = 0\n\n  /**\n   * An array of nodes to process\n   */\n  #rootNode: RootNode\n\n  /**\n   * Options to configure the compiler behavior\n   */\n  #options: CompilerOptions\n\n  /**\n   * Buffer for collection the JS output string\n   */\n  #buffer: CompilerBuffer = new CompilerBuffer()\n\n  constructor(rootNode: RootNode, options?: CompilerOptions) {\n    this.#rootNode = rootNode\n    this.#options = options || { convertEmptyStringsToNull: false }\n  }\n\n  /**\n   * Initiates the JS output\n   */\n  #initiateJSOutput() {\n    this.#buffer.writeStatement(\n      defineInlineErrorMessages({\n        required: 'value is required',\n        object: 'value is not a valid object',\n        array: 'value is not a valid array',\n        ...this.#options.messages,\n      })\n    )\n    this.#buffer.writeStatement(defineInlineFunctions(this.#options))\n    this.#buffer.writeStatement('let out;')\n  }\n\n  /**\n   * Finished the JS output\n   */\n  #finishJSOutput() {\n    this.#buffer.writeStatement(reportErrors())\n    this.#buffer.writeStatement('return out;')\n  }\n\n  /**\n   * Compiles all the nodes\n   */\n  #compileNodes() {\n    this.compileNode(this.#rootNode.schema, this.#buffer, {\n      type: 'root',\n      variableName: 'root',\n      outputExpression: 'out',\n      fieldPathExpression: 'out',\n      wildCardPath: '',\n    })\n  }\n\n  /**\n   * Returns compiled output as a function\n   */\n  #toAsyncFunction<T extends Record<string, any>>(): (\n    data: any,\n    meta: Record<string, any>,\n    refs: Refs,\n    messagesProvider: MessagesProviderContact,\n    errorReporter: ErrorReporterContract\n  ) => Promise<T> {\n    return new AsyncFunction(\n      'root',\n      'meta',\n      'refs',\n      'messagesProvider',\n      'errorReporter',\n      this.#buffer.toString()\n    )\n  }\n\n  /**\n   * Converts a node to a field. Optionally accepts a parent node to create\n   * a field for a specific parent type.\n   */\n  createFieldFor(node: CompilerNodes, parent: CompilerParent) {\n    switch (parent.type) {\n      case 'array':\n        return createArrayField(parent)\n      case 'root':\n        return createRootField(parent)\n      case 'object':\n        return createObjectField(node, this.variablesCounter, parent)\n      case 'tuple':\n        return createTupleField(node, parent)\n      case 'record':\n        return createRecordField(parent)\n    }\n  }\n\n  /**\n   * Compiles a given compiler node\n   */\n  compileNode(\n    node: CompilerNodes,\n    buffer: CompilerBuffer,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    switch (node.type) {\n      case 'literal':\n        return new LiteralNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'array':\n        return new ArrayNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'record':\n        return new RecordNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'object':\n        return new ObjectNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'tuple':\n        return new TupleNodeCompiler(node, buffer, this, parent, parentField).compile()\n      case 'union':\n        return new UnionNodeCompiler(node, buffer, this, parent, parentField).compile()\n    }\n  }\n\n  /**\n   * Compile schema nodes to an async function\n   */\n  compile() {\n    this.#initiateJSOutput()\n    this.#compileNodes()\n    this.#finishJSOutput()\n\n    const outputFunction = this.#toAsyncFunction()\n\n    this.variablesCounter = 0\n    this.#buffer.flush()\n\n    return outputFunction\n  }\n}\n"]}
{"filename": "src/compiler/nodes/base.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Compiler } from '../main.js'", "\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineFieldVariables } from '../../scripts/field/variables.js'\nimport type { CompilerField, CompilerNodes, CompilerParent } from '../../types.js'\n\nexport abstract class BaseNode {\n  #node: CompilerNodes\n  #parentField?: CompilerField\n  protected field: CompilerField\n\n  constructor(\n    node: CompilerNodes,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    this.#parentField = parentField\n    this.#node = node\n", "    if (this.#parentField) {\n      this.field = this.#parentField\n    } else {\n      compiler.variablesCounter++\n      this.field = compiler.createFieldFor(node, parent)\n    }\n  }\n\n  protected defineField(buffer: CompilerBuffer) {\n    if (!this.#parentField) {\n      buffer.writeStatement(\n        defineFieldVariables({\n          fieldNameExpression: this.field.fieldNameExpression,\n          isArrayMember: this.field.isArrayMember,\n          parentValueExpression: this.field.parentValueExpression,\n          valueExpression: this.field.valueExpression,\n          variableName: this.field.variableName,\n          wildCardPath: this.field.wildCardPath,\n          parseFnRefId: 'parseFnId' in this.#node ? this.#node.parseFnId : undefined,\n        })\n      )\n    }\n  }\n}\n", "    if (!this.#parentField) {\n      buffer.writeStatement(\n        defineFieldVariables({\n          fieldNameExpression: this.field.fieldNameExpression,\n          isArrayMember: this.field.isArrayMember,\n          parentValueExpression: this.field.parentValueExpression,\n          valueExpression: this.field.valueExpression,\n          variableName: this.field.variableName,\n          wildCardPath: this.field.wildCardPath,\n          parseFnRefId: 'parseFnId' in this.#node ? this.#node.parseFnId : undefined,\n        })\n      )\n    }\n  }\n}\n"]}
{"filename": "src/compiler/nodes/literal.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'", "\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValueOutput } from '../../scripts/field/value_output.js'\nimport type { LiteralNode, CompilerParent, CompilerField } from '../../types.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n", "import { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles a literal schema node to JS string output.\n */\nexport class LiteralNodeCompiler extends BaseNode {\n  #node: LiteralNode\n  #buffer: CompilerBuffer\n\n  constructor(\n    node: LiteralNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define block to validate the existence of field\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Step 3: Define code to run validations on field\n     */\n    this.#buffer.writeStatement(\n      defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: false,\n      })\n    )\n\n    /**\n     * Step 4: Define block to save the output value or the null value\n     */\n    this.#buffer.writeStatement(\n      `${defineFieldValueOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        transformFnRefId: this.#node.transformFnId,\n      })}${this.#buffer.newLine}${defineFieldNullOutput({\n        variableName: this.field.variableName,\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        transformFnRefId: this.#node.transformFnId,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n"]}
{"filename": "src/compiler/nodes/object.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'", "\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineObjectGuard } from '../../scripts/object/guard.js'\nimport { defineElseCondition } from '../../scripts/define_else_conditon.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'", "import { defineFieldValidations } from '../../scripts/field/validations.js'\nimport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'\nimport { defineObjectInitialOutput } from '../../scripts/object/initial_output.js'\nimport { defineMoveProperties } from '../../scripts/object/move_unknown_properties.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\nimport type { CompilerField, CompilerParent, ObjectNode, ObjectGroupNode } from '../../types.js'\n\n/**\n * Compiles an object schema node to JS string output.\n */\nexport class ObjectNodeCompiler extends BaseNode {\n  #node: ObjectNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: ObjectNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Returns known field names for the object\n   */\n  #getFieldNames(node: Pick<ObjectNode, 'properties' | 'groups'>): string[] {\n    let fieldNames = node.properties.map((child) => child.fieldName)\n    const groupsFieldNames = node.groups.flatMap((group) => this.#getGroupFieldNames(group))\n    return fieldNames.concat(groupsFieldNames)\n  }\n\n  /**\n   * Returns field names of a group.\n   */\n  #getGroupFieldNames(group: ObjectGroupNode): string[] {\n    return group.conditions.flatMap((condition) => {\n      return this.#getFieldNames(condition.schema)\n    })\n  }\n\n  /**\n   * Compiles object children to JS output\n   */\n  #compileObjectChildren() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'object',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n\n    this.#node.properties.forEach((child) => this.#compiler.compileNode(child, buffer, parent))\n    return buffer.toString()\n  }\n\n  /**\n   * Compiles object groups with conditions to JS output.\n   */\n  #compileObjectGroups() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'object',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n    this.#node.groups.forEach((group) => this.#compileObjectGroup(group, buffer, parent))\n    return buffer.toString()\n  }\n\n  /**\n   * Compiles an object groups recursively\n   */\n  #compileObjectGroup(group: ObjectGroupNode, buffer: CompilerBuffer, parent: CompilerParent) {\n    group.conditions.forEach((condition, index) => {\n      const guardBuffer = buffer.child()\n\n      condition.schema.properties.forEach((child) => {\n        this.#compiler.compileNode(child, guardBuffer, parent)\n      })\n\n      condition.schema.groups.forEach((child) => {\n        this.#compileObjectGroup(child, guardBuffer, parent)\n      })\n\n      buffer.writeStatement(\n        defineConditionalGuard({\n          variableName: this.field.variableName,\n          conditional: index === 0 ? 'if' : 'else if',\n          conditionalFnRefId: condition.conditionalFnRefId,\n          guardedCodeSnippet: guardBuffer.toString(),\n        })\n      )\n    })\n\n    /**\n     * Define else block\n     */", " * Compiles an object schema node to JS string output.\n */\nexport class ObjectNodeCompiler extends BaseNode {\n  #node: ObjectNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: ObjectNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Returns known field names for the object\n   */\n  #getFieldNames(node: Pick<ObjectNode, 'properties' | 'groups'>): string[] {\n    let fieldNames = node.properties.map((child) => child.fieldName)\n    const groupsFieldNames = node.groups.flatMap((group) => this.#getGroupFieldNames(group))\n    return fieldNames.concat(groupsFieldNames)\n  }\n\n  /**\n   * Returns field names of a group.\n   */\n  #getGroupFieldNames(group: ObjectGroupNode): string[] {\n    return group.conditions.flatMap((condition) => {\n      return this.#getFieldNames(condition.schema)\n    })\n  }\n\n  /**\n   * Compiles object children to JS output\n   */\n  #compileObjectChildren() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'object',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n\n    this.#node.properties.forEach((child) => this.#compiler.compileNode(child, buffer, parent))\n    return buffer.toString()\n  }\n\n  /**\n   * Compiles object groups with conditions to JS output.\n   */\n  #compileObjectGroups() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'object',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n    this.#node.groups.forEach((group) => this.#compileObjectGroup(group, buffer, parent))\n    return buffer.toString()\n  }\n\n  /**\n   * Compiles an object groups recursively\n   */\n  #compileObjectGroup(group: ObjectGroupNode, buffer: CompilerBuffer, parent: CompilerParent) {\n    group.conditions.forEach((condition, index) => {\n      const guardBuffer = buffer.child()\n\n      condition.schema.properties.forEach((child) => {\n        this.#compiler.compileNode(child, guardBuffer, parent)\n      })\n\n      condition.schema.groups.forEach((child) => {\n        this.#compileObjectGroup(child, guardBuffer, parent)\n      })\n\n      buffer.writeStatement(\n        defineConditionalGuard({\n          variableName: this.field.variableName,\n          conditional: index === 0 ? 'if' : 'else if',\n          conditionalFnRefId: condition.conditionalFnRefId,\n          guardedCodeSnippet: guardBuffer.toString(),\n        })\n      )\n    })\n\n    /**\n     * Define else block\n     */", "    if (group.elseConditionalFnRefId && group.conditions.length) {\n      buffer.writeStatement(\n        defineElseCondition({\n          variableName: this.field.variableName,\n          conditionalFnRefId: group.elseConditionalFnRefId,\n        })\n      )\n    }\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + object children validations\n     * validation inside `if object field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isObjectValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineObjectInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: '{}',\n      })}${this.#buffer.newLine}${this.#compileObjectChildren()}${\n        this.#buffer.newLine\n      }${this.#compileObjectGroups()}${this.#buffer.newLine}${defineMoveProperties({\n        variableName: this.field.variableName,\n        allowUnknownProperties: this.#node.allowUnknownProperties,\n        fieldsToIgnore: this.#node.allowUnknownProperties ? this.#getFieldNames(this.#node) : [],\n      })}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isObjectValidBlock\" inside\n     * `if value is object` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnObject = defineObjectGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${isObjectValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an object` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnObject}${this.#buffer.newLine}${defineFieldNullOutput({\n        variableName: this.field.variableName,\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n"]}
{"filename": "src/compiler/nodes/array.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'", "\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineArrayLoop } from '../../scripts/array/loop.js'\nimport { defineArrayGuard } from '../../scripts/array/guard.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, ArrayNode } from '../../types.js'", "import { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, ArrayNode } from '../../types.js'\nimport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles an array schema node to JS string output.\n */\nexport class ArrayNodeCompiler extends BaseNode {\n  #node: ArrayNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: ArrayNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the array elements to a JS fragment\n   */\n  #compileArrayElements() {\n    const arrayElementsBuffer = this.#buffer.child()\n    this.#compiler.compileNode(this.#node.each, arrayElementsBuffer, {\n      type: 'array',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    })\n\n    const buffer = this.#buffer.child()\n    buffer.writeStatement(\n      defineArrayLoop({\n        variableName: this.field.variableName,\n        startingIndex: 0,\n        loopCodeSnippet: arrayElementsBuffer.toString(),\n      })\n    )\n\n    arrayElementsBuffer.flush()\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + array elements\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isArrayValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineArrayInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: `[]`,\n      })}${this.#buffer.newLine}${this.#compileArrayElements()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnArrayBlock = defineArrayGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an array` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n", "export class ArrayNodeCompiler extends BaseNode {\n  #node: ArrayNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: ArrayNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the array elements to a JS fragment\n   */\n  #compileArrayElements() {\n    const arrayElementsBuffer = this.#buffer.child()\n    this.#compiler.compileNode(this.#node.each, arrayElementsBuffer, {\n      type: 'array',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    })\n\n    const buffer = this.#buffer.child()\n    buffer.writeStatement(\n      defineArrayLoop({\n        variableName: this.field.variableName,\n        startingIndex: 0,\n        loopCodeSnippet: arrayElementsBuffer.toString(),\n      })\n    )\n\n    arrayElementsBuffer.flush()\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + array elements\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isArrayValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineArrayInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: `[]`,\n      })}${this.#buffer.newLine}${this.#compileArrayElements()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnArrayBlock = defineArrayGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an array` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n"]}
{"filename": "src/compiler/nodes/union.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'", "\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { callParseFunction } from '../../scripts/union/parse.js'\nimport { defineElseCondition } from '../../scripts/define_else_conditon.js'\nimport type { CompilerField, CompilerParent, UnionNode } from '../../types.js'\nimport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'\n\n/**", "\n/**\n * Compiles a union schema node to JS string output.\n */\nexport class UnionNodeCompiler extends BaseNode {\n  #compiler: Compiler\n  #node: UnionNode\n  #buffer: CompilerBuffer\n  #parent: CompilerParent\n\n  constructor(\n    node: UnionNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#parent = parent\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles union children by wrapping each conditon inside a conditional\n   * guard block\n   */\n  #compileUnionChildren() {\n    const childrenBuffer = this.#buffer.child()\n\n    this.#node.conditions.forEach((child, index) => {\n      const conditionalBuffer = this.#buffer.child()\n\n      /**\n       * Parse the value once the condition is true\n       */", "      if ('parseFnId' in child.schema) {\n        conditionalBuffer.writeStatement(\n          callParseFunction({\n            parseFnRefId: child.schema.parseFnId,\n            variableName: this.field.variableName,\n          })\n        )\n      }\n\n      this.#compiler.compileNode(child.schema, conditionalBuffer, this.#parent, this.field)\n\n      childrenBuffer.writeStatement(\n        defineConditionalGuard({\n          conditional: index === 0 ? 'if' : 'else if',\n          variableName: this.field.variableName,\n          conditionalFnRefId: child.conditionalFnRefId,\n          guardedCodeSnippet: conditionalBuffer.toString(),\n        })\n      )\n\n      conditionalBuffer.flush()\n    })\n\n    /**\n     * Define else block\n     */", "    if (this.#node.elseConditionalFnRefId && this.#node.conditions.length) {\n      childrenBuffer.writeStatement(\n        defineElseCondition({\n          variableName: this.field.variableName,\n          conditionalFnRefId: this.#node.elseConditionalFnRefId,\n        })\n      )\n    }\n\n    return childrenBuffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Compile union children wrapped inside predicate\n     * condition.\n     */\n    this.#buffer.writeStatement(this.#compileUnionChildren())\n  }\n}\n"]}
{"filename": "src/compiler/nodes/record.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'", "\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineRecordLoop } from '../../scripts/record/loop.js'\nimport { defineObjectGuard } from '../../scripts/object/guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, RecordNode } from '../../types.js'", "import { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, RecordNode } from '../../types.js'\nimport { defineObjectInitialOutput } from '../../scripts/object/initial_output.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles a record schema node to JS string output.\n */\nexport class RecordNodeCompiler extends BaseNode {\n  #node: RecordNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: RecordNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the record elements to a JS fragment\n   */\n  #compileRecordElements() {\n    const buffer = this.#buffer.child()\n    const recordElementsBuffer = this.#buffer.child()\n\n    this.#compiler.compileNode(this.#node.each, recordElementsBuffer, {\n      type: 'record',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    })\n\n    buffer.writeStatement(\n      defineRecordLoop({\n        variableName: this.field.variableName,\n        loopCodeSnippet: recordElementsBuffer.toString(),\n      })\n    )\n\n    recordElementsBuffer.flush()\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + tuple validation + array elements\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isObjectValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineObjectInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: `{}`,\n      })}${this.#compileRecordElements()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnObjectBlock = defineObjectGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isObjectValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an object` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnObjectBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n", "export class RecordNodeCompiler extends BaseNode {\n  #node: RecordNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: RecordNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the record elements to a JS fragment\n   */\n  #compileRecordElements() {\n    const buffer = this.#buffer.child()\n    const recordElementsBuffer = this.#buffer.child()\n\n    this.#compiler.compileNode(this.#node.each, recordElementsBuffer, {\n      type: 'record',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    })\n\n    buffer.writeStatement(\n      defineRecordLoop({\n        variableName: this.field.variableName,\n        loopCodeSnippet: recordElementsBuffer.toString(),\n      })\n    )\n\n    recordElementsBuffer.flush()\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + tuple validation + array elements\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isObjectValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineObjectInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: `{}`,\n      })}${this.#compileRecordElements()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnObjectBlock = defineObjectGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isObjectValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an object` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnObjectBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n"]}
{"filename": "src/compiler/nodes/tuple.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseNode } from './base.js'", "\nimport { BaseNode } from './base.js'\nimport type { Compiler } from '../main.js'\nimport type { CompilerBuffer } from '../buffer.js'\nimport { defineArrayGuard } from '../../scripts/array/guard.js'\nimport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\nimport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\nimport { defineFieldValidations } from '../../scripts/field/validations.js'\nimport type { CompilerField, CompilerParent, TupleNode } from '../../types.js'\nimport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'", "import type { CompilerField, CompilerParent, TupleNode } from '../../types.js'\nimport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'\nimport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\n/**\n * Compiles a tuple schema node to JS string output.\n */\nexport class TupleNodeCompiler extends BaseNode {\n  #node: TupleNode\n  #buffer: CompilerBuffer\n  #compiler: Compiler\n\n  constructor(\n    node: TupleNode,\n    buffer: CompilerBuffer,\n    compiler: Compiler,\n    parent: CompilerParent,\n    parentField?: CompilerField\n  ) {\n    super(node, compiler, parent, parentField)\n    this.#node = node\n    this.#buffer = buffer\n    this.#compiler = compiler\n  }\n\n  /**\n   * Compiles the tuple children to a JS fragment\n   */\n  #compileTupleChildren() {\n    const buffer = this.#buffer.child()\n    const parent = {\n      type: 'tuple',\n      fieldPathExpression: this.field.fieldPathExpression,\n      outputExpression: this.field.outputExpression,\n      variableName: this.field.variableName,\n      wildCardPath: this.field.wildCardPath,\n    } as const\n\n    this.#node.properties.forEach((child) => {\n      this.#compiler.compileNode(child, buffer, parent)\n    })\n\n    return buffer.toString()\n  }\n\n  compile() {\n    /**\n     * Define 1: Define field variable\n     */\n    this.defineField(this.#buffer)\n\n    /**\n     * Step 2: Define code to validate the existence of field.\n     */\n    this.#buffer.writeStatement(\n      defineFieldExistenceValidations({\n        allowNull: this.#node.allowNull,\n        isOptional: this.#node.isOptional,\n        variableName: this.field.variableName,\n      })\n    )\n\n    /**\n     * Wrapping initialization of output + tuple validation\n     * validation inside `if array field is valid` block.\n     *\n     * Pre step: 3\n     */\n    const isArrayValidBlock = defineIsValidGuard({\n      variableName: this.field.variableName,\n      bail: this.#node.bail,\n      guardedCodeSnippet: `${defineArrayInitialOutput({\n        variableName: this.field.variableName,\n        outputExpression: this.field.outputExpression,\n        outputValueExpression: this.#node.allowUnknownProperties\n          ? `copyProperties(${this.field.variableName}.value)`\n          : `[]`,\n      })}${this.#compileTupleChildren()}`,\n    })\n\n    /**\n     * Wrapping field validations + \"isArrayValidBlock\" inside\n     * `if value is array` check.\n     *\n     * Pre step: 3\n     */\n    const isValueAnArrayBlock = defineArrayGuard({\n      variableName: this.field.variableName,\n      guardedCodeSnippet: `${defineFieldValidations({\n        variableName: this.field.variableName,\n        validations: this.#node.validations,\n        bail: this.#node.bail,\n        dropMissingCheck: true,\n      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n    })\n\n    /**\n     * Step 3: Define `if value is an array` block and `else if value is null`\n     * block.\n     */\n    this.#buffer.writeStatement(\n      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n        allowNull: this.#node.allowNull,\n        outputExpression: this.field.outputExpression,\n        variableName: this.field.variableName,\n        conditional: 'else if',\n      })}`\n    )\n  }\n}\n"]}
{"filename": "src/compiler/fields/tuple_field.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'", "\nimport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'\n\nexport function createTupleField(\n  node: Pick<FieldNode, 'fieldName' | 'propertyName'>,\n  parent: CompilerParent\n): CompilerField {\n  /**\n   * Commented to see if a use case arrives for using this.\n   */\n  // const fieldPathExpression =\n  //   parent.fieldPathExpression !== `''`\n  //     ? `${parent.fieldPathExpression} + '.' + '${node.fieldName}'`\n  //     : `'${node.fieldName}'`\n\n  const wildCardPath =\n    parent.wildCardPath !== '' ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName\n\n  return {\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `${node.fieldName}`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${parent.variableName}_item_${node.fieldName}`,\n    valueExpression: `${parent.variableName}.value[${node.fieldName}]`,\n    outputExpression: `${parent.variableName}_out[${node.propertyName}]`,\n    isArrayMember: true,\n  }\n}\n"]}
{"filename": "src/compiler/fields/array_field.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, CompilerParent } from '../../types.js'", "\nimport type { CompilerField, CompilerParent } from '../../types.js'\n\nexport function createArrayField(parent: CompilerParent): CompilerField {\n  /**\n   * Commented to see if a use case arrives for using this.\n   */\n  // const fieldPathExpression =\n  //   parent.fieldPathExpression !== `''`\n  //     ? `${parent.fieldPathExpression} + '.' + ${parent.variableName}_i`\n  //     : `${parent.variableName}_i`\n\n  const wildCardPath = parent.wildCardPath !== '' ? `${parent.wildCardPath}.*` : `*`\n\n  return {\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `${parent.variableName}_i`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${parent.variableName}_item`,\n    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,\n    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,\n    isArrayMember: true,\n  }\n}\n"]}
{"filename": "src/compiler/fields/record_field.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, CompilerParent } from '../../types.js'", "\nimport type { CompilerField, CompilerParent } from '../../types.js'\n\nexport function createRecordField(parent: CompilerParent): CompilerField {\n  /**\n   * Commented to see if a use case arrives for using this.\n   */\n  // const fieldPathExpression =\n  //   parent.fieldPathExpression !== `''`\n  //     ? `${parent.fieldPathExpression} + '.' + ${parent.variableName}_i`\n  //     : `${parent.variableName}_i`\n\n  const wildCardPath = parent.wildCardPath !== '' ? `${parent.wildCardPath}.*` : `*`\n\n  return {\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `${parent.variableName}_i`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${parent.variableName}_item`,\n    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,\n    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,\n    isArrayMember: false,\n  }\n}\n"]}
{"filename": "src/compiler/fields/object_field.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'", "\nimport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'\n\nexport function createObjectField(\n  node: Pick<FieldNode, 'fieldName' | 'propertyName'>,\n  variablesCounter: number,\n  parent: CompilerParent\n): CompilerField {\n  /**\n   * Commented to see if a use case arrives for using this.\n   */\n  // const fieldPathExpression =\n  //   parent.fieldPathExpression !== `''`\n  //     ? `${parent.fieldPathExpression} + '.' + '${node.fieldName}'`\n  //     : `'${node.fieldName}'`\n\n  const wildCardPath =\n    parent.wildCardPath !== '' ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName\n\n  return {\n    parentValueExpression: `${parent.variableName}.value`,\n    fieldNameExpression: `'${node.fieldName}'`,\n    fieldPathExpression: wildCardPath,\n    wildCardPath: wildCardPath,\n    variableName: `${node.propertyName}_${variablesCounter}`,\n    valueExpression: `${parent.variableName}.value['${node.fieldName}']`,\n    outputExpression: `${parent.variableName}_out['${node.propertyName}']`,\n    isArrayMember: false,\n  }\n}\n"]}
{"filename": "src/compiler/fields/root_field.ts", "chunked_list": ["/*\n * @vinejs/compiler\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerField, CompilerParent } from '../../types.js'", "\nimport type { CompilerField, CompilerParent } from '../../types.js'\n\nexport function createRootField(parent: CompilerParent): CompilerField {\n  return {\n    parentValueExpression: parent.variableName,\n    fieldNameExpression: `''`,\n    fieldPathExpression: `''`,\n    wildCardPath: '',\n    variableName: `${parent.variableName}_item`,\n    valueExpression: 'root',\n    outputExpression: parent.outputExpression,\n    isArrayMember: false,\n  }\n}\n"]}
