{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup'\n\nexport default defineConfig([\n  {\n    entry: ['src/index.ts'],\n    outDir: 'build',\n    target: 'node16',\n    platform: 'node',\n    format: ['esm'],\n    splitting: false,", "    format: ['esm'],\n    splitting: false,\n    sourcemap: true,\n    minify: false,\n    shims: true,\n    dts: true\n  }\n])\n", ""]}
{"filename": "tests/test-templates.spec.ts", "chunked_list": ["import test from 'ava'\nimport { extractPrompts, replacePrompt } from '../src/lib/template'\nimport { readFileSync } from 'fs'\n\ntest('Extract prompts', t => {\n  const template = readFileSync('./tests/data/template.md', 'utf8')\n  const prompts = extractPrompts(template)\n  t.not(prompts, null)\n  console.log(prompts)\n})", "  console.log(prompts)\n})\n\ntest('Replace prompt', t => {\n  const template = readFileSync('./tests/data/template.md', 'utf8')\n  let newContent = replacePrompt(template, 0, '')\n  newContent = replacePrompt(newContent, 1, 'This is the content for the prompt 1')\n  newContent = replacePrompt(newContent, 2, 'This is the content for the prompt 2')\n  newContent = replacePrompt(newContent, 3, 'This is the content for the prompt 3')\n  newContent = replacePrompt(newContent, 4, 'This is the content for the prompt 4')", "  newContent = replacePrompt(newContent, 3, 'This is the content for the prompt 3')\n  newContent = replacePrompt(newContent, 4, 'This is the content for the prompt 4')\n\n  t.not(newContent, null)\n  console.log(newContent)\n})\n"]}
{"filename": "tests/test-api.spec.ts", "chunked_list": ["import test from 'ava'\nimport { OpenAIPostGenerator } from '../src/post'\nimport { PostPrompt } from '../src/types'\nimport { log } from 'console'\n\ntest.skip('API with custom template', async t => {\n  const postPrompt : PostPrompt = {\n    language: 'english',\n    model: 'gpt-4',\n    topic: 'Test prompt answer',", "    model: 'gpt-4',\n    topic: 'Test prompt answer',\n    temperature: 0.7,\n    frequencyPenalty: 0.5,\n    presencePenalty: 0.5,\n    logitBias: 0,\n    templateFile: './tests/data/template-2.md',\n    debug: true,\n    debugapi: true\n  }", "    debugapi: true\n  }\n  const postGenerator = new OpenAIPostGenerator(postPrompt)\n  const post = await postGenerator.generate()\n  t.not(post, null)\n  log(post)\n})\n\ntest('API', async t => {\n  try {\n    const postPrompt : PostPrompt = {\n      language: 'english',\n      model: 'gpt-4',\n      topic: 'Test prompt answer',\n      temperature: 0.7,\n      frequencyPenalty: 0.5,\n      presencePenalty: 0.5,\n      logitBias: 0,\n      debug: false,\n      debugapi: false\n    }\n    const postGenerator = new OpenAIPostGenerator(postPrompt)\n    const post = await postGenerator.generate()\n    t.not(post, null)\n    log(post)", "test('API', async t => {\n  try {\n    const postPrompt : PostPrompt = {\n      language: 'english',\n      model: 'gpt-4',\n      topic: 'Test prompt answer',\n      temperature: 0.7,\n      frequencyPenalty: 0.5,\n      presencePenalty: 0.5,\n      logitBias: 0,\n      debug: false,\n      debugapi: false\n    }\n    const postGenerator = new OpenAIPostGenerator(postPrompt)\n    const post = await postGenerator.generate()\n    t.not(post, null)\n    log(post)", "  } catch (e) {\n    log(e)\n  }\n})\n"]}
{"filename": "tests/test-images.spec.ts", "chunked_list": ["import test from 'ava'\nimport { generateImage } from '../src/lib/image/midjourney'\n\nconst IMAGE_PROMPT = `\nGenerate a realistic photography illustrating the concept of 'administrative management' made by a award winning photographer.\nIt should include elements commonly associated with administration such as an office desk, paperwork, a laptop, and a calendar. \nAlso, incorporate a manager in a professional attire overseeing these tasks. \nThe image should reflect a sense of organization, precision, and professionalism in a business setting.\n\n--ar 16:9 --v 5.1 --style raw --q 2 --s 750", "\n--ar 16:9 --v 5.1 --style raw --q 2 --s 750\n`\n\ntest.skip('Generate Image', async t => {\n  try {\n    await generateImage(IMAGE_PROMPT)\n  } catch (err) {\n    console.log(err)\n  }\n})\n"]}
{"filename": "tests/test-extractor.spec.ts", "chunked_list": ["import test from 'ava'\nimport { PostOutlineValidationError, extractPostOutlineFromCodeBlock, extractCodeBlock } from '../src/lib/extractor'\nimport fs from 'fs'\nimport { PostOutline } from '../src/types'\n\ntest.skip('extract outline', t => {\n  const content = readTextFileSync('./tests/data/outline-test.txt')\n  const result : PostOutline = extractPostOutlineFromCodeBlock(content)\n  t.not(result.title, null)\n  t.not(result.title, '')", "  t.not(result.title, null)\n  t.not(result.title, '')\n})\n\ntest.skip('Invalid outline', t => {\n  t.throws(() => extractInvalidOutline(), { instanceOf: PostOutlineValidationError })\n})\n\ntest('extract code block', t => {\n  const text = '```markdownThis is markdown text```'", "test('extract code block', t => {\n  const text = '```markdownThis is markdown text```'\n  const result = extractCodeBlock(text)\n  t.is(result, 'This is markdown text')\n\n  const text2 = '```This is markdown text```'\n  const result2 = extractCodeBlock(text2)\n  t.is(result2, 'This is markdown text')\n\n  const text3 = '```html<p>This is html text</p>```'", "\n  const text3 = '```html<p>This is html text</p>```'\n  const result3 = extractCodeBlock(text3)\n  t.is(result3, '<p>This is html text</p>')\n\n  const text4 = '```json{\"title\": \"This is json text\"}```'\n  const result4 = extractCodeBlock(text4)\n  t.is(result4, '{\"title\": \"This is json text\"}')\n})\n\nfunction extractInvalidOutline () {\n  const content = readTextFileSync('./tests/data/invalid-outline.txt')\n  return extractPostOutlineFromCodeBlock(content)\n}\n", "})\n\nfunction extractInvalidOutline () {\n  const content = readTextFileSync('./tests/data/invalid-outline.txt')\n  return extractPostOutlineFromCodeBlock(content)\n}\n\nfunction readTextFileSync (file) {\n  return fs.readFileSync(file, 'utf8')\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type TotalTokens = {\n  promptTokens: number,\n  completionTokens: number,\n  total : number\n}\n\nexport type PostPrompt = {\n  topic? : string\n  country? : string\n  intent? : string\n  audience? : string\n  language: string\n  tone? : 'informative' | 'captivating'\n  generate? : boolean // generate the audience and intent\n  withConclusion? : boolean\n  model : 'gpt-4' | 'gpt-4-32k' | 'gpt-3.5-turbo' | 'gpt-3.5-turbo-16k',\n  maxModelTokens? : 4000 | 8000,\n  temperature? : number\n  frequencyPenalty? : number\n  presencePenalty? : number\n  logitBias? : number\n  debug? : boolean\n  debugapi? : boolean\n  apiKey? : string\n  filename? : string\n\n  // The following attributes are only used for custom templates\n  templateFile? : string\n  templateContent? : string\n  prompts? : string[]\n}\n", "export type Heading = {\n  title: string\n  keywords?: string[]\n  headings?: Heading[]\n}\n\nexport type PostOutline = {\n  title: string\n  headings : Heading[],\n  slug : string,\n  seoTitle : string,\n  seoDescription : string\n}\n", "export type Post = {\n  title : string\n  content : string\n  seoTitle : string\n  seoDescription : string\n  slug : string,\n  categories? : number[],\n  status? : string,\n  totalTokens : TotalTokens\n}\n", "export type SeoInfo = {\n  h1 : string\n  slug : string\n  seoTitle : string\n  seoDescription : string\n}\n\nexport type AudienceIntentInfo = {\n  audience : string\n  intent : string\n}\n"]}
{"filename": "src/post.ts", "chunked_list": ["import { oraPromise } from 'ora'\nimport { ChatGptHelper, GeneratorHelperInterface } from './lib/post-helpers'\n\nimport {\n  PostPrompt,\n  Post\n} from './types'\nimport { replaceAllPrompts } from './lib/template'\n\n/**\n * Class for generating a post. It need a helper class to generate the post", "\n/**\n * Class for generating a post. It need a helper class to generate the post\n * Each helper class must implement the GeneratorHelperInterface\n */\nexport class PostGenerator {\n  private helper : GeneratorHelperInterface\n  public constructor (helper : GeneratorHelperInterface) {\n    this.helper = helper\n  }\n\n  public async generate () : Promise<Post> {\n    return this.helper.isCustom() ? await this.customGenerate() : await this.autoGenerate()\n  }\n\n  /**\n   * Generate a post using the custom prompt based on a template\n   */\n  private async customGenerate () : Promise<Post> {\n    const promptContents = []\n\n    await oraPromise(\n      this.helper.init(),\n      {\n        text: ' Init the completion parameters ...'\n      }\n    )\n\n    // We remove the first prompt because it is the system prompt\n    const prompts = this.helper.getPrompt().prompts.slice(1)\n\n    // for each prompt, we generate the content\n    const templatePrompts = prompts.entries()", "    for (const [index, prompt] of templatePrompts) {\n      const content = await oraPromise(\n        this.helper.generateCustomPrompt(prompt),\n        {\n          text: `Generating the prompt num. ${index + 1} ...`\n        }\n      )\n      promptContents.push(content)\n    }\n\n    // We replace the prompts by the AI answer in the template content\n    const content = replaceAllPrompts(this.helper.getPrompt().templateContent, promptContents)\n\n    const seoInfo = await oraPromise(\n      this.helper.generateSeoInfo(),\n      {\n        text: 'Generating SEO info ...'\n      }\n    )\n\n    return {\n      title: seoInfo.h1,\n      slug: seoInfo.slug,\n      seoTitle: seoInfo.seoTitle,\n      seoDescription: seoInfo.seoDescription,\n      content,\n      totalTokens: this.helper.getTotalTokens()\n    }\n  }\n\n  /**\n   * Generate a post using the auto mode\n   */\n  private async autoGenerate () : Promise<Post> {\n    await oraPromise(\n      this.helper.init(),\n      {\n        text: ' Init the completion parameters ...'\n      }\n    )\n\n    const tableOfContent = await oraPromise(\n      this.helper.generateContentOutline(),\n      {\n        text: 'Generating post outline ...'\n      }\n    )\n\n    let content = await oraPromise(\n      this.helper.generateIntroduction(),\n      {\n        text: 'Generating introduction...'\n      }\n    )\n\n    content += await oraPromise(\n      this.helper.generateHeadingContents(tableOfContent),\n      {\n        text: 'Generating content ...'\n      }\n    )\n", "    if (this.helper.getPrompt().withConclusion) {\n      content += await oraPromise(\n        this.helper.generateConclusion(),\n        {\n          text: 'Generating conclusion...'\n        }\n      )\n    }\n\n    return {\n      title: tableOfContent.title,\n      slug: tableOfContent.slug,\n      seoTitle: tableOfContent.seoTitle,\n      seoDescription: tableOfContent.seoDescription,\n      content,\n      totalTokens: this.helper.getTotalTokens()\n    }\n  }\n}\n\n/**\n * Class for generating a post using the OpenAI API\n */", "export class OpenAIPostGenerator extends PostGenerator {\n  public constructor (postPrompt : PostPrompt) {\n    super(new ChatGptHelper(postPrompt))\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["// for the\nexport * from './bin/command/post'\nexport * from './bin/command/wp'\nexport * from './lib/store/store'\n\n// for the api\nexport * from './post'\nexport * from './types'\n", ""]}
{"filename": "src/bin/command/post.ts", "chunked_list": ["import fs from 'fs'\nimport { Command } from 'commander'\nimport { marked } from 'marked'\nimport { askCustomQuestions, askQuestions } from '../question/questions'\nimport { OpenAIPostGenerator } from '../../post'\nimport { Post, PostPrompt } from 'src/types'\nimport { NoApiKeyError } from 'src/lib/errors'\n\nconst GPT4_PROMPT_PRICE = 0.03\nconst GPT4_COMPLETION_PRICE = 0.06", "const GPT4_PROMPT_PRICE = 0.03\nconst GPT4_COMPLETION_PRICE = 0.06\nconst GPT35_PROMPT_PRICE = 0.002\nconst GPT_COMPLETION_PRICE = 0.002\n\ntype Options = {\n  interactive: boolean\n  debug: boolean\n  debugapi: boolean\n  apiKey: string\n  templateFile: string\n  language: string\n  model: string\n  filename: string\n  topic: string\n  country: string\n  generate: boolean // generate the audience and intent\n  conclusion: boolean\n  tone: string\n  temperature: number\n  frequencyPenalty: number\n  presencePenalty: number\n  logitBias: number\n}\n", "export function buildPostCommands (program: Command) {\n  program.command('post')\n    .description('Generate a post')\n    .option('-t, --templateFile <file>', 'Set the template file (optional)')\n    .option('-i, --interactive', 'Use interactive mode (CLI questions)')\n    .option('-l, --language <language>', 'Set the language (optional), english by default')\n    .option('-m, --model <model>', 'Set the LLM : \"gpt-4\" | \"gpt-4-32k\" | \"gpt-3.5-turbo\" | \"gpt-3.5-turbo-16k\" (optional), GPT-4 by default')\n    .option('-f, --filename <filename>', 'Set the post file name (optional)')\n    .option('-tp, --topic <topic>', 'Set the post topic (optional)')\n    .option('-c, --country <country>', 'Set the country (optional)')\n    .option('-g, --generate', 'Generate the audience and intent (optional)')\n    .option('-co, --conclusion', 'With conclusion (optional)')\n    .option('-to, --tone <tone>', 'Set the tone : \"informative\" | \"captivating\" (optional)')\n    .option('-tp, --temperature <temperature>', 'Set the temperature (optional)')\n    .option('-fp, --frequencypenalty <frequencyPenalty>', 'Set the frequency penalty (optional)')\n    .option('-pp, --presencepenalty <presencePenalty>', 'Set the presence penalty (optional)')\n    .option('-lb, --logitbias <logitBias>', 'Set the logit bias (optional)')\n    .option('-d, --debug', 'Output extra debugging')\n    .option('-da, --debugapi', 'Debug the api calls')\n    .option('-k, --apiKey <key>', 'Set the OpenAI api key (optional, you can also set the OPENAI_API_KEY environment variable)')\n    .action(async (options) => {", "      try {\n        await generatePost(options)\n      } catch (error) {\n        if (error instanceof NoApiKeyError) {\n          console.error('Unable to initialize the ChatGPT API. Please make sure that you have set the OPENAI_API_KEY environment variable or use the -K option for setting the API key')\n        } else {\n          console.error(`Error during the generation of the post : ${error}`)\n        }\n      }\n    })\n}\n", "async function generatePost (options: Options) {\n  let answers : any = {}\n  if (isInteractive(options)) {\n    answers = isCustom(options) ? await askCustomQuestions() : await askQuestions()\n  }\n\n  const defaultPostPrompt = buildDefaultPostPrompt()\n\n  const postPrompt : PostPrompt = {\n    ...defaultPostPrompt,\n    ...options,\n    ...answers,\n    maxModelTokens: answers.model === 'gpt-4' ? 8000 : 4000\n\n  }\n", "  if (!postPrompt.topic) {\n    throw new Error('The topic is mandatory, use the option -tp or --topic')\n  }\n\n  const postGenerator = new OpenAIPostGenerator(postPrompt)\n  const post = await postGenerator.generate()\n\n  const jsonData = {\n    ...post,\n    content: isCustom(options)\n      ? (isMarkdown(options)\n          ? marked(post.content)\n          : post.content)\n      : marked(post.content)\n  }\n\n  const jsonFile = `${postPrompt.filename}.json`\n  const contentFile = `${postPrompt.filename}.${getFileExtension(options)}`\n\n  const writeJSONPromise = fs.promises.writeFile(jsonFile, JSON.stringify(jsonData), 'utf8')\n  const writeDocPromise = fs.promises.writeFile(contentFile, buildContent(options, post), 'utf8')\n  await Promise.all([writeJSONPromise, writeDocPromise])\n\n  console.log(`\ud83d\udd25 Content is successfully generated in the file : ${contentFile}. Use the file ${jsonFile} to publish the content on Wordpress.`)\n  console.log(`- Slug : ${post.slug}`)\n  console.log(`- H1 : ${post.title}`)\n  console.log(`- SEO Title : ${post.seoTitle}`)\n  console.log(`- SEO Description : ${post.seoDescription}`)\n  console.log(`- Total prompts tokens : ${post.totalTokens.promptTokens}`)\n  console.log(`- Total completion tokens : ${post.totalTokens.completionTokens}`)\n  console.log(`- Estimated cost :  ${estimatedCost(postPrompt.model, post)}$`)\n}\n", "function isInteractive (options : Options) {\n  return options?.interactive\n}\n\nfunction isCustom (options : Options) {\n  return options.templateFile !== undefined\n}\n\nfunction buildDefaultPostPrompt () : PostPrompt {\n  return {\n    model: 'gpt-4',\n    language: 'english',\n    tone: 'informative',\n    withConclusion: true,\n    temperature: 0.8,\n    frequencyPenalty: 0,\n    presencePenalty: 1,\n    logitBias: 0\n  }\n}\n", "function buildDefaultPostPrompt () : PostPrompt {\n  return {\n    model: 'gpt-4',\n    language: 'english',\n    tone: 'informative',\n    withConclusion: true,\n    temperature: 0.8,\n    frequencyPenalty: 0,\n    presencePenalty: 1,\n    logitBias: 0\n  }\n}\n", "function buildContent (options : Options, post : Post) {\n  return isHTML(options)\n    ? buildHTMLPage(post)\n    // in automatic mode, we add the title (h1) into the content\n    : buildMDPage(post)\n}\n\nfunction isHTML (options : Options) {\n  return getFileExtension(options) === 'html'\n}\n", "function isMarkdown (options : Options) {\n  return getFileExtension(options) === 'md'\n}\n\nfunction getFileExtension (options : Options) {\n  // in custom mode, we use the template extension\n  // in auto/default mode, we use the markdown extension in all cases\n  return isCustom(options) ? options.templateFile.split('.').pop() : 'md'\n}\n\nfunction buildMDPage (post: Post) {\n  return '# ' + post.title + '\\n' + post.content\n}\n", "function buildMDPage (post: Post) {\n  return '# ' + post.title + '\\n' + post.content\n}\n\nfunction buildHTMLPage (post : Post) {\n  return `\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>${post.seoTitle}</title>\n    <meta name=\"description\" content=\"${post.seoDescription}\">\n  </head>\n  <body>\n    <h1>${post.title}</h1>\n    ${post.content}\n  </body>\n  </html>\n  `\n}\n", "function estimatedCost (model : string, post : Post) {\n  const promptTokens = post.totalTokens.promptTokens\n  const completionTokens = post.totalTokens.completionTokens\n\n  return (model === 'gpt-4')\n    ? Number(((promptTokens / 1000) * GPT4_PROMPT_PRICE) + ((completionTokens / 1000) * GPT4_COMPLETION_PRICE)).toFixed(4)\n    : Number(((promptTokens / 1000) * GPT35_PROMPT_PRICE) + ((completionTokens / 1000) * GPT_COMPLETION_PRICE)).toFixed(4)\n}\n"]}
{"filename": "src/bin/command/wp.ts", "chunked_list": ["import fs from 'fs'\nimport util from 'util'\nimport { Command } from 'commander'\nimport {\n  getAllWordpress,\n  getWordpress,\n  addWordpress,\n  removeWordpress,\n  exportWordpressList,\n  importWordpressList", "  exportWordpressList,\n  importWordpressList\n} from '../../lib/store/store'\n\nimport { getCategories, createPost, updatePost } from '../../lib/wp/wp-api'\nimport { Post } from '../../types'\n\nconst readFile = util.promisify(fs.readFile)\n\ntype UpdateOptions = {\n  date : string\n}\n", "\ntype UpdateOptions = {\n  date : string\n}\n\nexport function buildWpCommands (program: Command) {\n  const wpCommand = program\n    .command('wp')\n    .description('Wordpress related commands. The wp list is stored in the local store : ~/.julius/wordpress.json')\n    .action(() => {\n      console.log('Please provide a sub-command: \"add\" or \"ls\" or \"rm\" , ... ')\n    })\n\n  wpCommand\n    .command('ls')\n    .description('List all Wordpress sites')\n    .action(async () => {\n      await getAllWp()\n    })\n\n  wpCommand\n    .command('info <domain|index>')\n    .description('Info on a Wordpress site')\n    .action(async (domain) => {\n      const domainFound = await getWordpress(domain)", "      if (domainFound) {\n        console.log('\\nWordpress site found :\\n')\n        console.log(`\\ndomain : ${domainFound.domain}`)\n        console.log(`username : ${domainFound.username}`)\n        console.log(`password : ${domainFound.password}\\n`)\n      } else {\n        console.log(`\\nWordpress site ${domain} not found\\n`)\n      }\n    })\n\n  wpCommand\n    .command('add <domain:username:password>')\n    .description('Add a new Wordpress site')\n    .action(async (site) => {\n      await addWpSite(site)\n    })\n\n  wpCommand\n    .command('rm <domain|index>')\n    .description('Remove Wordpress site')\n    .action(async (domain) => {\n      const deleted = await removeWordpress(domain)\n      console.log(deleted ? `\\nWordpress site ${domain} removed successfully\\n` : `Wordpress site ${domain} not found\\n`)\n    })\n\n  wpCommand\n    .command('export <file>')\n    .description('Export the list of wordpress sites (with credentials) the console')\n    .action(async (file) => {\n      await exportWordpressList(file)\n    })\n\n  wpCommand\n    .command('import <file>')\n    .description('Import the list of wordpress sites (with credentials) from a file')\n    .action(async (file) => {\n      await importWordpressList(file)\n    })\n\n  wpCommand\n    .command('categories <domain|index>')\n    .description('Fetch the categories for one Wordpress site')\n    .action(async (domain) => {\n      const domainFound = await getWordpress(domain)", "      if (domainFound) {\n        const categories = await getCategories(domainFound)\n        console.log(categories)\n      } else {\n        console.log(`\\nWordpress site ${domain} not found\\n`)\n      }\n    })\n\n  wpCommand\n    .command('post <domain> <categoryId> <jsonfile>')\n    .description('Create a new post to a Wordpress site. The file has to be a json file containing : { content, categories, seoTitle, seoDescription }')\n    .action(async (domain, categoryId, jsonFile) => {\n      const domainFound = await getWordpress(domain)", "      if (!domainFound) {\n        console.log(`\\nWordpress site ${domain} not found\\n`)\n        return\n      }\n      const jsonContent = await readFile(jsonFile, 'utf8')\n      const post: Post = JSON.parse(jsonContent)\n      post.categories = [categoryId]\n      post.status = 'draft'\n\n      await createPost(domainFound, post)\n      console.log(`\\nContent has been published on https://${domainFound.domain}/${post.slug}\\n`)\n    })\n\n  wpCommand\n    .command('update <domain> <slug> <jsonfile>')\n    .option('-d, --date <date>', 'Update the publish date of the post. Use the format YYYY-MM-DD:HH:MM:SS')\n    .description('Update a new post to a Wordpress site. The file has to be a json file containing : { content, seoTitle, seoDescription }')\n    .action(async (domain, slug, jsonFile, options : UpdateOptions) => {\n      const domainFound = await getWordpress(domain)", "      if (!domainFound) {\n        console.log(`\\nWordpress site ${domain} not found\\n`)\n        return\n      }\n      const jsonContent = await readFile(jsonFile, 'utf8')\n      const newContent: Post = JSON.parse(jsonContent)\n      await updatePost(domainFound, slug, newContent, options.date)\n      console.log(`\\nContent has been updated on https://${domainFound.domain}${slug}\\n\\n`)\n    })\n}\n", "async function getAllWp () {\n  const wpSites = await getAllWordpress()\n  if (wpSites.length === 0) {\n    console.log('\\nNo Wordpress site found\\n')\n    return\n  }\n  console.log('\\nWordpress sites :\\n')\n  console.log(wpSites.map((wp, index) => `${index + 1}. ${wp.domain} (${wp.username})`).join('\\n') + '\\n')\n}\n\nasync function addWpSite (site) {\n  const [domain, username, password] = site.split(':')", "async function addWpSite (site) {\n  const [domain, username, password] = site.split(':')\n  if (!domain || !username || !password) {\n    console.error('Invalid format for adding a new wp site. Expected : domain:username:password')\n    return\n  }\n  await addWordpress({ domain, username, password })\n  console.log(`\\nWordpress site ${domain} added successfully\\n`)\n}\n"]}
{"filename": "src/bin/question/questions.ts", "chunked_list": ["import inquirer from 'inquirer'\nimport inquirerPrompt from 'inquirer-autocomplete-prompt'\nimport inquirerFileTreeSelection from 'inquirer-file-tree-selection-prompt'\n\ninquirer.registerPrompt('autocomplete', inquirerPrompt)\ninquirer.registerPrompt('file-tree-selection', inquirerFileTreeSelection)\n\nconst LANGUAGES = ['english', 'french', 'spanish', 'german', 'italian', 'russian',\n  'portuguese', 'polish', 'turkish', 'swedish', 'norwegian', 'dutch', 'danish',\n  'czech', 'greek', 'hungarian', 'finnish', 'romanian', 'bulgarian', 'serbian',", "  'portuguese', 'polish', 'turkish', 'swedish', 'norwegian', 'dutch', 'danish',\n  'czech', 'greek', 'hungarian', 'finnish', 'romanian', 'bulgarian', 'serbian',\n  'slovak', 'croatian', 'ukrainian', 'slovene', 'estonian', 'latvian', 'lithuanian',\n  'chinese', 'hindi', 'arabic', 'japanese']\n\nconst CONTENT_TONE = ['informative', 'captivating']\n\nconst MODELS = ['gpt-4', 'gpt-3.5-turbo', 'gpt-3.5-turbo-16k', 'gpt-4-32k']\nconst questions = [\n  {", "const questions = [\n  {\n    type: 'autocomplete',\n    name: 'language',\n    message: 'Language ?',\n    source: (answersSoFar, input) => LANGUAGES.filter((language) => language.startsWith(input)),\n    default: 'english'\n  },\n  {\n    type: 'list',", "  {\n    type: 'list',\n    name: 'model',\n    message: 'AI model ?',\n    choices: MODELS,\n    default: 'gpt-4'\n  },\n  {\n    type: 'input',\n    name: 'filename',", "    type: 'input',\n    name: 'filename',\n    message: 'Filename (without extension) ?',\n    default: 'post'\n  },\n  {\n    type: 'input',\n    name: 'topic',\n    message: 'Topic/ Artitle Title ? '\n  },", "    message: 'Topic/ Artitle Title ? '\n  },\n  {\n    type: 'input',\n    name: 'country',\n    message: 'Country ?',\n    default: 'none'\n\n  },\n  {", "  },\n  {\n    type: 'input',\n    name: 'intent',\n    message: 'Intent ?',\n    default: 'The article should be informative and offer advice to the reader.'\n  },\n  {\n    type: 'input',\n    name: 'audience',", "    type: 'input',\n    name: 'audience',\n    message: 'Audience ?',\n    default: 'The article should be written for a general audience.'\n  },\n  {\n    type: 'confirm',\n    name: 'withConclusion',\n    message: 'With conclusion ?'\n  },", "    message: 'With conclusion ?'\n  },\n  {\n    type: 'list',\n    choices: CONTENT_TONE,\n    name: 'tone',\n    message: 'Content Tone ?',\n    default: 'Informative'\n  },\n  {", "  },\n  {\n    type: 'number',\n    name: 'temperature',\n    message: 'Temperature ?',\n    default: 0.8\n  },\n  {\n    type: 'number',\n    name: 'frequencyPenalty',", "    type: 'number',\n    name: 'frequencyPenalty',\n    message: 'Frequency Penalty (-2/2) ?',\n    default: 0\n  },\n  {\n    type: 'number',\n    name: 'presencePenalty',\n    message: 'Presence Penalty (-2/2) ?',\n    default: 1", "    message: 'Presence Penalty (-2/2) ?',\n    default: 1\n  },\n  {\n    type: 'number',\n    name: 'logitBias',\n    message: 'Logit bias ?',\n    default: 0\n  }\n", "  }\n\n]\nconst customQuestions = [\n  {\n    type: 'autocomplete',\n    name: 'language',\n    message: 'Language ?',\n    source: (answersSoFar, input) => LANGUAGES.filter((language) => language.startsWith(input)),\n    default: 'english'", "    source: (answersSoFar, input) => LANGUAGES.filter((language) => language.startsWith(input)),\n    default: 'english'\n  },\n  {\n    type: 'list',\n    name: 'model',\n    message: 'AI model ?',\n    choices: MODELS,\n    default: 'gpt-4'\n  },", "    default: 'gpt-4'\n  },\n  {\n    type: 'input',\n    name: 'filename',\n    message: 'Filename (without extension) ?',\n    default: 'post'\n  },\n  {\n    type: 'number',", "  {\n    type: 'number',\n    name: 'temperature',\n    message: 'Temperature ?',\n    default: 0.8\n  },\n  {\n    type: 'number',\n    name: 'frequencyPenalty',\n    message: 'Frequency Penalty (-2/2) ?',", "    name: 'frequencyPenalty',\n    message: 'Frequency Penalty (-2/2) ?',\n    default: 0\n  },\n  {\n    type: 'number',\n    name: 'presencePenalty',\n    message: 'Presence Penalty (-2/2) ?',\n    default: 1\n  }", "    default: 1\n  }\n\n]\n\nexport async function askQuestions () {\n  return inquirer.prompt(questions)\n}\n\nexport async function askCustomQuestions () {\n  return inquirer.prompt(customQuestions)\n}\n", "export async function askCustomQuestions () {\n  return inquirer.prompt(customQuestions)\n}\n"]}
{"filename": "src/lib/tokenizer.ts", "chunked_list": ["// eslint-disable-next-line camelcase\nimport { get_encoding } from '@dqbd/tiktoken'\n\n// TODO: make this configurable\nconst tokenizer = get_encoding('cl100k_base')\n\nexport function encode (input: string): Uint32Array {\n  return tokenizer.encode(input)\n}\n"]}
{"filename": "src/lib/template.ts", "chunked_list": ["\nexport function extractPrompts (template: string): string[] {\n  const regex = /{\\d+:((?:.|\\n)*?)}/g\n  return Array.from(template.matchAll(regex)).map((match) => match[1].trim())\n}\n\nexport function replacePrompt (template: string, index: number, content: string): string {\n  const regex = new RegExp(`{${index}:((?:.|\\n)*?)}`)\n  return template.replace(regex, content)\n}\n", "export function replaceAllPrompts (template: string, contents: string[]): string {\n  // We are removing the first prompt because it is the system prompt\n  let tmpTemplate = replacePrompt(template, 0, '')\n\n  contents.forEach((content, index) => {\n    tmpTemplate = replacePrompt(tmpTemplate, index + 1, content)\n  })\n\n  return tmpTemplate.trim()\n}\n"]}
{"filename": "src/lib/prompts.ts", "chunked_list": ["import { PostPrompt } from '../types'\n\nconst STRUCTURE_OUTLINE = 'Generate the blog post outline with the following JSON format: ' +\n'{\"title\": \"\", // Add the post title here ' +\n'\"headings\" : [ { \"title\": \"\", // Add the heading title here ' +\n  '\"keywords\": [\"...\", \"...\", \"...\", \"...\"], // Add a list of keywords here. They will help to generate the final content of this heading.' +\n  '\"headings\": [ // If necessary, add subheadings here. This is optional.' +\n    '{ \"title\": \"\", ' + '\"keywords\": [\"...\", \"...\"] },' +\n    '{ \"title\": \"\", \"keywords\": [\"...\", \"...\"] }, ... ] } ... ],' +\n'\"slug\" : \"\", // Use the main keywords for the slug based on the topic of the post. Do not mention the country. Max 3 or 4 keywords, without stop words and with text normalization and accent stripping.' +", "    '{ \"title\": \"\", \"keywords\": [\"...\", \"...\"] }, ... ] } ... ],' +\n'\"slug\" : \"\", // Use the main keywords for the slug based on the topic of the post. Do not mention the country. Max 3 or 4 keywords, without stop words and with text normalization and accent stripping.' +\n'\"seoTitle\" : \"\", // Not the same as the post title, max 60 characters, do not mention the country.' +\n'\"seoDescription : \"\" // Max 155 characters }'\n\nconst INFORMATIVE_INTRO_PROMPT = 'Compose the introduction for this blog post topic, without using phrases such as, \"In this article,...\" to introduce the subject.' +\n  'Instead, explain the context and/or explain the main problem. If necessary, mention facts to help the user better understand the context or the problem. Do not describe or introduce the content of the different headings of the outline.' +\n  'Do not add a heading. Your responses should be in the markdown format. Do not add the title in the beginning of the introduction.'\n\nconst CAPTIVATING_INTO_PROMPT = 'Compose a captivating introduction for this blog post topic, without using phrases such as, \"In this article,...\" to introduce the subject.' +", "\nconst CAPTIVATING_INTO_PROMPT = 'Compose a captivating introduction for this blog post topic, without using phrases such as, \"In this article,...\" to introduce the subject.' +\n  'Instead, focus on creating a hook to capture the reader\\'s attention, setting the tone and style, and seamlessly leading the reader into the main content of the article.' +\n  'Your introduction should entice readers to continue reading the article and learn more about the subject presented.' +\n  ' Do not add a heading. Your responses should be in the markdown format. Do not add the title in the beginning of the introduction.'\n\n// ------------------------------------------------------\n// PROMPTS FOR THE INTERACTIVE / AUTO MODE\n// ------------------------------------------------------\n\nexport function getAutoSystemPrompt (postPrompt : PostPrompt) {\n  return 'You are a copywriter with a strong expertise in SEO. I need a detailed blog post in ' + postPrompt.language + ' about the topic: \"' + postPrompt.topic + '\".' +\n    'Do not add a paragraph summarizing your response/explanation at the end of your answers.'\n}\n", "// ------------------------------------------------------\n\nexport function getAutoSystemPrompt (postPrompt : PostPrompt) {\n  return 'You are a copywriter with a strong expertise in SEO. I need a detailed blog post in ' + postPrompt.language + ' about the topic: \"' + postPrompt.topic + '\".' +\n    'Do not add a paragraph summarizing your response/explanation at the end of your answers.'\n}\n\nexport function getPromptForIntentAudience (postPrompt : PostPrompt) {\n  return 'For a post based on the topic : ' + postPrompt.topic + ', describe the ideal audience and intent for this topic.' +\n  'Write maximum 3 statements for the audience and also 3 statements for the intent.' +\n  'Your response should be only the following object in json format : ' +\n  '{\"audience\" : \"\", \"intent\": \"\"}'\n}\n", "export function getPromptForOutline (postPrompt : PostPrompt) {\n  const { country, intent, audience } = postPrompt\n  const prompt = STRUCTURE_OUTLINE +\n  'For the title and headings, do not capitalize words unless the first one.' +\n  'Please make sure your title is clear, concise, and accurately represents the topic of the post.' +\n  'Do not add a heading for an introduction, conclusion, or to summarize the article.' +\n  (country ? 'Market/country/region:' + country + '.' : '') +\n  (audience ? 'Audience: ' + audience + '.' : '') +\n  (intent ? 'Content intent: ' + intent + '.' : '')\n\n  return prompt\n}\n", "export function getPromptForMainKeyword () {\n  const prompt = 'Give me the most important SEO keyword in a JSON array in which each item matches a word without the stop words.'\n  return prompt\n}\n\nexport function getPromptForIntroduction (postPrompt : PostPrompt) {\n  return (!postPrompt.tone) || postPrompt.tone === 'informative' ? INFORMATIVE_INTRO_PROMPT : CAPTIVATING_INTO_PROMPT\n}\n\nexport function getPromptForHeading (tone : string, title : string, keywords : string[] | null) {\n  return tone === 'informative' ? getPromptForInformativeHeading(title, keywords) : getPromptForCaptivatingHeading(title, keywords)\n}\n", "export function getPromptForHeading (tone : string, title : string, keywords : string[] | null) {\n  return tone === 'informative' ? getPromptForInformativeHeading(title, keywords) : getPromptForCaptivatingHeading(title, keywords)\n}\n\nexport function getPromptForConclusion () {\n  return 'Write a compelling conclusion for this blog post topic without using transitional phrases such as, \"In conclusion\", \"In summary\", \"In short\", \"So\", \"Thus\", or any other transitional expressions.' +\n  'Focus on summarizing the main points of the post, emphasizing the significance of the topic, and leaving the reader with a lasting impression or a thought-provoking final remark.' +\n  'Ensure that your conclusion effectively wraps up the article and reinforces the central message or insights presented in the blog post.' +\n  'Do not add a heading. Your responses should be in the markdown format.'\n}\n", "function getPromptForInformativeHeading (title : string, keywords : string[] | null) {\n  const promptAboutKeywords = keywords ? ' based on the following list of keywords: ' + keywords.join(', ') + '.' : ''\n  return 'Write some informative content for the heading (without the heading)  \"' + title + '\"' + promptAboutKeywords +\n    'Make sure to provide in-depth information and valuable insights. Use clear and concise language, along with relevant examples or anecdotes if needed.' +\n    'Do not start the first sentence with the heading. Instead, start with a sentence that introduces and provides context for the heading.' +\n    'I do not want a conclusion or summary at the end of the generated text. Just the information requested. ' +\n    'This rule applies to all languages. ' +\n    'So do not add a paragraph at the end of your text beginning with one of the following words or variants: in conclusion, in sum, to conclude, in summary, ... ' +\n    'Your response should be in the markdown format.'\n}\n", "function getPromptForCaptivatingHeading (title : string, keywords : string[] | null) {\n  const promptAboutKeywords = keywords ? ' based on the following list of keywords: ' + keywords.join(', ') + '.' : ''\n\n  return 'Write some captivating content for the heading (without the heading): \"' + title + '\"' + promptAboutKeywords +\n  'Make sure to provide in-depth information and valuable insights. Use clear and concise language, along with relevant examples or anecdotes, to engage the reader and enhance their understanding.' +\n  'Do not start the first sentence with the heading. Instead, start with a sentence that introduces and provides context for the heading.' +\n  'I do not want a conclusion or summary at the end of the generated text. Just the information requested. ' +\n  'This rule applies to all languages. ' +\n  'So do not add a paragraph at the end of your text beginning with one of the following words or variants: in conclusion, in sum, to conclude, in summary, ... ' +\n  'Your response should be in the markdown format.'\n}\n\n// ------------------------------------------------------\n// PROMPTS FOR THE CUSTOM MODE (based on a template)\n// ------------------------------------------------------\n", "export function getCustomSystemPrompt (postPrompt : PostPrompt) {\n  // The prompt with the index 0 in the template is the system prompt\n  return postPrompt.prompts[0] + '\\n' + ' Language: ' + postPrompt.language + '. '\n}\n\nexport function getSeoSystemPrompt (postPrompt : PostPrompt) {\n  return 'You are a SEO expert and you need to optimize a web page based on the following info in ' + postPrompt.language + ': ' +\n    '\\n' + postPrompt.prompts[0]\n}\n\nexport function getPromptForSeoInfo (postPrompt : PostPrompt) {\n  return 'For content based on the topic of this conversation, Use the H1 provided in the system prompt. If not, write a new H1. ' +\n  'Use the slug provided in the system prompt. If not, write a new slug.' +\n  'Write an SEO title and an SEO description for this blog post.' +\n  'The SEO title should be no more than 60 characters long.' +\n  'The H1 and the title should be different.' +\n  'The SEO description should be no more than 155 characters long.' +\n  'Use the main keywords for the slug based on the topic of the post. Do not mention the country. Max 3 or 4 keywords, without stop words, and with text normalization and accent stripping.' +\n  'Your response should be in the JSON format based on the following structure: ' +\n  '{\"h1\" : \"\", \"seoTitle\": \"\", \"\": \"seoDescription\": \"\", \"slug\": \"\"}'\n}\n", "export function getPromptForSeoInfo (postPrompt : PostPrompt) {\n  return 'For content based on the topic of this conversation, Use the H1 provided in the system prompt. If not, write a new H1. ' +\n  'Use the slug provided in the system prompt. If not, write a new slug.' +\n  'Write an SEO title and an SEO description for this blog post.' +\n  'The SEO title should be no more than 60 characters long.' +\n  'The H1 and the title should be different.' +\n  'The SEO description should be no more than 155 characters long.' +\n  'Use the main keywords for the slug based on the topic of the post. Do not mention the country. Max 3 or 4 keywords, without stop words, and with text normalization and accent stripping.' +\n  'Your response should be in the JSON format based on the following structure: ' +\n  '{\"h1\" : \"\", \"seoTitle\": \"\", \"\": \"seoDescription\": \"\", \"slug\": \"\"}'\n}\n"]}
{"filename": "src/lib/errors.ts", "chunked_list": ["export class NoApiKeyError extends Error {\n  constructor () {\n    super()\n    this.name = 'NoApiKeyError'\n  }\n}\n"]}
{"filename": "src/lib/extractor.ts", "chunked_list": ["import JSON5 from 'json5'\nimport { validate } from 'jsonschema'\n\nimport { AudienceIntentInfo, PostOutline, SeoInfo } from '../types'\n\nexport class PostOutlineValidationError extends Error {\n  constructor (message: string, public readonly errors: any[]) {\n    super(message)\n  }\n}\n\nconst schemaValidiation = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    title: {\n      type: 'string'\n    },\n    headings: {\n      type: 'array',\n      items: {\n        $ref: '#/definitions/Heading'\n      }\n    },\n    slug: {\n      type: 'string'\n    },\n    seoTitle: {\n      type: 'string'\n    },\n    seoDescription: {\n      type: 'string'\n    }\n  },\n  required: [\n    'title',\n    'headings',\n    'slug',\n    'seoTitle',\n    'seoDescription'\n  ],\n  additionalProperties: false,\n  definitions: {\n    Heading: {\n      type: 'object',\n      properties: {\n        title: {\n          type: 'string'\n        },\n        keywords: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        headings: {\n          type: 'array',\n          items: {\n            $ref: '#/definitions/Heading'\n          }\n        }\n      },\n      required: [\n        'title'\n      ],\n      additionalProperties: false\n    }\n  }\n}\n", "export function extractCodeBlock (text: string): string {\n  // Extract code blocks with specified tags\n  const codeBlockTags = ['markdown', 'html', 'json']\n\n  for (const tag of codeBlockTags) {\n    const regex = new RegExp(`\\`\\`\\`${tag}((.|\\\\n|\\\\r)*?)\\`\\`\\``, 'i')\n    const match = text.match(regex)\n    if (match) {\n      return match[1]\n    }\n  }\n\n  // Extract code blocks without specified tags\n  const genericRegex = /```\\n?((.|\\\\n|\\\\r)*?)```/\n  const genericMatch = text.match(genericRegex)", "  if (genericMatch) {\n    return genericMatch[1]\n  }\n\n  // No code blocks found\n  return text\n}\n\nexport function extractPostOutlineFromCodeBlock (text: string) : PostOutline {\n  // Use JSON5 because it supports trailing comma and comments in the json text\n  const jsonData = JSON5.parse(extractCodeBlock(text))\n  const v = validate(jsonData, schemaValidiation)", "export function extractPostOutlineFromCodeBlock (text: string) : PostOutline {\n  // Use JSON5 because it supports trailing comma and comments in the json text\n  const jsonData = JSON5.parse(extractCodeBlock(text))\n  const v = validate(jsonData, schemaValidiation)\n  if (!v.valid) {\n    const errorList = v.errors.map((val) => val.toString())\n    throw new PostOutlineValidationError('Invalid json for the post outline', errorList)\n  }\n  return jsonData\n}\n", "export function extractJsonArray (text : string) : string[] {\n  return JSON5.parse(extractCodeBlock(text))\n}\n\nexport function extractSeoInfo (text : string) : SeoInfo {\n  return JSON5.parse(extractCodeBlock(text))\n}\n\nexport function extractAudienceIntentInfo (text : string) : AudienceIntentInfo {\n  return JSON5.parse(extractCodeBlock(text))\n}\n", "export function extractAudienceIntentInfo (text : string) : AudienceIntentInfo {\n  return JSON5.parse(extractCodeBlock(text))\n}\n"]}
{"filename": "src/lib/post-helpers.ts", "chunked_list": ["import * as dotenv from 'dotenv'\nimport { readFile as rd } from 'fs'\nimport { promisify } from 'util'\nimport { ChatGPTAPI, ChatGPTError, ChatMessage, SendMessageOptions } from 'chatgpt'\nimport pRetry, { AbortError, FailedAttemptError } from 'p-retry'\nimport { extractJsonArray, extractCodeBlock, extractPostOutlineFromCodeBlock, extractSeoInfo, extractAudienceIntentInfo } from './extractor'\nimport {\n  getPromptForMainKeyword,\n  getPromptForOutline,\n  getPromptForIntroduction,", "  getPromptForOutline,\n  getPromptForIntroduction,\n  getPromptForHeading,\n  getPromptForConclusion,\n  getAutoSystemPrompt,\n  getPromptForSeoInfo,\n  getCustomSystemPrompt,\n  getSeoSystemPrompt,\n  getPromptForIntentAudience as getPromptForAudienceIntent\n} from './prompts'", "  getPromptForIntentAudience as getPromptForAudienceIntent\n} from './prompts'\nimport {\n  Heading,\n  PostOutline,\n  PostPrompt,\n  TotalTokens,\n  SeoInfo\n} from '../types'\n", "} from '../types'\n\nimport { encode } from './tokenizer'\nimport { extractPrompts } from './template'\nimport { log } from 'console'\nimport { NoApiKeyError } from './errors'\n\ndotenv.config()\n\nconst readFile = promisify(rd)", "\nconst readFile = promisify(rd)\n\n/**\n* Specific Open AI API parameters for the completion\n*/\nexport type CompletionParams = {\n  temperature?: number | null,\n  top_p?: number | null,\n  max_tokens?: number,\n  presence_penalty?: number | null,\n  frequency_penalty?: number | null,\n  logit_bias?: object | null,\n\n}\n\n/**", " * Interface for the helper class for generating a post. it defines how to generate a post\n * Each helper class must implement this interface\n * @interface\n */\nexport interface GeneratorHelperInterface {\n  init () : Promise<void>\n  isCustom() : boolean\n  generateContentOutline () : Promise<PostOutline>\n  generateMainKeyword () : Promise<string[]>\n  generateIntroduction () : Promise<string>\n  generateConclusion () : Promise<string>\n  generateHeadingContents (tableOfContent : PostOutline) : Promise<string>\n  generateCustomPrompt(prompt : string) : Promise<string>\n  generateSeoInfo () : Promise<SeoInfo>\n  getTotalTokens() : TotalTokens\n  getPrompt() : PostPrompt\n}\n\n/**\n * Helper implementation for generating a post using the ChatGPT API\n * @class\n */", "export class ChatGptHelper implements GeneratorHelperInterface {\n  private postPrompt : PostPrompt\n  private api : ChatGPTAPI\n  // The parent message is either the previous one in the conversation (if a template is used)\n  // or the generated outline (if we are in auto mode)\n  private chatParentMessage : ChatMessage\n  private completionParams : CompletionParams\n  private totalTokens : TotalTokens = {\n    promptTokens: 0,\n    completionTokens: 0,\n    total: 0\n  }\n\n  // -----------------------------------------------\n  // CONSTRUCTOR AND INITIALIZATION\n  // -----------------------------------------------\n  public constructor (postPrompt : PostPrompt) {\n    this.postPrompt = postPrompt\n  }\n\n  isCustom () : boolean {\n    return this.postPrompt?.templateFile !== undefined\n  }\n\n  getPrompt (): PostPrompt {\n    return this.postPrompt\n  }\n\n  getTotalTokens (): TotalTokens {\n    return this.totalTokens\n  }\n\n  async init () {", "    if (this.isCustom()) {\n      if (this.postPrompt.debug) {\n        console.log(`Use template : ${this.postPrompt.templateFile}`)\n      }\n      this.postPrompt.templateContent = await this.readTemplate()\n      this.postPrompt.prompts = extractPrompts(this.postPrompt.templateContent)\n    }\n\n    const systemMessage = this.isCustom() ? getCustomSystemPrompt(this.postPrompt) : getAutoSystemPrompt(this.postPrompt)\n    await this.buildChatGPTAPI(systemMessage)\n  }\n\n  private async buildChatGPTAPI (systemMessage : string) {", "    try {\n      this.api = new ChatGPTAPI({\n        apiKey: this.postPrompt?.apiKey || process.env.OPENAI_API_KEY,\n        completionParams: {\n          model: this.postPrompt.model\n        },\n        systemMessage,\n        debug: this.postPrompt.debugapi\n      })\n    } catch (error) {\n      throw new NoApiKeyError()\n    }\n", "    } catch (error) {\n      throw new NoApiKeyError()\n    }\n\n    if (this.postPrompt.debug) {\n      console.log(`OpenAI API initialized with model : ${this.postPrompt.model}`)\n    }\n\n    this.completionParams = {\n      temperature: this.postPrompt.temperature ?? 0.8,\n      frequency_penalty: this.postPrompt.frequencyPenalty ?? 0,\n      presence_penalty: this.postPrompt.presencePenalty ?? 1\n    }\n", "    if (this.postPrompt.logitBias) {\n      const mainKwWords = await this.generateMainKeyword()\n      // set the logit bias in order to force the model to minimize the usage of the main keyword\n      const logitBiais: Record<number, number> = {}\n      mainKwWords.forEach((kw) => {\n        const encoded = encode(kw)\n        encoded.forEach((element) => {\n          logitBiais[element] = Number(this.postPrompt.logitBias) || -1\n        })\n      })\n      this.completionParams.logit_bias = logitBiais\n    }\n", "    if (this.postPrompt.debug) {\n      console.log('---------- COMPLETION PARAMETERS ----------')\n      console.log('Max Tokens  : ' + this.completionParams.max_tokens)\n      console.log('Temperature : ' + this.completionParams.temperature)\n      console.log('Frequency Penalty : ' + this.completionParams.frequency_penalty)\n      console.log('Presence Penalty : ' + this.completionParams.presence_penalty)\n      console.log('Logit Biais : ' + this.completionParams.logit_bias)\n    }\n  }\n\n  // -----------------------------------------------\n  // METHODS FOR THE AUTOMATIC MODE\n  // -----------------------------------------------\n  async generateMainKeyword () {\n    const prompt = getPromptForMainKeyword()", "    if (this.postPrompt.debug) {\n      console.log('---------- PROMPT MAIN KEYWORD ----------')\n      console.log(prompt)\n    }\n    const response = await this.sendRequest(prompt)\n    if (this.postPrompt.debug) {\n      console.log('---------- MAIN KEYWORD ----------')\n      console.log(response.text)\n    }\n\n    return extractJsonArray(response.text)\n  }\n\n  async generateContentOutline () {", "    if (this.postPrompt.generate) {\n      const audienceIntent = await this.generateAudienceIntent()\n      this.postPrompt = {\n        ...audienceIntent,\n        ...this.postPrompt\n      }\n    }\n\n    const prompt = getPromptForOutline(this.postPrompt)\n    if (this.postPrompt.debug) {\n      console.log('---------- PROMPT OUTLINE ----------')\n      console.log(prompt)\n    }\n    // the parent message is the outline for the upcoming content\n    // By this way, we can decrease the cost of the API call by minimizing the number of prompt tokens\n    // TODO : add an option to disable this feature\n    this.chatParentMessage = await this.sendRequest(prompt)", "    if (this.postPrompt.debug) {\n      console.log('---------- PROMPT OUTLINE ----------')\n      console.log(prompt)\n    }\n    // the parent message is the outline for the upcoming content\n    // By this way, we can decrease the cost of the API call by minimizing the number of prompt tokens\n    // TODO : add an option to disable this feature\n    this.chatParentMessage = await this.sendRequest(prompt)\n    if (this.postPrompt.debug) {\n      console.log('---------- OUTLINE ----------')\n      console.log(this.chatParentMessage.text)\n    }\n\n    return extractPostOutlineFromCodeBlock(this.chatParentMessage.text)\n  }\n\n  async generateAudienceIntent () {\n    const prompt = getPromptForAudienceIntent(this.postPrompt)", "    if (this.postPrompt.debug) {\n      console.log('---------- OUTLINE ----------')\n      console.log(this.chatParentMessage.text)\n    }\n\n    return extractPostOutlineFromCodeBlock(this.chatParentMessage.text)\n  }\n\n  async generateAudienceIntent () {\n    const prompt = getPromptForAudienceIntent(this.postPrompt)\n    if (this.postPrompt.debug) {\n      console.log('---------- PROMPT AUDIENCE INTENT ----------')\n      console.log(prompt)\n    }\n    const response = await this.sendRequest(prompt)", "    if (this.postPrompt.debug) {\n      console.log('---------- PROMPT AUDIENCE INTENT ----------')\n      console.log(prompt)\n    }\n    const response = await this.sendRequest(prompt)\n    if (this.postPrompt.debug) {\n      console.log('---------- AUDIENCE INTENT ----------')\n      console.log(response.text)\n    }\n\n    return extractAudienceIntentInfo(response.text)\n  }\n\n  async generateIntroduction () {\n    const response = await this.sendRequest(getPromptForIntroduction(this.postPrompt), this.completionParams)\n    return extractCodeBlock(response.text)\n  }\n\n  async generateConclusion () {\n    const response = await this.sendRequest(getPromptForConclusion(), this.completionParams)\n    return extractCodeBlock(response.text)\n  }\n\n  async generateHeadingContents (postOutline : PostOutline) {\n    const headingLevel = 2\n\n    return await this.buildContent(postOutline.headings, headingLevel)\n  }\n\n  private async buildContent (headings: Heading[], headingLevel : number, previousContent: string = ''): Promise<string> {", "    if (headings.length === 0) {\n      return previousContent\n    }\n    const [currentHeading, ...remainingHeadings] = headings\n\n    const mdHeading = Array(headingLevel).fill('#').join('')\n    let content = previousContent + '\\n' + mdHeading + ' ' + currentHeading.title\n\n    if (currentHeading.headings && currentHeading.headings.length > 0) {\n      content = await this.buildContent(currentHeading.headings, headingLevel + 1, content)\n    } else {\n      content += '\\n' + await this.getContent(currentHeading)\n    }\n\n    return this.buildContent(remainingHeadings, headingLevel, content)\n  }\n\n  private async getContent (heading: Heading): Promise<string> {", "    if (currentHeading.headings && currentHeading.headings.length > 0) {\n      content = await this.buildContent(currentHeading.headings, headingLevel + 1, content)\n    } else {\n      content += '\\n' + await this.getContent(currentHeading)\n    }\n\n    return this.buildContent(remainingHeadings, headingLevel, content)\n  }\n\n  private async getContent (heading: Heading): Promise<string> {\n    if (this.postPrompt.debug) {\n      console.log(`\\nHeading : ${heading.title}  ...'\\n`)\n    }\n    const response = await this.sendRequest(getPromptForHeading(this.postPrompt.tone, heading.title, heading.keywords), this.completionParams)\n    return `${extractCodeBlock(response.text)}\\n`\n  }\n\n  // -----------------------------------------------\n  // METHODS FOR THE CUSTOM MODE base on a template\n  // -----------------------------------------------\n\n  /**\n   * Generate a content based on one of prompt defined in the template\n   * @param customPrompt :  the prompt defined in the template\n   * @returns the AI answer\n   */\n  async generateCustomPrompt (customPrompt : string) {\n    this.chatParentMessage = await this.sendRequest(customPrompt, this.completionParams)\n    return extractCodeBlock(this.chatParentMessage.text)\n  }\n\n  /**\n   * Generate the SEO info for the post based on the template\n   * @returns the SEO info\n   */\n  async generateSeoInfo (): Promise<SeoInfo> {\n    const systemPrompt = getSeoSystemPrompt(this.postPrompt)\n    await this.buildChatGPTAPI(systemPrompt)\n\n    this.chatParentMessage = await this.sendRequest(getPromptForSeoInfo(this.postPrompt), this.completionParams)", "    if (this.postPrompt.debug) {\n      console.log(`\\nHeading : ${heading.title}  ...'\\n`)\n    }\n    const response = await this.sendRequest(getPromptForHeading(this.postPrompt.tone, heading.title, heading.keywords), this.completionParams)\n    return `${extractCodeBlock(response.text)}\\n`\n  }\n\n  // -----------------------------------------------\n  // METHODS FOR THE CUSTOM MODE base on a template\n  // -----------------------------------------------\n\n  /**\n   * Generate a content based on one of prompt defined in the template\n   * @param customPrompt :  the prompt defined in the template\n   * @returns the AI answer\n   */\n  async generateCustomPrompt (customPrompt : string) {\n    this.chatParentMessage = await this.sendRequest(customPrompt, this.completionParams)\n    return extractCodeBlock(this.chatParentMessage.text)\n  }\n\n  /**\n   * Generate the SEO info for the post based on the template\n   * @returns the SEO info\n   */\n  async generateSeoInfo (): Promise<SeoInfo> {\n    const systemPrompt = getSeoSystemPrompt(this.postPrompt)\n    await this.buildChatGPTAPI(systemPrompt)\n\n    this.chatParentMessage = await this.sendRequest(getPromptForSeoInfo(this.postPrompt), this.completionParams)", "    if (this.postPrompt.debug) {\n      log('---------- SEO INFO ----------')\n      console.log(this.chatParentMessage.text)\n    }\n    return extractSeoInfo(this.chatParentMessage.text)\n  }\n\n  private async readTemplate () : Promise<string> {\n    const templatePath = this.postPrompt.templateFile\n    return await readFile(templatePath, 'utf-8')\n  }\n\n  // -----------------------------------------------\n  // SEND REQUEST TO OPENAI API\n  // -----------------------------------------------\n  private async sendRequest (prompt : string, completionParams? : CompletionParams) {\n    return await pRetry(async () => {\n      const options : SendMessageOptions = { parentMessageId: this.chatParentMessage?.id }", "      if (completionParams) {\n        options.completionParams = completionParams\n      }\n\n      const response = await this.api.sendMessage(prompt, options)\n      this.totalTokens.promptTokens += response.detail.usage.prompt_tokens\n      this.totalTokens.completionTokens += response.detail.usage.completion_tokens\n      this.totalTokens.total += response.detail.usage.total_tokens\n      return response\n    }, {\n      retries: 10,\n      onFailedAttempt: async (error) => {\n        this.manageError(error)\n      }\n    })\n  }\n\n  private manageError (error: FailedAttemptError) {", "    if (this.postPrompt.debug) {\n      console.log('---------- OPENAI REQUEST ERROR ----------')\n      console.log(error)\n    }\n    if (error instanceof ChatGPTError) {\n      const chatGPTError = error as ChatGPTError\n      if (chatGPTError.statusCode === 401) {\n        console.log('OpenAI API Error : Invalid API key: please check your API key in the option -k or in the OPENAI_API_KEY env var.')\n        process.exit(1)\n      }\n      if (chatGPTError.statusCode === 404) {\n        console.log(`OpenAI API Error :  Invalid model for your OpenAI subscription. Check if you can use : ${this.postPrompt.model}.`)\n        console.log(this.postPrompt.model === 'gpt-4' || this.postPrompt.model === 'gpt-4-32k' ? 'You need to join the waiting list to use the GPT-4 API : https://openai.com/waitlist/gpt-4-api' : '')\n        process.exit(1)\n      }\n    }\n", "      if (chatGPTError.statusCode === 404) {\n        console.log(`OpenAI API Error :  Invalid model for your OpenAI subscription. Check if you can use : ${this.postPrompt.model}.`)\n        console.log(this.postPrompt.model === 'gpt-4' || this.postPrompt.model === 'gpt-4-32k' ? 'You need to join the waiting list to use the GPT-4 API : https://openai.com/waitlist/gpt-4-api' : '')\n        process.exit(1)\n      }\n    }\n\n    if (error instanceof AbortError) {\n      console.log(`OpenAI API - Request aborted. ${error.message}`)\n    } else {\n      console.log(`OpenAI API - Request failed - Attempt ${error.attemptNumber} failed. There are ${error.retriesLeft} retries left. ${error.message}`)\n    }\n  }\n}\n"]}
{"filename": "src/lib/store/store.ts", "chunked_list": ["import os from 'os'\nimport fs from 'fs'\nimport path from 'path'\nimport util from 'util'\nimport { Wordpress } from './types'\nconst readFile = util.promisify(fs.readFile)\n\nconst userHomeDir = os.homedir()\n\nconst HIDDEN_DIR_NAME = '.julius'", "\nconst HIDDEN_DIR_NAME = '.julius'\nconst hiddenDirPath = path.join(userHomeDir, HIDDEN_DIR_NAME)\n\nconst WORDPRESS_FILE = `${hiddenDirPath}/wordpress.json`\n\nexport function initStore () {\n  if (!fs.existsSync(hiddenDirPath)) {\n    fs.mkdirSync(hiddenDirPath)\n  }\n", "  if (!fs.existsSync(WORDPRESS_FILE)) {\n    fs.writeFileSync(WORDPRESS_FILE, '[]', 'utf8')\n  }\n}\n\nexport async function getAllWordpress () : Promise<Wordpress[]> {\n  const data = await readFile(WORDPRESS_FILE, 'utf8')\n  return JSON.parse(data)\n}\n\nexport async function addWordpress (wp: Wordpress): Promise<void> {\n  const wpSites = [...await getAllWordpress(), wp].sort((a, b) => a.domain.localeCompare(b.domain))\n  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n}\n", "export async function addWordpress (wp: Wordpress): Promise<void> {\n  const wpSites = [...await getAllWordpress(), wp].sort((a, b) => a.domain.localeCompare(b.domain))\n  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n}\n\nexport async function getWordpress (domain: string): Promise<Wordpress | undefined> {\n  const wpSites = await getAllWordpress()\n  const index = !isNaN(Number(domain)) ? Number(domain) - 1 : wpSites.findIndex((wp) => wp.domain === domain)\n  return wpSites[index]\n}\n", "export async function removeWordpress (domain: string): Promise<Boolean> {\n  const wpSites = await getAllWordpress()\n  const index = !isNaN(Number(domain)) ? Number(domain) - 1 : wpSites.findIndex((wp) => wp.domain === domain)\n\n  if (index < 0) {\n    return false\n  }\n  wpSites.splice(index, 1)\n  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n  return true\n}\n", "export async function exportWordpressList (exportFile : string) {\n  await fs.promises.copyFile(WORDPRESS_FILE, exportFile)\n}\n\nexport async function importWordpressList (importFile : string) {\n  const data = await readFile(importFile, 'utf8')\n  const wpSites = JSON.parse(data)\n  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n}\n"]}
{"filename": "src/lib/store/types.ts", "chunked_list": ["export type Wordpress = {\n    domain : string,\n    username: string,\n    password: string\n\n}\n"]}
{"filename": "src/lib/wp/wp-api.ts", "chunked_list": ["import moment from 'moment-timezone'\nimport axios from 'axios'\nimport { Wordpress } from '../store/types'\nimport { Post } from 'src/types'\n\ntype UpdatePost = {\n  content: string;\n  title: string;\n  meta: {\n    yoast_wpseo_title: string,\n    yoast_wpseo_metadesc: string\n  };\n  date?: string;\n  date_gmt?: string;\n}\n", "export async function getCategories (wp : Wordpress) {\n  const { domain, username, password } = wp\n  const response = await axios.get(`${getApiUrl(domain)}/categories`, authenticate(username, password))\n\n  return response.data.map((category) => {\n    return {\n      id: category.id,\n      name: category.name,\n      slug: category.slug\n    }\n  })\n}\n", "export async function createPost (wp : Wordpress, post : Post) {\n  const { domain, username, password } = wp\n  const postData : any = {\n    ...post\n  }\n\n  postData.meta = {\n    yoast_wpseo_title: post.seoTitle,\n    yoast_wpseo_metadesc: post.seoDescription\n  }\n\n  return await axios.post(`${getApiUrl(domain)}/posts`, postData, authenticate(username, password))\n}\n", "export async function updatePost (wp : Wordpress, slug: string, newContent : Post, publishDate : string) {\n  const { domain, username, password } = wp\n\n  const apiUrl = getApiUrl(domain)\n  const response = await axios.get(`${apiUrl}/posts?slug=${slug}`, authenticate(username, password))\n\n  if (response.data.length === 0) {\n    throw new Error(`Post with ${slug} not found`)\n  }\n\n  const postId: number = response.data[0].id\n\n  const updatedPost : UpdatePost = {\n    content: newContent.content,\n    title: newContent.title,\n    meta: {\n      yoast_wpseo_title: newContent.seoTitle,\n      yoast_wpseo_metadesc: newContent.seoDescription\n    }\n  }", "  if (publishDate) {\n    updatedPost.date = publishDate\n    updatedPost.date_gmt = moment(publishDate).utc().format()\n  }\n\n  await axios.put(`${apiUrl}/posts/${postId}`, updatedPost, authenticate(username, password))\n}\n\nfunction getApiUrl (domain) {\n  return `https://${domain}/wp-json/wp/v2`\n}\n", "function getApiUrl (domain) {\n  return `https://${domain}/wp-json/wp/v2`\n}\n\nfunction authenticate (username : string, password : string) {\n  const token = Buffer.from(`${username}:${password}`, 'utf8').toString('base64')\n\n  return {\n    headers: {\n      Authorization: `Basic ${token}`,\n      'Content-Type': 'application/json'\n    }\n  }\n};\n"]}
{"filename": "src/lib/image/midjourney.ts", "chunked_list": ["import * as dotenv from 'dotenv'\nimport { Midjourney } from 'midjourney'\n\ndotenv.config()\n\nexport async function generateImage (prompt : string) : Promise<string[]> {\n  const client = new Midjourney({\n    ServerId: process.env.SERVER_ID,\n    ChannelId: process.env.CHANNEL_ID,\n    SalaiToken: process.env.SALAI_TOKEN,\n    Debug: true,\n    Ws: true\n  })\n  await client.Connect()\n  const imagine = await client.Imagine(prompt)\n\n  const upscale1 = await client.Upscale({\n    index: 1,\n    msgId: <string>imagine.id,\n    hash: <string>imagine.hash,\n    flags: imagine.flags,\n    loading: (uri: string, progress: string) => {\n      console.log('Upscale.loading', uri, 'progress', progress)\n    }\n  })\n\n  const upscale2 = await client.Upscale({\n    index: 2,\n    msgId: <string>imagine.id,\n    hash: <string>imagine.hash,\n    flags: imagine.flags,\n    loading: (uri: string, progress: string) => {\n      console.log('Upscale.loading', uri, 'progress', progress)\n    }\n  })\n\n  const upscale3 = await client.Upscale({\n    index: 3,\n    msgId: <string>imagine.id,\n    hash: <string>imagine.hash,\n    flags: imagine.flags,\n    loading: (uri: string, progress: string) => {\n      console.log('Upscale.loading', uri, 'progress', progress)\n    }\n  })\n\n  const upscale4 = await client.Upscale({\n    index: 4,\n    msgId: <string>imagine.id,\n    hash: <string>imagine.hash,\n    flags: imagine.flags,\n    loading: (uri: string, progress: string) => {\n      console.log('Upscale.loading', uri, 'progress', progress)\n    }\n  })\n\n  return [upscale1.uri, upscale2.uri, upscale3.uri, upscale4.uri]\n}\n"]}
