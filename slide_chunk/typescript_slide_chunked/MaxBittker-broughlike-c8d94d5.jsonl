{"filename": "src/index.ts", "chunked_list": ["import Game from \"Game\";\nimport * as PIXI from \"pixi.js\";\n\nimport \"./style.css\";\n\nlet timeout: any = null;\n\nfunction onLoad() {\n  function doResize() {\n    game.resize();\n  }\n\n  const app = new PIXI.Application({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    antialias: true,\n    transparent: false,\n    resolution: window.devicePixelRatio || 1,\n  });\n\n  app.renderer.view.style.position = \"absolute\";\n  app.renderer.view.style.display = \"block\";\n  app.renderer.plugins.interaction.interactionFrequency = 60;\n\n  const game = new Game(app);\n\n  clearTimeout(timeout);\n  timeout = setTimeout(doResize, 1000);\n\n  document.body.appendChild(app.view);\n  document.body.style.backgroundColor =\n  \"#\" + Game.BACKGROUND_COLOUR.toString(16).padStart(6, \"0\");\n\n  window.onresize = function (event: Event) {\n    doResize();\n    clearTimeout(timeout);\n    timeout = setTimeout(doResize, 500);\n  };\n\n  window.onkeydown = function (event: KeyboardEvent) {", "  function doResize() {\n    game.resize();\n  }\n\n  const app = new PIXI.Application({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    antialias: true,\n    transparent: false,\n    resolution: window.devicePixelRatio || 1,\n  });\n\n  app.renderer.view.style.position = \"absolute\";\n  app.renderer.view.style.display = \"block\";\n  app.renderer.plugins.interaction.interactionFrequency = 60;\n\n  const game = new Game(app);\n\n  clearTimeout(timeout);\n  timeout = setTimeout(doResize, 1000);\n\n  document.body.appendChild(app.view);\n  document.body.style.backgroundColor =\n  \"#\" + Game.BACKGROUND_COLOUR.toString(16).padStart(6, \"0\");\n\n  window.onresize = function (event: Event) {\n    doResize();\n    clearTimeout(timeout);\n    timeout = setTimeout(doResize, 500);\n  };\n\n  window.onkeydown = function (event: KeyboardEvent) {", "    if (\n      [\"Space\", \"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"].indexOf(\n        event.code\n      ) > -1\n    ) {\n      event.preventDefault();\n    }\n    game.keydown(event.code);\n  };\n}\n", "if (window.hasOwnProperty(\"cordova\")) {\n  document.addEventListener(\"deviceready\", onLoad, false);\n} else {\n  window.onload = onLoad;\n}\n"]}
{"filename": "src/Game.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport { Sound, sound } from \"@pixi/sound\";\nimport { Actions } from \"pixi-actions\";\n\nimport { Screen, GameScreen, MenuScreen } from \"screens\";\nimport { Font } from \"utils\";\nimport Save from \"./save/Save\";\n\nimport * as _ from \"underscore\";\n\nexport default class Game {\n  // Display options\n  static TARGET_WIDTH = 225;\n  static TARGET_HEIGHT = 345;\n  static INTEGER_SCALING = false;\n  static MAINTAIN_RATIO = false;\n  static BACKGROUND_COLOUR = 0x333333;\n\n  // Mouse\n  static HOLD_INITIAL_TIME_MS = 500;\n  static HOLD_REPEAT_TIME_MS = 400;\n  static SWIPE_TRIGGER_THRESHOLD = 10;\n  static SWIPE_MAX_TIME_MS = 500;\n\n  // Game options\n  static EXIT_TYPE: \"stairs\" | \"door\" = \"door\";\n  static DIMENSION = 5;\n\n  // Debug stuff\n  static DEBUG_SHOW_FRAMERATE = true;\n\n  // Helpers\n  static instance: Game;\n\n  resources: any;\n  spritesheet: PIXI.Spritesheet;\n  app: PIXI.Application;\n  stage: PIXI.Container;\n  fpsLabel: PIXI.BitmapText;\n  backgroundSprite: PIXI.Sprite;\n  innerBackgroundSprite: PIXI.Sprite;\n\n  // Full size of app\n  width: number = window.innerWidth;\n  height: number = window.innerHeight;\n  // Size of stage (on mobile, may include inset areas)\n  stageWidth: number = window.innerWidth;\n  stageHeight: number = window.innerHeight;\n  scale: number = 1;\n\n  currentScreen: Screen;\n\n  startTouch: { x: number; y: number };\n  startTouchTime: number;\n  touchPosition: { x: number; y: number } = {x: 0, y: 0};\n  previousHoldPosition: { x: number; y: number } = {x: 0, y: 0};\n  isHoldRepeating: boolean = false;\n\n  playerHash: string;\n  playerName: string;\n\n  muted: boolean;\n  stretchDisplay: boolean;\n\n  fpsAverageShort: number[] = [];\n  fpsAverageLong: number[] = [];\n\n  constructor(app: PIXI.Application) {\n    this.app = app;\n\n    this.muted = false;\n    this.stretchDisplay = !Game.INTEGER_SCALING;\n\n    this.stage = new PIXI.Container();\n    this.app.stage.addChild(this.stage);\n\n    Save.initialise();\n\n    this.resize();\n\n    this.init();\n  }\n\n  setStretchDisplay(s: boolean) {\n    this.stretchDisplay = s;\n    this.resize();\n  }\n\n  static tex(name: string): PIXI.Texture {\n    return Game.instance.spritesheet.textures[name];\n  }\n\n  init() {\n    sound.init();\n    Game.instance = this;\n    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;\n    PIXI.settings.ROUND_PIXELS = false;\n\n    PIXI.Loader.shared\n      .add(\"spritesheet\", \"packed.json\")\n      .add(\"Kaph\", \"font/kaph.fnt\")\n      .add(\"sound-attack\", \"sound/attack.wav\")\n      .add(\"sound-bump\", \"sound/bump.wav\")\n      .add(\"sound-step1\", \"sound/step1.wav\")\n      .add(\"sound-step2\", \"sound/step2.wav\")\n      .add(\"sound-step3\", \"sound/step3.wav\")\n      .add(\"sound-step4\", \"sound/step4.wav\")\n      .use((resource, next) => {\n        // Load sounds into sound system", "import * as _ from \"underscore\";\n\nexport default class Game {\n  // Display options\n  static TARGET_WIDTH = 225;\n  static TARGET_HEIGHT = 345;\n  static INTEGER_SCALING = false;\n  static MAINTAIN_RATIO = false;\n  static BACKGROUND_COLOUR = 0x333333;\n\n  // Mouse\n  static HOLD_INITIAL_TIME_MS = 500;\n  static HOLD_REPEAT_TIME_MS = 400;\n  static SWIPE_TRIGGER_THRESHOLD = 10;\n  static SWIPE_MAX_TIME_MS = 500;\n\n  // Game options\n  static EXIT_TYPE: \"stairs\" | \"door\" = \"door\";\n  static DIMENSION = 5;\n\n  // Debug stuff\n  static DEBUG_SHOW_FRAMERATE = true;\n\n  // Helpers\n  static instance: Game;\n\n  resources: any;\n  spritesheet: PIXI.Spritesheet;\n  app: PIXI.Application;\n  stage: PIXI.Container;\n  fpsLabel: PIXI.BitmapText;\n  backgroundSprite: PIXI.Sprite;\n  innerBackgroundSprite: PIXI.Sprite;\n\n  // Full size of app\n  width: number = window.innerWidth;\n  height: number = window.innerHeight;\n  // Size of stage (on mobile, may include inset areas)\n  stageWidth: number = window.innerWidth;\n  stageHeight: number = window.innerHeight;\n  scale: number = 1;\n\n  currentScreen: Screen;\n\n  startTouch: { x: number; y: number };\n  startTouchTime: number;\n  touchPosition: { x: number; y: number } = {x: 0, y: 0};\n  previousHoldPosition: { x: number; y: number } = {x: 0, y: 0};\n  isHoldRepeating: boolean = false;\n\n  playerHash: string;\n  playerName: string;\n\n  muted: boolean;\n  stretchDisplay: boolean;\n\n  fpsAverageShort: number[] = [];\n  fpsAverageLong: number[] = [];\n\n  constructor(app: PIXI.Application) {\n    this.app = app;\n\n    this.muted = false;\n    this.stretchDisplay = !Game.INTEGER_SCALING;\n\n    this.stage = new PIXI.Container();\n    this.app.stage.addChild(this.stage);\n\n    Save.initialise();\n\n    this.resize();\n\n    this.init();\n  }\n\n  setStretchDisplay(s: boolean) {\n    this.stretchDisplay = s;\n    this.resize();\n  }\n\n  static tex(name: string): PIXI.Texture {\n    return Game.instance.spritesheet.textures[name];\n  }\n\n  init() {\n    sound.init();\n    Game.instance = this;\n    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;\n    PIXI.settings.ROUND_PIXELS = false;\n\n    PIXI.Loader.shared\n      .add(\"spritesheet\", \"packed.json\")\n      .add(\"Kaph\", \"font/kaph.fnt\")\n      .add(\"sound-attack\", \"sound/attack.wav\")\n      .add(\"sound-bump\", \"sound/bump.wav\")\n      .add(\"sound-step1\", \"sound/step1.wav\")\n      .add(\"sound-step2\", \"sound/step2.wav\")\n      .add(\"sound-step3\", \"sound/step3.wav\")\n      .add(\"sound-step4\", \"sound/step4.wav\")\n      .use((resource, next) => {\n        // Load sounds into sound system", "        if (resource) {\n          if ([\"wav\", \"ogg\", \"mp3\", \"mpeg\"].includes(resource.extension)) {\n            sound.add(resource.name, Sound.from(resource.data));\n          }\n        }\n        next();\n      })\n      .load((_, resources) => {\n        this.resources = resources;\n        this.spritesheet = this.resources[\"spritesheet\"].spritesheet;\n        this.postInit();\n      });\n  }\n\n  gotoGameScreen() {\n    const gameScreen = new GameScreen();", "    if (!Save.loadGameState(gameScreen)) {\n      gameScreen.nextLevel();\n    }\n    this.setScreen(gameScreen);\n  }\n\n  gotoMenuScreen() {\n    this.setScreen(new MenuScreen());\n  }\n\n  setScreen(screen: Screen) {", "    if (this.currentScreen != null) {\n      // Remove it!\n      Actions.fadeOutAndRemove(this.currentScreen, 0.2).play();\n    }\n    // Add new one\n    screen.alpha = 0;\n    Actions.fadeIn(screen, 0.2).play();\n    this.currentScreen = screen;\n    this.stage.addChild(screen);\n    this.notifyScreensOfSize();\n  }\n\n  postInit() {\n    // FPS label\n    this.fpsLabel = new PIXI.BitmapText(\n      \"0\",\n      Font.makeFontOptions(\"medium\", \"left\")\n    );\n    this.fpsLabel.anchor.set(0);\n    this.fpsLabel.position.set(10, 10);\n    this.fpsLabel.tint = 0xffffff;", "    if (Game.DEBUG_SHOW_FRAMERATE) {\n      this.app.stage.addChild(this.fpsLabel);\n    }\n\n    // Add background\n    this.backgroundSprite = PIXI.Sprite.from(PIXI.Texture.WHITE);\n    this.backgroundSprite.tint = 0xffffff;\n    this.backgroundSprite.width = this.width;\n    this.backgroundSprite.height = this.height;\n    this.app.stage.addChildAt(this.backgroundSprite, 0);\n\n    // Inner background\n    this.innerBackgroundSprite = PIXI.Sprite.from(PIXI.Texture.WHITE);\n    this.innerBackgroundSprite.tint = Game.BACKGROUND_COLOUR;\n    this.innerBackgroundSprite.width = Game.TARGET_WIDTH;\n    this.innerBackgroundSprite.height = Game.TARGET_HEIGHT;\n    this.stage.addChild(this.innerBackgroundSprite);\n", "    if (Save.hasGameState()) {\n      this.gotoGameScreen();\n    } else {\n      this.gotoMenuScreen();\n    }\n\n    this.resize();\n    this.notifyScreensOfSize();\n\n    // Register swipe listeners\n    // EventEmitter types issue - see https://github.com/pixijs/pixijs/issues/7429\n    const stage = this.backgroundSprite as any;\n    stage.interactive = true;\n    stage.on(\"pointerdown\", (e: any) => {\n      this.isHoldRepeating = false;\n      this.startTouch = { x: e.data.global.x, y: e.data.global.y };\n      this.startTouchTime = Date.now();\n    });\n    stage.on(\"pointermove\", (e: any) => {", "      if (!this.startTouch) return;\n      this.touchPosition.x = e.data.global.x;\n      this.touchPosition.y = e.data.global.y;\n    });\n    stage.on(\"pointerup\", (e: any) => {\n      if (!this.startTouch) return;\n      if (this.isHoldRepeating) {\n        this.startTouch = null;\n        return;\n      }\n      const deltaTime = Date.now() - this.startTouchTime;", "      if (deltaTime > Game.SWIPE_MAX_TIME_MS) return;\n      const deltaX = e.data.global.x - this.startTouch.x;\n      const deltaY = e.data.global.y - this.startTouch.y;\n      this.performSwipe(deltaX, deltaY);\n      this.startTouch = null;\n    });\n\n    this.app.ticker.add((delta: number) => this.tick(delta));\n  }\n\n  playSound(name: string | string[]) {", "    if (this.muted) return;\n    const theName = Array.isArray(name) ? _.sample(name) : name;\n    const resource = this.resources[\"sound-\" + theName];\n    if (resource?.sound) {\n      resource.sound.play();\n    }\n  }\n  \n  performSwipe(deltaX: number, deltaY: number) {\n    const absDeltaX = Math.abs(deltaX);\n    const absDeltaY = Math.abs(deltaY);\n    const absMin = Math.min(absDeltaX, absDeltaY);\n    const absMax = Math.max(absDeltaX, absDeltaY);\n    // The other axis must be smaller than this to avoid a diagonal swipe\n    const confusionThreshold = absMax / 2;", "    if (absMin < confusionThreshold) {\n      if (absMax > Game.SWIPE_TRIGGER_THRESHOLD) {\n        if (absMax == absDeltaX) {\n          // Right or left\n          this.keydown(deltaX > 0 ? \"KeyD\" : \"KeyA\");\n        } else {\n          // Up or down\n          this.keydown(deltaY > 0 ? \"KeyS\" : \"KeyW\");\n        }\n      }\n    }\n  }\n\n  tick(delta: number) {\n    // delta is in frames\n    let elapsedSeconds = delta / 60;\n\n    Actions.tick(elapsedSeconds);\n    \n    // If pointer is held down, trigger movements.", "    if (this.startTouch) {\n      const elapsed = Date.now() - this.startTouchTime;\n      if (this.isHoldRepeating) {\n        if (elapsed > Game.HOLD_REPEAT_TIME_MS) {\n          const deltaX = this.touchPosition.x - this.startTouch.x;\n          const deltaY = this.touchPosition.y - this.startTouch.y;\n          this.performSwipe(deltaX, deltaY);\n          this.startTouchTime = Date.now();\n        }\n      } else if (elapsed > Game.HOLD_INITIAL_TIME_MS) {\n        // Held down for some time Trigger a swipe!\n        const deltaX = this.touchPosition.x - this.startTouch.x;\n        const deltaY = this.touchPosition.y - this.startTouch.y;\n        this.performSwipe(deltaX, deltaY);\n        // From now on, when we pass HOLD_REPEAT_TIME_MS, we perform another swipe\n        this.isHoldRepeating = true;\n        this.startTouchTime = Date.now();\n      }\n    }\n\n    this.fpsAverageShort.push(this.app.ticker.FPS);\n    this.fpsAverageLong.push(this.app.ticker.FPS);\n\n    // Keep most recent only", "      } else if (elapsed > Game.HOLD_INITIAL_TIME_MS) {\n        // Held down for some time Trigger a swipe!\n        const deltaX = this.touchPosition.x - this.startTouch.x;\n        const deltaY = this.touchPosition.y - this.startTouch.y;\n        this.performSwipe(deltaX, deltaY);\n        // From now on, when we pass HOLD_REPEAT_TIME_MS, we perform another swipe\n        this.isHoldRepeating = true;\n        this.startTouchTime = Date.now();\n      }\n    }\n\n    this.fpsAverageShort.push(this.app.ticker.FPS);\n    this.fpsAverageLong.push(this.app.ticker.FPS);\n\n    // Keep most recent only", "    if (this.fpsAverageShort.length > 100) {\n      this.fpsAverageShort.shift();\n    }\n    if (this.fpsAverageLong.length > 1000) {\n      this.fpsAverageLong.shift();\n    }\n\n    const avgShort =\n      _.reduce(this.fpsAverageShort, (a, b) => a + b, 0) /\n      (this.fpsAverageShort.length === 0 ? 1 : this.fpsAverageShort.length);\n    const avgLong =\n      _.reduce(this.fpsAverageLong, (a, b) => a + b, 0) /\n      (this.fpsAverageLong.length === 0 ? 1 : this.fpsAverageLong.length);\n    this.fpsLabel.text =\n      \"\" +\n      Math.round(this.app.ticker.FPS) +\n      \"\\n\" +\n      Math.round(avgShort) +\n      \"\\n\" +\n      Math.round(avgLong) +\n      \"\\n\";\n  }\n\n  notifyScreensOfSize() {\n    // Let screens now", "    for (const s of this.stage.children) {\n      if (s instanceof Screen) {\n        if (Game.MAINTAIN_RATIO) {\n          s.resize(Game.TARGET_WIDTH, Game.TARGET_HEIGHT);\n        } else {\n          s.resize(this.width / this.scale, this.height / this.scale);\n        }\n      }\n    }\n  }\n\n  resize() {\n    const rootStyle = getComputedStyle(document.documentElement);\n    const resizeInfo = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      safeInsets: {\n        left: parseInt(rootStyle.getPropertyValue('--safe-area-left')) || 0,\n        right: parseInt(rootStyle.getPropertyValue('--safe-area-right')) || 0,\n        top: parseInt(rootStyle.getPropertyValue('--safe-area-top')) || 0,\n        bottom: parseInt(rootStyle.getPropertyValue('--safe-area-bottom')) || 0\n      }\n    };\n\n    //this part resizes the canvas but keeps ratio the same\n    this.app.renderer.view.style.width = resizeInfo.width + \"px\";\n    this.app.renderer.view.style.height = resizeInfo.height + \"px\";\n\n    this.width = resizeInfo.width;\n    this.height = resizeInfo.height;\n", "    if (this.backgroundSprite) {\n      this.backgroundSprite.width = resizeInfo.width;\n      this.backgroundSprite.height = resizeInfo.height;\n      this.backgroundSprite.alpha = Game.MAINTAIN_RATIO ? 1 : 0;\n    }\n\n    this.app.renderer.resize(resizeInfo.width, resizeInfo.height);\n\n    // Ensure stage can fit inside the view!\n    // Scale it if it's not snug\n    // Stage side sits inside the safe insets\n    this.stageWidth = resizeInfo.width - resizeInfo.safeInsets.left - resizeInfo.safeInsets.right;\n    this.stageHeight = resizeInfo.height - resizeInfo.safeInsets.top - resizeInfo.safeInsets.bottom;\n    const targetScaleX = resizeInfo.width / Game.TARGET_WIDTH;\n    const targetScaleY = resizeInfo.height / Game.TARGET_HEIGHT;\n    const smoothScaling = Math.min(targetScaleX, targetScaleY);\n    // Pick integer scale which best fits\n    this.scale = !this.stretchDisplay\n      ? Math.max(1, Math.floor(smoothScaling))\n      : smoothScaling;\n    this.stage.scale.set(this.scale, this.scale);\n", "    if (this.innerBackgroundSprite) {\n      if (Game.MAINTAIN_RATIO) {\n        this.innerBackgroundSprite.width = Game.TARGET_WIDTH * this.scale;\n        this.innerBackgroundSprite.height = Game.TARGET_HEIGHT * this.scale;\n      } else {\n        this.innerBackgroundSprite.width = resizeInfo.width;\n        this.innerBackgroundSprite.height = resizeInfo.height;\n      }\n    }\n\n    // Centre stage", "    if (Game.MAINTAIN_RATIO) {\n      this.stage.position.set(\n        resizeInfo.safeInsets.left + (this.stageWidth - Game.TARGET_WIDTH * this.scale) / 2,\n        resizeInfo.safeInsets.top + (this.stageHeight - Game.TARGET_HEIGHT * this.scale) / 2\n      );\n      if (this.innerBackgroundSprite) {\n        this.innerBackgroundSprite.position.set(this.stage.position.x, this.stage.position.y);\n      }\n    } else {\n      this.stage.position.set(resizeInfo.safeInsets.left, resizeInfo.safeInsets.top);\n    }\n\n    this.notifyScreensOfSize();\n  }\n\n  keydown(code: string) {", "    if (this.currentScreen) this.currentScreen.keydown(code);\n  }\n}\n"]}
{"filename": "src/utils/Font.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\ntype FontSize = \"small\" | \"medium\" | \"large\";\n\nexport default class Font {\n  static fonts = {\n    Kaph: {\n      baseSize: 24,\n      license: \"https://opensource.org/licenses/OFL-1.1\",\n    },\n  };\n  static makeFontOptions(\n    size: FontSize,\n    align: PIXI.TextStyleAlign = \"center\",\n    face: \"Kaph\" = \"Kaph\"\n  ) {\n    const font = this.fonts[face];\n    return {\n      fontName: face,\n      fontSize: this.multiplier(size) * font.baseSize,\n      align,\n    };\n  }\n  static multiplier(size: FontSize): number {", "    if (size === \"small\") return 0.5;\n    if (size === \"medium\") return 1;\n    if (size === \"large\") return 1.5;\n    else return 1;\n  }\n}\n"]}
{"filename": "src/utils/Coords.ts", "chunked_list": ["export default class Coords {\n  col: number;\n  row: number;\n  constructor(col: number, row: number) {\n    this.col = col;\n    this.row = row;\n  }\n  add(dx: number, dy: number) {\n    this.col += dx;\n    this.row += dy;\n    return this;\n  }\n  set(col: number | Coords, row: number = null) {", "    if (typeof col == \"number\") {\n      this.col = col;\n      this.row = row;\n    } else {\n      this.col = col.col;\n      this.row = col.row;\n    }\n    return this;\n  }\n  clone(): Coords {\n    return new Coords(this.col, this.row);\n  }\n  equals(col: number | Coords, row: number = null) {\n    let c = 0;\n    let r = 0;", "    if (typeof col == \"number\") {\n      c = col;\n      r = row;\n    } else {\n      c = col.col;\n      r = col.row;\n    }\n    return this.col == c && this.row == r;\n  }\n}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["import Coords from \"./Coords\";\nimport Font from \"./Font\";\n\nexport { Coords, Font };\n"]}
{"filename": "src/save/Save.ts", "chunked_list": ["import Engine from \"./engine/Engine\";\nimport LocalStorageEngine from \"./engine/LocalStorageEngine\";\nimport MemoryEngine from \"./engine/MemoryEngine\";\n\nimport GameScreen from \"../screens/game/GameScreen\";\nimport DungeonGrid from \"../screens/game/grid/DungeonGrid\";\nimport Wall from \"../screens/game/grid/Wall\";\nimport { PlayerCharacter, EnemyCharacter, Character } from \"../screens/game/character\";\nimport type { CharacterType } from \"../screens/game/character/Character\";\nimport { Coords } from \"utils\";", "import type { CharacterType } from \"../screens/game/character/Character\";\nimport { Coords } from \"utils\";\n\nexport default class Save {\n  static engine: Engine;\n  static initialise() {\n    if (LocalStorageEngine.isSupported()) {\n      this.engine = new LocalStorageEngine();\n    } else {\n      this.engine = new MemoryEngine();\n    }\n  }\n\n  // Coords\n  private static serialiseCoords(coords: Coords) {", "    if (!coords) return null;\n    return [coords.col, coords.row];\n  }\n  private static deserialiseCoords(coords: any): Coords {\n    if (!coords) return null;\n    return new Coords(coords[0], coords[1]);\n  }\n\n  // Walls\n  private static serialiseWalls(walls: Wall[]) {\n    return walls.map((w) => {\n      return {\n        from: this.serialiseCoords(w.from),\n        to: this.serialiseCoords(w.to),\n      };\n    });\n  }\n  private static deserialiseWalls(walls: any): Wall[] {\n    return walls.map(\n      (w: any) =>\n        new Wall(this.deserialiseCoords(w.from), this.deserialiseCoords(w.to))\n    );\n  }\n\n  // Characters\n  private static serialiseCharacters(characters: Character[]) {\n    return characters.map((c) => {\n      return {\n        type: c.type,\n        coords: this.serialiseCoords(c.coords),\n        hp: c.hp,\n      };\n    });\n  }\n  private static deserialiseCharacters(characters: any): Character[] {\n    return characters.map(\n      (c: any) => this.createCharacter(c.type, c.hp, this.deserialiseCoords(c.coords))\n    );\n  }\n  private static createCharacter(type: CharacterType, hp: number, coords: Coords) {\n    let c;", "    if (type === \"player\") {\n      c = new PlayerCharacter();\n    } else {\n      c = new EnemyCharacter(type);\n    }\n    c.coords = coords;\n    c.hp = hp;\n    return c;\n  }\n\n  // Dungeon grid\n  private static serialiseDungeonGrid(dungeonGrid: DungeonGrid) {\n    return {\n      characters: this.serialiseCharacters(dungeonGrid.characters),\n      walls: this.serialiseWalls(dungeonGrid.walls),\n      edgeWalls: this.serialiseWalls(dungeonGrid.edgeWalls),\n      dimension: dungeonGrid.dimension,\n      exitCoords: this.serialiseCoords(dungeonGrid.exitCoords),\n      exitDir: this.serialiseCoords(dungeonGrid.exitDir),\n    };\n  }\n  private static deserialiseDungeonGrid(gameScreen: GameScreen, data: any) {\n    const dungeonGrid = new DungeonGrid(gameScreen, data.dimension);\n    const chars = this.deserialiseCharacters(data.characters);", "    for (const c of chars) {\n        dungeonGrid.addCharacter(c);\n    }\n    dungeonGrid.walls = this.deserialiseWalls(data.walls);\n    dungeonGrid.edgeWalls = this.deserialiseWalls(data.edgeWalls);\n    dungeonGrid.exitCoords = this.deserialiseCoords(data.exitCoords);\n    dungeonGrid.exitDir = this.deserialiseCoords(data.exitDir);\n    dungeonGrid.drawWalls(dungeonGrid.walls);\n    dungeonGrid.updateExitCoords();\n    return dungeonGrid;\n  }\n\n  // Game state\n  private static serialiseGameState(gameScreen: GameScreen) {\n    return {\n      level: gameScreen.level,\n      state: gameScreen.state,\n      score: gameScreen.score,\n      dungeonGrid: this.serialiseDungeonGrid(gameScreen.dungeonGrid),\n    };\n  }\n  private static deserialiseGameState(gameScreen: GameScreen, data: any) {\n    gameScreen.level = data.level;\n    gameScreen.state = data.state;\n    gameScreen.score = data.score;\n\n    // Remove the old dungeon grid:", "    if (gameScreen.dungeonGrid) {\n        gameScreen.gameContainer.removeChild(gameScreen.dungeonGrid);\n    }\n    gameScreen.dungeonGrid = this.deserialiseDungeonGrid(gameScreen, data.dungeonGrid);\n    gameScreen.gameContainer.addChild(gameScreen.dungeonGrid);\n\n    const pc = gameScreen.dungeonGrid.characters.find(c => c.isPlayer);\n    gameScreen.playerCharacter = pc;\n    gameScreen.incScore(0);\n  }\n\n  static hasGameState() {\n    return !!this.engine.load(\"currentGameState\");\n  }\n\n  static saveGameState(gameScreen: GameScreen) {\n    // Save game state...\n    const data = this.serialiseGameState(gameScreen);\n    this.engine.save(\"currentGameState\", data);\n  }\n\n  static loadGameState(gameScreen: GameScreen) {\n    // Save game state...\n    const data = this.engine.load(\"currentGameState\");", "    if (data) {\n        // Load data into gameScreen...\n        this.deserialiseGameState(gameScreen, data);\n        return true;\n    }\n    return false;\n  }\n\n  static clearGameState() {\n    this.engine.remove(\"currentGameState\");\n  }\n}\n"]}
{"filename": "src/save/engine/LocalStorageEngine.ts", "chunked_list": ["import Engine from \"./Engine\";\n\nexport default class LocalStorageEngine implements Engine {\n  storage: Storage = null;\n  constructor() {\n    if (LocalStorageEngine.isSupported()) {\n      this.storage = localStorage;\n    } else {\n      this.storage = null;\n    }\n  }\n  static isSupported() {", "    try {\n      localStorage.setItem(\"__test\", \"1\");\n      localStorage.removeItem(\"__test\");\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  save(key: string, value: any): void {\n    if (!this.storage) return;\n    this.storage.setItem(key, JSON.stringify(value));\n  }\n  load(key: string): any {", "    if (!this.storage) return;\n    this.storage.setItem(key, JSON.stringify(value));\n  }\n  load(key: string): any {\n    if (!this.storage) null;\n    const value = this.storage.getItem(key);\n    if (!value) return null;\n    try {\n      return JSON.parse(value);\n    } catch (e) {\n      // Invalid JSON...\n      this.storage.removeItem(key);\n      return null;\n    }\n  }\n  remove(key: string): void {", "    } catch (e) {\n      // Invalid JSON...\n      this.storage.removeItem(key);\n      return null;\n    }\n  }\n  remove(key: string): void {\n    if (!this.storage) return;\n    this.storage.removeItem(key);\n  }\n}\n"]}
{"filename": "src/save/engine/MemoryEngine.ts", "chunked_list": ["import Engine from \"./Engine\";\n\nexport default class MemoryEngine implements Engine {\n  storage = new Map();\n  save(key: string, value: any): void {\n    this.storage.set(key, value);\n  }\n  load(key: string): any {\n    if (!this.storage.has(key)) return null;\n    return this.storage.get(key);\n  }\n  remove(key: string): void {", "    if (!this.storage.has(key)) return null;\n    return this.storage.get(key);\n  }\n  remove(key: string): void {\n    if (!this.storage) return;\n    this.storage.delete(key);\n  }\n}\n"]}
{"filename": "src/save/engine/Engine.ts", "chunked_list": ["export default interface Engine {\n  save(key: string, value: any): void;\n  load(key: string): any;\n  remove(key: string): void;\n}\n"]}
{"filename": "src/ui/Button.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport { Font } from \"utils\";\n\nexport default class Button extends PIXI.Container {\n  label: PIXI.BitmapText;\n  onclick: () => void;\n  constructor(text: string, onclick: () => void) {\n    super();\n\n    this.onclick = onclick;\n\n    // Make a label!\n    const theLabel = new PIXI.BitmapText(text, Font.makeFontOptions(\"small\"));\n    theLabel.tint = 0;\n    theLabel.anchor.set(0.5);\n    theLabel.position.x = 0;\n    theLabel.position.y = 0;\n    this.label = theLabel;\n\n    // Background\n    const holderBackground = PIXI.Sprite.from(PIXI.Texture.WHITE);\n    holderBackground.width = 200;\n    holderBackground.height = 25;\n    holderBackground.position.set(\n      -holderBackground.width / 2,\n      -holderBackground.height / 2\n    );\n\n    this.addChild(holderBackground);\n    this.addChild(theLabel);\n\n    const ee = this as any;\n    ee.interactive = true;\n    ee.on(\"pointertap\", () => {\n      this.onclick();\n    });\n  }\n}\n"]}
{"filename": "src/ui/index.ts", "chunked_list": ["import Button from \"./Button\";\n\nexport { Button };\n"]}
{"filename": "src/screens/index.ts", "chunked_list": ["import Screen from \"./Screen\";\nimport MenuScreen from \"./menu/MenuScreen\";\nimport GameScreen from \"./game/GameScreen\";\n\nexport { Screen, GameScreen, MenuScreen };\n"]}
{"filename": "src/screens/Screen.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\nexport default class Screen extends PIXI.Container {\n  keydown(code: string) {}\n  resize(width: number, height: number) {}\n}\n"]}
{"filename": "src/screens/menu/MenuScreen.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport Game from \"Game\";\nimport { Button } from \"ui\";\nimport { Font } from \"utils\";\nimport Screen from \"../Screen\";\n\nexport default class MenuScreen extends Screen {\n  static PADDING = 20;\n  startButton: Button;\n  logo: PIXI.BitmapText;\n  w: number;\n  h: number;\n  constructor() {\n    super();\n\n    // Logo at top\n    this.logo = new PIXI.BitmapText(\"TEMPLATE\", Font.makeFontOptions(\"large\"));\n    this.logo.anchor.set(0.5, 0);\n    this.logo.tint = 0xffffff;\n    this.addChild(this.logo);\n\n    // Button to continue or start\n    this.startButton = new Button(\"Start\", () => {\n      // Start new game!\n      Game.instance.gotoGameScreen();\n    });\n    this.addChild(this.startButton);\n  }\n\n  resize(width: number, height: number) {\n    this.w = width;\n    this.h = height;\n\n    this.logo.position.set(width / 2, MenuScreen.PADDING);\n\n    this.startButton.position.set(\n      width / 2,\n      height - this.startButton.height / 2 - MenuScreen.PADDING\n    );\n  }\n\n  keydown(code: string) {", "    if (code == \"Enter\") {\n      this.startButton.onclick();\n      return;\n    }\n  }\n}\n"]}
{"filename": "src/screens/game/GameOverModal.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport Game from \"Game\";\nimport { Font } from \"utils\";\n\nimport * as _ from \"underscore\";\n\nimport GameScreen from \"./GameScreen\";\n\nexport default class GameOverModal extends PIXI.Container {\n  game: GameScreen;\n  scoresTable: PIXI.Container;\n\n  constructor(game: GameScreen) {\n    super();\n\n    this.game = game;\n\n    // Leaderboard\n    const titleLabel = new PIXI.BitmapText(\n      \"Game Over\",\n      Font.makeFontOptions(\"small\")\n    );\n    titleLabel.anchor.set(0.5, 0.5);\n    titleLabel.position.x = Game.TARGET_WIDTH / 2;\n    titleLabel.position.y = 20;\n    this.addChild(titleLabel);\n\n    {\n      // Your score\n      const lbl = new PIXI.BitmapText(\n        \"Your score - \" + game.score,\n        Font.makeFontOptions(\"small\")\n      );\n      lbl.anchor.set(0.5, 0.5);\n      lbl.position.x = Game.TARGET_WIDTH / 2;\n      lbl.position.y = 55;\n      this.addChild(lbl);\n    }\n\n    // Play Again buttons\n    {\n      const button = new PIXI.BitmapText(\n        \"[ Return to Menu ]\",\n        Font.makeFontOptions(\"small\")\n      );\n      button.anchor.set(0.5, 0.5);\n      button.position.x = Game.TARGET_WIDTH / 2;\n      button.position.y = 115;\n      this.addChild(button);\n\n      // Clicker\n      const clicker = PIXI.Sprite.from(PIXI.Texture.WHITE);\n      clicker.tint = 0xff0000;\n      clicker.alpha = 0;\n      clicker.anchor.set(0.5, 0.5);\n      clicker.width = button.width * 1.5;\n      clicker.height = button.height * 2;\n      clicker.position.set(button.position.x, button.position.y);\n      this.addChild(clicker);\n      const ee = clicker as any;\n      ee.interactive = true;\n      ee.on(\"pointertap\", () => {\n        Game.instance.gotoMenuScreen();\n      });\n    }\n  }\n}\n", "export default class GameOverModal extends PIXI.Container {\n  game: GameScreen;\n  scoresTable: PIXI.Container;\n\n  constructor(game: GameScreen) {\n    super();\n\n    this.game = game;\n\n    // Leaderboard\n    const titleLabel = new PIXI.BitmapText(\n      \"Game Over\",\n      Font.makeFontOptions(\"small\")\n    );\n    titleLabel.anchor.set(0.5, 0.5);\n    titleLabel.position.x = Game.TARGET_WIDTH / 2;\n    titleLabel.position.y = 20;\n    this.addChild(titleLabel);\n\n    {\n      // Your score\n      const lbl = new PIXI.BitmapText(\n        \"Your score - \" + game.score,\n        Font.makeFontOptions(\"small\")\n      );\n      lbl.anchor.set(0.5, 0.5);\n      lbl.position.x = Game.TARGET_WIDTH / 2;\n      lbl.position.y = 55;\n      this.addChild(lbl);\n    }\n\n    // Play Again buttons\n    {\n      const button = new PIXI.BitmapText(\n        \"[ Return to Menu ]\",\n        Font.makeFontOptions(\"small\")\n      );\n      button.anchor.set(0.5, 0.5);\n      button.position.x = Game.TARGET_WIDTH / 2;\n      button.position.y = 115;\n      this.addChild(button);\n\n      // Clicker\n      const clicker = PIXI.Sprite.from(PIXI.Texture.WHITE);\n      clicker.tint = 0xff0000;\n      clicker.alpha = 0;\n      clicker.anchor.set(0.5, 0.5);\n      clicker.width = button.width * 1.5;\n      clicker.height = button.height * 2;\n      clicker.position.set(button.position.x, button.position.y);\n      this.addChild(clicker);\n      const ee = clicker as any;\n      ee.interactive = true;\n      ee.on(\"pointertap\", () => {\n        Game.instance.gotoMenuScreen();\n      });\n    }\n  }\n}\n"]}
{"filename": "src/screens/game/GameScreen.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport { Actions } from \"pixi-actions\";\nimport Game from \"Game\";\nimport Screen from \"../Screen\";\nimport { Font } from \"utils\";\nimport Save from \"../../save/Save\";\n\nimport DungeonGrid from \"./grid/DungeonGrid\";\nimport { PlayerCharacter, EnemyCharacter } from \"./character\";\nimport GameOverModal from \"./GameOverModal\";", "import { PlayerCharacter, EnemyCharacter } from \"./character\";\nimport GameOverModal from \"./GameOverModal\";\n\nimport * as _ from \"underscore\";\n\ntype GameState = \"play\" | \"gameover\";\n\nexport default class GameScreen extends Screen {\n  playerCharacter: PlayerCharacter;\n  dungeonGrid: DungeonGrid;\n  darkOverlay: PIXI.Container;\n  gameContainer: PIXI.Container;\n\n  gameOverModal: GameOverModal;\n\n  readyToMove: boolean;\n  queuedMove: { dx: number; dy: number };\n\n  level: number;\n\n  state: GameState = \"play\";\n\n  modals: PIXI.Container[] = [];\n\n  score: number;\n  scoreLabel: PIXI.BitmapText;\n\n  prevWidth: number = 0;\n  prevHeight: number = 0;\n\n  constructor() {\n    super();\n\n    // Setup\n    this.readyToMove = true;\n    this.queuedMove = null;\n    this.level = 0;\n    this.score = 0;\n    this.gameContainer = new PIXI.Container();\n    this.addChild(this.gameContainer);\n\n    // Score\n    this.scoreLabel = new PIXI.BitmapText(\"0\", Font.makeFontOptions(\"small\"));\n    this.scoreLabel.anchor.set(0.5);\n    this.scoreLabel.tint = 0xffffff;\n    this.gameContainer.addChild(this.scoreLabel);\n\n    // Add a character\n    this.playerCharacter = new PlayerCharacter();\n    this.playerCharacter.coords.set(2, 4);\n\n    // Dark overlay\n    this.darkOverlay = new PIXI.Container();\n    this.darkOverlay.visible = false;\n    {\n      const rect = PIXI.Sprite.from(PIXI.Texture.WHITE);\n      rect.tint = 0;\n      rect.alpha = 0.8;\n      this.darkOverlay.addChild(rect);\n    }\n    this.addChild(this.darkOverlay);\n  }\n\n  incScore(amt: number) {\n    this.score += amt;\n    this.scoreLabel.text = \"\" + this.score;\n  }\n\n  showDarkOverlay(delay: number = 0) {\n    this.darkOverlay.visible = true;\n    this.darkOverlay.alpha = 0;\n    Actions.sequence(\n      Actions.delay(delay),\n      Actions.fadeIn(this.darkOverlay, 0.2)\n    ).play();\n  }\n\n  hideDarkOverlay(delay: number = 0) {\n    Actions.sequence(\n      Actions.delay(delay),\n      Actions.runFunc(() => {\n        this.darkOverlay.visible = false;\n        this.darkOverlay.alpha = 0;\n      })\n    ).play();\n  }\n\n  gameOver() {\n    this.state = \"gameover\";\n    Save.clearGameState();\n    this.showDarkOverlay(0.5);\n\n    this.gameOverModal = new GameOverModal(this);\n    this.gameOverModal.alpha = 0;\n    Actions.sequence(\n      Actions.delay(2),\n      Actions.fadeIn(this.gameOverModal, 0.2)\n    ).play();\n    this.addChild(this.gameOverModal);\n    this.resizeAgain();\n  }\n\n  nextLevel() {\n    this.incScore(1);\n\n    this.level++;\n\n    this.readyToMove = true;\n\n    const nextGrid = new DungeonGrid(this, Game.DIMENSION);", "    if (this.dungeonGrid) {\n      // Slide the new one in!\n      if (Game.EXIT_TYPE == \"door\" && this.dungeonGrid.exitDir) {\n        const dx = this.dungeonGrid.exitDir.col * this.dungeonGrid.edgeSize;\n        const dy = this.dungeonGrid.exitDir.row * this.dungeonGrid.edgeSize;\n        nextGrid.position.set(\n          this.dungeonGrid.position.x + dx,\n          this.dungeonGrid.position.y + dy\n        );\n        nextGrid.alpha = 0;\n        Actions.parallel(\n          Actions.fadeIn(nextGrid, 0.2),\n          Actions.moveTo(\n            nextGrid,\n            this.dungeonGrid.position.x,\n            this.dungeonGrid.position.y,\n            0.5\n          )\n        ).play();\n        Actions.sequence(\n          Actions.parallel(\n            Actions.fadeOut(this.dungeonGrid, 0.2),\n            Actions.moveTo(\n              this.dungeonGrid,\n              this.dungeonGrid.position.x - dx,\n              this.dungeonGrid.position.y - dy,\n              0.5\n            )\n          ),\n          Actions.remove(this.dungeonGrid)\n        ).play();\n\n        // Move the player to opposite side of the dungeon", "        if (this.dungeonGrid.exitDir.col != 0) {\n          this.playerCharacter.coords.col = this.dungeonGrid.dimension - this.playerCharacter.coords.col - 1;\n        } else {\n          this.playerCharacter.coords.row = this.dungeonGrid.dimension - this.playerCharacter.coords.row - 1;\n        }\n        // Ensure that any pending animations don't intefere with positioning in next level\n        Actions.clear(this.playerCharacter);\n      } else {\n        nextGrid.position.set(this.dungeonGrid.position.x, this.dungeonGrid.position.y);\n        nextGrid.alpha = 0;\n        Actions.fadeIn(nextGrid, 0.5).play();\n        Actions.fadeOutAndRemove(this.dungeonGrid, 0.5).play();\n      }\n    } else {\n      // If this is the first grid, we need to place it in the correct place\n      this.resizeAgain();\n      nextGrid.alpha = 0;\n      Actions.fadeIn(nextGrid, 0.5).play();\n    }\n\n    this.dungeonGrid = nextGrid;\n    this.dungeonGrid.addCharacter(this.playerCharacter);\n    this.dungeonGrid.clearEnemies();\n    this.dungeonGrid.generateWalls(Math.min(3 + this.level, 8));\n    this.dungeonGrid.setExitCell();\n\n    this.gameContainer.addChild(this.dungeonGrid);\n\n    const monsterLevel = Math.min(this.level, 20);\n    const numEnemies =\n      2 +\n      Math.min(5, Math.floor(monsterLevel / 5)) +\n      Math.min(10, Math.max(0, monsterLevel - 40));\n    this.spawnEnemy(numEnemies);\n\n    Save.saveGameState(this);\n  }\n\n  spawnEnemy(n: number) {", "    for (let i = 0; i < n; i++) {\n      const enemyCharacter = new EnemyCharacter(\"enemy1\");\n      // Random empty cell\n      const coord = this.dungeonGrid.getRandomEmptyCell();\n      if (!coord) return;\n      enemyCharacter.coords.set(coord.col, coord.row);\n      this.dungeonGrid.addCharacter(enemyCharacter);\n    }\n  }\n\n  pumpQueuedMove() {", "    if (this.queuedMove) {\n      this.doMove(this.queuedMove.dx, this.queuedMove.dy);\n      this.queuedMove = null;\n    }\n  }\n\n  doMove(dx: number, dy: number) {\n    if (this.state != \"play\") {\n      // Can't move!\n      return;\n    }\n    // 1. If you aren't yet ready to move, then queue the direction", "    if (this.readyToMove) {\n      // 2. Otherwise, do the move\n      const moveResult = this.dungeonGrid.moveCharacter(\n        this.playerCharacter,\n        dx,\n        dy\n      );\n\n      // 3. If the move was successful, then say we aren't ready to move yet\n      if (moveResult.wentThroughExit) {\n        // Load in new level\n        // Snazzy animation too, if I could handle it!\n        this.nextLevel();", "      if (moveResult.wentThroughExit) {\n        // Load in new level\n        // Snazzy animation too, if I could handle it!\n        this.nextLevel();\n      } else if (moveResult.didMove) {\n        this.postMove(moveResult.delay);\n      } else {\n        this.readyToMove = false;\n\n        // After a delay, let the player move again\n        Actions.sequence(\n          Actions.delay(moveResult.delay),\n          Actions.runFunc(() => {\n            this.readyToMove = true;\n            this.pumpQueuedMove();\n          })\n        ).play();\n      }\n    } else {\n      this.queuedMove = { dx, dy };\n    }\n  }\n\n  postMove(delay: number) {\n    this.readyToMove = false;\n\n    // Any character on exit\n    let onExit = false;", "    if (Game.EXIT_TYPE == \"stairs\" && this.dungeonGrid.exitCoords) {\n      if (this.dungeonGrid.exitCoords.equals(this.playerCharacter.coords)) {\n        onExit = true;\n      }\n    }\n\n    if (onExit) {\n      this.nextLevel();\n    } else {\n      Actions.sequence(\n        Actions.delay(delay),\n        Actions.runFunc(() => {", "          if (this.state != \"gameover\") {\n            this.doEnemyMove();\n          }\n        })\n      ).play();\n    }\n\n    if (this.state == \"play\")\n      Save.saveGameState(this);\n  }\n\n  doEnemyMove() {\n    // Move enemies, after a delay!\n    const enemyMoveResult = this.dungeonGrid.moveEnemies();\n\n    let delay = enemyMoveResult.delay;\n\n    // After a delay, let the player move again\n    // Fudge this value, I like to be able to move really soon\n    Actions.sequence(\n      Actions.delay(delay),\n      Actions.runFunc(() => {\n        this.readyToMove = true;\n        this.pumpQueuedMove();\n      })\n    ).play();\n", "    if (this.state == \"play\")\n      Save.saveGameState(this);\n  }\n\n  resizeAgain() {\n    this.resize(this.prevWidth, this.prevHeight);\n  }\n\n  resize(width: number, height: number) {\n    if (!this.parent) return;\n    this.prevWidth = width;\n    this.prevHeight = height;\n\n    this.darkOverlay.width = Game.instance.width / Game.instance.scale;\n    this.darkOverlay.height = Game.instance.height / Game.instance.scale;\n    this.darkOverlay.position.set(\n      -this.parent.position.x / Game.instance.scale,\n      -this.parent.position.y / Game.instance.scale\n    );\n\n    // Dungeon grid position\n    let dungeonY = (height - this.dungeonGrid.edgeSize) / 2;\n    let dungeonX = (width - this.dungeonGrid.edgeSize) / 2;\n\n    // Grids\n    // Move it\n    this.dungeonGrid.position.set(dungeonX, dungeonY);\n    this.scoreLabel.position.set(dungeonX + this.dungeonGrid.edgeSize / 2, 16);\n\n    // Modals\n    const modals = [this.gameOverModal];", "    if (!this.parent) return;\n    this.prevWidth = width;\n    this.prevHeight = height;\n\n    this.darkOverlay.width = Game.instance.width / Game.instance.scale;\n    this.darkOverlay.height = Game.instance.height / Game.instance.scale;\n    this.darkOverlay.position.set(\n      -this.parent.position.x / Game.instance.scale,\n      -this.parent.position.y / Game.instance.scale\n    );\n\n    // Dungeon grid position\n    let dungeonY = (height - this.dungeonGrid.edgeSize) / 2;\n    let dungeonX = (width - this.dungeonGrid.edgeSize) / 2;\n\n    // Grids\n    // Move it\n    this.dungeonGrid.position.set(dungeonX, dungeonY);\n    this.scoreLabel.position.set(dungeonX + this.dungeonGrid.edgeSize / 2, 16);\n\n    // Modals\n    const modals = [this.gameOverModal];", "    for (const m of modals) {\n      if (m) {\n        // Centre it!\n        const x = (width - Game.TARGET_WIDTH) / 2;\n        const y = (height - Game.TARGET_HEIGHT) / 2;\n        m.position.set(x, y);\n      }\n    }\n  }\n\n  keydown(code: string) {\n    let dx = 0;\n    let dy = 0;", "    if (code == \"ArrowLeft\" || code == \"KeyA\") {\n      dx = -1;\n    } else if (code == \"ArrowRight\" || code == \"KeyD\") {\n      dx = 1;\n    } else if (code == \"ArrowUp\" || code == \"KeyW\") {\n      dy = -1;\n    } else if (code == \"ArrowDown\" || code == \"KeyS\") {\n      dy = 1;\n    }\n    if (dx != 0 || dy != 0) {\n      // Attempted move\n      this.doMove(dx, dy);\n    }\n  }\n}\n", "    if (dx != 0 || dy != 0) {\n      // Attempted move\n      this.doMove(dx, dy);\n    }\n  }\n}\n"]}
{"filename": "src/screens/game/grid/Wall.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport { Coords } from \"utils\";\nimport * as _ from \"underscore\";\n\nexport default class Wall extends PIXI.Container {\n  static CONNECTION_PREFERRED_RATIO = 0.6;\n  static PREDETERMINED_LAYOUTS: any = { shrine: [] };\n  from: Coords;\n  to: Coords;\n  sprite: PIXI.Sprite;\n  constructor(from: Coords, to: Coords) {\n    super();\n\n    this.from = from;\n    this.to = to;\n\n    this.sprite = PIXI.Sprite.from(PIXI.Texture.WHITE);\n    this.sprite.tint = 0x4d3206;\n\n    this.addChild(this.sprite);\n  }\n\n  setCellSize(cellSize: number) {\n    const withSize = cellSize * 1.1;\n    const againstSize = 5;\n    this.sprite.width = this.isHorizontal ? withSize : againstSize;\n    this.sprite.height = this.isHorizontal ? againstSize : withSize;\n  }\n\n  blocks(start: Coords, dx: number, dy: number) {", "    if (this.isHorizontal) {\n      if (dy == 0) return false;\n      if (dy < 0 && this.from.equals(start)) {\n        // Hitting a wall\n        return true;\n      }\n      if (\n        dy > 0 &&\n        this.from.col == start.col &&\n        this.from.row == start.row + 1\n      ) {\n        // Hitting a wall\n        return true;\n      }\n    }", "    if (!this.isHorizontal) {\n      if (dx == 0) return false;\n      if (dx < 0 && this.from.equals(start)) {\n        // Hitting a wall\n        return true;\n      }\n      if (\n        dx > 0 &&\n        this.from.col == start.col + 1 &&\n        this.from.row == start.row\n      ) {\n        // Hitting a wall\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get isHorizontal(): boolean {\n    return this.from.row == this.to.row;\n  }\n\n  static floodFillAddToQueue(\n    Q: number[][],\n    n: number[],\n    dx: number,\n    dy: number,\n    dimension: number,\n    walls: Wall[],\n    prospective: Wall,\n    flood: boolean[][]\n  ) {\n    const col = n[0] + dx;\n    const row = n[1] + dy;\n    const from = new Coords(n[0], n[1]);\n\n    // If not in bounds, don't add to Q", "    if (col < 0 || row < 0) return;\n    if (col >= dimension || row >= dimension) return;\n    // If already flooded, don't add\n    if (flood[col][row]) return;\n    // If a wall blocks, don't add\n    for (const w of walls) {\n      if (w.blocks(from, dx, dy)) return;\n    }\n    // If the prospective blocks, don't add\n    if (prospective.blocks(from, dx, dy)) return;\n    Q.push([col, row]);\n  }\n\n  static floodFill(\n    flood: boolean[][],\n    walls: Wall[],\n    prospective: Wall,\n    dimension: number\n  ): boolean {", "    if (prospective.blocks(from, dx, dy)) return;\n    Q.push([col, row]);\n  }\n\n  static floodFill(\n    flood: boolean[][],\n    walls: Wall[],\n    prospective: Wall,\n    dimension: number\n  ): boolean {\n    for (let i = 0; i < flood.length; i++) {", "    for (let i = 0; i < flood.length; i++) {\n      for (let j = 0; j < flood[i].length; j++) {\n        flood[i][j] = false;\n      }\n    }\n\n    const Q = [];\n    Q.push([0, 0]);\n\n    while (Q.length > 0) {\n      const n = Q.pop();\n      flood[n[0]][n[1]] = true;\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        0,\n        1,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        0,\n        -1,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        1,\n        0,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        -1,\n        0,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n    }\n", "    while (Q.length > 0) {\n      const n = Q.pop();\n      flood[n[0]][n[1]] = true;\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        0,\n        1,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        0,\n        -1,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        1,\n        0,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n      Wall.floodFillAddToQueue(\n        Q,\n        n,\n        -1,\n        0,\n        dimension,\n        walls,\n        prospective,\n        flood\n      );\n    }\n", "    for (let i = 0; i < flood.length; i++) {\n      for (let j = 0; j < flood[i].length; j++) {\n        if (!flood[i][j]) return false;\n      }\n    }\n\n    return true;\n  }\n\n  static edges(dimension: number) {\n    // Generate walls which go all around the edges\n    const walls: Wall[] = [];", "    for (let edge = 0; edge < 4; edge++) {\n      for (let i = 0; i < dimension; i++) {\n        const startCoords = new Coords(0, 0);\n        const endCoords = new Coords(0, 0);\n        if (edge == 0 || edge == 2) {\n          // Top/bottom\n          startCoords.col = i;\n          endCoords.col = i + 1;\n          startCoords.row = edge == 0 ? 0 : dimension;\n          endCoords.row = startCoords.row;\n        } else {\n          // Left/right\n          startCoords.row = i;\n          endCoords.row = i + 1;\n          startCoords.col = edge == 1 ? 0 : dimension;\n          endCoords.col = startCoords.col;\n        }\n        walls.push(new Wall(startCoords, endCoords));\n      }\n    }\n    return walls;\n  }\n\n  static randomLayout(numWalls: number, dimension: number): Wall[] {\n    const walls: Wall[] = [];\n\n    const flood: boolean[][] = [];", "    for (let i = 0; i < dimension; i++) {\n      const col: boolean[] = [];\n      for (let j = 0; j < dimension; j++) {\n        col.push(false);\n      }\n      flood.push(col);\n    }\n\n    // Create N wall segments. If a wall segment would create a blockage, don't add it.\n    let limit = 0;\n    while (walls.length < numWalls) {", "    while (walls.length < numWalls) {\n      if (limit++ > 1000) {\n        break;\n      }\n\n      let prospective: Wall = null;\n      if (walls.length > 0 && Math.random() < Wall.CONNECTION_PREFERRED_RATIO) {\n        // Try to join onto an existing wall\n        const prevWall = _.sample(walls);\n        const connectingWalls = [];\n        if (prevWall.isHorizontal) {\n          connectingWalls.push(\n            // 2 parallel\n            [prevWall.from.clone().add(-1, 0), prevWall.to.clone().add(-1, 0)],\n            [prevWall.from.clone().add(1, 0), prevWall.to.clone().add(1, 0)],\n            // 4 perpendicular\n            [prevWall.from.clone(), prevWall.from.clone().add(0, 1)],\n            [prevWall.from.clone().add(0, -1), prevWall.from.clone()],\n            [prevWall.to.clone(), prevWall.to.clone().add(0, 1)],\n            [prevWall.to.clone().add(0, -1), prevWall.to.clone()]\n          );\n        } else {\n          connectingWalls.push(\n            // 2 parallel\n            [prevWall.from.clone().add(0, -1), prevWall.to.clone().add(0, -1)],\n            [prevWall.from.clone().add(0, 1), prevWall.to.clone().add(0, 1)],\n            // 4 perpendicular\n            [prevWall.from.clone(), prevWall.from.clone().add(1, 0)],\n            [prevWall.from.clone().add(-1, 0), prevWall.from.clone()],\n            [prevWall.to.clone(), prevWall.to.clone().add(1, 0)],\n            [prevWall.to.clone().add(-1, 0), prevWall.to.clone()]\n          );\n        }\n        // Remove any which are duplicated, or out of bounds\n        const viableConnectingWalls: Coords[][] = [];", "        if (prevWall.isHorizontal) {\n          connectingWalls.push(\n            // 2 parallel\n            [prevWall.from.clone().add(-1, 0), prevWall.to.clone().add(-1, 0)],\n            [prevWall.from.clone().add(1, 0), prevWall.to.clone().add(1, 0)],\n            // 4 perpendicular\n            [prevWall.from.clone(), prevWall.from.clone().add(0, 1)],\n            [prevWall.from.clone().add(0, -1), prevWall.from.clone()],\n            [prevWall.to.clone(), prevWall.to.clone().add(0, 1)],\n            [prevWall.to.clone().add(0, -1), prevWall.to.clone()]\n          );\n        } else {\n          connectingWalls.push(\n            // 2 parallel\n            [prevWall.from.clone().add(0, -1), prevWall.to.clone().add(0, -1)],\n            [prevWall.from.clone().add(0, 1), prevWall.to.clone().add(0, 1)],\n            // 4 perpendicular\n            [prevWall.from.clone(), prevWall.from.clone().add(1, 0)],\n            [prevWall.from.clone().add(-1, 0), prevWall.from.clone()],\n            [prevWall.to.clone(), prevWall.to.clone().add(1, 0)],\n            [prevWall.to.clone().add(-1, 0), prevWall.to.clone()]\n          );\n        }\n        // Remove any which are duplicated, or out of bounds\n        const viableConnectingWalls: Coords[][] = [];", "        outer: for (const w of connectingWalls) {\n          // If not in bounds, don't add to Q\n          if (w[0].col < 0 || w[0].row < 0) continue;\n          if (w[0].col >= dimension || w[0].row >= dimension) continue;\n          if (w[1].col < 0 || w[1].row < 0) continue;\n          if (w[1].col >= dimension || w[1].row >= dimension) continue;\n\n          const isHorizontal = w[0].row == w[1].row;\n          if (isHorizontal) {\n            // If it's horizontal, you can't go on top or bottom\n            if (w[0].row == 0 || w[0].row == dimension - 1) continue;\n          } else {\n            // If it's vertical, you can't go on either edge", "          if (isHorizontal) {\n            // If it's horizontal, you can't go on top or bottom\n            if (w[0].row == 0 || w[0].row == dimension - 1) continue;\n          } else {\n            // If it's vertical, you can't go on either edge\n            if (w[0].col == 0 || w[0].col == dimension - 1) continue;\n          }\n          // If another wall here, don't add\n          for (const w2 of walls) {\n            if (w2.from.equals(w[0]) && w2.to.equals(w[1])) {\n              continue outer;\n            }\n          }\n          viableConnectingWalls.push(w);\n        }", "          for (const w2 of walls) {\n            if (w2.from.equals(w[0]) && w2.to.equals(w[1])) {\n              continue outer;\n            }\n          }\n          viableConnectingWalls.push(w);\n        }\n        if (viableConnectingWalls.length > 0) {\n          const coords = _.sample(viableConnectingWalls);\n          prospective = new Wall(coords[0], coords[1]);\n        }\n      }\n", "      if (prospective == null) {\n        // Random wall\n        const horizontal = Math.random() < 0.5;\n        const dx = horizontal ? 1 : 0;\n        const dy = horizontal ? 0 : 1;\n\n        let startX = null,\n          startY = null;\n        startX = _.random(horizontal ? 0 : 1, dimension - 1);\n        startY = _.random(horizontal ? 1 : 0, dimension - 1);\n\n        const from = new Coords(startX, startY);\n        const to = from.clone().add(dx, dy);\n\n        // If there is already a wall here, skip!\n        let alreadyExists = false;", "        for (const w of walls) {\n          if (w.from.equals(from) && w.to.equals(to)) {\n            alreadyExists = true;\n            break;\n          }\n        }\n        if (alreadyExists) continue;\n\n        prospective = new Wall(from, to);\n      }\n\n      // If we can't flood fill, skip!\n      const canFloodFill = Wall.floodFill(flood, walls, prospective, dimension);", "      if (!canFloodFill) continue;\n\n      walls.push(prospective);\n    }\n\n    return walls;\n  }\n}\n"]}
{"filename": "src/screens/game/grid/Grid.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport { Action, Actions } from \"pixi-actions\";\nimport Character from \"../character/Character\";\nimport { Coords } from \"utils\";\nimport Wall from \"./Wall\";\n\nexport default class Grid extends PIXI.Container {\n  dimension: number;\n  edgeSize: number;\n  constructor(dimension: number) {\n    super();\n    this.dimension = dimension;\n    this.edgeSize = 28 * this.dimension;\n  }\n\n  get cellSize(): number {\n    return this.edgeSize / this.dimension;\n  }\n\n  inBounds(col: number | Coords, row: number = null) {\n    let c = 0,\n      r = 0;", "    if (typeof col == \"number\") {\n      c = col;\n      r = row;\n    } else {\n      c = col.col;\n      r = col.row;\n    }\n    return !(c < 0 || c >= this.dimension || r < 0 || r >= this.dimension);\n  }\n\n  makeMoveTo(\n    character: Character,\n    dx: number = 0,\n    dy: number = 0,\n    time: number = 0.1\n  ): Action {\n    return Actions.moveTo(\n      character,\n      this.cellSize * (character.coords.col + dx) + this.cellSize / 2,\n      this.cellSize * (character.coords.row + dy) + this.cellSize - 3,\n      time\n    );\n  }\n\n  setPositionTo(\n    actor: PIXI.Container,\n    coords: Coords,\n    isWall: boolean = false\n  ) {", "    if (isWall) {\n      if ((actor as Wall).isHorizontal) {\n        actor.position.set(\n          this.cellSize * coords.col + (this.cellSize - actor.width) / 2,\n          this.cellSize * coords.row + -actor.height / 2\n        );\n      } else {\n        actor.position.set(\n          this.cellSize * coords.col + -actor.width / 2,\n          this.cellSize * coords.row + (this.cellSize - actor.height) / 2\n        );\n      }\n    } else {\n      actor.position.set(\n        this.cellSize * coords.col + this.cellSize / 2,\n        this.cellSize * coords.row + this.cellSize - 3\n      );\n    }\n  }\n}\n"]}
{"filename": "src/screens/game/grid/DungeonGrid.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport { Actions } from \"pixi-actions\";\nimport { Character, EnemyCharacter, PlayerCharacter } from \"../character\";\nimport GameScreen from \"../GameScreen\";\nimport Grid from \"./Grid\";\nimport Wall from \"./Wall\";\nimport { Coords } from \"utils\";\nimport * as _ from \"underscore\";\nimport Game from \"Game\";\n\nexport default class DungeonGrid extends Grid {\n  characters: Character[] = [];\n  walls: Wall[] = [];\n  edgeWalls: Wall[] = [];\n  wallsHolder: PIXI.Container = new PIXI.Container();\n  charactersHolder: PIXI.Container = new PIXI.Container();\n  gameScreen: GameScreen;\n  coords: Coords[] = [];\n  cellSquares: PIXI.Sprite[][] = [];\n  cellStairs: PIXI.Sprite[][] = [];\n  exitCoords: Coords;\n  exitDir: Coords = null;\n  constructor(gameScreen: GameScreen, dimension: number) {\n    super(dimension);\n\n    this.gameScreen = gameScreen;\n\n    // Add cell backgrounds\n    const background = PIXI.Sprite.from(PIXI.Texture.WHITE);\n    background.tint = 0xd3c8a2;\n    background.width = this.edgeSize;\n    background.height = this.edgeSize;\n    background.alpha = 1;\n    background.anchor.set(0, 0);\n    this.addChild(background);\n", "import Game from \"Game\";\n\nexport default class DungeonGrid extends Grid {\n  characters: Character[] = [];\n  walls: Wall[] = [];\n  edgeWalls: Wall[] = [];\n  wallsHolder: PIXI.Container = new PIXI.Container();\n  charactersHolder: PIXI.Container = new PIXI.Container();\n  gameScreen: GameScreen;\n  coords: Coords[] = [];\n  cellSquares: PIXI.Sprite[][] = [];\n  cellStairs: PIXI.Sprite[][] = [];\n  exitCoords: Coords;\n  exitDir: Coords = null;\n  constructor(gameScreen: GameScreen, dimension: number) {\n    super(dimension);\n\n    this.gameScreen = gameScreen;\n\n    // Add cell backgrounds\n    const background = PIXI.Sprite.from(PIXI.Texture.WHITE);\n    background.tint = 0xd3c8a2;\n    background.width = this.edgeSize;\n    background.height = this.edgeSize;\n    background.alpha = 1;\n    background.anchor.set(0, 0);\n    this.addChild(background);\n", "    for (let i = 0; i < this.dimension; i++) {\n      const col1 = [];\n      const col2 = [];\n      for (let j = 0; j < this.dimension; j++) {\n        const cell = PIXI.Sprite.from(PIXI.Texture.WHITE);\n        cell.tint = 0;\n        cell.alpha = (i + j) % 2 == 0 ? 0 : 0.2;\n        cell.width = this.cellSize;\n        cell.height = this.cellSize;\n        const offset1 = (this.cellSize - cell.width) / 2;\n        cell.position.set(\n          i * this.cellSize + offset1,\n          j * this.cellSize + offset1\n        );\n        col1.push(cell);\n        this.addChild(cell);\n\n        const stair = PIXI.Sprite.from(Game.tex(\"stairs.png\"));\n        stair.width = this.cellSize * 0.8;\n        stair.height = this.cellSize * 0.8;\n        const offset2 = (this.cellSize - stair.width) / 2;\n        stair.position.set(\n          i * this.cellSize + offset2,\n          j * this.cellSize + offset2\n        );\n        stair.visible = false;\n        col2.push(stair);\n        this.addChild(stair);\n      }\n      this.cellSquares.push(col1);\n      this.cellStairs.push(col2);\n    }\n\n    this.addChild(this.wallsHolder);\n    this.addChild(this.charactersHolder);\n", "    for (let i = 0; i < this.dimension; i++) {\n      for (let j = 0; j < this.dimension; j++) {\n        this.coords.push(new Coords(i, j));\n      }\n    }\n  }\n\n  clearEnemies() {\n    for (let i = this.characters.length - 1; i >= 0; i--) {\n      const c = this.characters[i];\n      if (!c.isPlayer) {\n        Actions.fadeOutAndRemove(c, 0.2).play();\n        this.characters.splice(i, 1);\n      }\n    }\n  }\n\n  unsetExitCell() {\n    this.exitCoords = null;\n    this.updateExitCoords();\n  }\n\n  setExitCell(minDistanceFromPlayer: number = 7) {\n    const possibles = [];\n    const backups = [];\n\n    let dijks = null;\n    dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n", "    for (let i = this.characters.length - 1; i >= 0; i--) {\n      const c = this.characters[i];\n      if (!c.isPlayer) {\n        Actions.fadeOutAndRemove(c, 0.2).play();\n        this.characters.splice(i, 1);\n      }\n    }\n  }\n\n  unsetExitCell() {\n    this.exitCoords = null;\n    this.updateExitCoords();\n  }\n\n  setExitCell(minDistanceFromPlayer: number = 7) {\n    const possibles = [];\n    const backups = [];\n\n    let dijks = null;\n    dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n", "    for (let i = 0; i < this.dimension; i++) {\n      for (let j = 0; j < this.dimension; j++) {\n        if (i == 2 && j == 2) continue;\n        if (\n          Game.EXIT_TYPE == \"door\" &&\n          ![0, this.dimension - 1].includes(i) &&\n          ![0, this.dimension - 1].includes(j)\n        )\n          continue;\n        if (dijks.distance[i][j] >= minDistanceFromPlayer) {\n          possibles.push(new Coords(i, j));\n        }", "        if (dijks.distance[i][j] >= minDistanceFromPlayer) {\n          possibles.push(new Coords(i, j));\n        }\n        if (dijks.distance[i][j] >= 3) {\n          backups.push(new Coords(i, j));\n        }\n      }\n    }\n\n    if (possibles.length == 0) {\n      possibles.push(...backups);\n    }\n", "    if (possibles.length == 0) {\n      possibles.push(...backups);\n    }\n\n    if (possibles.length == 0) {\n      for (let i = 0; i < this.dimension; i++) {\n        for (let j = 0; j < this.dimension; j++) {\n          if (i == 2 && j == 2) continue;\n          if (\n            Game.EXIT_TYPE == \"door\" &&\n            ![0, this.dimension - 1].includes(i) &&\n            ![0, this.dimension - 1].includes(j)\n          )\n            continue;\n          const c = new Coords(i, j);\n          let anyCoincidence = false;", "          if (\n            Game.EXIT_TYPE == \"door\" &&\n            ![0, this.dimension - 1].includes(i) &&\n            ![0, this.dimension - 1].includes(j)\n          )\n            continue;\n          const c = new Coords(i, j);\n          let anyCoincidence = false;\n          if (this.gameScreen.playerCharacter.coords.equals(c)) {\n            anyCoincidence = true;\n            break;\n          }", "          if (this.gameScreen.playerCharacter.coords.equals(c)) {\n            anyCoincidence = true;\n            break;\n          }\n          if (!anyCoincidence) {\n            possibles.push(c);\n          }\n        }\n      }\n    }\n\n    const coords = _.sample(possibles);\n    this.exitCoords = coords;", "    if (Game.EXIT_TYPE == \"door\") {\n      const possibleDirs = [];\n      if (coords.row == 0) possibleDirs.push(new Coords(0, -1));\n      if (coords.row == this.dimension - 1) possibleDirs.push(new Coords(0, 1));\n      if (coords.col == 0) possibleDirs.push(new Coords(-1, 0));\n      if (coords.col == this.dimension - 1) possibleDirs.push(new Coords(1, 0));\n      if (possibleDirs.length > 0) this.exitDir = _.sample(possibleDirs);\n    }\n    this.updateExitCoords();\n  }\n\n  updateExitCoords() {", "    if (Game.EXIT_TYPE == \"stairs\") {\n      this.cellStairs.forEach((a, i) =>\n        a.forEach(\n          (stairs, j) =>\n            (stairs.visible =\n              this.exitCoords &&\n              this.exitCoords.col == i &&\n              this.exitCoords.row == j)\n        )\n      );\n    } else {\n      // Remove other edge walls (if there are any)", "      for (const c of this.edgeWalls) {\n        this.wallsHolder.removeChild(c);\n      }\n      this.edgeWalls = [];\n\n      // Add outer wall\n      let walls: Wall[] = Wall.edges(this.dimension);\n\n      // Make hole where exit is\n      if (this.exitCoords && this.exitDir) {\n        walls = walls.filter(\n          (w) => !w.blocks(this.exitCoords, this.exitDir.col, this.exitDir.row)\n        );\n      }\n\n      // Draw walls\n      this.drawWalls(walls);\n      this.walls.push(...walls);\n      this.edgeWalls.push(...walls);\n    }\n  }\n\n  getRandomEmptyCell(): Coords {\n    let dijks = null;\n    dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n    const shuffledCoords = _.shuffle(this.coords);", "      if (this.exitCoords && this.exitDir) {\n        walls = walls.filter(\n          (w) => !w.blocks(this.exitCoords, this.exitDir.col, this.exitDir.row)\n        );\n      }\n\n      // Draw walls\n      this.drawWalls(walls);\n      this.walls.push(...walls);\n      this.edgeWalls.push(...walls);\n    }\n  }\n\n  getRandomEmptyCell(): Coords {\n    let dijks = null;\n    dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n    const shuffledCoords = _.shuffle(this.coords);", "    for (const coord of shuffledCoords) {\n      if (this.exitCoords && this.exitCoords.equals(coord)) continue;\n      if (\n        !this.getCharacterAt(coord) &&\n        (!dijks || dijks.distance[coord.col][coord.row] > 1)\n      ) {\n        return coord;\n      }\n    }\n    return null;\n  }\n\n  generateWalls(numWalls: number) {\n    // Delete all old walls", "    for (const w of this.walls) {\n      Actions.fadeOutAndRemove(w, 0.2).play();\n    }\n    this.walls = Wall.randomLayout(numWalls, this.dimension);\n\n    // Add some new walls... they must generate any closed areas\n    this.drawWalls(this.walls);\n  }\n\n  drawWalls(walls: Wall[]) {\n    for (const w of walls) {\n      w.alpha = 0;\n      Actions.fadeIn(w, 0.2).play();\n      this.wallsHolder.addChild(w);\n      w.setCellSize(this.cellSize);\n\n      // Place in the correct place\n      this.setPositionTo(w, w.from, true);\n    }\n  }\n\n  addCharacter(character: Character) {\n    character.scale.set(0.2);\n    character.alpha = 0;\n    Actions.fadeIn(character, 0.2).play();\n    this.characters.push(character);\n    this.charactersHolder.addChild(character);\n\n    // Place in the correct place!\n    this.setPositionTo(character, character.coords);\n  }\n\n  getCharacterAt(col: number | Coords, row: number = null): Character {\n    let c = 0;\n    let r = 0;", "    for (const w of walls) {\n      w.alpha = 0;\n      Actions.fadeIn(w, 0.2).play();\n      this.wallsHolder.addChild(w);\n      w.setCellSize(this.cellSize);\n\n      // Place in the correct place\n      this.setPositionTo(w, w.from, true);\n    }\n  }\n\n  addCharacter(character: Character) {\n    character.scale.set(0.2);\n    character.alpha = 0;\n    Actions.fadeIn(character, 0.2).play();\n    this.characters.push(character);\n    this.charactersHolder.addChild(character);\n\n    // Place in the correct place!\n    this.setPositionTo(character, character.coords);\n  }\n\n  getCharacterAt(col: number | Coords, row: number = null): Character {\n    let c = 0;\n    let r = 0;", "    if (typeof col == \"number\") {\n      c = col;\n      r = row;\n    } else {\n      c = col.col;\n      r = col.row;\n    }\n    for (const char of this.characters) {\n      if (char.coords.col == c && char.coords.row == r) {\n        return char;\n      }\n    }\n    return null;\n  }\n\n  bumpAnimation(character: Character, dx: number, dy: number) {\n    const time = 0.1;\n    Actions.sequence(\n      this.makeMoveTo(character, dx * 0.1, dy * 0.1, time / 2),\n      this.makeMoveTo(character, 0, 0, time / 2)\n    ).play();\n    return time;\n  }\n\n  damageEnemy(targetCharacter: EnemyCharacter) {\n    let delay = 0;\n    const didDie = targetCharacter.damage(1);", "      if (char.coords.col == c && char.coords.row == r) {\n        return char;\n      }\n    }\n    return null;\n  }\n\n  bumpAnimation(character: Character, dx: number, dy: number) {\n    const time = 0.1;\n    Actions.sequence(\n      this.makeMoveTo(character, dx * 0.1, dy * 0.1, time / 2),\n      this.makeMoveTo(character, 0, 0, time / 2)\n    ).play();\n    return time;\n  }\n\n  damageEnemy(targetCharacter: EnemyCharacter) {\n    let delay = 0;\n    const didDie = targetCharacter.damage(1);", "    if (didDie) {\n      // Remove from characters array\n      const index = this.characters.indexOf(targetCharacter);\n      if (index >= 0) {\n        this.characters.splice(index, 1);\n      }\n      // Remove from charactersHolder\n      targetCharacter.position.x += this.position.x;\n      targetCharacter.position.y += this.position.y;\n      this.charactersHolder.removeChild(targetCharacter);\n      delay = 0;\n    }\n    return delay;\n  }\n\n  moveCharacter(\n    character: Character,\n    dx: number,\n    dy: number\n  ): { didMove: boolean; delay: number; wentThroughExit: boolean } {\n    // Check the target space is available\n    const targetCoord = character.coords.clone().add(dx, dy);\n\n    // Edge of grid!", "    if (!this.inBounds(targetCoord)) {\n      if (\n        this.exitCoords &&\n        character.coords.equals(this.exitCoords) &&\n        Game.EXIT_TYPE == \"door\" &&\n        this.exitDir &&\n        this.exitDir.equals(dx, dy)\n      ) {\n        // We are going through the exit!\n        return { didMove: true, delay: 0, wentThroughExit: true };\n      }\n      // Hitting the edge of the grid\n      Game.instance.playSound(\"bump\");\n      const delay = this.bumpAnimation(character, dx, dy);\n      return { didMove: false, delay, wentThroughExit: false };\n    }\n\n    // Hitting a wall?", "    if (this.doesWallSeparate(character.coords, dx, dy)) {\n      Game.instance.playSound(\"bump\");\n      const delay = this.bumpAnimation(character, dx, dy);\n      return { didMove: false, delay, wentThroughExit: false };\n    }\n\n    // Is there another character here?\n    try {\n      const targetCharacter = this.getCharacterAt(targetCoord);\n      if (targetCharacter) {\n        let delay = this.bumpAnimation(character, dx, dy);", "      if (targetCharacter) {\n        let delay = this.bumpAnimation(character, dx, dy);\n        if (character.isPlayer && targetCharacter.isEnemy) {\n          // Attack the character\n          Game.instance.playSound(\"attack\");\n          delay += this.damageEnemy(targetCharacter as EnemyCharacter);\n          return { didMove: true, delay, wentThroughExit: false };\n        } else if (character.isEnemy && targetCharacter.isPlayer) {\n          const player = targetCharacter as PlayerCharacter;\n          // Take a damage!\n          if (player.damage(1)) {\n            this.gameScreen.gameOver();\n          }\n          return { didMove: true, delay, wentThroughExit: false };\n        } else {\n          return { didMove: false, delay, wentThroughExit: false };\n        }\n      }", "          if (player.damage(1)) {\n            this.gameScreen.gameOver();\n          }\n          return { didMove: true, delay, wentThroughExit: false };\n        } else {\n          return { didMove: false, delay, wentThroughExit: false };\n        }\n      }\n    } catch (e) {\n      // The game is over\n      this.gameScreen.gameOver();\n      return { didMove: true, delay: 0, wentThroughExit: false };\n    }\n\n    // Move the character", "    } catch (e) {\n      // The game is over\n      this.gameScreen.gameOver();\n      return { didMove: true, delay: 0, wentThroughExit: false };\n    }\n\n    // Move the character\n    if (character.isPlayer) {\n      Game.instance.playSound([\"step1\", \"step2\", \"step3\", \"step4\"]);\n    }\n    character.coords.set(targetCoord);\n\n    // Animate to the new position\n    this.makeMoveTo(character).play();\n    return { didMove: true, delay: 0.05, wentThroughExit: false };\n  }\n\n  doesWallSeparate(start: Coords, dx: number, dy: number) {", "    for (const w of this.walls) {\n      if (w.blocks(start, dx, dy)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  moveEnemies() {\n    let delay = 0;\n\n    // 1. Dijkstra the grid, ignoring enemies\n    // Pick the closest character\n    const dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n    const enemiesAndDistances = [];", "    for (const char of this.characters) {\n      if (char.isEnemy) {\n        let distance = dijks.distance[char.coords.col][char.coords.row];\n        enemiesAndDistances.push({\n          distance,\n          char,\n        });\n      }\n    }\n\n    // 2. Sort by closest to furthest\n    let sortedEnemies = _.sortBy(enemiesAndDistances, \"distance\");\n\n    // 3. For each enemy, pathfind (properly) to the player\n    let atLeastOneMove = false;", "    for (let tries = 0; tries < 5; tries++) {\n      const tryAgainLater = [];\n      for (const e of sortedEnemies) {\n        const char = e.char;\n\n        const dijks = this.dijkstra(\n          this.gameScreen.playerCharacter.coords,\n          true,\n          char.coords\n        );\n\n        // Move in the direction which has the lowest distance\n        let targetCol = dijks.col[char.coords.col][char.coords.row];\n        let targetRow = dijks.row[char.coords.col][char.coords.row];\n", "        if (targetCol == null || targetRow == null) {\n          const neighbours: Coords[] = [];\n          this.addPotentialNeighbour(neighbours, char.coords, 1, 0);\n          this.addPotentialNeighbour(neighbours, char.coords, 0, 1);\n          this.addPotentialNeighbour(neighbours, char.coords, -1, 0);\n          this.addPotentialNeighbour(neighbours, char.coords, 0, -1);\n          if (neighbours.length > 0) {\n            // If there is no good route, then random direction\n            const dir = _.sample(neighbours);\n            targetCol = dir.col;\n            targetRow = dir.row;\n          } else {\n            // If there is no route at all, then wait, we'll try again in a bit\n            tryAgainLater.push(e);\n            continue;\n          }\n        }\n\n        const dx = targetCol - char.coords.col;\n        const dy = targetRow - char.coords.row;\n        atLeastOneMove = true;\n        delay = Math.max(this.moveCharacter(char, dx, dy).delay, delay);\n      }\n", "      if (tryAgainLater.length == 0) {\n        break;\n      } else {\n        sortedEnemies = tryAgainLater;\n      }\n    }\n\n    return { didMove: true, delay };\n  }\n\n  addPotentialNeighbour(\n    list: Coords[],\n    coords: Coords,\n    dx: number,\n    dy: number\n  ) {", "    if (!this.inBounds(coords.col + dx, coords.row + dy)) {\n      // Out of bounds, ignore!\n      return;\n    }\n    if (this.doesWallSeparate(coords, dx, dy)) {\n      // There is no path, ignore!\n      return;\n    }\n    const char = this.getCharacterAt(coords.col + dx, coords.row + dy);\n    if (char && char.isEnemy) {\n      // There is a monster on the target square, ignore!\n      return;\n    }\n    list.push(coords.clone().add(dx, dy));\n  }\n\n  updateTentativeDistance(\n    withEnemiesAsObstacles: boolean,\n    tentativeDistance: number[][],\n    tentativeSourceCol: number[][],\n    tentativeSourceRow: number[][],\n    coords: Coords,\n    dx: number,\n    dy: number\n  ) {", "    if (char && char.isEnemy) {\n      // There is a monster on the target square, ignore!\n      return;\n    }\n    list.push(coords.clone().add(dx, dy));\n  }\n\n  updateTentativeDistance(\n    withEnemiesAsObstacles: boolean,\n    tentativeDistance: number[][],\n    tentativeSourceCol: number[][],\n    tentativeSourceRow: number[][],\n    coords: Coords,\n    dx: number,\n    dy: number\n  ) {", "    if (!this.inBounds(coords.col + dx, coords.row + dy)) {\n      // Out of bounds, ignore!\n      return;\n    }\n    if (this.doesWallSeparate(coords, dx, dy)) {\n      // There is no path, ignore!\n      return;\n    }\n    if (withEnemiesAsObstacles) {\n      const char = this.getCharacterAt(coords.col + dx, coords.row + dy);\n      if (char && char.isEnemy) {\n        // There is a monster on the target square, ignore!\n        return;\n      }\n    }\n    const newTentativeDistance = tentativeDistance[coords.col][coords.row] + 1;", "    if (withEnemiesAsObstacles) {\n      const char = this.getCharacterAt(coords.col + dx, coords.row + dy);\n      if (char && char.isEnemy) {\n        // There is a monster on the target square, ignore!\n        return;\n      }\n    }\n    const newTentativeDistance = tentativeDistance[coords.col][coords.row] + 1;\n    if (\n      tentativeDistance[coords.col + dx][coords.row + dy] > newTentativeDistance\n    ) {\n      tentativeDistance[coords.col + dx][coords.row + dy] =\n        newTentativeDistance;\n      tentativeSourceCol[coords.col + dx][coords.row + dy] = coords.col;\n      tentativeSourceRow[coords.col + dx][coords.row + dy] = coords.row;\n    }\n  }\n\n  dijkstra(\n    target: Coords,\n    withEnemiesAsObstacles: boolean,\n    stopAt: Coords = null\n  ): { distance: number[][]; col: number[][]; row: number[][] } {\n    const current = target.clone();\n\n    const visited: boolean[][] = [];\n    const tentativeDistance: number[][] = [];\n    const tentativeSourceCol: number[][] = [];\n    const tentativeSourceRow: number[][] = [];", "    if (\n      tentativeDistance[coords.col + dx][coords.row + dy] > newTentativeDistance\n    ) {\n      tentativeDistance[coords.col + dx][coords.row + dy] =\n        newTentativeDistance;\n      tentativeSourceCol[coords.col + dx][coords.row + dy] = coords.col;\n      tentativeSourceRow[coords.col + dx][coords.row + dy] = coords.row;\n    }\n  }\n\n  dijkstra(\n    target: Coords,\n    withEnemiesAsObstacles: boolean,\n    stopAt: Coords = null\n  ): { distance: number[][]; col: number[][]; row: number[][] } {\n    const current = target.clone();\n\n    const visited: boolean[][] = [];\n    const tentativeDistance: number[][] = [];\n    const tentativeSourceCol: number[][] = [];\n    const tentativeSourceRow: number[][] = [];", "    for (let i = 0; i < this.dimension; i++) {\n      // col\n      const c1 = [];\n      const c2 = [];\n      const c3 = [];\n      const c4 = [];\n      for (let j = 0; j < this.dimension; j++) {\n        // row\n        c1.push(false);\n        if (target.row == j && target.col == i) {\n          c2.push(0);\n        } else {\n          c2.push(99999);\n        }\n        c3.push(null);\n        c4.push(null);\n      }\n      visited.push(c1);\n      tentativeDistance.push(c2);\n      tentativeSourceCol.push(c3);\n      tentativeSourceRow.push(c4);\n    }\n\n    do {\n      // Consider all unvisited neighbours of `current`\n      const utd = (dx: number, dy: number) => {\n        this.updateTentativeDistance(\n          stopAt && stopAt.equals(current.col + dx, current.row + dy)\n            ? false\n            : withEnemiesAsObstacles,\n          tentativeDistance,\n          tentativeSourceCol,\n          tentativeSourceRow,\n          current,\n          dx,\n          dy\n        );\n      };\n      utd(1, 0);\n      utd(-1, 0);\n      utd(0, -1);\n      utd(0, 1);\n\n      // Mark current as visited\n      visited[current.col][current.row] = true;\n\n      // Stop if we've connected our two target points", "        if (target.row == j && target.col == i) {\n          c2.push(0);\n        } else {\n          c2.push(99999);\n        }\n        c3.push(null);\n        c4.push(null);\n      }\n      visited.push(c1);\n      tentativeDistance.push(c2);\n      tentativeSourceCol.push(c3);\n      tentativeSourceRow.push(c4);\n    }\n\n    do {\n      // Consider all unvisited neighbours of `current`\n      const utd = (dx: number, dy: number) => {\n        this.updateTentativeDistance(\n          stopAt && stopAt.equals(current.col + dx, current.row + dy)\n            ? false\n            : withEnemiesAsObstacles,\n          tentativeDistance,\n          tentativeSourceCol,\n          tentativeSourceRow,\n          current,\n          dx,\n          dy\n        );\n      };\n      utd(1, 0);\n      utd(-1, 0);\n      utd(0, -1);\n      utd(0, 1);\n\n      // Mark current as visited\n      visited[current.col][current.row] = true;\n\n      // Stop if we've connected our two target points", "      if (stopAt && stopAt.equals(current)) break;\n\n      let smallestTentativeDistance = 9999999;\n      let smallests = [];\n      for (let i = 0; i < this.dimension; i++) {\n        for (let j = 0; j < this.dimension; j++) {\n          if (visited[i][j]) continue;\n          if (\n            smallests.length == 0 ||\n            tentativeDistance[i][j] < smallestTentativeDistance\n          ) {\n            smallestTentativeDistance = tentativeDistance[i][j];\n            smallests = [];\n          }", "          if (tentativeDistance[i][j] == smallestTentativeDistance) {\n            smallests.push([i, j]);\n          }\n        }\n      }\n\n      // If there are no unvisited, we are done\n      if (smallests.length == 0) break;\n\n      // Otherwise, set current to unvisited with smallest tentative\n      const randomSmallest = _.sample(smallests);\n      current.set(randomSmallest[0], randomSmallest[1]);", "    } while (true);\n\n    // Return the dijkstra map for the whole grid\n    return {\n      distance: tentativeDistance,\n      col: tentativeSourceCol,\n      row: tentativeSourceRow,\n    };\n  }\n}\n"]}
{"filename": "src/screens/game/character/EnemyCharacter.ts", "chunked_list": ["import Character from \"./Character\";\nimport * as _ from \"underscore\";\n\nexport type EnemyCharacterType = \"enemy1\" | \"enemy2\" | \"enemy3\";\n\nexport default class EnemyCharacter extends Character {\n  constructor(type: EnemyCharacterType) {\n    const spriteName = \"enemy-character.png\";\n    super(spriteName);\n\n    this.type = type;\n", "    if (this.type === \"enemy1\") {\n      this.hp = 1;\n      this.maxHp = 1;\n    } else if (this.type === \"enemy2\") {\n      this.hp = 2;\n      this.maxHp = 2;\n    } else if (this.type === \"enemy3\") {\n      this.hp = 3;\n      this.maxHp = 3;\n    }\n  }\n\n  get isEnemy() {\n    return true;\n  }\n}\n"]}
{"filename": "src/screens/game/character/Character.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\nimport Game from \"Game\";\nimport { Coords } from \"utils\";\nimport type { EnemyCharacterType } from \"./EnemyCharacter\";\n\nexport type CharacterType = \"player\" | EnemyCharacterType;\n\nexport default class Character extends PIXI.Container {\n  coords: Coords;\n  _hp: number = 1;\n  _maxHp: number = 1;\n  type: CharacterType;\n  sprite: PIXI.Sprite;\n  heartsHolder: PIXI.Container;\n  constructor(backgroundPath: string) {\n    super();\n\n    this.coords = new Coords(0, 0);\n\n    this.sprite = PIXI.Sprite.from(Game.tex(backgroundPath));\n    this.sprite.anchor.set(0.5, 1);\n    this.addChild(this.sprite);\n\n    // Add holder for hearts\n    this.heartsHolder = new PIXI.Container();\n    this.addChild(this.heartsHolder);\n  }\n\n  get isEnemy() {\n    return false;\n  }\n\n  get isPlayer() {\n    return false;\n  }\n\n  get hp() {\n    return this._hp;\n  }\n  set hp(hp: number) {\n    this._hp = hp;\n    // CHANGE WHITE/REDNESS", "    for (let i = 0; i < this.heartsHolder.children.length; i++) {\n      const heart = this.heartsHolder.children[i];\n      (heart as PIXI.Sprite).tint = (i < this._hp) ? 0xff0000 : 0xffffff;\n    }\n  }\n\n  get maxHp() {\n    return this._maxHp;\n  }\n  set maxHp(maxHp: number) {\n    this._maxHp = maxHp;\n\n    this.heartsHolder.removeChildren();", "    for (let i = 0; i < this._maxHp; i++) {\n      const heart = PIXI.Sprite.from(Game.tex(\"heart.png\"));\n      heart.anchor.set(0.5);\n      heart.position.set(\n        -(this._maxHp * heart.width)/2 + heart.width * (i + 0.5),\n        0\n      );\n      heart.tint = (i < this._hp) ? 0xff0000 : 0xffffff;\n      this.heartsHolder.addChild(heart);\n    }\n  }\n\n  damage(amount: number): boolean {\n    this.hp -= amount;\n\n    return this.hp <= 0;\n  }\n}\n"]}
{"filename": "src/screens/game/character/PlayerCharacter.ts", "chunked_list": ["import Character from \"./Character\";\n\nexport default class PlayerCharacter extends Character {\n  constructor() {\n    super(\"player-character.png\");\n    this.type = \"player\";\n\n    this.hp = 4;\n    this.maxHp = 4;\n  }\n\n  get isPlayer() {\n    return true;\n  }\n}\n"]}
{"filename": "src/screens/game/character/index.ts", "chunked_list": ["import Character from \"./Character\";\nimport EnemyCharacter from \"./EnemyCharacter\";\nimport PlayerCharacter from \"./PlayerCharacter\";\n\nexport { Character, EnemyCharacter, PlayerCharacter };\n"]}
