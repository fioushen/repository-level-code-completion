{"filename": "utils.d.ts", "chunked_list": ["import { Locator } from 'testcafe';\nexport function getElement(alias: string): Promise<Locator>;\nexport function getValue(alias: string): any;\nexport function getConditionWait(condition: string): Function;\nexport function getValueWait(condition: string): Function;\n\n\n"]}
{"filename": "test/utilsImport.spec.ts", "chunked_list": ["import { getValue, getValueWait, getConditionWait, getElement } from '../utils.js'\nimport { test, expect } from 'vitest';\ntest.each([\n    getValue,\n    getValueWait,\n    getConditionWait,\n    getElement\n])('util function %p', (fn) => {\n    expect(fn).toBeInstanceOf(Function);\n});", "    expect(fn).toBeInstanceOf(Function);\n});\n"]}
{"filename": "test-e2e/webui.ts", "chunked_list": ["import Memory from './memory';\nimport App from './page_object';\nimport localServer from './support/server';\n\nconst common = {\n    paths: ['test-e2e/features/*.feature'],\n    require: ['test-e2e/step-definitions/*.ts', 'src/*.ts'],\n    browser: {\n        logLevel: 'warn',\n        timeout: {", "        logLevel: 'warn',\n        timeout: {\n            page: 5000\n        },\n        capabilities: {\n            browserName: 'chrome:headless'\n        },\n        reuseSession: true\n    },\n    format: [", "    },\n    format: [\n        '@qavajs/console-formatter',\n        '@qavajs/html-formatter:test-e2e/report.html',\n        '@qavajs/xunit-formatter:test-e2e/report.xml'\n    ],\n    memory: new Memory(),\n    pageObject: new App(),\n    parallel: 3,\n    publishQuiet: true,", "    parallel: 3,\n    publishQuiet: true,\n    retry: 1,\n    service: [localServer],\n    screenshot: ['onFail'],\n    defaultTimeout: 20000\n}\n\nexport default common;\n", "export default common;\n\nexport const debug = {\n    ...common,\n    retry: 0,\n    tags: '@debug',\n    browser: {\n        logLevel: 'warn',\n        timeout: {\n            page: 5000", "        timeout: {\n            page: 5000\n        },\n        capabilities: {\n            browserName: 'chrome'\n        },\n        reuseSession: true\n    },\n    parallel: 1\n}", "    parallel: 1\n}\n"]}
{"filename": "test-e2e/page_object/index.ts", "chunked_list": ["import { $, $$, Component } from '@qavajs/po-testcafe';\nexport default class App {\n    SimpleTextElement = $('#textValue');\n    SimpleTextListItems = $$('#textValueList li');\n    SimpleTextInput = $('#textInput');\n    FileInput = $('#fileInput');\n    Action = $('#action');\n    AlertButton = $('#confirm');\n    PromptButton = $('#prompt');\n    Button = $('#button');\n    ButtonHover = $('#buttonHover');\n    Input = $('#input');\n    Select = $('#select');\n    Buttons = $$('.button');\n\n    FrameElement = $('#frameElement');\n\n    NewTabLink = $('#newTabLink');\n\n    PresentElement = $('#present');\n    DetachElement = $('#detach');\n    VisibleElement = $('#visible');\n    HiddenElement = $('#hidden');\n\n    Loading = $('#loading');\n    LoadingInput = $('#loadingInput');\n    WaitCollection = $$('#waitCollection > div');\n    PressCounter = $('#pressCounter');\n\n    Users = $$('#users > li');\n    OverflowContainer = $('#overflowContainer');\n\n    IgnoreHierarchyComponent = $(new IgnoreHierarchyComponent('#ignoreHierarchyComponent'));\n    ComponentWithoutSelector = $(new ComponentWithoutSelector());\n    KeyDump = $('#keywordevent');\n\n    Cookie = $('#cookie');\n    LocalStorage = $('#localStorage');\n    SessionStorage = $('#sessionStorage');\n\n}\n", "class IgnoreHierarchyComponent extends Component {\n    Input = $('#input', { ignoreHierarchy: true });\n}\n\nclass ComponentWithoutSelector {\n    Input = $('#input');\n}\n"]}
{"filename": "test-e2e/step-definitions/index.ts", "chunked_list": ["import { Then } from '@cucumber/cucumber';\nimport memory from '@qavajs/memory';\nimport { expect } from 'chai';\nimport * as testcafe from 'testcafe';\n\ndeclare global {\n    var t: TestController;\n    var testcafe: TestCafe;\n    var runner: Runner;\n    var taskPromise: any;", "    var runner: Runner;\n    var taskPromise: any;\n    var config: any;\n}\n\n\nThen('I expect {string} memory value to be equal {string}', async function(actual, expected) {\n    const actualValue = memory.getValue(actual);\n    const expectedValue = memory.getValue(expected);\n    expect(expectedValue).to.eql(actualValue);", "    const expectedValue = memory.getValue(expected);\n    expect(expectedValue).to.eql(actualValue);\n});\n"]}
{"filename": "test-e2e/support/server.ts", "chunked_list": ["// @ts-ignore\nimport express, { Express } from 'express';\nimport { createServer } from 'http';\n\nclass Service {\n    httpServer: any;\n    before() {\n        const app: Express = express();\n        const port = 3000;\n\n        app.use(express.static('./test-e2e/apps'))\n        this.httpServer = createServer(app);\n        this.httpServer.listen(port);\n    };\n    after() {\n        this.httpServer.close();\n    }\n}\n\nexport default new Service();\n"]}
{"filename": "test-e2e/memory/index.ts", "chunked_list": ["import { resolve } from 'path';\n\nconst file = (path: string) => `file://${path}`\n\nexport default class Memory {\n    valuesPage = file(resolve('./test-e2e/apps/values.html'));\n    actionsPage = file(resolve('./test-e2e/apps/actions.html'));\n    framePage = file(resolve('./test-e2e/apps/frame.html'));\n    waitsPage = file(resolve('./test-e2e/apps/waits.html'));\n    mockPage = file(resolve('./test-e2e/apps/mock.html'));\n    storagePage = file(resolve('./test-e2e/apps/storage.html'));\n\n    array = (...args: Array<any>) => args;\n\n    // @ts-ignore\n    setInputValue = () => document.querySelector('#input').value = 'some value';\n\n    // @ts-ignore\n    getActionInnerText = () => document.querySelector(\"#action\").innerText;\n\n    // @ts-ignore\n    clickJS = () => target().click();\n\n    // @ts-ignore\n    getInnerText = () => target().innerText;\n\n    userFromMemory = 'Mock 3';\n\n    users = JSON.stringify([\n        {\"name\": \"Memory Mock 1\"},\n        {\"name\": \"Memory Mock 2\"},\n        {\"name\": \"Memory Mock 3\"}\n    ]);\n\n    uploadFile = resolve('./test-e2e/apps/actions.html');\n\n    button2 = 'Button2';\n\n    userInterceptionPredicate = (request: any) => request.url.includes('users');\n}\n\n"]}
{"filename": "src/defaultTimeouts.ts", "chunked_list": ["export default {\n    present: 10000,\n    visible: 10000,\n    page: 10000\n}\n"]}
{"filename": "src/transformers.ts", "chunked_list": ["import { conditionWait, conditionWaitExtractRegexp } from './conditionWait';\nimport { valueWait, valueWaitExtractRegexp } from './valueWait';\nimport { po } from '@qavajs/po-testcafe';\nimport memory from '@qavajs/memory';\nimport { Selector } from 'testcafe';\n\nexport function getValue(alias: string): any {\n    return memory.getValue(alias)\n}\n\nexport async function getElement(alias: string): Promise<Selector> {\n    return po.getElement(await memory.getValue(alias))\n}\n", "export async function getElement(alias: string): Promise<Selector> {\n    return po.getElement(await memory.getValue(alias))\n}\n\nexport function getConditionWait(condition: string): Function {\n    const match = condition.match(conditionWaitExtractRegexp) as RegExpMatchArray;\n    if (!match) throw new Error(`${condition} wait is not implemented`);\n    const [ _, reverse, validation ] = match;\n    return async function (element: Selector, timeout: number) {\n        await conditionWait(element, validation, timeout, Boolean(reverse))\n    }\n}\n", "export function getValueWait(condition: string): Function {\n    const match = condition.match(valueWaitExtractRegexp) as RegExpMatchArray;\n    if (!match) throw new Error(`${condition} wait is not implemented`);\n    const [ _, reverse, validation ] = match;\n    return async function (valueFn: ClientFunction, expected: any, timeout: number) {\n        await valueWait(valueFn, expected, validation, timeout, Boolean(reverse))\n    }\n}\n"]}
{"filename": "src/hooks.ts", "chunked_list": ["import { After, AfterStep, AfterAll, Before, BeforeStep, BeforeAll } from '@cucumber/cucumber';\nimport defaultTimeouts from './defaultTimeouts';\nimport { po } from '@qavajs/po-testcafe';\nimport { saveScreenshotAfterStep, saveScreenshotBeforeStep, takeScreenshot } from './utils/utils';\nimport createTestCafe from 'testcafe';\nimport { join } from 'path';\n\ndeclare global {\n    var t: TestController;\n    var testcafe: TestCafe;", "    var t: TestController;\n    var testcafe: TestCafe;\n    var runner: Runner;\n    var taskPromise: any;\n    var config: any;\n}\n\nBeforeAll(async function (){\n    global.testcafe = await createTestCafe('localhost');\n})", "    global.testcafe = await createTestCafe('localhost');\n})\n\nBefore(async function () {\n    const driverConfig = config.browser ?? config.driver;\n    driverConfig.timeout = {\n        ...defaultTimeouts,\n        ...driverConfig.timeout\n    }\n    global.config.driverConfig = driverConfig;", "    }\n    global.config.driverConfig = driverConfig;\n\n    if (!global.t || !config.driverConfig.reuseSession) {\n        global.runner = await testcafe.createRunner();\n        global.taskPromise = global.runner\n            .src(join(__dirname, 'testController/bootstrap.{ts,js}'))\n            .browsers([config.driverConfig.capabilities.browserName])\n            .run({\n                nativeAutomation: config.driverConfig.capabilities.nativeAutomation ?? false\n            });\n        await new Promise((resolve) => {\n            const interval = setInterval(() => {", "                if (global.t) {\n                    clearInterval(interval)\n                    resolve(t);\n                }\n            }, 500)\n        });\n    }\n    po.init({timeout: config.driverConfig.timeout.present});\n    po.register(config.pageObject);\n    this.log(`browser instance started:\\n${JSON.stringify(config.driverConfig, null, 2)}`);\n});\n\nBeforeStep(async function () {", "    if (saveScreenshotBeforeStep(config)) {\n        try {\n            this.attach(await takeScreenshot(), 'image/png');\n        } catch (err) {\n            console.warn(err)\n        }\n    }\n});\n\nAfterStep(async function (step) {\n    try {", "    try {\n        if (saveScreenshotAfterStep(config, step)) {\n            this.attach(await takeScreenshot(), 'image/png');\n        }\n    } catch (err) {\n        console.warn(err)\n    }\n});\n\nAfter(async function (scenario) {\n    if (global.config.driverConfig.reuseSession) {\n        let close = true;", "    if (global.config.driverConfig.reuseSession) {\n        let close = true;\n        while (close) {\n            try {\n                await t.closeWindow();\n            } catch (err) {\n                close = false\n            }\n        }\n    }\n    if (global.t && !global.config.driverConfig.reuseSession) {\n        await global.taskPromise.cancel();\n        await global.runner.stop();\n        // @ts-ignore\n        global.t = null;\n        // @ts-ignore\n        global.runner = null;\n        // @ts-ignore\n        global.taskPromise = null;\n    }\n});\n\nAfterAll(async function () {\n    await global.testcafe.close();\n});\n\n\n", "    if (global.t && !global.config.driverConfig.reuseSession) {\n        await global.taskPromise.cancel();\n        await global.runner.stop();\n        // @ts-ignore\n        global.t = null;\n        // @ts-ignore\n        global.runner = null;\n        // @ts-ignore\n        global.taskPromise = null;\n    }\n});\n\nAfterAll(async function () {\n    await global.testcafe.close();\n});\n\n\n"]}
{"filename": "src/conditionWait.ts", "chunked_list": ["import { Selector } from 'testcafe';\n\nexport const conditionValidations = {\n    PRESENT: 'present',\n    // CLICKABLE: 'clickable',\n    VISIBLE: 'visible',\n    INVISIBLE: 'invisible',\n    IN_VIEWPORT: 'in viewport',\n    // ENABLED: 'enabled',\n    // DISABLED: 'disabled'", "    // ENABLED: 'enabled',\n    // DISABLED: 'disabled'\n}\n\nconst notClause = '(not )?';\nconst toBeClause = 'to (?:be )?';\nconst validationClause = `(${Object.values(conditionValidations).join('|')})`;\n\nexport const conditionWaitExtractRegexp = new RegExp(`^${notClause}${toBeClause}${validationClause}$`);\nexport const conditionWaitRegexp = new RegExp(`(${notClause}${toBeClause}${validationClause})`);", "export const conditionWaitExtractRegexp = new RegExp(`^${notClause}${toBeClause}${validationClause}$`);\nexport const conditionWaitRegexp = new RegExp(`(${notClause}${toBeClause}${validationClause})`);\n\nconst executeWait = (expect: Assertion<any>, reverse: boolean, timeout: number, timeoutMsg: string) => {\n    return reverse\n        ? expect.eql(0, timeoutMsg, { timeout })\n        : expect.gt(0, timeoutMsg, { timeout });\n}\n\nconst waits = {", "\nconst waits = {\n    [conditionValidations.PRESENT]: (\n        element: Selector,\n        reverse: boolean,\n        timeout: number,\n        timeoutMsg: string\n    ) => {\n        const expect = t.expect(element.with({ boundTestRun: t }).count);\n        return executeWait(expect, reverse, timeout, timeoutMsg);\n    },\n    [conditionValidations.VISIBLE]: (\n        element: Selector,\n        reverse: boolean,\n        timeout: number,\n        timeoutMsg: string\n    ) => {", "        const expect = t.expect(element.with({ boundTestRun: t }).count);\n        return executeWait(expect, reverse, timeout, timeoutMsg);\n    },\n    [conditionValidations.VISIBLE]: (\n        element: Selector,\n        reverse: boolean,\n        timeout: number,\n        timeoutMsg: string\n    ) => {\n        const expect = t.expect(element.filterVisible().with({ boundTestRun: t }).count)\n        return executeWait(expect, reverse, timeout, timeoutMsg);\n    },\n    [conditionValidations.INVISIBLE]: (\n        element: Selector,\n        reverse: boolean,\n        timeout: number,\n        timeoutMsg: string\n    ) => {", "        const expect = t.expect(element.filterVisible().with({ boundTestRun: t }).count)\n        return executeWait(expect, reverse, timeout, timeoutMsg);\n    },\n    [conditionValidations.INVISIBLE]: (\n        element: Selector,\n        reverse: boolean,\n        timeout: number,\n        timeoutMsg: string\n    ) => {\n        const expect = t.expect(element.filterHidden().with({ boundTestRun: t }).count)\n        return executeWait(expect, reverse, timeout, timeoutMsg);\n    },\n}\n/**\n * Wait for condition\n * @param {Selector} element - element\n * @param {string} validationType - validation to perform\n * @param {number} [timeout] - timeout to wait\n * @param {boolean} [reverse] - negate flag\n * @return {Promise<void>}\n */", "        const expect = t.expect(element.filterHidden().with({ boundTestRun: t }).count)\n        return executeWait(expect, reverse, timeout, timeoutMsg);\n    },\n}\n/**\n * Wait for condition\n * @param {Selector} element - element\n * @param {string} validationType - validation to perform\n * @param {number} [timeout] - timeout to wait\n * @param {boolean} [reverse] - negate flag\n * @return {Promise<void>}\n */", "export async function conditionWait(\n    element: Selector,\n    validationType: string,\n    timeout: number = 10000,\n    reverse: boolean = false\n) {\n    const timeoutMsg: string = `Element is${reverse ? '' : ' not'} ${validationType}`;\n    const waitFn = waits[validationType];\n    await waitFn(element, reverse, timeout, timeoutMsg);\n}\n"]}
{"filename": "src/actions.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue, getElement } from './transformers';\nimport { ClientFunction, Selector } from 'testcafe';\nimport {parseCoords} from './utils/utils';\n\n/**\n * Opens provided url\n * @param {string} url - url to navigate\n * @example I open 'https://google.com'\n */", " * @example I open 'https://google.com'\n */\nWhen('I open {string} url', async function (url: string) {\n    const urlValue = await getValue(url);\n    await t.navigateTo(urlValue);\n});\n\n/**\n * Type text to element\n * @param {string} alias - element to type", " * Type text to element\n * @param {string} alias - element to type\n * @param {string} value - value to type\n * @example I type 'wikipedia' to 'Google Input'\n */\nWhen('I type {string} to {string}', async function (value: string, alias: string) {\n    const element = await getElement(alias);\n    const typeValue = await getValue(value);\n    await t.typeText(element, typeValue);\n});", "    await t.typeText(element, typeValue);\n});\n\n/**\n * Click element\n * @param {string} alias - element to click\n * @example I click 'Google Button'\n */\nWhen('I click {string}', async function (alias: string) {\n    const element = await getElement(alias);", "When('I click {string}', async function (alias: string) {\n    const element = await getElement(alias);\n    await t.click(element);\n});\n\n/**\n * Click element via script\n * @param {string} alias - element to click\n * @example I force click 'Google Button'\n */", " * @example I force click 'Google Button'\n */\nWhen('I force click {string}', async function (alias: string) {\n    const element = await getElement(alias);\n    // @ts-ignore\n    await t.eval(() => element().click(), { dependencies: { element } });\n});\n\n/**\n * Right click element", "/**\n * Right click element\n * @param {string} alias - element to right click\n * @example I right click 'Google Button'\n */\nWhen('I right click {string}', async function (alias: string) {\n    const element = await getElement(alias);\n    await t.rightClick(element);\n});\n", "});\n\n/**\n * Double click element\n * @param {string} alias - double element to click\n * @example I double click 'Google Button'\n */\nWhen('I double click {string}', async function (alias: string) {\n    const element = await getElement(alias);\n    await t.doubleClick(element);", "    const element = await getElement(alias);\n    await t.doubleClick(element);\n});\n\n/**\n * Clear input\n * @param {string} alias - element to clear\n * @example I clear 'Google Input'\n */\nWhen('I clear {string}', async function (alias: string) {", " */\nWhen('I clear {string}', async function (alias: string) {\n    const element = await getElement(alias);\n    await t.selectText(element).pressKey('delete');\n});\n\n/**\n * Switch to parent frame\n * @example I switch to parent frame\n */", " * @example I switch to parent frame\n */\nWhen('I switch to parent frame', async function () {\n    await t.switchToMainWindow();\n});\n\n/**\n * Switch to frame by index\n * @param {number} index - index to switch\n * @example I switch to 2 frame", " * @param {number} index - index to switch\n * @example I switch to 2 frame\n */\nWhen('I switch to {int} frame', async function (index: number) {\n    await t.switchToIframe(Selector('iframe').nth(index - 1));\n});\n\n/**\n * Switch to frame by index\n * @param {number} index - index to switch", " * Switch to frame by index\n * @param {number} index - index to switch\n * @example I switch to 2 frame\n */\nWhen('I switch to {string} window', async function (hrefOrTitleKey: string) {\n    const hrefOrTitle = await getValue(hrefOrTitleKey);\n    await t.switchToWindow((win: WindowFilterData) =>\n        win.title.includes(hrefOrTitle) || win.url.href.includes(hrefOrTitle)\n    );\n});", "    );\n});\n\n/**\n * Refresh current page\n * @example I refresh page\n */\nWhen('I refresh page', async function () {\n    await ClientFunction(() => {\n        document.location.reload();\n    }).with({ boundTestRun: t })();\n});\n\n/**\n * Press button\n * @param {string} key - key to press\n * @example I press 'Enter' key\n * @example I press 'Control+C' keys\n */\nWhen('I press {string} key(s)', async function (key: string) {\n    const resolvedKey = await getValue(key);\n    await t.pressKey(resolvedKey.toLowerCase());\n});\n\n/**\n * Press button given number of times\n * @param {string} key - key to press\n * @param {number} num - number of times\n * @example I press 'Enter' key 5 times\n * @example I press 'Control+V' keys 5 times\n */\nWhen('I press {string} key(s) {int} time(s)', async function (key: string, num: number) {\n    const resolvedKey = await getValue(key)", "    await ClientFunction(() => {\n        document.location.reload();\n    }).with({ boundTestRun: t })();\n});\n\n/**\n * Press button\n * @param {string} key - key to press\n * @example I press 'Enter' key\n * @example I press 'Control+C' keys\n */\nWhen('I press {string} key(s)', async function (key: string) {\n    const resolvedKey = await getValue(key);\n    await t.pressKey(resolvedKey.toLowerCase());\n});\n\n/**\n * Press button given number of times\n * @param {string} key - key to press\n * @param {number} num - number of times\n * @example I press 'Enter' key 5 times\n * @example I press 'Control+V' keys 5 times\n */\nWhen('I press {string} key(s) {int} time(s)', async function (key: string, num: number) {\n    const resolvedKey = await getValue(key)", "    for (let i: number = 0; i < num; i++) {\n        await t.pressKey(resolvedKey.toLowerCase());\n    }\n});\n\n/**\n * Hover over element\n * @param {string} alias - element to hover over\n * @example I hover over 'Google Button'\n */\nWhen('I hover over {string}', async function (alias: string) {\n    const element = await getElement(alias);\n    await t.hover(element);\n});\n\n/**\n * Select option with certain text from select element\n * @param {string} option - option to select\n * @param {string} alias - alias of select\n * @example I select '1900' option from 'Registration Form > Date Of Birth'\n * @example I select '$dateOfBirth' option from 'Registration Form > Date Of Birth' dropdown\n */\nWhen('I select {string} option from {string} dropdown', async function (option: string, alias: string) {\n    const optionValue = await getValue(option);\n    const select = await getElement(alias);\n    await t\n        .click(select)\n        .click(select.find('option').withText(optionValue));\n});\n\n/**\n * Select option with certain text from select element\n * @param {number} optionIndex - index of option to select\n * @param {string} alias - alias of select\n * @example I select 1 option from 'Registration Form > Date Of Birth' dropdown\n */\nWhen('I select {int}(st|nd|rd|th) option from {string} dropdown', async function (optionIndex: number, alias: string) {\n    const select = await getElement(alias);\n    await t\n        .click(select)\n        .click(select.find('option').nth(optionIndex - 1));\n});\n\n/**\n * Click on element with desired text in collection\n * @param {string} expectedText - text to click\n * @param {string} alias - collection to search text\n * @example I click 'google' text in 'Search Engines' collection\n * @example I click '$someVarWithText' text in 'Search Engines' collection\n */\nWhen(\n    'I click {string} text in {string} collection',\n    async function (value: string, alias: string) {\n        const resolvedValue = await getValue(value);\n        const collection = await getElement(alias);\n        await t.click(collection.withText(resolvedValue));\n    }\n);\n\n/**\n * Scroll by provided offset\n * @param {string} - offset string in 'x, y' format\n * @example\n * When I scroll by '0, 100'\n */\nWhen('I scroll by {string}', async function (offset: string) {\n    const [x, y] = parseCoords(await getValue(offset));\n    await t.scrollBy(x, y);\n});\n\n/**\n * Scroll by provided offset in element\n * @param {string} - offset string in 'x, y' format\n * @param {string} - element alias\n * @example\n * When I scroll by '0, 100' in 'Overflow Container'\n */\nWhen('I scroll by {string} in {string}', async function (offset: string, alias: string) {\n    const element = await getElement(alias);\n    const [x, y] = parseCoords(await getValue(offset));\n    await t.scrollBy(element, x, y);\n});\n\n/**\n * Provide file url to upload input\n * @param {string} alias - element to upload file\n * @param {string} value - file path\n * @example I upload '/folder/file.txt' to 'File Input'\n */\nWhen('I upload {string} file to {string}', async function (value: string, alias: string) {\n    const element = await getElement(alias);\n    const filePath = await getValue(value);\n    await t.setFilesToUpload(element, [filePath]).click(element);\n});\n\n/**\n * Set alert handler\n * @example I will accept alert\n */\nWhen('I will accept alert', async function () {\n    await t.setNativeDialogHandler(() => true);\n});\n\n/**\n * Dismiss alert\n * testcafe automatically dismisses all dialogs. This step is just to make it implicitly.\n * @example I will dismiss alert\n */\nWhen('I will dismiss alert', async function () {\n    await t.setNativeDialogHandler(() => false);\n});\n\n/**\n * Type text to prompt\n * I type {string} to alert\n * @example I will type 'coffee' to alert\n */\nWhen('I will type {string} to alert', async function (valueKey: string) {\n    const value = await getValue(valueKey);\n    await t.setNativeDialogHandler(() => value, { dependencies: { value }});\n});\n"]}
{"filename": "src/cookies.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue } from './transformers';\nimport memory from '@qavajs/memory';\n\n/**\n * Set cookie\n * @param {string} cookie - cookie name\n * @param {string} value - value to set\n * @example I set 'userID' cookie 'user1'\n * @example I set 'userID' cookie '$userIdCookie'", " * @example I set 'userID' cookie 'user1'\n * @example I set 'userID' cookie '$userIdCookie'\n */\nWhen('I set {string} cookie as {string}', async function (cookie, value) {\n    const cookieValue = await getValue(value);\n    const cookieObject = typeof cookieValue === 'object' ? cookieValue : { name: cookie, value: cookieValue };\n    await t.setCookies(cookieObject);\n});\n\n/**", "\n/**\n * Save cookie value to memory\n * @param {string} cookie - cookie name\n * @param {string} key - memory key\n * @example I save value of 'auth' cookie as 'authCookie'\n */\nWhen('I save value of {string} cookie as {string}', async function (cookie, key) {\n    const cookieName = await getValue(cookie);\n    const cookies = await t.getCookies([cookieName]);", "    const cookieName = await getValue(cookie);\n    const cookies = await t.getCookies([cookieName]);\n    memory.setValue(key, cookies.pop());\n});\n"]}
{"filename": "src/intercept.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue } from './transformers';\nimport memory from '@qavajs/memory';\nimport { RequestLogger } from 'testcafe';\n\n/**\n * Create interception for url or predicate function\n * @param {string | function} url - url or predicate function to listen\n * @param {string} key - memory key to save\n * @example I create interception for '.+\\/api\\/qavajs' as 'intercept'\n * @example I create interception for '$interceptHandler' as 'intercept' // if you need to pass function as interception handler\n */\nWhen('I create interception for {string} as {string}', async function (urlTemplate: string, key: string) {\n    const url = await getValue(urlTemplate);\n    const predicate = typeof url === 'string' ? new RegExp(url, 'g') : url;\n    const requestLogger = RequestLogger(predicate, {\n        logRequestBody: true,\n        logRequestHeaders: true,\n        logResponseBody: true,\n        logResponseHeaders: true\n    });\n    memory.setValue(key, requestLogger);\n    await t.addRequestHooks(requestLogger);\n});\n\n/**\n * Wait for interception response\n * @param {string} interception - key of saved interception promise\n * @example I wait for '$interception' response\n */\nWhen('I wait for {string} response', async function (interception: string) {\n    const requestLogger: RequestLogger = await getValue(interception);\n    await t.expect(requestLogger.requests.length).gt(0);\n    await t.expect(requestLogger.contains(request => !!request.response)).ok();\n});\n\n/**\n * Save interception response\n * @param {string} interception - key of saved interception promise\n * @example I save '$interception' response as 'response'\n */\nWhen('I save {string} response as {string}', async function (interception: string, key: string) {\n    const requestLogger: RequestLogger = await getValue(interception);\n    await t.expect(requestLogger.requests.length).gt(0);\n    await t.expect(requestLogger.contains(request => !!request.response)).ok();\n    const requests = requestLogger.requests;\n    memory.setValue(key, requests[requests.length - 1]);\n});\n", " * @example I create interception for '$interceptHandler' as 'intercept' // if you need to pass function as interception handler\n */\nWhen('I create interception for {string} as {string}', async function (urlTemplate: string, key: string) {\n    const url = await getValue(urlTemplate);\n    const predicate = typeof url === 'string' ? new RegExp(url, 'g') : url;\n    const requestLogger = RequestLogger(predicate, {\n        logRequestBody: true,\n        logRequestHeaders: true,\n        logResponseBody: true,\n        logResponseHeaders: true\n    });\n    memory.setValue(key, requestLogger);\n    await t.addRequestHooks(requestLogger);\n});\n\n/**\n * Wait for interception response\n * @param {string} interception - key of saved interception promise\n * @example I wait for '$interception' response\n */\nWhen('I wait for {string} response', async function (interception: string) {\n    const requestLogger: RequestLogger = await getValue(interception);\n    await t.expect(requestLogger.requests.length).gt(0);\n    await t.expect(requestLogger.contains(request => !!request.response)).ok();\n});\n\n/**\n * Save interception response\n * @param {string} interception - key of saved interception promise\n * @example I save '$interception' response as 'response'\n */\nWhen('I save {string} response as {string}', async function (interception: string, key: string) {\n    const requestLogger: RequestLogger = await getValue(interception);\n    await t.expect(requestLogger.requests.length).gt(0);\n    await t.expect(requestLogger.contains(request => !!request.response)).ok();\n    const requests = requestLogger.requests;\n    memory.setValue(key, requests[requests.length - 1]);\n});\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { defineParameterType } from '@cucumber/cucumber';\n\ndefineParameterType({\n    name: 'testcafeValidation',\n    regexp: /((?:is |do |does |to )?(not |to not )?(?:to )?(?:be )?(equal|strictly equal|deeply equal|have member|match|contain|above|below|greater than|less than|have type)(?:s|es)?)/,\n    transformer: p => p,\n    useForSnippets: false\n});\n\ndefineParameterType({", "\ndefineParameterType({\n    name: 'testcafeValueWait',\n    regexp: /((not )?to (?:be )?(equal|contain|above|below|match))/,\n    transformer: p => p,\n    useForSnippets: false\n});\n\ndefineParameterType({\n    name: 'testcafeConditionWait',", "defineParameterType({\n    name: 'testcafeConditionWait',\n    regexp: /((not )?to (?:be )?(present|clickable|visible|invisible|enabled|disabled|in viewport))/,\n    transformer: p => p,\n    useForSnippets: false\n});\n\ndefineParameterType({\n    name: 'testcafeTimeout',\n    regexp: /(?:\\(timeout: (\\d+)\\))?/,", "    name: 'testcafeTimeout',\n    regexp: /(?:\\(timeout: (\\d+)\\))?/,\n    transformer: p => p ? parseInt(p) : null,\n    useForSnippets: false\n});\n\ndefineParameterType({\n    name: 'testcafePoType',\n    regexp: /(element|collection)/,\n    transformer: p => p,", "    regexp: /(element|collection)/,\n    transformer: p => p,\n    useForSnippets: false\n});\n\n"]}
{"filename": "src/execute.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue, getElement } from './transformers';\nimport memory from '@qavajs/memory';\nimport { ClientFunction } from 'testcafe';\n\nconst resolveFunction = (fnDef: string | Function) => typeof fnDef === 'string' ? eval(`() => ${fnDef}`) : fnDef;\n/**\n * Execute client function\n * @param {string} functionKey - memory key of function\n * @example I execute '$fn' function // fn is function reference\n * @example I execute 'window.scrollBy(0, 100)' function\n */\nWhen('I execute {string} function', async function (functionKey) {\n    const fnDef = await getValue(functionKey);\n    const clientFunction = ClientFunction(resolveFunction(fnDef));", " * @param {string} functionKey - memory key of function\n * @example I execute '$fn' function // fn is function reference\n * @example I execute 'window.scrollBy(0, 100)' function\n */\nWhen('I execute {string} function', async function (functionKey) {\n    const fnDef = await getValue(functionKey);\n    const clientFunction = ClientFunction(resolveFunction(fnDef));\n    await clientFunction.with({ boundTestRun: t })();\n});\n\n/**", " * Execute client function and save result into memory\n * @param {string} functionKey - memory key of function\n * @param {string} memoryKey - memory key to store result\n * @example I execute '$fn' function and save result as 'result' // fn is function reference\n * @example I execute 'window.scrollY' function and save result as 'scroll'\n */\nWhen('I execute {string} function and save result as {string}', async function (functionKey, memoryKey) {\n    const fnDef = await getValue(functionKey);\n    const clientFunction = ClientFunction(resolveFunction(fnDef));\n    memory.setValue(memoryKey, await clientFunction.with({ boundTestRun: t })());\n});\n\n/**", "    memory.setValue(memoryKey, await clientFunction.with({ boundTestRun: t })());\n});\n\n/**\n * Execute client function on certain element\n * @param {string} functionKey - memory key of function\n * @param {string} alias - alias of target element\n * @example I execute '$fn' function on 'Component > Element' // fn is function reference\n * @example I execute 'target.scrollIntoView()' function on 'Component > Element'\n */\nWhen('I execute {string} function on {string}', async function (functionKey, alias) {\n    const fnDef = await getValue(functionKey);\n    const element = await getElement(alias);\n    const clientFunction = ClientFunction(resolveFunction(fnDef), {\n        dependencies: { target: element }\n    });", " * @example I execute 'target.scrollIntoView()' function on 'Component > Element'\n */\nWhen('I execute {string} function on {string}', async function (functionKey, alias) {\n    const fnDef = await getValue(functionKey);\n    const element = await getElement(alias);\n    const clientFunction = ClientFunction(resolveFunction(fnDef), {\n        dependencies: { target: element }\n    });\n    await clientFunction.with({ boundTestRun: t })();\n});\n\n/**", "    await clientFunction.with({ boundTestRun: t })();\n});\n\n/**\n * Execute client function on certain element\n * @param {string} functionKey - memory key of function\n * @param {string} alias - alias of target element\n * @example I execute '$fn' function on 'Component > Element' and save result as 'innerText' // fn is function reference\n * @example I execute 'target.innerText' function on 'Component > Element' and save result as 'innerText'\n */\nWhen(", " * @example I execute 'target.innerText' function on 'Component > Element' and save result as 'innerText'\n */\nWhen(\n    'I execute {string} function on {string} and save result as {string}',\n    async function (functionKey, alias, memoryKey) {\n        const fnDef = await getValue(functionKey);\n        const element = await getElement(alias);\n        const clientFunction = ClientFunction(resolveFunction(fnDef), {\n            dependencies: { target: element }\n        });\n        memory.setValue(memoryKey, await clientFunction.with({ boundTestRun: t })());\n    }\n);\n", "        memory.setValue(memoryKey, await clientFunction.with({ boundTestRun: t })());\n    }\n);\n"]}
{"filename": "src/waits.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue, getElement, getConditionWait, getValueWait } from './transformers';\nimport {ClientFunction} from 'testcafe';\n\n/**\n * Wait for element condition\n * @param {string} alias - element to wait condition\n * @param {string} wait - wait condition\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until 'Header' to be visible", " * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until 'Header' to be visible\n * @example I wait until 'Loading' not to be present\n * @example I wait until 'Search Bar > Submit Button' to be clickable\n * @example I wait until 'Search Bar > Submit Button' to be clickable (timeout: 3000)\n */\nWhen(\n    'I wait until {string} {testcafeConditionWait}( ){testcafeTimeout}',\n    async function (alias: string, waitType: string, timeout: number | null) {\n        const wait = getConditionWait(waitType);", "    async function (alias: string, waitType: string, timeout: number | null) {\n        const wait = getConditionWait(waitType);\n        const element = await getElement(alias);\n        await wait(element, timeout ? timeout : config.browser.timeout.page);\n    }\n);\n\n/**\n * Wait for element text condition\n * @param {string} alias - element to wait condition", " * Wait for element text condition\n * @param {string} alias - element to wait condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until text of 'Header' to be equal 'Javascript'\n * @example I wait until text of 'Header' not to be equal 'Python'\n * @example I wait until text of 'Header' to be equal 'Javascript' (timeout: 3000)\n */\nWhen(", " */\nWhen(\n    'I wait until text of {string} {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (alias: string, waitType: string, value: string, timeout: number | null) {\n        const wait = getValueWait(waitType);\n        const element = await getElement(alias);\n        const expectedValue = await getValue(value);\n        await wait(\n            element.with({ boundTestRun: t }).innerText,\n            expectedValue,\n            timeout ? timeout : config.browser.timeout.page\n        );\n    }\n);\n\n/**\n * Wait for collection length condition\n * @param {string} alias - element to wait condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until number of elements in 'Search Results' collection to be equal '50'\n * @example I wait until number of elements in 'Search Results' collection to be above '49'\n * @example I wait until number of elements in 'Search Results' collection to be below '51'\n * @example I wait until number of elements in 'Search Results' collection to be below '51' (timeout: 3000)\n */\nWhen(\n    'I wait until number of elements in {string} collection {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (alias: string, waitType: string, value: string, timeout: number | null) {\n        const wait = getValueWait(waitType);\n        const collection = await getElement(alias);\n        const expectedValue = await getValue(value);\n        await wait(", "            element.with({ boundTestRun: t }).innerText,\n            expectedValue,\n            timeout ? timeout : config.browser.timeout.page\n        );\n    }\n);\n\n/**\n * Wait for collection length condition\n * @param {string} alias - element to wait condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until number of elements in 'Search Results' collection to be equal '50'\n * @example I wait until number of elements in 'Search Results' collection to be above '49'\n * @example I wait until number of elements in 'Search Results' collection to be below '51'\n * @example I wait until number of elements in 'Search Results' collection to be below '51' (timeout: 3000)\n */\nWhen(\n    'I wait until number of elements in {string} collection {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (alias: string, waitType: string, value: string, timeout: number | null) {\n        const wait = getValueWait(waitType);\n        const collection = await getElement(alias);\n        const expectedValue = await getValue(value);\n        await wait(", "            collection.with({ boundTestRun: t }).count,\n            parseFloat(expectedValue),\n            timeout ? timeout : config.browser.timeout.page\n        );\n    }\n);\n\n/**\n * Wait for element property condition\n * @param {string} property - property\n * @param {string} alias - element to wait condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until 'value' property of 'Search Input' to be equal 'Javascript'\n * @example I wait until 'value' property of 'Search Input' to be equal 'Javascript' (timeout: 3000)\n */\nWhen(\n    'I wait until {string} property of {string} {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (property: string, alias: string, waitType: string, value: string, timeout: number | null) {\n        const propertyName = await getValue(property);\n        const wait = getValueWait(waitType);\n        const element = await getElement(alias);\n        const expectedValue = await getValue(value);\n        // @ts-ignore", "        const getValueFn = element.with({ boundTestRun: t })[propertyName];\n        await wait(getValueFn, expectedValue, timeout ? timeout : config.browser.timeout.page);\n    }\n);\n\n/**\n * Wait for element attribute condition\n * @param {string} attribute - attribute\n * @param {string} alias - element to wait condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until 'href' attribute of 'Home Link' to be equal '/javascript'\n * @example I wait until 'href' attribute of 'Home Link' to be equal '/javascript' (timeout: 3000)\n */\nWhen(\n    'I wait until {string} attribute of {string} {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (attribute: string, alias: string, waitType: string, value: string, timeout: number | null) {\n        const attributeName = await getValue(attribute);\n        const wait = getValueWait(waitType);\n        const element = await getElement(alias);\n        const expectedValue = await getValue(value);", "        const getValueFn = element.with({ boundTestRun: t }).getAttribute(attributeName);\n        await wait(getValueFn, expectedValue, timeout ? timeout : config.browser.timeout.page);\n    }\n);\n\n/**\n * Wait\n * @param {number} ms - milliseconds\n * @example I wait 1000 ms\n */\nWhen('I wait {int} ms', async function (ms) {\n    await new Promise((resolve: Function): void => {\n        setTimeout(() => resolve(), ms)\n    });\n});\n\n/**\n * Wait for url condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until current url to be equal 'https://qavajs.github.io/'\n * @example I wait until current url not to contain 'java'\n * @example I wait until current url not to contain 'java' (timeout: 3000)\n */\nWhen(\n    'I wait until current url {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (waitType: string, value: string, timeout: number | null) {\n        const wait = getValueWait(waitType);\n        const expectedValue = await getValue(value);\n        const getValueFn = await ClientFunction(() => window.location.href )", "            .with({ boundTestRun: t });\n        await wait(getValueFn(), expectedValue, timeout ? timeout : config.browser.timeout.page);\n    }\n);\n\n/**\n * Wait for title condition\n * @param {string} wait - wait condition\n * @param {string} value - expected value to wait\n * @param {number|null} [timeout] - custom timeout in ms\n * @example I wait until page title to be equal 'qavajs'\n * @example I wait until page title not to contain 'java'\n * @example I wait until page title to be equal 'qavajs' (timeout: 3000)\n */\nWhen(\n    'I wait until page title {testcafeValueWait} {string}( ){testcafeTimeout}',\n    async function (waitType: string, value: string, timeout: number | null) {\n        const wait = getValueWait(waitType);\n        const expectedValue = await getValue(value);\n        const getValueFn = await ClientFunction(() => window.document.title )", "            .with({ boundTestRun: t });\n        await wait(getValueFn(), expectedValue, timeout ? timeout : config.browser.timeout.page);\n    }\n);\n"]}
{"filename": "src/localSessionStorage.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue } from './transformers';\nimport memory from '@qavajs/memory';\nimport {ClientFunction} from 'testcafe';\n\n/**\n * Set value of local/session storage\n * @param {string} storageKey - local/session storage key to set value\n * @param {string} storageType - storage type (local or session)\n * @param {string} value - value to set", " * @param {string} storageType - storage type (local or session)\n * @param {string} value - value to set\n * @example I set 'username' local storage value as 'user1'\n * @example I set '$sessionStorageKey' session storage value as '$sessionStorageValue'\n */\nWhen('I set {string} {word} storage value as {string}', async function (storageKey, storageType, value) {\n    await ClientFunction(function () {\n        const storage: string = storageType + 'Storage';\n        // @ts-ignore\n        window[storage].setItem(storageKey, value);", "        // @ts-ignore\n        window[storage].setItem(storageKey, value);\n    }, {\n        dependencies: {\n            storageKey: await getValue(storageKey),\n            storageType,\n            value: await getValue(value)\n        }\n    }).with({ boundTestRun: t })();\n});\n\n/**\n * Save value of local/session storage to memory\n * @param {string} storageKey - local/session storage key to set value\n * @param {string} storageType - storage type (local or session)\n * @param {string} key - memory key\n * @example I save value of 'username' local storage as 'localStorageValue'\n * @example I save value of '$sessionStorageKey' session storage value as 'sessionStorageValue'\n */\nWhen('I save value of {string} {word} storage as {string}', async function (storageKey, storageType, key) {\n    const value = await ClientFunction(function () {\n        const storage: string = storageType + 'Storage';\n        // @ts-ignore\n        return window[storage].getItem(storageKey);\n    }, {\n        dependencies: {\n            storageKey: await getValue(storageKey),\n            storageType,\n        }", "    }).with({ boundTestRun: t })();\n});\n\n/**\n * Save value of local/session storage to memory\n * @param {string} storageKey - local/session storage key to set value\n * @param {string} storageType - storage type (local or session)\n * @param {string} key - memory key\n * @example I save value of 'username' local storage as 'localStorageValue'\n * @example I save value of '$sessionStorageKey' session storage value as 'sessionStorageValue'\n */\nWhen('I save value of {string} {word} storage as {string}', async function (storageKey, storageType, key) {\n    const value = await ClientFunction(function () {\n        const storage: string = storageType + 'Storage';\n        // @ts-ignore\n        return window[storage].getItem(storageKey);\n    }, {\n        dependencies: {\n            storageKey: await getValue(storageKey),\n            storageType,\n        }", "    }).with({ boundTestRun: t })();\n    memory.setValue(key, value);\n});\n"]}
{"filename": "src/mock.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { getValue } from './transformers';\nimport memory from '@qavajs/memory';\nimport {RequestMock} from 'testcafe';\n\nlet mocks: {[prop: string]: RequestMock} = {};\n/**\n * Create simple mock instance\n * @param {string} urlTemplate - minimatch url template to mock\n * @param {string} memoryKey - memory key to store mock instance", " * @param {string} urlTemplate - minimatch url template to mock\n * @param {string} memoryKey - memory key to store mock instance\n * @example When I create mock for '.+/yourservice/.+' as 'mock1'\n * @example When I create mock for '$mockUrlTemplate' as 'mock1'\n */\nWhen('I create mock for {string} as {string}', async function (urlTemplate: string, memoryKey: string) {\n    const url = await getValue(urlTemplate);\n    memory.setValue(memoryKey, url);\n});\n\nasync function respondWith(mockKey: string, statusCode: string, body: string): Promise<void> {\n    const url: any = await getValue(mockKey);\n    const responseStatusCode: number = parseInt(await getValue(statusCode));\n    const responseBody = await getValue(body);\n    const mockTemplate = typeof url === 'string' ? new RegExp(url, 'g') : url;\n    const response = RequestMock()\n        .onRequestTo(mockTemplate)\n        .respond(\n            responseBody,\n            responseStatusCode,\n            { 'access-control-allow-origin': '*' }\n        );\n    mocks[mockKey] = response;\n    await t.addRequestHooks(response);\n}\n\n/**\n * Add mocking rule to respond with desired status code and payload\n * @param {string} mockKey - memory key to get mock instance\n * @param {string} statusCode - status code\n * @param {string} body - response body\n * @example\n * When I create mock for '/yourservice/**' with filter options as 'myServiceMock'\n * And I set '$myServiceMock' mock to respond '200' with:\n * \"\"\"\n * {\n *     \"status\": \"success\"\n * }\n * \"\"\"\n */\nWhen('I set {string} mock to respond {string} with:', respondWith);\n\n/**\n * Add mocking rule to respond with desired status code and payload\n * @param {string} mockKey - memory key to get mock instance\n * @param {string} statusCode - status code\n * @param {string} body - response body\n * @example\n * When I create mock for '/yourservice/**' with filter options as 'myServiceMock'\n * And I set '$myServiceMock' mock to respond '200' with '$response'\n */\nWhen('I set {string} mock to respond {string} with {string}', respondWith);\n\n/**\n * Restore mock\n * @param {string} mockKey - memory key to get mock instance\n * @example When I restore '$myServiceMock'\n */\nWhen('I restore {string} mock', async function (mockKey: string) {\n    const mock = mocks[mockKey];\n    await t.removeRequestHooks(mock);\n    delete mocks[mockKey];\n});\n\n/**\n * Restore all mocks\n * @example When I restore all mocks\n */\nWhen('I restore all mocks', async function () {\n    await t.removeRequestHooks(...Object.values(mocks));\n    mocks = {};\n});\n", "});\n\nasync function respondWith(mockKey: string, statusCode: string, body: string): Promise<void> {\n    const url: any = await getValue(mockKey);\n    const responseStatusCode: number = parseInt(await getValue(statusCode));\n    const responseBody = await getValue(body);\n    const mockTemplate = typeof url === 'string' ? new RegExp(url, 'g') : url;\n    const response = RequestMock()\n        .onRequestTo(mockTemplate)\n        .respond(\n            responseBody,\n            responseStatusCode,\n            { 'access-control-allow-origin': '*' }\n        );\n    mocks[mockKey] = response;\n    await t.addRequestHooks(response);\n}\n\n/**\n * Add mocking rule to respond with desired status code and payload\n * @param {string} mockKey - memory key to get mock instance\n * @param {string} statusCode - status code\n * @param {string} body - response body\n * @example\n * When I create mock for '/yourservice/**' with filter options as 'myServiceMock'\n * And I set '$myServiceMock' mock to respond '200' with:\n * \"\"\"\n * {\n *     \"status\": \"success\"\n * }\n * \"\"\"\n */\nWhen('I set {string} mock to respond {string} with:', respondWith);\n\n/**\n * Add mocking rule to respond with desired status code and payload\n * @param {string} mockKey - memory key to get mock instance\n * @param {string} statusCode - status code\n * @param {string} body - response body\n * @example\n * When I create mock for '/yourservice/**' with filter options as 'myServiceMock'\n * And I set '$myServiceMock' mock to respond '200' with '$response'\n */\nWhen('I set {string} mock to respond {string} with {string}', respondWith);\n\n/**\n * Restore mock\n * @param {string} mockKey - memory key to get mock instance\n * @example When I restore '$myServiceMock'\n */\nWhen('I restore {string} mock', async function (mockKey: string) {\n    const mock = mocks[mockKey];\n    await t.removeRequestHooks(mock);\n    delete mocks[mockKey];\n});\n\n/**\n * Restore all mocks\n * @example When I restore all mocks\n */\nWhen('I restore all mocks', async function () {\n    await t.removeRequestHooks(...Object.values(mocks));\n    mocks = {};\n});\n"]}
{"filename": "src/poDefine.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\nimport { po, $, $$ } from '@qavajs/po-testcafe';\nimport { getValue } from './transformers';\n\n/**\n * Register selector as page object\n * @param {string} selectorKey - selector to register\n * @param {string} aliasKey - alias of element\n * @example\n * When I define '#someId' as 'My Button' element", " * @example\n * When I define '#someId' as 'My Button' element\n * And I click 'My Button'\n *\n * When I define 'li.selected' as 'Selected Items' collection\n * And I expect number of element in 'Selected Items' collection to equal '3'\n */\nWhen('I define {string} as {string} {testcafePoType}', async function (\n    selectorKey: string, aliasKey: string, poType: string\n) {", "    selectorKey: string, aliasKey: string, poType: string\n) {\n    const selector = await getValue(selectorKey);\n    const alias = (await getValue(aliasKey)).replace(/\\s/g, '');\n    const defineElement = poType === 'element' ? $ : $$;\n    po.register({ [alias]: defineElement(selector) });\n});\n"]}
{"filename": "src/memory.ts", "chunked_list": ["import memory from '@qavajs/memory';\nimport { When } from '@cucumber/cucumber';\nimport { getElement, getValue } from './transformers';\nimport {ClientFunction} from 'testcafe';\n\n/**\n * Save text of element to memory\n * @param {string} alias - element to get value\n * @param {string} key - key to store value\n * @example I save text of '#1 of Search Results' as 'firstSearchResult'", " * @param {string} key - key to store value\n * @example I save text of '#1 of Search Results' as 'firstSearchResult'\n */\nWhen('I save text of {string} as {string}', async function (alias, key) {\n    const element = await getElement(alias);\n    const value = await element.with({ boundTestRun: t }).innerText;\n    memory.setValue(key, value);\n});\n\n/**\n * Save property of element to memory\n * @param {string} property - property to store\n * @param {string} alias - element to get value\n * @param {string} key - key to store value\n * @example I save 'checked' property of 'Checkbox' as 'checked'\n * @example I save '$prop' property of 'Checkbox' as 'checked'\n */\nWhen('I save {string} property of {string} as {string}', async function (property, alias, key) {\n    const element = await getElement(alias);\n    const propertyName = await getValue(property);\n    // @ts-ignore", "    const value = await element.with({ boundTestRun: t })[propertyName];\n    memory.setValue(key, value);\n});\n\n/**\n * Save attribute of element to memory\n * @param {string} attribute - attribute to store\n * @param {string} alias - element to get value\n * @param {string} key - key to store value\n * @example I save 'href' attribute of 'Link' as 'linkHref'\n * @example I save '$prop' attribute of 'Link' as 'linkHref'\n */\nWhen('I save {string} attribute of {string} as {string}', async function (attribute, alias, key) {\n    const element = await getElement(alias);\n    const attributeName = await getValue(attribute);", "    const value = await element.with({ boundTestRun: t }).getAttribute(attributeName);\n    memory.setValue(key, value);\n});\n\n/**\n * Save number of elements in collection to memory\n * @param {string} alias - collection to get value\n * @param {string} key - key to store value\n * @example I save number of elements in 'Search Results' as 'numberOfSearchResults'\n */\nWhen('I save number of elements in {string} collection as {string}', async function (alias, key) {\n    const collection = await getElement(alias);", "    const value = await collection.with({ boundTestRun: t }).count;\n    memory.setValue(key, value);\n});\n\n/**\n * Save array of texts of collection to memory\n * @param {string} alias - collection to get values\n * @param {string} key - key to store value\n * @example I save text of every element of 'Search Results' collection as 'searchResults'\n */\nWhen(\n    'I save text of every element of {string} collection as {string}',\n    async function (alias: string, key: string) {\n        const collection = await getElement(alias);", "        const count = await collection.with({ boundTestRun: t }).count;\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            values.push(await collection.nth(i).with({ boundTestRun: t }).innerText);\n        }\n        memory.setValue(key, values);\n    }\n);\n\n/**\n * Save array of attributes of collection to memory\n * @param {string} alias - collection to get values\n * @param {string} key - key to store value\n * @example I save 'checked' attribute of every element of 'Search > Checkboxes' collection as 'checkboxes'\n */\nWhen(\n    'I save {string} attribute of every element of {string} collection as {string}',\n    async function (attribute: string, alias: string, key: string) {\n        const collection = await getElement(alias);", "        const count = await collection.with({ boundTestRun: t }).count;\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            values.push(await collection.nth(i).with({ boundTestRun: t }).getAttribute(attribute));\n        }\n        memory.setValue(key, values);\n    }\n);\n\n/**\n * Save array of property of collection to memory\n * @param {string} alias - collection to get values\n * @param {string} key - key to store value\n * @example I save 'href' property of every element of 'Search > Links' collection as 'hrefs'\n */\nWhen(\n    'I save {string} property of every element of {string} collection as {string}',\n    async function (property: string, alias: string, key: string) {\n        const propertyName = await getValue(property);\n        const collection = await getElement(alias);", "        const count = await collection.with({ boundTestRun: t }).count;\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            const element = collection.nth(i).with({ boundTestRun: t });\n            // @ts-ignore\n            values.push(await element[propertyName]);\n        }\n        memory.setValue(key, values);\n    }\n);\n\n/**\n * Save current url to memory\n * @param {string} key - key to store value\n * @example I save current url as 'currentUrl'\n */\nWhen('I save current url as {string}', async function (key: string) {\n    const url = await ClientFunction(() => window.location.href )", "        .with({ boundTestRun: t })();\n    memory.setValue(key, url);\n});\n\n/**\n * Save current page title to memory\n * @param {string} key - key to store value\n * @example I save page title as 'currentTitle'\n */\nWhen('I save page title as {string}', async function (key: string) {\n    const title = await ClientFunction(() => window.document.title )", "        .with({ boundTestRun: t })();\n    memory.setValue(key, title);\n});\n\n/**\n * Save page screenshot into memory\n * @param {string} key - key to store value\n * @example I save screenshot as 'screenshot'\n */\nWhen('I save screenshot as {string}', async function(key: string) {\n    const screenshot = await t.takeScreenshot();\n    memory.setValue(key, screenshot);\n});\n\n/**\n * Save css property of element to memory\n * @param {string} property - property to store\n * @param {string} alias - element to get value\n * @param {string} key - key to store value\n * @example I save 'color' css property of 'Checkbox' as 'checkboxColor'\n * @example I save '$propertyName' property of 'Checkbox' as 'checkboxColor'\n */\nWhen('I save {string} css property of {string} as {string}', async function (property, alias, key) {\n    const element = await getElement(alias);\n    const propertyName = await getValue(property);\n    const value = await ClientFunction(() => {\n        // @ts-ignore\n        return getComputedStyle(element()).getPropertyValue(propertyName)", "    }, { dependencies: { element, propertyName }}).with({ boundTestRun: t })();\n    memory.setValue(key, value);\n});\n"]}
{"filename": "src/valueWait.ts", "chunked_list": ["function regexp(regexpLike: string | RegExp) {\n    if (typeof regexpLike === 'string') {\n        return new RegExp(regexpLike, 'gmi')\n    }\n    return regexpLike\n}\n\nexport const valueValidations = {\n    EQUAL: 'equal',\n    CONTAIN: 'contain',\n    ABOVE: 'above',\n    BELOW: 'below',\n    MATCH: 'match'\n}\n\nconst notClause = '(not )?';\nconst toBeClause = 'to (?:be )?';\nconst validationClause = `(${Object.values(valueValidations).join('|')})`;\n\nexport const valueWaitExtractRegexp = new RegExp(`^${notClause}${toBeClause}${validationClause}$`);\nexport const valueWaitRegexp = new RegExp(`(${notClause}${toBeClause}${validationClause})`);\n\nconst waits = {\n    [valueValidations.EQUAL]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n        reverse\n            ? poll.notEql(expected, message, { timeout })\n            : poll.eql(expected, message, { timeout }),\n    [valueValidations.CONTAIN]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n        reverse\n            ? poll.notContains(expected, message, { timeout })\n            : poll.contains(expected, message, { timeout }),\n    [valueValidations.ABOVE]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n        reverse\n            ? poll.lte(parseFloat(expected), message, { timeout })\n            : poll.gt(parseFloat(expected), message, { timeout }),\n    [valueValidations.BELOW]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n        reverse\n            ? poll.gte(parseFloat(expected), message, { timeout })\n            : poll.lt(parseFloat(expected), message, { timeout }),\n    [valueValidations.MATCH]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n        reverse\n            ? poll.notMatch(regexp(expected), message, { timeout })\n            : poll.match(regexp(expected), message, { timeout })\n}\n\n/**\n * Wait for condition", " * @param {any} valueFn - function to return value\n * @param {any} expected - expected value\n * @param {string} validationType - validation to perform\n * @param {number} [timeout] - timeout to wait\n * @param {boolean} [reverse] - negate flag\n * @return {Promise<void>}\n */\nexport async function valueWait(\n    valueFn: ClientFunction | Selector,\n    expected: any,\n    validationType: string,\n    timeout: number = 10000,\n    reverse: boolean\n) {\n    const message: string = `Value is${reverse ? '' : ' not'} ${validationType} ${expected}`;\n    const waitFn = waits[validationType];\n    const poll: Assertion = t.expect(valueFn);\n    await waitFn(poll, expected, reverse, timeout, message);\n}\n"]}
{"filename": "src/validations.ts", "chunked_list": ["import { Then } from '@cucumber/cucumber';\nimport { getValue, getElement, getConditionWait } from './transformers';\nimport { getValidation } from '@qavajs/validation';\nimport { ClientFunction } from 'testcafe';\n\n/**\n * Verify element condition\n * @param {string} alias - element to wait condition\n * @param {string} condition - wait condition\n * @example I expect 'Header' to be visible", " * @param {string} condition - wait condition\n * @example I expect 'Header' to be visible\n * @example I expect 'Loading' not to be present\n * @example I expect 'Search Bar > Submit Button' to be clickable\n */\nThen('I expect {string} {testcafeConditionWait}', async function (alias: string, condition: string) {\n    const element = await getElement(alias);\n    const wait = getConditionWait(condition);\n    await wait(element, config.browser.timeout.page);\n});", "    await wait(element, config.browser.timeout.page);\n});\n\n/**\n * Verify that text of element satisfies condition\n * @param {string} alias - element to get text\n * @param {string} validationType - validation\n * @param {string} value - expected result\n * @example I expect text of '#1 of Search Results' equals to 'google'\n * @example I expect text of '#2 of Search Results' does not contain 'yandex'", " * @example I expect text of '#1 of Search Results' equals to 'google'\n * @example I expect text of '#2 of Search Results' does not contain 'yandex'\n */\nThen(\n    'I expect text of {string} {testcafeValidation} {string}',\n    async function (alias: string, validationType: string, value: any) {\n        const expectedValue = await getValue(value);\n        const element = await getElement(alias);\n        const validation = getValidation(validationType);\n        const elementText: string = await element.with({ boundTestRun: t }).innerText;\n        this.log(`AR: ${elementText}`);\n        this.log(`ER: ${expectedValue}`);\n        validation(elementText, expectedValue);\n    }\n);\n\n/**\n * Verify that property of element satisfies condition\n * @param {string} property - element to verify\n * @param {string} alias - element to verify\n * @param {string} validationType - validation\n * @param {string} value - expected value\n * @example I expect 'value' property of 'Search Input' to be equal 'text'\n * @example I expect 'innerHTML' property of 'Label' to contain '<b>'\n */\nThen(\n    'I expect {string} property of {string} {testcafeValidation} {string}',\n    async function (property: string, alias: string, validationType: string, value: string) {\n        const propertyName = await getValue(property);\n        const expectedValue = await getValue(value);\n        const element = await getElement(alias);\n        const validation = getValidation(validationType);\n        // @ts-ignore", "        const validation = getValidation(validationType);\n        const elementText: string = await element.with({ boundTestRun: t }).innerText;\n        this.log(`AR: ${elementText}`);\n        this.log(`ER: ${expectedValue}`);\n        validation(elementText, expectedValue);\n    }\n);\n\n/**\n * Verify that property of element satisfies condition\n * @param {string} property - element to verify\n * @param {string} alias - element to verify\n * @param {string} validationType - validation\n * @param {string} value - expected value\n * @example I expect 'value' property of 'Search Input' to be equal 'text'\n * @example I expect 'innerHTML' property of 'Label' to contain '<b>'\n */\nThen(\n    'I expect {string} property of {string} {testcafeValidation} {string}',\n    async function (property: string, alias: string, validationType: string, value: string) {\n        const propertyName = await getValue(property);\n        const expectedValue = await getValue(value);\n        const element = await getElement(alias);\n        const validation = getValidation(validationType);\n        // @ts-ignore", "        const actualValue: string = await element.with({ boundTestRun: t })[propertyName];\n        this.log(`AR: ${actualValue}`);\n        this.log(`ER: ${expectedValue}`);\n        validation(actualValue, expectedValue);\n    }\n);\n\n/**\n * Verify that attribute of element satisfies condition\n * @param {string} attribute - element to verify\n * @param {string} alias - element to verify\n * @param {string} validationType - validation\n * @param {string} value - expected value\n * @example I expect 'href' attribute of 'Home Link' to contain '/home'\n */\nThen(\n    'I expect {string} attribute of {string} {testcafeValidation} {string}',\n    async function (attribute: string, alias: string, validationType: string, value: string) {\n        const attributeName = await getValue(attribute);\n        const expectedValue = await getValue(value);\n        const element = await getElement(alias);\n        const validation = getValidation(validationType);", "        const actualValue: string | null = await element.with({ boundTestRun: t }).getAttribute(attributeName);\n        this.log(`AR: ${actualValue}`);\n        this.log(`ER: ${expectedValue}`);\n        validation(actualValue, expectedValue);\n    }\n);\n\n/**\n * Verify that current url satisfies condition\n * @param {string} validationType - validation\n * @param {string} expected - expected value\n * @example I expect current url contains 'wikipedia'\n * @example I expect current url equals 'https://wikipedia.org'\n */\nThen(\n    'I expect current url {testcafeValidation} {string}',\n    async function (validationType: string, expected: string) {\n        const validation = getValidation(validationType);\n        const expectedUrl = await getValue(expected);\n        const actualUrl = await ClientFunction(() => window.location.href )", "            .with({ boundTestRun: t })();\n        this.log(`AR: ${actualUrl}`);\n        this.log(`ER: ${expectedUrl}`);\n        validation(actualUrl, expectedUrl);\n    }\n);\n//\n/**\n * Verify that number of element in collection satisfies condition\n * @param {string} alias - collection to verify\n * @param {string} validationType - validation\n * @param {string} value - expected value\n * @example I expect number of elements in 'Search Results' collection to be equal '50'\n * @example I expect number of elements in 'Search Results' collection to be above '49'\n * @example I expect number of elements in 'Search Results' collection to be below '51'\n */\nThen(\n    'I expect number of elements in {string} collection {testcafeValidation} {string}',\n    async function (alias: string, validationType: string, value: string) {\n        const expectedValue = await getValue(value);\n        const collection = await getElement(alias);\n        const validation = getValidation(validationType);", "        const actualCount = await collection.with({ boundTestRun: t }).count;\n        this.log(`AR: ${actualCount}`);\n        this.log(`ER: ${expectedValue}`);\n        validation(actualCount, expectedValue);\n    }\n);\n\n/**\n * Verify that page title satisfies condition\n * @param {string} validationType - validation\n * @param {string} expected - expected value\n * @example I expect page title equals 'Wikipedia'\n */\nThen(\n    'I expect page title {testcafeValidation} {string}',\n    async function (validationType: string, expected: string) {\n        const validation = getValidation(validationType);\n        const expectedTitle = await getValue(expected);\n        const actualTitle = await ClientFunction(() => window.document.title )", "            .with({ boundTestRun: t })();\n        this.log(`AR: ${actualTitle}`);\n        this.log(`ER: ${expectedTitle}`);\n        validation(actualTitle, expectedTitle);\n    }\n);\n\n/**\n * Verify that all texts in collection satisfy condition\n * @param {string} alias - collection to get texts\n * @param {string} validationType - validation\n * @param {string} value - expected result\n * @example I expect text of every element in 'Search Results' collection equals to 'google'\n * @example I expect text of every element in 'Search Results' collection does not contain 'yandex'\n */\nThen(\n    'I expect text of every element in {string} collection {testcafeValidation} {string}',\n    async function (alias: string, validationType: string, value: string) {\n        const expectedValue = await getValue(value);\n        const collection = await getElement(alias);\n        const validation = getValidation(validationType);", "        const count = await collection.with({ boundTestRun: t }).count;\n        for (let i = 0; i < count; i++) {\n            const text = await collection.nth(i).with({ boundTestRun: t }).innerText;\n            validation(text, expectedValue);\n        }\n    }\n);\n\n/**\n * Verify that all particular attributes in collection satisfy condition\n * @param {string} alias - collection to get attrs\n * @param {string} validationType - validation\n * @param {string} value - expected result\n * @example I expect 'href' attribute of every element in 'Search Results' collection to contain 'google'\n */\nThen(\n    'I expect {string} attribute of every element in {string} collection {testcafeValidation} {string}',\n    async function (attributeKey: string, alias: string, validationType: string, value: string) {\n        const attribute = await getValue(attributeKey);\n        const expectedValue = await getValue(value);\n        const collection = await getElement(alias);\n        const validation = getValidation(validationType);", "        const count = await collection.with({ boundTestRun: t }).count;\n        for (let i = 0; i < count; i++) {\n            const attr = await collection.nth(i).with({ boundTestRun: t }).getAttribute(attribute);\n            validation(attr, expectedValue);\n        }\n    }\n);\n\n/**\n * Verify that all particular properties in collection satisfy condition\n * @param {string} alias - collection to get props\n * @param {string} validationType - validation\n * @param {string} value - expected result\n * @example I expect 'href' property of every element in 'Search Results' collection to contain 'google'\n */\nThen(\n    'I expect {string} property of every element in {string} collection {testcafeValidation} {string}',\n    async function (propertyKey: string, alias: string, validationType: string, value: string) {\n        const property = await getValue(propertyKey);\n        const expectedValue = await getValue(value);\n        const collection = await getElement(alias);\n        const validation = getValidation(validationType);\n", "        const count = await collection.with({ boundTestRun: t }).count;\n        for (let i = 0; i < count; i++) {\n            // @ts-ignore\n            const prop = await collection.nth(i).with({ boundTestRun: t })[property];\n            validation(prop, expectedValue);\n        }\n    }\n);\n\n/**\n * Verify that css property of element satisfies condition\n * @param {string} property - element to verify\n * @param {string} alias - element to verify\n * @param {string} validationType - validation\n * @param {string} value - expected value\n * @example I expect 'color' css property of 'Search Input' to be equal 'rgb(42, 42, 42)'\n * @example I expect 'font-family' css property of 'Label' to contain 'Fira'\n */\nThen(\n    'I expect {string} css property of {string} {testcafeValidation} {string}',\n    async function (property: string, alias: string, validationType: string, value: string) {\n        const propertyName = await getValue(property);\n        const expectedValue = await getValue(value);\n        const element = await getElement(alias);\n        const validation = getValidation(validationType);\n        const actualValue = await ClientFunction(() => {\n            // @ts-ignore\n            return getComputedStyle(element()).getPropertyValue(propertyName)", "        }, { dependencies: { element, propertyName }}).with({ boundTestRun: t })();\n        this.log(`AR: ${actualValue}`);\n        this.log(`ER: ${expectedValue}`);\n        validation(actualValue, expectedValue);\n    }\n);\n\n// /**\n//  * Verify that text of an alert meets expectation\n//  * @param {string} validationType - validation\n//  * @param {string} value - expected text value\n//  * @example I expect text of alert does not contain 'coffee'\n//  */\n// Then('I expect text of alert {testcafeValidation} {string}', async function (validationType: string, expectedValue: string) {\n//         const alertText = await new Promise<string>(resolve => page.once('dialog', async (dialog) => {\n//             resolve(dialog.message());\n//         }));\n//         const expected = await getValue(expectedValue);\n//         const validation = getValidation(validationType);\n//         this.log(`AR: ${alertText}`);\n//         this.log(`ER: ${expected}`);\n//         validation(alertText, expectedValue);\n//     }\n// );\n"]}
{"filename": "src/testController/bootstrap.ts", "chunked_list": ["import testController from './testController';\nfixture`qavajs`;\ntest('testcafe', testController.setup);\n"]}
{"filename": "src/testController/testController.ts", "chunked_list": ["const testController = {\n    testController: null,\n    setup: function(t: TestController) {\n        global.t = t;\n        return new Promise(() => {});\n    },\n    get: function() {\n        return testController.testController;\n    }\n};", "    }\n};\n\nexport default testController;\n"]}
{"filename": "src/utils/screenshotEvent.ts", "chunked_list": ["export enum ScreenshotEvent {\n    ON_FAIL = 'onFail',\n    BEFORE_STEP = 'beforeStep',\n    AFTER_STEP = 'afterStep'\n}\n"]}
{"filename": "src/utils/utils.ts", "chunked_list": ["import { ScreenshotEvent } from './screenshotEvent';\nimport { TraceEvent } from './traceEvent';\nimport { Status, ITestStepHookParameter, ITestCaseHookParameter } from '@cucumber/cucumber';\nimport { join } from 'path';\nimport { readFile } from 'fs/promises';\n\nexport function saveScreenshotAfterStep(config: any, step: ITestStepHookParameter): boolean {\n    const isAfterStepScreenshot = equalOrIncludes(config.screenshot, ScreenshotEvent.AFTER_STEP);\n    const isOnFailScreenshot = equalOrIncludes(config.screenshot, ScreenshotEvent.ON_FAIL);\n    return (isOnFailScreenshot && step.result.status === Status.FAILED) || isAfterStepScreenshot\n}\n", "export function saveScreenshotBeforeStep(config: any): boolean {\n    return equalOrIncludes(config.screenshot, ScreenshotEvent.BEFORE_STEP)\n}\n\nexport function saveTrace(driverConfig: any, scenario: ITestCaseHookParameter): boolean {\n    return driverConfig?.trace && (\n        (equalOrIncludes(driverConfig?.trace.event, TraceEvent.AFTER_SCENARIO)) ||\n        (scenario.result?.status === Status.FAILED && equalOrIncludes(driverConfig?.trace.event, TraceEvent.ON_FAIL))\n    )\n}\n", "function normalizeScenarioName(name: string): string {\n    return name.replace(/\\W/g, '-')\n}\n\nexport function traceArchive(driverConfig: any, scenario: ITestCaseHookParameter): string {\n    return join(\n        driverConfig.trace?.dir ?? 'traces',\n        `${normalizeScenarioName(scenario.pickle.name)}-${scenario.testCaseStartedId}.zip`\n    )\n}\n\n/**\n * Parse 'x, y' string to coordinates array\n * @param {string} coords - 'x, y' string\n * @return {number[]} - coords array\n */", "export function parseCoords(coords: string): number[] {\n    return coords.split(/\\s?,\\s?/).map((c: string) => parseFloat(c ?? 0))\n}\n\nexport function equalOrIncludes(value: string | string[], argument: string) {\n    return Array.isArray(value)\n        ? value.includes(argument)\n        : value === argument;\n}\n\nexport async function throwTimeoutError(fn: Function, message: string) {", "export async function throwTimeoutError(fn: Function, message: string) {\n    try {\n        await fn()\n    } catch (err: any) {\n        if (err.message.includes('exceeded while waiting on the predicate')) {\n            throw new Error(message);\n        }\n        throw err\n    }\n}\n", "export async function takeScreenshot(): Promise<string> {\n    const screenshotPath = await t.takeScreenshot();\n    const screenshot = await readFile(screenshotPath);\n    return screenshot.toString('base64');\n}\n\nexport function isChromium(browserName: string): boolean {\n   return browserName.includes('chrom')\n}\n"]}
{"filename": "src/utils/traceEvent.ts", "chunked_list": ["export enum TraceEvent {\n    ON_FAIL = 'onFail',\n    AFTER_SCENARIO = 'afterScenario'\n}\n"]}
