{"filename": "src/Watchman.service.ts", "chunked_list": ["import { HttpStatus, Injectable } from '@nestjs/common';\nimport { Request, Response } from 'express';\nimport { BaseStrategy } from './strategies';\nimport {\n  IException,\n  WatchData,\n  WatchmanModuleOptions,\n  WatchMetaData,\n} from './interfaces';\n", "} from './interfaces';\n\n@Injectable()\nexport class WatchmanService {\n  constructor(\n    private options: Partial<WatchmanModuleOptions>,\n    private strategy: BaseStrategy,\n  ) {}\n\n  public setStrategy(strategy: BaseStrategy) {\n    this.strategy = strategy;\n  }\n\n  public watch(exception: IException, data: WatchData): void {\n    const { host, trackUUID, metaData } = data;\n    let _host: WatchMetaData = null;", "    if (host) {\n      const ctx = host.switchToHttp();\n      _host = {\n        request: ctx.getRequest<Request>(),\n        response: ctx.getResponse<Response>(),\n      };\n    }\n    const status =\n      'getStatus' in exception\n        ? exception.getStatus()\n        : HttpStatus.INTERNAL_SERVER_ERROR;", "    if (trackUUID) exception.uuid = trackUUID;\n    if (status === HttpStatus.INTERNAL_SERVER_ERROR)\n      return this.strategy.execute(exception, status, _host, metaData);\n    if (this.options && this.options.catchOnlyInternalExceptions) return;\n    return this.strategy.execute(exception, status, _host, metaData);\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './Watchman.module';\nexport * from './Watchman.service';\nexport * from './strategies/export.strategy';\nexport * from './interfaces';\nexport * from './constants';\n"]}
{"filename": "src/Watchman.module.ts", "chunked_list": ["import { HttpModule } from '@nestjs/axios';\nimport { DynamicModule, Module, Provider, Type } from '@nestjs/common';\nimport { WatchmanService } from './Watchman.service';\nimport {\n  WatchmanModuleAsyncOptions,\n  WatchmanModuleFactory,\n  WatchmanModuleOptions,\n} from './interfaces';\nimport { STRATEGY_TOKEN, Watchman_OPTIONS } from './constants';\nimport {", "import { STRATEGY_TOKEN, Watchman_OPTIONS } from './constants';\nimport {\n  BaseStrategy,\n  injectStrategies,\n  strategyDependenciesProviders,\n  strategyProviders,\n} from './strategies';\n\n@Module({})\nexport class WatchmanModule {\n  static forRoot(option: WatchmanModuleOptions): DynamicModule {\n    const provider: Provider<any> = {\n      provide: WatchmanService,\n      useFactory: (config: WatchmanModuleOptions, ...args: BaseStrategy[]) => {", "@Module({})\nexport class WatchmanModule {\n  static forRoot(option: WatchmanModuleOptions): DynamicModule {\n    const provider: Provider<any> = {\n      provide: WatchmanService,\n      useFactory: (config: WatchmanModuleOptions, ...args: BaseStrategy[]) => {\n        if (!option.strategy) throw new Error('Please Provide Strategy class');\n        const loadedStrategy = args.find(\n          (injectedStrategy) =>\n            injectedStrategy && injectedStrategy instanceof option.strategy,\n        );", "        if (!config.strategyConfig)\n          throw new Error('Please set your config in strategyConfig object');\n        return new WatchmanService(config, loadedStrategy);\n      },\n      inject: [Watchman_OPTIONS, ...injectStrategies],\n    };\n\n    return {\n      providers: [\n        provider,\n        { provide: Watchman_OPTIONS, useValue: option },\n        ...strategyDependenciesProviders,\n        ...strategyProviders,\n      ],\n      exports: [provider],\n      module: WatchmanModule,\n      imports: [HttpModule],\n    };\n  }\n  static forRootAsync(options: WatchmanModuleAsyncOptions): DynamicModule {\n    const provider: Provider = {\n      provide: WatchmanService,\n      useFactory: async (\n        config: WatchmanModuleOptions,\n        ...args: BaseStrategy[]\n      ) => {\n        const strategy = options.strategy || config.strategy;", "        if (!strategy) throw new Error('Please Provide Strategy class');\n        const loadedStrategy = args.find(\n          (injectedStrategy) =>\n            injectedStrategy && injectedStrategy instanceof strategy,\n        );\n        if (!options.strategy) {\n          if (!config.strategyConfig)\n            throw new Error('Please set your config in strategyConfig object');\n        }\n\n        return new WatchmanService(config, loadedStrategy);\n      },\n      inject: [\n        { token: Watchman_OPTIONS, optional: true },\n        { token: STRATEGY_TOKEN, optional: true },\n        ...injectStrategies,\n      ],\n    };\n\n    return {\n      module: WatchmanModule,\n      imports: [...(options.imports || []), HttpModule],\n      providers: [\n        ...this.createAsyncProviders(options),\n        provider,\n        ...strategyProviders,\n        ...strategyDependenciesProviders,\n        {\n          provide: STRATEGY_TOKEN,\n          useClass: options.strategy,\n        },\n      ],\n      exports: [provider],\n    };\n  }\n\n  private static createAsyncProviders(\n    options: WatchmanModuleAsyncOptions,\n  ): Provider[] {", "    if (options.useExisting || options.useFactory) {\n      return [this.createAsyncOptionsProvider(options)];\n    }\n\n    const useClass = options.useClass as Type<WatchmanModuleFactory>;\n    if (useClass)\n      return [\n        this.createAsyncOptionsProvider(options),\n        {\n          provide: useClass,\n          useClass,\n        },\n      ];\n\n    return [\n      {\n        provide: Watchman_OPTIONS,\n        useValue: null,\n      },\n    ];\n  }\n\n  private static createAsyncOptionsProvider(\n    options: WatchmanModuleAsyncOptions,\n  ): Provider {", "    if (options.useFactory) {\n      return {\n        provide: Watchman_OPTIONS,\n        useFactory: options.useFactory,\n        inject: options.inject || [],\n      };\n    }\n\n    const inject = [\n      (options.useClass || options.useExisting) as Type<WatchmanModuleFactory>,\n    ];\n\n    return {\n      provide: Watchman_OPTIONS,\n      useFactory: async (optionsFactory: WatchmanModuleFactory) =>\n        await optionsFactory.createWatchmanModuleOptions(),\n      inject,\n    };\n  }\n}\n"]}
{"filename": "src/strategies/export.strategy.ts", "chunked_list": ["export * from './discord.strategy';\n"]}
{"filename": "src/strategies/base.strategy.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport { Inject } from '@nestjs/common';\nimport { Watchman_OPTIONS } from '../constants';\nimport {\n  DiscordConfig,\n  IException,\n  WatchmanModuleOptions,\n  WatchMetaData,\n} from '../interfaces';\n\ntype StrategyConfig = WatchmanModuleOptions['strategyConfig'];", "} from '../interfaces';\n\ntype StrategyConfig = WatchmanModuleOptions['strategyConfig'];\nexport abstract class BaseStrategy {\n  private _statusCode: number;\n  private _exception: IException;\n  private _request: Request;\n  private _response: Response;\n  private _filePath: string;\n  private _fileName: string;\n  private _metaData: any;\n  private strategyConfig: StrategyConfig;\n\n  @Inject(Watchman_OPTIONS)\n  private _options: WatchmanModuleOptions = {\n    strategyConfig: null,\n    catchOnlyInternalExceptions: false,\n  };\n\n  execute(\n    exception: IException,\n    statusCode: number,\n    host: WatchMetaData,\n    metaDta: any,\n  ): void {\n    {\n      this._statusCode = statusCode || null;\n      this._exception = exception || null;\n      this._request = host?.request || null;\n      this._response = host?.response || null;\n      this._metaData = metaDta || null;\n      this._filePath = this.extractErrorPath(this._exception.stack);\n      this._fileName =\n        this._filePath && this.extractErrorFileNameFromPath(this._filePath);\n      let message;", "      if (!!host) message = this.withHostMessageFormat();\n      else message = this.simpleMessageFormat();\n      this.send(message);\n    }\n  }\n\n  get statusCode(): number {\n    return this._statusCode;\n  }\n\n  get exception(): IException {\n    return this._exception;\n  }\n\n  get metaData(): any {\n    return this._metaData;\n  }\n\n  get request(): Request {\n    return this._request;\n  }\n\n  get response(): Response {\n    return this._response;\n  }\n\n  get filePath(): string {\n    return this._filePath;\n  }\n\n  get fileName(): string {\n    return this._fileName;\n  }\n\n  get config(): StrategyConfig {", "    if (!this.strategyConfig) return this._options.strategyConfig;\n    return this.strategyConfig;\n  }\n\n  set config(config: StrategyConfig) {\n    this.strategyConfig = config;\n  }\n\n  private extractErrorFileNameFromPath(path: string): string | null {\n    return (\n      path\n        .slice(path.lastIndexOf('/'))\n        .replace('/', '')\n        .replace(/\\(|\\)/gi, '') || null\n    );\n  }\n\n  private extractErrorPath(errorStack: string): string | null {\n    errorStack = errorStack.slice(errorStack.indexOf('\\n'));\n    const firstIndex = errorStack.indexOf('/');\n    const nextIndex = errorStack.indexOf('\\n', errorStack.indexOf('/'));\n\n    const path = errorStack.slice(firstIndex, nextIndex);\n    const uselessPaths = path.match(\n      /node_modules|internal|streams|stream_base_commons|task_queues/gi,\n    );", "    if (uselessPaths && uselessPaths.length) {\n      return this.extractErrorPath(errorStack.slice(nextIndex));\n    }\n    return path || null;\n  }\n\n  abstract send(messageBody): unknown;\n\n  abstract withHostMessageFormat(): unknown;\n\n  abstract simpleMessageFormat(): unknown;\n}\n"]}
{"filename": "src/strategies/discord.strategy.ts", "chunked_list": ["import { HttpService } from '@nestjs/axios';\nimport { Inject, Injectable, Optional } from '@nestjs/common';\nimport { Subscription } from 'rxjs';\nimport { EmbedBuilder } from 'discord.js';\nimport { BaseStrategy } from './base.strategy';\nimport { DiscordConfig, IDiscordBody } from '../interfaces';\n\n@Injectable()\nexport class DiscordBaseStrategy extends BaseStrategy {\n  @Inject()\n  private httpService: HttpService;\n\n  @Inject(EmbedBuilder.name)\n  embedBuilder: EmbedBuilder;\n\n  constructor(@Optional() discordConfig?: DiscordConfig) {\n    super();", "export class DiscordBaseStrategy extends BaseStrategy {\n  @Inject()\n  private httpService: HttpService;\n\n  @Inject(EmbedBuilder.name)\n  embedBuilder: EmbedBuilder;\n\n  constructor(@Optional() discordConfig?: DiscordConfig) {\n    super();\n    if (discordConfig) this.config = discordConfig;\n  }\n\n  send(discordBody: IDiscordBody): Subscription {\n    return this.httpService\n      .post(this.config.webHookUrl, discordBody)\n      .subscribe();\n  }\n\n  private mention(mentionList: Array<'here' | 'everyone' | string>): string {\n    return mentionList\n      .map((person) =>\n        person === 'here' || person === 'everyone'\n          ? `@${person}`\n          : `<@${person}>`,\n      )\n      .join(', ');\n  }\n  withHostMessageFormat(): IDiscordBody {\n    const embed = this.embedBuilder\n      .setColor(0xff0000)\n      .setTitle(this.exception.name)\n      .setFields(\n        {\n          name: 'Occurred In',\n          value: this.fileName || 'ExceptionHandler',\n        },\n        {\n          name: 'Route',\n          value: this.request.path,\n          inline: true,\n        },\n        {\n          name: 'Http Method',\n          value: this.request.method,\n          inline: true,\n        },\n        {\n          name: 'Trace',\n          value: this.exception?.stack.slice(0, 1020) + '...',\n        },\n      )\n      .setTimestamp()\n      .setFooter({\n        text: 'Happened At ',\n        iconURL: 'https://i.imgur.com/AfFp7pu.png',\n      });", "    if (discordConfig) this.config = discordConfig;\n  }\n\n  send(discordBody: IDiscordBody): Subscription {\n    return this.httpService\n      .post(this.config.webHookUrl, discordBody)\n      .subscribe();\n  }\n\n  private mention(mentionList: Array<'here' | 'everyone' | string>): string {\n    return mentionList\n      .map((person) =>\n        person === 'here' || person === 'everyone'\n          ? `@${person}`\n          : `<@${person}>`,\n      )\n      .join(', ');\n  }\n  withHostMessageFormat(): IDiscordBody {\n    const embed = this.embedBuilder\n      .setColor(0xff0000)\n      .setTitle(this.exception.name)\n      .setFields(\n        {\n          name: 'Occurred In',\n          value: this.fileName || 'ExceptionHandler',\n        },\n        {\n          name: 'Route',\n          value: this.request.path,\n          inline: true,\n        },\n        {\n          name: 'Http Method',\n          value: this.request.method,\n          inline: true,\n        },\n        {\n          name: 'Trace',\n          value: this.exception?.stack.slice(0, 1020) + '...',\n        },\n      )\n      .setTimestamp()\n      .setFooter({\n        text: 'Happened At ',\n        iconURL: 'https://i.imgur.com/AfFp7pu.png',\n      });", "    if (this.exception.uuid)\n      embed.addFields({ name: 'Tracking Id', value: this.exception.uuid });\n    const discordBody: IDiscordBody = {\n      embeds: [embed],\n    };\n    if (this.config.mentionList && this.config.mentionList.length)\n      discordBody.content = this.mention(this.config.mentionList);\n    return discordBody;\n  }\n\n  simpleMessageFormat(): IDiscordBody {\n    /**\n     * @see {@link https://discordjs.guide/popular-topics/embeds.html#embed-preview}\n     * **/\n    const embed = this.embedBuilder\n      .setColor(0xff0000)\n      .setTitle(this.exception.name)\n      .setFields(\n        {\n          name: 'Occurred In',\n          value: this.fileName || 'ExceptionHandler',\n        },\n        {\n          name: 'Trace',\n          value: this.exception?.stack.slice(0, 1020) + '...',\n        },\n      )\n      .setTimestamp()\n      .setFooter({\n        text: 'Happened At ',\n        iconURL: 'https://i.imgur.com/AfFp7pu.png',\n      });", "    if (this.exception.uuid)\n      embed.addFields({ name: 'Tracking Id', value: this.exception.uuid });\n    const discordBody: IDiscordBody = {\n      embeds: [embed],\n    };\n    if (this.config.mentionList && this.config.mentionList.length)\n      discordBody.content = this.mention(this.config.mentionList);\n    return discordBody;\n  }\n}\n"]}
{"filename": "src/strategies/index.ts", "chunked_list": ["import {\n  InjectionToken,\n  OptionalFactoryDependency,\n  Provider,\n} from '@nestjs/common';\nimport { DiscordBaseStrategy } from './discord.strategy';\nimport { BaseStrategy } from './base.strategy';\nimport { EmbedBuilder } from 'discord.js';\n\n// export from here to access locally", "\n// export from here to access locally\nexport { DiscordBaseStrategy, BaseStrategy };\nexport const injectStrategies: Array<\n  InjectionToken | OptionalFactoryDependency\n> = [DiscordBaseStrategy];\nexport const strategyProviders: Array<Provider<any>> = [DiscordBaseStrategy];\n\nexport const strategyDependenciesProviders: Array<Provider<any>> = [\n  {", "export const strategyDependenciesProviders: Array<Provider<any>> = [\n  {\n    provide: EmbedBuilder.name,\n    useClass: EmbedBuilder,\n  },\n];\n"]}
{"filename": "src/constants/provider-names.ts", "chunked_list": ["export const Watchman_OPTIONS = 'WatchmanOptions';\nexport const STRATEGY_TOKEN = 'STRATEGY';\n"]}
{"filename": "src/constants/index.ts", "chunked_list": ["export * from './provider-names';\n"]}
{"filename": "src/interfaces/module.interface.ts", "chunked_list": ["import { ArgumentsHost, ModuleMetadata, Type } from '@nestjs/common';\nimport { DiscordConfig } from './discord.interface';\nimport { Request, Response } from 'express';\n\nexport interface WatchmanModuleAsyncOptions\n  extends Pick<ModuleMetadata, 'imports'> {\n  strategy?: any;\n  inject?: any[];\n  useClass?: Type<WatchmanModuleFactory>;\n  useExisting?: Type<WatchmanModuleFactory>;\n  useFactory?: (\n    ...args: any[]\n  ) => Promise<WatchmanModuleOptions> | WatchmanModuleOptions;\n}", "export interface WatchmanModuleOptions {\n  /**\n   * @default false\n   * */\n  catchOnlyInternalExceptions?: boolean;\n  strategy?: any;\n  strategyConfig?: DiscordConfig;\n}\n\nexport interface WatchmanModuleFactory {\n  createWatchmanModuleOptions: () =>\n    | Promise<WatchmanModuleOptions>\n    | WatchmanModuleOptions;\n}\n", "export interface WatchmanModuleFactory {\n  createWatchmanModuleOptions: () =>\n    | Promise<WatchmanModuleOptions>\n    | WatchmanModuleOptions;\n}\n\nexport interface WatchMetaData {\n  request: Request;\n  response: Response;\n}\n", "export interface WatchData {\n  host?: ArgumentsHost | null;\n  trackUUID?: string | null;\n  metaData?: any;\n}\n"]}
{"filename": "src/interfaces/discord.interface.ts", "chunked_list": ["import { EmbedBuilder } from '@discordjs/builders';\n\nexport interface DiscordConfig {\n  webHookUrl: string;\n  /**\n   * @description you can use \"here\" and \"everyone\" to mention or set a userId or roleId to mention persons. note that don't pass @ in mention text\n   * @see  {@link https://support.discord.com/hc/en-us/articles/206346498-Where-can-I-find-my-User-Server-Message-ID- Where can I find my User OR Role ID}\n   * */\n  mentionList?: Array<'here' | 'everyone' | string>;\n}\n", "export interface IDiscordBody {\n  /**\n   * @description the message contents (up to 2000 characters)\n   */\n  content?: string;\n\n  /**\n   * @description override the default username of the webhook\n   */\n  username?: string;\n\n  /**\n   * @description override the default avatar of the webhook\n   */\n  avatar_url?: string;\n\n  /**\n   * @description true if this is a TTS message\n   */\n  tts?: boolean;\n\n  /**\n   * @description message can be generated in embeds\n   * @overview Array of up to 10 embed objects\n   * @see {@link https://discord.com/developers/docs/resources/channel#embed-object Embed Object Structure}\n   * @see {@link https://discordjs.guide/popular-topics/embeds.html#embed-preview How To Generate Embeds With EmbedBuilder Class}\n   */\n  embeds?: Array<EmbedBuilder | Embedded>;\n\n  /**\n   * @description allowed mentions for the message", "   * @type  allowed mention object\n   * @see {@link https://discord.com/developers/docs/resources/channel#allowed-mentions-objectallowed }\n   */\n  allowed_mentions?: AllowedMentions;\n\n  /**\n   * @description the components to include with the message\n   * @type  array of message component\n   * @see {@link https://discord.com/developers/docs/interactions/message-components#component-objectmessage }\n   */\n  components?: Array<string>;\n\n  /**\n   * @description the contents of the file being sent", "   * @type  file contents\n   */\n  files?: any;\n\n  /**\n   * @description JSON encoded body of non-file params\n   */\n  payload_json?: string;\n\n  /**\n   * @description attachment objects with filename and description", "   * @type  array of partial attachment objects\n   * @see {@link https://discord.com/developers/docs/resources/channel#attachment-objectattachment}\n   */\n  attachments?: any;\n}\n\ninterface AllowedMentions {\n  parse?: Array<Allowed_Mention_Types>; //\tarray of allowed mention types\tAn array of allowed mention types to parse from the content.\n  roles?: Array<string>; //\tlist of snowflakes\tArray of role_ids to mention (Max size of 100)\n  users?: Array<string>; //\tlist of snowflakes\tArray of user_ids to mention (Max size of 100)\n  replied_user?: boolean; //\tFor replies, whether to mention the author of the message being replied to (default false)\n}\n", "interface Embedded {\n  title?: string; //\ttitle of embed\n  type?: 'rich'; //string\ttype of embed (always \"rich\" for webhook embeds)\n  description?: string; //\tdescription of embed\n  url?: string; //\turl of embed\n  timestamp?: string; //\tISO8601 timestamp of embed content\n  color?: number; //\tinteger\tcolor code of the embed\n  footer?: EmbeddedFooter; //\tembed footer object\tfooter information\n  image?: EmbeddedImage; //\tembed image object\timage information\n  thumbnail?: EmbeddedThumbnail; //\tembed thumbnail object\tthumbnail information\n  video?: any; //\tembed video object\tvideo information\n  provider?: EmbeddedProvider; //embed provider object\tprovider information\n  author?: any; //embed author object\tauthor information\n  fields?: Array<EmbeddedField>; //\tarray of embed field objects\tfields information\n}", "interface EmbeddedField {\n  name: string; //\tname of the field\n  value: string; //\tvalue of the field\n  inline?: boolean; //whether or not this field should display inline\n}\ninterface EmbeddedProvider {\n  name?: string; //\tname of provider\n  url?: string; //\turl of provider\n}\ninterface EmbeddedThumbnail {\n  url: string; //source url of thumbnail (only supports http(s) and attachments)\n  proxy_url?: string; //a proxied url of the thumbnail\n  height?: number; //\theight of thumbnail\n  width?: number; //width of thumbnail\n}", "interface EmbeddedThumbnail {\n  url: string; //source url of thumbnail (only supports http(s) and attachments)\n  proxy_url?: string; //a proxied url of the thumbnail\n  height?: number; //\theight of thumbnail\n  width?: number; //width of thumbnail\n}\ninterface EmbeddedImage {\n  url: string; //\tsource url of image (only supports http(s) and attachments)\n  proxy_url?: string; //\ta proxied url of the image\n  height?: number; //\theight of image\n  width?: number; //\twidth of image\n}", "interface EmbeddedFooter {\n  text: string; //\tfooter text\n  icon_url?: string; //\turl of footer icon (only supports http(s) and attachments)\n  proxy_icon_url?: string; //a proxied url of footer icon\n}\n\nexport enum Allowed_Mention_Types {\n  RoleMentions = 'roles', //\tControls role mentions\n  UserMentions = 'users', //\tControls user mentions\n  EveryoneMentions = 'everyone', //\tControls @everyone and @here mentions\n}\n"]}
{"filename": "src/interfaces/index.ts", "chunked_list": ["export * from './discord.interface';\nexport * from './module.interface';\nexport * from './watchman-service.inteface';\n"]}
{"filename": "src/interfaces/watchman-service.inteface.ts", "chunked_list": ["import { HttpException } from '@nestjs/common';\n\ntype UUID = { uuid?: string };\nexport type IException = HttpException & UUID;\n"]}
