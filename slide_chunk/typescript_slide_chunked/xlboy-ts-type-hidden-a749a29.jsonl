{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    include: ['src/**/*.test.ts'],\n    exclude: ['.history/**/*']\n  }\n});\n", ""]}
{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['cjs'],\n  external: ['vscode'],\n  sourcemap: true\n});\n", ""]}
{"filename": "scripts/vsce-package.ts", "chunked_list": ["import { execa } from 'execa';\n\nasync function main(toPublish: boolean) {\n  if (toPublish) {\n    await execa('vsce', ['publish', '--no-dependencies', '-p', process.env.VSCE_TOKEN!], {\n      stdio: 'inherit'\n    });\n  } else {\n    await execa('vsce', ['package', '--no-dependencies'], { stdio: 'inherit' });\n  }\n}\n\nconst args = process.argv.slice(2);\nconst toPublish = args.includes('--publish');\n\nmain(toPublish);\n"]}
{"filename": "src/index.ts", "chunked_list": ["import vscode from 'vscode';\n\nimport { version } from '../package.json';\nimport { registerCommand } from './core/command';\nimport { Config } from './core/config';\nimport { EditorContext } from './core/editor-context';\nimport { log } from './core/log';\nimport { StatusBar } from './core/status-bar';\nimport { GlobalState } from './core/global-state';\n\nexport function activate(vscodeContext: vscode.ExtensionContext) {\n  log.appendLine(`TS Type Hidden for VS Code v${version}\\n`);", "import { GlobalState } from './core/global-state';\n\nexport function activate(vscodeContext: vscode.ExtensionContext) {\n  log.appendLine(`TS Type Hidden for VS Code v${version}\\n`);\n  if (!Config.i.get().enabled) {\n    log.appendLine('Extension disabled, exiting...');\n\n    return;\n  }\n\n  GlobalState.init(vscodeContext);\n  EditorContext.init();\n  StatusBar.init(vscodeContext);\n  registerCommand(vscodeContext);\n}\n"]}
{"filename": "src/core/config.ts", "chunked_list": ["import type { ReadonlyDeep } from 'type-fest';\nimport vscode from 'vscode';\nimport fs from 'fs-extra';\n\nimport { log } from './log';\nimport { TYPE_KIND } from './helpers/type-analyzer/constants';\n\ninterface ExtensionConfig {\n  /** @default true */\n  enabled: boolean;\n  /** @default `{$ExtensionRootPath}/res/type-icon.png` */\n  typeIconPath: string;\n  /** @default [] */\n  ignoreTypeKinds: TYPE_KIND[];\n}\n\nconst defaultTypeIconPath = `${__dirname}/../res/type-icon.png`;\n", "export class Config {\n  private static _instance: Config;\n  /** instance */\n  static get i(): Config {\n    return (Config._instance ??= new Config());\n  }\n\n  get(): ReadonlyDeep<ExtensionConfig> {\n    return Object.freeze(this.config);\n  }\n\n  private sync() {\n    const config = vscode.workspace.getConfiguration('ts-type-hidden');\n\n    this.config = {\n      enabled: config.get('enabled', true),\n      typeIconPath: config.get('typeIconPath') || defaultTypeIconPath,\n      ignoreTypeKinds: config.get('ignoreTypeKinds', [])\n    } satisfies ExtensionConfig;\n  }\n\n  private config!: ExtensionConfig;\n  private watchCallbacks: Array<Function> = [];\n\n  private constructor() {\n    this.sync();\n    this.verify();\n    this.watch();\n  }\n\n  update() {\n    this.sync();\n    log.appendLine(`Config updated:\n${JSON.stringify(this.config, null, 2)}\n`);\n  }\n\n  registerWatchCallback(fn: Function) {\n    this.watchCallbacks.push(fn);\n  }\n\n  private verify() {", "    if (!fs.existsSync(this.config.typeIconPath)) {\n      vscode.window.showErrorMessage(\n        '[ts-type-hidden configuration]: \\n`typeIconPath` is not a valid path'\n      );\n      this.config.typeIconPath = defaultTypeIconPath;\n    }\n\n    for (let i = this.config.ignoreTypeKinds.length - 1; i >= 0; i--) {\n      const typeKindToIgnore = this.config.ignoreTypeKinds[i];\n      const isInvalid = !Object.values(TYPE_KIND).includes(typeKindToIgnore);\n      if (isInvalid) {\n        this.config.ignoreTypeKinds.splice(i, 1);\n        vscode.window.showErrorMessage(\n          `[ts-type-hidden configuration]: \\n\\`ignoreTypeKinds.${typeKindToIgnore}\\` is not a valid value`\n        );\n      }\n    }\n  }\n\n  private watch() {\n    vscode.workspace.onDidChangeConfiguration(() => {\n      this.update();\n      this.verify();\n      this.watchCallbacks.forEach(cb => cb());\n    });\n  }\n}\n", "      if (isInvalid) {\n        this.config.ignoreTypeKinds.splice(i, 1);\n        vscode.window.showErrorMessage(\n          `[ts-type-hidden configuration]: \\n\\`ignoreTypeKinds.${typeKindToIgnore}\\` is not a valid value`\n        );\n      }\n    }\n  }\n\n  private watch() {\n    vscode.workspace.onDidChangeConfiguration(() => {\n      this.update();\n      this.verify();\n      this.watchCallbacks.forEach(cb => cb());\n    });\n  }\n}\n"]}
{"filename": "src/core/editor-context.ts", "chunked_list": ["import vscode from 'vscode';\nimport { type AnalyzedType, TypeAnalyzer } from './helpers/type-analyzer';\nimport { debounce, isEqual } from 'lodash-es';\nimport { GlobalState } from './global-state';\nimport { Config } from './config';\n\ntype FoldingRange = Record<'start' | 'end', /* lineNumber */ number>;\n\ninterface EditorInfo {\n  code: string;\n  analyzedTypes: AnalyzedType[];\n  isTSX: boolean;\n  foldedTypeRanges: FoldingRange[];\n}\n", "interface EditorInfo {\n  code: string;\n  analyzedTypes: AnalyzedType[];\n  isTSX: boolean;\n  foldedTypeRanges: FoldingRange[];\n}\n\nexport class EditorContext {\n  private static _instance: EditorContext;\n\n  /** instance */\n  public static get i(): EditorContext {", "    if (!EditorContext._instance) {\n      throw new Error('EditorContext not initialized');\n    }\n\n    return EditorContext._instance;\n  }\n  public static init() {\n    EditorContext._instance = new EditorContext();\n  }\n\n  private editors = new Map</* filePath */ string, EditorInfo>();\n  private curFocusedTypes: AnalyzedType[] = [];\n\n  private constructor() {\n    this.register();\n    this.initVisibleEditors();\n    this.decoration.init();\n    Config.i.registerWatchCallback(this.decoration.refreshIcon);\n", "    if (GlobalState.i.isHiddenMode) this.hideType(true);\n  }\n\n  hideType(needToFold = false) {\n    const activeEditorWindow = vscode.window.activeTextEditor;\n\n    if (activeEditorWindow && this.utils.isTargetDocument(activeEditorWindow.document)) {\n      const activeEditorInfo = this.editors.get(activeEditorWindow.document.fileName);\n      if (!activeEditorInfo) return;\n\n      const filteredAnalyzedTypes = activeEditorInfo.analyzedTypes\n        .filter(type => !Config.i.get().ignoreTypeKinds.includes(type.kind))\n        .filter(type => !this.curFocusedTypes.some(curFType => isEqual(type, curFType)));\n      const typeRangesToHide = filteredAnalyzedTypes.map(\n        type =>\n          new vscode.Range(\n            activeEditorWindow.document.positionAt(type.range.pos),\n            activeEditorWindow.document.positionAt(type.range.end)\n          )\n      );\n\n      activeEditorWindow.setDecorations(this.decoration.get().hidden, typeRangesToHide);\n      activeEditorWindow.setDecorations(this.decoration.get().icon, typeRangesToHide);\n", "      if (!activeEditorInfo) return;\n\n      const filteredAnalyzedTypes = activeEditorInfo.analyzedTypes\n        .filter(type => !Config.i.get().ignoreTypeKinds.includes(type.kind))\n        .filter(type => !this.curFocusedTypes.some(curFType => isEqual(type, curFType)));\n      const typeRangesToHide = filteredAnalyzedTypes.map(\n        type =>\n          new vscode.Range(\n            activeEditorWindow.document.positionAt(type.range.pos),\n            activeEditorWindow.document.positionAt(type.range.end)\n          )\n      );\n\n      activeEditorWindow.setDecorations(this.decoration.get().hidden, typeRangesToHide);\n      activeEditorWindow.setDecorations(this.decoration.get().icon, typeRangesToHide);\n", "      if (needToFold) {\n        setTimeout(() => {\n          handleMultiLineFold.call(this, activeEditorWindow, activeEditorInfo);\n        }, 200);\n        // Q\uff1a\u2191\u4e3a\u4ec0\u4e48\u9700\u8981 200ms \u5ef6\u65f6\uff1f\n        // A\uff1a\u5728\u521d\u6b21\u6253\u5f00\u6587\u4ef6\u65f6\uff0c\u6267\u884c\u4e86\u76f8\u5173\u4ee3\u7801\u540e\u8d70\u5230\u6b64\u65b9\u6cd5\u5185\u65f6\uff0c\u83b7\u53d6\u5230\u7684 `currentCursorPos` \u662f\u4e0d\u6b63\u786e\u7684\u201c\u5934\u4f4d\u7f6e\u201d\n        // A\uff1a\u4e3a\u4ec0\u4e48\u662f\u5934\u4f4d\u7f6e\uff1f\u731c\u6d4b\u662f\u672a\u521d\u59cb\u5316\u597d\u7b49\u539f\u56e0\uff0c\u56e0\u800c\u6ca1\u80fd\u53ca\u65f6\u5c06\u5149\u6807\u4f4d\u7f6e\u540c\u6b65\u5230 `selection.active` \u4e2d\u2026\n      }\n    }\n\n    return;\n", "    async function handleMultiLineFold(\n      this: EditorContext,\n      activeEditorWindow: vscode.TextEditor,\n      activeEditorInfo: EditorInfo\n    ) {\n      const currentCursorPos = activeEditorWindow.selection.active;\n      const filteredAnalyzedTypes = activeEditorInfo.analyzedTypes.filter(\n        type => !Config.i.get().ignoreTypeKinds.includes(type.kind)\n      );\n      let foldedCount = 0;\n      activeEditorInfo.foldedTypeRanges = [];\n", "      for await (const type of filteredAnalyzedTypes) {\n        const typeRange = new vscode.Range(\n          activeEditorWindow.document.positionAt(type.range.pos),\n          activeEditorWindow.document.positionAt(type.range.end)\n        );\n        const typeText = activeEditorWindow.document.getText(typeRange);\n        const typeLineCount = typeText.split('\\n').length;\n\n        if (typeLineCount > 2) {\n          const inFoldingRange = (() => {\n            const curFoldingRanges = this.utils.getActiveEditorFoldingRanges();\n", "        if (typeLineCount > 2) {\n          const inFoldingRange = (() => {\n            const curFoldingRanges = this.utils.getActiveEditorFoldingRanges();\n\n            for (const curFRange of curFoldingRanges) {\n              if (\n                curFRange.start <= typeRange.start.line &&\n                curFRange.end >= typeRange.end.line\n              ) {\n                return true;\n              }\n            }\n\n            return false;\n          })();\n", "          if (!inFoldingRange) {\n            foldedCount++;\n            const lineToFold = {\n              start: typeRange.start.line,\n              end: typeRange.end.line + 1\n            };\n            activeEditorWindow.selection = new vscode.Selection(\n              lineToFold.start,\n              0,\n              lineToFold.end,\n              0\n            );\n            activeEditorInfo.foldedTypeRanges.push(lineToFold);\n            await vscode.commands.executeCommand(\n              'editor.createFoldingRangeFromSelection'\n            );\n          }\n        }\n      }\n", "      if (foldedCount > 0) {\n        activeEditorWindow.selection = new vscode.Selection(\n          currentCursorPos,\n          currentCursorPos\n        );\n        activeEditorWindow.revealRange(\n          new vscode.Range(currentCursorPos.line, 0, currentCursorPos.line, 0),\n          vscode.TextEditorRevealType.InCenter\n        );\n      }\n    }\n  }\n\n  async showType() {\n    const activeEditorWindow = vscode.window.activeTextEditor;\n", "    if (activeEditorWindow && this.utils.isTargetDocument(activeEditorWindow.document)) {\n      activeEditorWindow.setDecorations(this.decoration.get().hidden, []);\n      activeEditorWindow.setDecorations(this.decoration.get().icon, []);\n\n      const curEditorInfo = this.editors.get(activeEditorWindow.document.fileName);\n      if (curEditorInfo) {\n        const curPos = activeEditorWindow.selection.active;\n\n        for await (const range of curEditorInfo.foldedTypeRanges) {\n          activeEditorWindow.selection = new vscode.Selection(\n            range.start,\n            0,\n            range.end,\n            0\n          );\n          await vscode.commands.executeCommand('editor.unfold');\n        }\n\n        activeEditorWindow.selection = new vscode.Selection(curPos, curPos);\n        activeEditorWindow.revealRange(\n          new vscode.Range(curPos.line, 0, curPos.line, 0),\n          vscode.TextEditorRevealType.InCenter\n        );\n      }\n    }\n  }\n\n  private register() {\n    vscode.window.onDidChangeActiveTextEditor(editor => {", "      if (editor && this.utils.isTargetDocument(editor.document)) {\n        const filePath = editor.document.fileName;\n        let isFirstOpen = false;\n        if (!this.editors.has(filePath)) {\n          isFirstOpen = true;\n          const fileCode = editor.document.getText();\n          const isTSX = editor.document.languageId === 'typescriptreact';\n          this.editors.set(filePath, {\n            code: fileCode,\n            analyzedTypes: new TypeAnalyzer(fileCode, isTSX).analyze(),\n            isTSX,\n            foldedTypeRanges: []\n          });\n        }\n", "        if (GlobalState.i.isHiddenMode) this.hideType(isFirstOpen);\n      }\n    });\n\n    vscode.workspace.onDidChangeTextDocument(\n      debounce<(event: vscode.TextDocumentChangeEvent) => void>(event => {\n        const curChangedEditorInfo = this.editors.get(event.document.fileName);\n\n        if (curChangedEditorInfo) {\n          const newCode = event.document.getText();\n          curChangedEditorInfo.code = newCode;\n          curChangedEditorInfo.analyzedTypes = new TypeAnalyzer(\n            newCode,\n            curChangedEditorInfo.isTSX\n          ).analyze();\n          this.curFocusedTypes = this.getActiveEditorFocusedTypes();\n", "        if (curChangedEditorInfo) {\n          const newCode = event.document.getText();\n          curChangedEditorInfo.code = newCode;\n          curChangedEditorInfo.analyzedTypes = new TypeAnalyzer(\n            newCode,\n            curChangedEditorInfo.isTSX\n          ).analyze();\n          this.curFocusedTypes = this.getActiveEditorFocusedTypes();\n\n          if (GlobalState.i.isHiddenMode) this.hideType();\n        }\n      }, 1000)\n    );\n\n    vscode.window.onDidChangeTextEditorSelection(event => {", "          if (GlobalState.i.isHiddenMode) this.hideType();\n        }\n      }, 1000)\n    );\n\n    vscode.window.onDidChangeTextEditorSelection(event => {\n      if (this.utils.isTargetDocument(event.textEditor.document)) {\n        const curEditorInfo = this.editors.get(event.textEditor.document.fileName);\n        if (!curEditorInfo) return;\n\n        const focusedTypes = this.getActiveEditorFocusedTypes();", "        if (!curEditorInfo) return;\n\n        const focusedTypes = this.getActiveEditorFocusedTypes();\n        if (!isEqual(focusedTypes, this.curFocusedTypes)) {\n          this.curFocusedTypes = focusedTypes;\n\n          const cursorPositionUpdateOnly =\n            curEditorInfo.code === event.textEditor.document.getText();\n          if (cursorPositionUpdateOnly && GlobalState.i.isHiddenMode) {\n            this.hideType();\n          }\n        }\n      }\n    });\n  }\n\n  private initVisibleEditors() {\n    vscode.window.visibleTextEditors.forEach(editor => {", "          if (cursorPositionUpdateOnly && GlobalState.i.isHiddenMode) {\n            this.hideType();\n          }\n        }\n      }\n    });\n  }\n\n  private initVisibleEditors() {\n    vscode.window.visibleTextEditors.forEach(editor => {\n      if (this.utils.isTargetDocument(editor.document)) {\n        const fileCode = editor.document.getText();\n        const isTSX = editor.document.languageId === 'typescriptreact';\n        this.editors.set(editor.document.fileName, {\n          code: fileCode,\n          analyzedTypes: new TypeAnalyzer(fileCode, isTSX).analyze(),\n          isTSX,\n          foldedTypeRanges: []\n        });\n      }\n    });\n  }\n\n  private getActiveEditorFocusedTypes() {\n    const activeEditorWindow = vscode.window.activeTextEditor;", "      if (this.utils.isTargetDocument(editor.document)) {\n        const fileCode = editor.document.getText();\n        const isTSX = editor.document.languageId === 'typescriptreact';\n        this.editors.set(editor.document.fileName, {\n          code: fileCode,\n          analyzedTypes: new TypeAnalyzer(fileCode, isTSX).analyze(),\n          isTSX,\n          foldedTypeRanges: []\n        });\n      }\n    });\n  }\n\n  private getActiveEditorFocusedTypes() {\n    const activeEditorWindow = vscode.window.activeTextEditor;", "    if (!activeEditorWindow) return [];\n\n    const curEditrInfo = this.editors.get(activeEditorWindow.document.fileName);\n    if (!curEditrInfo) return [];\n\n    const cursorPos = activeEditorWindow.selection.active;\n    const cursorOffset = activeEditorWindow.document.offsetAt(cursorPos);\n    const focusedTypes = curEditrInfo.analyzedTypes.filter(type => {\n      const start = activeEditorWindow.document.positionAt(type.range.pos);\n      return (\n        cursorPos.line === start.line ||\n        (cursorOffset >= type.range.pos && cursorOffset <= type.range.end)\n      );\n    });\n\n    return focusedTypes;\n  }\n\n  private utils = {\n    isTargetDocument(document: vscode.TextDocument) {\n      return (\n        (document.languageId === 'typescript' ||\n          document.languageId === 'typescriptreact') &&\n        !document.isUntitled &&\n        !document.fileName.endsWith('.d.ts')\n      );\n    },\n    getActiveEditorFoldingRanges(): FoldingRange[] {\n      const activeEditorWindow = vscode.window.activeTextEditor;", "      if (!activeEditorWindow) return [];\n\n      const foldingRanges: FoldingRange[] = [];\n\n      // `[[0, 11], [25, 44]]`, get `[11, 25]`\n      activeEditorWindow.visibleRanges.forEach((range, index, visibleRanges) => {\n        if (visibleRanges.length === 1 || index === visibleRanges.length - 1) return;\n\n        const endLine = range.end.line;\n        const nextStartLine = visibleRanges[index + 1]!.start.line;\n\n        foldingRanges.push({ start: endLine, end: nextStartLine });\n      });\n\n      return foldingRanges;\n    }\n  };\n\n  private decoration = (() => {\n    let value: Record<'hidden' | 'icon', vscode.TextEditorDecorationType>;\n\n    const createIcon = () =>\n      vscode.window.createTextEditorDecorationType({\n        gutterIconPath: vscode.Uri.file(Config.i.get().typeIconPath),\n        gutterIconSize: 'contain'\n      });\n\n    return {\n      get: () => value,\n      refreshIcon() {\n        value.icon.dispose();\n        value.icon = createIcon();\n      },\n      init() {\n        value = {\n          hidden: vscode.window.createTextEditorDecorationType({\n            textDecoration: 'opacity: 0; font-size: 0; display: none'\n          }),\n          icon: createIcon()\n        };\n      }\n    };\n  })();\n}\n"]}
{"filename": "src/core/global-state.ts", "chunked_list": ["import vscode from 'vscode';\n\nexport class GlobalState {\n  private static _instance: GlobalState;\n\n  /** instance */\n  public static get i(): GlobalState {\n    if (!GlobalState._instance) {\n      throw new Error('GlobalState not initialized');\n    }\n\n    return GlobalState._instance;\n  }\n\n  public static init(vscodeContext: vscode.ExtensionContext) {\n    GlobalState._instance = new GlobalState(vscodeContext);\n  }\n\n  private constructor(private readonly vscodeContext: vscode.ExtensionContext) {}\n\n  get isHiddenMode() {\n    return this.vscodeContext.globalState.get('isHiddenMode', true);\n  }\n  set isHiddenMode(value: boolean) {\n    this.vscodeContext.globalState.update('isHiddenMode', value);\n  }\n}\n"]}
{"filename": "src/core/log.ts", "chunked_list": ["import vscode from 'vscode';\n\nexport const log = vscode.window.createOutputChannel('TS Type Hidden');\n"]}
{"filename": "src/core/status-bar.ts", "chunked_list": ["import vscode from 'vscode';\n\nexport class StatusBar {\n  private static _instance: StatusBar;\n\n  /** instance */\n  public static get i(): StatusBar {\n    if (!StatusBar._instance) {\n      throw new Error('StatusBar not initialized');\n    }\n\n    return StatusBar._instance;\n  }\n\n  public static init(vscodeContext: vscode.ExtensionContext) {\n    StatusBar._instance = new StatusBar(vscodeContext);\n  }\n\n  private statusBarItem: vscode.StatusBarItem;\n\n  constructor(vscodeContext: vscode.ExtensionContext) {\n    const isHiddenMode = vscodeContext.globalState.get('isHiddenMode', true);\n    this.statusBarItem = vscode.window.createStatusBarItem();\n    this.statusBarItem.command = 'ts-type-hidden.toogle';\n    this.statusBarItem.show();\n    this.changeStatus(isHiddenMode);\n    vscodeContext.subscriptions.push(this.statusBarItem);\n  }\n\n  changeStatus(isHiddenMode: boolean) {\n    this.statusBarItem.text = isHiddenMode ? 'TH \u2705' : 'TH \u274c';\n\n    this.statusBarItem.tooltip =\n      '[TS Type Hidden] - Click to toggle hidden mode (Current mode: ' +\n      (isHiddenMode ? 'On' : 'Off') +\n      ')';\n  }\n}\n"]}
{"filename": "src/core/command.ts", "chunked_list": ["import vscode from 'vscode';\n\nimport { EditorContext } from './editor-context';\nimport { log } from './log';\nimport { GlobalState } from './global-state';\nimport { StatusBar } from './status-bar';\n\nexport function registerCommand(vscodeContext: vscode.ExtensionContext) {\n  vscodeContext.subscriptions.push(\n    vscode.commands.registerCommand('ts-type-hidden.toogle', () => {\n      GlobalState.i.isHiddenMode = !GlobalState.i.isHiddenMode;\n      GlobalState.i.isHiddenMode\n        ? EditorContext.i.hideType(true)\n        : EditorContext.i.showType();\n      StatusBar.i.changeStatus(GlobalState.i.isHiddenMode);\n      log.appendLine(\n        `[command.toogle] Toogle hidden mode, Current mode: ${\n          !GlobalState.i.isHiddenMode ? 'On' : 'Off'\n        }`\n      );\n    }),\n    vscode.commands.registerCommand('ts-type-hidden.open', () => {\n      log.appendLine(`[command.open] Open hidden mode`);\n      GlobalState.i.isHiddenMode = true;\n      EditorContext.i.hideType(true);\n      StatusBar.i.changeStatus(true);\n    }),\n\n    vscode.commands.registerCommand('ts-type-hidden.close', () => {\n      log.appendLine(`[command.close] Close hidden mode`);\n      GlobalState.i.isHiddenMode = false;\n      EditorContext.i.showType();\n      StatusBar.i.changeStatus(false);\n    })\n  );\n}\n"]}
{"filename": "src/core/helpers/type-analyzer/index.test.ts", "chunked_list": ["import { describe, expect, it } from 'vitest';\nimport { TypeAnalyzer } from '.';\nimport { TYPE_KIND } from './constants';\n\ndescribe('function', () => {\n  it('overloading', () => {\n    const analyzer = new TypeAnalyzer(`\nconst t = 1\n\nfunction a<B extends 222>(): void;\nfunction b<A>(o: A): string;\n`);\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 14, end: 48 },", "\nfunction a<B extends 222>(): void;\nfunction b<A>(o: A): string;\n`);\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 14, end: 48 },\n        text: 'function a<B extends 222>(): void;',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      },\n      {\n        range: { pos: 49, end: 77 },", "        text: 'function a<B extends 222>(): void;',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      },\n      {\n        range: { pos: 49, end: 77 },\n        text: 'function b<A>(o: A): string;',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      }\n    ]);\n  });\n\n  it('function-generic-definition - a`<B extends ...>`()', () => {\n    const analyzer = new TypeAnalyzer(\n      `", "function a<B extends 111, C extends 111>() {}\nconst b = <B extends 222, C extends 222>() => {};\nconst c = function<B extends 333, C extends 333>() {}\nconst d = {\n  a<B extends 444, C extends 444>() {}\n}\n`\n    );\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 11, end: 41 },\n        text: '<B extends 111, C extends 111>',\n        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n      },\n      {\n        range: { pos: 57, end: 87 },\n        text: '<B extends 222, C extends 222>',\n        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n      },\n      {\n        range: { pos: 115, end: 145 },\n        text: '<B extends 333, C extends 333>',\n        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n      },\n      {\n        range: { pos: 166, end: 196 },\n        text: '<B extends 444, C extends 444>',\n        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n      }\n    ]);\n  });\n\n  it('function-parameter - (`a: number, b: string, ...`)', () => {\n    const analyzer = new TypeAnalyzer(`", "function a(a1: A111, a2?: A222) {}\nconst b = (b1: B111, b2?: B222) => {};\nconst c = function(c1: C111, c2?: C222) {}\nconst d = {\n  e(d1: E111, d2?: E222) {}\n  f: (f1: F111, f2?: F222) => {}\n}\n`);\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 14, end: 20 },\n        text: ': A111',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 24, end: 31 },\n        text: '?: A222',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 49, end: 55 },\n        text: ': B111',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 59, end: 66 },\n        text: '?: B222',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 96, end: 102 },\n        text: ': C111',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 106, end: 113 },\n        text: '?: C222',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 136, end: 142 },\n        text: ': E111',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 146, end: 153 },\n        text: '?: E222',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 166, end: 172 },\n        text: ': F111',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 176, end: 183 },\n        text: '?: F222',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      }\n    ]);\n  });\n\n  it('function-return - ()`: number`', () => {\n    const analyzer = new TypeAnalyzer(`n", "function a(): A111 {}\nconst b = (): B111 => {};\nconst c = function(): C111 {}\nconst d = {\n  d(): D111 {}\n  e: (): E111 => {}\n}\n`);\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 14, end: 20 },\n        text: ': A111',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 36, end: 42 },\n        text: ': B111',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 70, end: 76 },\n        text: ': C111',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 97, end: 103 },\n        text: ': D111',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 114, end: 120 },\n        text: ': E111',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      }\n    ]);\n  });\n\n  it('function-type-predicate - (a: any)`: asserts a is ...)`', () => {\n    const analyzer = new TypeAnalyzer(`", "function a(value): asserts a is aaa {}\n\nconst b = (value): asserts b is bbb => {};\n\nconst c = function (value): asserts d is ddd {};\n\nconst d = {\n  e(value): asserts e is eee {},\n  f: (value): asserts f is fff => {}\n};\n`);\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 18, end: 36 },\n        text: ': asserts a is aaa',\n        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n      },\n      {\n        range: { pos: 58, end: 76 },\n        text: ': asserts b is bbb',\n        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n      },\n      {\n        range: { pos: 111, end: 129 },\n        text: ': asserts d is ddd',\n        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n      },\n      {\n        range: { pos: 157, end: 175 },\n        text: ': asserts e is eee',\n        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n      },\n      {\n        range: { pos: 192, end: 210 },\n        text: ': asserts f is fff',\n        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n      }\n    ]);\n  });\n});\n\nit('interface', () => {\n  const analyzer = new TypeAnalyzer(`", "interface t {};\ninterface A111 {\n  a: number;\n  b: string;\n  c: {\n    e: 1\n  }\n}`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 1, end: 15 },", "      text: 'interface t {}',\n      kind: TYPE_KIND.INTERFACE\n    },\n    {\n      range: { pos: 17, end: 81 },\n      text: 'interface A111 {\\n  a: number;\\n  b: string;\\n  c: {\\n    e: 1\\n  }\\n}',\n      kind: TYPE_KIND.INTERFACE\n    }\n  ]);\n});\n", "it('type alias', () => {\n  const analyzer = new TypeAnalyzer(`\ntype t = number;\ntype A111  = {\n  a: number;\n} | 123 & {}`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 1, end: 17 },", "      text: 'type t = number;',\n      kind: TYPE_KIND.TYPE_ALIAS\n    },\n    {\n      range: { pos: 18, end: 58 },\n      text: 'type A111  = {\\n  a: number;\\n} | 123 & {}',\n      kind: TYPE_KIND.TYPE_ALIAS\n    }\n  ]);\n});\n", "it('variable type definition', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = 1;\ndeclare const b: number, c: string;\nconst d: number, e: string;\nconst eee: null | string = ''\nlet fff!: string = ''\nusing ggg: usingAny = fn();\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 14, end: 49 },\n      text: 'declare const b: number, c: string;',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 57, end: 65 },\n      text: ': number',\n      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n    },\n    {\n      range: { pos: 68, end: 76 },\n      text: ': string',\n      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n    },\n    {\n      range: { pos: 87, end: 102 },\n      text: ': null | string',\n      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n    },\n    {\n      range: { pos: 115, end: 124 },\n      text: '!: string',\n      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n    },\n    {\n      range: { pos: 139, end: 149 },\n      text: ': usingAny',\n      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n    }\n  ]);\n});\n\nit('declare statement', () => {\n  const analyzer = new TypeAnalyzer(`\ndeclare const a: number;", "declare function b(): number;\ndeclare class c {}\ndeclare module d {}\ndeclare namespace e {}\ndeclare enum f {}\ndeclare global {}\ndeclare module 'g' {}\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 1, end: 25 },\n      text: 'declare const a: number;',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 26, end: 55 },", "      text: 'declare function b(): number;',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 56, end: 74 },\n      text: 'declare class c {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 75, end: 94 },\n      text: 'declare module d {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 95, end: 117 },\n      text: 'declare namespace e {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 118, end: 135 },", "      text: 'declare module d {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 95, end: 117 },\n      text: 'declare namespace e {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 118, end: 135 },\n      text: 'declare enum f {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 136, end: 153 },\n      text: 'declare global {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 154, end: 175 },\n      text: \"declare module 'g' {}\",\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    }\n  ]);\n});\n\nit('as expression', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = 1 as number;\nconst b = 1 as number | string;\nconst c = 1 as number | string | null as 111 as 3;\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 12, end: 22 },\n      text: ' as number',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 35, end: 54 },\n      text: ' as number | string',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 67, end: 93 },\n      text: ' as number | string | null',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 93, end: 100 },\n      text: ' as 111',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 100, end: 105 },\n      text: ' as 3',\n      kind: TYPE_KIND.AS_ASSERTION\n    }\n  ]);\n});\n\nit('satisfies expression', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = 1 satisfies number;\nconst b = 1 satisfies number | string;\nconst c = 1 satisfies number | string | null;\n\nconst d = () => {\n  return 333 satisfies any\n}\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 12, end: 29 },\n      text: ' satisfies number',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    },\n    {\n      range: { pos: 42, end: 68 },\n      text: ' satisfies number | string',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    },\n    {\n      range: { pos: 81, end: 114 },\n      text: ' satisfies number | string | null',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    },\n    {\n      range: { pos: 147, end: 161 },\n      text: ' satisfies any',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    }\n  ]);\n});\n\nit('satisfies & as', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = {} satisfies {} as const;\nconst b = {} as const satisfies {};\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      kind: TYPE_KIND.SATISFIES_OPERATOR,\n      range: { pos: 13, end: 26 },\n      text: ' satisfies {}'\n    },\n    {\n      kind: TYPE_KIND.AS_ASSERTION,\n      range: { pos: 26, end: 35 },\n      text: ' as const'\n    },\n    {\n      kind: TYPE_KIND.AS_ASSERTION,\n      range: { pos: 49, end: 58 },\n      text: ' as const'\n    },\n    {\n      kind: TYPE_KIND.SATISFIES_OPERATOR,\n      range: { pos: 58, end: 71 },\n      text: ' satisfies {}'\n    }\n  ]);\n});\n", "      text: 'declare enum f {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 136, end: 153 },\n      text: 'declare global {}',\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    },\n    {\n      range: { pos: 154, end: 175 },\n      text: \"declare module 'g' {}\",\n      kind: TYPE_KIND.DECLARE_STATEMENT\n    }\n  ]);\n});\n\nit('as expression', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = 1 as number;\nconst b = 1 as number | string;\nconst c = 1 as number | string | null as 111 as 3;\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 12, end: 22 },\n      text: ' as number',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 35, end: 54 },\n      text: ' as number | string',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 67, end: 93 },\n      text: ' as number | string | null',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 93, end: 100 },\n      text: ' as 111',\n      kind: TYPE_KIND.AS_ASSERTION\n    },\n    {\n      range: { pos: 100, end: 105 },\n      text: ' as 3',\n      kind: TYPE_KIND.AS_ASSERTION\n    }\n  ]);\n});\n\nit('satisfies expression', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = 1 satisfies number;\nconst b = 1 satisfies number | string;\nconst c = 1 satisfies number | string | null;\n\nconst d = () => {\n  return 333 satisfies any\n}\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 12, end: 29 },\n      text: ' satisfies number',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    },\n    {\n      range: { pos: 42, end: 68 },\n      text: ' satisfies number | string',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    },\n    {\n      range: { pos: 81, end: 114 },\n      text: ' satisfies number | string | null',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    },\n    {\n      range: { pos: 147, end: 161 },\n      text: ' satisfies any',\n      kind: TYPE_KIND.SATISFIES_OPERATOR\n    }\n  ]);\n});\n\nit('satisfies & as', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a = {} satisfies {} as const;\nconst b = {} as const satisfies {};\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      kind: TYPE_KIND.SATISFIES_OPERATOR,\n      range: { pos: 13, end: 26 },\n      text: ' satisfies {}'\n    },\n    {\n      kind: TYPE_KIND.AS_ASSERTION,\n      range: { pos: 26, end: 35 },\n      text: ' as const'\n    },\n    {\n      kind: TYPE_KIND.AS_ASSERTION,\n      range: { pos: 49, end: 58 },\n      text: ' as const'\n    },\n    {\n      kind: TYPE_KIND.SATISFIES_OPERATOR,\n      range: { pos: 58, end: 71 },\n      text: ' satisfies {}'\n    }\n  ]);\n});\n", "it('type assertion', () => {\n  const analyzer = new TypeAnalyzer(`\nconst a =<number>1;\nconst b = <number | string>1;\nconst c = <number | string | null>1;\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 10, end: 18 },\n      text: '<number>',\n      kind: TYPE_KIND.ANGLE_BRACKETS_ASSERTION\n    },\n    {\n      range: { pos: 31, end: 48 },\n      text: '<number | string>',\n      kind: TYPE_KIND.ANGLE_BRACKETS_ASSERTION\n    },\n    {\n      range: { pos: 61, end: 85 },\n      text: '<number | string | null>',\n      kind: TYPE_KIND.ANGLE_BRACKETS_ASSERTION\n    }\n  ]);\n});\n\nit('call expression', () => {\n  const analyzer = new TypeAnalyzer(`\nb<number>();\nnew d<number, string>();\nf<number, string, null>();\nnew Set<PersistListener<S>>()\n`);\n\n  analyzer.analyze();\n\n  expect(analyzer.analyzedTypes).toMatchObject([\n    {\n      range: { pos: 2, end: 10 },\n      text: '<number>',\n      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n    },\n    {\n      range: { pos: 19, end: 35 },\n      text: '<number, string>',\n      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n    },\n    {\n      range: { pos: 40, end: 62 },\n      text: '<number, string, null>',\n      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n    },\n    {\n      range: { end: 93, pos: 73 },\n      text: '<PersistListener<S>>',\n      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n    }\n  ]);\n});\n\ndescribe('class', () => {", "  it('property type definition', () => {\n    const analyzer = new TypeAnalyzer(`\nclass A {\n  a: number;\n  public b: string;\n  protected c: {\n    e: 1\n  }\n  private d: () => void = () => {}\n  e!: boolean;\n  g?: string; \n}\n  `);\n\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 14, end: 22 },\n        text: ': number',\n        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n      },\n      {\n        range: { pos: 34, end: 42 },\n        text: ': string',\n        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n      },\n      {\n        range: { pos: 57, end: 73 },\n        text: ': {\\n    e: 1\\n  }',\n        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n      },\n      {\n        range: { pos: 85, end: 97 },\n        text: ': () => void',\n        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n      },\n      {\n        range: { pos: 112, end: 122 },\n        text: '!: boolean',\n        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n      },\n      {\n        range: { end: 136, pos: 127 },\n        text: '?: string',\n        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n      }\n    ]);\n  });\n\n  it('method declaration', () => {\n    const analyzer = new TypeAnalyzer(`", "class A {\n  public a(p: 1): boolean;\n  public a(p: 2): number;\n  public a(p: 1 | 2): boolean | number {\n    return '' as any;\n  }\n  public b(a: number): string;\n  protected c(b: number | 1): {\n    e: 1\n  }\n  protected get compileUtils(): any | 'compileUtils' {\n    const abc = {\n      getConfig: (): ReadonlyDeep<InnerCompilerConfig> => {\n        return getCurrentCompileConfig() as any as unknown;\n      },\n      b(): void {}\n    }\n  }\n}\n  `);\n\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 11, end: 37 },\n        text: '  public a(p: 1): boolean;',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      },\n      {\n        range: { pos: 38, end: 63 },\n        text: '  public a(p: 2): number;',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      },\n      {\n        range: { pos: 76, end: 83 },\n        text: ': 1 | 2',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      },\n      {\n        range: { pos: 84, end: 102 },\n        text: ': boolean | number',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 118, end: 125 },\n        text: ' as any',\n        kind: TYPE_KIND.AS_ASSERTION\n      },\n      {\n        range: { pos: 131, end: 161 },\n        text: '  public b(a: number): string;',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      },\n      {\n        range: { pos: 162, end: 206 },\n        text: '  protected c(b: number | 1): {\\n    e: 1\\n  }',\n        kind: TYPE_KIND.FUNCTION_OVERLOAD\n      },\n      {\n        range: { pos: 237, end: 259 },\n        text: \": any | 'compileUtils'\",\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 299, end: 334 },\n        text: ': ReadonlyDeep<InnerCompilerConfig>',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      },\n      {\n        range: { pos: 380, end: 387 },\n        text: ' as any',\n        kind: TYPE_KIND.AS_ASSERTION\n      },\n      {\n        range: { pos: 387, end: 398 },\n        text: ' as unknown',\n        kind: TYPE_KIND.AS_ASSERTION\n      },\n      {\n        range: { pos: 418, end: 424 },\n        text: ': void',\n        kind: TYPE_KIND.FUNCTION_RETURN\n      }\n    ]);\n  });\n\n  it('constructor', () => {\n    const analyzer = new TypeAnalyzer(`", "class A {\n  constructor(a: number) {}\n}\n  `);\n\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 26, end: 34 },\n        text: ': number',\n        kind: TYPE_KIND.FUNCTION_PARAMETER\n      }\n    ]);\n  });\n});\n\ndescribe('tsx', () => {\n  it('generic arguments', () => {\n    const analyzer = new TypeAnalyzer(\n      `\n  const a = <Component<number> />\n  const b = <A<number, string> />\n  const c = <A<number, string, null> />\n  const d = <A\n    <number, string, null, 1, 2 | 3, [22]>\n  />\n  `,\n      true\n    );\n\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 23, end: 31 },\n        text: '<number>',\n        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n      },\n      {\n        range: { pos: 49, end: 65 },\n        text: '<number, string>',\n        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n      },\n      {\n        range: { pos: 83, end: 105 },\n        text: '<number, string, null>',\n        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n      },\n      {\n        range: { pos: 128, end: 166 },\n        text: '<number, string, null, 1, 2 | 3, [22]>',\n        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n      }\n    ]);\n  });\n\n  it('integration', () => {\n    const analyzer = new TypeAnalyzer(\n      `\n  const a = <Component<number>\n      name\n      test={111 as any}\n      t2={\\`...\\${11 as string}\\`}\n      {...test as object}\n    />\n\n  `,\n      true\n    );\n\n    analyzer.analyze();\n\n    expect(analyzer.analyzedTypes).toMatchObject([\n      {\n        range: { pos: 23, end: 31 },\n        text: '<number>',\n        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n      },\n      {\n        range: { pos: 58, end: 65 },\n        text: ' as any',\n        kind: TYPE_KIND.AS_ASSERTION\n      },\n      {\n        range: { pos: 85, end: 95 },\n        text: ' as string',\n        kind: TYPE_KIND.AS_ASSERTION\n      },\n      {\n        range: { pos: 113, end: 123 },\n        text: ' as object',\n        kind: TYPE_KIND.AS_ASSERTION\n      }\n    ]);\n  });\n});\n"]}
{"filename": "src/core/helpers/type-analyzer/constants.ts", "chunked_list": ["export enum TYPE_KIND {\n  /**\n   * ```ts\n   * type A  = ({ ... } & { ... }) | string[]\n   * ```\n   * \u23ed\ufe0f  `type A = ({ ... } & { ... }) | string[]`\n   */\n  TYPE_ALIAS = 'type-alias',\n  /**\n   * ```ts\n   * interface A {\n   *   ...\n   * }\n   * ```", "   * interface A {\n   *   ...\n   * }\n   * ```\n   * \u23ed\ufe0f  `interface A { ... }`\n   */\n  INTERFACE = 'interface',\n  /**\n   * ```ts\n   * function fn(a: number): number[];\n   * function fn(a: number[], opts: { ... }): number[];\n   * ```", "   * function fn(a: number): number[];\n   * function fn(a: number[], opts: { ... }): number[];\n   * ```\n   * \u23ed\ufe0f  `function fn(a: number): number[];`\n   *\n   * \u23ed\ufe0f  `function fn(a: number[], opts: { ... }): number[];`\n   */\n  FUNCTION_OVERLOAD = 'function-overload',\n\n  /**\n   * ```ts", "   * function fn(): number {}\n   * ```\n   * \u23ed\ufe0f  `: number`\n   */\n  FUNCTION_RETURN = 'function-return',\n  /**\n   * ```ts\n   * function fn(a: any): a is number {}\n   * ```\n   * \u23ed\ufe0f  `: a is number`\n   */\n  FUNCTION_TYPE_PREDICATE = 'function-type-predicate',\n  /**\n   * ```ts", "   * function fn<A extends string>(a: A, b: number) {}\n   * ```\n   * \u23ed\ufe0f  `: A`\n   *\n   * \u23ed\ufe0f  `: number`\n   */\n  FUNCTION_PARAMETER = 'function-parameter',\n  /**\n   * ```ts\n   * function fn<A extends string, B = [A, '']>() {}\n   * ```\n   * \u23ed\ufe0f  `<A extends string, B = [A, '']>`\n   */\n  FUNCTION_GENERIC_DEFINITION = 'function-generic-definition',\n\n  /**\n   * ```ts\n   * const name = get<UserModule>(userModule, 'info.name');\n   * const userModel = new UserModel<UserEntity>({ ... });\n   * ```\n   * \u23ed\ufe0f  `<UserModule>`\n   *\n   * \u23ed\ufe0f  `<UserEntity>`\n   */\n  FUNCTION_CALL_GENERIC = 'function-call-generic',\n  /**\n   * ```ts\n   * const EditUserForm = <ProForm<UserModel> id={userId} />;\n   * ```\n   * \u23ed\ufe0f  `<UserModel>`\n   */\n  TSX_COMPONENT_GENERIC = 'tsx-component-generic',\n\n  /**\n   * ```ts\n   * const a: number = 1;\n   * ```\n   * \u23ed\ufe0f  `: number`\n   */\n  VARIABLE_TYPE_DEFINITION = 'variable-type-definition',\n\n  /**\n   * ```ts", "   * function fn<A extends string, B = [A, '']>() {}\n   * ```\n   * \u23ed\ufe0f  `<A extends string, B = [A, '']>`\n   */\n  FUNCTION_GENERIC_DEFINITION = 'function-generic-definition',\n\n  /**\n   * ```ts\n   * const name = get<UserModule>(userModule, 'info.name');\n   * const userModel = new UserModel<UserEntity>({ ... });\n   * ```\n   * \u23ed\ufe0f  `<UserModule>`\n   *\n   * \u23ed\ufe0f  `<UserEntity>`\n   */\n  FUNCTION_CALL_GENERIC = 'function-call-generic',\n  /**\n   * ```ts\n   * const EditUserForm = <ProForm<UserModel> id={userId} />;\n   * ```\n   * \u23ed\ufe0f  `<UserModel>`\n   */\n  TSX_COMPONENT_GENERIC = 'tsx-component-generic',\n\n  /**\n   * ```ts\n   * const a: number = 1;\n   * ```\n   * \u23ed\ufe0f  `: number`\n   */\n  VARIABLE_TYPE_DEFINITION = 'variable-type-definition',\n\n  /**\n   * ```ts", "   * class A {\n   *   public size?: number;\n   *   private setSize!: Function = () => {}\n   * }\n   * ```\n   * \u23ed\ufe0f  `?: number`\n   *\n   * \u23ed\ufe0f  `!: Function`\n   */\n  CLASS_PROPERTY_TYPE_DEFINITION = 'class-property-type-definition',\n\n  /**\n   * ```ts\n   * const num: any = 77;\n   * const num1 = (<number>num).toFixed(2);\n   * ```\n   * \u23ed\ufe0f  `<number>`\n   */\n  ANGLE_BRACKETS_ASSERTION = 'angle-brackets-assertion',\n\n  /**\n   * ```ts\n   * fn() as any;\n   * ```\n   * \u23ed\ufe0f  ` as any`\n   */\n  AS_ASSERTION = 'as-assertion',\n\n  /**\n   * ```ts\n   * const user = { ... } satisfies UserModel;\n   * ```\n   * \u23ed\ufe0f  ` satisfies UserModel`\n   */\n  SATISFIES_OPERATOR = 'satisfies-operator',\n  /**\n   * ```ts\n   * declare const a: number;", "   * declare function b(): number;\n   * declare class c {}\n   * declare module d {}\n   * declare namespace e {}\n   * declare enum f {}\n   * declare global {}\n   * declare module 'g' {}\n   * ```\n   * \u23ed\ufe0f  \ud83d\udc46 All statements that begin with `declare`\n   */\n  DECLARE_STATEMENT = 'declare-statement'\n}\n"]}
{"filename": "src/core/helpers/type-analyzer/index.ts", "chunked_list": ["import { isEqual } from 'lodash-es';\nimport ts from 'typescript';\nimport { TYPE_KIND } from './constants';\n\nexport interface AnalyzedType {\n  kind: TYPE_KIND;\n  range: ts.TextRange;\n  text: string;\n}\n\nexport class TypeAnalyzer {\n  public sourceFile: ts.SourceFile;\n  public analyzedTypes: AnalyzedType[] = [];\n\n  constructor(code: string, isTSX = false) {\n    this.sourceFile = ts.createSourceFile(\n      `temp.ts${isTSX ? 'x' : ''}`,\n      code,\n      ts.ScriptTarget.Latest,\n      true,\n      isTSX ? ts.ScriptKind.TSX : ts.ScriptKind.TS\n    );\n  }\n\n  analyze() {\n    this.visit(this.sourceFile, null);\n    this.cleanAnalyzedTypes();\n\n    return this.analyzedTypes;\n  }\n\n  private cleanAnalyzedTypes() {\n    clearUselessTypes.call(this);\n    clearLineBreakOfStartOrEnd.call(this);\n\n    return;\n", "export class TypeAnalyzer {\n  public sourceFile: ts.SourceFile;\n  public analyzedTypes: AnalyzedType[] = [];\n\n  constructor(code: string, isTSX = false) {\n    this.sourceFile = ts.createSourceFile(\n      `temp.ts${isTSX ? 'x' : ''}`,\n      code,\n      ts.ScriptTarget.Latest,\n      true,\n      isTSX ? ts.ScriptKind.TSX : ts.ScriptKind.TS\n    );\n  }\n\n  analyze() {\n    this.visit(this.sourceFile, null);\n    this.cleanAnalyzedTypes();\n\n    return this.analyzedTypes;\n  }\n\n  private cleanAnalyzedTypes() {\n    clearUselessTypes.call(this);\n    clearLineBreakOfStartOrEnd.call(this);\n\n    return;\n", "    function clearLineBreakOfStartOrEnd(this: TypeAnalyzer) {\n      this.analyzedTypes.forEach(type => {\n        const oldTextLength = type.text.length;\n\n        type.text = type.text.replace(/^[\\r\\n]+/, '');\n        const startLineBreakCount = oldTextLength - type.text.length;\n\n        type.text = type.text.replace(/[\\r\\n]+$/, '');\n        const endLineBreakCount = oldTextLength - startLineBreakCount - type.text.length;\n\n        type.range.pos += startLineBreakCount;\n        type.range.end -= endLineBreakCount;\n      });\n    }\n\n    // [1]. `declare const a: number`, [2]. `: number`. remove [2]", "    function clearUselessTypes(this: TypeAnalyzer) {\n      const indexsToRemove = new Set<number>();\n      this.analyzedTypes.forEach((type, index) => {\n        if (indexsToRemove.has(index)) return;\n\n        this.analyzedTypes.forEach((_type, _index) => {\n          if (index === _index || indexsToRemove.has(_index)) return;\n\n          if (isEqual(_type, type)) return indexsToRemove.add(index);\n\n          if (type.range.pos >= _type.range.pos) {", "          if (isEqual(_type, type)) return indexsToRemove.add(index);\n\n          if (type.range.pos >= _type.range.pos) {\n            if (type.range.end < _type.range.end) indexsToRemove.add(index);\n          }\n        });\n      });\n\n      const sortedToRemoveIndexs = Array.from(indexsToRemove).sort((a, b) => b - a);\n      sortedToRemoveIndexs.forEach(index => this.analyzedTypes.splice(index, 1));\n    }\n  }\n\n  private visit(node: ts.Node, parent: ts.Node | null) {", "    if (\n      ts.isTypeNode(node) ||\n      ts.isTypeElement(node) ||\n      ts.isTypeOfExpression(node) ||\n      ts.isTypeOperatorNode(node) ||\n      ts.isTypeParameterDeclaration(node) ||\n      ts.isTypePredicateNode(node) ||\n      ts.isTypeQueryNode(node) ||\n      ts.isTypeReferenceNode(node) ||\n      ts.isTypeAliasDeclaration(node) ||\n      ts.isInterfaceDeclaration(node) ||\n      ts.isTypeLiteralNode(node) ||\n      ts.isVariableStatement(node) ||\n      ts.isClassDeclaration(node) ||\n      ts.isModuleDeclaration(node) ||\n      ts.isEnumDeclaration(node)\n    ) {", "      if (parent) {\n        this.handleDifferentNode(parent!, node);\n      } else {\n        console.error('[Error]: parent is null');\n      }\n    } else {\n      ts.forEachChild(node, child => this.visit(child, node));\n    }\n  }\n\n  private handleDifferentNode(parent: ts.Node, child: ts.Node) {", "    type NodeHandlers = Partial<Record<ts.SyntaxKind, Function>>;\n    const parentNodeHandlers: NodeHandlers = {\n      [ts.SyntaxKind.FunctionDeclaration]: handleParentFunction.bind(this),\n      [ts.SyntaxKind.MethodDeclaration]: handleParentFunction.bind(this),\n      [ts.SyntaxKind.FunctionExpression]: handleParentFunction.bind(this),\n      [ts.SyntaxKind.ArrowFunction]: handleParentFunction.bind(this),\n      [ts.SyntaxKind.GetAccessor]: handleParentFunction.bind(this),\n      [ts.SyntaxKind.Parameter]: handleParentParameter.bind(this),\n      [ts.SyntaxKind.VariableDeclaration]: handleParentVariableDeclaration.bind(this),\n      [ts.SyntaxKind.AsExpression]: handleParentAsOrSatisfiesExpr.bind(this),\n      [ts.SyntaxKind.SatisfiesExpression]: handleParentAsOrSatisfiesExpr.bind(this),\n      [ts.SyntaxKind.TypeAssertionExpression]: handleParentTypeAssertionExpr.bind(this),\n      [ts.SyntaxKind.CallExpression]: handleParentCallOrNewExpr.bind(this),\n      [ts.SyntaxKind.NewExpression]: handleParentCallOrNewExpr.bind(this),\n      [ts.SyntaxKind.PropertyDeclaration]: handleParentPropertyDeclaration.bind(this),\n      [ts.SyntaxKind.JsxSelfClosingElement]: handleParentJsxElement.bind(this)\n    };\n\n    const childNodeHandlers: NodeHandlers = {\n      [ts.SyntaxKind.InterfaceDeclaration]: handleChildInterfaceOrTypeAlias.bind(this),\n      [ts.SyntaxKind.TypeAliasDeclaration]: handleChildInterfaceOrTypeAlias.bind(this),\n      [ts.SyntaxKind.VariableStatement]: handleChildDeclareStatement.bind(this),\n      [ts.SyntaxKind.ClassDeclaration]: handleChildDeclareStatement.bind(this),\n      [ts.SyntaxKind.ModuleDeclaration]: handleChildDeclareStatement.bind(this),\n      [ts.SyntaxKind.EnumDeclaration]: handleChildDeclareStatement.bind(this),\n      [ts.SyntaxKind.GetAccessor]: handleChildGetOrSetAccessor.bind(this),\n      [ts.SyntaxKind.SetAccessor]: handleChildGetOrSetAccessor.bind(this)\n    };\n\n    parentNodeHandlers[parent.kind]?.(parent, child);\n    childNodeHandlers[child.kind]?.(child);\n\n    return;\n\n    // [tsx] context: `<Component<number, string> .../>`, get `<number, string>`", "    function handleParentJsxElement(\n      this: TypeAnalyzer,\n      parent: ts.JsxSelfClosingElement,\n      curChild: ts.Node\n    ) {\n      if (parent.typeArguments && parent.typeArguments.length > 0) {\n        const children = parent.getChildren(this.sourceFile);\n        const startIndex = children.findIndex(\n          child => child.pos === parent.typeArguments![0].pos\n        );\n        const endIndex = children.findIndex(\n          child => child.pos === parent.typeArguments!.at(-1)!.end\n        );\n        // <\n        const prevNode = children[startIndex - 1];\n        // >\n        const nextNode = children[endIndex + 1];\n        return this.pushAnalyzedType(TYPE_KIND.TSX_COMPONENT_GENERIC, [\n          prevNode.end - 1,\n          nextNode.pos\n        ]);\n      }\n    }\n", "    // [class] context: `class A { a?: number }`, get `?: number`\n    function handleParentPropertyDeclaration(\n      this: TypeAnalyzer,\n      parent: ts.PropertyDeclaration,\n      curChild: ts.Node\n    ) {\n      if (curChild === parent.type) {\n        const children = parent.getChildren(this.sourceFile);\n        const index = children.findIndex(child => child.pos === parent.type!.pos);\n        // :\n        const prevNode = children[index - 1];\n        // ? or !\n        const operatorNode = children[index - 2];\n        const hasOperatorNode = [\n          ts.SyntaxKind.QuestionToken,\n          ts.SyntaxKind.ExclamationToken\n        ].includes(operatorNode.kind);\n        return this.pushAnalyzedType(TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION, [\n          hasOperatorNode ? operatorNode.end - 1 : prevNode.end - 1,\n          parent.type!.end\n        ]);\n      }\n    }\n\n    // parent = `fn<number>()` | `new fn<number>()`, get `<number>`(typeArguments)", "    function handleParentCallOrNewExpr(\n      this: TypeAnalyzer,\n      parent: ts.CallExpression | ts.NewExpression,\n      curChild: ts.Node\n    ) {\n      if (parent.typeArguments && parent.typeArguments.length > 0) {\n        const children = parent.getChildren(this.sourceFile);\n\n        const startIndex = children.findIndex(\n          child => child.pos === parent.typeArguments![0].pos\n        );\n        const endIndex = children.findIndex(\n          child => child.end === parent.typeArguments!.at(-1)!.end\n        );\n        // <\n        const prevNode = children[startIndex - 1];\n        // >\n        const nextNode = children[endIndex + 1];\n        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_CALL_GENERIC, [\n          prevNode.end - 1,\n          nextNode.pos + 1\n        ]);\n      }\n    }\n\n    // context: `<number>a`, get `<number>`", "    function handleParentTypeAssertionExpr(\n      this: TypeAnalyzer,\n      parent: ts.TypeAssertion,\n      curChild: ts.Node\n    ) {\n      const children = parent.getChildren(this.sourceFile);\n      const index = children.findIndex(\n        child => child.pos === curChild.pos && child.end === curChild.end\n      );\n      // <\n      const prevNode = children[index - 1];\n      // >\n      const nextNode = children[index + 1];\n\n      return this.pushAnalyzedType(TYPE_KIND.ANGLE_BRACKETS_ASSERTION, [\n        prevNode.end - 1,\n        nextNode.pos + 1\n      ]);\n    }\n\n    // context = `a as number` | `a satisfies number`, curChild = `number`", "    function handleParentAsOrSatisfiesExpr(\n      this: TypeAnalyzer,\n      parent: ts.AsExpression | ts.SatisfiesExpression,\n      curChild: ts.Node\n    ) {\n      const children = parent.getChildren(this.sourceFile);\n      const index = children.findIndex(\n        child => child.pos === curChild.pos && child.end === curChild.end\n      );\n      // as, satisfies\n      const prevNode = children[index - 1];\n      const kind =\n        prevNode.kind === ts.SyntaxKind.AsKeyword\n          ? TYPE_KIND.AS_ASSERTION\n          : TYPE_KIND.SATISFIES_OPERATOR;\n\n      return this.pushAnalyzedType(kind, [prevNode.pos, curChild.end]);\n    }\n\n    // VariableStatement, ClassDeclaration, ModuleDeclaration, EnumDeclaration", "    function handleChildDeclareStatement(\n      this: TypeAnalyzer,\n      child:\n        | ts.VariableStatement\n        | ts.ClassDeclaration\n        | ts.ModuleDeclaration\n        | ts.EnumDeclaration\n    ) {\n      const hasDeclareKeyword = child.modifiers?.some(\n        modifier => modifier.kind === ts.SyntaxKind.DeclareKeyword\n      );\n", "      if (hasDeclareKeyword) {\n        this.pushAnalyzedType(TYPE_KIND.DECLARE_STATEMENT, [child.pos, child.end]);\n      } else {\n        ts.forEachChild(child, _child => this.visit(_child, child));\n      }\n    }\n\n    // context = `const a: number`, curChild = `number`, get `: number`\n    function handleParentVariableDeclaration(\n      this: TypeAnalyzer,\n      parent: ts.VariableDeclaration,\n      curChild: ts.Node\n    ) {\n      const children = parent.getChildren(this.sourceFile);\n      const index = children.findIndex(\n        child => child.pos === curChild.pos && child.end === curChild.end\n      );\n      // :\n      const prevNode = children[index - 1];\n      // !\n      const operatorNode = children[index - 2];\n      const hasOperatorNode = operatorNode.kind === ts.SyntaxKind.ExclamationToken;\n      this.pushAnalyzedType(TYPE_KIND.VARIABLE_TYPE_DEFINITION, [\n        hasOperatorNode ? operatorNode.end - 1 : prevNode.end - 1,\n        curChild.end\n      ]);\n    }\n", "    function handleParentVariableDeclaration(\n      this: TypeAnalyzer,\n      parent: ts.VariableDeclaration,\n      curChild: ts.Node\n    ) {\n      const children = parent.getChildren(this.sourceFile);\n      const index = children.findIndex(\n        child => child.pos === curChild.pos && child.end === curChild.end\n      );\n      // :\n      const prevNode = children[index - 1];\n      // !\n      const operatorNode = children[index - 2];\n      const hasOperatorNode = operatorNode.kind === ts.SyntaxKind.ExclamationToken;\n      this.pushAnalyzedType(TYPE_KIND.VARIABLE_TYPE_DEFINITION, [\n        hasOperatorNode ? operatorNode.end - 1 : prevNode.end - 1,\n        curChild.end\n      ]);\n    }\n", "    function handleChildGetOrSetAccessor(\n      this: TypeAnalyzer,\n      curChild: ts.GetAccessorDeclaration | ts.SetAccessorDeclaration\n    ) {\n      ts.forEachChild(curChild, _child => this.visit(_child, curChild));\n    }\n\n    function handleChildInterfaceOrTypeAlias(\n      this: TypeAnalyzer,\n      child: ts.InterfaceDeclaration | ts.TypeAliasDeclaration\n    ) {\n      const kind =\n        child.kind === ts.SyntaxKind.InterfaceDeclaration\n          ? TYPE_KIND.INTERFACE\n          : TYPE_KIND.TYPE_ALIAS;\n      this.pushAnalyzedType(kind, [child.pos, child.end]);\n    }\n\n    // context = `a: number`, curChild = `number`", "    function handleParentParameter(\n      this: TypeAnalyzer,\n      parent: ts.ParameterDeclaration,\n      curChild: ts.Node\n    ) {\n      const children = parent.getChildren(this.sourceFile);\n      const index = children.findIndex(\n        child => child.pos === curChild.pos && child.end === curChild.end\n      );\n      // :\n      const prevNode = children[index - 1];\n      // ?\n      const optionalNode = children[index - 2];\n      const hasOptionalNode = optionalNode.kind === ts.SyntaxKind.QuestionToken;\n\n      this.pushAnalyzedType(TYPE_KIND.FUNCTION_PARAMETER, [\n        hasOptionalNode ? optionalNode.pos : prevNode.pos,\n        curChild.end\n      ]);\n    }\n\n    // FunctionDeclaration | MethodDeclaration | FunctionExpression", "    function handleParentFunction(\n      this: TypeAnalyzer,\n      parent: ts.FunctionDeclaration | ts.MethodDeclaration | ts.FunctionExpression,\n      curChild: ts.Node\n    ) {\n      const hasDeclareKeyword = parent.modifiers?.some(\n        modifier => modifier.kind === ts.SyntaxKind.DeclareKeyword\n      );\n      if (hasDeclareKeyword) {\n        return this.pushAnalyzedType(TYPE_KIND.DECLARE_STATEMENT, [\n          parent.pos,\n          parent.end\n        ]);\n      }\n", "      if (hasDeclareKeyword) {\n        return this.pushAnalyzedType(TYPE_KIND.DECLARE_STATEMENT, [\n          parent.pos,\n          parent.end\n        ]);\n      }\n\n      // function a<B extends 222>(test: ...): void;\n      const isOverload = parent.body === undefined;\n      if (isOverload) {\n        // public a<B extends 222>(test: ...): void;", "      if (isOverload) {\n        // public a<B extends 222>(test: ...): void;\n        if (ts.isMethodDeclaration(parent)) {\n          let startPos = parent.name.end;\n          if (parent.modifiers && parent.modifiers.length > 0) {\n            startPos = parent.modifiers[0].pos;\n          }\n          return this.pushAnalyzedType(TYPE_KIND.FUNCTION_OVERLOAD, [\n            startPos,\n            parent.end\n          ]);\n        } else {\n          return this.pushAnalyzedType(TYPE_KIND.FUNCTION_OVERLOAD, [\n            parent.pos,\n            parent.end\n          ]);\n        }\n      }\n\n      const children = parent.getChildren(this.sourceFile);\n      const index = children.findIndex(\n        child => child.pos === curChild.pos && child.end === curChild.end\n      );\n", "      // \u2193\u2193 function a<B extends 222>(test: ...) { ... } \u2193\u2193\n      if (ts.isTypeParameterDeclaration(curChild) && parent.typeParameters) {\n        // children.slice(startIndex, endIndex) = B extends 222, C extends ...\n        const startIndex = children.findIndex(\n          child => child.pos === parent.typeParameters!.pos\n        );\n        const endIndex = children.findIndex(\n          child => child.end === parent.typeParameters!.end\n        );\n        // <\n        const prevNode = children[startIndex - 1];\n        // >\n        const nextNode = children[endIndex + 1];\n        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_GENERIC_DEFINITION, [\n          prevNode.end - 1,\n          nextNode.pos + 1\n        ]);\n      }\n", "      if (ts.isTypePredicateNode(curChild)) {\n        // children[index], node = x is any\n        // :\n        const prevNode = children[index - 1];\n        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_TYPE_PREDICATE, [\n          prevNode.end - 1,\n          curChild.end\n        ]);\n      }\n\n      if (parent.type === curChild) {", "      if (parent.type === curChild) {\n        // children[index], node = function return type\n        // :\n        const prevNode = children[index - 1];\n        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_RETURN, [\n          prevNode.end - 1,\n          curChild.end\n        ]);\n      }\n    }\n  }\n\n  private pushAnalyzedType(\n    kind: AnalyzedType['kind'],\n    range: [pos: number, end: number]\n  ) {\n    const [pos, end] = range;\n    const text = this.sourceFile.text.slice(pos, end);\n    this.analyzedTypes.push({ kind, range: { pos, end }, text });\n  }\n}\n"]}
