{"filename": "src/types.ts", "chunked_list": ["import {Job} from 'prisma/prisma-client';\n\nexport type TJob = Omit<Job, 'id' | 'job_name' | 'created_date'>;\n"]}
{"filename": "src/server.ts", "chunked_list": ["require('dotenv').config();\nconst http = require('http');\nimport {scraper} from './modules/scraper';\nimport {collectCompanies} from './modules/companies';\nimport {cli} from './modules/cli';\nimport {gatheringCompanies, generateCoverLetter, getJD, getUserInformation, startScarpData, updateInformation} from './modules/telegram';\n\ngenerateCoverLetter();\ngetUserInformation();\nstartScarpData();", "getUserInformation();\nstartScarpData();\nupdateInformation();\ngatheringCompanies();\ngetJD()\n\nexport async function runScripts(locations?: string[], keyword?: string, description?: boolean) {\n  if (locations && keyword) {\n    console.log('we are here');\n    await scraper(locations, keyword, description);\n    return;\n  }\n  const userArgs = await cli();", "  if (userArgs) {\n    await collectCompanies();\n    console.log(userArgs);\n    await scraper(userArgs.locations, userArgs.keyword, userArgs.d);\n  }\n}\n\nconst server = http.createServer((req: any, res: any) => {\n  if (req.method === 'GET' && req.url === '/start') {\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.write(JSON.stringify({message: 'Script ran'}));\n    res.end();\n    void runScripts(['Amsterdam'], 'react', false);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.write('404 Not Found\\n');\n    res.end();\n  }\n});\n\nconst PORT = process.env.PORT || 6000;\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`);\n});\n", "  if (req.method === 'GET' && req.url === '/start') {\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.write(JSON.stringify({message: 'Script ran'}));\n    res.end();\n    void runScripts(['Amsterdam'], 'react', false);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.write('404 Not Found\\n');\n    res.end();\n  }\n});\n\nconst PORT = process.env.PORT || 6000;\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`);\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["require('dotenv').config();\nimport {scraper} from './modules/scraper';\nimport {collectCompanies} from './modules/companies';\nimport {cli} from './modules/cli';\n\nexport async function runScripts() {\n  const userArgs = await cli();\n  if (userArgs) {\n    await collectCompanies();\n    await scraper(userArgs.locations, userArgs.keyword, userArgs.d);\n  }\n}\n\nvoid runScripts();\n"]}
{"filename": "src/modules/cli/index.ts", "chunked_list": ["import yargs from 'yargs';\nimport {hideBin} from 'yargs/helpers';\n\nexport type TCli = {\n  locations: string[];\n  keyword: string;\n  d: boolean;\n};\n\nexport async function cli(): Promise<TCli | undefined> {\n  try {\n    const argv = await yargs(hideBin(process.argv))\n      .option('locations', {\n        type: 'array',\n        description: 'List of locations',\n        demandOption: true,\n        coerce: arg => (typeof arg === 'string' ? [arg] : arg),\n      })\n      .option('keyword', {\n        type: 'string',\n        description: 'Keyword for searching',\n        demandOption: true,\n        coerce: arg => arg,\n      })\n      .option('d', {\n        type: 'boolean',\n        description: 'Get Description or not? (default is False)',\n        default: false,\n      }).argv;\n\n    return {\n      locations: argv.locations,\n      keyword: argv.keyword,\n      d: argv.d,\n    } as TCli;", "export async function cli(): Promise<TCli | undefined> {\n  try {\n    const argv = await yargs(hideBin(process.argv))\n      .option('locations', {\n        type: 'array',\n        description: 'List of locations',\n        demandOption: true,\n        coerce: arg => (typeof arg === 'string' ? [arg] : arg),\n      })\n      .option('keyword', {\n        type: 'string',\n        description: 'Keyword for searching',\n        demandOption: true,\n        coerce: arg => arg,\n      })\n      .option('d', {\n        type: 'boolean',\n        description: 'Get Description or not? (default is False)',\n        default: false,\n      }).argv;\n\n    return {\n      locations: argv.locations,\n      keyword: argv.keyword,\n      d: argv.d,\n    } as TCli;", "  } catch (err) {\n    console.log(err);\n  }\n}\n"]}
{"filename": "src/modules/companies/siaExplains.ts", "chunked_list": ["import prisma from '../db';\nimport {createDriver} from '../driver';\nimport {By} from 'selenium-webdriver';\n\nexport const siaExplains = async () => {\n  const driver = await createDriver();\n\n  try {\n    await driver.get('https://siaexplains.github.io/visa-sponsorship-companies/');\n    await driver.sleep(3000);\n    const parentElement = await driver.findElements(By.className('odd:bg-white'));\n    const companies: string[] = [];", "    for (const element of parentElement) {\n      const childElement = await element.findElement(By.css('td:first-child'));\n      const company = await childElement.getText();\n      companies.push(company.toLocaleLowerCase());\n    }\n    let newCompanies = 0;\n    for (const el of companies) {\n      const isExist = await prisma.companies.findUnique({\n        where: {\n          name: el,\n        },\n      });", "      if (!isExist) {\n        newCompanies = newCompanies + 1;\n        await prisma.companies.create({data: {name: el, source: 'siaexplains'}});\n      }\n    }\n    return {newCompanies, companies: companies.length};\n  } catch (err) {\n    console.log(err);\n  } finally {\n    await driver.quit();\n  }\n};\n", "  } finally {\n    await driver.quit();\n  }\n};\n"]}
{"filename": "src/modules/companies/relocateMe.ts", "chunked_list": ["import prisma from '../db';\nimport {createDriver} from '../driver';\nimport {By} from 'selenium-webdriver';\n\nexport const relocateMe = async () => {\n  const driver = await createDriver();\n\n  try {\n    await driver.get('https://relocate.me/companies');\n    await driver.sleep(3000);\n    const parentElement = await driver.findElements(By.className('wwbc-companies__link'));\n    const companies: string[] = [];", "    for (const element of parentElement) {\n      const childElement = await element.findElement(By.css('span:first-child'));\n      const company = await childElement.getText();\n      companies.push(company.toLocaleLowerCase());\n    }\n    let newCompanies = 0;\n    for (const el of companies) {\n      const isExist = await prisma.companies.findUnique({\n        where: {\n          name: el,\n        },\n      });", "      if (!isExist) {\n        newCompanies = newCompanies + 1;\n        await prisma.companies.create({data: {name: el, source: 'relocate.me'}});\n      }\n    }\n    return {newCompanies, companies: companies.length};\n  } catch (err) {\n    console.log(err);\n  } finally {\n    await driver.quit();\n  }\n};\n", "  } finally {\n    await driver.quit();\n  }\n};\n"]}
{"filename": "src/modules/companies/index.ts", "chunked_list": ["import {relocateMe} from './relocateMe';\nimport {siaExplains} from './siaExplains';\n\ntype companiesData = {\n  relocateCom: Record<string, number>;\n  newCompanies: number;\n  siaExplains: Record<string, number>;\n};\n\nexport async function collectCompanies(): Promise<companiesData | undefined> {\n  try {\n    const companiesData: companiesData = {\n      newCompanies: 0,\n      relocateCom: {\n        companies: 0,\n      },\n      siaExplains: {\n        newCompanies: 0,\n        companies: 0,\n      },\n    };\n    const relocateCom = await relocateMe();", "export async function collectCompanies(): Promise<companiesData | undefined> {\n  try {\n    const companiesData: companiesData = {\n      newCompanies: 0,\n      relocateCom: {\n        companies: 0,\n      },\n      siaExplains: {\n        newCompanies: 0,\n        companies: 0,\n      },\n    };\n    const relocateCom = await relocateMe();", "    if (relocateCom) {\n      companiesData.relocateCom.companies = relocateCom.companies;\n      companiesData.newCompanies += relocateCom.newCompanies;\n    }\n\n    const siaExplainData = await siaExplains();\n    if (siaExplainData) {\n      companiesData.siaExplains.companies = siaExplainData.companies;\n      companiesData.newCompanies += siaExplainData.newCompanies;\n    }\n    return companiesData;", "  } catch (err) {\n    console.log(err);\n  }\n}\n"]}
{"filename": "src/modules/scraper/jobCollector.ts", "chunked_list": ["import {By, until} from 'selenium-webdriver';\nimport {createDriver} from '../driver';\nimport {elementGetter} from './elements';\nimport {isExcludedByTitle} from './isExcludedByTitle';\nimport {TJob} from '../../types';\n\nexport async function jobCollector(locations: string[], keyword: string) {\n  const driver = await createDriver();\n  const jobs: TJob[] = [];\n  try {\n    for (const location of locations) {\n      const keywords = encodeURI(keyword);\n      await driver.get(\n        `https://www.linkedin.com/jobs/search?keywords=${keywords}&location=${location}&f_TPR=r86400&trk=public_jobs_jobs-search-bar_search-submit&position=1&pageNum=0`,\n      );\n      /* \n        **FOR Getting All Job Element**\n        const jobCount = await driver.findElement(By.className('results-context-header__job-count'))?.getText();\n        Math.ceil(+jobCount)\n        with Select on Show More Button!\n      */", "  try {\n    for (const location of locations) {\n      const keywords = encodeURI(keyword);\n      await driver.get(\n        `https://www.linkedin.com/jobs/search?keywords=${keywords}&location=${location}&f_TPR=r86400&trk=public_jobs_jobs-search-bar_search-submit&position=1&pageNum=0`,\n      );\n      /* \n        **FOR Getting All Job Element**\n        const jobCount = await driver.findElement(By.className('results-context-header__job-count'))?.getText();\n        Math.ceil(+jobCount)\n        with Select on Show More Button!\n      */", "      for (let i = 0; i < 4; i++) {\n        // Scroll to the bottom of the page\n        await driver.executeScript('window.scrollTo(0, document.body.scrollHeight);');\n\n        // Wait for new content to load\n        await driver.wait(until.elementLocated(By.css('ul.jobs-search__results-list>li')));\n\n        // Wait for some additional time to allow the page to fully render\n        await driver.sleep(3000);\n      }\n\n      // Get job listings\n      console.log('before listing...');\n      const jobElements = await driver.findElements(By.css('ul.jobs-search__results-list>li'));\n      console.log(jobElements.length, `count of jobs for ${location}`);", "      for (const el of jobElements) {\n        const title = await elementGetter({el, selector: 'h3.base-search-card__title'});\n        const company = await elementGetter({\n          el,\n          selector: '[data-tracking-control-name=\"public_jobs_jserp-result_job-search-card-subtitle\"]',\n        });\n        const location = await elementGetter({el, selector: 'span.job-search-card__location'});\n        const time = await elementGetter({el, selector: 'time'});\n        const link = await elementGetter({el, selector: 'a.base-card__full-link', method: 'attribute', attr: 'href'});\n        if (isExcludedByTitle(title.toLocaleLowerCase()) && link.length > 1) {\n          jobs.push({\n            title: title.toLocaleLowerCase(),\n            company,\n            location,\n            time,\n            link,\n            visa: false,\n            description: '',\n            source: 'Linkedin',\n          });\n        } else {\n          console.log('filtered by title:', title);\n        }\n      }\n    }\n    return jobs;", "        if (isExcludedByTitle(title.toLocaleLowerCase()) && link.length > 1) {\n          jobs.push({\n            title: title.toLocaleLowerCase(),\n            company,\n            location,\n            time,\n            link,\n            visa: false,\n            description: '',\n            source: 'Linkedin',\n          });\n        } else {\n          console.log('filtered by title:', title);\n        }\n      }\n    }\n    return jobs;", "  } catch (err) {\n    console.log(err);\n  } finally {\n    // Close the browser\n    await driver?.quit();\n  }\n}\n"]}
{"filename": "src/modules/scraper/filterKeywords.ts", "chunked_list": ["import {TJob} from 'types';\nimport {createDriver} from '../driver';\nimport {By} from 'selenium-webdriver';\nimport prisma from '../db';\nimport {cleanedText} from '../../helper/cleanedText';\nimport {jobDescriptionClicker} from './elements';\n\nexport async function filterKeyword(jobs: TJob[]): Promise<TJob[]> {\n  const driver = await createDriver();\n  const jobItems = jobs.filter(job => job.link.length > 1);\n  try {\n    const filteredJobs: TJob[] = [];", "  try {\n    const filteredJobs: TJob[] = [];\n    for (const job of jobItems) {\n      console.log('finding keywords ...', job.link);\n      await driver.get(job.link);\n      await jobDescriptionClicker(driver);\n      await driver.sleep(3000);\n      const element = await driver.findElement(By.className('core-section-container'));\n      const text = await element.getText();\n      await driver.sleep(3000);\n      const companyName = text.toLocaleLowerCase();\n      const haveVisa =\n        (await prisma.companies.findUnique({where: {name: companyName}})) ||\n        text.toLocaleLowerCase().includes('visa sponsorship');\n      job.visa = !!haveVisa;\n      job.description = cleanedText(text).substring(0, 300) + '...';\n      filteredJobs.push(job);\n      const handles = await driver.getAllWindowHandles();", "      for (let i = 1; i < handles.length; i++) {\n        await driver.switchTo().window(handles[i]);\n        await driver.close();\n      }\n      await driver.switchTo().window(handles[0]);\n    }\n    return filteredJobs;\n  } catch (err) {\n    console.log(err);\n    await driver.quit();\n    throw new Error('filtered broken');", "  } finally {\n    await driver?.quit();\n  }\n}\n"]}
{"filename": "src/modules/scraper/parsPath.ts", "chunked_list": ["const url = require('url');\n\nexport function parsPath(jobUrl: string) {\n  const pathName = validateURL(jobUrl) ? url?.parse(jobUrl)?.pathname : '';\n  return pathName.split('/').pop();\n}\n\nexport function validateURL(url: string) {\n  let valid = true;\n  try {\n    new URL(url);", "  try {\n    new URL(url);\n  } catch (error) {\n    valid = false;\n  } finally {\n    return valid;\n  }\n}\n"]}
{"filename": "src/modules/scraper/isExcludedByTitle.ts", "chunked_list": ["export function isExcludedByTitle(title: string): boolean {\n  // const keywords = ['junior', 'no visa sponsorship', 'no visasponsorship', 'no visa', 'entry level', 'remote'];\n  const keywords = (process.env.TITLE_FILTER_KEYWORDS as string).split(',').map(el => el.trim());\n  const forceKeyword = (process.env.TITLE_MUST_KEYWORD as string).split(',').map(el => el.trim());\n  return !keywords.some(keyword => title.includes(keyword)) && forceKeyword.some(keyword => title.includes(keyword));\n}\n"]}
{"filename": "src/modules/scraper/index.ts", "chunked_list": ["import {jobCollector} from './jobCollector';\nimport {filterKeyword} from './filterKeywords';\nimport {checkAndSaveJobs} from './saveJobs';\nimport TelegramBot from 'node-telegram-bot-api';\n\nexport const scraper = async (\n  locations: string[],\n  keyword: string,\n  isCheckDescription?: boolean,\n  bot?: TelegramBot,", "  isCheckDescription?: boolean,\n  bot?: TelegramBot,\n  chatId?: number,\n) => {\n  try {\n    const jobs = (await jobCollector(locations, keyword)) ?? [];\n    const filteredJobs = isCheckDescription ? await filterKeyword(jobs) : jobs;\n    await checkAndSaveJobs(filteredJobs, bot, chatId);\n  } catch (err) {\n    console.log(err);\n  } finally {\n    console.log('job done!');\n  }\n};\n", "  } catch (err) {\n    console.log(err);\n  } finally {\n    console.log('job done!');\n  }\n};\n"]}
{"filename": "src/modules/scraper/saveJobs.ts", "chunked_list": ["import {TJob} from 'types';\nimport {parsPath} from './parsPath';\nimport prisma from '../db';\nimport {sendJobToChannel} from '../telegram';\nimport {cleanedText} from '../../helper/cleanedText';\nimport TelegramBot from 'node-telegram-bot-api';\n\nexport async function checkAndSaveJobs(jobs: TJob[], bot?: TelegramBot, chatId?: number) {\n  let count = 0;\n  try {\n    for (const job of jobs) {\n      const job_name: string = parsPath(job?.link);\n      const existingJob = await prisma.job.findUnique({\n        where: {\n          job_name: job_name,\n        },\n      });\n", "  try {\n    for (const job of jobs) {\n      const job_name: string = parsPath(job?.link);\n      const existingJob = await prisma.job.findUnique({\n        where: {\n          job_name: job_name,\n        },\n      });\n\n      if (!existingJob) {\n        count += 1;\n        const response = await prisma.job.create({\n          data: {\n            title: job.title,\n            company: job.company,\n            location: job.location,\n            time: job.time,\n            link: job.link,\n            description: cleanedText(job.description as string),\n            job_name: job_name,\n          },\n        });\n        await sendJobToChannel(response, count, jobs.length);\n        console.log('Jobs saved to database successfully!', `${count}/${jobs.length}`);\n      }\n    }", "      if (!existingJob) {\n        count += 1;\n        const response = await prisma.job.create({\n          data: {\n            title: job.title,\n            company: job.company,\n            location: job.location,\n            time: job.time,\n            link: job.link,\n            description: cleanedText(job.description as string),\n            job_name: job_name,\n          },\n        });\n        await sendJobToChannel(response, count, jobs.length);\n        console.log('Jobs saved to database successfully!', `${count}/${jobs.length}`);\n      }\n    }", "  } catch (e: any) {\n    console.error(`Error saving jobs to database: ${e.message}`);\n  } finally {\n    if(bot && chatId) {\n      bot.sendMessage(chatId, `${jobs.length} jobs found by scraping \ud83d\ude08`);\n      bot.sendMessage(chatId, `${count} jobs are new \ud83d\ude2c`);\n    }\n    await prisma.$disconnect();\n  }\n}\n"]}
{"filename": "src/modules/scraper/getDescription.ts", "chunked_list": ["import {cleanedText} from '../../helper/cleanedText';\nimport {createDriver} from '../driver';\nimport {jobDescriptionClicker} from './elements';\nimport {By} from 'selenium-webdriver';\nimport prisma from '../db';\n\nexport async function getDescription(id: number) {\n  try {\n    const job = await prisma.job.findUnique({\n      where: {\n        id,\n      },\n    });", "    if (!job) {\n      console.log(`Job ${id} is not exist in db`);\n      return null;\n    }\n    if (job.description) {\n      return job.description;\n    }\n    const description = await scrapDescription(job.link);\n\n    const updatedJob = await prisma.job.update({\n      where: {id},\n      data: {\n        description,\n      },\n    });\n    return updatedJob?.description;", "  } catch (err) {\n    console.log(err);\n  }\n}\n\nexport async function scrapDescription(link: string) {\n  const driver = await createDriver();\n  try {\n    await driver.get(link);\n    await jobDescriptionClicker(driver);\n    await driver.sleep(5000);\n    const element = await driver.findElement(By.className('core-section-container'));\n    const text = await element.getText();\n    const editedText = cleanedText(text).substring(0, 3500);\n    return editedText;", "  } catch (err) {\n    console.log(err);\n  } finally {\n    driver?.quit();\n  }\n}\n"]}
{"filename": "src/modules/scraper/elements.ts", "chunked_list": ["import {By, WebDriver, WebElement} from 'selenium-webdriver';\n\ntype TElementGetter = {\n  el: WebElement;\n  selector: string;\n  method?: 'text' | 'attribute';\n  attr?: string;\n};\n\nexport async function elementGetter({el, selector, method = 'text', attr = 'href'}: TElementGetter) {\n  let name = '';", "export async function elementGetter({el, selector, method = 'text', attr = 'href'}: TElementGetter) {\n  let name = '';\n  try {\n    const element = await el.findElement(By.css(selector));\n    name = method == 'text' ? await element.getText() : await element.getAttribute(attr);\n  } catch {\n    name = '';\n  } finally {\n    return name;\n  }\n}\n\n", "export async function jobDescriptionClicker(el: WebDriver) {\n  try {\n    const showMoreBtn = await el.findElement(By.className('show-more-less-html__button--more'));\n    await showMoreBtn?.click();\n  }\n  catch (err){\n    console.log(\"element didn't had description\", err)\n  }\n}\n"]}
{"filename": "src/modules/openAI/index.ts", "chunked_list": ["import {sendMessageToBot} from '../telegram';\nimport {Configuration, OpenAIApi} from 'openai';\n\nexport async function getCoverLetter(jobDescription: string, chatId: number, info: string) {\n  const configuration = new Configuration({\n    apiKey: process.env.OPENAI_API_KEY,\n  });\n  const openai = new OpenAIApi(configuration);\n\n  try {\n    const res = await openai.createCompletion(\n      {\n        model: 'text-davinci-003',\n        prompt: `${info} write cover letter for below job description:\\n ${jobDescription}`,\n        max_tokens: 1000,\n        temperature: 0.5,\n        stream: true,\n      },\n      {responseType: 'stream'},\n    );\n    console.log(jobDescription, 'JOB Description');\n\n    let response = '';\n    // @ts-ignore\n    res.data.on('data', (data: any) => {\n      const lines = data\n        .toString()\n        .split('\\n')\n        .filter((line: string) => line.trim() !== '');", "  try {\n    const res = await openai.createCompletion(\n      {\n        model: 'text-davinci-003',\n        prompt: `${info} write cover letter for below job description:\\n ${jobDescription}`,\n        max_tokens: 1000,\n        temperature: 0.5,\n        stream: true,\n      },\n      {responseType: 'stream'},\n    );\n    console.log(jobDescription, 'JOB Description');\n\n    let response = '';\n    // @ts-ignore\n    res.data.on('data', (data: any) => {\n      const lines = data\n        .toString()\n        .split('\\n')\n        .filter((line: string) => line.trim() !== '');", "      for (const line of lines) {\n        const message = line.replace(/^data: /, '');\n        if (message.trim() === '[DONE]') {\n          console.log(response.trim(), 'generated cover letter finished!');\n          sendMessageToBot(response, chatId);\n          return; // Stream finished\n        }\n        try {\n          const parsed = JSON.parse(message);\n          response += parsed.choices[0].text;\n        } catch (error) {\n          console.error('Could not JSON parse stream message', message, error);\n        }\n      }\n    });", "        } catch (error) {\n          console.error('Could not JSON parse stream message', message, error);\n        }\n      }\n    });\n  } catch (error) {\n    console.log(error);\n  }\n}\n"]}
{"filename": "src/modules/db/index.ts", "chunked_list": ["import { PrismaClient } from 'prisma/prisma-client'\n\nconst prisma = new PrismaClient();\n\n(async function prismaConnection() {\n  try {\n    await prisma.$connect();\n    console.log('Connected to database successfully!');\n  } catch (e: any) {\n    console.error(`Error connecting to database: ${e.message}`);\n  } finally {\n    await prisma.$disconnect();\n  }\n})();\n\nexport default prisma;\n", "  } catch (e: any) {\n    console.error(`Error connecting to database: ${e.message}`);\n  } finally {\n    await prisma.$disconnect();\n  }\n})();\n\nexport default prisma;\n"]}
{"filename": "src/modules/telegram/index.ts", "chunked_list": ["require('dotenv').config();\nimport {companyLogoMapper} from '../../helper/countryMapper';\nimport TelegramBot from 'node-telegram-bot-api';\nimport {Job} from 'prisma/prisma-client';\nimport {getDescription} from '../scraper/getDescription';\nimport {getCoverLetter} from '../openAI';\nimport prisma from '../db';\nimport {scraper} from '../scraper';\nimport {collectCompanies} from '../companies';\n", "import {collectCompanies} from '../companies';\n\nconst botToken = `${process.env.TELEGRAM_BOT_TOKEN}`;\nconst channelName = `${process.env.TELEGRAM_CHANNEL_NAME}`;\nconst bot = new TelegramBot(botToken, {polling: true});\nlet isActionRunning = false;\n\nexport const sendJobToChannel = async (job: Job, count: number, total: number) => {\n  try {\n    const convertedDate = new Date(job.created_date!);\n    const chat = await bot.getChat(channelName);\n    const message = `<b>\ud83c\udf1f${String(job.title).toLocaleUpperCase()}</b>\\n\\nCompany: ${\n      job.company\n    }\\n\\nLocation: ${companyLogoMapper(job.location as string)}\\n\\n\ud83d\udcc6 Date: <i>${\n      convertedDate.toLocaleDateString() + ' ' + convertedDate.toLocaleTimeString()\n    }</i>\\n${job.description ? `\\n\ud83d\udd39Description: <i>${job.description}</i>\\n\\n` : ''}\\nSource:${\n      job.source === 'linkedin' ? '<strong>LinkedIn</strong>' : ''\n    }\\n${job.visa ? '<u>\ud83c\udf10#visa</u>' : ''}\\n \ud83c\udd94 <code>${job.id}</code>`;\n    const keyboard = {\n      inline_keyboard: [\n        [\n          {text: 'View Job & Apply', url: job.link},\n          {\n            text: 'Generate cover letter',\n            url: `https://t.me/${process.env.TELEGRAM_BOT_NAME}?start=cover-letter-${job.id}`,\n          },\n        ],\n      ],\n    };\n    setTimeout(async () => {\n      await bot.sendMessage(chat.id, message, {reply_markup: keyboard, parse_mode: 'HTML', disable_notification: true});\n      console.log('sent to telegram', `${count}/${total} (TOTAL(not filtered))`);\n    }, count * 5000);", "  try {\n    const convertedDate = new Date(job.created_date!);\n    const chat = await bot.getChat(channelName);\n    const message = `<b>\ud83c\udf1f${String(job.title).toLocaleUpperCase()}</b>\\n\\nCompany: ${\n      job.company\n    }\\n\\nLocation: ${companyLogoMapper(job.location as string)}\\n\\n\ud83d\udcc6 Date: <i>${\n      convertedDate.toLocaleDateString() + ' ' + convertedDate.toLocaleTimeString()\n    }</i>\\n${job.description ? `\\n\ud83d\udd39Description: <i>${job.description}</i>\\n\\n` : ''}\\nSource:${\n      job.source === 'linkedin' ? '<strong>LinkedIn</strong>' : ''\n    }\\n${job.visa ? '<u>\ud83c\udf10#visa</u>' : ''}\\n \ud83c\udd94 <code>${job.id}</code>`;\n    const keyboard = {\n      inline_keyboard: [\n        [\n          {text: 'View Job & Apply', url: job.link},\n          {\n            text: 'Generate cover letter',\n            url: `https://t.me/${process.env.TELEGRAM_BOT_NAME}?start=cover-letter-${job.id}`,\n          },\n        ],\n      ],\n    };\n    setTimeout(async () => {\n      await bot.sendMessage(chat.id, message, {reply_markup: keyboard, parse_mode: 'HTML', disable_notification: true});\n      console.log('sent to telegram', `${count}/${total} (TOTAL(not filtered))`);\n    }, count * 5000);", "  } catch (err) {\n    console.log(err);\n  }\n};\n\nexport const generateCoverLetter = () => {\n  bot.onText(/\\/coverletter (.+)/, async (msg, match: RegExpExecArray | null) => {\n    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;\n", "    if (!match) {\n      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /coverletter <job id>');\n      return;\n    }\n\n    console.log(`Request for cover letter by job id ${match?.[1]}`);\n    const response = await getDescription(+match[1]);\n    if (!response) {\n      bot.sendMessage(msg.chat.id, 'job description is not exist' + response);\n      return;\n    }\n", "    try {\n      const information = await prisma.information.findFirst();\n      bot.sendMessage(msg.chat.id, information ? 'loading...' : 'information is not found');\n      if (information) await getCoverLetter(response, msg.chat.id, information?.description);\n    } catch (error) {\n      console.error(error);\n      bot.sendMessage(msg.chat.id, 'Failed to generate cover letter.');\n    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n\nexport const getUserInformation = () => {\n  bot.onText(/\\/information (.+)/, async (msg, match: RegExpExecArray | null) => {", "    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;\n    if (!match || !match[1]) {\n      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /information <user information>');\n      return;\n    }\n\n    try {\n      const isInformationExist = await prisma.information.findFirst();", "    try {\n      const isInformationExist = await prisma.information.findFirst();\n      if (!!isInformationExist) {\n        throw new Error('you have information please remove or edit!');\n      }\n      const information = await prisma.information.create({data: {description: match[1]}});\n      if (information) {\n        bot.sendMessage(msg.chat.id, 'Your data saved...');\n        return;\n      }\n      throw new Error(\"Your information Can't saved please check your message!\");", "    } catch (error) {\n      bot.sendMessage(msg.chat.id, (error as Error)?.message || 'failed to save data please try few minutes later!');\n    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n\nexport const updateInformation = () => {\n  bot.onText(/\\/information_update (.+)/, async (msg, match: RegExpExecArray | null) => {\n    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;", "    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;\n    if (!match || !match[1]) {\n      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /information <user information>');\n      return;\n    }\n\n    try {\n      const information = await prisma.information.findFirst();", "    try {\n      const information = await prisma.information.findFirst();\n      if (information) {\n        const response = await prisma.information.update({\n          data: {description: match[1]},\n          where: {id: information.id},\n        });\n        if (response) {\n          bot.sendMessage(msg.chat.id, 'Your data updated successfully...');\n        }\n        return;\n      }\n      bot.sendMessage(msg.chat.id, 'You must first add information with /information <message>');", "    } catch (error) {\n      bot.sendMessage(msg.chat.id, 'failed to save data please try few minutes later!');\n    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n\nexport const sendMessageToBot = async (message: string, chatId: number) => {\n  try {\n    bot.sendMessage(chatId, message);", "  try {\n    bot.sendMessage(chatId, message);\n  } catch (err) {\n    console.log(err);\n  }\n};\n\nexport const startScarpData = () => {\n  bot.onText(/\\/start (.+)/, async (msg, match: RegExpExecArray | null) => {\n    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;", "    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;\n    if (!match || !match[1]) {\n      bot.sendMessage(msg.chat.id, 'Your arguments is not valid');\n      return;\n    }\n\n    if (match[0].includes('cover-letter')) {\n      const jobId = match[0].split('-')?.[2];\n      const response = await getDescription(+jobId);", "    if (match[0].includes('cover-letter')) {\n      const jobId = match[0].split('-')?.[2];\n      const response = await getDescription(+jobId);\n      if (!response) {\n        bot.sendMessage(msg.chat.id, 'job description is not exist' + response);\n        return;\n      }\n\n      try {\n        const information = await prisma.information.findFirst();\n        bot.sendMessage(msg.chat.id, information ? 'loading...' : 'information is not found');", "      try {\n        const information = await prisma.information.findFirst();\n        bot.sendMessage(msg.chat.id, information ? 'loading...' : 'information is not found');\n        if (information) await getCoverLetter(response, msg.chat.id, information?.description);\n      } catch (error) {\n        console.error(error);\n        bot.sendMessage(msg.chat.id, 'Failed to generate cover letter.');\n      } finally {\n        isActionRunning = false;\n      }\n      return;\n    }\n\n    const args = match?.[1]?.split('-');\n    const locations = args?.[0]?.trim()?.split(',');\n    const keyword = args?.[1]?.trim();\n", "    try {\n      if (locations && keyword) {\n        bot.sendMessage(msg.chat.id, 'Your script is running \ud83c\udfb0');\n        await scraper(locations, keyword, false, bot, msg.chat.id);\n      }\n    } catch (err) {\n      console.log(err);\n      bot.sendMessage(msg.chat.id, 'There are some problem on running scraper!');\n    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n\nexport const gatheringCompanies = () => {\n  bot.onText(/\\/companies/, async msg => {", "    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n\nexport const gatheringCompanies = () => {\n  bot.onText(/\\/companies/, async msg => {\n    try {\n      if (isActionRunning) {\n        bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n        return;\n      }\n      bot.sendMessage(msg.chat.id, 'gathering data please wait... \ud83c\udf18');\n      const data = await collectCompanies();", "    try {\n      if (isActionRunning) {\n        bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n        return;\n      }\n      bot.sendMessage(msg.chat.id, 'gathering data please wait... \ud83c\udf18');\n      const data = await collectCompanies();\n      if (!data) {\n        throw new Error('cant find data!');\n      }\n      const {relocateCom, siaExplains, newCompanies} = data;\n      bot.sendMessage(\n        msg.chat.id,\n        `relocateMe:${relocateCom.companies} companies found \\n\n        siaExplains: ${siaExplains.companies} \\n\n        ${newCompanies} of them are new!\ud83c\udf1d\n        `,\n      );", "    } catch (err) {\n      bot.sendMessage(msg.chat.id, (err as Error)?.message || 'failed to find data please try few minutes later!');\n    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n\nexport const getJD = () => {\n  bot.onText(/\\/jd (.+)/, async (msg, match: RegExpExecArray | null) => {\n    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;\n", "    if (isActionRunning) {\n      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... \ud83c\udfb2');\n      return;\n    }\n    isActionRunning = true;\n\n    if (!match || !match[0]) {\n      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /jd <jobId>');\n      return;\n    }\n", "    try {\n      const jobId = +match[1];\n      const jobDescription = await prisma.job.findUnique({\n        where: {\n          id: jobId,\n        },\n      });\n      if (jobDescription?.description) {\n        const code = `${jobDescription.description}`;\n        await bot.sendMessage(msg.chat.id, code);\n        return;\n      }\n      const scrapJd = await getDescription(jobId);\n      bot.sendMessage(msg.chat.id, scrapJd ? String(scrapJd) : 'nothing found!');", "    } catch (error) {\n      bot.sendMessage(msg.chat.id, 'failed to save data please try few minutes later!');\n    } finally {\n      isActionRunning = false;\n    }\n  });\n};\n"]}
{"filename": "src/modules/driver/index.ts", "chunked_list": ["import {Builder} from 'selenium-webdriver';\nimport firefox from 'selenium-webdriver/firefox';\n\nexport async function createDriver() {\n  const options = new firefox.Options();\n  options.headless();\n  options.addArguments('--ignore-ssl-errors=yes');\n  options.addArguments('--ignore-certificate-errors');\n  return new Builder().forBrowser('firefox').setFirefoxOptions(options).build();\n}\n"]}
{"filename": "src/helper/countryMapper.ts", "chunked_list": ["import {capitalizedString} from './delay';\n\nexport function companyLogoMapper(location: string) {\n  const countryLogo = {\n    netherlands: '\ud83c\uddf3\ud83c\uddf1',\n    'united kingdom': '\ud83c\uddec\ud83c\udde7',\n    finland: '\ud83c\uddeb\ud83c\uddee',\n    sweden: '\ud83c\uddf8\ud83c\uddea',\n    france: '\ud83c\uddeb\ud83c\uddf7',\n    denmark: '\ud83c\udde6\ud83c\uddf9',\n  };\n  const country = location.toLocaleLowerCase().split(',');\n  const countryName = country[country.length - 1];\n  const logo = countryLogo[countryName.trim() as keyof typeof countryLogo] ?? '\ud83c\udff3\ufe0f';\n  return `${logo} ${capitalizedString(countryName.trim())}`;\n}\n"]}
{"filename": "src/helper/delay.ts", "chunked_list": ["export const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n\nexport function capitalizedString(str: string){\n    return str.charAt(0).toUpperCase() + str.slice(1)\n}"]}
{"filename": "src/helper/cleanedText.ts", "chunked_list": ["export function cleanedText(text: string) {\n  return text.replace(/(\\r\\n|\\n|\\r)/gm, '');\n}\n"]}
