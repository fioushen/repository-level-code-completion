{"filename": "index.ts", "chunked_list": ["export * from \"./src\";\n"]}
{"filename": "src/api.ts", "chunked_list": ["export type Result<\n  D extends unknown = unknown,\n  C extends unknown = number | string,\n> = Ok<D> | Err<C>;\n\nexport interface Ok<D extends unknown = null> {\n  ok: true;\n  err: false;\n  data: D;\n}\n", "export interface Err<\n  C extends unknown = number | string,\n  E extends Error = Error,\n  X extends { [key: string]: unknown } = { [key: string]: unknown },\n> {\n  ok: false;\n  err: true;\n  errCode: C;\n  errMessage: string;\n  errException: E | null;\n  errContext: X | null;\n}\n"]}
{"filename": "src/testUtils.ts", "chunked_list": ["import type { Result } from \"./api\";\nimport { expect } from \"vitest\";\n\nexport function assertResultEquals<R extends Result>(\n  result: R,\n  data: Partial<R>,\n): void {\n  expect(result).toEqual(expect.objectContaining(data));\n}\n"]}
{"filename": "src/helpers.spec.ts", "chunked_list": ["import type { Result } from \"./api\";\nimport { err } from \"./err\";\nimport {\n  allErr,\n  allOk,\n  assertIsErr,\n  assertIsOk,\n  assertIsResult,\n  isErrResult,\n  isOkResult,", "  isErrResult,\n  isOkResult,\n  isResult,\n  someErr,\n  someOk,\n} from \"./helpers\";\nimport { ok } from \"./ok\";\nimport { describe, expect, it } from \"vitest\";\n\ndescribe(\"helpers\", () => {", "\ndescribe(\"helpers\", () => {\n  describe(\"isResult()\", () => {\n    it(\"should return true for an Ok result\", () => {\n      expect(isResult(ok())).toBeTruthy();\n    });\n\n    it(\"should return true for an Err result\", () => {\n      expect(isResult(err())).toBeTruthy();\n    });", "      expect(isResult(err())).toBeTruthy();\n    });\n\n    it(\"should return true for any non Result input value\", () => {\n      expect(isResult(null)).toBeFalsy();\n      expect(isResult(undefined)).toBeFalsy();\n      expect(isResult(false)).toBeFalsy();\n      expect(isResult(true)).toBeFalsy();\n      expect(isResult({})).toBeFalsy();\n      expect(isResult([])).toBeFalsy();", "      expect(isResult({})).toBeFalsy();\n      expect(isResult([])).toBeFalsy();\n      expect(isResult(0)).toBeFalsy();\n      expect(isResult(\"\")).toBeFalsy();\n    });\n  });\n\n  describe(\"isOkResult()\", () => {\n    it(\"should return true for an Ok result\", () => {\n      expect(isOkResult(ok())).toBeTruthy();", "    it(\"should return true for an Ok result\", () => {\n      expect(isOkResult(ok())).toBeTruthy();\n    });\n\n    it(\"should return false for an Ok result\", () => {\n      expect(isOkResult(err())).toBeFalsy();\n    });\n\n    it(\"should return true for any non Result input value\", () => {\n      expect(isOkResult(null)).toBeFalsy();", "    it(\"should return true for any non Result input value\", () => {\n      expect(isOkResult(null)).toBeFalsy();\n      expect(isOkResult(undefined)).toBeFalsy();\n      expect(isOkResult(false)).toBeFalsy();\n      expect(isOkResult(true)).toBeFalsy();\n      expect(isOkResult({})).toBeFalsy();\n      expect(isOkResult([])).toBeFalsy();\n      expect(isOkResult(0)).toBeFalsy();\n      expect(isOkResult(\"\")).toBeFalsy();\n    });", "      expect(isOkResult(\"\")).toBeFalsy();\n    });\n  });\n\n  describe(\"isErrResult()\", () => {\n    it(\"should return false for an Ok result\", () => {\n      expect(isErrResult(ok())).toBeFalsy();\n    });\n\n    it(\"should return true for an Err result\", () => {", "\n    it(\"should return true for an Err result\", () => {\n      expect(isErrResult(err())).toBeTruthy();\n    });\n\n    it(\"should return true for any non Result input value\", () => {\n      expect(isErrResult(null)).toBeFalsy();\n      expect(isErrResult(undefined)).toBeFalsy();\n      expect(isErrResult(false)).toBeFalsy();\n      expect(isErrResult(true)).toBeFalsy();", "      expect(isErrResult(false)).toBeFalsy();\n      expect(isErrResult(true)).toBeFalsy();\n      expect(isErrResult({})).toBeFalsy();\n      expect(isErrResult([])).toBeFalsy();\n      expect(isErrResult(0)).toBeFalsy();\n      expect(isErrResult(\"\")).toBeFalsy();\n    });\n  });\n\n  describe(\"someErr()\", () => {", "\n  describe(\"someErr()\", () => {\n    it(\"should return true if one or more errors is falsy\", () => {\n      expect(someErr([err()])).toBeTruthy();\n      expect(someErr([err(), err()])).toBeTruthy();\n    });\n\n    it(\"should return false if zero input values are Err instances\", () => {\n      expect(someErr([ok()])).toBeFalsy();\n      expect(someErr([ok(), ok()])).toBeFalsy();", "      expect(someErr([ok()])).toBeFalsy();\n      expect(someErr([ok(), ok()])).toBeFalsy();\n    });\n\n    it(\"should return false when an empty array is passed in\", () => {\n      expect(someErr([])).toBeFalsy();\n    });\n  });\n\n  describe(\"someOk()\", () => {", "\n  describe(\"someOk()\", () => {\n    it(\"should return true if one or more errors is falsy\", () => {\n      expect(someOk([ok()])).toBeTruthy();\n      expect(someOk([ok(), ok()])).toBeTruthy();\n    });\n\n    it(\"should return false if zero input values are Err instances\", () => {\n      expect(someOk([err()])).toBeFalsy();\n      expect(someOk([err(), err()])).toBeFalsy();", "      expect(someOk([err()])).toBeFalsy();\n      expect(someOk([err(), err()])).toBeFalsy();\n    });\n\n    it(\"should return false when an empty array is passed in\", () => {\n      expect(someOk([])).toBeFalsy();\n    });\n  });\n\n  describe(\"allErr()\", () => {", "\n  describe(\"allErr()\", () => {\n    it(\"should return true if all input values are Err instances\", () => {\n      expect(allErr([err()])).toBeTruthy();\n      expect(allErr([err(), err()])).toBeTruthy();\n    });\n\n    it(\"should return false if one or more errors is falsy\", () => {\n      expect(allErr([ok()])).toBeFalsy();\n      expect(allErr([ok(), err()])).toBeFalsy();", "      expect(allErr([ok()])).toBeFalsy();\n      expect(allErr([ok(), err()])).toBeFalsy();\n    });\n\n    it(\"should return true when an empty array is passed in\", () => {\n      expect(allErr([])).toBeFalsy();\n    });\n  });\n\n  describe(\"allOk()\", () => {", "\n  describe(\"allOk()\", () => {\n    it(\"should return true if all input values are Ok instances\", () => {\n      expect(allOk([ok()])).toBeTruthy();\n      expect(allOk([ok(), ok()])).toBeTruthy();\n    });\n\n    it(\"should return false if one or more errors is falsy\", () => {\n      expect(allOk([err()])).toBeFalsy();\n      expect(allOk([err(), ok()])).toBeFalsy();", "      expect(allOk([err()])).toBeFalsy();\n      expect(allOk([err(), ok()])).toBeFalsy();\n    });\n\n    it(\"should return true when an empty array is passed in\", () => {\n      expect(allOk([])).toBeFalsy();\n    });\n  });\n\n  describe(\"assertIsResult()\", () => {", "\n  describe(\"assertIsResult()\", () => {\n    it(\"should throw an error if the provided value is not a Result instance\", () => {\n      expect(() => assertIsResult(undefined)).toThrow();\n      expect(() => assertIsResult(null)).toThrow();\n      expect(() => assertIsResult({})).toThrow();\n      expect(() => assertIsResult(ok())).not.toThrow();\n      expect(() => assertIsResult(err())).not.toThrow();\n    });\n  });", "    });\n  });\n\n  describe(\"assertIsOk()\", () => {\n    it(\"should throw an error if the provided value is not an Ok instance\", () => {\n      expect(() => assertIsOk(err())).toThrow();\n      expect(() => assertIsOk(undefined)).toThrow();\n      expect(() => assertIsOk(null)).toThrow();\n      expect(() => assertIsOk({})).toThrow();\n      expect(() => assertIsOk(ok())).not.toThrow();", "      expect(() => assertIsOk({})).toThrow();\n      expect(() => assertIsOk(ok())).not.toThrow();\n    });\n  });\n\n  describe(\"assertIsErr()\", () => {\n    it(\"should throw an error if the provided value is not an Err instance\", () => {\n      expect(() => assertIsErr(ok())).toThrow();\n      expect(() => assertIsErr(undefined)).toThrow();\n      expect(() => assertIsErr(null)).toThrow();", "      expect(() => assertIsErr(undefined)).toThrow();\n      expect(() => assertIsErr(null)).toThrow();\n      expect(() => assertIsErr({})).toThrow();\n      expect(() => assertIsErr(err())).not.toThrow();\n    });\n  });\n});\n\nexport function assertResultEquals<R extends Result>(\n  result: R,\n  data: Partial<R>,\n): void {\n  expect(result).toEqual(expect.objectContaining(data));\n}\n", "export function assertResultEquals<R extends Result>(\n  result: R,\n  data: Partial<R>,\n): void {\n  expect(result).toEqual(expect.objectContaining(data));\n}\n"]}
{"filename": "src/err.spec.ts", "chunked_list": ["import type { Err, Result } from \"./api\";\nimport { err } from \"./err\";\nimport { assertResultEquals } from \"./testUtils\";\nimport { describe, expect, it } from \"vitest\";\n\ndescribe(\"err()\", () => {\n  it(\"should return an Err result when called with nothing\", () => {\n    assertResultEquals(err(), { ok: false });\n    assertResultEquals(err(), { err: true });\n    assertResultEquals(err(), { errMessage: \"\" });", "    assertResultEquals(err(), { err: true });\n    assertResultEquals(err(), { errMessage: \"\" });\n    assertResultEquals(err(), { errCode: 0 });\n    assertResultEquals(err(), { errContext: null });\n    assertResultEquals(err(), { errException: null });\n  });\n\n  it(\"should return an Err result when called with null or undefined or boolean value\", () => {\n    const target = err();\n    errIsErr(err(null), target);", "    const target = err();\n    errIsErr(err(null), target);\n    errIsErr(err(undefined), target);\n    errIsErr(err(true), target);\n    errIsErr(err(false), target);\n  });\n\n  it(\"should return an Err result with a number\", () => {\n    expect(err(0).errCode).toEqual(0);\n    expect(err(0).errMessage).toEqual(\"\");", "    expect(err(0).errCode).toEqual(0);\n    expect(err(0).errMessage).toEqual(\"\");\n    expect(err(1).errCode).toEqual(1);\n    expect(err(1).errMessage).toEqual(\"\");\n  });\n\n  it(\"should return an Err result with a string\", () => {\n    expect(err(\"fail\").errMessage).toEqual(\"fail\");\n  });\n", "  });\n\n  it(\"should return an Err result with a string/number\", () => {\n    assertResultEquals(err(\"fail\", 123), {\n      errCode: 123,\n      errMessage: \"fail\",\n    });\n    assertResultEquals(err(\"fail\", 0), { errCode: 0, errMessage: \"fail\" });\n    assertResultEquals(err(\"fail\", -1), { errCode: -1, errMessage: \"fail\" });\n  });", "    assertResultEquals(err(\"fail\", -1), { errCode: -1, errMessage: \"fail\" });\n  });\n\n  it(\"should return an Err result with a string/string\", () => {\n    assertResultEquals(err(\"fail\", \"BAD_ERROR\"), {\n      errCode: \"BAD_ERROR\",\n      errMessage: \"fail\",\n    });\n  });\n", "  });\n\n  it(\"should return an Err result with a string/number/context\", () => {\n    const ctx = { some: \"data\" };\n    assertResultEquals(err(\"fail\", 123, ctx), {\n      errCode: 123,\n      errMessage: \"fail\",\n      errContext: ctx,\n    });\n  });", "    });\n  });\n\n  it(\"should return an Err result with the data extracted out of a Err input value\", () => {\n    expect(err(err()).errCode).toEqual(0);\n    expect(err(err(123)).errCode).toEqual(123);\n    expect(err(err(err(456))).errCode).toEqual(456);\n  });\n\n  it(\"should return an Err result with an Error value passed in as the input param\", () => {", "\n  it(\"should return an Err result with an Error value passed in as the input param\", () => {\n    const e = new Error(\"fail\");\n    expect(err(e).errException).toEqual(e);\n    expect(err(e).errCode).toEqual(0);\n    expect(err(e).errMessage).toEqual(\"fail\");\n  });\n\n  it(\"should override values if more params are passed in after the Error value\", () => {\n    const e = new Error(\"fail\");", "  it(\"should override values if more params are passed in after the Error value\", () => {\n    const e = new Error(\"fail\");\n    assertResultEquals(err(e, \"mega fail\"), {\n      errMessage: \"mega fail\",\n      errException: e,\n    });\n    assertResultEquals(err(e, \"mega fail\", 456), {\n      errMessage: \"mega fail\",\n      errException: e,\n      errCode: 456,", "      errException: e,\n      errCode: 456,\n    });\n    assertResultEquals(err(e, \"mega fail\", 456, { data: \"123\" }), {\n      errMessage: \"mega fail\",\n      errException: e,\n      errCode: 456,\n      errContext: { data: \"123\" },\n    });\n  });", "    });\n  });\n\n  it(\"should allow the entire object as data to be passed in\", () => {\n    const e = new Error(\"fail\");\n    assertResultEquals(\n      err({\n        errCode: 123,\n        errMessage: \"not good\",\n        errContext: { some: \"data\" },", "        errMessage: \"not good\",\n        errContext: { some: \"data\" },\n        errException: e,\n      }),\n      {\n        errCode: 123,\n        errMessage: \"not good\",\n        errContext: { some: \"data\" },\n        errException: e,\n      },", "        errException: e,\n      },\n    );\n  });\n\n  it(\"should allow the entire object as data to be passed in but use the exception's error message if not overridden\", () => {\n    const e = new Error(\"error123: fail\");\n    assertResultEquals(\n      err({\n        errCode: 123,", "      err({\n        errCode: 123,\n        errContext: { some: \"data\" },\n        errException: e,\n      }),\n      {\n        errCode: 123,\n        errMessage: \"error123: fail\",\n        errContext: { some: \"data\" },\n        errException: e,", "        errContext: { some: \"data\" },\n        errException: e,\n      },\n    );\n  });\n\n  it(\"should allow a partial object as data to be passed in\", () => {\n    assertResultEquals(\n      err({\n        errContext: { some: \"data\" },", "      err({\n        errContext: { some: \"data\" },\n      }),\n      {\n        errCode: 0,\n        errMessage: \"\",\n        errContext: { some: \"data\" },\n        errException: null,\n      },\n    );", "      },\n    );\n  });\n\n  it(\"should not set any data on the Err result\", () => {\n    expect(err()).not.toHaveProperty(\"data\");\n  });\n\n  it(\"should support enums as error codes\", () => {\n    enum StringEnum {\n      BAD_ERROR = \"BAD_ERROR\",\n      GOOD_ERROR = \"GOOD_ERROR\",\n    }", "  it(\"should support enums as error codes\", () => {\n    enum StringEnum {\n      BAD_ERROR = \"BAD_ERROR\",\n      GOOD_ERROR = \"GOOD_ERROR\",\n    }\n    enum NumEnum {\n      BAD_ERROR = 1,\n      GOOD_ERROR = 2,\n    }\n    const strError: Result<unknown, StringEnum> = err(\n      \"something broke abc\",\n      StringEnum.BAD_ERROR,\n    );\n    expect(strError.errCode).toEqual(StringEnum.BAD_ERROR);\n\n    const numError: Result<unknown, NumEnum> = err(\n      \"something broke 123\",\n      NumEnum.BAD_ERROR,\n    );\n    expect(numError.errCode).toEqual(NumEnum.BAD_ERROR);\n  });\n\n  it(\"should allow an Err object to be passed in with overrides\", () => {\n    const e = err(\"fail\", 555, { old: \"data\" });\n\n    // no overrides\n    assertResultEquals(err(e), {\n      errMessage: \"fail\",\n      errCode: 555,\n      errContext: { old: \"data\" },\n    });\n\n    // just the message\n    assertResultEquals(err(e, \"super fail\"), {\n      errMessage: \"super fail\",\n      errCode: 555,\n      errContext: { old: \"data\" },\n    });\n\n    // message and number\n    assertResultEquals(err(e, \"super fail\", 999), {\n      errMessage: \"super fail\",\n      errCode: 999,\n      errContext: { old: \"data\" },\n    });\n\n    // message, number and context\n    assertResultEquals(err(e, \"super fail\", 999, { some: \"data\" }), {\n      errMessage: \"super fail\",\n      errCode: 999,\n      errContext: { some: \"data\" },\n    });\n  });\n});\n", "function errIsErr(a: Err, b: Err): void {\n  expect(a.ok).toEqual(a.ok);\n  expect(a.err).toEqual(b.err);\n  expect(a.errMessage).toEqual(b.errMessage);\n  expect(a.errCode).toEqual(b.errCode);\n  expect(a.errContext).toEqual(b.errContext);\n  expect(a.errException).toEqual(b.errException);\n}\n"]}
{"filename": "src/from.ts", "chunked_list": ["import type { Err, Ok, Result } from \"./api\";\nimport { err } from \"./err\";\nimport { allOk, isResult } from \"./helpers\";\nimport { ok } from \"./ok\";\n\nexport function from<D extends unknown, R extends Result<D>[]>(\n  results: R,\n): Ok<D[]> | Err<number, Error, { results: R }> {\n  if (allOk(results)) {\n    const data = (results as Ok<D>[]).map((r) => {\n      let data = r.data;", "  if (allOk(results)) {\n    const data = (results as Ok<D>[]).map((r) => {\n      let data = r.data;\n      while (isResult(data)) {\n        if (data.err) {\n          data = null as D;\n          break;\n        }\n        data = (data as Ok<D>).data;\n      }\n      return data;\n    });\n    return ok(data);\n  } else {\n    const context = { results };\n    return err({ errContext: context });\n  }\n}\n", "export async function fromPromise<D extends unknown>(\n  promise: Promise<D>,\n): Promise<Result<D>> {\n  try {\n    const data = await promise;\n    return ok(data);\n  } catch (e) {\n    return err(e);\n  }\n}\n"]}
{"filename": "src/err.ts", "chunked_list": ["import type { Err } from \"./api\";\nimport { isJsError } from \"./shared\";\n\n// this is used to make sure that at least one of the\n// properties of an object is defined (becausePartial\n// makes all properties optional))\ntype AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\n/**\n * Creates an Err result.\n */", "export function err(): Err;\nexport function err(err: null | undefined | boolean): Err;\nexport function err<T extends Err>(err: T): T;\nexport function err<C extends number>(errCode: C): Err<C>;\nexport function err(errMessage: string): Err;\nexport function err<C extends unknown = number | string>(\n  errMessage: string,\n  errCode: C,\n): Err<C>;\nexport function err<\n  C extends unknown = string | number,\n  X extends { [key: string]: unknown } = { [key: string]: unknown },\n>(errMessage: string, errCode: C, errContext: X): Err<number, Error, X>;", "export function err<\n  C extends unknown = string | number,\n  X extends { [key: string]: unknown } = { [key: string]: unknown },\n>(errMessage: string, errCode: C, errContext: X): Err<number, Error, X>;\nexport function err<\n  E extends Err,\n  C extends unknown = string | number,\n  X extends { [key: string]: unknown } = { [key: string]: unknown },\n>(\n  e: AtLeastOne<Partial<E>>,\n  errMessage?: string,\n  errCode?: C,\n  errContext?: X,\n): Err<C, NonNullable<E[\"errException\"]>, X>;", "export function err<\n  E extends Error,\n  C extends unknown = string | number,\n  X extends { [key: string]: unknown } = { [key: string]: unknown },\n>(\n  e: E | { stack: string; message: string } | unknown,\n  errMessage?: string,\n  errCode?: C,\n  errContext?: X,\n): Err<C, E, X>;\nexport function err(a?: unknown, b?: unknown, c?: unknown, d?: unknown): Err {\n  let code: number | string = 0;\n  let message: string = \"\";\n  let context: { [key: string]: unknown } | null = null;\n  let exception: Error | null = null;\n\n  // err()\n  // err(null | undefined)\n  // --\n  // otherwise...", "export function err(a?: unknown, b?: unknown, c?: unknown, d?: unknown): Err {\n  let code: number | string = 0;\n  let message: string = \"\";\n  let context: { [key: string]: unknown } | null = null;\n  let exception: Error | null = null;\n\n  // err()\n  // err(null | undefined)\n  // --\n  // otherwise...\n  if (a !== null && a !== undefined) {\n    switch (typeof a) {\n      // err(number)\n      case \"number\":\n        code = a;\n        break;\n\n      // err(string, number?, context?)\n      case \"string\":\n        message = a;", "  if (a !== null && a !== undefined) {\n    switch (typeof a) {\n      // err(number)\n      case \"number\":\n        code = a;\n        break;\n\n      // err(string, number?, context?)\n      case \"string\":\n        message = a;\n        if (typeof b === \"number\" || typeof b === \"string\") {\n          code = b;\n        }", "        if (typeof b === \"number\" || typeof b === \"string\") {\n          code = b;\n        }\n        if (c && typeof c === \"object\") {\n          context = c as { [key: string]: unknown };\n        }\n        break;\n\n      case \"object\":\n        if (isJsError(a)) {\n          // err(Error, message?, code?, context?)\n          exception = a;\n          message = typeof b === \"string\" ? b : a.message || \"\";\n          code = typeof c === \"number\" || typeof c === \"string\" ? c : 0;\n          context =\n            typeof d === \"object\" ? (d as { [key: string]: unknown }) : null;\n        } else {\n          // err({ errMessage?, errCode?, errContext?, errException? })\n          const { errCode, errMessage, errContext, errException } =\n            a as Partial<Err>;\n          exception = errException ?? null;\n          code =\n            typeof c === \"number\"\n              ? c\n              : typeof errCode === \"number\"\n              ? errCode\n              : 0;\n          message = isValidString(b)\n            ? b\n            : isValidString(errMessage)\n            ? errMessage\n            : exception\n            ? exception.message\n            : \"\";\n          context = isErrContext(d) ? d : errContext ?? null;\n        }\n        break;\n    }\n  }\n\n  return {\n    ok: false,\n    err: true,\n    errCode: code,\n    errContext: context,\n    errMessage: message,\n    errException: exception,\n  };\n}\n", "        if (isJsError(a)) {\n          // err(Error, message?, code?, context?)\n          exception = a;\n          message = typeof b === \"string\" ? b : a.message || \"\";\n          code = typeof c === \"number\" || typeof c === \"string\" ? c : 0;\n          context =\n            typeof d === \"object\" ? (d as { [key: string]: unknown }) : null;\n        } else {\n          // err({ errMessage?, errCode?, errContext?, errException? })\n          const { errCode, errMessage, errContext, errException } =\n            a as Partial<Err>;\n          exception = errException ?? null;\n          code =\n            typeof c === \"number\"\n              ? c\n              : typeof errCode === \"number\"\n              ? errCode\n              : 0;\n          message = isValidString(b)\n            ? b\n            : isValidString(errMessage)\n            ? errMessage\n            : exception\n            ? exception.message\n            : \"\";\n          context = isErrContext(d) ? d : errContext ?? null;\n        }\n        break;\n    }\n  }\n\n  return {\n    ok: false,\n    err: true,\n    errCode: code,\n    errContext: context,\n    errMessage: message,\n    errException: exception,\n  };\n}\n", "function isValidString(value: unknown): value is string {\n  return typeof value === \"string\" && value.length !== 0;\n}\n\nfunction isErrContext(value: unknown): value is { [key: string]: unknown } {\n  return typeof value === \"object\" && value !== null;\n}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["export function isJsError(e: unknown): e is Error {\n  return (\n    e instanceof Error ||\n    (typeof e === \"object\" &&\n      e !== null &&\n      typeof (e as { message?: unknown }).message === \"string\")\n  );\n}\n"]}
{"filename": "src/from.spec.ts", "chunked_list": ["import { err } from \"./err\";\nimport { from, fromPromise } from \"./from\";\nimport { assertIsErr } from \"./helpers\";\nimport { ok } from \"./ok\";\nimport { describe, expect, it } from \"vitest\";\n\ndescribe(\"\", () => {\n  describe(\"from()\", () => {\n    it(\"should return a Ok result if all input values are Ok instances\", () => {\n      const a = ok(1);", "    it(\"should return a Ok result if all input values are Ok instances\", () => {\n      const a = ok(1);\n      const b = ok(2);\n      const c = ok({ value: 3 });\n      expect(from([a, b, c])).toEqual(ok([1, 2, { value: 3 }]));\n    });\n\n    it(\"should extract all inner data if there are any ok(ok()) values\", () => {\n      const a = ok(1);\n      const b = ok(ok(\"yes\"));", "      const a = ok(1);\n      const b = ok(ok(\"yes\"));\n      const c = ok(ok(ok({ value: \"no\" })));\n      expect(from([a, b, c])).toEqual(ok([1, \"yes\", { value: \"no\" }]));\n    });\n\n    it(\"should return a Err result if one or more input values are Err instances\", () => {\n      expect(from([err()]).err).toBeTruthy();\n      expect(from([err(), ok()]).err).toBeTruthy();\n    });", "      expect(from([err(), ok()]).err).toBeTruthy();\n    });\n\n    it(\"should collect expose all the input values on errContext if any errors are detected\", () => {\n      const a = ok(1);\n      const b = err(2);\n      const c = err(\"fail\");\n      const result = from([a, b, c]);\n\n      assertIsErr(result);", "\n      assertIsErr(result);\n      expect(result.err).toBeTruthy();\n      expect(result.errContext).toEqual({ results: [a, b, c] });\n    });\n\n    it(\"should return an Err result if there are zero values passed in\", () => {\n      expect(from([]).err).toBeTruthy();\n    });\n  });", "    });\n  });\n\n  describe(\"fromPromise()\", () => {\n    it(\"should return an Ok result if the promise resolves\", async () => {\n      const promise = Promise.resolve(1);\n      const result = await fromPromise(promise);\n      expect(result).toEqual(ok(1));\n    });\n", "    });\n\n    it(\"should return an Err result if the promise rejects\", async () => {\n      // eslint-disable-next-line prefer-promise-reject-errors\n      const promise = Promise.reject(1);\n      const result = await fromPromise(promise);\n      assertIsErr(result);\n      expect(result.err).toBeTruthy();\n    });\n  });", "    });\n  });\n});\n"]}
{"filename": "src/ok.ts", "chunked_list": ["import type { Err, Ok } from \"./api\";\nimport { isOkResult } from \"./helpers\";\n\n/**\n * Creates an Ok result.\n */\nexport function ok(): Ok<null>;\nexport function ok(value: undefined): Ok<undefined>;\nexport function ok<T extends Err>(value: T): Ok<null>;\nexport function ok<T extends { ok: true; err: false }>(value: T): T;\nexport function ok<T extends unknown>(value: T): Ok<T>;", "export function ok<T extends Err>(value: T): Ok<null>;\nexport function ok<T extends { ok: true; err: false }>(value: T): T;\nexport function ok<T extends unknown>(value: T): Ok<T>;\nexport function ok(value?: unknown): Ok<unknown> {\n  let resultData: any = value;\n  if (resultData === undefined) {\n    // special case for undefined actually being\n    // passed in as undefined\n    resultData = arguments.length === 1 ? undefined : null;\n  } else if (isOkResult(value)) {\n    // no need for a loop since ok(ok()) does this", "  } else if (isOkResult(value)) {\n    // no need for a loop since ok(ok()) does this\n    // by way of the function call stack\n    resultData = value.data;\n  }\n  return { ok: true, err: false, data: resultData };\n}\n"]}
{"filename": "src/helpers.ts", "chunked_list": ["import type { Err, Ok, Result } from \"./api\";\n\nexport function isOkResult<D extends unknown = unknown>(\n  value: unknown,\n): value is Ok<D> {\n  return isResult(value) && value.ok;\n}\n\nexport function isErrResult(value: unknown): value is Err {\n  return isResult(value) && value.err;\n}\n", "export function isErrResult(value: unknown): value is Err {\n  return isResult(value) && value.err;\n}\n\nexport function isResult(value: unknown): value is Result {\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"ok\" in value &&\n    \"err\" in value\n  ) {\n    const r = value as Result;\n    return typeof r.ok === \"boolean\" && typeof r.err === \"boolean\";\n  }\n  return false;\n}\n", "export function someErr(results: Result[]): boolean {\n  return results.some((r) => r.err);\n}\n\nexport function allErr(results: Result[]): boolean {\n  return results.length ? results.every((r) => r.err) : false;\n}\n\nexport function someOk(results: Result[]): boolean {\n  return results.some((r) => r.ok);\n}\n", "export function someOk(results: Result[]): boolean {\n  return results.some((r) => r.ok);\n}\n\nexport function allOk(results: Result[]): boolean {\n  return results.length ? results.every((r) => r.ok) : false;\n}\n\nexport function assertIsResult(value: unknown): asserts value is Result {\n  if (!isResult(value)) {\n    throw new TypeError(\"value is not a Result\");\n  }\n}\n", "export function assertIsResult(value: unknown): asserts value is Result {\n  if (!isResult(value)) {\n    throw new TypeError(\"value is not a Result\");\n  }\n}\n\nexport function assertIsErr(value: unknown): asserts value is Err {\n  if (!isErrResult(value)) {\n    throw new TypeError(\"value is not an Err result\");\n  }\n}\n", "export function assertIsOk(value: unknown): asserts value is Ok {\n  if (!isOkResult(value)) {\n    throw new TypeError(\"value is not an Ok result\");\n  }\n}\n"]}
{"filename": "src/toResult.ts", "chunked_list": ["import type { Err, Ok, Result } from \"./api\";\nimport { err } from \"./err\";\nimport { ok } from \"./ok\";\nimport { isJsError } from \"./shared\";\n\nexport function toResult<\n  D extends unknown,\n  T extends { ok: true; data?: D } | { err: false; data?: D },\n>(value: T): Ok<T>;\nexport function toResult<\n  C extends unknown,\n  T extends { ok: false; errCode?: C } | { err: true; errCode?: C },\n>(value: T): Err<T[\"errCode\"]>;", "export function toResult<\n  C extends unknown,\n  T extends { ok: false; errCode?: C } | { err: true; errCode?: C },\n>(value: T): Err<T[\"errCode\"]>;\nexport function toResult<D extends false | \"\" | 0 | null | undefined>(\n  value: D,\n): Err;\nexport function toResult<\n  D extends true | unknown[] | Record<string, unknown> | number | string,\n>(value: D): Ok<D>;\nexport function toResult(value: unknown): Result {", "export function toResult(value: unknown): Result {\n  if (value === undefined || value === null) {\n    return err();\n  }\n\n  if (typeof value === \"object\") {\n    if ((\"ok\" in value && value.ok) || (\"err\" in value && !value.err)) {\n      const data = (value as Ok).data ?? null;\n      return ok(data);\n    } else if ((\"err\" in value && value.err) || (\"ok\" in value && !value.ok)) {\n      const e = value as Err;\n      const errCode = e.errCode ?? 0;\n      const errMessage = e.errMessage || \"\";\n      const errContext = e.errContext ?? null;\n      const errException = isJsError(e.errException) ? e.errException : null;\n      return err({\n        errCode,\n        errMessage,\n        errContext,\n        errException,\n      });\n    }\n\n    // fallback for any {} object\n    return value ? ok(value) : err();\n  }\n\n  switch (typeof value) {\n    case \"boolean\":\n      return value ? ok(value) : err();\n\n    case \"number\":\n      return value === 0 ? err() : ok(value);\n\n    case \"string\":\n      return value === \"\" ? err() : ok(value);\n\n    default:\n      return err();\n  }\n}\n", "    } else if ((\"err\" in value && value.err) || (\"ok\" in value && !value.ok)) {\n      const e = value as Err;\n      const errCode = e.errCode ?? 0;\n      const errMessage = e.errMessage || \"\";\n      const errContext = e.errContext ?? null;\n      const errException = isJsError(e.errException) ? e.errException : null;\n      return err({\n        errCode,\n        errMessage,\n        errContext,\n        errException,\n      });\n    }\n\n    // fallback for any {} object\n    return value ? ok(value) : err();\n  }\n\n  switch (typeof value) {\n    case \"boolean\":\n      return value ? ok(value) : err();\n\n    case \"number\":\n      return value === 0 ? err() : ok(value);\n\n    case \"string\":\n      return value === \"\" ? err() : ok(value);\n\n    default:\n      return err();\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./api\";\nexport * from \"./ok\";\nexport * from \"./err\";\nexport * from \"./helpers\";\nexport * from \"./from\";\nexport * from \"./toResult\";\n"]}
{"filename": "src/toResult.spec.ts", "chunked_list": ["import { err } from \"./err\";\nimport { ok } from \"./ok\";\nimport { toResult } from \"./toResult\";\nimport { describe, expect, it } from \"vitest\";\n\ndescribe(\"toResult()\", () => {\n  it(\"should convert a simple {ok:true} or {err:false} object to an Ok result\", () => {\n    expect(toResult({ ok: true })).toEqual(ok());\n    expect(toResult({ ok: true, err: false })).toEqual(ok());\n    expect(toResult({ err: false })).toEqual(ok());", "    expect(toResult({ ok: true, err: false })).toEqual(ok());\n    expect(toResult({ err: false })).toEqual(ok());\n    expect(toResult({ err: false, ok: false })).toEqual(ok());\n  });\n\n  it(\"should retain any data when accepting an ok-like input value\", () => {\n    expect(toResult({ ok: true, data: \"123\" })).toEqual(ok(\"123\"));\n    expect(toResult({ ok: true, data: { value: \"456\" } })).toEqual(\n      ok({ value: \"456\" }),\n    );", "      ok({ value: \"456\" }),\n    );\n    expect(toResult({ err: false, data: \"123\" })).toEqual(ok(\"123\"));\n    expect(toResult({ err: false, data: { value: \"456\" } })).toEqual(\n      ok({ value: \"456\" }),\n    );\n  });\n\n  it(\"should convert a simple {ok:false} or {err:true} object to an Err result\", () => {\n    expect(toResult({ ok: false })).toEqual(err());", "  it(\"should convert a simple {ok:false} or {err:true} object to an Err result\", () => {\n    expect(toResult({ ok: false })).toEqual(err());\n    expect(toResult({ err: true })).toEqual(err());\n  });\n\n  it(\"should retain the errMessage, errCode, errContext and errException when accepting an err-like input value\", () => {\n    expect(toResult({ ok: false, errMessage: \"noo\" })).toEqual(err(\"noo\"));\n    expect(toResult({ err: true, errMessage: \"noo!\" })).toEqual(err(\"noo!\"));\n\n    expect(toResult({ err: true, errCode: 999 })).toEqual(err(999));", "\n    expect(toResult({ err: true, errCode: 999 })).toEqual(err(999));\n    expect(toResult({ ok: false, errCode: 999 })).toEqual(err(999));\n    expect(toResult({ err: true, errCode: \"FFF\" })).toEqual(\n      err({ errCode: \"FFF\" }),\n    );\n    expect(toResult({ ok: false, errCode: \"FFF\" })).toEqual(\n      err({ errCode: \"FFF\" }),\n    );\n", "    );\n\n    const ctx = { a: 1 };\n    expect(toResult({ err: true, errContext: ctx })).toEqual(\n      err({ errContext: ctx }),\n    );\n    expect(toResult({ ok: false, errContext: ctx })).toEqual(\n      err({ errContext: ctx }),\n    );\n", "    );\n\n    const e = new Error(\"!!!\");\n    expect(toResult({ err: true, errException: e })).toEqual(\n      err({ errException: e, errMessage: \"!!!\" }),\n    );\n    expect(toResult({ ok: false, errException: e })).toEqual(\n      err({ errException: e, errMessage: \"!!!\" }),\n    );\n", "    );\n\n    expect(\n      toResult({\n        ok: false,\n        errMessage: \"it broke\",\n        errCode: 999,\n        errContext: ctx,\n        errException: e,\n      }),", "        errException: e,\n      }),\n    ).toEqual(\n      err({\n        errMessage: \"it broke\",\n        errCode: 999,\n        errContext: ctx,\n        errException: e,\n      }),\n    );", "      }),\n    );\n\n    expect(\n      toResult({\n        err: true,\n        errMessage: \"it broke\",\n        errCode: 999,\n        errContext: ctx,\n        errException: e,", "        errContext: ctx,\n        errException: e,\n      }),\n    ).toEqual(\n      err({\n        errMessage: \"it broke\",\n        errCode: 999,\n        errContext: ctx,\n        errException: e,\n      }),", "        errException: e,\n      }),\n    );\n  });\n\n  it(\"should convert an input-value of false / empty string / zero / null / undefined to an Err result\", () => {\n    expect(toResult(false)).toEqual(err());\n    expect(toResult(\"\")).toEqual(err());\n    expect(toResult(0)).toEqual(err());\n    expect(toResult(null)).toEqual(err());", "    expect(toResult(0)).toEqual(err());\n    expect(toResult(null)).toEqual(err());\n    expect(toResult(undefined)).toEqual(err());\n  });\n\n  it(\"should convert an input-value of true / string / number / object / array to an Ok result\", () => {\n    expect(toResult(true)).toEqual(ok(true));\n    expect(toResult(\"abc\")).toEqual(ok(\"abc\"));\n    expect(toResult(123)).toEqual(ok(123));\n    expect(toResult({})).toEqual(ok({}));", "    expect(toResult(123)).toEqual(ok(123));\n    expect(toResult({})).toEqual(ok({}));\n    expect(toResult({ a: 1 })).toEqual(ok({ a: 1 }));\n    expect(toResult([])).toEqual(ok([]));\n    expect(toResult([1, 2, 3])).toEqual(ok([1, 2, 3]));\n  });\n});\n"]}
{"filename": "src/ok.spec.ts", "chunked_list": ["import { ok } from \"./ok\";\nimport { assertResultEquals } from \"./testUtils\";\nimport { describe, expect, it } from \"vitest\";\n\ndescribe(\"ok()\", () => {\n  it(\"should return an Ok reuslt when called with nothing\", () => {\n    assertResultEquals(ok(), { ok: true });\n    assertResultEquals(ok(), { err: false });\n    assertResultEquals(ok(), { data: null });\n  });", "    assertResultEquals(ok(), { data: null });\n  });\n\n  it(\"should return an Ok result with the provided data\", () => {\n    assertResultEquals(ok(null), { ok: true, data: null });\n    assertResultEquals(ok(undefined), { ok: true, data: undefined });\n    assertResultEquals(ok(0), { ok: true, data: 0 });\n    assertResultEquals(ok(123), { ok: true, data: 123 });\n    assertResultEquals(ok(true), { ok: true, data: true });\n    assertResultEquals(ok(false), { ok: true, data: false });", "    assertResultEquals(ok(true), { ok: true, data: true });\n    assertResultEquals(ok(false), { ok: true, data: false });\n    assertResultEquals(ok(\"\"), { ok: true, data: \"\" });\n    assertResultEquals(ok([]), { ok: true, data: [] });\n    assertResultEquals(ok({}), { ok: true, data: {} });\n    assertResultEquals(ok({ key: \"value\" }), {\n      ok: true,\n      data: { key: \"value\" },\n    });\n  });", "    });\n  });\n\n  it(\"should return an Ok result with the data of an Ok\", () => {\n    assertResultEquals(ok(ok()), { ok: true, data: null });\n    assertResultEquals(ok(ok(1)), { ok: true, data: 1 });\n    assertResultEquals(ok(ok(\"abc\")), { ok: true, data: \"abc\" });\n    assertResultEquals(ok(ok(ok(true))), { ok: true, data: true });\n  });\n", "  });\n\n  it(\"should not set any error details on the Ok result\", () => {\n    expect(ok()).not.toHaveProperty(\"errCode\");\n    expect(ok()).not.toHaveProperty(\"errMessage\");\n    expect(ok()).not.toHaveProperty(\"errContext\");\n    expect(ok()).not.toHaveProperty(\"errException\");\n  });\n\n  it(\"should allow `any` data to be passed in\", () => {", "\n  it(\"should allow `any` data to be passed in\", () => {\n    const data: any = { key: \"value\" };\n    expect(ok(data).data).toBe(data);\n  });\n});\n"]}
