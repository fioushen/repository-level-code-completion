{"filename": "src/main/config.ts", "chunked_list": ["const Config = {\n  defaultPrefix: \"!\",\n  version: \"1.1.0-stable\",\n  disableWatchdog: false, // If your world crashes, change this to true\n};\n\nexport { Config };\n"]}
{"filename": "src/main/index.ts", "chunked_list": ["import { SystemEvents } from \"./@modules/modules\";\nimport { Config } from \"./config\";\n\nSystemEvents.on(\n  \"watchdogTerminate\",\n  (watchdog) => (watchdog.cancel = Config.disableWatchdog)\n);\n\nimport \"./plugins/plugin.loader\";\n", "import \"./plugins/plugin.loader\";\n"]}
{"filename": "src/main/plugins/plugin.loader.ts", "chunked_list": ["/**\n * This is an AutoLoad system\n * Import plugin using pluginFolder, like if you have plugin called \"Example\" then add \"Example\" to the pluginFolder, it should looks like this\n * [\"Example\", \"Plugin 1\", \"Plugin 2\"]\n * Don't forget to rename the main plugin with \"system\", example: \"Plugin 1/system\"\n */\n\nconst pluginFolder: string[] = [\n  // Import Plugin (Folder Name)\n  \"Chat Ranks\",", "  // Import Plugin (Folder Name)\n  \"Chat Ranks\",\n  \"Custom Commands\",\n];\n\n//.\n//.\n//.\n//.\n//.", "//.\n//.\n//.\n//.\n//.\n//.\n//.\n//.\n//.\n//.", "//.\n//.\n//.\n// Don't Touch\nimport \"./_ignore/index\";\nconst start: number = Date.now();\nfor (const plugin of pluginFolder) {\n  const end: number = Date.now();\n  import(`./${plugin}/system`)\n    .then(() =>\n      console.warn(\n        `Loaded plugin: ${plugin} successfully, in ${end - start} ms`\n      )\n    )", "    .catch((err) =>\n      console.warn(\n        `Error on loading plugin: ${plugin}\\nError: ${err}\\nStack: ${err.stack}`\n      )\n    );\n}\n"]}
{"filename": "src/main/plugins/@modules.ts", "chunked_list": ["// Modules chaining\nexport {\n  Command,\n  CommandRegistration,\n  Collection,\n  PlayerClass,\n  ChatClass,\n  ErrorClass,\n  FailedClass,\n  FormClass,", "  FailedClass,\n  FormClass,\n  Form,\n  World,\n  Database,\n  AfterEvents,\n  BeforeEvents,\n  SystemEvents,\n  CooldownClass,\n  Formatter,", "  CooldownClass,\n  Formatter,\n  Timer,\n  Validation,\n  MS,\n} from \"../@modules/modules\";\n"]}
{"filename": "src/main/plugins/Chat Ranks/config.ts", "chunked_list": ["const RankConfig = {\n  /**\n   * @NAME = Player Name\n   * @CHAT = Player Message\n   */\n  defaultRank: \"\u00a77[Member] \u00a7r@NAME \u00a77>> \u00a7r@CHAT\",\n};\n\nexport { RankConfig };\n", "export { RankConfig };\n"]}
{"filename": "src/main/plugins/Chat Ranks/system.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\nimport { BeforeEvents, Command, PlayerClass } from \"../@modules\";\nimport { RankConfig } from \"./config\";\n\nBeforeEvents.on(\"chat\", (rawdata) => {\n  const { sender, message } = rawdata;\n  if (message.startsWith(Command.getPrefix())) return;\n  rawdata.cancel = true;\n  const player = new PlayerClass(sender);\n  const getRank =\n    player.getTagStartsWith(\"rank:\")?.slice(5) ?? RankConfig.defaultRank;\n  world.sendMessage(\n    getRank?.replaceAll(\"@NAME\", sender.name)?.replaceAll(\"@CHAT\", message)\n  );\n});\n"]}
{"filename": "src/main/plugins/_ignore/index.ts", "chunked_list": ["// Runner\nimport \"./EventEmitter/index\";\n"]}
{"filename": "src/main/plugins/_ignore/EventEmitter/index.ts", "chunked_list": ["import { world, system, ChatSendBeforeEvent  } from \"@minecraft/server\";\nimport {\n  BeforeEvents,\n  AfterEvents,\n  SystemEvents,\n} from \"../../@modules\";\n\n// Before events\nworld.beforeEvents.chatSend.subscribe((cb) => BeforeEvents.emit(\"chat\", cb));\n", "world.beforeEvents.chatSend.subscribe((cb) => BeforeEvents.emit(\"chat\", cb));\n\nworld.beforeEvents.dataDrivenEntityTriggerEvent.subscribe((cb) =>\n  BeforeEvents.emit(\"dataDrivenEntity\", cb)\n);\n\nworld.beforeEvents.explosion.subscribe((cb) =>\n  BeforeEvents.emit(\"explosion\", cb)\n);\n", ");\n\nworld.beforeEvents.itemDefinitionEvent.subscribe((cb) =>\n  BeforeEvents.emit(\"itemDefinition\", cb)\n);\n\nworld.beforeEvents.itemUse.subscribe((cb) => BeforeEvents.emit(\"itemUse\", cb));\n\nworld.beforeEvents.itemUseOn.subscribe((cb) =>\n  BeforeEvents.emit(\"itemUseOn\", cb)", "world.beforeEvents.itemUseOn.subscribe((cb) =>\n  BeforeEvents.emit(\"itemUseOn\", cb)\n);\n\nworld.beforeEvents.pistonActivate.subscribe((cb) =>\n  BeforeEvents.emit(\"pistonActivate\", cb)\n);\n\n// After events\nworld.afterEvents.blockBreak.subscribe((cb) =>", "// After events\nworld.afterEvents.blockBreak.subscribe((cb) =>\n  AfterEvents.emit(\"blockBreak\", cb)\n);\n\nworld.afterEvents.blockExplode.subscribe((cb) =>\n  AfterEvents.emit(\"blockExplode\", cb)\n);\n\nworld.afterEvents.blockPlace.subscribe((cb) =>", "\nworld.afterEvents.blockPlace.subscribe((cb) =>\n  AfterEvents.emit(\"blockPlace\", cb)\n);\n\nworld.afterEvents.buttonPush.subscribe((cb) =>\n  AfterEvents.emit(\"buttonPush\", cb)\n);\n\nworld.afterEvents.chatSend.subscribe((cb) => AfterEvents.emit(\"chat\", cb));", "\nworld.afterEvents.chatSend.subscribe((cb) => AfterEvents.emit(\"chat\", cb));\n\nworld.afterEvents.dataDrivenEntityTriggerEvent.subscribe((cb) =>\n  AfterEvents.emit(\"dataDrivenEntity\", cb)\n);\n\nworld.afterEvents.effectAdd.subscribe((cb) =>\n  AfterEvents.emit(\"effectAdd\", cb)\n);", "  AfterEvents.emit(\"effectAdd\", cb)\n);\n\nworld.afterEvents.entityDie.subscribe((cb) =>\n  AfterEvents.emit(\"entityDie\", cb)\n);\n\nworld.afterEvents.entityHealthChanged.subscribe((cb) =>\n  AfterEvents.emit(\"entityHealthChanged\", cb)\n);", "  AfterEvents.emit(\"entityHealthChanged\", cb)\n);\n\nworld.afterEvents.entityHitBlock.subscribe((cb) =>\n  AfterEvents.emit(\"entityHitBlock\", cb)\n);\n\nworld.afterEvents.entityHitEntity.unsubscribe((cb) =>\n  AfterEvents.emit(\"entityHitEntity\", cb)\n);", "  AfterEvents.emit(\"entityHitEntity\", cb)\n);\n\nworld.afterEvents.entityHurt.subscribe((cb) =>\n  AfterEvents.emit(\"entityHurt\", cb)\n);\n\nworld.afterEvents.entityRemoved.subscribe((cb) =>\n  AfterEvents.emit(\"entityRemoved\", cb)\n);", "  AfterEvents.emit(\"entityRemoved\", cb)\n);\n\nworld.afterEvents.entitySpawn.subscribe((cb) =>\n  AfterEvents.emit(\"entitySpawn\", cb)\n);\n\nworld.afterEvents.explosion.subscribe((cb) =>\n  AfterEvents.emit(\"explosion\", cb)\n);", "  AfterEvents.emit(\"explosion\", cb)\n);\n\nworld.afterEvents.itemCompleteUse.subscribe((cb) =>\n  AfterEvents.emit(\"itemCompleteUse\", cb)\n);\n\nworld.afterEvents.itemDefinitionEvent.subscribe((cb) =>\n  AfterEvents.emit(\"itemDefinition\", cb)\n);", "  AfterEvents.emit(\"itemDefinition\", cb)\n);\n\nworld.afterEvents.itemReleaseUse.subscribe((cb) =>\n  AfterEvents.emit(\"itemReleaseUse\", cb)\n);\n\nworld.afterEvents.itemStartUse.subscribe((cb) =>\n  AfterEvents.emit(\"itemStartUse\", cb)\n);", "  AfterEvents.emit(\"itemStartUse\", cb)\n);\n\nworld.afterEvents.itemStartUseOn.subscribe((cb) =>\n  AfterEvents.emit(\"itemStartUseOn\", cb)\n);\n\nworld.afterEvents.itemStopUse.subscribe((cb) =>\n  AfterEvents.emit(\"itemStopUse\", cb)\n);", "  AfterEvents.emit(\"itemStopUse\", cb)\n);\n\nworld.afterEvents.itemStopUseOn.subscribe((cb) =>\n  AfterEvents.emit(\"itemStopUseOn\", cb)\n);\n\nworld.afterEvents.itemUse.subscribe((cb) => AfterEvents.emit(\"itemUse\", cb));\n\nworld.afterEvents.itemUseOn.subscribe((cb) =>", "\nworld.afterEvents.itemUseOn.subscribe((cb) =>\n  AfterEvents.emit(\"itemUseOn\", cb)\n);\n\nworld.afterEvents.leverAction.subscribe((cb) =>\n  AfterEvents.emit(\"leverAction\", cb)\n);\n\nworld.afterEvents.messageReceive.subscribe((cb) =>", "\nworld.afterEvents.messageReceive.subscribe((cb) =>\n  AfterEvents.emit(\"messageReceive\", cb)\n);\n\nworld.afterEvents.pistonActivate.subscribe((cb) =>\n  AfterEvents.emit(\"pistonActivate\", cb)\n);\n\nworld.afterEvents.playerJoin.subscribe((cb) =>", "\nworld.afterEvents.playerJoin.subscribe((cb) =>\n  AfterEvents.emit(\"playerJoin\", cb)\n);\n\nworld.afterEvents.playerLeave.subscribe((cb) =>\n  AfterEvents.emit(\"playerLeave\", cb)\n);\n\nworld.afterEvents.playerSpawn.subscribe((cb) =>", "\nworld.afterEvents.playerSpawn.subscribe((cb) =>\n  AfterEvents.emit(\"playerSpawn\", cb)\n);\n\nworld.afterEvents.pressurePlatePop.subscribe((cb) =>\n  AfterEvents.emit(\"pressurePlatePop\", cb)\n);\n\nworld.afterEvents.pressurePlatePush.subscribe((cb) =>", "\nworld.afterEvents.pressurePlatePush.subscribe((cb) =>\n  AfterEvents.emit(\"pressurePlatePush\", cb)\n);\n\nworld.afterEvents.projectileHit.subscribe((cb) =>\n  AfterEvents.emit(\"projectileHit\", cb)\n);\n\nworld.afterEvents.targetBlockHit.subscribe((cb) =>", "\nworld.afterEvents.targetBlockHit.subscribe((cb) =>\n  AfterEvents.emit(\"targetBlockHit\", cb)\n);\n\nworld.afterEvents.tripWireTrip.subscribe((cb) =>\n  AfterEvents.emit(\"tripWireTrip\", cb)\n);\n\nworld.afterEvents.weatherChange.subscribe((cb) =>", "\nworld.afterEvents.weatherChange.subscribe((cb) =>\n  AfterEvents.emit(\"weatherChange\", cb)\n);\n\nworld.afterEvents.worldInitialize.subscribe((cb) =>\n  AfterEvents.emit(\"worldInitialize\", cb)\n);\n\n// System events", "\n// System events\nsystem.beforeEvents.watchdogTerminate.subscribe((cb) =>\n  SystemEvents.emit(\"watchdogTerminate\", cb)\n);\n\nsystem.afterEvents.scriptEventReceive.subscribe((cb) =>\n  SystemEvents.emit(\"scriptEventReceive\", cb)\n);\n", ");\n"]}
{"filename": "src/main/plugins/Custom Commands/system.ts", "chunked_list": ["// Information\nimport \"./information/help\";\nimport \"./information/version\";\n\n// Global\nimport \"./global/home/home\";\nimport \"./global/home/sethome\";\nimport \"./global/home/delhome\";\nimport \"./global/home/listhome\";\n", "import \"./global/home/listhome\";\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/listhome.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\nimport { Command, CommandRegistration, Validation } from \"../../../@modules\";\nimport { HomeDB } from \"./sethome\";\n\nconst registration: CommandRegistration = new CommandRegistration()\n  .setName(\"listhome\")\n  .setDescription(\"Get all home\")\n  .setUsage([\"<homeName>\"])\n  .setExample([\"listhome myHome\"]);\n", "  .setExample([\"listhome myHome\"]);\n\nCommand.BuildCommand(registration, (interaction) => {\n  const { sender } = interaction;\n  const homes = [];\n\n  for (const [, home] of HomeDB) {\n    if (home.creator === sender.name) homes.push(home);\n  }\n\n  return sender.sendMessage(\n    `\u00a7b---- Home List ----\\n\\n${\n      homes.length === 0\n        ? \"\u00a7f# \u00a77You don't have any home\"\n        : homes\n            .sort()\n            .map(\n              (home: { name: string; dimension: string }) =>\n                `\u00a7f# \u00a7a${home.name} \u00a77- ${home.dimension}`\n            )\n            .join(\"\\n\\n\")\n    }`\n  );\n});\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/delhome.ts", "chunked_list": ["import { Command, CommandRegistration, Validation } from \"../../../@modules\";\nimport { HomeDB } from \"./sethome\";\n\nconst registration: CommandRegistration = new CommandRegistration()\n  .setName(\"delhome\")\n  .setDescription(\"Delete home\")\n  .setAliases([\"deletehome\", \"dhome\"])\n  .setInputs({ 0: [\"string\"] })\n  .setUsage([\"<homeName>\"])\n  .setExample([\"home myHome\", \"deletehome myHome\", \"dhome myHome\"]);", "  .setUsage([\"<homeName>\"])\n  .setExample([\"home myHome\", \"deletehome myHome\", \"dhome myHome\"]);\n\nCommand.BuildCommand(registration, (interaction) => {\n  const { sender, inputs } = interaction;\n  const homeName = inputs.getInput(0) as any;\n\n  if (Validation.isUndefined(homeName))\n    return sender.sendMessage(\"\u00a7cHome name cannot be empty\");\n\n  const homeDBFrmt = `${sender.name}_${homeName}`;", "  if (!HomeDB.hasKey(homeDBFrmt))\n    return sender.sendMessage(`\u00a7cHome with name \u00a7e${homeName} \u00a7cdoesn't exist`);\n\n  HomeDB.delete(homeDBFrmt);\n  return sender.sendMessage(\n    `\u00a7aSuccessfully deleted home with name \u00a7e${homeName}`\n  );\n});\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/home.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\nimport { Command, CommandRegistration, Validation } from \"../../../@modules\";\nimport { HomeDB } from \"./sethome\";\n\nconst registration: CommandRegistration = new CommandRegistration()\n  .setName(\"home\")\n  .setDescription(\"Teleport to home\")\n  .setInputs({ 0: [\"string\"] })\n  .setUsage([\"<homeName>\"])\n  .setExample([\"home myHome\"]);", "  .setUsage([\"<homeName>\"])\n  .setExample([\"home myHome\"]);\n\nCommand.BuildCommand(registration, async (interaction) => {\n  const { sender, inputs } = interaction;\n  const homeName = inputs.getInput(0) as any;\n\n  if (Validation.isUndefined(homeName))\n    return sender.sendMessage(\"\u00a7cHome name cannot be empty\");\n\n  const homeDBFrmt = `${sender.name}_${homeName}`;", "  if (!HomeDB.hasKey(homeDBFrmt))\n    return sender.sendMessage(`\u00a7cHome with name \u00a7e${homeName} \u00a7cdoesn't exist`);\n\n  const parsedHome = HomeDB.get(homeDBFrmt);\n\n  await null;\n  sender.teleport(\n    {\n      x: parsedHome.coordinate[0],\n      y: parsedHome.coordinate[1],\n      z: parsedHome.coordinate[2],\n    },\n    { dimension: world.getDimension(parsedHome.dimension) }\n  );\n  return sender.sendMessage(\n    `\u00a7aSuccessfully teleported to home with name \u00a7e${homeName}`\n  );\n});\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/sethome.ts", "chunked_list": ["import {\n  Command,\n  CommandRegistration,\n  Database,\n  Validation,\n} from \"../../../@modules\";\n\nconst registration: CommandRegistration = new CommandRegistration()\n  .setName(\"sethome\")\n  .setDescription(\"Sethome home\")", "  .setName(\"sethome\")\n  .setDescription(\"Sethome home\")\n  .setAliases([\"shome\"])\n  .setInputs({ 0: [\"string\"] })\n  .setUsage([\"<homeName>\"])\n  .setExample([\"sethome myHome\", \"shome myHome\"]);\n\nconst HomeDB = new Database(\"HomeDB\");\n\nCommand.BuildCommand(registration, (interaction) => {", "\nCommand.BuildCommand(registration, (interaction) => {\n  const { sender, inputs } = interaction;\n  const homeName = inputs.getInput(0) as any;\n\n  if (Validation.isUndefined(homeName))\n    return sender.sendMessage(\"\u00a7cHome name cannot be empty\");\n\n  const homeDBFrmt = `${sender.name}_${homeName}`;\n  if (HomeDB.hasKey(homeDBFrmt))\n    return sender.sendMessage(`\u00a7eHome with name \u00a7e${homeName} \u00a7calready exist`);\n\n  HomeDB.set(homeDBFrmt, {\n    name: homeName,\n    creator: sender.name,\n    coordinate: [\n      Math.floor(sender.location.x),\n      Math.floor(sender.location.y),\n      Math.floor(sender.location.z),\n    ],\n    dimension: sender.dimension.id,\n  });\n  return sender.sendMessage(\n    `\u00a7aSuccessfully set home with name \u00a7e${homeName} \u00a7aat coordinates \u00a7eX: ${Math.floor(\n      sender.location.x\n    )} Y: ${Math.floor(sender.location.x)} Z: ${Math.floor(sender.location.z)}`\n  );\n});\n\nexport { HomeDB };\n", "  if (HomeDB.hasKey(homeDBFrmt))\n    return sender.sendMessage(`\u00a7eHome with name \u00a7e${homeName} \u00a7calready exist`);\n\n  HomeDB.set(homeDBFrmt, {\n    name: homeName,\n    creator: sender.name,\n    coordinate: [\n      Math.floor(sender.location.x),\n      Math.floor(sender.location.y),\n      Math.floor(sender.location.z),\n    ],\n    dimension: sender.dimension.id,\n  });\n  return sender.sendMessage(\n    `\u00a7aSuccessfully set home with name \u00a7e${homeName} \u00a7aat coordinates \u00a7eX: ${Math.floor(\n      sender.location.x\n    )} Y: ${Math.floor(sender.location.x)} Z: ${Math.floor(sender.location.z)}`\n  );\n});\n\nexport { HomeDB };\n"]}
{"filename": "src/main/plugins/Custom Commands/information/version.ts", "chunked_list": ["import { Config } from \"../../../config\";\nimport { Command, CommandRegistration } from \"../../@modules\";\n\nconst registration: CommandRegistration = new CommandRegistration()\n  .setName(\"version\")\n  .setDescription(\"Get API version\")\n  .setCategory(\"Information\")\n  .setAliases([\"ver\", \"versi\"]);\n\nCommand.BuildCommand(registration, (interaction) =>", "\nCommand.BuildCommand(registration, (interaction) =>\n  interaction.sender.sendMessage(`\u00a7aAPI Version: \u00a7e${Config.version}`)\n);\n"]}
{"filename": "src/main/plugins/Custom Commands/information/help.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\nimport { Command, CommandRegistration, Validation } from \"../../@modules\";\n\nconst registration: CommandRegistration = new CommandRegistration()\n  .setName(\"help\")\n  .setDescription(\"Help command\")\n  .setCategory(\"Information\")\n  .setAliases([\"?\", \"h\"])\n  .setInputs({ 0: [\"number\", \"string\"] })\n  .setUsage([\"<pageNumber | CommandName>\"])", "  .setInputs({ 0: [\"number\", \"string\"] })\n  .setUsage([\"<pageNumber | CommandName>\"])\n  .setExample([\"help ping\", \"help 1\", \"help\"]);\n\nconst PAGE_LIMIT: number = 12;\n\nCommand.BuildCommand(registration, (interaction) => {\n  const { sender, inputs } = interaction;\n\n  if (\n    isNaN(inputs.getInput(0) as any) &&\n    !Validation.isUndefined(inputs.getInput(0) as any)\n  ) {\n    const item = Command.getCommand(inputs.getInput(0) as any);\n", "\n  if (\n    isNaN(inputs.getInput(0) as any) &&\n    !Validation.isUndefined(inputs.getInput(0) as any)\n  ) {\n    const item = Command.getCommand(inputs.getInput(0) as any);\n\n    if (!item)\n      return sender.sendMessage(\n        `\u00a7cCommands with name or alias \u00a7f${\n          inputs.getInput(0) as any\n        } \u00a7cnot found.`\n      );\n\n    return sender.sendMessage(\n      `\u00a7a--- Command information ---\\n\u00a77Name: \u00a7f${\n        item.name\n      }\\n\u00a77Description: \u00a7f${\n        item.description.length === 0\n          ? \"No description found\"\n          : item.description\n      }\\n\u00a77Category: \u00a7f${item.category}\\n\u00a77Aliases: \u00a7f${\n        item.aliases.length === 0 ? \"No aliases found\" : item.aliases.join(\", \")\n      }\\n\u00a77Usage: \u00a7f\\n - ${\n        item.usage.length === 0 ? \"No usage found\" : item.usage.join(\"\\n - \")\n      }\\n\u00a77Example Usage: \u00a7f\\n - ${\n        item.example.length === 0\n          ? \"No example found\"\n          : item.example.join(\"\\n - \")\n      }\\n\u00a7a--------------------------`\n    );\n  } else {\n    const startIndex: number = (((inputs.getInput(0) as any) ?? 1) - 1) * PAGE_LIMIT;\n    const endIndex: number = ((inputs.getInput(0) as any) ?? 1) * PAGE_LIMIT;\n    const items = Array.from(Command.getAllCommands().values())\n      .slice(startIndex, endIndex)\n      .filter((command) => !command.private);\n    const maxPages: number = Math.ceil(items.length / PAGE_LIMIT);\n\n    let messages: string = \"\";\n    let currentCategory: string = \"\";\n\n    messages += `\u00a7a--- Showing help page ${\n      inputs.getInput(0) ?? 1\n    } of ${maxPages} [\u00a7e${Command.getPrefix()}help <page>\u00a7a] ---\\n\\n`;\n    messages += items\n      .map((item) => {\n        let categoryLine = \"\";", "        if (item.category !== currentCategory) {\n          categoryLine = `\u00a7e${item.category}:\\n`;\n          currentCategory = item.category;\n        }\n        return `${categoryLine} \u00a77${Command.getPrefix()}${item.name} \u00a7f${\n          item.usage[0]\n        }`;\n      })\n      .join(\"\\n\");\n\n    if (inputs.getInput(0) === 1) {\n      const remainingItems = Array.from(\n        Command.getAllCommands().values()\n      ).slice(PAGE_LIMIT);", "    if (inputs.getInput(0) === 1) {\n      const remainingItems = Array.from(\n        Command.getAllCommands().values()\n      ).slice(PAGE_LIMIT);\n      if (remainingItems.length > 0) {\n        messages += `\\n\u00a7eTo view the next page, use \u00a7f${Command.getPrefix()}help 2 \u00a7eor \u00a7f${Command.getPrefix()}help 3\u00a7e, and so on`;\n      }\n    } else {\n      const remainingItems = Array.from(\n        Command.getAllCommands().values()\n      ).slice(endIndex);", "      if (remainingItems.length > 0) {\n        messages += `\\n\u00a7eTo view the next page, use \u00a7f${Command.getPrefix()}help ${\n          ((inputs.getInput(0) as any) ?? 1) + 1\n        }`;\n      }\n    }\n\n    return sender.sendMessage(messages);\n  }\n});\n"]}
{"filename": "src/main/@modules/modules.ts", "chunked_list": ["export { Command } from \"./handlers/command/Command.Class\";\nexport { CommandRegistration } from \"./handlers/command/CommandRegistration.Class\";\nexport { Collection } from \"./handlers/data/Collection.Class\";\nexport { PlayerClass } from \"./handlers/entity/Player.Class\";\nexport { EntityClass } from \"./handlers/entity/Entity.Class\";\nexport { ChatClass } from \"./handlers/message/Chat.Class\";\nexport { ErrorClass } from \"./handlers/message/Error.Class\";\nexport { FailedClass } from \"./handlers/message/Failed.Class\";\nexport { FormClass } from \"./handlers/interface/Form.Class\";\nexport * as Form from \"./handlers/interface/Form.Function\";", "export { FormClass } from \"./handlers/interface/Form.Class\";\nexport * as Form from \"./handlers/interface/Form.Function\";\nexport * as World from \"./handlers/world/World.Function\";\n\nexport { Database } from \"./storages/Database.Class\";\n\nexport { AfterEvents } from \"./events/AfterEventsEmitter.Class\";\nexport { BeforeEvents } from \"./events/BeforeEventsEmitter.Class\";\nexport { SystemEvents } from \"./events/SystemEventsEmitter.Class\";\n", "export { SystemEvents } from \"./events/SystemEventsEmitter.Class\";\n\nexport { CooldownClass } from \"./utils/Cooldown.Class\";\nexport * as Formatter from \"./utils/Formatter.Function\";\nexport * as Timer from \"./utils/Timer.Function\";\nexport * as Validation from \"./utils/Validation.Function\";\nexport * as MS from \"./utils/MS.Function\";\n"]}
{"filename": "src/main/@modules/storages/Database.Class.ts", "chunked_list": ["import {\n  world,\n  ScoreboardIdentityType,\n  Scoreboard,\n  ScoreboardObjective,\n} from \"@minecraft/server\";\nimport { Collection } from \"../handlers/data/Collection.Class\";\nimport { ChatClass } from \"../handlers/message/Chat.Class\";\nimport { ErrorClass } from \"../handlers/message/Error.Class\";\nimport * as Formatter from \"../utils/Formatter.Function\";", "import { ErrorClass } from \"../handlers/message/Error.Class\";\nimport * as Formatter from \"../utils/Formatter.Function\";\nimport * as Validation from \"../utils/Validation.Function\";\nimport * as Timer from \"../utils/Timer.Function\";\n\nclass Database {\n  private DB_NAME: string;\n  private DB_SAVED_NAMES: string[];\n  private RESTORED_DATA: Collection;\n  private error: ErrorClass;\n  private objective: Scoreboard | ScoreboardObjective;\n\n  /**\n   * Database class\n   * @param name - Database name\n   */\n  constructor(name: string) {\n    this.DB_NAME = name;\n    this.DB_SAVED_NAMES = [];\n    this.RESTORED_DATA = new Collection();\n    this.error = new ErrorClass();\n    this.objective =\n      world.scoreboard.getObjective(`DB_${name}`) ??\n      world.scoreboard.addObjective(`DB_${name}`, `DB_${name}`);\n", "    if (name.length > 15 || !name)\n      this.error.CustomError(\n        \"Database\",\n        \"constructor\",\n        \"Database names can't be more than 15 characters nor empty\"\n      );\n    if (this.DB_SAVED_NAMES.includes(name))\n      this.error.CustomError(\n        \"Database\",\n        \"constructor\",\n        `Database with name ${name} already exist`\n      );\n\n    this.DB_SAVED_NAMES.push(name);\n\n    Timer.runNextTick(() => {", "      for (const participant of this.objective.getParticipants()) {\n        if (participant.type !== ScoreboardIdentityType.FakePlayer) continue;\n        const [cleanData, parsedData] = participant.displayName\n          .slice(1, -1)\n          .split(\",\")\n          .map(Formatter.DecryptText);\n        this.RESTORED_DATA.set(JSON.parse(cleanData), JSON.parse(parsedData));\n      }\n    });\n  }\n\n  private _dataMerge(...arrays: any): any {\n    const destination: any = {};\n    arrays.forEach((source: any) => {", "      for (let prop in source) {\n        if (destination[prop] === null || Validation.isArray(destination[prop]))\n          destination[prop] =\n            destination[prop]?.concat(source[prop]) || source[prop];\n        else if (typeof destination[prop] === \"object\")\n          destination[prop] = this._dataMerge(destination[prop], source[prop]);\n        else destination[prop] = source[prop];\n      }\n    });\n    return destination;\n  }\n\n  /**\n   * Push new data to database\n   * @param key - Key\n   * @param value - Value or data\n   */\n  push(key: string, value: any): undefined | void {", "    if (!this.hasKey(key)) return undefined;\n    this.set(key, this._dataMerge(this.get(key), value));\n  }\n\n  /**\n   * Set data to database\n   * @param key - Key\n   * @param value - Value or data\n   */\n  async set(key: string, value: any) {\n    if (value.length >= 32000)\n      this.error.CustomError(\n        \"Database\",\n        \"set\",\n        \"Value length is too much, limit character is 32000 or 32k\"\n      );\n    const [encryptKey, encryptValue] = [key, value].map((item) =>\n      Formatter.EncryptText(JSON.stringify(item))\n    );\n    this.delete(key);\n    await null;\n    new ChatClass().runCommand(\n      `scoreboard players set \"[${encryptKey},${encryptValue}]\" \"DB_${this.DB_NAME}\" 0`\n    );\n    this.RESTORED_DATA.set(key, value);\n  }\n\n  /**\n   * Get data from database\n   * @param key - Key\n   */\n  get(key: string): any | undefined {\n    return this.hasKey(key) ? this.RESTORED_DATA.get(key) : undefined;\n  }\n\n  /**\n   * Delete database data based with key\n   * @param key - Key\n   */\n  async delete(key: string): Promise<void | undefined> {", "    if (value.length >= 32000)\n      this.error.CustomError(\n        \"Database\",\n        \"set\",\n        \"Value length is too much, limit character is 32000 or 32k\"\n      );\n    const [encryptKey, encryptValue] = [key, value].map((item) =>\n      Formatter.EncryptText(JSON.stringify(item))\n    );\n    this.delete(key);\n    await null;\n    new ChatClass().runCommand(\n      `scoreboard players set \"[${encryptKey},${encryptValue}]\" \"DB_${this.DB_NAME}\" 0`\n    );\n    this.RESTORED_DATA.set(key, value);\n  }\n\n  /**\n   * Get data from database\n   * @param key - Key\n   */\n  get(key: string): any | undefined {\n    return this.hasKey(key) ? this.RESTORED_DATA.get(key) : undefined;\n  }\n\n  /**\n   * Delete database data based with key\n   * @param key - Key\n   */\n  async delete(key: string): Promise<void | undefined> {", "    if (!this.hasKey(key)) return undefined;\n    const [encryptKey, encryptValue] = [key, this.RESTORED_DATA.get(key)].map(\n      (item) => Formatter.EncryptText(JSON.stringify(item))\n    );\n    await null;\n    new ChatClass().runCommand(\n      `scoreboard players reset \"[${encryptKey},${encryptValue}]\" \"DB_${this.DB_NAME}\"`\n    );\n    this.RESTORED_DATA.delete(key);\n  }\n\n  /**\n   * Find data without key\n   * @param fn - Function\n   */\n  find(fn: (value: any, key?: any, map?: Map<any, any>) => any): any {\n    return this.RESTORED_DATA.find(fn);\n  }\n\n  /**\n   * Looping the data\n   * @param fn - Function\n   */\n  forEach(fn: (value: any, key?: any, map?: Map<any, any>) => void): any {\n    return this.RESTORED_DATA.forEach(fn);\n  }\n\n  /**\n   * Reset database\n   */\n  reset() {\n    world.scoreboard.removeObjective(`DB_${this.DB_NAME}`);\n    world.scoreboard.addObjective(`DB_${this.DB_NAME}`, `DB_${this.DB_NAME}`);\n    this.RESTORED_DATA.clear();\n  }\n\n  /** Iterator */\n  *values() {\n    yield* this.RESTORED_DATA.values();\n  }\n\n  /** Iterator */\n  *keys() {\n    yield* this.RESTORED_DATA.keys();\n  }\n\n  /**\n   * Has key\n   * @param key - Key\n   */\n  hasKey(key: string): boolean {\n    return this.RESTORED_DATA.has(key);\n  }\n\n  /** Iterator */\n  *entries() {\n    yield* this.RESTORED_DATA.entries();\n  }\n\n  /** Iterator */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n}\n\nexport { Database };\n"]}
{"filename": "src/main/@modules/utils/Validation.Function.ts", "chunked_list": ["/**\n * Check if string\n * @param string\n */\nfunction isString(string: string): boolean {\n  return typeof string === \"string\";\n}\n\n/**\n * Check if number\n * @param number\n */", "function isNumber(number: number): boolean {\n  return typeof number === \"number\";\n}\n\n/**\n * Check if integer\n * @param integer\n */\nfunction isInteger(integer: bigint): boolean {\n  return Number.isInteger(integer);\n}\n\n/**\n * Check if boolean\n * @param boolean\n */", "function isInteger(integer: bigint): boolean {\n  return Number.isInteger(integer);\n}\n\n/**\n * Check if boolean\n * @param boolean\n */\nfunction isBoolean(boolean: boolean): boolean {\n  return typeof boolean === \"boolean\";\n}\n\n/**\n * Check if object\n * @param object\n */", "function isBoolean(boolean: boolean): boolean {\n  return typeof boolean === \"boolean\";\n}\n\n/**\n * Check if object\n * @param object\n */\nfunction isObject(object: object): boolean {\n  return (\n    typeof object === \"object\" && !Array.isArray(object) && object !== null\n  );\n}\n\n/**\n * Check if array\n * @param array\n */", "function isObject(object: object): boolean {\n  return (\n    typeof object === \"object\" && !Array.isArray(object) && object !== null\n  );\n}\n\n/**\n * Check if array\n * @param array\n */\nfunction isArray(array: Array<any>): boolean {\n  return Array.isArray(array);\n}\n\n/**\n * Check if null\n * @param object\n */", "function isArray(array: Array<any>): boolean {\n  return Array.isArray(array);\n}\n\n/**\n * Check if null\n * @param object\n */\nfunction isNull(object: null): boolean {\n  return object === null;\n}\n\n/**\n * Check if undefined\n * @param object\n */", "function isNull(object: null): boolean {\n  return object === null;\n}\n\n/**\n * Check if undefined\n * @param object\n */\nfunction isUndefined(object: undefined): boolean {\n  return object === undefined;\n}\n\n/**\n * Check if error\n * @param error\n */", "function isUndefined(object: undefined): boolean {\n  return object === undefined;\n}\n\n/**\n * Check if error\n * @param error\n */\nfunction isError(error: Error): boolean {\n  return error instanceof Error && \"message\" in error;\n}\n\nexport {\n  isString,\n  isNumber,\n  isInteger,\n  isBoolean,\n  isObject,\n  isArray,\n  isNull,\n  isUndefined,\n  isError,\n};", "function isError(error: Error): boolean {\n  return error instanceof Error && \"message\" in error;\n}\n\nexport {\n  isString,\n  isNumber,\n  isInteger,\n  isBoolean,\n  isObject,\n  isArray,\n  isNull,\n  isUndefined,\n  isError,\n};"]}
{"filename": "src/main/@modules/utils/MS.Function.ts", "chunked_list": ["/**\n * Converting durations or milliseconds\n */\nfunction Format(\n  value: number | string,\n  {\n    compactDuration = false,\n    fullDuration = false,\n    avoidDuration = [],\n  }: {\n    compactDuration?: boolean;\n    fullDuration?: boolean;\n    avoidDuration?: string[];\n  } = {}\n): boolean | number | string {", "  if (typeof value === \"string\") {\n    if (/^\\d+$/.test(value)) return Number(value);\n    const durations = value.match(\n      /-?\\d*\\.?\\d+\\s*?(years?|yrs?|weeks?|days?|hours?|hrs?|minutes?|mins?|seconds?|secs?|milliseconds?|msecs?|ms|[smhdwy])/gi\n    );\n    return durations\n      ? durations.reduce((a, b) => a + toMiliseconds(b), 0)\n      : null;\n  }\n\n  if (typeof value === \"number\")\n    return toDuration(value, {\n      compactDuration,\n      fullDuration,\n      avoidDuration,\n    });\n\n  return false;\n}\n\n/**\n * Convert durations to milliseconds\n */", "  if (typeof value === \"number\")\n    return toDuration(value, {\n      compactDuration,\n      fullDuration,\n      avoidDuration,\n    });\n\n  return false;\n}\n\n/**\n * Convert durations to milliseconds\n */", "function toMiliseconds(value: string): number {\n  const number = Number(value.replace(/[^-.0-9]+/g, \"\"));\n  value = value.replace(/\\s+/g, \"\");\n  if (/\\d+(?=y)/i.test(value)) return number * 3.154e10;\n  else if (/\\d+(?=w)/i.test(value)) return number * 6.048e8;\n  else if (/\\d+(?=d)/i.test(value)) return number * 8.64e7;\n  else if (/\\d+(?=h)/i.test(value)) return number * 3.6e6;\n  else if (/\\d+(?=m)/i.test(value)) return number * 60000;\n  else if (/\\d+(?=s)/i.test(value)) return number * 1000;\n  else if (/\\d+(?=ms|milliseconds?)/i.test(value)) return number;\n}\n\n/**\n * Convert milliseconds to duration\n */", "  else if (/\\d+(?=s)/i.test(value)) return number * 1000;\n  else if (/\\d+(?=ms|milliseconds?)/i.test(value)) return number;\n}\n\n/**\n * Convert milliseconds to duration\n */\nfunction toDuration(\n  value: number,\n  {\n    compactDuration = false,\n    fullDuration = false,\n    avoidDuration = [],\n  }: {\n    compactDuration?: boolean;\n    fullDuration?: boolean;\n    avoidDuration?: string[];\n  } = {}\n): string {\n  const absMs = Math.abs(value);\n  const duration = [\n    { short: \"w\", long: \"week\", duration: Math.floor(absMs / 6.048e8) },\n    { short: \"d\", long: \"day\", duration: Math.floor(absMs / 8.64e7) % 7 },\n    { short: \"h\", long: \"hour\", duration: Math.floor(absMs / 3.6e6) % 24 },\n    { short: \"m\", long: \"minute\", duration: Math.floor(absMs / 60000) % 60 },\n    { short: \"s\", long: \"second\", duration: Math.floor(absMs / 1000) % 60 },\n    { short: \"ms\", long: \"millisecond\", duration: absMs % 1000 },\n  ];\n\n  const mappedDuration = duration\n    .filter((obj) =>\n      obj.duration !== 0 && avoidDuration\n        ? fullDuration &&\n          !avoidDuration.map((v: string) => v.toLowerCase()).includes(obj.short)\n        : obj.duration\n    )\n    .map(\n      (obj) =>\n        `${Math.sign(value) === -1 ? \"-\" : \"\"}${\n          compactDuration\n            ? `${Math.floor(obj.duration)}${obj.short}`\n            : `${Math.floor(obj.duration)} ${obj.long}${\n                obj.duration === 1 ? \"\" : \"s\"\n              }`\n        }`\n    );\n  const result = fullDuration\n    ? mappedDuration.join(compactDuration ? \" \" : \", \")\n    : mappedDuration[0];\n  return result || `${absMs}`;\n}\n\nexport { Format, toMiliseconds, toDuration };\n"]}
{"filename": "src/main/@modules/utils/Timer.Function.ts", "chunked_list": ["import { system } from \"@minecraft/server\";\n\n/**\n * Run next tick\n * @param callback\n */\nfunction runNextTick(callback: () => void): number {\n  const timerId = system.run(callback);\n  return timerId;\n}\n\n/**\n * Repeatedly executing a function\n * @param callback\n * @param tick\n */", "function setTickInterval(callback: () => void, tick: number): number {\n  const timerId = system.runInterval(callback, tick);\n  return timerId;\n}\n\n/**\n * Executing a function with delay\n * @param callback\n * @param tick\n */\nfunction setTickTimeout(callback: () => void, tick: number): number {\n  const timerId = system.runTimeout(callback, tick);\n  return timerId;\n}\n\n/**\n * Same with setTickInterval but without tick\n * @param callback\n */", "function setTickTimeout(callback: () => void, tick: number): number {\n  const timerId = system.runTimeout(callback, tick);\n  return timerId;\n}\n\n/**\n * Same with setTickInterval but without tick\n * @param callback\n */\nfunction runInfinityLoop(callback: () => void): number {\n  const timerId = system.runInterval(callback);\n  return timerId;\n}\n\n/**\n * Clear tick\n * @param timerId\n * @example\n * const run = setTickInterval(YourFunction, 20);\n * clearTick(run);\n */", "function runInfinityLoop(callback: () => void): number {\n  const timerId = system.runInterval(callback);\n  return timerId;\n}\n\n/**\n * Clear tick\n * @param timerId\n * @example\n * const run = setTickInterval(YourFunction, 20);\n * clearTick(run);\n */", "function clearTick(timerId: number) {\n  system.clearRun(timerId);\n}\n\n/**\n * Like setTickTimeout but without function\n * @param tick\n * @example\n * console.warn(\"One\");\n * sleep(20);\n * console.warn(\"Two\");\n */", "async function sleep(tick: number): Promise<any> {\n  try {\n    return new Promise(\n      (resolve: (value?: unknown) => void, reject: (reason?: any) => void) => {\n        system.runTimeout(resolve, tick);\n      }\n    );\n  } catch (err) {\n    console.warn(err, err.stack);\n  }\n}\n\nexport {\n  runNextTick,\n  setTickInterval,\n  setTickTimeout,\n  runInfinityLoop,\n  clearTick,\n  sleep,\n};\n"]}
{"filename": "src/main/@modules/utils/Cooldown.Class.ts", "chunked_list": ["import { setTickTimeout } from \"./Timer.Function\";\n\nclass CooldownClass {\n  private endTime: number;\n\n  /**\n   * Cooldown system\n   */\n  constructor() {\n    this.endTime = null;\n  }\n\n  /**\n   * Start cooldown\n   * @param duration - Duration in seconds\n   */\n  start(duration: number) {", "    if (this.isActive()) return;\n\n    this.endTime = Date.now() + duration * 1000;\n\n    setTickTimeout(() => {\n      this.endTime = null;\n    }, duration * 20);\n  }\n\n  /**\n   * Check cooldown\n   * @returns {number}\n   */\n  isActive(): boolean {\n    return this.endTime !== null && this.endTime > Date.now();\n  }\n\n  /**\n   * Get cooldown time remaining\n   * @returns {number}\n   */\n  getCooldown(): number {", "    if (this.isActive()) {\n      const remainingTime = Math.max(0, this.endTime - Date.now());\n      return Math.round(remainingTime / 1000);\n    }\n    return 0;\n  }\n}\n\nexport { CooldownClass };\n"]}
{"filename": "src/main/@modules/utils/Formatter.Function.ts", "chunked_list": ["/**\n * Turn text into colored text\n * @param text - The text you want to format to rainbow colors.\n * @example rainbowText('This is rainbow text!');\n */\nfunction rainbowText(text: string): string {\n  const rainbowCode: string[] = [\n    \"\u00a74\",\n    \"\u00a7c\",\n    \"\u00a76\",\n    \"\u00a7e\",\n    \"\u00a7g\",\n    \"\u00a72\",\n    \"\u00a7a\",\n    \"\u00a7b\",\n    \"\u00a73\",\n    \"\u00a79\",\n    \"\u00a75\",\n    \"\u00a7d\",\n  ];\n  const letter: string[] = text.replace(/\u00a7./g, \"\").split(\"\");\n\n  let newMessage: string = \"\";\n  let rainbowIndex: number = 0;\n\n  letter.forEach((letter) => {", "    if (letter !== \" \") {\n      newMessage += `${rainbowCode[rainbowIndex]}${letter}`;\n      rainbowIndex + 1 >= rainbowCode.length\n        ? (rainbowIndex = 0)\n        : rainbowIndex++;\n    } else newMessage += \" \";\n  });\n\n  return newMessage;\n}\n\n/**\n * This will display in text in thousands, millions and etc... For ex: \"1400 -> \"1.4k\", \"1000000\" -> \"1M\", etc...\n * @param number - The number you want to convert\n * @example metricNumbers(15000);\n */", "function metricNumbers(value: number): string | number {\n  const types: string[] = [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\n  const selectType: number = (Math.log10(value) / 3) | 0;\n\n  if (selectType == 0) return value;\n  let scaled: number = value / Math.pow(10, selectType * 3);\n\n  return scaled.toFixed(1) + types[selectType];\n}\n\n/**\n * Will format your number. For ex: \"1400\" -> \"1,400\", \"1000000\" -> \"1,000,000\", etc...\n * @param number - The number you want to convert\n * @example thousandsSeparator(15000);\n */", "function thousandsSeparator(value: number): string {\n  if (typeof value !== \"number\") return;\n  return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n\n/**\n * Encrypt text\n * @param text\n */\nfunction EncryptText(text: string): string {\n  return text\n    .split(\"\")\n    .map((char) => {\n      return char.charCodeAt(0).toString(10);\n    })\n    .join(\"|\");\n}\n\n/**\n * Decrypt text\n * @param encrypt\n */", "function EncryptText(text: string): string {\n  return text\n    .split(\"\")\n    .map((char) => {\n      return char.charCodeAt(0).toString(10);\n    })\n    .join(\"|\");\n}\n\n/**\n * Decrypt text\n * @param encrypt\n */", "function DecryptText(encrypt: string): string {\n  return encrypt\n    .split(\"|\")\n    .map((char) => {\n      return String.fromCharCode(parseInt(char, 10));\n    })\n    .join(\"\");\n}\n\nexport {\n  rainbowText,\n  metricNumbers,\n  thousandsSeparator,\n  EncryptText,\n  DecryptText,\n};\n"]}
{"filename": "src/main/@modules/events/AfterEventsEmitter.Class.ts", "chunked_list": ["import {\n  AfterEventCallback,\n  AfterEventsList,\n} from \"../@types/events/AfterEventsType\";\n\nclass AfterEventsEmitter {\n  private _eventsListener: {\n    [key: string]: {\n      callback: Function;\n      once: boolean;\n    }[];\n  };\n\n  /**\n   * Event emitter\n   */\n  constructor() {\n    this._eventsListener = {};\n  }\n\n  private _addListener(\n    name: string,\n    callback: Function,\n    once: boolean = false\n  ) {", "    if (!this._eventsListener[name]) {\n      this._eventsListener[name] = [];\n    }\n    this._eventsListener[name].push({ callback, once });\n  }\n\n  /**\n   * Event trigger\n   * @param name - Trigger name\n   * @param args - Event insert callback\n   */\n  emit(name: string, ...args: any) {\n    const listener = this._eventsListener[name];", "    if (listener) {\n      listener.forEach((value, index) => {\n        value.callback(...args);\n        if (value.once) listener.splice(index, 1);\n      });\n    }\n  }\n\n  /**\n   * On event call\n   * @param name - Event name\n   * @param callback - Callback\n   */\n  on<T extends AfterEventsList>(\n    name: T,\n    callback: (arg: AfterEventCallback<T>) => void\n  ) {\n    this._addListener(name, callback);\n  }\n\n  /**\n   * Once event call\n   * @param name - Event name\n   * @param callback - Callback\n   */\n  once<T extends AfterEventsList>(\n    name: T,\n    callback: (arg: AfterEventCallback<T>) => void\n  ) {\n    this._addListener(name, callback, true);\n  }\n}\n\nconst AfterEvents = new AfterEventsEmitter();\nexport { AfterEvents };\n"]}
{"filename": "src/main/@modules/events/SystemEventsEmitter.Class.ts", "chunked_list": ["import {\n  SystemEventCallback,\n  SystemEventsList,\n} from \"../@types/events/SystemEventsType\";\n\nclass SystemEventsEmitter {\n  private _eventsListener: {\n    [key: string]: {\n      callback: Function;\n      once: boolean;\n    }[];\n  };\n\n  /**\n   * Event emitter\n   */\n  constructor() {\n    this._eventsListener = {};\n  }\n\n  private _addListener(\n    name: string,\n    callback: Function,\n    once: boolean = false\n  ) {", "    if (!this._eventsListener[name]) {\n      this._eventsListener[name] = [];\n    }\n    this._eventsListener[name].push({ callback, once });\n  }\n\n  /**\n   * Event trigger\n   * @param name - Event trigger\n   * @param args - Event insert callback\n   */\n  emit(name: string, ...args: any) {\n    const listener = this._eventsListener[name];", "    if (listener) {\n      listener.forEach((value, index) => {\n        value.callback(...args);\n        if (value.once) listener.splice(index, 1);\n      });\n    }\n  }\n\n  /**\n   * On event call\n   * @param name - Event name\n   * @param callback - Callback\n   */\n  on<T extends SystemEventsList>(\n    name: T,\n    callback: (arg: SystemEventCallback<T>) => void\n  ) {\n    this._addListener(name, callback);\n  }\n\n  /**\n   * Once event call\n   * @param name - Event name\n   * @param callback - Callback\n   */\n  once<T extends SystemEventsList>(\n    name: T,\n    callback: (arg: SystemEventCallback<T>) => void\n  ) {\n    this._addListener(name, callback, true);\n  }\n}\n\nconst SystemEvents = new SystemEventsEmitter();\nexport { SystemEvents };\n"]}
{"filename": "src/main/@modules/events/BeforeEventsEmitter.Class.ts", "chunked_list": ["import {\n  BeforeEventsList,\n  BeforeEventCallback,\n} from \"../@types/events/BeforeEventsType\";\n\nclass BeforeEventsEmitter {\n  private _eventsListener: {\n    [key: string]: {\n      callback: Function;\n      once: boolean;\n    }[];\n  };\n\n  /**\n   * Event emitter\n   */\n  constructor() {\n    this._eventsListener = {};\n  }\n\n  private _addListener(\n    name: string,\n    callback: Function,\n    once: boolean = false\n  ) {", "    if (!this._eventsListener[name]) {\n      this._eventsListener[name] = [];\n    }\n    this._eventsListener[name].push({ callback, once });\n  }\n\n  /**\n   * Event trigger\n   * @param name - Event trigger\n   * @param args - Event insert callback\n   */\n  emit(name: string, ...args: any) {\n    const listener = this._eventsListener[name];", "    if (listener) {\n      listener.forEach((value, index) => {\n        value.callback(...args);\n        if (value.once) listener.splice(index, 1);\n      });\n    }\n  }\n\n  /**\n   * On event call\n   * @param name - Event name\n   * @param callback - Callback\n   */\n  on<T extends BeforeEventsList>(\n    name: T,\n    callback: (arg: BeforeEventCallback<T>) => void\n  ) {\n    this._addListener(name, callback);\n  }\n\n  /**\n   * Once event call\n   * @param name - Event name\n   * @param callback - Callback\n   */\n  once<T extends BeforeEventsList>(\n    name: T,\n    callback: (arg: BeforeEventCallback<T>) => void\n  ) {\n    this._addListener(name, callback, true);\n  }\n}\n\nconst BeforeEvents = new BeforeEventsEmitter();\nexport { BeforeEvents };\n"]}
{"filename": "src/main/@modules/handlers/entity/Player.Class.ts", "chunked_list": ["import {\n  world,\n  Player,\n  EntityInventoryComponent,\n  ItemStack,\n} from \"@minecraft/server\";\nimport { EntityClass } from \"./Entity.Class\";\nimport { ErrorClass } from \"../message/Error.Class\";\nimport * as Validation from \"../../utils/Validation.Function\";\nimport * as World from \"../world/World.Function\";", "import * as Validation from \"../../utils/Validation.Function\";\nimport * as World from \"../world/World.Function\";\n\nclass PlayerClass extends EntityClass {\n  private playerObject: Player;\n  private inventory;\n  private errors: ErrorClass;\n\n  /**\n   * Player class\n   * @param playerObject - Player object\n   */\n  constructor(playerObject: Player) {\n    super(playerObject);\n    this.playerObject = playerObject;\n    this.inventory = this.playerObject.getComponent(\n      \"inventory\"\n    ) as EntityInventoryComponent;\n    this.errors = new ErrorClass();\n", "    if (!playerObject)\n      this.errors.CustomError(\n        \"PlayerClass\",\n        \"constructor\",\n        \"PlayerObject cannot be empty\"\n      );\n  }\n\n  /**\n   * Get player scoreboard score\n   * @param objective - Scoreboard objective name\n   * @example\n   * getScore(\"money\");\n   */\n  getScore(objective: string): number {", "    try {\n      const sb = world.scoreboard.getObjective(objective);\n      if (!sb) world.scoreboard.addObjective(objective, objective);\n      return sb.getScore(this.playerObject.scoreboardIdentity);\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Set player scoreboard value\n   * @param {String} objective - Scoreboard objective name\n   * @param {Number} value - Value\n   * @param {Boolean} isAdd - If true, it will add score not set score\n   */\n  setScore(\n    objective: string,\n    value: number,\n    isAdd: boolean = false\n  ): unknown | undefined {", "    try {\n      const sb = world.scoreboard.getObjective(objective);\n      if (!sb) world.scoreboard.addObjective(objective, objective);\n      return isAdd\n        ? this.setScore(objective, this.getScore(objective) + value)\n        : sb.setScore(this.playerObject.scoreboardIdentity, value);\n    } catch {\n      return undefined;\n    }\n  }\n\n  /**\n   * Get player xp level\n   * @example getXpLevel();\n   */\n  getXpLevel(): number {\n    return this.playerObject.level ?? 0;\n  }\n\n  /**\n   * Check player if online\n   * @param target - Player name\n   * @example isOnline(\"JustSky001\");\n   */\n  isOnline(target: string): boolean {\n    return (\n      World.getOnlinePlayers().find(\n        (player: Player) => player.name === target\n      ) !== undefined\n    );\n  }\n\n  /**\n   * Get player inventory empty slots\n   */\n  getEmptySlots() {\n    return this.inventory.container.emptySlotsCount;\n  }\n\n  /**\n   * Get player item in right hands slot\n   */\n  getRightItem(): ItemStack | undefined {\n    return this.inventory.container.getItem(this.playerObject.selectedSlot);\n  }\n\n  /**\n   * Get all items in inventory\n   */\n  getItems(): { [key: number]: ItemStack } {\n    let inventory = {};", "    for (let i = 0; i < this.inventory.container.size; i++) {\n      Object.assign(inventory, {\n        [i]: this.inventory.container.getItem(i),\n      });\n    }\n    return inventory;\n  }\n\n  /**\n   * Set item lore (player selected slot)\n   * @param lore - Lore list\n   */\n  setItemLore(lore: string[]): undefined {", "    if (!Validation.isArray(lore)) return;\n    this.getRightItem()?.setLore(lore);\n    this.inventory.container.setItem(\n      this.playerObject.selectedSlot,\n      this.getRightItem()\n    );\n  }\n\n  /**\n   * Get player object from name\n   * @param target - Player name\n   */\n  getPlayerObjectFromName(target: string): Player | undefined {\n    return World.getOnlinePlayers().find((player) => player.name === target);\n  }\n\n  /**\n   * Get needed xp to next level\n   */\n  needXpToLevelUp(): number {\n    return this.playerObject.totalXpNeededForNextLevel;\n  }\n\n  /**\n   * Get earned xp at current level\n   */\n  xpEarned(): number {\n    return this.playerObject.xpEarnedAtCurrentLevel;\n  }\n\n  /**\n   * Get inventory component\n   */\n  getInventoryComponent(): EntityInventoryComponent {\n    return this.inventory;\n  }\n\n  /**\n   * Get raw component\n   */\n  getRawPlayerComponent(): Player {\n    return this.playerObject;\n  }\n\n  /**\n   * Query\n   */\n  Query(query: QueryName): boolean {\n    return this.playerObject[query];\n  }\n}\n\nexport { PlayerClass };\n"]}
{"filename": "src/main/@modules/handlers/entity/Entity.Class.ts", "chunked_list": ["import { Entity } from \"@minecraft/server\";\nimport { ErrorClass } from \"../message/Error.Class\";\n\nclass EntityClass {\n  private entityObject: Entity;\n  private error: ErrorClass;\n\n  /**\n   * Entity class\n   * @param entityObject - Entity object\n   */\n  constructor(entityObject: Entity) {\n    this.entityObject = entityObject;\n    this.error = new ErrorClass();\n", "    if (!entityObject)\n      this.error.CustomError(\n        \"EntityClass\",\n        \"constructor\",\n        \"EntityObject cannot be empty\"\n      );\n  }\n\n  /**\n   * Get player all tag\n   * @example getTags();\n   */\n  getTags(): string[] {\n    return this.entityObject.getTags();\n  }\n\n  /**\n   * Check player if had tag\n   * @param tag - Tag\n   * @example hasTag(\"tag\");\n   */\n  hasTag(tag: string): boolean {", "    if (!tag)\n      this.error.CustomError(\"EntityClass\", \"hasTag\", \"tag cannot be empty\");\n\n    return this.entityObject.hasTag(tag);\n  }\n\n  /**\n   * Get player specific tag\n   * @example getSpecificTag(\"tag:\");\n   */\n  getTagStartsWith(startswith: string): string {", "    if (!startswith)\n      this.error.CustomError(\n        \"EntityClass\",\n        \"getTagStartsWith\",\n        \"startswith cannot be empty\"\n      );\n\n    const check: string = this.getTags()?.find((tag) =>\n      tag.startsWith(startswith)\n    );\n    return check;\n  }\n}\n\nexport { EntityClass };\n"]}
{"filename": "src/main/@modules/handlers/message/Chat.Class.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\nimport { ErrorClass } from \"./Error.Class\";\n\nclass ChatClass {\n  /**\n   * Broadcast message in chat\n   * @param rawtext - The text must be Object\n   * @param player - Player name (Optional)\n   * @example broadcast({ text: \"Hello world!\" });\n   */\n  broadcast(rawtext: object, player: string): unknown {\n    const JSONstring = JSON.stringify(rawtext);\n    return this.runCommand(\n      `tellraw ${player ? `\"${player}\"` : \"@a\"} {\"rawtext\":[${JSON.stringify(\n        rawtext\n      )}]}`\n    );\n  }\n\n  /**\n   * Runs a command\n   * @param command - Basic command but without \"/\"\n   * @param dimension - \"overworld\" | \"nether\" | \"the end\"\n   * @param debugMode - If true, it will logs the command results, but if false, it will run the command\n   * @example runCommand(\"say Hello world!\");\n   */\n  runCommand(\n    command: string,\n    dimension: string = \"overworld\",\n    debugMode: boolean = false\n  ): unknown | string {", "    if (command.startsWith(\"/\"))\n      new ErrorClass().CustomError(\n        \"ChatClass\",\n        \"runCommand\",\n        'command cannot starts with \"/\" at <anonymous>'\n      );\n\n    return debugMode\n      ? console.warn(JSON.stringify(this.runCommand(command)))\n      : world.getDimension(dimension).runCommand(command);\n  }\n\n  /**\n   * Runs multiple command at once\n   * @param commands - Basic command but without \"/\"\n   * @example runCommands([ \"say Hello\", \"say World!\" ]);\n   */\n  runCommands(commands: string[]) {", "    if (commands.some((slash) => slash.startsWith(\"/\")))\n      new ErrorClass().CustomError(\n        \"ChatClass\",\n        \"runCommands\",\n        'commands cannot starts with \"/\" at <anonymous>'\n      );\n\n    commands.forEach((cmd) => {\n      this.runCommand(cmd);\n    });\n  }\n}\n\nexport { ChatClass };\n"]}
{"filename": "src/main/@modules/handlers/message/Failed.Class.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\n\nclass FailedClass {\n  /**\n   * Invalid command builder\n   * @param player - Player object\n   * @param commandName - Command name\n   */\n  InvalidCommand(player: Player, commandName: string): unknown {\n    return player.sendMessage({\n      rawtext: [\n        {\n          text: \"\u00a7c\",\n        },\n        {\n          translate: \"commands.generic.unknown\",\n          with: [`${commandName}`],\n        },\n      ],\n    });\n  }\n}\n\nexport { FailedClass };\n"]}
{"filename": "src/main/@modules/handlers/message/Error.Class.ts", "chunked_list": ["class ErrorClass {\n  /**\n   * Custom error\n   * @param className - Class target\n   * @param functionName - Function target\n   * @param errorMessage - Error message\n   */\n  CustomError(\n    className: string,\n    functionName: string,\n    errorMessage: string\n  ): Error {\n    throw new Error(`[${className}::${functionName}] ${errorMessage}`);\n  }\n}\n\nexport { ErrorClass };\n"]}
{"filename": "src/main/@modules/handlers/data/Collection.Class.ts", "chunked_list": ["class Collection extends Map {\n  /**\n   * Collection\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Collection find\n   * @param fn - Function\n   */\n  find(fn: (value: any, key?: any, idk?: unknown) => any) {", "    for (const [key, value] of this) {\n      if (fn(value, key, this)) return value;\n    }\n  }\n}\n\nexport { Collection };\n"]}
{"filename": "src/main/@modules/handlers/command/CommandRegistration.Class.ts", "chunked_list": ["class CommandRegistration {\n  private name: string;\n  private description: string;\n  private private: boolean;\n  private category: string;\n  private requireTags: string[];\n  private aliases: string[];\n  private usage: string[];\n  private example: string[];\n  private inputs: {\n    [key: number]: string[];\n  };\n\n  /**\n   * Command registration\n   */\n  constructor() {\n    this.name = \"\";\n    this.description = \"No Description\";\n    this.private = false;\n    this.category = \"Global\";\n    this.requireTags = [];\n    this.aliases = [];\n    this.usage = [];\n    this.example = [];\n    this.inputs = {};\n  }\n\n  /**\n   * Set command name\n   */\n  setName(name: string) {\n    this.name = name;\n    return this;\n  }\n\n  /**\n   * Set command description\n   */\n  setDescription(desc: string) {\n    this.description = desc;\n    return this;\n  }\n\n  /**\n   * Set command private\n   */\n  setPrivate(value: boolean) {\n    this.private = value;\n    return this;\n  }\n\n  /**\n   * Set command category\n   */\n  setCategory(cname: string) {\n    this.category = cname;\n    return this;\n  }\n\n  /**\n   * Set command require tags\n   */\n  setRequireTags(tags: string[]) {\n    this.requireTags = tags;\n    return this;\n  }\n\n  /**\n   * Ser t command aliases\n   */\n  setAliases(als: string[]) {\n    this.aliases = als;\n    return this;\n  }\n\n  /**\n   * Set command usage\n   */\n  setUsage(usage: string[]) {\n    this.usage = usage;\n    return this;\n  }\n\n  /**\n   * Set command example\n   */\n  setExample(eg: string[]) {\n    this.example = eg;\n    return this;\n  }\n\n  /**\n   * Set command input\n   */\n  setInputs(inputs: { [key: number]: SupportedInputs }) {\n    Object.assign(this.inputs, inputs);\n    return this;\n  }\n\n  /**\n   * Extract to JSON - You don't need this for creating custom command\n   */\n  _ToJSON() {\n    return {\n      name: this.name,\n      description: this.description,\n      private: this.private,\n      category: this.category,\n      requireTags: this.requireTags,\n      aliases: this.aliases,\n      usage: this.usage,\n      example: this.example,\n      inputs: this.inputs,\n    };\n  }\n}\n\nexport { CommandRegistration };\n"]}
{"filename": "src/main/@modules/handlers/command/Command.Class.ts", "chunked_list": ["import { ChatSendBeforeEvent, world } from \"@minecraft/server\";\nimport { Collection } from \"../data/Collection.Class\";\nimport { FailedClass } from \"../message/Failed.Class\";\nimport { Database } from \"../../storages/Database.Class\";\nimport { ErrorClass } from \"../message/Error.Class\";\nimport * as Validation from \"../../utils/Validation.Function\";\nimport { Config } from \"../../../config\";\nimport { CommandBuild } from \"../../@types/handlers/command/CommandBuilder\";\nimport { CommandRegistration } from \"./CommandRegistration.Class\";\n\nclass CommandClass {\n  private registration: Collection;\n  private failed: FailedClass;\n  private error: ErrorClass;\n  private db: Database;\n  private commandPrefix: string;\n\n  /**\n   * Custom Command\n   */\n  constructor() {\n    this.registration = new Collection();\n    this.failed = new FailedClass();\n    this.error = new ErrorClass();\n    this.db = new Database(\"GlobalDB\");\n    this.commandPrefix = this.db.get(\"commandPrefix\") ?? Config.defaultPrefix;\n\n    world.beforeEvents.chatSend.subscribe(this.execute.bind(this));\n  }\n\n  /**\n   * Register new command\n   * @param registration\n   * @param callback\n   */\n  BuildCommand(\n    registration: CommandRegistration,\n    callback: (arg: CommandBuild) => void\n  ) {\n    const information = registration._ToJSON();\n    this.registration.set(information.name, {\n      ...information,\n      callback,\n    });\n  }\n\n  /**\n   * Get command\n   * @param commandName\n   */\n  getCommand(commandName: string) {\n    return (\n      this.registration.get(commandName) ||\n      this.registration.find((als) => als?.aliases.includes(commandName))\n    );\n  }\n\n  /**\n   * Get all command registratios\n   */\n  getAllCommands(): Collection {\n    return this.registration;\n  }\n\n  /**\n   * Get command prefix\n   */\n  getPrefix(): string {\n    return this.commandPrefix;\n  }\n\n  /**\n   * Set command prefix\n   * @param prefix\n   */\n  setPrefix(prefix: string) {", "import { CommandRegistration } from \"./CommandRegistration.Class\";\n\nclass CommandClass {\n  private registration: Collection;\n  private failed: FailedClass;\n  private error: ErrorClass;\n  private db: Database;\n  private commandPrefix: string;\n\n  /**\n   * Custom Command\n   */\n  constructor() {\n    this.registration = new Collection();\n    this.failed = new FailedClass();\n    this.error = new ErrorClass();\n    this.db = new Database(\"GlobalDB\");\n    this.commandPrefix = this.db.get(\"commandPrefix\") ?? Config.defaultPrefix;\n\n    world.beforeEvents.chatSend.subscribe(this.execute.bind(this));\n  }\n\n  /**\n   * Register new command\n   * @param registration\n   * @param callback\n   */\n  BuildCommand(\n    registration: CommandRegistration,\n    callback: (arg: CommandBuild) => void\n  ) {\n    const information = registration._ToJSON();\n    this.registration.set(information.name, {\n      ...information,\n      callback,\n    });\n  }\n\n  /**\n   * Get command\n   * @param commandName\n   */\n  getCommand(commandName: string) {\n    return (\n      this.registration.get(commandName) ||\n      this.registration.find((als) => als?.aliases.includes(commandName))\n    );\n  }\n\n  /**\n   * Get all command registratios\n   */\n  getAllCommands(): Collection {\n    return this.registration;\n  }\n\n  /**\n   * Get command prefix\n   */\n  getPrefix(): string {\n    return this.commandPrefix;\n  }\n\n  /**\n   * Set command prefix\n   * @param prefix\n   */\n  setPrefix(prefix: string) {", "    if (!prefix)\n      this.error.CustomError(\n        \"CommandClass\",\n        \"setPrefix\",\n        \"prefix cannot be empty\"\n      );\n\n    if (!Validation.isString(prefix))\n      this.error.CustomError(\n        \"CommandClass\",\n        \"setPrefix\",\n        \"prefix must be string\"\n      );\n\n    this.db.set(\"currentPrefix\", prefix);\n  }\n\n  /**\n   * Get input\n   */\n  private getCommandInput(\n    args: string[],\n    commandInput: { [key: number]: string[] },\n    inputNumber: number\n  ): undefined | boolean | string | number {", "    if (!commandInput) return undefined;\n\n    const inputTypes = [\"string\", \"boolean\", \"number\", \"playername\"];\n    const getTypes = commandInput[inputNumber];\n    const inputValue = args[inputNumber];\n\n    if (!getTypes || inputValue === undefined) return undefined;\n\n    for (const type of getTypes) {\n      if (type === \"playername\" && inputValue.startsWith(\"@\"))\n        return inputValue.substring(1);\n", "    for (const type of getTypes) {\n      if (type === \"playername\" && inputValue.startsWith(\"@\"))\n        return inputValue.substring(1);\n\n      if (inputTypes.includes(type)) {\n        if (type === \"boolean\") {\n          if (inputValue === \"true\") return true;\n          if (inputValue === \"false\") return false;\n        }\n\n        if (type === \"number\") {\n          const parsedValue = Number(inputValue);", "        if (type === \"number\") {\n          const parsedValue = Number(inputValue);\n          if (!isNaN(parsedValue)) return parsedValue;\n        }\n\n        if (typeof inputValue === type) return inputValue;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Execute\n   * @private\n   * @param packet\n   */\n  private execute(packet: ChatSendBeforeEvent) {\n    const { message, sender } = packet;", "    if (!message.startsWith(this.commandPrefix)) return;\n\n    packet.cancel = true;\n    const args: string[] = message\n      .slice(this.commandPrefix.length)\n      .trim()\n      .match(/\"[^\"]+\"|\\S+/g)\n      .map((e) => e.replace(/\"/g, \"\"));\n    const commandArgs: string = args.shift().toLowerCase();\n    const commandName = this.getCommand(commandArgs);\n", "    if (\n      !commandName ||\n      (!!commandName?.private && !sender.isOp()) ||\n      (commandName?.requireTags.length > 0 &&\n        !commandName?.requireTags.every((i: any) =>\n          sender.getTags().includes(i)\n        ))\n    )\n      return this.failed.InvalidCommand(sender, commandArgs);\n    else\n      commandName?.callback({\n        DB: {\n          used: this.db,\n        },\n        inputs: {\n          getInput: (inputNumber: number) =>\n            this.getCommandInput(args, commandName.inputs, inputNumber),\n        },\n        raw: packet,\n        sender,\n        config: Config,\n      });\n  }\n}\n\nconst Command = new CommandClass();\nexport { Command };\n"]}
{"filename": "src/main/@modules/handlers/interface/Form.Function.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\nimport { FormCancelationReason } from \"@minecraft/server-ui\";\nimport { ErrorClass } from \"../message/Error.Class\";\nimport {\n  ActiveForm,\n  ActiveFormResponse,\n} from \"../../@types/handlers/interface/ActiveForm\";\n\n/**\n * Forced send form to player", "/**\n * Forced send form to player\n * @param formId - Form id\n * @param player - Player object\n */\nasync function SendActiveForm<T extends ActiveForm>(\n  formId: T,\n  player: Player\n): Promise<ActiveFormResponse<T>> {\n  try {\n    while (true) {\n      const response = await (formId as T).show(player);", "  try {\n    while (true) {\n      const response = await (formId as T).show(player);\n      if (response.cancelationReason !== FormCancelationReason.UserBusy)\n        return response as ActiveFormResponse<T>;\n    }\n  } catch (error) {\n    new ErrorClass().CustomError(\"SendActiveForm\", \"typeFunction\", error);\n  }\n}\n\nexport { SendActiveForm };\n"]}
{"filename": "src/main/@modules/handlers/interface/Form.Class.ts", "chunked_list": ["import { Player, RawMessage } from \"@minecraft/server\";\nimport {\n  ActionFormData,\n  MessageFormData,\n  ModalFormData,\n} from \"@minecraft/server-ui\";\nimport { ErrorClass } from \"../message/Error.Class\";\nimport * as Validation from \"../../utils/Validation.Function\";\nimport {\n  FormTypeList,", "import {\n  FormTypeList,\n  FormTypes,\n  FormResponse,\n} from \"../../@types/handlers/interface/FormType\";\n\nclass FormClass<T extends FormTypeList> {\n  private type: string;\n  private typeMap: { [key: string]: any };\n  private error: ErrorClass;\n  private formType: FormTypes<T>;\n\n  /**\n   * Form class\n   * @param type - Form type (action, message, modal)\n   */\n  constructor(type: T) {\n    this.type = type;\n    this.typeMap = {\n      action: ActionFormData,\n      message: MessageFormData,\n      modal: ModalFormData,\n    };\n    this.error = new ErrorClass();\n", "    if (type.length === 0)\n      this.error.CustomError(\n        \"FormClass\",\n        \"constructor\",\n        \"type cannot be empty\"\n      );\n    if (Validation.isUndefined(this.typeMap[type]))\n      this.error.CustomError(\n        \"FormClass\",\n        \"constructor\",\n        \"unsupported type, available type (action, message, modal)\"\n      );\n\n    this.formType = new this.typeMap[type]();\n  }\n\n  /**\n   * AllForm: form title\n   * @param text - Title text\n   */\n  setTitle(text: string | RawMessage) {\n    this.formType.title(text);\n    return this;\n  }\n\n  /**\n   * Action and Message: form body\n   * @param text - Body text\n   */\n  setBody(text: string | RawMessage) {", "    if (\n      !(this.formType instanceof ActionFormData) ||\n      !(this.formType instanceof MessageFormData)\n    )\n      this.error.CustomError(\n        \"FormClass\",\n        \"setBody\",\n        \"Modal form don't have setBody method\"\n      );\n    (this.formType as ActionFormData | MessageFormData).body(text);\n    return this;\n  }\n\n  /**\n   * Action: form button\n   * @param text - Button text\n   * @param iconPath - Button icon (optional)\n   */\n  addButton(text: string | RawMessage, iconPath?: string) {", "    if (!(this.formType instanceof ActionFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"addButton\",\n        \"Message and Modal form don't have addButton method\"\n      );\n    (this.formType as ActionFormData).button(text, iconPath);\n    return this;\n  }\n\n  /**\n   * Message: form button 1\n   * @param text - Button text\n   */\n  setButton1(text: string | RawMessage) {", "    if (!(this.formType instanceof MessageFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"setButton1\",\n        \"Action and Modal form don't have setButton1 method\"\n      );\n    (this.formType as MessageFormData).button1(text);\n    return this;\n  }\n\n  /**\n   * Message: form button 2\n   * @param text - Button text\n   */\n  setButton2(text: string | RawMessage) {", "    if (!(this.formType instanceof MessageFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"setButton2\",\n        \"Action and Modal form don't have setButton2 method\"\n      );\n    (this.formType as MessageFormData).button2(text);\n    return this;\n  }\n\n  /**\n   * Modal: form dropdown\n   * @param label - Label text\n   * @param options - Array options\n   * @param defaultValue - Default value array number (optional)\n   */\n  addDropdown(\n    label: string | RawMessage,\n    options: string[] | RawMessage[],\n    defaultValue?: number\n  ) {", "    if (!(this.formType instanceof ModalFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"addDropdown\",\n        \"Action and Message form don't have addDropdown method\"\n      );\n    (this.formType as ModalFormData).dropdown(label, options, defaultValue);\n    return this;\n  }\n\n  /**\n   * Modal: form slider\n   * @param label - Label text\n   * @param minValue - Minimal slider value\n   * @param maxValue - Maximal slider value\n   * @param valueStep - Value step\n   * @param defaultValue - Default slider value (optional)\n   */\n  addSlider(\n    label: string | RawMessage,\n    minValue: number,\n    maxValue: number,\n    valueStep: number,\n    defaultValue?: number\n  ) {", "    if (!(this.formType instanceof ModalFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"addSlider\",\n        \"Action and Message form don't have addSlider method\"\n      );\n    (this.formType as ModalFormData).slider(\n      label,\n      minValue,\n      maxValue,\n      valueStep,\n      defaultValue\n    );\n    return this;\n  }\n\n  /**\n   * Modal: form text field\n   * @param label - Label text\n   * @param placeholder - Placeholder text\n   * @param defaultValue - Default text value (optional)\n   */\n  addTextField(\n    label: string | RawMessage,\n    placeholder: string | RawMessage,\n    defaultValue?: string\n  ) {", "    if (!(this.formType instanceof ModalFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"addTextField\",\n        \"Action and Message form don't have addTextField method\"\n      );\n    (this.formType as ModalFormData).textField(\n      label,\n      placeholder,\n      defaultValue\n    );\n    return this;\n  }\n\n  /**\n   * Modal: form toggle\n   * @param label - Label text\n   * @param defaultValue - Default toggle value (optional)\n   */\n  addToggle(label: string | RawMessage, defaultValue?: boolean) {", "    if (!(this.formType instanceof ModalFormData))\n      this.error.CustomError(\n        \"FormClass\",\n        \"addToggle\",\n        \"Action and Message form don't have addToggle method\"\n      );\n    (this.formType as ModalFormData).toggle(label, defaultValue);\n    return this;\n  }\n\n  /**\n   * Show message to player\n   * @param player - Player object\n   */\n  async sendForm(player: Player): Promise<FormResponse<T>> {", "    try {\n      const response = await this.formType.show(player);\n      return response as FormResponse<T>;\n    } catch (error) {\n      this.error.CustomError(\"FormClass\", \"sendForm\", error);\n    }\n  }\n}\n\nexport { FormClass };\n"]}
{"filename": "src/main/@modules/handlers/world/World.Function.ts", "chunked_list": ["import { world, Player } from \"@minecraft/server\";\n\n/**\n * Get all online players\n */\nfunction getOnlinePlayers(): Player[] {\n  return world.getAllPlayers();\n}\n\nexport { getOnlinePlayers };\n"]}
{"filename": "src/main/@modules/@types/events/SystemEventsType.d.ts", "chunked_list": ["import {\n  ScriptEventCommandMessageAfterEvent,\n  WatchdogTerminateBeforeEvent,\n} from \"@minecraft/server\";\n\ntype SystemEventsList = \"watchdogTerminate\" | \"scriptEventReceive\";\n\ntype SystemEventCallback<T extends SystemEventsList> =\n  T extends \"watchdogTerminate\"\n    ? WatchdogTerminateBeforeEvent\n    : T extends \"scriptEventReceive\"\n    ? ScriptEventCommandMessageAfterEvent\n    : undefined;\n"]}
{"filename": "src/main/@modules/@types/events/BeforeEventsType.d.ts", "chunked_list": ["import {\n  ChatSendBeforeEvent,\n  DataDrivenEntityTriggerBeforeEvent,\n  ExplosionBeforeEvent,\n  ItemDefinitionBeforeEventSignal,\n  ItemUseBeforeEvent,\n  ItemUseOnBeforeEvent,\n  PistonActivateBeforeEvent,\n} from \"@minecraft/server\";\n\ntype BeforeEventsList =\n  | \"chat\"\n  | \"dataDrivenEntity\"\n  | \"explosion\"\n  | \"itemDefinition\"\n  | \"itemUse\"\n  | \"itemUseOn\"\n  | \"pistonActivate\";\n", "} from \"@minecraft/server\";\n\ntype BeforeEventsList =\n  | \"chat\"\n  | \"dataDrivenEntity\"\n  | \"explosion\"\n  | \"itemDefinition\"\n  | \"itemUse\"\n  | \"itemUseOn\"\n  | \"pistonActivate\";\n", "type BeforeEventCallback<T extends BeforeEventsList> = T extends \"chat\"\n  ? ChatSendBeforeEvent\n  : T extends \"dataDrivenEntity\"\n  ? DataDrivenEntityTriggerBeforeEvent\n  : T extends \"explosion\"\n  ? ExplosionBeforeEvent\n  : T extends \"itemDefinition\"\n  ? ItemDefinitionBeforeEventSignal\n  : T extends \"itemUse\"\n  ? ItemUseBeforeEvent\n  : T extends \"itemUseOn\"\n  ? ItemUseOnBeforeEvent\n  : T extends \"pistonActivate\"\n  ? PistonActivateBeforeEvent\n  : undefined;\n"]}
{"filename": "src/main/@modules/@types/events/AfterEventsType.d.ts", "chunked_list": ["import {\n  BlockBreakAfterEvent,\n  BlockExplodeAfterEvent,\n  BlockPlaceAfterEvent,\n  ButtonPushAfterEvent,\n  ChatSendAfterEvent,\n  DataDrivenEntityTriggerAfterEvent,\n  EffectAddAfterEvent,\n  EntityDieAfterEvent,\n  EntityHealthChangedAfterEvent,", "  EntityDieAfterEvent,\n  EntityHealthChangedAfterEvent,\n  EntityHitBlockAfterEvent,\n  EntityHitEntityAfterEvent,\n  EntityHurtAfterEvent,\n  EntityRemovedAfterEvent,\n  EntitySpawnAfterEvent,\n  ExplosionAfterEvent,\n  ItemCompleteUseAfterEvent,\n  ItemDefinitionAfterEventSignal,", "  ItemCompleteUseAfterEvent,\n  ItemDefinitionAfterEventSignal,\n  ItemReleaseUseAfterEvent,\n  ItemStartUseAfterEvent,\n  ItemStartUseOnAfterEvent,\n  ItemStopUseAfterEvent,\n  ItemStopUseOnAfterEvent,\n  ItemUseAfterEvent,\n  ItemUseOnAfterEvent,\n  LeverActionAfterEvent,", "  ItemUseOnAfterEvent,\n  LeverActionAfterEvent,\n  MessageReceiveAfterEvent,\n  PistonActivateAfterEvent,\n  PlayerJoinAfterEvent,\n  PlayerLeaveAfterEvent,\n  PlayerSpawnAfterEvent,\n  PressurePlatePopAfterEvent,\n  PressurePlatePushAfterEvent,\n  ProjectileHitAfterEvent,", "  PressurePlatePushAfterEvent,\n  ProjectileHitAfterEvent,\n  TargetBlockHitAfterEvent,\n  TripWireTripAfterEvent,\n  WeatherChangeAfterEvent,\n  WorldInitializeAfterEvent,\n} from \"@minecraft/server\";\n\ntype AfterEventsList =\n  | \"blockBreak\"\n  | \"blockExplode\"\n  | \"blockPlace\"\n  | \"buttonPush\"\n  | \"chat\"\n  | \"dataDrivenEntity\"\n  | \"effectAdd\"\n  | \"entityDie\"\n  | \"entityHealthChanged\"\n  | \"entityHitBlock\"\n  | \"entityHitEntity\"\n  | \"entityHurt\"\n  | \"entityRemoved\"\n  | \"entitySpawn\"\n  | \"explosion\"\n  | \"itemCompleteUse\"\n  | \"itemDefinition\"\n  | \"itemReleaseUse\"\n  | \"itemStartUse\"\n  | \"itemStartUseOn\"\n  | \"itemStopUse\"\n  | \"itemStopUseOn\"\n  | \"itemUse\"\n  | \"itemUseOn\"\n  | \"leverAction\"\n  | \"messageReceive\"\n  | \"pistonActivate\"\n  | \"playerJoin\"\n  | \"playerLeave\"\n  | \"playerSpawn\"\n  | \"pressurePlatePop\"\n  | \"pressurePlatePush\"\n  | \"projectileHit\"\n  | \"targetBlockHit\"\n  | \"tripWireTrip\"\n  | \"weatherChange\"\n  | \"worldInitialize\";\n", "type AfterEventsList =\n  | \"blockBreak\"\n  | \"blockExplode\"\n  | \"blockPlace\"\n  | \"buttonPush\"\n  | \"chat\"\n  | \"dataDrivenEntity\"\n  | \"effectAdd\"\n  | \"entityDie\"\n  | \"entityHealthChanged\"\n  | \"entityHitBlock\"\n  | \"entityHitEntity\"\n  | \"entityHurt\"\n  | \"entityRemoved\"\n  | \"entitySpawn\"\n  | \"explosion\"\n  | \"itemCompleteUse\"\n  | \"itemDefinition\"\n  | \"itemReleaseUse\"\n  | \"itemStartUse\"\n  | \"itemStartUseOn\"\n  | \"itemStopUse\"\n  | \"itemStopUseOn\"\n  | \"itemUse\"\n  | \"itemUseOn\"\n  | \"leverAction\"\n  | \"messageReceive\"\n  | \"pistonActivate\"\n  | \"playerJoin\"\n  | \"playerLeave\"\n  | \"playerSpawn\"\n  | \"pressurePlatePop\"\n  | \"pressurePlatePush\"\n  | \"projectileHit\"\n  | \"targetBlockHit\"\n  | \"tripWireTrip\"\n  | \"weatherChange\"\n  | \"worldInitialize\";\n", "type AfterEventCallback<T extends AfterEventsList> = T extends \"blockBreak\"\n  ? BlockBreakAfterEvent\n  : T extends \"blockExplode\"\n  ? BlockExplodeAfterEvent\n  : T extends \"blockPlace\"\n  ? BlockPlaceAfterEvent\n  : T extends \"buttonPush\"\n  ? ButtonPushAfterEvent\n  : T extends \"chat\"\n  ? ChatSendAfterEvent\n  : T extends \"dataDrivenEntity\"\n  ? DataDrivenEntityTriggerAfterEvent\n  : T extends \"effectAdd\"\n  ? EffectAddAfterEvent\n  : T extends \"entityDie\"\n  ? EntityDieAfterEvent\n  : T extends \"entityHealthChanged\"\n  ? EntityHealthChangedAfterEvent\n  : T extends \"entityHitBlock\"\n  ? EntityHitBlockAfterEvent\n  : T extends \"entityHitEntity\"\n  ? EntityHitEntityAfterEvent\n  : T extends \"entityHurt\"\n  ? EntityHurtAfterEvent\n  : T extends \"entityRemoved\"\n  ? EntityRemovedAfterEvent\n  : T extends \"entitySpawn\"\n  ? EntitySpawnAfterEvent\n  : T extends \"explosion\"\n  ? ExplosionAfterEvent\n  : T extends \"itemCompleteUse\"\n  ? ItemCompleteUseAfterEvent\n  : T extends \"itemDefinition\"\n  ? ItemDefinitionAfterEventSignal\n  : T extends \"itemReleaseUse\"\n  ? ItemReleaseUseAfterEvent\n  : T extends \"itemStartUse\"\n  ? ItemStartUseAfterEvent\n  : T extends \"itemStartUseOn\"\n  ? ItemStartUseOnAfterEvent\n  : T extends \"itemStopUse\"\n  ? ItemStopUseAfterEvent\n  : T extends \"itemStopUseOn\"\n  ? ItemStopUseOnAfterEvent\n  : T extends \"itemUse\"\n  ? ItemUseAfterEvent\n  : T extends \"itemUseOn\"\n  ? ItemUseOnAfterEvent\n  : T extends \"leverAction\"\n  ? LeverActionAfterEvent\n  : T extends \"messageReceive\"\n  ? MessageReceiveAfterEvent\n  : T extends \"pistonActivate\"\n  ? PistonActivateAfterEvent\n  : T extends \"playerJoin\"\n  ? PlayerJoinAfterEvent\n  : T extends \"playerLeave\"\n  ? PlayerLeaveAfterEvent\n  : T extends \"playerSpawn\"\n  ? PlayerSpawnAfterEvent\n  : T extends \"pressurePlatePop\"\n  ? PressurePlatePopAfterEvent\n  : T extends \"pressurePlatePush\"\n  ? PressurePlatePushAfterEvent\n  : T extends \"projectileHit\"\n  ? ProjectileHitAfterEvent\n  : T extends \"targetBlockHit\"\n  ? TargetBlockHitAfterEvent\n  : T extends \"tripWireTrip\"\n  ? TripWireTripAfterEvent\n  : T extends \"weatherChange\"\n  ? WeatherChangeAfterEvent\n  : T extends \"worldInitialize\"\n  ? WorldInitializeAfterEvent\n  : undefined;\n"]}
{"filename": "src/main/@modules/@types/handlers/entity/PlayerType.d.ts", "chunked_list": ["type QueryName =\n  | \"isClimbing\"\n  | \"isFalling\"\n  | \"isFlying\"\n  | \"isGliding\"\n  | \"isInWater\"\n  | \"isJumping\"\n  | \"isOnGround\"\n  | \"isSneaking\"\n  | \"isSprinting\"\n  | \"isSwimming\";\n"]}
{"filename": "src/main/@modules/@types/handlers/command/RegistrationType.d.ts", "chunked_list": ["type inputs = [\"string\", \"boolean\", \"number\", \"playername\"]\n\ntype SupportedInputs = inputs[number][]"]}
{"filename": "src/main/@modules/@types/handlers/command/CommandBuilder.d.ts", "chunked_list": ["import { ChatSendBeforeEvent, Player } from \"@minecraft/server\";\nimport { Config } from \"../../../../config\";\n\ninterface CommandBuild {\n  DB?: {\n    used: number;\n  };\n  sender?: Player;\n  inputs?: {\n    getInput: (inputNumber: number) => number | string | boolean | undefined;\n  };\n  config?: typeof Config;\n  raw: ChatSendBeforeEvent;\n}\n"]}
{"filename": "src/main/@modules/@types/handlers/interface/FormType.d.ts", "chunked_list": ["import {\n  ActionFormData,\n  ActionFormResponse,\n  MessageFormData,\n  MessageFormResponse,\n  ModalFormData,\n  ModalFormResponse,\n} from \"@minecraft/server-ui\";\n\ntype FormTypeList = \"action\" | \"message\" | \"modal\";\n", "\ntype FormTypeList = \"action\" | \"message\" | \"modal\";\n\ntype FormTypes<T extends FormTypeList> = T extends \"action\"\n  ? ActionFormData\n  : T extends \"message\"\n  ? MessageFormData\n  : T extends \"modal\"\n  ? ModalFormData\n  : undefined;\n", "type FormResponse<T> = T extends \"action\"\n  ? ActionFormResponse\n  : T extends \"message\"\n  ? MessageFormResponse\n  : T extends \"modal\"\n  ? ModalFormResponse\n  : undefined;\n"]}
{"filename": "src/main/@modules/@types/handlers/interface/ActiveForm.d.ts", "chunked_list": ["import {\n  ActionFormData,\n  ActionFormResponse,\n  MessageFormData,\n  MessageFormResponse,\n  ModalFormData,\n  ModalFormResponse,\n} from \"@minecraft/server-ui\";\n\ntype ActiveForm = ActionFormData | MessageFormData | ModalFormData;\n", "\ntype ActiveForm = ActionFormData | MessageFormData | ModalFormData;\n\ntype ActiveFormResponse<T extends ActiveForm> = T extends ActionFormData\n  ? ActionFormResponse\n  : T extends MessageFormData\n  ? MessageFormResponse\n  : T extends ModalFormData\n  ? ModalFormResponse\n  : undefined;\n"]}
{"filename": "src/main/@modules/@types/handlers/world/WorldType.d.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\n\ntype GetAllPlayers<T extends boolean> = T extends true ? number : Player[]"]}
