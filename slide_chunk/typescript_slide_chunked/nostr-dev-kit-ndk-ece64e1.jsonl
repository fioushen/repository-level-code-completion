{"filename": "src/index.ts", "chunked_list": ["import debug from \"debug\";\nimport EventEmitter from \"eventemitter3\";\nimport { NDKCacheAdapter } from \"./cache/index.js\";\nimport dedupEvent from \"./events/dedup.js\";\nimport NDKEvent from \"./events/index.js\";\nimport type { NDKRelay } from \"./relay/index.js\";\nimport { NDKPool } from \"./relay/pool/index.js\";\nimport { calculateRelaySetFromEvent } from \"./relay/sets/calculate.js\";\nimport { NDKRelaySet } from \"./relay/sets/index.js\";\nimport { correctRelaySet } from \"./relay/sets/utils.js\";", "import { NDKRelaySet } from \"./relay/sets/index.js\";\nimport { correctRelaySet } from \"./relay/sets/utils.js\";\nimport type { NDKSigner } from \"./signers/index.js\";\nimport {\n    NDKFilter,\n    NDKSubscription,\n    NDKSubscriptionOptions,\n    filterFromId,\n    relaysFromBech32,\n} from \"./subscription/index.js\";", "    relaysFromBech32,\n} from \"./subscription/index.js\";\nimport NDKUser, { NDKUserParams } from \"./user/index.js\";\nimport { NDKUserProfile } from \"./user/profile.js\";\n\nexport { NDKEvent, NDKUser, NDKFilter, NDKUserProfile, NDKCacheAdapter };\nexport * from \"./events/index.js\";\nexport * from \"./events/kinds/index.js\";\nexport * from \"./events/kinds/article.js\";\nexport * from \"./events/kinds/dvm/index.js\";", "export * from \"./events/kinds/article.js\";\nexport * from \"./events/kinds/dvm/index.js\";\nexport * from \"./events/kinds/lists/index.js\";\nexport * from \"./events/kinds/repost.js\";\nexport * from \"./relay/index.js\";\nexport * from \"./relay/sets/index.js\";\nexport * from \"./signers/index.js\";\nexport * from \"./signers/nip07/index.js\";\nexport * from \"./signers/nip46/backend/index.js\";\nexport * from \"./signers/nip46/rpc.js\";", "export * from \"./signers/nip46/backend/index.js\";\nexport * from \"./signers/nip46/rpc.js\";\nexport * from \"./signers/nip46/index.js\";\nexport * from \"./signers/private-key/index.js\";\nexport * from \"./subscription/index.js\";\nexport * from \"./user/profile.js\";\nexport { NDKZapInvoice, zapInvoiceFromEvent } from \"./zap/invoice.js\";\n\nexport interface NDKConstructorParams {\n    explicitRelayUrls?: string[];\n    devWriteRelayUrls?: string[];\n    signer?: NDKSigner;\n    cacheAdapter?: NDKCacheAdapter;\n    debug?: debug.Debugger;\n}", "export interface NDKConstructorParams {\n    explicitRelayUrls?: string[];\n    devWriteRelayUrls?: string[];\n    signer?: NDKSigner;\n    cacheAdapter?: NDKCacheAdapter;\n    debug?: debug.Debugger;\n}\nexport interface GetUserParams extends NDKUserParams {\n    npub?: string;\n    hexpubkey?: string;\n}\n", "export default class NDK extends EventEmitter {\n    public pool: NDKPool;\n    public signer?: NDKSigner;\n    public cacheAdapter?: NDKCacheAdapter;\n    public debug: debug.Debugger;\n    public devWriteRelaySet?: NDKRelaySet;\n\n    public delayedSubscriptions: Map<string, NDKSubscription[]>;\n\n    public constructor(opts: NDKConstructorParams = {}) {\n        super();\n\n        this.debug = opts.debug || debug(\"ndk\");\n        this.pool = new NDKPool(opts.explicitRelayUrls || [], this);\n        this.signer = opts.signer;\n        this.cacheAdapter = opts.cacheAdapter;\n        this.delayedSubscriptions = new Map();\n", "        if (opts.devWriteRelayUrls) {\n            this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(\n                opts.devWriteRelayUrls,\n                this\n            );\n        }\n    }\n\n    public toJSON(): string {\n        return { relayCount: this.pool.relays.size }.toString();\n    }\n\n    /**\n     * Connect to relays with optional timeout.\n     * If the timeout is reached, the connection will be continued to be established in the background.\n     */\n    public async connect(timeoutMs?: number): Promise<void> {\n        this.debug(\"Connecting to relays\", { timeoutMs });\n        return this.pool.connect(timeoutMs);\n    }\n\n    /**\n     * Get a NDKUser object\n     *\n     * @param opts\n     * @returns\n     */\n    public getUser(opts: GetUserParams): NDKUser {\n        const user = new NDKUser(opts);\n        user.ndk = this;\n        return user;\n    }\n\n    /**\n     * Create a new subscription. Subscriptions automatically start and finish when all relays\n     * on the set send back an EOSE. (set `opts.closeOnEose` to `false` in order avoid this)\n     *\n     * @param filters\n     * @param opts\n     * @param relaySet explicit relay set to use\n     * @param autoStart automatically start the subscription\n     * @returns NDKSubscription\n     */\n    public subscribe(\n        filters: NDKFilter | NDKFilter[],\n        opts?: NDKSubscriptionOptions,\n        relaySet?: NDKRelaySet,\n        autoStart = true\n    ): NDKSubscription {\n        const subscription = new NDKSubscription(this, filters, opts, relaySet);\n\n        // Signal to the relays that they are explicitly being used", "        if (relaySet) {\n            for (const relay of relaySet.relays) {\n                this.pool.useTemporaryRelay(relay);\n            }\n        }\n\n        if (autoStart) subscription.start();\n\n        return subscription;\n    }\n\n    /**\n     * Publish an event to a relay\n     * @param event event to publish\n     * @param relaySet explicit relay set to use\n     * @param timeoutMs timeout in milliseconds to wait for the event to be published\n     * @returns The relays the event was published to\n     *\n     * @deprecated Use `event.publish()` instead\n     */\n    public async publish(\n        event: NDKEvent,\n        relaySet?: NDKRelaySet,\n        timeoutMs?: number\n    ): Promise<Set<NDKRelay>> {\n        this.debug(\"Deprecated: Use `event.publish()` instead\");\n", "        if (!relaySet) {\n            // If we have a devWriteRelaySet, use it to publish all events\n            relaySet =\n                this.devWriteRelaySet ||\n                calculateRelaySetFromEvent(this, event);\n        }\n\n        return relaySet.publish(event, timeoutMs);\n    }\n\n    /**\n     * Fetch a single event.\n     *\n     * @param idOrFilter event id in bech32 format or filter\n     * @param opts subscription options\n     * @param relaySet explicit relay set to use\n     */\n    public async fetchEvent(\n        idOrFilter: string | NDKFilter,\n        opts?: NDKSubscriptionOptions,\n        relaySet?: NDKRelaySet\n    ): Promise<NDKEvent | null> {\n        let filter: NDKFilter;\n\n        // if no relayset has been provided, try to get one from the event id", "        if (!relaySet && typeof idOrFilter === \"string\") {\n            const relays = relaysFromBech32(idOrFilter);\n\n            if (relays.length > 0) {\n                relaySet = new NDKRelaySet(new Set<NDKRelay>(relays), this);\n\n                // Make sure we have connected relays in this set\n                relaySet = correctRelaySet(relaySet, this.pool);\n            }\n        }\n", "        if (typeof idOrFilter === \"string\") {\n            filter = filterFromId(idOrFilter);\n        } else {\n            filter = idOrFilter;\n        }\n\n        if (!filter) {\n            throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n        }\n\n        return new Promise((resolve) => {\n            const s = this.subscribe(\n                filter,\n                { ...(opts || {}), closeOnEose: true },\n                relaySet,\n                false\n            );\n            s.on(\"event\", (event) => {\n                event.ndk = this;\n                resolve(event);\n            });\n\n            s.on(\"eose\", () => {\n                resolve(null);\n            });\n\n            s.start();\n        });\n    }\n\n    /**\n     * Fetch events\n     */\n    public async fetchEvents(\n        filters: NDKFilter | NDKFilter[],\n        opts?: NDKSubscriptionOptions,\n        relaySet?: NDKRelaySet\n    ): Promise<Set<NDKEvent>> {\n        return new Promise((resolve) => {\n            const events: Map<string, NDKEvent> = new Map();\n\n            const relaySetSubscription = this.subscribe(\n                filters,\n                { ...(opts || {}), closeOnEose: true },\n                relaySet,\n                false\n            );\n\n            const onEvent = (event: NDKEvent) => {\n                const dedupKey = event.deduplicationKey();\n\n                const existingEvent = events.get(dedupKey);", "                if (existingEvent) {\n                    event = dedupEvent(existingEvent, event);\n                }\n\n                event.ndk = this;\n                events.set(dedupKey, event);\n            };\n\n            // We want to inspect duplicated events\n            // so we can dedup them\n            relaySetSubscription.on(\"event\", onEvent);\n            relaySetSubscription.on(\"event:dup\", onEvent);\n\n            relaySetSubscription.on(\"eose\", () => {\n                resolve(new Set(events.values()));\n            });\n\n            relaySetSubscription.start();\n        });\n    }\n\n    /**\n     * Ensures that a signer is available to sign an event.\n     */\n    public async assertSigner() {", "        if (!this.signer) {\n            this.emit(\"signerRequired\");\n            throw new Error(\"Signer required\");\n        }\n    }\n}\n"]}
{"filename": "src/light-bolt11-decoder.d.ts", "chunked_list": ["declare module \"light-bolt11-decoder\" {\n    export function decode(bolt11: string): any;\n}\n"]}
{"filename": "src/zap/invoice.ts", "chunked_list": ["import { decode } from \"light-bolt11-decoder\";\nimport NDKEvent, { type NDKEventId, type NostrEvent } from \"../events/index.js\";\n\nexport interface NDKZapInvoice {\n    id?: NDKEventId;\n    zapper: string; // pubkey of zapper app\n    zappee: string; // pubkey of user sending zap\n    zapped: string; // pubkey of user receiving zap\n    zappedEvent?: string; // event zapped\n    amount: number; // amount zapped in millisatoshis\n    comment?: string;\n}\n\n/**\n * Parses a zap invoice from a kind 9735 event\n *\n * @param event The event to parse\n *\n * @returns NDKZapInvoice | null\n */", "export function zapInvoiceFromEvent(event: NDKEvent): NDKZapInvoice | null {\n    const description = event.getMatchingTags(\"description\")[0];\n    const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n    let decodedInvoice;\n    let zapRequest: NostrEvent;\n\n    if (!description || !bolt11 || !bolt11[1]) {\n        return null;\n    }\n\n    try {\n        let zapRequestPayload = description[1];", "    try {\n        let zapRequestPayload = description[1];\n        if (zapRequestPayload.startsWith(\"%\")) {\n            zapRequestPayload = decodeURIComponent(zapRequestPayload);\n        }\n        if (zapRequestPayload === \"\") {\n            return null;\n        }\n\n        zapRequest = JSON.parse(zapRequestPayload);\n        decodedInvoice = decode(bolt11[1]);", "    } catch (e) {\n        return null;\n    }\n\n    const amountSection = decodedInvoice.sections.find(\n        (s: any) => s.name === \"amount\"\n    );\n    if (!amountSection) {\n        return null;\n    }\n\n    const amount = parseInt(amountSection.value);", "    if (!amount) {\n        return null;\n    }\n\n    const content = zapRequest.content;\n    const sender = zapRequest.pubkey;\n    const recipientTag = event.getMatchingTags(\"p\")[0];\n    const recipient = recipientTag[1];\n    let zappedEvent = event.getMatchingTags(\"e\")[0];\n    if (!zappedEvent) {\n        zappedEvent = event.getMatchingTags(\"a\")[0];\n    }\n\n    const zappedEventId = zappedEvent ? zappedEvent[1] : undefined;\n\n    // ignore self-zaps (TODO: configurable?)", "    if (!zappedEvent) {\n        zappedEvent = event.getMatchingTags(\"a\")[0];\n    }\n\n    const zappedEventId = zappedEvent ? zappedEvent[1] : undefined;\n\n    // ignore self-zaps (TODO: configurable?)\n    // if (sender === recipient) { return null; } XXX\n\n    const zapInvoice: NDKZapInvoice = {\n        id: event.id,\n        zapper: event.pubkey,\n        zappee: sender,\n        zapped: recipient,\n        zappedEvent: zappedEventId,\n        amount,\n        comment: content,\n    };\n\n    return zapInvoice;\n}\n"]}
{"filename": "src/zap/index.ts", "chunked_list": ["import { bech32 } from \"@scure/base\";\nimport EventEmitter from \"eventemitter3\";\nimport { nip57 } from \"nostr-tools\";\nimport type { NostrEvent } from \"../events/index.js\";\nimport NDKEvent, { NDKTag } from \"../events/index.js\";\nimport NDK from \"../index.js\";\nimport User from \"../user/index.js\";\n\nconst DEFAULT_RELAYS = [\n    \"wss://nos.lol\",", "const DEFAULT_RELAYS = [\n    \"wss://nos.lol\",\n    \"wss://relay.nostr.band\",\n    \"wss://relay.f7z.io\",\n    \"wss://relay.damus.io\",\n    \"wss://nostr.mom\",\n    \"wss://no.str.cr\",\n];\n\ninterface ZapConstructorParams {\n    ndk: NDK;\n    zappedEvent?: NDKEvent;\n    zappedUser?: User;\n}\n", "\ninterface ZapConstructorParams {\n    ndk: NDK;\n    zappedEvent?: NDKEvent;\n    zappedUser?: User;\n}\n\ntype ZapConstructorParamsRequired = Required<\n    Pick<ZapConstructorParams, \"zappedEvent\">\n> &\n    Pick<ZapConstructorParams, \"zappedUser\"> &\n    ZapConstructorParams;\n", "export default class Zap extends EventEmitter {\n    public ndk?: NDK;\n    public zappedEvent?: NDKEvent;\n    public zappedUser: User;\n\n    public constructor(args: ZapConstructorParamsRequired) {\n        super();\n        this.ndk = args.ndk;\n        this.zappedEvent = args.zappedEvent;\n\n        this.zappedUser =\n            args.zappedUser ||\n            this.ndk.getUser({ hexpubkey: this.zappedEvent.pubkey });\n    }\n\n    public async getZapEndpoint(): Promise<string | undefined> {\n        let lud06: string | undefined;\n        let lud16: string | undefined;\n        let zapEndpoint: string | undefined;\n        let zapEndpointCallback: string | undefined;\n", "        if (this.zappedEvent) {\n            const zapTag = (await this.zappedEvent.getMatchingTags(\"zap\"))[0];\n\n            if (zapTag) {\n                switch (zapTag[2]) {\n                    case \"lud06\":\n                        lud06 = zapTag[1];\n                        break;\n                    case \"lud16\":\n                        lud16 = zapTag[1];\n                        break;\n                    default:\n                        throw new Error(`Unknown zap tag ${zapTag}`);\n                }\n            }\n        }\n", "        if (this.zappedUser && !lud06 && !lud16) {\n            // check if user has a profile, otherwise request it\n            if (!this.zappedUser.profile) {\n                await this.zappedUser.fetchProfile();\n            }\n\n            lud06 = (this.zappedUser.profile || {}).lud06;\n            lud16 = (this.zappedUser.profile || {}).lud16;\n        }\n\n        if (lud16) {\n            const [name, domain] = lud16.split(\"@\");\n            zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;", "        if (lud16) {\n            const [name, domain] = lud16.split(\"@\");\n            zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n        } else if (lud06) {\n            const { words } = bech32.decode(lud06, 1000);\n            const data = bech32.fromWords(words);\n            const utf8Decoder = new TextDecoder(\"utf-8\");\n            zapEndpoint = utf8Decoder.decode(data);\n        }\n\n        if (!zapEndpoint) {\n            throw new Error(\"No zap endpoint found\");\n        }\n\n        const response = await fetch(zapEndpoint);\n        const body = await response.json();\n", "        if (!zapEndpoint) {\n            throw new Error(\"No zap endpoint found\");\n        }\n\n        const response = await fetch(zapEndpoint);\n        const body = await response.json();\n\n        if (body?.allowsNostr && (body?.nostrPubkey || body?.nostrPubKey)) {\n            zapEndpointCallback = body.callback;\n        }\n\n        return zapEndpointCallback;\n    }\n\n    /**\n     * Generates a kind:9734 zap request and returns the payment request\n     * @param amount amount to zap in millisatoshis\n     * @param comment optional comment to include in the zap request\n     * @param extraTags optional extra tags to include in the zap request\n     * @param relays optional relays to ask zapper to publish the zap to\n     * @returns the payment request\n     */\n    public async createZapRequest(\n        amount: number, // amount to zap in millisatoshis\n        comment?: string,\n        extraTags?: NDKTag[],\n        relays?: string[]\n    ): Promise<string | null> {\n        const zapEndpoint = await this.getZapEndpoint();\n", "        if (!zapEndpoint) {\n            throw new Error(\"No zap endpoint found\");\n        }\n\n        if (!this.zappedEvent) throw new Error(\"No zapped event found\");\n\n        const zapRequest = nip57.makeZapRequest({\n            profile: this.zappedUser.hexpubkey(),\n\n            // set the event to null since nostr-tools doesn't support nip-33 zaps\n            event: null,\n            amount,\n            comment: comment || \"\",\n            relays: relays ?? this.relays(),\n        });\n\n        // add the event tag if it exists; this supports both 'e' and 'a' tags", "        if (this.zappedEvent) {\n            const tag = this.zappedEvent.tagReference();\n            if (tag) {\n                zapRequest.tags.push(tag);\n            }\n        }\n\n        zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n\n        const zapRequestEvent = new NDKEvent(\n            this.ndk,\n            zapRequest as NostrEvent\n        );", "        if (extraTags) {\n            zapRequestEvent.tags = zapRequestEvent.tags.concat(extraTags);\n        }\n\n        await zapRequestEvent.sign();\n        const zapRequestNostrEvent = await zapRequestEvent.toNostrEvent();\n\n        const response = await fetch(\n            `${zapEndpoint}?` +\n                new URLSearchParams({\n                    amount: amount.toString(),\n                    nostr: JSON.stringify(zapRequestNostrEvent),\n                })\n        );\n        const body = await response.json();\n\n        return body.pr;\n    }\n\n    /**\n     * @returns the relays to use for the zap request\n     */\n    private relays(): string[] {\n        let r: string[] = [];\n", "        if (this.ndk?.pool?.relays) {\n            r = this.ndk.pool.urls();\n        }\n\n        if (!r.length) {\n            r = DEFAULT_RELAYS;\n        }\n\n        return r;\n    }\n}\n"]}
{"filename": "src/signers/index.ts", "chunked_list": ["import type { NostrEvent } from \"../events/index.js\";\nimport NDKUser from \"../user\";\n\n/**\n * Interface for NDK signers.\n */\nexport interface NDKSigner {\n    /**\n     * Blocks until the signer is ready and returns the associated NDKUser.\n     * @returns A promise that resolves to the NDKUser instance.\n     */\n    blockUntilReady(): Promise<NDKUser>;\n\n    /**\n     * Getter for the user property.\n     * @returns A promise that resolves to the NDKUser instance.\n     */\n    user(): Promise<NDKUser>;\n\n    /**\n     * Signs the given Nostr event.\n     * @param event - The Nostr event to be signed.\n     * @returns A promise that resolves to the signature of the signed event.\n     */\n    sign(event: NostrEvent): Promise<string>;\n\n    /**\n     * Encrypts the given Nostr event for the given recipient.\n     * @param value - The value to be encrypted.\n     * @param recipient - The recipient of the encrypted value.\n     */\n    encrypt(recipient: NDKUser, value: string): Promise<string>;\n\n    /**\n     * Decrypts the given value.\n     * @param value\n     */\n    decrypt(sender: NDKUser, value: string): Promise<string>;\n}\n"]}
{"filename": "src/signers/nip46/rpc.ts", "chunked_list": ["import EventEmitter from \"eventemitter3\";\nimport NDK, {\n    NDKEvent,\n    NDKFilter,\n    NDKSigner,\n    NDKSubscription,\n    NostrEvent,\n} from \"../../index.js\";\n\nexport interface NDKRpcRequest {\n    id: string;\n    pubkey: string;\n    method: string;\n    params: string[];\n    event: NDKEvent;\n}\n", "\nexport interface NDKRpcRequest {\n    id: string;\n    pubkey: string;\n    method: string;\n    params: string[];\n    event: NDKEvent;\n}\n\nexport interface NDKRpcResponse {\n    id: string;\n    result: string;\n    error?: string;\n    event: NDKEvent;\n}\n", "export interface NDKRpcResponse {\n    id: string;\n    result: string;\n    error?: string;\n    event: NDKEvent;\n}\n\nexport class NDKNostrRpc extends EventEmitter {\n    private ndk: NDK;\n    private signer: NDKSigner;\n    private debug: debug.Debugger;\n\n    public constructor(ndk: NDK, signer: NDKSigner, debug: debug.Debugger) {\n        super();\n        this.ndk = ndk;\n        this.signer = signer;\n        this.debug = debug.extend(\"rpc\");\n    }\n\n    /**", "     * Subscribe to a filter. This function will resolve once the subscription is ready.\n     */\n    public async subscribe(filter: NDKFilter): Promise<NDKSubscription> {\n        const sub = this.ndk.subscribe(filter, { closeOnEose: false });\n\n        sub.on(\"event\", async (event: NDKEvent) => {\n            try {\n                const parsedEvent = await this.parseEvent(event);\n                if ((parsedEvent as NDKRpcRequest).method) {\n                    this.emit(\"request\", parsedEvent);\n                } else {\n                    this.emit(`response-${parsedEvent.id}`, parsedEvent);\n                }", "                if ((parsedEvent as NDKRpcRequest).method) {\n                    this.emit(\"request\", parsedEvent);\n                } else {\n                    this.emit(`response-${parsedEvent.id}`, parsedEvent);\n                }\n            } catch (e) {\n                this.debug(\"error parsing event\", e, event);\n            }\n        });\n\n        return new Promise((resolve, reject) => {\n            sub.on(\"eose\", () => resolve(sub));\n        });\n    }\n\n    public async parseEvent(\n        event: NDKEvent\n    ): Promise<NDKRpcRequest | NDKRpcResponse> {\n        const remoteUser = this.ndk.getUser({ hexpubkey: event.pubkey });\n        remoteUser.ndk = this.ndk;\n        const decryptedContent = await this.signer.decrypt(\n            remoteUser,\n            event.content\n        );\n        const parsedContent = JSON.parse(decryptedContent);\n        const { id, method, params, result, error } = parsedContent;\n", "        if (method) {\n            return { id, pubkey: event.pubkey, method, params, event };\n        } else {\n            return { id, result, error, event };\n        }\n    }\n\n    public async sendResponse(\n        id: string,\n        remotePubkey: string,\n        result: string,\n        kind = 24133,\n        error?: string\n    ) {\n        const res = { id, result } as NDKRpcResponse;", "        if (error) {\n            res.error = error;\n        }\n\n        const localUser = await this.signer.user();\n        const remoteUser = this.ndk.getUser({ hexpubkey: remotePubkey });\n        const event = new NDKEvent(this.ndk, {\n            kind,\n            content: JSON.stringify(res),\n            tags: [[\"p\", remotePubkey]],\n            pubkey: localUser.hexpubkey(),\n        } as NostrEvent);\n\n        event.content = await this.signer.encrypt(remoteUser, event.content);\n        await event.sign(this.signer);\n        await this.ndk.publish(event);\n    }\n\n    /**\n     * Sends a request.\n     * @param remotePubkey\n     * @param method\n     * @param params\n     * @param kind\n     * @param id\n     */\n    public async sendRequest(\n        remotePubkey: string,\n        method: string,\n        params: string[] = [],\n        kind = 24133,\n        cb?: (res: NDKRpcResponse) => void\n    ) {\n        const id = Math.random().toString(36).substring(7);\n        const localUser = await this.signer.user();\n        const remoteUser = this.ndk.getUser({ hexpubkey: remotePubkey });\n        const request = { id, method, params };\n        const promise = new Promise<NDKRpcResponse>((resolve) => {", "            if (cb) this.once(`response-${id}`, cb);\n        });\n\n        const event = new NDKEvent(this.ndk, {\n            kind,\n            content: JSON.stringify(request),\n            tags: [[\"p\", remotePubkey]],\n            pubkey: localUser.hexpubkey(),\n        } as NostrEvent);\n\n        event.content = await this.signer.encrypt(remoteUser, event.content);\n        await event.sign(this.signer);\n        this.debug(\"sending request to\", remotePubkey);\n\n        await this.ndk.publish(event);\n\n        return promise;\n    }\n}\n"]}
{"filename": "src/signers/nip46/index.ts", "chunked_list": ["import NDK, {\n    NDKPrivateKeySigner,\n    NDKSigner,\n    NDKUser,\n    NostrEvent,\n} from \"../../index.js\";\nimport { NDKNostrRpc, NDKRpcResponse } from \"./rpc.js\";\n\n/**\n * This NDKSigner implements NIP-46, which allows remote signing of events.\n * This class is meant to be used client-side, paired with the NDKNip46Backend or a NIP-46 backend (like Nostr-Connect)\n */", "/**\n * This NDKSigner implements NIP-46, which allows remote signing of events.\n * This class is meant to be used client-side, paired with the NDKNip46Backend or a NIP-46 backend (like Nostr-Connect)\n */\nexport class NDKNip46Signer implements NDKSigner {\n    private ndk: NDK;\n    public remoteUser: NDKUser;\n    public remotePubkey: string;\n    public token: string | undefined;\n    public localSigner: NDKSigner;\n    private rpc: NDKNostrRpc;\n    private debug: debug.Debugger;\n\n    /**\n     * @param ndk - The NDK instance to use\n     * @param token - connection token, in the form \"npub#otp\"\n     * @param localSigner - The signer that will be used to request events to be signed\n     */\n    public constructor(ndk: NDK, token: string, localSigner?: NDKSigner);\n\n    /**\n     * @param ndk - The NDK instance to use\n     * @param remoteNpub - The npub that wants to be published as\n     * @param localSigner - The signer that will be used to request events to be signed\n     */\n    public constructor(ndk: NDK, remoteNpub: string, localSigner?: NDKSigner);\n\n    /**\n     * @param ndk - The NDK instance to use\n     * @param remotePubkey - The public key of the npub that wants to be published as\n     * @param localSigner - The signer that will be used to request events to be signed\n     */\n    public constructor(ndk: NDK, remotePubkey: string, localSigner?: NDKSigner);\n\n    /**\n     * @param ndk - The NDK instance to use\n     * @param tokenOrRemotePubkey - The public key, or a connection token, of the npub that wants to be published as\n     * @param localSigner - The signer that will be used to request events to be signed\n     */\n    public constructor(\n        ndk: NDK,\n        tokenOrRemotePubkey: string,\n        localSigner?: NDKSigner\n    ) {\n        let remotePubkey: string;\n        let token: string | undefined;\n", "        if (tokenOrRemotePubkey.includes(\"#\")) {\n            const parts = tokenOrRemotePubkey.split(\"#\");\n            remotePubkey = new NDKUser({ npub: parts[0] }).hexpubkey();\n            token = parts[1];\n        } else if (tokenOrRemotePubkey.startsWith(\"npub\")) {\n            remotePubkey = new NDKUser({\n                npub: tokenOrRemotePubkey,\n            }).hexpubkey();\n        } else {\n            remotePubkey = tokenOrRemotePubkey;\n        }\n\n        this.ndk = ndk;\n        this.remotePubkey = remotePubkey;\n        this.token = token;\n        this.debug = ndk.debug.extend(\"nip46:signer\");\n\n        this.remoteUser = new NDKUser({ hexpubkey: remotePubkey });\n", "        if (!localSigner) {\n            this.localSigner = NDKPrivateKeySigner.generate();\n        } else {\n            this.localSigner = localSigner;\n        }\n\n        this.rpc = new NDKNostrRpc(ndk, this.localSigner, this.debug);\n    }\n\n    /**\n     * Get the user that is being published as\n     */\n    public async user(): Promise<NDKUser> {\n        return this.remoteUser;\n    }\n\n    public async blockUntilReady(): Promise<NDKUser> {\n        const localUser = await this.localSigner.user();\n        const user = this.ndk.getUser({ npub: localUser.npub });\n\n        // Generates subscription, single subscription for the lifetime of our connection\n        await this.rpc.subscribe({\n            kinds: [24133 as number],\n            \"#p\": [localUser.hexpubkey()],\n        });\n\n        return new Promise((resolve, reject) => {\n            // There is a race condition between the subscription and sending the request;\n            // introducing a small delay here to give a clear priority to the subscription\n            // to happen first\n            setTimeout(() => {\n                const connectParams = [localUser.hexpubkey()];\n", "                if (this.token) {\n                    connectParams.push(this.token);\n                }\n\n                this.rpc.sendRequest(\n                    this.remotePubkey,\n                    \"connect\",\n                    connectParams,\n                    24133,\n                    (response: NDKRpcResponse) => {\n                        if (response.result === \"ack\") {\n                            resolve(user);\n                        } else {\n                            reject(response.error);\n                        }\n                    }\n                );\n            }, 100);\n        });\n    }\n\n    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n        this.debug(\"asking for encryption\");\n\n        const promise = new Promise<string>((resolve, reject) => {\n            this.rpc.sendRequest(\n                this.remotePubkey,\n                \"nip04_encrypt\",\n                [recipient.hexpubkey(), value],\n                24133,\n                (response: NDKRpcResponse) => {", "                        if (response.result === \"ack\") {\n                            resolve(user);\n                        } else {\n                            reject(response.error);\n                        }\n                    }\n                );\n            }, 100);\n        });\n    }\n\n    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n        this.debug(\"asking for encryption\");\n\n        const promise = new Promise<string>((resolve, reject) => {\n            this.rpc.sendRequest(\n                this.remotePubkey,\n                \"nip04_encrypt\",\n                [recipient.hexpubkey(), value],\n                24133,\n                (response: NDKRpcResponse) => {", "                    if (!response.error) {\n                        resolve(response.result);\n                    } else {\n                        reject(response.error);\n                    }\n                }\n            );\n        });\n\n        return promise;\n    }\n\n    public async decrypt(sender: NDKUser, value: string): Promise<string> {\n        this.debug(\"asking for decryption\");\n\n        const promise = new Promise<string>((resolve, reject) => {\n            this.rpc.sendRequest(\n                this.remotePubkey,\n                \"nip04_decrypt\",\n                [sender.hexpubkey(), value],\n                24133,\n                (response: NDKRpcResponse) => {", "                    if (!response.error) {\n                        const value = JSON.parse(response.result);\n                        resolve(value[0]);\n                    } else {\n                        reject(response.error);\n                    }\n                }\n            );\n        });\n\n        return promise;\n    }\n\n    public async sign(event: NostrEvent): Promise<string> {\n        this.debug(\"asking for a signature\");\n\n        const promise = new Promise<string>((resolve, reject) => {\n            this.rpc.sendRequest(\n                this.remotePubkey,\n                \"sign_event\",\n                [JSON.stringify(event)],\n                24133,\n                (response: NDKRpcResponse) => {\n                    this.debug(\"got a response\", response);", "                    if (!response.error) {\n                        const json = JSON.parse(response.result);\n                        resolve(json.sig);\n                    } else {\n                        reject(response.error);\n                    }\n                }\n            );\n        });\n\n        return promise;\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/describe.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\nexport default class DescribeHandlingStrategy\n    implements IEventHandlingStrategy\n{\n    async handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined> {\n        const keys = Object.keys(backend.handlers);\n        return JSON.stringify(keys);\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/nip04-encrypt.ts", "chunked_list": ["import NDKUser from \"../../../user/index.js\";\nimport { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\nexport default class Nip04EncryptHandlingStrategy\n    implements IEventHandlingStrategy\n{\n    async handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined> {\n        const [recipientPubkey, payload] = params;\n        const recipientUser = new NDKUser({ hexpubkey: recipientPubkey });\n        const decryptedPayload = await backend.encrypt(\n            remotePubkey,\n            recipientUser,\n            payload\n        );\n\n        return decryptedPayload;\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/connect.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\nexport default class ConnectEventHandlingStrategy\n    implements IEventHandlingStrategy\n{\n    async handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined> {\n        const [pubkey, token] = params;\n        const debug = backend.debug.extend(\"connect\");\n\n        debug(`connection request from ${pubkey}`);\n", "        if (token && backend.applyToken) {\n            debug(`applying token`);\n            await backend.applyToken(pubkey, token);\n        }\n\n        if (await backend.pubkeyAllowed(pubkey, \"connect\", token)) {\n            debug(`connection request from ${pubkey} allowed`);\n            return \"ack\";\n        } else {\n            debug(`connection request from ${pubkey} rejected`);\n        }\n\n        return undefined;\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/nip04-decrypt.ts", "chunked_list": ["import NDKUser from \"../../../user/index.js\";\nimport { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\nexport default class Nip04DecryptHandlingStrategy\n    implements IEventHandlingStrategy\n{\n    async handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined> {\n        const [senderPubkey, payload] = params;\n        const senderUser = new NDKUser({ hexpubkey: senderPubkey });\n        const decryptedPayload = await backend.decrypt(\n            remotePubkey,\n            senderUser,\n            payload\n        );\n\n        return JSON.stringify([decryptedPayload]);\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/sign-event.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\nexport default class SignEventHandlingStrategy\n    implements IEventHandlingStrategy\n{\n    async handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined> {\n        const event = await backend.signEvent(remotePubkey, params);", "        if (!event) return undefined;\n\n        return JSON.stringify(await event.toNostrEvent());\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/index.ts", "chunked_list": ["import { verifySignature, Event } from \"nostr-tools\";\nimport NDK, { NDKEvent, NDKPrivateKeySigner, NDKUser } from \"../../../index.js\";\nimport { NDKNostrRpc } from \"../rpc.js\";\nimport ConnectEventHandlingStrategy from \"./connect.js\";\nimport DescribeEventHandlingStrategy from \"./describe.js\";\nimport GetPublicKeyHandlingStrategy from \"./get-public-key.js\";\nimport Nip04DecryptHandlingStrategy from \"./nip04-decrypt.js\";\nimport Nip04EncryptHandlingStrategy from \"./nip04-encrypt.js\";\nimport SignEventHandlingStrategy from \"./sign-event.js\";\n\nexport type Nip46PermitCallback = (\n    pubkey: string,\n    method: string,\n    params?: any\n) => Promise<boolean>;\n", "import SignEventHandlingStrategy from \"./sign-event.js\";\n\nexport type Nip46PermitCallback = (\n    pubkey: string,\n    method: string,\n    params?: any\n) => Promise<boolean>;\n\nexport type Nip46ApplyTokenCallback = (\n    pubkey: string,\n    token: string\n) => Promise<void>;\n", "export type Nip46ApplyTokenCallback = (\n    pubkey: string,\n    token: string\n) => Promise<void>;\n\nexport interface IEventHandlingStrategy {\n    handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined>;\n}\n\n/**", " * This class implements a NIP-46 backend, meaning that it will hold a private key\n * of the npub that wants to be published as.\n *\n * This backend is meant to be used by an NDKNip46Signer, which is the class that\n * should run client-side, where the user wants to sign events from.\n */\nexport class NDKNip46Backend {\n    readonly ndk: NDK;\n    readonly signer: NDKPrivateKeySigner;\n    public localUser?: NDKUser;\n    readonly debug: debug.Debugger;\n    private rpc: NDKNostrRpc;\n    private permitCallback: Nip46PermitCallback;\n\n    /**\n     * @param ndk The NDK instance to use\n     * @param privateKey The private key of the npub that wants to be published as\n     */\n    public constructor(\n        ndk: NDK,\n        privateKey: string,\n        permitCallback: Nip46PermitCallback\n    ) {\n        this.ndk = ndk;\n        this.signer = new NDKPrivateKeySigner(privateKey);\n        this.debug = ndk.debug.extend(\"nip46:backend\");\n        this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug);\n        this.permitCallback = permitCallback;\n    }\n\n    /**\n     * This method starts the backend, which will start listening for incoming\n     * requests.\n     */\n    public async start() {\n        this.localUser = await this.signer.user();\n\n        const sub = this.ndk.subscribe(\n            {\n                kinds: [24133 as number],\n                \"#p\": [this.localUser.hexpubkey()],\n            },\n            { closeOnEose: false }\n        );\n\n        sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n    }\n\n    public handlers: { [method: string]: IEventHandlingStrategy } = {\n        connect: new ConnectEventHandlingStrategy(),\n        sign_event: new SignEventHandlingStrategy(),\n        nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n        nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n        get_public_key: new GetPublicKeyHandlingStrategy(),\n        describe: new DescribeEventHandlingStrategy(),\n    };\n\n    /**\n     * Enables the user to set a custom strategy for handling incoming events.\n     * @param method - The method to set the strategy for\n     * @param strategy - The strategy to set\n     */\n    public setStrategy(method: string, strategy: IEventHandlingStrategy) {\n        this.handlers[method] = strategy;\n    }\n\n    /**\n     * Overload this method to apply tokens, which can\n     * wrap permission sets to be applied to a pubkey.\n     * @param pubkey public key to apply token to\n     * @param token token to apply\n     */\n    async applyToken(pubkey: string, token: string): Promise<void> {\n        throw new Error(\"connection token not supported\");\n    }\n\n    protected async handleIncomingEvent(event: NDKEvent) {\n        const { id, method, params } = (await this.rpc.parseEvent(\n            event\n        )) as any;\n        const remotePubkey = event.pubkey;\n        let response: string | undefined;\n\n        this.debug(\"incoming event\", { id, method, params });\n\n        // validate signature explicitly", "        if (!verifySignature(event.rawEvent() as Event<any>)) {\n            this.debug(\"invalid signature\", event.rawEvent());\n            return;\n        }\n\n        const strategy = this.handlers[method];\n        if (strategy) {\n            try {\n                response = await strategy.handle(this, remotePubkey, params);\n            } catch (e: any) {\n                this.debug(\"error handling event\", e, { id, method, params });\n                this.rpc.sendResponse(\n                    id,\n                    remotePubkey,\n                    \"error\",\n                    undefined,\n                    e.message\n                );\n            }\n        } else {\n            this.debug(\"unsupported method\", { method, params });\n        }\n", "            } catch (e: any) {\n                this.debug(\"error handling event\", e, { id, method, params });\n                this.rpc.sendResponse(\n                    id,\n                    remotePubkey,\n                    \"error\",\n                    undefined,\n                    e.message\n                );\n            }\n        } else {\n            this.debug(\"unsupported method\", { method, params });\n        }\n", "        if (response) {\n            this.debug(`sending response to ${remotePubkey}`, response);\n            this.rpc.sendResponse(id, remotePubkey, response);\n        } else {\n            this.rpc.sendResponse(\n                id,\n                remotePubkey,\n                \"error\",\n                undefined,\n                \"Not authorized\"\n            );\n        }\n    }\n\n    public async decrypt(\n        remotePubkey: string,\n        senderUser: NDKUser,\n        payload: string\n    ) {", "        if (!(await this.pubkeyAllowed(remotePubkey, \"decrypt\", payload))) {\n            this.debug(`decrypt request from ${remotePubkey} rejected`);\n            return undefined;\n        }\n\n        return await this.signer.decrypt(senderUser, payload);\n    }\n\n    public async encrypt(\n        remotePubkey: string,\n        recipientUser: NDKUser,\n        payload: string\n    ) {", "        if (!(await this.pubkeyAllowed(remotePubkey, \"encrypt\", payload))) {\n            this.debug(`encrypt request from ${remotePubkey} rejected`);\n            return undefined;\n        }\n\n        return await this.signer.encrypt(recipientUser, payload);\n    }\n\n    public async signEvent(\n        remotePubkey: string,\n        params: string[]\n    ): Promise<NDKEvent | undefined> {\n        const [eventString] = params;\n\n        this.debug(`sign event request from ${remotePubkey}`);\n\n        const event = new NDKEvent(this.ndk, JSON.parse(eventString));\n\n        this.debug(\"event to sign\", event.rawEvent());\n", "        if (!(await this.pubkeyAllowed(remotePubkey, \"sign_event\", event))) {\n            this.debug(`sign event request from ${remotePubkey} rejected`);\n            return undefined;\n        }\n\n        this.debug(`sign event request from ${remotePubkey} allowed`);\n\n        await event.sign(this.signer);\n        return event;\n    }\n\n    /**\n     * This method should be overriden by the user to allow or reject incoming\n     * connections.\n     */\n    public async pubkeyAllowed(\n        pubkey: string,\n        method: string,\n        params?: any\n    ): Promise<boolean> {\n        return this.permitCallback(pubkey, method, params);\n    }\n}\n"]}
{"filename": "src/signers/nip46/backend/get-public-key.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\nexport default class GetPublicKeyHandlingStrategy\n    implements IEventHandlingStrategy\n{\n    async handle(\n        backend: NDKNip46Backend,\n        remotePubkey: string,\n        params: string[]\n    ): Promise<string | undefined> {\n        return backend.localUser?.hexpubkey();\n    }\n}\n"]}
{"filename": "src/signers/nip07/index.ts", "chunked_list": ["import debug from \"debug\";\nimport type { NostrEvent } from \"../../events/index.js\";\nimport NDKUser from \"../../user/index.js\";\nimport { NDKSigner } from \"../index.js\";\n\ntype Nip04QueueItem = {\n    type: \"encrypt\" | \"decrypt\";\n    counterpartyHexpubkey: string;\n    value: string;\n    resolve: (value: string) => void;\n    reject: (reason?: Error) => void;\n};\n\n/**", " * NDKNip07Signer implements the NDKSigner interface for signing Nostr events\n * with a NIP-07 browser extension (e.g., getalby, nos2x).\n */\nexport class NDKNip07Signer implements NDKSigner {\n    private _userPromise: Promise<NDKUser> | undefined;\n    public nip04Queue: Nip04QueueItem[] = [];\n    private nip04Processing = false;\n    private debug: debug.Debugger;\n\n    public constructor() {\n        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        this.debug = debug(\"ndk:nip07\");\n    }\n\n    public async blockUntilReady(): Promise<NDKUser> {\n        const pubkey = await window.nostr?.getPublicKey();\n\n        // If the user rejects granting access, error out", "        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        this.debug = debug(\"ndk:nip07\");\n    }\n\n    public async blockUntilReady(): Promise<NDKUser> {\n        const pubkey = await window.nostr?.getPublicKey();\n\n        // If the user rejects granting access, error out", "        if (!pubkey) {\n            throw new Error(\"User rejected access\");\n        }\n\n        return new NDKUser({ hexpubkey: pubkey });\n    }\n\n    /**\n     * Getter for the user property.\n     * @returns The NDKUser instance.\n     */\n    public async user(): Promise<NDKUser> {", "        if (!this._userPromise) {\n            this._userPromise = this.blockUntilReady();\n        }\n\n        return this._userPromise;\n    }\n\n    /**\n     * Signs the given Nostr event.\n     * @param event - The Nostr event to be signed.\n     * @returns The signature of the signed event.\n     * @throws Error if the NIP-07 is not available on the window object.\n     */\n    public async sign(event: NostrEvent): Promise<string> {", "        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        const signedEvent = await window.nostr.signEvent(event);\n        return signedEvent.sig;\n    }\n\n    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        const recipientHexPubKey = recipient.hexpubkey();\n        return this.queueNip04(\"encrypt\", recipientHexPubKey, value);\n    }\n\n    public async decrypt(sender: NDKUser, value: string): Promise<string> {", "        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        const recipientHexPubKey = recipient.hexpubkey();\n        return this.queueNip04(\"encrypt\", recipientHexPubKey, value);\n    }\n\n    public async decrypt(sender: NDKUser, value: string): Promise<string> {\n        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        const senderHexPubKey = sender.hexpubkey();\n        return this.queueNip04(\"decrypt\", senderHexPubKey, value);\n    }\n\n    private async queueNip04(\n        type: \"encrypt\" | \"decrypt\",\n        counterpartyHexpubkey: string,\n        value: string\n    ): Promise<string> {\n        return new Promise((resolve, reject) => {\n            this.nip04Queue.push({\n                type,\n                counterpartyHexpubkey,\n                value,\n                resolve,\n                reject,\n            });\n", "        if (!window.nostr) {\n            throw new Error(\"NIP-07 extension not available\");\n        }\n\n        const senderHexPubKey = sender.hexpubkey();\n        return this.queueNip04(\"decrypt\", senderHexPubKey, value);\n    }\n\n    private async queueNip04(\n        type: \"encrypt\" | \"decrypt\",\n        counterpartyHexpubkey: string,\n        value: string\n    ): Promise<string> {\n        return new Promise((resolve, reject) => {\n            this.nip04Queue.push({\n                type,\n                counterpartyHexpubkey,\n                value,\n                resolve,\n                reject,\n            });\n", "            if (!this.nip04Processing) {\n                this.processNip04Queue();\n            }\n        });\n    }\n\n    private async processNip04Queue(\n        item?: Nip04QueueItem,\n        retries = 0\n    ): Promise<void> {\n        if (!item && this.nip04Queue.length === 0) {\n            this.nip04Processing = false;\n            return;\n        }\n\n        this.nip04Processing = true;\n        const { type, counterpartyHexpubkey, value, resolve, reject } =\n            item || this.nip04Queue.shift()!;\n\n        this.debug(\"Processing encryption queue item\", {\n            type,\n            counterpartyHexpubkey,\n            value,\n        });\n", "        if (!item && this.nip04Queue.length === 0) {\n            this.nip04Processing = false;\n            return;\n        }\n\n        this.nip04Processing = true;\n        const { type, counterpartyHexpubkey, value, resolve, reject } =\n            item || this.nip04Queue.shift()!;\n\n        this.debug(\"Processing encryption queue item\", {\n            type,\n            counterpartyHexpubkey,\n            value,\n        });\n", "        try {\n            let result;\n\n            if (type === \"encrypt\") {\n                result = await window.nostr!.nip04.encrypt(\n                    counterpartyHexpubkey,\n                    value\n                );\n            } else {\n                result = await window.nostr!.nip04.decrypt(\n                    counterpartyHexpubkey,\n                    value\n                );\n            }\n\n            resolve(result);", "        } catch (error: any) {\n            // retry a few times if the call is already executing\n            if (\n                error.message &&\n                error.message.includes(\"call already executing\")\n            ) {\n                if (retries < 5) {\n                    this.debug(\"Retrying encryption queue item\", {\n                        type,\n                        counterpartyHexpubkey,\n                        value,\n                        retries,\n                    });\n                    setTimeout(() => {\n                        this.processNip04Queue(item, retries + 1);\n                    }, 50 * retries);\n\n                    return;\n                }\n            }\n            reject(error);\n        }\n\n        this.processNip04Queue();\n    }\n}\n\ndeclare global {", "    interface Window {\n        nostr?: {\n            getPublicKey(): Promise<string>;\n            signEvent(event: NostrEvent): Promise<{ sig: string }>;\n            nip04: {\n                encrypt(\n                    recipientHexPubKey: string,\n                    value: string\n                ): Promise<string>;\n                decrypt(\n                    senderHexPubKey: string,\n                    value: string\n                ): Promise<string>;\n            };\n        };\n    }\n}\n"]}
{"filename": "src/signers/private-key/index.test.ts", "chunked_list": ["import { NDKUser, NostrEvent } from \"../../index.js\";\nimport { NDKPrivateKeySigner } from \"./index\";\n\ndescribe(\"NDKPrivateKeySigner\", () => {\n    it(\"generates a new NDKPrivateKeySigner instance with a private key\", () => {\n        const signer = NDKPrivateKeySigner.generate();\n        expect(signer).toBeInstanceOf(NDKPrivateKeySigner);\n        expect(signer.privateKey).toBeDefined();\n    });\n", "    });\n\n    it(\"creates a new NDKPrivateKeySigner instance with a provided private key\", () => {\n        const privateKey =\n            \"00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff\";\n        const signer = new NDKPrivateKeySigner(privateKey);\n        expect(signer).toBeInstanceOf(NDKPrivateKeySigner);\n        expect(signer.privateKey).toBe(privateKey);\n    });\n", "    });\n\n    it(\"returns a user instance with a public key corresponding to the private key\", async () => {\n        const privateKey =\n            \"e8eb7464168139c6ccb9111f768777f332fa1289dff11244ccfe89970ff776d4\";\n        const signer = new NDKPrivateKeySigner(privateKey);\n        const user = await signer.user();\n        expect(user).toBeInstanceOf(NDKUser);\n        expect(user.hexpubkey()).toBe(\n            \"07f61c41b44a923952db82e6e7bcd184b059fe087f58f9d9a918da391f38d503\"", "        expect(user.hexpubkey()).toBe(\n            \"07f61c41b44a923952db82e6e7bcd184b059fe087f58f9d9a918da391f38d503\"\n        );\n    });\n\n    it(\"signs a NostrEvent with the private key\", async () => {\n        const privateKey =\n            \"00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff\";\n        const signer = new NDKPrivateKeySigner(privateKey);\n", "        const signer = new NDKPrivateKeySigner(privateKey);\n\n        const event: NostrEvent = {\n            pubkey: \"07f61c41b44a923952db82e6e7bcd184b059fe087f58f9d9a918da391f38d503\",\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [],\n            content: \"Test content\",\n            kind: 1,\n        };\n", "        };\n\n        const signature = await signer.sign(event);\n        expect(signature).toBeDefined();\n        expect(signature.length).toBe(128);\n    });\n});\n"]}
{"filename": "src/signers/private-key/index.ts", "chunked_list": ["import type { UnsignedEvent } from \"nostr-tools\";\nimport {\n    generatePrivateKey,\n    getPublicKey,\n    nip04,\n    getSignature,\n} from \"nostr-tools\";\nimport type { NostrEvent } from \"../../events/index.js\";\nimport NDKUser from \"../../user\";\nimport { NDKSigner } from \"../index.js\";", "import NDKUser from \"../../user\";\nimport { NDKSigner } from \"../index.js\";\n\nexport class NDKPrivateKeySigner implements NDKSigner {\n    private _user: NDKUser | undefined;\n    privateKey?: string;\n\n    public constructor(privateKey?: string) {\n        if (privateKey) {\n            this.privateKey = privateKey;\n            this._user = new NDKUser({\n                hexpubkey: getPublicKey(this.privateKey),\n            });\n        }\n    }\n\n    public static generate() {\n        const privateKey = generatePrivateKey();\n        return new NDKPrivateKeySigner(privateKey);\n    }\n\n    public async blockUntilReady(): Promise<NDKUser> {", "        if (privateKey) {\n            this.privateKey = privateKey;\n            this._user = new NDKUser({\n                hexpubkey: getPublicKey(this.privateKey),\n            });\n        }\n    }\n\n    public static generate() {\n        const privateKey = generatePrivateKey();\n        return new NDKPrivateKeySigner(privateKey);\n    }\n\n    public async blockUntilReady(): Promise<NDKUser> {", "        if (!this._user) {\n            throw new Error(\"NDKUser not initialized\");\n        }\n        return this._user;\n    }\n\n    public async user(): Promise<NDKUser> {\n        await this.blockUntilReady();\n        return this._user as NDKUser;\n    }\n\n    public async sign(event: NostrEvent): Promise<string> {", "        if (!this.privateKey) {\n            throw Error(\"Attempted to sign without a private key\");\n        }\n\n        return getSignature(event as UnsignedEvent, this.privateKey);\n    }\n\n    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n        if (!this.privateKey) {\n            throw Error(\"Attempted to encrypt without a private key\");\n        }\n\n        const recipientHexPubKey = recipient.hexpubkey();\n        return await nip04.encrypt(this.privateKey, recipientHexPubKey, value);\n    }\n\n    public async decrypt(sender: NDKUser, value: string): Promise<string> {", "        if (!this.privateKey) {\n            throw Error(\"Attempted to encrypt without a private key\");\n        }\n\n        const recipientHexPubKey = recipient.hexpubkey();\n        return await nip04.encrypt(this.privateKey, recipientHexPubKey, value);\n    }\n\n    public async decrypt(sender: NDKUser, value: string): Promise<string> {\n        if (!this.privateKey) {\n            throw Error(\"Attempted to decrypt without a private key\");\n        }\n\n        const senderHexPubKey = sender.hexpubkey();\n        return await nip04.decrypt(this.privateKey, senderHexPubKey, value);\n    }\n}\n", "        if (!this.privateKey) {\n            throw Error(\"Attempted to decrypt without a private key\");\n        }\n\n        const senderHexPubKey = sender.hexpubkey();\n        return await nip04.decrypt(this.privateKey, senderHexPubKey, value);\n    }\n}\n"]}
{"filename": "src/events/nip19.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\nimport NDKEvent from \".\";\n\nexport function encode(this: NDKEvent) {\n    if (this.isParamReplaceable()) {\n        return nip19.naddrEncode({\n            kind: this.kind as number,\n            pubkey: this.pubkey,\n            identifier: this.replaceableDTag(),\n            relays: this.relay ? [this.relay.url] : [],\n        });", "    } else if (this.relay) {\n        return nip19.neventEncode({\n            id: this.tagId(),\n            relays: [this.relay.url],\n            author: this.pubkey,\n        });\n    } else {\n        return nip19.noteEncode(this.tagId());\n    }\n}\n"]}
{"filename": "src/events/kind.ts", "chunked_list": ["import NDKEvent from \"./index.js\";\n\nexport function isReplaceable(this: NDKEvent): boolean {\n    if (this.kind === undefined) throw new Error(\"Kind not set\");\n    return this.kind >= 10000 && this.kind < 20000;\n}\n\nexport function isEphemeral(this: NDKEvent): boolean {\n    if (this.kind === undefined) throw new Error(\"Kind not set\");\n    return this.kind >= 20000 && this.kind < 30000;\n}\n", "    if (this.kind === undefined) throw new Error(\"Kind not set\");\n    return this.kind >= 20000 && this.kind < 30000;\n}\n\nexport function isParamReplaceable(this: NDKEvent): boolean {\n    if (this.kind === undefined) throw new Error(\"Kind not set\");\n    return this.kind >= 30000 && this.kind < 40000;\n}\n"]}
{"filename": "src/events/nip04.ts", "chunked_list": ["import NDKEvent from \".\";\nimport { NDKSigner } from \"../signers\";\nimport NDKUser from \"../user\";\n\nexport async function encrypt(\n    this: NDKEvent,\n    recipient?: NDKUser,\n    signer?: NDKSigner\n) {\n    if (!signer) {\n        if (!this.ndk) {\n            throw new Error(\"No signer available\");\n        }\n\n        await this.ndk.assertSigner();\n\n        signer = this.ndk.signer!;\n    }\n", "    if (!signer) {\n        if (!this.ndk) {\n            throw new Error(\"No signer available\");\n        }\n\n        await this.ndk.assertSigner();\n\n        signer = this.ndk.signer!;\n    }\n\n    if (!recipient) {\n        const pTags = this.getMatchingTags(\"p\");\n", "    if (!recipient) {\n        const pTags = this.getMatchingTags(\"p\");\n\n        if (pTags.length !== 1) {\n            throw new Error(\n                \"No recipient could be determined and no explicit recipient was provided\"\n            );\n        }\n\n        recipient = new NDKUser({ hexpubkey: pTags[0][1] });\n        recipient.ndk = this.ndk;\n    }\n\n    this.content = await signer.encrypt(recipient, this.content);\n}\n", "export async function decrypt(\n    this: NDKEvent,\n    sender?: NDKUser,\n    signer?: NDKSigner\n) {\n    if (!signer) {\n        if (!this.ndk) {\n            throw new Error(\"No signer available\");\n        }\n\n        await this.ndk.assertSigner();\n\n        signer = this.ndk.signer!;\n    }\n", "    if (!sender) {\n        sender = this.author;\n    }\n\n    this.content = await signer.decrypt(sender, this.content);\n}\n"]}
{"filename": "src/events/content-tagger.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\nimport { EventPointer, ProfilePointer } from \"nostr-tools/lib/nip19\";\nimport { NDKTag } from \"./index.js\";\n\nexport function generateContentTags(\n    content: string,\n    tags: NDKTag[] = []\n): { content: string; tags: NDKTag[] } {\n    const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent)[a-zA-Z0-9]+/g;\n\n    content = content.replace(tagRegex, (tag) => {", "        try {\n            const entity = tag.split(/(@|nostr:)/)[2];\n            const { type, data } = nip19.decode(entity);\n            let t: NDKTag;\n\n            switch (type) {\n                case \"npub\":\n                    t = [\"p\", data as string];\n                    break;\n                case \"nprofile\":\n                    t = [\"p\", (data as ProfilePointer).pubkey as string];\n                    break;\n                case \"nevent\":\n                    t = [\"e\", (data as EventPointer).id as string];\n                    break;\n                case \"note\":\n                    t = [\"e\", data as string];\n                    break;\n                default:\n                    return tag;\n            }\n", "            if (!tags.find((t2) => t2[0] === t[0] && t2[1] === t[1])) {\n                tags.push(t);\n            }\n\n            return `nostr:${entity}`;\n        } catch (error) {\n            return tag;\n        }\n    });\n\n    return { content, tags };\n}\n"]}
{"filename": "src/events/index.test.ts", "chunked_list": ["import NDK, { NDKEvent, NDKSubscription, NDKUser, NostrEvent } from \"../index\";\n\ndescribe(\"NDKEvent\", () => {\n    let ndk: NDK;\n    let event: NDKEvent;\n    let user1: NDKUser;\n    let user2: NDKUser;\n\n    beforeEach(() => {\n        ndk = new NDK();", "    beforeEach(() => {\n        ndk = new NDK();\n        user1 = new NDKUser({\n            npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n        });\n        user2 = new NDKUser({\n            npub: \"npub12262qa4uhw7u8gdwlgmntqtv7aye8vdcmvszkqwgs0zchel6mz7s6cgrkj\",\n        });\n        event = new NDKEvent(ndk);\n        event.author = user1;", "        event = new NDKEvent(ndk);\n        event.author = user1;\n    });\n\n    describe(\"deduplicationKey\", () => {\n        it(\"returns <kind>:<pubkey> for kinds 0\", () => {\n            event.kind = 0;\n            const result = event.deduplicationKey();\n            expect(result).toEqual(`0:${user1.hexpubkey()}`);\n        });", "            expect(result).toEqual(`0:${user1.hexpubkey()}`);\n        });\n\n        it(\"returns <kind>:<pubkey> for kinds 3\", () => {\n            event.kind = 3;\n            const result = event.deduplicationKey();\n            expect(result).toEqual(`3:${user1.hexpubkey()}`);\n        });\n\n        it(\"returns tagId for other kinds\", () => {", "\n        it(\"returns tagId for other kinds\", () => {\n            event.kind = 2;\n            const spy = jest.spyOn(event, \"tagId\").mockReturnValue(\"mockTagId\");\n            const result = event.deduplicationKey();\n            expect(result).toEqual(\"mockTagId\");\n            expect(spy).toHaveBeenCalled();\n            spy.mockRestore();\n        });\n", "        });\n\n        it(\"returns parameterized tagId for kinds between 30k and 40k\", () => {\n            event.kind = 35000;\n            const spy = jest\n                .spyOn(event, \"tagId\")\n                .mockReturnValue(\"parameterizedTagId\");\n            const result = event.deduplicationKey();\n            expect(result).toEqual(\"parameterizedTagId\");\n            expect(spy).toHaveBeenCalled();", "            expect(result).toEqual(\"parameterizedTagId\");\n            expect(spy).toHaveBeenCalled();\n            spy.mockRestore();\n        });\n    });\n\n    describe(\"tag\", () => {\n        it(\"tags a user without a marker\", () => {\n            event.tag(user2);\n            expect(event.tags).toEqual([[\"p\", user2.hexpubkey()]]);", "            event.tag(user2);\n            expect(event.tags).toEqual([[\"p\", user2.hexpubkey()]]);\n        });\n\n        it(\"tags a user with a marker\", () => {\n            event.tag(user2, \"author\");\n            expect(event.tags).toEqual([[\"p\", user2.hexpubkey(), \"author\"]]);\n        });\n\n        it(\"tags an event without a marker\", () => {", "\n        it(\"tags an event without a marker\", () => {\n            const otherEvent = new NDKEvent(ndk, {\n                id: \"123\",\n                kind: 1,\n            } as NostrEvent);\n            otherEvent.author = user1;\n\n            event.tag(otherEvent);\n            expect(event.tags).toEqual([[\"e\", otherEvent.id]]);", "            event.tag(otherEvent);\n            expect(event.tags).toEqual([[\"e\", otherEvent.id]]);\n        });\n\n        it(\"tags an event with a marker\", () => {\n            const otherEvent = new NDKEvent(ndk, {\n                id: \"123\",\n                kind: 1,\n            } as NostrEvent);\n            otherEvent.author = user1;", "            } as NostrEvent);\n            otherEvent.author = user1;\n            event.tag(otherEvent, \"marker\");\n            expect(event.tags).toEqual([[\"e\", otherEvent.id, \"marker\"]]);\n        });\n\n        it(\"tags an event author when it's different from the signing user\", () => {\n            const otherEvent = new NDKEvent(ndk, { kind: 1 } as NostrEvent);\n            otherEvent.author = user2;\n            event.tag(otherEvent);", "            otherEvent.author = user2;\n            event.tag(otherEvent);\n            expect(event.tags).toEqual([\n                [\"e\", otherEvent.id],\n                [\"p\", user2.hexpubkey()],\n            ]);\n        });\n\n        it(\"does not tag an event author when it's the same as the signing user\", () => {\n            const otherEvent = new NDKEvent(ndk, { kind: 1 } as NostrEvent);", "        it(\"does not tag an event author when it's the same as the signing user\", () => {\n            const otherEvent = new NDKEvent(ndk, { kind: 1 } as NostrEvent);\n            otherEvent.author = user1;\n            event.tag(otherEvent);\n            expect(event.tags).toEqual([[\"e\", otherEvent.id]]);\n        });\n    });\n\n    describe(\"fetchEvents\", () => {\n        it(\"correctly handles a relay sending old replaced events\", async () => {", "    describe(\"fetchEvents\", () => {\n        it(\"correctly handles a relay sending old replaced events\", async () => {\n            const eventData = {\n                kind: 300001,\n                tags: [[\"d\", \"\"]],\n                content: \"\",\n                pubkey: \"\",\n            };\n            const event1 = new NDKEvent(ndk, {\n                ...eventData,", "            const event1 = new NDKEvent(ndk, {\n                ...eventData,\n                created_at: Date.now() / 1000 - 3600,\n            });\n            const event2 = new NDKEvent(ndk, {\n                ...eventData,\n                created_at: Date.now() / 1000,\n            });\n\n            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {", "\n            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n                const sub = new NDKSubscription(ndk, filter, opts);\n\n                setTimeout(() => {\n                    sub.emit(\"event\", event1);\n                    sub.emit(\"event\", event2);\n                    sub.emit(\"eose\");\n                }, 100);\n", "                }, 100);\n\n                return sub;\n            });\n\n            const events = await ndk.fetchEvents({ kinds: [30001 as number] });\n\n            expect(events.size).toBe(1);\n            const dedupedEvent = events.values().next().value;\n", "            const dedupedEvent = events.values().next().value;\n\n            expect(dedupedEvent).toEqual(event2);\n        });\n    });\n\n    describe(\"toNostrEvent\", () => {\n        it(\"returns a NostrEvent object\", async () => {\n            const nostrEvent = await event.toNostrEvent();\n            expect(nostrEvent).toHaveProperty(\"created_at\");", "            const nostrEvent = await event.toNostrEvent();\n            expect(nostrEvent).toHaveProperty(\"created_at\");\n            expect(nostrEvent).toHaveProperty(\"content\");\n            expect(nostrEvent).toHaveProperty(\"tags\");\n            expect(nostrEvent).toHaveProperty(\"kind\");\n            expect(nostrEvent).toHaveProperty(\"pubkey\");\n            expect(nostrEvent).toHaveProperty(\"id\");\n        });\n\n        describe(\"mentions\", () => {", "\n        describe(\"mentions\", () => {\n            it(\"handles NIP-27 mentions\", async () => {\n                event.content =\n                    \"hello nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft!\";\n                const nostrEvent = await event.toNostrEvent();\n                const mentionTag = nostrEvent.tags.find(\n                    (t) =>\n                        t[0] === \"p\" &&\n                        t[1] ===", "                        t[0] === \"p\" &&\n                        t[1] ===\n                            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\"\n                );\n                expect(mentionTag).toBeTruthy();\n            });\n        });\n    });\n\n    describe(\"tagReference\", () => {", "\n    describe(\"tagReference\", () => {\n        it(\"returns the correct tag for referencing the event\", () => {\n            const event1 = new NDKEvent(ndk, {\n                created_at: Date.now() / 1000,\n                content: \"\",\n                kind: 30000,\n                pubkey: \"pubkey\",\n                tags: [[\"d\", \"d-code\"]],\n            });", "                tags: [[\"d\", \"d-code\"]],\n            });\n\n            const event2 = new NDKEvent(ndk, {\n                created_at: Date.now() / 1000,\n                content: \"\",\n                tags: [],\n                kind: 1,\n                pubkey: \"pubkey\",\n                id: \"eventid\",", "                pubkey: \"pubkey\",\n                id: \"eventid\",\n            });\n\n            expect(event1.tagReference()).toEqual([\"a\", \"30000:pubkey:d-code\"]);\n            expect(event2.tagReference()).toEqual([\"e\", \"eventid\"]);\n        });\n    });\n});\n", "});\n"]}
{"filename": "src/events/repost.ts", "chunked_list": ["import { NDKSigner } from \"../signers/index.js\";\nimport NDKEvent, { NostrEvent } from \"./index.js\";\nimport { NDKKind } from \"./kinds/index.js\";\n\n/**\n * NIP-18 reposting event.\n *\n * @param publish Whether to publish the reposted event automatically\n * @param signer The signer to use for signing the reposted event\n * @returns The reposted event", " * @param signer The signer to use for signing the reposted event\n * @returns The reposted event\n */\nexport async function repost(\n    this: NDKEvent,\n    publish = true,\n    signer?: NDKSigner\n) {\n    if (!signer) {\n        if (!this.ndk) throw new Error(\"No NDK instance found\");\n        this.ndk.assertSigner();\n        signer = this.ndk.signer;\n    }\n", "    if (!signer) {\n        if (!this.ndk) throw new Error(\"No NDK instance found\");\n        this.ndk.assertSigner();\n        signer = this.ndk.signer;\n    }\n\n    if (!signer) {\n        throw new Error(\"No signer available\");\n    }\n\n    const user = await signer.user();\n\n    const e = new NDKEvent(this.ndk, {\n        kind: getKind(this),\n        content: \"\",\n        pubkey: user.hexpubkey(),\n    } as NostrEvent);\n    e.tag(this);\n", "    if (e.kind === NDKKind.GenericRepost) {\n        e.tags.push([\"k\", `${this.kind}`]);\n    }\n\n    await e.sign(signer);\n    if (publish) await e.publish();\n\n    return e;\n}\n\nfunction getKind(event: NDKEvent): NDKKind {", "function getKind(event: NDKEvent): NDKKind {\n    if (event.kind === 1) {\n        return NDKKind.Repost;\n    }\n\n    return NDKKind.GenericRepost;\n}\n"]}
{"filename": "src/events/nip19.test.ts", "chunked_list": ["import NDK, { NDKEvent, NDKRelay, NostrEvent } from \"../index\";\n\nlet ndk: NDK;\n\nbeforeAll(() => {\n    ndk = new NDK();\n});\n\ndescribe(\"NDKEvent\", () => {\n    describe(\"encode\", () => {", "describe(\"NDKEvent\", () => {\n    describe(\"encode\", () => {\n        it(\"encodes NIP-33 events\", () => {\n            const event = new NDKEvent(ndk, {\n                kind: 30000,\n                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n                tags: [[\"d\", \"1234\"]],\n            } as NostrEvent);\n\n            const a = event.encode();", "\n            const a = event.encode();\n            expect(a).toBe(\n                \"naddr1qqzrzv3nxspzp75cf0tahv5z7plpdeaws7ex52nmnwgtwfr2g3m37r844evqrr6jqvzqqqr4xq098d2k\"\n            );\n        });\n\n        it(\"encodes NIP-33 events with relay when it's known\", () => {\n            const event = new NDKEvent(ndk, {\n                kind: 30000,", "            const event = new NDKEvent(ndk, {\n                kind: 30000,\n                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n                tags: [[\"d\", \"1234\"]],\n            } as NostrEvent);\n            event.relay = new NDKRelay(\"wss://relay.f7z.io\");\n\n            const a = event.encode();\n            expect(a).toBe(\n                \"naddr1qqzrzv3nxsq3yamnwvaz7tmjv4kxz7fwvcmh5tnfdupzp75cf0tahv5z7plpdeaws7ex52nmnwgtwfr2g3m37r844evqrr6jqvzqqqr4xq45f5n4\"", "            expect(a).toBe(\n                \"naddr1qqzrzv3nxsq3yamnwvaz7tmjv4kxz7fwvcmh5tnfdupzp75cf0tahv5z7plpdeaws7ex52nmnwgtwfr2g3m37r844evqrr6jqvzqqqr4xq45f5n4\"\n            );\n        });\n\n        it(\"encodes events as notes when the relay is known\", () => {\n            const event = new NDKEvent(ndk, {\n                kind: 1,\n                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n                tags: [[\"d\", \"1234\"]],", "                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n                tags: [[\"d\", \"1234\"]],\n            } as NostrEvent);\n            event.relay = new NDKRelay(\"wss://relay.f7z.io\");\n\n            const a = event.encode();\n            expect(a).toBe(\n                \"nevent1qqqqzynhwden5te0wfjkccte9enrw73wd9hsyg86np9a0kajstc8u9h846rmy6320wdepdeydfz8w8cv7kh9sqv02gyxar4d\"\n            );\n        });", "            );\n        });\n    });\n});\n"]}
{"filename": "src/events/index.ts", "chunked_list": ["import EventEmitter from \"eventemitter3\";\nimport { getEventHash, UnsignedEvent } from \"nostr-tools\";\nimport NDK, { NDKFilter, NDKRelay, NDKRelaySet, NDKUser } from \"../index.js\";\nimport { NDKSigner } from \"../signers/index.js\";\nimport Zap from \"../zap/index.js\";\nimport { generateContentTags } from \"./content-tagger.js\";\nimport { isParamReplaceable, isReplaceable } from \"./kind.js\";\nimport { NDKKind } from \"./kinds/index.js\";\nimport { decrypt, encrypt } from \"./nip04.js\";\nimport { encode } from \"./nip19.js\";", "import { decrypt, encrypt } from \"./nip04.js\";\nimport { encode } from \"./nip19.js\";\nimport { repost } from \"./repost.js\";\n\nexport type NDKEventId = string;\nexport type NDKTag = string[];\n\nexport type NostrEvent = {\n    created_at: number;\n    content: string;\n    tags: NDKTag[];\n    kind?: NDKKind | number;\n    pubkey: string;\n    id?: string;\n    sig?: string;\n};\n", "export type ContentTag = {\n    tags: NDKTag[];\n    content: string;\n};\n\n/**\n * NDKEvent is the basic building block of NDK; most things\n * you do with NDK will revolve around writing or consuming NDKEvents.\n */\nexport default class NDKEvent extends EventEmitter {\n    public ndk?: NDK;\n    public created_at?: number;\n    public content = \"\";\n    public tags: NDKTag[] = [];\n    public kind?: NDKKind | number;\n    public id = \"\";\n    public sig?: string;\n    public pubkey = \"\";\n\n    /**\n     * The relay that this event was first received from.\n     */\n    public relay: NDKRelay | undefined;\n\n    constructor(ndk?: NDK, event?: NostrEvent) {\n        super();\n        this.ndk = ndk;\n        this.created_at = event?.created_at;\n        this.content = event?.content || \"\";\n        this.tags = event?.tags || [];\n        this.id = event?.id || \"\";\n        this.sig = event?.sig;\n        this.pubkey = event?.pubkey || \"\";\n        this.kind = event?.kind;\n    }\n\n    /**\n     * Returns the event as is.\n     */\n    public rawEvent(): NostrEvent {\n        return {\n            created_at: this.created_at,\n            content: this.content,\n            tags: this.tags,\n            kind: this.kind,\n            pubkey: this.pubkey,\n            id: this.id,\n            sig: this.sig,\n        } as NostrEvent;\n    }\n\n    set author(user: NDKUser) {\n        this.pubkey = user.hexpubkey();\n    }\n\n    /**\n     * Returns an NDKUser for the author of the event.\n     */\n    get author(): NDKUser {\n        const user = new NDKUser({ hexpubkey: this.pubkey });\n        user.ndk = this.ndk;\n        return user;\n    }\n\n    /**\n     * Tag a user with an optional marker.\n     * @param user The user to tag.\n     * @param marker The marker to use in the tag.\n     */\n    public tag(user: NDKUser, marker?: string): void;\n\n    /**\n     * Tag a user with an optional marker.\n     * @param event The event to tag.\n     * @param marker The marker to use in the tag.\n     * @example\n     * ```typescript\n     * reply.tag(opEvent, \"reply\");\n     * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n     * ```\n     */\n    public tag(event: NDKEvent, marker?: string): void;\n    public tag(userOrEvent: NDKUser | NDKEvent, marker?: string): void {\n        const tag = userOrEvent.tagReference();", "export default class NDKEvent extends EventEmitter {\n    public ndk?: NDK;\n    public created_at?: number;\n    public content = \"\";\n    public tags: NDKTag[] = [];\n    public kind?: NDKKind | number;\n    public id = \"\";\n    public sig?: string;\n    public pubkey = \"\";\n\n    /**\n     * The relay that this event was first received from.\n     */\n    public relay: NDKRelay | undefined;\n\n    constructor(ndk?: NDK, event?: NostrEvent) {\n        super();\n        this.ndk = ndk;\n        this.created_at = event?.created_at;\n        this.content = event?.content || \"\";\n        this.tags = event?.tags || [];\n        this.id = event?.id || \"\";\n        this.sig = event?.sig;\n        this.pubkey = event?.pubkey || \"\";\n        this.kind = event?.kind;\n    }\n\n    /**\n     * Returns the event as is.\n     */\n    public rawEvent(): NostrEvent {\n        return {\n            created_at: this.created_at,\n            content: this.content,\n            tags: this.tags,\n            kind: this.kind,\n            pubkey: this.pubkey,\n            id: this.id,\n            sig: this.sig,\n        } as NostrEvent;\n    }\n\n    set author(user: NDKUser) {\n        this.pubkey = user.hexpubkey();\n    }\n\n    /**\n     * Returns an NDKUser for the author of the event.\n     */\n    get author(): NDKUser {\n        const user = new NDKUser({ hexpubkey: this.pubkey });\n        user.ndk = this.ndk;\n        return user;\n    }\n\n    /**\n     * Tag a user with an optional marker.\n     * @param user The user to tag.\n     * @param marker The marker to use in the tag.\n     */\n    public tag(user: NDKUser, marker?: string): void;\n\n    /**\n     * Tag a user with an optional marker.\n     * @param event The event to tag.\n     * @param marker The marker to use in the tag.\n     * @example\n     * ```typescript\n     * reply.tag(opEvent, \"reply\");\n     * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n     * ```\n     */\n    public tag(event: NDKEvent, marker?: string): void;\n    public tag(userOrEvent: NDKUser | NDKEvent, marker?: string): void {\n        const tag = userOrEvent.tagReference();", "        if (marker) tag.push(marker);\n        this.tags.push(tag);\n\n        if (userOrEvent instanceof NDKEvent) {\n            const tagEventAuthor = userOrEvent.author;\n\n            // If event author is not the same as the user signing this event, tag the author\n            if (tagEventAuthor && this.pubkey !== tagEventAuthor.hexpubkey()) {\n                this.tag(tagEventAuthor);\n            }\n\n            // tag p-tags in the event if they are not the same as the user signing this event", "            for (const pTag of userOrEvent.getMatchingTags(\"p\")) {\n                if (pTag[1] === this.pubkey) continue;\n                if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1]))\n                    continue;\n\n                this.tags.push([\"p\", pTag[1]]);\n            }\n        }\n    }\n\n    /**\n     * Return a NostrEvent object, trying to fill in missing fields\n     * when possible, adding tags when necessary.\n     * @param pubkey {string} The pubkey of the user who the event belongs to.\n     * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n     */\n    async toNostrEvent(pubkey?: string): Promise<NostrEvent> {", "        if (!pubkey && this.pubkey === \"\") {\n            const user = await this.ndk?.signer?.user();\n            this.pubkey = user?.hexpubkey() || \"\";\n        }\n\n        if (!this.created_at) this.created_at = Math.floor(Date.now() / 1000);\n\n        const nostrEvent = this.rawEvent();\n        const { content, tags } = this.generateTags();\n        nostrEvent.content = content || \"\";\n        nostrEvent.tags = tags;\n", "        try {\n            this.id = getEventHash(nostrEvent as UnsignedEvent);\n            // eslint-disable-next-line no-empty\n        } catch (e) {}\n\n        if (this.id) nostrEvent.id = this.id;\n        if (this.sig) nostrEvent.sig = this.sig;\n\n        return nostrEvent;\n    }\n\n    public isReplaceable = isReplaceable.bind(this);\n    public isParamReplaceable = isParamReplaceable.bind(this);\n\n    /**\n     * Encodes a bech32 id.\n     *\n     * @returns {string} - Encoded naddr, note or nevent.\n     */\n    public encode = encode.bind(this);\n    public encrypt = encrypt.bind(this);\n    public decrypt = decrypt.bind(this);\n\n    /**\n     * Get all tags with the given name\n     * @param tagName {string} The name of the tag to search for\n     * @returns {NDKTag[]} An array of the matching tags\n     */\n    public getMatchingTags(tagName: string): NDKTag[] {\n        return this.tags.filter((tag) => tag[0] === tagName);\n    }\n\n    /**\n     * Get the first tag with the given name\n     * @param tagName Tag name to search for\n     * @returns The value of the first tag with the given name, or undefined if no such tag exists\n     */\n    public tagValue(tagName: string): string | undefined {\n        const tags = this.getMatchingTags(tagName);", "        if (tags.length === 0) return undefined;\n        return tags[0][1];\n    }\n\n    /**\n     * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n     * @param tagName Tag name to search for and remove\n     * @returns {void}\n     */\n    public removeTag(tagName: string): void {\n        this.tags = this.tags.filter((tag) => tag[0] !== tagName);\n    }\n\n    /**\n     * Sign the event if a signer is present.\n     *\n     * It will generate tags.\n     * Repleacable events will have their created_at field set to the current time.\n     * @param signer {NDKSigner} The NDKSigner to use to sign the event\n     * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n     */\n    public async sign(signer?: NDKSigner): Promise<string> {", "        if (!signer) {\n            this.ndk?.assertSigner();\n\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            signer = this.ndk!.signer!;\n        }\n\n        await this.generateTags();\n\n        if (this.isReplaceable()) {\n            this.created_at = Math.floor(Date.now() / 1000);\n        }\n\n        const nostrEvent = await this.toNostrEvent();\n\n        this.sig = await signer.sign(nostrEvent);\n\n        return this.sig;\n    }\n\n    /**\n     * Attempt to sign and then publish an NDKEvent to a given relaySet.\n     * If no relaySet is provided, the relaySet will be calculated by NDK.\n     * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n     * @returns A promise that resolves to the relays the event was published to.\n     */\n    public async publish(\n        relaySet?: NDKRelaySet,\n        timeoutMs?: number\n    ): Promise<Set<NDKRelay>> {", "        if (this.isReplaceable()) {\n            this.created_at = Math.floor(Date.now() / 1000);\n        }\n\n        const nostrEvent = await this.toNostrEvent();\n\n        this.sig = await signer.sign(nostrEvent);\n\n        return this.sig;\n    }\n\n    /**\n     * Attempt to sign and then publish an NDKEvent to a given relaySet.\n     * If no relaySet is provided, the relaySet will be calculated by NDK.\n     * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n     * @returns A promise that resolves to the relays the event was published to.\n     */\n    public async publish(\n        relaySet?: NDKRelaySet,\n        timeoutMs?: number\n    ): Promise<Set<NDKRelay>> {", "        if (!this.sig) await this.sign();\n        if (!this.ndk)\n            throw new Error(\n                \"NDKEvent must be associated with an NDK instance to publish\"\n            );\n\n        return this.ndk.publish(this, relaySet, timeoutMs);\n    }\n\n    /**\n     * Generates tags for users, notes, and other events tagged in content.\n     * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n     * @returns {ContentTag} The tags and content of the event.\n     */\n    protected generateTags(): ContentTag {\n        let tags: NDKTag[] = [];\n\n        // don't autogenerate if there currently are tags\n        const g = generateContentTags(this.content, this.tags);\n        const content = g.content;\n        tags = g.tags;\n\n        // if this is a parameterized replaceable event, check if there's a d tag, if not, generate it", "        if (this.kind && this.kind >= 30000 && this.kind <= 40000) {\n            const dTag = this.getMatchingTags(\"d\")[0];\n            // generate a string of 32 random bytes\n            if (!dTag) {\n                const str = [...Array(16)]\n                    .map(() => Math.random().toString(36)[2])\n                    .join(\"\");\n                tags.push([\"d\", str]);\n            }\n        }\n\n        return { content: content || \"\", tags };\n    }\n\n    /**\n     * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n     * a parameterized replaceable event.\n     * @returns {string} the \"d\" tag of the event.\n     */\n    replaceableDTag() {", "        if (this.kind && this.kind >= 30000 && this.kind <= 40000) {\n            const dTag = this.getMatchingTags(\"d\")[0];\n            const dTagId = dTag ? dTag[1] : \"\";\n\n            return dTagId;\n        }\n\n        throw new Error(\"Event is not a parameterized replaceable event\");\n    }\n\n    /**\n     * Provides a deduplication key for the event.\n     *\n     * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n     * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n     * For all other kinds this will be the event id\n     */\n    deduplicationKey(): string {", "        if (this.kind === 0 || this.kind === 3) {\n            return `${this.kind}:${this.pubkey}`;\n        } else {\n            return this.tagId();\n        }\n    }\n\n    /**\n     * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n     * @returns {string} The id\n     */\n    tagId(): string {\n        // NIP-33", "        if (this.kind && this.kind >= 30000 && this.kind <= 40000) {\n            const dTagId = this.replaceableDTag();\n\n            return `${this.kind}:${this.pubkey}:${dTagId}`;\n        }\n\n        return this.id;\n    }\n\n    /**\n     * Get the tag that can be used to reference this event from another event\n     * @example\n     *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n     *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n     *\n     *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n     *     event.tagReference(); // [\"e\", \"eventid\"]\n     * @returns {NDKTag} The NDKTag object referencing this event\n     */\n    tagReference(): NDKTag {\n        // NIP-33", "        if (this.isParamReplaceable()) {\n            return [\"a\", this.tagId()];\n        }\n\n        return [\"e\", this.tagId()];\n    }\n\n    /**\n     * Provides the filter that will return matching events for this event.\n     *\n     * @example\n     *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n     *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n     * @example\n     *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n     *    event.filter(); // { \"#e\": [\"eventid\"] }\n     *\n     * @returns The filter that will return matching events for this event\n     */\n    filter(): NDKFilter {", "        if (this.isParamReplaceable()) {\n            return { \"#a\": [this.tagId()] };\n        } else {\n            return { \"#e\": [this.tagId()] };\n        }\n    }\n\n    /**\n     * Create a zap request for an existing event\n     *\n     * @param amount The amount to zap in millisatoshis\n     * @param comment A comment to add to the zap request\n     * @param extraTags Extra tags to add to the zap request\n     */\n    async zap(\n        amount: number,\n        comment?: string,\n        extraTags?: NDKTag[]\n    ): Promise<string | null> {", "        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\n        this.ndk.assertSigner();\n\n        const zap = new Zap({\n            ndk: this.ndk,\n            zappedEvent: this,\n        });\n\n        const paymentRequest = await zap.createZapRequest(\n            amount,\n            comment,\n            extraTags\n        );\n\n        // await zap.publish(amount);\n        return paymentRequest;\n    }\n\n    /**\n     * Generates a deletion event of the current event\n     *\n     * @param reason The reason for the deletion\n     * @returns The deletion event\n     */\n    async delete(reason?: string): Promise<NDKEvent> {", "        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\n        this.ndk.assertSigner();\n\n        const e = new NDKEvent(this.ndk, {\n            kind: NDKKind.EventDeletion,\n            content: reason || \"\",\n        } as NostrEvent);\n        e.tag(this);\n        await e.publish();\n\n        return e;\n    }\n\n    /**\n     * NIP-18 reposting event.\n     *\n     * @param publish Whether to publish the reposted event automatically\n     * @param signer The signer to use for signing the reposted event\n     * @returns The reposted event\n     *\n     * @function\n     */\n    public repost = repost.bind(this);\n}\n"]}
{"filename": "src/events/dedup.ts", "chunked_list": ["import { NDKEvent } from \"../index.js\";\n\n/**\n * Receives two events and returns the \"correct\" event to use.\n * #nip-33\n */\nexport default function dedup(event1: NDKEvent, event2: NDKEvent) {\n    // return the newest of the two\n    if (event1.created_at! > event2.created_at!) {\n        return event1;\n    }\n\n    return event2;\n}\n", "    if (event1.created_at! > event2.created_at!) {\n        return event1;\n    }\n\n    return event2;\n}\n"]}
{"filename": "src/events/content-tagger.test.ts", "chunked_list": ["import { generateContentTags } from \"./content-tagger\";\nimport { NDKTag } from \"./index.js\";\n\ndescribe(\"generateContentTags\", () => {\n    it(\"should replace valid tags and store decoded data in the tags array\", () => {\n        const content =\n            \"This is a sample content with @npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and @note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\";\n        const tags: NDKTag[] = [];\n\n        const { content: processedContent, tags: processedTags } =", "\n        const { content: processedContent, tags: processedTags } =\n            generateContentTags(content, tags);\n\n        expect(processedContent).toEqual(\n            \"This is a sample content with nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and nostr:note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\"\n        );\n        expect(processedTags.length).toEqual(2);\n        expect(processedTags).toEqual([\n            [", "        expect(processedTags).toEqual([\n            [\n                \"p\",\n                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n            ],\n            [\n                \"e\",\n                \"6ab77c8baf6d0542131cc70b59ba3ece904fd58efe91d612dc3e870bdaf93034\",\n            ],\n        ]);", "            ],\n        ]);\n    });\n\n    it(\"should not replace invalid tags and leave the tags array unchanged\", () => {\n        const content = \"This is a sample content with an @invalidTag.\";\n        const tags: NDKTag[] = [];\n\n        const { content: processedContent, tags: processedTags } =\n            generateContentTags(content, tags);", "        const { content: processedContent, tags: processedTags } =\n            generateContentTags(content, tags);\n\n        expect(processedContent).toEqual(content);\n        expect(processedTags.length).toEqual(0);\n    });\n\n    it(\"should handle existing tags and update indexes accordingly\", () => {\n        const content =\n            \"This is a sample content with @npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and @note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\";", "        const content =\n            \"This is a sample content with @npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and @note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\";\n        const tags: NDKTag[] = [[\"p\", \"existing_p\"]];\n\n        const { content: processedContent, tags: processedTags } =\n            generateContentTags(content, tags);\n\n        expect(processedContent).toEqual(\n            \"This is a sample content with nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and nostr:note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\"\n        );", "            \"This is a sample content with nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and nostr:note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\"\n        );\n        expect(processedTags.length).toEqual(3);\n        expect(processedTags).toEqual([\n            [\"p\", \"existing_p\"],\n            [\n                \"p\",\n                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n            ],\n            [", "            ],\n            [\n                \"e\",\n                \"6ab77c8baf6d0542131cc70b59ba3ece904fd58efe91d612dc3e870bdaf93034\",\n            ],\n        ]);\n    });\n\n    it(\"does not replace an event without a nostr: or @ prefix\", async () => {\n        const content =", "    it(\"does not replace an event without a nostr: or @ prefix\", async () => {\n        const content =\n            \"note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur \" +\n            \"@note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur\";\n\n        const { content: processedContent, tags: processedTags } =\n            generateContentTags(content, []);\n\n        expect(processedContent).toEqual(\n            \"note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur \" +", "        expect(processedContent).toEqual(\n            \"note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur \" +\n                \"nostr:note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur\"\n        );\n        expect(processedTags).toEqual([\n            [\n                \"e\",\n                \"8c9093d06a21a5b738e9d21d907334444e7ea12258c21da333e0fc265cf92a8b\",\n            ],\n        ]);", "            ],\n        ]);\n    });\n});\n"]}
{"filename": "src/events/kinds/article.ts", "chunked_list": ["import NDK from \"../../index.js\";\nimport { ContentTag, type NostrEvent } from \"../index.js\";\nimport NDKEvent from \"../index.js\";\nimport { NDKKind } from \"./index.js\";\n\n/**\n * Represents a NIP-23 article.\n */\nexport class NDKArticle extends NDKEvent {\n    constructor(ndk: NDK | undefined, rawEvent?: NostrEvent) {\n        super(ndk, rawEvent);\n        this.kind = NDKKind.Article;\n    }\n\n    /**\n     * Creates a NDKArticle from an existing NDKEvent.\n     *\n     * @param event NDKEVent to create the NDKArticle from.\n     * @returns NDKArticle\n     */\n    static from(event: NDKEvent) {\n        return new NDKArticle(event.ndk, event.rawEvent());\n    }\n\n    /**\n     * Getter for the article title.\n     *\n     * @returns {string | undefined} - The article title if available, otherwise undefined.\n     */\n    get title(): string | undefined {\n        return this.tagValue(\"title\");\n    }\n\n    /**\n     * Setter for the article title.\n     *\n     * @param {string | undefined} title - The title to set for the article.\n     */\n    set title(title: string | undefined) {\n        this.removeTag(\"title\");\n", "export class NDKArticle extends NDKEvent {\n    constructor(ndk: NDK | undefined, rawEvent?: NostrEvent) {\n        super(ndk, rawEvent);\n        this.kind = NDKKind.Article;\n    }\n\n    /**\n     * Creates a NDKArticle from an existing NDKEvent.\n     *\n     * @param event NDKEVent to create the NDKArticle from.\n     * @returns NDKArticle\n     */\n    static from(event: NDKEvent) {\n        return new NDKArticle(event.ndk, event.rawEvent());\n    }\n\n    /**\n     * Getter for the article title.\n     *\n     * @returns {string | undefined} - The article title if available, otherwise undefined.\n     */\n    get title(): string | undefined {\n        return this.tagValue(\"title\");\n    }\n\n    /**\n     * Setter for the article title.\n     *\n     * @param {string | undefined} title - The title to set for the article.\n     */\n    set title(title: string | undefined) {\n        this.removeTag(\"title\");\n", "        if (title) this.tags.push([\"title\", title]);\n    }\n\n    /**\n     * Getter for the article image.\n     *\n     * @returns {string | undefined} - The article image if available, otherwise undefined.\n     */\n    get image(): string | undefined {\n        return this.tagValue(\"image\");\n    }\n\n    /**\n     * Setter for the article image.\n     *\n     * @param {string | undefined} image - The image to set for the article.\n     */\n    set image(image: string | undefined) {\n        this.removeTag(\"image\");\n", "        if (image) this.tags.push([\"image\", image]);\n    }\n\n    /**\n     * Getter for the article's publication timestamp.\n     *\n     * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n     */\n    get published_at(): number | undefined {\n        const tag = this.tagValue(\"published_at\");\n        if (tag) {\n            return parseInt(tag);\n        }\n        return undefined;\n    }\n\n    /**\n     * Setter for the article's publication timestamp.\n     *\n     * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n     */\n    set published_at(timestamp: number | undefined) {\n        this.removeTag(\"published_at\"); // Removes any existing \"published_at\" tag.\n", "        if (tag) {\n            return parseInt(tag);\n        }\n        return undefined;\n    }\n\n    /**\n     * Setter for the article's publication timestamp.\n     *\n     * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n     */\n    set published_at(timestamp: number | undefined) {\n        this.removeTag(\"published_at\"); // Removes any existing \"published_at\" tag.\n", "        if (timestamp !== undefined) {\n            this.tags.push([\"published_at\", timestamp.toString()]);\n        }\n    }\n\n    /**\n     * Generates content tags for the article.\n     *\n     * This method first checks and sets the publication date if not available,\n     * and then generates content tags based on the base NDKEvent class.\n     *\n     * @returns {ContentTag} - The generated content tags.\n     */\n    protected generateTags(): ContentTag {\n        super.generateTags();\n", "        if (!this.published_at) {\n            this.published_at = this.created_at;\n        }\n\n        return super.generateTags();\n    }\n\n    /**\n     * Getter for the article's URL.\n     *\n     * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n     */\n    get url(): string | undefined {\n        return this.tagValue(\"url\");\n    }\n\n    /**\n     * Setter for the article's URL.\n     *\n     * @param {string | undefined} url - The URL to set for the article.\n     */\n    set url(url: string | undefined) {", "        if (url) {\n            this.tags.push([\"url\", url]);\n        } else {\n            this.removeTag(\"url\");\n        }\n    }\n}\n"]}
{"filename": "src/events/kinds/repost.ts", "chunked_list": ["import NDK, { NDKFilter } from \"../../index.js\";\nimport { NDKSubscriptionOptions } from \"../../subscription/index.js\";\nimport NDKEvent, { NDKTag, NostrEvent } from \"../index.js\";\n\ntype classWithConvertFunction<T> = {\n    from: (event: NDKEvent) => T;\n};\n\n/**\n * Handles NIP-18 reposts.\n */", "export class NDKRepost<T> extends NDKEvent {\n    private _repostedEvents: T[] | undefined;\n\n    constructor(ndk?: NDK, rawEvent?: NostrEvent) {\n        super(ndk, rawEvent);\n    }\n\n    static from(event: NDKEvent) {\n        return new NDKRepost(event.ndk, event.rawEvent());\n    }\n\n    /**\n     * Returns all reposted events by the current event.\n     *", "     * @param klass Optional class to convert the events to.\n     * @returns\n     */\n    async repostedEvents(\n        klass?: classWithConvertFunction<T>,\n        opts?: NDKSubscriptionOptions\n    ): Promise<T[]> {\n        const items: T[] = [];\n\n        if (!this.ndk) throw new Error(\"NDK instance not set\");\n", "        if (!this.ndk) throw new Error(\"NDK instance not set\");\n\n        if (this._repostedEvents !== undefined) return this._repostedEvents;\n\n        for (const eventId of this.repostedEventIds()) {\n            const filter = filterForId(eventId);\n            const event = await this.ndk.fetchEvent(filter, opts);\n\n            if (event) {\n                items.push(klass ? klass.from(event) : (event as T));\n            }\n        }\n\n        return items;\n    }\n\n    /**\n     * Returns the reposted event IDs.\n     */\n    repostedEventIds(): string[] {\n        return this.tags\n            .filter((t: NDKTag) => t[0] === \"e\" || t[0] === \"a\")\n            .map((t: NDKTag) => t[1]);\n    }\n}\n", "            if (event) {\n                items.push(klass ? klass.from(event) : (event as T));\n            }\n        }\n\n        return items;\n    }\n\n    /**\n     * Returns the reposted event IDs.\n     */\n    repostedEventIds(): string[] {\n        return this.tags\n            .filter((t: NDKTag) => t[0] === \"e\" || t[0] === \"a\")\n            .map((t: NDKTag) => t[1]);\n    }\n}\n", "function filterForId(id: string): NDKFilter {\n    if (id.match(/:/)) {\n        const [kind, pubkey, identifier] = id.split(\":\");\n        return {\n            kinds: [parseInt(kind)],\n            authors: [pubkey],\n            \"#d\": [identifier],\n        };\n    } else {\n        return { ids: [id] };\n    }\n}\n"]}
{"filename": "src/events/kinds/index.ts", "chunked_list": ["export enum NDKKind {\n    Metadata = 0,\n    Text = 1,\n    RecommendRelay = 2,\n    Contacts = 3,\n    EncryptedDirectMessage = 4,\n    EventDeletion = 5,\n    Repost = 6,\n    Reaction = 7,\n    BadgeAward = 8,\n    GenericRepost = 16,\n    ChannelCreation = 40,\n    ChannelMetadata = 41,\n    ChannelMessage = 42,\n    ChannelHideMessage = 43,\n    ChannelMuteUser = 44,\n    Report = 1984,\n    ZapRequest = 9734,\n    Zap = 9735,\n    Highlight = 9802,\n    MuteList = 10000,\n    PinList = 10001,\n    RelayList = 10002,\n    ClientAuth = 22242,\n    NostrConnect = 24133,\n    CategorizedPeopleList = 30000,\n    CategorizedBookmarkList = 30001,\n    CategorizedRelayList = 30022,\n    ProfileBadge = 30008,\n    BadgeDefinition = 30009,\n    MarketStall = 30017,\n    MarketProduct = 30018,\n    Article = 30023,\n    AppSpecificData = 30078,\n    CategorizedHighlightList = 39802,\n\n    // NIP-90: Data Vending Machines\n    DVMJobFeedback = 65000,\n    DVMJobResult = 65001,\n    DVMJobRequestTranscription = 65002,\n}\n"]}
{"filename": "src/events/kinds/lists/index.ts", "chunked_list": ["import NDK, { NDKKind, NDKRelay, NDKUser } from \"../../../index.js\";\nimport NDKEvent from \"../../index.js\";\nimport { NDKTag, NostrEvent } from \"../../index.js\";\n\nexport type NDKListItem = NDKRelay | NDKUser | NDKEvent;\n\n/**\n * Represents any NIP-33 list kind.\n *\n * This class provides some helper methods to manage the list, particularly\n * a CRUD interface to list items.\n *\n * List items can be encrypted or not. Encrypted items are JSON-encoded and\n * self-signed by the user's key.\n *\n * @example Adding an event to the list.\n * const event1 = new NDKEvent(...);\n * const list = new NDKList();\n * list.addItem(event1);\n *\n * @example Adding an encrypted `p` tag to the list with a \"person\" mark.\n * const secretFollow = new NDKUser(...);\n * list.addItem(secretFollow, 'person', true);\n *\n * @emits NDKList#change\n */", " * This class provides some helper methods to manage the list, particularly\n * a CRUD interface to list items.\n *\n * List items can be encrypted or not. Encrypted items are JSON-encoded and\n * self-signed by the user's key.\n *\n * @example Adding an event to the list.\n * const event1 = new NDKEvent(...);\n * const list = new NDKList();\n * list.addItem(event1);\n *\n * @example Adding an encrypted `p` tag to the list with a \"person\" mark.\n * const secretFollow = new NDKUser(...);\n * list.addItem(secretFollow, 'person', true);\n *\n * @emits NDKList#change\n */", "export class NDKList extends NDKEvent {\n    public _encryptedTags: NDKTag[] | undefined;\n\n    /**\n     * Stores the number of bytes the content was before decryption\n     * to expire the cache when the content changes.\n     */\n    private encryptedTagsLength: number | undefined;\n\n    constructor(ndk?: NDK, rawEvent?: NostrEvent) {\n        super(ndk, rawEvent);", "        if (!this.kind) this.kind = NDKKind.CategorizedBookmarkList;\n    }\n\n    /**\n     * Wrap a NDKEvent into a NDKList\n     */\n    static from(ndkEvent: NDKEvent): NDKList {\n        return new NDKList(ndkEvent.ndk, ndkEvent.rawEvent());\n    }\n\n    /**\n     * Returns the name of the list.\n     */\n    get name(): string | undefined {\n        return this.tagValue(\"name\") ?? this.tagValue(\"d\");\n    }\n\n    /**\n     * Sets the name of the list.\n     */\n    set name(name: string | undefined) {\n        this.removeTag(\"name\");\n", "        if (name) {\n            this.tags.push([\"name\", name]);\n        } else {\n            throw new Error(\"Name cannot be empty\");\n        }\n    }\n\n    /**\n     * Returns the description of the list.\n     */\n    get description(): string | undefined {\n        return this.tagValue(\"description\");\n    }\n\n    /**\n     * Sets the description of the list.\n     */\n    set description(name: string | undefined) {", "        if (name) {\n            this.tags.push([\"description\", name]);\n        } else {\n            this.removeTag(\"description\");\n        }\n    }\n\n    private isEncryptedTagsCacheValid(): boolean {\n        return !!(\n            this._encryptedTags &&\n            this.encryptedTagsLength === this.content.length\n        );\n    }\n\n    /**\n     * Returns the decrypted content of the list.\n     */\n    async encryptedTags(useCache = true): Promise<NDKTag[]> {", "        if (useCache && this.isEncryptedTagsCacheValid())\n            return this._encryptedTags!;\n\n        if (!this.ndk) throw new Error(\"NDK instance not set\");\n        if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n\n        const user = await this.ndk.signer.user();\n\n        try {\n            if (this.content.length > 0) {\n                try {\n                    const decryptedContent = await this.ndk.signer.decrypt(\n                        user,\n                        this.content\n                    );\n                    const a = JSON.parse(decryptedContent);", "        try {\n            if (this.content.length > 0) {\n                try {\n                    const decryptedContent = await this.ndk.signer.decrypt(\n                        user,\n                        this.content\n                    );\n                    const a = JSON.parse(decryptedContent);\n                    if (a && a[0]) {\n                        this.encryptedTagsLength = this.content.length;\n                        return (this._encryptedTags = a);\n                    }\n                    this.encryptedTagsLength = this.content.length;\n                    return (this._encryptedTags = []);", "                    if (a && a[0]) {\n                        this.encryptedTagsLength = this.content.length;\n                        return (this._encryptedTags = a);\n                    }\n                    this.encryptedTagsLength = this.content.length;\n                    return (this._encryptedTags = []);\n                } catch (e) {\n                    console.log(`error decrypting ${this.content}`);\n                }\n            }\n        } catch (e) {\n            // console.trace(e);\n            // throw e;\n        }\n\n        return [];\n    }\n\n    /**\n     * This method can be overriden to validate that a tag is valid for this list.\n     *\n     * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n     */\n    public validateTag(tagValue: string): boolean | string {\n        return true;\n    }\n\n    /**\n     * Returns the unecrypted items in this list.\n     */\n    get items(): NDKTag[] {\n        return this.tags.filter((t) => {\n            return ![\"d\", \"name\", \"description\"].includes(t[0]);\n        });\n    }\n\n    /**\n     * Adds a new item to the list.\n     * @param relay Relay to add\n     * @param mark Optional mark to add to the item\n     * @param encrypted Whether to encrypt the item\n     */\n    async addItem(\n        item: NDKListItem | NDKTag,\n        mark: string | undefined = undefined,\n        encrypted = false\n    ): Promise<void> {", "        } catch (e) {\n            // console.trace(e);\n            // throw e;\n        }\n\n        return [];\n    }\n\n    /**\n     * This method can be overriden to validate that a tag is valid for this list.\n     *\n     * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n     */\n    public validateTag(tagValue: string): boolean | string {\n        return true;\n    }\n\n    /**\n     * Returns the unecrypted items in this list.\n     */\n    get items(): NDKTag[] {\n        return this.tags.filter((t) => {\n            return ![\"d\", \"name\", \"description\"].includes(t[0]);\n        });\n    }\n\n    /**\n     * Adds a new item to the list.\n     * @param relay Relay to add\n     * @param mark Optional mark to add to the item\n     * @param encrypted Whether to encrypt the item\n     */\n    async addItem(\n        item: NDKListItem | NDKTag,\n        mark: string | undefined = undefined,\n        encrypted = false\n    ): Promise<void> {", "        if (!this.ndk) throw new Error(\"NDK instance not set\");\n        if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n\n        let tag;\n\n        if (item instanceof NDKEvent) {\n            tag = item.tagReference();\n        } else if (item instanceof NDKUser) {\n            tag = item.tagReference();\n        } else if (item instanceof NDKRelay) {\n            tag = item.tagReference();", "        } else if (item instanceof NDKRelay) {\n            tag = item.tagReference();\n        } else if (Array.isArray(item)) {\n            // NDKTag\n            tag = item;\n        } else {\n            throw new Error(\"Invalid object type\");\n        }\n\n        if (mark) tag.push(mark);\n", "        if (mark) tag.push(mark);\n\n        if (encrypted) {\n            const user = await this.ndk.signer.user();\n            const currentList = await this.encryptedTags();\n\n            currentList.push(tag);\n\n            this._encryptedTags = currentList;\n            this.encryptedTagsLength = this.content.length;\n            this.content = JSON.stringify(currentList);\n            await this.encrypt(user);\n        } else {\n            this.tags.push(tag);\n        }\n\n        this.created_at = Math.floor(Date.now() / 1000);\n\n        this.emit(\"change\");\n    }\n\n    /**\n     * Removes an item from the list.\n     *\n     * @param index The index of the item to remove.\n     * @param encrypted Whether to remove from the encrypted list or not.\n     */\n    async removeItem(index: number, encrypted: boolean): Promise<NDKList> {", "        if (!this.ndk) throw new Error(\"NDK instance not set\");\n        if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n\n        if (encrypted) {\n            const user = await this.ndk.signer.user();\n            const currentList = await this.encryptedTags();\n\n            currentList.splice(index, 1);\n            this._encryptedTags = currentList;\n            this.encryptedTagsLength = this.content.length;\n            this.content = JSON.stringify(currentList);\n            await this.encrypt(user);\n        } else {\n            this.tags.splice(index, 1);\n        }\n\n        this.created_at = Math.floor(Date.now() / 1000);\n\n        this.emit(\"change\");\n\n        return this;\n    }\n}\n\nexport default NDKList;\n"]}
{"filename": "src/events/kinds/dvm/NDKDVMRequest.ts", "chunked_list": ["import NDK, { NDKDVMJobResult, NDKEvent, NostrEvent } from \"../../../index.js\";\n\n/**\n * NIP-90: Data vending machine\n *\n * A generic Job request class for Data Vending Machines\n */\nexport class NDKDVMRequest extends NDKEvent {\n    constructor(ndk: NDK | undefined, event?: NostrEvent) {\n        super(ndk, event);\n", "        if (ndk) {\n            this.tags.push([\"relays\", ...ndk.pool.urls()]);\n        }\n    }\n\n    static from(event: NDKEvent) {\n        return new NDKDVMRequest(event.ndk, event.rawEvent());\n    }\n\n    /**\n     * Create a new result event for this request\n     */\n    public createResult(data?: NostrEvent) {\n        const event = new NDKDVMJobResult(this.ndk, data);\n        event.jobRequest = this;\n\n        return event;\n    }\n\n    set bid(msatAmount: number | undefined) {", "        if (msatAmount === undefined) {\n            this.removeTag(\"bid\");\n        } else {\n            this.tags.push([\"bid\", msatAmount.toString()]);\n        }\n    }\n\n    get bid(): number | undefined {\n        const v = this.tagValue(\"bid\");\n\n        if (v === undefined) return undefined;\n\n        return parseInt(v);\n    }\n\n    /**\n     * Adds a new input to the job\n     * @param args The arguments to the input\n     */\n    addInput(...args: string[]): void {\n        this.tags.push([\"i\", ...args]);\n    }\n\n    /**\n     * Adds a new parameter to the job\n     */\n    addParam(...args: string[]): void {\n        this.tags.push([\"param\", ...args]);\n    }\n\n    set output(output: string | string[] | undefined) {", "        if (v === undefined) return undefined;\n\n        return parseInt(v);\n    }\n\n    /**\n     * Adds a new input to the job\n     * @param args The arguments to the input\n     */\n    addInput(...args: string[]): void {\n        this.tags.push([\"i\", ...args]);\n    }\n\n    /**\n     * Adds a new parameter to the job\n     */\n    addParam(...args: string[]): void {\n        this.tags.push([\"param\", ...args]);\n    }\n\n    set output(output: string | string[] | undefined) {", "        if (output === undefined) {\n            this.removeTag(\"output\");\n        } else {\n            if (typeof output === \"string\") output = [output];\n            this.tags.push([\"output\", ...output]);\n        }\n    }\n\n    get output(): string[] | undefined {\n        const outputTag = this.getMatchingTags(\"output\")[0];\n        return outputTag ? outputTag.slice(1) : undefined;\n    }\n}\n"]}
{"filename": "src/events/kinds/dvm/NDKDVMJobResult.ts", "chunked_list": ["import NDK from \"../../../index.js\";\nimport NDKEvent, { NostrEvent } from \"../../index.js\";\nimport { NDKKind } from \"../index.js\";\n\n/**\n * This event is published by Data Vending Machines when\n * they have finished processing a job.\n */\nexport class NDKDVMJobResult extends NDKEvent {\n    constructor(ndk?: NDK, event?: NostrEvent) {\n        super(ndk, event);\n        this.kind = NDKKind.DVMJobResult;\n    }\n\n    static from(event: NDKEvent) {\n        return new NDKDVMJobResult(event.ndk, event.rawEvent());\n    }\n\n    set result(result: string | undefined) {", "export class NDKDVMJobResult extends NDKEvent {\n    constructor(ndk?: NDK, event?: NostrEvent) {\n        super(ndk, event);\n        this.kind = NDKKind.DVMJobResult;\n    }\n\n    static from(event: NDKEvent) {\n        return new NDKDVMJobResult(event.ndk, event.rawEvent());\n    }\n\n    set result(result: string | undefined) {", "        if (result === undefined) {\n            this.content = \"\";\n        } else {\n            this.content = result;\n        }\n    }\n\n    get result(): string | undefined {\n        if (this.content === \"\") {\n            return undefined;\n        }\n\n        return this.content;\n    }\n\n    set status(status: string | undefined) {\n        this.removeTag(\"status\");\n", "        if (this.content === \"\") {\n            return undefined;\n        }\n\n        return this.content;\n    }\n\n    set status(status: string | undefined) {\n        this.removeTag(\"status\");\n\n        if (status !== undefined) {\n            this.tags.push([\"status\", status]);\n        }\n    }\n\n    get status(): string | undefined {\n        return this.tagValue(\"status\");\n    }\n\n    set jobRequest(event: NDKEvent | undefined) {\n        this.removeTag(\"request\");\n", "        if (status !== undefined) {\n            this.tags.push([\"status\", status]);\n        }\n    }\n\n    get status(): string | undefined {\n        return this.tagValue(\"status\");\n    }\n\n    set jobRequest(event: NDKEvent | undefined) {\n        this.removeTag(\"request\");\n", "        if (event) {\n            this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n            this.tag(event);\n        }\n    }\n\n    get jobRequest(): NDKEvent | undefined {\n        const tag = this.tagValue(\"request\");\n\n        if (tag === undefined) {\n            return undefined;\n        }\n\n        return new NDKEvent(this.ndk, JSON.parse(tag));\n    }\n}\n", "        if (tag === undefined) {\n            return undefined;\n        }\n\n        return new NDKEvent(this.ndk, JSON.parse(tag));\n    }\n}\n"]}
{"filename": "src/events/kinds/dvm/index.ts", "chunked_list": ["export * from \"./NDKDVMRequest\";\nexport * from \"./NDKTranscriptionDVM\";\nexport * from \"./NDKDVMJobResult\";\n"]}
{"filename": "src/events/kinds/dvm/NDKTranscriptionDVM.ts", "chunked_list": ["import { NDKKind } from \"..\";\nimport NDKEvent, { NostrEvent } from \"../..\";\nimport NDK from \"../../..\";\nimport { NDKDVMRequest } from \"./NDKDVMRequest\";\n\n/**\n * NIP-90\n *\n * This class creates DVM transcription job types\n */\nexport class NDKTranscriptionDVM extends NDKDVMRequest {\n    constructor(ndk: NDK | undefined, event?: NostrEvent) {\n        super(ndk, event);\n        this.kind = NDKKind.DVMJobRequestTranscription;\n    }\n\n    static from(event: NDKEvent) {\n        return new NDKTranscriptionDVM(event.ndk, event.rawEvent());\n    }\n\n    /**\n     * Returns the original source of the transcription\n     */\n    get url(): string | undefined {\n        const inputTags = this.getMatchingTags(\"i\");\n", " * This class creates DVM transcription job types\n */\nexport class NDKTranscriptionDVM extends NDKDVMRequest {\n    constructor(ndk: NDK | undefined, event?: NostrEvent) {\n        super(ndk, event);\n        this.kind = NDKKind.DVMJobRequestTranscription;\n    }\n\n    static from(event: NDKEvent) {\n        return new NDKTranscriptionDVM(event.ndk, event.rawEvent());\n    }\n\n    /**\n     * Returns the original source of the transcription\n     */\n    get url(): string | undefined {\n        const inputTags = this.getMatchingTags(\"i\");\n", "        if (inputTags.length !== 1) {\n            return undefined;\n        }\n\n        return inputTags[0][1];\n    }\n\n    /**\n     * Getter for the title tag\n     */\n    get title(): string | undefined {\n        return this.tagValue(\"title\");\n    }\n\n    /**\n     * Setter for the title tag\n     */\n    set title(value: string | undefined) {\n        this.removeTag(\"title\");\n", "        if (value) {\n            this.tags.push([\"title\", value]);\n        }\n    }\n\n    /**\n     * Getter for the image tag\n     */\n    get image(): string | undefined {\n        return this.tagValue(\"image\");\n    }\n\n    /**\n     * Setter for the image tag\n     */\n    set image(value: string | undefined) {\n        this.removeTag(\"image\");\n", "        if (value) {\n            this.tags.push([\"image\", value]);\n        }\n    }\n}\n"]}
{"filename": "src/relay/score.ts", "chunked_list": ["// TODO this will probably get more sophisticated\nexport type NDKRelayScore = number;\n"]}
{"filename": "src/relay/index.ts", "chunked_list": ["import debug from \"debug\";\nimport EventEmitter from \"eventemitter3\";\nimport { Relay, relayInit, Sub } from \"nostr-tools\";\nimport \"websocket-polyfill\";\nimport NDKEvent, { NDKTag, NostrEvent } from \"../events/index.js\";\nimport { NDKSubscription } from \"../subscription/index.js\";\nimport User from \"../user/index.js\";\nimport { NDKRelayScore } from \"./score.js\";\n\nexport enum NDKRelayStatus {\n    CONNECTING,\n    CONNECTED,\n    DISCONNECTING,\n    DISCONNECTED,\n    RECONNECTING,\n    FLAPPING,\n}\n", "\nexport enum NDKRelayStatus {\n    CONNECTING,\n    CONNECTED,\n    DISCONNECTING,\n    DISCONNECTED,\n    RECONNECTING,\n    FLAPPING,\n}\n\nexport interface NDKRelayConnectionStats {\n    /**\n     * The number of times a connection has been attempted.\n     */\n    attempts: number;\n\n    /**\n     * The number of times a connection has been successfully established.\n     */\n    success: number;\n\n    /**\n     * The durations of the last 100 connections in milliseconds.\n     */\n    durations: number[];\n\n    /**\n     * The time the current connection was established in milliseconds.\n     */\n    connectedAt?: number;\n}\n\n/**", "export interface NDKRelayConnectionStats {\n    /**\n     * The number of times a connection has been attempted.\n     */\n    attempts: number;\n\n    /**\n     * The number of times a connection has been successfully established.\n     */\n    success: number;\n\n    /**\n     * The durations of the last 100 connections in milliseconds.\n     */\n    durations: number[];\n\n    /**\n     * The time the current connection was established in milliseconds.\n     */\n    connectedAt?: number;\n}\n\n/**", " * The NDKRelay class represents a connection to a relay.\n *\n * @emits NDKRelay#connect\n * @emits NDKRelay#disconnect\n * @emits NDKRelay#notice\n * @emits NDKRelay#event\n * @emits NDKRelay#published when an event is published to the relay\n * @emits NDKRelay#publish:failed when an event fails to publish to the relay\n * @emits NDKRelay#eose\n */\nexport class NDKRelay extends EventEmitter {\n    readonly url: string;\n    readonly scores: Map<User, NDKRelayScore>;\n    private relay: Relay;\n    private _status: NDKRelayStatus;\n    private connectedAt?: number;\n    private _connectionStats: NDKRelayConnectionStats = {\n        attempts: 0,\n        success: 0,\n        durations: [],\n    };\n    public complaining = false;\n    private debug: debug.Debugger;\n\n    /**\n     * Active subscriptions this relay is connected to\n     */\n    public activeSubscriptions = new Set<NDKSubscription>();\n\n    public constructor(url: string) {\n        super();\n        this.url = url;\n        this.relay = relayInit(url);\n        this.scores = new Map<User, NDKRelayScore>();\n        this._status = NDKRelayStatus.DISCONNECTED;\n        this.debug = debug(`ndk:relay:${url}`);\n\n        this.relay.on(\"connect\", () => {\n            this.updateConnectionStats.connected();\n            this._status = NDKRelayStatus.CONNECTED;\n            this.emit(\"connect\");\n        });\n\n        this.relay.on(\"disconnect\", () => {\n            this.updateConnectionStats.disconnected();\n", "export class NDKRelay extends EventEmitter {\n    readonly url: string;\n    readonly scores: Map<User, NDKRelayScore>;\n    private relay: Relay;\n    private _status: NDKRelayStatus;\n    private connectedAt?: number;\n    private _connectionStats: NDKRelayConnectionStats = {\n        attempts: 0,\n        success: 0,\n        durations: [],\n    };\n    public complaining = false;\n    private debug: debug.Debugger;\n\n    /**\n     * Active subscriptions this relay is connected to\n     */\n    public activeSubscriptions = new Set<NDKSubscription>();\n\n    public constructor(url: string) {\n        super();\n        this.url = url;\n        this.relay = relayInit(url);\n        this.scores = new Map<User, NDKRelayScore>();\n        this._status = NDKRelayStatus.DISCONNECTED;\n        this.debug = debug(`ndk:relay:${url}`);\n\n        this.relay.on(\"connect\", () => {\n            this.updateConnectionStats.connected();\n            this._status = NDKRelayStatus.CONNECTED;\n            this.emit(\"connect\");\n        });\n\n        this.relay.on(\"disconnect\", () => {\n            this.updateConnectionStats.disconnected();\n", "            if (this._status === NDKRelayStatus.CONNECTED) {\n                this._status = NDKRelayStatus.DISCONNECTED;\n\n                this.handleReconnection();\n            }\n            this.emit(\"disconnect\");\n        });\n\n        this.relay.on(\"notice\", (notice: string) => this.handleNotice(notice));\n    }\n\n    /**\n     * Evaluates the connection stats to determine if the relay is flapping.\n     */\n    private isFlapping(): boolean {\n        const durations = this._connectionStats.durations;", "        if (durations.length < 10) return false;\n\n        const sum = durations.reduce((a, b) => a + b, 0);\n        const avg = sum / durations.length;\n        const variance =\n            durations\n                .map((x) => Math.pow(x - avg, 2))\n                .reduce((a, b) => a + b, 0) / durations.length;\n        const stdDev = Math.sqrt(variance);\n        const isFlapping = stdDev < 1000;\n\n        return isFlapping;\n    }\n\n    /**\n     * Called when the relay is unexpectedly disconnected.\n     */\n    private handleReconnection() {", "        if (this.isFlapping()) {\n            this.emit(\"flapping\", this, this._connectionStats);\n            this._status = NDKRelayStatus.FLAPPING;\n        }\n\n        if (this.connectedAt && Date.now() - this.connectedAt < 5000) {\n            setTimeout(() => this.connect(), 60000);\n        } else {\n            this.connect();\n        }\n    }\n\n    get status(): NDKRelayStatus {\n        return this._status;\n    }\n\n    /**\n     * Connects to the relay.\n     */\n    public async connect(): Promise<void> {", "        try {\n            this.updateConnectionStats.attempt();\n            this._status = NDKRelayStatus.CONNECTING;\n            await this.relay.connect();\n        } catch (e) {\n            this.debug(\"Failed to connect\", e);\n            this._status = NDKRelayStatus.DISCONNECTED;\n            throw e;\n        }\n    }\n\n    /**\n     * Disconnects from the relay.\n     */\n    public disconnect(): void {\n        this._status = NDKRelayStatus.DISCONNECTING;\n        this.relay.close();\n    }\n\n    async handleNotice(notice: string) {\n        // This is a prototype; if the relay seems to be complaining\n        // remove it from relay set selection for a minute.", "        if (notice.includes(\"oo many\") || notice.includes(\"aximum\")) {\n            this.disconnect();\n\n            // fixme\n            setTimeout(() => this.connect(), 2000);\n            this.debug(this.relay.url, \"Relay complaining?\", notice);\n            // this.complaining = true;\n            // setTimeout(() => {\n            //     this.complaining = false;\n            //     console.log(this.relay.url, 'Reactivate relay');\n            // }, 60000);\n        }\n\n        this.emit(\"notice\", this, notice);\n    }\n\n    /**\n     * Subscribes to a subscription.\n     */\n    public subscribe(subscription: NDKSubscription): Sub {\n        const { filters } = subscription;\n\n        const sub = this.relay.sub(filters, {\n            id: subscription.subId,\n        });\n        this.debug(`Subscribed to ${JSON.stringify(filters)}`);\n\n        sub.on(\"event\", (event: NostrEvent) => {\n            const e = new NDKEvent(undefined, event);\n            e.relay = this;\n            subscription.eventReceived(e, this);\n        });\n\n        sub.on(\"eose\", () => {\n            subscription.eoseReceived(this);\n        });\n\n        const unsub = sub.unsub;\n        sub.unsub = () => {\n            this.debug(`Unsubscribing from ${JSON.stringify(filters)}`);\n            this.activeSubscriptions.delete(subscription);\n            unsub();\n        };\n\n        this.activeSubscriptions.add(subscription);\n        subscription.on(\"close\", () => {\n            this.activeSubscriptions.delete(subscription);\n        });\n\n        return sub;\n    }\n\n    /**\n     * Publishes an event to the relay with an optional timeout.\n     *\n     * If the relay is not connected, the event will be published when the relay connects,\n     * unless the timeout is reached before the relay connects.\n     *\n     * @param event The event to publish\n     * @param timeoutMs The timeout for the publish operation in milliseconds\n     * @returns A promise that resolves when the event has been published or rejects if the operation times out\n     */\n    public async publish(event: NDKEvent, timeoutMs = 2500): Promise<boolean> {", "        if (this.status === NDKRelayStatus.CONNECTED) {\n            return this.publishEvent(event, timeoutMs);\n        } else {\n            this.once(\"connect\", () => {\n                this.publishEvent(event, timeoutMs);\n            });\n            return true;\n        }\n    }\n\n    private async publishEvent(\n        event: NDKEvent,\n        timeoutMs?: number\n    ): Promise<boolean> {\n        const nostrEvent = await event.toNostrEvent();\n        const publish = this.relay.publish(nostrEvent as any);\n        let publishTimeout: NodeJS.Timeout | number;\n\n        const publishPromise = new Promise<boolean>((resolve, reject) => {\n            publish\n                .then(() => {\n                    clearTimeout(publishTimeout as unknown as NodeJS.Timeout);\n                    this.emit(\"published\", event);\n                    resolve(true);\n                })", "                .catch((err) => {\n                    clearTimeout(publishTimeout as NodeJS.Timeout);\n                    this.debug(\"Publish failed\", err, event.id);\n                    this.emit(\"publish:failed\", event, err);\n                    reject(err);\n                });\n        });\n\n        // If no timeout is specified, just return the publish promise\n        if (!timeoutMs) {\n            return publishPromise;\n        }\n\n        // Create a promise that rejects after timeoutMs milliseconds\n        const timeoutPromise = new Promise<boolean>((_, reject) => {\n            publishTimeout = setTimeout(() => {\n                this.debug(\"Publish timed out\", event.rawEvent());\n                this.emit(\"publish:failed\", event, \"Timeout\");\n                reject(new Error(\"Publish operation timed out\"));\n            }, timeoutMs);\n        });\n\n        // wait for either the publish operation to complete or the timeout to occur\n        return Promise.race([publishPromise, timeoutPromise]);\n    }\n\n    /**\n     * Called when this relay has responded with an event but\n     * wasn't the fastest one.\n     * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public scoreSlowerEvent(timeDiffInMs: number): void {\n        // TODO\n    }\n\n    /**\n     * Utility functions to update the connection stats.\n     */\n    private updateConnectionStats = {\n        connected: () => {\n            this._connectionStats.success++;\n            this._connectionStats.connectedAt = Date.now();\n        },\n\n        disconnected: () => {", "        if (!timeoutMs) {\n            return publishPromise;\n        }\n\n        // Create a promise that rejects after timeoutMs milliseconds\n        const timeoutPromise = new Promise<boolean>((_, reject) => {\n            publishTimeout = setTimeout(() => {\n                this.debug(\"Publish timed out\", event.rawEvent());\n                this.emit(\"publish:failed\", event, \"Timeout\");\n                reject(new Error(\"Publish operation timed out\"));\n            }, timeoutMs);\n        });\n\n        // wait for either the publish operation to complete or the timeout to occur\n        return Promise.race([publishPromise, timeoutPromise]);\n    }\n\n    /**\n     * Called when this relay has responded with an event but\n     * wasn't the fastest one.\n     * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public scoreSlowerEvent(timeDiffInMs: number): void {\n        // TODO\n    }\n\n    /**\n     * Utility functions to update the connection stats.\n     */\n    private updateConnectionStats = {\n        connected: () => {\n            this._connectionStats.success++;\n            this._connectionStats.connectedAt = Date.now();\n        },\n\n        disconnected: () => {", "            if (this._connectionStats.connectedAt) {\n                this._connectionStats.durations.push(\n                    Date.now() - this._connectionStats.connectedAt\n                );\n\n                if (this._connectionStats.durations.length > 100) {\n                    this._connectionStats.durations.shift();\n                }\n            }\n            this._connectionStats.connectedAt = undefined;\n        },\n\n        attempt: () => {\n            this._connectionStats.attempts++;\n        },\n    };\n\n    /**\n     * Returns the connection stats.\n     */\n    get connectionStats(): NDKRelayConnectionStats {\n        return this._connectionStats;\n    }\n\n    public tagReference(marker?: string): NDKTag {\n        const tag = [\"r\", this.relay.url];\n", "        if (marker) {\n            tag.push(marker);\n        }\n\n        return tag;\n    }\n}\n"]}
{"filename": "src/relay/pool/index.ts", "chunked_list": ["import debug from \"debug\";\nimport EventEmitter from \"eventemitter3\";\nimport NDK from \"../../index.js\";\nimport { NDKRelay, NDKRelayStatus } from \"../index.js\";\n\nexport type NDKPoolStats = {\n    total: number;\n    connected: number;\n    disconnected: number;\n    connecting: number;\n};\n\n/**\n * Handles connections to all relays. A single pool should be used per NDK instance.\n *\n * @emit connect - Emitted when all relays in the pool are connected, or when the specified timeout has elapsed, and some relays are connected.\n * @emit notice - Emitted when a relay in the pool sends a notice.\n * @emit flapping - Emitted when a relay in the pool is flapping.\n * @emit relay:connect - Emitted when a relay in the pool connects.\n * @emit relay:disconnect - Emitted when a relay in the pool disconnects.\n */", "export class NDKPool extends EventEmitter {\n    public relays = new Map<string, NDKRelay>();\n    private debug: debug.Debugger;\n    private temporaryRelayTimers = new Map<string, NodeJS.Timeout>();\n\n    public constructor(relayUrls: string[] = [], ndk: NDK) {\n        super();\n        this.debug = ndk.debug.extend(\"pool\");\n        for (const relayUrl of relayUrls) {\n            const relay = new NDKRelay(relayUrl);\n            this.addRelay(relay, false);\n        }\n    }\n\n    /**\n     * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n     * @param relay - The relay to add to the pool.\n     * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n     */\n    public useTemporaryRelay(relay: NDKRelay, removeIfUnusedAfter = 600000) {\n        const relayAlreadyInPool = this.relays.has(relay.url);\n\n        // check if the relay is already in the pool", "        for (const relayUrl of relayUrls) {\n            const relay = new NDKRelay(relayUrl);\n            this.addRelay(relay, false);\n        }\n    }\n\n    /**\n     * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n     * @param relay - The relay to add to the pool.\n     * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n     */\n    public useTemporaryRelay(relay: NDKRelay, removeIfUnusedAfter = 600000) {\n        const relayAlreadyInPool = this.relays.has(relay.url);\n\n        // check if the relay is already in the pool", "        if (!relayAlreadyInPool) {\n            this.addRelay(relay);\n        }\n\n        // check if the relay already has a disconnecting timer\n        const existingTimer = this.temporaryRelayTimers.get(relay.url);\n        if (existingTimer) {\n            clearTimeout(existingTimer);\n        }\n\n        // add a disconnecting timer only if the relay was not already in the pool\n        // or if it had an existing timer\n        // this prevents explicit relays from being removed from the pool", "        if (!relayAlreadyInPool || existingTimer) {\n            // set a timer to remove the relay from the pool if it is not used within the specified time\n            const timer = setTimeout(() => {\n                this.removeRelay(relay.url);\n            }, removeIfUnusedAfter) as unknown as NodeJS.Timeout;\n\n            this.temporaryRelayTimers.set(relay.url, timer);\n        }\n    }\n\n    /**\n     * Adds a relay to the pool.\n     *\n     * @param relay - The relay to add to the pool.\n     * @param connect - Whether or not to connect to the relay.\n     */\n    public addRelay(relay: NDKRelay, connect = true) {\n        const relayUrl = relay.url;\n\n        relay.on(\"notice\", (relay, notice) =>\n            this.emit(\"notice\", relay, notice)\n        );\n        relay.on(\"connect\", () => this.handleRelayConnect(relayUrl));\n        relay.on(\"disconnect\", () => this.emit(\"relay:disconnect\", relay));\n        relay.on(\"flapping\", () => this.handleFlapping(relay));\n        this.relays.set(relayUrl, relay);\n", "        if (connect) {\n            relay.connect();\n        }\n    }\n\n    /**\n     * Removes a relay from the pool.\n     * @param relayUrl - The URL of the relay to remove.\n     * @returns {boolean} True if the relay was removed, false if it was not found.\n     */\n    public removeRelay(relayUrl: string): boolean {\n        const relay = this.relays.get(relayUrl);", "        if (relay) {\n            relay.disconnect();\n            this.relays.delete(relayUrl);\n            this.emit(\"relay:disconnect\", relay);\n            return true;\n        }\n\n        // remove the relay from the temporary relay timers\n        const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n        if (existingTimer) {\n            clearTimeout(existingTimer);\n            this.temporaryRelayTimers.delete(relayUrl);\n        }\n\n        return false;\n    }\n\n    private handleRelayConnect(relayUrl: string) {\n        this.debug(`Relay ${relayUrl} connected`);\n        this.emit(\"relay:connect\", this.relays.get(relayUrl));\n", "        if (existingTimer) {\n            clearTimeout(existingTimer);\n            this.temporaryRelayTimers.delete(relayUrl);\n        }\n\n        return false;\n    }\n\n    private handleRelayConnect(relayUrl: string) {\n        this.debug(`Relay ${relayUrl} connected`);\n        this.emit(\"relay:connect\", this.relays.get(relayUrl));\n", "        if (this.stats().connected === this.relays.size) {\n            this.emit(\"connect\");\n        }\n    }\n\n    /**\n     * Attempts to establish a connection to each relay in the pool.\n     *\n     * @async\n     * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n     * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n     * @throws {Error} If any of the connection attempts result in an error or timeout.\n     */\n    public async connect(timeoutMs?: number): Promise<void> {\n        const promises: Promise<void>[] = [];\n\n        this.debug(\n            `Connecting to ${this.relays.size} relays${\n                timeoutMs ? `, timeout ${timeoutMs}...` : \"\"\n            }`\n        );\n", "        for (const relay of this.relays.values()) {\n            if (timeoutMs) {\n                const timeoutPromise = new Promise<void>((_, reject) => {\n                    setTimeout(\n                        () => reject(`Timed out after ${timeoutMs}ms`),\n                        timeoutMs\n                    );\n                });\n\n                promises.push(\n                    Promise.race([relay.connect(), timeoutPromise]).catch(\n                        (e) => {\n                            this.debug(\n                                `Failed to connect to relay ${relay.url}: ${e}`\n                            );\n                        }\n                    )\n                );\n            } else {\n                promises.push(relay.connect());\n            }\n        }\n\n        // If we are running with a timeout, check if we need to emit a `connect` event\n        // in case some, but not all, relays were connected", "                    Promise.race([relay.connect(), timeoutPromise]).catch(\n                        (e) => {\n                            this.debug(\n                                `Failed to connect to relay ${relay.url}: ${e}`\n                            );\n                        }\n                    )\n                );\n            } else {\n                promises.push(relay.connect());\n            }\n        }\n\n        // If we are running with a timeout, check if we need to emit a `connect` event\n        // in case some, but not all, relays were connected", "        if (timeoutMs) {\n            setTimeout(() => {\n                const allConnected =\n                    this.stats().connected === this.relays.size;\n                const someConnected = this.stats().connected > 0;\n\n                if (!allConnected && someConnected) {\n                    this.emit(\"connect\");\n                }\n            }, timeoutMs);\n        }\n\n        await Promise.all(promises);\n    }\n\n    private handleFlapping(relay: NDKRelay) {\n        this.debug(`Relay ${relay.url} is flapping`);\n\n        // TODO: Be smarter about this.\n        this.relays.delete(relay.url);\n        this.emit(\"flapping\", relay);\n    }\n\n    public size(): number {\n        return this.relays.size;\n    }\n\n    /**\n     * Returns the status of each relay in the pool.\n     * @returns {NDKPoolStats} An object containing the number of relays in each status.\n     */\n    public stats(): NDKPoolStats {\n        const stats: NDKPoolStats = {\n            total: 0,\n            connected: 0,\n            disconnected: 0,\n            connecting: 0,\n        };\n", "        for (const relay of this.relays.values()) {\n            stats.total++;\n            if (relay.status === NDKRelayStatus.CONNECTED) {\n                stats.connected++;\n            } else if (relay.status === NDKRelayStatus.DISCONNECTED) {\n                stats.disconnected++;\n            } else if (relay.status === NDKRelayStatus.CONNECTING) {\n                stats.connecting++;\n            }\n        }\n\n        return stats;\n    }\n\n    public connectedRelays(): NDKRelay[] {\n        return Array.from(this.relays.values()).filter(\n            (relay) => relay.status === NDKRelayStatus.CONNECTED\n        );\n    }\n\n    /**\n     * Get a list of all relay urls in the pool.\n     */\n    public urls(): string[] {\n        return Array.from(this.relays.keys());\n    }\n}\n"]}
{"filename": "src/relay/sets/utils.ts", "chunked_list": ["import { NDKPool } from \"../../relay/pool/index.js\";\nimport { NDKRelaySet } from \"../../relay/sets/index.js\";\n\n/**\n * If the provided relay set does not include connected relays in the pool\n * the relaySet will have the connected relays added to it.\n */\nexport function correctRelaySet(\n    relaySet: NDKRelaySet,\n    pool: NDKPool\n): NDKRelaySet {\n    const connectedRelays = pool.connectedRelays();\n    const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n        return connectedRelays.map((r) => r.url).includes(relay.url);\n    });\n", "    if (!includesConnectedRelay) {\n        // Add connected relays to the relay set\n        for (const relay of connectedRelays) {\n            relaySet.addRelay(relay);\n        }\n    }\n\n    // if connected relays is empty (such us when we're first starting, add all relays)\n    if (connectedRelays.length === 0) {\n        for (const relay of pool.relays.values()) {\n            relaySet.addRelay(relay);\n        }\n    }\n\n    return relaySet;\n}\n", "    if (connectedRelays.length === 0) {\n        for (const relay of pool.relays.values()) {\n            relaySet.addRelay(relay);\n        }\n    }\n\n    return relaySet;\n}\n"]}
{"filename": "src/relay/sets/index.ts", "chunked_list": ["import { sha256 } from \"@noble/hashes/sha256\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport NDKEvent from \"../../events/index.js\";\nimport type NDK from \"../../index.js\";\nimport {\n    NDKSubscription,\n    NDKSubscriptionGroup,\n} from \"../../subscription/index.js\";\nimport { NDKRelay, NDKRelayStatus } from \"../index.js\";\n\n/**\n * A relay set is a group of relays. This grouping can be short-living, for a single\n * REQ or can be long-lasting, for example for the explicit relay list the user\n * has specified.\n *\n * Requests to relays should be sent through this interface.\n */", "export class NDKRelaySet {\n    readonly relays: Set<NDKRelay>;\n    private debug: debug.Debugger;\n    private ndk: NDK;\n\n    public constructor(relays: Set<NDKRelay>, ndk: NDK) {\n        this.relays = relays;\n        this.ndk = ndk;\n        this.debug = ndk.debug.extend(\"relayset\");\n    }\n\n    /**\n     * Adds a relay to this set.\n     */\n    public addRelay(relay: NDKRelay) {\n        this.relays.add(relay);\n    }\n\n    /**\n     * Creates a relay set from a list of relay URLs.\n     *\n     * This is useful for testing in development to pass a local relay\n     * to publish methods.\n     *\n     * @param relayUrls - list of relay URLs to include in this set\n     * @param ndk\n     * @returns NDKRelaySet\n     */\n    static fromRelayUrls(relayUrls: string[], ndk: NDK): NDKRelaySet {\n        const relays = new Set<NDKRelay>();", "        for (const url of relayUrls) {\n            const relay = ndk.pool.relays.get(url);\n            if (relay) {\n                relays.add(relay);\n            }\n        }\n\n        return new NDKRelaySet(new Set(relays), ndk);\n    }\n\n    private subscribeOnRelay(relay: NDKRelay, subscription: NDKSubscription) {\n        const sub = relay.subscribe(subscription);\n        subscription.relaySubscriptions.set(relay, sub);\n    }\n\n    /**\n     * Calculates an ID of this specific combination of relays.\n     */\n    public getId() {\n        const urls = Array.from(this.relays).map((r) => r.url);\n        const urlString = urls.sort().join(\",\");\n        return bytesToHex(sha256(urlString));\n    }\n\n    /**\n     * Add a subscription to this relay set\n     */\n    public subscribe(subscription: NDKSubscription): NDKSubscription {\n        const subGroupableId = subscription.groupableId();\n        const groupableId = `${this.getId()}:${subGroupableId}`;\n", "        if (!subGroupableId) {\n            this.executeSubscription(subscription);\n            return subscription;\n        }\n\n        const delayedSubscription =\n            this.ndk.delayedSubscriptions.get(groupableId);\n        if (delayedSubscription) {\n            delayedSubscription.push(subscription);\n        } else {\n            setTimeout(() => {\n                this.executeDelayedSubscription(groupableId);\n            }, subscription.opts.groupableDelay);\n\n            this.ndk.delayedSubscriptions.set(groupableId, [subscription]);\n        }\n\n        return subscription;\n    }\n\n    private executeDelayedSubscription(groupableId: string) {\n        const subscriptions = this.ndk.delayedSubscriptions.get(groupableId);\n        this.ndk.delayedSubscriptions.delete(groupableId);\n", "        if (subscriptions) {\n            if (subscriptions.length > 1) {\n                this.executeSubscriptions(subscriptions);\n            } else {\n                this.executeSubscription(subscriptions[0]);\n            }\n        }\n    }\n\n    /**\n     * This function takes a similar group of subscriptions, merges the filters\n     * and sends a single subscription to the relay.\n     */\n    private executeSubscriptions(subscriptions: NDKSubscription[]) {\n        const ndk = subscriptions[0].ndk;\n        const subGroup = new NDKSubscriptionGroup(ndk, subscriptions);\n\n        this.executeSubscription(subGroup);\n    }\n\n    private executeSubscription(\n        subscription: NDKSubscription\n    ): NDKSubscription {\n        this.debug(\"subscribing\", { filters: subscription.filters });\n", "     * This function takes a similar group of subscriptions, merges the filters\n     * and sends a single subscription to the relay.\n     */\n    private executeSubscriptions(subscriptions: NDKSubscription[]) {\n        const ndk = subscriptions[0].ndk;\n        const subGroup = new NDKSubscriptionGroup(ndk, subscriptions);\n\n        this.executeSubscription(subGroup);\n    }\n\n    private executeSubscription(\n        subscription: NDKSubscription\n    ): NDKSubscription {\n        this.debug(\"subscribing\", { filters: subscription.filters });\n", "        for (const relay of this.relays) {\n            if (relay.status === NDKRelayStatus.CONNECTED) {\n                // If the relay is already connected, subscribe immediately\n                this.subscribeOnRelay(relay, subscription);\n            } else {\n                // If the relay is not connected, add a one-time listener to wait for the 'connected' event\n                const connectedListener = () => {\n                    this.debug(\n                        \"new relay coming online for active subscription\",\n                        {\n                            relay: relay.url,\n                            filters: subscription.filters,\n                        }\n                    );\n                    this.subscribeOnRelay(relay, subscription);\n                };\n                relay.once(\"connect\", connectedListener);\n\n                // Add a one-time listener to remove the connectedListener when the subscription stops\n                subscription.once(\"close\", () => {\n                    relay.removeListener(\"connect\", connectedListener);\n                });\n            }\n        }\n\n        return subscription;\n    }\n\n    /**\n     * Publish an event to all relays in this set. Returns the number of relays that have received the event.\n     * @param event\n     * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation\n     * @returns A set where the event was successfully published to\n     */\n    public async publish(\n        event: NDKEvent,\n        timeoutMs?: number\n    ): Promise<Set<NDKRelay>> {\n        const publishedToRelays: Set<NDKRelay> = new Set();\n\n        // go through each relay and publish the event\n        const promises: Promise<void>[] = Array.from(this.relays).map(\n            (relay: NDKRelay) => {\n                return new Promise<void>((resolve) => {\n                    relay\n                        .publish(event, timeoutMs)\n                        .then(() => {\n                            publishedToRelays.add(relay);\n                            resolve();\n                        })", "                        .catch((err) => {\n                            this.debug(\"error publishing to relay\", {\n                                relay: relay.url,\n                                err,\n                            });\n                            resolve();\n                        });\n                });\n            }\n        );\n\n        await Promise.all(promises);\n", "        if (publishedToRelays.size === 0) {\n            throw new Error(\"No relay was able to receive the event\");\n        }\n\n        return publishedToRelays;\n    }\n\n    public size(): number {\n        return this.relays.size;\n    }\n}\n"]}
{"filename": "src/relay/sets/calculate.ts", "chunked_list": ["import Event from \"../../events/index.js\";\nimport NDK from \"../../index.js\";\nimport { NDKFilter } from \"../../subscription/index.js\";\nimport { NDKRelay } from \"../index.js\";\nimport { NDKRelaySet } from \"./index.js\";\n\n/**\n * Creates a NDKRelaySet for the specified event.\n * TODO: account for relays where tagged pubkeys or hashtags\n * tend to write to.", " * TODO: account for relays where tagged pubkeys or hashtags\n * tend to write to.\n * @param ndk {NDK}\n * @param event {Event}\n * @returns Promise<NDKRelaySet>\n */\nexport function calculateRelaySetFromEvent(\n    ndk: NDK,\n    event: Event\n): NDKRelaySet {\n    const relays: Set<NDKRelay> = new Set();\n\n    ndk.pool?.relays.forEach((relay) => relays.add(relay));\n\n    return new NDKRelaySet(relays, ndk);\n}\n\n/**\n * Creates a NDKRelaySet for the specified filter\n * @param ndk\n * @param filter\n * @returns Promise<NDKRelaySet>\n */", "export function calculateRelaySetFromFilter(\n    ndk: NDK,\n    filter: NDKFilter\n): NDKRelaySet {\n    const relays: Set<NDKRelay> = new Set();\n\n    ndk.pool?.relays.forEach((relay) => {\n        if (!relay.complaining) {\n            relays.add(relay);\n        } else {\n            ndk.debug(`Relay ${relay.url} is complaining, not adding to set`);\n        }\n    });\n\n    return new NDKRelaySet(relays, ndk);\n}\n\n/**\n * Calculates a number of RelaySets for each filter.\n * @param ndk\n * @param filters\n */", "export function calculateRelaySetsFromFilters(\n    ndk: NDK,\n    filters: NDKFilter[]\n): Map<NDKFilter, NDKRelaySet> {\n    const sets: Map<NDKFilter, NDKRelaySet> = new Map();\n\n    filters.forEach((filter) => {\n        const set = calculateRelaySetFromFilter(ndk, filter);\n        sets.set(filter, set);\n    });\n\n    return sets;\n}\n"]}
{"filename": "src/user/follows.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\nimport NDKUser from \"./index.js\";\n\nexport async function follows(this: NDKUser): Promise<Set<NDKUser>> {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n\n    const contactListEvents = await this.ndk.fetchEvents({\n        kinds: [3],\n        authors: [this.hexpubkey()],\n    });\n", "    if (contactListEvents) {\n        const npubs = new Set<string>();\n\n        contactListEvents.forEach((event) => {\n            event.tags.forEach((tag: string[]) => {\n                if (tag[0] === \"p\") {\n                    try {\n                        const npub = nip19.npubEncode(tag[1]);\n                        npubs.add(npub);\n                    } catch (e) {\n                        /* empty */\n                    }\n                }\n            });\n        });\n\n        return [...npubs].reduce((acc: Set<NDKUser>, npub: string) => {\n            const user = new NDKUser({ npub });\n            user.ndk = this.ndk;\n            acc.add(user);\n            return acc;\n        }, new Set<NDKUser>());\n    }\n\n    return new Set<NDKUser>();\n}\n", "                    } catch (e) {\n                        /* empty */\n                    }\n                }\n            });\n        });\n\n        return [...npubs].reduce((acc: Set<NDKUser>, npub: string) => {\n            const user = new NDKUser({ npub });\n            user.ndk = this.ndk;\n            acc.add(user);\n            return acc;\n        }, new Set<NDKUser>());\n    }\n\n    return new Set<NDKUser>();\n}\n"]}
{"filename": "src/user/index.test.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\nimport NDK, { NDKEvent, NDKSubscription } from \"../index.js\";\nimport NDKUser, { NDKUserParams } from \"./index.js\";\n\njest.mock(\"nostr-tools\", () => ({\n    nip05: {\n        queryProfile: jest.fn(),\n    },\n    nip19: {\n        npubEncode: jest.fn(),", "    nip19: {\n        npubEncode: jest.fn(),\n        decode: jest.fn(),\n    },\n}));\n\ndescribe(\"NDKUser\", () => {\n    beforeEach(() => {\n        jest.clearAllMocks();\n    });", "        jest.clearAllMocks();\n    });\n\n    describe(\"constructor\", () => {\n        it(\"sets npub from provided npub\", () => {\n            const opts: NDKUserParams = {\n                npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n            };\n\n            const user = new NDKUser(opts);", "\n            const user = new NDKUser(opts);\n\n            expect(user.npub).toEqual(\n                \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\"\n            );\n        });\n\n        it(\"sets npub from provided hexpubkey\", () => {\n            const opts: NDKUserParams = {", "        it(\"sets npub from provided hexpubkey\", () => {\n            const opts: NDKUserParams = {\n                hexpubkey:\n                    \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n            };\n\n            (nip19.npubEncode as jest.Mock).mockReturnValue(\"encoded_npub\");\n\n            const user = new NDKUser(opts);\n", "            const user = new NDKUser(opts);\n\n            expect(nip19.npubEncode).toHaveBeenCalledWith(\n                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\"\n            );\n            expect(user.npub).toEqual(\"encoded_npub\");\n        });\n\n        it(\"sets relayUrls from provided relayUrls\", () => {\n            const opts: NDKUserParams = {", "        it(\"sets relayUrls from provided relayUrls\", () => {\n            const opts: NDKUserParams = {\n                relayUrls: [\"url1\", \"url2\"],\n            };\n\n            const user = new NDKUser(opts);\n\n            expect(user.relayUrls).toEqual([\"url1\", \"url2\"]);\n        });\n    });", "        });\n    });\n\n    describe(\"hexpubkey\", () => {\n        it(\"returns the decoded hexpubkey\", () => {\n            const user = new NDKUser({\n                npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n            });\n\n            (nip19.decode as jest.Mock).mockReturnValue({", "\n            (nip19.decode as jest.Mock).mockReturnValue({\n                data: \"decoded_hexpubkey\",\n            });\n\n            const hexpubkey = user.hexpubkey();\n\n            expect(nip19.decode).toHaveBeenCalledWith(\n                \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\"\n            );", "                \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\"\n            );\n            expect(hexpubkey).toEqual(\"decoded_hexpubkey\");\n        });\n    });\n\n    describe(\"fetchProfile\", () => {\n        const ndk = new NDK();\n        let newEvent: NDKEvent;\n        let oldEvent: NDKEvent;", "        let newEvent: NDKEvent;\n        let oldEvent: NDKEvent;\n        const user = new NDKUser({\n            npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n        });\n        user.ndk = ndk;\n        (nip19.decode as jest.Mock).mockReturnValue({\n            data: \"decoded_hexpubkey\",\n        });\n        const pubkey = user.hexpubkey();", "        });\n        const pubkey = user.hexpubkey();\n\n        it(\"Returns updated fields\", async () => {\n            newEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 3600,\n                content: JSON.stringify({", "                created_at: Date.now() / 1000 - 3600,\n                content: JSON.stringify({\n                    displayName: \"JeffG\",\n                    name: \"Jeff\",\n                    image: \"https://image.url\",\n                    banner: \"https://banner.url\",\n                    bio: \"Some bio info\",\n                    nip05: \"_@jeffg.fyi\",\n                    lud06: \"lud06value\",\n                    lud16: \"lud16value\",", "                    lud06: \"lud06value\",\n                    lud16: \"lud16value\",\n                    about: \"About jeff\",\n                    zapService: \"Zapservice details\",\n                }),\n            });\n\n            oldEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,", "                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 7200,\n                content: JSON.stringify({\n                    displayName: \"JeffG_OLD\",\n                    name: \"Jeff_OLD\",\n                    image: \"https://image.url.old\",\n                    banner: \"https://banner.url.old\",\n                    bio: \"Some OLD bio info\",", "                    banner: \"https://banner.url.old\",\n                    bio: \"Some OLD bio info\",\n                    nip05: \"OLD@jeffg.fyi\",\n                    lud06: \"lud06value OLD\",\n                    lud16: \"lud16value OLD\",\n                    about: \"About jeff OLD\",\n                    zapService: \"Zapservice details OLD\",\n                }),\n            });\n", "            });\n\n            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n                const sub = new NDKSubscription(ndk, filter, opts);\n\n                setTimeout(() => {\n                    sub.emit(\"event\", newEvent);\n                    sub.emit(\"event\", oldEvent);\n                    sub.emit(\"eose\");\n                }, 100);", "                    sub.emit(\"eose\");\n                }, 100);\n\n                return sub;\n            });\n\n            await user.fetchProfile();\n            expect(user.profile?.displayName).toEqual(\"JeffG\");\n            expect(user.profile?.name).toEqual(\"Jeff\");\n            expect(user.profile?.image).toEqual(\"https://image.url\");", "            expect(user.profile?.name).toEqual(\"Jeff\");\n            expect(user.profile?.image).toEqual(\"https://image.url\");\n            expect(user.profile?.banner).toEqual(\"https://banner.url\");\n            expect(user.profile?.bio).toEqual(\"Some bio info\");\n            expect(user.profile?.nip05).toEqual(\"_@jeffg.fyi\");\n            expect(user.profile?.lud06).toEqual(\"lud06value\");\n            expect(user.profile?.lud16).toEqual(\"lud16value\");\n            expect(user.profile?.about).toEqual(\"About jeff\");\n            expect(user.profile?.zapService).toEqual(\"Zapservice details\");\n        });", "            expect(user.profile?.zapService).toEqual(\"Zapservice details\");\n        });\n\n        // Both \"display_name\" and \"displayName\" are set to \"displayName\" field in the user profile\n        it(\"Display name is set properly\", async () => {\n            newEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 3600,", "                tags: [],\n                created_at: Date.now() / 1000 - 3600,\n                content: JSON.stringify({\n                    displayName: \"JeffG\",\n                    display_name: \"James\",\n                }),\n            });\n\n            oldEvent = new NDKEvent(ndk, {\n                kind: 0,", "            oldEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 7200,\n                content: JSON.stringify({\n                    displayName: \"Bob\",\n                }),\n            });\n", "            });\n\n            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n                const sub = new NDKSubscription(ndk, filter, opts);\n\n                setTimeout(() => {\n                    sub.emit(\"event\", newEvent);\n                    sub.emit(\"event\", oldEvent);\n                    sub.emit(\"eose\");\n                }, 100);", "                    sub.emit(\"eose\");\n                }, 100);\n\n                return sub;\n            });\n\n            await user.fetchProfile();\n            expect(user.profile?.displayName).toEqual(\"JeffG\");\n        });\n", "        });\n\n        // Both \"image\" and \"picture\" are set to the \"image\" field in the user profile\n        it(\"Image is set properly\", async () => {\n            newEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 3600,\n                content: JSON.stringify({", "                created_at: Date.now() / 1000 - 3600,\n                content: JSON.stringify({\n                    picture: \"https://set-from-picture-field.url\",\n                }),\n            });\n\n            oldEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],", "                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 7200,\n                content: JSON.stringify({\n                    image: \"https://set-from-image-field.url\",\n                }),\n            });\n\n            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n                const sub = new NDKSubscription(ndk, filter, opts);", "            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n                const sub = new NDKSubscription(ndk, filter, opts);\n\n                setTimeout(() => {\n                    sub.emit(\"event\", newEvent);\n                    sub.emit(\"event\", oldEvent);\n                    sub.emit(\"eose\");\n                }, 100);\n\n                return sub;", "\n                return sub;\n            });\n\n            await user.fetchProfile();\n            expect(user.profile?.image).toEqual(\n                \"https://set-from-picture-field.url\"\n            );\n        });\n", "        });\n\n        it(\"Allows for arbitrary values to be set on user profiles\", async () => {\n            newEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 3600,\n                content: JSON.stringify({\n                    customField: \"custom NEW\",", "                content: JSON.stringify({\n                    customField: \"custom NEW\",\n                }),\n            });\n\n            oldEvent = new NDKEvent(ndk, {\n                kind: 0,\n                pubkey: pubkey,\n                tags: [],\n                created_at: Date.now() / 1000 - 7200,", "                tags: [],\n                created_at: Date.now() / 1000 - 7200,\n                content: JSON.stringify({\n                    customField: \"custom OLD\",\n                }),\n            });\n\n            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n                const sub = new NDKSubscription(ndk, filter, opts);\n", "                const sub = new NDKSubscription(ndk, filter, opts);\n\n                setTimeout(() => {\n                    sub.emit(\"event\", newEvent);\n                    sub.emit(\"event\", oldEvent);\n                    sub.emit(\"eose\");\n                }, 100);\n\n                return sub;\n            });", "                return sub;\n            });\n\n            await user.fetchProfile();\n            expect(user.profile?.customField).toEqual(\"custom NEW\");\n        });\n    });\n});\n", ""]}
{"filename": "src/user/follows.test.ts", "chunked_list": ["import NDKEvent from \"../events/index\";\nimport NDK from \"../index\";\nimport NDKUser from \"./index\";\n\njest.mock(\"../index.js\", () => {\n    return {\n        __esModule: true,\n        default: jest.fn().mockImplementation(() => {\n            return {\n                fetchEvents: jest.fn(),", "            return {\n                fetchEvents: jest.fn(),\n            };\n        }),\n    };\n});\n\ndescribe(\"follows\", () => {\n    it(\"skips tags on the contact list with invalid pubkeys\", async () => {\n        const ndk = new NDK();", "    it(\"skips tags on the contact list with invalid pubkeys\", async () => {\n        const ndk = new NDK();\n        const user = new NDKUser({\n            hexpubkey:\n                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n        });\n        user.ndk = ndk;\n\n        const followedHexpubkey =\n            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\";", "        const followedHexpubkey =\n            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\";\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        (user.ndk!.fetchEvents as jest.Mock).mockImplementation(() => {\n            const e = new NDKEvent(ndk);\n            e.tags = [[\"p\", \"invalid-pubkey\"]];\n            e.tags = [[\"p\", followedHexpubkey]];\n            return new Set([e]);\n        });", "            return new Set([e]);\n        });\n\n        const followedUsers = await user.follows();\n        expect(followedUsers.size).toBe(1);\n\n        for (const followedUser of followedUsers) {\n            expect(followedUser).toBeInstanceOf(NDKUser);\n            expect(followedUser.hexpubkey()).toBe(followedHexpubkey);\n            expect(followedUser.ndk).toBe(user.ndk);\n        }\n    });\n\n    it(\"dedupes followed users\", async () => {\n        const ndk = new NDK();\n        const user = new NDKUser({\n            hexpubkey:\n                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n        });\n        user.ndk = ndk;\n\n        const followedHexpubkey =\n            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\";\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        (user.ndk!.fetchEvents as jest.Mock).mockImplementation(() => {\n            const e = new NDKEvent(ndk);\n            e.tags = [[\"p\", \"invalid-pubkey\"]];\n            e.tags = [[\"p\", followedHexpubkey]];\n            e.tags = [[\"p\", followedHexpubkey]];\n            return new Set([e]);\n        });\n\n        const followedUsers = await user.follows();\n        expect(followedUsers.size).toBe(1);\n", "        for (const followedUser of followedUsers) {\n            expect(followedUser).toBeInstanceOf(NDKUser);\n            expect(followedUser.hexpubkey()).toBe(followedHexpubkey);\n            expect(followedUser.ndk).toBe(user.ndk);\n        }\n    });\n});\n"]}
{"filename": "src/user/index.ts", "chunked_list": ["import { nip05, nip19 } from \"nostr-tools\";\nimport { default as NDKEvent, NDKTag, NostrEvent } from \"../events/index.js\";\nimport NDK, { NDKKind } from \"../index.js\";\nimport {\n    NDKSubscriptionCacheUsage,\n    NDKSubscriptionOptions,\n} from \"../subscription/index.js\";\nimport { follows } from \"./follows.js\";\nimport { NDKUserProfile, mergeEvent } from \"./profile\";\n\nexport interface NDKUserParams {\n    npub?: string;\n    hexpubkey?: string;\n    nip05?: string;\n    relayUrls?: string[];\n}\n\n/**\n * Represents a pubkey.\n */", "import { NDKUserProfile, mergeEvent } from \"./profile\";\n\nexport interface NDKUserParams {\n    npub?: string;\n    hexpubkey?: string;\n    nip05?: string;\n    relayUrls?: string[];\n}\n\n/**\n * Represents a pubkey.\n */", "export default class NDKUser {\n    public ndk: NDK | undefined;\n    public profile?: NDKUserProfile;\n    readonly npub: string = \"\";\n    readonly relayUrls: string[] = [];\n\n    public constructor(opts: NDKUserParams) {\n        if (opts.npub) this.npub = opts.npub;\n\n        if (opts.hexpubkey) {\n            this.npub = nip19.npubEncode(opts.hexpubkey);\n        }\n", "        if (opts.hexpubkey) {\n            this.npub = nip19.npubEncode(opts.hexpubkey);\n        }\n\n        if (opts.relayUrls) {\n            this.relayUrls = opts.relayUrls;\n        }\n    }\n\n    /**\n     * Instantiate an NDKUser from a NIP-05 string\n     * @param nip05Id {string} The user's NIP-05\n     * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n     */\n    static async fromNip05(nip05Id: string): Promise<NDKUser | undefined> {\n        const profile = await nip05.queryProfile(nip05Id);\n", "        if (profile) {\n            return new NDKUser({\n                hexpubkey: profile.pubkey,\n                relayUrls: profile.relays,\n            });\n        }\n    }\n\n    /**\n     * Get the hexpubkey for a user\n     * @returns {string} The user's hexpubkey\n     */\n    public hexpubkey(): string {\n        return nip19.decode(this.npub).data as string;\n    }\n\n    /**\n     * Fetch a user's kind 0 metadata events and merge the events in a single up-to-date profile\n     * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n     * @returns {Promise<Set<NDKEvent>>} A set of all NDKEvents events returned for the given user\n     */\n    public async fetchProfile(\n        opts?: NDKSubscriptionOptions\n    ): Promise<Set<NDKEvent> | null> {", "        if (!this.ndk) throw new Error(\"NDK not set\");\n\n        if (!this.profile) this.profile = {};\n\n        let setMetadataEvents: Set<NDKEvent> | null = null;\n\n        // if no options have been set and we have a cache, try to load from cache with no grouping\n        // This is done in favour of simply using NDKSubscriptionCacheUsage.CACHE_FIRST since\n        // we want to avoid depending on the grouping, arguably, all queries should go through this\n        // type of behavior when we have a locking cache\n        if (\n            !opts && // if no options have been set\n            this.ndk.cacheAdapter && // and we have a cache\n            this.ndk.cacheAdapter.locking // and the cache identifies itself as fast \ud83d\ude02\n        ) {\n            setMetadataEvents = await this.ndk.fetchEvents(\n                {\n                    kinds: [0],\n                    authors: [this.hexpubkey()],\n                },\n                {\n                    cacheUsage: NDKSubscriptionCacheUsage.ONLY_CACHE,\n                    closeOnEose: true,\n                    groupable: false,\n                }\n            );\n\n            opts = {\n                cacheUsage: NDKSubscriptionCacheUsage.ONLY_RELAY,\n                closeOnEose: true,\n            };\n        }\n", "        // type of behavior when we have a locking cache\n        if (\n            !opts && // if no options have been set\n            this.ndk.cacheAdapter && // and we have a cache\n            this.ndk.cacheAdapter.locking // and the cache identifies itself as fast \ud83d\ude02\n        ) {\n            setMetadataEvents = await this.ndk.fetchEvents(\n                {\n                    kinds: [0],\n                    authors: [this.hexpubkey()],\n                },\n                {\n                    cacheUsage: NDKSubscriptionCacheUsage.ONLY_CACHE,\n                    closeOnEose: true,\n                    groupable: false,\n                }\n            );\n\n            opts = {\n                cacheUsage: NDKSubscriptionCacheUsage.ONLY_RELAY,\n                closeOnEose: true,\n            };\n        }\n", "        if (!setMetadataEvents || setMetadataEvents.size === 0) {\n            setMetadataEvents = await this.ndk.fetchEvents(\n                {\n                    kinds: [0],\n                    authors: [this.hexpubkey()],\n                },\n                opts\n            );\n        }\n\n        if (setMetadataEvents) {\n            // sort setMetadataEvents by created_at in ascending order\n            const sortedSetMetadataEvents = Array.from(setMetadataEvents).sort(\n                (a, b) => (a.created_at as number) - (b.created_at as number)\n            );\n\n            sortedSetMetadataEvents.forEach((event) => {", "        if (setMetadataEvents) {\n            // sort setMetadataEvents by created_at in ascending order\n            const sortedSetMetadataEvents = Array.from(setMetadataEvents).sort(\n                (a, b) => (a.created_at as number) - (b.created_at as number)\n            );\n\n            sortedSetMetadataEvents.forEach((event) => {\n                try {\n                    this.profile = mergeEvent(event, this.profile!);\n                } catch (e) {}\n            });\n        }\n\n        return setMetadataEvents;\n    }\n\n    /**\n     * Returns a set of users that this user follows.\n     */\n    public follows = follows.bind(this);\n\n    /**\n     * Returns a set of relay list events for a user.\n     * @returns {Promise<Set<NDKEvent>>} A set of NDKEvents returned for the given user.\n     */\n    public async relayList(): Promise<Set<NDKEvent>> {", "                } catch (e) {}\n            });\n        }\n\n        return setMetadataEvents;\n    }\n\n    /**\n     * Returns a set of users that this user follows.\n     */\n    public follows = follows.bind(this);\n\n    /**\n     * Returns a set of relay list events for a user.\n     * @returns {Promise<Set<NDKEvent>>} A set of NDKEvents returned for the given user.\n     */\n    public async relayList(): Promise<Set<NDKEvent>> {", "        if (!this.ndk) throw new Error(\"NDK not set\");\n\n        const relayListEvents = await this.ndk.fetchEvents({\n            kinds: [10002],\n            authors: [this.hexpubkey()],\n        });\n\n        if (relayListEvents) {\n            return relayListEvents;\n        }\n\n        return new Set<NDKEvent>();\n    }\n\n    /**\n     * Get the tag that can be used to reference this user in an event\n     * @returns {NDKTag} an NDKTag\n     */\n    public tagReference(): NDKTag {\n        return [\"p\", this.hexpubkey()];\n    }\n\n    /**\n     * Publishes the current profile.\n     */\n    public async publish() {", "        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\n        this.ndk.assertSigner();\n\n        const event = new NDKEvent(this.ndk, {\n            kind: 0,\n            content: JSON.stringify(this.profile),\n        } as NostrEvent);\n        await event.publish();\n    }\n\n    /**\n     * Add a follow to this user's contact list\n     *\n     * @param newFollow {NDKUser} The user to follow\n     * @param currentFollowList {Set<NDKUser>} The current follow list\n     * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n     */\n    public async follow(\n        newFollow: NDKUser,\n        currentFollowList?: Set<NDKUser>\n    ): Promise<boolean> {", "        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\n        this.ndk.assertSigner();\n\n        if (!currentFollowList) {\n            currentFollowList = await this.follows();\n        }\n\n        if (currentFollowList.has(newFollow)) {\n            return false;\n        }\n\n        currentFollowList.add(newFollow);\n\n        const event = new NDKEvent(this.ndk, {\n            kind: NDKKind.Contacts,\n        } as NostrEvent);\n\n        // This is a horrible hack and I need to fix it", "        if (currentFollowList.has(newFollow)) {\n            return false;\n        }\n\n        currentFollowList.add(newFollow);\n\n        const event = new NDKEvent(this.ndk, {\n            kind: NDKKind.Contacts,\n        } as NostrEvent);\n\n        // This is a horrible hack and I need to fix it", "        for (const follow of currentFollowList) {\n            event.tag(follow);\n        }\n\n        await event.publish();\n\n        return true;\n    }\n}\n"]}
{"filename": "src/user/profile.ts", "chunked_list": ["import NDKEvent from \"../events/index.js\";\n\n/**\n * NDKUserProfile represents a user's kind 0 profile metadata\n */\nexport type NDKUserProfile = {\n    [key: string]: string | undefined; // allows custom fields\n    name?: string;\n    displayName?: string;\n    image?: string;\n    banner?: string;\n    bio?: string;\n    nip05?: string;\n    lud06?: string;\n    lud16?: string;\n    about?: string;\n    zapService?: string;\n    website?: string;\n};\n", "export function mergeEvent(\n    event: NDKEvent,\n    profile: NDKUserProfile\n): NDKUserProfile {\n    const payload = JSON.parse(event.content);\n\n    Object.keys(payload).forEach((key) => {\n        switch (key) {\n            case \"name\":\n                profile.name = payload.name;\n                break;\n            case \"display_name\":\n            case \"displayName\":\n                profile.displayName =\n                    payload.displayName || payload.display_name;\n                break;\n            case \"image\":\n            case \"picture\":\n                profile.image = payload.image || payload.picture;\n                break;\n            case \"banner\":\n                profile.banner = payload.banner;\n                break;\n            case \"bio\":\n                profile.bio = payload.bio;\n                break;\n            case \"nip05\":\n                profile.nip05 = payload.nip05;\n                break;\n            case \"lud06\":\n                profile.lud06 = payload.lud06;\n                break;\n            case \"lud16\":\n                profile.lud16 = payload.lud16;\n                break;\n            case \"about\":\n                profile.about = payload.about;\n                break;\n            case \"zapService\":\n                profile.zapService = payload.zapService;\n                break;\n            case \"website\":\n                profile.website = payload.website;\n                break;\n            default:\n                profile[key] = payload[key];\n                break;\n        }\n    });\n\n    return profile;\n}\n"]}
{"filename": "src/subscription/utils.ts", "chunked_list": ["import { NDKFilter, NDKSubscription } from \"./index.js\";\n\n/**\n * Checks if a subscription is fully guaranteed to have been filled.\n *\n * This is useful to determine if a cache hit fully satisfies a subscription.\n *\n * @param subscription\n * @returns\n */\nexport function queryFullyFilled(subscription: NDKSubscription): boolean {", " * @returns\n */\nexport function queryFullyFilled(subscription: NDKSubscription): boolean {\n    if (filterIncludesIds(subscription.filter)) {\n        if (resultHasAllRequestedIds(subscription)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n", "function filterIncludesIds(filter: NDKFilter): boolean {\n    return !!filter[\"ids\"];\n}\n\nfunction resultHasAllRequestedIds(subscription: NDKSubscription): boolean {\n    const ids = subscription.filter[\"ids\"];\n\n    return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\n"]}
{"filename": "src/subscription/index.ts", "chunked_list": ["import EventEmitter from \"eventemitter3\";\nimport { Filter as NostrFilter, matchFilter, Sub, nip19 } from \"nostr-tools\";\nimport { EventPointer } from \"nostr-tools/lib/nip19\";\nimport NDKEvent, { NDKEventId } from \"../events/index.js\";\nimport NDK from \"../index.js\";\nimport { NDKRelay } from \"../relay\";\nimport { calculateRelaySetFromFilter } from \"../relay/sets/calculate\";\nimport { NDKRelaySet } from \"../relay/sets/index.js\";\nimport { queryFullyFilled } from \"./utils.js\";\n\nexport type NDKFilter = NostrFilter;\n", "import { queryFullyFilled } from \"./utils.js\";\n\nexport type NDKFilter = NostrFilter;\n\nexport enum NDKSubscriptionCacheUsage {\n    // Only use cache, don't subscribe to relays\n    ONLY_CACHE = \"ONLY_CACHE\",\n\n    // Use cache, if no matches, use relays\n    CACHE_FIRST = \"CACHE_FIRST\",\n\n    // Use cache in addition to relays\n    PARALLEL = \"PARALLEL\",\n\n    // Skip cache, don't query it\n    ONLY_RELAY = \"ONLY_RELAY\",\n}\n", "export interface NDKSubscriptionOptions {\n    closeOnEose: boolean;\n    cacheUsage?: NDKSubscriptionCacheUsage;\n\n    /**\n     * Groupable subscriptions are created with a slight time\n     * delayed to allow similar filters to be grouped together.\n     */\n    groupable?: boolean;\n\n    /**\n     * The delay to use when grouping subscriptions, specified in milliseconds.\n     * @default 100\n     */\n    groupableDelay?: number;\n\n    /**\n     * The subscription ID to use for the subscription.\n     */\n    subId?: string;\n}\n\n/**\n * Default subscription options.\n */\nexport const defaultOpts: NDKSubscriptionOptions = {\n    closeOnEose: true,\n    cacheUsage: NDKSubscriptionCacheUsage.CACHE_FIRST,\n    groupable: true,\n    groupableDelay: 100,\n};\n\n/**\n * Represents a subscription to an NDK event stream.\n *\n * @event NDKSubscription#event\n * Emitted when an event is received by the subscription.\n * @param {NDKEvent} event - The event received by the subscription.\n * @param {NDKRelay} relay - The relay that received the event.\n * @param {NDKSubscription} subscription - The subscription that received the event.\n *\n * @event NDKSubscription#event:dup\n * Emitted when a duplicate event is received by the subscription.\n * @param {NDKEvent} event - The duplicate event received by the subscription.\n * @param {NDKRelay} relay - The relay that received the event.\n * @param {number} timeSinceFirstSeen - The time elapsed since the first time the event was seen.\n * @param {NDKSubscription} subscription - The subscription that received the event.\n *\n * @event NDKSubscription#eose - Emitted when all relays have reached the end of the event stream.\n * @param {NDKSubscription} subscription - The subscription that received EOSE.\n *\n * @event NDKSubscription#close - Emitted when the subscription is closed.\n * @param {NDKSubscription} subscription - The subscription that was closed.\n */", "export class NDKSubscription extends EventEmitter {\n    readonly subId: string;\n    readonly filters: NDKFilter[];\n    readonly opts: NDKSubscriptionOptions;\n    public relaySet?: NDKRelaySet;\n    public ndk: NDK;\n    public relaySubscriptions: Map<NDKRelay, Sub>;\n    private debug: debug.Debugger;\n\n    /**\n     * Events that have been seen by the subscription, with the time they were first seen.\n     */\n    public eventFirstSeen = new Map<NDKEventId, number>();\n\n    /**\n     * Relays that have sent an EOSE.\n     */\n    public eosesSeen = new Set<NDKRelay>();\n\n    /**\n     * Events that have been seen by the subscription per relay.\n     */\n    public eventsPerRelay: Map<NDKRelay, Set<NDKEventId>> = new Map();\n\n    public constructor(\n        ndk: NDK,\n        filters: NDKFilter | NDKFilter[],\n        opts?: NDKSubscriptionOptions,\n        relaySet?: NDKRelaySet,\n        subId?: string\n    ) {\n        super();\n        this.ndk = ndk;\n        this.opts = { ...defaultOpts, ...(opts || {}) };\n        this.filters = filters instanceof Array ? filters : [filters];\n        this.subId = subId || opts?.subId || generateFilterId(this.filters[0]);\n\n        this.relaySet = relaySet;\n        this.relaySubscriptions = new Map<NDKRelay, Sub>();\n        this.debug = ndk.debug.extend(`subscription:${this.subId}`);\n\n        // validate that the caller is not expecting a persistent\n        // subscription while using an option that will only hit the cache\n", "        if (\n            this.opts.cacheUsage === NDKSubscriptionCacheUsage.ONLY_CACHE &&\n            !this.opts.closeOnEose\n        ) {\n            throw new Error(\n                \"Cannot use cache-only options with a persistent subscription\"\n            );\n        }\n    }\n\n    /**\n     * Provides access to the first filter of the subscription for\n     * backwards compatibility.\n     */\n    get filter(): NDKFilter {\n        return this.filters[0];\n    }\n\n    /**\n     * Calculates the groupable ID for this subscription.\n     *\n     * @returns The groupable ID, or null if the subscription is not groupable.\n     */\n    public groupableId(): string | null {", "        if (!this.opts?.groupable || this.filters.length > 1) {\n            return null;\n        }\n\n        const filter = this.filters[0];\n\n        // Check if there is a kind and no time-based filters\n        const noTimeConstraints = !filter.since && !filter.until;\n        const noLimit = !filter.limit;\n\n        if (noTimeConstraints && noLimit) {\n            let id = filter.kinds ? filter.kinds.join(\",\") : \"\";\n            const keys = Object.keys(filter || {})\n                .sort()\n                .join(\"-\");\n            id += `-${keys}`;\n\n            return id;\n        }\n\n        return null;\n    }\n\n    private shouldQueryCache(): boolean {\n        return this.opts?.cacheUsage !== NDKSubscriptionCacheUsage.ONLY_RELAY;\n    }\n\n    private shouldQueryRelays(): boolean {\n        return this.opts?.cacheUsage !== NDKSubscriptionCacheUsage.ONLY_CACHE;\n    }\n\n    private shouldWaitForCache(): boolean {\n        return (\n            // Must want to close on EOSE; subscriptions\n            // that want to receive further updates must\n            // always hit the relay\n            this.opts.closeOnEose &&\n            // Cache adapter must claim to be fast\n            !!this.ndk.cacheAdapter?.locking &&\n            // If explicitly told to run in parallel, then\n            // we should not wait for the cache\n            this.opts.cacheUsage !== NDKSubscriptionCacheUsage.PARALLEL\n        );\n    }\n\n    /**\n     * Start the subscription. This is the main method that should be called\n     * after creating a subscription.\n     */\n    public async start(): Promise<void> {\n        let cachePromise;\n", "        if (noTimeConstraints && noLimit) {\n            let id = filter.kinds ? filter.kinds.join(\",\") : \"\";\n            const keys = Object.keys(filter || {})\n                .sort()\n                .join(\"-\");\n            id += `-${keys}`;\n\n            return id;\n        }\n\n        return null;\n    }\n\n    private shouldQueryCache(): boolean {\n        return this.opts?.cacheUsage !== NDKSubscriptionCacheUsage.ONLY_RELAY;\n    }\n\n    private shouldQueryRelays(): boolean {\n        return this.opts?.cacheUsage !== NDKSubscriptionCacheUsage.ONLY_CACHE;\n    }\n\n    private shouldWaitForCache(): boolean {\n        return (\n            // Must want to close on EOSE; subscriptions\n            // that want to receive further updates must\n            // always hit the relay\n            this.opts.closeOnEose &&\n            // Cache adapter must claim to be fast\n            !!this.ndk.cacheAdapter?.locking &&\n            // If explicitly told to run in parallel, then\n            // we should not wait for the cache\n            this.opts.cacheUsage !== NDKSubscriptionCacheUsage.PARALLEL\n        );\n    }\n\n    /**\n     * Start the subscription. This is the main method that should be called\n     * after creating a subscription.\n     */\n    public async start(): Promise<void> {\n        let cachePromise;\n", "        if (this.shouldQueryCache()) {\n            cachePromise = this.startWithCache();\n\n            if (this.shouldWaitForCache()) {\n                await cachePromise;\n\n                // if the cache has a hit, return early\n                if (queryFullyFilled(this)) {\n                    this.emit(\"eose\", this);\n                    return;\n                }\n            }\n        }\n", "        if (this.shouldQueryRelays()) {\n            this.startWithRelaySet();\n        } else {\n            this.emit(\"eose\", this);\n        }\n\n        return;\n    }\n\n    public stop(): void {\n        this.relaySubscriptions.forEach((sub) => sub.unsub());\n        this.relaySubscriptions.clear();\n        this.emit(\"close\", this);\n    }\n\n    private async startWithCache(): Promise<void> {", "        if (this.ndk.cacheAdapter?.query) {\n            const promise = this.ndk.cacheAdapter.query(this);\n\n            if (this.ndk.cacheAdapter.locking) {\n                await promise;\n            }\n        }\n    }\n\n    private startWithRelaySet(): void {\n        if (!this.relaySet) {\n            this.relaySet = calculateRelaySetFromFilter(\n                this.ndk,\n                this.filters[0]\n            );\n        }\n", "        if (!this.relaySet) {\n            this.relaySet = calculateRelaySetFromFilter(\n                this.ndk,\n                this.filters[0]\n            );\n        }\n\n        if (this.relaySet) {\n            this.relaySet.subscribe(this);\n        }\n    }\n\n    // EVENT handling\n\n    /**\n     * Called when an event is received from a relay or the cache\n     * @param event\n     * @param relay\n     * @param fromCache Whether the event was received from the cache\n     */\n    public eventReceived(\n        event: NDKEvent,\n        relay: NDKRelay | undefined,\n        fromCache = false\n    ) {", "        if (relay) event.relay = relay;\n        if (!relay) relay = event.relay;\n\n        if (!fromCache && relay) {\n            // track the event per relay\n            let events = this.eventsPerRelay.get(relay);\n\n            if (!events) {\n                events = new Set();\n                this.eventsPerRelay.set(relay, events);\n            }\n\n            events.add(event.id);\n\n            // mark the event as seen\n            const eventAlreadySeen = this.eventFirstSeen.has(event.id);\n", "            if (eventAlreadySeen) {\n                const timeSinceFirstSeen =\n                    Date.now() - (this.eventFirstSeen.get(event.id) || 0);\n                relay.scoreSlowerEvent(timeSinceFirstSeen);\n\n                this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this);\n\n                return;\n            }\n\n            if (this.ndk.cacheAdapter) {\n                this.ndk.cacheAdapter.setEvent(event, this.filters[0], relay);\n            }\n\n            this.eventFirstSeen.set(`${event.id}`, Date.now());\n        } else {\n            this.eventFirstSeen.set(`${event.id}`, 0);\n        }\n\n        this.emit(\"event\", event, relay, this);\n    }\n\n    // EOSE handling\n    private eoseTimeout: ReturnType<typeof setTimeout> | undefined;\n\n    public eoseReceived(relay: NDKRelay): void {", "            if (this.ndk.cacheAdapter) {\n                this.ndk.cacheAdapter.setEvent(event, this.filters[0], relay);\n            }\n\n            this.eventFirstSeen.set(`${event.id}`, Date.now());\n        } else {\n            this.eventFirstSeen.set(`${event.id}`, 0);\n        }\n\n        this.emit(\"event\", event, relay, this);\n    }\n\n    // EOSE handling\n    private eoseTimeout: ReturnType<typeof setTimeout> | undefined;\n\n    public eoseReceived(relay: NDKRelay): void {", "        if (this.opts?.closeOnEose) {\n            this.relaySubscriptions.get(relay)?.unsub();\n            this.relaySubscriptions.delete(relay);\n\n            // if this was the last relay that needed to EOSE, emit that this subscription is closed\n            if (this.relaySubscriptions.size === 0) {\n                this.emit(\"close\", this);\n            }\n        }\n\n        this.eosesSeen.add(relay);\n\n        const hasSeenAllEoses = this.eosesSeen.size === this.relaySet?.size();\n", "        if (hasSeenAllEoses) {\n            this.emit(\"eose\");\n        } else {\n            if (this.eoseTimeout) {\n                clearTimeout(this.eoseTimeout);\n            }\n\n            this.eoseTimeout = setTimeout(() => {\n                this.emit(\"eose\");\n            }, 500);\n        }\n    }\n}\n\n/**\n * Represents a group of subscriptions.\n *\n * Events emitted from the group will be emitted from each subscription.\n */", "export class NDKSubscriptionGroup extends NDKSubscription {\n    private subscriptions: NDKSubscription[];\n\n    constructor(ndk: NDK, subscriptions: NDKSubscription[]) {\n        const debug = ndk.debug.extend(\"subscription-group\");\n\n        const filters = mergeFilters(subscriptions.map((s) => s.filters[0]));\n\n        super(\n            ndk,\n            filters,\n            subscriptions[0].opts, // TODO: This should be merged\n            subscriptions[0].relaySet // TODO: This should be merged\n        );\n\n        this.subscriptions = subscriptions;\n\n        debug(\"merged filters\", {\n            count: subscriptions.length,\n            mergedFilters: this.filters[0],\n        });\n\n        // forward events to the matching subscriptions\n        this.on(\"event\", this.forwardEvent);\n        this.on(\"event:dup\", this.forwardEventDup);\n        this.on(\"eose\", this.forwardEose);\n        this.on(\"close\", this.forwardClose);\n    }\n\n    private isEventForSubscription(\n        event: NDKEvent,\n        subscription: NDKSubscription\n    ): boolean {\n        const { filters } = subscription;\n", "        if (!filters) return false;\n\n        return matchFilter(filters[0], event.rawEvent() as any);\n\n        // check if there is a filter whose key begins with '#'; if there is, check if the event has a tag with the same key on the first position\n        // of the tags array of arrays and the same value in the second position\n        // for (const key in filter) {\n        //     if (key === 'kinds' && filter.kinds!.includes(event.kind!)) return false;\n        //     else if (key === 'authors' && filter.authors!.includes(event.pubkey)) return false;\n        //     else if (key.startsWith('#')) {\n        //         const tagKey = key.slice(1);\n        //         const tagValue = filter[key];\n", "        //     else if (key === 'authors' && filter.authors!.includes(event.pubkey)) return false;\n        //     else if (key.startsWith('#')) {\n        //         const tagKey = key.slice(1);\n        //         const tagValue = filter[key];\n\n        //         if (event.tags) {\n        //             for (const tag of event.tags) {\n        //                 if (tag[0] === tagKey && tag[1] === tagValue) {\n        //                     return false;\n        //                 }\n        //             }\n        //         }\n        //     }\n\n        // return true;\n    }\n\n    private forwardEvent(event: NDKEvent, relay: NDKRelay) {", "        for (const subscription of this.subscriptions) {\n            if (!this.isEventForSubscription(event, subscription)) {\n                continue;\n            }\n\n            subscription.emit(\"event\", event, relay, subscription);\n        }\n    }\n\n    private forwardEventDup(\n        event: NDKEvent,\n        relay: NDKRelay,\n        timeSinceFirstSeen: number\n    ) {", "        for (const subscription of this.subscriptions) {\n            if (!this.isEventForSubscription(event, subscription)) {\n                continue;\n            }\n\n            subscription.emit(\n                \"event:dup\",\n                event,\n                relay,\n                timeSinceFirstSeen,\n                subscription\n            );\n        }\n    }\n\n    private forwardEose() {", "        for (const subscription of this.subscriptions) {\n            subscription.emit(\"eose\", subscription);\n        }\n    }\n\n    private forwardClose() {\n        for (const subscription of this.subscriptions) {\n            subscription.emit(\"close\", subscription);\n        }\n    }\n}\n\n/**\n * Go through all the passed filters, which should be\n * relatively similar, and merge them.\n */", "export function mergeFilters(filters: NDKFilter[]): NDKFilter {\n    const result: any = {};\n\n    filters.forEach((filter) => {\n        Object.entries(filter).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                if (result[key] === undefined) {\n                    result[key] = [...value];\n                } else {\n                    result[key] = Array.from(\n                        new Set([...result[key], ...value])\n                    );\n                }\n            } else {\n                result[key] = value;\n            }\n        });\n    });\n\n    return result as NDKFilter;\n}\n\n/**\n * Creates a valid nostr filter from an event id or a NIP-19 bech32.\n */", "export function filterFromId(id: string): NDKFilter {\n    let decoded;\n\n    try {\n        decoded = nip19.decode(id);\n\n        switch (decoded.type) {\n            case \"nevent\":\n                return { ids: [decoded.data.id] };\n            case \"note\":\n                return { ids: [decoded.data] };\n            case \"naddr\":\n                return {\n                    authors: [decoded.data.pubkey],\n                    \"#d\": [decoded.data.identifier],\n                    kinds: [decoded.data.kind],\n                };\n        }", "    } catch (e) {}\n\n    return { ids: [id] };\n}\n\n/**\n * Returns the specified relays from a NIP-19 bech32.\n *\n * @param bech32 The NIP-19 bech32.\n */\nexport function relaysFromBech32(bech32: string): NDKRelay[] {", "export function relaysFromBech32(bech32: string): NDKRelay[] {\n    try {\n        const decoded = nip19.decode(bech32);\n\n        if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n            const data = decoded.data as unknown as EventPointer;\n\n            if (data?.relays) {\n                return data.relays.map((r: string) => new NDKRelay(r));\n            }\n        }", "    } catch (e) {\n        /* empty */\n    }\n\n    return [];\n}\n\n/**\n * Generates a random filter id, based on the filter keys.\n */\nfunction generateFilterId(filter: NDKFilter) {\n    const keys = Object.keys(filter) || [];\n    const subId = [];\n", "function generateFilterId(filter: NDKFilter) {\n    const keys = Object.keys(filter) || [];\n    const subId = [];\n\n    for (const key of keys) {\n        if (key === \"kinds\") {\n            const v = [key, filter.kinds!.join(\",\")];\n            subId.push(v.join(\":\"));\n        } else {\n            subId.push(key);\n        }\n    }\n\n    subId.push(Math.floor(Math.random() * 999999999).toString());\n    return subId.join(\"-\");\n}\n"]}
{"filename": "src/cache/index.ts", "chunked_list": ["import NDKEvent from \"../events/index.js\";\nimport { NDKRelay } from \"../relay/index.js\";\nimport { NDKFilter, NDKSubscription } from \"../subscription/index.js\";\n\nexport interface NDKCacheAdapter {\n    /**\n     * Whether this cache adapter is expected to be fast.\n     * If this is true, the cache will be queried before the relays.\n     * When this is false, the cache will be queried in addition to the relays.\n     */\n    locking: boolean;\n\n    query(subscription: NDKSubscription): Promise<void>;\n    setEvent(\n        event: NDKEvent,\n        filter: NDKFilter,\n        relay?: NDKRelay\n    ): Promise<void>;\n}\n"]}
