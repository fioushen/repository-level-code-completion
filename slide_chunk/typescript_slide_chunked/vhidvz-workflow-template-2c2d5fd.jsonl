{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from './../src/app.module';\n\ndescribe('AppController (e2e)', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({", "  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('/ (GET)', () => {", "\n  it('/ (GET)', () => {\n    return request(app.getHttpServer())\n      .get('/')\n      .expect(200)\n      .expect('Hello World!');\n  });\n});\n", ""]}
{"filename": "src/main.ts", "chunked_list": ["import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  app.useGlobalPipes(new ValidationPipe());\n\n  const config = new DocumentBuilder()\n    .setTitle(process.env.npm_package_name)\n    .setVersion(process.env.npm_package_version)\n    .setDescription(process.env.npm_package_description)\n    .build();\n\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api', app, document);\n\n  await app.listen(3000);\n\n  console.log(`Swagger UI is running on: ${await app.getUrl()}/api`);\n}\nbootstrap();\n"]}
{"filename": "src/app.workflow.ts", "chunked_list": ["import { Act, Data, Node, Process, Value } from '@vhidvz/wfjs/common';\nimport {\n  EventActivity,\n  GatewayActivity,\n  TaskActivity,\n} from '@vhidvz/wfjs/core';\nimport { Data as DataFlow, Value as ValueFlow } from './schemas';\nimport { AppProvider } from './app.provider';\nimport { Injectable } from '@nestjs/common';\nimport { WorkflowJS } from '@vhidvz/wfjs';", "import { Injectable } from '@nestjs/common';\nimport { WorkflowJS } from '@vhidvz/wfjs';\nimport { join } from 'path';\n\n@Injectable()\n@Process({ name: 'Simple Workflow', path: join(__dirname, 'app.flow.bpmn') })\nexport class AppWorkflow extends WorkflowJS {\n  constructor(private readonly appProvider: AppProvider) {\n    super();\n  }\n\n  @Node({ name: 'start' })\n  async start(@Act() activity: EventActivity) {\n    activity.takeOutgoing();\n  }\n\n  @Node({ name: 'approval_gateway', pause: true })\n  async approvalGateway(\n    @Data() data: DataFlow,\n    @Value() value: ValueFlow,\n    @Act() activity: GatewayActivity,\n  ) {\n    data.global = `${data.global}, ${await this.appProvider.getHello(\n      value.local,\n    )}`;\n", "    if (value.local !== 'no')\n      activity.takeOutgoing({ name: 'parallel_gateway' });\n    else activity.takeOutgoing({ name: 'some_task' }, { pause: true });\n  }\n\n  @Node({ name: 'some_task' })\n  async someTask(@Value() value: ValueFlow, @Act() activity: TaskActivity) {\n    activity.takeOutgoing();\n\n    return { local: `some value(${value.local}) to end event.` };\n  }\n\n  @Node({ name: 'parallel_gateway' })\n  async parallelGateway(@Act() activity: GatewayActivity) {\n    activity.takeOutgoing(null, { pause: 'another_task' });\n  }\n\n  @Node({ name: 'another_task' })\n  async anotherTask(@Act() activity: TaskActivity) {\n    activity.takeOutgoing();\n  }\n\n  @Node({ name: 'review', pause: true })\n  async review(@Value() value: ValueFlow, @Act() activity: TaskActivity) {\n    activity.takeOutgoing();\n\n    return { local: `${value.local} to end event.` };\n  }\n\n  @Node({ name: 'end' })\n  async end(@Data() data: DataFlow, @Value() value: ValueFlow) {\n    data.global = `${data.global}, received a value from previous task(${value.local})`;\n  }\n}\n"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { HttpException, HttpStatus, Injectable } from '@nestjs/common';\nimport { AppRepository } from './app.repository';\nimport { AppWorkflow } from './app.workflow';\nimport { Data, Value } from './schemas';\nimport { Context } from '@vhidvz/wfjs';\n\n@Injectable()\nexport class AppService {\n  constructor(\n    private readonly appWorkflow: AppWorkflow,\n    private readonly appRepository: AppRepository,\n  ) {}\n\n  /**", "   * This is an asynchronous function that returns the result of finding an item with a specific ID in\n   * the app repository.\n   *\n   * @param {string} id - The `id` parameter is a string that represents the unique identifier of an\n   * entity that we want to find in the database. The `find` method is used to retrieve an entity from\n   * the database based on its `id`. The `async` keyword indicates that the method returns a promise\n   * that resolves to\n   *\n   * @returns The `find` method is being called on the `appRepository` object with the `id` parameter,\n   * and the result of that method call is being returned. The `await` keyword is used to wait for the\n   * `find` method to complete before returning its result. The specific data type of the returned\n   * value is not specified in the code snippet.\n   */\n  async find(id: string) {\n    return await this.appRepository.find(id);\n  }\n\n  /**", "   * `find` method to complete before returning its result. The specific data type of the returned\n   * value is not specified in the code snippet.\n   */\n  async find(id: string) {\n    return await this.appRepository.find(id);\n  }\n\n  /**\n   * This function creates a new item in the app repository using data passed in and the context\n   * returned from executing the app workflow.\n   *\n   * @param {string} data - The `data` parameter is a string that is passed as an argument to the\n   * `create` method. It is then used as input to the `execute` method of the `appWorkflow` object. The\n   * `context` object returned from the `execute` method is then used as input to the\n   *\n   * @returns The `create` method is returning the result of calling the `create` method of the\n   * `appRepository` with the `context` object obtained from executing the `appWorkflow` with the\n   * provided `data` parameter.\n   */\n  async create(data: Data) {\n    // if you have only one start point this is OK\n    const { context } = await this.appWorkflow.execute({ data });\n\n    return this.appRepository.create(context.serialize());\n  }\n\n  /**", "   * This function creates a new item in the app repository using data passed in and the context\n   * returned from executing the app workflow.\n   *\n   * @param {string} data - The `data` parameter is a string that is passed as an argument to the\n   * `create` method. It is then used as input to the `execute` method of the `appWorkflow` object. The\n   * `context` object returned from the `execute` method is then used as input to the\n   *\n   * @returns The `create` method is returning the result of calling the `create` method of the\n   * `appRepository` with the `context` object obtained from executing the `appWorkflow` with the\n   * provided `data` parameter.\n   */\n  async create(data: Data) {\n    // if you have only one start point this is OK\n    const { context } = await this.appWorkflow.execute({ data });\n\n    return this.appRepository.create(context.serialize());\n  }\n\n  /**", "   * This is an async function that updates an app's context based on a given activity and value.\n   *\n   * @param {string} id - The ID of the app that needs to be updated.\n   * @param {string} activity - The `activity` parameter is a string that represents the name of the\n   * activity that needs to be executed in the workflow.\n   * @param {string} value - The value parameter is a string that represents the input value to be\n   * passed to the appWorkflow.execute() method. It is used to update the context of the app with the\n   * result of the workflow execution.\n   *\n   * @returns The `update` method is returning the updated context after executing the specified\n   * activity on the given id.\n   */\n  async update(id: string, activity: string, value: Value) {", "    try {\n      const ctx = await this.appRepository.find(id);\n\n      if (!ctx)\n        throw new HttpException(\n          'flow with given id dose not exist',\n          HttpStatus.BAD_REQUEST,\n        );\n\n      const { context } = await this.appWorkflow.execute({\n        value,\n        node: { name: activity },\n        context: Context.deserialize(ctx.toJSON()),\n      });\n\n      return this.appRepository.update(id, context.serialize());", "    } catch (error) {\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\n    }\n  }\n}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { MongooseModule } from '@nestjs/mongoose';\nimport { AppController } from './app.controller';\nimport { AppRepository } from './app.repository';\nimport { AppWorkflow } from './app.workflow';\nimport { AppProvider } from './app.provider';\nimport { App, AppSchema } from './schemas';\nimport { AppService } from './app.service';\nimport { Module } from '@nestjs/common';\n\n@Module({", "\n@Module({\n  imports: [\n    MongooseModule.forRoot('mongodb://localhost/nest'),\n    MongooseModule.forFeature([{ name: App.name, schema: AppSchema }]),\n  ],\n  controllers: [AppController],\n  providers: [AppService, AppWorkflow, AppRepository, AppProvider],\n})\nexport class AppModule {}\n", "})\nexport class AppModule {}\n"]}
{"filename": "src/app.provider.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppProvider {\n  async getHello(value: string): Promise<string> {\n    return `Hello ${value}!`;\n  }\n}\n"]}
{"filename": "src/app.constants.ts", "chunked_list": ["export const ACTIVITY_LIST = [\n  'another_task',\n  'approval_gateway',\n  'parallel_gateway',\n  'review',\n  'some_task',\n];\n"]}
{"filename": "src/app.repository.ts", "chunked_list": ["import { ContextInterface } from '@vhidvz/wfjs';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Injectable } from '@nestjs/common';\nimport { Model } from 'mongoose';\nimport { App } from './schemas';\n\n@Injectable()\nexport class AppRepository {\n  constructor(@InjectModel(App.name) private appModel: Model<App>) {}\n\n  async find(id: string) {\n    return this.appModel.findById(id);\n  }\n\n  async create(context: ContextInterface) {\n    return this.appModel.create(context);\n  }\n\n  async update(id: string, context: ContextInterface) {\n    return this.appModel.findByIdAndUpdate(id, context, { new: true });\n  }\n}\n"]}
{"filename": "src/app.controller.ts", "chunked_list": ["import { Body, Controller, Get, Param, Patch, Post } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { DataDto, ValueDto } from './dto';\nimport { ActivityPipe } from './pipes';\nimport { App } from './schemas';\nimport { ApiTags } from '@nestjs/swagger';\n\n@ApiTags('workflows')\n@Controller('flow')\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get(':id')\n  async find(@Param('id') id: string): Promise<App> {\n    return this.appService.find(id);\n  }\n\n  @Post()\n  async create(@Body() data: DataDto): Promise<App> {\n    return this.appService.create(data);\n  }\n\n  @Patch(':id/:activity')\n  async update(\n    @Body() value: ValueDto,\n    @Param('id') id: string,\n    @Param('activity', ActivityPipe) activity: string,\n  ): Promise<App> {\n    return this.appService.update(id, activity, value);\n  }\n}\n", "@Controller('flow')\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get(':id')\n  async find(@Param('id') id: string): Promise<App> {\n    return this.appService.find(id);\n  }\n\n  @Post()\n  async create(@Body() data: DataDto): Promise<App> {\n    return this.appService.create(data);\n  }\n\n  @Patch(':id/:activity')\n  async update(\n    @Body() value: ValueDto,\n    @Param('id') id: string,\n    @Param('activity', ActivityPipe) activity: string,\n  ): Promise<App> {\n    return this.appService.update(id, activity, value);\n  }\n}\n"]}
{"filename": "src/schemas/token.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { State, StateSchema } from './state.schema';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { TokenInterface } from '@vhidvz/wfjs';\n\n@Schema({ _id: false })\nexport class Token implements TokenInterface {\n  @ApiProperty()\n  @Prop({ type: String })\n  id: string;\n\n  @ApiProperty()\n  @Prop({ type: String })\n  parent?: string;\n\n  @ApiProperty()\n  @Prop({ type: Boolean })\n  locked?: boolean;\n\n  @ApiProperty({ type: [State] })\n  @Prop({ type: [StateSchema] })\n  history: State[];\n}\n\nexport const TokenSchema = SchemaFactory.createForClass(Token);\n"]}
{"filename": "src/schemas/app.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Token, TokenSchema } from './token.schema';\nimport { ContextInterface } from '@vhidvz/wfjs';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { HydratedDocument } from 'mongoose';\nimport { Data } from './data.schema';\nimport { Status } from 'src/enums';\n\n@Schema()\nexport class App implements ContextInterface {\n  @ApiProperty()\n  @Prop({ type: Data, required: true, index: true })\n  data: Data;\n\n  @ApiProperty({ enum: Status })\n  @Prop({ type: String, enum: Status, required: true })\n  status: Status;\n\n  @ApiProperty({ type: [Token] })\n  @Prop({ type: [TokenSchema], required: true })\n  tokens: Token[];\n}\n", "@Schema()\nexport class App implements ContextInterface {\n  @ApiProperty()\n  @Prop({ type: Data, required: true, index: true })\n  data: Data;\n\n  @ApiProperty({ enum: Status })\n  @Prop({ type: String, enum: Status, required: true })\n  status: Status;\n\n  @ApiProperty({ type: [Token] })\n  @Prop({ type: [TokenSchema], required: true })\n  tokens: Token[];\n}\n", "export type AppDocument = HydratedDocument<App>;\nexport const AppSchema = SchemaFactory.createForClass(App);\n"]}
{"filename": "src/schemas/state.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { StateInterface } from '@vhidvz/wfjs';\nimport { Value } from './value.schema';\nimport { Status } from 'src/enums';\n\n@Schema({ _id: false })\nexport class State implements StateInterface {\n  @ApiProperty()\n  @Prop({ type: String })\n  ref: string;\n\n  @ApiProperty()\n  @Prop({ type: String, required: false })\n  name?: string;\n\n  @ApiProperty({ enum: Status })\n  @Prop({ type: String, enum: Status })\n  status: Status;\n\n  @ApiProperty()\n  @Prop({ type: Value, required: false })\n  value?: Value;\n}\n\nexport const StateSchema = SchemaFactory.createForClass(State);\n"]}
{"filename": "src/schemas/data.schema.ts", "chunked_list": ["import { Prop, Schema } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\n\n@Schema({ _id: false })\nexport class Data {\n  @ApiProperty()\n  @Prop({ type: String, required: true, trim: true, minlength: 1 })\n  global: string;\n}\n"]}
{"filename": "src/schemas/index.ts", "chunked_list": ["export * from './app.schema';\nexport * from './data.schema';\nexport * from './value.schema';\n"]}
{"filename": "src/schemas/value.schema.ts", "chunked_list": ["import { Prop, Schema } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\n\n@Schema({ _id: false })\nexport class Value {\n  @ApiProperty()\n  @Prop({ type: String, required: true, trim: true, minlength: 1 })\n  local: string;\n}\n"]}
{"filename": "src/pipes/activity.pipe.ts", "chunked_list": ["import { BadRequestException, Injectable, PipeTransform } from '@nestjs/common';\nimport { ACTIVITY_LIST } from 'src/app.constants';\n\n@Injectable()\nexport class ActivityPipe implements PipeTransform {\n  transform(value: string): string {\n    if (!ACTIVITY_LIST.includes(value)) {\n      throw new BadRequestException('Invalid Activity');\n    }\n\n    return value;\n  }\n}\n"]}
{"filename": "src/pipes/index.ts", "chunked_list": ["export * from './activity.pipe';\n"]}
{"filename": "src/enums/index.ts", "chunked_list": ["export * from './status.enum';\n"]}
{"filename": "src/enums/status.enum.ts", "chunked_list": ["export enum Status {\n  Completed = 'completed',\n  Failed = 'failed',\n  Paused = 'paused',\n  Ready = 'ready',\n  Running = 'running',\n  Terminated = 'terminated',\n}\n"]}
{"filename": "src/dto/data.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString } from 'class-validator';\n\nexport class DataDto {\n  @IsString()\n  @IsNotEmpty()\n  global: string;\n}\n"]}
{"filename": "src/dto/value.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString } from 'class-validator';\n\nexport class ValueDto {\n  @IsString()\n  @IsNotEmpty()\n  local: string;\n}\n"]}
{"filename": "src/dto/index.ts", "chunked_list": ["export * from './data.dto';\nexport * from './value.dto';\n"]}
