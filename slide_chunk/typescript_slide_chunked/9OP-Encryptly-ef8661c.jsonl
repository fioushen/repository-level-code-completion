{"filename": "vite.config.ts", "chunked_list": ["import react from '@vitejs/plugin-react-swc';\nimport { resolve } from 'path';\nimport { defineConfig } from 'vite';\nimport eslint from 'vite-plugin-eslint';\n\nimport { dependencies } from './package.json';\n\nconst projectRootDir = resolve(__dirname);\n\nconst BASE_CHUNKS = {", "\nconst BASE_CHUNKS = {\n  vendor: ['react', 'react-router-dom', 'react-dom', 'swr', 'react-icons'],\n  ui: ['@chakra-ui/react', '@emotion/react'],\n};\n\nfunction renderChunks(deps: Record<string, string>) {\n  const chunks = {};\n  const alreadySplit = Object.values(BASE_CHUNKS).reduce((acc, l) => acc.concat(l), []);\n  Object.keys(deps).forEach((key) => {\n    if (alreadySplit.includes(key)) return;\n    chunks[key] = [key];\n  });\n  return chunks;\n}\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    {\n      // default settings on build (i.e. fail on error)\n      ...eslint(),\n      apply: 'build',\n    },\n    {\n      // do not fail on serve (i.e. local development)\n      ...eslint({\n        failOnWarning: false,\n        failOnError: false,\n        fix: true,\n      }),\n      apply: 'serve',\n      enforce: 'post',\n    },\n    // splitVendorChunkPlugin(),\n  ],\n  // base: \"/Encryptly/\",\n  resolve: {\n    alias: { '@app': resolve(projectRootDir, '/src') },\n  },\n  server: {\n    host: '0.0.0.0',\n    port: 3000,\n    open: false,\n    cors: true,\n  },\n  preview: {\n    host: '0.0.0.0',\n    port: 3000,\n  },\n  build: {\n    outDir: 'dist',\n    sourcemap: false,\n    rollupOptions: {\n      cache: true,\n      output: {\n        format: 'esm',\n        manualChunks: {\n          ...BASE_CHUNKS,\n          ...renderChunks(dependencies),\n        },\n      },\n    },\n  },\n});\n", "    if (alreadySplit.includes(key)) return;\n    chunks[key] = [key];\n  });\n  return chunks;\n}\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    {\n      // default settings on build (i.e. fail on error)\n      ...eslint(),\n      apply: 'build',\n    },\n    {\n      // do not fail on serve (i.e. local development)\n      ...eslint({\n        failOnWarning: false,\n        failOnError: false,\n        fix: true,\n      }),\n      apply: 'serve',\n      enforce: 'post',\n    },\n    // splitVendorChunkPlugin(),\n  ],\n  // base: \"/Encryptly/\",\n  resolve: {\n    alias: { '@app': resolve(projectRootDir, '/src') },\n  },\n  server: {\n    host: '0.0.0.0',\n    port: 3000,\n    open: false,\n    cors: true,\n  },\n  preview: {\n    host: '0.0.0.0',\n    port: 3000,\n  },\n  build: {\n    outDir: 'dist',\n    sourcemap: false,\n    rollupOptions: {\n      cache: true,\n      output: {\n        format: 'esm',\n        manualChunks: {\n          ...BASE_CHUNKS,\n          ...renderChunks(dependencies),\n        },\n      },\n    },\n  },\n});\n"]}
{"filename": "src/theme.ts", "chunked_list": ["import { ComponentStyleConfig, extendTheme } from '@chakra-ui/react';\n\nconst AlertStyle: ComponentStyleConfig = {\n  // style object for base or default style\n  baseStyle: {\n    container: {\n      borderWidth: '3px',\n      borderRadius: '6px',\n      borderColor: 'black',\n      // maxWidth: \"25rem\",", "      borderColor: 'black',\n      // maxWidth: \"25rem\",\n      padding: '1rem',\n      boxShadow: 'none',\n    },\n    title: {\n      fontWeight: 'bold',\n      fontSize: 'lg',\n      marginBottom: '.8rem',\n    },", "      marginBottom: '.8rem',\n    },\n    description: {\n      fontSize: 'sm',\n      fontWeight: 'medium',\n      lineHeight: '1rem',\n    },\n  },\n  // styles for different sizes (\"sm\", \"md\", \"lg\")\n  sizes: {},", "  // styles for different sizes (\"sm\", \"md\", \"lg\")\n  sizes: {},\n  // styles for different visual variants (\"outline\", \"solid\")\n  variants: {},\n  // default values for 'size', 'variant' and 'colorScheme'\n  defaultProps: {\n    variant: 'solid',\n  },\n};\n", "};\n\nconst ButtonStyle: ComponentStyleConfig = {\n  baseStyle: {},\n  sizes: {},\n  variants: {\n    solid: {\n      borderRadius: '0',\n      borderWidth: '3px',\n      borderColor: 'black',", "      borderWidth: '3px',\n      borderColor: 'black',\n      boxShadow: '-8px 8px 0px 0px #000',\n      _hover: {\n        boxShadow: 'none',\n      },\n    },\n  },\n  defaultProps: {},\n};", "  defaultProps: {},\n};\n\nconst InputStyle: ComponentStyleConfig = {\n  baseStyle: {\n    field: {\n      borderRadius: '10px',\n      borderWidth: '3px!important',\n      borderColor: 'black',\n      boxShadow: '-4px 4px 0px 0px #000',", "      borderColor: 'black',\n      boxShadow: '-4px 4px 0px 0px #000',\n      _hover: { boxShadow: 'none' },\n    },\n    addon: {\n      border: '3px solid',\n    },\n  },\n  sizes: {},\n  variants: {},", "  sizes: {},\n  variants: {},\n  defaultProps: {},\n};\n\nconst CardStyle: ComponentStyleConfig = {\n  baseStyle: {\n    padding: '1.5rem',\n    borderWidth: '3px',\n    borderRadius: '10px',", "    borderWidth: '3px',\n    borderRadius: '10px',\n    borderColor: 'black',\n    boxShadow: '-4px 4px 0px 0px #000',\n  },\n  sizes: {},\n  variants: {},\n  defaultProps: {},\n};\n", "};\n\nconst ModalStyle: ComponentStyleConfig = {\n  baseStyle: {\n    dialog: {\n      color: 'white',\n      borderWidth: '3px',\n      borderRadius: '10px',\n      borderColor: 'black',\n      boxShadow: '-4px 4px 0px 0px #000',", "      borderColor: 'black',\n      boxShadow: '-4px 4px 0px 0px #000',\n    },\n  },\n  sizes: {},\n  variants: {},\n  defaultProps: {},\n};\n\nconst theme = extendTheme({", "\nconst theme = extendTheme({\n  fonts: {\n    heading: `'Cispeo'`,\n    body: `'Cispeo'`,\n  },\n  components: {\n    Alert: AlertStyle,\n    Button: ButtonStyle,\n    Input: InputStyle,", "    Button: ButtonStyle,\n    Input: InputStyle,\n    Card: CardStyle,\n    Modal: ModalStyle,\n  },\n});\n\nexport default theme;\n", ""]}
{"filename": "src/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\ninterface Error {\n  status?: number;\n  info?: string;\n}\n"]}
{"filename": "src/lib/files.ts", "chunked_list": ["export const saveFile = (\n  fileData: BlobPart[],\n  name: string,\n  type: string,\n  ref: React.RefObject<HTMLAnchorElement>,\n) => {\n  const file = new File(fileData, name, {\n    type,\n  });\n  const objectUrl = URL.createObjectURL(file);", "  });\n  const objectUrl = URL.createObjectURL(file);\n\n  if (ref.current) {\n    ref.current.href = objectUrl;\n    ref.current.download = name;\n    ref.current.click();\n  }\n};\n\nexport const handleDataItem = async (items: DataTransferItem[]) => {\n  const files: File[] = [];\n", "  for (let i = 0; i < items.length; i++) {\n    const item = items[0].webkitGetAsEntry();\n\n    if (!item) {\n      continue;\n    }\n\n    switch (true) {\n      case item.isFile: {\n        const file = await getFile(item as FileSystemFileEntry);\n        files.push(file);\n        break;\n      }\n\n      case item.isDirectory: {\n        const tree: File[] = [];\n        await traverseFileTree(item as FileSystemDirectoryEntry, '', tree);\n        const archive = await createArchive(tree);\n        const archiveFile = new File([archive], item.name + '.zip', {\n          type: 'application/zip',\n        });\n        files.push(archiveFile);\n        break;\n      }\n\n      default:\n        break;\n    }\n  }\n\n  return files;\n};\n\nconst getFile = async (fileEntry: FileSystemFileEntry): Promise<File> => {\n  return new Promise((resolve, reject) => fileEntry.file(resolve, reject));\n};\n\nconst traverseFileTree = async (\n  item: FileSystemFileEntry | FileSystemDirectoryEntry | FileSystemEntry,\n  path: string,\n  acc: File[],\n) => {\n  path = path || '';\n\n  switch (true) {\n    case item.isFile: {\n      const file = await getFile(item as FileSystemFileEntry);\n      acc.push(new File([file], path + file.name, { type: file.type }));\n      return;\n    }\n\n    case item.isDirectory: {\n      const dirReader = (item as FileSystemDirectoryEntry).createReader();\n      const entries = await readEntries(dirReader);", "      for (const entry of entries) {\n        await traverseFileTree(entry, path + item.name + '/', acc);\n      }\n      return;\n    }\n\n    default:\n      return;\n  }\n};\n\nconst readEntries = (reader: FileSystemDirectoryReader): Promise<FileSystemEntry[]> => {\n  return new Promise((resolve, _) => {\n    reader.readEntries((entries) => {\n      resolve(entries);\n    });\n  });\n};\n\n/**\n * Investigate which format to use: .zip or .tar\n * Check for better/lighter library for archiving multiple File into a single one\n */\nconst createArchive = async (files: File[]) => {\n  const { BlobReader, BlobWriter, ZipWriter } = await import('@zip.js/zip.js');\n\n  const zipFileWriter = new BlobWriter();\n  const zipWriter = new ZipWriter(zipFileWriter);\n", "  for (const file of files) {\n    await zipWriter.add(file.name, new BlobReader(file));\n  }\n\n  await zipWriter.close();\n  const zipFileBlob = await zipFileWriter.getData();\n  return zipFileBlob;\n};\n"]}
{"filename": "src/lib/promisify.ts", "chunked_list": ["const promisify = <T, K>(worker: Worker, args: T): Promise<K> => {\n  return new Promise((resolve, reject) => {\n    try {\n      worker.onmessage = (result) => {\n        resolve(result.data);\n        worker.terminate();\n      };\n\n      worker.onerror = (error) => {\n        reject(error);\n        worker.terminate();\n      };\n\n      worker.postMessage(args);", "    } catch (error) {\n      reject(error);\n      worker.terminate();\n    }\n  });\n};\n\nexport default promisify;\n"]}
{"filename": "src/lib/formatBytes.ts", "chunked_list": ["const formatBytes = (bytes: number, decimals = 2): string => {\n  if (!+bytes) return '0 Bytes';\n\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n};\n\nexport default formatBytes;\n"]}
{"filename": "src/lib/storage.ts", "chunked_list": ["const ACCESS_TOKEN = 'ACCESS_TOKEN';\n\nexport const getStorageAccessToken = (): string => {\n  return sessionStorage.getItem(ACCESS_TOKEN) || '';\n};\n\nexport const setStorageAccessToken = (token: string) => {\n  sessionStorage.setItem(ACCESS_TOKEN, token);\n};\n", "};\n\nexport const delStorageAccessToken = () => {\n  sessionStorage.removeItem(ACCESS_TOKEN);\n};\n"]}
{"filename": "src/lib/authorizationUrl.ts", "chunked_list": ["const APP_SCOPES = [\n  'https://www.googleapis.com/auth/drive.file',\n  'https://www.googleapis.com/auth/drive.appdata',\n  'https://www.googleapis.com/auth/userinfo.email',\n];\n\nexport const verifyScopes = (scopes: string[]): boolean => {\n  for (const scope of APP_SCOPES) {\n    if (!scopes.includes(scope)) return false;\n  }\n  return true;\n};\n\nexport const getAuthorizationUrl = (): string => {\n  // Documentation:\n  // https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow#creatingclient\n\n  const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;\n  const redirectUri = import.meta.env.VITE_REDIRECT_URI;\n\n  const url =\n    'https://accounts.google.com/o/oauth2/v2/auth?' +\n    'access_type=online&' +\n    'prompt=select_account&' +\n    'response_type=token&' +\n    'include_granted_scopes=true&' +\n    `client_id=${clientId}&` +\n    `scope=${APP_SCOPES.join(' ')}&` +\n    `redirect_uri=${redirectUri}&`;\n\n  return url;\n};\n", "    if (!scopes.includes(scope)) return false;\n  }\n  return true;\n};\n\nexport const getAuthorizationUrl = (): string => {\n  // Documentation:\n  // https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow#creatingclient\n\n  const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;\n  const redirectUri = import.meta.env.VITE_REDIRECT_URI;\n\n  const url =\n    'https://accounts.google.com/o/oauth2/v2/auth?' +\n    'access_type=online&' +\n    'prompt=select_account&' +\n    'response_type=token&' +\n    'include_granted_scopes=true&' +\n    `client_id=${clientId}&` +\n    `scope=${APP_SCOPES.join(' ')}&` +\n    `redirect_uri=${redirectUri}&`;\n\n  return url;\n};\n"]}
{"filename": "src/lib/crypto.ts", "chunked_list": ["import { WrappedKey } from '@app/models';\n\n// Recommended nonce byte lenght for AES-GCM 256bytes\nconst NONCE_SIZE = 12;\n\n// Store a 1 byte VERSION flag in\n// for backward compatibility\nconst VERSION = 0x01;\nconst VERSION_SIZE = 1;\n", "const VERSION_SIZE = 1;\n\nexport const decrypt = async (data: Blob, key: CryptoKey): Promise<Blob> => {\n  const buff = await data.arrayBuffer();\n\n  const version = buff.slice(0, VERSION_SIZE);\n  const iv = buff.slice(VERSION_SIZE, NONCE_SIZE + VERSION_SIZE);\n  const cipher = buff.slice(NONCE_SIZE + VERSION_SIZE);\n\n  if (VERSION !== new Uint8Array(version)[0]) {\n    throw new Error('File version not recognized');\n  }\n\n  const decrypted = await self.crypto.subtle.decrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    cipher,\n  );\n  return new Blob([decrypted]);\n};\n\nexport const encrypt = async (data: Blob, key: CryptoKey): Promise<Blob> => {\n  const iv = self.crypto.getRandomValues(new Uint8Array(NONCE_SIZE));\n  const plain = await data.arrayBuffer();\n  const encrypted = await self.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plain);\n  return new Blob([new Uint8Array([VERSION]).buffer, iv.buffer, encrypted]);\n};\n\nexport const generateEncryptionKey = async () => {\n  const key = await self.crypto.subtle.generateKey(\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n  return key;\n};\n\nconst getKeyMaterial = async (passphrase: string): Promise<CryptoKey> => {\n  const enc = new TextEncoder();\n  return self.crypto.subtle.importKey(\n    'raw',\n    enc.encode(passphrase),\n    { name: 'PBKDF2' },\n    false,\n    ['deriveBits', 'deriveKey'],\n  );\n};\n\nconst getWrapKey = async (keyMaterial: CryptoKey, salt: Uint8Array) => {\n  return self.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt,\n      iterations: 100000,\n      hash: 'SHA-256',\n    },\n    keyMaterial,\n    { name: 'AES-KW', length: 256 },\n    true,\n    ['wrapKey', 'unwrapKey'],\n  );\n};\n\nexport const wrapEncryptionKey = async (\n  encryptionKey: CryptoKey,\n  passphrase: string,\n): Promise<WrappedKey> => {\n  const keyMaterial = await getKeyMaterial(passphrase);\n  const salt = self.crypto.getRandomValues(new Uint8Array(16));\n  const wrapKey = await getWrapKey(keyMaterial, salt);\n  const key = await self.crypto.subtle.wrapKey('raw', encryptionKey, wrapKey, 'AES-KW');\n  return {\n    enc: toB64(key),\n    salt: [...salt],\n  };\n};\n\nexport const unwrapEncryptionKey = async (\n  wrappedKey: WrappedKey,\n  passphrase: string,\n): Promise<CryptoKey> => {\n  const salt = new Uint8Array(wrappedKey.salt);\n  const keyMaterial = await getKeyMaterial(passphrase);\n  const wrapKey = await getWrapKey(keyMaterial, salt);\n  return self.crypto.subtle.unwrapKey(\n    'raw',\n    fromB64(wrappedKey.enc),\n    wrapKey,\n    'AES-KW',\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n};\n\nexport const exportEncryptionKey = async (encryptionKey: CryptoKey): Promise<string> => {\n  return toB64(await self.crypto.subtle.exportKey('raw', encryptionKey));\n};\n\nexport const importEncryptionKey = async (encryptionKey: string): Promise<CryptoKey> => {\n  return self.crypto.subtle.importKey(\n    'raw',\n    fromB64(encryptionKey),\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n};\n\nexport const sha256 = async (str: string): Promise<string> => {\n  const digest = await self.crypto.subtle.digest('SHA-512', fromB64(str));\n  return toB64(digest);\n};\n\nconst toB64 = (buf: ArrayBuffer): string => {\n  return self.btoa(\n    new Uint8Array(buf).reduce((data, byte) => data + String.fromCharCode(byte), ''),\n  );\n};\n\nconst fromB64 = (buf: string): ArrayBuffer => {\n  return new Uint8Array(\n    [...self.atob(buf)].reduce(\n      (data, char) => data.concat([char.charCodeAt(0)]),\n      [] as number[],\n    ),\n  ).buffer;\n};\n", "\n  if (VERSION !== new Uint8Array(version)[0]) {\n    throw new Error('File version not recognized');\n  }\n\n  const decrypted = await self.crypto.subtle.decrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    cipher,\n  );\n  return new Blob([decrypted]);\n};\n\nexport const encrypt = async (data: Blob, key: CryptoKey): Promise<Blob> => {\n  const iv = self.crypto.getRandomValues(new Uint8Array(NONCE_SIZE));\n  const plain = await data.arrayBuffer();\n  const encrypted = await self.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plain);\n  return new Blob([new Uint8Array([VERSION]).buffer, iv.buffer, encrypted]);\n};\n\nexport const generateEncryptionKey = async () => {\n  const key = await self.crypto.subtle.generateKey(\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n  return key;\n};\n\nconst getKeyMaterial = async (passphrase: string): Promise<CryptoKey> => {\n  const enc = new TextEncoder();\n  return self.crypto.subtle.importKey(\n    'raw',\n    enc.encode(passphrase),\n    { name: 'PBKDF2' },\n    false,\n    ['deriveBits', 'deriveKey'],\n  );\n};\n\nconst getWrapKey = async (keyMaterial: CryptoKey, salt: Uint8Array) => {\n  return self.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt,\n      iterations: 100000,\n      hash: 'SHA-256',\n    },\n    keyMaterial,\n    { name: 'AES-KW', length: 256 },\n    true,\n    ['wrapKey', 'unwrapKey'],\n  );\n};\n\nexport const wrapEncryptionKey = async (\n  encryptionKey: CryptoKey,\n  passphrase: string,\n): Promise<WrappedKey> => {\n  const keyMaterial = await getKeyMaterial(passphrase);\n  const salt = self.crypto.getRandomValues(new Uint8Array(16));\n  const wrapKey = await getWrapKey(keyMaterial, salt);\n  const key = await self.crypto.subtle.wrapKey('raw', encryptionKey, wrapKey, 'AES-KW');\n  return {\n    enc: toB64(key),\n    salt: [...salt],\n  };\n};\n\nexport const unwrapEncryptionKey = async (\n  wrappedKey: WrappedKey,\n  passphrase: string,\n): Promise<CryptoKey> => {\n  const salt = new Uint8Array(wrappedKey.salt);\n  const keyMaterial = await getKeyMaterial(passphrase);\n  const wrapKey = await getWrapKey(keyMaterial, salt);\n  return self.crypto.subtle.unwrapKey(\n    'raw',\n    fromB64(wrappedKey.enc),\n    wrapKey,\n    'AES-KW',\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n};\n\nexport const exportEncryptionKey = async (encryptionKey: CryptoKey): Promise<string> => {\n  return toB64(await self.crypto.subtle.exportKey('raw', encryptionKey));\n};\n\nexport const importEncryptionKey = async (encryptionKey: string): Promise<CryptoKey> => {\n  return self.crypto.subtle.importKey(\n    'raw',\n    fromB64(encryptionKey),\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n};\n\nexport const sha256 = async (str: string): Promise<string> => {\n  const digest = await self.crypto.subtle.digest('SHA-512', fromB64(str));\n  return toB64(digest);\n};\n\nconst toB64 = (buf: ArrayBuffer): string => {\n  return self.btoa(\n    new Uint8Array(buf).reduce((data, byte) => data + String.fromCharCode(byte), ''),\n  );\n};\n\nconst fromB64 = (buf: string): ArrayBuffer => {\n  return new Uint8Array(\n    [...self.atob(buf)].reduce(\n      (data, char) => data.concat([char.charCodeAt(0)]),\n      [] as number[],\n    ),\n  ).buffer;\n};\n"]}
{"filename": "src/lib/webworkers/encrypt.worker.ts", "chunked_list": ["import { encrypt, importEncryptionKey } from '@app/lib/crypto';\n\nself.onmessage = async function (e) {\n  try {\n    const { file, key }: { file: File; key: string } = e.data;\n    const importKey = await importEncryptionKey(key);\n    const encrypted = await encrypt(file, importKey);\n    self.postMessage(encrypted);\n  } catch (err) {\n    self.reportError(err);\n  }\n};\n", "  } catch (err) {\n    self.reportError(err);\n  }\n};\n"]}
{"filename": "src/lib/webworkers/decrypt.worker.ts", "chunked_list": ["import { decrypt, importEncryptionKey } from '@app/lib/crypto';\n\nself.onmessage = async function (e) {\n  try {\n    const { data, key }: { data: Blob; key: string } = e.data;\n    const importKey = await importEncryptionKey(key);\n    const decrypted = await decrypt(data, importKey);\n    self.postMessage(decrypted);\n  } catch (err) {\n    self.reportError(err);\n  }\n};\n", "  } catch (err) {\n    self.reportError(err);\n  }\n};\n"]}
{"filename": "src/models/index.ts", "chunked_list": ["export interface UserInfo {\n  email: string;\n}\n\nexport interface StorageQuota {\n  limit: number;\n  usage: number;\n  usageInDrive: number;\n}\n\nexport interface FileMetadata {\n  id: string;\n  name: string;\n  size: number;\n  createdTime: Date;\n  mimeType: string;\n}\n", "export interface FileMetadata {\n  id: string;\n  name: string;\n  size: number;\n  createdTime: Date;\n  mimeType: string;\n}\n\nexport interface WrappedKey {\n  enc: string;\n  salt: number[];\n}\n", "export interface WrappedKey {\n  enc: string;\n  salt: number[];\n}\n\nexport interface AppData {\n  encryptionKey: WrappedKey;\n}\n"]}
{"filename": "src/hooks/http.ts", "chunked_list": ["import { AppData, FileMetadata, StorageQuota, UserInfo } from '../models';\n\nconst JSONtoUserInfo = (json: any): UserInfo => {\n  const userInfo: UserInfo = {\n    email: json['emailAddress'],\n  };\n  return userInfo;\n};\n\nconst JSONtoFileMetadata = (json: any): FileMetadata => {", "\nconst JSONtoFileMetadata = (json: any): FileMetadata => {\n  const fileMetadata: FileMetadata = {\n    id: json['id'],\n    name: json['name'],\n    size: parseInt(json['size'] || 0),\n    createdTime: new Date(json['createdTime']),\n    mimeType: json['mimeType'],\n  };\n  return fileMetadata;", "  };\n  return fileMetadata;\n};\n\nconst JSONtoFilesMetadata = (json: any): FileMetadata[] => {\n  return json\n    .map((file: any): FileMetadata | undefined => {\n      if (file['trashed'] === true) {\n        return;\n      }\n      return JSONtoFileMetadata(file);\n    })\n    .filter((e: any) => e != null)\n    .sort((a: FileMetadata, b: FileMetadata) =>\n      a.createdTime && b.createdTime ? a.createdTime > b.createdTime : 0,\n    );\n};\n\nconst JSONtoAppData = (json: any): AppData => {\n  const appData: AppData = {\n    encryptionKey: {\n      enc: json['encryptionKey']['enc'],\n      salt: json['encryptionKey']['salt'],\n    },\n  };\n  return appData;\n};\n\nconst JSONtoStorageQuota = (json: any): StorageQuota => {\n  const storageQuota: StorageQuota = {\n    limit: parseInt(json['limit']),\n    usage: parseInt(json['usage']),\n    usageInDrive: parseInt(json['usageInDrive']),\n  };\n  return storageQuota;\n};\n\nexport const getUserInfo = async (token: string): Promise<UserInfo> => {\n  const res = await fetch('https://www.googleapis.com/drive/v3/about?fields=user', {\n    method: 'GET',\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  const json = await res.json();\n", "  if (!res.ok) {\n    const error = new Error('Failed fetching user.');\n    error.info = json;\n    error.status = res.status;\n    throw error;\n  }\n\n  return JSONtoUserInfo(json['user']);\n};\n\nexport const revokeToken = async (token: string): Promise<void> => {\n  fetch(`https://oauth2.googleapis.com/revoke?token=${token}type=accesstoken`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n  });\n};\n\nexport const revokeApp = async (token: string): Promise<void> => {\n  fetch(`https://oauth2.googleapis.com/revoke`, {\n    method: 'POST',\n    headers: { Authorization: `Bearer ${token}` },\n  });\n};\n\nconst CONFIG_FILE_NAME = 'config.json';\nconst APP_DATA_FOLDER = 'appDataFolder';\n\nconst createConfigFile = async (token: string): Promise<string> => {\n  const res = await fetch('https://www.googleapis.com/drive/v3/files?fields=id', {\n    method: 'POST',\n    body: JSON.stringify({\n      mimeType: 'application/json',\n      parents: [APP_DATA_FOLDER],\n      name: CONFIG_FILE_NAME,\n    }),\n    headers: {\n      Authorization: `Bearer ${token}`,\n      'Content-Type': 'application/json',\n    },\n  });\n  const json = await res.json();\n  return json['id'];\n};\n\nconst uploadConfigFile = async (\n  token: string,\n  configFileId: string,\n  data: AppData,\n): Promise<void> => {\n  const bytes = new TextEncoder().encode(JSON.stringify(data));\n  const file = new File([bytes], 'config.json', { type: 'application/json' });\n\n  await fetch(\n    `https://www.googleapis.com/upload/drive/v3/files/${configFileId}?uploadType=media`,\n    {\n      method: 'PATCH',\n      body: file,\n      headers: { Authorization: `Bearer ${token}` },\n    },\n  );\n};\n\nexport const saveAppData = async (token: string, data: AppData): Promise<void> => {\n  const configFileId = await createConfigFile(token);\n  await uploadConfigFile(token, configFileId, data);\n};\n\nconst getAppFiles = async (token: string) => {\n  const res = await fetch(\n    'https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=files(*)',\n    {\n      method: 'GET',\n      headers: { Authorization: `Bearer ${token}` },\n    },\n  );\n  const json = await res.json();\n  return JSONtoFilesMetadata(json['files']);\n};\nconst loadConfigFile = async (token: string, configFileId: string): Promise<AppData> => {\n  const res = await fetch(\n    `https://www.googleapis.com/drive/v3/files/${configFileId}?spaces=appDataFolder&alt=media`,\n    {\n      method: 'GET',\n      headers: { Authorization: `Bearer ${token}` },\n    },\n  );\n  const json = await res.json();\n  return JSONtoAppData(json);\n};\nexport const loadAppData = async (token: string): Promise<AppData | undefined> => {\n  const files = await getAppFiles(token);\n  const configFile = files.find((f) => f.name == CONFIG_FILE_NAME);", "  if (!configFile) {\n    // throw new Error(`Config file <${CONFIG_FILE_NAME}> not found`);\n    return;\n  }\n  return await loadConfigFile(token, configFile.id);\n};\n// only for debug\nexport const deleteAppFolder = async (token: string): Promise<void> => {\n  const files = await getAppFiles(token);\n  const promises = files.map(({ id: fileId }) => {\n    return fetch(`https://www.googleapis.com/drive/v3/files/${fileId}`, {\n      method: 'DELETE',\n      headers: { Authorization: `Bearer ${token}` },\n    });\n  });\n  await Promise.all(promises);\n};\n\nexport const getStorageQuota = async (token: string): Promise<StorageQuota> => {\n  const res = await fetch(\n    'https://www.googleapis.com/drive/v3/about?fields=storageQuota',\n    {\n      method: 'GET',\n      headers: { Authorization: `Bearer ${token}` },\n    },\n  );\n  const json = await res.json();\n  return JSONtoStorageQuota(json['storageQuota']);\n};\n\nexport const getUserFiles = async (token: string): Promise<FileMetadata[]> => {\n  const res = await fetch('https://www.googleapis.com/drive/v3/files?fields=*', {\n    method: 'GET',\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  const json = await res.json();\n  return JSONtoFilesMetadata(json['files']);\n};\n\nconst uploadFileMetadata = async (token: string, name: string): Promise<string> => {\n  // https://developers.google.com/drive/api/guides/manage-uploads#http_2\n  const res = await fetch(\n    'https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable',\n    {\n      method: 'POST',\n      body: JSON.stringify({\n        name: name,\n        originalFilename: name,\n        mimeType: 'application/octet-stream', // \"text/plain\"\n        description: 'From encryptly',\n      }),\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json; charset=UTF-8',\n        'X-Upload-Content-Type': 'application/octet-stream',\n      },\n    },\n  );\n  const location = res.headers.get('location');", "  if (!res.ok || !location) {\n    const error = new Error('Failed upload session resume.');\n    error.info = await res.json();\n    error.status = res.status;\n    throw error;\n  }\n  return location;\n};\n\ninterface Chunk {\n  data: Blob;\n  ratio: number;\n  contentLength: string;\n  contentRange: string;\n}\n\nconst generateChunks = (data: Blob): Chunk[] => {\n  /**\n   *  Create chunks in multiples of 256 KB (256 x 1024 bytes) in size,\n   *  except for the final chunk that completes the upload.\n   *  Keep the chunk size as large as possible so that the upload is efficient.\n   *\n   *  Add headers:\n   *  - Content-Length. Set to the number of bytes in the current chunk.\n   *  - Content-Range. Set to show which bytes in the file you upload.\n   *  For example, Content-Range: bytes 0-524287/2000000 shows that you\n   *  upload the first 524,288 bytes (256 x 1024 x 2) in a 2,000,000 byte file.\n   */\n  const chunkSize = 256 * 1024 * 16;\n  const dataSize = data.size;\n  const chunks: Chunk[] = [];\n  let chunkCount = 0;", "interface Chunk {\n  data: Blob;\n  ratio: number;\n  contentLength: string;\n  contentRange: string;\n}\n\nconst generateChunks = (data: Blob): Chunk[] => {\n  /**\n   *  Create chunks in multiples of 256 KB (256 x 1024 bytes) in size,\n   *  except for the final chunk that completes the upload.\n   *  Keep the chunk size as large as possible so that the upload is efficient.\n   *\n   *  Add headers:\n   *  - Content-Length. Set to the number of bytes in the current chunk.\n   *  - Content-Range. Set to show which bytes in the file you upload.\n   *  For example, Content-Range: bytes 0-524287/2000000 shows that you\n   *  upload the first 524,288 bytes (256 x 1024 x 2) in a 2,000,000 byte file.\n   */\n  const chunkSize = 256 * 1024 * 16;\n  const dataSize = data.size;\n  const chunks: Chunk[] = [];\n  let chunkCount = 0;", "  for (; (chunkCount + 1) * chunkSize < dataSize; chunkCount += 1) {\n    const start = chunkSize * chunkCount;\n    const end = chunkSize * (chunkCount + 1);\n    const chunk: Chunk = {\n      data: data.slice(start, end),\n      ratio: (end / dataSize) * 100,\n      contentLength: (end - start).toString(),\n      contentRange: `bytes ${start}-${end - 1}/${dataSize}`,\n    };\n    chunks.push(chunk);\n  }\n\n  const start = chunkSize * chunkCount;\n  const end = dataSize;\n  const lastChunk: Chunk = {\n    data: data.slice(start, end),\n    ratio: 100,\n    contentLength: (end - start).toString(),\n    contentRange: `bytes ${start}-${end - 1}/${dataSize}`,\n  };\n  chunks.push(lastChunk);\n\n  return chunks;\n};\n\nasync function* uploadFileMedia(\n  token: string,\n  file: Blob,\n  session: string,\n): AsyncGenerator<number, string, void> {\n  // https://developers.google.com/drive/api/guides/manage-uploads#http---multiple-requests\n  const chunks = generateChunks(file);\n", "  for (const { data, ratio, contentLength, contentRange } of chunks) {\n    await fetch(session, {\n      method: 'PUT',\n      body: data,\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Length': contentLength,\n        'Content-Range': contentRange,\n      },\n    });\n    yield ratio;\n  }\n\n  return 'ok';\n}\n\nexport const uploadFile = async (\n  token: string,\n  name: string,\n  data: Blob,\n): Promise<AsyncGenerator<number, string, void>> => {\n  const uploadSession = await uploadFileMetadata(token, name);\n  return uploadFileMedia(token, data, uploadSession);\n};\n\nconst downloadFileMedia = async (token: string, fileId: string): Promise<Blob> => {\n  const res = await fetch(\n    `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,\n    {\n      method: 'GET',\n      headers: { Authorization: `Bearer ${token}` },\n    },\n  );\n  const data = await res.blob();\n  return data;\n};\nconst downloadFileMetadata = async (\n  token: string,\n  fileId: string,\n): Promise<FileMetadata> => {\n  const res = await fetch(\n    `https://www.googleapis.com/drive/v3/files/${fileId}?fields=*`,\n    {\n      method: 'GET',\n      headers: { Authorization: `Bearer ${token}` },\n    },\n  );\n  const json = await res.json();\n  const metadata = JSONtoFileMetadata(json);\n  return metadata;\n};\nexport const downloadFile = async (\n  token: string,\n  fileId: string,\n): Promise<{\n  metadata: FileMetadata;\n  data: Blob;\n}> => {\n  const data = await downloadFileMedia(token, fileId);\n  const metadata = await downloadFileMetadata(token, fileId);\n  return { metadata, data };\n};\n\nexport const deleteFile = async (token: string, fileId: string): Promise<void> => {\n  await fetch(`https://www.googleapis.com/drive/v2/files/${fileId}`, {\n    method: 'DELETE',\n    headers: { Authorization: `Bearer ${token}` },\n  });\n};\n"]}
{"filename": "src/hooks/index.ts", "chunked_list": ["import { useCallback, useContext } from 'react';\nimport { AppContext } from '@app/context';\nimport { generateEncryptionKey, wrapEncryptionKey } from '@app/lib/crypto';\nimport promisify from '@app/lib/promisify';\nimport {\n  delStorageAccessToken,\n  getStorageAccessToken,\n  setStorageAccessToken,\n} from '@app/lib/storage';\nimport DecryptWorker from '@app/lib/webworkers/decrypt.worker?worker';", "} from '@app/lib/storage';\nimport DecryptWorker from '@app/lib/webworkers/decrypt.worker?worker';\nimport EncryptWorker from '@app/lib/webworkers/encrypt.worker?worker';\nimport useSWR, { mutate } from 'swr';\n\nimport {\n  deleteAppFolder,\n  deleteFile,\n  downloadFile,\n  getStorageQuota,", "  downloadFile,\n  getStorageQuota,\n  getUserFiles,\n  getUserInfo,\n  loadAppData,\n  revokeToken,\n  saveAppData,\n  uploadFile,\n} from './http';\n", "} from './http';\n\nexport const useIsAuthenticated = () => {\n  const { accessToken, encryptionKey } = useContext(AppContext);\n  const hasAccessToken = accessToken.value != '' && accessToken.value != null;\n  const hasEncryptionKey = encryptionKey.value != '' && encryptionKey.value != null;\n  return hasAccessToken && hasEncryptionKey;\n};\n\nexport const useRecoverAccessToken = () => {", "\nexport const useRecoverAccessToken = () => {\n  const { accessToken } = useContext(AppContext);\n\n  return async () => {\n    const token = getStorageAccessToken();\n\n    if (token) {\n      try {\n        await getUserInfo(token);\n        accessToken.setValue(token);\n        setStorageAccessToken(token);\n        return true;", "      try {\n        await getUserInfo(token);\n        accessToken.setValue(token);\n        setStorageAccessToken(token);\n        return true;\n      } catch (err) {\n        accessToken.setValue('');\n        delStorageAccessToken();\n      }\n    }\n\n    return false;\n  };\n};\n\nexport const useUserInfo = () => {\n  const { accessToken } = useContext(AppContext);\n\n  return useSWR('UserInfo', () => getUserInfo(accessToken.value));\n};\n\nexport const useLogout = () => {\n  const { accessToken, encryptionKey } = useContext(AppContext);\n\n  return async () => {\n    sessionStorage.clear();\n    encryptionKey.setValue('');\n    await revokeToken(accessToken.value);\n    accessToken.setValue('');\n\n    // Clear all previous, to force refetch new data with new token/user\n    await mutate(() => true, undefined, {\n      revalidate: true,\n      populateCache: true,\n    });\n  };\n};\n\nexport const useDriveQuota = () => {\n  const { accessToken } = useContext(AppContext);\n  return useSWR('driveQuota', () => getStorageQuota(accessToken.value));\n};\n\nexport const useListFiles = () => {\n  const { accessToken } = useContext(AppContext);\n  return useSWR('listFiles', () => getUserFiles(accessToken.value), {\n    revalidateOnFocus: false,\n    revalidateIfStale: false,\n  });\n};\n\nexport const revalidateListFiles = async () => {\n  const keys = ['listFiles', 'driveQuota'];\n\n  await mutate((key: string) => keys.includes(key), undefined, {\n    revalidate: true,\n    populateCache: false,\n  });\n};\n\nexport const useEncryptFile = () => {\n  const { encryptionKey } = useContext(AppContext);\n\n  return useCallback(\n    (file: File): Promise<Blob> => {\n      const worker = new EncryptWorker();\n      return promisify(worker, { file, key: encryptionKey.value });\n    },\n    [encryptionKey.value],\n  );\n};\n\nexport const useDecryptFile = () => {\n  const { encryptionKey } = useContext(AppContext);\n\n  return useCallback(\n    async (data: Blob): Promise<Blob> => {\n      const worker = new DecryptWorker();\n      return promisify(worker, { data, key: encryptionKey.value });\n    },\n    [encryptionKey.value],\n  );\n};\n\nexport const useUploadFile = () => {\n  const { accessToken } = useContext(AppContext);\n\n  return async (file: { data: Blob; name: string }) => {\n    const generator = await uploadFile(accessToken.value, file.name, file.data);\n    return generator;\n  };\n};\n\nexport const useDownloadFile = () => {\n  const { accessToken } = useContext(AppContext);\n\n  return async (fileId: string) => {\n    const { metadata, data } = await downloadFile(accessToken.value, fileId);\n    return { data, metadata };\n  };\n};\n\nexport const useDeleteFile = () => {\n  const { accessToken } = useContext(AppContext);\n\n  return async (fileId: string) => {\n    await deleteFile(accessToken.value, fileId);\n    await revalidateListFiles();\n  };\n};\n\nexport const useAppData = () => {\n  const { accessToken } = useContext(AppContext);\n  return useSWR('appData', () => loadAppData(accessToken.value), {\n    revalidateOnFocus: false,\n    revalidateIfStale: false,\n    revalidateOnReconnect: false,\n  });\n};\n\nexport const useSaveAppData = () => {\n  const { accessToken } = useContext(AppContext);\n\n  return async (passphrase: string) => {\n    const encryptionKey = await generateEncryptionKey();\n    const wrappedKey = await wrapEncryptionKey(encryptionKey, passphrase);\n    await saveAppData(accessToken.value, { encryptionKey: wrappedKey });\n    await mutate((key: string) => key == 'appData', undefined, {\n      revalidate: true,\n      populateCache: false,\n    });\n  };\n};\n\n// only for debug\nexport const useDeleteAppDataFolder = () => {\n  const { accessToken } = useContext(AppContext);\n  return () => deleteAppFolder(accessToken.value);\n};\n"]}
