{"filename": "src/app.ts", "chunked_list": ["import express,{ Request, Response, Application, NextFunction } from 'express';\nimport http from 'http';\nimport connectDB from './framework/database/Mongodb/connection/connection';\nimport serverConfig from './framework/webserver/server';\nimport expressConfig from './framework/webserver/express';\nimport router from './framework/webserver/routes'\nimport errorHandler from './framework/webserver/middlewares/errorHandler';\nimport AppError from './utilities/appError';\nimport { HttpStatus } from './types/httpstatuscodes'\nimport path from 'path';", "import { HttpStatus } from './types/httpstatuscodes'\nimport path from 'path';\nimport { Server } from 'socket.io';\nimport socketConfig from './framework/websocket/websocket';\nimport configKeys from './config';\n\nconst app: Application = express();\nconst server = http.createServer(app);\n\nconst io = new Server(server, {", "\nconst io = new Server(server, {\n    cors: {\n        origin: configKeys.CLIENT_URL,\n        methods: [\"GET\", \"POST\"]\n    }\n})\n\n// connect socket.io\nsocketConfig(io);", "// connect socket.io\nsocketConfig(io);\n\n// mongoDB connection\nconnectDB();\n\n// middleware configuration\nexpressConfig(app);\n\nrouter(app);", "\nrouter(app);\n\n// adding public folder as static file\napp.use('/uploads', express.static(path.join(__dirname, '../public/uploads')));\n\napp.use(errorHandler);\n\n// catch error\napp.all(\"*\", (req: Request, res: Response, next: NextFunction) => {", "// catch error\napp.all(\"*\", (req: Request, res: Response, next: NextFunction) => {\n    next(new AppError('Not found', HttpStatus.UNAUTHORIZED));\n});\n\nserverConfig(server).startServer()"]}
{"filename": "src/config.ts", "chunked_list": ["import dotenv from 'dotenv';\n\ndotenv.config();\n\nconst configKeys = {\n    MONGO_URL : process.env.MONGODB_URL as string,\n    PORT : process.env.PORT as any,\n    JWT_SECRET: process.env.JWT_TOKEN_KEY as string,\n    CLIENT_URL: process.env.CLIENT_URL as string\n}", "    CLIENT_URL: process.env.CLIENT_URL as string\n}\n\n\nexport default configKeys;"]}
{"filename": "src/application/useCases/chat/chat.ts", "chunked_list": ["import { HttpStatus } from \"../../../types/httpstatuscodes\";\nimport AppError from \"../../../utilities/appError\";\nimport { chatRepositoriesInterfaceType } from \"../../repositories/chatRepositeries\";\n\nexport const createChat = async (senderId: string, recieverId: string, repository: ReturnType<chatRepositoriesInterfaceType>) => {\n    const chat = await repository.createChat(senderId, recieverId);\n    if(!chat){\n        throw new AppError('User not found', HttpStatus.UNAUTHORIZED);\n    }\n    return chat;\n}\n\nexport const getAllchats = async (userId: string, repository: ReturnType<chatRepositoriesInterfaceType>) => {\n    const getChats = await repository.getAllchat(userId);\n    return getChats;\n}\n\nexport const getChat = async(firstId: string, secondId: string,  repository: ReturnType<chatRepositoriesInterfaceType>) => {\n    const chat = await repository.getChat(firstId, secondId);\n    return chat;\n}"]}
{"filename": "src/application/useCases/message/message.ts", "chunked_list": ["import { HttpStatus } from \"../../../types/httpstatuscodes\";\nimport AppError from \"../../../utilities/appError\";\nimport { messageRepositoryInterfaceType } from \"../../repositories/messageRepository\";\n\n// logics for creating a new message\nexport const createMessage = async (chatId: string, messageId: string, message: string, repository: ReturnType<messageRepositoryInterfaceType>) => {\n    const createResponse = await repository.createMessage(chatId, messageId, message);\n    if (!createResponse) return new AppError('User not created', HttpStatus.NOT_FOUND);\n    return createResponse;\n};\n\nexport const getMessages = async(chatId: string, repository: ReturnType<messageRepositoryInterfaceType>) => {\n    const messages = await repository.getMessages(chatId);\n    return messages;\n}"]}
{"filename": "src/application/useCases/auth/adminAuth.ts", "chunked_list": ["import { HttpStatus } from '../../../types/httpstatuscodes';\nimport AppError from '../../../utilities/appError';\nimport { AdminDbInterface } from '../../repositories/adminDbRepositories';\nimport { AuthServiceInterface } from '../../services/authServiceInterface';\n\n\nexport const adminLogin =async (\n    email: string,\n    password: string,\n    adminRepository: ReturnType<AdminDbInterface>,", "    password: string,\n    adminRepository: ReturnType<AdminDbInterface>,\n    authService: ReturnType<AuthServiceInterface>\n) => {\n   \n    \n    const admin: any = await adminRepository.getAdminByEmail(email);\n\n    \n    if(!admin){\n        throw new AppError(\"Admin not exist\", HttpStatus.UNAUTHORIZED);\n    }\n    const checkPassword: any = await authService.comparePassword(password, admin.password);", "    \n    if(!admin){\n        throw new AppError(\"Admin not exist\", HttpStatus.UNAUTHORIZED);\n    }\n    const checkPassword: any = await authService.comparePassword(password, admin.password);\n    if(!checkPassword){\n        throw new AppError(\"Password you entered was incorrect\", HttpStatus.UNAUTHORIZED);\n    }\n    const token: string = await authService.generateToken(admin._id.toString());\n    console.log(token,'lllllll');\n    \n    return {\n        token,\n        admin\n    };\n}; \n"]}
{"filename": "src/application/useCases/auth/userAuth.ts", "chunked_list": ["import { HttpStatus } from '../../../types/httpstatuscodes';\nimport AppError from '../../../utilities/appError';\nimport { UserDbInterface } from '../../repositories/userDbRepositories';\nimport { AuthServiceInterface } from '../../services/authServiceInterface';\n\nexport const userRegister = async (user: { name: string, userName: string, email: string, number: number, password: any }, userRepository: ReturnType<UserDbInterface>, authService: ReturnType<AuthServiceInterface>) => {\n    // bussiness logic\n    user.email = user.email.toLowerCase();\n    const isEmailExist: any = await userRepository.getUserByEmail(user.email);\n\n    if (isEmailExist) {\n        throw new AppError('Email already exist : ', HttpStatus.UNAUTHORIZED)\n    }\n\n\n\n    let encryptedPassword = await authService.encryptPassword(user.password);\n    user.password = encryptedPassword\n\n    const { _id: userId } = await userRepository.addUser(user);\n    const token = authService.generateToken(userId.toString());\n    return token;\n\n};\n\nexport const userLogin = async (\n    userName: string,\n    password: string,\n    userRepository: ReturnType<UserDbInterface>,\n    authService: ReturnType<AuthServiceInterface>\n) => {\n\n    const user: any = await userRepository.getUserByUserName(userName);\n", "    const isEmailExist: any = await userRepository.getUserByEmail(user.email);\n\n    if (isEmailExist) {\n        throw new AppError('Email already exist : ', HttpStatus.UNAUTHORIZED)\n    }\n\n\n\n    let encryptedPassword = await authService.encryptPassword(user.password);\n    user.password = encryptedPassword\n\n    const { _id: userId } = await userRepository.addUser(user);\n    const token = authService.generateToken(userId.toString());\n    return token;\n\n};\n\nexport const userLogin = async (\n    userName: string,\n    password: string,\n    userRepository: ReturnType<UserDbInterface>,\n    authService: ReturnType<AuthServiceInterface>\n) => {\n\n    const user: any = await userRepository.getUserByUserName(userName);\n", "    if (!user) {\n        throw new AppError(\"User not exist\", HttpStatus.UNAUTHORIZED);\n    }\n    const checkPassword: any = await authService.comparePassword(password, user.password);\n\n    if (user.isBlock) {\n        throw new AppError(\"User was blocked\", HttpStatus.UNAUTHORIZED)\n    }\n\n    if (!checkPassword) {\n        throw new AppError(\"Password you entered was incorrect\", HttpStatus.UNAUTHORIZED);\n    }\n    const token: string = await authService.generateToken(user._id.toString());\n\n    return {\n        token,\n        user\n    };\n};\n\nexport const googleAuthLogin = async (\n    user: {\n        name: any;\n        userName: any;\n        email: any;\n        number?: any;\n        password?: any;\n    },\n\n    userRepository: ReturnType<UserDbInterface>,\n    authService: ReturnType<AuthServiceInterface>\n) => {\n    const isEmailExist: any = await userRepository.getUserByEmail(user.email);\n", "    if (!checkPassword) {\n        throw new AppError(\"Password you entered was incorrect\", HttpStatus.UNAUTHORIZED);\n    }\n    const token: string = await authService.generateToken(user._id.toString());\n\n    return {\n        token,\n        user\n    };\n};\n\nexport const googleAuthLogin = async (\n    user: {\n        name: any;\n        userName: any;\n        email: any;\n        number?: any;\n        password?: any;\n    },\n\n    userRepository: ReturnType<UserDbInterface>,\n    authService: ReturnType<AuthServiceInterface>\n) => {\n    const isEmailExist: any = await userRepository.getUserByEmail(user.email);\n", "    if (isEmailExist) {\n        if (isEmailExist.isBlock) {\n            throw new AppError(\"User was blocked\", HttpStatus.UNAUTHORIZED)\n        }\n        const token: any = await authService.generateToken(isEmailExist._id.toString())\n        return {\n            user: isEmailExist,\n            token\n        }\n    } else {\n        const userDetails: any = await userRepository.addUser(user)\n        const token: string = await authService.generateToken(userDetails._id.toString())\n        return {\n            user: userDetails,\n            token\n        }\n    }\n}\n\nexport const userBlock = async (id: any, userRepository: ReturnType<UserDbInterface>) => {\n    const { isBlock }: any = await userRepository.getUserById(id)", "    if (!isBlock) {\n        const blockResponse: any = await userRepository.blockUser(id);\n        return blockResponse;\n    } else {\n        const unBlockResponse: any = await userRepository.unBlockUser(id);\n        return unBlockResponse;\n    }\n}\n"]}
{"filename": "src/application/useCases/user/user.ts", "chunked_list": ["import { HttpStatus } from '../../../types/httpstatuscodes';\nimport AppError from '../../../utilities/appError';\nimport { UserDbInterface } from '../../repositories/userDbRepositories';\n\n\nexport const getUserDetails = async (id: string, repository: ReturnType<UserDbInterface>) => {\n    // Get all users\n    const users: any[] = await repository.getAllUsers();\n\n    if (id !== 'undefined') {\n\n        // Get blocked users\n        const { blockedUsers } = await repository.getUserById(id);\n\n        // Filter out blocked users\n        const filtered = users.filter((user: any) => !blockedUsers.includes(user._id));\n\n        return filtered;\n    } else {\n        return users\n    }\n\n};\n\n\nexport const userById = async (id: string, repository: ReturnType<UserDbInterface>) => {\n    const user: any = await repository.getUserById(id)\n", "\n    if (id !== 'undefined') {\n\n        // Get blocked users\n        const { blockedUsers } = await repository.getUserById(id);\n\n        // Filter out blocked users\n        const filtered = users.filter((user: any) => !blockedUsers.includes(user._id));\n\n        return filtered;\n    } else {\n        return users\n    }\n\n};\n\n\nexport const userById = async (id: string, repository: ReturnType<UserDbInterface>) => {\n    const user: any = await repository.getUserById(id)\n", "    if (!user) {\n        throw new AppError(\"user not exist\", HttpStatus.UNAUTHORIZED);\n    }\n    return user;\n}\n\nexport const followers = async (id: string, repository: ReturnType<UserDbInterface>) => {\n    const followers: any = await repository.getFollowers(id);\n    return followers;\n}\n\nexport const followings = async (id: string, repository: ReturnType<UserDbInterface>) => {\n    const followings: any = await repository.getFollowings(id);\n    return followings\n}\n\nexport const requestFriend = async (id: string, friendId: string, repository: ReturnType<UserDbInterface>) => {\n    const { userName, dp } = await repository.getUserById(id);\n    const { requests, userName: friendName, dp: friendDp } = await repository.getUserById(friendId);\n\n    // check user is already in request list\n    const isRequested = requests.find((request: any) => request.id === id);\n", "    if (isRequested) {\n        await repository.cancelRequest(id, friendId);\n        return 'Request canceled';\n    } else {\n        await repository.sendRequest(id, userName, friendName, dp, friendDp, friendId);\n        return 'Request sended';\n    }\n\n}\n\nexport const requestFriendResponse = async (id: string, friendId: string, { response }: any, repository: ReturnType<UserDbInterface>) => {", "    if (response === 'accept') {\n\n        await repository.followFriend(friendId, id);\n        await repository.cancelRequest(friendId, id);\n        return 'Request accepted'\n    } else {\n\n        await repository.cancelRequest(friendId, id);\n        return 'Request rejected'\n    }\n}\n\nexport const unfollow = async (id: any, friendId: any, repository: ReturnType<UserDbInterface>) => {\n\n    // this friend is already a follower\n    const friend: any = await repository.unfollowFriend(id, friendId);\n    return {\n        status: 'unfollow',\n        friend\n    }\n\n}\n\nexport const searchUserByPrefix = async (prefix: any, type: any, repository: ReturnType<UserDbInterface>) => {", "    if (!prefix) return HttpStatus.NOT_FOUND\n\n    const searchedUsers: any = await repository.searchUser(prefix, type)\n    return searchedUsers\n}\n\nexport const updateProfileInfo = async (id: string, body: any, repository: ReturnType<UserDbInterface>) => {\n    if (!body || !id) return HttpStatus.NOT_FOUND\n    const updateProfile: any = await repository.updateProfile(id, body);\n    return updateProfile\n}\n\nexport const userBlock = async (userId: string, blockId: string, repository: ReturnType<UserDbInterface>) => {\n\n    const { blockingUsers } = await repository.getUserById(userId);\n\n    // check user is already blocked\n    const isBlocked = blockingUsers.some((user: any) => user === blockId);\n", "    if (isBlocked) {\n        // user already blocked\n        const updateResult: any = await repository.unBlockUserByUser(userId, blockId);\n        return updateResult;\n    } else {\n        // user not blocked\n        const updateResult: any = await repository.blockUserByUser(userId, blockId);\n        return updateResult;\n    }\n}"]}
{"filename": "src/application/useCases/post/post.ts", "chunked_list": ["import { HttpStatus } from \"../../../types/httpstatuscodes\";\nimport AppError from \"../../../utilities/appError\";\nimport { postDbInterfaceType } from \"../../repositories/postDbRepositories\";\n\n// bussiness logics...\n\n// find all posts from the database\nexport const getAllPost = async (repositories: ReturnType<postDbInterfaceType>) => {\n  const posts = await repositories.getAllPost()\n  if (!posts) {\n    throw new AppError('Post not available', HttpStatus.BAD_REQUEST)\n  }\n  return posts;\n};\n\n// create a post\nexport const postCreate = async (\n  postDetails: {\n    userId: string;\n    description: string;\n    image: string;\n    userName: string;\n  },\n  respositories: ReturnType<postDbInterfaceType>\n) => {\n  const newpost = await respositories.uploadPost(postDetails)", "  const posts = await repositories.getAllPost()\n  if (!posts) {\n    throw new AppError('Post not available', HttpStatus.BAD_REQUEST)\n  }\n  return posts;\n};\n\n// create a post\nexport const postCreate = async (\n  postDetails: {\n    userId: string;\n    description: string;\n    image: string;\n    userName: string;\n  },\n  respositories: ReturnType<postDbInterfaceType>\n) => {\n  const newpost = await respositories.uploadPost(postDetails)", "  if (!newpost) {\n    throw new AppError('Uploading failed', HttpStatus.BAD_REQUEST)\n  }\n  return newpost\n};\n\n// get all post by a user\nexport const getPostsByUser = async (userId: any, repositories: ReturnType<postDbInterfaceType>) => {\n  const posts = await repositories.getPostsByUser(userId)\n  return posts;\n};\n\n// get a single post by postId\nexport const getPostById = async (id: any, repositories: ReturnType<postDbInterfaceType>) => {\n  const post = await repositories.getPostById(id)\n\n\n  return post;\n}\n\n//delete a particular post by postId\nexport const deletePostById = async (id: any, repositories: ReturnType<postDbInterfaceType>) => {\n  const deletedData = await repositories.deletePost(id)", "  if (!deletedData) {\n    throw new AppError('No data found for delete', HttpStatus.BAD_REQUEST)\n  }\n  return deletedData\n}\n\n// like or dislike post \nexport const updateLike = async (id: any, userId: any, repositories: ReturnType<postDbInterfaceType>) => {\n\n  // find the post by id\n  const post = await repositories.getPostById(id);\n\n  // check weather user is already liked this post of not", "  if (post.likes.includes(userId)) {\n\n    // if user already liked the post\n\n    await repositories.dislikePost(id, userId);\n  }\n  else {\n    // else user not liked the post\n\n    await repositories.likePost(id, userId);\n  }\n\n\n};\n\n// add comment to a particular post by postId\nexport const insertComment = async (postId: string, userId: string, comment: string, repositories: ReturnType<postDbInterfaceType>) => {\n\n  const commentResult = await repositories.insertComment(postId, userId, comment);\n\n  return commentResult;\n}\n\n// reply a comment\nexport const replyComment = async (postId: string, userId: string, comment: string, reply: string, repositories: ReturnType<postDbInterfaceType>) => {\n  const commentResult = await repositories.replyComment(postId,userId, comment, reply);", "  if (!commentResult) {\n    throw new AppError('Reply failed', HttpStatus.BAD_REQUEST)\n  }\n  return 'Reply succcess';\n}\n\n// delete a particulat comment using index number\nexport const deleteComment = async (postId: string, index: string, repositories: ReturnType<postDbInterfaceType>) => {\n  const { comments } = await repositories.getPostById(postId);\n  comments.splice(index, 1);\n  const updateResult = await repositories.pushComment(postId, comments);\n  return updateResult;\n}\n\n\n// edit post \nexport const postEdit = async (postId: string, body: any, repositories: ReturnType<postDbInterfaceType>) => {\n  const commentResult = await repositories.editPost(postId, body);\n\n  return commentResult;\n}\n\n// report post \nexport const postReport = async (userId: string, postId: string, reason: any, repositories: ReturnType<postDbInterfaceType>) => {\n  const response = await repositories.reportPost(userId, postId, reason)\n  return response;\n}\n\nexport const getReportedUsers = async (postId: string, repositories: ReturnType<postDbInterfaceType>) => {\n  const users = await repositories.getReportedUsers(postId)\n  return users;\n}\n\n\n\n\n"]}
{"filename": "src/application/repositories/postDbRepositories.ts", "chunked_list": ["import { postRepositoryType } from \"../../framework/database/Mongodb/repositories/postRepositeries\";\n\n// post database operation interface\n\nexport const postDbInterface: any = (repositories: ReturnType<postRepositoryType>) => {\n\n    const getAllPost = async () => await repositories.getAllPost()\n    \n\n    const uploadPost = async (post:{", "\n    const uploadPost = async (post:{\n        userId: string;\n        description: string;\n        image: string;\n        video: string;\n        userName: string;\n    }) => { return repositories.uploadPost(post)}\n\n", "\n\n    const getPostsByUser = async (userId: string) => {\n        return await repositories.getPostsByUser(userId)\n    };\n\n    const getPostById =async (id:string) => {\n        return await repositories.getPostById(id)\n    }\n", "    }\n\n    const deletePost = async (id: string) => {\n        const deletedData = await repositories.deletePost(id)\n        return deletedData;\n    }\n\n    const dislikePost = async (id: string, userId: string) => {\n        await repositories.dislikePost(id, userId)\n    }", "        await repositories.dislikePost(id, userId)\n    }\n\n    const likePost = async (id: string, userId: string) => {\n        await repositories.likePost(id, userId)\n    }\n\n    const insertComment = async(postId: string, userId: string, comment: string) => {\n        const insertResult = await repositories.insertComment(postId, userId, comment);\n        return insertResult", "        const insertResult = await repositories.insertComment(postId, userId, comment);\n        return insertResult\n    }\n\n    const replyComment = async(postId: string,userId: string, comment: string, reply: string) => {\n        const response = await repositories.replyComment(postId,userId, comment, reply);\n        return response\n    }\n\n    const editPost = async(postId: string, body: any) => {", "\n    const editPost = async(postId: string, body: any) => {\n        const editPost = await repositories.editPost(postId, body)\n        return editPost\n    }\n\n    const reportPost = async(userId: string, postId: string, reason: any) => {\n        const repostResponse = await repositories.reportPost(userId, postId, reason);\n        return repostResponse;\n    }", "        return repostResponse;\n    }\n\n    const getReportedUsers = async (postId: string) => {\n        const users = await repositories.getReportedUsers(postId);\n        return users;\n    }\n\n    return {\n        getAllPost,", "    return {\n        getAllPost,\n        uploadPost,\n        getPostsByUser,\n        getPostById,\n        deletePost,\n        dislikePost,\n        likePost,\n        insertComment,\n        replyComment,", "        insertComment,\n        replyComment,\n        editPost,\n        reportPost,\n        getReportedUsers\n\n    }\n}\n\nexport type postDbInterfaceType = typeof postDbInterface;", "\nexport type postDbInterfaceType = typeof postDbInterface;"]}
{"filename": "src/application/repositories/adminDbRepositories.ts", "chunked_list": ["// correct\nimport { adminRepositoryMongoDB } from \"../../framework/database/Mongodb/repositories/adminRepositories\";\n\nexport const adminDbRepository = (repository: ReturnType<adminRepositoryMongoDB>) => {\n\n    const getAdminByEmail = async (email: string) => {\n        return await repository.getAdminByEmail(email)\n    };\n\n", "\n\n    return {\n\n        getAdminByEmail,\n    }\n\n};\n\n\nexport type AdminDbInterface = typeof adminDbRepository;", "\n\nexport type AdminDbInterface = typeof adminDbRepository;"]}
{"filename": "src/application/repositories/userDbRepositories.ts", "chunked_list": ["import { userRepositoryMongoDB } from \"../../framework/database/Mongodb/repositories/userRepositories\";\n\n\nexport const userDbRepository = (repository: ReturnType<userRepositoryMongoDB>) => {\n    const addUser = async (user: {\n        name: string;\n        userName: string;\n        email: string;\n        number?: number;\n        password?: string;", "        number?: number;\n        password?: string;\n    }) => {\n\n        return await repository.addUser(user);\n    };\n\n    const getAllUsers = async () => {\n        return await repository.getAllUsers()\n", "        return await repository.getAllUsers()\n\n    }\n\n    const getUserByEmail = async (email: string) => {\n        return await repository.getUserByEmail(email);\n    };\n\n    const getUserByUserName = async (userName: string) => {\n", "    const getUserByUserName = async (userName: string) => {\n\n        return await repository.getUserByUserName(userName);\n    };\n\n    const getUserById = async (id: string) => {\n        return await repository.getUserById(id);\n    };\n\n    const getFollowers = async (id: string) => {", "\n    const getFollowers = async (id: string) => {\n        return await repository.getFollowers(id);\n    };\n\n    const getFollowings = async (id: string) => {\n        return await repository.getFollowings(id);\n    };\n\n    const findFriend = async (id: string, friendId: string) => {", "\n    const findFriend = async (id: string, friendId: string) => {\n        return await repository.findFriend(id, friendId);\n    }\n\n    const sendRequest = async (id: string, userName: string, friendName: string, dp: any, friendDp: string,  friendId: string) => {\n        return await repository.sendRequest(id, userName, friendName,dp, friendDp,  friendId);\n    }\n\n    const cancelRequest = async (id: string, friendId: string) => {", "\n    const cancelRequest = async (id: string, friendId: string) => {\n        return await repository.cancelRequest(id, friendId);\n    }\n\n    const unfollowFriend = async (id: string, friendId: string) => {\n        return await repository.unfollowFriend(id, friendId)\n    }\n\n    const followFriend = async (id: string, friendId: string) => {", "\n    const followFriend = async (id: string, friendId: string) => {\n        return await repository.followFriend(id, friendId)\n    }\n\n    const searchUser = async (prefix: string, type: string) => {\n        return await repository.searchUser(prefix, type);\n    }\n    const updateProfile = async (id: string, body: any) => {\n        return await repository.updateProfile(id, body)", "    const updateProfile = async (id: string, body: any) => {\n        return await repository.updateProfile(id, body)\n    }\n    const blockUser = async (id: string) => {\n        return await repository.blockUser(id);\n    }\n    const unBlockUser = async (id: string) => {\n        return await repository.unBlockUser(id);\n    }\n", "    }\n\n    const blockUserByUser = async (userId: string, blockId: string) => {\n        return await repository.blockUserByUser(userId, blockId);\n    }\n\n    const unBlockUserByUser = async (userId: string, blockId: string) => {\n        return await repository.unBlockUserByUser(userId, blockId);\n    }\n", "    }\n\n\n\n    return {\n        addUser,\n        getUserByEmail,\n        getUserByUserName,\n        getUserById,\n        getFollowers,", "        getUserById,\n        getFollowers,\n        getFollowings,\n        sendRequest,\n        cancelRequest,\n        findFriend,\n        unfollowFriend,\n        followFriend,\n        getAllUsers,\n        searchUser,", "        getAllUsers,\n        searchUser,\n        updateProfile,\n        blockUser,\n        unBlockUser,\n        blockUserByUser,\n        unBlockUserByUser\n\n\n    };", "\n    };\n};\n\nexport type UserDbInterface = typeof userDbRepository;"]}
{"filename": "src/application/repositories/messageRepository.ts", "chunked_list": ["import { messageRepositoryMongoDBType } from \"../../framework/database/Mongodb/repositories/messageRepository\";\n\nexport const messageRepositoryInterface = (repository: ReturnType<messageRepositoryMongoDBType>) => {\n    const createMessage = async (chatId: string, senderId: string, message: any) => {\n        const createResponse = await repository.createMessage(chatId, senderId, message);\n        return createResponse;\n    }\n\n    const getMessages = async(chatId: string) => {\n        return repository.getMessages(chatId);", "    const getMessages = async(chatId: string) => {\n        return repository.getMessages(chatId);\n    }\n\n    return {\n        createMessage,\n        getMessages\n    }\n}\n\nexport type messageRepositoryInterfaceType = typeof messageRepositoryInterface;", "}\n\nexport type messageRepositoryInterfaceType = typeof messageRepositoryInterface;"]}
{"filename": "src/application/repositories/chatRepositeries.ts", "chunked_list": ["import { chatRepositoryType } from \"../../framework/database/Mongodb/repositories/chatRepositories\";\n\nexport const chatRepositoriesInterface = (repository: ReturnType<chatRepositoryType>) => {\n\n    // interface for create chat\n    const createChat = async (senderId: string, recieverId: string) => {\n        const createChat = await repository.createChat(senderId, recieverId);\n        return createChat;\n    };\n\n    const getAllchat = async (userId: string) => {\n        const chats = await repository.getAllchat(userId);\n        return chats\n    }\n\n    const getChat = async (firstId: string, secondId: string) => {\n        const chat = await repository.getChat(firstId, secondId);\n        return chat;\n    }\n\n    return {\n        createChat,\n        getAllchat,\n        getChat\n    }\n};\n", "export type chatRepositoriesInterfaceType = typeof chatRepositoriesInterface;"]}
{"filename": "src/application/services/authServiceInterface.ts", "chunked_list": ["import { AuthServiceReturn } from \"../../framework/services/authServices\";\n\nexport const authServiceInterface = (service: AuthServiceReturn) => {\n    const encryptPassword = async (password: string) => {\n        \n        return await service.encryptPassword(password);\n    };\n    const comparePassword = async (password: string, hashedPassword: string) => {\n        return await service.comparePassword(password, hashedPassword);\n    };", "        return await service.comparePassword(password, hashedPassword);\n    };\n    const verifyPassword = async (token: string) => {\n        return service.verifyToken(token);\n    };\n    const generateToken = async (payload: string) => {\n        return service.generateToken(payload);\n    };\n\n    return {", "\n    return {\n        encryptPassword,\n        comparePassword,\n        verifyPassword,\n        generateToken\n    }\n\n}\n\nexport type AuthServiceInterface = typeof authServiceInterface;\n", "}\n\nexport type AuthServiceInterface = typeof authServiceInterface;\n"]}
{"filename": "src/adapters/controllers/messageController.ts", "chunked_list": ["import { Request, Response } from \"express\";\nimport expressAsyncHandler from \"express-async-handler\";\nimport { messageRepositoryInterfaceType } from \"../../application/repositories/messageRepository\";\nimport { messageRepositoryMongoDBType } from \"../../framework/database/Mongodb/repositories/messageRepository\";\nimport { createMessage, getMessages } from \"../../application/useCases/message/message\";\n\nconst messageController = (messageRepositoryInterface: messageRepositoryInterfaceType, messageRepositoryMongoDB: messageRepositoryMongoDBType) => {\n    const messageRepository = messageRepositoryInterface(messageRepositoryMongoDB());\n\n    const createNewMessage = expressAsyncHandler(async(req: Request, res: Response) => {", "\n    const createNewMessage = expressAsyncHandler(async(req: Request, res: Response) => {\n        const {chatId, senderId, message} = req.body;\n        \n        const createResponse = await createMessage(chatId, senderId, message, messageRepository);\n        \n        res.json({\n            status: 'success',\n            response: createResponse\n        })", "            response: createResponse\n        })\n    })\n\n    const getUserMessages = expressAsyncHandler(async(req: Request, res: Response) => {\n        const { chatId } = req.params;\n        const messages = await getMessages(chatId, messageRepository);\n\n        res.json({\n            status: 'Message fetch success',", "        res.json({\n            status: 'Message fetch success',\n            messages\n        })\n    })\n\n    return {\n        createNewMessage,\n        getUserMessages\n    }", "        getUserMessages\n    }\n}\n\nexport default messageController;"]}
{"filename": "src/adapters/controllers/chatController.ts", "chunked_list": ["import { Request, Response } from \"express\";\nimport expressAsyncHandler from \"express-async-handler\";\nimport { chatRepositoriesInterfaceType } from \"../../application/repositories/chatRepositeries\";\nimport { chatRepositoryType } from \"../../framework/database/Mongodb/repositories/chatRepositories\";\nimport { createChat, getAllchats, getChat } from \"../../application/useCases/chat/chat\";\n\nconst chatController = (chatRepositoriesInterfaceType: chatRepositoriesInterfaceType, chatRepositoryType: chatRepositoryType) => {\n    const chatRepositeries = chatRepositoriesInterfaceType(chatRepositoryType());\n\n    const chatCreate = expressAsyncHandler(async (req: Request, res: Response) => {", "\n    const chatCreate = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { senderId, recieverId } = req.params;\n        const newChat = await createChat(senderId, recieverId, chatRepositeries);\n        res.json({\n            status: 'success',\n            chats: newChat\n        })\n    })\n", "    })\n\n    const getChats = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { userId} = req.params;\n        const chats = await getAllchats(userId, chatRepositeries);\n        res.json({\n            status: 'success',\n            chats\n            \n        })", "            \n        })\n    })\n\n    const getSingleChat = expressAsyncHandler(async(req: Request, res:Response) => {\n        const { firstId, secondId } = req.params;\n        const chat = await getChat(firstId, secondId, chatRepositeries);\n        res.json({\n            status: 'success',\n            chat", "            status: 'success',\n            chat\n        })\n    })\n\n    return {\n        chatCreate,\n        getChats,\n        getSingleChat\n    }", "        getSingleChat\n    }\n}\n\nexport default chatController;"]}
{"filename": "src/adapters/controllers/adminAuthController.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport asyncHandler from 'express-async-handler';\nimport { AuthServices } from '../../framework/services/authServices';\nimport { AuthServiceInterface } from '../../application/services/authServiceInterface';\nimport { AdminDbInterface } from '../../application/repositories/adminDbRepositories';\nimport { adminRepositoryMongoDB } from '../../framework/database/Mongodb/repositories/adminRepositories';\nimport { adminLogin } from '../../application/useCases/auth/adminAuth';\n\n// authentication controllers\nconst authControllers = (", "// authentication controllers\nconst authControllers = (\n    authServiceInterface: AuthServiceInterface,\n    authService: AuthServices,\n    adminDbInterface: AdminDbInterface,\n    adminDbservice: adminRepositoryMongoDB\n) => {\n    const dbAdminRepository = adminDbInterface(adminDbservice());\n    const authServices = authServiceInterface(authService());\n   ", "    const authServices = authServiceInterface(authService());\n   \n    const loginAdmin = asyncHandler(async(req: Request, res: Response) => {\n        console.log('-------------------------------------------------------');       \n        \n        const { email, password }  = req.body;\n        const token = await adminLogin(email, password, dbAdminRepository, authServices)\n        // res.setHeader('authorization', token.token);\n        res.json({\n            status: \"success\",", "        res.json({\n            status: \"success\",\n            message: \"admin verified\",\n            token\n        });\n    });\n\n    return {\n        loginAdmin,\n    };", "        loginAdmin,\n    };\n};\n\nexport default authControllers;"]}
{"filename": "src/adapters/controllers/postControllers.ts", "chunked_list": ["import { Request, Response } from \"express\";\nimport expressAsyncHandler from \"express-async-handler\";\nimport { postRepositoryType } from \"../../framework/database/Mongodb/repositories/postRepositeries\";\nimport { postDbInterfaceType } from \"../../application/repositories/postDbRepositories\";\nimport { getAllPost, postCreate, getPostsByUser, getPostById, deletePostById, updateLike, insertComment, deleteComment, postEdit, postReport, getReportedUsers, replyComment } from '../../application/useCases/post/post'\n\nconst postControllers = (postDbInterface: postDbInterfaceType, postRepositoryType: postRepositoryType) => {\n\n    const dbRepositoriesPost = postDbInterface(postRepositoryType())\n", "    const dbRepositoriesPost = postDbInterface(postRepositoryType())\n\n    const getPosts = expressAsyncHandler(async (req: Request, res: Response) => {\n        const posts = await getAllPost(dbRepositoriesPost)\n        res.json({\n            status: \"success\",\n            posts\n        })\n    })\n", "    })\n\n    const uploadPost = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { userId, description, userName, image, video } = req.body;\n\n\n        const body = { userId, description, userName, image, video };\n        const newPost = await postCreate(body, dbRepositoriesPost);\n\n", "\n\n        res.json({\n            status: 'upload-success',\n            newPost\n        })\n\n    })\n\n    const getUserPosts = expressAsyncHandler(async (req: Request, res: Response) => {", "\n    const getUserPosts = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { userId } = req.params;\n        const posts: any = await getPostsByUser(userId, dbRepositoriesPost);\n        res.json({\n            status: 'posts find success',\n            posts\n        })\n    })\n", "    })\n\n    const getPost = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n        const post: any = await getPostById(id, dbRepositoriesPost);\n\n\n\n        res.json({\n            status: 'post find success',", "        res.json({\n            status: 'post find success',\n            post\n        })\n    })\n\n    const deletePost = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n        const deletedData = await deletePostById(id, dbRepositoriesPost)\n", "        const deletedData = await deletePostById(id, dbRepositoriesPost)\n\n        res.json({\n            status: 'Deleted success',\n            deletedData\n        })\n\n    })\n\n    const postLikeUpdate = expressAsyncHandler(async (req: Request, res: Response) => {", "\n    const postLikeUpdate = expressAsyncHandler(async (req: Request, res: Response) => {\n\n        const { id, userId } = req.query;\n        await updateLike(id, userId, dbRepositoriesPost)\n\n        res.json({\n            status: 'like update success'\n        })\n", "        })\n\n    })\n\n    const commentPost = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { postId, userId } = req.params;\n\n        const { comment } = req.body\n\n        const updateResult = await insertComment(postId, userId, comment, dbRepositoriesPost)", "\n        const updateResult = await insertComment(postId, userId, comment, dbRepositoriesPost)\n\n\n        res.json({\n            status: 'comment success',\n            comment: updateResult\n        })\n    })\n", "    })\n\n\n    const commentReply = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { userId, postId } = req.params;\n        const { comment, reply } = req.body;\n        const updateResult = await replyComment(postId, userId, comment, reply, dbRepositoriesPost)\n        res.json({\n            status: updateResult\n        })", "            status: updateResult\n        })\n    })\n\n    const commentDelete = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { postId, index } = req.params;\n\n        const deleteResult = await deleteComment(postId, index, dbRepositoriesPost)\n\n        res.json({", "\n        res.json({\n            status: 'comment deleted',\n            deletedComment: deleteResult\n        })\n    })\n\n    const editPost = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { postId } = req.params;\n        const { description } = req.body;", "        const { postId } = req.params;\n        const { description } = req.body;\n\n        const postEditResult: any = await postEdit(postId, description, dbRepositoriesPost)\n\n        res.json({\n            status: 'post update success',\n            response: postEditResult\n        })\n    })", "        })\n    })\n\n    const reportPost = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { userId, postId } = req.params;\n        const { reason } = req.body;\n\n        const repostResponse = await postReport(userId, postId, reason, dbRepositoriesPost)\n        res.json({\n            status: 'posted success',", "        res.json({\n            status: 'posted success',\n            response: repostResponse\n        })\n    })\n\n    const getReporters = expressAsyncHandler(async (req: Request, res: Response) => {\n        const { postId } = req.params;\n        const users = await getReportedUsers(postId, dbRepositoriesPost);\n        res.json({", "        const users = await getReportedUsers(postId, dbRepositoriesPost);\n        res.json({\n            status: 'reposted users fetched',\n            users\n        })\n    })\n\n\n    return {\n        getPosts,", "    return {\n        getPosts,\n        uploadPost,\n        getUserPosts,\n        getPost,\n        deletePost,\n        postLikeUpdate,\n        commentPost,\n        commentReply,\n        commentDelete,", "        commentReply,\n        commentDelete,\n        editPost,\n        reportPost,\n        getReporters\n    }\n}\n\nexport default postControllers;", "export default postControllers;"]}
{"filename": "src/adapters/controllers/userControllers.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport asyncHandler from 'express-async-handler';\nimport { UserDbInterface } from '../../application/repositories/userDbRepositories';\nimport { userById, followers, followings, unfollow, getUserDetails, searchUserByPrefix, updateProfileInfo, userBlock, requestFriend, requestFriendResponse } from '../../application/useCases/user/user';\nimport { userRepositoryMongoDB } from '../../framework/database/Mongodb/repositories/userRepositories';\n\nconst userControllers = (\n    userDbRepository: UserDbInterface,\n    userDbRepositoryService: userRepositoryMongoDB\n) => {", "    userDbRepositoryService: userRepositoryMongoDB\n) => {\n    const dbRepositoryUser = userDbRepository(userDbRepositoryService());\n\n\n    // get all users list\n    const getAllUsers = asyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n        const users = await getUserDetails(id, dbRepositoryUser);\n        res.json({", "        const users = await getUserDetails(id, dbRepositoryUser);\n        res.json({\n            status: 'Get users success',\n            users\n        })\n    })\n\n    // get a user details by id\n    const getUserById = asyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;", "    const getUserById = asyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n\n        const user = await userById(id, dbRepositoryUser)\n        res.json({\n            status: \"success\",\n            user\n        });\n    });\n", "    });\n\n    // get followers list of the user\n    const getFollowersList = asyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n        const followersList: any = await followers(id, dbRepositoryUser);\n        res.json({\n            status: 'get followers success',\n            followers: followersList\n        })", "            followers: followersList\n        })\n\n    })\n\n    // get following list of the user\n    const getFollowingsList = asyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n        const followingList: any = await followings(id, dbRepositoryUser);\n        res.json({", "        const followingList: any = await followings(id, dbRepositoryUser);\n        res.json({\n            status: 'get following success',\n            followings: followingList\n        })\n    })\n\n\n    // send friend request to user\n    const sendRequest = asyncHandler(async (req: Request, res: Response) => {", "    // send friend request to user\n    const sendRequest = asyncHandler(async (req: Request, res: Response) => {\n        const { id, friendId } = req.params;\n        const response = await requestFriend(id, friendId, dbRepositoryUser);\n        res.json({\n            status: response\n        })\n    })\n\n    // accept or reject request", "\n    // accept or reject request\n    const responseFriendRequest = asyncHandler(async (req: Request, res: Response) => {\n        const { id, friendId } = req.params;\n        const { response } = req.body;\n        const status = await requestFriendResponse(id, friendId, response, dbRepositoryUser)\n        res.json({\n            status\n        })\n    })", "        })\n    })\n\n    // insert followers to user\n    const unfollowUser = asyncHandler(async (req: Request, res: Response) => {\n        const { id, friendId } = req.query;\n        const { status, friend }: any = await unfollow(id, friendId, dbRepositoryUser);\n        res.json({\n            status,\n            friend", "            status,\n            friend\n        })\n    })\n\n    // search user \n    const searchUser = asyncHandler(async (req: Request, res: Response) => {\n\n        const { prefix } = req.params;\n        const { type } = req.query;", "        const { prefix } = req.params;\n        const { type } = req.query;\n        console.log(type, 'par');\n\n\n        const users: any = await searchUserByPrefix(prefix, type, dbRepositoryUser);\n        res.json({\n            status: 'searched success',\n            users\n        })", "            users\n        })\n    })\n\n    // update profile informations\n    const updateProfile = asyncHandler(async (req: Request, res: Response) => {\n        const { id } = req.params;\n        const { userName, bio, gender, city, file } = req.body;\n\n        const updateResult = await updateProfileInfo(id, { userName, file, bio, gender, city }, dbRepositoryUser);", "\n        const updateResult = await updateProfileInfo(id, { userName, file, bio, gender, city }, dbRepositoryUser);\n        res.json({\n            status: 'Update success',\n            data: updateResult\n        })\n    })\n\n    // block user by user\n    const blockUser = asyncHandler(async (req: Request, res: Response) => {", "    // block user by user\n    const blockUser = asyncHandler(async (req: Request, res: Response) => {\n        const { userId, blockId } = req.params;\n        const blockResult = await userBlock(userId, blockId, dbRepositoryUser);\n        res.json({\n            status: blockResult\n        });\n    })\n\n    return {", "\n    return {\n        getUserById,\n        sendRequest,\n        responseFriendRequest,\n        getFollowersList,\n        getFollowingsList,\n        unfollowUser,\n        getAllUsers,\n        searchUser,", "        getAllUsers,\n        searchUser,\n        updateProfile,\n        blockUser\n    };\n};\n\nexport default userControllers;"]}
{"filename": "src/adapters/controllers/authControllers.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport asyncHandler from 'express-async-handler';\nimport { AuthServices } from '../../framework/services/authServices';\nimport { AuthServiceInterface } from '../../application/services/authServiceInterface';\nimport { UserDbInterface } from '../../application/repositories/userDbRepositories';\nimport { userRepositoryMongoDB } from '../../framework/database/Mongodb/repositories/userRepositories';\nimport { userRegister, userLogin, googleAuthLogin, userBlock} from '../../application/useCases/auth/userAuth';\n\n// authentication controllers\nconst authControllers = (", "// authentication controllers\nconst authControllers = (\n    authServiceInterface: AuthServiceInterface,\n    authService: AuthServices,\n    userDbInterface: UserDbInterface,\n    userDbservice: userRepositoryMongoDB\n) => {\n    const dbUserRepository = userDbInterface(userDbservice());\n    const authServices = authServiceInterface(authService());\n    const registerUser = asyncHandler(async(req: Request, res: Response) => {", "    const authServices = authServiceInterface(authService());\n    const registerUser = asyncHandler(async(req: Request, res: Response) => {\n        \n        const { name, userName, number,email, password } = req.body;\n        const user = {\n            name,\n            userName,\n            number,\n            email,\n            password,", "            email,\n            password,\n            };\n    \n    const token = await userRegister(user, dbUserRepository, authServices);\n    \n    res.json({\n        status:\"success\",\n        message: \"User registered\",\n        token", "        message: \"User registered\",\n        token\n    });\n    });\n    const loginUser = asyncHandler(async(req: Request, res: Response) => {\n        \n        const { userName, password } : { userName: string; password: string} = req.body;\n        const token = await userLogin(userName, password, dbUserRepository, authServices);\n        // res.setHeader('authorization', token.token);\n        res.json({", "        // res.setHeader('authorization', token.token);\n        res.json({\n            status: \"success\",\n            message: \"user verified\",\n            token\n        });\n    });\n\n    const googleAuth = asyncHandler(async(req: Request, res: Response) => {\n        console.log('-----------------------');", "    const googleAuth = asyncHandler(async(req: Request, res: Response) => {\n        console.log('-----------------------');\n        const { fullName, firstName, email } = req.body;\n        const userData: any = { name:fullName, userName:firstName, number: 7594837203, email }\n        console.log(userData);\n\n        \n        const {user, token} = await googleAuthLogin(userData, dbUserRepository, authServices)\n\n        res.json({", "\n        res.json({\n            status:'Google login success',\n            user,\n            token\n        })\n    })\n\n    const blockUser = asyncHandler(async(req: Request, res: Response) => {\n        const { id } = req.params;", "    const blockUser = asyncHandler(async(req: Request, res: Response) => {\n        const { id } = req.params;\n        const blockResult = await userBlock(id, dbUserRepository);\n        res.json({\n            status: `${blockResult} success`\n        })\n    })\n\n    return {\n        registerUser,", "    return {\n        registerUser,\n        loginUser,\n        googleAuth,\n        blockUser\n    };\n};\n\nexport default authControllers;", "export default authControllers;"]}
{"filename": "src/types/httpstatuscodes.ts", "chunked_list": ["export enum HttpStatus {\n    CONTINUE = 100,\n    SWITCHING_PROTOCOLS = 101,\n    PROCESSING = 102,\n    EARLYHINTS = 103,\n    OK = 200,\n    CREATED = 201,\n    ACCEPTED = 202,\n    NON_AUTHORITATIVE_INFORMATION = 203,\n    NO_CONTENT = 204,\n    RESET_CONTENT = 205,\n    PARTIAL_CONTENT = 206,\n    AMBIGUOUS = 300,\n    MOVED_PERMANENTLY = 301,\n    FOUND = 302,\n    SEE_OTHER = 303,\n    NOT_MODIFIED = 304,\n    TEMPORARY_REDIRECT = 307,\n    PERMANENT_REDIRECT = 308,\n    BAD_REQUEST = 400,\n    UNAUTHORIZED = 401,\n    PAYMENT_REQUIRED = 402,\n    FORBIDDEN = 403,\n    NOT_FOUND = 404,\n    METHOD_NOT_ALLOWED = 405,\n    NOT_ACCEPTABLE = 406,\n    PROXY_AUTHENTICATION_REQUIRED = 407,\n    REQUEST_TIMEOUT = 408,\n    CONFLICT = 409,\n    GONE = 410,\n    LENGTH_REQUIRED = 411,\n    PRECONDITION_FAILED = 412,\n    PAYLOAD_TOO_LARGE = 413,\n    URI_TOO_LONG = 414,\n    UNSUPPORTED_MEDIA_TYPE = 415,\n    REQUESTED_RANGE_NOT_SATISFIABLE = 416,\n    EXPECTATION_FAILED = 417,\n    I_AM_A_TEAPOT = 418,\n    MISDIRECTED = 421,\n    UNPROCESSABLE_ENTITY = 422,\n    FAILED_DEPENDENCY = 424,\n    PRECONDITION_REQUIRED = 428,\n    TOO_MANY_REQUESTS = 429,\n    INTERNAL_SERVER_ERROR = 500,\n    NOT_IMPLEMENTED = 501,\n    BAD_GATEWAY = 502,\n    SERVICE_UNAVAILABLE = 503,\n    GATEWAY_TIMEOUT = 504,\n    HTTP_VERSION_NOT_SUPPORTED = 505\n}\n\n"]}
{"filename": "src/utilities/appError.ts", "chunked_list": ["import { HttpStatus } from \"../types/httpstatuscodes\";\n\nclass AppError extends Error {\n    statusCode: number;\n    status: string;\n    isOperational: boolean;\n    constructor(message: string, statusCode: HttpStatus) {\n      super(message);\n      \n      this.statusCode = statusCode;\n      this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\n      this.isOperational = true;\n  \n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n  \nexport default AppError;"]}
{"filename": "src/framework/database/Mongodb/repositories/postRepositeries.ts", "chunked_list": ["import Post from \"../models/postModel\";\nimport User from \"../models/userModel\";\nimport { ObjectId } from 'mongodb'\nimport cloudinary from 'cloudinary'\n\n// post database operations\n\nexport const postRepositoryMongoDb = () => {\n\n    const getAllPost = async () => {", "\n    const getAllPost = async () => {\n        return await Post.find().sort({ createdAt: -1 });\n    }\n\n    const uploadPost = (async (post: {\n        userId: string;\n        description: string;\n        image: string;\n        video: string;", "        image: string;\n        video: string;\n        userName: string;\n    }) => {\n        const newpost = new Post(post);\n        return await newpost.save();\n    })\n\n    const getPostsByUser = async (userId: any) => {\n        return await Post.find({ userId })", "    const getPostsByUser = async (userId: any) => {\n        return await Post.find({ userId })\n    }\n\n    const getPostById = async (_id: string) => {\n        const posts = await Post.findById({ _id: new ObjectId(_id) })\n\n        return posts;\n    }\n", "    }\n\n    const deletePost = async (_id: string) => {\n\n        const deletedData = await Post.findByIdAndDelete({ _id: new ObjectId(_id) })\n\n        return deletedData\n    }\n\n    const dislikePost = async (_id: string, userId: string) => {", "\n    const dislikePost = async (_id: string, userId: string) => {\n        await Post.findByIdAndUpdate({ _id },\n            { $pull: { likes: userId } })\n    }\n\n    const likePost = async (_id: string, userId: string) => {\n\n        await Post.findByIdAndUpdate({ _id },\n            { $push: { likes: userId } })", "        await Post.findByIdAndUpdate({ _id },\n            { $push: { likes: userId } })\n    }\n\n    const insertComment = async (postId: string, userId: string, comment: string) => {\n        const updateResult = await Post.findByIdAndUpdate({ _id: postId }, {\n            $push: { comments: { userId, comment, reply: [] } }\n        });\n\n        return updateResult;", "\n        return updateResult;\n    }\n\n    const replyComment = async (_id: string, userId: string, comment: string, reply: string) => {\n        const updateResult = await Post.updateOne(\n            { _id, \"comments.comment\": comment },\n            {\n                $push: {\n                    \"comments.$.reply\": { userId, reply }", "                $push: {\n                    \"comments.$.reply\": { userId, reply }\n                }\n            }\n        );\n\n        return updateResult;\n    };\n\n", "\n\n\n    const editPost = async (_id: string, description: any) => {\n        const updateResult = await Post.findByIdAndUpdate({ _id }, {\n            $set: { description }\n        })\n        return updateResult\n    }\n", "    }\n\n    const reportPost = async (userId: string, postId: string, reason: any) => {\n        const repostResponse = await Post.findByIdAndUpdate({ _id: postId }, {\n            $push: { reports: { userId, reason } }\n        })\n        return repostResponse;\n    }\n\n    const getReportedUsers = async (postId: string) => {", "\n    const getReportedUsers = async (postId: string) => {\n        const postDetails: any = await Post.findOne({ _id: postId });\n\n        const users: any = await Promise.all(\n            postDetails.reports.map(async ({ userId }: any) => {\n                return await User.findOne({ _id: userId })\n            })\n        )\n        return users;", "        )\n        return users;\n\n    }\n\n    return {\n        getAllPost,\n        uploadPost,\n        getPostsByUser,\n        getPostById,", "        getPostsByUser,\n        getPostById,\n        deletePost,\n        dislikePost,\n        likePost,\n        insertComment,\n        replyComment,\n        editPost,\n        reportPost,\n        getReportedUsers", "        reportPost,\n        getReportedUsers\n\n    }\n}\n\nexport type postRepositoryType = typeof postRepositoryMongoDb;"]}
{"filename": "src/framework/database/Mongodb/repositories/userRepositories.ts", "chunked_list": ["import User from \"../models/userModel\";\n\nexport const userRepositoryMongoDB = () => {\n  const addUser = async (user: {\n    name: string;\n    userName: string;\n    email: string;\n    number?: number;\n    password?: string;\n  }) => {", "    password?: string;\n  }) => {\n\n    const newUser = new User(user);\n\n    return await newUser.save();\n  };\n\n  const getAllUsers = async () => {\n    const users: any = await User.find();", "  const getAllUsers = async () => {\n    const users: any = await User.find();\n    // const users: any = await User.find({ _id: { $ne: '646fa8515333e77cdec159c2' }, followers: { $nin: ['6471800e2ed680381cbae276', '6477705ef858f715f868093a'] } });\n\n    return users;\n  }\n\n  const getUserByEmail = async (email: string) => {\n    const user: any = await User.findOne({ email }).select('-password');\n    return user", "    const user: any = await User.findOne({ email }).select('-password');\n    return user\n  };\n  const getUserByUserName = async (userName: string) => {\n\n    const user: any = await User.findOne({ userName })\n    return user;\n  };\n  const getUserById = async (id: string) => {\n    try {\n      const user: any = await User.findOne({ _id: id }).select('-password');\n      return user;", "  const getUserById = async (id: string) => {\n    try {\n      const user: any = await User.findOne({ _id: id }).select('-password');\n      return user;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const getFollowers = async (_id: string) => {\n    const user: any = await User.findOne({ _id });\n    const followers: any[] = await Promise.all(\n      user.followers.map(async (follower: any) => {\n        return await User.findOne({ _id: follower });\n      })\n    );\n    return followers;\n  };\n\n  const getFollowings = async (_id: string) => {\n    const user: any = await User.findOne({ _id });\n    const followings: any[] = await Promise.all(\n      user.following.map(async (following: any) => {\n        return await User.findOne({ _id: following });\n      })\n    );\n\n    return followings;\n  };\n\n  const findFriend = async (_id: string, friendId: any) => {\n    const user: any = await User.findOne({ _id })\n\n\n    const isUserExist: any = await user.followers.find((user: any) => user === friendId)\n\n    return isUserExist;\n  }\n\n\n  const sendRequest = async (id: string, userName: string, friendName: string, dp: any, friendDp: string, friendId: string) => {\n    await User.updateOne({ _id: friendId }, {\n      $push: { requests: { id, userName, dp } }\n    })\n    await User.updateOne({ _id: id }, {\n      $push: { requested: { id: friendId, userName: friendName, dp: friendDp } }\n    })\n    return;\n  }\n\n  const cancelRequest = async (id: string, friendId: string) => {\n    await User.updateOne({ _id: friendId }, {\n      $pull: { requests: { id } }\n    })\n    await User.updateOne({ _id: id }, {\n      $pull: { requested: { id: friendId } }\n    })\n    return;\n  }\n\n  const unfollowFriend = async (_id: string, friendId: string) => {\n    // remove friend from user follower list\n    await User.findByIdAndUpdate({ _id },\n      { $pull: { followers: friendId } });\n    await User.findByIdAndUpdate({ _id: friendId },\n      { $pull: { following: _id } })\n    const friendDetails: any = await User.findOne({ _id: friendId });\n\n    return friendDetails\n  }\n\n  const followFriend = async (_id: string, friendId: string) => {\n    // add friend to user follower list\n    await User.findByIdAndUpdate({ _id },\n      { $push: { followers: friendId } });\n    await User.findByIdAndUpdate({ _id: friendId },\n      { $push: { following: _id } })\n    const friendDetails: any = await User.findOne({ _id: friendId });\n\n\n    return friendDetails\n  }\n\n  const searchUser = async (prefix: any, type: any) => {\n", "    if (type === 'userName') {\n      const regex = new RegExp(`^${prefix}`, 'i');\n      const users = await User.find({ userName: regex });\n\n      return users\n\n    } else if (type === 'gender') {\n      const regex = new RegExp(`^${prefix}`, 'i');\n      const users = await User.find({ gender: regex });\n      return users\n\n    } else {\n      const regex = new RegExp(`^${prefix}`, 'i');\n      const users = await User.find({ city: regex });\n\n      return users\n    }\n\n\n  }\n\n  const updateProfile = async (_id: string, data: {\n    userName: string,\n    file: string,\n    bio: string,\n    gender: string,\n    city: string\n  }) => {\n    const { userName, file, bio, gender, city } = data;\n\n    const updateResult = await User.findByIdAndUpdate(_id, {\n      $set: {\n        userName,\n        dp: file,\n        bio,\n        gender,\n        city,\n      }\n    }, { new: true });\n\n    return updateResult;\n  };\n\n  const blockUser = async (_id: string) => {\n    await User.findByIdAndUpdate({ _id }, {\n      $set: { isBlock: true }\n    })\n    return 'Blocked'\n  }\n  const unBlockUser = async (_id: string) => {\n    await User.findByIdAndUpdate({ _id }, {\n      $set: { isBlock: false }\n    })\n    return 'UnBlocked'\n  }\n  const blockUserByUser = async (blockingUser: string, blockedUser: string) => {\n    await User.findByIdAndUpdate({ _id: blockedUser }, {\n      $push: { blockedUsers: blockingUser }\n    });\n    await User.findByIdAndUpdate({ _id: blockingUser }, {\n      $push: { blockingUsers: blockedUser }\n    });\n    return 'Blocked';\n  }\n\n  const unBlockUserByUser = async (blockingUser: string, blockedUser: string) => {\n    await User.findByIdAndUpdate({ _id: blockedUser }, {\n      $pull: { blockedUsers: blockingUser }\n    });\n    await User.findByIdAndUpdate({ _id: blockingUser }, {\n      $pull: { blockingUsers: blockedUser }\n    });\n    return 'Unblocked';\n  }\n\n  return {\n    addUser,\n    getUserByEmail,\n    getUserByUserName,\n    getUserById,\n    getFollowers,\n    getFollowings,\n    findFriend,\n    sendRequest,\n    cancelRequest,\n    unfollowFriend,\n    followFriend,\n    getAllUsers,\n    searchUser,\n    updateProfile,\n    blockUser,\n    unBlockUser,\n    blockUserByUser,\n    unBlockUserByUser\n  };\n}\n", "export type userRepositoryMongoDB = typeof userRepositoryMongoDB;"]}
{"filename": "src/framework/database/Mongodb/repositories/messageRepository.ts", "chunked_list": ["import Message from \"../models/MessageModal\";\n\nexport const messageRepositoryMongoDB = () => {\n\n    // create a message with a person based on their chatId\n    const createMessage = async (chatId: string, senderId: string, message: any) => {\n        const newMessage =  new Message({\n            chatId,\n            senderId,\n            message", "            senderId,\n            message\n        });\n        return await newMessage.save();\n    }\n\n    // get single person messages\n    const getMessages = async (chatId: string) => {\n        return await Message.find({chatId});\n    }", "        return await Message.find({chatId});\n    }\n\n    return {\n        createMessage,\n        getMessages\n    }\n\n}\n\nexport type messageRepositoryMongoDBType = typeof messageRepositoryMongoDB;\n\n", "}\n\nexport type messageRepositoryMongoDBType = typeof messageRepositoryMongoDB;\n\n"]}
{"filename": "src/framework/database/Mongodb/repositories/chatRepositories.ts", "chunked_list": ["import Chat from \"../models/Chatmodel\";\n\nexport const chatRepositoryMongoDB = () => {\n\n    // create chat collection in db\n    const createChat = async (senderId: string, recieverId: string) => {\n        try {\n            // find the chat is already in the database\n            const isChatExist = await Chat.findOne({\n                members: { $all: [senderId, recieverId] }\n            });\n", "            if(isChatExist) {\n                // if the chat is already in the database nothing to do\n                return isChatExist;\n            } else {\n                // create a new chat with the sender and reciever\n                const newChat = new Chat({\n                    members: [senderId, recieverId]\n                });\n\n                const saveResponse = await newChat.save();\n                return saveResponse;\n            }\n            ", "        } catch (error) {\n            throw error\n        }\n}\n\n   const getAllchat = async (userId: string) => {\n    try {\n        return await Chat.find({\n            members: { $in: [userId]}\n        })\n    } catch (error) {\n        throw error;\n    }\n   }\n\n   const getChat = async (firstId: string, secondId: string) => {\n    return await Chat.find({\n        members: { $all: [firstId, secondId]}\n    });\n   };\n\n    return {\n        createChat,\n        getAllchat,\n        getChat\n    }\n\n};\n", "    } catch (error) {\n        throw error;\n    }\n   }\n\n   const getChat = async (firstId: string, secondId: string) => {\n    return await Chat.find({\n        members: { $all: [firstId, secondId]}\n    });\n   };\n\n    return {\n        createChat,\n        getAllchat,\n        getChat\n    }\n\n};\n", "export type chatRepositoryType = typeof chatRepositoryMongoDB;"]}
{"filename": "src/framework/database/Mongodb/repositories/adminRepositories.ts", "chunked_list": ["//correct\nimport Admin from \"../models/adminModel\";\n\nexport const adminRepositoryMongoDB = () => {\n\n    const getAdminByEmail = async (email: string) => {\n        const user: any = await Admin.findOne({ email });\n        return user\n    };\n", "    };\n\n\n\n    return {\n\n        getAdminByEmail,\n\n    };\n}", "    };\n}\n\nexport type adminRepositoryMongoDB = typeof adminRepositoryMongoDB;"]}
{"filename": "src/framework/database/Mongodb/models/Chatmodel.ts", "chunked_list": ["import mongoose, { Schema, model } from \"mongoose\";\n\n\nconst ChatSchema = new mongoose.Schema(\n    {\n        members: {\n            type: Array,\n        }\n    },\n    {", "    },\n    {\n        timestamps: true\n    }\n);\n\nconst ChatModel = model(\"Chat\", ChatSchema);\nexport default ChatModel;"]}
{"filename": "src/framework/database/Mongodb/models/postModel.ts", "chunked_list": ["import { Document, Schema, model } from \"mongoose\";\n\ninterface IPost extends Document {\n  userId: string;\n  description: string;\n  userName?: string;\n  likes: any[];\n  comments: any[];\n  reports: any[];\n  createdAt: Date;\n  image?: string;\n  video?: string;\n  location: {\n    type: string;\n    coordinates: number[];\n  };\n}\n\nconst postSchema = new Schema<IPost>(\n  {\n    userId: {\n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n      required: true,\n    },\n    userName: {\n      type: String,\n    },\n    likes: [],\n    comments: [],\n    reports: [],\n    createdAt: {\n      type: Date,\n      default: new Date(),\n    },\n    image: String,\n    video: String,\n    location: {\n      type: {\n        type: String,\n        enum: [\"Point\"],\n        default: \"Point\",\n      },\n      coordinates: {\n        type: [Number],\n        default: [Math.random() * 180 - 90, Math.random() * 360 - 180],\n      },\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\n\n\nconst Post = model<IPost>(\"Post\", postSchema);\n\nexport default Post;\n"]}
{"filename": "src/framework/database/Mongodb/models/userModel.ts", "chunked_list": ["import mongoose, { Schema, model } from \"mongoose\";\n\n// schema for users\nconst userSchema = new Schema(\n  {\n    name: {\n      type: String,\n      required: true,\n    },\n    userName: {", "    },\n    userName: {\n      type: String,\n      required: true,\n      unique: true,\n    },\n    email: {\n      type: String,\n      required: true,\n    },", "      required: true,\n    },\n    number: {\n        type: Number,\n    },\n    password: {\n      type: String,\n      minlength:3\n    },\n    dp: {", "    },\n    dp: {\n      type: String,\n    },\n    bio: {\n      type: String,\n    },\n    gender: {\n      type: String\n    },", "      type: String\n    },\n    city:{\n      type: String\n    },\n    isBlock: {\n      type: Boolean,\n      default: false,\n    },\n    blockedUsers:[],", "    },\n    blockedUsers:[],\n    blockingUsers:[],\n    followers: [],\n    following: [],\n    requests:[],\n    requested:[]\n\n  },\n  { timestamps: true }", "  },\n  { timestamps: true }\n);\n\nconst User = model(\"User\", userSchema);\n\nexport default User;\n"]}
{"filename": "src/framework/database/Mongodb/models/adminModel.ts", "chunked_list": ["import mongoose, { Schema, model } from \"mongoose\";\n\nconst adminSchema = new Schema(\n    {\n        name:{\n            type:String,\n            default: 'CONNECTIFY-ADMIN'\n        },\n        email: {\n            require: true,", "        email: {\n            require: true,\n            type: String\n        },\n        password: {\n            require:true,\n            type: String\n        }\n    }\n)", "    }\n)\n\n const Admin = model('admin', adminSchema);\n\n export default Admin"]}
{"filename": "src/framework/database/Mongodb/models/MessageModal.ts", "chunked_list": ["import mongoose, { Mongoose, model } from \"mongoose\";\n\nconst MessageSchema = new mongoose.Schema(\n    {\n        chatId: {\n            type: String,\n        },\n        senderId: {\n            type: String\n        },", "            type: String\n        },\n        message: {\n            type: String\n        }\n\n    },\n    {\n        timestamps: true\n        ", "        timestamps: true\n        \n    }\n);\n\nconst MessageModel = mongoose.model(\"message\", MessageSchema);\n\nexport default MessageModel;\n", ""]}
{"filename": "src/framework/database/Mongodb/connection/connection.ts", "chunked_list": ["import mongoose  from \"mongoose\";\nimport configKeys from '../../../../config';\n\nmongoose.set(\"strictQuery\", true);\n\nconst connectDB = async () => {\n    try {\n        await mongoose.connect(configKeys.MONGO_URL).then(()=>{\n            console.log(`Database connected successfully`);\n        })\n", "    } catch (error) {\n        console.log(`Database connection error : ${error}`);\n        process.exit(1) \n    }\n}\n\nexport default connectDB"]}
{"filename": "src/framework/services/cloudinaryServices.ts", "chunked_list": ["import cloudinary from \"../../config\";\n\n"]}
{"filename": "src/framework/services/authServices.ts", "chunked_list": ["import bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport configKeys from '../../config';\n\nexport const authServices = () => {\n    const encryptPassword = async (password:string) => {\n\n      \n        const salt = await bcrypt.genSalt(10);\n        password = await bcrypt.hash(password, salt);", "        const salt = await bcrypt.genSalt(10);\n        password = await bcrypt.hash(password, salt);\n        \n        return password;\n    };\n    const comparePassword = (password:string, hasedPassword:string) => {\n        return bcrypt.compare(password, hasedPassword);\n    };\n    const generateToken = (payload: string) => {\n        if (configKeys.JWT_SECRET) {\n          const token = jwt.sign({ payload }, configKeys.JWT_SECRET, {\n            expiresIn: \"5d\",\n          });\n          return token;\n        } else {\n          throw new Error(\"JWT_TOKEN_KEY is undefined\");\n        }\n      };\n    const verifyToken = (token:string) => {", "    const generateToken = (payload: string) => {\n        if (configKeys.JWT_SECRET) {\n          const token = jwt.sign({ payload }, configKeys.JWT_SECRET, {\n            expiresIn: \"5d\",\n          });\n          return token;\n        } else {\n          throw new Error(\"JWT_TOKEN_KEY is undefined\");\n        }\n      };\n    const verifyToken = (token:string) => {", "        if (configKeys.JWT_SECRET) {\n            \n            const isVerify =  jwt.verify(token, configKeys.JWT_SECRET)\n            return isVerify;\n        }\n    };\n\n    return {\n        encryptPassword, \n        comparePassword,\n        generateToken,\n        verifyToken\n    }\n      \n}\n", "export type AuthServices = typeof authServices;\nexport type AuthServiceReturn = ReturnType<AuthServices>"]}
{"filename": "src/framework/services/multerServices.ts", "chunked_list": ["import multer, { StorageEngine } from 'multer'\nimport { v4 as uuidv4 } from 'uuid';\nconst storage: StorageEngine = multer.diskStorage({\n    destination: (req, file, cb) => {\n        cb(null, 'public/uploads')\n    },\n    filename: (req, file, cb) => {\n        const uniqueFilename = `${uuidv4()}-${file.originalname}`;\n        cb(null, uniqueFilename);\n    }", "        cb(null, uniqueFilename);\n    }\n});\n\nexport const upload = multer({ storage })\n\n"]}
{"filename": "src/framework/websocket/websocket.ts", "chunked_list": ["import { Server, Socket } from \"socket.io\";\nimport { DefaultEventsMap } from \"socket.io/dist/typed-events\";\n\ninterface User {\n  userId: string;\n  socketId: string;\n}\n\nlet activeUsers: User[] = [];\nlet activeVideoCall: User[] = [];\n\nconst socketConfig = (io: Server<DefaultEventsMap, any>) => {\n  io.on(\"connection\", (socket: Socket<DefaultEventsMap, any>) => {\n    socket.on(\"new-user-add\", (newUserId: string) => {", "      if (!activeUsers.some((user) => user.userId === newUserId)) {\n        activeUsers.push({ userId: newUserId, socketId: socket.id });\n        console.log(`new user connected: ${newUserId}, ${socket.id}`);\n      }\n      io.emit(\"get-users\", activeUsers);\n    });\n\n    socket.on(\"send-message\", (data: any) => {\n      const { receiverId } = data;\n      const user = activeUsers.find((user) => user.userId === receiverId);\n      console.log(`sending message to ${receiverId}`);", "      if (user) {\n        io.to(user.socketId).emit(\"notification\", data)\n        io.to(user.socketId).emit(\"receive-message\", data)\n      }\n      \n    });\n\n    socket.on(\"me\", (userId) => {\n      if (!activeVideoCall.some((user: User) => user.userId === userId)) {\n        activeVideoCall.push({ userId, socketId: socket.id });\n      }\n      socket.emit(\"activeforcall\", activeVideoCall);\n    });\n\n    socket.on(\"calluser\", ({ userToCall, signalData, from, name }) => {\n      io.to(userToCall).emit(\"calluser\", { signal: signalData, from, name });\n    });\n\n    socket.on(\"answercall\", (data) => {\n      io.to(data.to).emit(\"callaccepted\", data.signal);\n    });\n\n    socket.on(\"callend\", (userToCall) => {\n      io.to(userToCall).emit(\"callingcut\", \"call ended\");\n    });\n\n    socket.on(\"disconnect\", () => {\n      activeUsers = activeUsers.filter((user) => user.socketId !== socket.id);\n      console.log(`user disconnected: ${socket.id}`);\n      io.emit(\"get-users\", activeUsers);\n\n      activeVideoCall = activeVideoCall.filter(\n        (user) => user.socketId !== socket.id\n      );\n      io.emit(\"activeforcall\", activeVideoCall);\n    });\n  });\n};\n\nexport default socketConfig;\n", "      if (!activeVideoCall.some((user: User) => user.userId === userId)) {\n        activeVideoCall.push({ userId, socketId: socket.id });\n      }\n      socket.emit(\"activeforcall\", activeVideoCall);\n    });\n\n    socket.on(\"calluser\", ({ userToCall, signalData, from, name }) => {\n      io.to(userToCall).emit(\"calluser\", { signal: signalData, from, name });\n    });\n\n    socket.on(\"answercall\", (data) => {\n      io.to(data.to).emit(\"callaccepted\", data.signal);\n    });\n\n    socket.on(\"callend\", (userToCall) => {\n      io.to(userToCall).emit(\"callingcut\", \"call ended\");\n    });\n\n    socket.on(\"disconnect\", () => {\n      activeUsers = activeUsers.filter((user) => user.socketId !== socket.id);\n      console.log(`user disconnected: ${socket.id}`);\n      io.emit(\"get-users\", activeUsers);\n\n      activeVideoCall = activeVideoCall.filter(\n        (user) => user.socketId !== socket.id\n      );\n      io.emit(\"activeforcall\", activeVideoCall);\n    });\n  });\n};\n\nexport default socketConfig;\n"]}
{"filename": "src/framework/webserver/express.ts", "chunked_list": ["import express, { Application, NextFunction } from \"express\";\nimport morgan from \"morgan\";\nimport CORS from 'cors';\nimport cookieParser from \"cookie-parser\";\nimport bodyParser from \"body-parser\";\nimport configKeys from \"../../config\";\n\n\nconst expressConfig = (app: Application) => {\n", "const expressConfig = (app: Application) => {\n\n    const corsEnable = {\n        origin: configKeys.CLIENT_URL,\n        exposeHeaders: ['Cross-Origin-Opener-Policy', 'Cross-Origin-Resourse-Policy']\n    };\n\n    // express middlewares configuration \n    app.use(CORS(corsEnable));\n    app.use(morgan('dev'));", "    app.use(CORS(corsEnable));\n    app.use(morgan('dev'));\n    app.use(express.json());\n    app.use(cookieParser());\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }))\n    app.use(express.urlencoded({ extended: true }))\n\n\n}", "\n}\n\nexport default expressConfig;"]}
{"filename": "src/framework/webserver/server.ts", "chunked_list": ["import { Server } from 'http';\nimport configKeys from '../../config';\n\nconst serverConfig = (server: Server) => {\n  const startServer = () => {\n    server.listen(configKeys.PORT, '0.0.0.0', () => {\n      console.log(`Server started on http://localhost:${configKeys.PORT}`);\n    });\n  };\n", "  };\n\n  return {\n    startServer,\n  };\n};\n\nexport default serverConfig;\n", ""]}
{"filename": "src/framework/webserver/middlewares/authMiddleware.ts", "chunked_list": ["import { Request, Response, NextFunction } from \"express\";\nimport { HttpStatus } from \"../../../types/httpstatuscodes\";\nimport AppError from \"../../../utilities/appError\";\nimport { authServices } from \"../../services/authServices\";\n\n\nconst userAuthMiddleware = (req: Request, res: Response, next: NextFunction) => {\n  let token: string | null = null;\n  console.log(\"Entered to middleware\");\n\n  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer \")) {\n    token = req.headers.authorization.split(\" \")[1];\n    token = token.replace(/\"/g, \"\"); // Remove double quotes from the token\n  }\n", "  console.log(\"Entered to middleware\");\n\n  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer \")) {\n    token = req.headers.authorization.split(\" \")[1];\n    token = token.replace(/\"/g, \"\"); // Remove double quotes from the token\n  }\n\n  if (!token) {\n    throw new AppError(\"Token not found\", HttpStatus.UNAUTHORIZED);\n  }\n", "  try {\n    const { payload }: any = authServices().verifyToken(token);\n    if(payload) next(); // Call next to proceed to the next middleware or route handler\n    \n  } catch (error) {\n    console.log(error);\n    \n    throw new AppError(\"Unauthorized user\", HttpStatus.UNAUTHORIZED);\n  }\n};\n\nexport default userAuthMiddleware;\n"]}
{"filename": "src/framework/webserver/middlewares/errorHandler.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\nimport AppError from '../../../utilities/appError';\n\nconst errorHandler = (err: AppError, req:Request, res:Response, next: NextFunction) => {\n    err.statusCode = err.statusCode || 500;\n    err.status = err.status || 'error';\n    if(err.statusCode === 404){\n        res.status(err.statusCode).json({ \n            errors: err.status,\n            errorMessage: err.message\n         })\n    } else{\n        res.status(err.statusCode).json({\n            status: err.status,\n            message: err.message\n        })\n    }\n}\n\nexport default errorHandler;"]}
{"filename": "src/framework/webserver/routes/adminAuth.ts", "chunked_list": ["import express from 'express';\nimport authControllers from '../../../adapters/controllers/adminAuthController';\nimport { adminDbRepository } from '../../../application/repositories/adminDbRepositories';\nimport { adminRepositoryMongoDB } from '../../database/Mongodb/repositories/adminRepositories';\nimport { authServiceInterface } from '../../../application/services/authServiceInterface';\nimport { authServices } from '../../services/authServices';\n\nconst adminauthRouter = () => {\n    const router = express.Router();\n    const controllers = authControllers(", "    const router = express.Router();\n    const controllers = authControllers(\n        authServiceInterface,\n        authServices,\n        adminDbRepository,\n        adminRepositoryMongoDB  \n    );\n\n\n    router.post('/login', controllers.loginAdmin);", "\n    router.post('/login', controllers.loginAdmin);\n\n\n\n    return router\n\n}\n\n", "\n\nexport default adminauthRouter;"]}
{"filename": "src/framework/webserver/routes/auth.ts", "chunked_list": ["import express from 'express';\nimport authControllers from '../../../adapters/controllers/authControllers';\nimport { userDbRepository } from '../../../application/repositories/userDbRepositories';\nimport { userRepositoryMongoDB } from '../../database/Mongodb/repositories/userRepositories';\nimport { authServiceInterface } from '../../../application/services/authServiceInterface';\nimport { authServices } from '../../services/authServices';\n\nconst authRouter = () => {\n    const router = express.Router();\n    const controllers = authControllers(", "    const router = express.Router();\n    const controllers = authControllers(\n        authServiceInterface,\n        authServices,\n        userDbRepository,\n        userRepositoryMongoDB\n    );\n\n    router.post('/register', controllers.registerUser);\n", "    router.post('/register', controllers.registerUser);\n\n    router.post('/login', controllers.loginUser);\n\n    router.post('/google_auth', controllers.googleAuth)\n\n    router.patch('/user/block/:id', controllers.blockUser)\n\n    return router\n", "    return router\n\n}\n\n\nexport default authRouter;"]}
{"filename": "src/framework/webserver/routes/chat.ts", "chunked_list": ["import express from 'express';\nimport chatController from '../../../adapters/controllers/chatController';\nimport { chatRepositoriesInterface } from '../../../application/repositories/chatRepositeries';\nimport { chatRepositoryMongoDB } from '../../database/Mongodb/repositories/chatRepositories';\n\nconst chatRouter = () => {\n    const router = express.Router();\n    const controllers = chatController(chatRepositoriesInterface, chatRepositoryMongoDB);\n\n    // create new chat box between two users", "\n    // create new chat box between two users\n    router.post('/:senderId/:recieverId', controllers.chatCreate);\n\n    // get all chats by user\n    router.get('/:userId', controllers.getChats);\n\n    // get single chat\n    router.get('/:firstId/:secondId', controllers.getSingleChat);\n", "    router.get('/:firstId/:secondId', controllers.getSingleChat);\n\n\n\n    return router;\n}\n\nexport default chatRouter;"]}
{"filename": "src/framework/webserver/routes/message.ts", "chunked_list": ["import express from 'express';\nimport messageController from '../../../adapters/controllers/messageController';\nimport { messageRepositoryInterface } from '../../../application/repositories/messageRepository';\nimport { messageRepositoryMongoDB } from '../../database/Mongodb/repositories/messageRepository';\n\nconst messageRouter = () => {\n    const router = express.Router();\n    const controller = messageController(messageRepositoryInterface, messageRepositoryMongoDB);\n\n    router.post('/', controller.createNewMessage);", "\n    router.post('/', controller.createNewMessage);\n\n    router.get('/:chatId', controller.getUserMessages);\n\n\n    return router;\n};\n\nexport default messageRouter;", "\nexport default messageRouter;"]}
{"filename": "src/framework/webserver/routes/post.ts", "chunked_list": ["import express from \"express\";\nimport postControllers from \"../../../adapters/controllers/postControllers\";\nimport { postDbInterface } from \"../../../application/repositories/postDbRepositories\";\nimport { postRepositoryMongoDb } from \"../../database/Mongodb/repositories/postRepositeries\";\nimport { upload } from \"../../services/multerServices\";\n\nconst  postRouter = () => {\n    const router = express.Router();\n    const controller = postControllers(postDbInterface, postRepositoryMongoDb);\n", "    const controller = postControllers(postDbInterface, postRepositoryMongoDb);\n\n    // get all posts from db\n    router.get('/', controller.getPosts);\n\n    // upload post\n    router.post('/', upload.single('image'), controller.uploadPost);\n\n    // edit post\n    router.put('/edit_post/:postId', controller.editPost)", "    // edit post\n    router.put('/edit_post/:postId', controller.editPost)\n\n    // get posts by a user\n    router.get('/userposts/:userId', controller.getUserPosts)\n\n    // get individual post by id\n    router.get('/post/:id', controller.getPost)\n\n    // delete particular post by id", "\n    // delete particular post by id\n    router.delete('/:id', controller.deletePost)\n\n    // like and dilike post by user\n    router.patch('/like', controller.postLikeUpdate)\n\n    // push comment in post\n    router.patch('/comment/:postId/:userId', controller.commentPost)\n", "    router.patch('/comment/:postId/:userId', controller.commentPost)\n\n    // reply comment\n    router.patch('/comment/reply/:postId/:userId', controller.commentReply)\n\n    // delete comment in post\n    router.delete('/delete_comment/:postId/:index', controller.commentDelete)\n\n    // report post\n    router.post('/report/:userId/:postId', controller.reportPost)", "    // report post\n    router.post('/report/:userId/:postId', controller.reportPost)\n\n    // get reported users\n    router.get('/reported/:postId', controller.getReporters)\n\n    return router;\n};\n    \nexport default postRouter;", "    \nexport default postRouter;\n"]}
{"filename": "src/framework/webserver/routes/index.ts", "chunked_list": ["import {Application} from 'express';\nimport authRouter from './auth';\nimport userRouter from './user';\nimport postRouter from './post';\nimport adminauthRouter from './adminAuth';\nimport chatRouter from './chat';\nimport messageRouter from './message';\nimport userAuthMiddleware from '../middlewares/authMiddleware'\n\nconst routes = (app: Application) => {", "\nconst routes = (app: Application) => {\n    app.use('/api/auth', authRouter());\n    app.use('/api/admin',  adminauthRouter())\n    app.use('/api/user',  userRouter());\n    app.use('/api/post',  postRouter());\n    app.use('/api/chat',  chatRouter());\n    app.use('/api/message',  messageRouter());\n}\n", "}\n\nexport default routes;"]}
{"filename": "src/framework/webserver/routes/user.ts", "chunked_list": ["import express from 'express';\nimport userControllers from '../../../adapters/controllers/userControllers';\nimport { userDbRepository } from '../../../application/repositories/userDbRepositories';\nimport { userRepositoryMongoDB } from '../../database/Mongodb/repositories/userRepositories';\nimport { upload } from '../../services/multerServices';\n\nconst userRouter = () => {\n    const router = express.Router();\n\n    const controllers: any = userControllers(userDbRepository,userRepositoryMongoDB);", "\n    const controllers: any = userControllers(userDbRepository,userRepositoryMongoDB);\n\n    router.get('/all/:id', controllers.getAllUsers)\n\n    router.get('/:id', controllers.getUserById);\n\n    router.patch('/request/:id/:friendId', controllers.sendRequest)\n\n    router.get('/followers/:id', controllers.getFollowersList);", "\n    router.get('/followers/:id', controllers.getFollowersList);\n\n    router.get('/followings/:id', controllers.getFollowingsList);\n\n    router.patch('/', controllers.unfollowUser)\n\n    router.patch('/request/friend/:id/:friendId', controllers.responseFriendRequest)\n\n    router.get('/search/:prefix', controllers.searchUser)", "\n    router.get('/search/:prefix', controllers.searchUser)\n\n    router.put('/:id',upload.single('file'), controllers.updateProfile)\n\n    router.patch('/:userId/:blockId', controllers.blockUser);\n    \n    return router;\n}\n", "}\n\nexport default userRouter;"]}
