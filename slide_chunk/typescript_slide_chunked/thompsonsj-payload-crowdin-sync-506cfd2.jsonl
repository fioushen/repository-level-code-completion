{"filename": "jest.config.ts", "chunked_list": ["import type { Config } from \"jest\";\n\nconst config: Config = {\n  verbose: true,\n  modulePathIgnorePatterns: [\"dist\"],\n  testEnvironment: \"node\",\n  // globalSetup: '<rootDir>/dev/src/tests/globalSetup.ts',\n  roots: [\"<rootDir>/src/\", \"<rootDir>/dev/\"],\n};\n", "};\n\nexport default config;\n"]}
{"filename": "dev/src/payload-types.ts", "chunked_list": ["/* tslint:disable */\n/* eslint-disable */\n/**\n * This file was automatically generated by Payload.\n * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n * and re-run `payload generate:types` to regenerate this file.\n */\n\nexport interface Config {\n  collections: {\n    categories: Category;\n    \"localized-posts\": LocalizedPost;\n    \"nested-field-collection\": NestedFieldCollection;\n    posts: Post;\n    tags: Tag;\n    users: User;\n    \"crowdin-files\": CrowdinFile;\n    \"crowdin-collection-directories\": CrowdinCollectionDirectory;\n    \"crowdin-article-directories\": CrowdinArticleDirectory;\n  };\n  globals: {\n    nav: Nav;\n  };\n}", "export interface Config {\n  collections: {\n    categories: Category;\n    \"localized-posts\": LocalizedPost;\n    \"nested-field-collection\": NestedFieldCollection;\n    posts: Post;\n    tags: Tag;\n    users: User;\n    \"crowdin-files\": CrowdinFile;\n    \"crowdin-collection-directories\": CrowdinCollectionDirectory;\n    \"crowdin-article-directories\": CrowdinArticleDirectory;\n  };\n  globals: {\n    nav: Nav;\n  };\n}", "export interface Category {\n  id: string;\n  name?: string;\n}\nexport interface LocalizedPost {\n  id: string;\n  title?: string;\n  author?: string | User;\n  publishedDate?: string;\n  category?: string | Category;\n  tags?: string[] | Tag[];\n  content?: {\n    [k: string]: unknown;\n  }[];\n  status?: \"draft\" | \"published\";\n  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n  updatedAt: string;\n  createdAt: string;\n}", "export interface User {\n  id: string;\n  name?: string;\n  updatedAt: string;\n  createdAt: string;\n  email: string;\n  resetPasswordToken?: string;\n  resetPasswordExpiration?: string;\n  salt?: string;\n  hash?: string;\n  loginAttempts?: number;\n  lockUntil?: string;\n  password?: string;\n}", "export interface Tag {\n  id: string;\n  name?: string;\n}\nexport interface CrowdinArticleDirectory {\n  id: string;\n  name?: string;\n  crowdinCollectionDirectory?: string | CrowdinCollectionDirectory;\n  crowdinFiles?: string[] | CrowdinFile[];\n  createdAt: string;\n  updatedAt: string;\n  originalId?: number;\n  projectId?: number;\n  directoryId?: number;\n  excludeLocales?: (\"de_DE\" | \"fr_FR\")[];\n}", "export interface CrowdinCollectionDirectory {\n  id: string;\n  name?: string;\n  title?: string;\n  collectionSlug?: string;\n  createdAt: string;\n  updatedAt: string;\n  originalId?: number;\n  projectId?: number;\n  directoryId?: number;\n}", "export interface CrowdinFile {\n  id: string;\n  title?: string;\n  field?: string;\n  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n  createdAt: string;\n  updatedAt: string;\n  originalId?: number;\n  projectId?: number;\n  directoryId?: number;\n  revisionId?: number;\n  name?: string;\n  type?: string;\n  path?: string;\n  fileData?: {\n    json?:\n      | {\n          [k: string]: unknown;\n        }\n      | unknown[]\n      | string\n      | number\n      | boolean\n      | null;\n    html?: string;\n  };\n}", "export interface NestedFieldCollection {\n  id: string;\n  textField?: string;\n  richTextField?: {\n    [k: string]: unknown;\n  }[];\n  textareaField?: string;\n  arrayField?: {\n    textField?: string;\n    richTextField?: {\n      [k: string]: unknown;\n    }[];\n    textareaField?: string;\n    id?: string;\n  }[];\n  layout?: (\n    | {\n        textField?: string;\n        richTextField?: {\n          [k: string]: unknown;\n        }[];\n        textareaField?: string;\n        id?: string;\n        blockName?: string;\n        blockType: \"basicBlock\";\n      }\n    | {\n        richTextField?: {\n          [k: string]: unknown;\n        }[];\n        id?: string;\n        blockName?: string;\n        blockType: \"basicBlockRichText\";\n      }\n    | {\n        textField?: string;\n        richTextField?: {\n          [k: string]: unknown;\n        }[];\n        textareaField?: string;\n        id?: string;\n        blockName?: string;\n        blockType: \"basicBlockMixed\";\n      }\n    | {\n        title?: string;\n        messages?: {\n          title?: string;\n          message?: {\n            [k: string]: unknown;\n          }[];\n          id?: string;\n        }[];\n        id?: string;\n        blockName?: string;\n        blockType: \"testBlockArrayOfRichText\";\n      }\n  )[];\n  group?: {\n    textField?: string;\n    richTextField?: {\n      [k: string]: unknown;\n    }[];\n    textareaField?: string;\n  };\n  tabOneTitle?: string;\n  tabOneContent?: {\n    [k: string]: unknown;\n  }[];\n  tabTwo: {\n    tabTwoTitle?: string;\n    tabTwoContent?: {\n      [k: string]: unknown;\n    }[];\n  };\n  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n  updatedAt: string;\n  createdAt: string;\n}", "export interface Post {\n  id: string;\n  title?: string;\n  author?: string | User;\n  publishedDate?: string;\n  category?: string | Category;\n  tags?: string[] | Tag[];\n  content?: {\n    [k: string]: unknown;\n  }[];\n  status?: \"draft\" | \"published\";\n  updatedAt: string;\n  createdAt: string;\n}", "export interface Nav {\n  id: string;\n  items: {\n    label?: string;\n    id?: string;\n  }[];\n  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n  updatedAt?: string;\n  createdAt?: string;\n}\n"]}
{"filename": "dev/src/payload.config.ts", "chunked_list": ["import { buildConfig } from \"payload/config\";\nimport path from \"path\";\nimport Nav from \"./globals/Nav\";\nimport Categories from \"./collections/Categories\";\nimport LocalizedPosts from \"./collections/LocalizedPosts\";\nimport Posts from \"./collections/Posts\";\nimport NestedFieldCollection from \"./collections/NestedFieldCollection\";\nimport Tags from \"./collections/Tags\";\nimport Users from \"./collections/Users\";\nimport { resolve } from \"path\";", "import Users from \"./collections/Users\";\nimport { resolve } from \"path\";\n\nimport { crowdinSync } from \"../../dist\";\n\nimport dotenv from \"dotenv\";\n\ndotenv.config({\n  path: resolve(__dirname, \"../.env\"),\n});", "  path: resolve(__dirname, \"../.env\"),\n});\n\nexport const localeMap = {\n  de_DE: {\n    crowdinId: \"de\",\n  },\n  fr_FR: {\n    crowdinId: \"fr\",\n  },", "    crowdinId: \"fr\",\n  },\n};\n\nexport default buildConfig({\n  serverURL: process.env.PAYLOAD_PUBLIC_SERVER_URL || \"http://localhost:3000\",\n  admin: {\n    user: Users.slug,\n  },\n  plugins: [", "  },\n  plugins: [\n    crowdinSync({\n      projectId: 323731,\n      directoryId: 1169,\n      token: `fake-token`, // CrowdIn API is mocked but we need a token to pass schema validation\n      localeMap,\n      sourceLocale: \"en\",\n    }),\n  ],", "    }),\n  ],\n  collections: [\n    Categories,\n    LocalizedPosts,\n    NestedFieldCollection,\n    Posts,\n    Tags,\n    Users,\n  ],", "    Users,\n  ],\n  globals: [Nav],\n  localization: {\n    locales: [\"en\", ...Object.keys(localeMap)],\n    defaultLocale: \"en\",\n    fallback: true,\n  },\n  typescript: {\n    outputFile: path.resolve(__dirname, \"payload-types.ts\"),", "  typescript: {\n    outputFile: path.resolve(__dirname, \"payload-types.ts\"),\n  },\n  graphQL: {\n    schemaOutputFile: path.resolve(__dirname, \"generated-schema.graphql\"),\n  },\n});\n"]}
{"filename": "dev/src/server.ts", "chunked_list": ["import express from \"express\";\nimport payload from \"payload\";\nimport { resolve } from \"path\";\n\nrequire(\"dotenv\").config({\n  path: resolve(__dirname, \"../.env\"),\n});\nconst app = express();\n\n// Redirect root to Admin panel", "\n// Redirect root to Admin panel\napp.get(\"/\", (_, res) => {\n  res.redirect(\"/admin\");\n});\n\n// Initialize Payload\npayload.init({\n  secret: process.env.PAYLOAD_SECRET,\n  mongoURL: process.env.MONGODB_URI,", "  secret: process.env.PAYLOAD_SECRET,\n  mongoURL: process.env.MONGODB_URI,\n  express: app,\n  onInit: () => {\n    payload.logger.info(`Payload Admin URL: ${payload.getAdminURL()}`);\n  },\n});\n\n// Add your own express routes here\n", "// Add your own express routes here\n\napp.listen(3000);\n"]}
{"filename": "dev/src/collections/Categories.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst Categories: CollectionConfig = {\n  slug: \"categories\",\n  admin: {\n    useAsTitle: \"name\",\n  },\n  access: {\n    read: () => true,\n  },", "    read: () => true,\n  },\n  fields: [\n    {\n      name: \"name\",\n      type: \"text\",\n    },\n  ],\n  timestamps: false,\n};", "  timestamps: false,\n};\n\nexport default Categories;\n"]}
{"filename": "dev/src/collections/NestedFieldCollection.ts", "chunked_list": ["import { Block, CollectionConfig } from \"payload/types\";\nimport { basicLocalizedFields } from \"./fields/basicLocalizedFields\";\n\nconst BasicBlockTextFields: Block = {\n  slug: \"basicBlock\", // required\n  fields: basicLocalizedFields,\n};\n\nconst BasicBlockRichTextField: Block = {\n  slug: \"basicBlockRichText\", // required", "const BasicBlockRichTextField: Block = {\n  slug: \"basicBlockRichText\", // required\n  fields: [\n    {\n      name: \"richTextField\",\n      type: \"richText\",\n      localized: true,\n    },\n  ],\n};", "  ],\n};\n\nconst BasicBlockMixedFields: Block = {\n  slug: \"basicBlockMixed\", // required\n  fields: [\n    ...basicLocalizedFields,\n    {\n      name: \"richTextField\",\n      type: \"richText\",", "      name: \"richTextField\",\n      type: \"richText\",\n      localized: true,\n    },\n  ],\n};\n\nconst TestBlockArrayOfRichText: Block = {\n  slug: \"testBlockArrayOfRichText\",\n  fields: [", "  slug: \"testBlockArrayOfRichText\",\n  fields: [\n    {\n      name: \"title\",\n      type: \"text\",\n      localized: true,\n    },\n    {\n      name: \"messages\",\n      type: \"array\",", "      name: \"messages\",\n      type: \"array\",\n      localized: true,\n      maxRows: 3,\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n          localized: true,\n        },", "          localized: true,\n        },\n        {\n          name: \"message\",\n          type: \"richText\",\n        },\n      ],\n    },\n  ],\n};", "  ],\n};\n\nconst NestedFieldCollection: CollectionConfig = {\n  slug: \"nested-field-collection\",\n  access: {\n    read: () => true,\n  },\n  fields: [\n    ...basicLocalizedFields,", "  fields: [\n    ...basicLocalizedFields,\n    // array\n    {\n      name: \"arrayField\",\n      type: \"array\",\n      fields: [...basicLocalizedFields],\n    },\n    // blocks\n    {", "    // blocks\n    {\n      name: \"layout\", // required\n      type: \"blocks\", // required\n      blocks: [\n        BasicBlockTextFields,\n        BasicBlockRichTextField,\n        BasicBlockMixedFields,\n        TestBlockArrayOfRichText,\n      ],", "        TestBlockArrayOfRichText,\n      ],\n    },\n    // collapsible\n    /*{\n      label: 'Collapsible',\n      type: 'collapsible',\n      fields: basicLocalizedFields,\n    },*/\n    // group", "    },*/\n    // group\n    {\n      name: \"group\", // required\n      type: \"group\", // required\n      fields: basicLocalizedFields,\n    },\n    // tabs\n    {\n      type: \"tabs\", // required", "    {\n      type: \"tabs\", // required\n      tabs: [\n        {\n          label: \"Tab One Label\", // required\n          fields: [\n            {\n              name: \"tabOneTitle\",\n              type: \"text\",\n              localized: true,", "              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"tabOneContent\",\n              type: \"richText\",\n              localized: true,\n            },\n          ],\n        },", "          ],\n        },\n        {\n          name: \"tabTwo\",\n          label: \"Tab Two Label\",\n          fields: [\n            {\n              name: \"tabTwoTitle\",\n              type: \"text\",\n              localized: true,", "              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"tabTwoContent\",\n              type: \"richText\",\n              localized: true,\n            },\n          ],\n        },", "          ],\n        },\n      ],\n    },\n  ],\n};\n\nexport default NestedFieldCollection;\n", ""]}
{"filename": "dev/src/collections/Users.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst Users: CollectionConfig = {\n  slug: \"users\",\n  auth: true,\n  admin: {\n    useAsTitle: \"email\",\n  },\n  access: {\n    read: () => true,", "  access: {\n    read: () => true,\n  },\n  fields: [\n    // Email added by default\n    {\n      name: \"name\",\n      type: \"text\",\n    },\n  ],", "    },\n  ],\n};\n\nexport default Users;\n"]}
{"filename": "dev/src/collections/Tags.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst Tags: CollectionConfig = {\n  slug: \"tags\",\n  admin: {\n    useAsTitle: \"name\",\n  },\n  access: {\n    read: () => true,\n  },", "    read: () => true,\n  },\n  fields: [\n    {\n      name: \"name\",\n      type: \"text\",\n    },\n  ],\n  timestamps: false,\n};", "  timestamps: false,\n};\n\nexport default Tags;\n"]}
{"filename": "dev/src/collections/LocalizedPosts.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst Posts: CollectionConfig = {\n  slug: \"localized-posts\",\n  admin: {\n    defaultColumns: [\"title\", \"author\", \"category\", \"tags\", \"status\"],\n    useAsTitle: \"title\",\n  },\n  access: {\n    read: () => true,", "  access: {\n    read: () => true,\n  },\n  fields: [\n    {\n      name: \"title\",\n      type: \"text\",\n      localized: true,\n    },\n    {", "    },\n    {\n      name: \"author\",\n      type: \"relationship\",\n      relationTo: \"users\",\n    },\n    {\n      name: \"publishedDate\",\n      type: \"date\",\n    },", "      type: \"date\",\n    },\n    {\n      name: \"category\",\n      type: \"relationship\",\n      relationTo: \"categories\",\n    },\n    {\n      name: \"tags\",\n      type: \"relationship\",", "      name: \"tags\",\n      type: \"relationship\",\n      relationTo: \"tags\",\n      hasMany: true,\n    },\n    {\n      name: \"content\",\n      type: \"richText\",\n      localized: true,\n    },", "      localized: true,\n    },\n    {\n      name: \"status\",\n      type: \"select\",\n      options: [\n        {\n          value: \"draft\",\n          label: \"Draft\",\n        },", "          label: \"Draft\",\n        },\n        {\n          value: \"published\",\n          label: \"Published\",\n        },\n      ],\n      defaultValue: \"draft\",\n      admin: {\n        position: \"sidebar\",", "      admin: {\n        position: \"sidebar\",\n      },\n    },\n  ],\n};\n\nexport default Posts;\n", ""]}
{"filename": "dev/src/collections/Posts.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst Posts: CollectionConfig = {\n  slug: \"posts\",\n  admin: {\n    defaultColumns: [\"title\", \"author\", \"category\", \"tags\", \"status\"],\n    useAsTitle: \"title\",\n  },\n  access: {\n    read: () => true,", "  access: {\n    read: () => true,\n  },\n  fields: [\n    {\n      name: \"title\",\n      type: \"text\",\n    },\n    {\n      name: \"author\",", "    {\n      name: \"author\",\n      type: \"relationship\",\n      relationTo: \"users\",\n    },\n    {\n      name: \"publishedDate\",\n      type: \"date\",\n    },\n    {", "    },\n    {\n      name: \"category\",\n      type: \"relationship\",\n      relationTo: \"categories\",\n    },\n    {\n      name: \"tags\",\n      type: \"relationship\",\n      relationTo: \"tags\",", "      type: \"relationship\",\n      relationTo: \"tags\",\n      hasMany: true,\n    },\n    {\n      name: \"content\",\n      type: \"richText\",\n    },\n    {\n      name: \"status\",", "    {\n      name: \"status\",\n      type: \"select\",\n      options: [\n        {\n          value: \"draft\",\n          label: \"Draft\",\n        },\n        {\n          value: \"published\",", "        {\n          value: \"published\",\n          label: \"Published\",\n        },\n      ],\n      defaultValue: \"draft\",\n      admin: {\n        position: \"sidebar\",\n      },\n    },", "      },\n    },\n  ],\n};\n\nexport default Posts;\n"]}
{"filename": "dev/src/collections/fields/basicLocalizedFields.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\nexport const basicLocalizedFields: Field[] = [\n  {\n    name: \"textField\",\n    type: \"text\",\n    localized: true,\n  },\n  {\n    name: \"richTextField\",", "  {\n    name: \"richTextField\",\n    type: \"richText\",\n    localized: true,\n  },\n  {\n    name: \"textareaField\",\n    type: \"textarea\",\n    localized: true,\n  },", "    localized: true,\n  },\n];\n"]}
{"filename": "dev/src/tests/files.test.ts", "chunked_list": ["import mongoose from \"mongoose\";\nimport payload from \"payload\";\nimport { initPayloadTest } from \"./helpers/config\";\nimport {\n  getFileByDocumentID,\n  getFilesByDocumentID,\n  getArticleDirectory,\n} from \"../../../dist/api/helpers\";\n\n/**", "\n/**\n * Test files\n *\n * Ensure that files are created for Crowdin as expected.\n *\n * Note: This test suite is not intended to test file contents.\n * This is the responsibility of buildCrowdinHtmlObject and\n * buildCrowdinJsonObject which are unit tested in `src/utilities`.\n */", " * buildCrowdinJsonObject which are unit tested in `src/utilities`.\n */\n\nconst collections = {\n  nonLocalized: \"posts\",\n  localized: \"localized-posts\",\n  nestedFields: \"nested-field-collection\",\n};\n\ndescribe(`Crowdin file create, update and delete`, () => {", "\ndescribe(`Crowdin file create, update and delete`, () => {\n  beforeAll(async () => {\n    await initPayloadTest({ __dirname });\n  });\n\n  afterAll(async () => {\n    await mongoose.connection.dropDatabase();\n    await mongoose.connection.close();\n    await payload.mongoMemoryServer.stop();", "    await mongoose.connection.close();\n    await payload.mongoMemoryServer.stop();\n  });\n\n  describe(`Collection: ${collections.localized}`, () => {\n    it(\"updates the `fields` file for a new article\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });", "        data: { title: \"Test post\" },\n      });\n      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n      expect(file.fileData.json).toEqual({ title: \"Test post\" });\n    });\n\n    it(\"updates the `fields` file if a text field has changed\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },", "        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n      const updatedPost = await payload.update({\n        id: post.id,\n        collection: collections.localized,\n        data: { title: \"Test post updated\" },\n      });\n      const updatedFile = await getFileByDocumentID(\"fields\", post.id, payload);", "      });\n      const updatedFile = await getFileByDocumentID(\"fields\", post.id, payload);\n      expect(file.updatedAt).not.toEqual(updatedFile.updatedAt);\n      expect(updatedFile.fileData.json).toEqual({ title: \"Test post updated\" });\n    });\n  });\n\n  describe(`Collection: ${collections.nestedFields}`, () => {\n    it(\"does not create files for empty localized fields\", async () => {\n      const article = await payload.create({", "    it(\"does not create files for empty localized fields\", async () => {\n      const article = await payload.create({\n        collection: collections.nestedFields,\n        data: {},\n      });\n\n      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n      expect(crowdinFiles.length).toEqual(0);\n    });\n", "    });\n\n    it(\"creates files containing fieldType content\", async () => {\n      const article = await payload.create({\n        collection: collections.nestedFields,\n        locale: \"en\",\n        data: {\n          textField: \"Test title\",\n          richTextField: [\n            {", "          richTextField: [\n            {\n              children: [\n                {\n                  text: \"Test content\",\n                },\n              ],\n            },\n          ],\n          textareaField: \"Test meta description\",", "          ],\n          textareaField: \"Test meta description\",\n        },\n      });\n      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n      expect(crowdinFiles.length).toEqual(2);\n      expect(\n        crowdinFiles.find((file) => file.name === \"richTextField.html\")\n      ).toBeDefined();\n      expect(", "      ).toBeDefined();\n      expect(\n        crowdinFiles.find((file) => file.name === \"fields.json\")\n      ).toBeDefined();\n    });\n\n    it(\"creates files containing `array` fieldType content\", async () => {\n      const article = await payload.create({\n        collection: collections.nestedFields,\n        data: {", "        collection: collections.nestedFields,\n        data: {\n          arrayField: [\n            {\n              textField: \"Test title 1\",\n              richTextField: [\n                {\n                  children: [\n                    {\n                      text: \"Test content 1\",", "                    {\n                      text: \"Test content 1\",\n                    },\n                  ],\n                },\n              ],\n              textareaField: \"Test meta description 1\",\n            },\n            {\n              textField: \"Test title 2\",", "            {\n              textField: \"Test title 2\",\n              richTextField: [\n                {\n                  children: [\n                    {\n                      text: \"Test content 2\",\n                    },\n                  ],\n                },", "                  ],\n                },\n              ],\n              textareaField: \"Test meta description 2\",\n            },\n          ],\n        },\n      });\n      const ids = article.arrayField.map((item) => item.id);\n      const crowdinFiles = await getFilesByDocumentID(article.id, payload);", "      const ids = article.arrayField.map((item) => item.id);\n      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n      expect(crowdinFiles.length).toEqual(3);\n      expect(\n        crowdinFiles.find(\n          (file) => file.name === `arrayField.${ids[0]}.richTextField.html`\n        )\n      ).toBeDefined();\n      expect(\n        crowdinFiles.find(", "      expect(\n        crowdinFiles.find(\n          (file) => file.name === `arrayField.${ids[1]}.richTextField.html`\n        )\n      ).toBeDefined();\n      expect(\n        crowdinFiles.find((file) => file.name === \"fields.json\")\n      ).toBeDefined();\n    });\n", "    });\n\n    it(\"creates files containing `blocks` fieldType content\", async () => {\n      const article = await payload.create({\n        collection: collections.nestedFields,\n        data: {\n          layout: [\n            {\n              textField: \"Test title 1\",\n              richTextField: [", "              textField: \"Test title 1\",\n              richTextField: [\n                {\n                  children: [\n                    {\n                      text: \"Test content 1\",\n                    },\n                  ],\n                },\n              ],", "                },\n              ],\n              textareaField: \"Test meta description 1\",\n              blockType: \"basicBlock\",\n            },\n            {\n              messages: [\n                {\n                  message: [\n                    {", "                  message: [\n                    {\n                      children: [\n                        {\n                          text: \"Test content 1\",\n                        },\n                      ],\n                    },\n                  ],\n                  id: \"64735620230d57bce946d370\",", "                  ],\n                  id: \"64735620230d57bce946d370\",\n                },\n                {\n                  message: [\n                    {\n                      children: [\n                        {\n                          text: \"Test content 1\",\n                        },", "                          text: \"Test content 1\",\n                        },\n                      ],\n                    },\n                  ],\n                  id: \"64735621230d57bce946d371\",\n                },\n              ],\n              blockType: \"testBlockArrayOfRichText\",\n            },", "              blockType: \"testBlockArrayOfRichText\",\n            },\n          ],\n        },\n      });\n      const blockIds = article.layout.map((item) => item.id);\n      const blockTypes = article.layout.map((item) => item.blockType);\n      const arrayIds = article.layout[1].messages.map((item) => item.id);\n      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n      expect(crowdinFiles.length).toEqual(4);", "      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n      expect(crowdinFiles.length).toEqual(4);\n      const jsonFile = crowdinFiles.find((file) => file.name === \"fields.json\");\n      expect(\n        crowdinFiles.find(\n          (file) =>\n            file.name ===\n            `layout.${blockIds[0]}.${blockTypes[0]}.richTextField.html`\n        )\n      ).toBeDefined();", "        )\n      ).toBeDefined();\n      expect(\n        crowdinFiles.find(\n          (file) =>\n            file.name ===\n            `layout.${blockIds[1]}.${blockTypes[1]}.messages.${arrayIds[0]}.message.html`\n        )\n      ).toBeDefined();\n      expect(", "      ).toBeDefined();\n      expect(\n        crowdinFiles.find(\n          (file) =>\n            file.name ===\n            `layout.${blockIds[1]}.${blockTypes[1]}.messages.${arrayIds[1]}.message.html`\n        )\n      ).toBeDefined();\n      expect(jsonFile).toBeDefined();\n      expect(jsonFile.fileData.json).toEqual({", "      expect(jsonFile).toBeDefined();\n      expect(jsonFile.fileData.json).toEqual({\n        layout: {\n          [blockIds[0]]: {\n            basicBlock: {\n              textareaField: \"Test meta description 1\",\n              textField: \"Test title 1\",\n            },\n          },\n        },", "          },\n        },\n      });\n    });\n\n    it(\"deletes the `fields` file when an existing article is deleted\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });", "        data: { title: \"Test post\" },\n      });\n      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n      expect(file.fileData.json).toEqual({ title: \"Test post\" });\n      const deletedPost = await payload.delete({\n        collection: collections.localized,\n        id: post.id,\n      });\n      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n      expect(crowdinFiles.length).toEqual(0);", "      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n      expect(crowdinFiles.length).toEqual(0);\n    });\n\n    it(\"deletes the collection Crowdin article directory when an existing article is deleted\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      const file = await getFileByDocumentID(\"fields\", post.id, payload);", "      });\n      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n      expect(file.fileData.json).toEqual({ title: \"Test post\" });\n      const deletedPost = await payload.delete({\n        collection: collections.localized,\n        id: post.id,\n      });\n      const crowdinPayloadArticleDirectory = await getArticleDirectory(\n        post.id,\n        payload", "        post.id,\n        payload\n      );\n      expect(crowdinPayloadArticleDirectory).toBeUndefined();\n    });\n  });\n});\n"]}
{"filename": "dev/src/tests/translations.test.ts", "chunked_list": ["import mongoose from \"mongoose\";\nimport payload from \"payload\";\nimport { initPayloadTest } from \"./helpers/config\";\nimport { payloadCrowdinSyncTranslationsApi } from \"../../../dist/api/payload-crowdin-sync/translations\";\nimport nock from \"nock\";\nimport { payloadCreateData } from \"./fixtures/nested-field-collection/simple-blocks.fixture\";\nimport { payloadCreateBlocksRichTextData } from \"./fixtures/nested-field-collection/rich-text-blocks.fixture\";\n\n/**\n * Test translations", "/**\n * Test translations\n *\n * Ensure translations are retrieved, compared, and\n * stored as expected.\n */\n\nconst collections = {\n  nonLocalized: \"posts\",\n  localized: \"localized-posts\",", "  nonLocalized: \"posts\",\n  localized: \"localized-posts\",\n  nestedFields: \"nested-field-collection\",\n};\n\nconst pluginOptions = {\n  projectId: 323731,\n  directoryId: 1169,\n  token: process.env.CROWDIN_TOKEN,\n  localeMap: {", "  token: process.env.CROWDIN_TOKEN,\n  localeMap: {\n    de_DE: {\n      crowdinId: \"de\",\n    },\n    fr_FR: {\n      crowdinId: \"fr\",\n    },\n  },\n  sourceLocale: \"en\",", "  },\n  sourceLocale: \"en\",\n};\n\ndescribe(\"Translations\", () => {\n  beforeAll(async () => {\n    await initPayloadTest({ __dirname });\n  });\n\n  afterEach(async () => {", "\n  afterEach(async () => {\n    nock.cleanAll();\n  });\n\n  afterAll(async () => {\n    await mongoose.connection.dropDatabase();\n    await mongoose.connection.close();\n    await payload.mongoMemoryServer.stop();\n  });", "    await payload.mongoMemoryServer.stop();\n  });\n\n  describe(\"fn: getTranslation\", () => {\n    it(\"retrieves a translation from Crowdin\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(", "      });\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n        pluginOptions,\n        payload\n      );\n      const scope = nock(\"https://api.crowdin.com\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, {", "        )\n        .reply(200, {\n          title: \"Testbeitrag\",\n        })\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, {\n          title: \"Poste d'essai\",\n        });", "          title: \"Poste d'essai\",\n        });\n      const translation = await translationsApi.getTranslation({\n        documentId: post.id,\n        fieldName: \"fields\",\n        locale: \"de_DE\",\n      });\n      expect(translation).toEqual({\n        title: \"Testbeitrag\",\n      });", "        title: \"Testbeitrag\",\n      });\n    });\n  });\n\n  describe(\"fn: updateTranslation\", () => {\n    it(\"updates a Payload article with a `text` field translation retrieved from Crowdin\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },", "        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n        pluginOptions,\n        payload\n      );\n      const scope = nock(\"https://api.crowdin.com\")\n        .get(\n          `/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de`", "        .get(\n          `/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de`\n        )\n        .reply(200, {\n          title: \"Testbeitrag\",\n        })\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, {", "        )\n        .reply(200, {\n          title: \"Poste d'essai\",\n        });\n      const translation = await translationsApi.updateTranslation({\n        documentId: post.id,\n        collection: collections.localized,\n        dryRun: false,\n      });\n      // retrieve translated post from Payload", "      });\n      // retrieve translated post from Payload\n      const result = await payload.findByID({\n        collection: collections.localized,\n        id: post.id,\n        locale: \"de_DE\",\n      });\n      expect(result.title).toEqual(\"Testbeitrag\");\n    });\n", "    });\n\n    it(\"updates a Payload article with a `richText` field translation retrieved from Crowdin\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: {\n          content: [\n            {\n              children: [\n                {", "              children: [\n                {\n                  text: \"Test content\",\n                },\n              ],\n            },\n          ],\n        },\n      });\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(", "      });\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n        pluginOptions,\n        payload\n      );\n      const scope = nock(\"https://api.crowdin.com\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, \"<p>Testbeitrag</p>\")", "        )\n        .reply(200, \"<p>Testbeitrag</p>\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, {\n          title: \"Poste d'essai\",\n        });\n      const translation = await translationsApi.updateTranslation({\n        documentId: post.id,", "      const translation = await translationsApi.updateTranslation({\n        documentId: post.id,\n        collection: collections.localized,\n        dryRun: false,\n      });\n      // retrieve translated post from Payload\n      const result = await payload.findByID({\n        collection: collections.localized,\n        id: post.id,\n        locale: \"de_DE\",", "        id: post.id,\n        locale: \"de_DE\",\n      });\n      expect(result.content).toEqual([\n        {\n          children: [{ text: \"Testbeitrag\" }],\n          type: \"p\",\n        },\n      ]);\n    });", "      ]);\n    });\n\n    it(\"updates a Payload article with a *blocks* field translation retrieved from Crowdin\", async () => {\n      const post = await payload.create({\n        collection: collections.nestedFields,\n        data: payloadCreateData,\n      });\n      // we need the ids created by Payload to update the blocks\n      const blockIds = post.layout.map((block) => block.id);", "      // we need the ids created by Payload to update the blocks\n      const blockIds = post.layout.map((block) => block.id);\n      const blockTypes = post.layout.map((block) => block.blockType);\n      const responseDe = {\n        layout: {\n          [blockIds[0]]: {\n            [blockTypes[0]]: {\n              textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n              textareaField:\n                \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",", "              textareaField:\n                \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n            },\n          },\n          [blockIds[1]]: {\n            [blockTypes[1]]: {\n              textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n              textareaField:\n                \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n            },", "                \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n            },\n          },\n        },\n      };\n      const responseFr = {\n        layout: {\n          [blockIds[0]]: {\n            [blockTypes[0]]: {\n              textField:", "            [blockTypes[0]]: {\n              textField:\n                \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 0\",\n              textareaField:\n                \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 0\",\n            },\n          },\n          [blockIds[1]]: {\n            [blockTypes[1]]: {\n              textField:", "            [blockTypes[1]]: {\n              textField:\n                \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 1\",\n              textareaField:\n                \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 1\",\n            },\n          },\n        },\n      };\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(", "      };\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n        pluginOptions,\n        payload\n      );\n      const scope = nock(\"https://api.crowdin.com\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, responseDe)", "        )\n        .reply(200, responseDe)\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, responseFr);\n      const translation = await translationsApi.updateTranslation({\n        documentId: post.id,\n        collection: collections.nestedFields,\n        dryRun: false,", "        collection: collections.nestedFields,\n        dryRun: false,\n      });\n      // retrieve translated post from Payload\n      const resultDe = await payload.findByID({\n        collection: collections.nestedFields,\n        id: post.id,\n        locale: \"de_DE\",\n      });\n      expect(resultDe.layout).toEqual([", "      });\n      expect(resultDe.layout).toEqual([\n        {\n          textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n          id: blockIds[0],\n          blockType: \"basicBlock\",\n        },\n        {\n          textField: \"Textfeldinhalt im Block bei Layoutindex 1\",", "        {\n          textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n          id: blockIds[1],\n          blockType: \"basicBlock\",\n        },\n      ]);\n      // retrieve translated post from Payload\n      const resultFr = await payload.findByID({\n        collection: collections.nestedFields,", "      const resultFr = await payload.findByID({\n        collection: collections.nestedFields,\n        id: post.id,\n        locale: \"fr_FR\",\n      });\n      expect(resultFr.layout).toEqual([\n        {\n          textField:\n            \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 0\",\n          textareaField:", "            \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 0\",\n          textareaField:\n            \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 0\",\n          id: blockIds[0],\n          blockType: \"basicBlock\",\n        },\n        {\n          textField:\n            \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 1\",\n          textareaField:", "            \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 1\",\n          textareaField:\n            \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 1\",\n          id: blockIds[1],\n          blockType: \"basicBlock\",\n        },\n      ]);\n    });\n\n    it(\"updates a Payload article with a *blocks* field translation retrieved from Crowdin and detects no change on the next update attempt\", async () => {", "\n    it(\"updates a Payload article with a *blocks* field translation retrieved from Crowdin and detects no change on the next update attempt\", async () => {\n      const post = await payload.create({\n        collection: collections.nestedFields,\n        data: payloadCreateData,\n      });\n      // we need the ids created by Payload to update the blocks\n      const blockIds = post.layout.map((block) => block.id);\n      const blockTypes = post.layout.map((block) => block.blockType);\n      const responseDe = {", "      const blockTypes = post.layout.map((block) => block.blockType);\n      const responseDe = {\n        layout: {\n          [blockIds[0]]: {\n            [blockTypes[0]]: {\n              textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n              textareaField:\n                \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n            },\n          },", "            },\n          },\n          [blockIds[1]]: {\n            [blockTypes[1]]: {\n              textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n              textareaField:\n                \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n            },\n          },\n        },", "          },\n        },\n      };\n      const responseFr = {\n        layout: {\n          [blockIds[0]]: {\n            [blockTypes[0]]: {\n              textField:\n                \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 0\",\n              textareaField:", "                \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 0\",\n              textareaField:\n                \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 0\",\n            },\n          },\n          [blockIds[1]]: {\n            [blockTypes[1]]: {\n              textField:\n                \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 1\",\n              textareaField:", "                \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 1\",\n              textareaField:\n                \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 1\",\n            },\n          },\n        },\n      };\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n        pluginOptions,\n        payload", "        pluginOptions,\n        payload\n      );\n      const scope = nock(\"https://api.crowdin.com\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, responseDe)\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"", "        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, responseFr);\n      const translation = await translationsApi.updateTranslation({\n        documentId: post.id,\n        collection: collections.nestedFields,\n        dryRun: false,\n      });\n      // retrieve translated post from Payload", "      });\n      // retrieve translated post from Payload\n      const resultDe = await payload.findByID({\n        collection: collections.nestedFields,\n        id: post.id,\n        locale: \"de_DE\",\n      });\n      expect(resultDe.layout).toEqual([\n        {\n          textField: \"Textfeldinhalt im Block bei Layoutindex 0\",", "        {\n          textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n          id: blockIds[0],\n          blockType: \"basicBlock\",\n        },\n        {\n          textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n          id: blockIds[1],", "          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n          id: blockIds[1],\n          blockType: \"basicBlock\",\n        },\n      ]);\n      // retrieve translated post from Payload\n      const resultFr = await payload.findByID({\n        collection: collections.nestedFields,\n        id: post.id,\n        locale: \"fr_FR\",", "        id: post.id,\n        locale: \"fr_FR\",\n      });\n      expect(resultFr.layout).toEqual([\n        {\n          textField:\n            \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 0\",\n          textareaField:\n            \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 0\",\n          id: blockIds[0],", "            \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 0\",\n          id: blockIds[0],\n          blockType: \"basicBlock\",\n        },\n        {\n          textField:\n            \"Contenu du champ de texte dans le bloc \u00e0 l'index de mise en page 1\",\n          textareaField:\n            \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 1\",\n          id: blockIds[1],", "            \"Contenu du champ Textarea dans le bloc \u00e0 l'index de mise en page 1\",\n          id: blockIds[1],\n          blockType: \"basicBlock\",\n        },\n      ]);\n      const nextScope = nock(\"https://api.crowdin.com\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, responseDe)", "        )\n        .reply(200, responseDe)\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, responseFr);\n      const nextTranslation = await translationsApi.updateTranslation({\n        documentId: post.id,\n        collection: collections.nestedFields,\n        dryRun: false,", "        collection: collections.nestedFields,\n        dryRun: false,\n      });\n      expect(nextTranslation.translations[\"de_DE\"].changed).toBe(false);\n      expect(nextTranslation.translations[\"fr_FR\"].changed).toBe(false);\n    });\n\n    it(\"updates a Payload article with *blocks* rich text translations retrieved from Crowdin\", async () => {\n      const post = await payload.create({\n        collection: collections.nestedFields,", "      const post = await payload.create({\n        collection: collections.nestedFields,\n        data: payloadCreateBlocksRichTextData,\n      });\n      // we need the ids created by Payload to update the blocks\n      const blockIds = post.layout.map((block) => block.id);\n      const blockTypes = post.layout.map((block) => block.blockType);\n      const responseDeOne =\n        \"<p>Rich-Text-Inhalt im Blocklayout bei Index 0.</p>\";\n      const responseDeTwo =", "        \"<p>Rich-Text-Inhalt im Blocklayout bei Index 0.</p>\";\n      const responseDeTwo =\n        \"<p>Rich-Text-Inhalt im Blocklayout bei Index 1.</p>\";\n      const responseFrOne =\n        \"<p>Contenu de texte enrichi dans la disposition des blocs \u00e0 l'index 0.</p>\";\n      const responseFrTwo =\n        \"<p>Contenu de texte enrichi dans la disposition des blocs \u00e0 l'index 1.</p>\";\n      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n        pluginOptions,\n        payload", "        pluginOptions,\n        payload\n      );\n      const scope = nock(\"https://api.crowdin.com\")\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, responseDeTwo)\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"", "        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n        )\n        .reply(200, responseDeOne)\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, responseFrTwo)\n        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"", "        .get(\n          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n        )\n        .reply(200, responseFrOne);\n      const translation = await translationsApi.updateTranslation({\n        documentId: post.id,\n        collection: collections.nestedFields,\n        dryRun: false,\n      });\n      // retrieve translated post from Payload", "      });\n      // retrieve translated post from Payload\n      const resultDe = await payload.findByID({\n        collection: collections.nestedFields,\n        id: post.id,\n        locale: \"de_DE\",\n      });\n      expect(resultDe.layout).toEqual([\n        {\n          richTextField: [", "        {\n          richTextField: [\n            {\n              children: [\n                {\n                  text: \"Rich-Text-Inhalt im Blocklayout bei Index 0.\",\n                },\n              ],\n              type: \"p\",\n            },", "              type: \"p\",\n            },\n          ],\n          id: blockIds[0],\n          blockType: \"basicBlockRichText\",\n        },\n        {\n          richTextField: [\n            {\n              children: [", "            {\n              children: [\n                {\n                  text: \"Rich-Text-Inhalt im Blocklayout bei Index 1.\",\n                },\n              ],\n              type: \"p\",\n            },\n          ],\n          id: blockIds[1],", "          ],\n          id: blockIds[1],\n          blockType: \"basicBlockRichText\",\n        },\n      ]);\n      // retrieve translated post from Payload\n      const resultFr = await payload.findByID({\n        collection: collections.nestedFields,\n        id: post.id,\n        locale: \"fr_FR\",", "        id: post.id,\n        locale: \"fr_FR\",\n      });\n      expect(resultFr.layout).toEqual([\n        {\n          richTextField: [\n            {\n              children: [\n                {\n                  text: \"Contenu de texte enrichi dans la disposition des blocs \u00e0 l'index 0.\",", "                {\n                  text: \"Contenu de texte enrichi dans la disposition des blocs \u00e0 l'index 0.\",\n                },\n              ],\n              type: \"p\",\n            },\n          ],\n          id: blockIds[0],\n          blockType: \"basicBlockRichText\",\n        },", "          blockType: \"basicBlockRichText\",\n        },\n        {\n          richTextField: [\n            {\n              children: [\n                {\n                  text: \"Contenu de texte enrichi dans la disposition des blocs \u00e0 l'index 1.\",\n                },\n              ],", "                },\n              ],\n              type: \"p\",\n            },\n          ],\n          id: blockIds[1],\n          blockType: \"basicBlockRichText\",\n        },\n      ]);\n    });", "      ]);\n    });\n  });\n});\n"]}
{"filename": "dev/src/tests/collections.test.ts", "chunked_list": ["import mongoose from \"mongoose\";\nimport payload from \"payload\";\nimport { initPayloadTest } from \"./helpers/config\";\nimport {\n  getFilesByDocumentID,\n  getFileByDocumentID,\n} from \"../../../dist/api/helpers\";\n\n/**\n * Test the collections", "/**\n * Test the collections\n *\n * Ensure plugin collections are created and\n * behave as expected.\n *\n * Collections to test:\n *\n * - crowdin-article-directories\n * - crowdin-files", " * - crowdin-article-directories\n * - crowdin-files\n * - crowdin-collection-directories\n *\n * Terminology:\n *\n * - article directory: Crowdin Article Directory\n * - collection directory: Crowdin Collection Directory\n * - file: Crowdin File\n */", " * - file: Crowdin File\n */\n\nconst collections = {\n  nonLocalized: \"posts\",\n  localized: \"localized-posts\",\n};\n\ndescribe(\"Collections\", () => {\n  beforeAll(async () => {", "describe(\"Collections\", () => {\n  beforeAll(async () => {\n    await initPayloadTest({ __dirname });\n  });\n\n  afterAll(async () => {\n    await mongoose.connection.dropDatabase();\n    await mongoose.connection.close();\n    await payload.mongoMemoryServer.stop();\n  });", "    await payload.mongoMemoryServer.stop();\n  });\n\n  describe(\"Non-localized collections\", () => {\n    it(\"does not create an article directory\", async () => {\n      const post = await payload.create({\n        collection: collections.nonLocalized,\n        data: { title: \"Test post\" },\n      });\n      const result = await payload.findByID({", "      });\n      const result = await payload.findByID({\n        collection: collections.nonLocalized,\n        id: post.id,\n      });\n      const crowdinArticleDirectoryId = result.crowdinArticleDirectory?.id;\n      expect(crowdinArticleDirectoryId).toBeUndefined();\n    });\n  });\n", "  });\n\n  describe(\"crowdin-article-directories\", () => {\n    it(\"creates an article directory\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      // retrieve post to get populated fields\n      const result = await payload.findByID({", "      // retrieve post to get populated fields\n      const result = await payload.findByID({\n        collection: collections.localized,\n        id: post.id,\n      });\n      const crowdinArticleDirectoryId = result.crowdinArticleDirectory?.id;\n      expect(crowdinArticleDirectoryId).toBeDefined();\n    });\n\n    it(\"creates only one article directory\", async () => {", "\n    it(\"creates only one article directory\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      // retrieve post to get populated fields\n      const postRefreshed = await payload.findByID({\n        collection: collections.localized,\n        id: post.id,", "        collection: collections.localized,\n        id: post.id,\n      });\n      const crowdinArticleDirectoryId =\n        postRefreshed.crowdinArticleDirectory?.id;\n      const updatedPost = await payload.update({\n        id: post.id,\n        collection: collections.localized,\n        data: { title: \"Updated test post\" },\n      });", "        data: { title: \"Updated test post\" },\n      });\n      // retrieve post to get populated fields\n      const updatedPostRefreshed = await payload.findByID({\n        collection: collections.localized,\n        id: updatedPost.id,\n      });\n      expect(updatedPostRefreshed.crowdinArticleDirectory?.id).toEqual(\n        crowdinArticleDirectoryId\n      );", "        crowdinArticleDirectoryId\n      );\n    });\n\n    it(\"creates unique article directories for two articles created in the same collection\", async () => {\n      const postOne = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post 1\" },\n      });\n      // retrieve post to get populated fields", "      });\n      // retrieve post to get populated fields\n      const postOneRefreshed = await payload.findByID({\n        collection: collections.localized,\n        id: postOne.id,\n      });\n      const postTwo = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post 2\" },\n      });", "        data: { title: \"Test post 2\" },\n      });\n      // retrieve post to get populated fields\n      const postTwoRefreshed = await payload.findByID({\n        collection: collections.localized,\n        id: postTwo.id,\n      });\n      expect(postOneRefreshed.crowdinArticleDirectory.id).not.toEqual(\n        postTwoRefreshed.crowdinArticleDirectory.id\n      );", "        postTwoRefreshed.crowdinArticleDirectory.id\n      );\n    });\n  });\n\n  describe(\"crowdin-files\", () => {\n    it('creates a \"fields\" Crowdin file to include the title field', async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },", "        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n      expect(crowdinFiles.length).toEqual(1);\n      const file = crowdinFiles.find((doc) => doc.field === \"fields\");\n      expect(file).not.toEqual(undefined);\n      expect(file.type).toEqual(\"json\");\n    });\n", "    });\n\n    it('does not create a \"fields\" Crowdin file if all fields are empty strings', async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"\" },\n      });\n      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n      expect(crowdinFiles.length).toEqual(0);\n    });", "      expect(crowdinFiles.length).toEqual(0);\n    });\n\n    const fieldsAndContentTestName =\n      \"creates a `fields` file to include the title field and a `content` file for the content richText field\";\n    it(`${fieldsAndContentTestName}`, async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: {\n          title: `${fieldsAndContentTestName}`,", "        data: {\n          title: `${fieldsAndContentTestName}`,\n          content: [\n            {\n              children: [\n                {\n                  text: `${fieldsAndContentTestName}`,\n                },\n              ],\n            },", "              ],\n            },\n          ],\n        },\n      });\n      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n      expect(crowdinFiles.length).toEqual(2);\n      const fields = crowdinFiles.find((doc) => doc.field === \"fields\");\n      const content = crowdinFiles.find((doc) => doc.field === \"content\");\n      expect(fields).not.toEqual(undefined);", "      const content = crowdinFiles.find((doc) => doc.field === \"content\");\n      expect(fields).not.toEqual(undefined);\n      expect(fields.type).toEqual(\"json\");\n      expect(content).not.toEqual(undefined);\n      expect(content.type).toEqual(\"html\");\n    });\n  });\n\n  describe(\"crowdin-collection-directories\", () => {\n    it(\"associates an article Directory with a collection directory\", async () => {", "  describe(\"crowdin-collection-directories\", () => {\n    it(\"associates an article Directory with a collection directory\", async () => {\n      const post = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post\" },\n      });\n      // retrieve post to get populated fields\n      const result = await payload.findByID({\n        collection: collections.localized,\n        id: post.id,", "        collection: collections.localized,\n        id: post.id,\n      });\n      const crowdinArticleDirectoryId = result.crowdinArticleDirectory?.id;\n      expect(crowdinArticleDirectoryId).toBeDefined();\n      expect(\n        result.crowdinArticleDirectory.crowdinCollectionDirectory.name\n      ).toEqual(collections.localized);\n    });\n", "    });\n\n    it(\"uses the same collection directory for two articles created in the same collection\", async () => {\n      const postOne = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post 1\" },\n      });\n      // retrieve post to get populated fields\n      const postOneRefreshed = await payload.findByID({\n        collection: collections.localized,", "      const postOneRefreshed = await payload.findByID({\n        collection: collections.localized,\n        id: postOne.id,\n      });\n      const postTwo = await payload.create({\n        collection: collections.localized,\n        data: { title: \"Test post 2\" },\n      });\n      // retrieve post to get populated fields\n      const postTwoRefreshed = await payload.findByID({", "      // retrieve post to get populated fields\n      const postTwoRefreshed = await payload.findByID({\n        collection: collections.localized,\n        id: postTwo.id,\n      });\n      expect(\n        postOneRefreshed.crowdinArticleDirectory.crowdinCollectionDirectory\n      ).toEqual(\n        postTwoRefreshed.crowdinArticleDirectory.crowdinCollectionDirectory\n      );", "        postTwoRefreshed.crowdinArticleDirectory.crowdinCollectionDirectory\n      );\n    });\n  });\n});\n"]}
{"filename": "dev/src/tests/fixtures/nested-field-collection/simple-blocks.fixture.ts", "chunked_list": ["export const payloadCreateData = {\n  layout: [\n    {\n      textField: \"Text field content in block at layout index 0\",\n      textareaField: \"Textarea field content in block at layout index 0\",\n      blockType: \"basicBlock\",\n    },\n    {\n      textField: \"Text field content in block at layout index 1\",\n      textareaField: \"Textarea field content in block at layout index 1\",", "      textField: \"Text field content in block at layout index 1\",\n      textareaField: \"Textarea field content in block at layout index 1\",\n      blockType: \"basicBlock\",\n    },\n  ],\n};\n"]}
{"filename": "dev/src/tests/fixtures/nested-field-collection/rich-text-blocks.fixture.ts", "chunked_list": ["export const payloadCreateBlocksRichTextData = {\n  layout: [\n    {\n      richTextField: [\n        {\n          children: [\n            {\n              text: \"Rich text content in block layout at index 0.\",\n            },\n          ],", "            },\n          ],\n        },\n      ],\n      blockType: \"basicBlockRichText\",\n    },\n    {\n      richTextField: [\n        {\n          children: [", "        {\n          children: [\n            {\n              text: \"Rich text content in block layout at index 1.\",\n            },\n          ],\n        },\n      ],\n      blockType: \"basicBlockRichText\",\n    },", "      blockType: \"basicBlockRichText\",\n    },\n  ],\n};\n"]}
{"filename": "dev/src/tests/helpers/config.ts", "chunked_list": ["import payload from \"payload\";\nimport swcRegister from \"@swc/register\";\nimport { v4 as uuid } from \"uuid\";\nimport type { InitOptions } from \"payload/dist/config/types\";\nimport path from \"path\";\nimport express from \"express\";\n\ntype Options = {\n  __dirname: string;\n  init?: Partial<InitOptions>;\n};\n", "export async function initPayloadTest(\n  options: Options\n): Promise<{ serverURL: string }> {\n  const initOptions = {\n    local: true,\n    secret: uuid(),\n    mongoURL: `mongodb://localhost/${uuid()}`,\n    ...(options.init || {}),\n  };\n\n  process.env.NODE_ENV = \"test\";\n  process.env.PAYLOAD_CONFIG_PATH = path.resolve(\n    options.__dirname,\n    \"./../payload.config.ts\"\n  );\n\n  const port = process.env.PORT || 3000;\n", "  if (!initOptions?.local) {\n    initOptions.express = express();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore - bad @swc/register types\n  swcRegister({\n    sourceMaps: \"inline\",\n    jsc: {\n      parser: {\n        syntax: \"typescript\",\n        tsx: true,\n      },\n    },\n    module: {\n      type: \"commonjs\",\n    },\n  });\n\n  await payload.init(initOptions);\n", "  if (initOptions.express) {\n    initOptions.express.listen(port);\n  }\n\n  return { serverURL: `http://localhost:${port}` };\n}\n"]}
{"filename": "dev/src/globals/Nav.ts", "chunked_list": ["import { GlobalConfig } from \"payload/types\";\n\nconst Nav: GlobalConfig = {\n  slug: \"nav\",\n  fields: [\n    {\n      name: \"items\",\n      type: \"array\",\n      required: true,\n      maxRows: 8,", "      required: true,\n      maxRows: 8,\n      fields: [\n        {\n          name: \"label\",\n          type: \"text\",\n          localized: true,\n        },\n      ],\n    },", "      ],\n    },\n  ],\n};\n\nexport default Nav;\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\nexport interface CollectionOptions {\n  directory?: string;\n}\n\nexport interface PluginOptions {\n  projectId: number;\n  /** This should be optional? */\n  directoryId?: number;\n  token: string;\n  //client: crowdinAPIService,\n  localeMap: {\n    [key: string]: {\n      crowdinId: string;\n    };\n  };\n  sourceLocale: string;\n  collections?: Record<string, CollectionOptions>;\n}\n", "export type FieldWithName = Field & { name: string };\n"]}
{"filename": "src/plugin.ts", "chunked_list": ["import type { Config } from \"payload/config\";\nimport type { PluginOptions } from \"./types\";\nimport {\n  getAfterChangeHook,\n  getGlobalAfterChangeHook,\n} from \"./hooks/collections/afterChange\";\nimport { getAfterDeleteHook } from \"./hooks/collections/afterDelete\";\nimport { getFields } from \"./fields/getFields\";\nimport CrowdinFiles from \"./collections/CrowdinFiles\";\nimport CrowdinCollectionDirectories from \"./collections/CrowdinCollectionDirectories\";", "import CrowdinFiles from \"./collections/CrowdinFiles\";\nimport CrowdinCollectionDirectories from \"./collections/CrowdinCollectionDirectories\";\nimport CrowdinArticleDirectories from \"./collections/CrowdinArticleDirectories\";\nimport { containsLocalizedFields } from \"./utilities\";\nimport { getReviewTranslationEndpoint } from \"./endpoints/globals/reviewTranslation\";\nimport { getReviewFieldsEndpoint } from \"./endpoints/globals/reviewFields\";\nimport Joi from \"joi\";\n\n/**\n * This plugin extends all collections that contain localized fields", "/**\n * This plugin extends all collections that contain localized fields\n * by uploading all translation-enabled field content in the default\n * language to Crowdin for translation. Crowdin translations are\n * are synced to fields in all other locales (except the default language).\n *\n **/\n\nexport const crowdinSync =\n  (pluginOptions: PluginOptions) =>", "export const crowdinSync =\n  (pluginOptions: PluginOptions) =>\n  (config: Config): Config => {\n    const initFunctions: (() => void)[] = [];\n\n    // schema validation\n    const schema = Joi.object({\n      projectId: Joi.number().required(),\n\n      directoryId: Joi.number(),", "\n      directoryId: Joi.number(),\n\n      // optional - if not provided, the plugin will not do anything in the afterChange hook.\n      token: Joi.string().required(),\n\n      localeMap: Joi.object().pattern(\n        /./,\n        Joi.object({\n          crowdinId: Joi.string().required(),", "        Joi.object({\n          crowdinId: Joi.string().required(),\n        }).pattern(/./, Joi.any())\n      ),\n\n      sourceLocale: Joi.string().required(),\n    });\n\n    const validate = schema.validate(pluginOptions);\n\n    if (validate.error) {\n      console.log(\n        \"Payload Crowdin Sync option validation errors:\",\n        validate.error\n      );\n    }\n\n    return {\n      ...config,\n      admin: {\n        ...(config.admin || {}),\n      },\n      collections: [\n        ...(config.collections || []).map((existingCollection) => {", "    const validate = schema.validate(pluginOptions);\n\n    if (validate.error) {\n      console.log(\n        \"Payload Crowdin Sync option validation errors:\",\n        validate.error\n      );\n    }\n\n    return {\n      ...config,\n      admin: {\n        ...(config.admin || {}),\n      },\n      collections: [\n        ...(config.collections || []).map((existingCollection) => {", "          if (containsLocalizedFields({ fields: existingCollection.fields })) {\n            const fields = getFields({\n              collection: existingCollection,\n            });\n\n            return {\n              ...existingCollection,\n              hooks: {\n                ...(existingCollection.hooks || {}),\n                afterChange: [\n                  ...(existingCollection.hooks?.afterChange || []),\n                  getAfterChangeHook({\n                    collection: existingCollection,\n                    pluginOptions,\n                  }),\n                ],\n                afterDelete: [\n                  ...(existingCollection.hooks?.afterDelete || []),\n                  getAfterDeleteHook({\n                    pluginOptions,\n                  }),\n                ],\n              },\n              fields,\n            };\n          }\n\n          return existingCollection;\n        }),\n        CrowdinFiles,\n        CrowdinCollectionDirectories,\n        {\n          ...CrowdinArticleDirectories,\n          fields: [\n            ...(CrowdinArticleDirectories.fields || []),\n            {\n              name: \"excludeLocales\",\n              type: \"select\",\n              options: Object.keys(pluginOptions.localeMap),\n              hasMany: true,\n              admin: {\n                description:\n                  \"Select locales to exclude from translation synchronization.\",\n              },\n            },\n          ],\n          endpoints: [\n            ...(CrowdinArticleDirectories.endpoints || []),\n            getReviewTranslationEndpoint({\n              pluginOptions,\n            }),\n            getReviewTranslationEndpoint({\n              pluginOptions,\n              type: \"update\",\n            }),\n            getReviewFieldsEndpoint({\n              pluginOptions\n            })\n          ],\n        },\n      ],\n      globals: [\n        ...(config.globals || []).map((existingGlobal) => {", "          if (containsLocalizedFields({ fields: existingGlobal.fields })) {\n            const fields = getFields({\n              collection: existingGlobal,\n            });\n            return {\n              ...existingGlobal,\n              hooks: {\n                ...(existingGlobal.hooks || {}),\n                afterChange: [\n                  ...(existingGlobal.hooks?.afterChange || []),\n                  getGlobalAfterChangeHook({\n                    global: existingGlobal,\n                    pluginOptions,\n                  }),\n                ],\n              },\n              fields,\n            };\n          }\n\n          return existingGlobal;\n        }),\n      ],\n      onInit: async (payload) => {\n        initFunctions.forEach((fn) => fn());", "        if (config.onInit) await config.onInit(payload);\n      },\n    };\n  };\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { crowdinSync } from \"./plugin\";\n\nexport { crowdinSync };\n"]}
{"filename": "src/collections/CrowdinCollectionDirectories.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst CrowdinCollectionDirectories: CollectionConfig = {\n  slug: \"crowdin-collection-directories\",\n  admin: {\n    defaultColumns: [\"name\", \"title\", \"collectionSlug\", \"updatedAt\"],\n    useAsTitle: \"name\",\n    group: \"Crowdin Admin\",\n  },\n  access: {", "  },\n  access: {\n    read: () => true,\n  },\n  fields: [\n    /* Crowdin field */\n    {\n      name: \"name\",\n      type: \"text\",\n    },", "      type: \"text\",\n    },\n    {\n      name: \"title\",\n      type: \"text\",\n    },\n    /* Internal fields  */\n    {\n      name: \"collectionSlug\",\n      type: \"text\",", "      name: \"collectionSlug\",\n      type: \"text\",\n    },\n\n    /* Crowdin fields */\n    {\n      name: \"createdAt\",\n      type: \"date\",\n    },\n    {", "    },\n    {\n      name: \"updatedAt\",\n      type: \"date\",\n    },\n    {\n      name: \"originalId\",\n      type: \"number\",\n    },\n    {", "    },\n    {\n      name: \"projectId\",\n      type: \"number\",\n    },\n    {\n      name: \"directoryId\",\n      type: \"number\",\n    },\n  ],", "    },\n  ],\n};\n\nexport default CrowdinCollectionDirectories;\n"]}
{"filename": "src/collections/CrowdinFiles.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\nimport {\n  buildCrowdinHtmlObject,\n  buildCrowdinJsonObject,\n  getLocalizedFields,\n} from \"../utilities\";\n\n/*\n  Sample data returned from Crowdin API\n*/", "  Sample data returned from Crowdin API\n*/\n/*\n{\n  data: {\n    revisionId: 5,\n    status: 'active',\n    priority: 'normal',\n    importOptions: { contentSegmentation: true, customSegmentation: false },\n    exportOptions: null,", "    importOptions: { contentSegmentation: true, customSegmentation: false },\n    exportOptions: null,\n    excludedTargetLanguages: null,\n    createdAt: '2022-10-31T18:14:55+00:00',\n    updatedAt: '2022-11-04T16:36:05+00:00',\n    id: 1079,\n    projectId: 323731,\n    branchId: null,\n    directoryId: 1077,\n    name: 'en.html',", "    directoryId: 1077,\n    name: 'en.html',\n    title: null,\n    type: 'html',\n    path: '/policies/security-and-privacy/en.html'\n  }\n}\n*/\n\nconst CrowdinFiles: CollectionConfig = {", "\nconst CrowdinFiles: CollectionConfig = {\n  slug: \"crowdin-files\",\n  admin: {\n    defaultColumns: [\"path\", \"title\", \"field\", \"revisionId\", \"updatedAt\"],\n    useAsTitle: \"path\",\n    group: \"Crowdin Admin\",\n  },\n  access: {\n    read: () => true,", "  access: {\n    read: () => true,\n  },\n  fields: [\n    /* Crowdin field */\n    {\n      name: \"title\",\n      type: \"text\",\n    },\n    /* Internal fields  */", "    },\n    /* Internal fields  */\n    {\n      name: \"field\",\n      type: \"text\",\n    },\n    {\n      name: \"crowdinArticleDirectory\",\n      type: \"relationship\",\n      relationTo: \"crowdin-article-directories\",", "      type: \"relationship\",\n      relationTo: \"crowdin-article-directories\",\n      hasMany: false,\n    },\n    /* Crowdin fields */\n    {\n      name: \"createdAt\",\n      type: \"date\",\n    },\n    {", "    },\n    {\n      name: \"updatedAt\",\n      type: \"date\",\n    },\n    {\n      name: \"originalId\",\n      type: \"number\",\n    },\n    {", "    },\n    {\n      name: \"projectId\",\n      type: \"number\",\n    },\n    {\n      name: \"directoryId\",\n      type: \"number\",\n    },\n    {", "    },\n    {\n      name: \"revisionId\",\n      type: \"number\",\n    },\n    {\n      name: \"name\",\n      type: \"text\",\n    },\n    {", "    },\n    {\n      name: \"type\",\n      type: \"text\",\n    },\n    {\n      name: \"path\",\n      type: \"text\",\n    },\n    {", "    },\n    {\n      name: \"fileData\",\n      type: \"group\",\n      admin: {\n        description: \"The file data submitted to the Crowdin API\",\n      },\n      fields: [\n        {\n          name: \"json\",", "        {\n          name: \"json\",\n          type: \"json\",\n        },\n        {\n          name: \"html\",\n          type: \"textarea\",\n        },\n      ],\n    },", "      ],\n    },\n  ],\n};\n\nexport default CrowdinFiles;\n"]}
{"filename": "src/collections/CrowdinArticleDirectories.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\nconst CrowdinArticleDirectories: CollectionConfig = {\n  slug: \"crowdin-article-directories\",\n  admin: {\n    defaultColumns: [\n      \"name\",\n      \"title\",\n      \"crowdinCollectionDirectory\",\n      \"createdAt\",", "      \"crowdinCollectionDirectory\",\n      \"createdAt\",\n    ],\n    useAsTitle: \"name\",\n    group: \"Crowdin Admin\",\n  },\n  access: {\n    read: () => true,\n  },\n  fields: [", "  },\n  fields: [\n    /* Crowdin field */\n    {\n      name: \"name\",\n      type: \"text\",\n    },\n    /* Internal fields  */\n    {\n      name: \"crowdinCollectionDirectory\",", "    {\n      name: \"crowdinCollectionDirectory\",\n      type: \"relationship\",\n      relationTo: \"crowdin-collection-directories\",\n      hasMany: false,\n    },\n    {\n      name: \"crowdinFiles\",\n      type: \"relationship\",\n      relationTo: \"crowdin-files\",", "      type: \"relationship\",\n      relationTo: \"crowdin-files\",\n      hasMany: true,\n    },\n    /* Crowdin fields */\n    {\n      name: \"createdAt\",\n      type: \"date\",\n    },\n    {", "    },\n    {\n      name: \"updatedAt\",\n      type: \"date\",\n    },\n    {\n      name: \"originalId\",\n      type: \"number\",\n    },\n    {", "    },\n    {\n      name: \"projectId\",\n      type: \"number\",\n    },\n    {\n      name: \"directoryId\",\n      type: \"number\",\n    },\n  ],", "    },\n  ],\n};\n\nexport default CrowdinArticleDirectories;\n"]}
{"filename": "src/endpoints/globals/reviewTranslation.ts", "chunked_list": ["import { Endpoint } from \"payload/config\";\nimport { PluginOptions } from \"../../types\";\nimport { payloadCrowdinSyncTranslationsApi } from \"../../api/payload-crowdin-sync/translations\";\n\nexport const getReviewTranslationEndpoint = ({\n  pluginOptions,\n  type = \"review\",\n}: {\n  pluginOptions: PluginOptions;\n  type?: \"review\" | \"update\";", "  pluginOptions: PluginOptions;\n  type?: \"review\" | \"update\";\n}): Endpoint => ({\n  path: `/:id/${type}`,\n  method: \"get\",\n  handler: async (req, res, next) => {\n    const articleDirectory = await req.payload.findByID({\n      id: req.params.id,\n      collection: req.collection?.config.slug as string,\n    });", "      collection: req.collection?.config.slug as string,\n    });\n    const global =\n      articleDirectory.crowdinCollectionDirectory.collectionSlug === \"globals\";\n    const translationsApi = new payloadCrowdinSyncTranslationsApi(\n      pluginOptions,\n      req.payload\n    );\n    try {\n      const translations = await translationsApi.updateTranslation({\n        documentId: !global && articleDirectory.name,\n        collection: global\n          ? articleDirectory.name\n          : articleDirectory.crowdinCollectionDirectory.collectionSlug,\n        global,\n        dryRun: type === \"update\" ? false : true,\n        excludeLocales: articleDirectory.excludeLocales || [],\n      });\n      res.status(200).send(translations);", "    try {\n      const translations = await translationsApi.updateTranslation({\n        documentId: !global && articleDirectory.name,\n        collection: global\n          ? articleDirectory.name\n          : articleDirectory.crowdinCollectionDirectory.collectionSlug,\n        global,\n        dryRun: type === \"update\" ? false : true,\n        excludeLocales: articleDirectory.excludeLocales || [],\n      });\n      res.status(200).send(translations);", "    } catch (error) {\n      res.status(400).send(error);\n    }\n  },\n});\n"]}
{"filename": "src/endpoints/globals/reviewFields.ts", "chunked_list": ["import { Endpoint } from \"payload/config\";\nimport { PluginOptions } from \"../../types\";\nimport { payloadCrowdinSyncTranslationsApi } from \"../../api/payload-crowdin-sync/translations\";\nimport { getLocalizedFields } from \"../../utilities\";\n\nexport const getReviewFieldsEndpoint = ({\n  pluginOptions,\n}: {\n  pluginOptions: PluginOptions;\n}): Endpoint => ({", "  pluginOptions: PluginOptions;\n}): Endpoint => ({\n  path: `/:id/fields`,\n  method: \"get\",\n  handler: async (req, res, next) => {\n    const articleDirectory = await req.payload.findByID({\n      id: req.params.id,\n      collection: req.collection?.config.slug as string,\n    });\n    const global =", "    });\n    const global =\n      articleDirectory.crowdinCollectionDirectory.collectionSlug === \"globals\";\n    const translationsApi = new payloadCrowdinSyncTranslationsApi(\n      pluginOptions,\n      req.payload\n    );\n    try {\n      const collectionConfig = await translationsApi.getCollectionConfig(global ? articleDirectory.name : articleDirectory.crowdinCollectionDirectory.collectionSlug, global)\n      const response = {\n        fields: collectionConfig.fields,\n        localizedFields: getLocalizedFields({ fields: collectionConfig.fields })\n      }\n      res.status(200).send(response);", "    } catch (error) {\n      res.status(400).send(error);\n    }\n  },\n});\n"]}
{"filename": "src/fields/getFields.ts", "chunked_list": ["import type { CollectionConfig, Field, GlobalConfig } from \"payload/types\";\n\ninterface Args {\n  collection: CollectionConfig | GlobalConfig;\n}\n\nexport const getFields = ({ collection }: Args): Field[] => {\n  const fields = [...collection.fields];\n\n  const crowdinArticleDirectoryField: Field = {\n    name: \"crowdinArticleDirectory\",\n    type: \"relationship\",\n    relationTo: \"crowdin-article-directories\",\n    hasMany: false,\n    /*admin: {\n      readOnly: true,\n      disabled: true,\n    },*/\n  };\n\n  fields.push(crowdinArticleDirectoryField);\n\n  return fields;\n};\n"]}
{"filename": "src/hooks/collections/afterDelete.ts", "chunked_list": ["import { CollectionAfterDeleteHook } from \"payload/types\";\nimport { payloadCrowdinSyncFilesApi } from \"../../api/payload-crowdin-sync/files\";\nimport { PluginOptions } from \"../../types\";\n\ninterface CommonArgs {\n  pluginOptions: PluginOptions;\n}\n\ninterface Args extends CommonArgs {}\n\nexport const getAfterDeleteHook =\n  ({ pluginOptions }: Args): CollectionAfterDeleteHook =>\n  async ({\n    req, // full express request\n    id, // id of document to delete\n    doc, // deleted document\n  }) => {\n    /**\n     * Abort if token not set and not in test mode\n     */", "interface Args extends CommonArgs {}\n\nexport const getAfterDeleteHook =\n  ({ pluginOptions }: Args): CollectionAfterDeleteHook =>\n  async ({\n    req, // full express request\n    id, // id of document to delete\n    doc, // deleted document\n  }) => {\n    /**\n     * Abort if token not set and not in test mode\n     */", "    if (!pluginOptions.token && process.env.NODE_ENV !== \"test\") {\n      return doc;\n    }\n\n    /**\n     * Initialize Crowdin client sourceFilesApi\n     */\n    const filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, req.payload);\n\n    await filesApi.deleteFilesAndDirectory(`${id}`);\n  };\n"]}
{"filename": "src/hooks/collections/afterChange.ts", "chunked_list": ["import {\n  CollectionAfterChangeHook,\n  CollectionConfig,\n  Field,\n  GlobalConfig,\n  GlobalAfterChangeHook,\n  PayloadRequest,\n} from \"payload/types\";\nimport { Descendant } from \"slate\";\nimport { PluginOptions } from \"../../types\";", "import { Descendant } from \"slate\";\nimport { PluginOptions } from \"../../types\";\nimport {\n  buildCrowdinHtmlObject,\n  buildCrowdinJsonObject,\n  convertSlateToHtml,\n  fieldChanged,\n} from \"../../utilities\";\nimport deepEqual from \"deep-equal\";\nimport { getLocalizedFields } from \"../../utilities\";", "import deepEqual from \"deep-equal\";\nimport { getLocalizedFields } from \"../../utilities\";\nimport { payloadCrowdinSyncFilesApi } from \"../../api/payload-crowdin-sync/files\";\n\n/**\n * Update Crowdin collections and make updates in Crowdin\n *\n * This functionality used to be split into field hooks.\n * However, it is more reliable to loop through localized\n * fields and perform opeerations in one place. The", " * However, it is more reliable to loop through localized\n * fields and perform opeerations in one place. The\n * asynchronous nature of operations means that\n * we need to be careful updates are not made sooner than\n * expected.\n */\n\ninterface CommonArgs {\n  pluginOptions: PluginOptions;\n}\n", "interface Args extends CommonArgs {\n  collection: CollectionConfig;\n}\n\ninterface GlobalArgs extends CommonArgs {\n  global: GlobalConfig;\n}\n\nexport const getGlobalAfterChangeHook =\n  ({ global, pluginOptions }: GlobalArgs): GlobalAfterChangeHook =>\n  async ({\n    doc, // full document data\n    previousDoc, // document data before updating the collection\n    req, // full express request\n  }) => {\n    const operation = previousDoc ? \"update\" : \"create\";\n    return performAfterChange({\n      doc,\n      req,\n      previousDoc,\n      operation,\n      collection: global,\n      global: true,\n      pluginOptions,\n    });\n  };\n\nexport const getAfterChangeHook =\n  ({ collection, pluginOptions }: Args): CollectionAfterChangeHook =>\n  async ({\n    doc, // full document data\n    req, // full express request\n    previousDoc, // document data before updating the collection\n    operation, // name of the operation ie. 'create', 'update'\n  }) => {\n    return performAfterChange({\n      doc,\n      req,\n      previousDoc,\n      operation,\n      collection,\n      pluginOptions,\n    });\n  };\n", "interface IPerformChange {\n  doc: any;\n  req: PayloadRequest;\n  previousDoc: any;\n  operation: string;\n  collection: CollectionConfig | GlobalConfig;\n  global?: boolean;\n  pluginOptions: PluginOptions;\n}\n\nconst performAfterChange = async ({\n  doc, // full document data\n  req, // full express request\n  previousDoc,\n  operation,\n  collection,\n  global = false,\n  pluginOptions,\n}: IPerformChange) => {\n  /**\n   * Abort if token not set and not in test mode\n   */", "  if (!pluginOptions.token && process.env.NODE_ENV !== \"test\") {\n    return doc;\n  }\n\n  const localizedFields: Field[] = getLocalizedFields({\n    fields: collection.fields,\n  });\n\n  /**\n   * Abort if there are no fields to localize\n   */", "  if (localizedFields.length === 0) {\n    return doc;\n  }\n\n  /**\n   * Abort if locale is unavailable or this\n   * is an update from the API to the source\n   * locale.\n   */\n  if (!req.locale || req.locale !== pluginOptions.sourceLocale) {\n    return doc;\n  }\n\n  /**\n   * Prepare JSON objects\n   *\n   * `text` fields are compiled into a single JSON file\n   * on Crowdin. Prepare previous and current objects.\n   */\n  const currentCrowdinJsonData = buildCrowdinJsonObject({\n    doc,\n    fields: localizedFields,\n  });\n  const prevCrowdinJsonData = buildCrowdinJsonObject({\n    doc: previousDoc,\n    fields: localizedFields,\n  });\n\n  /**\n   * Initialize Crowdin client sourceFilesApi\n   */\n  const filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, req.payload);\n\n  /**\n   * Retrieve the Crowdin Article Directory article\n   *\n   * Records of Crowdin directories are stored in Payload.\n   */\n  const articleDirectory = await filesApi.findOrCreateArticleDirectory({\n    document: doc,\n    collectionSlug: collection.slug,\n    global,\n  });\n", "  if (!req.locale || req.locale !== pluginOptions.sourceLocale) {\n    return doc;\n  }\n\n  /**\n   * Prepare JSON objects\n   *\n   * `text` fields are compiled into a single JSON file\n   * on Crowdin. Prepare previous and current objects.\n   */\n  const currentCrowdinJsonData = buildCrowdinJsonObject({\n    doc,\n    fields: localizedFields,\n  });\n  const prevCrowdinJsonData = buildCrowdinJsonObject({\n    doc: previousDoc,\n    fields: localizedFields,\n  });\n\n  /**\n   * Initialize Crowdin client sourceFilesApi\n   */\n  const filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, req.payload);\n\n  /**\n   * Retrieve the Crowdin Article Directory article\n   *\n   * Records of Crowdin directories are stored in Payload.\n   */\n  const articleDirectory = await filesApi.findOrCreateArticleDirectory({\n    document: doc,\n    collectionSlug: collection.slug,\n    global,\n  });\n", "  // START: function definitions\n  const createOrUpdateJsonFile = async () => {\n    await filesApi.createOrUpdateFile({\n      name: \"fields\",\n      value: currentCrowdinJsonData,\n      fileType: \"json\",\n      articleDirectory,\n    });\n  };\n\n  const createOrUpdateHtmlFile = async ({\n    name,\n    value,\n  }: {\n    name: string;\n    value: Descendant[];\n  }) => {\n    await filesApi.createOrUpdateFile({\n      name: name,\n      value: convertSlateToHtml(value),\n      fileType: \"html\",\n      articleDirectory,\n    });\n  };\n\n  const createOrUpdateJsonSource = async () => {", "    if (\n      (!deepEqual(currentCrowdinJsonData, prevCrowdinJsonData) &&\n        Object.keys(currentCrowdinJsonData).length !== 0) ||\n      process.env.PAYLOAD_CROWDIN_SYNC_ALWAYS_UPDATE === \"true\"\n    ) {\n      await createOrUpdateJsonFile();\n    }\n  };\n\n  /**\n   * Recursively send rich text fields to Crowdin as HTML\n   *\n   * Name these HTML files with dot notation. Examples:\n   *\n   * * `localizedRichTextField`\n   * * `groupField.localizedRichTextField`\n   * * `arrayField[0].localizedRichTextField`\n   * * `arrayField[1].localizedRichTextField`\n   */\n  const createOrUpdateHtmlSource = async () => {\n    const currentCrowdinHtmlData = buildCrowdinHtmlObject({\n      doc,\n      fields: localizedFields,\n    });\n    const prevCrowdinHtmlData = buildCrowdinHtmlObject({\n      doc: previousDoc,\n      fields: localizedFields,\n    });\n    Object.keys(currentCrowdinHtmlData).forEach(async (name) => {\n      const currentValue = currentCrowdinHtmlData[name];\n      const prevValue = prevCrowdinHtmlData[name];", "      if (\n        !fieldChanged(prevValue, currentValue, \"richText\") &&\n        process.env.PAYLOAD_CROWDIN_SYNC_ALWAYS_UPDATE !== \"true\"\n      ) {\n        return;\n      }\n      const file = await createOrUpdateHtmlFile({\n        name,\n        value: currentValue as Descendant[],\n      });\n    });\n  };", "  // END: function definitions\n\n  await createOrUpdateJsonSource();\n  await createOrUpdateHtmlSource();\n\n  return doc;\n};\n"]}
{"filename": "src/api/connection.ts", "chunked_list": ["import crowdin from \"@crowdin/crowdin-api-client\";\n\nexport const { uploadStorageApi, sourceFilesApi } = new crowdin({\n  token: process.env.CROWDIN_API_TOKEN as string,\n});\n"]}
{"filename": "src/api/helpers.ts", "chunked_list": ["import { Payload } from \"payload\";\nimport { IcrowdinFile } from \"./payload-crowdin-sync/files\";\n\n/**\n * get Crowdin Article Directory for a given documentId\n *\n * The Crowdin Article Directory is associated with a document,\n * so is easy to retrieve. Use this function when you only have\n * a document id.\n */\nexport async function getArticleDirectory(\n  documentId: string,\n  payload: Payload,\n  allowEmpty?: boolean\n) {\n  // Get directory\n  const crowdinPayloadArticleDirectory = await payload.find({\n    collection: \"crowdin-article-directories\",\n    where: {\n      name: {\n        equals: documentId,\n      },\n    },\n  });", "export async function getArticleDirectory(\n  documentId: string,\n  payload: Payload,\n  allowEmpty?: boolean\n) {\n  // Get directory\n  const crowdinPayloadArticleDirectory = await payload.find({\n    collection: \"crowdin-article-directories\",\n    where: {\n      name: {\n        equals: documentId,\n      },\n    },\n  });", "  if (crowdinPayloadArticleDirectory.totalDocs === 0 && allowEmpty) {\n    // a thrown error won't be reported in an api call, so console.log it as well.\n    console.log(`No article directory found for document ${documentId}`);\n    throw new Error(\n      \"This article does not have a corresponding entry in the  crowdin-article-directories collection.\"\n    );\n  }\n  return crowdinPayloadArticleDirectory\n    ? crowdinPayloadArticleDirectory.docs[0]\n    : undefined;\n}\n", "export async function getFile(\n  name: string,\n  crowdinArticleDirectoryId: string,\n  payload: Payload\n): Promise<any> {\n  const result = await payload.find({\n    collection: \"crowdin-files\",\n    where: {\n      field: { equals: name },\n      crowdinArticleDirectory: {\n        equals: crowdinArticleDirectoryId,\n      },\n    },\n  });\n  return result.docs[0];\n}\n", "export async function getFiles(\n  crowdinArticleDirectoryId: string,\n  payload: Payload\n): Promise<any> {\n  const result = await payload.find({\n    collection: \"crowdin-files\",\n    where: {\n      crowdinArticleDirectory: {\n        equals: crowdinArticleDirectoryId,\n      },\n    },\n  });\n  return result.docs;\n}\n", "export async function getFileByDocumentID(\n  name: string,\n  documentId: string,\n  payload: Payload\n): Promise<IcrowdinFile> {\n  const articleDirectory = await getArticleDirectory(documentId, payload);\n  return getFile(name, articleDirectory.id, payload);\n}\n\nexport async function getFilesByDocumentID(\n  documentId: string,\n  payload: Payload\n): Promise<IcrowdinFile[]> {\n  const articleDirectory = await getArticleDirectory(documentId, payload);", "export async function getFilesByDocumentID(\n  documentId: string,\n  payload: Payload\n): Promise<IcrowdinFile[]> {\n  const articleDirectory = await getArticleDirectory(documentId, payload);\n  if (!articleDirectory) {\n    // tests call this function to make sure files are deleted\n    return [];\n  }\n  const files = await getFiles(articleDirectory.id, payload);\n  return files;\n}\n"]}
{"filename": "src/api/payload-crowdin-sync/files.ts", "chunked_list": ["import crowdin, {\n  Credentials,\n  SourceFiles,\n  UploadStorage,\n} from \"@crowdin/crowdin-api-client\";\nimport { mockCrowdinClient } from \"../mock/crowdin-client\";\nimport { Payload } from \"payload\";\nimport { PluginOptions } from \"../../types\";\nimport { toWords } from \"payload/dist/utilities/formatLabels\";\nimport {", "import { toWords } from \"payload/dist/utilities/formatLabels\";\nimport {\n  getArticleDirectory,\n  getFile,\n  getFiles,\n  getFileByDocumentID,\n  getFilesByDocumentID,\n} from \"../helpers\";\nimport { isEmpty } from \"lodash\";\n\nexport interface IcrowdinFile {\n  id: string;\n  originalId: number;\n  fileData: {\n    json?: Object;\n    html?: string;\n  };\n}\n", "import { isEmpty } from \"lodash\";\n\nexport interface IcrowdinFile {\n  id: string;\n  originalId: number;\n  fileData: {\n    json?: Object;\n    html?: string;\n  };\n}\n", "interface IfindOrCreateCollectionDirectory {\n  collectionSlug: string;\n}\n\ninterface IfindOrCreateArticleDirectory\n  extends IfindOrCreateCollectionDirectory {\n  document: any;\n  global?: boolean;\n}\n\ninterface IupdateOrCreateFile {\n  name: string;\n  value: string | object;\n  fileType: \"html\" | \"json\";\n  articleDirectory: any;\n}\n", "interface IupdateOrCreateFile {\n  name: string;\n  value: string | object;\n  fileType: \"html\" | \"json\";\n  articleDirectory: any;\n}\n\ninterface IcreateOrUpdateFile {\n  name: string;\n  fileData: string | object;\n  fileType: \"html\" | \"json\";\n}\n", "interface IcreateFile extends IcreateOrUpdateFile {\n  directoryId: number;\n}\n\ninterface IupdateFile extends IcreateOrUpdateFile {\n  crowdinFile: IcrowdinFile;\n}\n\ninterface IupdateCrowdinFile extends IcreateOrUpdateFile {\n  fileId: number;\n}\n", "interface IupdateCrowdinFile extends IcreateOrUpdateFile {\n  fileId: number;\n}\n\ninterface IgetTranslation {\n  documentId: string;\n  fieldName: string;\n  locale: string;\n  global?: boolean;\n}\n", "export class payloadCrowdinSyncFilesApi {\n  sourceFilesApi: SourceFiles;\n  uploadStorageApi: UploadStorage;\n  projectId: number;\n  directoryId?: number;\n  payload: Payload;\n\n  constructor(pluginOptions: PluginOptions, payload: Payload) {\n    // credentials\n    const credentials: Credentials = {\n      token: pluginOptions.token,\n    };\n    const { sourceFilesApi, uploadStorageApi } = new crowdin(credentials);\n    this.projectId = pluginOptions.projectId;\n    this.directoryId = pluginOptions.directoryId;\n    this.sourceFilesApi =\n      process.env.NODE_ENV === \"test\"\n        ? (mockCrowdinClient(pluginOptions) as any)\n        : sourceFilesApi;\n    this.uploadStorageApi =\n      process.env.NODE_ENV === \"test\"\n        ? (mockCrowdinClient(pluginOptions) as any)\n        : uploadStorageApi;\n    this.payload = payload;\n  }\n\n  async findOrCreateArticleDirectory({\n    document,\n    collectionSlug,\n    global = false,\n  }: IfindOrCreateArticleDirectory) {\n    let crowdinPayloadArticleDirectory;\n", "    if (document.crowdinArticleDirectory) {\n      // Update not possible. Article name needs to be updated manually on Crowdin.\n      // The name of the directory is Crowdin specific helper text to give\n      // context to translators.\n      // See https://developer.crowdin.com/api/v2/#operation/api.projects.directories.getMany\n      crowdinPayloadArticleDirectory = await this.payload.findByID({\n        collection: \"crowdin-article-directories\",\n        id:\n          document.crowdinArticleDirectory.id ||\n          document.crowdinArticleDirectory,\n      });\n    } else {\n      const crowdinPayloadCollectionDirectory =\n        await this.findOrCreateCollectionDirectory({\n          collectionSlug: global ? \"globals\" : collectionSlug,\n        });\n\n      // Create article directory on Crowdin\n      const crowdinDirectory = await this.sourceFilesApi.createDirectory(\n        this.projectId,\n        {\n          directoryId: crowdinPayloadCollectionDirectory.originalId,\n          name: global ? collectionSlug : document.id,\n          title: global\n            ? toWords(collectionSlug)\n            : document.title || document.name, // no tests for this Crowdin metadata, but makes it easier for translators\n        }\n      );\n\n      // Store result in Payload CMS\n      crowdinPayloadArticleDirectory = await this.payload.create({\n        collection: \"crowdin-article-directories\",\n        data: {\n          crowdinCollectionDirectory: crowdinPayloadCollectionDirectory.id,\n          originalId: crowdinDirectory.data.id,\n          projectId: this.projectId,\n          directoryId: crowdinDirectory.data.directoryId,\n          name: crowdinDirectory.data.name,\n          createdAt: crowdinDirectory.data.createdAt,\n          updatedAt: crowdinDirectory.data.updatedAt,\n        },\n      });\n\n      // Associate result with document", "      if (global) {\n        const update = await this.payload.updateGlobal({\n          slug: collectionSlug,\n          data: {\n            crowdinArticleDirectory: crowdinPayloadArticleDirectory.id,\n          },\n        });\n      } else {\n        const update = await this.payload.update({\n          collection: collectionSlug,\n          id: document.id,\n          data: {\n            crowdinArticleDirectory: crowdinPayloadArticleDirectory.id,\n          },\n        });\n      }\n    }\n\n    return crowdinPayloadArticleDirectory;\n  }\n\n  private async findOrCreateCollectionDirectory({\n    collectionSlug,\n  }: IfindOrCreateCollectionDirectory) {\n    let crowdinPayloadCollectionDirectory;\n    // Check whether collection directory exists on Crowdin\n    const query = await this.payload.find({\n      collection: \"crowdin-collection-directories\",\n      where: {\n        collectionSlug: {\n          equals: collectionSlug,\n        },\n      },\n    });\n", "    if (query.totalDocs === 0) {\n      // Create collection directory on Crowdin\n      const crowdinDirectory = await this.sourceFilesApi.createDirectory(\n        this.projectId,\n        {\n          directoryId: this.directoryId,\n          name: collectionSlug,\n          title: toWords(collectionSlug), // is this transformed value available on the collection object?\n        }\n      );\n\n      // Store result in Payload CMS\n      crowdinPayloadCollectionDirectory = await this.payload.create({\n        collection: \"crowdin-collection-directories\",\n        data: {\n          collectionSlug: collectionSlug,\n          originalId: crowdinDirectory.data.id,\n          projectId: this.projectId,\n          directoryId: crowdinDirectory.data.directoryId,\n          name: crowdinDirectory.data.name,\n          title: crowdinDirectory.data.title,\n          createdAt: crowdinDirectory.data.createdAt,\n          updatedAt: crowdinDirectory.data.updatedAt,\n        },\n      });\n    } else {\n      crowdinPayloadCollectionDirectory = query.docs[0];\n    }\n\n    return crowdinPayloadCollectionDirectory;\n  }\n\n  async getFile(name: string, crowdinArticleDirectoryId: string): Promise<any> {\n    return getFile(name, crowdinArticleDirectoryId, this.payload);\n  }\n\n  async getFiles(crowdinArticleDirectoryId: string): Promise<any> {\n    return getFiles(crowdinArticleDirectoryId, this.payload);\n  }\n\n  /**\n   * Create/Update/Delete a file on Crowdin\n   *\n   * Records the file in Payload CMS under the `crowdin-files` collection.\n   *\n   * - Create a file if it doesn't exist on Crowdin and the supplied content is not empty\n   * - Update a file if it exists on Crowdin and the supplied content is not empty\n   * - Delete a file if it exists on Crowdin and the supplied file content is empty\n   */\n  async createOrUpdateFile({\n    name,\n    value,\n    fileType,\n    articleDirectory,\n  }: IupdateOrCreateFile) {\n    const empty = isEmpty(value);\n    // Check whether file exists on Crowdin\n    let crowdinFile = await this.getFile(name, articleDirectory.id);\n    let updatedCrowdinFile;", "    if (!empty) {\n      if (!crowdinFile) {\n        updatedCrowdinFile = await this.createFile({\n          name,\n          value,\n          fileType,\n          articleDirectory,\n        });\n      } else {\n        updatedCrowdinFile = await this.updateFile({\n          crowdinFile,\n          name: name,\n          fileData: value,\n          fileType: fileType,\n        });\n      }\n    } else {", "      if (crowdinFile) {\n        updatedCrowdinFile = await this.deleteFile(crowdinFile);\n      }\n    }\n    return updatedCrowdinFile;\n  }\n\n  private async updateFile({\n    crowdinFile,\n    name,\n    fileData,\n    fileType,\n  }: IupdateFile) {\n    // Update file on Crowdin\n    const updatedCrowdinFile = await this.crowdinUpdateFile({\n      fileId: crowdinFile.originalId,\n      name,\n      fileData,\n      fileType,\n    });\n\n    const payloadCrowdinFile = await this.payload.update({\n      collection: \"crowdin-files\", // required\n      id: crowdinFile.id,\n      data: {\n        // required\n        updatedAt: updatedCrowdinFile.data.updatedAt,\n        revisionId: updatedCrowdinFile.data.revisionId,\n        ...(fileType === \"json\" && { fileData: { json: fileData } }),\n        ...(fileType === \"html\" && { fileData: { html: fileData } }),\n      },\n    });\n  }\n\n  private async createFile({\n    name,\n    value,\n    fileType,\n    articleDirectory,\n  }: IupdateOrCreateFile) {\n    // Create file on Crowdin\n    const crowdinFile = await this.crowdinCreateFile({\n      directoryId: articleDirectory.originalId,\n      name: name,\n      fileData: value,\n      fileType: fileType,\n    });\n\n    // createFile has been intermittent in not being available\n    // perhaps logic goes wrong somewhere and express middleware\n    // is hard to debug?\n    /*const crowdinFile =  {data: {\n      revisionId: 5,\n      status: 'active',\n      priority: 'normal',\n      importOptions: { contentSegmentation: true, customSegmentation: false },\n      exportOptions: null,\n      excludedTargetLanguages: null,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      id: 1079,\n      projectId: 323731,\n      branchId: null,\n      directoryId: 1077,\n      name: name,\n      title: null,\n      type: fileType,\n      path: `/policies/security-and-privacy/${name}.${fileType}`\n    }}*/\n\n    // Store result on Payload CMS", "    if (crowdinFile) {\n      const payloadCrowdinFile = await this.payload.create({\n        collection: \"crowdin-files\", // required\n        data: {\n          // required\n          title: crowdinFile.data.name,\n          field: name,\n          crowdinArticleDirectory: articleDirectory.id,\n          createdAt: crowdinFile.data.createdAt,\n          updatedAt: crowdinFile.data.updatedAt,\n          originalId: crowdinFile.data.id,\n          projectId: crowdinFile.data.projectId,\n          directoryId: crowdinFile.data.directoryId,\n          revisionId: crowdinFile.data.revisionId,\n          name: crowdinFile.data.name,\n          type: crowdinFile.data.type,\n          path: crowdinFile.data.path,\n          ...(fileType === \"json\" && { fileData: { json: value } }),\n          ...(fileType === \"html\" && { fileData: { html: value } }),\n        },\n      });\n\n      return payloadCrowdinFile;\n    }\n  }\n\n  async deleteFile(crowdinFile: IcrowdinFile) {\n    const file = await this.sourceFilesApi.deleteFile(\n      this.projectId,\n      crowdinFile.originalId\n    );\n    const payloadFile = await this.payload.delete({\n      collection: \"crowdin-files\", // required\n      id: crowdinFile.id, // required\n    });\n    return payloadFile;\n  }\n\n  private async crowdinUpdateFile({\n    fileId,\n    name,\n    fileData,\n    fileType,\n  }: IupdateCrowdinFile) {\n    const storage = await this.uploadStorageApi.addStorage(\n      name,\n      fileData,\n      fileType\n    );\n    //const file = await sourceFilesApi.deleteFile(projectId, 1161)\n    const file = await this.sourceFilesApi.updateOrRestoreFile(\n      this.projectId,\n      fileId,\n      {\n        storageId: storage.data.id,\n      }\n    );\n    return file;\n  }\n\n  private async crowdinCreateFile({\n    name,\n    fileData,\n    fileType,\n    directoryId,\n  }: IcreateFile) {\n    const storage = await this.uploadStorageApi.addStorage(\n      name,\n      fileData,\n      fileType\n    );\n    const options = {\n      name: `${name}.${fileType}`,\n      title: name,\n      storageId: storage.data.id,\n      directoryId,\n      type: fileType,\n    };", "    try {\n      const file = await this.sourceFilesApi.createFile(\n        this.projectId,\n        options\n      );\n      return file;\n    } catch (error) {\n      console.error(error, options);\n    }\n  }\n\n  async getArticleDirectory(documentId: string) {\n    const result = await getArticleDirectory(documentId, this.payload);\n    return result;\n  }\n\n  async deleteFilesAndDirectory(documentId: string) {\n    const files = await this.getFilesByDocumentID(documentId);\n", "    for (const file of files) {\n      await this.deleteFile(file);\n    }\n\n    await this.deleteArticleDirectory(documentId);\n  }\n\n  async deleteArticleDirectory(documentId: string) {\n    const crowdinPayloadArticleDirectory = await this.getArticleDirectory(\n      documentId\n    );\n    await this.sourceFilesApi.deleteDirectory(\n      this.projectId,\n      crowdinPayloadArticleDirectory.originalId\n    );\n    await this.payload.delete({\n      collection: \"crowdin-article-directories\",\n      id: crowdinPayloadArticleDirectory.id,\n    });\n  }\n\n  async getFileByDocumentID(name: string, documentId: string) {\n    const result = await getFileByDocumentID(name, documentId, this.payload);\n    return result;\n  }\n\n  async getFilesByDocumentID(documentId: string) {\n    const result = await getFilesByDocumentID(documentId, this.payload);\n    return result;\n  }\n}\n"]}
{"filename": "src/api/payload-crowdin-sync/translations.ts", "chunked_list": ["import crowdin, {\n  Credentials,\n  Translations,\n} from \"@crowdin/crowdin-api-client\";\nimport { payloadCrowdinSyncFilesApi } from \"./files\";\nimport { mockCrowdinClient } from \"../mock/crowdin-client\";\nimport { Payload } from \"payload\";\nimport { PluginOptions } from \"../../types\";\nimport deepEqual from \"deep-equal\";\nimport {", "import deepEqual from \"deep-equal\";\nimport {\n  CollectionConfig,\n  GlobalConfig,\n  SanitizedCollectionConfig,\n  SanitizedGlobalConfig,\n} from \"payload/types\";\nimport { htmlToSlate, payloadHtmlToSlateConfig } from \"slate-serializers\";\nimport {\n  getLocalizedFields,", "import {\n  getLocalizedFields,\n  getFieldSlugs,\n  buildCrowdinJsonObject,\n  buildCrowdinHtmlObject,\n  buildPayloadUpdateObject,\n  getLocalizedRequiredFields,\n} from \"../../utilities\";\n\ninterface IgetLatestDocumentTranslation {\n  collection: string;\n  doc: any;\n  locale: string;\n  global?: boolean;\n}\n", "\ninterface IgetLatestDocumentTranslation {\n  collection: string;\n  doc: any;\n  locale: string;\n  global?: boolean;\n}\n\ninterface IgetCurrentDocumentTranslation {\n  doc: any;\n  collection: string;\n  locale: string;\n  global?: boolean;\n}\n", "interface IgetCurrentDocumentTranslation {\n  doc: any;\n  collection: string;\n  locale: string;\n  global?: boolean;\n}\n\ninterface IgetTranslation {\n  documentId: string;\n  fieldName: string;\n  locale: string;\n  global?: boolean;\n}\n", "interface IupdateTranslation {\n  documentId: string;\n  collection: string;\n  dryRun?: boolean;\n  global?: boolean;\n  excludeLocales?: string[];\n}\n\nexport class payloadCrowdinSyncTranslationsApi {\n  translationsApi: Translations;\n  filesApi: payloadCrowdinSyncFilesApi; // our wrapper for file operations\n  projectId: number;\n  directoryId?: number;\n  payload: Payload;\n  localeMap: PluginOptions[\"localeMap\"];\n  sourceLocale: PluginOptions[\"sourceLocale\"];\n\n  constructor(pluginOptions: PluginOptions, payload: Payload) {\n    // credentials\n    const credentials: Credentials = {\n      token: pluginOptions.token,\n    };\n    const { translationsApi } = new crowdin(credentials);\n    this.projectId = pluginOptions.projectId;\n    this.directoryId = pluginOptions.directoryId;\n    this.translationsApi =\n      process.env.NODE_ENV === \"test\"\n        ? (mockCrowdinClient(pluginOptions) as any)\n        : translationsApi;\n    this.filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, payload);\n    this.payload = payload;\n    this.localeMap = pluginOptions.localeMap;\n    this.sourceLocale = pluginOptions.sourceLocale;\n  }\n\n  async updateTranslation({\n    documentId,\n    collection,\n    dryRun = true,\n    global = false,\n    excludeLocales = [],\n  }: IupdateTranslation) {\n    /**\n     * Get existing document\n     *\n     * * check document exists\n     * * check for `meta` field (which can be added by @payloadcms/seo)\n     *\n     */\n    let doc: { crowdinArticleDirectory: { id: any } };", "export class payloadCrowdinSyncTranslationsApi {\n  translationsApi: Translations;\n  filesApi: payloadCrowdinSyncFilesApi; // our wrapper for file operations\n  projectId: number;\n  directoryId?: number;\n  payload: Payload;\n  localeMap: PluginOptions[\"localeMap\"];\n  sourceLocale: PluginOptions[\"sourceLocale\"];\n\n  constructor(pluginOptions: PluginOptions, payload: Payload) {\n    // credentials\n    const credentials: Credentials = {\n      token: pluginOptions.token,\n    };\n    const { translationsApi } = new crowdin(credentials);\n    this.projectId = pluginOptions.projectId;\n    this.directoryId = pluginOptions.directoryId;\n    this.translationsApi =\n      process.env.NODE_ENV === \"test\"\n        ? (mockCrowdinClient(pluginOptions) as any)\n        : translationsApi;\n    this.filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, payload);\n    this.payload = payload;\n    this.localeMap = pluginOptions.localeMap;\n    this.sourceLocale = pluginOptions.sourceLocale;\n  }\n\n  async updateTranslation({\n    documentId,\n    collection,\n    dryRun = true,\n    global = false,\n    excludeLocales = [],\n  }: IupdateTranslation) {\n    /**\n     * Get existing document\n     *\n     * * check document exists\n     * * check for `meta` field (which can be added by @payloadcms/seo)\n     *\n     */\n    let doc: { crowdinArticleDirectory: { id: any } };", "    if (global) {\n      doc = await this.payload.findGlobal({\n        slug: collection,\n        locale: this.sourceLocale,\n      });\n    } else {\n      doc = await this.payload.findByID({\n        collection: collection,\n        id: documentId,\n        locale: this.sourceLocale,\n      });\n    }\n    const report: { [key: string]: any } = {};", "    for (const locale of Object.keys(this.localeMap)) {\n      if (excludeLocales.includes(locale)) {\n        continue;\n      }\n      report[locale] = {};\n      report[locale].currentTranslations =\n        await this.getCurrentDocumentTranslation({\n          doc: doc,\n          collection: collection,\n          locale: locale,\n          global,\n        });\n      report[locale].latestTranslations =\n        await this.getLatestDocumentTranslation({\n          collection: collection,\n          doc: doc,\n          locale: locale,\n          global,\n        });\n      report[locale].changed = !deepEqual(\n        report[locale].currentTranslations,\n        report[locale].latestTranslations\n      );", "      if (report[locale].changed && !dryRun) {\n        if (global) {\n          try {\n            await this.payload.updateGlobal({\n              slug: collection,\n              locale: locale,\n              data: {\n                ...report[locale].latestTranslations,\n                // error on update without the following line.\n                // see https://github.com/thompsonsj/payload-crowdin-sync/pull/13/files#r1209271660\n                crowdinArticleDirectory: doc.crowdinArticleDirectory.id,\n              },\n            });", "          } catch (error) {\n            console.log(error);\n          }\n        } else {\n          try {\n            await this.payload.update({\n              collection: collection,\n              locale: locale,\n              id: documentId,\n              data: report[locale].latestTranslations,\n            });", "          } catch (error) {\n            console.log(error);\n          }\n        }\n      }\n    }\n    return {\n      source: doc,\n      translations: { ...report },\n    };\n  }\n\n  getCollectionConfig(\n    collection: string,\n    global: boolean\n  ): CollectionConfig | GlobalConfig {\n    let collectionConfig:\n      | SanitizedGlobalConfig\n      | SanitizedCollectionConfig\n      | undefined;", "    if (global) {\n      collectionConfig = this.payload.config.globals.find(\n        (col: GlobalConfig) => col.slug === collection\n      );\n    } else {\n      collectionConfig = this.payload.config.collections.find(\n        (col: CollectionConfig) => col.slug === collection\n      );\n    }\n    if (!collectionConfig)\n      throw new Error(`Collection ${collection} not found in payload config`);\n    return collectionConfig;\n  }\n\n  async getCurrentDocumentTranslation({\n    doc,\n    collection,\n    locale,\n    global = false,\n  }: IgetCurrentDocumentTranslation) {\n    // get document\n    let document: any;", "    if (!collectionConfig)\n      throw new Error(`Collection ${collection} not found in payload config`);\n    return collectionConfig;\n  }\n\n  async getCurrentDocumentTranslation({\n    doc,\n    collection,\n    locale,\n    global = false,\n  }: IgetCurrentDocumentTranslation) {\n    // get document\n    let document: any;", "    if (global) {\n      document = await this.payload.findGlobal({\n        slug: collection,\n        locale: locale,\n      });\n    } else {\n      document = await this.payload.findByID({\n        collection: collection,\n        id: doc.id,\n        locale: locale,\n      });\n    }\n\n    const collectionConfig = this.getCollectionConfig(collection, global);\n\n    const localizedFields = getLocalizedFields({\n      fields: collectionConfig.fields,\n    });\n\n    // build crowdin json object\n    const crowdinJsonObject = buildCrowdinJsonObject({\n      doc: document,\n      fields: localizedFields,\n    });\n    const crowdinHtmlObject = buildCrowdinHtmlObject({\n      doc: document,\n      fields: localizedFields,\n    });", "    try {\n      const docTranslations = buildPayloadUpdateObject({\n        crowdinJsonObject,\n        crowdinHtmlObject,\n        fields: localizedFields,\n        document,\n      });\n      return docTranslations;\n    } catch (error) {\n      console.log(error);\n      throw new Error(`${error}`);\n    }\n  }\n\n  /**\n   * Retrieve translations from Crowdin for a document in a given locale\n   */\n  async getLatestDocumentTranslation({\n    collection,\n    doc,\n    locale,\n    global = false,\n  }: IgetLatestDocumentTranslation) {\n    const collectionConfig = this.getCollectionConfig(collection, global);\n\n    const localizedFields = getLocalizedFields({\n      fields: collectionConfig.fields,\n    });\n", "    } catch (error) {\n      console.log(error);\n      throw new Error(`${error}`);\n    }\n  }\n\n  /**\n   * Retrieve translations from Crowdin for a document in a given locale\n   */\n  async getLatestDocumentTranslation({\n    collection,\n    doc,\n    locale,\n    global = false,\n  }: IgetLatestDocumentTranslation) {\n    const collectionConfig = this.getCollectionConfig(collection, global);\n\n    const localizedFields = getLocalizedFields({\n      fields: collectionConfig.fields,\n    });\n", "    if (!localizedFields) {\n      return { message: \"no localized fields\" };\n    }\n\n    let docTranslations: { [key: string]: any } = {};\n    // add json fields\n    const crowdinJsonObject =\n      (await this.getTranslation({\n        documentId: global ? collectionConfig.slug : doc.id,\n        fieldName: \"fields\",\n        locale: locale,\n      })) || {};\n    // add html fields\n    const localizedHtmlFields = await this.getHtmlFieldSlugs(\n      global ? collectionConfig.slug : doc.id\n    );\n    let crowdinHtmlObject: { [key: string]: any } = {};", "    for (const field of localizedHtmlFields) {\n      crowdinHtmlObject[field] = await this.getTranslation({\n        documentId: global ? collectionConfig.slug : doc.id,\n        fieldName: field,\n        locale: locale,\n      });\n    }\n\n    docTranslations = buildPayloadUpdateObject({\n      crowdinJsonObject,\n      crowdinHtmlObject,\n      fields: localizedFields,\n      document: doc,\n    });\n\n    // Add required fields if not present\n    const requiredFieldSlugs = getFieldSlugs(\n      getLocalizedRequiredFields(collectionConfig)\n    );", "    if (requiredFieldSlugs.length > 0) {\n      const currentTranslations = await this.getCurrentDocumentTranslation({\n        doc: doc,\n        collection: collection,\n        locale: locale,\n        global,\n      });\n      requiredFieldSlugs.forEach((slug) => {\n        if (!docTranslations.hasOwnProperty(slug)) {\n          docTranslations[slug] = currentTranslations[slug];\n        }\n      });\n    }\n    return docTranslations;\n  }\n\n  async getHtmlFieldSlugs(documentId: string) {\n    const files = await this.filesApi.getFilesByDocumentID(documentId);\n    return files\n      .filter((file: any) => file.type === \"html\")\n      .map((file: any) => file.field);\n  }\n\n  /**\n   * Retrieve translations for a document field name\n   *\n   * * returns Slate object for html fields\n   * * returns all json fields if fieldName is 'fields'\n   */\n  async getTranslation({ documentId, fieldName, locale }: IgetTranslation) {\n    const articleDirectory = await this.filesApi.getArticleDirectory(\n      documentId\n    );\n    const file = await this.filesApi.getFile(fieldName, articleDirectory.id);\n    // it is possible a file doesn't exist yet - e.g. an article with localized text fields that contains an empty html field.", "        if (!docTranslations.hasOwnProperty(slug)) {\n          docTranslations[slug] = currentTranslations[slug];\n        }\n      });\n    }\n    return docTranslations;\n  }\n\n  async getHtmlFieldSlugs(documentId: string) {\n    const files = await this.filesApi.getFilesByDocumentID(documentId);\n    return files\n      .filter((file: any) => file.type === \"html\")\n      .map((file: any) => file.field);\n  }\n\n  /**\n   * Retrieve translations for a document field name\n   *\n   * * returns Slate object for html fields\n   * * returns all json fields if fieldName is 'fields'\n   */\n  async getTranslation({ documentId, fieldName, locale }: IgetTranslation) {\n    const articleDirectory = await this.filesApi.getArticleDirectory(\n      documentId\n    );\n    const file = await this.filesApi.getFile(fieldName, articleDirectory.id);\n    // it is possible a file doesn't exist yet - e.g. an article with localized text fields that contains an empty html field.", "    if (!file) {\n      return;\n    }\n    try {\n      const response = await this.translationsApi.buildProjectFileTranslation(\n        this.projectId,\n        file.originalId,\n        {\n          targetLanguageId: this.localeMap[locale].crowdinId,\n        }\n      );\n      const data = await this.getFileDataFromUrl(response.data.url);\n      return file.type === \"html\"\n        ? htmlToSlate(data, payloadHtmlToSlateConfig)\n        : JSON.parse(data);", "    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  private async getFileDataFromUrl(url: string) {\n    const response = await fetch(url);\n    const body = await response.text();\n    return body;\n  }\n\n  /**\n   * Restore id and blockType to translations\n   *\n   * In order to update a document, we need to know the id and blockType of each block.\n   *\n   * Ideally, id and blockType are not sent to Crowdin - hence\n   * we need to restore them from the original document.\n   *\n   * This currently only works for a top-level `layout` blocks field.\n   *\n   * TODO: make this work for nested blocks.\n   */\n  restoreIdAndBlockType = (\n    document: any,\n    translations: any,\n    key: string = \"layout\"\n  ) => {", "    if (translations.hasOwnProperty(key)) {\n      translations[key] = translations[key].map(\n        (block: any, index: number) => ({\n          ...block,\n          id: document[key][index].id,\n          blockType: document[key][index].blockType,\n        })\n      );\n    }\n    return translations;\n  };\n}\n"]}
{"filename": "src/api/mock/crowdin-client.ts", "chunked_list": ["import { PluginOptions } from \"../../types\";\nimport {\n  ResponseObject,\n  SourceFilesModel,\n  UploadStorageModel,\n  TranslationsModel,\n} from \"@crowdin/crowdin-api-client\";\n\n/*\n  Crowdin Service mock", "/*\n  Crowdin Service mock\n\n  Although it is against best practice to mock an API\n  response, Crowdin and Payload CMS need to perform\n  multiple interdependent operations.\n\n  As a result, for effective testing, mocks are required\n  to provide Payload with expected data for subsequent\n  operations.", "  to provide Payload with expected data for subsequent\n  operations.\n\n  Importing types from the Crowdin API client provides\n  assurance that the mock returns expected data structures.\n*/\n\nclass crowdinAPIWrapper {\n  projectId: number;\n  directoryId?: number;\n  branchId: number;\n\n  constructor(pluginOptions: PluginOptions) {\n    this.projectId = pluginOptions.projectId;\n    this.directoryId = pluginOptions.directoryId;\n    this.branchId = 4;\n  }\n\n  async listFileRevisions(projectId: number, fileId: number) {\n    return await Promise.resolve(1).then(() => undefined);\n  }\n\n  async createDirectory(\n    projectId: number,\n    {\n      directoryId = 1179,\n      name,\n      title = \"undefined\",\n    }: SourceFilesModel.CreateDirectoryRequest\n  ): Promise<ResponseObject<SourceFilesModel.Directory>> {\n    return await Promise.resolve(1).then(() => {\n      const date = new Date().toISOString();\n      return {\n        data: {\n          id: 1169,\n          projectId: this.projectId,\n          branchId: this.branchId,\n          directoryId,\n          name: name,\n          title: title,\n          exportPattern: \"**\",\n          priority: \"normal\",\n          createdAt: date,\n          updatedAt: date,\n        },\n      };\n    });\n  }\n\n  async addStorage(\n    fileName: string,\n    request: any,\n    contentType?: string\n  ): Promise<ResponseObject<UploadStorageModel.Storage>> {\n    const storage = await Promise.resolve(1).then(() => {\n      return {\n        data: {\n          id: 1788135621,\n          fileName,\n        },\n      };\n    });\n    return storage;\n  }\n\n  async deleteFile(projectId: number, fileId: number): Promise<void> {\n    await Promise.resolve(1).then(() => undefined);\n  }\n\n  async deleteDirectory(projectId: number, directoryId: number): Promise<void> {\n    await Promise.resolve(1).then(() => undefined);\n  }\n\n  async createFile(\n    projectId: number,\n    {\n      directoryId = 1172,\n      name,\n      storageId,\n      type = \"html\",\n    }: SourceFilesModel.CreateFileRequest\n  ): Promise<ResponseObject<SourceFilesModel.File>> {\n    /*const storageId = await this.addStorage({\n      name,\n      fileData,\n      fileType,\n    })*/\n    const file = await Promise.resolve(1).then(() => {\n      const date = new Date().toISOString();\n      return {\n        data: {\n          revisionId: 5,\n          status: \"active\",\n          priority: \"normal\" as SourceFilesModel.Priority,\n          importOptions: {} as any,\n          exportOptions: {} as any,\n          excludedTargetLanguages: [],\n          createdAt: date,\n          updatedAt: date,\n          id: 1079,\n          projectId,\n          branchId: this.branchId,\n          directoryId,\n          name: name,\n          title: name,\n          type,\n          path: `/policies/security-and-privacy/${name}`,\n          parserVersion: 3,\n        },\n      };\n    });\n    return file;\n  }\n\n  async updateOrRestoreFile(\n    projectId: number,\n    fileId: number,\n    { storageId }: SourceFilesModel.ReplaceFileFromStorageRequest\n  ): Promise<ResponseObject<SourceFilesModel.File>> {\n    /*const storageId = await this.addStorage({\n      name,\n      fileData,\n      fileType,\n    })*/\n    const file = await Promise.resolve(1).then(() => {\n      const date = new Date().toISOString();\n      return {\n        data: {\n          revisionId: 5,\n          status: \"active\",\n          priority: \"normal\" as SourceFilesModel.Priority,\n          importOptions: {} as any,\n          exportOptions: {} as any,\n          excludedTargetLanguages: [],\n          createdAt: date,\n          updatedAt: date,\n          id: 1079,\n          projectId,\n          branchId: this.branchId,\n          directoryId: this.directoryId as number,\n          name: \"file\",\n          title: \"file\",\n          type: \"html\",\n          path: `/policies/security-and-privacy/file.filetype`,\n          parserVersion: 3,\n        },\n      };\n    });\n    return file;\n  }\n\n  async buildProjectFileTranslation(\n    projectId: number,\n    fileId: number,\n    { targetLanguageId }: TranslationsModel.BuildProjectFileTranslationRequest\n  ): Promise<\n    ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>\n  > {\n    const build = await Promise.resolve(1).then(() => {\n      const date = new Date().toISOString();\n      return {\n        data: {\n          id: 1,\n          projectId,\n          branchId: this.branchId,\n          fileId,\n          languageId: \"en\",\n          status: \"inProgress\",\n          progress: 0,\n          createdAt: date,\n          updatedAt: date,\n          etag: \"string\",\n          url: `https://api.crowdin.com/api/v2/projects/1/translations/builds/1/download?targetLanguageId=${targetLanguageId}`,\n          expireIn: \"string\",\n        },\n      };\n    });\n    return build;\n  }\n}\n", "export function mockCrowdinClient(pluginOptions: PluginOptions) {\n  return new crowdinAPIWrapper(pluginOptions);\n}\n"]}
{"filename": "src/utilities/index.spec.ts", "chunked_list": ["import { Block, CollectionConfig, GlobalConfig } from \"payload/types\";\nimport {\n  getLocalizedFields,\n  fieldChanged,\n  containsLocalizedFields,\n  getFieldSlugs,\n} from \".\";\nimport deepEqual from \"deep-equal\";\n\ndescribe(\"Function: containsLocalizedFields\", () => {", "\ndescribe(\"Function: containsLocalizedFields\", () => {\n  it(\"detects localized fields on the top-level\", () => {\n    const global: GlobalConfig = {\n      slug: \"global\",\n      fields: [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"richText\",\n          localized: true,", "          type: \"richText\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n      ],\n    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);", "    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);\n  });\n\n  it(\"detects localized fields in a group field\", () => {\n    const global: GlobalConfig = {\n      slug: \"global\",\n      fields: [\n        {\n          name: \"simpleNonLocalizedField\",", "        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",", "            {\n              name: \"simpleLocalizedField\",\n              type: \"richText\",\n              localized: true,\n            },\n          ],\n        },\n      ],\n    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);", "    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);\n  });\n\n  it(\"detects localized fields in an array field\", () => {\n    const global: GlobalConfig = {\n      slug: \"global\",\n      fields: [\n        {\n          name: \"simpleNonLocalizedField\",", "        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"richText\",", "            {\n              name: \"richText\",\n              type: \"richText\",\n              localized: true,\n            },\n          ],\n        },\n      ],\n    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);", "    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);\n  });\n\n  it(\"returns false if no localized fields in a blocks field\", () => {\n    const TestBlock: Block = {\n      slug: \"text\",\n      imageAltText: \"Text\",\n      fields: [\n        {", "      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n        },\n        {\n          name: \"text\",\n          type: \"richText\",\n        },\n        {", "        },\n        {\n          name: \"select\",\n          type: \"select\",\n          options: [\"one\", \"two\"],\n        },\n      ],\n    };\n    const global: GlobalConfig = {\n      slug: \"global\",", "    const global: GlobalConfig = {\n      slug: \"global\",\n      fields: [\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"blocksField\",\n          type: \"blocks\",", "          name: \"blocksField\",\n          type: \"blocks\",\n          blocks: [TestBlock],\n        },\n      ],\n    };\n    expect(containsLocalizedFields({ fields: global.fields })).toBe(false);\n  });\n});\n", "});\n\ndescribe(\"Function: fieldChanged\", () => {\n  it(\"detects a richText field change on create\", () => {\n    const before = undefined;\n    const after = {\n      children: [\n        {\n          text: \"Test content\",\n        },", "          text: \"Test content\",\n        },\n      ],\n    };\n    const type = \"richText\";\n    expect(fieldChanged(before, after, type)).toEqual(true);\n  });\n\n  it(\"detects a richText field change on update\", () => {\n    const before = {", "  it(\"detects a richText field change on update\", () => {\n    const before = {\n      children: [\n        {\n          text: \"Test content before\",\n        },\n      ],\n    };\n    const after = {\n      children: [", "    const after = {\n      children: [\n        {\n          text: \"Test content\",\n        },\n      ],\n    };\n    const type = \"richText\";\n    expect(fieldChanged(before, after, type)).toEqual(true);\n  });", "    expect(fieldChanged(before, after, type)).toEqual(true);\n  });\n\n  it(\"returns false for equal richText objects\", () => {\n    const before = {\n      children: [\n        {\n          text: \"Test content\",\n        },\n      ],", "        },\n      ],\n    };\n    const after = before;\n    const type = \"richText\";\n    expect(fieldChanged(before, after, type)).toEqual(false);\n  });\n});\n\n/**", "\n/**\n * Test the deep-equal dependency\n *\n * Usually, tests should not be done on third\n * party libraries but in this case, we need to\n * be sure key order does not matter.\n */\ndescribe(\"deep-equal\", () => {\n  it(\"returns equal if keys are in a different order\", () => {", "describe(\"deep-equal\", () => {\n  it(\"returns equal if keys are in a different order\", () => {\n    const obj1 = {\n      title: \"Sample article\",\n      content: [\n        {\n          children: [\n            {\n              text: \"Heading 2\",\n            },", "              text: \"Heading 2\",\n            },\n          ],\n          type: \"h2\",\n        },\n        {\n          children: [\n            {\n              text: \"A regular paragraph.\",\n            },", "              text: \"A regular paragraph.\",\n            },\n          ],\n        },\n      ],\n      meta: {\n        title: \"Sample article | Company\",\n        description: \"\",\n      },\n    };", "      },\n    };\n    const obj2 = {\n      title: \"Sample article\",\n      meta: {\n        description: \"\",\n        title: \"Sample article | Company\",\n      },\n      content: [\n        {", "      content: [\n        {\n          children: [\n            {\n              text: \"Heading 2\",\n            },\n          ],\n          type: \"h2\",\n        },\n        {", "        },\n        {\n          children: [\n            {\n              text: \"A regular paragraph.\",\n            },\n          ],\n        },\n      ],\n    };", "      ],\n    };\n    expect(deepEqual(obj1, obj2)).toBe(true);\n  });\n});\n"]}
{"filename": "src/utilities/isLocalizedField.spec.ts", "chunked_list": ["import { Field } from \"payload/types\";\nimport { isLocalizedField } from \".\";\n\ndescribe(\"fn: isLocalizedField\", () => {\n  it(\"excludes a select localized field\", () => {\n    const field: Field = {\n      name: \"select\",\n      type: \"select\",\n      localized: true,\n      options: [\"one\", \"two\"],", "      localized: true,\n      options: [\"one\", \"two\"],\n    };\n    expect(isLocalizedField(field)).toBe(false);\n  });\n});\n"]}
{"filename": "src/utilities/getFieldSlugs.spec.ts", "chunked_list": ["import { CollectionConfig, GlobalConfig } from \"payload/types\";\nimport { getLocalizedFields, getFieldSlugs } from \".\";\n\ndescribe(\"Function: getFieldSlugs\", () => {\n  it(\"detects top-level richText fields\", () => {\n    const Policies: CollectionConfig = {\n      slug: \"policies\",\n      admin: {\n        defaultColumns: [\"title\", \"updatedDate\"],\n        useAsTitle: \"title\",", "        defaultColumns: [\"title\", \"updatedDate\"],\n        useAsTitle: \"title\",\n        group: \"Pages\",\n      },\n      access: {\n        read: () => true,\n      },\n      versions: {\n        drafts: true,\n      },", "        drafts: true,\n      },\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"updatedDate\",", "        {\n          name: \"updatedDate\",\n          type: \"date\",\n          admin: {\n            description:\n              \"If set, this updated date/time will be displayed on the policy page.\",\n          },\n        },\n        {\n          name: \"content\",", "        {\n          name: \"content\",\n          type: \"richText\",\n          localized: true,\n        },\n      ],\n    };\n    const htmlFields = getLocalizedFields({\n      fields: Policies.fields,\n      type: \"html\",", "      fields: Policies.fields,\n      type: \"html\",\n    });\n    expect(getFieldSlugs(htmlFields)).toEqual([\"content\"]);\n  });\n\n  it(\"returns an empty array if no rich text fields\", () => {\n    const Statistics: GlobalConfig = {\n      slug: \"statistics\",\n      access: {", "      slug: \"statistics\",\n      access: {\n        read: () => true,\n      },\n      fields: [\n        {\n          name: \"users\",\n          type: \"group\",\n          fields: [\n            {", "          fields: [\n            {\n              name: \"text\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"number\",\n              type: \"number\",\n              min: 0,", "              type: \"number\",\n              min: 0,\n              admin: {\n                step: 100,\n                description:\n                  \"Restricted to multiples of 100 in order to simplify localization.\",\n              },\n            },\n          ],\n        },", "          ],\n        },\n        {\n          name: \"companies\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"text\",\n              type: \"text\",\n              localized: true,", "              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"number\",\n              type: \"number\",\n              min: 0,\n              admin: {\n                step: 100,\n                description:", "                step: 100,\n                description:\n                  \"Restricted to multiples of 100 in order to simplify localization.\",\n              },\n            },\n          ],\n        },\n        {\n          name: \"countries\",\n          type: \"group\",", "          name: \"countries\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"text\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"number\",", "            {\n              name: \"number\",\n              type: \"number\",\n              min: 0,\n              admin: {\n                step: 1,\n              },\n            },\n          ],\n        },", "          ],\n        },\n        {\n          name: \"successfulHires\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"text\",\n              type: \"text\",\n              localized: true,", "              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"number\",\n              type: \"number\",\n              min: 0,\n              admin: {\n                step: 100,\n                description:", "                step: 100,\n                description:\n                  \"Restricted to multiples of 100 in order to simplify localization.\",\n              },\n            },\n          ],\n        },\n      ],\n    };\n    const htmlFields = getLocalizedFields({", "    };\n    const htmlFields = getLocalizedFields({\n      fields: Statistics.fields,\n      type: \"html\",\n    });\n    expect(getFieldSlugs(htmlFields)).toEqual([]);\n  });\n});\n", ""]}
{"filename": "src/utilities/containsLocalizedFields.spec.ts", "chunked_list": ["import { CollectionConfig, Field, GlobalConfig } from \"payload/types\";\nimport { containsLocalizedFields, getLocalizedFields } from \".\";\n\ndescribe(\"fn: containsLocalizedFields: true tests\", () => {\n  describe(\"basic field type tests\", () => {\n    it(\"includes localized fields from a group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"simpleNonLocalizedField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n\n    it(\"includes localized fields from an array field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"text\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n\n    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          localized: true,\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n            },\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n\n    it(\"includes localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n      const fields: Field[] = [\n        {\n          label: \"Array fields\",\n          type: \"collapsible\",\n          fields: [\n            {\n              name: \"arrayField\",\n              type: \"array\",\n              fields: [\n                {\n                  name: \"title\",\n                  type: \"richText\",\n                  localized: true,\n                },\n                {\n                  name: \"content\",\n                  type: \"richText\",\n                  localized: true,\n                },\n                {\n                  name: \"select\",\n                  type: \"select\",\n                  localized: true,\n                  options: [\"one\", \"two\"],\n                },\n              ],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n\n    /**\n     * * help ensure no errors during version 0 development", "     * * mitigate against errors if a new field type is introduced by Payload CMS\n     */\n    it(\"does not include unrecognized field types\", () => {\n      const fields: any[] = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"textNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"unknownLocalizedField\",\n          type: \"weird\",\n          localized: true,\n        },\n        {\n          name: \"Unknown Field type\",\n          type: \"strange\",\n          fields: [\n            {\n              name: \"textLocalizedFieldInCollapsibleField\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"textNonLocalizedFieldInCollapsibleField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"selectLocalizedFieldInCollapsibleField\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n\n    it(\"includes localized fields from a group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"simpleNonLocalizedField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n\n    it(\"includes localized fields from a group field with a localization setting on the group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          localized: true,\n          fields: [\n            {\n              name: \"textLocalizedField\",\n              type: \"text\",\n            },\n            {\n              name: \"richTextLocalizedField\",\n              type: \"richText\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(true);\n    });\n  });\n\n  it(\"includes localized fields from a group field with a localization setting on the group field: localized parent only\", () => {\n    const fields: Field[] = [\n      {\n        name: \"groupField\",\n        type: \"group\",\n        localized: true,\n        fields: [\n          {\n            name: \"textLocalizedField\",\n            type: \"text\",\n          },\n          {\n            name: \"richTextLocalizedField\",\n            type: \"richText\",\n          },\n          // select fields not supported yet\n          {\n            name: \"text\",\n            type: \"select\",\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n    ];\n    expect(containsLocalizedFields({ fields })).toEqual(true);\n  });\n\n  describe(\"extract rich text localized fields\", () => {\n    const fields: Field[] = [\n      {\n        name: \"simpleLocalizedField\",\n        type: \"richText\",\n        localized: true,\n      },\n      {\n        name: \"simpleNonLocalizedField\",\n        type: \"text\",\n      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n            localized: true,\n          },\n          {\n            name: \"richText\",\n            type: \"richText\",\n            localized: true,\n          },\n          {\n            name: \"select\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        fields: [\n          {\n            name: \"simpleLocalizedField\",\n            type: \"richText\",\n            localized: true,\n          },\n          {\n            name: \"simpleNonLocalizedField\",\n            type: \"text\",\n          },\n          // select fields not supported yet\n          {\n            name: \"text\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n    ];\n    expect(containsLocalizedFields({ fields })).toEqual(true);\n  });\n\n  it(\"returns nested json fields in a group inside an array\", () => {\n    const linkField: Field = {\n      name: \"link\",\n      type: \"group\",\n      fields: [\n        {\n          name: \"text\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"href\",\n          type: \"text\",\n        },\n        {\n          name: \"type\",\n          type: \"select\",\n          options: [\"ctaPrimary\", \"ctaSecondary\"],\n        },\n      ],\n    };\n    const Promos: CollectionConfig = {\n      slug: \"promos\",\n      admin: {\n        defaultColumns: [\"title\", \"updatedAt\"],\n        useAsTitle: \"title\",\n        group: \"Shared\",\n      },\n      access: {\n        read: () => true,\n      },\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"text\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"ctas\",\n          type: \"array\",\n          minRows: 1,\n          maxRows: 2,\n          fields: [linkField],\n        },\n      ],\n    };\n    expect(containsLocalizedFields({ fields: Promos.fields })).toEqual(true);\n  });\n});\n\ndescribe(\"fn: containsLocalizedFields: false tests\", () => {", "  describe(\"basic field type tests\", () => {\n    it(\"includes localized fields from a group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",\n              type: \"text\",\n            },\n            {\n              name: \"simpleNonLocalizedField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n\n    it(\"includes localized fields from an array field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n            },\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n\n    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n            },\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n\n    it(\"includes localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n      const fields: Field[] = [\n        {\n          label: \"Array fields\",\n          type: \"collapsible\",\n          fields: [\n            {\n              name: \"arrayField\",\n              type: \"array\",\n              fields: [\n                {\n                  name: \"title\",\n                  type: \"richText\",\n                },\n                {\n                  name: \"content\",\n                  type: \"richText\",\n                },\n                {\n                  name: \"select\",\n                  type: \"select\",\n                  options: [\"one\", \"two\"],\n                },\n              ],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n\n    /**\n     * * help ensure no errors during version 0 development", "     * * mitigate against errors if a new field type is introduced by Payload CMS\n     */\n    it(\"does not include unrecognized field types\", () => {\n      const fields: any[] = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"textNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"unknownLocalizedField\",\n          type: \"weird\",\n          localized: true,\n        },\n        {\n          name: \"Unknown Field type\",\n          type: \"strange\",\n          fields: [\n            {\n              name: \"textLocalizedFieldInCollapsibleField\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"textNonLocalizedFieldInCollapsibleField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"selectLocalizedFieldInCollapsibleField\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n\n    it(\"includes localized fields from a group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",\n              type: \"text\",\n            },\n            {\n              name: \"simpleNonLocalizedField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n\n    it(\"includes localized fields from a group field with a localization setting on the group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"textLocalizedField\",\n              type: \"text\",\n            },\n            {\n              name: \"richTextLocalizedField\",\n              type: \"richText\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(containsLocalizedFields({ fields })).toEqual(false);\n    });\n  });\n\n  describe(\"extract rich text localized fields\", () => {\n    const fields: Field[] = [\n      {\n        name: \"simpleLocalizedField\",\n        type: \"richText\",\n      },\n      {\n        name: \"simpleNonLocalizedField\",\n        type: \"text\",\n      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n          },\n          {\n            name: \"richText\",\n            type: \"richText\",\n          },\n          {\n            name: \"select\",\n            type: \"select\",\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        fields: [\n          {\n            name: \"simpleLocalizedField\",\n            type: \"richText\",\n          },\n          {\n            name: \"simpleNonLocalizedField\",\n            type: \"text\",\n          },\n          // select fields not supported yet\n          {\n            name: \"text\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n    ];\n    expect(containsLocalizedFields({ fields })).toEqual(false);\n  });\n\n  it(\"returns nested json fields in a group inside an array\", () => {\n    const linkField: Field = {\n      name: \"link\",\n      type: \"group\",\n      fields: [\n        {\n          name: \"text\",\n          type: \"text\",\n        },\n        {\n          name: \"href\",\n          type: \"text\",\n        },\n        {\n          name: \"type\",\n          type: \"select\",\n          options: [\"ctaPrimary\", \"ctaSecondary\"],\n        },\n      ],\n    };\n    const Promos: CollectionConfig = {\n      slug: \"promos\",\n      admin: {\n        defaultColumns: [\"title\", \"updatedAt\"],\n        useAsTitle: \"title\",\n        group: \"Shared\",\n      },\n      access: {\n        read: () => true,\n      },\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n        },\n        {\n          name: \"text\",\n          type: \"text\",\n        },\n        {\n          name: \"ctas\",\n          type: \"array\",\n          minRows: 1,\n          maxRows: 2,\n          fields: [linkField],\n        },\n      ],\n    };\n    expect(containsLocalizedFields({ fields: Promos.fields })).toEqual(false);\n  });\n});\n"]}
{"filename": "src/utilities/index.ts", "chunked_list": ["import {\n  Block,\n  CollapsibleField,\n  CollectionConfig,\n  Field,\n  GlobalConfig,\n} from \"payload/types\";\nimport deepEqual from \"deep-equal\";\nimport { FieldWithName } from \"../types\";\nimport { slateToHtml, payloadSlateToDomConfig } from \"slate-serializers\";", "import { FieldWithName } from \"../types\";\nimport { slateToHtml, payloadSlateToDomConfig } from \"slate-serializers\";\nimport type { Descendant } from \"slate\";\nimport { get, isEmpty, map, merge, omitBy } from \"lodash\";\nimport dot from \"dot-object\";\n\nconst localizedFieldTypes = [\"richText\", \"text\", \"textarea\"];\n\nconst nestedFieldTypes = [\"array\", \"group\", \"blocks\"];\n", "const nestedFieldTypes = [\"array\", \"group\", \"blocks\"];\n\nexport const containsNestedFields = (field: Field) =>\n  nestedFieldTypes.includes(field.type);\n\nexport const getLocalizedFields = ({\n  fields,\n  type,\n  localizedParent = false,\n}: {", "  localizedParent = false,\n}: {\n  fields: Field[];\n  type?: \"json\" | \"html\";\n  localizedParent?: boolean;\n}): any[] => {\n  const localizedFields = getLocalizedFieldsRecursive({\n    fields,\n    type,\n    localizedParent,", "    type,\n    localizedParent,\n  });\n  return localizedFields;\n};\n\nexport const getLocalizedFieldsRecursive = ({\n  fields,\n  type,\n  localizedParent = false,", "  type,\n  localizedParent = false,\n}: {\n  fields: Field[];\n  type?: \"json\" | \"html\";\n  localizedParent?: boolean;\n}): any[] => [\n  ...fields\n    // localized or group fields only.\n    .filter(", "    // localized or group fields only.\n    .filter(\n      (field) =>\n        isLocalizedField(field, localizedParent) || containsNestedFields(field)\n    )\n    // further filter on Crowdin field type\n    .filter((field) => {\n      if (containsNestedFields(field)) {\n        return true;\n      }\n      return type\n        ? fieldCrowdinFileType(field as FieldWithName) === type\n        : true;\n    })\n    // exclude group, array and block fields with no localized fields\n    // TODO: find a better way to do this - block, array and group logic is duplicated, and this filter needs to be compatible with field extraction logic later in this function\n    .filter((field) => {\n      const localizedParent = hasLocalizedProp(field);", "      if (field.type === \"group\" || field.type === \"array\") {\n        return containsLocalizedFields({\n          fields: field.fields,\n          type,\n          localizedParent,\n        });\n      }\n      if (field.type === \"blocks\") {\n        return field.blocks.find((block) =>\n          containsLocalizedFields({\n            fields: block.fields,\n            type,\n            localizedParent,\n          })\n        );\n      }\n      return true;\n    })\n    // recursion for group, array and blocks field\n    .map((field) => {\n      const localizedParent = hasLocalizedProp(field);", "      if (field.type === \"group\" || field.type === \"array\") {\n        return {\n          ...field,\n          fields: getLocalizedFields({\n            fields: field.fields,\n            type,\n            localizedParent,\n          }),\n        };\n      }\n      if (field.type === \"blocks\") {\n        const blocks = field.blocks\n          .map((block: Block) => {", "      if (field.type === \"blocks\") {\n        const blocks = field.blocks\n          .map((block: Block) => {\n            if (\n              containsLocalizedFields({\n                fields: block.fields,\n                type,\n                localizedParent,\n              })\n            ) {\n              return {\n                slug: block.slug,\n                fields: getLocalizedFields({\n                  fields: block.fields,\n                  type,\n                  localizedParent,\n                }),\n              };\n            }\n          })\n          .filter((block) => block);\n        return {\n          ...field,\n          blocks,\n        };\n      }\n      return field;\n    })\n    .filter(\n      (field) =>\n        (field as any).type !== \"collapsible\" && (field as any).type !== \"tabs\"\n    ),\n  ...convertTabs({ fields }),\n  // recursion for collapsible field - flatten results into the returned array\n  ...getCollapsibleLocalizedFields({ fields, type }),\n];\n\nexport const getCollapsibleLocalizedFields = ({\n  fields,\n  type,\n}: {\n  fields: Field[];\n  type?: \"json\" | \"html\";\n}): any[] =>\n  fields\n    .filter((field) => field.type === \"collapsible\")\n    .flatMap((field) =>\n      getLocalizedFields({\n        fields: (field as CollapsibleField).fields,\n        type,\n      })\n    );\n\nexport const convertTabs = ({\n  fields,\n  type,\n}: {\n  fields: Field[];\n  type?: \"json\" | \"html\";\n}): any[] =>\n  fields\n    .filter((field) => field.type === \"tabs\")\n    .flatMap((field) => {", "      if (field.type === \"tabs\") {\n        const flattenedFields = field.tabs.reduce((tabFields, tab) => {\n          return [\n            ...tabFields,\n            \"name\" in tab\n              ? ({\n                  type: \"group\",\n                  name: tab.name,\n                  fields: tab.fields,\n                } as Field)\n              : ({\n                  label: \"fromTab\",\n                  type: \"collapsible\",\n                  fields: tab.fields,\n                } as Field),\n          ];\n        }, [] as Field[]);\n        return getLocalizedFields({\n          fields: flattenedFields,\n          type,\n        });\n      }\n      return field;\n    });\n\nexport const getLocalizedRequiredFields = (\n  collection: CollectionConfig | GlobalConfig,\n  type?: \"json\" | \"html\"\n): any[] => {\n  const fields = getLocalizedFields({ fields: collection.fields, type });\n  return fields.filter((field) => field.required);\n};\n\n/**\n * Not yet compatible with nested fields - this means nested HTML\n * field translations cannot be synced from Crowdin.\n */\nexport const getFieldSlugs = (fields: FieldWithName[]): string[] =>\n  fields\n    .filter(\n      (field: Field) => field.type === \"text\" || field.type === \"richText\"\n    )\n    .map((field: FieldWithName) => field.name);\n\nconst hasLocalizedProp = (field: Field) =>\n  \"localized\" in field && field.localized;\n\n/**\n * Is Localized Field\n *\n * Note that `id` should be excluded - it is a `text` field that is added by Payload CMS.\n */\nexport const isLocalizedField = (\n  field: Field,\n  addLocalizedProp: boolean = false\n) =>\n  (hasLocalizedProp(field) || addLocalizedProp) &&\n  localizedFieldTypes.includes(field.type) &&\n  !excludeBasedOnDescription(field) &&\n  (field as any).name !== \"id\";\n\nconst excludeBasedOnDescription = (field: Field) => {\n  const description = get(field, \"admin.description\", \"\");", "  if (description.includes(\"Not sent to Crowdin. Localize in the CMS.\")) {\n    return true;\n  }\n  return false;\n};\n\nexport const containsLocalizedFields = ({\n  fields,\n  type,\n  localizedParent,\n}: {\n  fields: Field[];\n  type?: \"json\" | \"html\";\n  localizedParent?: boolean;\n}): boolean => {\n  return !isEmpty(getLocalizedFields({ fields, type, localizedParent }));\n};\n\nexport const fieldChanged = (\n  previousValue: string | object | undefined,\n  value: string | object | undefined,\n  type: string\n) => {", "  if (type === \"richText\") {\n    return !deepEqual(previousValue || {}, value || {});\n  }\n  return previousValue !== value;\n};\n\nexport const removeLineBreaks = (string: string) =>\n  string.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\nexport const fieldCrowdinFileType = (field: FieldWithName): \"json\" | \"html\" =>\n  field.type === \"richText\" ? \"html\" : \"json\";\n\n/**\n * Reorder blocks and array values based on the order of the original document.\n */\nexport const restoreOrder = ({\n  updateDocument,\n  document,\n  fields,\n}: {\n  updateDocument: { [key: string]: any };\n  document: { [key: string]: any };\n  fields: Field[];\n}) => {\n  let response: { [key: string]: any } = {};\n  // it is possible the original document is empty (e.g. new document)", "  if (!document) {\n    return updateDocument;\n  }\n  fields.forEach((field: any) => {\n    if (!updateDocument || !updateDocument[field.name]) {\n      return;\n    }\n    if (field.type === \"group\") {\n      response[field.name] = restoreOrder({\n        updateDocument: updateDocument[field.name],\n        document: document[field.name],\n        fields: field.fields,\n      });", "    } else if (field.type === \"array\" || field.type === \"blocks\") {\n      response[field.name] = document[field.name]\n        .map((item: any) => {\n          const arrayItem = updateDocument[field.name].find(\n            (updateItem: any) => {\n              return updateItem.id === item.id;\n            }\n          );\n          if (!arrayItem) {\n            return;\n          }\n          const subFields =\n            field.type === \"blocks\"\n              ? field.blocks.find(\n                  (block: Block) => block.slug === item.blockType\n                )?.fields || []\n              : field.fields;\n          return {\n            ...restoreOrder({\n              updateDocument: arrayItem,\n              document: item,\n              fields: subFields,\n            }),\n            id: arrayItem.id,\n            ...(field.type === \"blocks\" && { blockType: arrayItem.blockType }),\n          };\n        })\n        .filter((item: any) => !isEmpty(item));\n    } else {\n      response[field.name] = updateDocument[field.name];\n    }\n  });\n  return response;\n};\n\n/**\n * Convert Crowdin objects to Payload CMS data objects.\n *\n * * `crowdinJsonObject` is the JSON object returned from Crowdin.\n * * `crowdinHtmlObject` is the HTML object returned from Crowdin. Optional. Merged into resulting object if provided.\n * * `fields` is the collection or global fields array.\n * * `topLevel` is a flag used internally to filter json fields before recursion.\n * * `document` is the document object. Optional. Used to restore the order of `array` and `blocks` field values.\n */\nexport const buildPayloadUpdateObject = ({\n  crowdinJsonObject,\n  crowdinHtmlObject,\n  fields,\n  topLevel = true,\n  document,\n}: {\n  crowdinJsonObject: { [key: string]: any };\n  crowdinHtmlObject?: { [key: string]: any };\n  /** Use getLocalizedFields to pass localized fields only */\n  fields: Field[];\n  /** Flag used internally to filter json fields before recursion. */\n  topLevel?: boolean;\n  document?: { [key: string]: any };\n}) => {\n  let response: { [key: string]: any } = {};", "          if (!arrayItem) {\n            return;\n          }\n          const subFields =\n            field.type === \"blocks\"\n              ? field.blocks.find(\n                  (block: Block) => block.slug === item.blockType\n                )?.fields || []\n              : field.fields;\n          return {\n            ...restoreOrder({\n              updateDocument: arrayItem,\n              document: item,\n              fields: subFields,\n            }),\n            id: arrayItem.id,\n            ...(field.type === \"blocks\" && { blockType: arrayItem.blockType }),\n          };\n        })\n        .filter((item: any) => !isEmpty(item));\n    } else {\n      response[field.name] = updateDocument[field.name];\n    }\n  });\n  return response;\n};\n\n/**\n * Convert Crowdin objects to Payload CMS data objects.\n *\n * * `crowdinJsonObject` is the JSON object returned from Crowdin.\n * * `crowdinHtmlObject` is the HTML object returned from Crowdin. Optional. Merged into resulting object if provided.\n * * `fields` is the collection or global fields array.\n * * `topLevel` is a flag used internally to filter json fields before recursion.\n * * `document` is the document object. Optional. Used to restore the order of `array` and `blocks` field values.\n */\nexport const buildPayloadUpdateObject = ({\n  crowdinJsonObject,\n  crowdinHtmlObject,\n  fields,\n  topLevel = true,\n  document,\n}: {\n  crowdinJsonObject: { [key: string]: any };\n  crowdinHtmlObject?: { [key: string]: any };\n  /** Use getLocalizedFields to pass localized fields only */\n  fields: Field[];\n  /** Flag used internally to filter json fields before recursion. */\n  topLevel?: boolean;\n  document?: { [key: string]: any };\n}) => {\n  let response: { [key: string]: any } = {};", "  if (crowdinHtmlObject) {\n    const destructured = dot.object(crowdinHtmlObject);\n    merge(crowdinJsonObject, destructured);\n  }\n  const filteredFields = topLevel\n    ? getLocalizedFields({\n        fields,\n        type: !crowdinHtmlObject ? \"json\" : undefined,\n      })\n    : fields;\n  filteredFields.forEach((field) => {", "    if (!crowdinJsonObject[field.name]) {\n      return;\n    }\n    if (field.type === \"group\") {\n      response[field.name] = buildPayloadUpdateObject({\n        crowdinJsonObject: crowdinJsonObject[field.name],\n        fields: field.fields,\n        topLevel: false,\n      });\n    } else if (field.type === \"array\") {\n      response[field.name] = map(crowdinJsonObject[field.name], (item, id) => {\n        const payloadUpdateObject = buildPayloadUpdateObject({\n          crowdinJsonObject: item,\n          fields: field.fields,\n          topLevel: false,\n        });\n        return {\n          ...payloadUpdateObject,\n          id,\n        };\n      }).filter((item: any) => !isEmpty(item));", "    } else if (field.type === \"array\") {\n      response[field.name] = map(crowdinJsonObject[field.name], (item, id) => {\n        const payloadUpdateObject = buildPayloadUpdateObject({\n          crowdinJsonObject: item,\n          fields: field.fields,\n          topLevel: false,\n        });\n        return {\n          ...payloadUpdateObject,\n          id,\n        };\n      }).filter((item: any) => !isEmpty(item));", "    } else if (field.type === \"blocks\") {\n      response[field.name] = map(crowdinJsonObject[field.name], (item, id) => {\n        // get first and only object key\n        const blockType = Object.keys(item)[0];\n        const payloadUpdateObject = buildPayloadUpdateObject({\n          crowdinJsonObject: item[blockType],\n          fields:\n            field.blocks.find((block: Block) => block.slug === blockType)\n              ?.fields || [],\n          topLevel: false,\n        });\n        return {\n          ...payloadUpdateObject,\n          id,\n          blockType,\n        };\n      }).filter((item: any) => !isEmpty(item));\n    } else {\n      response[field.name] = crowdinJsonObject[field.name];\n    }\n  });", "  if (document) {\n    response = restoreOrder({\n      updateDocument: response,\n      document,\n      fields,\n    });\n  }\n  return omitBy(response, isEmpty);\n};\n\nexport const buildCrowdinJsonObject = ({\n  doc,\n  fields,\n  topLevel = true,\n}: {\n  doc: { [key: string]: any };\n  /** Use getLocalizedFields to pass localized fields only */\n  fields: Field[];\n  /** Flag used internally to filter json fields before recursion. */\n  topLevel?: boolean;\n}) => {\n  let response: { [key: string]: any } = {};\n  const filteredFields = topLevel\n    ? getLocalizedFields({ fields, type: \"json\" })\n    : fields;\n  filteredFields.forEach((field) => {", "    if (!doc[field.name]) {\n      return;\n    }\n    if (field.type === \"group\") {\n      response[field.name] = buildCrowdinJsonObject({\n        doc: doc[field.name],\n        fields: field.fields,\n        topLevel: false,\n      });\n    } else if (field.type === \"array\") {\n      response[field.name] = doc[field.name]\n        .map((item: any) => {\n          const crowdinJsonObject = buildCrowdinJsonObject({\n            doc: item,\n            fields: field.fields,\n            topLevel: false,\n          });", "    } else if (field.type === \"array\") {\n      response[field.name] = doc[field.name]\n        .map((item: any) => {\n          const crowdinJsonObject = buildCrowdinJsonObject({\n            doc: item,\n            fields: field.fields,\n            topLevel: false,\n          });\n          if (!isEmpty(crowdinJsonObject)) {\n            return {\n              [item.id]: crowdinJsonObject,\n            };\n          }\n        })\n        .filter((item: any) => !isEmpty(item))\n        .reduce((acc: object, item: any) => ({ ...acc, ...item }), {});", "          if (!isEmpty(crowdinJsonObject)) {\n            return {\n              [item.id]: crowdinJsonObject,\n            };\n          }\n        })\n        .filter((item: any) => !isEmpty(item))\n        .reduce((acc: object, item: any) => ({ ...acc, ...item }), {});\n    } else if (field.type === \"blocks\") {\n      response[field.name] = doc[field.name]\n        .map((item: any) => {\n          const crowdinJsonObject = buildCrowdinJsonObject({\n            doc: item,\n            fields:\n              field.blocks.find((block: Block) => block.slug === item.blockType)\n                ?.fields || [],\n            topLevel: false,\n          });", "    } else if (field.type === \"blocks\") {\n      response[field.name] = doc[field.name]\n        .map((item: any) => {\n          const crowdinJsonObject = buildCrowdinJsonObject({\n            doc: item,\n            fields:\n              field.blocks.find((block: Block) => block.slug === item.blockType)\n                ?.fields || [],\n            topLevel: false,\n          });\n          if (!isEmpty(crowdinJsonObject)) {\n            return {\n              [item.id]: {\n                [item.blockType]: crowdinJsonObject,\n              },\n            };\n          }\n        })\n        .filter((item: any) => !isEmpty(item))\n        .reduce((acc: object, item: any) => ({ ...acc, ...item }), {});\n    } else {\n      response[field.name] = doc[field.name];\n    }\n  });\n  return omitBy(response, isEmpty);\n};\n\nexport const buildCrowdinHtmlObject = ({\n  doc,\n  fields,\n  prefix = \"\",\n  topLevel = true,\n}: {\n  doc: { [key: string]: any };\n  /** Use getLocalizedFields to pass localized fields only */\n  fields: Field[];\n  /** Use to build dot notation field during recursion. */\n  prefix?: string;\n  /** Flag used internally to filter html fields before recursion. */\n  topLevel?: boolean;\n}) => {\n  let response: { [key: string]: any } = {};\n  // it is convenient to be able to pass all fields - filter in this case\n  const filteredFields = topLevel\n    ? getLocalizedFields({ fields, type: \"html\" })\n    : fields;\n  filteredFields.forEach((field) => {\n    const name = [prefix, (field as FieldWithName).name]\n      .filter((string) => string)\n      .join(\".\");", "          if (!isEmpty(crowdinJsonObject)) {\n            return {\n              [item.id]: {\n                [item.blockType]: crowdinJsonObject,\n              },\n            };\n          }\n        })\n        .filter((item: any) => !isEmpty(item))\n        .reduce((acc: object, item: any) => ({ ...acc, ...item }), {});\n    } else {\n      response[field.name] = doc[field.name];\n    }\n  });\n  return omitBy(response, isEmpty);\n};\n\nexport const buildCrowdinHtmlObject = ({\n  doc,\n  fields,\n  prefix = \"\",\n  topLevel = true,\n}: {\n  doc: { [key: string]: any };\n  /** Use getLocalizedFields to pass localized fields only */\n  fields: Field[];\n  /** Use to build dot notation field during recursion. */\n  prefix?: string;\n  /** Flag used internally to filter html fields before recursion. */\n  topLevel?: boolean;\n}) => {\n  let response: { [key: string]: any } = {};\n  // it is convenient to be able to pass all fields - filter in this case\n  const filteredFields = topLevel\n    ? getLocalizedFields({ fields, type: \"html\" })\n    : fields;\n  filteredFields.forEach((field) => {\n    const name = [prefix, (field as FieldWithName).name]\n      .filter((string) => string)\n      .join(\".\");", "    if (!doc[field.name]) {\n      return;\n    }\n    if (field.type === \"group\") {\n      const subPrefix = `${[prefix, field.name]\n        .filter((string) => string)\n        .join(\".\")}`;\n      response = {\n        ...response,\n        ...buildCrowdinHtmlObject({\n          doc: doc[field.name],\n          fields: field.fields,\n          prefix: subPrefix,\n          topLevel: false,\n        }),\n      };", "    } else if (field.type === \"array\") {\n      const arrayValues = doc[field.name].map((item: any, index: number) => {\n        const subPrefix = `${[prefix, `${field.name}`, `${item.id}`]\n          .filter((string) => string)\n          .join(\".\")}`;\n        return buildCrowdinHtmlObject({\n          doc: item,\n          fields: field.fields,\n          prefix: subPrefix,\n          topLevel: false,\n        });\n      });\n      response = {\n        ...response,\n        ...merge({}, ...arrayValues),\n      };", "    } else if (field.type === \"blocks\") {\n      const arrayValues = doc[field.name].map((item: any, index: number) => {\n        const subPrefix = `${[\n          prefix,\n          `${field.name}`,\n          `${item.id}`,\n          `${item.blockType}`,\n        ]\n          .filter((string) => string)\n          .join(\".\")}`;\n        return buildCrowdinHtmlObject({\n          doc: item,\n          fields:\n            field.blocks.find((block: Block) => block.slug === item.blockType)\n              ?.fields || [],\n          prefix: subPrefix,\n          topLevel: false,\n        });\n      });\n      response = {\n        ...response,\n        ...merge({}, ...arrayValues),\n      };\n    } else {", "      if (doc[field.name]?.en) {\n        response[name] = doc[field.name].en;\n      } else {\n        response[name] = doc[field.name];\n      }\n    }\n  });\n  return response;\n};\n\nexport const convertSlateToHtml = (slate: Descendant[]): string => {\n  return slateToHtml(slate, {\n    ...payloadSlateToDomConfig,\n    encodeEntities: false,\n    alwaysEncodeBreakingEntities: true,\n  });\n};\n"]}
{"filename": "src/utilities/getCollapsibleLocalizedFields.spec.ts", "chunked_list": ["import { GlobalConfig } from \"payload/types\";\nimport { getCollapsibleLocalizedFields } from \".\";\n\ndescribe(\"fn: getCollapsibleLocalizedFields\", () => {\n  it(\"includes only localized fields from a collapsible field\", () => {\n    const global: GlobalConfig = {\n      slug: \"global\",\n      fields: [\n        {\n          name: \"textLocalizedField\",", "        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"textNonLocalizedField\",\n          type: \"text\",\n        },\n        {", "        },\n        {\n          label: \"Collapsible Field\",\n          type: \"collapsible\",\n          fields: [\n            {\n              name: \"textLocalizedFieldInCollapsibleField\",\n              type: \"text\",\n              localized: true,\n            },", "              localized: true,\n            },\n            {\n              name: \"textNonLocalizedFieldInCollapsibleField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"selectLocalizedFieldInCollapsibleField\",\n              type: \"select\",", "              name: \"selectLocalizedFieldInCollapsibleField\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ],\n    };\n    const expected = [", "    };\n    const expected = [\n      {\n        name: \"textLocalizedFieldInCollapsibleField\",\n        type: \"text\",\n        localized: true,\n      },\n    ];\n    expect(getCollapsibleLocalizedFields({ fields: global.fields })).toEqual(\n      expected", "    expect(getCollapsibleLocalizedFields({ fields: global.fields })).toEqual(\n      expected\n    );\n  });\n});\n"]}
{"filename": "src/utilities/getLocalizedFields.spec.ts", "chunked_list": ["import { Block, CollectionConfig, Field, GlobalConfig } from \"payload/types\";\nimport { getLocalizedFields } from \".\";\n\ndescribe(\"fn: getLocalizedFields\", () => {\n  describe(\"basic field types\", () => {\n    it(\"includes a text field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",", "          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(fields);\n    });\n\n    it(\"excludes a localized text field based on the admin description\", () => {\n      const fields: Field[] = [", "    it(\"excludes a localized text field based on the admin description\", () => {\n      const fields: Field[] = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"textLocalizedFieldWithExcludeDescription\",\n          type: \"text\",", "          name: \"textLocalizedFieldWithExcludeDescription\",\n          type: \"text\",\n          localized: true,\n          admin: {\n            description: \"Not sent to Crowdin. Localize in the CMS.\",\n          },\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual([\n        {", "      expect(getLocalizedFields({ fields })).toEqual([\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n      ]);\n    });\n\n    it(\"includes a richText field\", () => {", "\n    it(\"includes a richText field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"richTextLocalizedField\",\n          type: \"richText\",\n          localized: true,\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(fields);", "      ];\n      expect(getLocalizedFields({ fields })).toEqual(fields);\n    });\n\n    it(\"includes a textarea field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"textareaLocalizedField\",\n          type: \"textarea\",\n          localized: true,", "          type: \"textarea\",\n          localized: true,\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(fields);\n    });\n  });\n\n  describe(\"include fields from groups and arrays\", () => {\n    const mixedFieldCollection: Field[] = [", "  describe(\"include fields from groups and arrays\", () => {\n    const mixedFieldCollection: Field[] = [\n      {\n        name: \"textLocalizedField\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"textNonLocalizedField\",\n        type: \"text\",", "        name: \"textNonLocalizedField\",\n        type: \"text\",\n      },\n      {\n        name: \"richTextLocalizedField\",\n        type: \"richText\",\n        localized: true,\n      },\n      {\n        name: \"richTextNonLocalizedField\",", "      {\n        name: \"richTextNonLocalizedField\",\n        type: \"richText\",\n      },\n      {\n        name: \"textareaLocalizedField\",\n        type: \"text\",\n        localized: true,\n      },\n      {", "      },\n      {\n        name: \"textareaNonLocalizedField\",\n        type: \"text\",\n      },\n      // select fields not supported yet\n      {\n        name: \"text\",\n        type: \"select\",\n        localized: true,", "        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n    ];\n\n    const localizedFieldCollection: Field[] = [\n      {\n        name: \"textLocalizedField\",\n        type: \"text\",", "        name: \"textLocalizedField\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"richTextLocalizedField\",\n        type: \"richText\",\n        localized: true,\n      },\n      {", "      },\n      {\n        name: \"textareaLocalizedField\",\n        type: \"text\",\n        localized: true,\n      },\n    ];\n\n    it(\"includes localized fields from a group field\", () => {\n      const fields: Field[] = [", "    it(\"includes localized fields from a group field\", () => {\n      const fields: Field[] = [\n        ...mixedFieldCollection,\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [...mixedFieldCollection],\n        },\n      ];\n      const expected = [", "      ];\n      const expected = [\n        ...localizedFieldCollection,\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [...localizedFieldCollection],\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(expected);", "      ];\n      expect(getLocalizedFields({ fields })).toEqual(expected);\n    });\n\n    it(\"includes localized fields from an array field\", () => {\n      const fields: Field[] = [\n        ...mixedFieldCollection,\n        {\n          name: \"arrayField\",\n          type: \"array\",", "          name: \"arrayField\",\n          type: \"array\",\n          fields: [...mixedFieldCollection],\n        },\n      ];\n      const expected = [\n        ...localizedFieldCollection,\n        {\n          name: \"arrayField\",\n          type: \"array\",", "          name: \"arrayField\",\n          type: \"array\",\n          fields: [...localizedFieldCollection],\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(expected);\n    });\n\n    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n      const fields: Field[] = [", "    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n      const fields: Field[] = [\n        ...mixedFieldCollection,\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          localized: true,\n          fields: [\n            {\n              name: \"title\",", "            {\n              name: \"title\",\n              type: \"text\",\n            },\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"textarea\",", "            {\n              name: \"textarea\",\n              type: \"textarea\",\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],", "            },\n          ],\n        },\n      ];\n      const expected = [\n        ...localizedFieldCollection,\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          localized: true,", "          type: \"array\",\n          localized: true,\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n            },\n            {\n              name: \"text\",\n              type: \"text\",", "              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"textarea\",\n              type: \"textarea\",\n            },\n          ],\n        },\n      ];", "        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(expected);\n    });\n\n    it(\"includes localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n      const fields: Field[] = [\n        {\n          label: \"Array fields\",\n          type: \"collapsible\",", "          label: \"Array fields\",\n          type: \"collapsible\",\n          fields: [\n            {\n              name: \"arrayField\",\n              type: \"array\",\n              fields: [...mixedFieldCollection],\n            },\n          ],\n        },", "          ],\n        },\n      ];\n      const expected = [\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [...localizedFieldCollection],\n        },\n      ];", "        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(expected);\n    });\n\n    /**\n     * * help ensure no errors during version 0 development\n     * * mitigate against errors if a new field type is introduced by Payload CMS\n     */\n    it(\"does not include unrecognized field types\", () => {\n      const global: any = {\n        slug: \"global\",\n        fields: [\n          {\n            name: \"textLocalizedField\",\n            type: \"text\",\n            localized: true,\n          },\n          {\n            name: \"textNonLocalizedField\",\n            type: \"text\",\n          },\n          {\n            name: \"unknownLocalizedField\",\n            type: \"weird\",\n            localized: true,\n          },\n          {\n            name: \"Unknown Field type\",\n            type: \"strange\",\n            fields: [\n              {\n                name: \"textLocalizedFieldInCollapsibleField\",\n                type: \"text\",\n                localized: true,\n              },\n              {\n                name: \"textNonLocalizedFieldInCollapsibleField\",\n                type: \"text\",\n              },\n              // select fields not supported yet\n              {\n                name: \"selectLocalizedFieldInCollapsibleField\",\n                type: \"select\",\n                localized: true,\n                options: [\"one\", \"two\"],\n              },\n            ],\n          },\n        ],\n      };\n      const expected = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n      ];\n      expect(getLocalizedFields({ fields: global.fields })).toEqual(expected);\n    });\n\n    it(\"includes localized fields from a group field with a localization setting on the group field\", () => {\n      const fields: Field[] = [\n        ...mixedFieldCollection,\n        {\n          name: \"groupField\",\n          type: \"group\",\n          localized: true,\n          fields: [\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"richText\",\n              type: \"richText\",\n            },\n            {\n              name: \"textarea\",\n              type: \"textarea\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      const expected = [\n        ...localizedFieldCollection,\n        {\n          name: \"groupField\",\n          type: \"group\",\n          localized: true,\n          fields: [\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"richText\",\n              type: \"richText\",\n            },\n            {\n              name: \"textarea\",\n              type: \"textarea\",\n            },\n          ],\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual(expected);\n    });\n\n    it(\"includes localized fields from a blocks field\", () => {\n      const TestBlock: Block = {\n        slug: \"text\",\n        imageAltText: \"Text\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n            localized: true,\n          },\n          {\n            name: \"text\",\n            type: \"richText\",\n            localized: true,\n          },\n          {\n            name: \"select\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },\n        ],\n      };\n      const TestBlockLocalizedFieldsOnly: Block = {\n        slug: \"text\",\n        imageAltText: \"Text\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n            localized: true,\n          },\n          {\n            name: \"text\",\n            type: \"richText\",\n            localized: true,\n          },\n        ],\n      };\n      const global: GlobalConfig = {\n        slug: \"global\",\n        fields: [\n          {\n            name: \"simpleLocalizedField\",\n            type: \"text\",\n            localized: true,\n          },\n          {\n            name: \"simpleNonLocalizedField\",\n            type: \"text\",\n          },\n          {\n            name: \"blocksField\",\n            type: \"blocks\",\n            blocks: [TestBlock],\n          },\n        ],\n      };\n      const expected = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"blocksField\",\n          type: \"blocks\",\n          blocks: [\n            {\n              fields: [\n                {\n                  name: \"title\",\n                  type: \"text\",\n                  localized: true,\n                },\n                {\n                  name: \"text\",\n                  type: \"richText\",\n                  localized: true,\n                },\n              ],\n              slug: \"text\",\n            },\n          ],\n        },\n      ];\n      expect(getLocalizedFields({ fields: global.fields })).toEqual(expected);\n    });\n  });\n\n  it(\"extract rich text localized fields\", () => {\n    const global: GlobalConfig = {\n      slug: \"global\",\n      fields: [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"richText\",\n          localized: true,\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"richText\",\n              type: \"richText\",\n              localized: true,\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",\n              type: \"richText\",\n              localized: true,\n            },\n            {\n              name: \"simpleNonLocalizedField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ],\n    };\n    const expected = [\n      {\n        name: \"simpleLocalizedField\",\n        type: \"richText\",\n        localized: true,\n      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [\n          {\n            name: \"richText\",\n            type: \"richText\",\n            localized: true,\n          },\n        ],\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        fields: [\n          {\n            name: \"simpleLocalizedField\",\n            type: \"richText\",\n            localized: true,\n          },\n        ],\n      },\n    ];\n    expect(getLocalizedFields({ fields: global.fields, type: \"html\" })).toEqual(\n      expected\n    );\n  });\n\n  it(\"returns nested json fields in a group inside an array\", () => {\n    const linkField: Field = {\n      name: \"link\",\n      type: \"group\",\n      fields: [\n        {\n          name: \"text\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"href\",\n          type: \"text\",\n        },\n        {\n          name: \"type\",\n          type: \"select\",\n          options: [\"ctaPrimary\", \"ctaSecondary\"],\n        },\n      ],\n    };\n    const Promos: CollectionConfig = {\n      slug: \"promos\",\n      admin: {\n        defaultColumns: [\"title\", \"updatedAt\"],\n        useAsTitle: \"title\",\n        group: \"Shared\",\n      },\n      access: {\n        read: () => true,\n      },\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"text\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"ctas\",\n          type: \"array\",\n          minRows: 1,\n          maxRows: 2,\n          fields: [linkField],\n        },\n      ],\n    };\n    const expected = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"text\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"ctas\",\n        type: \"array\",\n        minRows: 1,\n        maxRows: 2,\n        fields: [\n          {\n            name: \"link\",\n            type: \"group\",\n            fields: [\n              {\n                name: \"text\",\n                type: \"text\",\n                localized: true,\n              },\n            ],\n          },\n        ],\n      },\n    ];\n    const jsonFields = getLocalizedFields({\n      fields: Promos.fields,\n      type: \"json\",\n    });\n    expect(jsonFields).toEqual(expected);\n  });\n\n  describe(\"empty tests\", () => {\n    it(\"ignore non-localized group field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"groupField\",\n          type: \"group\",\n          fields: [\n            {\n              name: \"simpleLocalizedField\",\n              type: \"text\",\n            },\n            {\n              name: \"simpleNonLocalizedField\",\n              type: \"text\",\n            },\n            // select fields not supported yet\n            {\n              name: \"text\",\n              type: \"select\",\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n\n      expect(getLocalizedFields({ fields })).toEqual([]);\n    });\n\n    it(\"ignore non-localized array field\", () => {\n      const fields: Field[] = [\n        {\n          name: \"simpleLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"simpleNonLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n            },\n            {\n              name: \"text\",\n              type: \"text\",\n            },\n            {\n              name: \"select\",\n              type: \"select\",\n              localized: true,\n              options: [\"one\", \"two\"],\n            },\n          ],\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual([]);\n    });\n\n    it(\"ignore non-localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n      const fields: Field[] = [\n        {\n          label: \"Array fields\",\n          type: \"collapsible\",\n          fields: [\n            {\n              name: \"arrayField\",\n              type: \"array\",\n              fields: [\n                {\n                  name: \"title\",\n                  type: \"richText\",\n                },\n                {\n                  name: \"content\",\n                  type: \"richText\",\n                },\n                {\n                  name: \"select\",\n                  type: \"select\",\n                  options: [\"one\", \"two\"],\n                },\n              ],\n            },\n          ],\n        },\n      ];\n      expect(getLocalizedFields({ fields })).toEqual([]);\n    });\n\n    /**\n     * * help ensure no errors during version 0 development", "     * * mitigate against errors if a new field type is introduced by Payload CMS\n     */\n    it(\"does not include unrecognized field types\", () => {\n      const global: any = {\n        slug: \"global\",\n        fields: [\n          {\n            name: \"textLocalizedField\",\n            type: \"text\",\n          },\n          {\n            name: \"textNonLocalizedField\",\n            type: \"text\",\n          },\n          {\n            name: \"unknownLocalizedField\",\n            type: \"weird\",\n            localized: true,\n          },\n          {\n            name: \"Unknown Field type\",\n            type: \"strange\",\n            fields: [\n              {\n                name: \"textLocalizedFieldInCollapsibleField\",\n                type: \"text\",\n                localized: true,\n              },\n              {\n                name: \"textNonLocalizedFieldInCollapsibleField\",\n                type: \"text\",\n              },\n              // select fields not supported yet\n              {\n                name: \"selectLocalizedFieldInCollapsibleField\",\n                type: \"select\",\n                localized: true,\n                options: [\"one\", \"two\"],\n              },\n            ],\n          },\n        ],\n      };\n      expect(getLocalizedFields({ fields: global.fields })).toEqual([]);\n    });\n\n    /**\n     * blocks not supported yet\n    it (\"includes localized fields from a blocks field\", () => {\n      const TestBlock: Block = {\n        slug: 'text',\n        imageAltText: 'Text',\n        fields: [\n          {\n            name: 'title',\n            type: 'text',\n            localized: true,\n          },\n          {\n            name: 'text',\n            type: 'richText',\n            localized: true,\n          },\n          {\n            name: 'select',\n            type: 'select',\n            localized: true,\n            options: [\n              'one',\n              'two'\n            ]\n          },\n        ]\n      }\n      const TestBlockLocalizedFieldsOnly: Block = {\n        slug: 'text',\n        imageAltText: 'Text',\n        fields: [\n          {\n            name: 'title',\n            type: 'text',\n            localized: true,\n          },\n          {\n            name: 'text',\n            type: 'richText',\n            localized: true,\n          },\n        ]\n      }\n      const global: GlobalConfig = {\n        slug: \"global\",\n        fields: [\n          {\n            name: 'simpleLocalizedField',\n            type: 'text',\n            localized: true,\n          },\n          {\n            name: 'simpleNonLocalizedField',\n            type: 'text',\n          },\n          {\n            name: 'blocksField',\n            type: 'blocks',\n            blocks: [\n              TestBlock\n            ]\n          },\n        ]\n      }\n      const expected = [\n        {\n          name: 'simpleLocalizedField',\n          type: 'text',\n          localized: true,\n        },\n        {\n          name: 'blocksField',\n          type: 'blocks',\n          blocks: [\n            {\n              fields: [\n                {\n                  name: 'title',\n                  type: 'text',\n                  localized: true,\n                },\n                {\n                  name: 'text',\n                  type: 'richText',\n                  localized: true,\n                },\n              ]\n            }\n          ]\n        },\n      ]\n      expect(getLocalizedFields(global.fields)).toEqual(expected)\n    })\n    */\n  });\n\n  /**\n   * @see https://github.com/payloadcms/plugin-seo\n   *\n   * payloadcms/plugin-seo adds localized fields.\n   * If there are no other localized fields, we don't\n   * want to submit to Crowdin.\n   */\n  describe(\"payloadcms/plugin-seo tests\", () => {\n    const seoFields: Field[] = [\n      {\n        name: \"meta\",\n        label: \"SEO\",\n        type: \"group\",\n        fields: [\n          /**{\n            \"name\": \"overview\",\n            \"label\": \"Overview\",\n            \"type\": \"ui\",\n            \"admin\": {\n              \"components\": {}\n            }\n          },*/\n          {\n            name: \"title\",\n            type: \"text\",\n            localized: true,\n            admin: {\n              components: {},\n            },\n          },\n          {\n            name: \"description\",\n            type: \"textarea\",\n            localized: true,\n            admin: {\n              components: {},\n            },\n          },\n          /**{\n            \"name\": \"preview\",\n            \"label\": \"Preview\",\n            \"type\": \"ui\",\n            \"admin\": {\n              \"components\": {}\n            }\n          }**/\n        ],\n      },\n    ];\n\n    it(\"includes payloadcms/plugin-seo localized fields if there are no localized fields on the collection/global\", () => {\n      const nonLocalizedFieldCollection: Field[] = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n        },\n        {\n          name: \"richTextLocalizedField\",\n          type: \"richText\",\n        },\n        {\n          name: \"textareaLocalizedField\",\n          type: \"text\",\n        },\n      ];\n      const fields: Field[] = [...nonLocalizedFieldCollection, ...seoFields];\n      expect(getLocalizedFields({ fields })).toEqual([{\n        \"fields\": [\n          {\n            \"admin\": {\n              \"components\": {},\n            },\n            \"localized\": true,\n            \"name\": \"title\",\n            \"type\": \"text\",\n          },\n          {\n            \"admin\": {\n              \"components\": {},\n            },\n            \"localized\": true,\n            \"name\": \"description\",\n            \"type\": \"textarea\",\n          },\n        ],\n        \"label\": \"SEO\",\n        \"name\": \"meta\",\n        \"type\": \"group\",\n      },]);\n    });\n\n    it(\"includes payloadcms/plugin-seo localized fields if there are localized fields on the collection/global\", () => {\n      const localizedFieldCollection: Field[] = [\n        {\n          name: \"textLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"richTextLocalizedField\",\n          type: \"richText\",\n          localized: true,\n        },\n        {\n          name: \"textareaLocalizedField\",\n          type: \"text\",\n          localized: true,\n        },\n      ];\n      const fields: Field[] = [...localizedFieldCollection, ...seoFields];\n      expect(getLocalizedFields({ fields })).toMatchInlineSnapshot(`\n        [\n          {\n            \"localized\": true,\n            \"name\": \"textLocalizedField\",\n            \"type\": \"text\",\n          },\n          {\n            \"localized\": true,\n            \"name\": \"richTextLocalizedField\",\n            \"type\": \"richText\",\n          },\n          {\n            \"localized\": true,\n            \"name\": \"textareaLocalizedField\",\n            \"type\": \"text\",\n          },\n          {\n            \"fields\": [\n              {\n                \"admin\": {\n                  \"components\": {},\n                },\n                \"localized\": true,\n                \"name\": \"title\",\n                \"type\": \"text\",\n              },\n              {\n                \"admin\": {\n                  \"components\": {},\n                },\n                \"localized\": true,\n                \"name\": \"description\",\n                \"type\": \"textarea\",\n              },\n            ],\n            \"label\": \"SEO\",\n            \"name\": \"meta\",\n            \"type\": \"group\",\n          },\n        ]\n      `);\n    });\n\n    it(\"includes payloadcms/plugin-seo localized fields if there are localized fields within tabs on the collection/global\", () => {\n      const localizedFieldCollection: Field[] = [\n        {\n          type: \"tabs\",\n          tabs: [\n            {\n              label: \"Content\",\n              fields: [\n                {\n                  name: \"unusedField\",\n                  type: \"text\",\n                  localized: true,\n                  admin: {\n                    description:\n                      \"This field is not used, it has been added to activate CrowdIn localization for SEO fields. It will be removed in a future release.\",\n                  },\n                  label: \"Unused Field\",\n                  hooks: {},\n                  access: {},\n                },\n                {\n                  type: \"collapsible\",\n                  label: \"Hero\",\n                  admin: {\n                    initCollapsed: true,\n                  },\n                  fields: [\n                    {\n                      name: \"hero\",\n                      type: \"group\",\n                      localized: true,\n                      fields: [\n                        {\n                          name: \"title\",\n                          type: \"richText\",\n                          admin: {\n                            elements: [],\n                            leaves: [\"bold\"],\n                          },\n                          label: \"Title\",\n                          hooks: {},\n                          access: {},\n                        },\n                        {\n                          name: \"text\",\n                          type: \"richText\",\n                          admin: {\n                            elements: [],\n                            leaves: [\"bold\"],\n                          },\n                          label: \"Text\",\n                          hooks: {},\n                          access: {},\n                        },\n                      ],\n                      label: \"Hero\",\n                      hooks: {},\n                      access: {},\n                      admin: {},\n                    },\n                  ],\n                },\n                {\n                  type: \"collapsible\",\n                  label: \"Promo\",\n                  admin: {\n                    initCollapsed: true,\n                  },\n                  fields: [\n                    {\n                      name: \"promo\",\n                      type: \"relationship\",\n                      relationTo: \"promos\",\n                      hasMany: false,\n                      label: \"Promo\",\n                      hooks: {},\n                      access: {},\n                      admin: {},\n                    },\n                  ],\n                },\n              ],\n            },\n            {\n              label: \"SEO\",\n              fields: [\n                {\n                  name: \"meta\",\n                  label: \"SEO\",\n                  type: \"group\",\n                  fields: [\n                    {\n                      name: \"title\",\n                      type: \"text\",\n                      localized: true,\n                      admin: {\n                        components: {},\n                      },\n                      label: \"Title\",\n                      hooks: {},\n                      access: {},\n                    },\n                    {\n                      name: \"description\",\n                      type: \"textarea\",\n                      localized: true,\n                      admin: {\n                        components: {},\n                      },\n                      label: \"Description\",\n                      hooks: {},\n                      access: {},\n                    },\n                    {\n                      name: \"image\",\n                      label: \"Meta Image\",\n                      type: \"upload\",\n                      localized: true,\n                      relationTo: \"share-images\",\n                      admin: {\n                        description:\n                          \"Maximum upload file size: 12MB. Recommended file size for images is <500KB.\",\n                        components: {},\n                      },\n                      hooks: {},\n                      access: {},\n                    },\n                  ],\n                  hooks: {},\n                  access: {},\n                  admin: {},\n                },\n              ],\n            },\n          ],\n          admin: {},\n        },\n        {\n          name: \"crowdinArticleDirectory\",\n          type: \"relationship\",\n          relationTo: \"crowdin-article-directories\",\n          hasMany: false,\n          label: \"Crowdin Article Directory\",\n          hooks: {},\n          access: {},\n          admin: {},\n        },\n        {\n          name: \"_status\",\n          label: {\n            ar: \"\u0627\u0644\u062d\u0627\u0644\u0629\",\n            az: \"Status\",\n            bg: \"\u0421\u0442\u0430\u0442\u0443\u0441\",\n            cs: \"Stav\",\n            de: \"Status\",\n            en: \"Status\",\n            es: \"Estado\",\n            fa: \"\u0648\u0636\u0639\u06cc\u062a\",\n            fr: \"Statut\",\n            hr: \"Status\",\n            hu: \"\u00c1llapot\",\n            it: \"Stato\",\n            ja: \"\u30b9\u30c6\u30fc\u30bf\u30b9\",\n            my: \"\u1021\u1001\u103c\u1031\u1021\u1014\u1031\",\n            nb: \"Status\",\n            nl: \"Status\",\n            pl: \"Status\",\n            pt: \"Status\",\n            ro: \"Status\",\n            ru: \"\u0421\u0442\u0430\u0442\u0443\u0441\",\n            sv: \"Status\",\n            th: \"\u0e2a\u0e16\u0e32\u0e19\u0e30\",\n            tr: \"Durum\",\n            ua: \"\u0421\u0442\u0430\u0442\u0443\u0441\",\n            vi: \"Tr\u1ea1ng th\u00e1i\",\n            zh: \"\u72b6\u6001\",\n          },\n          type: \"select\",\n          options: [\n            {\n              label: {\n                ar: \"\u0645\u0633\u0648\u062f\u0629\",\n                az: \"Qaralama\",\n                bg: \"\u0427\u0435\u0440\u043d\u043e\u0432\u0430\",\n                cs: \"Koncept\",\n                de: \"Entwurf\",\n                en: \"Draft\",\n                es: \"Borrador\",\n                fa: \"\u067e\u06cc\u0634\u200c\u0646\u0648\u06cc\u0633\",\n                fr: \"Brouillon\",\n                hr: \"Nacrt\",\n                hu: \"Piszkozat\",\n                it: \"Bozza\",\n                ja: \"\u30c9\u30e9\u30d5\u30c8\",\n                my: \"\u1019\u1030\u1000\u103c\u1019\u103a\u1038\",\n                nb: \"Utkast\",\n                nl: \"Concept\",\n                pl: \"Szkic\",\n                pt: \"Rascunho\",\n                ro: \"Proiect\",\n                ru: \"\u0427\u0435\u0440\u043d\u043e\u0432\u0438\u043a\",\n                sv: \"Utkast\",\n                th: \"\u0e09\u0e1a\u0e31\u0e1a\u0e23\u0e48\u0e32\u0e07\",\n                tr: \"Taslak\",\n                ua: \"\u0427\u0435\u0440\u043d\u0435\u0442\u043a\u0430\",\n                vi: \"B\u1ea3n nh\u00e1p\",\n                zh: \"\u8349\u7a3f\",\n              },\n              value: \"draft\",\n            },\n            {\n              label: {\n                ar: \"\u062a\u0645 \u0627\u0644\u0646\u0634\u0631\",\n                az: \"D\u0259rc edilmi\u015f\",\n                bg: \"\u041f\u0443\u0431\u043b\u0438\u043a\u0443\u0432\u0430\u043d\u043e\",\n                cs: \"Publikov\u00e1no\",\n                de: \"Ver\u00f6ffentlicht\",\n                en: \"Published\",\n                es: \"Publicado\",\n                fa: \"\u0627\u0646\u062a\u0634\u0627\u0631 \u06cc\u0627\u0641\u062a\u0647\",\n                fr: \"Publi\u00e9\",\n                hr: \"Objavljeno\",\n                hu: \"K\u00f6zz\u00e9tett\",\n                it: \"Pubblicato\",\n                ja: \"\u516c\u958b\u6e08\u307f\",\n                my: \"\u1010\u1004\u103a\u1015\u103c\u102e\u1038\u1015\u103c\u102e\u104b\",\n                nb: \"Publisert\",\n                nl: \"Gepubliceerd\",\n                pl: \"Opublikowano\",\n                pt: \"Publicado\",\n                ro: \"Publicat\",\n                ru: \"\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e\",\n                sv: \"Publicerad\",\n                th: \"\u0e40\u0e1c\u0e22\u0e41\u0e1e\u0e23\u0e48\u0e41\u0e25\u0e49\u0e27\",\n                tr: \"Yay\u0131nland\u0131\",\n                ua: \"\u041e\u043f\u0443\u0431\u043b\u0456\u043a\u043e\u0432\u0430\u043d\u043e\",\n                vi: \"\u0110\u00e3 xu\u1ea5t b\u1ea3n\",\n                zh: \"\u5df2\u53d1\u5e03\",\n              },\n              value: \"published\",\n            },\n          ],\n          defaultValue: \"draft\",\n          admin: {\n            disableBulkEdit: true,\n            components: {},\n          },\n          hooks: {},\n          access: {},\n        },\n        {\n          name: \"updatedAt\",\n          label: \"Updated At\",\n          type: \"date\",\n          admin: {\n            hidden: true,\n            disableBulkEdit: true,\n          },\n          hooks: {},\n          access: {},\n        },\n        {\n          name: \"createdAt\",\n          label: \"Created At\",\n          type: \"date\",\n          admin: {\n            hidden: true,\n            disableBulkEdit: true,\n          },\n          hooks: {},\n          access: {},\n        },\n      ];\n      const fields: Field[] = localizedFieldCollection;\n      expect(getLocalizedFields({ fields })).toMatchInlineSnapshot(`\n        [\n          {\n            \"access\": {},\n            \"admin\": {\n              \"description\": \"This field is not used, it has been added to activate CrowdIn localization for SEO fields. It will be removed in a future release.\",\n            },\n            \"hooks\": {},\n            \"label\": \"Unused Field\",\n            \"localized\": true,\n            \"name\": \"unusedField\",\n            \"type\": \"text\",\n          },\n          {\n            \"access\": {},\n            \"admin\": {},\n            \"fields\": [\n              {\n                \"access\": {},\n                \"admin\": {\n                  \"elements\": [],\n                  \"leaves\": [\n                    \"bold\",\n                  ],\n                },\n                \"hooks\": {},\n                \"label\": \"Title\",\n                \"name\": \"title\",\n                \"type\": \"richText\",\n              },\n              {\n                \"access\": {},\n                \"admin\": {\n                  \"elements\": [],\n                  \"leaves\": [\n                    \"bold\",\n                  ],\n                },\n                \"hooks\": {},\n                \"label\": \"Text\",\n                \"name\": \"text\",\n                \"type\": \"richText\",\n              },\n            ],\n            \"hooks\": {},\n            \"label\": \"Hero\",\n            \"localized\": true,\n            \"name\": \"hero\",\n            \"type\": \"group\",\n          },\n          {\n            \"access\": {},\n            \"admin\": {},\n            \"fields\": [\n              {\n                \"access\": {},\n                \"admin\": {\n                  \"components\": {},\n                },\n                \"hooks\": {},\n                \"label\": \"Title\",\n                \"localized\": true,\n                \"name\": \"title\",\n                \"type\": \"text\",\n              },\n              {\n                \"access\": {},\n                \"admin\": {\n                  \"components\": {},\n                },\n                \"hooks\": {},\n                \"label\": \"Description\",\n                \"localized\": true,\n                \"name\": \"description\",\n                \"type\": \"textarea\",\n              },\n            ],\n            \"hooks\": {},\n            \"label\": \"SEO\",\n            \"name\": \"meta\",\n            \"type\": \"group\",\n          },\n        ]\n      `);\n    });\n  });\n});\n"]}
{"filename": "src/utilities/tests/fixtures/basic-localized-fields.fixture.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\nexport const basicNonLocalizedFields: Field[] = [\n  {\n    name: \"textField\",\n    type: \"text\",\n  },\n  {\n    name: \"textareaField\",\n    type: \"textarea\",", "    name: \"textareaField\",\n    type: \"textarea\",\n  },\n  // select not supported: included to ensure it does not send to Crowdin\n  {\n    name: \"select\",\n    type: \"select\",\n    options: [\"one\", \"two\"],\n  },\n  // image not supported: included to ensure it does send to Crowdin", "  },\n  // image not supported: included to ensure it does send to Crowdin\n  {\n    name: \"image\",\n    type: \"upload\",\n    relationTo: \"media\",\n  },\n];\n\nexport const basicLocalizedFields: Field[] = [", "\nexport const basicLocalizedFields: Field[] = [\n  {\n    name: \"textField\",\n    type: \"text\",\n    localized: true,\n  },\n  {\n    name: \"textareaField\",\n    type: \"textarea\",", "    name: \"textareaField\",\n    type: \"textarea\",\n    localized: true,\n  },\n  // select not supported: included to ensure it does not send to Crowdin\n  {\n    name: \"select\",\n    type: \"select\",\n    localized: true,\n    options: [\"one\", \"two\"],", "    localized: true,\n    options: [\"one\", \"two\"],\n  },\n  // image not supported: included to ensure it does send to Crowdin\n  {\n    name: \"image\",\n    type: \"upload\",\n    relationTo: \"media\",\n    localized: true,\n  },", "    localized: true,\n  },\n];\n\nexport const emptyFieldDocValue = {\n  textField: \"\",\n  textareaField: \"\",\n  select: \"one\",\n  image: \"63ea51826ff825cddad3c296\",\n};", "  image: \"63ea51826ff825cddad3c296\",\n};\n\nexport const fieldDocValue = {\n  textField: \"Text field content\",\n  textareaField: \"A textarea field value.\\nWith a new line.\",\n  select: \"one\",\n  image: \"63ea51826ff825cddad3c296\",\n};\n", "};\n\nexport const fieldJsonCrowdinObject = (prefix?: string) => {\n  const value = {\n    textField: \"Text field content\",\n    textareaField: \"A textarea field value.\\nWith a new line.\",\n  };\n  if (prefix) {\n    var tgt = {};\n    dot.str(prefix, value, tgt);\n    return tgt;\n  }\n  return value;\n};\n"]}
{"filename": "src/utilities/tests/fixtures/blocks-field-type.fixture.ts", "chunked_list": ["import { Block, Field } from \"payload/types\";\nimport { basicLocalizedFields } from \"./basic-localized-fields.fixture\";\nimport dot from \"dot-object\";\n\nconst BasicBlockTextFields: Block = {\n  slug: \"basicBlock\", // required\n  fields: basicLocalizedFields,\n};\n\nconst BasicBlockRichTextField: Block = {", "\nconst BasicBlockRichTextField: Block = {\n  slug: \"basicBlockRichText\", // required\n  fields: [\n    {\n      name: \"richTextField\",\n      type: \"richText\",\n      localized: true,\n    },\n  ],", "    },\n  ],\n};\n\nconst BasicBlockMixedFields: Block = {\n  slug: \"basicBlockMixed\", // required\n  fields: [\n    ...basicLocalizedFields,\n    {\n      name: \"richTextField\",", "    {\n      name: \"richTextField\",\n      type: \"richText\",\n      localized: true,\n    },\n  ],\n};\n\nexport const field: Field = {\n  name: \"blocksField\",", "export const field: Field = {\n  name: \"blocksField\",\n  type: \"blocks\",\n  blocks: [\n    BasicBlockTextFields,\n    BasicBlockRichTextField,\n    BasicBlockMixedFields,\n  ],\n};\n", "};\n\nexport const fieldDocValue = [\n  {\n    textField: \"Text field content in basicBlock at layout index 0\",\n    textareaField: \"Textarea field content in basicBlock at layout index 0\",\n    id: \"63ea42b06ff825cddad3c133\",\n    blockType: \"basicBlock\",\n  },\n  {", "  },\n  {\n    richTextField: [\n      {\n        type: \"h1\",\n        children: [\n          {\n            text: \"Rich text content in \",\n          },\n          {", "          },\n          {\n            text: \"basicBlockRichText\",\n            bold: true,\n          },\n          {\n            text: \" layout at index 1.\",\n          },\n        ],\n      },", "        ],\n      },\n      {\n        children: [\n          {\n            text: \"An extra paragraph for good measure.\",\n          },\n        ],\n      },\n    ],", "      },\n    ],\n    id: \"63d169d3d9dfd46d37c649e4\",\n    blockType: \"basicBlockRichText\",\n  },\n  {\n    textField: \"Text field content in basicBlock at layout index 2\",\n    textareaField: \"Textarea field content in basicBlock at layout index 2\",\n    id: \"63ea373fb725d8a50646952e\",\n    blockType: \"basicBlock\",", "    id: \"63ea373fb725d8a50646952e\",\n    blockType: \"basicBlock\",\n  },\n  {\n    richTextField: [\n      {\n        children: [\n          {\n            text: \"Rich text content in basicBlockRichText layout at index 3.\",\n          },", "            text: \"Rich text content in basicBlockRichText layout at index 3.\",\n          },\n        ],\n      },\n    ],\n    id: \"63ea3e7fb725d8a50646956a\",\n    blockType: \"basicBlockRichText\",\n  },\n  {\n    textField: \"Text field content in basicBlockMixed at layout index 4\",", "  {\n    textField: \"Text field content in basicBlockMixed at layout index 4\",\n    textareaField:\n      \"Textarea field content in basicBlockMixed at layout index 4\",\n    richTextField: [\n      {\n        children: [\n          {\n            text: \"Rich text content in basicBlockMixed layout at index 4.\",\n          },", "            text: \"Rich text content in basicBlockMixed layout at index 4.\",\n          },\n        ],\n      },\n    ],\n    id: \"63ea40106ff825cddad3c10b\",\n    blockType: \"basicBlockMixed\",\n  },\n];\n", "];\n\nexport const fieldJsonCrowdinObject = (prefix?: string) => {\n  const value = {\n    blocksField: {\n      \"63ea42b06ff825cddad3c133\": {\n        basicBlock: {\n          textField: \"Text field content in basicBlock at layout index 0\",\n          textareaField:\n            \"Textarea field content in basicBlock at layout index 0\",", "          textareaField:\n            \"Textarea field content in basicBlock at layout index 0\",\n        },\n      },\n      \"63ea373fb725d8a50646952e\": {\n        basicBlock: {\n          textField: \"Text field content in basicBlock at layout index 2\",\n          textareaField:\n            \"Textarea field content in basicBlock at layout index 2\",\n        },", "            \"Textarea field content in basicBlock at layout index 2\",\n        },\n      },\n\n      \"63ea40106ff825cddad3c10b\": {\n        basicBlockMixed: {\n          textField: \"Text field content in basicBlockMixed at layout index 4\",\n          textareaField:\n            \"Textarea field content in basicBlockMixed at layout index 4\",\n        },", "            \"Textarea field content in basicBlockMixed at layout index 4\",\n        },\n      },\n    },\n  };\n  if (prefix) {\n    var tgt = {};\n    dot.str(prefix, value, tgt);\n    return tgt;\n  }\n  return value;\n};\n\nexport const fieldHtmlCrowdinObject = (prefix?: string) => ({\n  [`${\n    prefix || \"\"\n  }blocksField.63d169d3d9dfd46d37c649e4.basicBlockRichText.richTextField`]: [\n    {\n      type: \"h1\",\n      children: [\n        {\n          text: \"Rich text content in \",\n        },\n        {\n          text: \"basicBlockRichText\",\n          bold: true,\n        },\n        {\n          text: \" layout at index 1.\",\n        },\n      ],\n    },\n    {\n      children: [\n        {\n          text: \"An extra paragraph for good measure.\",\n        },\n      ],\n    },\n  ],\n  [`${\n    prefix || \"\"\n  }blocksField.63ea3e7fb725d8a50646956a.basicBlockRichText.richTextField`]: [\n    {\n      children: [\n        {\n          text: \"Rich text content in basicBlockRichText layout at index 3.\",\n        },\n      ],\n    },\n  ],\n  [`${\n    prefix || \"\"\n  }blocksField.63ea40106ff825cddad3c10b.basicBlockMixed.richTextField`]: [\n    {\n      children: [\n        {\n          text: \"Rich text content in basicBlockMixed layout at index 4.\",\n        },\n      ],\n    },\n  ],\n});\n"]}
{"filename": "src/utilities/tests/buildPayloadUpdateObject/blocks-field-type.spec.ts", "chunked_list": ["import { Block, Field } from \"payload/types\";\nimport {\n  buildCrowdinJsonObject,\n  buildPayloadUpdateObject,\n  getLocalizedFields,\n} from \"../..\";\nimport { FieldWithName } from \"../../../types\";\n\nconst TestBlockOne: Block = {\n  slug: \"testBlockOne\",", "const TestBlockOne: Block = {\n  slug: \"testBlockOne\",\n  fields: [\n    {\n      name: \"title\",\n      type: \"text\",\n      localized: true,\n    },\n    {\n      name: \"text\",", "    {\n      name: \"text\",\n      type: \"text\",\n      localized: true,\n    },\n    {\n      name: \"select\",\n      type: \"select\",\n      localized: true,\n      options: [\"one\", \"two\"],", "      localized: true,\n      options: [\"one\", \"two\"],\n    },\n  ],\n};\n\nconst TestBlockTwo: Block = {\n  slug: \"testBlockTwo\",\n  fields: [\n    {", "  fields: [\n    {\n      name: \"url\",\n      type: \"text\",\n      localized: true,\n    },\n  ],\n};\n\nconst TestBlockTwoNonLocalized: Block = {", "\nconst TestBlockTwoNonLocalized: Block = {\n  slug: \"testBlockTwo\",\n  fields: [\n    {\n      name: \"url\",\n      type: \"text\",\n    },\n  ],\n};", "  ],\n};\n\ndescribe(\"fn: buildPayloadUpdateObject: blocks field type\", () => {\n  it(\"includes localized fields nested in blocks\", () => {\n    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",\n      blocksField: {\n        \"64735620230d57bce946d370\": {\n          testBlockOne: {", "        \"64735620230d57bce946d370\": {\n          testBlockOne: {\n            title: \"Block field title content one\",\n            text: \"Block field text content one\",\n          },\n        },\n        \"64735621230d57bce946d371\": {\n          testBlockTwo: {\n            url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          },", "            url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          },\n        },\n      },\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,", "        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },", "        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockOne, TestBlockTwo],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {", "    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          title: \"Block field title content one\",\n          text: \"Block field text content one\",\n          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",\n        },", "          blockType: \"testBlockOne\",\n        },\n        {\n          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          id: \"64735621230d57bce946d371\",\n          blockType: \"testBlockTwo\",\n        },\n      ],\n    };\n    expect(", "    };\n    expect(\n      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n    ).toEqual(expected);\n  });\n\n  it(\"excludes block with no localized fields\", () => {\n    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",\n      blocksField: {", "      title: \"Test Policy created with title\",\n      blocksField: {\n        \"64735620230d57bce946d370\": {\n          testBlockOne: {\n            title: \"Block field title content one\",\n            text: \"Block field text content one\",\n          },\n        },\n      },\n    };", "      },\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {", "      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",", "        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {", "      blocksField: [\n        {\n          title: \"Block field title content one\",\n          text: \"Block field text content one\",\n          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",\n        },\n      ],\n    };\n    expect(", "    };\n    expect(\n      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n    ).toEqual(expected);\n  });\n\n  it(\"excludes block with no localized fields - more blocks\", () => {\n    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",\n      blocksField: {", "      title: \"Test Policy created with title\",\n      blocksField: {\n        \"64735620230d57bce946d370\": {\n          testBlockOne: {\n            title: \"Block field title content one\",\n            text: \"Block field text content one\",\n          },\n        },\n        \"64a535cdf1eaa5498709c906\": {\n          testBlockOne: {", "        \"64a535cdf1eaa5498709c906\": {\n          testBlockOne: {\n            title: \"Block field title content two\",\n            text: \"Block field text content two\",\n          },\n        },\n      },\n    };\n    const fields: FieldWithName[] = [\n      {", "    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",", "        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n      },", "        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          title: \"Block field title content one\",\n          text: \"Block field text content one\",", "          title: \"Block field title content one\",\n          text: \"Block field text content one\",\n          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",\n        },\n        {\n          title: \"Block field title content two\",\n          text: \"Block field text content two\",\n          id: \"64a535cdf1eaa5498709c906\",\n          blockType: \"testBlockOne\",", "          id: \"64a535cdf1eaa5498709c906\",\n          blockType: \"testBlockOne\",\n        },\n      ],\n    };\n    expect(\n      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n    ).toEqual(expected);\n  });\n", "  });\n\n  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file\", () => {\n    const TestBlockArrayOfRichText: Block = {\n      slug: \"testBlockArrayOfRichText\",\n      fields: [\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [", "          type: \"array\",\n          fields: [\n            {\n              name: \"richText\",\n              type: \"richText\",\n              localized: true,\n            },\n          ],\n        },\n      ],", "        },\n      ],\n    };\n\n    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",", "      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,", "        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockArrayOfRichText],\n      },\n    ];", "      },\n    ];\n    const localizedFields = getLocalizedFields({ fields, type: \"json\" });\n    const expected = {\n      title: \"Test Policy created with title\",\n    };\n    expect(\n      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n    ).toEqual(expected);\n  });", "    ).toEqual(expected);\n  });\n\n  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file 2\", () => {\n    const TestBlockArrayOfRichText: Block = {\n      slug: \"testBlockArrayOfRichText\",\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",", "          name: \"title\",\n          type: \"text\",\n          localized: true,\n        },\n        {\n          name: \"messages\",\n          type: \"array\",\n          localized: true,\n          maxRows: 3,\n          fields: [", "          maxRows: 3,\n          fields: [\n            {\n              name: \"title\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"message\",\n              type: \"richText\",", "              name: \"message\",\n              type: \"richText\",\n            },\n          ],\n        },\n      ],\n    };\n\n    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",", "    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",\n      blocksField: {\n        \"649cd1ecbac7445191be36af\": {\n          testBlockArrayOfRichText: {\n            messages: {\n              \"64735620230d57bce946d370\": {\n                title: \"Test title 1\",\n              },\n              \"64735621230d57bce946d371\": {", "              },\n              \"64735621230d57bce946d371\": {\n                title: \"Test title 2\",\n              },\n            },\n          },\n        },\n      },\n    };\n    const fields: FieldWithName[] = [", "    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",", "      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockArrayOfRichText],", "        type: \"blocks\",\n        blocks: [TestBlockArrayOfRichText],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          messages: [", "        {\n          messages: [\n            {\n              title: \"Test title 1\",\n              id: \"64735620230d57bce946d370\",\n            },\n            {\n              title: \"Test title 2\",\n              id: \"64735621230d57bce946d371\",\n            },", "              id: \"64735621230d57bce946d371\",\n            },\n          ],\n          id: \"649cd1ecbac7445191be36af\",\n          blockType: \"testBlockArrayOfRichText\",\n        },\n      ],\n    };\n    expect(\n      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })", "    expect(\n      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n    ).toEqual(expected);\n  });\n});\n"]}
{"filename": "src/utilities/tests/buildPayloadUpdateObject/add-rich-text-fields.spec.ts", "chunked_list": ["import { Block, Field } from \"payload/types\";\nimport {\n  buildCrowdinJsonObject,\n  buildPayloadUpdateObject,\n  getLocalizedFields,\n  restoreOrder,\n} from \"../..\";\nimport { FieldWithName } from \"../../../types\";\nimport {\n  field,", "import {\n  field,\n  fieldHtmlCrowdinObject,\n  fieldJsonCrowdinObject,\n  fieldDocValue,\n} from \"../fixtures/blocks-field-type.fixture\";\nimport dot from \"dot-object\";\n\ndescribe(\"fn: buildPayloadUpdateObject: blocks field type\", () => {\n  it(\"includes localized fields\", () => {", "describe(\"fn: buildPayloadUpdateObject: blocks field type\", () => {\n  it(\"includes localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {", "      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      field,\n    ];\n    const crowdinJsonObject = {", "    ];\n    const crowdinJsonObject = {\n      title: \"Test Policy created with title\",\n      ...fieldJsonCrowdinObject(),\n    };\n    const crowdinHtmlObject = fieldHtmlCrowdinObject();\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,\n    };", "      blocksField: fieldDocValue,\n    };\n\n    expect(\n      buildPayloadUpdateObject({\n        crowdinJsonObject,\n        crowdinHtmlObject,\n        fields,\n        document: doc,\n      })", "        document: doc,\n      })\n    ).toEqual(expected);\n  });\n});\n"]}
{"filename": "src/utilities/tests/getLocalizedFields/tabs-field-type.spec.ts", "chunked_list": ["import { Field } from \"payload/types\";\nimport { getLocalizedFields } from \"./../../\";\nimport { basicLocalizedFields } from \"../fixtures/basic-localized-fields.fixture\";\n\ndescribe(\"presentation only tab fields\", () => {\n  it(\"returns an empty array if no localized fields in tabs\", () => {\n    // fixture from https://payloadcms.com/docs/fields/tabs\n    const fields: Field[] = [\n      {\n        type: \"tabs\", // required", "      {\n        type: \"tabs\", // required\n        tabs: [\n          // required\n          {\n            label: \"Tab One Label\", // required\n            description: \"This will appear within the tab above the fields.\",\n            fields: [\n              // required\n              {", "              // required\n              {\n                name: \"someTextField\",\n                type: \"text\",\n                required: true,\n              },\n            ],\n          },\n          {\n            name: \"tabTwo\",", "          {\n            name: \"tabTwo\",\n            label: \"Tab Two Label\", // required\n            interfaceName: \"TabTwo\", // optional (`name` must be present)\n            fields: [\n              // required\n              {\n                name: \"numberField\", // accessible via tabTwo.numberField\n                type: \"number\",\n                required: true,", "                type: \"number\",\n                required: true,\n              },\n            ],\n          },\n        ],\n      },\n    ];\n\n    expect(getLocalizedFields({ fields })).toEqual([]);", "\n    expect(getLocalizedFields({ fields })).toEqual([]);\n  });\n\n  it(\"returns localized fields in tabs\", () => {\n    // fixture from https://payloadcms.com/docs/fields/tabs\n    const fields: Field[] = [\n      {\n        type: \"tabs\", // required\n        tabs: [", "        type: \"tabs\", // required\n        tabs: [\n          // required\n          {\n            label: \"Tab One Label\", // required\n            description: \"This will appear within the tab above the fields.\",\n            fields: [\n              // required\n              {\n                name: \"someTextField\",", "              {\n                name: \"someTextField\",\n                type: \"text\",\n                required: true,\n                localized: true,\n              },\n            ],\n          },\n          {\n            name: \"tabTwo\",", "          {\n            name: \"tabTwo\",\n            label: \"Tab Two Label\", // required\n            interfaceName: \"TabTwo\", // optional (`name` must be present)\n            fields: [\n              // required\n              {\n                name: \"numberField\", // accessible via tabTwo.numberField\n                type: \"number\",\n                required: true,", "                type: \"number\",\n                required: true,\n                localized: true,\n              },\n            ],\n          },\n        ],\n      },\n    ];\n", "    ];\n\n    expect(getLocalizedFields({ fields })).toEqual([\n      {\n        localized: true,\n        name: \"someTextField\",\n        required: true,\n        type: \"text\",\n      },\n    ]);", "      },\n    ]);\n  });\n\n  it(\"returns localized fields in tab respecting tab names\", () => {\n    // fixture from https://payloadcms.com/docs/fields/tabs\n    const fields: Field[] = [\n      {\n        type: \"tabs\", // required\n        tabs: [", "        type: \"tabs\", // required\n        tabs: [\n          // required\n          {\n            label: \"Tab One Label\", // required\n            description: \"This will appear within the tab above the fields.\",\n            fields: basicLocalizedFields,\n          },\n          {\n            name: \"tabTwo\",", "          {\n            name: \"tabTwo\",\n            label: \"Tab Two Label\", // required\n            interfaceName: \"TabTwo\", // optional (`name` must be present)\n            fields: basicLocalizedFields,\n          },\n        ],\n      },\n    ];\n", "    ];\n\n    expect(getLocalizedFields({ fields })).toEqual([\n      {\n        fields: [\n          {\n            name: \"textField\",\n            type: \"text\",\n            localized: true,\n          },", "            localized: true,\n          },\n          {\n            name: \"textareaField\",\n            type: \"textarea\",\n            localized: true,\n          },\n        ],\n        name: \"tabTwo\",\n        type: \"group\",", "        name: \"tabTwo\",\n        type: \"group\",\n      },\n      {\n        name: \"textField\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"textareaField\",", "      {\n        name: \"textareaField\",\n        type: \"textarea\",\n        localized: true,\n      },\n    ]);\n  });\n\n  it(\"returns localized fields in tab respecting tab names with other fields\", () => {\n    // fixture from https://payloadcms.com/docs/fields/tabs", "  it(\"returns localized fields in tab respecting tab names with other fields\", () => {\n    // fixture from https://payloadcms.com/docs/fields/tabs\n    const fields: Field[] = [\n      {\n        name: \"textFieldExtra\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"textareaFieldExtra\",", "      {\n        name: \"textareaFieldExtra\",\n        type: \"textarea\",\n        localized: true,\n      },\n      {\n        type: \"tabs\", // required\n        tabs: [\n          // required\n          {", "          // required\n          {\n            label: \"Tab One Label\", // required\n            description: \"This will appear within the tab above the fields.\",\n            fields: basicLocalizedFields,\n          },\n          {\n            name: \"tabTwo\",\n            label: \"Tab Two Label\", // required\n            interfaceName: \"TabTwo\", // optional (`name` must be present)", "            label: \"Tab Two Label\", // required\n            interfaceName: \"TabTwo\", // optional (`name` must be present)\n            fields: basicLocalizedFields,\n          },\n        ],\n      },\n    ];\n\n    expect(getLocalizedFields({ fields })).toEqual([\n      {", "    expect(getLocalizedFields({ fields })).toEqual([\n      {\n        name: \"textFieldExtra\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"textareaFieldExtra\",\n        type: \"textarea\",\n        localized: true,", "        type: \"textarea\",\n        localized: true,\n      },\n      {\n        fields: [\n          {\n            name: \"textField\",\n            type: \"text\",\n            localized: true,\n          },", "            localized: true,\n          },\n          {\n            name: \"textareaField\",\n            type: \"textarea\",\n            localized: true,\n          },\n        ],\n        name: \"tabTwo\",\n        type: \"group\",", "        name: \"tabTwo\",\n        type: \"group\",\n      },\n      {\n        name: \"textField\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"textareaField\",", "      {\n        name: \"textareaField\",\n        type: \"textarea\",\n        localized: true,\n      },\n    ]);\n  });\n});\n", ""]}
{"filename": "src/utilities/tests/inline-snapshots/book-demo.test.ts", "chunked_list": ["import BookDemo from \"./collections/BookDemo\";\nimport {\n  buildCrowdinJsonObject,\n  buildCrowdinHtmlObject,\n  buildPayloadUpdateObject,\n  getLocalizedFields,\n} from \"../..\";\n\ndescribe(\"book demo collection snapshots\", () => {\n  const doc = {", "describe(\"book demo collection snapshots\", () => {\n  const doc = {\n    hero: {\n      title: [\n        {\n          type: \"p\",\n          children: [\n            {\n              text: \"R\u00e9servez une d\u00e9mo\",\n            },", "              text: \"R\u00e9servez une d\u00e9mo\",\n            },\n          ],\n        },\n      ],\n      text: [\n        {\n          type: \"p\",\n          children: [\n            {", "          children: [\n            {\n              text: \"Apprenez comment Acme Corp peut vous aider \u00e0 \",\n            },\n            {\n              text: \"atteindre vos objectifs\",\n              bold: true,\n            },\n            {\n              text: \". Nous sommes pr\u00eats \u00e0 parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n\u2019est pas le cas, on vous offre un cupcake ! \ud83d\ude09\",", "            {\n              text: \". Nous sommes pr\u00eats \u00e0 parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n\u2019est pas le cas, on vous offre un cupcake ! \ud83d\ude09\",\n            },\n          ],\n        },\n      ],\n    },\n    form: {\n      title: \"R\u00e9servez une d\u00e9mo\",\n      subTitle:", "      title: \"R\u00e9servez une d\u00e9mo\",\n      subTitle:\n        \"Nous vous contacterons d\u00e8s que possible pour fixer une heure qui vous convienne.\",\n      content: {\n        title: \"\",\n        items: [\n          {\n            text: \"\",\n            id: \"64a8af5656f68b0022bfd267\",\n          },", "            id: \"64a8af5656f68b0022bfd267\",\n          },\n          {\n            text: \"Offres d'emploi et utilisateurs illimit\u00e9s\",\n            id: \"64a8af5656f68b0022bfd268\",\n          },\n          {\n            text: \"\",\n            id: \"64a8af5656f68b0022bfd269\",\n          },", "            id: \"64a8af5656f68b0022bfd269\",\n          },\n          {\n            text: \"\",\n            id: \"64a8af5656f68b0022bfd26a\",\n          },\n          {\n            text: \"\",\n            id: \"64a8af5656f68b0022bfd26b\",\n          },", "            id: \"64a8af5656f68b0022bfd26b\",\n          },\n          {\n            text: \"Des pr\u00e9sentations produits et des webinaires gratuits\",\n            id: \"64a8af5656f68b0022bfd26c\",\n          },\n          {\n            text: \"Un acc\u00e8s complet \u00e0 l'Acad\u00e9mie Acme Corp\",\n            id: \"64a8af5656f68b0022bfd26d\",\n          },", "            id: \"64a8af5656f68b0022bfd26d\",\n          },\n        ],\n      },\n    },\n    logoTitle: \"Ador\u00e9 par les meilleurs recruteurs internationaux\",\n    promo: \"6474f51370b180880beb4bcb\",\n    meta: {\n      title: \"R\u00e9servez une d\u00e9mo | Acme Corp\",\n      description:", "      title: \"R\u00e9servez une d\u00e9mo | Acme Corp\",\n      description:\n        \"Book a demo of Acme Corp Widget and let our team show you the magic of our product! Schedule a call with one of team members here.\",\n    },\n    crowdinArticleDirectory: \"6486e2a7715834a0e4b7cea4\",\n    _status: \"published\",\n    globalType: \"book-demo\",\n    createdAt: \"2023-06-12T07:43:55.361Z\",\n    updatedAt: \"2023-07-25T09:43:57.619Z\",\n    id: \"6486ccbb27a4f59700b066ec\",", "    updatedAt: \"2023-07-25T09:43:57.619Z\",\n    id: \"6486ccbb27a4f59700b066ec\",\n  };\n  const fields = BookDemo.fields;\n  const localizedFields = getLocalizedFields({ fields });\n  const crowdinJsonObject = buildCrowdinJsonObject({\n    doc,\n    fields: localizedFields,\n  });\n  const crowdinHtmlObject = buildCrowdinHtmlObject({", "  });\n  const crowdinHtmlObject = buildCrowdinHtmlObject({\n    doc,\n    fields: localizedFields,\n  });\n\n  it(\"getLocalizedFields\", () => {\n    expect(getLocalizedFields({ fields })).toMatchInlineSnapshot(`\n      [\n        {", "      [\n        {\n          \"localized\": true,\n          \"name\": \"logoTitle\",\n          \"required\": true,\n          \"type\": \"text\",\n        },\n        {\n          \"fields\": [\n            {", "          \"fields\": [\n            {\n              \"admin\": {\n                \"elements\": [],\n                \"leaves\": [\n                  \"bold\",\n                ],\n              },\n              \"name\": \"title\",\n              \"type\": \"richText\",", "              \"name\": \"title\",\n              \"type\": \"richText\",\n            },\n            {\n              \"admin\": {\n                \"elements\": [],\n                \"leaves\": [\n                  \"bold\",\n                ],\n              },", "                ],\n              },\n              \"name\": \"text\",\n              \"type\": \"richText\",\n            },\n          ],\n          \"localized\": true,\n          \"name\": \"hero\",\n          \"type\": \"group\",\n        },", "          \"type\": \"group\",\n        },\n        {\n          \"fields\": [\n            {\n              \"name\": \"title\",\n              \"type\": \"text\",\n            },\n            {\n              \"name\": \"subTitle\",", "            {\n              \"name\": \"subTitle\",\n              \"type\": \"text\",\n            },\n            {\n              \"fields\": [\n                {\n                  \"name\": \"title\",\n                  \"type\": \"text\",\n                },", "                  \"type\": \"text\",\n                },\n                {\n                  \"fields\": [\n                    {\n                      \"name\": \"text\",\n                      \"type\": \"text\",\n                    },\n                  ],\n                  \"localized\": true,", "                  ],\n                  \"localized\": true,\n                  \"name\": \"items\",\n                  \"type\": \"array\",\n                },\n              ],\n              \"localized\": true,\n              \"name\": \"content\",\n              \"type\": \"group\",\n            },", "              \"type\": \"group\",\n            },\n          ],\n          \"localized\": true,\n          \"name\": \"form\",\n          \"type\": \"group\",\n        },\n      ]\n    `);\n  });", "    `);\n  });\n\n  it(\"buildCrowdinJsonObject\", () => {\n    expect(crowdinJsonObject).toMatchInlineSnapshot(`\n      {\n        \"form\": {\n          \"content\": {\n            \"items\": {\n              \"64a8af5656f68b0022bfd268\": {", "            \"items\": {\n              \"64a8af5656f68b0022bfd268\": {\n                \"text\": \"Offres d'emploi et utilisateurs illimit\u00e9s\",\n              },\n              \"64a8af5656f68b0022bfd26c\": {\n                \"text\": \"Des pr\u00e9sentations produits et des webinaires gratuits\",\n              },\n              \"64a8af5656f68b0022bfd26d\": {\n                \"text\": \"Un acc\u00e8s complet \u00e0 l'Acad\u00e9mie Acme Corp\",\n              },", "                \"text\": \"Un acc\u00e8s complet \u00e0 l'Acad\u00e9mie Acme Corp\",\n              },\n            },\n          },\n          \"subTitle\": \"Nous vous contacterons d\u00e8s que possible pour fixer une heure qui vous convienne.\",\n          \"title\": \"R\u00e9servez une d\u00e9mo\",\n        },\n        \"logoTitle\": \"Ador\u00e9 par les meilleurs recruteurs internationaux\",\n      }\n    `);", "      }\n    `);\n  });\n\n  it(\"buildCrowdinHtmlObject\", () => {\n    expect(crowdinHtmlObject).toMatchInlineSnapshot(`\n      {\n        \"hero.text\": [\n          {\n            \"children\": [", "          {\n            \"children\": [\n              {\n                \"text\": \"Apprenez comment Acme Corp peut vous aider \u00e0 \",\n              },\n              {\n                \"bold\": true,\n                \"text\": \"atteindre vos objectifs\",\n              },\n              {", "              },\n              {\n                \"text\": \". Nous sommes pr\u00eats \u00e0 parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n\u2019est pas le cas, on vous offre un cupcake ! \ud83d\ude09\",\n              },\n            ],\n            \"type\": \"p\",\n          },\n        ],\n        \"hero.title\": [\n          {", "        \"hero.title\": [\n          {\n            \"children\": [\n              {\n                \"text\": \"R\u00e9servez une d\u00e9mo\",\n              },\n            ],\n            \"type\": \"p\",\n          },\n        ],", "          },\n        ],\n      }\n    `);\n  });\n\n  it(\"buildPayloadUpdateObject\", () => {\n    const docTranslations = buildPayloadUpdateObject({\n      crowdinJsonObject,\n      crowdinHtmlObject,", "      crowdinJsonObject,\n      crowdinHtmlObject,\n      fields: localizedFields,\n      document: doc,\n    });\n    expect(docTranslations).toMatchInlineSnapshot(`\n      {\n        \"form\": {\n          \"content\": {\n            \"items\": [", "          \"content\": {\n            \"items\": [\n              {\n                \"id\": \"64a8af5656f68b0022bfd268\",\n                \"text\": \"Offres d'emploi et utilisateurs illimit\u00e9s\",\n              },\n              {\n                \"id\": \"64a8af5656f68b0022bfd26c\",\n                \"text\": \"Des pr\u00e9sentations produits et des webinaires gratuits\",\n              },", "                \"text\": \"Des pr\u00e9sentations produits et des webinaires gratuits\",\n              },\n              {\n                \"id\": \"64a8af5656f68b0022bfd26d\",\n                \"text\": \"Un acc\u00e8s complet \u00e0 l'Acad\u00e9mie Acme Corp\",\n              },\n            ],\n          },\n          \"subTitle\": \"Nous vous contacterons d\u00e8s que possible pour fixer une heure qui vous convienne.\",\n          \"title\": \"R\u00e9servez une d\u00e9mo\",", "          \"subTitle\": \"Nous vous contacterons d\u00e8s que possible pour fixer une heure qui vous convienne.\",\n          \"title\": \"R\u00e9servez une d\u00e9mo\",\n        },\n        \"hero\": {\n          \"text\": [\n            {\n              \"children\": [\n                {\n                  \"text\": \"Apprenez comment Acme Corp peut vous aider \u00e0 \",\n                },", "                  \"text\": \"Apprenez comment Acme Corp peut vous aider \u00e0 \",\n                },\n                {\n                  \"bold\": true,\n                  \"text\": \"atteindre vos objectifs\",\n                },\n                {\n                  \"text\": \". Nous sommes pr\u00eats \u00e0 parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n\u2019est pas le cas, on vous offre un cupcake ! \ud83d\ude09\",\n                },\n              ],", "                },\n              ],\n              \"type\": \"p\",\n            },\n          ],\n          \"title\": [\n            {\n              \"children\": [\n                {\n                  \"text\": \"R\u00e9servez une d\u00e9mo\",", "                {\n                  \"text\": \"R\u00e9servez une d\u00e9mo\",\n                },\n              ],\n              \"type\": \"p\",\n            },\n          ],\n        },\n        \"logoTitle\": \"Ador\u00e9 par les meilleurs recruteurs internationaux\",\n      }", "        \"logoTitle\": \"Ador\u00e9 par les meilleurs recruteurs internationaux\",\n      }\n    `);\n  });\n});\n"]}
{"filename": "src/utilities/tests/inline-snapshots/collections/BookDemo.ts", "chunked_list": ["import { GlobalConfig } from \"payload/types\";\nimport { heroField } from \"./shared/heroField\";\nimport { collapsibleFields as cf } from \"./shared/collapsibleFields\";\n\nconst BookDemo: GlobalConfig = {\n  slug: \"book-demo\",\n  access: {\n    read: () => true,\n  },\n  versions: {", "  },\n  versions: {\n    drafts: true,\n  },\n  admin: {\n    group: \"Static Pages\",\n  },\n  fields: [\n    cf(\"Hero\", [heroField({ image: true })]),\n    cf(\"Form\", [", "    cf(\"Hero\", [heroField({ image: true })]),\n    cf(\"Form\", [\n      {\n        type: \"group\",\n        name: \"form\",\n        localized: true,\n        fields: [\n          {\n            type: \"text\",\n            name: \"title\",", "            type: \"text\",\n            name: \"title\",\n          },\n          {\n            type: \"text\",\n            name: \"subTitle\",\n          },\n          {\n            type: \"group\",\n            name: \"content\",", "            type: \"group\",\n            name: \"content\",\n            localized: true,\n            fields: [\n              {\n                name: \"title\",\n                type: \"text\",\n              },\n              {\n                name: \"items\",", "              {\n                name: \"items\",\n                type: \"array\",\n                localized: true,\n                fields: [{ type: \"text\", name: \"text\" }],\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    ]),\n    {\n      name: \"logoTitle\",\n      type: \"text\",\n      required: true,\n      localized: true,\n    },\n    cf(\"Promo\", [", "    },\n    cf(\"Promo\", [\n      {\n        name: \"promo\",\n        type: \"relationship\",\n        relationTo: \"promos\",\n        hasMany: false,\n      },\n    ]),\n  ],", "    ]),\n  ],\n};\n\nexport default BookDemo;\n"]}
{"filename": "src/utilities/tests/inline-snapshots/collections/shared/heroField.ts", "chunked_list": ["interface IHeroFieldOptions {\n  image?: boolean;\n  badge?: boolean;\n}\n\nconst defaultOptions = { image: false, badge: false };\n\nexport const heroField = (options: IHeroFieldOptions = {}): any => {\n  options = { ...defaultOptions, ...options };\n\n  const config = {\n    name: \"hero\",\n    type: \"group\",\n    localized: true,\n    fields: [\n      {\n        name: \"title\",\n        type: \"richText\",\n        admin: {\n          elements: [],\n          leaves: [\"bold\"],\n        },\n      },\n      {\n        name: \"text\",\n        type: \"richText\",\n        admin: {\n          elements: [],\n          leaves: [\"bold\"],\n        },\n      },\n      options.badge && {\n        name: \"badge\",\n        type: \"group\",\n        localized: true,\n        fields: [\n          {\n            name: \"badgeText\",\n            type: \"text\",\n          },\n          {\n            name: \"text\",\n            type: \"text\",\n          },\n          {\n            name: \"link\",\n            type: \"text\",\n            admin: {\n              description: \"Not sent to CrowdIn. Localize in the CMS.\",\n            },\n          },\n        ],\n      },\n      options.image && {\n        name: \"image\",\n        type: \"upload\",\n        relationTo: \"media\",\n      },\n    ].filter(Boolean),\n  };\n\n  return config;\n};\n"]}
{"filename": "src/utilities/tests/inline-snapshots/collections/shared/collapsibleFields.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\nexport const collapsibleFields = (label: string, fields: any): Field => ({\n  type: \"collapsible\",\n  label,\n  admin: {\n    initCollapsed: true,\n  },\n  fields,\n});", "  fields,\n});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/basic-field-types.spec.ts", "chunked_list": ["import { CollectionConfig, Field, GlobalConfig } from \"payload/types\";\nimport { buildCrowdinHtmlObject, getLocalizedFields } from \"../..\";\n\ndescribe(\"fn: buildCrowdinHtmlObject\", () => {\n  it(\"does not include undefined localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: [\n        {\n          type: \"h1\",", "        {\n          type: \"h1\",\n          children: [\n            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",\n              bold: true,\n            },", "              bold: true,\n            },\n            {\n              text: \" rich text value\",\n            },\n          ],\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",", "      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"richText\",\n        localized: true,\n      },", "        localized: true,\n      },\n      {\n        name: \"anotherString\",\n        type: \"text\",\n        localized: true,\n      },\n    ];\n    const expected = {\n      title: [", "    const expected = {\n      title: [\n        {\n          type: \"h1\",\n          children: [\n            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",", "            {\n              text: \"test\",\n              bold: true,\n            },\n            {\n              text: \" rich text value\",\n            },\n          ],\n        },\n      ],", "        },\n      ],\n    };\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: [", "      id: \"638641358b1a140462752076\",\n      title: [\n        {\n          type: \"h1\",\n          children: [\n            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",", "            {\n              text: \"test\",\n              bold: true,\n            },\n            {\n              text: \" rich text value\",\n            },\n          ],\n        },\n      ],", "        },\n      ],\n      content: [\n        {\n          type: \"p\",\n          children: [\n            {\n              text: \"A simple paragraph.\",\n            },\n          ],", "            },\n          ],\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {", "    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"richText\",\n        localized: true,\n      },\n      {\n        name: \"content\",\n        type: \"richText\",\n        localized: true,", "        type: \"richText\",\n        localized: true,\n      },\n    ];\n    const expected = {\n      title: [\n        {\n          type: \"h1\",\n          children: [\n            {", "          children: [\n            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",\n              bold: true,\n            },\n            {\n              text: \" rich text value\",", "            {\n              text: \" rich text value\",\n            },\n          ],\n        },\n      ],\n      content: [\n        {\n          type: \"p\",\n          children: [", "          type: \"p\",\n          children: [\n            {\n              text: \"A simple paragraph.\",\n            },\n          ],\n        },\n      ],\n    };\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);", "    };\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields nested in a group\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: {\n        title: [", "      groupField: {\n        title: [\n          {\n            type: \"h1\",\n            children: [\n              {\n                text: \"A \",\n              },\n              {\n                text: \"test\",", "              {\n                text: \"test\",\n                bold: true,\n              },\n              {\n                text: \" rich text value\",\n              },\n            ],\n          },\n        ],", "          },\n        ],\n        content: [\n          {\n            type: \"p\",\n            children: [\n              {\n                text: \"A simple paragraph.\",\n              },\n            ],", "              },\n            ],\n          },\n        ],\n        select: \"one\",\n      },\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {", "      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",", "        name: \"groupField\",\n        type: \"group\",\n        fields: [\n          {\n            admin: {\n              elements: [\"link\"],\n              leaves: [\"bold\", \"italic\", \"underline\"],\n            },\n            name: \"title\",\n            type: \"richText\",", "            name: \"title\",\n            type: \"richText\",\n            localized: true,\n          },\n          {\n            name: \"content\",\n            type: \"richText\",\n            localized: true,\n          },\n          // select not supported yet", "          },\n          // select not supported yet\n          {\n            name: \"select\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },", "        ],\n      },\n    ];\n    const expected = {\n      [\"groupField.title\"]: [\n        {\n          type: \"h1\",\n          children: [\n            {\n              text: \"A \",", "            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",\n              bold: true,\n            },\n            {\n              text: \" rich text value\",\n            },", "              text: \" rich text value\",\n            },\n          ],\n        },\n      ],\n      [\"groupField.content\"]: [\n        {\n          type: \"p\",\n          children: [\n            {", "          children: [\n            {\n              text: \"A simple paragraph.\",\n            },\n          ],\n        },\n      ],\n    };\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });", "    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields nested in a group with a localization setting on the group field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: {\n        title: [\n          {", "        title: [\n          {\n            type: \"h1\",\n            children: [\n              {\n                text: \"A \",\n              },\n              {\n                text: \"test\",\n                bold: true,", "                text: \"test\",\n                bold: true,\n              },\n              {\n                text: \" rich text value\",\n              },\n            ],\n          },\n        ],\n        content: [", "        ],\n        content: [\n          {\n            type: \"p\",\n            children: [\n              {\n                text: \"A simple paragraph.\",\n              },\n            ],\n          },", "            ],\n          },\n        ],\n        select: \"one\",\n      },\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [", "    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",", "      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        localized: true,", "        type: \"group\",\n        localized: true,\n        fields: [\n          {\n            admin: {\n              elements: [\"link\"],\n              leaves: [\"bold\", \"italic\", \"underline\"],\n            },\n            name: \"title\",\n            type: \"richText\",", "            name: \"title\",\n            type: \"richText\",\n          },\n          {\n            name: \"content\",\n            type: \"richText\",\n          },\n          // select not supported yet\n          {\n            name: \"select\",", "          {\n            name: \"select\",\n            type: \"select\",\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n    ];\n    const expected = {\n      [\"groupField.title\"]: [", "    const expected = {\n      [\"groupField.title\"]: [\n        {\n          type: \"h1\",\n          children: [\n            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",", "            {\n              text: \"test\",\n              bold: true,\n            },\n            {\n              text: \" rich text value\",\n            },\n          ],\n        },\n      ],", "        },\n      ],\n      [\"groupField.content\"]: [\n        {\n          type: \"p\",\n          children: [\n            {\n              text: \"A simple paragraph.\",\n            },\n          ],", "            },\n          ],\n        },\n      ],\n    };\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n});\n", ""]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/array-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinHtmlObject } from \"../..\";\nimport {\n  field,\n  fieldCrowdinObject,\n  fieldDocValue,\n  fieldLocalizedTopLevel,\n} from \"./fixtures/array-field-type.fixture\";\n\ndescribe(\"fn: buildCrowdinHtmlObject: array field type\", () => {", "\ndescribe(\"fn: buildCrowdinHtmlObject: array field type\", () => {\n  it(\"includes localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet", "      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      field,\n    ];", "      field,\n    ];\n    const expected = fieldCrowdinObject;\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields with a top-level localization setting\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",", "      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,", "        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      fieldLocalizedTopLevel,\n    ];\n    const expected = fieldCrowdinObject;\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n", "  });\n\n  it(\"includes localized fields within a collapsible field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet", "      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        label: \"Array fields\",", "      {\n        label: \"Array fields\",\n        type: \"collapsible\",\n        fields: [field],\n      },\n    ];\n    const expected = fieldCrowdinObject;\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n", "  });\n\n  it(\"includes localized fields with a top-level localization setting within a collapsible field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet", "      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        label: \"Array fields\",", "      {\n        label: \"Array fields\",\n        type: \"collapsible\",\n        fields: [fieldLocalizedTopLevel],\n      },\n    ];\n    const expected = fieldCrowdinObject;\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n});", "  });\n});\n\ndescribe(\"fn: buildCrowdinHtmlObject - group nested in array\", () => {\n  const doc = {\n    id: \"6474a81bef389b66642035ff\",\n    title: [\n      {\n        type: \"h1\",\n        children: [", "        type: \"h1\",\n        children: [\n          {\n            text: \"A \",\n          },\n          {\n            text: \"test\",\n            bold: true,\n          },\n          {", "          },\n          {\n            text: \" rich text value\",\n          },\n        ],\n      },\n    ],\n    ctas: [\n      {\n        link: {", "      {\n        link: {\n          text: [\n            {\n              type: \"p\",\n              children: [\n                {\n                  text: \"Link rich text.\",\n                },\n              ],", "                },\n              ],\n            },\n          ],\n          href: \"#\",\n          type: \"ctaPrimary\",\n        },\n        id: \"6474a80221baea4f5f169757\",\n      },\n      {", "      },\n      {\n        link: {\n          text: [\n            {\n              type: \"p\",\n              children: [\n                {\n                  text: \"Second link rich text.\",\n                },", "                  text: \"Second link rich text.\",\n                },\n              ],\n            },\n          ],\n          href: \"#\",\n          type: \"ctaSecondary\",\n        },\n        id: \"6474a81021baea4f5f169758\",\n      },", "        id: \"6474a81021baea4f5f169758\",\n      },\n    ],\n    createdAt: \"2023-05-29T13:26:51.734Z\",\n    updatedAt: \"2023-05-29T14:47:45.957Z\",\n    crowdinArticleDirectory: {\n      id: \"6474baaf73b854f4d464e38f\",\n      updatedAt: \"2023-05-29T14:46:07.000Z\",\n      createdAt: \"2023-05-29T14:46:07.000Z\",\n      name: \"6474a81bef389b66642035ff\",", "      createdAt: \"2023-05-29T14:46:07.000Z\",\n      name: \"6474a81bef389b66642035ff\",\n      crowdinCollectionDirectory: {\n        id: \"6474baaf73b854f4d464e38d\",\n        updatedAt: \"2023-05-29T14:46:07.000Z\",\n        createdAt: \"2023-05-29T14:46:07.000Z\",\n        name: \"promos\",\n        title: \"Promos\",\n        collectionSlug: \"promos\",\n        originalId: 1633,", "        collectionSlug: \"promos\",\n        originalId: 1633,\n        projectId: 323731,\n        directoryId: 1169,\n      },\n      originalId: 1635,\n      projectId: 323731,\n      directoryId: 1633,\n    },\n  };", "    },\n  };\n  const linkField: Field = {\n    name: \"link\",\n    type: \"group\",\n    fields: [\n      {\n        name: \"text\",\n        type: \"richText\",\n        localized: true,", "        type: \"richText\",\n        localized: true,\n      },\n      {\n        name: \"href\",\n        type: \"text\",\n      },\n      {\n        name: \"type\",\n        type: \"select\",", "        name: \"type\",\n        type: \"select\",\n        options: [\"ctaPrimary\", \"ctaSecondary\"],\n      },\n    ],\n  };\n  const Promos: CollectionConfig = {\n    slug: \"promos\",\n    admin: {\n      defaultColumns: [\"title\", \"updatedAt\"],", "    admin: {\n      defaultColumns: [\"title\", \"updatedAt\"],\n      useAsTitle: \"title\",\n      group: \"Shared\",\n    },\n    access: {\n      read: () => true,\n    },\n    fields: [\n      {", "    fields: [\n      {\n        name: \"title\",\n        type: \"richText\",\n        localized: true,\n      },\n      {\n        name: \"text\",\n        type: \"text\",\n        localized: true,", "        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"ctas\",\n        type: \"array\",\n        minRows: 1,\n        maxRows: 2,\n        fields: [linkField],\n      },", "        fields: [linkField],\n      },\n    ],\n  };\n\n  const expected: any = {\n    [\"ctas.6474a80221baea4f5f169757.link.text\"]: [\n      {\n        type: \"p\",\n        children: [", "        type: \"p\",\n        children: [\n          {\n            text: \"Link rich text.\",\n          },\n        ],\n      },\n    ],\n    [\"ctas.6474a81021baea4f5f169758.link.text\"]: [\n      {", "    [\"ctas.6474a81021baea4f5f169758.link.text\"]: [\n      {\n        type: \"p\",\n        children: [\n          {\n            text: \"Second link rich text.\",\n          },\n        ],\n      },\n    ],", "      },\n    ],\n    title: [\n      {\n        type: \"h1\",\n        children: [\n          {\n            text: \"A \",\n          },\n          {", "          },\n          {\n            text: \"test\",\n            bold: true,\n          },\n          {\n            text: \" rich text value\",\n          },\n        ],\n      },", "        ],\n      },\n    ],\n  };\n\n  it(\"includes group json fields nested inside of array field items\", () => {\n    expect(buildCrowdinHtmlObject({ doc, fields: Promos.fields })).toEqual(\n      expected\n    );\n  });", "    );\n  });\n\n  it(\"can work with an empty group field in an array\", () => {\n    expect(\n      buildCrowdinHtmlObject({\n        doc: {\n          ...doc,\n          ctas: [{}, {}],\n        },", "          ctas: [{}, {}],\n        },\n        fields: Promos.fields,\n      })\n    ).toEqual({\n      title: [\n        {\n          type: \"h1\",\n          children: [\n            {", "          children: [\n            {\n              text: \"A \",\n            },\n            {\n              text: \"test\",\n              bold: true,\n            },\n            {\n              text: \" rich text value\",", "            {\n              text: \" rich text value\",\n            },\n          ],\n        },\n      ],\n    });\n  });\n});\n", "});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/blocks-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinHtmlObject } from \"../..\";\nimport {\n  field,\n  fieldHtmlCrowdinObject,\n  fieldDocValue,\n} from \"../fixtures/blocks-field-type.fixture\";\n\ndescribe(\"fn: buildCrowdinHtmlObject: blocks field type\", () => {\n  it(\"includes localized fields\", () => {", "describe(\"fn: buildCrowdinHtmlObject: blocks field type\", () => {\n  it(\"includes localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {", "      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      field,\n    ];\n    const expected = fieldHtmlCrowdinObject();", "    ];\n    const expected = fieldHtmlCrowdinObject();\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields within a collapsible field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,", "      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",", "        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],", "        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        label: \"Array fields\",\n        type: \"collapsible\",\n        fields: [field],\n      },\n    ];\n    const expected = fieldHtmlCrowdinObject();", "    ];\n    const expected = fieldHtmlCrowdinObject();\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields within an array field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [", "      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          blocksField: fieldDocValue,\n          id: \"63ea4adb6ff825cddad3c1f2\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet", "      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"arrayField\",", "      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [field],\n      },\n    ];\n    const expected = fieldHtmlCrowdinObject(\n      \"arrayField.63ea4adb6ff825cddad3c1f2.\"\n    );\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);", "    );\n    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n  });\n});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/fixtures/array-field-type.fixture.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\nexport const field: Field = {\n  name: \"arrayField\",\n  type: \"array\",\n  fields: [\n    {\n      name: \"title\",\n      type: \"richText\",\n      localized: true,", "      type: \"richText\",\n      localized: true,\n    },\n    {\n      name: \"content\",\n      type: \"richText\",\n      localized: true,\n    },\n    {\n      name: \"select\",", "    {\n      name: \"select\",\n      type: \"select\",\n      localized: true,\n      options: [\"one\", \"two\"],\n    },\n  ],\n};\n\nexport const fieldLocalizedTopLevel: Field = {", "\nexport const fieldLocalizedTopLevel: Field = {\n  name: \"arrayField\",\n  type: \"array\",\n  localized: true,\n  fields: [\n    {\n      name: \"title\",\n      type: \"richText\",\n    },", "      type: \"richText\",\n    },\n    {\n      name: \"content\",\n      type: \"richText\",\n    },\n    {\n      name: \"select\",\n      type: \"select\",\n      options: [\"one\", \"two\"],", "      type: \"select\",\n      options: [\"one\", \"two\"],\n    },\n  ],\n};\n\nexport const fieldDocValue = [\n  {\n    title: [\n      {", "    title: [\n      {\n        type: \"h1\",\n        children: [\n          {\n            text: \"A \",\n          },\n          {\n            text: \"test\",\n            bold: true,", "            text: \"test\",\n            bold: true,\n          },\n          {\n            text: \" rich text value\",\n          },\n        ],\n      },\n    ],\n    content: [", "    ],\n    content: [\n      {\n        type: \"p\",\n        children: [\n          {\n            text: \"A simple paragraph in the first array item.\",\n          },\n        ],\n      },", "        ],\n      },\n    ],\n    select: \"two\",\n    id: \"64735620230d57bce946d370\",\n  },\n  {\n    title: [\n      {\n        type: \"h1\",", "      {\n        type: \"h1\",\n        children: [\n          {\n            text: \"A \",\n          },\n          {\n            text: \"test\",\n            bold: true,\n          },", "            bold: true,\n          },\n          {\n            text: \" rich text value\",\n          },\n        ],\n      },\n    ],\n    content: [\n      {", "    content: [\n      {\n        type: \"p\",\n        children: [\n          {\n            text: \"A simple paragraph in the second array item.\",\n          },\n        ],\n      },\n    ],", "      },\n    ],\n    select: \"two\",\n    id: \"64735621230d57bce946d371\",\n  },\n];\n\nexport const fieldCrowdinObject = {\n  [\"arrayField.64735620230d57bce946d370.title\"]: [\n    {", "  [\"arrayField.64735620230d57bce946d370.title\"]: [\n    {\n      type: \"h1\",\n      children: [\n        {\n          text: \"A \",\n        },\n        {\n          text: \"test\",\n          bold: true,", "          text: \"test\",\n          bold: true,\n        },\n        {\n          text: \" rich text value\",\n        },\n      ],\n    },\n  ],\n  [\"arrayField.64735620230d57bce946d370.content\"]: [", "  ],\n  [\"arrayField.64735620230d57bce946d370.content\"]: [\n    {\n      type: \"p\",\n      children: [\n        {\n          text: \"A simple paragraph in the first array item.\",\n        },\n      ],\n    },", "      ],\n    },\n  ],\n  [\"arrayField.64735621230d57bce946d371.title\"]: [\n    {\n      type: \"h1\",\n      children: [\n        {\n          text: \"A \",\n        },", "          text: \"A \",\n        },\n        {\n          text: \"test\",\n          bold: true,\n        },\n        {\n          text: \" rich text value\",\n        },\n      ],", "        },\n      ],\n    },\n  ],\n  [\"arrayField.64735621230d57bce946d371.content\"]: [\n    {\n      type: \"p\",\n      children: [\n        {\n          text: \"A simple paragraph in the second array item.\",", "        {\n          text: \"A simple paragraph in the second array item.\",\n        },\n      ],\n    },\n  ],\n};\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/group-field-type.spec.ts", "chunked_list": ["import { Field } from \"payload/types\";\nimport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\nimport {\n  basicNonLocalizedFields,\n  basicLocalizedFields,\n  emptyFieldDocValue,\n  fieldJsonCrowdinObject,\n  fieldDocValue,\n} from \"../../tests/fixtures/basic-localized-fields.fixture\";\n", "} from \"../../tests/fixtures/basic-localized-fields.fixture\";\n\ndescribe(\"fn: buildCrowdinJsonObject: group field type\", () => {\n  it(\"creates an empty JSON object if fields are empty\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"\",\n      groupField: emptyFieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",", "      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },", "        localized: true,\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        fields: basicLocalizedFields,\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {};", "    const localizedFields = getLocalizedFields({ fields });\n    const expected = {};\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"includes localized fields nested in a group\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",", "    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {", "    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        fields: basicLocalizedFields,", "        type: \"group\",\n        fields: basicLocalizedFields,\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      groupField: fieldJsonCrowdinObject(),\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(", "    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"includes localized fields nested in a group with a localization setting on the group field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",", "      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        localized: true,\n        fields: basicNonLocalizedFields,", "        localized: true,\n        fields: basicNonLocalizedFields,\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      groupField: fieldJsonCrowdinObject(),\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(", "    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"includes localized fields and meta @payloadcms/plugin-seo \", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      status: \"draft\",\n      meta: {\n        title: \"Meta title value\",\n        description: \"Meta description value.\\nCan contain new lines.\",\n      },\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const localizedFields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"meta\",", "      {\n        name: \"meta\",\n        label: \"SEO\",\n        type: \"group\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n            localized: true,\n            admin: {", "            localized: true,\n            admin: {\n              components: {},\n            },\n          },\n          {\n            name: \"description\",\n            type: \"textarea\",\n            localized: true,\n            admin: {", "            localized: true,\n            admin: {\n              components: {},\n            },\n          },\n        ],\n      },\n    ];\n    const expected = {\n      title: \"Test Policy created with title\",", "    const expected = {\n      title: \"Test Policy created with title\",\n      meta: {\n        title: \"Meta title value\",\n        description: \"Meta description value.\\nCan contain new lines.\",\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );", "      expected\n    );\n  });\n\n  it(\"includes localized fields nested in groups nested in a group\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: {\n        nestedGroupField: fieldDocValue,", "      groupField: {\n        nestedGroupField: fieldDocValue,\n        secondNestedGroupField: fieldDocValue,\n      },\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {", "    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"groupField\",\n        type: \"group\",\n        fields: [", "        type: \"group\",\n        fields: [\n          {\n            name: \"nestedGroupField\",\n            type: \"group\",\n            fields: basicLocalizedFields,\n          },\n          {\n            name: \"secondNestedGroupField\",\n            type: \"group\",", "            name: \"secondNestedGroupField\",\n            type: \"group\",\n            fields: basicLocalizedFields,\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",", "    const expected = {\n      title: \"Test Policy created with title\",\n      groupField: {\n        nestedGroupField: fieldJsonCrowdinObject(),\n        secondNestedGroupField: fieldJsonCrowdinObject(),\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );", "      expected\n    );\n  });\n\n  it(\"includes localized fields nested in groups nested in a group nested in a collapsible field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: {\n        nestedGroupField: fieldDocValue,", "      groupField: {\n        nestedGroupField: fieldDocValue,\n        secondNestedGroupField: fieldDocValue,\n      },\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {", "    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        label: \"collapsibleField\",\n        type: \"collapsible\",\n        fields: [", "        type: \"collapsible\",\n        fields: [\n          {\n            name: \"groupField\",\n            type: \"group\",\n            fields: [\n              {\n                name: \"nestedGroupField\",\n                type: \"group\",\n                fields: basicLocalizedFields,", "                type: \"group\",\n                fields: basicLocalizedFields,\n              },\n              {\n                name: \"secondNestedGroupField\",\n                type: \"group\",\n                fields: basicLocalizedFields,\n              },\n            ],\n          },", "            ],\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      groupField: {\n        nestedGroupField: fieldJsonCrowdinObject(),", "      groupField: {\n        nestedGroupField: fieldJsonCrowdinObject(),\n        secondNestedGroupField: fieldJsonCrowdinObject(),\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n", "  });\n\n  it(\"includes localized fields nested in groups nested in a group nested in a collapsible field with top-level localization settings\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      groupField: {\n        nestedGroupField: fieldDocValue,\n        secondNestedGroupField: fieldDocValue,\n      },", "        secondNestedGroupField: fieldDocValue,\n      },\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",", "        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        label: \"collapsibleField\",\n        type: \"collapsible\",\n        fields: [\n          {\n            name: \"groupField\",", "          {\n            name: \"groupField\",\n            type: \"group\",\n            fields: [\n              {\n                name: \"nestedGroupField\",\n                type: \"group\",\n                localized: true,\n                fields: basicNonLocalizedFields,\n              },", "                fields: basicNonLocalizedFields,\n              },\n              {\n                name: \"secondNestedGroupField\",\n                type: \"group\",\n                localized: true,\n                fields: basicNonLocalizedFields,\n              },\n            ],\n          },", "            ],\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      groupField: {\n        nestedGroupField: fieldJsonCrowdinObject(),", "      groupField: {\n        nestedGroupField: fieldJsonCrowdinObject(),\n        secondNestedGroupField: fieldJsonCrowdinObject(),\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n});", "  });\n});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/index.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\nimport { FieldWithName } from \"../../../types\";\n\ndescribe(\"fn: buildCrowdinJsonObject\", () => {\n  it(\"creates an empty object if no content exists\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const localizedFields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {", "      },\n      {\n        name: \"anotherString\",\n        type: \"text\",\n        localized: true,\n      },\n    ];\n    const expected = {};\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected", "    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"does not include undefined localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      status: \"draft\",", "      title: \"Test Policy created with title\",\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const localizedFields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,", "        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"anotherString\",\n        type: \"text\",\n        localized: true,\n      },\n    ];\n    const expected = {", "    ];\n    const expected = {\n      title: \"Test Policy created with title\",\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"includes localized fields\", () => {", "\n  it(\"includes localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Text value\",\n      anotherString: \"Another text value\",\n      description: \"A textarea value.\\nWith a new line.\",\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const localizedFields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {", "      },\n      {\n        name: \"anotherString\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"description\",\n        type: \"textarea\",\n        localized: true,", "        type: \"textarea\",\n        localized: true,\n      },\n    ];\n    const expected = {\n      title: \"Text value\",\n      anotherString: \"Another text value\",\n      description: \"A textarea value.\\nWith a new line.\",\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(", "    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"includes localized fields within a collapsible field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n        },\n        {", "        },\n        {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n          select: \"two\",\n          id: \"64735621230d57bce946d371\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",", "      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },", "        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {", "      },\n      {\n        label: \"Array fields\",\n        type: \"collapsible\",\n        fields: [\n          {\n            name: \"arrayField\",\n            type: \"array\",\n            fields: [\n              {", "            fields: [\n              {\n                name: \"title\",\n                type: \"text\",\n                localized: true,\n              },\n              {\n                name: \"text\",\n                type: \"text\",\n                localized: true,", "                type: \"text\",\n                localized: true,\n              },\n              {\n                name: \"select\",\n                type: \"select\",\n                localized: true,\n                options: [\"one\", \"two\"],\n              },\n            ],", "              },\n            ],\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      arrayField: {", "      title: \"Test Policy created with title\",\n      arrayField: {\n        \"64735620230d57bce946d370\": {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n        },\n\n        \"64735621230d57bce946d371\": {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",", "          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n});", "  });\n});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/array-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\nimport { FieldWithName } from \"../../../types\";\n\ndescribe(\"fn: buildCrowdinJsonObject: array field type\", () => {\n  it(\"do not include non-localized fields nested in an array\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [", "      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n        },\n        {\n          title: \"Array field title content two\",", "        {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n          select: \"two\",\n          id: \"64735621230d57bce946d371\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet", "      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"arrayField\",", "      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n          },\n          {\n            name: \"text\",", "          {\n            name: \"text\",\n            type: \"text\",\n          },\n          {\n            name: \"select\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },", "            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(", "    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"includes localized fields nested in an array\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n        },\n        {", "        },\n        {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n          select: \"two\",\n          id: \"64735621230d57bce946d371\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",", "      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },", "        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {", "      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n            localized: true,\n          },", "            localized: true,\n          },\n          {\n            name: \"text\",\n            type: \"text\",\n            localized: true,\n          },\n          {\n            name: \"select\",\n            type: \"select\",", "            name: \"select\",\n            type: \"select\",\n            localized: true,\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {", "    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      arrayField: {\n        \"64735620230d57bce946d370\": {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n        },\n        \"64735621230d57bce946d371\": {\n          title: \"Array field title content two\",", "        \"64735621230d57bce946d371\": {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });", "    );\n  });\n\n  it(\"includes localized fields nested in an array with a localization setting on the array field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          title: \"Array field title content one\",", "        {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n        },\n        {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n          select: \"two\",", "          text: \"Array field text content two\",\n          select: \"two\",\n          id: \"64735621230d57bce946d371\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: FieldWithName[] = [", "    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",", "      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        localized: true,", "        type: \"array\",\n        localized: true,\n        fields: [\n          {\n            name: \"title\",\n            type: \"text\",\n          },\n          {\n            name: \"text\",\n            type: \"text\",", "            name: \"text\",\n            type: \"text\",\n          },\n          {\n            name: \"select\",\n            type: \"select\",\n            options: [\"one\", \"two\"],\n          },\n        ],\n      },", "        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      arrayField: {\n        \"64735620230d57bce946d370\": {\n          title: \"Array field title content one\",\n          text: \"Array field text content one\",", "          title: \"Array field title content one\",\n          text: \"Array field text content one\",\n        },\n        \"64735621230d57bce946d371\": {\n          title: \"Array field title content two\",\n          text: \"Array field text content two\",\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(", "    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"does not include localized fields richText fields nested in an array field in the `fields.json` file\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          content: [\n            {\n              children: [\n                {\n                  text: \"Test content 1\",\n                },", "                  text: \"Test content 1\",\n                },\n              ],\n            },\n          ],\n          id: \"64735620230d57bce946d370\",\n        },\n        {\n          content: [\n            {", "          content: [\n            {\n              children: [\n                {\n                  text: \"Test content 1\",\n                },\n              ],\n            },\n          ],\n          id: \"64735621230d57bce946d371\",", "          ],\n          id: \"64735621230d57bce946d371\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: FieldWithName[] = [\n      {", "    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",", "        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        localized: true,\n        fields: [", "        localized: true,\n        fields: [\n          {\n            name: \"content\",\n            type: \"richText\",\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });", "    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n});", "  });\n});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/combined-field-types.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\nimport { FieldWithName } from \"../../../types\";\n\ndescribe(\"fn: buildCrowdinJsonObject: group nested in array\", () => {\n  const doc = {\n    id: \"6474a81bef389b66642035ff\",\n    title: \"Experience the magic of our product!\",\n    text: \"Get in touch with us or try it out yourself\",\n    ctas: [", "    text: \"Get in touch with us or try it out yourself\",\n    ctas: [\n      {\n        link: {\n          text: \"Talk to us\",\n          href: \"#\",\n          type: \"ctaPrimary\",\n        },\n        id: \"6474a80221baea4f5f169757\",\n      },", "        id: \"6474a80221baea4f5f169757\",\n      },\n      {\n        link: {\n          text: \"Try for free\",\n          href: \"#\",\n          type: \"ctaSecondary\",\n        },\n        id: \"6474a81021baea4f5f169758\",\n      },", "        id: \"6474a81021baea4f5f169758\",\n      },\n    ],\n    createdAt: \"2023-05-29T13:26:51.734Z\",\n    updatedAt: \"2023-05-29T14:47:45.957Z\",\n    crowdinArticleDirectory: {\n      id: \"6474baaf73b854f4d464e38f\",\n      updatedAt: \"2023-05-29T14:46:07.000Z\",\n      createdAt: \"2023-05-29T14:46:07.000Z\",\n      name: \"6474a81bef389b66642035ff\",", "      createdAt: \"2023-05-29T14:46:07.000Z\",\n      name: \"6474a81bef389b66642035ff\",\n      crowdinCollectionDirectory: {\n        id: \"6474baaf73b854f4d464e38d\",\n        updatedAt: \"2023-05-29T14:46:07.000Z\",\n        createdAt: \"2023-05-29T14:46:07.000Z\",\n        name: \"promos\",\n        title: \"Promos\",\n        collectionSlug: \"promos\",\n        originalId: 1633,", "        collectionSlug: \"promos\",\n        originalId: 1633,\n        projectId: 323731,\n        directoryId: 1169,\n      },\n      originalId: 1635,\n      projectId: 323731,\n      directoryId: 1633,\n    },\n  };", "    },\n  };\n  const linkField: Field = {\n    name: \"link\",\n    type: \"group\",\n    fields: [\n      {\n        name: \"text\",\n        type: \"text\",\n        localized: true,", "        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"href\",\n        type: \"text\",\n      },\n      {\n        name: \"type\",\n        type: \"select\",", "        name: \"type\",\n        type: \"select\",\n        options: [\"ctaPrimary\", \"ctaSecondary\"],\n      },\n    ],\n  };\n  const Promos: CollectionConfig = {\n    slug: \"promos\",\n    admin: {\n      defaultColumns: [\"title\", \"updatedAt\"],", "    admin: {\n      defaultColumns: [\"title\", \"updatedAt\"],\n      useAsTitle: \"title\",\n      group: \"Shared\",\n    },\n    access: {\n      read: () => true,\n    },\n    fields: [\n      {", "    fields: [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"text\",\n        type: \"text\",\n        localized: true,", "        type: \"text\",\n        localized: true,\n      },\n      {\n        name: \"ctas\",\n        type: \"array\",\n        minRows: 1,\n        maxRows: 2,\n        fields: [linkField],\n      },", "        fields: [linkField],\n      },\n    ],\n  };\n\n  const expected: any = {\n    ctas: {\n      \"6474a80221baea4f5f169757\": {\n        link: {\n          text: \"Talk to us\",", "        link: {\n          text: \"Talk to us\",\n        },\n      },\n      \"6474a81021baea4f5f169758\": {\n        link: {\n          text: \"Try for free\",\n        },\n      },\n    },", "      },\n    },\n\n    text: \"Get in touch with us or try it out yourself\",\n    title: \"Experience the magic of our product!\",\n  };\n\n  it(\"includes group json fields nested inside of array field items\", () => {\n    expect(\n      buildCrowdinJsonObject({", "    expect(\n      buildCrowdinJsonObject({\n        doc,\n        fields: getLocalizedFields({ fields: Promos.fields, type: \"json\" }),\n      })\n    ).toEqual(expected);\n  });\n\n  it(\"includes group json fields nested inside of array field items even when getLocalizedFields is run twice\", () => {\n    expect(", "  it(\"includes group json fields nested inside of array field items even when getLocalizedFields is run twice\", () => {\n    expect(\n      buildCrowdinJsonObject({\n        doc,\n        fields: getLocalizedFields({\n          fields: getLocalizedFields({ fields: Promos.fields }),\n          type: \"json\",\n        }),\n      })\n    ).toEqual(expected);", "      })\n    ).toEqual(expected);\n  });\n\n  /**\n   * afterChange builds a JSON object for the previous version of\n   * a document to compare with the current version. Ensure this\n   * function works in that scenario. Also important for dealing\n   * with non-required empty fields.\n   */\n  it(\"can work with an empty document\", () => {\n    expect(\n      buildCrowdinJsonObject({\n        doc: {},\n        fields: getLocalizedFields({ fields: Promos.fields }),\n      })\n    ).toEqual({});\n  });\n\n  it(\"can work with an empty array field\", () => {\n    expect(\n      buildCrowdinJsonObject({\n        doc: {\n          ...doc,\n          ctas: undefined,\n        },\n        fields: getLocalizedFields({ fields: Promos.fields }),\n      })\n    ).toEqual({\n      text: \"Get in touch with us or try it out yourself\",\n      title: \"Experience the magic of our product!\",\n    });\n  });\n\n  it(\"can work with an empty group field in an array\", () => {\n    expect(\n      buildCrowdinJsonObject({\n        doc: {\n          ...doc,\n          ctas: [{}, {}],\n        },\n        fields: getLocalizedFields({ fields: Promos.fields }),\n      })\n    ).toEqual({\n      text: \"Get in touch with us or try it out yourself\",\n      title: \"Experience the magic of our product!\",\n    });\n  });\n});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/blocks-field-type-fixture.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinJsonObject } from \"../..\";\nimport {\n  field,\n  fieldJsonCrowdinObject,\n  fieldDocValue,\n} from \"../fixtures/blocks-field-type.fixture\";\n\ndescribe(\"fn: buildCrowdinHtmlObject: blocks field type\", () => {\n  it(\"includes localized fields\", () => {", "describe(\"fn: buildCrowdinHtmlObject: blocks field type\", () => {\n  it(\"includes localized fields\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {", "      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      field,\n    ];\n    const expected = {", "    ];\n    const expected = {\n      title: \"Test Policy created with title\",\n      ...fieldJsonCrowdinObject(),\n    };\n    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields within a collapsible field\", () => {\n    const doc = {", "  it(\"includes localized fields within a collapsible field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: fieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [", "    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",", "      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        label: \"Array fields\",\n        type: \"collapsible\",\n        fields: [field],", "        type: \"collapsible\",\n        fields: [field],\n      },\n    ];\n    const expected = {\n      title: \"Test Policy created with title\",\n      ...fieldJsonCrowdinObject(),\n    };\n    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n  });", "    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n  });\n\n  it(\"includes localized fields within an array field\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      arrayField: [\n        {\n          blocksField: fieldDocValue,", "        {\n          blocksField: fieldDocValue,\n          id: \"63ea4adb6ff825cddad3c1f2\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [", "    };\n    const fields: Field[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",", "      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"arrayField\",\n        type: \"array\",\n        fields: [field],", "        type: \"array\",\n        fields: [field],\n      },\n    ];\n    const expected = {\n      title: \"Test Policy created with title\",\n      ...fieldJsonCrowdinObject(\"arrayField.63ea4adb6ff825cddad3c1f2\"),\n    };\n    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n  });", "    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n  });\n});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/tabs-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\nimport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\nimport { FieldWithName } from \"../../../types\";\nimport {\n  basicNonLocalizedFields,\n  basicLocalizedFields,\n  emptyFieldDocValue,\n  fieldJsonCrowdinObject,\n  fieldDocValue,\n} from \"../../tests/fixtures/basic-localized-fields.fixture\";", "  fieldDocValue,\n} from \"../../tests/fixtures/basic-localized-fields.fixture\";\n\ndescribe(\"fn: buildCrowdinJsonObject: group field type\", () => {\n  it(\"creates an empty JSON object if fields are empty\", () => {\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"\",\n      groupField: emptyFieldDocValue,\n      status: \"draft\",", "      groupField: emptyFieldDocValue,\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: Field[] = [\n      {\n        type: \"tabs\",\n        tabs: [\n          {", "        tabs: [\n          {\n            label: \"Tab 1\",\n            fields: [\n              {\n                name: \"title\",\n                type: \"text\",\n                localized: true,\n              },\n              // select not supported yet", "              },\n              // select not supported yet\n              {\n                name: \"select\",\n                type: \"select\",\n                localized: true,\n                options: [\"one\", \"two\"],\n              },\n            ],\n          },", "            ],\n          },\n          {\n            label: \"Tab 2\",\n            fields: [\n              {\n                name: \"groupField\",\n                type: \"group\",\n                fields: [\n                  {", "                fields: [\n                  {\n                    name: \"title\",\n                    type: \"text\",\n                    localized: true,\n                  },\n                  {\n                    name: \"text\",\n                    type: \"text\",\n                    localized: true,", "                    type: \"text\",\n                    localized: true,\n                  },\n                  {\n                    name: \"description\",\n                    type: \"textarea\",\n                    localized: true,\n                  },\n                  // select not supported yet\n                  {", "                  // select not supported yet\n                  {\n                    name: \"select\",\n                    type: \"select\",\n                    localized: true,\n                    options: [\"one\", \"two\"],\n                  },\n                ],\n              },\n            ],", "              },\n            ],\n          },\n        ],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {};\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected", "    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/blocks-field-type.spec.ts", "chunked_list": ["import { Block } from \"payload/types\";\nimport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\nimport { FieldWithName } from \"../../../types\";\n\nconst TestBlockOne: Block = {\n  slug: \"testBlockOne\",\n  fields: [\n    {\n      name: \"title\",\n      type: \"text\",", "      name: \"title\",\n      type: \"text\",\n      localized: true,\n    },\n    {\n      name: \"text\",\n      type: \"text\",\n      localized: true,\n    },\n    {", "    },\n    {\n      name: \"select\",\n      type: \"select\",\n      localized: true,\n      options: [\"one\", \"two\"],\n    },\n  ],\n};\n", "};\n\nconst TestBlockTwo: Block = {\n  slug: \"testBlockTwo\",\n  fields: [\n    {\n      name: \"url\",\n      type: \"text\",\n      localized: true,\n    },", "      localized: true,\n    },\n  ],\n};\n\nconst TestBlockTwoNonLocalized: Block = {\n  slug: \"testBlockTwo\",\n  fields: [\n    {\n      name: \"url\",", "    {\n      name: \"url\",\n      type: \"text\",\n    },\n  ],\n};\n\ndescribe(\"fn: buildCrowdinJsonObject: blocks field type\", () => {\n  it(\"includes localized fields nested in blocks\", () => {\n    const doc = {", "  it(\"includes localized fields nested in blocks\", () => {\n    const doc = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          title: \"Block field title content one\",\n          text: \"Block field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",", "          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",\n        },\n        {\n          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          id: \"64735621230d57bce946d371\",\n          blockType: \"testBlockTwo\",\n        },\n      ],\n    };", "      ],\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {", "      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",", "        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockOne, TestBlockTwo],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: {\n        \"64735620230d57bce946d370\": {", "      blocksField: {\n        \"64735620230d57bce946d370\": {\n          testBlockOne: {\n            title: \"Block field title content one\",\n            text: \"Block field text content one\",\n          },\n        },\n\n        \"64735621230d57bce946d371\": {\n          testBlockTwo: {", "        \"64735621230d57bce946d371\": {\n          testBlockTwo: {\n            url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          },\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );", "      expected\n    );\n  });\n\n  it(\"excludes block with no localized fields\", () => {\n    const doc = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          title: \"Block field title content one\",", "        {\n          title: \"Block field title content one\",\n          text: \"Block field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",\n        },\n        {\n          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          id: \"64735621230d57bce946d371\",", "          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          id: \"64735621230d57bce946d371\",\n          blockType: \"testBlockTwo\",\n        },\n      ],\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",", "        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],", "        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });", "    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: {\n        \"64735620230d57bce946d370\": {\n          testBlockOne: {\n            title: \"Block field title content one\",\n            text: \"Block field text content one\",\n          },", "            text: \"Block field text content one\",\n          },\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n", "  });\n\n  it(\"excludes block with no localized fields - more blocks\", () => {\n    const doc = {\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          title: \"Block field title content one\",\n          text: \"Block field text content one\",\n          select: \"two\",", "          text: \"Block field text content one\",\n          select: \"two\",\n          id: \"64735620230d57bce946d370\",\n          blockType: \"testBlockOne\",\n        },\n        {\n          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n          id: \"64735621230d57bce946d371\",\n          blockType: \"testBlockTwo\",\n        },", "          blockType: \"testBlockTwo\",\n        },\n        {\n          title: \"Block field title content two\",\n          text: \"Block field text content two\",\n          select: \"two\",\n          id: \"64a535cdf1eaa5498709c906\",\n          blockType: \"testBlockOne\",\n        },\n      ],", "        },\n      ],\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet", "      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",", "      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: {", "      title: \"Test Policy created with title\",\n      blocksField: {\n        \"64735620230d57bce946d370\": {\n          testBlockOne: {\n            title: \"Block field title content one\",\n            text: \"Block field text content one\",\n          },\n        },\n        \"64a535cdf1eaa5498709c906\": {\n          testBlockOne: {", "        \"64a535cdf1eaa5498709c906\": {\n          testBlockOne: {\n            title: \"Block field title content two\",\n            text: \"Block field text content two\",\n          },\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected", "    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file\", () => {\n    const TestBlockArrayOfRichText: Block = {\n      slug: \"testBlockArrayOfRichText\",\n      fields: [\n        {", "      fields: [\n        {\n          name: \"arrayField\",\n          type: \"array\",\n          fields: [\n            {\n              name: \"richText\",\n              type: \"richText\",\n              localized: true,\n            },", "              localized: true,\n            },\n          ],\n        },\n      ],\n    };\n\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",", "      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          arrayField: [\n            {\n              content: [\n                {\n                  children: [\n                    {", "                  children: [\n                    {\n                      text: \"Test content 1\",\n                    },\n                  ],\n                },\n              ],\n              id: \"64735620230d57bce946d370\",\n            },\n            {", "            },\n            {\n              content: [\n                {\n                  children: [\n                    {\n                      text: \"Test content 1\",\n                    },\n                  ],\n                },", "                  ],\n                },\n              ],\n              id: \"64735621230d57bce946d371\",\n            },\n          ],\n          blockType: \"testBlockArrayOfRichText\",\n        },\n      ],\n      status: \"draft\",", "      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,", "        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },", "        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockArrayOfRichText],\n      },\n    ];\n    const localizedFields = getLocalizedFields({ fields, type: \"json\" });\n    const expected = {", "    const localizedFields = getLocalizedFields({ fields, type: \"json\" });\n    const expected = {\n      title: \"Test Policy created with title\",\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n\n  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file 2\", () => {", "\n  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file 2\", () => {\n    const TestBlockArrayOfRichText: Block = {\n      slug: \"testBlockArrayOfRichText\",\n      fields: [\n        {\n          name: \"title\",\n          type: \"text\",\n          localized: true,\n        },", "          localized: true,\n        },\n        {\n          name: \"messages\",\n          type: \"array\",\n          localized: true,\n          maxRows: 3,\n          fields: [\n            {\n              name: \"title\",", "            {\n              name: \"title\",\n              type: \"text\",\n              localized: true,\n            },\n            {\n              name: \"message\",\n              type: \"richText\",\n            },\n          ],", "            },\n          ],\n        },\n      ],\n    };\n\n    const doc = {\n      id: \"638641358b1a140462752076\",\n      title: \"Test Policy created with title\",\n      blocksField: [", "      title: \"Test Policy created with title\",\n      blocksField: [\n        {\n          messages: [\n            {\n              title: \"Test title 1\",\n              message: [\n                {\n                  children: [\n                    {", "                  children: [\n                    {\n                      text: \"Test content 1\",\n                    },\n                  ],\n                },\n              ],\n              id: \"64735620230d57bce946d370\",\n            },\n            {", "            },\n            {\n              title: \"Test title 2\",\n              message: [\n                {\n                  children: [\n                    {\n                      text: \"Test content 1\",\n                    },\n                  ],", "                    },\n                  ],\n                },\n              ],\n              id: \"64735621230d57bce946d371\",\n            },\n          ],\n          id: \"649cd1ecbac7445191be36af\",\n          blockType: \"testBlockArrayOfRichText\",\n        },", "          blockType: \"testBlockArrayOfRichText\",\n        },\n      ],\n      status: \"draft\",\n      createdAt: \"2022-11-29T17:28:21.644Z\",\n      updatedAt: \"2022-11-29T17:28:21.644Z\",\n    };\n    const fields: FieldWithName[] = [\n      {\n        name: \"title\",", "      {\n        name: \"title\",\n        type: \"text\",\n        localized: true,\n      },\n      // select not supported yet\n      {\n        name: \"select\",\n        type: \"select\",\n        localized: true,", "        type: \"select\",\n        localized: true,\n        options: [\"one\", \"two\"],\n      },\n      {\n        name: \"blocksField\",\n        type: \"blocks\",\n        blocks: [TestBlockArrayOfRichText],\n      },\n    ];", "      },\n    ];\n    const localizedFields = getLocalizedFields({ fields });\n    const expected = {\n      title: \"Test Policy created with title\",\n      blocksField: {\n        \"649cd1ecbac7445191be36af\": {\n          testBlockArrayOfRichText: {\n            messages: {\n              \"64735620230d57bce946d370\": {", "            messages: {\n              \"64735620230d57bce946d370\": {\n                title: \"Test title 1\",\n              },\n\n              \"64735621230d57bce946d371\": {\n                title: \"Test title 2\",\n              },\n            },\n          },", "            },\n          },\n        },\n      },\n    };\n    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n      expected\n    );\n  });\n});", "  });\n});\n"]}
