{"filename": "src/Commands.ts", "chunked_list": ["import { Command } from './types/Command'\nimport Ping from './commands/Ping'\nimport TicketGenerator from './commands/TicketGenerator'\nimport CreateIssue from './commands/CreateIssue'\nimport Summarize from './commands/Summarize'\n\n// List of all commands available to the bot\nexport default [CreateIssue, Ping, TicketGenerator, Summarize] as Command[]\n", ""]}
{"filename": "src/bot.ts", "chunked_list": ["import { Client, GatewayIntentBits } from 'discord.js'\nimport { DISCORD_BOT_TOKEN } from './config/config'\nimport ready from './listeners/ready'\nimport interactionCreate from './listeners/interactionCreate'\n\nconsole.log('Initiating bot ...')\n\n// Create client\nconst client = new Client({\n  intents: [", "const client = new Client({\n  intents: [\n    GatewayIntentBits.DirectMessages,\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n  ],\n})\n\n// Ready the client", "\n// Ready the client\nready(client)\n\n// Listen to interactions\ninteractionCreate(client)\n\n// Login bot\nclient.login(DISCORD_BOT_TOKEN)\n", "client.login(DISCORD_BOT_TOKEN)\n"]}
{"filename": "src/commands/Summarize.ts", "chunked_list": ["import { ChatInputCommandInteraction, Client, SlashCommandBuilder } from 'discord.js'\nimport { Configuration, OpenAIApi } from 'openai'\nimport { getMessageFromURL, replaceMessageUrls } from '../utils/discord'\nimport { GPT_API_KEY } from '../config/config'\nimport openAISettings from '../config/openAISettings'\nimport { addConversation } from '../utils/openai'\n\n/*  ******SETTINGS****** */\nconst CONVERSATION_WORD_LIMIT = 3000 // Maximum number of words in conversation\n", "const CONVERSATION_WORD_LIMIT = 3000 // Maximum number of words in conversation\n\n// Setup\nconst config = new Configuration({ apiKey: GPT_API_KEY })\nconst openai = new OpenAIApi(config)\n\n// Command declaration\nconst summarizeCommandData = new SlashCommandBuilder()\n  .setName('summarize-ai')\n  .setDescription('Summarize the key points from a conversation starting with a message URL')", "  .setName('summarize-ai')\n  .setDescription('Summarize the key points from a conversation starting with a message URL')\n  .addStringOption((option) => option\n    .setName('start_message')\n    .setDescription('URL of the message to start summarizing from')\n    .setRequired(true))\n\n// Will summarize conversations\nasync function generateConversationSummary(discordClient: Client, conversation: string) {\n  if (conversation.trim().length === 0) {\n    throw new Error('Please enter valid information or conversation')\n  }\n\n  // Check if conversation is too long for GPT to handle in one call", "async function generateConversationSummary(discordClient: Client, conversation: string) {\n  if (conversation.trim().length === 0) {\n    throw new Error('Please enter valid information or conversation')\n  }\n\n  // Check if conversation is too long for GPT to handle in one call\n  if (conversation.split(' ').length > CONVERSATION_WORD_LIMIT) {\n    throw new Error(`\n        Not able to review the conversation because it exceeds the \n        word limit of ${CONVERSATION_WORD_LIMIT} (${conversation.split(' ').length} words)\n    `)\n  }\n\n  // Replace discord message urls with their actual message content\n  const noURLconversation = await replaceMessageUrls(discordClient, conversation)\n\n  // Send conversation to GPT with a summary prompt\n  const completion = await openai.createChatCompletion({\n    messages: [\n      { role: 'system', content: 'Please summarize the key points from the following conversation:' },\n      { role: 'user', content: noURLconversation },\n    ],\n    ...openAISettings,\n  } as any)\n\n  const summary = completion.data.choices[0].message?.content.toString()\n", "  if (summary) {\n    return summary\n  }\n  throw new Error('GPT response is unfortunately empty. Troubled servers perhaps?')\n}\n\nexport default {\n  data: summarizeCommandData,\n  execute: async (discordClient: Client, interaction: ChatInputCommandInteraction) => {\n    // Get the starting message using the provided URL\n    const startMessage = await getMessageFromURL(discordClient, interaction.options.getString('start_message'))\n\n    // Find the channel where the conversation took place\n    const channel = await discordClient.channels.cache.get(interaction.channelId)\n", "    if (channel && channel.isTextBased()) {\n      // Start the conversation with the starting message\n      let conversation = addConversation(startMessage)\n\n      // Fetch the messages in the channel after the starting message and concatenate them\n      const messages = await channel.messages.fetch({ after: startMessage.id })\n      messages.reverse().forEach((message) => {\n        conversation += addConversation(message)\n      })\n\n      // Generate a summary of the conversation\n      const summary = await generateConversationSummary(discordClient, conversation)\n\n      // Send the summary back to the user\n      await interaction.followUp({\n        content: `Here's the summary of the conversation:\\n\\n${summary}`,\n        ephemeral: true,\n\n      })\n    }\n  },\n}\n"]}
{"filename": "src/commands/Ping.ts", "chunked_list": ["import { Client, CommandInteraction } from 'discord.js'\nimport { SlashCommandBuilder } from '@discordjs/builders'\n\nconst pingCommandData = new SlashCommandBuilder()\n  .setName('ping')\n  .setDescription('Alfred will greet you')\n\nexport default {\n  data: pingCommandData,\n  execute: async (client: Client, interaction: CommandInteraction) => {", "  data: pingCommandData,\n  execute: async (client: Client, interaction: CommandInteraction) => {\n    const content = ':smile: *Why, hello!*'\n\n    await interaction.followUp({\n      ephemeral: true,\n      content,\n    })\n  },\n}", "  },\n}\n"]}
{"filename": "src/commands/CreateIssue.ts", "chunked_list": ["import { ChatInputCommandInteraction, Client } from 'discord.js'\nimport { SlashCommandBuilder } from '@discordjs/builders'\nimport { Configuration, OpenAIApi } from 'openai'\nimport { getOctokit, createIssue, getRepositoryLabels } from '../utils/github'\nimport { AlfredGithubConfig, GPT_API_KEY } from '../config/config'\nimport LabelsPrompt from '../prompts/LabelsPrompt'\nimport openAISettings from '../config/openAISettings'\nimport { AlfredResponse } from '../types/AlfredResponse'\n\n// TEMPORARY SETTINGS", "\n// TEMPORARY SETTINGS\nconst OWNER = 'viv-cheung'\nconst REPO = 'alfred'\n\n// Setup\nconst configuration = new Configuration({ apiKey: GPT_API_KEY })\nconst openai = new OpenAIApi(configuration)\nconst octokit = getOctokit(AlfredGithubConfig)\n", "const octokit = getOctokit(AlfredGithubConfig)\n\n// Command\nconst createIssueCommandData = new SlashCommandBuilder()\n  .setName('create-issue-manual')\n  .setDescription('Create a GitHub issue')\n  .addStringOption((option) => option\n    .setName('title')\n    .setDescription('The title of the issue')\n    .setRequired(true))", "    .setDescription('The title of the issue')\n    .setRequired(true))\n  .addStringOption((option) => option\n    .setName('content')\n    .setDescription('The body of the issue')\n    .setRequired(true))\n  .addBooleanOption((option) => option\n    .setName('ai-labels')\n    .setDescription('Let Alfred label the ticket?'))\n", "    .setDescription('Let Alfred label the ticket?'))\n\n// Command to let the bot create a ticket\nexport default {\n  data: createIssueCommandData,\n  execute: async (client: Client, interaction: ChatInputCommandInteraction): Promise<void> => {\n    const title = interaction.options.getString('title')\n    const body = interaction.options.getString('content')\n    const aiLabels = interaction.options.getBoolean('ai-labels') ?? true\n", "    const aiLabels = interaction.options.getBoolean('ai-labels') ?? true\n\n    // Labels proposed by Alfred\n    let proposedLabels: string[] | undefined\n\n    if (aiLabels) {\n      // Get Repository labels + definitions for auto-labeling\n      const labels = await getRepositoryLabels(await octokit, OWNER, REPO)\n      const alfredResponse = (await openai.createChatCompletion({\n        messages: [\n          { role: 'system', content: 'You will assign labels for the following github issue:' },\n          { role: 'user', content: `${title}: ${body}` },\n          { role: 'system', content: LabelsPrompt },\n          { role: 'system', content: labels },\n          { role: 'system', content: 'Reply with RFC8259 compliant JSON with a field called \"labels\"' },\n        ],\n        ...openAISettings,\n      } as any)).data.choices[0].message?.content.toString()\n\n      // Don't throw if smart labeling failed", "      try {\n        proposedLabels = (JSON.parse(alfredResponse!) as AlfredResponse).labels\n      } catch (e) {\n        console.log(`Can't assign labels: ${e}`)\n      }\n    }\n\n    // Create ticket\n    const url = await createIssue(await octokit, OWNER, REPO, title!, body!, proposedLabels)\n\n    // Send info back to discord\n    interaction.followUp({\n      content:\n          `**${title}**\\n`\n          + `:link: ${url}\\n`\n          + `:label: ${proposedLabels ?? ''}\\n`\n          + `\\`\\`\\`${body}\\`\\`\\``,\n      ephemeral: false,\n    })\n  },\n}\n"]}
{"filename": "src/commands/TicketGenerator.ts", "chunked_list": ["import {\n  Client, Message, SlashCommandBuilder, ChatInputCommandInteraction, ThreadChannel,\n} from 'discord.js'\nimport { Configuration, OpenAIApi } from 'openai'\nimport { GPT_API_KEY, AlfredGithubConfig } from '../config/config'\nimport openAISettings from '../config/openAISettings'\nimport { getOctokit, createIssue, getRepositoryLabels } from '../utils/github'\nimport LabelsPrompt from '../prompts/LabelsPrompt'\nimport PreConversationPrompt from '../prompts/PreConversationPrompt'\nimport {", "import PreConversationPrompt from '../prompts/PreConversationPrompt'\nimport {\n  getMessageFromURL, mentionUser, replaceMessageUrls, replyOrFollowup, waitForUserResponse,\n} from '../utils/discord'\nimport { AlfredResponse } from '../types/AlfredResponse'\nimport AlfredRolePrompt from '../prompts/AlfredRolePrompt'\nimport TicketRulesPrompt from '../prompts/TicketRulesPrompt'\nimport { addConversation } from '../utils/openai'\n\n/*  ******SETTINGS****** */", "\n/*  ******SETTINGS****** */\nconst COUNT_QUESTION_LIMIT = 4 // Number of questions Alfred can ask\nconst CONVERSATION_WORD_LIMIT = 1500 // Maximum number of words in conversation\nconst TIMEOUT_WAITING_FOR_RESPONSE_LIMIT = 60000 // Time user has to reply to a question\nconst USER_RESPONSE_COUNT_LIMIT = 1 // How many answers does Alfred wait for\n\n// TEMPORARY SETTINGS\nconst OWNER = 'viv-cheung'\nconst REPO = 'alfred'", "const OWNER = 'viv-cheung'\nconst REPO = 'alfred'\n\n// Setup\nconst config = new Configuration({ apiKey: GPT_API_KEY })\nconst openai = new OpenAIApi(config)\nconst octokit = getOctokit(AlfredGithubConfig)\n\n// Core function\nasync function generateAlfredResponse(discordClient: Client, conversation: string) {\n  if (conversation.trim().length === 0) {\n    throw new Error('Please enter valid information or conversation')\n  }\n\n  // Check if conversation is too long for GPT to handle in one call", "// Core function\nasync function generateAlfredResponse(discordClient: Client, conversation: string) {\n  if (conversation.trim().length === 0) {\n    throw new Error('Please enter valid information or conversation')\n  }\n\n  // Check if conversation is too long for GPT to handle in one call\n  if (conversation.split(' ').length > CONVERSATION_WORD_LIMIT) {\n    throw new Error(`\n      Not able to review the conversation because it exceeds the \n      word limit of ${CONVERSATION_WORD_LIMIT} (${conversation.split(' ').length} words)\n    `)\n  }\n\n  // Replace discord message urls with their actual message content\n  const noURLconversation = await replaceMessageUrls(discordClient, conversation)\n\n  // Get Repository labels + definitions for auto-labeling\n  const labels = await getRepositoryLabels(await octokit, OWNER, REPO)\n\n  // Send all to chat GPT\n  const completion = await openai.createChatCompletion({\n    messages: [\n      { role: 'system', content: AlfredRolePrompt },\n      { role: 'system', content: PreConversationPrompt },\n      { role: 'user', content: noURLconversation },\n      { role: 'system', content: TicketRulesPrompt },\n      { role: 'system', content: LabelsPrompt },\n      { role: 'system', content: labels },\n    ],\n    ...openAISettings,\n  } as any)\n  const alfredResponse = completion.data.choices[0].message?.content.toString()\n", "  if (alfredResponse) {\n    return JSON.parse(alfredResponse) as AlfredResponse\n  }\n  throw new Error('GPT response is unfortunately empty. Troubled servers perhaps?')\n}\n\n// Build command\nconst generateTicketCommandData = new SlashCommandBuilder()\n  .setName('create-issue-ai')\n  .setDescription('Alfred will read conversation and create a ticket')\n  .addStringOption((option) => option\n    .setName('first_message')\n    .setDescription('URL of the first message Alfred should start from')\n    .setRequired(true))\n\n// Command to generate a GitHub Ticket\nexport default {\n  data: generateTicketCommandData,\n  execute: async (discordClient: Client, interaction: ChatInputCommandInteraction) => {\n    let questionCount: number = 0 // Number of questions alfred asks\n    let responseThread: ThreadChannel | undefined\n\n    // Get the first message to start from (the Original Post)\n    const op = await getMessageFromURL(discordClient, interaction.options.getString('first_message'))\n\n    // Find the channel where the conversation took place\n    const channel = await discordClient.channels.cache.get(interaction.channelId)\n", "    if (channel && channel.isTextBased()) {\n      // Start the conversation with the OP\n      let conversation = addConversation(op)\n\n      // Fetch the messages in the channel after OP and concatenate them\n      const messages = await channel.messages.fetch({ after: op.id })\n      messages.reverse().forEach((message: Message<true> | Message<false>) => {\n        conversation += addConversation(message)\n      })\n\n      // Pass the messages from Discord to GPT model to create a response\n      let alfredResponse = await generateAlfredResponse(discordClient, conversation)\n\n      // If additional information is required from the user, Alfred will ask some questions to\n      // the user before creating the ticket, up to a point. To not pollute main channels,\n      // Alfred will create a thread to inquire further information.", "      while (alfredResponse.response_to_user !== 'I have all the information needed!' && questionCount < COUNT_QUESTION_LIMIT) {\n        await replyOrFollowup(\n          interaction,\n          questionCount > 1,\n          {\n            ephemeral: true,\n            content: `${mentionUser(interaction.user.id)} ${alfredResponse.response_to_user}`,\n          },\n          responseThread,\n        )\n\n        // Listen for user response in channel or thread\n        const responseMessage = await waitForUserResponse(\n          interaction.user.id,\n          USER_RESPONSE_COUNT_LIMIT,\n          TIMEOUT_WAITING_FOR_RESPONSE_LIMIT,\n          channel,\n          responseThread,\n        )\n", "        if (!responseMessage || responseMessage.size === 0) {\n          throw new Error('The waiting period for the response has timed out.')\n        }\n\n        // Append new response from user to conversation sent to GPT\n        conversation += `Alfred (you): ${alfredResponse.response_to_user}\\n`\n        conversation += addConversation(responseMessage?.first()!)\n        alfredResponse = await generateAlfredResponse(discordClient, conversation)\n\n        // Will make a thread for remaining interactions\n        if (!responseThread) {\n          responseThread = await responseMessage.last()?.startThread({\n            name: 'Alfred inquiries',\n            autoArchiveDuration: 60, // in minutes\n          })\n        }\n\n        questionCount += 1\n      }\n\n      // Create github ticket using alfred's response\n      const url = await createIssue(\n        await octokit,\n        OWNER,\n        REPO,\n        alfredResponse.title,\n        alfredResponse.body,\n        alfredResponse.labels,\n      )\n\n      await replyOrFollowup(\n        interaction,\n        questionCount > 1,\n        {\n          ephemeral: true,\n          content:\n            `**${alfredResponse.title}**\\n`\n            + `:link: ${url}\\n`\n            + `:label: ${alfredResponse.labels}\\n`\n            + `\\`\\`\\`${alfredResponse.body}\\`\\`\\``,\n        },\n        responseThread,\n      )\n    }\n  },\n}\n", "        if (!responseThread) {\n          responseThread = await responseMessage.last()?.startThread({\n            name: 'Alfred inquiries',\n            autoArchiveDuration: 60, // in minutes\n          })\n        }\n\n        questionCount += 1\n      }\n\n      // Create github ticket using alfred's response\n      const url = await createIssue(\n        await octokit,\n        OWNER,\n        REPO,\n        alfredResponse.title,\n        alfredResponse.body,\n        alfredResponse.labels,\n      )\n\n      await replyOrFollowup(\n        interaction,\n        questionCount > 1,\n        {\n          ephemeral: true,\n          content:\n            `**${alfredResponse.title}**\\n`\n            + `:link: ${url}\\n`\n            + `:label: ${alfredResponse.labels}\\n`\n            + `\\`\\`\\`${alfredResponse.body}\\`\\`\\``,\n        },\n        responseThread,\n      )\n    }\n  },\n}\n"]}
{"filename": "src/listeners/ready.ts", "chunked_list": ["import { Client } from 'discord.js'\nimport Commands from '../Commands'\n\n// Check if the client is in a ready state\nexport default (client: Client): void => {\n  client.on('ready', async () => {\n    if (!client.user || !client.application) {\n      return\n    }\n\n    await client.application.commands.set(Commands.map((command) => command.data.toJSON()))\n    console.log(`${client.user.username} is online`)\n  })\n}\n"]}
{"filename": "src/listeners/interactionCreate.ts", "chunked_list": ["import { CommandInteraction, Client, Interaction } from 'discord.js'\nimport Commands from '../Commands'\nimport safeExecute from '../utils/commands'\n\n// Slash command validation\nconst handleSlashCommand = async (\n  client: Client,\n  interaction: CommandInteraction,\n): Promise<void> => {\n  const slashCommand = Commands.find((c) => c.data.name === interaction.commandName)\n  if (!slashCommand) {\n    interaction.followUp({ content: 'Hm, I do not understand this command.' })\n    return\n  }\n\n  await interaction.deferReply()\n  safeExecute(slashCommand, client, interaction)\n}\n\n// Check if the message is a bot command\nexport default (client: Client): void => {\n  client.on('interactionCreate', async (interaction: Interaction) => {", "): Promise<void> => {\n  const slashCommand = Commands.find((c) => c.data.name === interaction.commandName)\n  if (!slashCommand) {\n    interaction.followUp({ content: 'Hm, I do not understand this command.' })\n    return\n  }\n\n  await interaction.deferReply()\n  safeExecute(slashCommand, client, interaction)\n}\n\n// Check if the message is a bot command\nexport default (client: Client): void => {\n  client.on('interactionCreate', async (interaction: Interaction) => {", "    if (interaction.isCommand() || interaction.isContextMenuCommand()) {\n      await handleSlashCommand(client, interaction)\n    }\n  })\n}\n"]}
{"filename": "src/utils/config.ts", "chunked_list": ["// Get environment variables and enforces they aren't missing\nexport default (key: string): string => {\n  const param = process.env[key]\n  if (!param || param === '' || param === '0') {\n    throw new Error(\n      `${key} is missing from your env file or is invalid.`,\n    )\n  }\n  return param\n}\n"]}
{"filename": "src/utils/commands.ts", "chunked_list": ["import { Client, CommandInteraction } from 'discord.js'\nimport { Command } from '../types/Command'\n\nexport default async function safeExecute(\n  command: Command,\n  client: Client,\n  interaction: CommandInteraction,\n) {\n  try {\n    await command.execute(client, interaction)\n  } catch (error) {\n    console.error(`Error while executing command ${command.data.name}:`, error)\n\n    await interaction.followUp({\n      content:\n       ':pensive: *I am terribly sorry, but it seems I\\'ve run into some trouble:*\\n'\n       + `:red_circle: **${error}**`,\n      ephemeral: true,\n    })\n  }\n}\n", "  try {\n    await command.execute(client, interaction)\n  } catch (error) {\n    console.error(`Error while executing command ${command.data.name}:`, error)\n\n    await interaction.followUp({\n      content:\n       ':pensive: *I am terribly sorry, but it seems I\\'ve run into some trouble:*\\n'\n       + `:red_circle: **${error}**`,\n      ephemeral: true,\n    })\n  }\n}\n"]}
{"filename": "src/utils/discord.ts", "chunked_list": ["import {\n  ChatInputCommandInteraction,\n  Client,\n  Collection,\n  InteractionReplyOptions,\n  Message,\n  TextBasedChannel,\n  ThreadChannel,\n} from 'discord.js'\n", "} from 'discord.js'\n\n// Regex for discord messages\n// e.g. https://discord.com/channels/1095842976/10969358/11023650\nconst messageUrlRegex = /https:\\/\\/discord\\.com\\/channels\\/(\\d+)\\/(\\d+)\\/(\\d+)/\n\n// Will get the message from a discord message URL\nexport async function getMessageFromURL(client: Client, url: string | null) {\n  if (!url) throw new Error(\"Message URL can't be undefined\")\n\n  const matches = url.match(messageUrlRegex)\n", "  if (!url) throw new Error(\"Message URL can't be undefined\")\n\n  const matches = url.match(messageUrlRegex)\n\n  if (!matches) {\n    throw new Error('Invalid message URL. Expected discord/guild_id/channel_id/message_id')\n  }\n\n  const [, guildId, channelId, messageId] = matches\n\n  const guild = await client.guilds.cache.get(guildId)", "  if (!guild) throw new Error('Server not found')\n\n  const channel = await guild.channels.cache.get(channelId)\n  if (!channel) throw new Error('Channel not found')\n  if (!channel.isTextBased()) throw new Error('Channel is not text based')\n\n  const message = await channel.messages.fetch(messageId)\n  if (!message) throw new Error('Message not found')\n\n  return message\n}\n\n// Replace all discord message URLs with their actual message content", "export async function replaceMessageUrls(client: Client, conversation: string): Promise<string> {\n  const replacer = async (match: string) => {\n    const message = await getMessageFromURL(client, match)\n    return message.content\n  }\n\n  // Handle all message fetching in parallel\n  async function replaceAsync(str: string, regex: RegExp, asyncFn: Function): Promise<string> {\n    const globalRegex = new RegExp(regex.source, `${regex.flags}g`)\n    const matches = Array.from(str.matchAll(globalRegex))\n    const replacements = await Promise.all(matches.map((match) => asyncFn(match[0])))\n    return matches.reduce((result, match, i) => result.replace(match[0], `(((reference to an other message: ${replacements[i]})))`), str)\n  }\n\n  // Return conversation with replaced URLs\n  const replacedConversation = await replaceAsync(conversation, messageUrlRegex, replacer)\n  return replacedConversation\n}\n\n// To mention users in reply messages", "export function mentionUser(userID: string) {\n  return `<@${userID}>`\n}\n\n// Logic to simplify whether to use a reply or followup message\nexport async function replyOrFollowup(\n  interaction: ChatInputCommandInteraction,\n  isReply: boolean,\n  reply: InteractionReplyOptions,\n  thread?: ThreadChannel,\n) {\n  // If in a thread, always just send message", "  if (thread) {\n    thread.send(reply.content!)\n  } else {\n    (isReply ? interaction.deferReply : interaction.followUp).bind(interaction)(reply)\n  }\n}\n\nexport async function waitForUserResponse(\n  userID: string, // User ID\n  max: number, // Maximum number of responses\n  time: number, // How long Alfred waits for\n  channel: TextBasedChannel,\n  thread?: ThreadChannel,\n): Promise<Collection<string, Message>> {\n  const filter = (m: any) => m.author.id === userID\n\n  // Custom timeout promise to be used when the thread is not defined, so it doesn't blow up\n  const timeoutPromise = new Promise<Collection<string, Message>>(\n    // eslint-disable-next-line no-promise-executor-return\n    (resolve) => setTimeout(() => resolve(new Collection()), time + 1000),\n  )\n\n  // Listeners\n  const threadPromise = thread ? thread.awaitMessages({ filter, max, time }) : timeoutPromise\n  const channelPromise = channel.awaitMessages({ filter, max, time })\n\n  // Listen to both channel and thread in parallel and return the first reply in either\n  return Promise.race([channelPromise, threadPromise])\n}\n"]}
{"filename": "src/utils/openai.ts", "chunked_list": ["import { Collection, Message } from 'discord.js'\n\nexport function addConversation(msg: Message) {\n  const attachments = msg.attachments.map((att) => att.url)\n  return `${msg.author.username}: ${msg.content} `\n    + `${attachments.length > 0 ? `[ATTACHMENTS: ${attachments}]` : ''}]\\n`\n}\n\nexport function stackConversation(\n  msgs: Collection<string, Message<true>> | Collection<string, Message<false>>,\n) {\n  let conversation = ''\n  msgs.reverse().forEach((message: Message<true> | Message<false>) => {\n    conversation += addConversation(message)\n  })\n  return conversation\n}\n", "export function stackConversation(\n  msgs: Collection<string, Message<true>> | Collection<string, Message<false>>,\n) {\n  let conversation = ''\n  msgs.reverse().forEach((message: Message<true> | Message<false>) => {\n    conversation += addConversation(message)\n  })\n  return conversation\n}\n"]}
{"filename": "src/utils/github.ts", "chunked_list": ["import { createAppAuth } from '@octokit/auth-app'\nimport { Octokit } from '@octokit/rest'\nimport { AlfredGithubConfig } from '../types/AlfredGithubConfig'\n\n// Will create an octokit isntance based on Alfred's configuration\nexport async function getOctokit(config: AlfredGithubConfig): Promise<Octokit> {\n  // Deconstruct config\n  const { installationId, ...options } = config\n\n  // Get auth for app\n  const auth = createAppAuth(options)\n\n  // Retrieve installation access token\n  const installationAuthentication = await auth({\n    type: 'installation',\n    installationId,\n  })\n\n  // Return ocktokit for specific app installation\n  return new Octokit({\n    auth: installationAuthentication.token,\n  })\n}\n\n// Will create an issue in specified repository", "export async function createIssue(\n  octokit: Octokit, // Octokit instance for that specific app installation\n  owner: string, // Owner of the repository\n  repo: string, // Name of the repository\n  title: string, // Issue title\n  body: string, // Content of the issue\n  labels?: string[], // Labels to assign to the issue\n): Promise<string> {\n  try {\n    const resp = await octokit.issues.create({\n      owner,\n      repo,\n      title,\n      body,\n      labels,\n    })\n    return resp.data.html_url", "  try {\n    const resp = await octokit.issues.create({\n      owner,\n      repo,\n      title,\n      body,\n      labels,\n    })\n    return resp.data.html_url\n  } catch (error) {\n    console.error('Error creating issue:', error)\n    throw new Error(`Failed to create issue: ${error}`)\n  }\n}\n\n// Will get the labels and their descriptions for a given repository", "  } catch (error) {\n    console.error('Error creating issue:', error)\n    throw new Error(`Failed to create issue: ${error}`)\n  }\n}\n\n// Will get the labels and their descriptions for a given repository\nexport async function getRepositoryLabels(\n  octokit: Octokit, // Octokit instance for that specific app installation\n  owner: string, // Owner of the repository\n  repo: string, // Name of the repository\n): Promise<string> {", "  try {\n    const response = await octokit.issues.listLabelsForRepo({\n      owner,\n      repo,\n      per_page: 200,\n    })\n    const labels = response.data\n\n    // Build a string with all labels\n    let labelsString = ''\n    labels.forEach((label) => {\n      labelsString += `${label.name}: ${label.description} \\n`\n    })\n\n    return labelsString", "  } catch (error) {\n    console.error(\"Error fetching repo's labels:\", error)\n    throw new Error(`Error fetching repo's labels: ${error}`)\n  }\n}\n"]}
{"filename": "src/config/config.ts", "chunked_list": ["import dotenv from 'dotenv'\nimport getEnvParameter from '../utils/config'\n\ndotenv.config()\n\n// Discord bot token\nexport const DISCORD_BOT_TOKEN = getEnvParameter('DISCORD_BOT_TOKEN')\n\n// OpenAI GPT-4 API key\nexport const GPT_API_KEY = getEnvParameter('GPT_API_KEY')", "// OpenAI GPT-4 API key\nexport const GPT_API_KEY = getEnvParameter('GPT_API_KEY')\n\n// Github configs\nconst ALFRED_GIT_APP_ID = Number(getEnvParameter('ALFRED_GIT_APP_ID'))\nconst ALFRED_GIT_CLIENT_ID = getEnvParameter('ALFRED_GIT_CLIENT_ID')\nconst ALFRED_GIT_INSTALLATION_ID = Number(getEnvParameter('ALFRED_GIT_INSTALLATION_ID'))\nconst ALFRED_GIT_CLIENT_SECRET = getEnvParameter('ALFRED_GIT_CLIENT_SECRET')\nconst ALFRED_GIT_PK = getEnvParameter('ALFRED_GIT_PK')\n", "const ALFRED_GIT_PK = getEnvParameter('ALFRED_GIT_PK')\n\nexport const AlfredGithubConfig = {\n  appId: ALFRED_GIT_APP_ID,\n  installationId: ALFRED_GIT_INSTALLATION_ID,\n  clientID: ALFRED_GIT_CLIENT_ID,\n  clientSecret: ALFRED_GIT_CLIENT_SECRET,\n  privateKey: ALFRED_GIT_PK,\n}\n", "}\n"]}
{"filename": "src/config/openAISettings.ts", "chunked_list": ["export default {\n  model: 'gpt-4',\n  temperature: 0.5,\n  max_tokens: 1000,\n}\n"]}
{"filename": "src/prompts/TicketRulesPrompt.ts", "chunked_list": ["export default\n`\n\nNow that you have the conversation, you will reply based on the following rules:\n\nYou will respond in only a RFC8259 compliant JSON response following this format without deviation. The format is composed of the issue summary, issue title, the issue body, the issue's labels and the response to the user who requested a ticket.\n\nIf the issue you are creating is a bug or problem, you will use the following JSON RFC8259 template: \n{\n  \"title\": \"Give a title that summarizes the problem\",\"body\": \"# Problem statement\\nGive a problem statement that summarizes the issues outlined in the conversation. Describe the problem.\\n\\n# Solution\\nDescribe the desired solution agreed upon in the conversation input. You can also propose a solution, but make it clear that it's YOUR proposed solution by starting with '**\ud83c\udfa9Alfred:**'.\\n\\n#QA Process\\nSummarize how a QA should test that the solution solves the problem\\n\\n# Additional Context\\nAdd any additional context you think would help resolve the issue.\", \"labels\": [\"Some label\"], \"response_to_user\": \"If there is insufficient information, unclear details, if the conversation is too general / generic or if there is confusion you don't know how to resolve, ask questions to the user. Otherwise, reply in a json format and reply EXACTLY with 'I have all the information needed!'\"", "{\n  \"title\": \"Give a title that summarizes the problem\",\"body\": \"# Problem statement\\nGive a problem statement that summarizes the issues outlined in the conversation. Describe the problem.\\n\\n# Solution\\nDescribe the desired solution agreed upon in the conversation input. You can also propose a solution, but make it clear that it's YOUR proposed solution by starting with '**\ud83c\udfa9Alfred:**'.\\n\\n#QA Process\\nSummarize how a QA should test that the solution solves the problem\\n\\n# Additional Context\\nAdd any additional context you think would help resolve the issue.\", \"labels\": [\"Some label\"], \"response_to_user\": \"If there is insufficient information, unclear details, if the conversation is too general / generic or if there is confusion you don't know how to resolve, ask questions to the user. Otherwise, reply in a json format and reply EXACTLY with 'I have all the information needed!'\"\n}\n\nElse if it's a feature request. enhancement or task to do, you will use the following JSON RFC8259 template:\n{\n  \"title\": \"Give a title that summarizes the ticket\",\"body\": \"Start with a high level summary of the conversation and what needs to be done.\\n\\n# Specification\\nDescribe what needs to be done.\\n\\n# Rationale\\nSummarize why this needs to be done\\n\\n# Additional Context\\nAdd any additional context you think is relevant to help people complete the task.\", \"labels\": [\"Some label\"], \"response_to_user\": \"If there is insufficient information, unclear details, if the conversation is too general / generic or if there is confusion you don't know how to resolve, ask questions to the user. Otherwise, reply in a json format and reply EXACTLY with 'I have all the information needed!'\"\n}\n\nYou will also follow these requirements:", "\nYou will also follow these requirements:\n- Be as consice as possible without losing information\n- Some messages may contain attachments. If they do, they will end with [ATTACHMENTS array_of_urls]. Embed all images in a new section called # Images at the end of the issue's body.\n- Don't hesitate to ask for further information if you believe it could lead to you writing a better ticket\n- VERY IMPORTANT: ONLY RETURN A RFC8259 compliant JSON AS A RESPONSE THAT CAN BE DIRECTLY PARSED, NOTHING ELSE. \n- Only add new lines (\"\\\\n\") within the body field of your response\n`\n", ""]}
{"filename": "src/prompts/LabelsPrompt.ts", "chunked_list": ["export default\n`\n\nAs for which label to assign in the 'labels' field of the JSON, please ONLY add labels present in the list below. Each label is accompanied with a description of what the label is for. \nAdd only the most relevant labels and if you aren't sure if a label is appropriate, don't add it.\nHere's the list of labels you can choose from;\n\n`\n", ""]}
{"filename": "src/prompts/PreConversationPrompt.ts", "chunked_list": ["export default\n`\n\nNow that you have the full context and directives, here's the conversation:\n\n`\n"]}
{"filename": "src/prompts/AlfredRolePrompt.ts", "chunked_list": ["export default\n`\n\nYou are Alfred, a gentle butler that help people create github tickets.\nYou will like a product manager, but with the personality of a kind and refined butler.\nI will give you a conversation between colleagues at a company.\nYou will create a github issue based on this conversation.\nThe GitHub ticket should contain all the necessary information for a developer, a product manager or a quality assurance tester to understand the feature request or bug report.\n`\n", "`\n"]}
{"filename": "src/types/AlfredResponse.ts", "chunked_list": ["export interface AlfredResponse {\n  title: string, // Issue title\n  body: string, // Content of issue\n  labels: string[], // Labels assigned to issue\n  response_to_user: string // Alfred's response to user\n}\n"]}
{"filename": "src/types/Command.ts", "chunked_list": ["import { SlashCommandBuilder, CommandInteraction, Client } from 'discord.js'\n\nexport interface Command {\n  data: SlashCommandBuilder;\n  execute: (client: Client, interaction: CommandInteraction) => Promise<void> ;\n}\n"]}
{"filename": "src/types/AlfredGithubConfig.ts", "chunked_list": ["export interface AlfredGithubConfig {\n  appId: number,\n  installationId: number,\n  clientID: string,\n  clientSecret: string,\n  privateKey: string\n}\n"]}
