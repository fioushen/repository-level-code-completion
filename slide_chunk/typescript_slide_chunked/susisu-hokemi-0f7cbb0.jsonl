{"filename": "examples/classes.ts", "chunked_list": ["import type { Component, Mixed } from \"@susisu/hokemi\";\nimport { impl, mixer } from \"@susisu/hokemi\";\n\n// 1. Declare components\n\nexport interface Clock {\n  getTime(): number;\n}\nexport type ClockComponent = Component<\"clock\", Clock>;\n\nexport interface Random {\n  getRandom(): number;\n}", "export type ClockComponent = Component<\"clock\", Clock>;\n\nexport interface Random {\n  getRandom(): number;\n}\nexport type RandomComponent = Component<\"random\", Random>;\n\nexport interface MyService {\n  getTimeAndRandom(): [number, number];\n}\nexport type MyServiceComponent = Component<\"myService\", MyService>;\n\n// 2. Implement components\n", "export type MyServiceComponent = Component<\"myService\", MyService>;\n\n// 2. Implement components\n\nclass ClockImpl implements Clock {\n  getTime(): number {\n    return Date.now();\n  }\n}\nexport const clockImpl = impl<ClockComponent>(\"clock\", ClockImpl);\n", "class RandomImpl implements Random {\n  getRandom(): number {\n    return Math.random();\n  }\n}\nexport const randomImpl = impl<RandomComponent>(\"random\", RandomImpl);\n\nclass MyServiceImpl implements MyService {\n  private clock: Clock;\n  private random: Random;\n\n  constructor({ clock, random }: Mixed<[ClockComponent, RandomComponent]>) {\n    this.clock = clock;\n    this.random = random;\n  }\n\n  getTimeAndRandom(): [number, number] {\n    return [this.clock.getTime(), this.random.getRandom()];\n  }\n}\nexport const myServiceImpl = impl<MyServiceComponent, [ClockComponent, RandomComponent]>(\n  \"myService\",\n  MyServiceImpl\n);\n\n// 3. Mix implementations and create an instance\n\nconst app = mixer(myServiceImpl, clockImpl, randomImpl).new();\nconsole.log(app.myService.getTimeAndRandom());\n"]}
{"filename": "examples/basic.ts", "chunked_list": ["import type { Component } from \"@susisu/hokemi\";\nimport { impl, mixer } from \"@susisu/hokemi\";\n\n// 1. Declare components\n\nexport type Clock = {\n  getTime: () => number;\n};\nexport type ClockComponent = Component<\"clock\", Clock>;\n\nexport type Random = {\n  getRandom: () => number;\n};", "export type ClockComponent = Component<\"clock\", Clock>;\n\nexport type Random = {\n  getRandom: () => number;\n};\nexport type RandomComponent = Component<\"random\", Random>;\n\nexport type MyService = {\n  getTimeAndRandom: () => [number, number];\n};\nexport type MyServiceComponent = Component<\"myService\", MyService>;\n\n// 2. Implement components\n\nexport const clockImpl = impl<ClockComponent>(\"clock\", () => ({\n  getTime: () => Date.now(),\n}));\n\nexport const randomImpl = impl<RandomComponent>(\"random\", () => ({\n  getRandom: () => Math.random(),\n}));\n\nexport const myServiceImpl = impl<MyServiceComponent, [ClockComponent, RandomComponent]>(\n  \"myService\",\n  ({ clock, random }) => ({\n    getTimeAndRandom: () => [clock.getTime(), random.getRandom()],\n  })\n);\n\n// 3. Mix implementations and create an instance\n\nconst app = mixer(myServiceImpl, clockImpl, randomImpl).new();\nconsole.log(app.myService.getTimeAndRandom());\n", "export type MyServiceComponent = Component<\"myService\", MyService>;\n\n// 2. Implement components\n\nexport const clockImpl = impl<ClockComponent>(\"clock\", () => ({\n  getTime: () => Date.now(),\n}));\n\nexport const randomImpl = impl<RandomComponent>(\"random\", () => ({\n  getRandom: () => Math.random(),\n}));\n\nexport const myServiceImpl = impl<MyServiceComponent, [ClockComponent, RandomComponent]>(\n  \"myService\",\n  ({ clock, random }) => ({\n    getTimeAndRandom: () => [clock.getTime(), random.getRandom()],\n  })\n);\n\n// 3. Mix implementations and create an instance\n\nconst app = mixer(myServiceImpl, clockImpl, randomImpl).new();\nconsole.log(app.myService.getTimeAndRandom());\n"]}
{"filename": "src/provider.ts", "chunked_list": ["import type { AbstractComponent, Component, Mixed } from \"./component\";\n\n/**\n * `Provider<N, T, D>` represents a component provider.\n * @param N The name of the component.\n * @param T The type of the provided instance.\n * @param D The type of the dependencies.\n */\nexport type Provider<N extends string, T extends unknown, D extends unknown> = Readonly<{\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __type: \"hokemi.type.Provider\";\n  name: N;\n  factory: Factory<T, D>;\n}>;\n", "export type Provider<N extends string, T extends unknown, D extends unknown> = Readonly<{\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __type: \"hokemi.type.Provider\";\n  name: N;\n  factory: Factory<T, D>;\n}>;\n\nexport type Factory<T extends unknown, D extends unknown> =\n  | FactoryFunction<T, D>\n  | FactoryClass<T, D>;\nexport type FactoryFunction<T extends unknown, D extends unknown> = (deps: D) => T;", "export type FactoryFunction<T extends unknown, D extends unknown> = (deps: D) => T;\nexport type FactoryClass<T extends unknown, D extends unknown> = new (deps: D) => T;\n\nexport function invokecFactory<T extends unknown, D extends unknown>(\n  factory: Factory<T, D>,\n  deps: D\n): T {\n  // check if the factory is a class (not a perfect check though)\n  const desc = Object.getOwnPropertyDescriptor(factory, \"prototype\");\n  if (desc && !desc.writable) {\n    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n    return new (factory as FactoryClass<T, D>)(deps);\n  } else {\n    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n    return (factory as FactoryFunction<T, D>)(deps);\n  }\n}\n\n/**\n * The upper bound of provider types.\n */", "  if (desc && !desc.writable) {\n    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n    return new (factory as FactoryClass<T, D>)(deps);\n  } else {\n    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n    return (factory as FactoryFunction<T, D>)(deps);\n  }\n}\n\n/**\n * The upper bound of provider types.\n */", "export type AbstractProvider = Provider<string, unknown, never>;\n\nexport type ProviderName<P extends AbstractProvider> = P extends Provider<infer N, unknown, never>\n  ? N\n  : never;\n\nexport type ProviderDependencies<P extends AbstractProvider> = (\n  P extends Provider<string, unknown, infer D> ? (deps: D) => unknown : never\n) extends (deps: infer I) => unknown\n  ? I\n  : never;\n", "export type ReconstructComponent<P extends AbstractProvider> = P extends Provider<\n  infer N,\n  infer T,\n  never\n>\n  ? Component<N, T>\n  : never;\n\nexport type MixedProvidedInstance<Ps extends AbstractProvider[]> = Mixed<{\n  [K in keyof Ps]: ReconstructComponent<Ps[K]>;\n}>;\n\n/**", "export type MixedProvidedInstance<Ps extends AbstractProvider[]> = Mixed<{\n  [K in keyof Ps]: ReconstructComponent<Ps[K]>;\n}>;\n\n/**\n * Returns the provider type that implements a component.\n * @param C A component.\n * @param Ds A list of dependencies.\n */\nexport type Impl<\n  C extends AbstractComponent,\n  Ds extends AbstractComponent[] = [],\n> = C extends Component<infer N, infer T> ? Provider<N, T, Mixed<Ds>> : never;\n", "export type Impl<\n  C extends AbstractComponent,\n  Ds extends AbstractComponent[] = [],\n> = C extends Component<infer N, infer T> ? Provider<N, T, Mixed<Ds>> : never;\n\nexport type ImplArgs<C extends AbstractComponent, Ds extends AbstractComponent[] = []> = _ImplArgs<\n  Impl<C, Ds>\n>;\ntype _ImplArgs<P extends AbstractProvider> = P extends Provider<infer N, infer T, infer D>\n  ? [name: N, factory: Factory<T, D>]\n  : never;\n\n/**\n * Creates an implementation of a component.\n * @param name The name of the component.", "type _ImplArgs<P extends AbstractProvider> = P extends Provider<infer N, infer T, infer D>\n  ? [name: N, factory: Factory<T, D>]\n  : never;\n\n/**\n * Creates an implementation of a component.\n * @param name The name of the component.\n * @param factory A factory function or class that creates an instance of the component.\n * @returns An implementation (provider) of the component.\n */\nexport function impl<C extends AbstractComponent, Ds extends AbstractComponent[] = []>(\n  ...[name, factory]: ImplArgs<C, Ds>\n): Impl<C, Ds> {\n  const provider: AbstractProvider = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    __type: \"hokemi.type.Provider\",\n    name,\n    factory,\n  };\n  // ImplArgs<C, Ds> and Impl<C, Ds> always have the same shape, so it's safe to cast.\n  // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n  return provider as Impl<C, Ds>;\n}\n", "export function impl<C extends AbstractComponent, Ds extends AbstractComponent[] = []>(\n  ...[name, factory]: ImplArgs<C, Ds>\n): Impl<C, Ds> {\n  const provider: AbstractProvider = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    __type: \"hokemi.type.Provider\",\n    name,\n    factory,\n  };\n  // ImplArgs<C, Ds> and Impl<C, Ds> always have the same shape, so it's safe to cast.\n  // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n  return provider as Impl<C, Ds>;\n}\n"]}
{"filename": "src/provider.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\nimport { assertType } from \"./__tests__/types\";\nimport type { Component } from \"./component\";\nimport type {\n  Factory,\n  Impl,\n  ImplArgs,\n  MixedProvidedInstance,\n  Provider,\n  ProviderDependencies,", "  Provider,\n  ProviderDependencies,\n  ProviderName,\n  ReconstructComponent,\n} from \"./provider\";\nimport { invokecFactory, impl } from \"./provider\";\n\ndescribe(\"invokecFactory\", () => {\n  it(\"calls the argument if it is a function\", () => {\n    type Foo = { getFoo: () => number };\n    const factory = (foo: number): Foo => ({ getFoo: () => foo });\n    const value = invokecFactory(factory, 42);\n    assertType<Equals<typeof value, Foo>>();\n    expect(value.getFoo()).toBe(42);\n  });\n\n  it(\"calls the constructor of the argument if it is a class\", () => {", "  it(\"calls the argument if it is a function\", () => {\n    type Foo = { getFoo: () => number };\n    const factory = (foo: number): Foo => ({ getFoo: () => foo });\n    const value = invokecFactory(factory, 42);\n    assertType<Equals<typeof value, Foo>>();\n    expect(value.getFoo()).toBe(42);\n  });\n\n  it(\"calls the constructor of the argument if it is a class\", () => {\n    const factory = class Foo {\n      private foo: number;\n\n      constructor(foo: number) {\n        this.foo = foo;\n      }\n\n      getFoo(): number {\n        return this.foo;\n      }\n    };\n    const value = invokecFactory(factory, 42);\n    assertType<Equals<typeof value, InstanceType<typeof factory>>>();\n    expect(value.getFoo()).toBe(42);\n  });\n});\n\ndescribe(\"ProviderName\", () => {\n  it(\"returns the name of the provider\", () => {", "    const factory = class Foo {\n      private foo: number;\n\n      constructor(foo: number) {\n        this.foo = foo;\n      }\n\n      getFoo(): number {\n        return this.foo;\n      }\n    };\n    const value = invokecFactory(factory, 42);\n    assertType<Equals<typeof value, InstanceType<typeof factory>>>();\n    expect(value.getFoo()).toBe(42);\n  });\n});\n\ndescribe(\"ProviderName\", () => {\n  it(\"returns the name of the provider\", () => {", "    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    assertType<Equals<ProviderName<FooProvider>, \"foo\">>();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<ProviderName<never>, never>>();\n\n    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    type BarProvider = Provider<\n      \"bar\",\n      { getBar: () => string },\n      { baz: { getBaz: () => boolean } }\n    >;\n    assertType<Equals<ProviderName<FooProvider | BarProvider>, \"foo\" | \"bar\">>();\n  });\n});\n\ndescribe(\"ProviderDependencies\", () => {\n  it(\"returns the dependencies of the provider\", () => {", "    type BarProvider = Provider<\n      \"bar\",\n      { getBar: () => string },\n      { baz: { getBaz: () => boolean } }\n    >;\n    assertType<Equals<ProviderName<FooProvider | BarProvider>, \"foo\" | \"bar\">>();\n  });\n});\n\ndescribe(\"ProviderDependencies\", () => {\n  it(\"returns the dependencies of the provider\", () => {", "    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    assertType<Equals<ProviderDependencies<FooProvider>, { bar: { getBar: () => string } }>>();\n  });\n\n  it(\"returns the intersection of the dependencies of all the union members\", () => {\n    assertType<Equals<ProviderDependencies<never>, unknown>>();\n\n    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    type BarProvider = Provider<\n      \"bar\",\n      { getBar: () => string },\n      { baz: { getBaz: () => boolean } }\n    >;\n    assertType<\n      Equals<\n        ProviderDependencies<FooProvider | BarProvider>,\n        { bar: { getBar: () => string } } & { baz: { getBaz: () => boolean } }\n      >\n    >();\n  });\n});\n\ndescribe(\"ReconstructComponent\", () => {", "    type BarProvider = Provider<\n      \"bar\",\n      { getBar: () => string },\n      { baz: { getBaz: () => boolean } }\n    >;\n    assertType<\n      Equals<\n        ProviderDependencies<FooProvider | BarProvider>,\n        { bar: { getBar: () => string } } & { baz: { getBaz: () => boolean } }\n      >\n    >();\n  });\n});\n\ndescribe(\"ReconstructComponent\", () => {", "  it(\"reconstructs a component type from the provider type\", () => {\n    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    assertType<\n      Equals<ReconstructComponent<FooProvider>, Component<\"foo\", { getFoo: () => number }>>\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<ReconstructComponent<never>, never>>();\n\n    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;", "    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    type BarProvider = Provider<\"bar\", { getBar: () => string }, {}>;\n    assertType<\n      Equals<\n        ReconstructComponent<FooProvider | BarProvider>,\n        Component<\"foo\", { getFoo: () => number }> | Component<\"bar\", { getBar: () => string }>\n      >\n    >();\n  });\n});\n\ndescribe(\"MixedProvidedInstance\", () => {", "  it(\"returns a mixed instance type of the providers\", () => {\n    assertType<Equals<MixedProvidedInstance<[]>, {}>>();\n\n    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    type BarProvider = Provider<\"bar\", { getBar: () => string }, {}>;\n    type BazProvider = Provider<\"baz\", { getBaz: () => boolean }, {}>;\n    assertType<\n      Equals<\n        MixedProvidedInstance<[FooProvider, BarProvider, BazProvider]>,\n        Readonly<{\n          foo: { getFoo: () => number };\n          bar: { getBar: () => string };\n          baz: { getBaz: () => boolean };\n        }>\n      >\n    >();\n", "    type Bar2Provider = Provider<\"bar\", { getBar2: () => string }, {}>;\n    assertType<\n      Equals<\n        MixedProvidedInstance<[FooProvider, BarProvider, BazProvider, Bar2Provider]>,\n        Readonly<{\n          foo: { getFoo: () => number };\n          bar: { getBar2: () => string };\n          baz: { getBaz: () => boolean };\n        }>\n      >\n    >();\n  });\n\n  it(\"distibutes over union members\", () => {", "    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n    type BarProvider = Provider<\"bar\", { getBar: () => string }, {}>;\n    type BazProvider = Provider<\"baz\", { getBaz: () => boolean }, {}>;\n    assertType<\n      Equals<\n        MixedProvidedInstance<[FooProvider, BarProvider] | [BazProvider]>,\n        | Readonly<{\n            foo: { getFoo: () => number };\n            bar: { getBar: () => string };\n          }>\n        | Readonly<{\n            baz: { getBaz: () => boolean };\n          }>\n      >\n    >();\n  });\n});\n\ndescribe(\"Impl\", () => {", "  it(\"returns a provider type that implements the component\", () => {\n    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    assertType<\n      Equals<\n        Impl<FooComponent, [BarComponent, BazComponent]>,\n        Provider<\n          \"foo\",\n          { getFoo: () => number },\n          Readonly<{\n            bar: { getBar: () => string };\n            baz: { getBaz: () => boolean };\n          }>\n        >\n      >\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<Impl<never, [BazComponent]>, never>>();\n", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    assertType<\n      Equals<\n        Impl<FooComponent | BarComponent, [BazComponent]>,\n        | Provider<\"foo\", { getFoo: () => number }, Readonly<{ baz: { getBaz: () => boolean } }>>\n        | Provider<\"bar\", { getBar: () => string }, Readonly<{ baz: { getBaz: () => boolean } }>>\n      >\n    >();\n  });\n});\n\ndescribe(\"ImplArgs\", () => {\n  it(\"returns a tuple that has the same shape of the provider that implements the component\", () => {", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    assertType<\n      Equals<\n        ImplArgs<FooComponent, [BarComponent, BazComponent]>,\n        [\n          \"foo\",\n          Factory<\n            { getFoo: () => number },\n            Readonly<{\n              bar: { getBar: () => string };\n              baz: { getBaz: () => boolean };\n            }>\n          >,\n        ]\n      >\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<ImplArgs<never, [BazComponent]>, never>>();\n", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    assertType<\n      Equals<\n        ImplArgs<FooComponent | BarComponent, [BazComponent]>,\n        | [\"foo\", Factory<{ getFoo: () => number }, Readonly<{ baz: { getBaz: () => boolean } }>>]\n        | [\"bar\", Factory<{ getBar: () => string }, Readonly<{ baz: { getBaz: () => boolean } }>>]\n      >\n    >();\n  });\n});\n\ndescribe(\"impl\", () => {\n  it(\"creates a provider that implements a component\", () => {", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\n    const foo = impl<FooComponent, [BarComponent]>(\"foo\", ({ bar }) => ({\n      getFoo: () => bar.getBar().length,\n    }));\n    assertType<Equals<typeof foo, Impl<FooComponent, [BarComponent]>>>();\n    expect(foo.name).toBe(\"foo\");\n    const value = invokecFactory(foo.factory, {\n      bar: {\n        getBar: () => \"Hello\",\n      },\n    });\n    expect(value.getFoo()).toBe(5);\n  });\n});\n"]}
{"filename": "src/utils.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\nimport { assertType } from \"./__tests__/types\";\nimport type { AsString, IsFiniteString, Merge, OrElse, Prod, Wrap } from \"./utils\";\n\ndescribe(\"IsFiniteString\", () => {\n  it(\"returns true if and only if the type has a finite number of inhabitants\", () => {\n    assertType<Equals<IsFiniteString<never>, true>>();\n\n    assertType<Equals<IsFiniteString<\"foo\">, true>>();\n    assertType<Equals<IsFiniteString<\"foo\" | \"bar\">, true>>();\n\n    assertType<Equals<IsFiniteString<string>, false>>();\n\n    assertType<Equals<IsFiniteString<`x-${string}`>, false>>();\n    assertType<Equals<IsFiniteString<`x-${number}`>, false>>();\n    assertType<Equals<IsFiniteString<`x-${bigint}`>, false>>();\n    assertType<Equals<IsFiniteString<`x-${boolean}`>, true>>();\n\n    assertType<Equals<IsFiniteString<\"foo\" | `x-${string}`>, false>>();\n    assertType<Equals<IsFiniteString<\"foo\" | `x-${number}`>, false>>();\n    assertType<Equals<IsFiniteString<\"foo\" | `x-${bigint}`>, false>>();\n    assertType<Equals<IsFiniteString<\"foo\" | `x-${boolean}`>, true>>();\n  });\n});\n\ndescribe(\"AsString\", () => {\n  it(\"removes non-string components of a type\", () => {\n    assertType<Equals<AsString<never>, never>>();\n    assertType<Equals<AsString<string | number>, string>>();\n    assertType<Equals<AsString<\"foo\" | \"bar\" | 42>, \"foo\" | \"bar\">>();\n  });\n});\n\ndescribe(\"Prod\", () => {", "  it(\"returns the product type of the given tuple type\", () => {\n    assertType<Equals<Prod<[]>, unknown>>();\n    assertType<Equals<Prod<[{ foo: \"foo\" }, { bar: \"bar\" }]>, { foo: \"foo\" } & { bar: \"bar\" }>>();\n    assertType<\n      Equals<\n        Prod<[{ foo: \"foo\" } | { bar: \"bar\" }, { baz: \"baz\" }]>,\n        ({ foo: \"foo\" } | { bar: \"bar\" }) & { baz: \"baz\" }\n      >\n    >();\n    assertType<\n      Equals<\n        Prod<[{ foo: \"foo\" }, { bar: \"bar\" } | { baz: \"baz\" }]>,\n        { foo: \"foo\" } & ({ bar: \"bar\" } | { baz: \"baz\" })\n      >\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<Prod<never>, never>>();\n    assertType<\n      Equals<\n        Prod<[{ foo: \"foo\" }, { bar: \"bar\" }] | [{ baz: \"baz\" }, { qux: \"qux\" }]>,\n        ({ foo: \"foo\" } & { bar: \"bar\" }) | ({ baz: \"baz\" } & { qux: \"qux\" })\n      >\n    >();\n  });\n});\n\ndescribe(\"Merge\", () => {", "  it(\"merges an intersection type into a sinlge type\", () => {\n    assertType<Equals<Merge<{}>, {}>>();\n    assertType<Equals<Merge<{ foo: \"foo\" } & { bar: \"bar\" }>, { foo: \"foo\"; bar: \"bar\" }>>();\n  });\n\n  it(\"keeps the original property modifiers\", () => {\n    assertType<\n      Equals<Merge<{ readonly foo: \"foo\" } & { bar?: \"bar\" }>, { readonly foo: \"foo\"; bar?: \"bar\" }>\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<Merge<never>, never>>();\n    assertType<\n      Equals<\n        Merge<({ foo: \"foo\" } & { bar: \"bar\" }) | ({ baz: \"baz\" } & { qux: \"qux\" })>,\n        { foo: \"foo\"; bar: \"bar\" } | { baz: \"baz\"; qux: \"qux\" }\n      >\n    >();\n  });\n});\n\ndescribe(\"OrElse\", () => {", "  it(\"returns the first type if it is not `never`; otherwise, returns the second type\", () => {\n    assertType<Equals<OrElse<never, \"xxx\">, \"xxx\">>();\n    assertType<Equals<OrElse<\"foo\", \"xxx\">, \"foo\">>();\n    assertType<Equals<OrElse<\"foo\" | \"bar\", \"xxx\">, \"foo\" | \"bar\">>();\n  });\n});\n\ndescribe(\"Wrap\", () => {\n  it(\"returns the type wrapped in a tupple if it is not `never`; otherwise, returns `never`\", () => {\n    assertType<Equals<Wrap<never>, never>>();\n    assertType<Equals<Wrap<\"foo\">, [\"foo\"]>>();\n    assertType<Equals<Wrap<\"foo\" | \"bar\">, [\"foo\" | \"bar\"]>>();\n  });\n});\n", "  it(\"returns the type wrapped in a tupple if it is not `never`; otherwise, returns `never`\", () => {\n    assertType<Equals<Wrap<never>, never>>();\n    assertType<Equals<Wrap<\"foo\">, [\"foo\"]>>();\n    assertType<Equals<Wrap<\"foo\" | \"bar\">, [\"foo\" | \"bar\"]>>();\n  });\n});\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export type IsFiniteString<S extends string> = _IsFiniteString<S> extends true ? true : false;\n// prettier-ignore\ntype _IsFiniteString<S extends string> =\n    string extends S ? false\n  : S extends \"\" ? true\n  : S extends `${infer H}${infer R}` ? (\n      string extends H ? false\n    : `${number}` extends H ? false\n    : `${bigint}` extends H ? false\n    : _IsFiniteString<R>\n  )\n  : never;\n", "export type AsString<T> = T extends string ? T : never;\n\nexport type Prod<Xs extends unknown[]> = Xs extends unknown\n  ? { [K in keyof Xs]: (x: Xs[K]) => unknown }[number] extends (x: infer P) => unknown\n    ? P\n    : never\n  : never;\n\nexport type Merge<T> = { [K in keyof T]: T[K] };\n\nexport type OrElse<T, E> = [T] extends [never] ? E : T;\n", "export type Merge<T> = { [K in keyof T]: T[K] };\n\nexport type OrElse<T, E> = [T] extends [never] ? E : T;\n\nexport type Wrap<T> = [T] extends [never] ? never : [T];\n"]}
{"filename": "src/component.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\nimport { assertType } from \"./__tests__/types\";\nimport type { Component, Instance, Mixed } from \"./component\";\n\ndescribe(\"Instance\", () => {\n  it(\"returns an object type with a property whose name is the component name and whose type is the component type\", () => {\n    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    assertType<Equals<Instance<FooComponent>, Readonly<{ foo: { getFoo: () => number } }>>>();\n  });\n\n  it(\"returns the union type of object types if the component name is a union string\", () => {", "  it(\"returns the union type of object types if the component name is a union string\", () => {\n    type XxxComponent = Component<never, { getXxx: () => number }>;\n    assertType<Equals<Instance<XxxComponent>, never>>();\n\n    type FooComponent = Component<\"foo1\" | \"foo2\", { getFoo: () => number }>;\n    assertType<\n      Equals<\n        Instance<FooComponent>,\n        Readonly<{ foo1: { getFoo: () => number } }> | Readonly<{ foo2: { getFoo: () => number } }>\n      >\n    >();\n  });\n", "  it(\"returns an object type with an optional index signature if the component name is not of a finite string type\", () => {\n    type XxxComponent = Component<string, { getXxx: () => number }>;\n    assertType<\n      Equals<\n        Instance<XxxComponent>,\n        Readonly<{ [key: string]: { getXxx: () => number } | undefined }>\n      >\n    >();\n\n    type YyyComponent = Component<`x-${string}`, { getYyy: () => number }>;\n    assertType<\n      Equals<\n        Instance<YyyComponent>,\n        Readonly<{ [key: `x-${string}`]: { getYyy: () => number } | undefined }>\n      >\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<Instance<never>, never>>();\n", "    type YyyComponent = Component<`x-${string}`, { getYyy: () => number }>;\n    assertType<\n      Equals<\n        Instance<YyyComponent>,\n        Readonly<{ [key: `x-${string}`]: { getYyy: () => number } | undefined }>\n      >\n    >();\n  });\n\n  it(\"distributes over union members\", () => {\n    assertType<Equals<Instance<never>, never>>();\n", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    assertType<\n      Equals<\n        Instance<FooComponent | BarComponent>,\n        Readonly<{ foo: { getFoo: () => number } }> | Readonly<{ bar: { getBar: () => string } }>\n      >\n    >();\n  });\n});\n\ndescribe(\"Mixed\", () => {", "  it(\"returns a mixed instance type of the components\", () => {\n    assertType<Equals<Mixed<[]>, {}>>();\n\n    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    assertType<\n      Equals<\n        Mixed<[FooComponent, BarComponent, BazComponent]>,\n        Readonly<{\n          foo: { getFoo: () => number };\n          bar: { getBar: () => string };\n          baz: { getBaz: () => boolean };\n        }>\n      >\n    >();\n  });\n\n  it(\"overrides previously declared component instances\", () => {", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    type Bar2Component = Component<\"bar\", { getBar2: () => bigint }>;\n    assertType<\n      Equals<\n        Mixed<[FooComponent, BarComponent, BazComponent, Bar2Component]>,\n        Readonly<{\n          foo: { getFoo: () => number };\n          bar: { getBar2: () => bigint };\n          baz: { getBaz: () => boolean };\n        }>\n      >\n    >();\n  });\n\n  it(\"erases all matching component instances before a component with an infinite name\", () => {", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"x-baz\", { getBaz: () => boolean }>;\n    type QuxComponent = Component<\"qux\", { getQux: () => bigint }>;\n    type XxxComponent = Component<string, { getXxx: () => number }>;\n    type YyyComponent = Component<`x-${string}`, { getYyy: () => number }>;\n    assertType<\n      Equals<\n        Mixed<[FooComponent, XxxComponent, BarComponent, BazComponent, YyyComponent, QuxComponent]>,\n        Readonly<{\n          bar: { getBar: () => string };\n          qux: { getQux: () => bigint };\n        }>\n      >\n    >();\n  });\n", "  it(\"returns an empty object type if the input is not a tuple\", () => {\n    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    assertType<Equals<Mixed<FooComponent[]>, {}>>();\n    assertType<Equals<Mixed<[...FooComponent[], BarComponent]>, {}>>();\n    assertType<Equals<Mixed<[FooComponent, ...BarComponent[]]>, {}>>();\n  });\n\n  it(\"distibutes over union members\", () => {\n    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n    assertType<\n      Equals<\n        Mixed<[FooComponent, BarComponent] | [BazComponent]>,\n        | Readonly<{\n            foo: { getFoo: () => number };\n            bar: { getBar: () => string };\n          }>\n        | Readonly<{\n            baz: { getBaz: () => boolean };\n          }>\n      >\n    >();\n  });\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { Component, AbstractComponent, Instance, Mixed } from \"./component\";\nexport { Provider, AbstractProvider, Impl, impl } from \"./provider\";\nexport { Mixer, mixer } from \"./mixer\";\n"]}
{"filename": "src/component.ts", "chunked_list": ["import type { AsString, IsFiniteString, Merge, Prod } from \"./utils\";\n\n/**\n * `Component<N, T>` represents a component.\n * @param N The name of the component.\n * @param T The type of the component instance.\n */\nexport type Component<N extends string, T extends unknown> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __type: \"hokemi.type.Component\";\n  name: N;\n  type: T;\n};\n\n/**\n * The upper bound of component types.\n */", "export type AbstractComponent = Component<string, unknown>;\n\n/**\n * Returns the instance type of a component.\n * @param C A component.\n */\nexport type Instance<C extends AbstractComponent> = C extends Component<infer N, infer T>\n  ? _Instance<N, T>\n  : never;\ntype _Instance<N extends string, T extends unknown> = N extends unknown\n  ? IsFiniteString<N> extends true\n    ? { readonly [N0 in N]: T }\n    : { readonly [N0 in N]?: T }\n  : never;\n\n/**", "type _Instance<N extends string, T extends unknown> = N extends unknown\n  ? IsFiniteString<N> extends true\n    ? { readonly [N0 in N]: T }\n    : { readonly [N0 in N]?: T }\n  : never;\n\n/**\n * Returns the mixed instance type of components.\n * @param Cs Components.\n */\nexport type Mixed<Cs extends AbstractComponent[]> = Merge<Prod<FilteredInstances<Cs, [], never>>>;\n// prettier-ignore", "export type Mixed<Cs extends AbstractComponent[]> = Merge<Prod<FilteredInstances<Cs, [], never>>>;\n// prettier-ignore\ntype FilteredInstances<\n  Cs extends AbstractComponent[],\n  Is extends Array<{}>,\n  K extends string\n> = Cs extends [] ? Is\n  : Cs extends [\n      ...infer Xs extends AbstractComponent[],\n      infer X extends AbstractComponent,\n    ] ? _FilteredInstances<Xs, Is, Instance<X>, K>\n  : [];\n// prettier-ignore", "type _FilteredInstances<\n  Cs extends AbstractComponent[],\n  Is extends Array<{}>,\n  I extends {},\n  K extends string\n> = I extends unknown\n  ? keyof I extends K\n    ? FilteredInstances<Cs, Is, K>\n    : IsFiniteString<AsString<keyof I>> extends true\n      ? FilteredInstances<Cs, [I, ...Is], K | AsString<keyof I>>\n      : FilteredInstances<Cs, Is, K | AsString<keyof I>>\n  : never;\n"]}
{"filename": "src/mixer.ts", "chunked_list": ["import type {\n  AbstractProvider,\n  ProviderDependencies,\n  ProviderName,\n  MixedProvidedInstance,\n} from \"./provider\";\nimport { invokecFactory } from \"./provider\";\nimport type { OrElse, Wrap } from \"./utils\";\n\n/**", "\n/**\n * `Mixer<Ps>` represents a mixer object.\n * @param Ps A list of providers to be mixed.\n */\nexport type Mixer<Ps extends AbstractProvider[]> = Readonly<{\n  /**\n   * Extends the mixer with more providers.\n   * @params providers Additional providers to be mixed.\n   * @returns An extended mixer object.\n   */\n  with: MixerMethodWith<Ps>;\n  /**\n   * Creates a new mixed instance.\n   * @returns A mixed instance.\n   */\n  new: MixerMethodNew<Ps>;\n}>;\n", "type MixerMethodWith<Ps extends AbstractProvider[]> = <Qs extends AbstractProvider[]>(\n  ...providers: Qs\n) => Mixer<[...Ps, ...Qs]>;\n\ntype MixerMethodNew<Ps extends AbstractProvider[]> = MixerError<Ps> extends never\n  ? () => MixedProvidedInstance<Ps>\n  : MixerError<Ps>;\n\ntype MixerError<Ps extends AbstractProvider[]> = {\n  [K in keyof Ps]: PerProviderError<Ps[K], Ps>;\n}[number];\n", "type MixerError<Ps extends AbstractProvider[]> = {\n  [K in keyof Ps]: PerProviderError<Ps[K], Ps>;\n}[number];\n\ntype PerProviderError<\n  P extends AbstractProvider,\n  Ps extends AbstractProvider[],\n> = MixedProvidedInstance<Ps> extends ProviderDependencies<P>\n  ? never\n  : OrElse<\n      MissingDependenciesError<P, Ps> | IncompatibleDependenciesError<P, Ps>,\n      UnknownError<{\n        reason: \"unknown dependency error (this is likely a bug; please file an issue)\";\n        providerName: ProviderName<P>;\n      }>\n    >;\n", "type UnknownError<E extends unknown> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __unknownError?: E;\n};\n\ntype MissingDependenciesError<\n  P extends AbstractProvider,\n  Ps extends AbstractProvider[],\n> = MissingDependencies<P, Ps> extends never\n  ? never\n  : {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      __missingDependenciesError?: {\n        reason: \"some dependencies are missing\";\n        providerName: ProviderName<P>;\n        dependencies: MissingDependencies<P, Ps>;\n      };\n    };", "type MissingDependencies<\n  P extends AbstractProvider,\n  Ps extends AbstractProvider[],\n> = _MissingDependencies<ProviderDependencies<P>, MixedProvidedInstance<Ps>>;\ntype _MissingDependencies<D extends unknown, I extends unknown> = D extends unknown\n  ? Wrap<\n      {\n        [N in keyof D]: N extends keyof I\n          ? never\n          : {\n              name: N;\n              expectedType: D[N];\n            };\n      }[keyof D]\n    >\n  : never;\n", "type IncompatibleDependenciesError<\n  P extends AbstractProvider,\n  Ps extends AbstractProvider[],\n> = IncompatibleDependencies<P, Ps> extends never\n  ? never\n  : {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      __incompatibleDependenciesError?: {\n        reason: \"some dependencies are incompatible\";\n        providerName: ProviderName<P>;\n        dependencies: IncompatibleDependencies<P, Ps>;\n      };\n    };", "type IncompatibleDependencies<\n  P extends AbstractProvider,\n  Ps extends AbstractProvider[],\n> = _IncompatibleDependencies<ProviderDependencies<P>, MixedProvidedInstance<Ps>>;\ntype _IncompatibleDependencies<D extends unknown, I extends unknown> = D extends unknown\n  ? Wrap<\n      {\n        [N in keyof D & keyof I]: I[N] extends D[N]\n          ? never\n          : {\n              name: N;\n              expectedType: D[N];\n              actualType: I[N];\n            };\n      }[keyof D & keyof I]\n    >\n  : never;\n\n/**\n * Creates a new mixer object.\n * @param providers Providers to be mixed.\n * @returns A mixer object.\n */", "export function mixer<Ps extends AbstractProvider[]>(...providers: Ps): Mixer<Ps> {\n  return {\n    with: (...otherProviders) => mixer(...providers, ...otherProviders),\n    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n    new: (() => {\n      const mixed = {};\n\n      const instances = new Map<string, unknown>();\n      const getters = new Map<string, () => unknown>();\n      const lock = new Set<string>();\n", "      for (const { name, factory } of providers) {\n        const getter = (): unknown => {\n          if (instances.has(name)) {\n            return instances.get(name);\n          }\n          if (lock.has(name)) {\n            throw new Error(`'${name}' is referenced during its initialization`);\n          }\n          lock.add(name);\n          // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n          const value = invokecFactory(factory, mixed as never);\n          lock.delete(name);\n          instances.set(name, value);\n          return value;\n        };\n        getters.set(name, getter);\n        Object.defineProperty(mixed, name, {\n          get: getter,\n          configurable: true,\n          enumerable: true,\n        });\n      }\n\n      // instantiate all the components", "      for (const getter of getters.values()) {\n        getter();\n      }\n\n      return mixed;\n    }) as MixerMethodNew<Ps>,\n  };\n}\n"]}
{"filename": "src/mixer.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\nimport { assertType } from \"./__tests__/types\";\nimport type { Component, Mixed } from \"./component\";\nimport type { Mixer } from \"./mixer\";\nimport { mixer } from \"./mixer\";\nimport type { Impl } from \"./provider\";\nimport { impl } from \"./provider\";\n\ndescribe(\"Mixer\", () => {\n  describe(\"new\", () => {", "describe(\"Mixer\", () => {\n  describe(\"new\", () => {\n    /* eslint-disable @typescript-eslint/naming-convention */\n\n    type Foo = { getFoo: () => number };\n    type Bar = { getBar: () => string };\n    type Baz = { getBaz: () => boolean };\n\n    type FooComponent = Component<\"foo\", Foo>;\n    type BarComponent = Component<\"bar\", Bar>;\n    type BazComponent = Component<\"baz\", Baz>;\n\n    it(\"creates an instance if there is no error\", () => {", "    type FooComponent = Component<\"foo\", Foo>;\n    type BarComponent = Component<\"bar\", Bar>;\n    type BazComponent = Component<\"baz\", Baz>;\n\n    it(\"creates an instance if there is no error\", () => {\n      type FooImpl = Impl<FooComponent, [BarComponent, BazComponent]>;\n      type BarImpl = Impl<BarComponent, [BazComponent]>;\n      type BazImpl = Impl<BazComponent>;\n\n      type M = Mixer<[FooImpl, BarImpl, BazImpl]>;\n      assertType<Equals<M[\"new\"], () => Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n    });\n\n    it(\"reports missing dependencies if some dependencies are missing\", () => {", "      type M = Mixer<[FooImpl, BarImpl, BazImpl]>;\n      assertType<Equals<M[\"new\"], () => Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n    });\n\n    it(\"reports missing dependencies if some dependencies are missing\", () => {\n      type FooImpl = Impl<FooComponent, [BarComponent, BazComponent]>;\n      type BarImpl = Impl<BarComponent, [BazComponent]>;\n\n      type M = Mixer<[FooImpl, BarImpl]>;\n      assertType<\n        Equals<\n          M[\"new\"],\n          | {\n              __missingDependenciesError?: {\n                reason: \"some dependencies are missing\";\n                providerName: \"foo\";\n                dependencies: [\n                  {\n                    name: \"baz\";\n                    expectedType: Baz;\n                  },\n                ];\n              };\n            }\n          | {\n              __missingDependenciesError?: {\n                reason: \"some dependencies are missing\";\n                providerName: \"bar\";\n                dependencies: [\n                  {\n                    name: \"baz\";\n                    expectedType: Baz;\n                  },\n                ];\n              };\n            }\n        >\n      >();\n    });\n\n    it(\"reports incompatible dependencies if some dependencies are incompatible\", () => {", "      type M = Mixer<[FooImpl, BarImpl]>;\n      assertType<\n        Equals<\n          M[\"new\"],\n          | {\n              __missingDependenciesError?: {\n                reason: \"some dependencies are missing\";\n                providerName: \"foo\";\n                dependencies: [\n                  {\n                    name: \"baz\";\n                    expectedType: Baz;\n                  },\n                ];\n              };\n            }\n          | {\n              __missingDependenciesError?: {\n                reason: \"some dependencies are missing\";\n                providerName: \"bar\";\n                dependencies: [\n                  {\n                    name: \"baz\";\n                    expectedType: Baz;\n                  },\n                ];\n              };\n            }\n        >\n      >();\n    });\n\n    it(\"reports incompatible dependencies if some dependencies are incompatible\", () => {", "      type FooImpl = Impl<FooComponent, [BarComponent, BazComponent]>;\n      type BarImpl = Impl<BarComponent, [BazComponent]>;\n      type BazImpl = Impl<BazComponent>;\n\n      type Bar2 = { getBar2: () => string };\n      type Bar2Component = Component<\"bar\", Bar2>;\n      type Bar2Impl = Impl<Bar2Component, [BazComponent]>;\n\n      type M = Mixer<[FooImpl, BarImpl, BazImpl, Bar2Impl]>;\n      assertType<\n        Equals<\n          M[\"new\"],\n          {\n            __incompatibleDependenciesError?: {\n              reason: \"some dependencies are incompatible\";\n              providerName: \"foo\";\n              dependencies: [\n                {\n                  name: \"bar\";\n                  expectedType: Bar;\n                  actualType: Bar2;\n                },\n              ];\n            };\n          }\n        >\n      >();\n    });\n\n    it(\"reports missing dependencies if some dependencies are possibly missing\", () => {", "      type M = Mixer<[FooImpl, BarImpl, BazImpl, Bar2Impl]>;\n      assertType<\n        Equals<\n          M[\"new\"],\n          {\n            __incompatibleDependenciesError?: {\n              reason: \"some dependencies are incompatible\";\n              providerName: \"foo\";\n              dependencies: [\n                {\n                  name: \"bar\";\n                  expectedType: Bar;\n                  actualType: Bar2;\n                },\n              ];\n            };\n          }\n        >\n      >();\n    });\n\n    it(\"reports missing dependencies if some dependencies are possibly missing\", () => {", "      type FooImpl = Impl<FooComponent, [BarComponent]>;\n      type BarImpl = Impl<BarComponent>;\n      type BarBazImpl = Impl<BarComponent | BazComponent>;\n\n      type M1 = Mixer<[FooImpl, BarBazImpl]>;\n      assertType<\n        Equals<\n          M1[\"new\"],\n          {\n            __missingDependenciesError?: {\n              reason: \"some dependencies are missing\";\n              providerName: \"foo\";\n              dependencies: [\n                {\n                  name: \"bar\";\n                  expectedType: Bar;\n                },\n              ];\n            };\n          }\n        >\n      >();\n", "      type M2 = Mixer<[FooImpl, BarBazImpl, BarImpl]>;\n      assertType<\n        Equals<M2[\"new\"], () => Mixed<[FooComponent, BarComponent | BazComponent, BarComponent]>>\n      >();\n    });\n\n    it(\"allows creating an instance if any possible combination of dependencies is provided\", () => {\n      type FooImpl = Impl<FooComponent, [BarComponent] | [BazComponent]>;\n      type BarImpl = Impl<BarComponent>;\n      type BazImpl = Impl<BazComponent>;\n", "      type BarImpl = Impl<BarComponent>;\n      type BazImpl = Impl<BazComponent>;\n\n      type M1 = Mixer<[FooImpl]>;\n      assertType<\n        Equals<\n          M1[\"new\"],\n          {\n            __missingDependenciesError?: {\n              reason: \"some dependencies are missing\";\n              providerName: \"foo\";\n              dependencies:\n                | [\n                    {\n                      name: \"bar\";\n                      expectedType: Bar;\n                    },\n                  ]\n                | [\n                    {\n                      name: \"baz\";\n                      expectedType: Baz;\n                    },\n                  ];\n            };\n          }\n        >\n      >();\n", "      type M2 = Mixer<[FooImpl, BarImpl]>;\n      assertType<Equals<M2[\"new\"], () => Mixed<[FooComponent, BarComponent]>>>();\n\n      type M3 = Mixer<[FooImpl, BazImpl]>;\n      assertType<Equals<M3[\"new\"], () => Mixed<[FooComponent, BazComponent]>>>();\n    });\n\n    it(\"reports missing dependencies unless all possible dependencies are provided\", () => {\n      type FooImpl = Impl<FooComponent, [BarComponent]> | Impl<FooComponent, [BazComponent]>;\n      type BarImpl = Impl<BarComponent>;\n      type BazImpl = Impl<BazComponent>;\n", "      type FooImpl = Impl<FooComponent, [BarComponent]> | Impl<FooComponent, [BazComponent]>;\n      type BarImpl = Impl<BarComponent>;\n      type BazImpl = Impl<BazComponent>;\n\n      type M1 = Mixer<[FooImpl]>;\n      assertType<\n        Equals<\n          M1[\"new\"],\n          {\n            __missingDependenciesError?: {\n              reason: \"some dependencies are missing\";\n              providerName: \"foo\";\n              dependencies: [\n                | {\n                    name: \"bar\";\n                    expectedType: Bar;\n                  }\n                | {\n                    name: \"baz\";\n                    expectedType: Baz;\n                  },\n              ];\n            };\n          }\n        >\n      >();\n", "      type M2 = Mixer<[FooImpl, BarImpl]>;\n      assertType<\n        Equals<\n          M2[\"new\"],\n          {\n            __missingDependenciesError?: {\n              reason: \"some dependencies are missing\";\n              providerName: \"foo\";\n              dependencies: [\n                {\n                  name: \"baz\";\n                  expectedType: Baz;\n                },\n              ];\n            };\n          }\n        >\n      >();\n", "      type M3 = Mixer<[FooImpl, BazImpl]>;\n      assertType<\n        Equals<\n          M3[\"new\"],\n          {\n            __missingDependenciesError?: {\n              reason: \"some dependencies are missing\";\n              providerName: \"foo\";\n              dependencies: [\n                {\n                  name: \"bar\";\n                  expectedType: Bar;\n                },\n              ];\n            };\n          }\n        >\n      >();\n", "      type M4 = Mixer<[FooImpl, BarImpl, BazImpl]>;\n      assertType<Equals<M4[\"new\"], () => Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n    });\n\n    /* eslint-enable @typescript-eslint/naming-convention */\n  });\n});\n\ndescribe(\"mixer\", () => {\n  type Foo = { getFoo: () => number };\n  type Bar = { getBar: () => string };", "  type Foo = { getFoo: () => number };\n  type Bar = { getBar: () => string };\n  type Baz = { getBaz: () => boolean };\n\n  type FooComponent = Component<\"foo\", Foo>;\n  type BarComponent = Component<\"bar\", Bar>;\n  type BazComponent = Component<\"baz\", Baz>;\n\n  it(\"mixes components and creates a mixed instance\", () => {\n    const foo = impl<FooComponent, [BarComponent, BazComponent]>(\"foo\", ({ bar, baz }) => ({\n      getFoo: () => (baz.getBaz() ? bar.getBar().length : 42),\n    }));\n    const bar = impl<BarComponent, [BazComponent]>(\"bar\", ({ baz }) => ({\n      getBar: () => (baz.getBaz() ? \"Hello\" : \"Bye\"),\n    }));\n    const baz = impl<BazComponent>(\"baz\", () => ({\n      getBaz: () => true,\n    }));\n\n    const m = mixer(foo, bar, baz);\n    assertType<Equals<typeof m, Mixer<[typeof foo, typeof bar, typeof baz]>>>();\n\n    const mixed = m.new();\n    assertType<Equals<typeof mixed, Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n    expect(mixed.foo.getFoo()).toBe(5);\n  });\n\n  it(\"overrides previous mixed components\", () => {\n    const foo = impl<FooComponent, [BarComponent, BazComponent]>(\"foo\", ({ bar, baz }) => ({\n      getFoo: () => (baz.getBaz() ? bar.getBar().length : 42),\n    }));\n    const bar = impl<BarComponent, [BazComponent]>(\"bar\", ({ baz }) => ({\n      getBar: () => (baz.getBaz() ? \"Hello\" : \"Bye\"),\n    }));\n    const baz = impl<BazComponent>(\"baz\", () => ({\n      getBaz: () => true,\n    }));\n    const baz2 = impl<BazComponent>(\"baz\", () => ({\n      getBaz: () => false,\n    }));\n", "    const m = mixer(foo, bar, baz).with(baz2);\n    assertType<Equals<typeof m, Mixer<[typeof foo, typeof bar, typeof baz, typeof baz2]>>>();\n\n    const mixed = m.new();\n    assertType<Equals<typeof mixed, Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n    expect(mixed.foo.getFoo()).toBe(42);\n  });\n\n  it(\"throws if a component is referenced during its initialization\", () => {\n    // foo and bar reference each other during initialization\n    const foo = impl<FooComponent, [BarComponent]>(\"foo\", ({ bar }) => ({\n      getFoo: () => bar.getBar().length,\n    }));\n    const bar = impl<BarComponent, [FooComponent]>(\"bar\", ({ foo }) => ({\n      getBar: () => foo.getFoo().toString(),\n    }));\n\n    expect(() => {\n      mixer(foo, bar).new();\n    }).toThrow(\"'foo' is referenced during its initialization\");\n  });\n\n  it(\"does not throw if a component is referenced after its initialization, even if there is a circular dependency\", () => {\n    // foo references bar during its initialization, while bar defers referencing foo until it is actually used\n    // (this is not a good example though; it loops forever if you call foo.getFoo() or bar.getBar())\n    const foo = impl<FooComponent, [BarComponent]>(\"foo\", ({ bar }) => ({\n      getFoo: () => bar.getBar().length,\n    }));\n    const bar = impl<BarComponent, [FooComponent]>(\"bar\", deps => ({\n      getBar: () => deps.foo.getFoo().toString(),\n    }));\n\n    expect(() => {\n      mixer(foo, bar).new();\n    }).not.toThrow();\n  });\n\n  it(\"accepts classes as compoent factories\", () => {\n    const foo = impl<FooComponent, [BarComponent, BazComponent]>(\n      \"foo\",", "      class FooImpl {\n        private bar: Bar;\n        private baz: Baz;\n\n        constructor({ bar, baz }: Mixed<[BarComponent, BazComponent]>) {\n          this.bar = bar;\n          this.baz = baz;\n        }\n\n        getFoo(): number {\n          return this.baz.getBaz() ? this.bar.getBar().length : 42;\n        }\n      }\n    );\n    const bar = impl<BarComponent, [BazComponent]>(\n      \"bar\",", "      class BarImpl {\n        private baz: Baz;\n\n        constructor({ baz }: Mixed<[BazComponent]>) {\n          this.baz = baz;\n        }\n\n        getBar(): string {\n          return this.baz.getBaz() ? \"Hello\" : \"Bye\";\n        }\n      }\n    );\n    const baz = impl<BazComponent>(\n      \"baz\",", "      class BazImpl {\n        getBaz(): boolean {\n          return true;\n        }\n      }\n    );\n\n    const m = mixer(foo, bar, baz);\n    assertType<Equals<typeof m, Mixer<[typeof foo, typeof bar, typeof baz]>>>();\n\n    const mixed = m.new();\n    assertType<Equals<typeof mixed, Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n    expect(mixed.foo.getFoo()).toBe(5);\n  });\n});\n"]}
{"filename": "src/__tests__/types.ts", "chunked_list": ["// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function assertType<_T extends true>(): void {}\n\nexport type Equals<T, U> = (<X>() => X extends T ? 1 : 2) extends <X>() => X extends U ? 1 : 2\n  ? true\n  : false;\n"]}
