{"filename": "jest.config.ts", "chunked_list": ["// For a detailed explanation regarding each configuration property, visit:\n// https://jestjs.io/docs/en/configuration.html\nimport { recursive } from 'merge'\nimport mongo from '@shelf/jest-mongodb/jest-preset'\n\nconst config = recursive(mongo, {\n  roots: [\n    '<rootDir>/src/',\n    '<rootDir>/tests/'\n  ],", "    '<rootDir>/tests/'\n  ],\n  clearMocks: true,\n  collectCoverage: true,\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/interfaces/**/*.ts'\n  ],\n  coverageDirectory: 'coverage',", "  ],\n  coverageDirectory: 'coverage',\n  testMatch: [\n    '<rootDir>/tests/**/*.test.ts'\n  ],\n  transform: {\n    '^.+\\\\.(t|j)sx?$': '@swc/jest'\n  },\n  testPathIgnorePatterns: [\n    'node_modules'", "  testPathIgnorePatterns: [\n    'node_modules'\n  ],\n  watchPathIgnorePatterns: [\n    'globalConfig'\n  ]\n})\n\nexport default config\n", "export default config\n"]}
{"filename": "jest-mongodb-config.ts", "chunked_list": ["export default {\n  mongodbMemoryServerOptions: {\n    binary: {\n      skipMD5: true\n    },\n    autoStart: false,\n    instance: {}\n  },\n  useSharedDBForAllJestWorkers: false\n}", "  useSharedDBForAllJestWorkers: false\n}\n"]}
{"filename": "tests/plugin-patch-history-disabled.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\nimport mongoose, { model } from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\nimport History from '../src/models/History'\n\nimport em from '../src/em'\n", "import em from '../src/em'\n\njest.mock('../src/em', () => {\n  return { emit: jest.fn() }\n})\n\ndescribe('plugin - patch history disabled', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {", "\n  UserSchema.plugin(patchHistoryPlugin, {\n    patchHistoryDisabled: true\n  })\n\n  const User = model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })", "    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})", "    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  it('should createHistory', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    user.name = 'Alice'\n    await user.save()", "    user.name = 'Alice'\n    await user.save()\n\n    user.name = 'Bob'\n    await user.save()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    await User.deleteMany({ role: 'user' }).exec()", "\n    await User.deleteMany({ role: 'user' }).exec()\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should omit update of role', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n", "    expect(user.name).toBe('John')\n\n    user.role = 'manager'\n    await user.save()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })", "    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should updateOne', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    await User.updateOne({ _id: user._id }, { name: 'Alice' }).exec()\n\n    const history = await History.find({})", "\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should findOneAndUpdate', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')", "    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    await User.findOneAndUpdate({ _id: user._id }, { name: 'Alice' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })", "    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should update deprecated', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    if (isMongooseLessThan7) {\n      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    } else {\n      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n  })\n\n  it('should updated deprecated with multi flag', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n", "    if (isMongooseLessThan7) {\n      await User.update({ role: 'user' }, { $set: { name: 'Bob' } }, { multi: true }).exec()\n    } else {\n      await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should create many', async () => {\n    await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' }\n    ])\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should findOneAndUpdate upsert', async () => {\n    await User.findOneAndUpdate({ name: 'John', role: 'user' }, { name: 'Bob', role: 'user' }, { upsert: true, runValidators: true }).exec()\n    const documents = await User.find({})\n    expect(documents).toHaveLength(1)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should update many', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n\n    await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n})\n"]}
{"filename": "tests/em.test.ts", "chunked_list": ["import { emitEvent } from '../src/patch'\nimport { patchEventEmitter } from '../src/plugin'\n\ndescribe('em', () => {\n  it('should subscribe and count', async () => {\n    let count = 0\n    const fn = () => {\n      count++\n    }\n    patchEventEmitter.on('test', fn)", "    }\n    patchEventEmitter.on('test', fn)\n    patchEventEmitter.emit('test')\n    expect(count).toBe(1)\n    patchEventEmitter.off('test', fn)\n    patchEventEmitter.emit('test')\n    expect(count).toBe(1)\n  })\n\n  it('emitEvent', async () => {", "\n  it('emitEvent', async () => {\n    const fn = jest.fn()\n    patchEventEmitter.on('test', fn)\n\n    const context = {\n      op: 'test',\n      modelName: 'Test',\n      collectionName: 'tests'\n    }", "      collectionName: 'tests'\n    }\n\n    emitEvent(context, 'test', { doc: { name: 'test' } })\n    expect(fn).toHaveBeenCalledTimes(1)\n\n    patchEventEmitter.off('test', fn)\n  })\n\n  it('emitEvent ignore', async () => {", "\n  it('emitEvent ignore', async () => {\n    const fn = jest.fn()\n    patchEventEmitter.on('test', fn)\n\n    const context = {\n      ignoreEvent: true,\n      op: 'test',\n      modelName: 'Test',\n      collectionName: 'tests'", "      modelName: 'Test',\n      collectionName: 'tests'\n    }\n\n    emitEvent(context, 'test', { doc: { name: 'test' } })\n    expect(fn).toHaveBeenCalledTimes(0)\n\n    patchEventEmitter.off('test', fn)\n  })\n})", "  })\n})\n"]}
{"filename": "tests/plugin.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\nimport mongoose from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\nimport History from '../src/models/History'\n\nimport em from '../src/em'\nimport { USER_CREATED, USER_UPDATED, USER_DELETED } from './constants/events'", "import em from '../src/em'\nimport { USER_CREATED, USER_UPDATED, USER_DELETED } from './constants/events'\n\njest.mock('../src/em', () => {\n  return { emit: jest.fn() }\n})\n\ndescribe('plugin', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n", "  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {\n    eventCreated: USER_CREATED,\n    eventUpdated: USER_UPDATED,\n    eventDeleted: USER_DELETED,\n    omit: ['__v', 'role', 'createdAt', 'updatedAt']\n  })\n\n  const User = mongoose.model('User', UserSchema)", "\n  const User = mongoose.model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })", "    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  it('should createHistory', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })", "  it('should createHistory', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    user.name = 'Alice'\n    await user.save()\n\n    user.name = 'Bob'\n    await user.save()\n", "    await user.save()\n\n    await User.deleteMany({ role: 'user' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(4)\n\n    const [first, second, third, fourth] = history\n\n    // 1 create", "\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n\n    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')", "    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    // 2 update\n    expect(second.version).toBe(1)", "    // 2 update\n    expect(second.version).toBe(1)\n    expect(second.op).toBe('update')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(user._id)\n\n    expect(second.doc).toBeUndefined()\n\n    expect(second.patch).toHaveLength(2)", "\n    expect(second.patch).toHaveLength(2)\n    expect(second.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'John' },\n      { op: 'replace', path: '/name', value: 'Alice' }\n    ])\n\n    // 3 update\n    expect(third.version).toBe(2)\n    expect(third.op).toBe('update')", "    expect(third.version).toBe(2)\n    expect(third.op).toBe('update')\n    expect(third.modelName).toBe('User')\n    expect(third.collectionName).toBe('users')\n    expect(third.collectionId).toEqual(user._id)\n\n    expect(third.doc).toBeUndefined()\n\n    expect(third.patch).toHaveLength(2)\n    expect(third.patch).toMatchObject([", "    expect(third.patch).toHaveLength(2)\n    expect(third.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'Alice' },\n      { op: 'replace', path: '/name', value: 'Bob' }\n    ])\n\n    // 4 delete\n    expect(fourth.version).toBe(0)\n    expect(fourth.op).toBe('deleteMany')\n    expect(fourth.modelName).toBe('User')", "    expect(fourth.op).toBe('deleteMany')\n    expect(fourth.modelName).toBe('User')\n    expect(fourth.collectionName).toBe('users')\n    expect(fourth.collectionId).toEqual(user._id)\n\n    expect(fourth.doc).toHaveProperty('_id', user._id)\n    expect(fourth.doc).toHaveProperty('name', 'Bob')\n    expect(fourth.doc).toHaveProperty('role', 'user')\n    expect(fourth.doc).toHaveProperty('createdAt')\n    expect(fourth.doc).toHaveProperty('updatedAt')", "    expect(fourth.doc).toHaveProperty('createdAt')\n    expect(fourth.doc).toHaveProperty('updatedAt')\n\n    expect(fourth.patch).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(4)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),", "      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n      patch: second.patch\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n      doc: expect.objectContaining({ _id: user._id, name: 'Bob', role: 'user' }),\n      patch: third.patch\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {", "    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining({ _id: user._id, name: 'Bob', role: 'user' })\n    })\n  })\n\n  it('should omit update of role', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n", "    expect(user.name).toBe('John')\n\n    user.role = 'manager'\n    await user.save()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n", "    const [first] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n\n    expect(first.doc).toHaveProperty('_id', user._id)", "\n    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)", "\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    // no update event emitted because role is omitted\n  })\n\n  it('should updateOne', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n", "    expect(user.name).toBe('John')\n\n    await User.updateOne({ _id: user._id }, { name: 'Alice' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    // 1 create", "\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n\n    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')", "    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    // 2 update\n    expect(second.version).toBe(1)", "    // 2 update\n    expect(second.version).toBe(1)\n    expect(second.op).toBe('updateOne')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(user._id)\n\n    expect(second.doc).toBeUndefined()\n\n    expect(second.patch).toHaveLength(2)", "\n    expect(second.patch).toHaveLength(2)\n    expect(second.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'John' },\n      { op: 'replace', path: '/name', value: 'Alice' }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {", "    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n      patch: second.patch\n    })\n  })\n\n  it('should findOneAndUpdate', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })", "  it('should findOneAndUpdate', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    await User.findOneAndUpdate({ _id: user._id }, { name: 'Alice' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history", "\n    const [first, second] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n", "    expect(first.collectionId).toEqual(user._id)\n\n    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n", "    expect(first.patch).toHaveLength(0)\n\n    // 2 update\n    expect(second.version).toBe(1)\n    expect(second.op).toBe('findOneAndUpdate')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(user._id)\n\n    expect(second.doc).toBeUndefined()", "\n    expect(second.doc).toBeUndefined()\n\n    expect(second.patch).toHaveLength(2)\n    expect(second.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'John' },\n      { op: 'replace', path: '/name', value: 'Alice' }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(2)", "\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n      patch: second.patch\n    })\n  })\n", "  })\n\n  it('should update deprecated', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    if (isMongooseLessThan7) {\n      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    } else {\n      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n\n    expect(first.doc).toHaveProperty('_id', user._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    // 2 update\n    expect(second.version).toBe(1)\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(user._id)\n\n    expect(second.doc).toBeUndefined()\n\n    expect(second.patch).toHaveLength(2)\n    expect(second.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'John' },\n      { op: 'replace', path: '/name', value: 'Alice' }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n      patch: second.patch\n    })\n  })\n\n  it('should updated deprecated with multi flag', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n", "    if (isMongooseLessThan7) {\n      await User.update({ role: 'user' }, { $set: { name: 'Bob' } }, { multi: true }).exec()\n    } else {\n      await User.findOneAndUpdate({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(4)\n\n    const [first, second, third, fourth] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(john._id)\n\n    expect(first.doc).toHaveProperty('_id', john._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    // 2 create\n    expect(second.version).toBe(0)\n    expect(second.op).toBe('create')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(alice._id)\n\n    expect(second.doc).toHaveProperty('_id', alice._id)\n    expect(second.doc).toHaveProperty('name', 'Alice')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n\n    expect(second.patch).toHaveLength(0)\n\n    // 3 update\n    expect(third.version).toBe(1)\n    expect(third.modelName).toBe('User')\n    expect(third.collectionName).toBe('users')\n    expect(third.collectionId).toEqual(john._id)\n\n    expect(third.doc).toBeUndefined()\n\n    expect(third.patch).toHaveLength(2)\n    expect(third.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'John' },\n      { op: 'replace', path: '/name', value: 'Bob' }\n    ])\n\n    // 4 update\n    expect(fourth.version).toBe(1)\n    expect(fourth.modelName).toBe('User')\n    expect(fourth.collectionName).toBe('users')\n    expect(fourth.collectionId).toEqual(alice._id)\n\n    expect(fourth.doc).toBeUndefined()\n\n    expect(fourth.patch).toHaveLength(2)\n    expect(fourth.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'Alice' },\n      { op: 'replace', path: '/name', value: 'Bob' }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(4)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: second.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: john._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: john._id, name: 'Bob', role: 'user' }),\n      patch: third.patch\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: alice._id, name: 'Alice', role: 'user' }),\n      doc: expect.objectContaining({ _id: alice._id, name: 'Bob', role: 'user' }),\n      patch: fourth.patch\n    })\n  })\n\n  it('should create many', async () => {\n    await User.create([\n      { name: 'Alice', role: 'user' },\n      { name: 'John', role: 'user' }\n    ])\n\n    const history = await History.find({}).sort('doc.name')\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n\n    expect(first.doc).toHaveProperty('_id')\n    expect(first.doc).toHaveProperty('name', 'Alice')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    // 2 create\n    expect(second.version).toBe(0)\n    expect(second.op).toBe('create')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n\n    expect(second.doc).toHaveProperty('_id')\n    expect(second.doc).toHaveProperty('name', 'John')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n\n    expect(second.patch).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: second.doc })\n  })\n\n  it('should findOneAndUpdate upsert', async () => {\n    await User.findOneAndUpdate({ name: 'John', role: 'user' }, { name: 'Bob', role: 'user' }, { upsert: true, runValidators: true }).exec()\n    const documents = await User.find({})\n    expect(documents).toHaveLength(1)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('findOneAndUpdate')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n\n    expect(first.doc).toHaveProperty('_id')\n    expect(first.doc).toHaveProperty('name', 'Bob')\n    expect(first.doc).toHaveProperty('role', 'user')\n\n    // Upsert don't have createdAt and updatedAt and validation errors\n    // Investigate this case later\n    // expect(first.doc).toHaveProperty('createdAt')\n    // expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    // updated event is not emitted because it's an upsert\n  })\n\n  it('should update many', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n\n    await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(4)\n\n    const [first, second, third, fourth] = history\n\n    // 1 create\n    expect(first.version).toBe(0)\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(john._id)\n\n    expect(first.doc).toHaveProperty('_id', john._id)\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n\n    expect(first.patch).toHaveLength(0)\n\n    // 2 create\n\n    expect(second.version).toBe(0)\n    expect(second.op).toBe('create')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(alice._id)\n\n    expect(second.doc).toHaveProperty('_id', alice._id)\n    expect(second.doc).toHaveProperty('name', 'Alice')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n\n    expect(second.patch).toHaveLength(0)\n\n    // 3 update\n    expect(third.version).toBe(1)\n    expect(third.op).toBe('updateMany')\n    expect(third.modelName).toBe('User')\n    expect(third.collectionName).toBe('users')\n    expect(third.collectionId).toEqual(john._id)\n\n    expect(third.doc).toBeUndefined()\n\n    expect(third.patch).toHaveLength(2)\n    expect(third.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'John' },\n      { op: 'replace', path: '/name', value: 'Bob' }\n    ])\n\n    // 4 update\n    expect(fourth.version).toBe(1)\n    expect(fourth.op).toBe('updateMany')\n    expect(fourth.modelName).toBe('User')\n    expect(fourth.collectionName).toBe('users')\n    expect(fourth.collectionId).toEqual(alice._id)\n\n    expect(fourth.doc).toBeUndefined()\n\n    expect(fourth.patch).toHaveLength(2)\n    expect(fourth.patch).toMatchObject([\n      { op: 'test', path: '/name', value: 'Alice' },\n      { op: 'replace', path: '/name', value: 'Bob' }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(4)\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: second.doc })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: john._id, name: 'John', role: 'user' }),\n      doc: expect.objectContaining({ _id: john._id, name: 'Bob', role: 'user' }),\n      patch: third.patch\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({ _id: alice._id, name: 'Alice', role: 'user' }),\n      doc: expect.objectContaining({ _id: alice._id, name: 'Bob', role: 'user' }),\n      patch: fourth.patch\n    })\n  })\n})\n"]}
{"filename": "tests/plugin-event-updated.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\nimport mongoose, { Types, model } from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\nimport History from '../src/models/History'\n\nimport em from '../src/em'\nimport { USER_UPDATED } from './constants/events'", "import em from '../src/em'\nimport { USER_UPDATED } from './constants/events'\n\njest.mock('../src/em', () => {\n  return {\n    emit: jest.fn()\n  }\n})\n\ndescribe('plugin - event updated & patch history disabled', () => {", "\ndescribe('plugin - event updated & patch history disabled', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {\n    eventUpdated: USER_UPDATED,\n    patchHistoryDisabled: true,\n    omit: ['createdAt', 'updatedAt']\n  })\n", "  })\n\n  const User = model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()", "  afterAll(async () => {\n    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  it('should save() and emit one update event', async () => {", "\n  it('should save() and emit one update event', async () => {\n    await User.create({ name: 'Bob', role: 'user' })\n    const user = new User({ name: 'John', role: 'user' })\n    const created = await user.save()\n\n    user.name = 'John Doe'\n    const updated = await user.save()\n\n    const history = await History.find({})", "\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,", "        __v: 0,\n        _id: created._id,\n        name: 'John',\n        role: 'user',\n        createdAt: created.createdAt,\n        updatedAt: created.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated._id,", "        __v: 0,\n        _id: updated._id,\n        name: 'John Doe',\n        role: 'user',\n        createdAt: created.createdAt,\n        updatedAt: updated.updatedAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/name', value: 'John' },\n        { op: 'replace', path: '/name', value: 'John Doe' }", "        { op: 'test', path: '/name', value: 'John' },\n        { op: 'replace', path: '/name', value: 'John Doe' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    const users = await User.find({})\n    expect(users).toHaveLength(2)\n    const [bob, john] = users\n    expect(bob.name).toBe('Bob')", "    const [bob, john] = users\n    expect(bob.name).toBe('Bob')\n    expect(john.name).toBe('John Doe')\n  })\n\n  it('should update() and emit three update event', async () => {\n    await User.create([\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'user' },\n      { name: 'John', role: 'user' }", "      { name: 'Bob', role: 'user' },\n      { name: 'John', role: 'user' }\n    ], { ordered: true })\n\n    if (isMongooseLessThan7) {\n      await User.update({ role: 'user' }, { role: 'manager' })\n    } else {\n      await User.updateMany({ role: 'user' }, { role: 'manager' })\n    }\n\n    const users = await User.find({ role: 'manager' })\n    expect(users).toHaveLength(3)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(3)\n\n    // Confirm that the document is updated\n    const updated = await User.find({}).sort({ name: 1 })\n    expect(updated).toHaveLength(3)\n    const [alice, bob, john] = updated\n    expect(alice.role).toBe('manager')\n    expect(bob.role).toBe('manager')\n    expect(john.role).toBe('manager')\n  })\n\n  it('should updateOne() and emit one update event', async () => {\n    await User.create([\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'user' },\n      { name: 'John', role: 'user' }\n    ], { ordered: true })\n\n    await User.updateOne({ name: 'Bob' }, { role: 'manager' })\n    const users = await User.find({ role: 'manager' })\n    expect(users).toHaveLength(1)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n\n    // Confirm that the document is updated\n    const updated = await User.find({}).sort({ name: 1 })\n    expect(updated).toHaveLength(3)\n    const [alice, bob, john] = updated\n    expect(alice.role).toBe('user')\n    expect(bob.role).toBe('manager')\n    expect(john.role).toBe('user')\n  })\n\n  it('should replaceOne() and emit two update event', async () => {\n    await User.create([\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'user' },\n      { name: 'John', role: 'user' }\n    ], { ordered: true })\n\n    await User.replaceOne({ name: 'Bob' }, { name: 'Bob Doe', role: 'manager' })\n    const users = await User.find({ role: 'manager' })\n    expect(users).toHaveLength(1)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: expect.any(Types.ObjectId),\n        name: 'Bob',\n        role: 'user',\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date)\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: expect.any(Types.ObjectId),\n        name: 'Bob Doe',\n        role: 'manager',\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date)\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/name', value: 'Bob' },\n        { op: 'replace', path: '/name', value: 'Bob Doe' },\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    const updated = await User.find({}).sort({ name: 1 })\n    expect(updated).toHaveLength(3)\n    const [alice, bob, john] = updated\n    expect(alice.role).toBe('user')\n    expect(bob.role).toBe('manager')\n    expect(john.role).toBe('user')\n  })\n\n  it('should updateMany() and emit two update event', async () => {\n    await User.create([\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'user' },\n      { name: 'John', role: 'user' }\n    ], { ordered: true })\n\n    await User.updateMany({ role: 'user' }, { role: 'manager' })\n    const users = await User.find({ role: 'manager' })\n    expect(users).toHaveLength(3)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(3)\n\n    // Confirm that the document is updated\n    const updated = await User.find({}).sort({ name: 1 })\n    expect(updated).toHaveLength(3)\n    const [alice, bob, john] = updated\n    expect(alice.role).toBe('manager')\n    expect(bob.role).toBe('manager')\n    expect(john.role).toBe('manager')\n  })\n\n  it('should findOneAndUpdate() and emit one update event', async () => {\n    await User.create({ name: 'Bob', role: 'user' })\n    const created = await User.create({ name: 'John', role: 'user' })\n    await User.findOneAndUpdate({ _id: created._id }, { name: 'John Doe', role: 'manager' })\n    const updated = await User.findById(created._id).exec()\n    expect(updated).not.toBeNull()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,\n        name: created.name,\n        role: created.role,\n        createdAt: created.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated?._id,\n        name: updated?.name,\n        role: updated?.role,\n        createdAt: created.createdAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' },\n        { op: 'test', path: '/name', value: 'John' },\n        { op: 'replace', path: '/name', value: 'John Doe' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    expect(updated?.name).toBe('John Doe')\n    expect(updated?.role).toBe('manager')\n  })\n\n  it('should findOneAndReplace() and emit one update event', async () => {\n    await User.create({ name: 'Bob', role: 'user' })\n    const created = await User.create({ name: 'John', role: 'user' })\n    await User.findOneAndReplace({ _id: created._id }, { name: 'John Doe', role: 'manager' })\n    const updated = await User.findById(created._id).exec()\n    expect(updated).not.toBeNull()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,\n        name: created.name,\n        role: created.role,\n        createdAt: created.createdAt,\n        updatedAt: created.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated?._id,\n        name: updated?.name,\n        role: updated?.role,\n        createdAt: updated?.createdAt,\n        updatedAt: updated?.updatedAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/name', value: 'John' },\n        { op: 'replace', path: '/name', value: 'John Doe' },\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    expect(updated?.name).toBe('John Doe')\n    expect(updated?.role).toBe('manager')\n  })\n\n  it('should findByIdAndUpdate() and emit one update event', async () => {\n    const created = await User.create({ name: 'Bob', role: 'user' })\n    await User.findByIdAndUpdate(created._id, { name: 'John Doe', role: 'manager' })\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,\n        name: created.name,\n        role: created.role,\n        createdAt: created.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,\n        name: 'John Doe',\n        role: 'manager',\n        createdAt: created.createdAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/name', value: 'Bob' },\n        { op: 'replace', path: '/name', value: 'John Doe' },\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    const updated = await User.findById(created._id).exec()\n    expect(updated?.name).toBe('John Doe')\n    expect(updated?.role).toBe('manager')\n  })\n\n  it('should update and emit one update event', async () => {\n    await User.create({ name: 'Bob', role: 'user' })\n    const created = await User.create({ name: 'John', role: 'user' })\n    await User.updateOne({ _id: created._id }, { name: 'John Doe', role: 'manager' })\n    const updated = await User.findById(created._id).exec()\n    expect(updated).not.toBeNull()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,\n        name: created.name,\n        role: created.role,\n        createdAt: created.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated?._id,\n        name: updated?.name,\n        role: updated?.role,\n        createdAt: created.createdAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' },\n        { op: 'test', path: '/name', value: 'John' },\n        { op: 'replace', path: '/name', value: 'John Doe' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    expect(updated?.name).toBe('John Doe')\n    expect(updated?.role).toBe('manager')\n  })\n\n  it('should updateMany and emit two update events', async () => {\n    const created1 = await User.create({ name: 'John', role: 'user' })\n    const created2 = await User.create({ name: 'Bob', role: 'user' })\n    await User.updateMany({}, { name: 'John Doe', role: 'manager' })\n    const updated1 = await User.findById(created1._id).exec()\n    expect(updated1).not.toBeNull()\n    const updated2 = await User.findById(created2._id).exec()\n    expect(updated2).not.toBeNull()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created1._id,\n        name: created1.name,\n        role: created1.role,\n        createdAt: created1.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated1?._id,\n        name: updated1?.name,\n        role: updated1?.role,\n        createdAt: created1.createdAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' },\n        { op: 'test', path: '/name', value: 'John' },\n        { op: 'replace', path: '/name', value: 'John Doe' }\n      ])\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created2._id,\n        name: created2.name,\n        role: created2.role,\n        createdAt: created2.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated2?._id,\n        name: updated2?.name,\n        role: updated2?.role,\n        createdAt: created2.createdAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' },\n        { op: 'test', path: '/name', value: 'Bob' },\n        { op: 'replace', path: '/name', value: 'John Doe' }\n      ])\n    })\n\n    // Confirm that the documents are updated\n    expect(updated1?.name).toBe('John Doe')\n    expect(updated1?.role).toBe('manager')\n\n    expect(updated2?.name).toBe('John Doe')\n    expect(updated2?.role).toBe('manager')\n  })\n\n  it('should findOneAndUpdate $set and emit one update event', async () => {\n    const created = await User.create({ name: 'Bob', role: 'user' })\n    await User.findOneAndUpdate({ _id: created._id }, { $set: { name: 'John Doe', role: 'manager' } })\n    const updated = await User.findById(created._id).exec()\n    expect(updated).not.toBeNull()\n    expect(updated?.name).toBe('John Doe')\n    expect(updated?.role).toBe('manager')\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n      oldDoc: expect.objectContaining({\n        __v: 0,\n        _id: created._id,\n        name: created.name,\n        role: created.role,\n        createdAt: created.createdAt\n      }),\n      doc: expect.objectContaining({\n        __v: 0,\n        _id: updated?._id,\n        name: updated?.name,\n        role: updated?.role,\n        createdAt: created.createdAt\n      }),\n      patch: expect.arrayContaining([\n        { op: 'test', path: '/name', value: 'Bob' },\n        { op: 'replace', path: '/name', value: 'John Doe' },\n        { op: 'test', path: '/role', value: 'user' },\n        { op: 'replace', path: '/role', value: 'manager' }\n      ])\n    })\n\n    // Confirm that the document is updated\n    expect(updated?.name).toBe('John Doe')\n    expect(updated?.role).toBe('manager')\n  })\n\n  it('should ignoreHook option on updateMany', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    await User.updateMany({ role: 'user' }, { role: 'admin' }, { ignoreHook: true }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n\n    // Confirm that the document is updated\n    const updated = await User.findById(john._id).exec()\n    expect(updated?.role).toBe('admin')\n  })\n})\n"]}
{"filename": "tests/patch.test.ts", "chunked_list": ["import mongoose, { model } from 'mongoose'\n\nimport { getUser, getReason, getMetadata, getData, getValue, getObjects, bulkPatch, updatePatch } from '../src/patch'\nimport { patchHistoryPlugin } from '../src/plugin'\n\nimport UserSchema from './schemas/UserSchema'\n\nimport { USER_DELETED } from './constants/events'\n\nimport type { HydratedDocument } from 'mongoose'", "\nimport type { HydratedDocument } from 'mongoose'\nimport type { User } from '../src/interfaces/IPluginOptions'\nimport type IPluginOptions from '../src/interfaces/IPluginOptions'\nimport type IUser from './interfaces/IUser'\nimport type IContext from '../src/interfaces/IContext'\n\nimport em from '../src/em'\n\njest.mock('../src/em', () => {\n  return {\n    emit: jest.fn()\n  }\n})\n\ndescribe('patch tests', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {\n    eventDeleted: USER_DELETED,\n    patchHistoryDisabled: true\n  })\n\n  const User = model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('patches').deleteMany({})\n  })\n\n  describe('getObjects', () => {\n    it('should omit properties from currentObject and originalObject based on the opts', async () => {\n      const original = await User.create({ name: 'John', role: 'user' })\n      const current = await User.create({ name: 'John', role: 'admin' })\n\n      const pluginOptions = {\n        omit: ['createdAt']\n      }\n\n      const { currentObject, originalObject } = getObjects(pluginOptions, current, original)\n\n      expect(currentObject.name).toBe('John')\n      expect(currentObject.role).toBe('admin')\n      expect(currentObject.createdAt).toBeUndefined()\n\n      expect(originalObject.name).toBe('John')\n      expect(originalObject.role).toBe('user')\n      expect(originalObject.createdAt).toBeUndefined()\n    })\n\n    it('should not omit properties from currentObject and originalObject if opts is empty', async () => {\n      const original = await User.create({ name: 'John', role: 'user' })\n      const current = await User.create({ name: 'John', role: 'admin' })\n\n      const { currentObject, originalObject } = getObjects({}, current, original)\n\n      expect(currentObject.name).toBe('John')\n      expect(currentObject.role).toBe('admin')\n      expect(currentObject.createdAt).toBeDefined()\n\n      expect(originalObject.name).toBe('John')\n      expect(originalObject.role).toBe('user')\n      expect(originalObject.createdAt).toBeDefined()\n    })\n  })\n\n  describe('bulkPatch', () => {\n    it('should emit eventDeleted if opts.patchHistoryDisabled is false', async () => {\n      const doc = new User({ name: 'John', role: 'user' })\n\n      const pluginOptions: IPluginOptions<IUser> = {\n        eventDeleted: USER_DELETED,\n        patchHistoryDisabled: false\n      }\n\n      const context: IContext<IUser> = {\n        op: 'deleteOne',\n        modelName: 'User',\n        collectionName: 'users',\n        deletedDocs: [doc]\n      }\n\n      await bulkPatch(pluginOptions, context, 'eventDeleted', 'deletedDocs')\n      expect(em.emit).toHaveBeenCalled()\n    })\n\n    it('should emit eventDeleted if opts.patchHistoryDisabled is true', async () => {\n      const doc = new User({ name: 'John', role: 'user' })\n\n      const pluginOptions: IPluginOptions<IUser> = {\n        eventDeleted: USER_DELETED,\n        patchHistoryDisabled: true\n      }\n\n      const context: IContext<IUser> = {\n        op: 'deleteOne',\n        modelName: 'User',\n        collectionName: 'users',\n        deletedDocs: [doc]\n      }\n\n      await bulkPatch(pluginOptions, context, 'eventDeleted', 'deletedDocs')\n      expect(em.emit).toHaveBeenCalled()\n    })\n  })\n\n  describe('updatePatch', () => {\n    it('should return if one object is empty', async () => {\n      const current = await User.create({ name: 'John', role: 'user' })\n\n      const pluginOptions: IPluginOptions<IUser> = {\n        eventDeleted: USER_DELETED,\n        patchHistoryDisabled: true\n      }\n\n      const context: IContext<IUser> = {\n        op: 'updateOne',\n        modelName: 'User',\n        collectionName: 'users'\n      }\n\n      await updatePatch(pluginOptions, context, current, {} as HydratedDocument<IUser>)\n      expect(em.emit).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('should getUser()', () => {\n    it('should return user, reason, metadata', async () => {\n      const opts: IPluginOptions<IUser> = {\n        getUser: () => ({ name: 'test' }),\n        getReason: () => 'test',\n        getMetadata: () => ({ test: 'test' })\n      }\n\n      await expect(getUser(opts)).resolves.toEqual({ name: 'test' })\n      await expect(getReason(opts)).resolves.toBe('test')\n      await expect(getMetadata(opts)).resolves.toEqual({ test: 'test' })\n    })\n  })\n\n  describe('should getData()', () => {\n    it('should return user, reason, metadata', async () => {\n      const opts: IPluginOptions<IUser> = {\n        getUser: () => ({ name: 'test' }),\n        getReason: () => 'test',\n        getMetadata: () => ({ test: 'test' })\n      }\n\n      await expect(getData(opts)).resolves.toEqual([{ name: 'test' }, 'test', { test: 'test' }])\n    })\n\n    it('should return user, reason, metadata undefined', async () => {\n      const opts: IPluginOptions<IUser> = {\n        getUser: () => ({ name: 'test' }),\n        getReason: () => 'test',\n        getMetadata: () => {\n          throw new Error('test')\n        }\n      }\n\n      await expect(getData(opts)).resolves.toEqual([{ name: 'test' }, 'test', undefined])\n    })\n\n    it('should getValue', () => {\n      const item1: PromiseSettledResult<User> = {\n        status: 'fulfilled',\n        value: {\n          name: 'test'\n        }\n      }\n\n      expect(getValue(item1)).toEqual({ name: 'test' })\n\n      const item2: PromiseSettledResult<User> = {\n        status: 'rejected',\n        reason: new Error('test')\n      }\n\n      expect(getValue(item2)).toBeUndefined()\n    })\n  })\n})\n"]}
{"filename": "tests/plugin-event-deleted.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\nimport mongoose, { model } from 'mongoose'\n\nimport type { ToObjectOptions } from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\nimport History from '../src/models/History'\n\nimport em from '../src/em'", "\nimport em from '../src/em'\nimport { USER_DELETED } from './constants/events'\n\njest.mock('../src/em', () => {\n  return {\n    emit: jest.fn()\n  }\n})\n", "})\n\nconst toObjectOptions: ToObjectOptions = {\n  depopulate: true,\n  virtuals: false\n}\n\ndescribe('plugin - event delete & patch history disabled', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n", "  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {\n    eventDeleted: USER_DELETED,\n    patchHistoryDisabled: true\n  })\n\n  const User = model('User', UserSchema)\n\n  beforeAll(async () => {", "\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {", "\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  it('should remove() and emit one delete event', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n\n    if (isMongooseLessThan7) {\n      await john.remove()\n    } else {\n      await john.deleteOne()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const user = await User.findById(john._id)\n    expect(user).toBeNull()\n  })\n\n  it('should remove() and emit two delete events', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john, alice] = users\n", "\n    if (isMongooseLessThan7) {\n      await john.remove()\n    } else {\n      await john.deleteOne()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const user = await User.findById(john._id)\n    expect(user).toBeNull()\n  })\n\n  it('should remove() and emit two delete events', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john, alice] = users\n", "    if (isMongooseLessThan7) {\n      await User.remove({ role: 'user' }).exec()\n    } else {\n      await User.deleteMany({ role: 'user' }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(alice.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const deletedAlice = await User.findById(alice._id)\n    expect(deletedAlice).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(1)\n  })\n\n  it('should remove() and emit one delete event { single: true }', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n", "    if (isMongooseLessThan7) {\n      await User.remove({ role: 'user' }, { single: true }).exec()\n    } else {\n      await User.deleteOne({ role: 'user' }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should findOneAndDelete() and emit one delete event', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n\n    await User.findOneAndDelete({ role: 'user' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should findOneAndRemove() and emit one delete event', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n\n    await User.findOneAndRemove({ role: 'user' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should findByIdAndDelete() and emit one delete event', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n\n    await User.findByIdAndDelete(john._id).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should findByIdAndRemove() and emit one delete event', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n\n    await User.findByIdAndRemove(john._id).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should deleteOne() and emit one delete event', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n\n    await User.deleteOne({ role: 'user' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should deleteMany() and emit two delete events', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john, alice] = users\n\n    await User.deleteMany({ role: 'user' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(2)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(alice.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const deletedAlice = await User.findById(alice._id)\n    expect(deletedAlice).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(1)\n  })\n\n  it('should deleteMany() and emit one delete event { single: true }', async () => {\n    const users = await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' },\n      { name: 'Bob', role: 'admin' }\n    ])\n\n    const [john] = users\n", "    if (isMongooseLessThan7) {\n      await User.deleteMany({ role: 'user' }, { single: true }).exec()\n    } else {\n      await User.deleteOne({ role: 'user' }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(2)\n  })\n\n  it('should create then delete and emit one delete event', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n", "    if (isMongooseLessThan7) {\n      await john.delete()\n    } else {\n      await john.deleteOne()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n    })\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(0)\n  })\n\n  it('should ignoreHook option on deleteMany', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    await User.deleteMany({ role: 'user' }, { ignoreHook: true }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n  })\n\n  it('should ignoreHook option on deleteOne', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    await User.deleteOne({ role: 'user' }, { ignoreHook: true }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(0)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n\n    // Check if data is deleted\n    const deletedJohn = await User.findById(john._id)\n    expect(deletedJohn).toBeNull()\n\n    const remaining = await User.find({})\n    expect(remaining).toHaveLength(0)\n  })\n})\n"]}
{"filename": "tests/plugin-pre-delete.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\nimport mongoose, { model } from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\n\nimport { USER_DELETED } from './constants/events'\n\nimport em from '../src/em'\n", "import em from '../src/em'\n\nconst preDeleteMock = jest.fn()\n\njest.mock('../src/em', () => {\n  return { emit: jest.fn() }\n})\n\ndescribe('plugin - preDelete test', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`", "describe('plugin - preDelete test', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {\n    eventDeleted: USER_DELETED,\n    patchHistoryDisabled: true,\n    preDelete: preDeleteMock\n  })\n\n  const User = model('User', UserSchema)", "\n  const User = model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })", "    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  it('should deleteMany and execute preDelete', async () => {\n    await User.create({ name: 'John', role: 'user' })", "  it('should deleteMany and execute preDelete', async () => {\n    await User.create({ name: 'John', role: 'user' })\n    await User.create({ name: 'Jane', role: 'user' })\n    await User.create({ name: 'Jack', role: 'user' })\n\n    const users = await User.find({}).sort().lean().exec()\n    expect(users).toHaveLength(3)\n\n    const [john, jane, jack] = users\n", "    const [john, jane, jack] = users\n\n    await User.deleteMany({ role: 'user' })\n    expect(preDeleteMock).toHaveBeenCalledTimes(1)\n    expect(preDeleteMock).toHaveBeenCalledWith([john, jane, jack])\n\n    expect(em.emit).toHaveBeenCalledTimes(3)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: {\n        __v: 0,", "      oldDoc: {\n        __v: 0,\n        _id: jane?._id,\n        name: 'Jane',\n        role: 'user',\n        createdAt: jane?.createdAt,\n        updatedAt: jane?.updatedAt\n      }\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {", "    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: {\n        __v: 0,\n        _id: john?._id,\n        name: 'John',\n        role: 'user',\n        createdAt: john?.createdAt,\n        updatedAt: john?.updatedAt\n      }", "        updatedAt: john?.updatedAt\n      }\n    })\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: {\n        __v: 0,\n        _id: jack?._id,\n        name: 'Jack',\n        role: 'user',\n        createdAt: jack?.createdAt,", "        role: 'user',\n        createdAt: jack?.createdAt,\n        updatedAt: jack?.updatedAt\n      }\n    })\n  })\n\n  it('should deleteOne and execute preDelete', async () => {\n    await User.create({ name: 'John', role: 'user' })\n    await User.create({ name: 'Jane', role: 'user' })", "    await User.create({ name: 'John', role: 'user' })\n    await User.create({ name: 'Jane', role: 'user' })\n    await User.create({ name: 'Jack', role: 'user' })\n\n    const users = await User.find({}).sort().lean().exec()\n    expect(users).toHaveLength(3)\n\n    const [john] = users\n\n    await User.deleteOne({ name: 'John' })", "\n    await User.deleteOne({ name: 'John' })\n    expect(preDeleteMock).toHaveBeenCalledTimes(1)\n    expect(preDeleteMock).toHaveBeenCalledWith([\n      {\n        __v: 0,\n        _id: john?._id,\n        name: 'John',\n        role: 'user',\n        createdAt: john?.createdAt,", "        role: 'user',\n        createdAt: john?.createdAt,\n        updatedAt: john?.updatedAt\n      }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: {\n        __v: 0,", "      oldDoc: {\n        __v: 0,\n        _id: john?._id,\n        name: 'John',\n        role: 'user',\n        createdAt: john?.createdAt,\n        updatedAt: john?.updatedAt\n      }\n    })\n  })", "    })\n  })\n\n  it('should remove and execute preDelete', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n\n    if (isMongooseLessThan7) {\n      await john?.remove()\n    } else {\n      await john?.deleteOne()\n    }\n\n    expect(preDeleteMock).toHaveBeenCalledTimes(1)\n    expect(preDeleteMock).toHaveBeenCalledWith([\n      {\n        __v: 0,\n        _id: john?._id,\n        name: 'John',\n        role: 'user',\n        createdAt: john?.createdAt,\n        updatedAt: john?.updatedAt\n      }\n    ])\n\n    expect(em.emit).toHaveBeenCalledTimes(1)\n    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n      oldDoc: {\n        __v: 0,\n        _id: john?._id,\n        name: 'John',\n        role: 'user',\n        createdAt: john?.createdAt,\n        updatedAt: john?.updatedAt\n      }\n    })\n  })\n})\n"]}
{"filename": "tests/plugin-omit-all.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\nimport mongoose, { Types, model } from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\nimport History from '../src/models/History'\n\nimport em from '../src/em'\n", "import em from '../src/em'\n\njest.mock('../src/em', () => {\n  return { emit: jest.fn() }\n})\n\ndescribe('plugin - omit all', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {", "\n  UserSchema.plugin(patchHistoryPlugin, {\n    omit: ['__v', 'name', 'role', 'createdAt', 'updatedAt']\n  })\n\n  const User = model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })", "    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})", "    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  it('should createHistory', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    user.name = 'Alice'\n    await user.save()", "    user.name = 'Alice'\n    await user.save()\n\n    user.name = 'Bob'\n    await user.save()\n\n    await User.deleteMany({ role: 'user' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)", "    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)", "    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)\n", "    expect(first.doc).toHaveProperty('_id', user._id)\n\n    expect(second.op).toBe('deleteMany')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(user._id)\n    expect(second.version).toBe(0)\n    expect(second.patch).toHaveLength(0)\n\n    expect(second.doc).toHaveProperty('name', 'Bob')", "\n    expect(second.doc).toHaveProperty('name', 'Bob')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n    expect(second.doc).toHaveProperty('_id', user._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n", "  })\n\n  it('should omit update of role', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    user.role = 'manager'\n    await user.save()\n\n    const history = await History.find({})", "\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)", "    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)", "    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should updateOne', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n", "    expect(user.name).toBe('John')\n\n    await User.updateOne({ _id: user._id }, { name: 'Alice' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    expect(first.op).toBe('create')", "\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')", "    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should findOneAndUpdate', async () => {", "\n  it('should findOneAndUpdate', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    await User.findOneAndUpdate({ _id: user._id }, { name: 'Alice' }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n", "    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)", "    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)", "\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should update deprecated', async () => {\n    const user = await User.create({ name: 'John', role: 'user' })\n    expect(user.name).toBe('John')\n\n    if (isMongooseLessThan7) {\n      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    } else {\n      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should updated deprecated with multi flag', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n", "    if (isMongooseLessThan7) {\n      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    } else {\n      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(user._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', user._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should updated deprecated with multi flag', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n", "    if (isMongooseLessThan7) {\n      await User.update({ role: 'user' }, { $set: { name: 'Bob' } }, { multi: true }).exec()\n    } else {\n      await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n    }\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(john._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', john._id)\n\n    expect(second.op).toBe('create')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(alice._id)\n    expect(second.version).toBe(0)\n    expect(second.patch).toHaveLength(0)\n\n    expect(second.doc).toHaveProperty('name', 'Alice')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n    expect(second.doc).toHaveProperty('_id', alice._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should create many', async () => {\n    await User.create([\n      { name: 'John', role: 'user' },\n      { name: 'Alice', role: 'user' }\n    ])\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toBeInstanceOf(Types.ObjectId)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id')\n\n    expect(second.op).toBe('create')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toBeInstanceOf(Types.ObjectId)\n    expect(second.version).toBe(0)\n    expect(second.patch).toHaveLength(0)\n\n    expect(second.doc).toHaveProperty('name', 'Alice')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n    expect(second.doc).toHaveProperty('_id')\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should findOneAndUpdate upsert', async () => {\n    await User.findOneAndUpdate({ name: 'John', role: 'user' }, { name: 'Bob', role: 'user' }, { upsert: true, runValidators: true }).exec()\n    const documents = await User.find({})\n    expect(documents).toHaveLength(1)\n\n    const history = await History.find({})\n    expect(history).toHaveLength(1)\n\n    const [first] = history\n\n    expect(first.op).toBe('findOneAndUpdate')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toBeInstanceOf(Types.ObjectId)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'Bob')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('_id')\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n\n  it('should update many', async () => {\n    const john = await User.create({ name: 'John', role: 'user' })\n    expect(john.name).toBe('John')\n    const alice = await User.create({ name: 'Alice', role: 'user' })\n    expect(alice.name).toBe('Alice')\n\n    await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\n    const history = await History.find({})\n    expect(history).toHaveLength(2)\n\n    const [first, second] = history\n\n    expect(first.op).toBe('create')\n    expect(first.modelName).toBe('User')\n    expect(first.collectionName).toBe('users')\n    expect(first.collectionId).toEqual(john._id)\n    expect(first.version).toBe(0)\n    expect(first.patch).toHaveLength(0)\n\n    expect(first.doc).toHaveProperty('name', 'John')\n    expect(first.doc).toHaveProperty('role', 'user')\n    expect(first.doc).toHaveProperty('createdAt')\n    expect(first.doc).toHaveProperty('updatedAt')\n    expect(first.doc).toHaveProperty('_id', john._id)\n\n    expect(second.op).toBe('create')\n    expect(second.modelName).toBe('User')\n    expect(second.collectionName).toBe('users')\n    expect(second.collectionId).toEqual(alice._id)\n    expect(second.version).toBe(0)\n    expect(second.patch).toHaveLength(0)\n\n    expect(second.doc).toHaveProperty('name', 'Alice')\n    expect(second.doc).toHaveProperty('role', 'user')\n    expect(second.doc).toHaveProperty('createdAt')\n    expect(second.doc).toHaveProperty('updatedAt')\n    expect(second.doc).toHaveProperty('_id', alice._id)\n\n    expect(em.emit).toHaveBeenCalledTimes(0)\n  })\n})\n"]}
{"filename": "tests/plugin-event-created.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\nimport mongoose, { Types, model } from 'mongoose'\n\nimport UserSchema from './schemas/UserSchema'\nimport { patchHistoryPlugin } from '../src/plugin'\nimport History from '../src/models/History'\n\nimport em from '../src/em'\nimport { USER_CREATED } from './constants/events'\n", "import { USER_CREATED } from './constants/events'\n\njest.mock('../src/em', () => {\n  return {\n    emit: jest.fn()\n  }\n})\n\ndescribe('plugin - event created & patch history disabled', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`", "describe('plugin - event created & patch history disabled', () => {\n  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\n  UserSchema.plugin(patchHistoryPlugin, {\n    eventCreated: USER_CREATED,\n    patchHistoryDisabled: true\n  })\n\n  const User = model('User', UserSchema)\n", "  const User = model('User', UserSchema)\n\n  beforeAll(async () => {\n    await mongoose.connect(uri)\n  })\n\n  afterAll(async () => {\n    await mongoose.connection.close()\n  })\n", "  })\n\n  beforeEach(async () => {\n    await mongoose.connection.collection('users').deleteMany({})\n    await mongoose.connection.collection('history').deleteMany({})\n  })\n\n  describe('normal cases', () => {\n    it('should save() and emit one create event', async () => {\n      const john = new User({ name: 'John', role: 'user' })", "    it('should save() and emit one create event', async () => {\n      const john = new User({ name: 'John', role: 'user' })\n      await john.save()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({", "      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: john._id,\n          name: john.name,\n          role: john.role,\n          createdAt: john.createdAt,\n          updatedAt: john.updatedAt\n        })\n      })\n", "      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('user')\n    })\n\n    it('should create() and emit one create event', async () => {", "\n    it('should create() and emit one create event', async () => {\n      const user = await User.create({ name: 'John', role: 'user' })\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({", "      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user._id,\n          name: user.name,\n          role: user.role,\n          createdAt: user.createdAt,\n          updatedAt: user.updatedAt\n        })\n      })\n", "      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('user')\n    })\n\n    it('should insertMany() and emit three create events', async () => {", "\n    it('should insertMany() and emit three create events', async () => {\n      const users = await User.insertMany([\n        { name: 'John', role: 'user' },\n        { name: 'Alice', role: 'user' },\n        { name: 'Bob', role: 'user' }\n      ], { ordered: true })\n\n      const [john, alice, bob] = users\n", "      const [john, alice, bob] = users\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(3)\n      expect(em.emit).toHaveBeenNthCalledWith(1, USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: john._id,\n          name: john.name,", "          _id: john._id,\n          name: john.name,\n          role: john.role,\n          createdAt: john.createdAt,\n          updatedAt: john.updatedAt\n        })\n      })\n      expect(em.emit).toHaveBeenNthCalledWith(2, USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: alice._id,", "        doc: expect.objectContaining({\n          _id: alice._id,\n          name: alice.name,\n          role: alice.role,\n          createdAt: alice.createdAt,\n          updatedAt: alice.updatedAt\n        })\n      })\n      expect(em.emit).toHaveBeenNthCalledWith(3, USER_CREATED, {\n        doc: expect.objectContaining({", "      expect(em.emit).toHaveBeenNthCalledWith(3, USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: bob._id,\n          name: bob.name,\n          role: bob.role,\n          createdAt: bob.createdAt,\n          updatedAt: bob.updatedAt\n        })\n      })\n", "      })\n\n      // Check if the documents are saved\n      const found = await User.find({})\n      expect(found).toHaveLength(3)\n\n      const [foundJohn, foundAlice, foundBob] = found\n\n      expect(foundJohn.name).toBe('John')\n      expect(foundJohn.role).toBe('user')", "      expect(foundJohn.name).toBe('John')\n      expect(foundJohn.role).toBe('user')\n\n      expect(foundAlice.name).toBe('Alice')\n      expect(foundAlice.role).toBe('user')\n\n      expect(foundBob.name).toBe('Bob')\n      expect(foundBob.role).toBe('user')\n    })\n  })", "    })\n  })\n\n  describe('upsert cases', () => {\n    it('should update() + upsert and emit one create event', async () => {\n      if (isMongooseLessThan7) {\n        await User.update(\n          { name: 'John' },\n          { name: 'John', role: 'admin' },\n          { upsert: true }\n        )\n      } else {\n        await User.findOneAndUpdate(\n          { name: 'John' },\n          { name: 'John', role: 'admin' },\n          { upsert: true }\n        )\n      }\n\n      const user = await User.findOne({ name: 'John', role: 'admin' })\n      expect(user).not.toBeNull()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user?._id,\n          name: user?.name,\n          role: user?.role\n        // Upsert does not set createdAt and updatedAt\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('admin')\n    })\n\n    it('should updateOne() + upsert and emit one create event', async () => {\n      await User.updateOne(\n        { name: 'John' },\n        { name: 'John', role: 'admin' },\n        { upsert: true }\n      )\n\n      const user = await User.findOne({ name: 'John', role: 'admin' })\n      expect(user).not.toBeNull()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user?._id,\n          name: user?.name,\n          role: user?.role\n        // Upsert does not set createdAt and updatedAt\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('admin')\n    })\n\n    it('should replaceOne() + upsert and emit one create event', async () => {\n      await User.replaceOne(\n        { name: 'John' },\n        { name: 'John', role: 'admin' },\n        { upsert: true }\n      )\n\n      const user = await User.findOne({ name: 'John', role: 'admin' })\n      expect(user).not.toBeNull()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user?._id,\n          name: user?.name,\n          role: user?.role\n          // Upsert does not set createdAt and updatedAt\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('admin')\n    })\n\n    it('should updateMany() + upsert and emit one create event', async () => {\n      await User.updateMany(\n        { name: { $in: ['John', 'Alice', 'Bob'] } },\n        { name: 'Steve', role: 'admin' },\n        { upsert: true }\n      )\n\n      const users = await User.findOne({ name: 'Steve', role: 'admin' })\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenNthCalledWith(1, USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: users?._id,\n          name: users?.name,\n          role: users?.role\n        // Upsert does not set createdAt and updatedAt\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findById(users?._id)\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('Steve')\n      expect(found?.role).toBe('admin')\n    })\n\n    it('should findOneAndUpdate() + upsert and emit one create event', async () => {\n      await User.findOneAndUpdate(\n        { name: 'John' },\n        { name: 'John', role: 'admin' },\n        { upsert: true }\n      )\n\n      const user = await User.findOne({ name: 'John', role: 'admin' })\n      expect(user).not.toBeNull()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user?._id,\n          name: user?.name,\n          role: user?.role\n        // Upsert does not set createdAt and updatedAt\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('admin')\n    })\n\n    it('should findOneAndReplace() + upsert and emit one create event', async () => {\n      await User.findOneAndReplace(\n        { name: 'John' },\n        { name: 'John', role: 'admin' },\n        { upsert: true }\n      )\n\n      const user = await User.findOne({ name: 'John', role: 'admin' })\n      expect(user).not.toBeNull()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user?._id,\n          name: user?.name,\n          role: user?.role\n        // Upsert does not set createdAt and updatedAt\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('admin')\n    })\n\n    it('should findByIdAndUpdate() + upsert and emit one create event', async () => {\n      const _id = new Types.ObjectId()\n      await User.findByIdAndUpdate(_id, { name: 'John', role: 'admin' }, { upsert: true })\n\n      const user = await User.findOne({ name: 'John', role: 'admin' })\n      expect(user).not.toBeNull()\n\n      const history = await History.find({})\n      expect(history).toHaveLength(0)\n\n      expect(em.emit).toHaveBeenCalledTimes(1)\n      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n        doc: expect.objectContaining({\n          _id: user?._id,\n          name: user?.name,\n          role: user?.role\n        })\n      })\n\n      // Check if the document is saved\n      const found = await User.findOne({})\n      expect(found).not.toBeNull()\n      expect(found?.name).toBe('John')\n      expect(found?.role).toBe('admin')\n    })\n  })\n})\n"]}
{"filename": "tests/schemas/UserSchema.ts", "chunked_list": ["import { Schema } from 'mongoose'\n\nimport type IUser from '../interfaces/IUser'\n\nconst UserSchema = new Schema<IUser>({\n  name: {\n    type: String,\n    required: true\n  },\n  role: {\n    type: String,\n    required: true\n  }\n}, { timestamps: true })\n\nexport default UserSchema\n"]}
{"filename": "tests/constants/events.ts", "chunked_list": ["export const USER_CREATED = 'user-created'\nexport const USER_UPDATED = 'user-updated'\nexport const USER_DELETED = 'user-deleted'\n"]}
{"filename": "tests/interfaces/IUser.ts", "chunked_list": ["interface IUser {\n  name: string\n  role: string\n  createdAt?: Date\n  updatedAt?: Date\n}\n\nexport default IUser\n"]}
{"filename": "src/plugin.ts", "chunked_list": ["import _ from 'lodash'\nimport { assign } from 'power-assign'\n\nimport type { HydratedDocument, Model, MongooseQueryMiddleware, QueryOptions, Schema, ToObjectOptions, UpdateQuery, UpdateWithAggregationPipeline } from 'mongoose'\n\nimport type IPluginOptions from './interfaces/IPluginOptions'\nimport type IContext from './interfaces/IContext'\nimport type IHookContext from './interfaces/IHookContext'\n\nimport { createPatch, updatePatch, deletePatch } from './patch'\nimport { isMongooseLessThan7 } from './version'\nimport em from './em'\n\nconst remove = isMongooseLessThan7 ? 'remove' : 'deleteOne'\n\nconst toObjectOptions: ToObjectOptions = {\n  depopulate: true,\n  virtuals: false\n}\n\nconst updateMethods = [\n  'update',\n  'updateOne',\n  'replaceOne',\n  'updateMany',\n  'findOneAndUpdate',\n  'findOneAndReplace',\n  'findByIdAndUpdate'\n]\n\nconst deleteMethods = [\n  'remove',\n  'findOneAndDelete',\n  'findOneAndRemove',\n  'findByIdAndDelete',\n  'findByIdAndRemove',\n  'deleteOne',\n  'deleteMany'\n]\n", "function isHookIgnored<T> (options: QueryOptions<T>): boolean {\n  return options.ignoreHook === true || (options.ignoreEvent === true && options.ignorePatchHistory === true)\n}\n\nfunction splitUpdateAndCommands<T> (updateQuery: UpdateWithAggregationPipeline | UpdateQuery<T> | null): { update: UpdateQuery<T>, commands: Record<string, unknown>[] } {\n  let update: UpdateQuery<T> = {}\n  const commands: Record<string, unknown>[] = []\n\n  if (!_.isEmpty(updateQuery) && !_.isArray(updateQuery) && _.isObjectLike(updateQuery)) {\n    update = _.cloneDeep(updateQuery)\n    const keys = _.keys(update).filter((key) => key.startsWith('$'))", "  if (!_.isEmpty(updateQuery) && !_.isArray(updateQuery) && _.isObjectLike(updateQuery)) {\n    update = _.cloneDeep(updateQuery)\n    const keys = _.keys(update).filter((key) => key.startsWith('$'))\n    if (!_.isEmpty(keys)) {\n      _.forEach(keys, (key) => {\n        commands.push({ [key]: update[key] as unknown })\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete update[key]\n      })\n    }\n  }\n\n  return { update, commands }\n}\n", "function assignUpdate<T> (document: HydratedDocument<T>, update: UpdateQuery<T>, commands: Record<string, unknown>[]): HydratedDocument<T> {\n  let updated = assign(document, update)\n  _.forEach(commands, (command) => {\n    try {\n      updated = assign(updated, command)\n    } catch {\n      // we catch assign keys that are not implemented\n    }\n  })\n\n  return updated\n}\n\n/**\n * @description Patch patch event emitter\n */\nexport const patchEventEmitter = em\n\n/**\n * @description Patch history plugin\n * @param {Schema} schema\n * @param {IPluginOptions} opts\n * @returns {void}\n */", "export const patchHistoryPlugin = function plugin<T> (schema: Schema<T>, opts: IPluginOptions<T>): void {\n  schema.pre('save', async function () {\n    const current = this.toObject(toObjectOptions) as HydratedDocument<T>\n    const model = this.constructor as Model<T>\n\n    const context: IContext<T> = {\n      op: this.isNew ? 'create' : 'update',\n      modelName: opts.modelName ?? model.modelName,\n      collectionName: opts.collectionName ?? model.collection.collectionName,\n      createdDocs: [current]\n    }\n", "    if (this.isNew) {\n      await createPatch(opts, context)\n    } else {\n      const original = await model.findById(current._id).lean().exec()\n      if (original) {\n        await updatePatch(opts, context, current, original as HydratedDocument<T>)\n      }\n    }\n  })\n\n  schema.post('insertMany', async function (docs) {\n    const context = {\n      op: 'create',\n      modelName: opts.modelName ?? this.modelName,\n      collectionName: opts.collectionName ?? this.collection.collectionName,\n      createdDocs: docs as unknown as HydratedDocument<T>[]\n    }\n\n    await createPatch(opts, context)\n  })\n\n  schema.pre(updateMethods as MongooseQueryMiddleware[], async function (this: IHookContext<T>) {\n    const options = this.getOptions()", "    if (isHookIgnored(options)) return\n\n    const model = this.model as Model<T>\n    const filter = this.getFilter()\n    const count = await this.model.count(filter).exec()\n\n    this._context = {\n      op: this.op,\n      modelName: opts.modelName ?? this.model.modelName,\n      collectionName: opts.collectionName ?? this.model.collection.collectionName,\n      isNew: options.upsert && count === 0,\n      ignoreEvent: options.ignoreEvent as boolean,\n      ignorePatchHistory: options.ignorePatchHistory as boolean\n    }\n\n    const updateQuery = this.getUpdate()\n    const { update, commands } = splitUpdateAndCommands(updateQuery)\n\n    const cursor = model.find(filter).lean().cursor()\n    await cursor.eachAsync(async (doc: HydratedDocument<T>) => {\n      await updatePatch(opts, this._context, assignUpdate(doc, update, commands), doc)\n    })\n  })\n\n  schema.post(updateMethods as MongooseQueryMiddleware[], async function (this: IHookContext<T>) {\n    const options = this.getOptions()", "    if (isHookIgnored(options)) return\n\n    if (!this._context.isNew) return\n\n    const model = this.model as Model<T>\n    const updateQuery = this.getUpdate()\n    const { update, commands } = splitUpdateAndCommands(updateQuery)\n\n    const filter = assignUpdate({} as HydratedDocument<T>, update, commands)\n    if (!_.isEmpty(filter)) {\n      const current = await model.findOne(update).lean().exec()", "    if (!_.isEmpty(filter)) {\n      const current = await model.findOne(update).lean().exec()\n      if (current) {\n        this._context.createdDocs = [current] as HydratedDocument<T>[]\n\n        await createPatch(opts, this._context)\n      }\n    }\n  })\n\n  schema.pre(remove, { document: true, query: false }, async function () {\n    const original = this.toObject(toObjectOptions) as HydratedDocument<T>\n", "    if (opts.preDelete && !_.isEmpty(original)) {\n      await opts.preDelete([original])\n    }\n  })\n\n  schema.post(remove, { document: true, query: false }, async function (this: HydratedDocument<T>) {\n    const original = this.toObject(toObjectOptions) as HydratedDocument<T>\n    const model = this.constructor as Model<T>\n\n    const context: IContext<T> = {\n      op: 'delete',\n      modelName: opts.modelName ?? model.modelName,\n      collectionName: opts.collectionName ?? model.collection.collectionName,\n      deletedDocs: [original]\n    }\n\n    await deletePatch(opts, context)\n  })\n\n  schema.pre(deleteMethods as MongooseQueryMiddleware[], { document: false, query: true }, async function (this: IHookContext<T>) {\n    const options = this.getOptions()", "    if (isHookIgnored(options)) return\n\n    const model = this.model as Model<T>\n    const filter = this.getFilter()\n\n    this._context = {\n      op: this.op,\n      modelName: opts.modelName ?? this.model.modelName,\n      collectionName: opts.collectionName ?? this.model.collection.collectionName,\n      ignoreEvent: options.ignoreEvent as boolean,\n      ignorePatchHistory: options.ignorePatchHistory as boolean\n    }\n", "    if (['remove', 'deleteMany'].includes(this._context.op) && !options.single) {\n      const docs = await model.find(filter).lean().exec()\n      if (!_.isEmpty(docs)) {\n        this._context.deletedDocs = docs as HydratedDocument<T>[]\n      }\n    } else {\n      const doc = await model.findOne(filter).lean().exec()\n      if (!_.isEmpty(doc)) {\n        this._context.deletedDocs = [doc] as HydratedDocument<T>[]\n      }\n    }\n", "    if (opts.preDelete && _.isArray(this._context.deletedDocs) && !_.isEmpty(this._context.deletedDocs)) {\n      await opts.preDelete(this._context.deletedDocs)\n    }\n  })\n\n  schema.post(deleteMethods as MongooseQueryMiddleware[], { document: false, query: true }, async function (this: IHookContext<T>) {\n    const options = this.getOptions()\n    if (isHookIgnored(options)) return\n\n    await deletePatch(opts, this._context)\n  })\n}\n"]}
{"filename": "src/patch.ts", "chunked_list": ["import _ from 'lodash'\nimport omit from 'omit-deep'\nimport jsonpatch from 'fast-json-patch'\n\nimport type { HydratedDocument, Types } from 'mongoose'\n\nimport type IEvent from './interfaces/IEvent'\nimport type IContext from './interfaces/IContext'\nimport type IPluginOptions from './interfaces/IPluginOptions'\nimport type { User, Metadata } from './interfaces/IPluginOptions'\n\nimport History from './models/History'\nimport em from './em'\n", "import type IPluginOptions from './interfaces/IPluginOptions'\nimport type { User, Metadata } from './interfaces/IPluginOptions'\n\nimport History from './models/History'\nimport em from './em'\n\nfunction isPatchHistoryEnabled<T> (opts: IPluginOptions<T>, context: IContext<T>): boolean {\n  return !opts.patchHistoryDisabled && !context.ignorePatchHistory\n}\n\nexport function getObjects<T> (opts: IPluginOptions<T>, current: HydratedDocument<T>, original: HydratedDocument<T>): { currentObject: Partial<T>, originalObject: Partial<T> } {\n  let currentObject = JSON.parse(JSON.stringify(current)) as Partial<T>\n  let originalObject = JSON.parse(JSON.stringify(original)) as Partial<T>\n", "export function getObjects<T> (opts: IPluginOptions<T>, current: HydratedDocument<T>, original: HydratedDocument<T>): { currentObject: Partial<T>, originalObject: Partial<T> } {\n  let currentObject = JSON.parse(JSON.stringify(current)) as Partial<T>\n  let originalObject = JSON.parse(JSON.stringify(original)) as Partial<T>\n\n  if (opts.omit) {\n    currentObject = omit(currentObject, opts.omit)\n    originalObject = omit(originalObject, opts.omit)\n  }\n\n  return { currentObject, originalObject }\n}\n", "export async function getUser<T> (opts: IPluginOptions<T>): Promise<User | undefined> {\n  if (_.isFunction(opts.getUser)) {\n    return await opts.getUser()\n  }\n  return undefined\n}\n\nexport async function getReason<T> (opts: IPluginOptions<T>): Promise<string | undefined> {\n  if (_.isFunction(opts.getReason)) {\n    return await opts.getReason()\n  }\n  return undefined\n}\n", "  if (_.isFunction(opts.getReason)) {\n    return await opts.getReason()\n  }\n  return undefined\n}\n\nexport async function getMetadata<T> (opts: IPluginOptions<T>): Promise<Metadata | undefined> {\n  if (_.isFunction(opts.getMetadata)) {\n    return await opts.getMetadata()\n  }\n  return undefined\n}\n", "export function getValue <T> (item: PromiseSettledResult<T>): T | undefined {\n  return item.status === 'fulfilled' ? item.value : undefined\n}\n\nexport async function getData<T> (opts: IPluginOptions<T>): Promise<[User | undefined, string | undefined, Metadata | undefined]> {\n  return Promise\n    .allSettled([getUser(opts), getReason(opts), getMetadata(opts)])\n    .then(([user, reason, metadata]) => {\n      return [\n        getValue(user),\n        getValue(reason),\n        getValue(metadata)\n      ]\n    })\n}\n", "export function emitEvent<T> (context: IContext<T>, event: string | undefined, data: IEvent<T>): void {\n  if (event && !context.ignoreEvent) {\n    em.emit(event, data)\n  }\n}\n\nexport async function bulkPatch<T> (opts: IPluginOptions<T>, context: IContext<T>, eventKey: 'eventCreated' | 'eventDeleted', docsKey: 'createdDocs' | 'deletedDocs'): Promise<void> {\n  const history = isPatchHistoryEnabled(opts, context)\n  const event = opts[eventKey]\n  const docs = context[docsKey]\n  const key = eventKey === 'eventCreated' ? 'doc' : 'oldDoc'\n", "  if (_.isEmpty(docs) || (!event && !history)) return\n\n  const [user, reason, metadata] = await getData(opts)\n\n  const chunks = _.chunk(docs, 1000)\n  for await (const chunk of chunks) {\n    const bulk = []\n\n    for (const doc of chunk) {\n      emitEvent(context, event, { [key]: doc })\n", "    for (const doc of chunk) {\n      emitEvent(context, event, { [key]: doc })\n\n      if (history) {\n        bulk.push({\n          insertOne: {\n            document: {\n              op: context.op,\n              modelName: context.modelName,\n              collectionName: context.collectionName,\n              collectionId: doc._id as Types.ObjectId,\n              doc,\n              user,\n              reason,\n              metadata,\n              version: 0\n            }\n          }\n        })\n      }\n    }\n", "    if (history) {\n      await History.bulkWrite(bulk, { ordered: false })\n    }\n  }\n}\n\nexport async function createPatch<T> (opts: IPluginOptions<T>, context: IContext<T>): Promise<void> {\n  await bulkPatch(opts, context, 'eventCreated', 'createdDocs')\n}\n\nexport async function updatePatch<T> (opts: IPluginOptions<T>, context: IContext<T>, current: HydratedDocument<T>, original: HydratedDocument<T>): Promise<void> {\n  const history = isPatchHistoryEnabled(opts, context)\n\n  const { currentObject, originalObject } = getObjects(opts, current, original)", "export async function updatePatch<T> (opts: IPluginOptions<T>, context: IContext<T>, current: HydratedDocument<T>, original: HydratedDocument<T>): Promise<void> {\n  const history = isPatchHistoryEnabled(opts, context)\n\n  const { currentObject, originalObject } = getObjects(opts, current, original)\n  if (_.isEmpty(originalObject) || _.isEmpty(currentObject)) return\n\n  const patch = jsonpatch.compare(originalObject, currentObject, true)\n  if (_.isEmpty(patch)) return\n\n  emitEvent(context, opts.eventUpdated, { oldDoc: original, doc: current, patch })\n", "  if (history) {\n    let version = 0\n\n    const lastHistory = await History.findOne({ collectionId: original._id as Types.ObjectId }).sort('-version').exec()\n\n    if (lastHistory && lastHistory.version >= 0) {\n      version = lastHistory.version + 1\n    }\n\n    const [user, reason, metadata] = await getData(opts)\n\n    await History.create({\n      op: context.op,\n      modelName: context.modelName,\n      collectionName: context.collectionName,\n      collectionId: original._id as Types.ObjectId,\n      patch,\n      user,\n      reason,\n      metadata,\n      version\n    })\n  }\n}\n", "export async function deletePatch<T> (opts: IPluginOptions<T>, context: IContext<T>): Promise<void> {\n  await bulkPatch(opts, context, 'eventDeleted', 'deletedDocs')\n}\n"]}
{"filename": "src/version.ts", "chunked_list": ["import { satisfies } from 'semver'\nimport mongoose from 'mongoose'\n\nexport const isMongooseLessThan7 = satisfies(mongoose.version, '<7')\nexport const isMongoose6 = satisfies(mongoose.version, '6')\n\nif (isMongoose6) {\n  mongoose.set('strictQuery', false)\n}\n"]}
{"filename": "src/em.ts", "chunked_list": ["import EventEmitter from 'events'\n\nclass PatchEventEmitter extends EventEmitter {}\nconst em = new PatchEventEmitter()\n\nexport default em\n"]}
{"filename": "src/interfaces/IHistory.ts", "chunked_list": ["import type { Types } from 'mongoose'\nimport type { Operation } from 'fast-json-patch'\n\ninterface IHistory {\n  op: string\n  modelName: string,\n  collectionName: string\n  collectionId: Types.ObjectId\n  version: number\n  doc?: object\n  user?: object\n  reason?: string\n  metadata?: object\n  patch?: Operation[]\n}\n\nexport default IHistory\n"]}
{"filename": "src/interfaces/IPluginOptions.ts", "chunked_list": ["import type { HydratedDocument } from 'mongoose'\n\nexport type User = Record<string, unknown>\nexport type Metadata = Record<string, unknown>\n\ninterface IPluginOptions<T> {\n  modelName?: string\n  collectionName?: string\n  eventUpdated?: string\n  eventCreated?: string\n  eventDeleted?: string\n  getUser?: () => Promise<User> | User\n  getReason?: () => Promise<string> | string\n  getMetadata?: () => Promise<Metadata> | Metadata\n  omit?: string[]\n  patchHistoryDisabled?: boolean\n  preDelete?: (docs: HydratedDocument<T>[]) => Promise<void>\n}\n\nexport default IPluginOptions\n"]}
{"filename": "src/interfaces/IEvent.ts", "chunked_list": ["import type { Operation } from 'fast-json-patch'\nimport type { HydratedDocument } from 'mongoose'\n\ninterface IEvent<T> {\n  oldDoc?: HydratedDocument<T>\n  doc?: HydratedDocument<T>\n  patch?: Operation[]\n}\n\nexport default IEvent\n"]}
{"filename": "src/interfaces/IContext.ts", "chunked_list": ["import type { HydratedDocument } from 'mongoose'\n\ninterface IContext<T> {\n  op: string\n  modelName: string\n  collectionName: string\n  isNew?: boolean\n  createdDocs?: HydratedDocument<T>[]\n  deletedDocs?: HydratedDocument<T>[]\n  ignoreEvent?: boolean\n  ignorePatchHistory?: boolean\n}\n\nexport default IContext\n"]}
{"filename": "src/interfaces/IHookContext.ts", "chunked_list": ["import type { Query } from 'mongoose'\nimport type IContext from './IContext'\n\ntype IHookContext<T> = Query<T, T> & { op: string, _context: IContext<T> }\n\nexport default IHookContext\n"]}
{"filename": "src/models/History.ts", "chunked_list": ["import { Schema, model } from 'mongoose'\n\nimport type IHistory from '../interfaces/IHistory'\n\nconst HistorySchema = new Schema<IHistory>({\n  op: {\n    type: String,\n    required: true\n  },\n  modelName: {\n    type: String,\n    required: true\n  },\n  collectionName: {\n    type: String,\n    required: true\n  },\n  collectionId: {\n    type: Schema.Types.ObjectId,\n    required: true\n  },\n  doc: {\n    type: Object\n  },\n  patch: {\n    type: Array\n  },\n  user: {\n    type: Object\n  },\n  reason: {\n    type: String\n  },\n  metadata: {\n    type: Object\n  },\n  version: {\n    type: Number,\n    min: 0,\n    default: 0\n  }\n}, { timestamps: true })\n\nHistorySchema.index({ collectionId: 1, version: -1 })\nHistorySchema.index({ op: 1, modelName: 1, collectionName: 1, collectionId: 1, reason: 1, version: 1 })\n\nconst History = model('History', HistorySchema, 'history')\n\nexport default History\n"]}
{"filename": "src/modules/power-assign.d.ts", "chunked_list": ["declare module 'power-assign' {\n  export function assign<T, U>(object1: T, object2: U): T & U\n}\n"]}
{"filename": "src/modules/omit-deep.d.ts", "chunked_list": ["declare module 'omit-deep' {\n  export default function omitDeep<T>(value: T, keys: string[]): Partial<T>\n}\n"]}
