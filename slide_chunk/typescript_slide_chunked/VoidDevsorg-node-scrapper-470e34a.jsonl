{"filename": "dist/src/index.d.ts", "chunked_list": ["export * from '../src/engines';\nexport { default as Engine } from '../src/lib';\n"]}
{"filename": "dist/src/engines/index.d.ts", "chunked_list": ["export { Google } from './lib/Google';\nexport { Bing } from './lib/Bing';\nexport { Wikipedia } from './lib/Wikipedia';\nexport { YouTube } from './lib/YouTube';\n"]}
{"filename": "dist/src/engines/lib/Bing.d.ts", "chunked_list": ["import { Options } from \"../../types/Bing\";\nimport useProxies from \"../../utils/useProxies\";\nexport declare class Bing {\n    private options;\n    private updateQueries;\n    constructor(options?: Options);\n    useProxies: typeof useProxies;\n    search(query: string): Promise<{}>;\n    private _search;\n    suggestions(query: string): Promise<{}>;\n    private _suggestions;\n    images(query: string): Promise<{}>;\n}\n"]}
{"filename": "dist/src/engines/lib/YouTube.d.ts", "chunked_list": ["import { Options } from \"../../types/YouTube\";\nimport useProxies from \"../../utils/useProxies\";\nexport declare class YouTube {\n    private options;\n    private updateQueries;\n    constructor(options?: Options);\n    useProxies: typeof useProxies;\n    search(query: string): Promise<{}>;\n    private _search;\n}\n"]}
{"filename": "dist/src/engines/lib/Google.d.ts", "chunked_list": ["import { Options } from \"../../types/Google\";\nimport useProxies from \"../../utils/useProxies\";\nexport declare class Google {\n    private options;\n    private updateQueries;\n    constructor(options?: Options);\n    useProxies: typeof useProxies;\n    search(query: string): Promise<{}>;\n    private _search;\n    suggestions(query: string): Promise<{}>;\n    private _suggestions;\n    images(query: string): Promise<{}>;\n}\n"]}
{"filename": "dist/src/engines/lib/Wikipedia.d.ts", "chunked_list": ["import { Options } from \"../../types/Wikipedia\";\nimport useProxies from \"../../utils/useProxies\";\nexport declare class Wikipedia {\n    private options;\n    private updateQueries;\n    constructor(options?: Options);\n    useProxies: typeof useProxies;\n    get(query: string): Promise<{}>;\n    private _get;\n}\n"]}
{"filename": "dist/src/utils/handleUrl.d.ts", "chunked_list": ["export default function _url(url: string, queries: {}): string;\n"]}
{"filename": "dist/src/utils/useProxies.d.ts", "chunked_list": ["export default function useProxies(callback: Function): Promise<unknown>;\n"]}
{"filename": "dist/src/utils/getAgent.d.ts", "chunked_list": ["export default function getAgent(): string;\n"]}
{"filename": "dist/src/lib/index.d.ts", "chunked_list": ["import { Options as GoogleOptions } from '../types/Google';\nimport { Options as BingOptions } from '../types/Bing';\nimport { Options as WikipediaOptions } from '../types/Wikipedia';\nimport { Options as YouTubeOptions } from '../types/YouTube';\ndeclare const _default: {\n    google: (query: string, options?: GoogleOptions, engine?: 0 | 1) => Promise<{}>;\n    bing: (query: string, options?: BingOptions, engine?: 0 | 1) => Promise<{}>;\n    wikipedia: (query: string, options?: WikipediaOptions) => Promise<{}>;\n    youtube: (query: string, options?: YouTubeOptions) => Promise<{}>;\n};", "    youtube: (query: string, options?: YouTubeOptions) => Promise<{}>;\n};\nexport default _default;\n"]}
{"filename": "dist/src/types/Bing.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    };\n}\nexport interface Options {\n    mkt?: string;\n    page?: number;\n    perPage?: number;\n    safe?: 'off' | 'moderate' | 'strict';\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n", "export interface Options {\n    mkt?: string;\n    page?: number;\n    perPage?: number;\n    safe?: 'off' | 'moderate' | 'strict';\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n"]}
{"filename": "dist/src/types/YouTube.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    };\n}\nexport interface Options {\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n", "export interface Options {\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n"]}
{"filename": "dist/src/types/Google.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    };\n}\nexport interface Options {\n    mkt?: string;\n    page?: number;\n    perPage?: number;\n    safe?: 'off' | 'active' | 'high' | 'medium' | 'safeUndefined';\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n", "export interface Options {\n    mkt?: string;\n    page?: number;\n    perPage?: number;\n    safe?: 'off' | 'active' | 'high' | 'medium' | 'safeUndefined';\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n"]}
{"filename": "dist/src/types/Wikipedia.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    };\n}\nexport interface Options {\n    language?: string;\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n", "export interface Options {\n    language?: string;\n    headers?: {\n        [key: string]: any;\n    };\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}\n"]}
{"filename": "examples/youtube.spec.ts", "chunked_list": ["import { YouTube } from '../src';\nconst youtube = new YouTube({\n    proxies: [\n        // ...\n    ]\n});\n\nyoutube.search('Bar\u0131\u015f \u00d6zcan').then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n", "    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n"]}
{"filename": "examples/bing.spec.ts", "chunked_list": ["import { Bing } from '../src';\nconst bing = new Bing({\n    mkt: 'tr-tr',\n    perPage: 10,\n    safe: 'off',\n    proxies: [\n        // ...\n    ]\n});\n", "});\n\nbing.search('Youtube').then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n"]}
{"filename": "examples/index.spec.ts", "chunked_list": ["import { Engine } from '../src';\n\nEngine.google('Google', {\n    mkt: 'tr-TR',\n    perPage: 20,\n    safe: 'off',\n    proxies: [\n        // ...\n    ]\n}, 0).then(data => {", "    ]\n}, 0).then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n"]}
{"filename": "examples/google.spec.ts", "chunked_list": ["import { Google } from '../src';\nconst google = new Google({\n    mkt: 'tr-TR',\n    perPage: 5,\n    safe: 'off',\n    proxies: [\n        // ...\n    ]\n});\n", "});\n\ngoogle.suggestions('Google').then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n"]}
{"filename": "examples/wikipedia.spec.ts", "chunked_list": ["import { Wikipedia } from '../src';\nconst wikipedia = new Wikipedia({\n    language: 'tr',\n    proxies: [\n        // ...\n    ]\n});\n\nwikipedia.get('Google').then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n", "wikipedia.get('Google').then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from '../src/engines';\nexport { default as Engine } from '../src/lib';"]}
{"filename": "src/engines/index.ts", "chunked_list": ["export { Google } from './lib/Google';\nexport { Bing } from './lib/Bing';\nexport { Wikipedia } from './lib/Wikipedia';\nexport { YouTube } from './lib/YouTube';\n"]}
{"filename": "src/engines/lib/Wikipedia.ts", "chunked_list": ["import axios from \"axios\";\nimport { getOptions, Options } from \"../../types/Wikipedia\";\nimport * as cheerio from 'cheerio';\nimport HttpsProxyAgent from 'https-proxy-agent';\nimport _url from \"../../utils/handleUrl\";\nimport useProxies from \"../../utils/useProxies\";\nimport https from 'https';\n\nexport class Wikipedia {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n\n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n", "export class Wikipedia {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n\n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n\n        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async get(query: string): Promise<{}> {\n        const __proxy = this.options.proxy;", "        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async get(query: string): Promise<{}> {\n        const __proxy = this.options.proxy;", "        if (__proxy) {\n            this.options.proxies.push(__proxy);\n            this.options.proxy = undefined;\n        }\n\n        return await this.useProxies(() => this._get(query));\n    }\n\n    private async _get(query: string): Promise<{}> {\n        return new Promise(async (resolve, reject) => {\n            const agent = this.options.proxy ? HttpsProxyAgent({\n                host: this.options.proxy?.host,\n                port: this.options.proxy?.port,\n                auth: this.options.proxy?.auth ? this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password : undefined\n            }) : new https.Agent({\n                rejectUnauthorized: false\n            });\n\n            return await axios(Object.assign({\n                url: _url(`https://${this.options.language}.wikipedia.org/wiki/${query.replace(/ /g, '_')}`, this.options.queries),\n                method: 'GET',\n                headers: this.options.headers,\n            }, (agent ? {\n                proxy: this.options.proxy ? {\n                    host: this.options.proxy?.host,\n                    port: this.options.proxy?.port,\n                    auth: {\n                        username: this.options.proxy?.auth?.username,\n                        password: this.options.proxy?.auth?.password\n                    }\n                } : undefined,\n                httpsAgent: agent\n            } : {}))).then(response => {\n                const html = response.data;\n                const $ = cheerio.load(html);\n                let result: {\n                    title?: string,\n                    image?: string,\n                    description?: {\n                        clean?: string,\n                        links?: any[],\n                        markdown?: string\n                    }\n                    infobox?: any[]\n                } = {\n                    title: undefined,\n                    image: undefined,\n                    description: {\n                        clean: undefined,\n                        links: undefined,\n                        markdown: undefined\n                    },\n                    infobox: undefined\n                };\n\n                const fixText = (text: string) => text.replace(/(\\r\\n|\\n|\\r)/gm, '').replace(/\\s+/g, ' ').trim();\n                const formatLink = (text: string) => {\n                    let _ = text;\n                    const regex = /\\(([^)]+)\\)/;\n                    const match = regex.exec(_);", "                    if (match) {\n                        const m = match[1];\n                        _ = _.replace(`_(${m})`, '');\n                    }\n\n                    _ = _.replace('/wiki/', '').replace(/_/g, '+').toLowerCase();\n                    if (_.endsWith('.')) _ = _.slice(0, _.length - 1);\n\n                    return `https://nustry.com/search?q=${_}`\n                }\n\n                $('.mw-parser-output').each((i, element) => {\n                    const $element = $(element);\n                    const $p = $element.find('p').not('.mw-empty-elt');\n                    $p.find('sup').remove();\n                    $p.first().each((i, element) => {\n                        const $element = $(element);\n                        const text = $element.text();\n                        const links: any[] = [];\n                        $element.find('a').each((i, element) => {\n                            const $element = $(element);\n                            const href = $element.attr('href');", "                            if (href && href.startsWith('/wiki/')) {\n                                links.push({\n                                    href: href,\n                                    text: $element.text()\n                                })\n                            }\n                        });\n                        \n                        result.description.clean = fixText(text);\n                        result.description.links = links;\n                        result.description.markdown = links.reduce((prev, curr) => {\n                            return prev.replace(curr.text, `[${curr.text}](${formatLink(curr.href)})`);\n                        }, fixText(text));\n                    });\n                });\n\n                $('.infobox').each((i, element) => {\n                    const $element = $(element);\n                    result.title = $element.find('caption').first().text();\n                    result.image = $element.find('a.image img').first().attr('src');\n                    const $tr = $element.find('tr');\n                    let values: any[] = [];\n                    $tr.each((i, element) => {\n                        const $element = $(element);\n                        const $th = $element.find('th');\n                        const $td = $element.find('td');\n                        $td.find('sup').remove();\n                        const th = $th.text();", "                        if (!th) return;\n                        const isHaveLI = $td.find('li').length > 0;\n                        const isHaveTable = $td.find('table').length > 0;\n                        const isHaveBR = $td.find('br').length > 0;\n\n                        let res: any = [fixText($td.text())];\n                        if (isHaveLI) {\n                            const $li = $td.find('li');\n                            const li: string[] = [];\n                            $li.each((i, element) => {\n                                const $element = $(element);\n                                li.push(fixText($element.text()));\n                            });\n                            res = li;", "                        } else if (isHaveTable) {\n                            const $table = $td.find('table');\n                            const table: {\n                                [key: string]: any\n                            } = {};\n                            $table.each((i, element) => {\n                                const $element = $(element);\n                                const $tr = $element.find('tr');\n                                $tr.each((i, element) => {\n                                    const $element = $(element);\n                                    const $th = $element.find('th');\n                                    const $td = $element.find('td');\n                                    const th = fixText($th.text());", "                                    if (!th) return;\n                                    table[th] = fixText($td.text());\n                                });\n                            });\n                            res = table;\n                        } else if (isHaveBR) {\n                            const removeTags = (text: string) => text.replace(/(<([^>]+)>)/gi, '');\n                            res = $td.html().split('<br>').map((text: string) => {\n                                return fixText(removeTags(text));\n                            })\n                        }\n\n                        const response = res;\n                        const $a = $td.find('a');\n                        const href = $a.attr('href');\n                        let links: any[] = [];", "                        if (href) {\n                            $a.map((i, element) => {\n                                const $element = $(element);\n                                links.push({\n                                    href: $element.attr('href'),\n                                    text: $element.text(),\n                                    isFound: $element.attr('href').startsWith('/wiki/')\n                                });\n                            });\n                        }\n\n                        const _ = {\n                            label: th,\n                            response: {\n                                clean: response,\n                                markdown: links.reduce((prev, curr) => {\n                                    return prev.replace(curr.text, `[${curr.text}](${formatLink(curr.href)})`);\n                                }, fixText($td.text()))\n                            },\n                            links\n                        };\n\n                        values.push(_);\n                    });\n\n                    result['infobox'] = values\n                });\n\n                const data = {\n                    result,\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "            }).catch(error => {\n                return reject(error);\n            });\n        });\n    }\n}"]}
{"filename": "src/engines/lib/Bing.ts", "chunked_list": ["import axios from \"axios\";\nimport { getOptions, Options } from \"../../types/Bing\";\nimport * as cheerio from 'cheerio';\nimport HttpsProxyAgent from 'https-proxy-agent';\nimport _url from \"../../utils/handleUrl\";\nimport useProxies from \"../../utils/useProxies\";\nimport https from 'https';\n\nexport class Bing {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n\n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n", "export class Bing {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n\n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n\n        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n", "        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n\n        if (_options?.mkt) {\n            if (!_options?.queries?.mkt) updateQueries('mkt', _options?.mkt);\n            if (!_options?.queries?.setlang) updateQueries('setlang', _options?.mkt);\n        }\n", "            if (!_options?.queries?.mkt) updateQueries('mkt', _options?.mkt);\n            if (!_options?.queries?.setlang) updateQueries('setlang', _options?.mkt);\n        }\n\n        if (_options?.safe) {\n            if (!_options?.queries?.safe) updateQueries('safeSearch', _options?.safe);\n        }\n\n        if (_options?.perPage) {\n            if (!_options?.queries?.count) updateQueries('count', _options?.perPage);\n            if (!_options?.queries?.offset) updateQueries('offset', (_options?.perPage * (_options?.page - 1)));\n        }\n", "        if (_options?.perPage) {\n            if (!_options?.queries?.count) updateQueries('count', _options?.perPage);\n            if (!_options?.queries?.offset) updateQueries('offset', (_options?.perPage * (_options?.page - 1)));\n        }\n\n        if (!_options?.queries?.pt) updateQueries('pt', 'page.serp');\n        if (!_options?.queries?.mkt) updateQueries('mkt', 'en-us');\n        if (!_options?.queries?.cp) updateQueries('cp', 6);\n        if (!_options?.queries?.msbqf) updateQueries('msbqf', false);\n        if (!_options?.queries?.cvid) updateQueries('cvid', 'void_development');\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async search(query: string): Promise<{}> {", "        if (!_options?.queries?.msbqf) updateQueries('msbqf', false);\n        if (!_options?.queries?.cvid) updateQueries('cvid', 'void_development');\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async search(query: string): Promise<{}> {\n        if (!this.options?.queries?.bq) this.updateQueries('bq', query);\n        if (!this.options?.queries?.q) this.updateQueries('q', query);", "        if (!this.options?.queries?.bq) this.updateQueries('bq', query);\n        if (!this.options?.queries?.q) this.updateQueries('q', query);\n        if (!this.options?.queries?.qry) this.updateQueries('qry', query);\n        const __proxy = this.options.proxy;\n        if (__proxy) {\n            this.options.proxies.push(__proxy);\n            this.options.proxy = undefined;\n        }\n\n        return await this.useProxies(() => this._search(query));\n    }\n\n    private async _search(query: string): Promise<{}> {\n        return new Promise(async (resolve, reject) => {\n            const agent = this.options.proxy ? HttpsProxyAgent({\n                host: this.options.proxy?.host,\n                port: this.options.proxy?.port,\n                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n            }) : new https.Agent({\n                rejectUnauthorized: false\n            });\n\n            return await axios(Object.assign({\n                url: _url(`https://www.bing.com/search`, this.options.queries),\n                method: 'GET',\n                headers: this.options.headers\n            }, (agent ? {\n                proxy: this.options.proxy ? {\n                    host: this.options.proxy?.host,\n                    port: this.options.proxy?.port,\n                    auth: {\n                        username: this.options.proxy?.auth?.username,\n                        password: this.options.proxy?.auth?.password\n                    }\n                } : undefined,\n                httpsAgent: agent\n            } : {}))).then(response => {\n                const html = response.data;\n                const $ = cheerio.load(html);\n                const results: any[] = [];\n\n                $('#b_results .b_algo').each((i, el) => {\n                    const title = $(el).find('h2 a').first().text();\n                    const description = $(el).find('.b_algoSlug').each((i, el) => {\n                        $(el).find('span').remove();\n                    }).text();\n                    const link = $(el).find('a').first().attr('href');\n                    const deepLinks: any[] = [];\n\n                    $(el).find('.b_deep li').each((i, el) => {\n                        deepLinks.push({\n                            title: $(el).find('a').text(),\n                            link: $(el).find('a').attr('href'),\n                            description: $(el).find('p').text()\n                        });\n                    });\n\n                    results.push({\n                        title,\n                        description,\n                        link,\n                        deepLinks\n                    });\n                });\n                const data = {\n                    results,\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "            }).catch(error => {\n                return reject(error);\n            });\n        });\n    }\n\n    public async suggestions(query: string): Promise<{}> {\n        if (!this.options?.queries?.bq) this.updateQueries('bq', query);\n        if (!this.options?.queries?.q) this.updateQueries('q', query);\n        if (!this.options?.queries?.qry) this.updateQueries('qry', query);\n        const __proxy = this.options.proxy;", "        if (!this.options?.queries?.q) this.updateQueries('q', query);\n        if (!this.options?.queries?.qry) this.updateQueries('qry', query);\n        const __proxy = this.options.proxy;\n        if (__proxy) {\n            this.options.proxies.push(__proxy);\n            this.options.proxy = undefined;\n        }\n\n        return await this.useProxies(() => this._suggestions(query));\n    }\n\n    private async _suggestions(query: string): Promise<{}> {\n        return new Promise(async (resolve, reject) => {\n            const agent = this.options.proxy ? HttpsProxyAgent({\n                host: this.options.proxy?.host,\n                port: this.options.proxy?.port,\n                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n            }) : new https.Agent({\n                rejectUnauthorized: false\n            });\n\n            return await axios(Object.assign({\n                url: _url(`https://www.bing.com/AS/Suggestions`, this.options.queries),\n                method: 'GET',\n                headers: this.options.headers\n            }, (agent ? {\n                proxy: this.options.proxy ? {\n                    host: this.options.proxy?.host,\n                    port: this.options.proxy?.port,\n                    auth: {\n                        username: this.options.proxy?.auth?.username,\n                        password: this.options.proxy?.auth?.password\n                    }\n                } : undefined,\n                httpsAgent: agent\n            } : {}))).then(response => {\n                const html = response.data;\n                const $ = cheerio.load(html);\n                const suggestions: any[] = [];\n\n                $('#sa_ul li').each((i, el) => {\n                    suggestions.push({\n                        text: $(el).find('.pp_title').text() || $(el).find('.sa_tm_text').text() || null,\n                        image: $(el).find('img').attr('src') ? 'https://th.bing.com' + $(el).find('img').attr('src') : null\n                    });\n                });\n\n                const data = {\n                    suggestions: suggestions.filter(s => s.text),\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "            }).catch(error => {\n                return reject(error);\n            });\n        });\n    }\n\n    public async images(query: string): Promise<{}> {\n        return new Error('Not implemented yet');\n    }\n}"]}
{"filename": "src/engines/lib/Google.ts", "chunked_list": ["import axios from \"axios\";\nimport { getOptions, Options } from \"../../types/Google\";\nimport * as cheerio from 'cheerio';\nimport HttpsProxyAgent from 'https-proxy-agent';\nimport _url from \"../../utils/handleUrl\";\nimport useProxies from \"../../utils/useProxies\";\nimport https from 'https';\n\nexport class Google {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n    \n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n", "export class Google {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n    \n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n\n        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n", "        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n\n        if (_options?.mkt) {\n            if (!_options?.queries?.lr) updateQueries('lr', 'lang_' + (_options?.mkt?.split('-')?.[0] || 'en'));\n            if (!_options?.queries?.hl) updateQueries('hl', _options?.mkt?.split('-')?.[0] || 'en');\n            if (!_options?.queries?.gl) updateQueries('gl', _options?.mkt?.split('-')?.[1] || 'US');\n        }\n", "            if (!_options?.queries?.lr) updateQueries('lr', 'lang_' + (_options?.mkt?.split('-')?.[0] || 'en'));\n            if (!_options?.queries?.hl) updateQueries('hl', _options?.mkt?.split('-')?.[0] || 'en');\n            if (!_options?.queries?.gl) updateQueries('gl', _options?.mkt?.split('-')?.[1] || 'US');\n        }\n\n        if (_options?.safe) {\n            if (!_options?.queries?.safe) updateQueries('safe', _options?.safe);\n        }\n\n        if (_options?.perPage) {\n            if (!_options?.queries?.num) updateQueries('num', _options?.perPage);", "        if (_options?.perPage) {\n            if (!_options?.queries?.num) updateQueries('num', _options?.perPage);\n            if (!_options?.queries?.start) updateQueries('start', (_options?.page - 1) * _options?.perPage);\n        }\n\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async search(query: string): Promise<{}> {", "        if (!this.options?.queries?.q) this.updateQueries('q', query);\n        const __proxy = this.options.proxy;\n        if (__proxy) {\n            this.options.proxies.push(__proxy);\n            this.options.proxy = undefined;\n        }\n        \n        return await this.useProxies(() => this._search(query));\n    }\n\n    private async _search(query: string): Promise<{}> {\n        return new Promise(async (resolve, reject) => {\n            const agent = this.options.proxy ? HttpsProxyAgent({\n                host: this.options.proxy?.host,\n                port: this.options.proxy?.port,\n                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n            }) : new https.Agent({\n                rejectUnauthorized: false\n            });\n            \n            return await axios(Object.assign({\n                url: _url(`https://www.google.com/search`, this.options.queries),\n                method: 'GET',\n                headers: this.options.headers\n            }, (agent ? {\n                proxy: this.options.proxy ? {\n                    host: this.options.proxy?.host,\n                    port: this.options.proxy?.port,\n                    auth: {\n                        username: this.options.proxy?.auth?.username,\n                        password: this.options.proxy?.auth?.password\n                    }\n                } : undefined,\n                httpsAgent: agent\n            } : {}))).then(response => {\n                const html = response.data;\n                const $ = cheerio.load(html);\n                const results: any[] = [];\n                const stats: any = {};\n                const relatedSearches: any[] = [];\n\n                $('#search .g').each((i, elem) => {", "                    if ($(elem).hasClass('VjDLd')) return;\n                    const favicon = $(elem).find('img').first().attr('src');\n                    const title = $(elem).find('.DKV0Md').first().text();\n                    const link = $(elem).find('a').first().attr('href');\n                    const description = $(elem).find('.yDYNvb').first().text();\n                    const deepLinks: any[] = [];\n\n                    $(elem).find('.mslg').each((i, elem) => {\n                        const h3 = $(elem).find('h3').text();\n                        const link = $(elem).find('a').attr('href');\n                        const description = $(elem).find('.zz3gNc').text();\n\n                        deepLinks.push({\n                            title: h3,\n                            link: link?.replace('/url?q=', ''),\n                            description\n                        });\n                    });\n\n                    $(elem).find('.XN9cAe').each((i, elem) => {\n                        const h3 = $(elem).find('h3').text();\n                        const link = $(elem).find('a').attr('href');\n                        const description = $(elem).find('.yDYNvb').text();\n\n                        deepLinks.push({\n                            title: h3,\n                            link: link?.replace('/url?q=', ''),\n                            description\n                        });\n                    });\n\n                    results.push({\n                        favicon,\n                        title,\n                        link,\n                        description,\n                        deepLinks\n                    });\n                });\n\n                const resultStats = $('#result-stats').text();", "                if (resultStats.match(/\\(([^)]+)\\)/)) {\n                    const onlyInBrackets = resultStats.match(/\\(([^)]+)\\)/);\n                    const onlyNumbers = resultStats.split(onlyInBrackets[0])[0].match(/\\d+/g).join('');\n                    stats.totalResults = Number(onlyNumbers);\n                    stats.timeTaken = onlyInBrackets[1];\n                }\n\n                $('#botstuff').each((i, elem) => {\n                    $(elem).find('b').each((i, elem) => {\n                        relatedSearches.push($(elem).text());\n                    });\n                });\n\n                const data = {\n                    results,\n                    relatedSearches,\n                    stats,\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "            }).catch(error => {\n                return reject(error);\n            });\n        });\n    }\n\n    public async suggestions(query: string): Promise<{}> {\n        if (!this.options?.queries?.q) this.updateQueries('q', query);\n        this.updateQueries('cp', 6);\n        this.updateQueries('xssi', 't');\n        this.updateQueries('authuser', 0);\n        this.updateQueries('client', 'gws-wiz');\n        this.updateQueries('dpr', 1);\n\n        const __proxy = this.options.proxy;", "        if (__proxy) {\n            this.options.proxies.push(__proxy);\n            this.options.proxy = undefined;\n        }\n\n        return await this.useProxies(() => this._suggestions(query));\n    }\n\n    private async _suggestions(query: string): Promise<{}> {\n        return new Promise(async (resolve, reject) => {\n            const agent = this.options.proxy ? HttpsProxyAgent({\n                host: this.options.proxy?.host,\n                port: this.options.proxy?.port,\n                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n            }) : new https.Agent({\n                rejectUnauthorized: false\n            });\n\n            return await axios(Object.assign({\n                url: _url(`https://www.google.com/complete/search`, this.options.queries),\n                method: 'GET',\n                headers: this.options.headers\n            }, (agent ? {\n                proxy: this.options.proxy ? {\n                    host: this.options.proxy?.host,\n                    port: this.options.proxy?.port,\n                    auth: {\n                        username: this.options.proxy?.auth?.username,\n                        password: this.options.proxy?.auth?.password\n                    }\n                } : undefined,\n                httpsAgent: agent\n            } : {}))).then(response => {\n                const html = response.data;\n                const suggestions: any[] = [];\n                const _data = html.split(')]}\\'')[1];\n                const json = JSON.parse(_data);\n\n                json[0].forEach((elem: any) => {\n                    const string = elem[0];\n                    const type = elem[1];\n                    const weight = elem[2];\n                    const data = elem[3];\n\n                    suggestions.push({\n                        string: {\n                            text: string.replace(/<b>/g, '').replace(/<\\/b>/g, ''),\n                            html: string,\n                            markdown: string.replace(/<b>/g, '**').replace(/<\\/b>/g, '**')\n                        },\n                        type,\n                        weight,\n                        data\n                    });\n                });\n\n                const data = {\n                    suggestions,\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "            }).catch(error => {\n                console.log(error);\n                return reject(error);\n            });\n        });\n    }\n\n    public async images(query: string): Promise<{}> {\n        return new Error('Not implemented yet');\n    }\n}"]}
{"filename": "src/engines/lib/YouTube.ts", "chunked_list": ["import axios from \"axios\";\nimport { getOptions, Options } from \"../../types/YouTube\";\nimport * as cheerio from 'cheerio';\nimport HttpsProxyAgent from 'https-proxy-agent';\nimport _url from \"../../utils/handleUrl\";\nimport useProxies from \"../../utils/useProxies\";\nimport https from 'https';\n\nexport class YouTube {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n\n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n", "export class YouTube {\n    private options: Options = getOptions();\n    private updateQueries: (name: string, value: any) => void;\n\n    constructor(options: Options = getOptions()) {\n        let _options = {\n            ...getOptions(),\n            ...options\n        };\n\n        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async search(query: string): Promise<{}> {\n        this.updateQueries('search_query', encodeURIComponent(query));\n        const __proxy = this.options.proxy;", "        function updateQueries(name: string, value: any) {\n            _options.queries = {\n                ..._options.queries,\n                [name]: value\n            }\n        }\n\n        this.updateQueries = updateQueries;\n        this.options = _options;\n    }\n\n    useProxies = useProxies;\n    public async search(query: string): Promise<{}> {\n        this.updateQueries('search_query', encodeURIComponent(query));\n        const __proxy = this.options.proxy;", "        if (__proxy) {\n            this.options.proxies.push(__proxy);\n            this.options.proxy = undefined;\n        }\n\n        return await this.useProxies(() => this._search(query));\n    }\n\n    private async _search(query: string): Promise<{}> {\n        return new Promise(async (resolve, reject) => {\n            const agent = this.options.proxy ? HttpsProxyAgent({\n                host: this.options.proxy?.host,\n                port: this.options.proxy?.port,\n                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n            }) : new https.Agent({\n                rejectUnauthorized: false\n            });\n\n            return await axios(Object.assign({\n                url: _url(`https://www.youtube.com/results`, this.options.queries),\n                method: 'GET',\n                headers: this.options.headers\n            }, (agent ? {\n                proxy: this.options.proxy ? {\n                    host: this.options.proxy?.host,\n                    port: this.options.proxy?.port,\n                    auth: {\n                        username: this.options.proxy?.auth?.username,\n                        password: this.options.proxy?.auth?.password\n                    }\n                } : undefined,\n                httpsAgent: agent\n            } : {}))).then((response) => {\n                const html = response.data;\n                const $ = cheerio.load(html);\n\n                let results: any[] = [];\n                $('script').each((index, element) => {\n                    const text = $(element).text();", "                    if (text.includes('ytInitialData')) {\n                        const regex = /var ytInitialData = \\{(.|\\n)*\\}/gm;\n                        const data = text.match(regex);\n                        if (data) {\n                            const json = JSON.parse(data[0].replace('var ytInitialData = ', ''));\n                            const contents = json.contents.twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer.contents[0].itemSectionRenderer.contents.filter((content: any) => content.videoRenderer);\n                            for (let i = 0; i < contents.length; i++) {\n                                const content = contents[i];\n                                if (content.videoRenderer) {\n                                    const video = content.videoRenderer;\n                                    const result = {\n                                        id: video.videoId,\n                                        title: video.title.runs[0].text,\n                                        description: video.detailedMetadataSnippets?.[0]?.snippetText?.runs?.map((run: any) => run.text).join('') || null,\n                                        duration: video.lengthText?.simpleText,\n                                        views: Number(video.viewCountText?.simpleText?.replace(/[^0-9]/g, '')),\n                                        thumbnail: video.thumbnail.thumbnails[0].url,\n                                        channel: {\n                                            id: video.ownerText.runs[0].navigationEndpoint.browseEndpoint.browseId,\n                                            name: video.ownerText.runs[0].text,\n                                            url: video.ownerText.runs[0].navigationEndpoint.browseEndpoint.canonicalBaseUrl,\n                                            verified: video.ownerBadges[0]?.metadataBadgeRenderer.tooltip === 'Verified' ? true : false\n                                        },\n                                        url: video.navigationEndpoint.commandMetadata.webCommandMetadata.url,\n                                        published: video.publishedTimeText?.simpleText\n                                    };\n                                    results.push(result);\n                                }\n                            }\n                        }\n                    }\n                });\n\n                const data = {\n                    results,\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "                                if (content.videoRenderer) {\n                                    const video = content.videoRenderer;\n                                    const result = {\n                                        id: video.videoId,\n                                        title: video.title.runs[0].text,\n                                        description: video.detailedMetadataSnippets?.[0]?.snippetText?.runs?.map((run: any) => run.text).join('') || null,\n                                        duration: video.lengthText?.simpleText,\n                                        views: Number(video.viewCountText?.simpleText?.replace(/[^0-9]/g, '')),\n                                        thumbnail: video.thumbnail.thumbnails[0].url,\n                                        channel: {\n                                            id: video.ownerText.runs[0].navigationEndpoint.browseEndpoint.browseId,\n                                            name: video.ownerText.runs[0].text,\n                                            url: video.ownerText.runs[0].navigationEndpoint.browseEndpoint.canonicalBaseUrl,\n                                            verified: video.ownerBadges[0]?.metadataBadgeRenderer.tooltip === 'Verified' ? true : false\n                                        },\n                                        url: video.navigationEndpoint.commandMetadata.webCommandMetadata.url,\n                                        published: video.publishedTimeText?.simpleText\n                                    };\n                                    results.push(result);\n                                }\n                            }\n                        }\n                    }\n                });\n\n                const data = {\n                    results,\n                    proxy: this.options.proxy,\n                    queries: this.options.queries\n                };\n\n                return resolve(data);", "            }).catch(error => {\n                return reject(error);\n            });\n        });\n    }\n}"]}
{"filename": "src/utils/handleUrl.ts", "chunked_list": ["export default function _url(url: string, queries: {}): string {\n    if (url.includes('?')) {\n        url += '&' + Object.keys(queries || {}).map(key => `${key}=${(queries as any)[key]}`).join('&');\n    } else {\n        url += '?' + Object.keys(queries || {}).map(key => `${key}=${(queries as any)[key]}`).join('&');\n    }\n\n    return url;\n}"]}
{"filename": "src/utils/useProxies.ts", "chunked_list": ["export default function useProxies(callback: Function) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const _proxy = Array.isArray(this.options.proxies);\n            if (this.options.proxies && _proxy) {\n                for (let i = 0; i < this.options.proxies.length; i++) {\n                    const proxy = this.options.proxies[i];\n                    this.options.proxy = proxy;\n                    try {\n                        const cb = await callback();\n                        return resolve(cb);", "                    try {\n                        const cb = await callback();\n                        return resolve(cb);\n                    } catch (error) {\n                        if (this.options.proxies.length - 1 === i) {\n                            throw new Error(error);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            const cb = await callback();\n            return resolve(cb);", "        } catch (error) {\n            return reject(error);\n        }\n    })\n}"]}
{"filename": "src/utils/getAgent.ts", "chunked_list": ["export default function getAgent(): string {\n    const agents: string[] = [\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\"\n    ];\n\n    return agents[Math.floor(Math.random() * agents.length)];\n}"]}
{"filename": "src/lib/index.ts", "chunked_list": ["import * as Engines from '../engines';\n\n// TYPES\nimport { getOptions as getGoogleOptions, Options as GoogleOptions } from '../types/Google';\nimport { getOptions as getBingOptions, Options as BingOptions } from '../types/Bing';\nimport { getOptions as getWikipediaOptions, Options as WikipediaOptions } from '../types/Wikipedia';\nimport { getOptions as getYouTubeOptions, Options as YouTubeOptions } from '../types/YouTube';\n\n\nexport default {", "\nexport default {\n    /*\n        *   Google\n        @param query: string\n        @param options: GoogleOptions\n        @param engine: 0 = Google, 1 = Google Suggestions\n    */\n    google: (query: string, options: GoogleOptions = getGoogleOptions(), engine: 0 | 1 = 0) => {\n        if (engine === 0) return new Engines.Google(options).search(query);\n        else if (engine === 1) return new Engines.Google(options).suggestions(query);\n\n        return new Engines.Google(options).search(query);\n    },\n    /*\n        *   Bing\n        @param query: string\n        @param options: GoogleOptions\n        @param engine: 0 = Google, 1 = Google Suggestions\n    */\n    bing: (query: string, options: BingOptions = getBingOptions(), engine: 0 | 1 = 0) => {", "    google: (query: string, options: GoogleOptions = getGoogleOptions(), engine: 0 | 1 = 0) => {\n        if (engine === 0) return new Engines.Google(options).search(query);\n        else if (engine === 1) return new Engines.Google(options).suggestions(query);\n\n        return new Engines.Google(options).search(query);\n    },\n    /*\n        *   Bing\n        @param query: string\n        @param options: GoogleOptions\n        @param engine: 0 = Google, 1 = Google Suggestions\n    */\n    bing: (query: string, options: BingOptions = getBingOptions(), engine: 0 | 1 = 0) => {", "        if (engine === 0) return new Engines.Bing(options).search(query);\n        else if (engine === 1) return new Engines.Bing(options).suggestions(query);\n\n        return new Engines.Bing(options).search(query);\n    },\n    wikipedia: (query: string, options: WikipediaOptions = getWikipediaOptions()) => {\n        return new Engines.Wikipedia(options).get(query);\n    },\n    youtube: (query: string, options: YouTubeOptions = getYouTubeOptions()) => {\n        return new Engines.YouTube(options).search(query);\n    }\n}; "]}
{"filename": "src/types/Wikipedia.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\nexport const getOptions = (): Options => {\n    return {\n        language: 'en',\n        headers: {\n            'Connection': 'keep-alive',\n            'Host': 'www.wikipedia.com',\n            'Pragma': 'no-cache',\n            'Referer': 'https://www.wikipedia.com/',", "            'Pragma': 'no-cache',\n            'Referer': 'https://www.wikipedia.com/',\n            'Sec-Fetch-Mode': 'navigate',\n            'Sec-Fetch-Site': 'same-origin',\n            'Sec-Fetch-User': '?1',\n            'Upgrade-Insecure-Requests': '1',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n            'accept-encoding': 'gzip, deflate, br',\n            'accept-language': 'en-US,en;q=0.9',\n            'cache-control': 'no-cache',", "            'accept-language': 'en-US,en;q=0.9',\n            'cache-control': 'no-cache',\n            'sec-ch-ua-arch': '\"x86\"',\n            'sec-ch-ua-bitness': '\"64\"',\n            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-model': '',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-ch-ua-platform-version': '\"10.0.0\"',", "            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-ch-ua-platform-version': '\"10.0.0\"',\n            'sec-ch-ua-wow64': '?0',\n            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n            'User-Agent': getAgent()\n        }\n    }\n\n}\n\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    }\n}\n", "}\n\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    }\n}\n", "export interface Options {\n    language?: string;\n    headers?: {\n        [key: string]: any;\n    }\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}"]}
{"filename": "src/types/Bing.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\nexport const getOptions = (): Options => {\n    return {\n        mkt: 'en-US',\n        page: 1,\n        perPage: 10,\n        safe: 'off',\n        headers: {\n            'Connection': 'keep-alive',", "        headers: {\n            'Connection': 'keep-alive',\n            'Host': 'www.bing.com',\n            'Pragma': 'no-cache',\n            'Referer': 'https://www.bing.com/',\n            'Sec-Fetch-Mode': 'navigate',\n            'Sec-Fetch-Site': 'same-origin',\n            'Sec-Fetch-User': '?1',\n            'Upgrade-Insecure-Requests': '1',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',", "            'Upgrade-Insecure-Requests': '1',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n            'accept-encoding': 'gzip, deflate, br',\n            'accept-language': 'en-US,en;q=0.9',\n            'cache-control': 'no-cache',\n            'sec-ch-ua-arch': '\"x86\"',\n            'sec-ch-ua-bitness': '\"64\"',\n            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n            'sec-ch-ua-mobile': '?0',", "            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-model': '',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-ch-ua-platform-version': '\"10.0.0\"',\n            'sec-ch-ua-wow64': '?0',\n            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n            'User-Agent': getAgent()\n        }\n    }", "        }\n    }\n\n}\n\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    }\n}\n", "export interface Options {\n    mkt?: string;\n    page?: number;\n    perPage?: number;\n    safe?: 'off' | 'moderate' | 'strict';\n    headers?: {\n        [key: string]: any;\n    }\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}"]}
{"filename": "src/types/Google.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\nexport const getOptions = (): Options => {\n    return {\n        mkt: 'en-US',\n        page: 1,\n        perPage: 10,\n        safe: 'off',\n        headers: {\n            'Connection': 'keep-alive',", "        headers: {\n            'Connection': 'keep-alive',\n            'Host': 'www.google.com',\n            'Pragma': 'no-cache',\n            'Referer': 'https://www.google.com/',\n            'Sec-Fetch-Mode': 'navigate',\n            'Sec-Fetch-Site': 'same-origin',\n            'Sec-Fetch-User': '?1',\n            'Upgrade-Insecure-Requests': '1',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',", "            'Upgrade-Insecure-Requests': '1',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n            'accept-encoding': 'gzip, deflate, br',\n            'accept-language': 'en-US,en;q=0.9',\n            'cache-control': 'no-cache',\n            'sec-ch-ua-arch': '\"x86\"',\n            'sec-ch-ua-bitness': '\"64\"',\n            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n            'sec-ch-ua-mobile': '?0',", "            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-model': '',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-ch-ua-platform-version': '\"10.0.0\"',\n            'sec-ch-ua-wow64': '?0',\n            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n            'User-Agent': getAgent()\n        }\n    }", "        }\n    }\n\n}\n\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    }\n}\n", "export interface Options {\n    mkt?: string;\n    page?: number;\n    perPage?: number;\n    safe?: 'off' | 'active' | 'high' | 'medium' | 'safeUndefined';\n    headers?: {\n        [key: string]: any;\n    }\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}"]}
{"filename": "src/types/YouTube.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\nexport const getOptions = (): Options => {\n    return {\n        headers: {\n            'Connection': 'keep-alive',\n            'Host': 'www.youtube.com',\n            'Pragma': 'no-cache',\n            'Referer': 'https://www.youtube.com/results?search_query=',\n            'Sec-Fetch-Mode': 'navigate',", "            'Referer': 'https://www.youtube.com/results?search_query=',\n            'Sec-Fetch-Mode': 'navigate',\n            'Sec-Fetch-Site': 'same-origin',\n            'Sec-Fetch-User': '?1',\n            'Upgrade-Insecure-Requests': '1',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n            'accept-encoding': 'gzip, deflate, br',\n            'accept-language': 'en-US,en;q=0.9',\n            'cache-control': 'no-cache',\n            'sec-ch-ua-arch': '\"x86\"',", "            'cache-control': 'no-cache',\n            'sec-ch-ua-arch': '\"x86\"',\n            'sec-ch-ua-bitness': '\"64\"',\n            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-model': '',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-ch-ua-platform-version': '\"10.0.0\"',\n            'sec-ch-ua-wow64': '?0',", "            'sec-ch-ua-platform-version': '\"10.0.0\"',\n            'sec-ch-ua-wow64': '?0',\n            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n            'User-Agent': getAgent()\n        }\n    }\n\n}\n\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    }\n}\n", "\nexport interface _proxy {\n    host: string;\n    port: number;\n    auth?: {\n        username: string;\n        password: string;\n    }\n}\n\nexport interface Options {\n    headers?: {\n        [key: string]: any;\n    }\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}", "export interface Options {\n    headers?: {\n        [key: string]: any;\n    }\n    proxy?: _proxy;\n    proxies?: _proxy[];\n    queries?: {\n        [key: string]: any;\n    } | undefined;\n}"]}
