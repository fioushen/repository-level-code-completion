{"filename": "src/parameters.ts", "chunked_list": ["import { GPT_3_5_TURBO, GPT_4, Model } from \"./openai\";\n\nconst args = process.argv.slice(2); // Remove the first two elements (Node.js executable and script path)\n\nexport const numberOfAgents = args.length > 0 ? parseInt(args[0]) : 1;\nconsole.log(`Number of agents: ${numberOfAgents}`);\n\nconst modelText = args.length > 1 ? args[1] : \"gpt-3.5-turbo\";\nexport let model: Model;\nswitch (modelText) {", "export let model: Model;\nswitch (modelText) {\n  case GPT_3_5_TURBO:\n  case GPT_4:\n    model = modelText;\n    break;\n  default:\n    throw Error(`Unrecognized OpenAI model: '${modelText}'`);\n}\nconsole.log(`Model: ${model}`);", "}\nconsole.log(`Model: ${model}`);\n"]}
{"filename": "src/task-queue.ts", "chunked_list": ["type Task<T = void> = () => Promise<T>;\n\nexport default class TaskQueue {\n  private tasks: Task[] = [];\n  private running: Promise<void> | undefined;\n  private intervals: NodeJS.Timer[] = [];\n\n  get length() {\n    return this.tasks.length;\n  }\n\n  run<T>(task: Task<T>): Promise<T> {\n    return new Promise((resolve, reject) => {", "      this.tasks.push(() => task().then(resolve).catch(reject));\n      this.runNext();\n    });\n  }\n\n  runPeriodically(task: Task, milliseconds: number): void {\n    let pending = false;\n    this.intervals.push(\n      setInterval(() => {\n        if (pending) return;\n        pending = true;\n        this.run(task).finally(() => {\n          pending = false;\n        });\n      }, milliseconds)\n    );\n  }\n\n  async stop() {\n    this.tasks.length = 0;\n    this.intervals.forEach(clearInterval);\n    this.intervals = [];", "        if (pending) return;\n        pending = true;\n        this.run(task).finally(() => {\n          pending = false;\n        });\n      }, milliseconds)\n    );\n  }\n\n  async stop() {\n    this.tasks.length = 0;\n    this.intervals.forEach(clearInterval);\n    this.intervals = [];", "    if (this.running) {\n      await this.running;\n    }\n  }\n\n  private async runNext() {\n    if (this.running) return;\n\n    const task = this.tasks.shift();\n    if (!task) return;\n", "    if (!task) return;\n\n    try {\n      await (this.running = task());\n    } finally {\n      this.running = undefined;\n    }\n\n    this.runNext();\n  }\n}\n"]}
{"filename": "src/make-decision.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport { Event } from \"./memory\";\nimport { createChatCompletion } from \"./openai\";\nimport { model } from \"./parameters\";\nimport { messageSourceName } from \"./util\";\n\nexport default async function makeDecision(events: Event[]): Promise<string> {\n  console.log(`Reflecting on ${events.length} events...`);\n  const t0 = Date.now();\n\n  const messages = events.map(toOpenAiMessage);\n\n  // console.log(JSON.stringify(messages, null, 2));\n\n  const responseContent = await createChatCompletion({\n    model,\n    messages,\n    temperature: 0.0,\n  });\n\n  console.log(\n    `Arrived at a decision after ${((Date.now() - t0) / 1000).toFixed(1)}s`\n  );\n\n  return responseContent;\n}\n\n// lazy load to avoid accessing OPENAI_API_KEY before env has been loaded", "export function toOpenAiMessage(event: Event): ChatCompletionRequestMessage {\n  switch (event.type) {\n    case \"message\": {\n      const { type: messageType, source, content } = event.message;\n      const role = source.type === \"system\" ? \"system\" : \"user\";\n      let header: string;\n      switch (messageType) {\n        case \"spontaneous\":\n        case \"ok\":\n          header = \"\";\n          break;\n        case \"agentToAgent\":\n          header = `--- MESSAGE FROM ${messageSourceName(\n            source\n          ).toUpperCase()} ---\\n\\n`;\n          break;\n        case \"error\":\n          header = \"--- ERROR ---\\n\\n\";\n          break;\n      }\n      return {\n        role,\n        content: `${header}${content}`,\n      };\n    }\n    case \"decision\":\n      return {\n        role: \"assistant\",\n        content: event.actionText,\n      };\n  }\n}\n"]}
{"filename": "src/in-memory-message-bus.ts", "chunked_list": ["import { EventEmitter } from \"events\";\nimport { MessageBus } from \"./message-bus\";\nimport { Message } from \"./message\";\n\nexport class InMemoryMessageBus implements MessageBus {\n  private emitter: EventEmitter;\n\n  constructor() {\n    this.emitter = new EventEmitter();\n  }\n\n  subscribe(listener: (message: Message) => void): void {\n    this.emitter.on(\"message\", listener);\n  }\n\n  unsubscribe(listener: (message: Message) => void): void {\n    this.emitter.off(\"message\", listener);\n  }\n\n  send(message: Message): void {\n    this.emitter.emit(\"message\", message);\n  }\n}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import dotenv from \"dotenv\";\nimport ActionHandler from \"./action-handler\";\nimport { Agent } from \"./agent\";\nimport { startConsole } from \"./console\";\nimport { InMemoryMessageBus } from \"./in-memory-message-bus\";\nimport { Event, Memory } from \"./memory\";\nimport { MessageBus } from \"./message-bus\";\nimport core from \"./module/definitions/core\";\nimport filesystem from \"./module/definitions/filesystem\";\nimport goals from \"./module/definitions/goals\";", "import filesystem from \"./module/definitions/filesystem\";\nimport goals from \"./module/definitions/goals\";\nimport messaging from \"./module/definitions/messaging\";\nimport notes from \"./module/definitions/notes\";\nimport web from \"./module/definitions/web\";\nimport { ModuleManager } from \"./module/module-manager\";\nimport { contextWindowSize } from \"./openai\";\nimport { model, numberOfAgents } from \"./parameters\";\nimport FileStore from \"./store/file-store\";\nimport JsonStore from \"./store/json-store\";", "import FileStore from \"./store/file-store\";\nimport JsonStore from \"./store/json-store\";\nimport { webSocketServer } from \"./web-socket-server\";\n\ndotenv.config();\n\nconst agentIds = Array.from({ length: numberOfAgents + 1 }, (_, i) => `${i}`);\n\nconst messageBus: MessageBus = new InMemoryMessageBus();\n", "const messageBus: MessageBus = new InMemoryMessageBus();\n\nmain();\n\nasync function main() {\n  startConsole(agentIds, messageBus);\n\n  webSocketServer(messageBus, 8080);\n\n  for (const id of agentIds.slice(1)) {\n    const moduleManager = new ModuleManager(id, agentIds, [\n      core,\n      goals,\n      notes,\n      messaging,\n      filesystem,\n      web,\n    ]);\n    const actionHandler = new ActionHandler(\n      agentIds,\n      messageBus,\n      moduleManager\n    );\n\n    const store = new JsonStore<Event[]>(new FileStore([id]));\n    // We have to leave room for the agent's next action, which is of unknown size\n    const compressionThreshold = Math.round(contextWindowSize[model] * 0.75);\n    const memory = new Memory(id, moduleManager, store, compressionThreshold);\n    const agent = new Agent(\n      id,\n      memory,\n      messageBus,\n      moduleManager,\n      actionHandler\n    );\n    await agent.start();\n  }\n}\n", "  for (const id of agentIds.slice(1)) {\n    const moduleManager = new ModuleManager(id, agentIds, [\n      core,\n      goals,\n      notes,\n      messaging,\n      filesystem,\n      web,\n    ]);\n    const actionHandler = new ActionHandler(\n      agentIds,\n      messageBus,\n      moduleManager\n    );\n\n    const store = new JsonStore<Event[]>(new FileStore([id]));\n    // We have to leave room for the agent's next action, which is of unknown size\n    const compressionThreshold = Math.round(contextWindowSize[model] * 0.75);\n    const memory = new Memory(id, moduleManager, store, compressionThreshold);\n    const agent = new Agent(\n      id,\n      memory,\n      messageBus,\n      moduleManager,\n      actionHandler\n    );\n    await agent.start();\n  }\n}\n"]}
{"filename": "src/task-queue.test.ts", "chunked_list": ["import TaskQueue from \"./task-queue\";\nimport { sleep } from \"./util\";\n\ndescribe(\"TaskQueue\", () => {\n  let taskQueue: TaskQueue;\n\n  beforeEach(() => {\n    taskQueue = new TaskQueue();\n  });\n", "  });\n\n  afterEach(() => taskQueue.stop());\n\n  describe(\"run\", () => {\n    it(\"should run tasks in serial\", async () => {\n      const results: number[] = [];\n\n      const task1 = async () => {\n        await sleep(100);", "      const task1 = async () => {\n        await sleep(100);\n        results.push(1);\n      };\n      const task2 = async () => {\n        results.push(2);\n      };\n\n      await Promise.all([taskQueue.run(task1), taskQueue.run(task2)]);\n", "      await Promise.all([taskQueue.run(task1), taskQueue.run(task2)]);\n\n      expect(results).toEqual([1, 2]);\n    });\n  });\n\n  describe(\"runPeriodically\", () => {\n    it(\"should skip re-scheduling task if still pending\", async () => {\n      let numTasksRun = 0;\n      const periodicTask = async () => {", "      let numTasksRun = 0;\n      const periodicTask = async () => {\n        await sleep(100);\n        numTasksRun++;\n      };\n\n      taskQueue.runPeriodically(periodicTask, 10);\n\n      await sleep(500);\n", "      await sleep(500);\n\n      expect(taskQueue.length).toBeLessThanOrEqual(1);\n      expect(numTasksRun).toBeGreaterThanOrEqual(3);\n      expect(numTasksRun).toBeLessThanOrEqual(5);\n    });\n  });\n});\n", ""]}
{"filename": "src/web-socket-server.ts", "chunked_list": ["import WebSocket from \"ws\";\nimport { MessageBus } from \"./message-bus\";\n\nexport const webSocketServer = (messageBus: MessageBus, port: number) => {\n  const wss = new WebSocket.Server({ port });\n\n  messageBus.subscribe((message) => {\n    wss.clients.forEach((client: WebSocket) => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(JSON.stringify(message));\n      }\n    });\n  });\n\n  wss.on(\"connection\", (ws: WebSocket) => {\n    console.log(\"WebSocket client connected\");\n    ws.on(\"message\", (message: string) => {\n      console.log(\"Received: %s\", message);\n    });\n    ws.on(\"close\", () => {\n      console.log(\"WebSocket client disconnected\");\n    });\n  });\n};\n", "      if (client.readyState === WebSocket.OPEN) {\n        client.send(JSON.stringify(message));\n      }\n    });\n  });\n\n  wss.on(\"connection\", (ws: WebSocket) => {\n    console.log(\"WebSocket client connected\");\n    ws.on(\"message\", (message: string) => {\n      console.log(\"Received: %s\", message);\n    });\n    ws.on(\"close\", () => {\n      console.log(\"WebSocket client disconnected\");\n    });\n  });\n};\n"]}
{"filename": "src/console.ts", "chunked_list": ["import readline from \"readline\";\nimport { messageBuilder } from \"./message\";\nimport { MessageBus } from \"./message-bus\";\n\nconst AGENT_ID = \"0\";\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n  prompt: \"$ \",", "  output: process.stdout,\n  prompt: \"$ \",\n});\n\nexport function startConsole(agentIds: string[], messageBus: MessageBus) {\n  messageBus.subscribe((message) => {\n    if (message.targetAgentIds && !message.targetAgentIds.includes(AGENT_ID))\n      return;\n    console.log(`\\n${message.content}\\n`);\n    rl.prompt();\n  });\n\n  rl.on(\"line\", (input) => {\n    const colonIndex = -1; //input.indexOf(\":\");\n    let targetAgentIds: string[];\n    let content: string;", "    if (colonIndex >= 0) {\n      targetAgentIds = [input.substring(0, colonIndex)];\n      content = input.substring(colonIndex + 1);\n    } else {\n      targetAgentIds = agentIds.filter((id) => id !== AGENT_ID);\n      content = input;\n    }\n\n    if (content)\n      messageBus.send(\n        messageBuilder.agentToAgent(AGENT_ID, targetAgentIds, content)\n      );\n\n    rl.prompt();\n  });\n\n  // Display the initial prompt\n  rl.prompt();\n}\n", "    if (content)\n      messageBus.send(\n        messageBuilder.agentToAgent(AGENT_ID, targetAgentIds, content)\n      );\n\n    rl.prompt();\n  });\n\n  // Display the initial prompt\n  rl.prompt();\n}\n"]}
{"filename": "src/message.ts", "chunked_list": ["export interface Message {\n  type: MessageType;\n  source: MessageSource;\n  targetAgentIds: string[];\n  content: string;\n}\n\ntype TypelessMessage = Omit<Message, \"type\">;\n\nexport type MessageType = keyof typeof messageBuilder;\n", "export type MessageType = keyof typeof messageBuilder;\n\nexport type MessageSource = SystemMessageSource | AgentMessageSource;\n\ninterface MessageSourceBase {\n  id?: string;\n}\n\ninterface SystemMessageSource extends MessageSourceBase {\n  type: \"system\";\n  id?: undefined;\n}\n", "interface SystemMessageSource extends MessageSourceBase {\n  type: \"system\";\n  id?: undefined;\n}\n\ninterface AgentMessageSource extends MessageSourceBase {\n  type: \"agent\";\n  id: string;\n}\n\nexport const systemSource: SystemMessageSource = { type: \"system\" };\nexport const agentSource = (id: string): AgentMessageSource => ({\n  type: \"agent\",\n  id,\n});\n\nexport const CODE_BLOCK_DELIMITER = \"```\";\n\nexport const messageBuilder = addMessageTypes({\n  spontaneous: singleTargetSystemMessage,\n\n  ok: singleTargetSystemMessage,\n\n  error: singleTargetSystemMessage,\n\n  agentToAgent: (\n    sourceAgentId: string,\n    targetAgentIds: string[],\n    content: string\n  ) => ({\n    source: agentSource(sourceAgentId),\n    targetAgentIds,\n    content,\n  }),\n});\n", "function addMessageTypes<\n  T extends Record<string, (...args: any) => TypelessMessage>\n>(record: T): { [K in keyof T]: (...args: Parameters<T[K]>) => Message } {\n  for (const [type, builder] of Object.entries(record)) {\n    (record as any)[type] = (...args: any) => ({\n      type,\n      ...(builder as any)(...args),\n    });\n  }\n  return record as any;\n}\n", "function singleTargetSystemMessage(\n  agentId: string,\n  content: string\n): TypelessMessage {\n  return {\n    source: systemSource,\n    targetAgentIds: [agentId],\n    content,\n  };\n}\n"]}
{"filename": "src/redis-message-bus.ts", "chunked_list": ["import { createClient, RedisClientType } from \"redis\";\nimport { MessageBus } from \"./message-bus\";\nimport { Message } from \"./message\";\n\nexport class RedisMessageBus implements MessageBus {\n  private publisher: RedisClientType;\n  private subscriber: RedisClientType;\n  private channel = \"messages\";\n\n  constructor() {\n    this.publisher = createClient();\n    this.subscriber = createClient();\n  }\n\n  subscribe(listener: (message: Message) => void): void {\n    this.subscriber.on(\"message\", (channel, message) => {", "      if (channel === this.channel) {\n        listener(JSON.parse(message));\n      }\n    });\n    this.subscriber.subscribe(this.channel, () => {});\n  }\n\n  unsubscribe(listener: (message: Message) => void): void {\n    this.subscriber.removeListener(\"message\", listener);\n    this.subscriber.unsubscribe(this.channel, () => {});\n  }\n\n  send(message: Message): void {\n    this.publisher.publish(this.channel, JSON.stringify(message));\n  }\n}\n"]}
{"filename": "src/openai.ts", "chunked_list": ["import { AxiosError, AxiosRequestConfig } from \"axios\";\nimport { memoize } from \"lodash\";\nimport { Configuration, CreateChatCompletionRequest, OpenAIApi } from \"openai\";\n\nexport const GPT_3_5_TURBO = \"gpt-3.5-turbo\";\nexport const GPT_4 = \"gpt-4\";\n\nexport const contextWindowSize = {\n  [GPT_3_5_TURBO]: 4000,\n  [GPT_4]: 8000,", "  [GPT_3_5_TURBO]: 4000,\n  [GPT_4]: 8000,\n};\n\nexport type Model = typeof GPT_3_5_TURBO | typeof GPT_4;\n\nexport async function createChatCompletion(\n  request: CreateChatCompletionRequest,\n  options?: AxiosRequestConfig\n): Promise<string> {\n  try {\n    const response = await openai().createChatCompletion(request, options);\n    return response.data.choices[0].message!.content;", "  try {\n    const response = await openai().createChatCompletion(request, options);\n    return response.data.choices[0].message!.content;\n  } catch (e) {\n    const { response } = e as AxiosError;\n    switch (response?.status) {\n      case 400:\n        throw Error(`Context window is full.`);\n      case 404:\n        throw Error(`Model '${request.model}' is unavailable.`);\n      case 429:\n        throw Error(`OpenAI rate limited.`);\n      default:\n        throw e;\n    }\n  }\n}\n\n// lazy load to avoid accessing OPENAI_API_KEY before env has been loaded\nconst openai = memoize(() => {\n  const apiKey = process.env.OPENAI_API_KEY;", "  if (!apiKey) throw Error(\"OPENAI_API_KEY is not configured!\");\n\n  const configuration = new Configuration({\n    apiKey: process.env.OPENAI_API_KEY,\n  });\n  return new OpenAIApi(configuration);\n});\n"]}
{"filename": "src/message-bus.ts", "chunked_list": ["import { Message } from \"./message\";\n\nexport interface MessageBus {\n  subscribe(listener: (message: Message) => void): void;\n  unsubscribe(listener: (message: Message) => void): void;\n  send(message: Message): void;\n}\n"]}
{"filename": "src/parse-action.ts", "chunked_list": ["import { CODE_BLOCK_DELIMITER } from \"./message\";\nimport { ActionDefinition } from \"./module/action-definition\";\nimport { getUsageText } from \"./module/util\";\nimport { MULTILINE_DELIMITER } from \"./util\";\n\ntype ParseResult =\n  | {\n      type: \"success\";\n      action: Action;\n    }\n  | { type: \"error\"; message: string };\n", "export interface Action {\n  actionDef: ActionDefinition;\n  thoughts?: string;\n  parameters: Record<string, string>;\n}\n\nexport default function parseAction(\n  actionDictionary: Map<string, ActionDefinition>,\n  text: string\n): ParseResult {\n  try {\n    text = text.trim();\n", "  try {\n    text = text.trim();\n\n    if (!/^\\S+(?=\\n|$)/.test(text.split(\"\\n\")[0])) {\n      return {\n        type: \"error\",\n        message: `\nYour action could not be parsed. Remember to always format your entire response as an action, like this:\n\n${CODE_BLOCK_DELIMITER}\n<action name>\n<arg 1 name>: <prop value>\n<arg 2 name>: <prop value>\n...\n${CODE_BLOCK_DELIMITER}\n`.trim(),\n      };\n    }\n\n    text = `name: ${text}`;\n\n    const jsonText =\n      \"{\" +\n      text\n        .split(MULTILINE_DELIMITER)\n        .map((part) => part.trim())\n        .map((part, i) => {", "          if (i % 2 === 0) return part;\n          return JSON.stringify(part) + \"\\n\";\n        })\n        .join(\"\")\n        .split(\"\\n\")\n        .filter(Boolean)\n        .map((line) => {\n          const colonIndex = line.indexOf(\":\");\n          if (colonIndex < 0)\n            throw new Error(\n              `Your action could not be parsed. Did you fail to wrap the entirety of a multi-line parameter value with the multi-line delimiter (\\`${MULTILINE_DELIMITER}\\`)?`\n            );\n          const key = line.substring(0, colonIndex).trim();\n          let value = line.substring(colonIndex + 1).trim();", "          if (colonIndex < 0)\n            throw new Error(\n              `Your action could not be parsed. Did you fail to wrap the entirety of a multi-line parameter value with the multi-line delimiter (\\`${MULTILINE_DELIMITER}\\`)?`\n            );\n          const key = line.substring(0, colonIndex).trim();\n          let value = line.substring(colonIndex + 1).trim();\n          if (!value.startsWith('\"') || !value.endsWith('\"'))\n            value = JSON.stringify(value);\n          return `\"${key}\": ${value}`;\n        })\n        .join(\",\") +\n      \"}\";\n\n    const { name, thoughts, ...parameters } = JSON.parse(jsonText);\n\n    const actionDef = actionDictionary.get(name);", "    if (!actionDef)\n      return {\n        type: \"error\",\n        message: `Unknown action \\`${name}\\`. Please refer to the list of available actions given in the introductory message.`,\n      };\n\n    const missingProps = Object.entries(actionDef.parameters)\n      .filter(\n        ([name, parameterDef]) =>\n          !parameterDef.optional && !(name in parameters)\n      )\n      .map(([name]) => name);", "    if (missingProps.length) {\n      return {\n        type: \"error\",\n        message: `Missing required parameter${\n          missingProps.length > 1 ? \"s\" : \"\"\n        } ${missingProps.map((p) => `\\`${p}\\``)}. ${getUsageText(actionDef)}`,\n      };\n    }\n\n    const extraProps = Object.keys(parameters).filter(\n      (p) => !(p in actionDef.parameters)\n    );", "    if (extraProps.length) {\n      return {\n        type: \"error\",\n        message: `Extraneous parameter${\n          extraProps.length > 1 ? \"s\" : \"\"\n        } ${extraProps.map((p) => `\\`${p}\\``)}. ${getUsageText(actionDef)}`,\n      };\n    }\n\n    return { type: \"success\", action: { actionDef, thoughts, parameters } };\n  } catch (e: any) {\n    return {\n      type: \"error\",\n      message: e.message,\n    };\n  }\n}\n", "  } catch (e: any) {\n    return {\n      type: \"error\",\n      message: e.message,\n    };\n  }\n}\n"]}
{"filename": "src/action-handler.ts", "chunked_list": ["import { ModuleManager } from \"./module/module-manager\";\nimport { MessageBus } from \"./message-bus\";\nimport { Action } from \"./parse-action\";\n\nexport default class ActionHandler {\n  constructor(\n    private agentIds: string[],\n    private messageBus: MessageBus,\n    private moduleManager: ModuleManager\n  ) {}\n\n  async handle(agentId: string, { actionDef, parameters }: Action) {\n    actionDef.execute({\n      context: this.moduleManager.getModuleForAction(actionDef.name)!.context,\n      parameters,\n      sendMessage: (message) => this.messageBus.send(message),\n    });\n  }\n}\n"]}
{"filename": "src/agent.ts", "chunked_list": ["import { last } from \"lodash\";\nimport ActionHandler from \"./action-handler\";\nimport makeDecision from \"./make-decision\";\nimport { Memory } from \"./memory\";\nimport { messageBuilder } from \"./message\";\nimport { MessageBus } from \"./message-bus\";\nimport { ModuleManager } from \"./module/module-manager\";\nimport parseAction from \"./parse-action\";\nimport TaskQueue from \"./task-queue\";\nimport { agentName, sleep } from \"./util\";", "import TaskQueue from \"./task-queue\";\nimport { agentName, sleep } from \"./util\";\n\nconst actionInterval = 1000;\n// const heartbeatInterval = 60 * 1000;\n\nexport class Agent {\n  constructor(\n    public id: string,\n    private memory: Memory,\n    private messageBus: MessageBus,\n    private moduleManager: ModuleManager,\n    private actionHandler: ActionHandler\n  ) {}\n\n  private taskQueue = new TaskQueue();\n\n  // Start this Agent's event loop\n  async start() {\n    // Subscribe to messages\n    this.messageBus.subscribe((message) => {", "      if (message.targetAgentIds && !message.targetAgentIds.includes(this.id))\n        return;\n      this.memory.append({ type: \"message\", message });\n    });\n\n    // Act on messages periodically\n    this.taskQueue.runPeriodically(() => this.takeAction(), actionInterval);\n\n    // Start heartbeat\n    // this.taskQueue.runPeriodically(async () => {\n    //   const messages = await this.memory.retrieve();\n    //   const lastMessage = last(messages);", "    //   if (lastMessage?.type === \"decision\") {\n    //     this.messageBus.send(\n    //       messageBuilder.spontaneous(\n    //         this.id,\n    //         \"This is your regularly scheduled heartbeat message. Is there anything you need to do?\"\n    //       )\n    //     );\n    //   }\n    // }, heartbeatInterval);\n  }\n\n  private async takeAction(): Promise<void> {", "    try {\n      let events = await this.memory.retrieve();\n\n      // Do not act again if the last event was a decision\n      if (last(events)?.type === \"decision\") return;\n\n      const actionText = await makeDecision(events);\n\n      // Reassign events in case summarization occurred\n      events = await this.memory.append({\n        type: \"decision\",\n        actionText,\n      });\n\n      const result = parseAction(this.moduleManager.actions, actionText);", "      if (result.type === \"error\") {\n        this.messageBus.send(messageBuilder.error(this.id, result.message));\n      } else {\n        await this.actionHandler.handle(this.id, result.action);\n      }\n    } catch (e) {\n      console.error(\n        `${agentName(\n          this.id\n        )} encountered the following problem while attempting to take action:`\n      );\n      console.error(e);", "    } finally {\n      if (process.env.AGENT_DELAY) {\n        await sleep(parseInt(process.env.AGENT_DELAY));\n      }\n    }\n  }\n}\n"]}
{"filename": "src/util.ts", "chunked_list": ["import { encode } from \"gpt-3-encoder\";\nimport { MessageSource } from \"./message\";\n\nexport function sleep(milliseconds: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function sleepUntil(condition: () => boolean): Promise<void> {\n  return new Promise((resolve) => {\n    if (condition()) return resolve();\n    const interval = setInterval(() => {", "    if (condition()) return resolve();\n    const interval = setInterval(() => {\n      if (condition()) {\n        clearInterval(interval);\n        resolve();\n      }\n    }, 1000);\n  });\n}\n\nexport function messageSourceName(source: MessageSource) {\n  return source.type === \"system\" ? \"System\" : agentName(source.id);\n}\n", "export function messageSourceName(source: MessageSource) {\n  return source.type === \"system\" ? \"System\" : agentName(source.id);\n}\n\nexport function agentName(agentId: string) {\n  return `${agentId === \"0\" ? \"Control\" : `Agent ${agentId}`}`;\n}\n\nexport const MULTILINE_DELIMITER = `% ${\"ff9d7713-0bb0-40d4-823c-5a66de48761b\"}`;\n\nexport const AVG_WORDS_PER_TOKEN = 0.75;\nexport const AVG_CHARACTERS_PER_TOKEN = 4;\n", "export function countTokens(text: string) {\n  return encode(text).length;\n}\n"]}
{"filename": "src/parse-action.test.ts", "chunked_list": ["import core from \"./module/definitions/core\";\nimport filesystem from \"./module/definitions/filesystem\";\nimport messaging from \"./module/definitions/messaging\";\nimport notes from \"./module/definitions/notes\";\nimport { ModuleManager } from \"./module/module-manager\";\nimport { getUsageText } from \"./module/util\";\nimport parseAction, { Action } from \"./parse-action\";\nimport { MULTILINE_DELIMITER } from \"./util\";\n\nconst moduleManager = new ModuleManager(", "\nconst moduleManager = new ModuleManager(\n  \"1\",\n  [\"1\"],\n  [core, notes, messaging, filesystem]\n);\n\ntest(\"case 1\", () => {\n  assertValid(`\nsendMessage", "  assertValid(`\nsendMessage\ntargetAgentId: 0\nmessage:\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\nHello Control, this is Agent 1.\nI am sending you a multi-line message.\nThis is another line.\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\n  `);", "% ff9d7713-0bb0-40d4-823c-5a66de48761b\n  `);\n});\n\ntest(\"case 2\", () => {\n  assertValid(`\nsendMessage\ntargetAgentId: 0\nmessage:\n% ff9d7713-0bb0-40d4-823c-5a66de48761b", "message:\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\nHello Control, this is Agent 1.\n\nHere is a multi-line message:\nThis is the first line.\nThis is the second line.\nThis is the third line.\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\n    `);", "% ff9d7713-0bb0-40d4-823c-5a66de48761b\n    `);\n});\n\ntest(\"case 3\", () => {\n  assertValid(`\nwriteFile\npath: ./schema/action-dictionary.json\ncontent:\n% ff9d7713-0bb0-40d4-823c-5a66de48761b", "content:\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"title\": \"Action\",\n  \"oneOf\": [\n    {\n      ... the old content of action-dictionary.json ...\n    },", "      ... the old content of action-dictionary.json ...\n    },\n    {\n      \"title\": \"NewActionDefinition\",\n      \"description\": \"This is an example of a new action definition.\",\n      \"properties\": {\n        \"type\": {\n          \"type\": \"string\",\n          \"const\": \"new-action-definition\"\n        },", "          \"const\": \"new-action-definition\"\n        },\n        \"exampleArg\": {\n          \"type\": \"string\",\n          \"description\": \"An example parameter for the new action definition.\"\n        }\n      },\n      \"required\": [\n        \"type\",\n        \"exampleArg\"", "        \"type\",\n        \"exampleArg\"\n      ],\n      \"additionalProperties\": false\n    }\n  ]\n}\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\n`);\n});", "`);\n});\n\ntest(\"invalid multiline with no delimiter\", () => {\n  expect(\n    assertInvalid(`\nsendMessage\ntargetAgentId: 0\nmessage: Hello Control, here's a list of things,\n", "message: Hello Control, here's a list of things,\n\n- 9 bottles of ketchup\n- 2 pairs of socks\n- a very big balloon\n  `)\n  ).toEqual(\n    `Your action could not be parsed. Did you fail to wrap the entirety of a multi-line parameter value with the multi-line delimiter (\\`% ff9d7713-0bb0-40d4-823c-5a66de48761b\\`)?`\n  );\n});", "  );\n});\n\ntest(\"multiline delimiter not starting on its own line\", () => {\n  expect(\n    assertValid(`\nsendMessage\ntargetAgentId: 0\nmessage: % ff9d7713-0bb0-40d4-823c-5a66de48761b\nhere is a", "message: % ff9d7713-0bb0-40d4-823c-5a66de48761b\nhere is a\nmulti\nline\nmessage\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\n`).parameters.message\n  ).toBe(\n    `\nhere is a", "    `\nhere is a\nmulti\nline\nmessage\n`.trim()\n  );\n});\n\ntest(\"parameter after multiline parameter\", () => {", "\ntest(\"parameter after multiline parameter\", () => {\n  const { parameters, thoughts } = assertValid(`\nsendMessage\ntargetAgentId: 0\nmessage:\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\nmulti\nline\nparameter", "line\nparameter\n% ff9d7713-0bb0-40d4-823c-5a66de48761b\nthoughts: Trying a multi-line parameter followed by another parameter.\n`);\n  expect(parameters.message).toBe(\n    `\nmulti\nline\nparameter", "line\nparameter\n`.trim()\n  );\n  expect(thoughts).toBe(\n    \"Trying a multi-line parameter followed by another parameter.\"\n  );\n});\n\ntest(\"invalid command name\", () => {", "\ntest(\"invalid command name\", () => {\n  expect(assertInvalid(\"foo\")).toBe(\n    \"Unknown action `foo`. Please refer to the list of available actions given in the introductory message.\"\n  );\n});\n\ntest(\"invalid raw text\", () => {\n  expect(assertInvalid(\"Hello Control, how are you doing?\")).toEqual(\n    `", "  expect(assertInvalid(\"Hello Control, how are you doing?\")).toEqual(\n    `\nYour action could not be parsed. Remember to always format your entire response as an action, like this:\n\n\\`\\`\\`\n<action name>\n<arg 1 name>: <prop value>\n<arg 2 name>: <prop value>\n...\n\\`\\`\\`", "...\n\\`\\`\\`\n`.trim()\n  );\n});\n\ntest(\"missing required parameter\", () => {\n  expect(assertInvalid(\"sendMessage\\ntargetAgentId: 0\")).toBe(\n    `Missing required parameter \\`message\\`. ${getUsageText(\n      messaging.actions.sendMessage", "    `Missing required parameter \\`message\\`. ${getUsageText(\n      messaging.actions.sendMessage\n    )}`\n  );\n});\n\ntest(\"extra parameter\", () => {\n  expect(assertInvalid(\"noop\\nfoo: bar\")).toEqual(\n    `Extraneous parameter \\`foo\\`. ${getUsageText(core.actions.noop)}`\n  );", "    `Extraneous parameter \\`foo\\`. ${getUsageText(core.actions.noop)}`\n  );\n});\n\ndescribe(\"quotes\", () => {\n  test(\"in-line parameter\", () => {\n    const action = assertValid(`\nsendMessage\ntargetAgentId: 0\nmessage: hello, \"control\"", "targetAgentId: 0\nmessage: hello, \"control\"\n`);\n    expect(action.actionDef.name).toBe(\"sendMessage\");\n    expect(action.parameters).toEqual({\n      targetAgentId: \"0\",\n      message: 'hello, \"control\"',\n    });\n  });\n", "  });\n\n  test(\"multi-line parameter\", () => {\n    const action = assertValid(`\nsendMessage\ntargetAgentId: 0\nmessage:\n${MULTILINE_DELIMITER}\nhello, \"control\"\n${MULTILINE_DELIMITER}", "hello, \"control\"\n${MULTILINE_DELIMITER}\n`);\n    expect(action.actionDef.name).toBe(\"sendMessage\");\n    expect(action.parameters).toEqual({\n      targetAgentId: \"0\",\n      message: 'hello, \"control\"',\n    });\n  });\n});", "  });\n});\n\n// =============================================================================\n\nfunction assertValid(text: string): Action {\n  const result = parseAction(moduleManager.actions, text);\n  if (result.type === \"error\") throw Error(`Parse failed: ${result.message}`);\n  return result.action;\n}\n", "function assertInvalid(text: string): string {\n  const result = parseAction(moduleManager.actions, text);\n  if (result.type === \"success\")\n    throw Error(\n      `Parse succeeded when it should've failed: ${JSON.stringify(\n        result.action,\n        null,\n        2\n      )}`\n    );\n  return result.message;\n}\n"]}
{"filename": "src/store/file-store.ts", "chunked_list": ["import { Store } from \".\";\nimport { readFile, writeFile, mkdir, stat, unlink, readdir } from \"fs/promises\";\nimport path from \"path\";\n\nconst STORE_DIR = \".store\";\n\nexport default class FileStore implements Store<string> {\n  constructor(private namespaces: string[]) {}\n\n  async get(key: string) {\n    await this.mkdirs();\n    const path = this.pathFor(key);\n    const fileExists = await checkExists(path);", "    if (!fileExists) return undefined;\n    const buffer = await readFile(path, \"utf-8\");\n    return buffer.toString();\n  }\n\n  async set(key: string, value: string) {\n    await this.mkdirs();\n    await writeFile(this.pathFor(key), value, \"utf-8\");\n  }\n\n  async delete(key: string) {\n    await this.mkdirs();\n    const path = this.pathFor(key);\n    const fileExists = await checkExists(path);", "    if (!fileExists) return false;\n    await unlink(path);\n    return true;\n  }\n\n  async getKeys() {\n    await this.mkdirs();\n    const fileNames = await readdir(this.dirPath);\n\n    // Get file stats for each file in parallel\n    const withStats = await Promise.all(\n      fileNames.map(async (fileName) => {\n        const stats = await stat(`${this.dirPath}/${fileName}`);\n        return { keyName: decodeFilename(fileName), stats };\n      })\n    );\n\n    // Sort by last modified date\n    const sortedKeys = withStats\n      .sort((a, b) => a.stats.mtime.getTime() - b.stats.mtime.getTime())\n      .map(({ keyName }) => keyName);\n\n    return sortedKeys;\n  }\n\n  private async mkdirs() {\n    await mkdir(this.dirPath, { recursive: true });\n  }\n\n  private pathFor(key: string) {\n    return path.join(this.dirPath, encodeFilename(key));\n  }\n\n  private get dirPath() {\n    return path.join(STORE_DIR, ...this.namespaces);\n  }\n}\n", "async function checkExists(path: string) {\n  try {\n    await stat(path);\n    return true;\n  } catch (e: any) {\n    if (e.code === \"ENOENT\") {\n      // Does not exist\n      return false;\n    } else {\n      // Some other error occurred\n      throw e;\n    }\n  }\n}\n", "function encodeChar(char: string): string {\n  return \"%\" + char.charCodeAt(0).toString(16);\n}\n\nfunction decodeChar(encodedChar: string): string {\n  return String.fromCharCode(parseInt(encodedChar.slice(1), 16));\n}\n\nfunction encodeFilename(filename: string): string {\n  // Replace invalid characters with their encoded versions\n  const replaced = filename.replace(/[\\\\/:*?\"<>|]/g, encodeChar);\n\n  // Limit the filename length, as some file systems have restrictions\n  const maxLength = 255;\n  const trimmed = replaced.slice(0, maxLength);\n\n  return trimmed;\n}\n", "function encodeFilename(filename: string): string {\n  // Replace invalid characters with their encoded versions\n  const replaced = filename.replace(/[\\\\/:*?\"<>|]/g, encodeChar);\n\n  // Limit the filename length, as some file systems have restrictions\n  const maxLength = 255;\n  const trimmed = replaced.slice(0, maxLength);\n\n  return trimmed;\n}\n", "function decodeFilename(filename: string): string {\n  // Decode the escaped characters back to their original form\n  return filename.replace(/%[0-9a-fA-F]{2}/g, decodeChar);\n}\n"]}
{"filename": "src/store/json-store.ts", "chunked_list": ["import { Store } from \".\";\n\nexport default class JsonStore<T> implements Store<T> {\n  constructor(private stringStore: Store<string>) {}\n\n  async get(key: string) {\n    const stringValue = await this.stringStore.get(key);\n    return stringValue && JSON.parse(stringValue);\n  }\n\n  async set(key: string, value: T) {\n    return this.stringStore.set(key, JSON.stringify(value, null, 2));\n  }\n\n  async delete(key: string) {\n    return this.stringStore.delete(key);\n  }\n\n  async getKeys() {\n    return this.stringStore.getKeys();\n  }\n}\n"]}
{"filename": "src/store/in-memory-store.ts", "chunked_list": ["import { Store } from \".\";\n\nexport default class InMemoryStore implements Store<string> {\n  private map = new Map<string, string>();\n\n  async get(key: string) {\n    return this.map.get(key);\n  }\n\n  async set(key: string, value: string) {\n    this.map.set(key, value);\n  }\n\n  async delete(key: string) {\n    return this.map.delete(key);\n  }\n\n  async getKeys() {\n    return [...this.map.keys()];\n  }\n}\n"]}
{"filename": "src/store/index.ts", "chunked_list": ["export interface Store<T = string> {\n  get(key: string): Promise<T | undefined>;\n  set(key: string, value: T): Promise<void>;\n  delete(key: string): Promise<boolean>;\n  getKeys(): Promise<string[]>;\n}\n"]}
{"filename": "src/module/define-module.ts", "chunked_list": ["import { fromPairs, mapValues, toPairs } from \"lodash\";\nimport { PartialActionDefinition } from \"./action-definition\";\nimport {\n  ModuleDefinitionInputs1,\n  ModuleDefinitionInputs2,\n  ModuleDefinition,\n} from \".\";\n\nexport function defineModule<S>(inputs1: ModuleDefinitionInputs1<S>) {\n  return {\n    with: <A extends string>({\n      actions,\n      ...inputs2\n    }: ModuleDefinitionInputs2<S, A>): ModuleDefinition<S, A> => ({\n      ...inputs1,\n      ...inputs2,\n      actions: fromPairs(\n        toPairs<PartialActionDefinition<S, string>>(actions).map(\n          ([name, { parameters = {}, ...definition }]) => [\n            name,\n            {\n              name,\n              parameters: mapValues(parameters, (parameter) => ({\n                optional: false,\n                ...parameter,\n              })),\n              ...definition,\n            },\n          ]\n        )\n      ) as any,\n    }),\n  };\n}\n", "export function defineModule<S>(inputs1: ModuleDefinitionInputs1<S>) {\n  return {\n    with: <A extends string>({\n      actions,\n      ...inputs2\n    }: ModuleDefinitionInputs2<S, A>): ModuleDefinition<S, A> => ({\n      ...inputs1,\n      ...inputs2,\n      actions: fromPairs(\n        toPairs<PartialActionDefinition<S, string>>(actions).map(\n          ([name, { parameters = {}, ...definition }]) => [\n            name,\n            {\n              name,\n              parameters: mapValues(parameters, (parameter) => ({\n                optional: false,\n                ...parameter,\n              })),\n              ...definition,\n            },\n          ]\n        )\n      ) as any,\n    }),\n  };\n}\n"]}
{"filename": "src/module/index.ts", "chunked_list": ["import { ActionDefinition, PartialActionDefinition } from \"./action-definition\";\n\nexport interface ModuleDefinition<S = any, A extends string = string>\n  extends ModuleDefinitionInputs1<S> {\n  pinnedMessage?: (context: ModuleContext<S>) => Promise<string | undefined>;\n  actions: Record<A, ActionDefinition<S>>;\n}\n\nexport interface ModuleDefinitionInputs1<S> {\n  name: string;\n  createState?: (params: ModuleStateInputs) => S;\n}\n", "export interface ModuleDefinitionInputs1<S> {\n  name: string;\n  createState?: (params: ModuleStateInputs) => S;\n}\n\nexport interface ModuleDefinitionInputs2<S, A extends string> {\n  pinnedMessage?: (context: ModuleContext<S>) => Promise<string | undefined>;\n  actions: Record<A, PartialActionDefinition<S, string>>;\n}\n\nexport interface ModuleStateInputs {\n  agentId: string;\n}\n", "export interface ModuleStateInputs {\n  agentId: string;\n}\n\nexport interface ModuleContext<S> {\n  agentId: string;\n  allAgentIds: string[];\n  actionDictionary: Map<string, ActionDefinition>;\n  state: S;\n}\n"]}
{"filename": "src/module/module-manager.ts", "chunked_list": ["import { ModuleDefinition } from \".\";\nimport { ActionDefinition } from \"./action-definition\";\nimport { ModuleInstance } from \"./module-instance\";\n\nexport class ModuleManager {\n  modules: ModuleInstance[];\n  actions: Map<string, ActionDefinition>;\n  private actionToModule: Map<string, ModuleInstance>;\n\n  constructor(\n    public agentId: string,\n    public allAgentIds: string[],\n    moduleDefinitions: ModuleDefinition[]\n  ) {\n    this.modules = moduleDefinitions.map(\n      (moduleDef) => new ModuleInstance(this, moduleDef)\n    );\n\n    this.actions = moduleDefinitions\n      .flatMap((module) => Object.values(module.actions))\n      .reduce(\n        (map, actionDef) => (map.set(actionDef.name, actionDef), map),\n        new Map()\n      );\n\n    this.actionToModule = new Map();", "    for (const module of this.modules) {\n      for (const actionDef of Object.values(module.moduleDef.actions)) {\n        this.actionToModule.set(actionDef.name, module);\n      }\n    }\n  }\n\n  getModuleForAction(name: string): ModuleInstance | undefined {\n    return this.actionToModule.get(name);\n  }\n}\n"]}
{"filename": "src/module/module-instance.ts", "chunked_list": ["import { ModuleContext, ModuleDefinition } from \".\";\nimport { ModuleManager } from \"./module-manager\";\n\nexport class ModuleInstance<S = void, A extends string = string> {\n  private _state: S | undefined;\n\n  constructor(\n    private moduleManager: ModuleManager,\n    public moduleDef: ModuleDefinition<S, A>\n  ) {}\n\n  get state(): S {", "    if (!this.moduleDef.createState) return undefined as S;\n\n    this._state = this.moduleDef.createState({\n      agentId: this.moduleManager.agentId,\n    });\n\n    return this._state;\n  }\n\n  get context(): ModuleContext<S> {\n    return {\n      agentId: this.moduleManager.agentId,\n      allAgentIds: this.moduleManager.allAgentIds,\n      actionDictionary: this.moduleManager.actions,\n      state: this.state,\n    };\n  }\n}\n"]}
{"filename": "src/module/util.ts", "chunked_list": ["import { CODE_BLOCK_DELIMITER } from \"../message\";\nimport { ActionDefinition } from \"./action-definition\";\n\nexport function getUsageText(actionDef: ActionDefinition): string {\n  return `Usage:\n\n${CODE_BLOCK_DELIMITER}\n${actionDef.name}\nthoughts: <reasoning behind this action> (optional)${Object.entries(\n    actionDef.parameters\n  )\n    .map(([name, { description }]) =>\n      name === \"name\"\n        ? undefined\n        : `\\n${name}: <${description.toLowerCase()}>${\n            actionDef.parameters[name].optional ? \" (optional)\" : \"\"\n          }`\n    )\n    .filter(Boolean)\n    .join(\"\")}\n${CODE_BLOCK_DELIMITER}`;\n}\n"]}
{"filename": "src/module/action-definition.ts", "chunked_list": ["import { ModuleContext } from \".\";\nimport { Message } from \"../message\";\n\nexport interface ActionDefinition<S = void, P extends string = string>\n  extends PartialActionDefinition<S, P> {\n  name: string;\n  parameters: Record<P, ParameterDefinition>;\n}\n\nexport interface PartialActionDefinition<S = void, P extends string = never> {\n  description: string;\n  parameters?: Record<P, PartialParameterDefinition>;\n  execute: ActionHandler<S, P>;\n}\n", "export interface PartialActionDefinition<S = void, P extends string = never> {\n  description: string;\n  parameters?: Record<P, PartialParameterDefinition>;\n  execute: ActionHandler<S, P>;\n}\n\nexport type ParameterDefinition = Required<PartialParameterDefinition>;\n\nexport interface PartialParameterDefinition {\n  description: string;\n  optional?: boolean;\n}\n", "export interface PartialParameterDefinition {\n  description: string;\n  optional?: boolean;\n}\n\nexport type ActionHandler<S = void, P extends string = string> = (\n  inputs: ActionHandlerInputs<S, P>\n) => Promise<void>;\n\nexport interface ActionHandlerInputs<S = void, P extends string = string> {\n  parameters: Record<P, string>;\n  context: ModuleContext<S>;\n  sendMessage: (message: Message) => void;\n}\nexport { ModuleContext };\n", "export interface ActionHandlerInputs<S = void, P extends string = string> {\n  parameters: Record<P, string>;\n  context: ModuleContext<S>;\n  sendMessage: (message: Message) => void;\n}\nexport { ModuleContext };\n"]}
{"filename": "src/module/definitions/messaging.ts", "chunked_list": ["import { defineModule } from \"../define-module\";\nimport { messageBuilder } from \"../../message\";\nimport { agentName } from \"../../util\";\n\nexport default defineModule({\n  name: \"messaging\",\n}).with({\n  actions: {\n    queryAgentRegistry: {\n      description: \"Ask who the other agents are that you can talk to\",\n      async execute({ context: { agentId, allAgentIds }, sendMessage }) {\n        sendMessage(\n          messageBuilder.ok(\n            agentId,\n            `These are the agents in the system:\\n\\n${allAgentIds\n              .map((id) => `${agentName(id)} [agentId=${id}]`)\n              .join(\"\\n\")}`\n          )\n        );\n      },\n    },\n\n    sendMessage: {\n      description: \"Send a message to another agent\",\n      parameters: {\n        targetAgentId: {\n          description: \"The target agent's ID\",\n        },\n        message: {\n          description: \"The content of the message\",\n        },\n      },\n      async execute({\n        parameters: { targetAgentId, message },\n        context: { agentId, allAgentIds },\n        sendMessage,\n      }) {", "        if (agentId === targetAgentId) {\n          return sendMessage(\n            messageBuilder.error(\n              agentId,\n              \"You can't send a message to yourself. Use the `writeNote` action if you want to make notes for yourself.\"\n            )\n          );\n        }\n\n        if (allAgentIds.includes(targetAgentId)) {\n          sendMessage(\n            messageBuilder.agentToAgent(agentId, [targetAgentId], message)\n          );\n        } else {\n          sendMessage(\n            messageBuilder.error(\n              agentId,\n              `You tried to send your message to an invalid targetAgentId (${JSON.stringify(\n                targetAgentId\n              )}). You can use the 'queryAgentRegistry' action to see a list of available agents and their agent IDs.`\n            )\n          );\n        }\n      },\n    },\n  },\n});\n", "        if (allAgentIds.includes(targetAgentId)) {\n          sendMessage(\n            messageBuilder.agentToAgent(agentId, [targetAgentId], message)\n          );\n        } else {\n          sendMessage(\n            messageBuilder.error(\n              agentId,\n              `You tried to send your message to an invalid targetAgentId (${JSON.stringify(\n                targetAgentId\n              )}). You can use the 'queryAgentRegistry' action to see a list of available agents and their agent IDs.`\n            )\n          );\n        }\n      },\n    },\n  },\n});\n"]}
{"filename": "src/module/definitions/web.ts", "chunked_list": ["import { google } from \"googleapis\";\nimport puppeteer from \"puppeteer\";\nimport TurndownService from \"turndown\";\nimport { messageBuilder } from \"../../message\";\nimport { Model, contextWindowSize, createChatCompletion } from \"../../openai\";\nimport { model } from \"../../parameters\";\nimport {\n  AVG_CHARACTERS_PER_TOKEN,\n  AVG_WORDS_PER_TOKEN,\n  countTokens,", "  AVG_WORDS_PER_TOKEN,\n  countTokens,\n} from \"../../util\";\nimport { defineModule } from \"../define-module\";\n\nexport default defineModule({\n  name: \"web\",\n}).with({\n  actions: {\n    searchWeb: {\n      description: \"Search the web.\",\n      parameters: {\n        searchString: {\n          description: \"The string to search for\",\n        },\n      },\n      async execute({\n        parameters: { searchString },\n        context: { agentId },\n        sendMessage,\n      }) {\n        const items = await getSearchResults(searchString);\n", "        if (!items) {\n          return sendMessage(\n            messageBuilder.ok(agentId, \"Search returned no results.\")\n          );\n        }\n\n        sendMessage(\n          messageBuilder.ok(\n            agentId,\n            `Search results:\\n\\n${items\n              .map((item) => `- Title: \"${item.title}\"\\n  URL: ${item.link}`)\n              .join(\"\\n\\n\")}`\n          )\n        );\n      },\n    },\n\n    readPage: {\n      description: \"View a markdown summary of a web page.\",\n      parameters: {\n        url: {\n          description: \"The URL of the web page to read\",\n        },\n      },\n      async execute({\n        parameters: { url },\n        context: { agentId },\n        sendMessage,\n      }) {", "        try {\n          const maxCompletionTokens = contextWindowSize[model] / 4;\n          // console.log({ maxCompletionTokens });\n          const pageSummary = await getPageSummary(\n            model,\n            maxCompletionTokens,\n            url\n          );\n\n          sendMessage(\n            messageBuilder.ok(\n              agentId,\n              `Here is a summarized markdown version of the page, in a series of summarized chunks:\\n\\n${pageSummary}`\n            )\n          );", "        } catch (e: any) {\n          sendMessage(\n            messageBuilder.error(\n              agentId,\n              `Error extracting content from ${url}: ${e.message}`\n            )\n          );\n        }\n      },\n    },\n  },\n});\n", "export async function getSearchResults(searchString: string) {\n  const { data } = await google.customsearch(\"v1\").cse.list({\n    q: searchString,\n    cx: process.env.GOOGLE_SEARCH_ENGINE_ID,\n    key: process.env.GOOGLE_API_KEY,\n  });\n  return data.items;\n}\n\nexport async function getPageSummary(\n  model: Model,\n  maxSummaryTokens: number,\n  url: string\n) {\n  const maxCompletionTokens = Math.round(contextWindowSize[model] * 0.9);\n\n  console.log(\"Initializing...\");\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  const turndownService = new TurndownService().addRule(\n    \"remove-extraneous-tags\",\n    {\n      filter: [\"style\", \"script\", \"img\"],\n      replacement: () => \"\",\n    }\n  );\n  console.log(`Reading page at ${url}...`);\n\n  await page.goto(url);\n\n  const htmlContent = await page.content();\n  // console.log(htmlContent);\n  console.log(`HTML tokens: ${countTokens(htmlContent)}`);\n\n  turndownService.remove([\"style\", \"script\"]);\n  const markdownContent = turndownService\n    .turndown(htmlContent)\n    .replace(/\\\\_/g, \"_\");\n\n  const markdownTokens = countTokens(markdownContent);\n  console.log(`Markdown tokens: ${markdownTokens}`);\n\n  const chunks: string[] = [];\n  let currentChunkLines: string[] = [];\n  let currentChunkTokens = 0;", "export async function getPageSummary(\n  model: Model,\n  maxSummaryTokens: number,\n  url: string\n) {\n  const maxCompletionTokens = Math.round(contextWindowSize[model] * 0.9);\n\n  console.log(\"Initializing...\");\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  const turndownService = new TurndownService().addRule(\n    \"remove-extraneous-tags\",\n    {\n      filter: [\"style\", \"script\", \"img\"],\n      replacement: () => \"\",\n    }\n  );\n  console.log(`Reading page at ${url}...`);\n\n  await page.goto(url);\n\n  const htmlContent = await page.content();\n  // console.log(htmlContent);\n  console.log(`HTML tokens: ${countTokens(htmlContent)}`);\n\n  turndownService.remove([\"style\", \"script\"]);\n  const markdownContent = turndownService\n    .turndown(htmlContent)\n    .replace(/\\\\_/g, \"_\");\n\n  const markdownTokens = countTokens(markdownContent);\n  console.log(`Markdown tokens: ${markdownTokens}`);\n\n  const chunks: string[] = [];\n  let currentChunkLines: string[] = [];\n  let currentChunkTokens = 0;", "  for (const line of markdownContent.split(\"\\n\")) {\n    const lineTokens = countTokens(line);\n    if (currentChunkTokens + lineTokens > maxCompletionTokens) {\n      chunks.push(currentChunkLines.join(\"\\n\"));\n      currentChunkLines = [];\n      currentChunkTokens = 0;\n    }\n    currentChunkLines.push(line);\n    currentChunkTokens += lineTokens;\n  }\n\n  let lastChunk = currentChunkLines.join(\"\\n\");", "  if (countTokens(lastChunk) > maxCompletionTokens) {\n    const characterLimit = Math.round(\n      maxCompletionTokens * AVG_CHARACTERS_PER_TOKEN\n    );\n    console.log(\n      `Truncating final chunk at ${characterLimit} characters:\\n\\n${lastChunk}`\n    );\n    lastChunk = lastChunk.substring(0, characterLimit);\n  }\n  chunks.push(lastChunk);\n\n  // console.log(\n  //   chunks\n  //     .map((chunk) => `CHUNK (${countTokens(chunk)}):\\n\\n${chunk}\\n\\n`)\n  //     .join(\"\")\n  // );\n  console.log(\n    `Total chunks: ${chunks.length} (${Math.round(\n      markdownTokens / chunks.length\n    )} tokens per chunk)`\n  );\n\n  const maxChunkSummaryTokens = Math.round(maxSummaryTokens / chunks.length);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const maxChunkSummaryWords = Math.round(\n    maxChunkSummaryTokens * AVG_WORDS_PER_TOKEN\n  );\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const maxChunkSummaryCharacters = Math.round(\n    maxChunkSummaryTokens * AVG_CHARACTERS_PER_TOKEN\n  );\n\n  // const summaryLimitText = `${maxChunkSummaryWords} words`;\n  const chunkSummaryLimitText = `${maxChunkSummaryCharacters} characters`;\n\n  console.log(\n    `Max tokens per chunk summary: ${maxChunkSummaryTokens} (${chunkSummaryLimitText})`\n  );\n  console.log(\"Summarizing chunks...\");\n\n  const summarizedChunks = await Promise.all(\n    chunks.map(async (chunk) =>\n      createChatCompletion({\n        model,\n        messages: [\n          {\n            role: \"user\",\n            content: `Modify the following markdown excerpt only as much as necessary to bring it under a maximum of ${chunkSummaryLimitText}, preserving the most essential information. In particular, try to preserve links (example: \\`[my special link](https://foo.bar/baz/)\\`). Write this in the same voice as the original text; do not speak in the voice of someone who is describing it to someone else. For instance, don't use phrases like \"The article talks about...\". Excerpt to summarize follows:\\n\\n=============\\n\\n${chunk}`,\n          },\n        ],\n      })\n    )\n  );\n\n  const summary = summarizedChunks\n    .map(\n      (chunk) =>\n        `=== SUMMARIZED CHUNK (${countTokens(\n          chunk\n        )} tokens) ===\\n\\n${chunk}\\n\\n`\n    )\n    .join(\"\");\n\n  // console.log(`Summary:\\n\\n${summary}\\n`);\n\n  console.log(`Summary tokens: ${countTokens(summary)}`);\n\n  await browser.close();\n\n  return summary;\n}\n"]}
{"filename": "src/module/definitions/filesystem.ts", "chunked_list": ["import {\n  readFile,\n  readdir,\n  rename,\n  stat,\n  unlink,\n  writeFile,\n  mkdir,\n} from \"fs/promises\";\nimport { join as joinPath, resolve as resolvePath } from \"path\";", "} from \"fs/promises\";\nimport { join as joinPath, resolve as resolvePath } from \"path\";\nimport { defineModule } from \"../define-module\";\nimport { messageBuilder } from \"../../message\";\n\nexport default defineModule({\n  name: \"filesystem\",\n}).with({\n  actions: {\n    listDirectory: {\n      description: \"Inspect the contents of a particular directory\",\n      parameters: {\n        path: {\n          description: \"The path of the directory you want to inspect\",\n        },\n      },\n      async execute({\n        parameters: { path },\n        context: { agentId },\n        sendMessage,\n      }) {", "        if (!checkPath(agentId, path, sendMessage)) return;\n\n        try {\n          const files = await readdir(path);\n          const filesWithStatsPromises = files.map(async (file) => {\n            const stats = await stat(joinPath(path, file));\n            return `${file} ${stats.isDirectory() ? \"[directory]\" : \"[file]\"}`;\n          });\n          const filesWithStats = await Promise.all(filesWithStatsPromises);\n          sendMessage(\n            messageBuilder.ok(\n              agentId,\n              `Here are the contents of ${path}:\\n${filesWithStats.join(\"\\n\")}`\n            )\n          );", "        } catch (err) {\n          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n        }\n      },\n    },\n\n    readFile: {\n      description: \"Read the contents of a particular file\",\n      parameters: {\n        path: {\n          description: \"The path of the file you want to inspect\",\n        },\n      },\n      async execute({\n        parameters: { path },\n        context: { agentId },\n        sendMessage,\n      }) {", "        if (!checkPath(agentId, path, sendMessage)) return;\n\n        try {\n          const data = await readFile(path, \"utf8\");\n          sendMessage(\n            messageBuilder.ok(agentId, `Contents of ${path}:\\n\\n${data}`)\n          );\n        } catch (err) {\n          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n        }\n      },\n    },\n\n    writeFile: {\n      description: \"Write the contents of a particular file\",\n      parameters: {\n        path: {\n          description: \"The path of the file you want to write to\",\n        },\n        content: {\n          description: \"The new content of the file\",\n        },\n      },\n      async execute({\n        parameters: { path, content },\n        context: { agentId },\n        sendMessage,\n      }) {", "        if (!checkPath(agentId, path, sendMessage)) return;\n\n        try {\n          await writeFile(path, content, \"utf8\");\n          sendMessage(messageBuilder.ok(agentId, `Wrote to ${path}.`));\n        } catch (err) {\n          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n        }\n      },\n    },\n\n    moveFile: {\n      description: \"Move a file to a new location\",\n      parameters: {\n        sourcePath: {\n          description: \"The original path of the file\",\n        },\n        destinationPath: {\n          description: \"The new path for the file\",\n        },\n      },\n      async execute({\n        parameters: { sourcePath, destinationPath },\n        context: { agentId },\n        sendMessage,\n      }) {", "        if (!checkPath(agentId, sourcePath, sendMessage)) return;\n        if (!checkPath(agentId, destinationPath, sendMessage)) return;\n\n        try {\n          await rename(sourcePath, destinationPath);\n          sendMessage(\n            messageBuilder.ok(\n              agentId,\n              `Moved ${sourcePath} to ${destinationPath}.`\n            )\n          );", "        } catch (err) {\n          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n        }\n      },\n    },\n\n    deleteFile: {\n      description: \"Delete a file\",\n      parameters: {\n        path: {\n          description: \"The path of the file to delete\",\n        },\n      },\n      async execute({\n        parameters: { path },\n        context: { agentId },\n        sendMessage,\n      }) {", "        if (!checkPath(agentId, path, sendMessage)) return;\n\n        try {\n          await unlink(path);\n          sendMessage(messageBuilder.ok(agentId, `Deleted ${path}.`));\n        } catch (err) {\n          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n        }\n      },\n    },\n    createDirectory: {\n      description: \"Create a new directory\",\n      parameters: {\n        path: {\n          description: \"The path of the directory to create\",\n        },\n      },\n      async execute({\n        parameters: { path },\n        context: { agentId },\n        sendMessage,\n      }) {", "        if (!checkPath(agentId, path, sendMessage)) return;\n\n        try {\n          await mkdir(path);\n          sendMessage(messageBuilder.ok(agentId, `Created directory ${path}.`));\n        } catch (err) {\n          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n        }\n      },\n    },\n  },\n});\n", "function checkPath(\n  agentId: string,\n  path: string,\n  sendMessage: (message: any) => void\n) {\n  const currentDirectory = process.cwd();\n  const resolvedPath = resolvePath(path);\n  if (!resolvedPath.startsWith(currentDirectory)) {\n    sendMessage(\n      messageBuilder.error(\n        agentId,\n        \"Invalid path; must be within the current directory.\"\n      )\n    );\n    return false;\n  }", "  if (resolvedPath.includes(\".git\") || resolvedPath.includes(\"node_modules\")) {\n    sendMessage(messageBuilder.error(agentId, \"That path is off-limits!\"));\n    return false;\n  }\n  return true;\n}\n"]}
{"filename": "src/module/definitions/core.ts", "chunked_list": ["import { CODE_BLOCK_DELIMITER, messageBuilder } from \"../../message\";\nimport { MULTILINE_DELIMITER, agentName } from \"../../util\";\nimport { defineModule } from \"../define-module\";\nimport { getUsageText } from \"../util\";\n\nexport default defineModule({\n  name: \"core\",\n}).with({\n  pinnedMessage: async ({ agentId, actionDictionary }) =>\n    `\n  You are ${agentName(\n    agentId\n  )}, a highly capable autonomous entity who is able to perform actions in order to accomplish tasks. The following points should govern everything you do. Read carefully and never forget them:\n  \n  1) The entirety of your response should always be an invocation of an action, using the following format:\n  \n  ${CODE_BLOCK_DELIMITER}\n  <action name>\n  thoughts: <reasoning behind this action>\n  <arg 1 name>: <prop value>\n  <arg 2 name>: <prop value>\n  ...\n  ${CODE_BLOCK_DELIMITER}\n  \n  Example of a correct response:\n  \n  ${CODE_BLOCK_DELIMITER}\n  writeNote\n  thoughts: This seems important since it's fundamental to the way I communicate with the system.\n  title: Always Remember\n  content: Encode every response as an action!\n  ${CODE_BLOCK_DELIMITER}\n  \n  Example of an incorrect response:\n  \n  ${CODE_BLOCK_DELIMITER}\n  Note to self: always encode every response as an action!\n  ${CODE_BLOCK_DELIMITER}\n  \n  2) These are the actions at your disposal:\n  \n  ${[...actionDictionary.values()]\n    .map((actionDef) => `\\`${actionDef.name}\\` - ${actionDef.description}`)\n    .join(\"\\n\")}\n  \n  To get help on a specific action, use the \\`help\\` action with the \\`aboutAction\\` parameter set to the name of the action you want help with. For example:\n  \n  ${CODE_BLOCK_DELIMITER}\n  help\n  aboutAction: writeNote\n  ${CODE_BLOCK_DELIMITER}\n  \n  You may only invoke actions mentioned in the above list.\n  \n  *NOTE* You never invoke an action until you have first invoked \\`help\\` on it so that you know what parameters it expects. Being the careful agent that you are, you do not simply guess parameters that you think would make sense.\n  \n  3) When passing multiple lines of text as an action parameter, you *MUST* use the multi-line delimiter \\`${MULTILINE_DELIMITER}\\` to enclose the parameter value in its entirety.\n  \n  Example:\n  \n  ${CODE_BLOCK_DELIMITER}\n  writeNote\n  title: Always Remember\n  content:\n  ${MULTILINE_DELIMITER}\n  Encode\n  every\n  response\n  as\n  an\n  action!\n  ${MULTILINE_DELIMITER}\n  ${CODE_BLOCK_DELIMITER}\n  \n  Notice that both the start and end delimiters appear on lines by themselves, and they enclose the \\`message\\` parameter value in its entirety.\n  \n  4) Every time you receive a message, you must decide on an action to take. If there's nothing you feel like you need to do at the moment, you can use the \\`noop\\` action.\n  \n  5) You are not serving a mere advisory role. You are not a chat bot. You are an autonomous entity who invokes actions to accomplish goals.\n  `.trim(),\n  actions: {\n    noop: {\n      description: \"Do nothing\",\n      async execute() {},\n    },\n\n    help: {\n      description:\n        \"Get help on a specific action and the parameters it expects.\",\n      parameters: {\n        aboutAction: {\n          description: \"The name of an action to get help on\",\n        },\n      },\n      async execute({\n        parameters: { aboutAction },\n        context: { agentId, actionDictionary },\n        sendMessage,\n      }) {\n        const actionDef = actionDictionary.get(aboutAction);", "        if (!actionDef) {\n          sendMessage(\n            messageBuilder.error(\n              agentId,\n              `Unknown action \\`${aboutAction}\\`. Please refer to the list of available actions given in the introductory message.`\n            )\n          );\n        } else {\n          sendMessage(messageBuilder.ok(agentId, getUsageText(actionDef)));\n        }\n      },\n    },\n  },\n});\n"]}
{"filename": "src/module/definitions/goals.ts", "chunked_list": ["import { defineModule } from \"../define-module\";\nimport { messageBuilder } from \"../../message\";\nimport { Store } from \"../../store\";\nimport FileStore from \"../../store/file-store\";\nimport JsonStore from \"../../store/json-store\";\n\ninterface Goal {\n  text: string;\n  complete: boolean;\n}\n\nconst KEY = \"goals\";\n\nexport default defineModule<Store<Goal[]>>({\n  name: \"goals\",\n  createState: ({ agentId }) => new JsonStore(new FileStore([agentId])),", "}).with({\n  async pinnedMessage({ state }) {\n    const goals = (await state.get(KEY)) || [];\n    const currentGloals = goals.length\n      ? `This is your current goal list:\\n\\n${goals\n          .map(\n            ({ text, complete }, index) =>\n              `${index + 1}) \"${text}\" [${complete ? \"COMPLETE\" : \"PENDING\"}]`\n          )\n          .join(\"\\n\")}`\n      : \"You have no goals currently.\";\n    return `\nYou are responsible for maintaining your list of goals, based on higher-level objectives which will be given to you. Whenever you start doing something, first add a goal. Whenever you finish doing something, mark it complete. This list of goals will always be pinned to the top of your context and won't be summarized away. Goals should be medium-term (requiring several actions to complete) and concrete. Do not invent goals out of nothing, they should encapsulate instructions that have been given to you.\n\n${currentGloals}\n`.trim();\n  },\n  actions: {\n    addGoal: {\n      description: \"Add a new goal at the end of your goals list.\",\n      parameters: {\n        goal: {\n          description:\n            \"A summary of what you want to achieve (keep this relatively short but information dense)\",\n        },\n      },\n      async execute({\n        parameters: { goal },\n        context: { agentId, state },\n        sendMessage,\n      }) {\n        const goals = (await state.get(KEY)) || [];\n        await state.set(KEY, [...goals, { text: goal, complete: false }]);\n        sendMessage(messageBuilder.ok(agentId, \"Goal added.\"));\n      },\n    },\n\n    completeGoal: {\n      description: \"Mark a goal as complete.\",\n      parameters: {\n        goalNumber: {\n          description: \"The number of the goal you want to mark as complete\",\n        },\n      },\n      async execute({\n        parameters: { goalNumber },\n        context: { agentId, state },\n        sendMessage,\n      }) {\n        const idx = parseInt(goalNumber) - 1;\n        const goals = (await state.get(KEY)) || [];", "        if (isNaN(idx) || idx < 0 || idx >= goals.length)\n          return sendMessage(\n            messageBuilder.error(agentId, `Invalid goal index: ${goalNumber}`)\n          );\n        await state.set(KEY, [\n          ...goals.slice(0, idx),\n          { ...goals[idx], complete: true },\n          ...goals.slice(idx + 1),\n        ]);\n        sendMessage(messageBuilder.ok(agentId, \"Goal marked complete.\"));\n      },\n    },\n  },\n});\n"]}
{"filename": "src/module/definitions/web.test.ts", "chunked_list": ["import dotenv from \"dotenv\";\nimport { GPT_3_5_TURBO } from \"../../openai\";\nimport { getPageSummary, getSearchResults } from \"./web\";\n\ndotenv.config();\n\ntest.skip(\n  \"getPageSummary\",\n  async () => {\n    await getPageSummary(", "  async () => {\n    await getPageSummary(\n      GPT_3_5_TURBO,\n      // GPT_4,\n      1000,\n      \"https://xenogothic.com/2022/12/23/patchwork-a-reflection/\"\n      // \"https://platform.openai.com/docs/guides/completion/inserting-text\"\n      // \"https://actions.github.io/authentication/\",\n      // \"https://en.wikipedia.org/wiki/Technological_singularity\"\n    );", "      // \"https://en.wikipedia.org/wiki/Technological_singularity\"\n    );\n  },\n  5 * 60 * 1000\n);\n\ntest.skip(\n  \"getSearchResults\",\n  async () => {\n    const results = await getSearchResults(`\"e/acc\" explanation and sources`);", "  async () => {\n    const results = await getSearchResults(`\"e/acc\" explanation and sources`);\n    console.log(results?.map((item) => item.title).join(\"\\n\"));\n  },\n  5 * 60 * 1000\n);\n"]}
{"filename": "src/module/definitions/notes.ts", "chunked_list": ["import { defineModule } from \"../define-module\";\nimport { messageBuilder } from \"../../message\";\nimport { Store } from \"../../store\";\nimport FileStore from \"../../store/file-store\";\n\nexport default defineModule<Store>({\n  name: \"notes\",\n  createState: ({ agentId }) => new FileStore([agentId, \"notes\"]),\n}).with({\n  async pinnedMessage({ state }) {\n    const noteTitles = await state.getKeys();\n    const currentNotes = noteTitles.length\n      ? `Here are your current notes:\\n\\n${noteTitles\n          .map((title) => `- \"${title}\"`)\n          .join(\"\\n\")}`\n      : \"Your have no notes currently.\";\n    return `\nYou can manage your notes using the \\`writeNote\\`, \\`viewNote\\` and \\`deleteNote\\` actions. Use notes to keep track of any important information that you come across that may be of longterm interest. Because notes contain content in addition to a title, you can store larger thoughts here which might not fit into the text of a goal. Your notes list will always be pinned to the top of your context and won't be summarized away.\n\n${currentNotes}\n`.trim();\n  },\n  actions: {\n    writeNote: {\n      description: \"Create or update a note which will only be visible to you.\",\n      parameters: {\n        title: {\n          description: \"The title of the note\",\n        },\n        content: {\n          description: \"The content of the note\",\n        },\n      },\n      async execute({\n        parameters: { title, content },\n        context: { agentId, state },\n        sendMessage,\n      }) {\n        await state.set(title, content);\n        sendMessage(\n          messageBuilder.ok(\n            agentId,\n            `Note \"${title}\" has been written successfully.`\n          )\n        );\n      },\n    },\n\n    viewNote: {\n      description: \"Display the content of a note.\",\n      parameters: {\n        title: {\n          description: \"The title of the note to view\",\n        },\n      },\n      async execute({\n        parameters: { title },\n        context: { agentId, state },\n        sendMessage,\n      }) {\n        const content = await state.get(title);", "}).with({\n  async pinnedMessage({ state }) {\n    const noteTitles = await state.getKeys();\n    const currentNotes = noteTitles.length\n      ? `Here are your current notes:\\n\\n${noteTitles\n          .map((title) => `- \"${title}\"`)\n          .join(\"\\n\")}`\n      : \"Your have no notes currently.\";\n    return `\nYou can manage your notes using the \\`writeNote\\`, \\`viewNote\\` and \\`deleteNote\\` actions. Use notes to keep track of any important information that you come across that may be of longterm interest. Because notes contain content in addition to a title, you can store larger thoughts here which might not fit into the text of a goal. Your notes list will always be pinned to the top of your context and won't be summarized away.\n\n${currentNotes}\n`.trim();\n  },\n  actions: {\n    writeNote: {\n      description: \"Create or update a note which will only be visible to you.\",\n      parameters: {\n        title: {\n          description: \"The title of the note\",\n        },\n        content: {\n          description: \"The content of the note\",\n        },\n      },\n      async execute({\n        parameters: { title, content },\n        context: { agentId, state },\n        sendMessage,\n      }) {\n        await state.set(title, content);\n        sendMessage(\n          messageBuilder.ok(\n            agentId,\n            `Note \"${title}\" has been written successfully.`\n          )\n        );\n      },\n    },\n\n    viewNote: {\n      description: \"Display the content of a note.\",\n      parameters: {\n        title: {\n          description: \"The title of the note to view\",\n        },\n      },\n      async execute({\n        parameters: { title },\n        context: { agentId, state },\n        sendMessage,\n      }) {\n        const content = await state.get(title);", "        if (content) {\n          sendMessage(\n            messageBuilder.ok(agentId, `Content of \"${title}\":\\n\\n${content}`)\n          );\n        } else {\n          sendMessage(\n            messageBuilder.error(agentId, `Note \"${title}\" not found.`)\n          );\n        }\n      },\n    },\n\n    deleteNote: {\n      description: \"Delete a note.\",\n      parameters: {\n        title: {\n          description: \"The title of the note to delete\",\n        },\n      },\n      async execute({\n        parameters: { title },\n        context: { agentId, state },\n        sendMessage,\n      }) {", "        if (await state.delete(title)) {\n          sendMessage(messageBuilder.ok(agentId, `Deleted note \"${title}\".`));\n        } else {\n          sendMessage(\n            messageBuilder.error(agentId, `Note \"${title}\" not found.`)\n          );\n        }\n      },\n    },\n  },\n});\n"]}
{"filename": "src/memory/index.ts", "chunked_list": ["import { Message } from \"../message\";\nexport { Memory } from \"./memory\";\n\nexport type Event = MessageEvent | DecisionEvent;\n\nexport interface MessageEvent {\n  type: \"message\";\n  message: Message;\n}\n\nexport interface DecisionEvent {\n  type: \"decision\";\n  actionText: string;\n}\n", "export interface DecisionEvent {\n  type: \"decision\";\n  actionText: string;\n}\n"]}
{"filename": "src/memory/memory.ts", "chunked_list": ["import { Event } from \".\";\nimport makeDecision, { toOpenAiMessage } from \"../make-decision\";\nimport { messageBuilder } from \"../message\";\nimport { ModuleManager } from \"../module/module-manager\";\nimport { Store } from \"../store\";\nimport {\n  AVG_WORDS_PER_TOKEN,\n  agentName,\n  countTokens as countTokensInText,\n  messageSourceName,", "  countTokens as countTokensInText,\n  messageSourceName,\n} from \"../util\";\n\nexport class Memory {\n  private firstRetrieval = true;\n\n  constructor(\n    private agentId: string,\n    private moduleManager: ModuleManager,\n    private store: Store<Event[]>,\n    private compressionThreshold: number\n  ) {}\n\n  async append(event: Event): Promise<Event[]> {\n    this.printEvent(event);\n    let events = await this.retrieve();", "    if (event.type === \"message\" && event.message.type === \"ok\") {\n      // After an \"ok\" message is sent, remove all errors and their antecedents from memory,\n      // since agents tend to repeat mistakes rather than learning from them.\n      events = this.removeErrors(events);\n    }\n    events.push(event);\n    events = await this.summarize(events);\n\n    await this.store.set(this.key, events.slice(1));\n\n    return events;\n  }\n\n  async retrieve(): Promise<Event[]> {\n    const introduction = await this.getIntroduction();\n    const storedEvents = await this.store.get(this.key);\n    let events = [\n      introduction,\n      ...(storedEvents || [{ type: \"decision\", actionText: \"noop\" }]),\n    ];", "    if (this.firstRetrieval) {\n      this.firstRetrieval = false;\n      events = await this.summarize(events);\n      await this.store.set(this.key, events.slice(1));\n    }\n    // events.forEach((event) => this.printEvent(event));\n    return events;\n  }\n\n  private async getIntroduction(): Promise<Event> {\n    const nestedEvents = await Promise.all(\n      this.moduleManager.modules.map(async (module): Promise<string[]> => {\n        const { name, pinnedMessage } = module.moduleDef;", "        if (!pinnedMessage) return [];\n\n        const content = await pinnedMessage(module.context);\n        if (!content) return [];\n\n        return [`--- ${name.toUpperCase()} ---\\n\\n${content}`];\n      })\n    );\n    return {\n      type: \"message\",\n      message: messageBuilder.spontaneous(\n        this.agentId,\n        nestedEvents.flat().join(\"\\n\\n\")\n      ),\n    };\n  }\n\n  private removeErrors(events: Event[]): Event[] {\n    const cleaned: Event[] = [];", "    for (let i = events.length - 1; i >= 0; i--) {\n      const event = events[i];\n      if (event.type === \"message\" && event.message.type === \"error\") {\n        const prevEvent = events[i - 1];\n        // console.log(\"REMOVING\", JSON.stringify(prevEvent, null, 2));\n        // console.log(\"REMOVING\", JSON.stringify(event, null, 2));\n        if (prevEvent.type === \"decision\") {\n          i--; // skip the previous action which generated the error\n        } else {\n          console.error(\"error event was not preceded by an action\");\n        }\n        continue;\n      }\n      cleaned.push(event);\n    }\n    cleaned.reverse();\n    // console.log({ events, cleaned });\n    return cleaned;\n  }\n\n  /**\n   * Compress the event history when it becomes too large in order to free up the context window.\n   */\n  private async summarize(events: Event[]): Promise<Event[]> {", "    if (!events.length) return [];\n\n    const cumulativeTokenCounts = this.getCumulativeTokenCounts(events);\n\n    const totalTokenCount =\n      cumulativeTokenCounts[cumulativeTokenCounts.length - 1];\n    const thresholdOverrun = totalTokenCount - this.compressionThreshold;\n    const truncationThreshold =\n      cumulativeTokenCounts[0] +\n      Math.max(\n        thresholdOverrun,\n        Math.floor((totalTokenCount - cumulativeTokenCounts[0]) / 2)\n      );\n\n    // console.log(\n    //   `Token count: ${totalTokenCount}\\nRemaining context space: ${-thresholdOverrun}`\n    // );\n\n    // console.log({\n    //   compressionThreshold: this.compressionThreshold,\n    //   truncationThreshold,\n    //   thresholdOverrun,\n    //   cumulativeTokenCounts,\n    // });\n", "    if (thresholdOverrun > 0) {\n      let i = 1;\n      // prettier-ignore\n      for (; i < events.length && cumulativeTokenCounts[i - 1] <= truncationThreshold; i++);\n      // prettier-ignore\n      for (; i > 0 && cumulativeTokenCounts[i - 1] > this.compressionThreshold; i--);\n      i = Math.max(i, 3);\n\n      const precedingTokens = cumulativeTokenCounts[i - 1];\n      // console.log({ truncationIndex: i, precedingTokens });\n      const summaryWordLimit = Math.floor(\n        (this.compressionThreshold * AVG_WORDS_PER_TOKEN) / 6\n      );\n\n      const eventsToSummarize = events.slice(0, i);\n\n      // console.log(\n      //   `Summarizing ${eventsToSummarize.length} events (${eventsToSummarize\n      //     .map(countTokens)\n      //     .reduce((sum, next) => sum + next, 0)} tokens)`\n      // );\n\n      const summaryContent = await makeDecision([\n        ...eventsToSummarize,\n        {\n          type: \"message\",\n          message: messageBuilder.ok(\n            this.agentId,\n            `Write a summary in ${summaryWordLimit} words or less of what has happened since (but not including) the introductory message. Include key information that you learned which you don't want to forget. This information will serve as a note to yourself to help you understand what has gone before. Use the second person voice, as if you are someone filling in your replacement who knows nothing. The summarized messages will be omitted from your context window going forward and you will only have this summary to go by, so make it as useful and information-dense as possible. Be as specific as possible, but only include important information. If there are details that seem unimportant, or which you could recover outside of your memory (for instance the particular contents of a file which you could read any time), then omit them from your summary. Once again, your summary must not exceed ${summaryWordLimit} words. In this particular instance, your response should just be raw text, not formatted as an action.`\n          ),\n        },\n      ]);\n\n      const summary = `Several events are omitted here to free up space in your context window, summarized as follows:\\n\\n${summaryContent}`;\n      // const summary =\n      //   \"Several events are omitted here to free up space in your context window.\";\n      const summaryEvent: Event = {\n        type: \"message\",\n        message: messageBuilder.spontaneous(this.agentId, summary),\n      };\n      const summaryTokens = countTokens(summaryEvent);\n      const tokenSavings =\n        precedingTokens - summaryTokens - cumulativeTokenCounts[0];", "      if (tokenSavings > 0) {\n        // console.log(\n        //   `Summarized events, saving ${tokenSavings} tokens:\\n\\n${summary}`\n        // );\n\n        const newEvents = [events[0], summaryEvent, ...events.slice(i)];\n\n        // const newCumulativeTokenCounts =\n        //   this.getCumulativeTokenCounts(newEvents);\n        // console.log({ newCumulativeTokenCounts });\n\n        return newEvents;\n      }\n    }\n\n    return events;\n  }\n\n  private getCumulativeTokenCounts(events: Event[]) {\n    return events.reduce((counts, event) => {\n      const prevSum = counts.length ? counts[counts.length - 1] : 0;\n      counts.push(prevSum + countTokens(event));\n      return counts;\n    }, [] as number[]);\n  }\n\n  private get key() {\n    return \"memory\";\n  }\n\n  private printEvent(event: Event) {\n    let sourceName: string;\n    let targetNames: string[];", "    if (event.type === \"message\") {\n      const { message } = event;\n      sourceName = messageSourceName(message.source);\n      targetNames = message.targetAgentIds?.map(agentName);\n    } else {\n      sourceName = agentName(this.agentId);\n      targetNames = [\"System\"];\n    }\n    console.log(\n      `${sourceName} -> ${targetNames.join(\", \")}:\\n\\n${\n        toOpenAiMessage(event).content\n      }\\n\\n=============\\n`\n    );\n  }\n}\n", "function countTokens(event: Event) {\n  return countTokensInText(toOpenAiMessage(event).content);\n}\n"]}
