{"filename": "vitest.config.ts", "chunked_list": ["import path from \"node:path\";\nimport { configDefaults, defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    exclude: [...configDefaults.exclude],\n  },\n  resolve: {\n    alias: {\n      \"~\": path.resolve(__dirname, \"./src\"),", "    alias: {\n      \"~\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n});\n"]}
{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from \"tsup\";\n\nexport default defineConfig({\n  entry: [\"src/index.ts\"],\n  format: [\"esm\"],\n  /**\n   * The `isolate` binary is an ES module. It is required to have the `.mjs`\n   * file extension, otherwise a non-ESM workspace will try to load it as\n   * commonJS. For details on this read [this article from Alex\n   * Rauschmayer](https://exploringjs.com/nodejs-shell-scripting/ch_creating-shell-scripts.html#node.*", "   * commonJS. For details on this read [this article from Alex\n   * Rauschmayer](https://exploringjs.com/nodejs-shell-scripting/ch_creating-shell-scripts.html#node.*\n   * js-esm-modules-as-standalone-shell-scripts-on-unix)\n   */\n  outExtension() {\n    return {\n      js: `.mjs`,\n    };\n  },\n  target: \"esnext\",", "  },\n  target: \"esnext\",\n  sourcemap: true,\n  dts: true,\n  clean: true,\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["#!/usr/bin/env node\n/**\n * For PNPM the hashbang at the top of the script was not required, but Yarn 3\n * did not seem to execute without it.\n */\n\n/**\n * A word about used terminology:\n *\n * The various package managers, while being very similar, seem to use a", " *\n * The various package managers, while being very similar, seem to use a\n * different definition for the term \"workspace\". If you want to read the code\n * it might be good to know that I consider the workspace to be the monorepo\n * itself, in other words, the overall structure that holds all the packages.\n */\nimport fs from \"fs-extra\";\nimport assert from \"node:assert\";\nimport path from \"node:path\";\nimport sourceMaps from \"source-map-support\";", "import path from \"node:path\";\nimport sourceMaps from \"source-map-support\";\nimport {\n  PackageManifest,\n  adaptManifestFiles,\n  adaptTargetPackageManifest,\n  createPackagesRegistry,\n  detectPackageManager,\n  getBuildOutputDir,\n  getConfig,", "  getBuildOutputDir,\n  getConfig,\n  listLocalDependencies,\n  packDependencies,\n  processBuildOutputFiles,\n  processLockfile,\n  unpackDependencies,\n} from \"~/helpers\";\nimport {\n  createLogger,", "import {\n  createLogger,\n  getDirname,\n  getRootRelativePath,\n  readTypedJson,\n} from \"~/utils\";\n\nconst config = getConfig();\nconst log = createLogger(config.logLevel);\n", "const log = createLogger(config.logLevel);\n\nsourceMaps.install();\n\nasync function start() {\n  const __dirname = getDirname(import.meta.url);\n\n  const thisPackageManifest = await readTypedJson<PackageManifest>(\n    path.join(path.join(__dirname, \"..\", \"package.json\"))\n  );\n\n  log.debug(\"Running isolate-package version\", thisPackageManifest.version);\n\n  /**\n   * If a targetPackagePath is set, we assume the configuration lives in the\n   * root of the workspace. If targetPackagePath is undefined (the default), we\n   * assume that the configuration lives in the target package directory.\n   */\n  const targetPackageDir = config.targetPackagePath\n    ? path.join(process.cwd(), config.targetPackagePath)\n    : process.cwd();\n\n  /**\n   * We want a trailing slash here. Functionally it doesn't matter, but it makes\n   * the relative paths more correct in the debug output.\n   */\n  const workspaceRootDir = config.targetPackagePath\n    ? process.cwd()\n    : path.join(targetPackageDir, config.workspaceRoot);\n\n  const buildOutputDir = await getBuildOutputDir(targetPackageDir);\n\n  assert(\n    fs.existsSync(buildOutputDir),\n    `Failed to find build output path at ${buildOutputDir}. Please make sure you build the source before isolating it.`\n  );\n\n  log.debug(\"Workspace root resolved to\", workspaceRootDir);\n  log.debug(\n    \"Isolate target package\",\n    getRootRelativePath(targetPackageDir, workspaceRootDir)\n  );\n\n  const isolateDir = path.join(targetPackageDir, config.isolateDirName);\n\n  log.debug(\n    \"Isolate output directory\",\n    getRootRelativePath(isolateDir, workspaceRootDir)\n  );\n", "  if (fs.existsSync(isolateDir)) {\n    await fs.remove(isolateDir);\n    log.debug(\"Cleaned the existing isolate output directory\");\n  }\n\n  await fs.ensureDir(isolateDir);\n\n  const tmpDir = path.join(isolateDir, \"__tmp\");\n  await fs.ensureDir(tmpDir);\n\n  const targetPackageManifest = await readTypedJson<PackageManifest>(\n    path.join(targetPackageDir, \"package.json\")\n  );\n\n  const packageManager = detectPackageManager(workspaceRootDir);\n\n  log.debug(\n    \"Detected package manager\",\n    packageManager.name,\n    packageManager.version\n  );\n\n  /**\n   * Disable lock files for PNPM because they are not yet supported.\n   */", "  if (packageManager.name === \"pnpm\") {\n    config.excludeLockfile = true;\n  }\n\n  /**\n   * Build a packages registry so we can find the workspace packages by name and\n   * have access to their manifest files and relative paths.\n   */\n  const packagesRegistry = await createPackagesRegistry(\n    workspaceRootDir,\n    config.workspacePackages\n  );\n\n  const localDependencies = listLocalDependencies(\n    targetPackageManifest,\n    packagesRegistry,\n    {\n      includeDevDependencies: config.includeDevDependencies,\n    }\n  );\n\n  const packedFilesByName = await packDependencies({\n    localDependencies,\n    packagesRegistry,\n    packDestinationDir: tmpDir,\n  });\n\n  await unpackDependencies(\n    packedFilesByName,\n    packagesRegistry,\n    tmpDir,\n    isolateDir\n  );\n\n  /**\n   * Adapt the manifest files for all the unpacked local dependencies\n   */\n  await adaptManifestFiles(localDependencies, packagesRegistry, isolateDir);\n\n  /**\n   * Pack the target package directory, and unpack it in the isolate location\n   */\n  await processBuildOutputFiles({\n    targetPackageDir,\n    tmpDir,\n    isolateDir,\n  });\n\n  /**\n   * Copy the target manifest file to the isolate location and adapt its\n   * workspace dependencies to point to the isolated packages.\n   */\n  await adaptTargetPackageManifest(\n    targetPackageManifest,\n    packagesRegistry,\n    isolateDir\n  );\n", "  if (config.excludeLockfile) {\n    log.warn(\"Excluding the lockfile from the isolate output\");\n  } else {\n    /**\n     * Copy and adapt the lockfile\n     */\n    await processLockfile({\n      workspaceRootDir,\n      targetPackageName: targetPackageManifest.name,\n      isolateDir,\n      packagesRegistry,\n    });\n  }\n\n  /**\n   * If there is an .npmrc file in the workspace root, copy it to the\n   * isolate because the settings there could affect how the lockfile is\n   * resolved. Note that .npmrc is used by both NPM and PNPM for configuration.\n   *\n   * See also: https://pnpm.io/npmrc\n   */\n  const npmrcPath = path.join(workspaceRootDir, \".npmrc\");\n", "  if (fs.existsSync(npmrcPath)) {\n    fs.copyFileSync(npmrcPath, path.join(isolateDir, \".npmrc\"));\n    log.debug(\"Copied .npmrc file to the isolate output\");\n  }\n\n  /**\n   * Clean up. Only so this in the happy path, so we can look at the temp folder\n   * when thing go wrong.\n   */\n  log.debug(\n    \"Deleting temp directory\",\n    getRootRelativePath(tmpDir, workspaceRootDir)\n  );\n  await fs.remove(tmpDir);\n\n  log.info(\"Isolate completed at\", isolateDir);\n}\n", "start().catch((err) => {\n  if (err instanceof Error) {\n    log.error(err.stack);\n    process.exit(1);\n  } else {\n    console.error(err);\n  }\n});\n\nprocess.on(\"unhandledRejection\", log.error);\n"]}
{"filename": "src/utils/inspect-value.ts", "chunked_list": ["import { inspect } from \"node:util\";\nimport { JsonValue } from \"type-fest\";\n\nexport function inspectValue(value: JsonValue) {\n  return inspect(value, false, 4, true);\n}\n"]}
{"filename": "src/utils/yaml.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport yaml from \"yaml\";\nimport { getErrorMessage } from \"./get-error-message\";\n\nexport function readTypedYamlSync<T>(filePath: string) {\n  try {\n    const rawContent = fs.readFileSync(filePath, \"utf-8\");\n    const data = yaml.parse(rawContent);\n    /**\n     * @TODO add some zod validation maybe\n     */\n    return data as T;", "  } catch (err) {\n    throw new Error(\n      `Failed to read YAML from ${filePath}: ${getErrorMessage(err)}`\n    );\n  }\n}\n\nexport function writeTypedYamlSync<T>(filePath: string, content: T) {\n  /**\n   * @TODO add some zod validation maybe\n   */\n  fs.writeFileSync(filePath, yaml.stringify(content), \"utf-8\");\n}\n"]}
{"filename": "src/utils/get-error-message.ts", "chunked_list": ["type ErrorWithMessage = {\n  message: string;\n};\n\nexport function getErrorMessage(error: unknown) {\n  return toErrorWithMessage(error).message;\n}\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n  return typeof error === \"object\" && error !== null && \"message\" in error;\n}\n", "function isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n  return typeof error === \"object\" && error !== null && \"message\" in error;\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n  if (isErrorWithMessage(maybeError)) return maybeError;\n\n  try {\n    return new Error(JSON.stringify(maybeError));\n  } catch {\n    /**\n     * Fallback in case there\u2019s an error stringifying the maybeError\n     * like with circular references.\n     */\n    return new Error(String(maybeError));\n  }\n}\n"]}
{"filename": "src/utils/pack.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport { exec } from \"node:child_process\";\nimport path from \"node:path\";\nimport { getConfig } from \"~/helpers\";\nimport { createLogger } from \"./logger\";\n\nexport async function pack(\n  srcDir: string,\n  dstDir: string,\n  usePnpmPack = false\n) {\n  const execOptions = {\n    maxBuffer: 10 * 1024 * 1024,\n  };\n\n  const log = createLogger(getConfig().logLevel);\n\n  const previousCwd = process.cwd();\n  process.chdir(srcDir);\n\n  /**\n   * PNPM pack seems to be a lot faster than NPM pack, so when PNPM is detected\n   * we use that instead.\n   */\n  const stdout = usePnpmPack\n    ? await new Promise<string>((resolve, reject) => {\n        exec(\n          `pnpm pack --pack-destination ${dstDir}`,\n          execOptions,\n          (err, stdout, stderr) => {", "            if (err) {\n              log.error(stderr);\n              return reject(err);\n            }\n\n            resolve(stdout);\n          }\n        );\n      })\n    : await new Promise<string>((resolve, reject) => {\n        exec(\n          `npm pack --pack-destination ${dstDir}`,\n          execOptions,\n          (err, stdout) => {", "            if (err) {\n              return reject(err);\n            }\n\n            resolve(stdout);\n          }\n        );\n      });\n\n  const fileName = path.basename(stdout.trim());\n\n  const filePath = path.join(dstDir, fileName);\n", "  if (!fs.existsSync(filePath)) {\n    log.error(\n      `The response from pack could not be resolved to an existing file: ${filePath}`\n    );\n  } else {\n    log.debug(`Packed (temp)/${fileName}`);\n  }\n\n  process.chdir(previousCwd);\n\n  /**\n   * Return the path anyway even if it doesn't validate. A later stage will wait\n   * for the file to occur still. Not sure if this makes sense. Maybe we should\n   * stop at the validation error...\n   */\n  return filePath;\n}\n"]}
{"filename": "src/utils/logger.ts", "chunked_list": ["import chalk from \"chalk\";\nimport { IsolateConfigResolved } from \"~/helpers\";\n\nexport type Logger = {\n  debug(...args: any[]): void;\n  info(...args: any[]): void;\n  warn(...args: any[]): void;\n  error(...args: any[]): void;\n};\n\nexport function createLogger(\n  logLevel: IsolateConfigResolved[\"logLevel\"]\n): Logger {\n  return {\n    debug(...args: any[]) {", "export function createLogger(\n  logLevel: IsolateConfigResolved[\"logLevel\"]\n): Logger {\n  return {\n    debug(...args: any[]) {\n      if (logLevel === \"debug\") {\n        console.log(chalk.blue(\"debug\"), ...args);\n      }\n    },\n    info(...args: any[]) {\n      if (logLevel === \"debug\" || logLevel === \"info\") {\n        console.log(chalk.green(\"info\"), ...args);\n      }\n    },\n    warn(...args: any[]) {", "      if (logLevel === \"debug\" || logLevel === \"info\") {\n        console.log(chalk.green(\"info\"), ...args);\n      }\n    },\n    warn(...args: any[]) {\n      if (logLevel === \"debug\" || logLevel === \"info\" || logLevel === \"warn\") {\n        console.log(chalk.yellow(\"warning\"), ...args);\n      }\n    },\n    error(...args: any[]) {\n      console.log(chalk.red(\"error\"), ...args);\n    },\n  };\n}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export * from \"./filter-object-undefined\";\nexport * from \"./get-dirname\";\nexport * from \"./get-error-message\";\nexport * from \"./get-relative-path\";\nexport * from \"./inspect-value\";\nexport * from \"./json\";\nexport * from \"./logger\";\nexport * from \"./pack\";\nexport * from \"./unpack\";\nexport * from \"./yaml\";", "export * from \"./unpack\";\nexport * from \"./yaml\";\n"]}
{"filename": "src/utils/json.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport stripJsonComments from \"strip-json-comments\";\nimport { getErrorMessage } from \"./get-error-message\";\n\n/**\n * @TODO pass in zod schema and validate\n */\nexport function readTypedJsonSync<T>(filePath: string) {\n  try {\n    const rawContent = fs.readFileSync(filePath, \"utf-8\");\n    const data = JSON.parse(stripJsonComments(rawContent)) as T;\n    return data;", "  try {\n    const rawContent = fs.readFileSync(filePath, \"utf-8\");\n    const data = JSON.parse(stripJsonComments(rawContent)) as T;\n    return data;\n  } catch (err) {\n    throw new Error(\n      `Failed to read JSON from ${filePath}: ${getErrorMessage(err)}`\n    );\n  }\n}\n", "export async function readTypedJson<T>(filePath: string) {\n  try {\n    const rawContent = await fs.readFile(filePath, \"utf-8\");\n    const data = JSON.parse(rawContent) as T;\n    return data;\n  } catch (err) {\n    throw new Error(\n      `Failed to read JSON from ${filePath}: ${getErrorMessage(err)}`\n    );\n  }\n}\n"]}
{"filename": "src/utils/filter-object-undefined.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\nimport { filterObjectUndefined } from \"./filter-object-undefined\";\n\ndescribe(\"filterObjectUndefined\", () => {\n  it(\"should filter out undefined values\", () => {\n    expect(\n      filterObjectUndefined({\n        a: \"a\",\n        b: undefined,\n        c: \"c\",", "        b: undefined,\n        c: \"c\",\n      })\n    ).toEqual({\n      a: \"a\",\n      c: \"c\",\n    });\n  });\n});\n", "});\n"]}
{"filename": "src/utils/get-dirname.ts", "chunked_list": ["import { fileURLToPath } from \"url\";\n\n/**\n * Calling context should pass in import.meta.url and the function will return\n * the equivalent of __dirname in Node/CommonJs.\n */\nexport function getDirname(importMetaUrl: string) {\n  return fileURLToPath(new URL(\".\", importMetaUrl));\n}\n"]}
{"filename": "src/utils/unpack.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport tar from \"tar-fs\";\nimport { createGunzip } from \"zlib\";\n\nexport async function unpack(filePath: string, unpackDir: string) {\n  await new Promise<void>((resolve, reject) => {\n    fs.createReadStream(filePath)\n      .pipe(createGunzip())\n      .pipe(tar.extract(unpackDir))\n      .on(\"finish\", () => resolve())\n      .on(\"error\", (err) => reject(err));\n  });\n}\n"]}
{"filename": "src/utils/get-relative-path.ts", "chunked_list": ["export function getRootRelativePath(path: string, rootPath: string) {\n  const strippedPath = path.replace(rootPath, \"\");\n\n  return strippedPath.startsWith(\"/\")\n    ? `(root)${strippedPath}`\n    : `(root)/${strippedPath}`;\n}\n\nexport function getIsolateRelativePath(path: string, isolatePath: string) {\n  const strippedPath = path.replace(isolatePath, \"\");\n\n  return strippedPath.startsWith(\"/\")\n    ? `(isolate)${strippedPath}`\n    : `(isolate)/${strippedPath}`;\n}\n", "export function getIsolateRelativePath(path: string, isolatePath: string) {\n  const strippedPath = path.replace(isolatePath, \"\");\n\n  return strippedPath.startsWith(\"/\")\n    ? `(isolate)${strippedPath}`\n    : `(isolate)/${strippedPath}`;\n}\n"]}
{"filename": "src/utils/filter-object-undefined.ts", "chunked_list": ["export function filterObjectUndefined(object: Record<string, unknown>) {\n  return Object.fromEntries(\n    Object.entries(object).filter(([_, value]) => value !== undefined)\n  );\n}\n"]}
{"filename": "src/helpers/config.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport { isEmpty } from \"lodash-es\";\nimport path from \"node:path\";\nimport { createLogger, inspectValue, readTypedJsonSync } from \"~/utils\";\n\nexport type IsolateConfigResolved = {\n  buildDirName?: string;\n  includeDevDependencies: boolean;\n  isolateDirName: string;\n  logLevel: \"info\" | \"debug\" | \"warn\" | \"error\";\n  targetPackagePath?: string;\n  tsconfigPath: string;\n  workspacePackages?: string[];\n  workspaceRoot: string;\n  excludeLockfile: boolean;\n  avoidPnpmPack: boolean;\n};\n", "export type IsolateConfig = Partial<IsolateConfigResolved>;\n\nconst configDefaults: IsolateConfigResolved = {\n  buildDirName: undefined,\n  includeDevDependencies: false,\n  isolateDirName: \"isolate\",\n  logLevel: \"info\",\n  targetPackagePath: undefined,\n  tsconfigPath: \"./tsconfig.json\",\n  workspacePackages: undefined,\n  workspaceRoot: \"../..\",\n  excludeLockfile: false,\n  avoidPnpmPack: false,\n};\n\n/**\n * Only initialize the configuration once, and keeping it here for subsequent\n * calls to getConfig.\n */\nlet __config: IsolateConfigResolved | undefined;\n\nconst validConfigKeys = Object.keys(configDefaults);\n\nconst CONFIG_FILE_NAME = \"isolate.config.json\";\n", "type LogLevel = IsolateConfigResolved[\"logLevel\"];\n\nexport function getConfig(): IsolateConfigResolved {\n  if (__config) {\n    return __config;\n  }\n\n  /**\n   * Since the logLevel is set via config we can't use it to determine if we\n   * should output verbose logging as part of the config loading process. Using\n   * the env var ISOLATE_CONFIG_LOG_LEVEL you have the option to log debug\n   * output.\n   */\n  const log = createLogger(\n    (process.env.ISOLATE_CONFIG_LOG_LEVEL as LogLevel) ?? \"warn\"\n  );\n\n  const configFilePath = path.join(process.cwd(), CONFIG_FILE_NAME);\n\n  log.debug(`Attempting to load config from ${configFilePath}`);\n\n  const configFromFile = fs.existsSync(configFilePath)\n    ? readTypedJsonSync<IsolateConfig>(configFilePath)\n    : {};\n\n  const foreignKeys = Object.keys(configFromFile).filter(\n    (key) => !validConfigKeys.includes(key)\n  );\n", "  if (!isEmpty(foreignKeys)) {\n    log.warn(`Found invalid config settings:`, foreignKeys.join(\", \"));\n  }\n\n  const config = Object.assign(\n    {},\n    configDefaults,\n    configFromFile\n  ) satisfies IsolateConfigResolved;\n\n  log.debug(\"Using configuration:\", inspectValue(config));\n\n  __config = config;\n  return config;\n}\n"]}
{"filename": "src/helpers/adapt-manifest-workspace-deps.ts", "chunked_list": ["import { omit } from \"lodash-es\";\nimport { filterObjectUndefined } from \"~/utils\";\nimport { PackageManifest, PackagesRegistry, patchWorkspaceEntries } from \".\";\n\nexport function adaptManifestWorkspaceDeps(\n  {\n    manifest,\n    packagesRegistry,\n    parentRootRelativeDir,\n  }: {\n    manifest: PackageManifest;\n    packagesRegistry: PackagesRegistry;\n    parentRootRelativeDir?: string;\n  },\n  opts: { includeDevDependencies?: boolean } = {}\n): PackageManifest {\n  return Object.assign(\n    omit(manifest, [\"devDependencies\"]),\n    filterObjectUndefined({\n      dependencies: manifest.dependencies\n        ? patchWorkspaceEntries(\n            manifest.dependencies,\n            packagesRegistry,\n            parentRootRelativeDir\n          )\n        : undefined,\n      devDependencies:\n        opts.includeDevDependencies && manifest.devDependencies\n          ? patchWorkspaceEntries(\n              manifest.devDependencies,\n              packagesRegistry,\n              parentRootRelativeDir\n            )\n          : undefined,\n    })\n  );\n}\n"]}
{"filename": "src/helpers/unpack-dependencies.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport path, { join } from \"node:path\";\nimport { getIsolateRelativePath } from \"~/utils\";\nimport { createLogger } from \"~/utils/logger\";\nimport { PackagesRegistry, getConfig } from \".\";\nimport { unpack } from \"../utils/unpack\";\n\nexport async function unpackDependencies(\n  packedFilesByName: Record<string, string>,\n  packagesRegistry: PackagesRegistry,\n  tmpDir: string,\n  isolateDir: string\n) {\n  const log = createLogger(getConfig().logLevel);\n\n  await Promise.all(\n    Object.entries(packedFilesByName).map(async ([packageName, filePath]) => {\n      const dir = packagesRegistry[packageName].rootRelativeDir;\n      const unpackDir = join(tmpDir, dir);\n\n      log.debug(\"Unpacking\", `(temp)/${path.basename(filePath)}`);\n\n      await unpack(filePath, unpackDir);\n\n      const destinationDir = join(isolateDir, dir);\n\n      await fs.ensureDir(destinationDir);\n\n      await fs.move(join(unpackDir, \"package\"), destinationDir, {\n        overwrite: true,\n      });\n\n      log.debug(\n        `Moved package files to ${getIsolateRelativePath(\n          destinationDir,\n          isolateDir\n        )}`\n      );\n    })\n  );\n}\n"]}
{"filename": "src/helpers/detect-package-manager.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport assert from \"node:assert\";\nimport { execSync } from \"node:child_process\";\nimport path from \"node:path\";\nimport { createLogger, readTypedJsonSync } from \"~/utils\";\nimport { getConfig } from \"./config\";\nimport { PackageManifest } from \"./create-packages-registry\";\nimport { getLockfileFileName } from \"./process-lockfile\";\n\nconst supportedPackageManagerNames = [\"pnpm\", \"yarn\", \"npm\"] as const;", "\nconst supportedPackageManagerNames = [\"pnpm\", \"yarn\", \"npm\"] as const;\n\nexport type PackageManagerName = (typeof supportedPackageManagerNames)[number];\n\nexport type PackageManager = {\n  name: PackageManagerName;\n  version: string;\n};\n\nlet packageManager: PackageManager | undefined;\n\n/**\n * First we check if the package manager is declared in the manifest. If it is,\n * we get the name and version from there. Otherwise we'll search for the\n * different lockfiles and ask the OS to report the installed version.\n */", "export function detectPackageManager(workspaceRoot: string): PackageManager {\n  /**\n   * Disable infer from manifest for now. I doubt it is useful after all but\n   * I'll keep the code as a reminder.\n   */\n  // packageManager =\n  //   inferFromManifest(workspaceRoot) ?? inferFromFiles(workspaceRoot);\n\n  packageManager = inferFromFiles(workspaceRoot);\n  return packageManager;\n}\n", "function inferFromManifest(workspaceRoot: string) {\n  const log = createLogger(getConfig().logLevel);\n\n  const rootManifest = readTypedJsonSync<PackageManifest>(\n    path.join(workspaceRoot, \"package.json\")\n  );\n\n  if (!rootManifest.packageManager) {\n    log.debug(\"No packageManager field found in root manifest\");\n    return;\n  }\n\n  const [name, version = \"*\"] = rootManifest.packageManager.split(\"@\") as [\n    PackageManagerName,\n    string,\n  ];\n\n  assert(\n    supportedPackageManagerNames.includes(name),\n    `Package manager \"${name}\" is not currently supported`\n  );\n\n  const lockfileName = getLockfileFileName(name);\n\n  assert(\n    fs.existsSync(path.join(workspaceRoot, lockfileName)),\n    `Manifest declares ${name} to be the packageManager, but failed to find ${lockfileName} in workspace root`\n  );\n\n  return { name, version };\n}\n", "function inferFromFiles(workspaceRoot: string): PackageManager {\n  for (const name of supportedPackageManagerNames) {\n    const lockfileName = getLockfileFileName(name);\n\n    if (fs.existsSync(path.join(workspaceRoot, lockfileName))) {\n      return { name, version: getVersion(name) };\n    }\n  }\n\n  /**\n   * If no lockfile was found, it could be that there is an npm shrinkwrap file.\n   */", "  if (fs.existsSync(path.join(workspaceRoot, \"npm-shrinkwrap.json\"))) {\n    return { name: \"npm\", version: getVersion(\"npm\") };\n  }\n\n  throw new Error(`Failed to detect package manager`);\n}\n\nfunction getVersion(packageManagerName: PackageManagerName): string {\n  const buffer = execSync(`${packageManagerName} --version`);\n  return buffer.toString().trim();\n}\n", "export function usePackageManager() {\n  if (!packageManager) {\n    throw Error(\n      \"No package manager detected. Make sure to call detectPackageManager() before usePackageManager()\"\n    );\n  }\n\n  return packageManager;\n}\n"]}
{"filename": "src/helpers/patch-workspace-entries.ts", "chunked_list": ["import path from \"node:path\";\nimport { createLogger } from \"~/utils\";\nimport { getConfig } from \"./config\";\nimport { PackagesRegistry } from \"./create-packages-registry\";\n\nexport function patchWorkspaceEntries(\n  dependencies: Record<string, string>,\n  packagesRegistry: PackagesRegistry,\n  parentRootRelativeDir?: string\n) {\n  const log = createLogger(getConfig().logLevel);\n  const allWorkspacePackageNames = Object.keys(packagesRegistry);\n\n  return Object.fromEntries(\n    Object.entries(dependencies).map(([key, value]) => {", "      if (allWorkspacePackageNames.includes(key)) {\n        const def = packagesRegistry[key];\n\n        /**\n         * When nested shared dependencies are used (local deps linking to other\n         * local deps), the parentRootRelativeDir will be passed in, and we\n         * store the relative path to the isolate/packages directory, as is\n         * required by some package managers.\n         *\n         * For consistency we also write the other file paths starting with\n         * ./, but it doesn't seem to be necessary for any package manager.\n         */\n        const relativePath = parentRootRelativeDir\n          ? path.relative(parentRootRelativeDir, `./${def.rootRelativeDir}`)\n          : `./${def.rootRelativeDir}`;\n\n        const linkPath = `file:${relativePath}`;\n\n        log.debug(`Linking dependency ${key} to ${linkPath}`);\n\n        return [key, linkPath];\n      } else {\n        return [key, value];\n      }\n    })\n  );\n}\n"]}
{"filename": "src/helpers/adapt-target-package-manifest.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport path from \"node:path\";\nimport {\n  PackageManifest,\n  PackagesRegistry,\n  adaptManifestWorkspaceDeps,\n  getConfig,\n} from \"~/helpers\";\n\nexport async function adaptTargetPackageManifest(\n  manifest: PackageManifest,\n  packagesRegistry: PackagesRegistry,\n  isolateDir: string\n) {\n  const outputManifest = adaptManifestWorkspaceDeps(\n    {\n      manifest,\n      packagesRegistry,\n    },\n    { includeDevDependencies: getConfig().includeDevDependencies }\n  );\n\n  await fs.writeFile(\n    path.join(isolateDir, \"package.json\"),\n    JSON.stringify(outputManifest, null, 2)\n  );\n}\n", "\nexport async function adaptTargetPackageManifest(\n  manifest: PackageManifest,\n  packagesRegistry: PackagesRegistry,\n  isolateDir: string\n) {\n  const outputManifest = adaptManifestWorkspaceDeps(\n    {\n      manifest,\n      packagesRegistry,\n    },\n    { includeDevDependencies: getConfig().includeDevDependencies }\n  );\n\n  await fs.writeFile(\n    path.join(isolateDir, \"package.json\"),\n    JSON.stringify(outputManifest, null, 2)\n  );\n}\n"]}
{"filename": "src/helpers/process-lockfile.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport assert from \"node:assert\";\nimport path from \"node:path\";\nimport { createLogger, readTypedYamlSync, writeTypedYamlSync } from \"~/utils\";\nimport { getConfig } from \"./config\";\nimport { PackagesRegistry } from \"./create-packages-registry\";\nimport {\n  PackageManagerName,\n  usePackageManager,\n} from \"./detect-package-manager\";", "  usePackageManager,\n} from \"./detect-package-manager\";\n\ntype PackagePath = string;\n\ntype PnpmLockfile = {\n  lockfileVersion: string;\n  importers: Record<\n    PackagePath,\n    {\n      dependencies?: Record<string, unknown>;\n      devDependencies?: Record<string, unknown>;\n    }\n  >;\n};\n", "export function getLockfileFileName(name: PackageManagerName) {\n  switch (name) {\n    case \"pnpm\":\n      return \"pnpm-lock.yaml\";\n    case \"yarn\":\n      return \"yarn.lock\";\n    case \"npm\":\n      return \"package-lock.json\";\n  }\n}\n\n/**\n * Adapt the lockfile and write it to the isolate directory. Because we keep the\n * structure of packages in the isolate directory the same as they were in the\n * monorepo, the lockfile is largely still correct. The only things that need to\n * be done is to remove the root dependencies and devDependencies, and rename\n * the path to the target package to act as the new root.\n */", "export function processLockfile({\n  workspaceRootDir,\n  targetPackageName,\n  packagesRegistry,\n  isolateDir,\n}: {\n  workspaceRootDir: string;\n  targetPackageName: string;\n  packagesRegistry: PackagesRegistry;\n  isolateDir: string;\n}) {\n  const log = createLogger(getConfig().logLevel);\n\n  const targetPackageRelativeDir =\n    packagesRegistry[targetPackageName].rootRelativeDir;\n\n  const { name } = usePackageManager();\n\n  const fileName = getLockfileFileName(name);\n\n  const lockfileSrcPath = path.join(workspaceRootDir, fileName);\n  const lockfileDstPath = path.join(isolateDir, fileName);\n\n  switch (name) {\n    case \"npm\": {\n      /**\n       * If there is a shrinkwrap file we copy that instead of the lockfile\n       */\n      const shrinkwrapSrcPath = path.join(\n        workspaceRootDir,\n        \"npm-shrinkwrap.json\"\n      );\n      const shrinkwrapDstPath = path.join(isolateDir, \"npm-shrinkwrap.json\");\n", "      if (fs.existsSync(shrinkwrapSrcPath)) {\n        fs.copyFileSync(shrinkwrapSrcPath, shrinkwrapDstPath);\n        log.debug(\"Copied shrinkwrap to\", shrinkwrapDstPath);\n      } else {\n        fs.copyFileSync(lockfileSrcPath, lockfileDstPath);\n        log.debug(\"Copied lockfile to\", lockfileDstPath);\n      }\n\n      return;\n    }\n    case \"yarn\": {\n      fs.copyFileSync(lockfileSrcPath, lockfileDstPath);\n      log.debug(\"Copied lockfile to\", lockfileDstPath);\n      return;\n    }\n    case \"pnpm\": {\n      const origLockfile = readTypedYamlSync<PnpmLockfile>(lockfileSrcPath);\n\n      log.debug(\"Read PNPM lockfile, version:\", origLockfile.lockfileVersion);\n\n      const adaptedLockfile = structuredClone(origLockfile);\n\n      const targetPackageDef =\n        adaptedLockfile.importers[targetPackageRelativeDir];\n\n      assert(\n        targetPackageDef,\n        `Failed to find target package in lockfile at importers[${targetPackageRelativeDir}]`\n      );\n      /**\n       * Overwrite the root importer with the target package importer contents\n       */\n      adaptedLockfile.importers[\".\"] = targetPackageDef;\n\n      /**\n       * Delete the target package original importer. Not really necessary.\n       */\n      delete adaptedLockfile.importers[targetPackageRelativeDir];\n\n      writeTypedYamlSync(lockfileDstPath, adaptedLockfile);\n\n      log.debug(\"Stored adapted lockfile at\", lockfileDstPath);\n\n      return;\n    }\n  }\n}\n"]}
{"filename": "src/helpers/process-build-output-files.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport path from \"node:path\";\nimport { createLogger, pack, unpack } from \"~/utils\";\nimport { getConfig } from \"./config\";\n\nconst TIMEOUT_MS = 5000;\n\nexport async function processBuildOutputFiles({\n  targetPackageDir,\n  tmpDir,\n  isolateDir,\n}: {\n  targetPackageDir: string;\n  tmpDir: string;\n  isolateDir: string;\n}) {\n  const log = createLogger(getConfig().logLevel);\n  const packedFilePath = await pack(targetPackageDir, tmpDir);\n  const unpackDir = path.join(tmpDir, \"target\");\n\n  const now = Date.now();\n  let isWaitingYet = false;\n", "  while (!fs.existsSync(packedFilePath) && Date.now() - now < TIMEOUT_MS) {\n    if (!isWaitingYet) {\n      log.debug(`Waiting for ${packedFilePath} to become available...`);\n    }\n    isWaitingYet = true;\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  }\n\n  await unpack(packedFilePath, unpackDir);\n  await fs.copy(path.join(unpackDir, \"package\"), isolateDir);\n}\n"]}
{"filename": "src/helpers/get-build-output-dir.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport path from \"node:path\";\nimport outdent from \"outdent\";\nimport { getConfig } from \"~/helpers\";\nimport { createLogger, readTypedJson } from \"~/utils\";\n\nexport async function getBuildOutputDir(targetPackageDir: string) {\n  const config = getConfig();\n  const log = createLogger(getConfig().logLevel);\n\n  if (config.buildDirName) {\n    log.debug(\"Using buildDirName from config:\", config.buildDirName);\n    return path.join(targetPackageDir, config.buildDirName);\n  }\n\n  const tsconfigPath = path.join(targetPackageDir, config.tsconfigPath);\n", "  if (config.buildDirName) {\n    log.debug(\"Using buildDirName from config:\", config.buildDirName);\n    return path.join(targetPackageDir, config.buildDirName);\n  }\n\n  const tsconfigPath = path.join(targetPackageDir, config.tsconfigPath);\n\n  if (fs.existsSync(tsconfigPath)) {\n    log.debug(\"Found tsconfig at:\", config.tsconfigPath);\n\n    const tsconfig = await readTypedJson<{\n      compilerOptions?: { outDir?: string };\n    }>(tsconfigPath);\n\n    const outDir = tsconfig.compilerOptions?.outDir;\n", "    if (outDir) {\n      return path.join(targetPackageDir, outDir);\n    } else {\n      throw new Error(outdent`\n        Failed to find outDir in tsconfig. If you are executing isolate from the root of a monorepo you should specify the buildDirName in isolate.config.json.\n      `);\n    }\n  } else {\n    log.warn(\"Failed to find tsconfig at:\", tsconfigPath);\n\n    throw new Error(outdent`\n      Failed to infer the build output directory from either the isolate config buildDirName or a Typescript config file. See the documentation on how to configure one of these options.\n    `);\n  }\n}\n"]}
{"filename": "src/helpers/find-packages-globs.ts", "chunked_list": ["import assert from \"node:assert\";\nimport path from \"node:path\";\nimport {\n  createLogger,\n  inspectValue,\n  readTypedJsonSync,\n  readTypedYamlSync,\n} from \"~/utils\";\nimport { getConfig } from \"./config\";\nimport { usePackageManager } from \"./detect-package-manager\";", "import { getConfig } from \"./config\";\nimport { usePackageManager } from \"./detect-package-manager\";\n\n/**\n * Find the globs that define where the packages are located within the\n * monorepo. This configuration is dependent on the package manager used, and I\n * don't know if we're covering all cases yet...\n */\nexport function findPackagesGlobs(workspaceRootDir: string) {\n  const log = createLogger(getConfig().logLevel);\n\n  const packageManager = usePackageManager();\n\n  switch (packageManager.name) {\n    case \"pnpm\": {\n      const { packages: globs } = readTypedYamlSync<{ packages: string[] }>(\n        path.join(workspaceRootDir, \"pnpm-workspace.yaml\")\n      );\n\n      log.debug(\"Detected pnpm packages globs:\", inspectValue(globs));\n      return globs;\n    }\n    case \"yarn\":\n    case \"npm\": {\n      const workspaceRootManifestPath = path.join(\n        workspaceRootDir,\n        \"package.json\"\n      );\n\n      const { workspaces } = readTypedJsonSync<{ workspaces: string[] }>(\n        workspaceRootManifestPath\n      );\n", "export function findPackagesGlobs(workspaceRootDir: string) {\n  const log = createLogger(getConfig().logLevel);\n\n  const packageManager = usePackageManager();\n\n  switch (packageManager.name) {\n    case \"pnpm\": {\n      const { packages: globs } = readTypedYamlSync<{ packages: string[] }>(\n        path.join(workspaceRootDir, \"pnpm-workspace.yaml\")\n      );\n\n      log.debug(\"Detected pnpm packages globs:\", inspectValue(globs));\n      return globs;\n    }\n    case \"yarn\":\n    case \"npm\": {\n      const workspaceRootManifestPath = path.join(\n        workspaceRootDir,\n        \"package.json\"\n      );\n\n      const { workspaces } = readTypedJsonSync<{ workspaces: string[] }>(\n        workspaceRootManifestPath\n      );\n", "      if (!workspaces) {\n        throw new Error(\n          `No workspaces field found in ${workspaceRootManifestPath}`\n        );\n      }\n\n      if (Array.isArray(workspaces)) {\n        return workspaces;\n      } else {\n        /**\n         * For Yarn, workspaces could be defined as an object with { packages: [],\n         * nohoist: [] }. See https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\n         */\n        const workspacesObject = workspaces as { packages?: string[] };\n\n        assert(\n          workspacesObject.packages,\n          \"workspaces.packages must be an array\"\n        );\n\n        return workspacesObject.packages;\n      }\n    }\n  }\n}\n"]}
{"filename": "src/helpers/list-local-dependencies.ts", "chunked_list": ["import { PackageManifest, PackagesRegistry } from \"./create-packages-registry\";\n\n/**\n * Recursively list the packages from dependencies (and optionally\n * devDependencies) that are found in the workspace.\n *\n * Here we do not need to rely on packages being declared as \"workspace:\" in the\n * manifest. We can simply compare the package names with the list of packages\n * that were found via the workspace glob patterns and added to the registry.\n */\nexport function listLocalDependencies(\n  manifest: PackageManifest,\n  packagesRegistry: PackagesRegistry,\n  { includeDevDependencies = false } = {}\n): string[] {\n  const allWorkspacePackageNames = Object.keys(packagesRegistry);\n\n  const localDependencyPackageNames = (\n    includeDevDependencies\n      ? [\n          ...Object.keys(manifest.dependencies ?? {}),\n          ...Object.keys(manifest.devDependencies ?? {}),\n        ]\n      : Object.keys(manifest.dependencies ?? {})\n  ).filter((name) => allWorkspacePackageNames.includes(name));\n\n  const nestedLocalDependencies = localDependencyPackageNames.flatMap(\n    (packageName) =>\n      listLocalDependencies(\n        packagesRegistry[packageName].manifest,\n        packagesRegistry,\n        { includeDevDependencies }\n      )\n  );\n\n  return localDependencyPackageNames.concat(nestedLocalDependencies);\n}\n", " * that were found via the workspace glob patterns and added to the registry.\n */\nexport function listLocalDependencies(\n  manifest: PackageManifest,\n  packagesRegistry: PackagesRegistry,\n  { includeDevDependencies = false } = {}\n): string[] {\n  const allWorkspacePackageNames = Object.keys(packagesRegistry);\n\n  const localDependencyPackageNames = (\n    includeDevDependencies\n      ? [\n          ...Object.keys(manifest.dependencies ?? {}),\n          ...Object.keys(manifest.devDependencies ?? {}),\n        ]\n      : Object.keys(manifest.dependencies ?? {})\n  ).filter((name) => allWorkspacePackageNames.includes(name));\n\n  const nestedLocalDependencies = localDependencyPackageNames.flatMap(\n    (packageName) =>\n      listLocalDependencies(\n        packagesRegistry[packageName].manifest,\n        packagesRegistry,\n        { includeDevDependencies }\n      )\n  );\n\n  return localDependencyPackageNames.concat(nestedLocalDependencies);\n}\n"]}
{"filename": "src/helpers/manifest.ts", "chunked_list": ["import path from \"node:path\";\nimport { readTypedJson } from \"~/utils\";\nimport { PackageManifest } from \"./create-packages-registry\";\n\nexport async function importManifest(packageDir: string) {\n  return readTypedJson<PackageManifest>(path.join(packageDir, \"package.json\"));\n}\n"]}
{"filename": "src/helpers/adapt-manifest-files.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport path from \"node:path\";\nimport {\n  PackagesRegistry,\n  adaptManifestWorkspaceDeps,\n  getConfig,\n} from \"~/helpers\";\nimport { createLogger } from \"~/utils\";\n\nexport async function adaptManifestFiles(\n  localDependencies: string[],\n  packagesRegistry: PackagesRegistry,\n  isolateDir: string\n) {\n  await Promise.all(\n    localDependencies.map(async (packageName) => {\n      const { manifest, rootRelativeDir } = packagesRegistry[packageName];\n\n      const outputManifest = adaptManifestWorkspaceDeps(\n        { manifest, packagesRegistry, parentRootRelativeDir: rootRelativeDir },\n        { includeDevDependencies: getConfig().includeDevDependencies }\n      );\n\n      await fs.writeFile(\n        path.join(isolateDir, rootRelativeDir, \"package.json\"),\n        JSON.stringify(outputManifest, null, 2)\n      );\n    })\n  );\n}\n", "\nexport async function adaptManifestFiles(\n  localDependencies: string[],\n  packagesRegistry: PackagesRegistry,\n  isolateDir: string\n) {\n  await Promise.all(\n    localDependencies.map(async (packageName) => {\n      const { manifest, rootRelativeDir } = packagesRegistry[packageName];\n\n      const outputManifest = adaptManifestWorkspaceDeps(\n        { manifest, packagesRegistry, parentRootRelativeDir: rootRelativeDir },\n        { includeDevDependencies: getConfig().includeDevDependencies }\n      );\n\n      await fs.writeFile(\n        path.join(isolateDir, rootRelativeDir, \"package.json\"),\n        JSON.stringify(outputManifest, null, 2)\n      );\n    })\n  );\n}\n"]}
{"filename": "src/helpers/index.ts", "chunked_list": ["export * from \"./adapt-manifest-files\";\nexport * from \"./adapt-manifest-workspace-deps\";\nexport * from \"./adapt-target-package-manifest\";\nexport * from \"./config\";\nexport * from \"./create-packages-registry\";\nexport * from \"./detect-package-manager\";\nexport * from \"./find-packages-globs\";\nexport * from \"./get-build-output-dir\";\nexport * from \"./list-local-dependencies\";\nexport * from \"./manifest\";", "export * from \"./list-local-dependencies\";\nexport * from \"./manifest\";\nexport * from \"./pack-dependencies\";\nexport * from \"./patch-workspace-entries\";\nexport * from \"./process-build-output-files\";\nexport * from \"./process-lockfile\";\nexport * from \"./unpack-dependencies\";\n"]}
{"filename": "src/helpers/create-packages-registry.ts", "chunked_list": ["import fs from \"fs-extra\";\nimport { globSync } from \"glob\";\nimport path from \"node:path\";\nimport { createLogger, readTypedJson } from \"~/utils\";\nimport { getConfig } from \"./config\";\nimport { findPackagesGlobs } from \"./find-packages-globs\";\n\nexport type PackageManifest = {\n  name: string;\n  packageManager?: string;\n  dependencies?: Record<string, string>;\n  devDependencies?: Record<string, string>;\n  main: string;\n  module?: string;\n  exports?: Record<string, { require: string; import: string }>;\n  files: string[];\n  version?: string;\n  typings?: string;\n  scripts?: Record<string, string>;\n};\n", "export type WorkspacePackageInfo = {\n  absoluteDir: string;\n  /**\n   * The path of the package relative to the workspace root. This is the path\n   * referenced in the lock file.\n   */\n  rootRelativeDir: string;\n  /**\n   * The package.json file contents\n   */\n  manifest: PackageManifest;\n};\n", "export type PackagesRegistry = Record<string, WorkspacePackageInfo>;\n\n/**\n * Build a list of all packages in the workspace, depending on the package\n * manager used, with a possible override from the config file. The list contains\n * the manifest with some directory info mapped by module name.\n */\nexport async function createPackagesRegistry(\n  workspaceRootDir: string,\n  workspacePackagesOverride: string[] | undefined\n): Promise<PackagesRegistry> {\n  const log = createLogger(getConfig().logLevel);\n", "  if (workspacePackagesOverride) {\n    log.debug(\n      `Override workspace packages via config: ${workspacePackagesOverride}`\n    );\n  }\n\n  const packagesGlobs =\n    workspacePackagesOverride ?? findPackagesGlobs(workspaceRootDir);\n\n  const cwd = process.cwd();\n  process.chdir(workspaceRootDir);\n\n  const allPackages = packagesGlobs\n    .flatMap((glob) => globSync(glob))\n    /**\n     * Make sure to filter any loose files that might hang around.\n     */\n    .filter((dir) => fs.lstatSync(dir).isDirectory());\n\n  const registry: PackagesRegistry = (\n    await Promise.all(\n      allPackages.map(async (rootRelativeDir) => {\n        const manifestPath = path.join(rootRelativeDir, \"package.json\");\n", "        if (!fs.existsSync(manifestPath)) {\n          log.warn(\n            `Ignoring directory ./${rootRelativeDir} because it does not contain a package.json file`\n          );\n          return;\n        } else {\n          log.debug(`Registering package ./${rootRelativeDir}`);\n\n          const manifest = await readTypedJson<PackageManifest>(\n            path.join(rootRelativeDir, \"package.json\")\n          );\n\n          return {\n            manifest,\n            rootRelativeDir,\n            absoluteDir: path.join(workspaceRootDir, rootRelativeDir),\n          };\n        }\n      })\n    )\n  ).reduce<PackagesRegistry>((acc, info) => {", "    if (info) {\n      acc[info.manifest.name] = info;\n    }\n    return acc;\n  }, {});\n\n  process.chdir(cwd);\n\n  return registry;\n}\n"]}
{"filename": "src/helpers/pack-dependencies.ts", "chunked_list": ["import assert from \"node:assert\";\nimport { createLogger, pack } from \"~/utils\";\nimport { getConfig } from \"./config\";\nimport { PackagesRegistry } from \"./create-packages-registry\";\nimport { usePackageManager } from \"./detect-package-manager\";\n\n/**\n * Pack dependencies so that we extract only the files that are supposed to be\n * published by the packages.\n *", " * published by the packages.\n *\n * @returns A map of package names to the path of the packed file\n */\nexport async function packDependencies({\n  /**\n   * All packages found in the monorepo by workspaces declaration\n   */\n  packagesRegistry,\n  /**\n   * The package names that appear to be local dependencies\n   */\n  localDependencies,\n  /**\n   * The directory where the isolated package and all its dependencies will end\n   * up. This is also the directory from where the package will be deployed. By\n   * default it is a subfolder in targetPackageDir called \"isolate\" but you can\n   * configure it.\n   */\n  packDestinationDir,\n}: {\n  packagesRegistry: PackagesRegistry;\n  localDependencies: string[];\n  packDestinationDir: string;\n}) {\n  const config = getConfig();\n  const log = createLogger(config.logLevel);\n\n  const packedFileByName: Record<string, string> = {};\n\n  const { name, version } = usePackageManager();\n\n  const versionMajor = parseInt(version.split(\".\")[0], 10);\n\n  const usePnpmPack =\n    !config.avoidPnpmPack && name === \"pnpm\" && versionMajor >= 8;\n", "  if (usePnpmPack) {\n    log.debug(\"Using PNPM pack instead of NPM pack\");\n  }\n\n  for (const dependency of localDependencies) {\n    const def = packagesRegistry[dependency];\n\n    assert(dependency, `Failed to find package definition for ${dependency}`);\n\n    const { name } = def.manifest;\n\n    /**\n     * If this dependency has already been packed, we skip it. It could happen\n     * because we are packing workspace dependencies recursively.\n     */", "    if (packedFileByName[name]) {\n      log.debug(`Skipping ${name} because it has already been packed`);\n      continue;\n    }\n\n    packedFileByName[name] = await pack(\n      def.absoluteDir,\n      packDestinationDir,\n      usePnpmPack\n    );\n  }\n\n  return packedFileByName;\n}\n"]}
