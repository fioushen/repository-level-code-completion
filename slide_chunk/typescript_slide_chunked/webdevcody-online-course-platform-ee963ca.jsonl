{"filename": "src/middleware.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n// middleware.ts\nimport { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\n\nexport default async function middleware(req: NextRequest) {\n  const url = req.nextUrl.clone();\n\n  const {\n    data: { auth },\n  } = await fetch(`${url.origin}/api/authSSR`, {\n    headers: req.headers,\n  }).then((res) => res.json());\n\n  url.search = new URLSearchParams(`callbackUrl=${url}`).toString();\n  url.pathname = `/api/auth/signin`;\n\n  return !auth ? NextResponse.redirect(url) : NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\"/dashboard\", \"/dashboard/courses\"],\n};\n"]}
{"filename": "src/pages/api/authSSR.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from \"next\";\nimport { getSession } from \"next-auth/react\";\n\nexport default async function handle(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const session = await getSession({ req });\n  res.json({ data: { auth: !!session } });\n}\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\nimport { env } from \"~/env.mjs\";\nimport { createTRPCContext } from \"~/server/api/trpc\";\nimport { appRouter } from \"~/server/api/root\";\n\n// export API handler\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext: createTRPCContext,", "  router: appRouter,\n  createContext: createTRPCContext,\n  onError:\n    env.NODE_ENV === \"development\"\n      ? ({ path, error }) => {\n          console.error(\n            `\u274c tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n          );\n        }\n      : undefined,", "        }\n      : undefined,\n});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\nimport { authOptions } from \"~/server/auth\";\n\nexport default NextAuth(authOptions);\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n *\n * We also create a few inference helpers for input and output types.\n */\nimport { httpBatchLink, loggerLink } from \"@trpc/client\";\nimport { createTRPCNext } from \"@trpc/next\";\nimport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n", "import { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n\nimport { type AppRouter } from \"~/server/api/root\";\n\nconst getBaseUrl = () => {\n  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n};\n\n/** A set of type-safe react-query hooks for your tRPC API. */\nexport const api = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      /**\n       * Transformer used for data de-serialization from the server.\n       *\n       * @see https://trpc.io/docs/data-transformers\n       */\n      transformer: superjson,\n\n      /**\n       * Links used to determine request flow from client to server.\n       *\n       * @see https://trpc.io/docs/links\n       */\n      links: [\n        loggerLink({\n          enabled: (opts) =>\n            process.env.NODE_ENV === \"development\" ||\n            (opts.direction === \"down\" && opts.result instanceof Error),\n        }),\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n    };\n  },\n  /**\n   * Whether tRPC should await queries when server rendering pages.\n   *\n   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n   */\n  ssr: false,\n});\n\n/**\n * Inference helper for inputs.\n *", " * @example type HelloInput = RouterInputs['example']['hello']\n */\nexport type RouterInputs = inferRouterInputs<AppRouter>;\n\n/**\n * Inference helper for outputs.\n *\n * @example type HelloOutput = RouterOutputs['example']['hello']\n */\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n", "export type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/utils/getImageUrl.ts", "chunked_list": ["import { env } from \"~/env.mjs\";\n\nexport function getImageUrl(id: string) {\n  return `http://localhost:9000/${env.NEXT_PUBLIC_S3_BUCKET_NAME}/${id}`;\n}\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\nimport {\n  getServerSession,\n  type NextAuthOptions,\n  type DefaultSession,\n} from \"next-auth\";\nimport GoogleProvider from \"next-auth/providers/google\";\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\nimport { env } from \"~/env.mjs\";\nimport { prisma } from \"~/server/db\";\n\n/**\n * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`", " * object and keep type safety.\n *\n * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n */\ndeclare module \"next-auth\" {\n  interface Session extends DefaultSession {\n    user: {\n      id: string;\n      // ...other properties\n      // role: UserRole;\n    } & DefaultSession[\"user\"];\n  }\n", "  // interface User {\n  //   // ...other properties\n  //   // role: UserRole;\n  // }\n}\n\n/**\n * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n *\n * @see https://next-auth.js.org/configuration/options\n */\nexport const authOptions: NextAuthOptions = {\n  callbacks: {\n    session: ({ session, user }) => ({\n      ...session,\n      user: {\n        ...session.user,\n        id: user.id,\n      },\n    }),\n  },\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    GoogleProvider({\n      clientId: env.GOOGLE_CLIENT_ID,\n      clientSecret: env.GOOGLE_CLIENT_SECRET,\n    }),\n    /**\n     * ...add more providers here.\n     *\n     * Most other providers require a bit more work than the Discord provider. For example, the\n     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account\n     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:\n     *\n     * @see https://next-auth.js.org/providers/github\n     */\n  ],\n};\n\n/**\n * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n *\n * @see https://next-auth.js.org/configuration/nextjs\n */\nexport const getServerAuthSession = (ctx: {\n  req: GetServerSidePropsContext[\"req\"];\n  res: GetServerSidePropsContext[\"res\"];\n}) => {\n  return getServerSession(ctx.req, ctx.res, authOptions);\n};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"~/env.mjs\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??", "export const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n */", "import { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\nimport { type Session } from \"next-auth\";\n\nimport { getServerAuthSession } from \"~/server/auth\";\nimport { prisma } from \"~/server/db\";\n\ntype CreateContextOptions = {\n  session: Session | null;\n};\n\n/**\n * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n * it from here.\n *\n * Examples of things you may need it for:\n * - testing, so we don't have to mock Next.js' req/res\n * - tRPC's `createSSGHelpers`, where we don't have req/res\n *\n * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts\n */\nconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n  return {\n    session: opts.session,\n    prisma,\n  };\n};\n\n/**\n * This is the actual context you will use in your router. It will be used to process every request\n * that goes through your tRPC endpoint.\n *\n * @see https://trpc.io/docs/context\n */\nexport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n  const { req, res } = opts;\n\n  // Get the session from the server using the getServerSession wrapper function\n  const session = await getServerAuthSession({ req, res });\n\n  return createInnerTRPCContext({\n    session,\n  });\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nimport { initTRPC, TRPCError } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure;\n\n/** Reusable middleware that enforces users are logged in before running the procedure. */\nconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {", "  if (!ctx.session || !ctx.session.user) {\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n  }\n  return next({\n    ctx: {\n      // infers the `session` as non-nullable\n      session: { ...ctx.session, user: ctx.session.user },\n    },\n  });\n});\n\n/**\n * Protected (authenticated) procedure\n *\n * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n * the session is valid and guarantees `ctx.session.user` is not null.\n *\n * @see https://trpc.io/docs/procedures\n */\nexport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { createTRPCRouter } from \"~/server/api/trpc\";\nimport { exampleRouter } from \"~/server/api/routers/example\";\nimport { courseRouter } from \"./routers/course\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({", " */\nexport const appRouter = createTRPCRouter({\n  example: exampleRouter,\n  course: courseRouter,\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/example.ts", "chunked_list": ["import { z } from \"zod\";\n\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  protectedProcedure,\n} from \"~/server/api/trpc\";\n\nexport const exampleRouter = createTRPCRouter({\n  hello: publicProcedure", "export const exampleRouter = createTRPCRouter({\n  hello: publicProcedure\n    .input(z.object({ text: z.string() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.text}`,\n      };\n    }),\n\n  getAll: publicProcedure.query(({ ctx }) => {", "\n  getAll: publicProcedure.query(({ ctx }) => {\n    return ctx.prisma.example.findMany();\n  }),\n\n  getSecretMessage: protectedProcedure.query(() => {\n    return \"you can now see this secret message!\";\n  }),\n});\n", "});\n"]}
{"filename": "src/server/api/routers/course.ts", "chunked_list": ["import { z } from \"zod\";\n\nimport { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\nimport { S3Client } from \"@aws-sdk/client-s3\";\nimport { createPresignedPost } from \"@aws-sdk/s3-presigned-post\";\nimport { env } from \"~/env.mjs\";\nimport { TRPCError } from \"@trpc/server\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst UPLOAD_MAX_FILE_SIZE = 1000000;", "\nconst UPLOAD_MAX_FILE_SIZE = 1000000;\n\nconst s3Client = new S3Client({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:9000\",\n  forcePathStyle: true,\n  credentials: {\n    accessKeyId: \"S3RVER\",\n    secretAccessKey: \"S3RVER\",", "    accessKeyId: \"S3RVER\",\n    secretAccessKey: \"S3RVER\",\n  },\n});\n\nexport const courseRouter = createTRPCRouter({\n  getCourseById: protectedProcedure\n    .input(\n      z.object({\n        courseId: z.string(),", "      z.object({\n        courseId: z.string(),\n      })\n    )\n    .query(({ ctx, input }) => {\n      return ctx.prisma.course.findUnique({\n        where: {\n          id: input.courseId,\n        },\n        include: {", "        },\n        include: {\n          sections: true,\n        },\n      });\n    }),\n  getCourses: protectedProcedure.query(({ ctx }) => {\n    return ctx.prisma.course.findMany({\n      where: {\n        userId: ctx.session.user.id,", "      where: {\n        userId: ctx.session.user.id,\n      },\n    });\n  }),\n  createCourse: protectedProcedure\n    .input(z.object({ title: z.string(), description: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      const userId = ctx.session.user.id;\n      const newCourse = await ctx.prisma.course.create({", "      const userId = ctx.session.user.id;\n      const newCourse = await ctx.prisma.course.create({\n        data: {\n          title: input.title,\n          description: input.description,\n          userId: userId,\n        },\n      });\n      return newCourse;\n    }),", "      return newCourse;\n    }),\n  updateCourse: protectedProcedure\n    .input(z.object({ title: z.string(), courseId: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      const userId = ctx.session.user.id;\n      await ctx.prisma.course.updateMany({\n        where: {\n          id: input.courseId,\n          userId,", "          id: input.courseId,\n          userId,\n        },\n        data: {\n          title: input.title,\n        },\n      });\n      return { status: \"updated\" };\n    }),\n  createPresignedUrl: protectedProcedure", "    }),\n  createPresignedUrl: protectedProcedure\n    .input(z.object({ courseId: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      // const userId = ctx.session.user.id;\n      const course = await ctx.prisma.course.findUnique({\n        where: {\n          id: input.courseId,\n        },\n      });", "        },\n      });\n\n      if (!course) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"the course does not exist\",\n        });\n      }\n\n      const imageId = uuidv4();\n      await ctx.prisma.course.update({\n        where: {\n          id: course.id,\n        },\n        data: {\n          imageId,\n        },\n      });\n\n      return createPresignedPost(s3Client, {\n        Bucket: env.NEXT_PUBLIC_S3_BUCKET_NAME,\n        Key: imageId,\n        Fields: {\n          key: imageId,\n        },\n        Conditions: [\n          [\"starts-with\", \"$Content-Type\", \"image/\"],\n          [\"content-length-range\", 0, UPLOAD_MAX_FILE_SIZE],\n        ],\n      });\n    }),\n  createSection: protectedProcedure\n    .input(z.object({ courseId: z.string(), title: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      const videoId = uuidv4();\n      return await ctx.prisma.section.create({\n        data: {\n          videoId,\n          title: input.title,\n          courseId: input.courseId,\n        },\n      });\n    }),\n  deleteSection: protectedProcedure\n    .input(z.object({ sectionId: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      const section = await ctx.prisma.section.delete({\n        where: {\n          id: input.sectionId,\n        },\n      });\n", "      if (!section) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"section not found\",\n        });\n      }\n\n      if (!section.courseId) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"section has no course\",\n        });\n      }\n\n      const course = await ctx.prisma.course.findUnique({\n        where: {\n          id: section.courseId,\n        },\n      });\n", "      if (course?.userId !== ctx.session.user.id) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"you do not have access to this course\",\n        });\n      }\n\n      return section;\n    }),\n  swapSections: protectedProcedure\n    .input(\n      z.object({ sectionIdSource: z.string(), sectionIdTarget: z.string() })\n    )\n    .mutation(async ({ ctx, input }) => {\n      const sectionSource = await ctx.prisma.section.findUnique({\n        where: {\n          id: input.sectionIdSource,\n        },\n      });", "      if (!sectionSource) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"the source section does not exist\",\n        });\n      }\n\n      const sectionTarget = await ctx.prisma.section.findUnique({\n        where: {\n          id: input.sectionIdTarget,\n        },\n      });", "      if (!sectionTarget) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"the target section does not exist\",\n        });\n      }\n\n      await ctx.prisma.section.update({\n        where: {\n          id: input.sectionIdSource,\n        },\n        data: {\n          order: sectionTarget.order,\n        },\n      });\n\n      await ctx.prisma.section.update({\n        where: {\n          id: input.sectionIdTarget,\n        },\n        data: {\n          order: sectionSource.order,\n        },\n      });\n    }),\n  createPresignedUrlForVideo: protectedProcedure\n    .input(z.object({ sectionId: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      const section = await ctx.prisma.section.findUnique({\n        where: {\n          id: input.sectionId,\n        },\n      });\n", "      if (!section) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"the section does not exist\",\n        });\n      }\n\n      if (!section.courseId) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"the section has no course\",\n        });\n      }\n\n      const course = await ctx.prisma.course.findUnique({\n        where: {\n          id: section.courseId,\n        },\n      });\n", "      if (course?.userId !== ctx.session.user.id) {\n        throw new TRPCError({\n          code: \"FORBIDDEN\",\n          message: \"you do not have access to this course\",\n        });\n      }\n\n      return createPresignedPost(s3Client, {\n        Bucket: env.NEXT_PUBLIC_S3_BUCKET_NAME,\n        Key: section.videoId,\n        Fields: {\n          key: section.videoId,\n        },\n        Conditions: [\n          [\"starts-with\", \"$Content-Type\", \"image/\"],\n          [\"content-length-range\", 0, UPLOAD_MAX_FILE_SIZE],\n        ],\n      });\n    }),\n});\n"]}
