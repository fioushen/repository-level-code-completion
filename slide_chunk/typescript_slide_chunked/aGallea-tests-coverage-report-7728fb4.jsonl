{"filename": "jest.config.ts", "chunked_list": ["/*\n * For a detailed explanation regarding each configuration property and type check, visit:\n * https://jestjs.io/docs/configuration\n */\n\nexport default {\n  // All imported modules in your tests should be mocked automatically\n  // automock: false,\n\n  // Stop running tests after `n` failures\n  // bail: 0,\n\n  // The directory where Jest should store its cached dependency information\n  // cacheDirectory: \"/private/var/folders/x0/z8cnrq89243fv317kptvwygh0000gp/T/jest_dy\",\n\n  // Automatically clear mock calls, instances, contexts and results before every test\n  clearMocks: true,\n\n  // Indicates whether the coverage information should be collected while executing the test\n  collectCoverage: true,\n\n  // An array of glob patterns indicating a set of files for which coverage information should be collected\n  // collectCoverageFrom: undefined,\n\n  // The directory where Jest should output its coverage files\n  coverageDirectory: 'coverage',\n\n  // An array of regexp pattern strings used to skip coverage collection\n  // coveragePathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // Indicates which provider should be used to instrument code for coverage\n  coverageProvider: 'v8',\n\n  // A list of reporter names that Jest uses when writing coverage reports\n  coverageReporters: [\n    'json',\n    'json-summary',\n    'text',\n    'text-summary',\n    \"lcov\",\n    'clover',\n    'cobertura',\n  ],\n  reporters: ['default', ['jest-junit', { outputDirectory: 'coverage' }]],\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n\n  // testMatch: [\n  //   '**/*.test.ts',\n  // ],\n  testPathIgnorePatterns: [\n      '/node_modules/',\n      '/dist/',\n  ],\n  // An object that configures minimum threshold enforcement for coverage results\n  // coverageThreshold: undefined,\n\n  // A path to a custom dependency extractor\n  // dependencyExtractor: undefined,\n\n  // Make calling deprecated APIs throw helpful error messages\n  // errorOnDeprecated: false,\n\n  // The default configuration for fake timers\n  // fakeTimers: {\n  //   \"enableGlobally\": false\n  // },\n\n  // Force coverage collection from ignored files using an array of glob patterns\n  // forceCoverageMatch: [],\n", "  // A path to a module which exports an async function that is triggered once before all test suites\n  // globalSetup: undefined,\n\n  // A path to a module which exports an async function that is triggered once after all test suites\n  // globalTeardown: undefined,\n\n  // A set of global variables that need to be available in all test environments\n  // globals: {},\n\n  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n  // maxWorkers: \"50%\",\n\n  // An array of directory names to be searched recursively up from the requiring module's location\n  // moduleDirectories: [\n  //   \"node_modules\"\n  // ],\n\n  // An array of file extensions your modules use\n  // moduleFileExtensions: [\n  //   \"js\",\n  //   \"mjs\",\n  //   \"cjs\",\n  //   \"jsx\",\n  //   \"ts\",\n  //   \"tsx\",\n  //   \"json\",\n  //   \"node\"\n  // ],\n", "  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  // moduleNameMapper: {},\n\n  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader\n  // modulePathIgnorePatterns: [],\n\n  // Activates notifications for test results\n  // notify: false,\n\n  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: \"failure-change\",\n\n  // A preset that is used as a base for Jest's configuration\n  // preset: undefined,\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n", "  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: \"failure-change\",\n\n  // A preset that is used as a base for Jest's configuration\n  // preset: undefined,\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n", "  // Reset the module registry before running each individual test\n  // resetModules: false,\n\n  // A path to a custom resolver\n  // resolver: undefined,\n\n  // Automatically restore mock state and implementation before every test\n  // restoreMocks: false,\n\n  // The root directory that Jest should scan for tests and modules within\n  // rootDir: undefined,\n\n  // A list of paths to directories that Jest should use to search for files in\n  // roots: [\n  //   \"<rootDir>\"\n  // ],\n\n  // Allows you to use a custom runner instead of Jest's default test runner\n  // runner: \"jest-runner\",\n\n  // The paths to modules that run some code to configure or set up the testing environment before each test\n  // setupFiles: [],\n\n  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n  // setupFilesAfterEnv: [],\n\n  // The number of seconds after which a test is considered as slow and reported as such in the results.\n  // slowTestThreshold: 5,\n\n  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n  // snapshotSerializers: [],\n\n  // The test environment that will be used for testing\n  // testEnvironment: \"jest-environment-node\",\n\n  // Options that will be passed to the testEnvironment\n  // testEnvironmentOptions: {},\n\n  // Adds a location field to test results\n  // testLocationInResults: false,\n\n  // The glob patterns Jest uses to detect test files\n  testMatch: [\n    \"**/__tests__/**/*.[jt]s?(x)\",\n    \"**/?(*.)+(spec|test).[tj]s?(x)\"\n  ],\n\n  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n  // testPathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // The regexp pattern or array of patterns that Jest uses to detect test files\n  // testRegex: [],\n\n  // This option allows the use of a custom results processor\n  // testResultsProcessor: undefined,\n\n  // This option allows use of a custom test runner\n  // testRunner: \"jest-circus/runner\",\n\n  // A map from regular expressions to paths to transformers\n  // transform: undefined,\n\n  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n  // transformIgnorePatterns: [\n  //   \"/node_modules/\",\n  //   \"\\\\.pnp\\\\.[^\\\\/]+$\"\n  // ],\n", "  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n  // unmockedModulePathPatterns: undefined,\n\n  // Indicates whether each individual test should be reported during the run\n  // verbose: undefined,\n\n  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n  // watchPathIgnorePatterns: [],\n\n  // Whether to use watchman for file crawling\n  // watchman: true,\n};\n"]}
{"filename": "test/commentCoverage.test.ts", "chunked_list": ["import { spyActions } from './actions.spy';\nimport * as github from '@actions/github';\nimport { DiffInfo, EventInfo, Junit } from '../src/types';\nimport { getEventInfo } from '../src/eventInfo';\nimport { buildBody, commentCoverage } from '../src/commentCoverage';\nimport * as core from '@actions/core';\n\nconst originalContext = { ...github.context };\n\ndescribe('commentCoverage tests', () => {", "\ndescribe('commentCoverage tests', () => {\n  afterAll(() => {\n    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;\n    jest.restoreAllMocks();\n    jest.resetAllMocks();\n  });\n\n  describe('commentCoverage tests', () => {", "\n  describe('commentCoverage tests', () => {\n    let eventInfo: EventInfo;\n    const spyCreateCommitComment = jest.fn();\n    const spyListComments = jest.fn().mockImplementation(() => ({\n      data: [],\n    }));\n    const spyUpdateComment = jest.fn();\n    const spyCreateComment = jest.fn();\n", "    const spyCreateComment = jest.fn();\n\n    beforeAll(() => {\n      spyActions();\n      jest.spyOn(github, 'getOctokit').mockImplementation(\n        () =>\n          ({\n            rest: {\n              repos: {\n                createCommitComment: spyCreateCommitComment,", "              repos: {\n                createCommitComment: spyCreateCommitComment,\n              },\n              issues: {\n                listComments: spyListComments,\n                updateComment: spyUpdateComment,\n                createComment: spyCreateComment,\n              },\n            },\n          } as any),", "            },\n          } as any),\n      );\n    });\n    beforeEach(() => {\n      eventInfo = getEventInfo();\n    });\n\n    test('createCommitComment with push event', async () => {\n      github.context.eventName = 'push';", "    test('createCommitComment with push event', async () => {\n      github.context.eventName = 'push';\n      await commentCoverage(eventInfo, 'some-body-content-1');\n      expect(spyCreateCommitComment).toBeCalledWith({\n        body: 'some-body-content-1',\n        commit_sha: 'abcdefghijklmnopqrstuvwxyz',\n        owner: 'some-owner',\n        repo: 'some-repo',\n      });\n    });", "      });\n    });\n    test('createComment with pull_request event', async () => {\n      github.context.eventName = 'pull_request';\n      await commentCoverage(eventInfo, 'some-body-content-2');\n      expect(spyCreateComment).toBeCalledWith({\n        body: 'some-body-content-2',\n        issue_number: 1,\n        owner: 'some-owner',\n        repo: 'some-repo',", "        owner: 'some-owner',\n        repo: 'some-repo',\n      });\n    });\n    test('createComment with pull_request event and overrideComment', async () => {\n      github.context.eventName = 'pull_request';\n      eventInfo.overrideComment = true;\n      await commentCoverage(eventInfo, 'some-body-content-3');\n      expect(spyListComments).toBeCalledWith({\n        repo: 'some-repo',", "      expect(spyListComments).toBeCalledWith({\n        repo: 'some-repo',\n        owner: 'some-owner',\n        issue_number: 1,\n      });\n      expect(spyCreateComment).toBeCalledWith({\n        body: 'some-body-content-3',\n        issue_number: 1,\n        owner: 'some-owner',\n        repo: 'some-repo',", "        owner: 'some-owner',\n        repo: 'some-repo',\n      });\n    });\n    test('updateComment with pull_request event and overrideComment', async () => {\n      github.context.eventName = 'pull_request';\n      eventInfo.overrideComment = true;\n      const spyListCommentsWithContent = jest.fn().mockImplementation(() => ({\n        data: [\n          {", "        data: [\n          {\n            user: {\n              login: 'github-actions[bot]',\n            },\n            body: '',\n            id: 50,\n          },\n          {\n            user: {", "          {\n            user: {\n              login: 'github-actions[bot]',\n            },\n            body: '<!-- tests-coverage-report -->foobar',\n            id: 51,\n          },\n        ],\n      }));\n      jest.spyOn(github, 'getOctokit').mockImplementation(", "      }));\n      jest.spyOn(github, 'getOctokit').mockImplementation(\n        () =>\n          ({\n            rest: {\n              issues: {\n                listComments: spyListCommentsWithContent,\n                updateComment: spyUpdateComment,\n                createComment: spyCreateComment,\n              },", "                createComment: spyCreateComment,\n              },\n            },\n          } as any),\n      );\n      await commentCoverage(eventInfo, 'some-body-content-4');\n      expect(spyListCommentsWithContent).toBeCalledWith({\n        repo: 'some-repo',\n        owner: 'some-owner',\n        issue_number: 1,", "        owner: 'some-owner',\n        issue_number: 1,\n      });\n      expect(spyUpdateComment).toBeCalledWith({\n        body: 'some-body-content-4',\n        comment_id: 51,\n        owner: 'some-owner',\n        repo: 'some-repo',\n      });\n    });", "      });\n    });\n  });\n\n  describe('buildBody tests', () => {\n    let eventInfo: EventInfo;\n    let junitInfo: Junit;\n    let diffsInfo: DiffInfo[];\n\n    beforeAll(() => {", "\n    beforeAll(() => {\n      spyActions();\n    });\n\n    beforeEach(() => {\n      eventInfo = getEventInfo();\n      junitInfo = {\n        tests: 51,\n        failures: {", "        tests: 51,\n        failures: {\n          count: 0,\n          info: undefined,\n        },\n        errors: 0,\n        skipped: 0,\n        time: '12s',\n      };\n      diffsInfo = [", "      };\n      diffsInfo = [\n        {\n          file: '1.file',\n          changedLines: ['1', '2', '3', '4', '5', '6'],\n          missedLines: ['2', '5'],\n        },\n      ];\n    });\n", "    });\n\n    test('dont show junit and diffCover content', async () => {\n      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n',\n      );\n    });\n    test('show only junit content, without junit info', async () => {\n      eventInfo.showJunit = true;\n      expect(buildBody(eventInfo, undefined, [])).toEqual(", "      eventInfo.showJunit = true;\n      expect(buildBody(eventInfo, undefined, [])).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\nNo JUnit details to present\\n',\n      );\n    });\n    test('show only junit content', async () => {\n      eventInfo.showJunit = true;\n      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### JUnit Details\\n| Total Tests | Failures  | Errors  | Skipped  | Time :hourglass_flowing_sand: |\\n| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n| 51 | 0 | 0 | 0 | 12s |\\n\\n',\n      );", "        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### JUnit Details\\n| Total Tests | Failures  | Errors  | Skipped  | Time :hourglass_flowing_sand: |\\n| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n| 51 | 0 | 0 | 0 | 12s |\\n\\n',\n      );\n    });\n    test('show junit content, with failures info', async () => {\n      eventInfo.showJunit = true;\n      eventInfo.showFailuresInfo = true;\n      junitInfo.failures = {\n        count: 1,\n        info: [\n          {", "        info: [\n          {\n            classname: 'my-class-name',\n            name: 'test name',\n            time: '-1',\n            error: 'error message',\n          },\n        ],\n      };\n      expect(buildBody(eventInfo, junitInfo, [])).toEqual(", "      };\n      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Failure :x:\\n### JUnit Details\\n| Total Tests | Failures :x: | Errors  | Skipped  | Time :hourglass_flowing_sand: |\\n| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n| 51 | 1 | 0 | 0 | 12s |\\n<details><table><summary><b>Failures Details</b>\\n\\n</summary><tr><th>File</th><th>Test Name</th><th>Error Message</th></tr><tr><td>TODO</td><td>test name</td><td>error message</td></tr></table></details>\\n\\n',\n      );\n    });\n    test('show only diffCover content, without diff info', async () => {\n      eventInfo.showDiffcover = true;\n      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details :ballot_box_with_check:\\nNo coverage details to present',\n      );", "        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details :ballot_box_with_check:\\nNo coverage details to present',\n      );\n    });\n    test('show only diffCover content', async () => {\n      eventInfo.showDiffcover = true;\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (67% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td>Total</td><td>4/6</td><td>67%</td><td></td></tr></table></details>',\n      );\n    });\n    test('diffCover content with full coverage', async () => {", "    });\n    test('diffCover content with full coverage', async () => {\n      eventInfo.showDiffcover = true;\n      diffsInfo.pop();\n      diffsInfo.push({\n        file: '1.file',\n        changedLines: ['1', '2', '3', '4', '5', '6'],\n        missedLines: [],\n      });\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(", "      });\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (100% >= 80%) :white_check_mark:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>6/6</td><td>100%</td><td></td></tr><tr><td>Total</td><td>6/6</td><td>100%</td><td></td></tr></table></details>',\n      );\n    });\n    test('diffCover content with no changes', async () => {\n      eventInfo.showDiffcover = true;\n      diffsInfo.pop();\n      diffsInfo.push({\n        file: '1.file',", "      diffsInfo.push({\n        file: '1.file',\n        changedLines: [],\n        missedLines: [],\n      });\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n',\n      );\n    });\n    test('diffCover content with missed range', async () => {", "    });\n    test('diffCover content with missed range', async () => {\n      eventInfo.showDiffcover = true;\n      diffsInfo.push({\n        file: '2.file',\n        changedLines: ['1', '2', '3', '4', '5', '6'],\n        missedLines: ['1', '2', '3', '5'],\n      });\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',", "      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n      );\n    });\n    test('diffCover content with full coverage', async () => {\n      eventInfo.showDiffcover = true;\n      eventInfo.minCoveragePercentage = '100';\n      diffsInfo.pop();\n      diffsInfo.push({\n        file: '1.file',", "      diffsInfo.push({\n        file: '1.file',\n        changedLines: ['1', '2', '3', '4', '5', '6'],\n        missedLines: [],\n      });\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (100% >= 100%) :white_check_mark:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>6/6</td><td>100%</td><td></td></tr><tr><td>Total</td><td>6/6</td><td>100%</td><td></td></tr></table></details>',\n      );\n    });\n    test('diffCover content with missed range and failUnder', async () => {", "    });\n    test('diffCover content with missed range and failUnder', async () => {\n      eventInfo.showDiffcover = true;\n      eventInfo.failUnderCoveragePercentage = false;\n      diffsInfo.push({\n        file: '2.file',\n        changedLines: ['1', '2', '3', '4', '5', '6'],\n        missedLines: ['1', '2', '3', '5'],\n      });\n      const coreSetFailedSpy = jest.spyOn(core, 'setFailed');", "      });\n      const coreSetFailedSpy = jest.spyOn(core, 'setFailed');\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n      );\n      expect(coreSetFailedSpy).not.toHaveBeenCalled();\n      eventInfo.failUnderCoveragePercentage = true;\n      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n      );", "        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n      );\n      expect(coreSetFailedSpy).toHaveBeenCalledWith('low coverage');\n    });\n  });\n});\n"]}
{"filename": "test/changedFiles.test.ts", "chunked_list": ["import { defaultInputs, spyActions } from './actions.spy';\nimport * as github from '@actions/github';\nimport { getChangedFiles } from '../src/changedFiles';\nimport { getEventInfo } from '../src/eventInfo';\nimport { EventInfo, FilesStatus } from '../src/types';\nimport * as core from '@actions/core';\n\nconst originalContext = { ...github.context };\n\ndescribe('eventInput tests', () => {", "\ndescribe('eventInput tests', () => {\n  beforeAll(() => {\n    const data = {\n      inputs: defaultInputs,\n      compareCommitsWithBasehead: {\n        total_commits: 3,\n        files: [\n          {\n            status: 'added',", "          {\n            status: 'added',\n            filename: '1.file',\n          },\n          {\n            status: 'modified',\n            filename: '2.file',\n          },\n          {\n            status: 'renamed',", "          {\n            status: 'renamed',\n            filename: '3.file',\n          },\n          {\n            status: 'copied',\n            filename: '4.file',\n          },\n          {\n            status: 'changed',", "          {\n            status: 'changed',\n            filename: '5.file',\n          },\n          {\n            status: 'unchanged',\n            filename: '6.file',\n          },\n          {\n            status: 'removed',", "          {\n            status: 'removed',\n            filename: '7.file',\n          },\n        ],\n      },\n    };\n    spyActions(data);\n  });\n", "  });\n\n  afterAll(() => {\n    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;\n    jest.restoreAllMocks();\n    jest.resetAllMocks();\n  });\n\n  test('getChangedFiles', async () => {", "\n  test('getChangedFiles', async () => {\n    const eventInfo: EventInfo = getEventInfo();\n    const filesStatus: FilesStatus = await getChangedFiles(eventInfo);\n    expect(filesStatus.all).toHaveLength(7);\n    expect(filesStatus.added).toHaveLength(1);\n    expect(filesStatus.added[0]).toEqual('1.file');\n    expect(filesStatus.modified).toHaveLength(1);\n    expect(filesStatus.modified[0]).toEqual('2.file');\n    expect(filesStatus.renamed).toHaveLength(1);", "    expect(filesStatus.modified[0]).toEqual('2.file');\n    expect(filesStatus.renamed).toHaveLength(1);\n    expect(filesStatus.renamed[0]).toEqual('3.file');\n    expect(filesStatus.copied).toHaveLength(1);\n    expect(filesStatus.copied[0]).toEqual('4.file');\n    expect(filesStatus.changed).toHaveLength(1);\n    expect(filesStatus.changed[0]).toEqual('5.file');\n    expect(filesStatus.unchanged).toHaveLength(1);\n    expect(filesStatus.unchanged[0]).toEqual('6.file');\n    expect(filesStatus.removed).toHaveLength(1);", "    expect(filesStatus.unchanged[0]).toEqual('6.file');\n    expect(filesStatus.removed).toHaveLength(1);\n    expect(filesStatus.removed[0]).toEqual('7.file');\n  });\n});\n"]}
{"filename": "test/diffCover.test.ts", "chunked_list": ["import { spyActions } from './actions.spy';\nimport * as github from '@actions/github';\nimport { CoverageTypeInfo, EventInfo, FilesStatus, DiffInfo } from '../src/types';\nimport { getEventInfo } from '../src/eventInfo';\nimport { diffCover } from '../src/diffCover';\nimport { parseFile } from '../src/parsers/cobertura';\nimport * as Utils from '../src/utils';\n\nconst originalContext = { ...github.context };\n", "const originalContext = { ...github.context };\n\ndescribe('diffCover tests', () => {\n  beforeAll(() => {\n    spyActions();\n  });\n\n  afterAll(() => {\n    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;", "    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;\n    jest.restoreAllMocks();\n    jest.resetAllMocks();\n  });\n\n  const getFilesStatus = (): FilesStatus => {\n    return {\n      all: [],\n      added: [],", "      all: [],\n      added: [],\n      removed: [],\n      modified: [],\n      renamed: [],\n      copied: [],\n      changed: [],\n      unchanged: [],\n    };\n  };", "    };\n  };\n\n  describe('Empty responses', () => {\n    test('showDiffcover false', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      const cobertura = await parseFile(\n        './test/assets/cobertura-coverage.xml',\n        '/Users/user/workspace/private/tests-coverage-report/',\n      );", "        '/Users/user/workspace/private/tests-coverage-report/',\n      );\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura,\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const DiffInfo: DiffInfo[] = await diffCover(", "      };\n      const DiffInfo: DiffInfo[] = await diffCover(\n        eventInfo,\n        getFilesStatus(),\n        coverageInfo,\n      );\n      expect(DiffInfo).toHaveLength(0);\n    });\n    test('empty added/modified/changed', async () => {\n      const eventInfo: EventInfo = getEventInfo();", "    test('empty added/modified/changed', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const cobertura = await parseFile(\n        './test/assets/cobertura-coverage.xml',\n        '/Users/user/workspace/private/tests-coverage-report/',\n      );\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura,", "      const coverageInfo: CoverageTypeInfo = {\n        cobertura,\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const DiffInfo: DiffInfo[] = await diffCover(\n        eventInfo,\n        getFilesStatus(),", "        eventInfo,\n        getFilesStatus(),\n        coverageInfo,\n      );\n      expect(DiffInfo).toHaveLength(0);\n    });\n  });\n\n  describe('Responses with content', () => {\n    test('diff info', async () => {", "  describe('Responses with content', () => {\n    test('diff info', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const cobertura = await parseFile(\n        './test/assets/cobertura-coverage.xml',\n        '/Users/user/workspace/private/tests-coverage-report/',\n      );\n      const coverageInfo: CoverageTypeInfo = {", "      );\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura,\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const filesStatus = getFilesStatus();\n      filesStatus.all = ['1.file', '2.file', '3.file'];", "      const filesStatus = getFilesStatus();\n      filesStatus.all = ['1.file', '2.file', '3.file'];\n      filesStatus.changed = ['1.file'];\n      filesStatus.added = ['2.file'];\n      filesStatus.modified = ['3.file'];\n      const DiffInfo: DiffInfo[] = await diffCover(eventInfo, filesStatus, coverageInfo);\n      expect(DiffInfo).toHaveLength(0);\n    });\n    test('with changed lines', async () => {\n      jest", "    test('with changed lines', async () => {\n      jest\n        .spyOn(Utils, 'execCommand')\n        .mockImplementation(async (command: string): Promise<Utils.ExecInfo> => {\n          if (command.includes('src/main.ts')) {\n            return {\n              status: 'success',\n              stdout: '1\\n2\\n3\\n4\\n10\\n11\\n12\\n13\\n17\\n18\\n19\\n20\\n21\\n22\\n29\\n30\\n',\n            };\n          } else if (command.includes('src/diffCover.ts')) {\n            return {\n              status: 'success',\n              stdout:\n                '1\\n2\\n3\\n4\\n5\\n51\\n52\\n53\\n54\\n72\\n73\\n74\\n78\\n79\\n80\\n81\\n82\\n83\\n',\n            };\n          }\n          return {\n            status: 'success',\n            stdout: '',\n          };\n        });\n      const eventInfo: EventInfo = getEventInfo();\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const cobertura = await parseFile(\n        './test/assets/cobertura-coverage.xml',\n        '/Users/user/workspace/private/tests-coverage-report/',\n      );\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura,\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const filesStatus = getFilesStatus();\n      filesStatus.all = ['src/diffCover.ts', 'src/main.ts', 'src/utils.ts'];\n      filesStatus.changed = ['src/diffCover.ts'];\n      filesStatus.added = ['src/main.ts'];\n      filesStatus.modified = ['src/utils.ts'];\n      const DiffInfo: DiffInfo[] = await diffCover(eventInfo, filesStatus, coverageInfo);\n      expect(DiffInfo).toHaveLength(2);\n      expect(DiffInfo[0]).toEqual({\n        changedLines: [\n          '1',\n          '2',\n          '3',\n          '4',\n          '5',\n          '51',\n          '52',\n          '53',\n          '54',\n          '72',\n          '73',\n          '74',\n          '78',\n          '79',\n          '80',\n          '81',\n          '82',\n          '83',\n        ],\n        file: 'src/diffCover.ts',\n        missedLines: [\n          '51',\n          '52',\n          '53',\n          '54',\n          '72',\n          '73',\n          '74',\n          '78',\n          '79',\n          '80',\n          '81',\n          '82',\n          '83',\n        ],\n      });\n      expect(DiffInfo[1]).toEqual({\n        changedLines: [\n          '1',\n          '2',\n          '3',\n          '4',\n          '10',\n          '11',\n          '12',\n          '13',\n          '17',\n          '18',\n          '19',\n          '20',\n          '21',\n          '22',\n          '29',\n          '30',\n        ],\n        file: 'src/main.ts',\n        missedLines: ['18', '19', '20', '21', '22', '29', '30'],\n      });\n    });\n  });\n\n  describe('Exceptions', () => {\n    test('invalid git log', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      jest.spyOn(Utils, 'execCommand').mockImplementation(\n        async (): Promise<Utils.ExecInfo> => ({\n          status: 'error',\n          message: 'some error message',\n          errorCode: 1,\n        }),\n      );\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura: [],\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const filesStatus = getFilesStatus();\n      await expect(diffCover(eventInfo, filesStatus, coverageInfo)).rejects.toThrow(\n        'failed to retrieve git log: master..some-head. error: some error message',\n      );\n    });\n    test('invalid git blame', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      jest\n        .spyOn(Utils, 'execCommand')\n        .mockImplementation(async (command: string): Promise<Utils.ExecInfo> => {", "          } else if (command.includes('src/diffCover.ts')) {\n            return {\n              status: 'success',\n              stdout:\n                '1\\n2\\n3\\n4\\n5\\n51\\n52\\n53\\n54\\n72\\n73\\n74\\n78\\n79\\n80\\n81\\n82\\n83\\n',\n            };\n          }\n          return {\n            status: 'success',\n            stdout: '',\n          };\n        });\n      const eventInfo: EventInfo = getEventInfo();\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const cobertura = await parseFile(\n        './test/assets/cobertura-coverage.xml',\n        '/Users/user/workspace/private/tests-coverage-report/',\n      );\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura,\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const filesStatus = getFilesStatus();\n      filesStatus.all = ['src/diffCover.ts', 'src/main.ts', 'src/utils.ts'];\n      filesStatus.changed = ['src/diffCover.ts'];\n      filesStatus.added = ['src/main.ts'];\n      filesStatus.modified = ['src/utils.ts'];\n      const DiffInfo: DiffInfo[] = await diffCover(eventInfo, filesStatus, coverageInfo);\n      expect(DiffInfo).toHaveLength(2);\n      expect(DiffInfo[0]).toEqual({\n        changedLines: [\n          '1',\n          '2',\n          '3',\n          '4',\n          '5',\n          '51',\n          '52',\n          '53',\n          '54',\n          '72',\n          '73',\n          '74',\n          '78',\n          '79',\n          '80',\n          '81',\n          '82',\n          '83',\n        ],\n        file: 'src/diffCover.ts',\n        missedLines: [\n          '51',\n          '52',\n          '53',\n          '54',\n          '72',\n          '73',\n          '74',\n          '78',\n          '79',\n          '80',\n          '81',\n          '82',\n          '83',\n        ],\n      });\n      expect(DiffInfo[1]).toEqual({\n        changedLines: [\n          '1',\n          '2',\n          '3',\n          '4',\n          '10',\n          '11',\n          '12',\n          '13',\n          '17',\n          '18',\n          '19',\n          '20',\n          '21',\n          '22',\n          '29',\n          '30',\n        ],\n        file: 'src/main.ts',\n        missedLines: ['18', '19', '20', '21', '22', '29', '30'],\n      });\n    });\n  });\n\n  describe('Exceptions', () => {\n    test('invalid git log', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      jest.spyOn(Utils, 'execCommand').mockImplementation(\n        async (): Promise<Utils.ExecInfo> => ({\n          status: 'error',\n          message: 'some error message',\n          errorCode: 1,\n        }),\n      );\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura: [],\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const filesStatus = getFilesStatus();\n      await expect(diffCover(eventInfo, filesStatus, coverageInfo)).rejects.toThrow(\n        'failed to retrieve git log: master..some-head. error: some error message',\n      );\n    });\n    test('invalid git blame', async () => {\n      const eventInfo: EventInfo = getEventInfo();\n      jest\n        .spyOn(Utils, 'execCommand')\n        .mockImplementation(async (command: string): Promise<Utils.ExecInfo> => {", "          if (command.includes('blame')) {\n            return {\n              status: 'error',\n              message: 'git blame error message',\n              errorCode: 1,\n            };\n          }\n          return {\n            status: 'success',\n            stdout: '',\n          };\n        });\n      eventInfo.showDiffcover = true;\n      eventInfo.diffcoverRef = 'cobertura';\n      const cobertura = await parseFile(\n        './test/assets/cobertura-coverage.xml',\n        '/Users/user/workspace/private/tests-coverage-report/',\n      );\n      const coverageInfo: CoverageTypeInfo = {\n        cobertura,\n        clover: [],\n        lcov: [],\n        jacoco: [],\n        junit: undefined,\n      };\n      const filesStatus = getFilesStatus();\n      filesStatus.all = ['src/diffCover.ts'];\n      filesStatus.changed = ['src/diffCover.ts'];\n      await expect(diffCover(eventInfo, filesStatus, coverageInfo)).rejects.toThrow(\n        'failed to execute \"git blame\" on file: src/diffCover.ts. error: git blame error message',\n      );\n    });\n  });\n});\n"]}
{"filename": "test/eventInfo.test.ts", "chunked_list": ["import * as github from '@actions/github';\nimport { getEventInfo } from '../src/eventInfo';\nimport { EventInfo } from '../src/types';\nimport { defaultCompareCommitsWithBasehead, spyActions } from './actions.spy';\n\nconst originalContext = { ...github.context };\n\ndescribe('eventInput tests', () => {\n  beforeAll(() => {\n    spyActions();", "  beforeAll(() => {\n    spyActions();\n  });\n\n  afterAll(() => {\n    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;\n    jest.restoreAllMocks();\n    jest.resetAllMocks();\n  });", "    jest.resetAllMocks();\n  });\n\n  test('getEventInfo - pull_request', () => {\n    const data = {\n      inputs: {\n        'github-token': 'abcdefgh',\n        'cobertura-path': 'cobertura.xml',\n        'show-junit': 'true',\n      },", "        'show-junit': 'true',\n      },\n      compareCommitsWithBasehead: defaultCompareCommitsWithBasehead,\n    };\n    spyActions(data);\n    const eventInfo: EventInfo = getEventInfo();\n    expect(eventInfo.token).toBe('abcdefgh');\n    expect(eventInfo.commitSha).toBe('abcdefghijklmnopqrstuvwxyz');\n    expect(eventInfo.jacocoPath).toBeUndefined();\n    expect(eventInfo.showJunit).toBeTruthy();", "    expect(eventInfo.jacocoPath).toBeUndefined();\n    expect(eventInfo.showJunit).toBeTruthy();\n  });\n\n  test('getEventInfo - push', () => {\n    const data = {\n      inputs: {\n        'github-token': 'abcdefgh',\n        'jacoco-path': 'jacoco.xml',\n        'show-junit': 'false',", "        'jacoco-path': 'jacoco.xml',\n        'show-junit': 'false',\n      },\n      compareCommitsWithBasehead: defaultCompareCommitsWithBasehead,\n    };\n    spyActions(data, 'push');\n    const eventInfo: EventInfo = getEventInfo();\n    expect(eventInfo.token).toBe('abcdefgh');\n    expect(eventInfo.commitSha).toBe('zyxwvutsrqponmlkjihgfedcba');\n    expect(eventInfo.jacocoPath).toBe('jacoco.xml');", "    expect(eventInfo.commitSha).toBe('zyxwvutsrqponmlkjihgfedcba');\n    expect(eventInfo.jacocoPath).toBe('jacoco.xml');\n    expect(eventInfo.coberturaPath).toBeUndefined();\n    expect(eventInfo.showJunit).toBeTruthy();\n  });\n});\n"]}
{"filename": "test/main.test.ts", "chunked_list": ["import { spyActions } from './actions.spy';\nimport * as github from '@actions/github';\nimport { main } from '../src/main';\nimport * as Comment from '../src/commentCoverage';\nimport { EventInfo } from '../src/types';\nimport { getEventInfo } from '../src/eventInfo';\nimport * as core from '@actions/core';\n\nconst originalContext = { ...github.context };\n", "const originalContext = { ...github.context };\n\ndescribe('main tests', () => {\n  beforeAll(() => {\n    spyActions();\n  });\n\n  afterAll(() => {\n    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;", "    github.context.ref = originalContext.ref;\n    github.context.sha = originalContext.sha;\n    jest.restoreAllMocks();\n    jest.resetAllMocks();\n  });\n\n  test('empty content', async () => {\n    const commentCoverageSpy = jest\n      .spyOn(Comment, 'commentCoverage')\n      .mockImplementation(async (eventInfo: EventInfo, body: string): Promise<void> => {", "      .spyOn(Comment, 'commentCoverage')\n      .mockImplementation(async (eventInfo: EventInfo, body: string): Promise<void> => {\n        return;\n      });\n    await main();\n    const eventInfo: EventInfo = getEventInfo();\n    expect(commentCoverageSpy).toHaveBeenCalledWith(\n      eventInfo,\n      '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n',\n    );", "      '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n',\n    );\n  });\n  test('exception', async () => {\n    jest\n      .spyOn(Comment, 'commentCoverage')\n      .mockImplementation(async (eventInfo: EventInfo, body: string): Promise<void> => {\n        throw new Error('some error');\n      });\n    const coreErrorSpy = jest.spyOn(core, 'setFailed');", "      });\n    const coreErrorSpy = jest.spyOn(core, 'setFailed');\n    await main();\n    expect(coreErrorSpy).toHaveBeenCalledWith('some error');\n  });\n});\n"]}
{"filename": "test/actions.spy.ts", "chunked_list": ["import * as core from '@actions/core';\nimport * as github from '@actions/github';\n\nexport const defaultInputs: { [key: string]: any } = {\n  title: 'Tests Report Mock',\n  'github-token': 'abcdefgh',\n  'cobertura-path': 'cobertura.xml',\n  'show-junit': false,\n  'min-coverage-percentage': '80',\n};", "  'min-coverage-percentage': '80',\n};\n\nexport const defaultCompareCommitsWithBasehead: { [key: string]: any } = {\n  total_commits: 0,\n  files: [],\n};\n\nexport const defaultData = {\n  inputs: defaultInputs,", "export const defaultData = {\n  inputs: defaultInputs,\n  compareCommitsWithBasehead: defaultCompareCommitsWithBasehead,\n};\n\nexport function spyActions(data = defaultData, eventName = 'pull_request') {\n  github.context.eventName = eventName;\n  jest.spyOn(core, 'getInput').mockImplementation((name: string) => {\n    return data.inputs[name];\n  });\n  jest\n    .spyOn(core, 'getBooleanInput')\n    .mockImplementation((name: string) => data.inputs[name]);\n\n  jest.spyOn(core, 'error').mockImplementation(jest.fn());\n  jest.spyOn(core, 'warning').mockImplementation(jest.fn());\n  jest.spyOn(core, 'info').mockImplementation(jest.fn());\n  jest.spyOn(core, 'debug').mockImplementation(jest.fn());\n  // jest.spyOn(core, 'setFailed').mockImplementation(jest.fn());\n\n  jest.spyOn(github.context, 'repo', 'get').mockImplementation(() => {\n    return {\n      owner: 'some-owner',\n      repo: 'some-repo',\n    };\n  });\n  github.context.ref = 'refs/heads/some-ref';\n  github.context.sha = '1234567890123456789012345678901234567890';\n  github.context.payload = {\n    pull_request: {\n      head: {\n        sha: 'abcdefghijklmnopqrstuvwxyz',\n        ref: 'some-head',\n      },\n      base: {\n        ref: 'master',\n      },\n      number: 1,\n    },\n    after: 'zyxwvutsrqponmlkjihgfedcba',\n  };\n  jest.spyOn(github, 'getOctokit').mockImplementation(\n    () =>\n      ({\n        rest: {\n          repos: {\n            compareCommitsWithBasehead: jest.fn(async () => ({\n              data: data.compareCommitsWithBasehead,\n            })),\n          },\n        },\n      } as any),\n  );\n}\n"]}
{"filename": "test/utils.test.ts", "chunked_list": ["import { execCommand } from '../src/utils';\n\ndescribe('Utils tests', () => {\n  test('exec command success', async () => {\n    const commitsShaExec = await execCommand(`git log --oneline | cut -f1 -d' '`);\n    expect(commitsShaExec.status).toEqual('success');\n  });\n  test('exec command error', async () => {\n    const commitsShaExec = await execCommand('some bad command');\n    expect(commitsShaExec.status).toEqual('error');", "    const commitsShaExec = await execCommand('some bad command');\n    expect(commitsShaExec.status).toEqual('error');\n  });\n});\n"]}
{"filename": "test/parsers/lcov.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/lcov';\n\ndescribe('lcov parser tests', () => {\n  test('No such file', async () => {\n    await expect(parseFile('invalid.file')).rejects.toThrow(\n      `ENOENT: no such file or directory, open 'invalid.file'`,\n    );\n  });\n  test('Filename empty string', async () => {\n    await expect(parseFile('')).resolves.toEqual([]);", "  test('Filename empty string', async () => {\n    await expect(parseFile('')).resolves.toEqual([]);\n  });\n  test('Invalid content', async () => {\n    await expect(parseFile('./test/assets/invalid.xml')).resolves.toEqual([]);\n  });\n\n  test('Parse', async () => {\n    const parsed = await parseFile('./test/assets/lcov.info');\n    expect(parsed).toHaveLength(5);", "    const parsed = await parseFile('./test/assets/lcov.info');\n    expect(parsed).toHaveLength(5);\n    expect(parsed[0].file).toEqual('src/changedFiles.ts');\n    expect(parsed[0].functions.found).toEqual(1);\n    expect(parsed[0].functions.hit).toEqual(0);\n    expect(parsed[0].functions.details).toHaveLength(1);\n    expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n    expect(parsed[0].functions.details[0].line).toEqual(5);\n    expect(parsed[0].functions.details[0].hit).toEqual(0);\n    expect(parsed[0].lines.found).toEqual(46);", "    expect(parsed[0].functions.details[0].hit).toEqual(0);\n    expect(parsed[0].lines.found).toEqual(46);\n    expect(parsed[0].lines.hit).toEqual(5);\n    expect(parsed[0].lines.details).toHaveLength(10);\n    expect(parsed[0].lines.details[0].line).toEqual(1);\n    expect(parsed[0].lines.details[0].hit).toEqual(1);\n    expect(parsed[0].lines.details[5].line).toEqual(6);\n    expect(parsed[0].lines.details[5].hit).toEqual(0);\n\n    expect(parsed[2].file).toEqual('src/diffCover.ts');", "\n    expect(parsed[2].file).toEqual('src/diffCover.ts');\n    expect(parsed[2].functions.found).toEqual(2);\n    expect(parsed[2].functions.hit).toEqual(1);\n    expect(parsed[2].branches.found).toEqual(1);\n    expect(parsed[2].branches.hit).toEqual(1);\n    expect(parsed[2].branches.details).toHaveLength(1);\n    expect(parsed[2].branches.details[0].block).toEqual(0);\n    expect(parsed[2].branches.details[0].line).toEqual(4);\n    expect(parsed[2].branches.details[0].branch).toEqual(0);", "    expect(parsed[2].branches.details[0].line).toEqual(4);\n    expect(parsed[2].branches.details[0].branch).toEqual(0);\n    expect(parsed[2].branches.details[0].taken).toEqual(1);\n  });\n});\n"]}
{"filename": "test/parsers/cobertura.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/cobertura';\n\ndescribe('cobertura parser tests', () => {\n  test('No such file', async () => {\n    await expect(parseFile('invalid.file', '')).rejects.toThrow(\n      `ENOENT: no such file or directory, open 'invalid.file'`,\n    );\n  });\n  test('Filename empty string', async () => {\n    await expect(parseFile('', '')).resolves.toEqual([]);", "  test('Filename empty string', async () => {\n    await expect(parseFile('', '')).resolves.toEqual([]);\n  });\n  test('Invalid xml content', async () => {\n    await expect(parseFile('./test/assets/invalid.xml', '')).rejects.toThrow(\n      'invalid or missing xml content',\n    );\n  });\n  test('error xml content', async () => {\n    await expect(parseFile('./test/assets/invalidXmlContent.xml', '')).rejects.toThrow(", "  test('error xml content', async () => {\n    await expect(parseFile('./test/assets/invalidXmlContent.xml', '')).rejects.toThrow(\n      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n    );\n  });\n\n  test('Parse', async () => {\n    const parsed = await parseFile(\n      './test/assets/cobertura-coverage.xml',\n      '/Users/user/workspace/private/tests-coverage-report/',", "      './test/assets/cobertura-coverage.xml',\n      '/Users/user/workspace/private/tests-coverage-report/',\n    );\n    expect(parsed).toHaveLength(12);\n    expect(parsed[0].file).toEqual('src/changedFiles.ts');\n    expect(parsed[0].functions.found).toEqual(1);\n    expect(parsed[0].functions.hit).toEqual(0);\n    expect(parsed[0].functions.details).toHaveLength(1);\n    expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n    expect(parsed[0].functions.details[0].line).toEqual(5);", "    expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n    expect(parsed[0].functions.details[0].line).toEqual(5);\n    expect(parsed[0].functions.details[0].hit).toEqual(0);\n    expect(parsed[0].lines.found).toEqual(46);\n    expect(parsed[0].lines.hit).toEqual(5);\n    expect(parsed[0].lines.details).toHaveLength(46);\n    expect(parsed[0].lines.details[0].line).toEqual(1);\n    expect(parsed[0].lines.details[0].hit).toEqual(1);\n    expect(parsed[0].lines.details[5].line).toEqual(6);\n    expect(parsed[0].lines.details[5].hit).toEqual(0);", "    expect(parsed[0].lines.details[5].line).toEqual(6);\n    expect(parsed[0].lines.details[5].hit).toEqual(0);\n\n    expect(parsed[2].file).toEqual('src/diffCover.ts');\n    expect(parsed[2].functions.found).toEqual(3);\n    expect(parsed[2].functions.hit).toEqual(1);\n    expect(parsed[2].branches.found).toEqual(1);\n    expect(parsed[2].branches.hit).toEqual(1);\n    expect(parsed[2].branches.details).toHaveLength(1);\n    expect(parsed[2].branches.details[0].line).toEqual(11);", "    expect(parsed[2].branches.details).toHaveLength(1);\n    expect(parsed[2].branches.details[0].line).toEqual(11);\n    expect(parsed[2].branches.details[0].branch).toEqual(0);\n    expect(parsed[2].branches.details[0].taken).toEqual(1);\n  });\n});\n"]}
{"filename": "test/parsers/clover.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/clover';\n\ndescribe('clover parser tests', () => {\n  test('No such file', async () => {\n    await expect(parseFile('invalid.file')).rejects.toThrow(\n      `ENOENT: no such file or directory, open 'invalid.file'`,\n    );\n  });\n  test('Filename empty string', async () => {\n    await expect(parseFile('')).resolves.toEqual([]);", "  test('Filename empty string', async () => {\n    await expect(parseFile('')).resolves.toEqual([]);\n  });\n  test('Invalid xml content', async () => {\n    await expect(parseFile('./test/assets/invalid.xml')).rejects.toThrow(\n      'invalid or missing xml content',\n    );\n  });\n  test('error xml content', async () => {\n    await expect(parseFile('./test/assets/invalidXmlContent.xml')).rejects.toThrow(", "  test('error xml content', async () => {\n    await expect(parseFile('./test/assets/invalidXmlContent.xml')).rejects.toThrow(\n      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n    );\n  });\n\n  test('Parse', async () => {\n    const parsed = await parseFile('./test/assets/clover.xml');\n    expect(parsed).toHaveLength(12);\n    expect(parsed[0].file).toEqual('changedFiles.ts');", "    expect(parsed).toHaveLength(12);\n    expect(parsed[0].file).toEqual('changedFiles.ts');\n    // expect(parsed[0].functions.found).toEqual(1);\n    // expect(parsed[0].functions.hit).toEqual(0);\n    // expect(parsed[0].functions.details).toHaveLength(1);\n    // expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n    // expect(parsed[0].functions.details[0].line).toEqual(5);\n    // expect(parsed[0].functions.details[0].hit).toEqual(0);\n    expect(parsed[0].lines.found).toEqual(46);\n    expect(parsed[0].lines.hit).toEqual(5);", "    expect(parsed[0].lines.found).toEqual(46);\n    expect(parsed[0].lines.hit).toEqual(5);\n    expect(parsed[0].lines.details).toHaveLength(46);\n    expect(parsed[0].lines.details[0].line).toEqual(1);\n    expect(parsed[0].lines.details[0].hit).toEqual(1);\n    expect(parsed[0].lines.details[5].line).toEqual(6);\n    expect(parsed[0].lines.details[5].hit).toEqual(0);\n\n    expect(parsed[2].file).toEqual('diffCover.ts');\n    expect(parsed[2].lines.found).toEqual(92);", "    expect(parsed[2].file).toEqual('diffCover.ts');\n    expect(parsed[2].lines.found).toEqual(92);\n    expect(parsed[2].lines.hit).toEqual(17);\n    expect(parsed[2].lines.details).toHaveLength(92);\n    // expect(parsed[2].functions.found).toEqual(3);\n    // expect(parsed[2].functions.hit).toEqual(1);\n    // expect(parsed[2].branches.found).toEqual(1);\n    // expect(parsed[2].branches.hit).toEqual(1);\n    // expect(parsed[2].branches.details).toHaveLength(1);\n    // expect(parsed[2].branches.details[0].line).toEqual(11);", "    // expect(parsed[2].branches.details).toHaveLength(1);\n    // expect(parsed[2].branches.details[0].line).toEqual(11);\n    // expect(parsed[2].branches.details[0].branch).toEqual(0);\n    // expect(parsed[2].branches.details[0].taken).toEqual(1);\n  });\n});\n"]}
{"filename": "test/parsers/junit.test.ts", "chunked_list": ["import { parse } from '../../src/parsers/junit';\n\ndescribe('junit parser tests', () => {\n  test('No such file', async () => {\n    await expect(parse('invalid.file')).rejects.toThrow(\n      `ENOENT: no such file or directory, lstat 'invalid.file'`,\n    );\n  });\n  test('Filename empty string', async () => {\n    await expect(parse('')).resolves.toBeUndefined();", "  test('Filename empty string', async () => {\n    await expect(parse('')).resolves.toBeUndefined();\n  });\n  test('Invalid xml content', async () => {\n    await expect(parse('./test/assets/invalid.xml')).rejects.toThrow(\n      'invalid or missing xml content',\n    );\n  });\n  test('error xml content', async () => {\n    await expect(parse('./test/assets/invalidXmlContent.xml')).rejects.toThrow(", "  test('error xml content', async () => {\n    await expect(parse('./test/assets/invalidXmlContent.xml')).rejects.toThrow(\n      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n    );\n  });\n\n  test('Parse', async () => {\n    const parsed = await parse('./test/assets/junit.xml');\n    expect(parsed).toBeDefined();\n    expect(parsed?.tests).toEqual(3);", "    expect(parsed).toBeDefined();\n    expect(parsed?.tests).toEqual(3);\n    expect(parsed?.time).toEqual('1.57s');\n    expect(parsed?.skipped).toEqual(0);\n    expect(parsed?.errors).toEqual(0);\n    expect(parsed?.failures).toBeDefined();\n    expect(parsed?.failures.count).toEqual(0);\n    expect(parsed?.failures.info).toHaveLength(0);\n  });\n  test('Parse V2', async () => {", "  });\n  test('Parse V2', async () => {\n    const parsed = await parse('./test/assets/junitV2.xml');\n    expect(parsed).toBeDefined();\n    expect(parsed?.tests).toEqual(1);\n    expect(parsed?.time).toEqual('3.46s');\n    expect(parsed?.skipped).toEqual(0);\n    expect(parsed?.errors).toEqual(0);\n    expect(parsed?.failures).toBeDefined();\n    expect(parsed?.failures.count).toEqual(1);", "    expect(parsed?.failures).toBeDefined();\n    expect(parsed?.failures.count).toEqual(1);\n    expect(parsed?.failures.info).toHaveLength(3);\n    expect(parsed?.failures.info?.[0]?.classname).toEqual('tests.test_connector');\n    expect(parsed?.failures.info?.[0]?.error).toEqual(\n      `BadRequestError: BadRequestError(400, 'illegal_argument_exception', 'Wildcard expressions or all indices are not allowed')`,\n    );\n    expect(parsed?.failures.info?.[0]?.name).toEqual('test_deletion');\n    expect(parsed?.failures.info?.[0]?.time).toEqual('0.06s');\n    expect(parsed?.failures.info?.[1]?.error).toEqual(", "    expect(parsed?.failures.info?.[0]?.time).toEqual('0.06s');\n    expect(parsed?.failures.info?.[1]?.error).toEqual(\n      `BadRequestError(400, 'illegal_argument_exception')`,\n    );\n    expect(parsed?.failures.info?.[1]?.time).toEqual('0.05s');\n    expect(parsed?.failures.info?.[2]?.error).toEqual('unknown failure');\n  });\n  test('Parse with failures', async () => {\n    const parsed = await parse('./test/assets/junitWithFailures.xml');\n    expect(parsed).toBeDefined();", "    const parsed = await parse('./test/assets/junitWithFailures.xml');\n    expect(parsed).toBeDefined();\n    expect(parsed?.tests).toEqual(50);\n    expect(parsed?.time).toEqual('6.18s');\n    expect(parsed?.skipped).toEqual(0);\n    expect(parsed?.errors).toEqual(0);\n    expect(parsed?.failures).toBeDefined();\n    expect(parsed?.failures.count).toEqual(2);\n    expect(parsed?.failures.info).toBeDefined();\n    expect(parsed?.failures.info).toHaveLength(2);", "    expect(parsed?.failures.info).toBeDefined();\n    expect(parsed?.failures.info).toHaveLength(2);\n    expect(parsed?.failures.info?.[0]?.classname).toEqual(\n      'junit parser tests error xml content',\n    );\n    expect(parsed?.failures.info?.[0]?.error).toEqual(\n      'Error: expect(received).rejects.toThrow(expected)',\n    );\n    expect(parsed?.failures.info?.[0]?.name).toEqual(\n      'junit parser tests error xml content',", "    expect(parsed?.failures.info?.[0]?.name).toEqual(\n      'junit parser tests error xml content',\n    );\n    expect(parsed?.failures.info?.[0]?.time).toEqual('0.04s');\n    expect(parsed?.failures.info?.[1]?.classname).toEqual('junit parser tests Parse');\n    expect(parsed?.failures.info?.[1]?.error).toEqual(\n      'Error: expect(received).toEqual(expected) // deep equality',\n    );\n    expect(parsed?.failures.info?.[1]?.name).toEqual('junit parser tests Parse');\n    expect(parsed?.failures.info?.[1]?.time).toEqual('0.01s');", "    expect(parsed?.failures.info?.[1]?.name).toEqual('junit parser tests Parse');\n    expect(parsed?.failures.info?.[1]?.time).toEqual('0.01s');\n  });\n  test('Parse folder with multiple files', async () => {\n    const parsed = await parse('./test/assets/junit');\n    expect(parsed).toBeDefined();\n    expect(parsed?.tests).toEqual(55);\n    expect(parsed?.time).toEqual('8.25s');\n    expect(parsed?.skipped).toEqual(6);\n    expect(parsed?.errors).toEqual(0);", "    expect(parsed?.skipped).toEqual(6);\n    expect(parsed?.errors).toEqual(0);\n    expect(parsed?.failures).toBeDefined();\n    expect(parsed?.failures.count).toEqual(3);\n    expect(parsed?.failures.info).toHaveLength(3);\n    expect(parsed?.failures.info?.[0]?.classname).toEqual(\n      'junit parser tests error xml content',\n    );\n    expect(parsed?.failures.info?.[0]?.error).toEqual(\n      'Error: expect(received).rejects.toThrow(expected)',", "    expect(parsed?.failures.info?.[0]?.error).toEqual(\n      'Error: expect(received).rejects.toThrow(expected)',\n    );\n    expect(parsed?.failures.info?.[0]?.name).toEqual(\n      'junit parser tests error xml content',\n    );\n    expect(parsed?.failures.info?.[0]?.time).toEqual('0.04s');\n    expect(parsed?.failures.info?.[1]?.classname).toEqual('junit parser tests Parse');\n    expect(parsed?.failures.info?.[1]?.error).toEqual(\n      'Error: expect(received).toEqual(expected) // deep equality',", "    expect(parsed?.failures.info?.[1]?.error).toEqual(\n      'Error: expect(received).toEqual(expected) // deep equality',\n    );\n    expect(parsed?.failures.info?.[1]?.name).toEqual('junit parser tests Parse');\n    expect(parsed?.failures.info?.[1]?.time).toEqual('0.01s');\n    expect(parsed?.failures.info?.[2]?.classname).toEqual('com.server.ServletTest');\n    expect(parsed?.failures.info?.[2]?.error).toEqual(\n      'expected:<...2Response(isSuccess=[true]',\n    );\n    expect(parsed?.failures.info?.[2]?.name).toEqual('testListRequestWithConditions');", "    );\n    expect(parsed?.failures.info?.[2]?.name).toEqual('testListRequestWithConditions');\n    expect(parsed?.failures.info?.[2]?.time).toEqual('4.13s');\n  });\n});\n"]}
{"filename": "test/parsers/jacoco.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/jacoco';\n\ndescribe('jacoco parser tests', () => {\n  test('No such file', async () => {\n    await expect(parseFile('invalid.file')).rejects.toThrow(\n      `ENOENT: no such file or directory, open 'invalid.file'`,\n    );\n  });\n  test('Filename empty string', async () => {\n    await expect(parseFile('')).resolves.toEqual([]);", "  test('Filename empty string', async () => {\n    await expect(parseFile('')).resolves.toEqual([]);\n  });\n  test('Invalid xml content', async () => {\n    await expect(parseFile('./test/assets/invalid.xml')).rejects.toThrow(\n      'invalid or missing xml content',\n    );\n  });\n  test('error xml content', async () => {\n    await expect(parseFile('./test/assets/invalidXmlContent.xml')).rejects.toThrow(", "  test('error xml content', async () => {\n    await expect(parseFile('./test/assets/invalidXmlContent.xml')).rejects.toThrow(\n      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n    );\n  });\n\n  test('Parse', async () => {\n    const parsed = await parseFile('./test/assets/jacoco.xml');\n    expect(parsed).toHaveLength(4);\n    expect(parsed[0].file).toEqual('net/cover/report/a/ClassA1.java');", "    expect(parsed).toHaveLength(4);\n    expect(parsed[0].file).toEqual('net/cover/report/a/ClassA1.java');\n    expect(parsed[0].functions.found).toEqual(2);\n    expect(parsed[0].functions.hit).toEqual(2);\n    expect(parsed[0].functions.details).toHaveLength(5);\n    expect(parsed[0].functions.details[0].name).toEqual('<init>');\n    expect(parsed[0].functions.details[0].line).toEqual(25);\n    expect(parsed[0].functions.details[0].hit).toEqual(1);\n    expect(parsed[0].lines.found).toEqual(4);\n    expect(parsed[0].lines.hit).toEqual(4);", "    expect(parsed[0].lines.found).toEqual(4);\n    expect(parsed[0].lines.hit).toEqual(4);\n    expect(parsed[0].lines.details).toHaveLength(4);\n    expect(parsed[0].lines.details[0].line).toEqual(25);\n    expect(parsed[0].lines.details[0].hit).toEqual(3);\n    expect(parsed[0].lines.details[3].line).toEqual(32);\n    expect(parsed[0].lines.details[3].hit).toEqual(2);\n\n    expect(parsed[2].file).toEqual('net/cover/report/b/ClassB1.java');\n    expect(parsed[2].functions.found).toEqual(18);", "    expect(parsed[2].file).toEqual('net/cover/report/b/ClassB1.java');\n    expect(parsed[2].functions.found).toEqual(18);\n    expect(parsed[2].functions.hit).toEqual(17);\n    expect(parsed[2].branches.found).toEqual(20);\n    expect(parsed[2].branches.hit).toEqual(16);\n    expect(parsed[2].branches.details).toHaveLength(20);\n    expect(parsed[2].branches.details[0].block).toEqual(0);\n    expect(parsed[2].branches.details[0].line).toEqual(56);\n    expect(parsed[2].branches.details[0].branch).toEqual(0);\n    expect(parsed[2].branches.details[0].taken).toEqual(1);", "    expect(parsed[2].branches.details[0].branch).toEqual(0);\n    expect(parsed[2].branches.details[0].taken).toEqual(1);\n    expect(parsed[2].branches.details[10].block).toEqual(0);\n    expect(parsed[2].branches.details[10].line).toEqual(147);\n    expect(parsed[2].branches.details[10].branch).toEqual(2);\n    expect(parsed[2].branches.details[10].taken).toEqual(1);\n  });\n});\n", ""]}
{"filename": "src/types.d.ts", "chunked_list": ["export interface CoverageTypeInfo {\n  cobertura: CoverInfo[];\n  clover: CoverInfo[];\n  lcov: CoverInfo[];\n  jacoco: CoverInfo[];\n  junit: Junit | undefined;\n}\n\nexport type DiffCoverRef = 'cobertura' | 'clover' | 'lcov' | 'jacoco';\n\nexport interface EventInfo {\n  token: string;\n  commentTitle: string;\n  owner: string;\n  repo: string;\n  coberturaPath: string;\n  cloverPath: string;\n  lcovPath: string;\n  jacocoPath: string;\n  junitPath: string;\n  showJunit: boolean;\n  showDiffcover: boolean;\n  minCoveragePercentage: string;\n  failUnderCoveragePercentage: boolean;\n  showFailuresInfo: boolean;\n  overrideComment: boolean;\n  commentId: string;\n  diffcoverRef: DiffCoverRef;\n  commitSha: string;\n  headRef: string;\n  baseRef: string;\n  pwd: string;\n  filesStatus?: FilesStatus;\n}\n", "export type DiffCoverRef = 'cobertura' | 'clover' | 'lcov' | 'jacoco';\n\nexport interface EventInfo {\n  token: string;\n  commentTitle: string;\n  owner: string;\n  repo: string;\n  coberturaPath: string;\n  cloverPath: string;\n  lcovPath: string;\n  jacocoPath: string;\n  junitPath: string;\n  showJunit: boolean;\n  showDiffcover: boolean;\n  minCoveragePercentage: string;\n  failUnderCoveragePercentage: boolean;\n  showFailuresInfo: boolean;\n  overrideComment: boolean;\n  commentId: string;\n  diffcoverRef: DiffCoverRef;\n  commitSha: string;\n  headRef: string;\n  baseRef: string;\n  pwd: string;\n  filesStatus?: FilesStatus;\n}\n", "export interface FilesStatus {\n  all: string[];\n  added: string[];\n  removed: string[];\n  modified: string[];\n  renamed: string[];\n  copied: string[];\n  changed: string[];\n  unchanged: string[];\n}\n", "export interface DiffInfo {\n  file: string;\n  missedLines: string[];\n  changedLines: string[];\n}\n\nexport interface CoverInfo {\n  file: string;\n  title: string;\n  lines: CoverInfoLines;\n  functions: CoverInfoFunctions;\n  branches: CoverInfoBranches;\n}\n", "export interface CoverInfoLines {\n  found: number;\n  hit: number;\n  details: CoverInfoLinesDetails[];\n}\n\nexport interface CoverInfoLinesDetails {\n  line: number;\n  hit: number;\n}\n", "export interface CoverInfoFunctions {\n  found: number;\n  hit: number;\n  details: CoverInfoFunctionsDetails[];\n}\n\nexport interface CoverInfoFunctionsDetails {\n  line: number;\n  hit: number;\n  name: string;\n}\n", "export interface CoverInfoBranches {\n  found: number;\n  hit: number;\n  details: CoverInfoBranchesDetails[];\n}\n\nexport interface CoverInfoBranchesDetails {\n  line: number;\n  branch: number;\n  taken: number;\n  block?: number;\n}\n", "export interface JunitFailureInfo {\n  classname: string;\n  name: string;\n  time: string;\n  error: string;\n}\n\nexport interface Junit {\n  tests: number;\n  failures: {\n    count: number;\n    info: JunitFailureInfo[] | undefined;\n  };\n  errors: number;\n  skipped: number;\n  time: string;\n}\n"]}
{"filename": "src/commentCoverage.ts", "chunked_list": ["import * as core from '@actions/core';\nimport { context, getOctokit } from '@actions/github';\nimport { DiffInfo, EventInfo, Junit } from './types';\n\nexport const commentCoverage = async (\n  eventInfo: EventInfo,\n  body: string,\n): Promise<void> => {\n  const { eventName, payload } = context;\n  const octokit = getOctokit(eventInfo.token);", "  const { eventName, payload } = context;\n  const octokit = getOctokit(eventInfo.token);\n\n  if (eventName === 'push') {\n    await octokit.rest.repos.createCommitComment({\n      repo: eventInfo.repo,\n      owner: eventInfo.owner,\n      commit_sha: eventInfo.commitSha,\n      body,\n    });\n  } else if (eventName === 'pull_request') {", "  } else if (eventName === 'pull_request') {\n    if (eventInfo.overrideComment) {\n      const { data: comments } = await octokit.rest.issues.listComments({\n        repo: eventInfo.repo,\n        owner: eventInfo.owner,\n        issue_number: payload.pull_request ? payload.pull_request.number : 0,\n      });\n\n      const comment = comments.find(\n        (comment) =>\n          comment.user?.login === 'github-actions[bot]' &&\n          comment.body?.startsWith(eventInfo.commentId),\n      );\n", "      if (comment) {\n        await octokit.rest.issues.updateComment({\n          repo: eventInfo.repo,\n          owner: eventInfo.owner,\n          comment_id: comment.id,\n          body,\n        });\n      } else {\n        await octokit.rest.issues.createComment({\n          repo: eventInfo.repo,\n          owner: eventInfo.owner,\n          issue_number: payload.pull_request?.number || 0,\n          body,\n        });\n      }\n    } else {\n      await octokit.rest.issues.createComment({\n        repo: eventInfo.repo,\n        owner: eventInfo.owner,\n        issue_number: payload.pull_request?.number || 0,\n        body,\n      });\n    }\n  }\n};\n\nexport const buildBody = (\n  eventInfo: EventInfo,\n  junitInfo: Junit | undefined,\n  diffsInfo: DiffInfo[],\n): string => {\n  let body = `${eventInfo.commentId}\\n`;\n  body += `## ${eventInfo.commentTitle} :page_facing_up:\\n`;\n  body += buildTestsStatusMarkdown(junitInfo);\n  body += buildJunitMarkdown(eventInfo, junitInfo);\n  body += buildDiffCoverHtml(eventInfo, diffsInfo);\n  return body;\n};\n\nconst buildTestsStatusMarkdown = (junitInfo: Junit | undefined) => {", "  if (junitInfo) {\n    const markdown =\n      junitInfo.failures?.count || junitInfo.errors\n        ? '### Tests Failure :x:'\n        : '### Tests Succees :white_check_mark:';\n    return `${markdown}\\n`;\n  }\n  return '';\n};\n\nconst buildJunitMarkdown = (eventInfo: EventInfo, junitInfo: Junit | undefined) => {", "  if (eventInfo.showJunit && junitInfo) {\n    let markdown = `| Total Tests | Failures ${\n      junitInfo.failures.count ? ':x:' : ''\n    } | Errors ${junitInfo.errors ? ':x:' : ''} | Skipped ${\n      junitInfo.skipped ? ':no_entry_sign:' : ''\n    } | Time :hourglass_flowing_sand: |\\n`;\n    markdown +=\n      '| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n';\n    markdown += `| ${junitInfo.tests} | ${junitInfo.failures.count} | ${junitInfo.errors} | ${junitInfo.skipped} | ${junitInfo.time} |\\n`;\n\n    if (\n      eventInfo.showFailuresInfo &&\n      junitInfo.failures.count > 0 &&\n      junitInfo.failures.info\n    ) {\n      markdown += `<details><table><summary><b>Failures Details</b>\\n\\n</summary><tr><th>File</th><th>Test Name</th><th>Error Message</th></tr>`;", "    if (\n      eventInfo.showFailuresInfo &&\n      junitInfo.failures.count > 0 &&\n      junitInfo.failures.info\n    ) {\n      markdown += `<details><table><summary><b>Failures Details</b>\\n\\n</summary><tr><th>File</th><th>Test Name</th><th>Error Message</th></tr>`;\n      for (const failure of junitInfo.failures.info) {\n        markdown += `<tr><td>TODO</td><td>${failure.name}</td><td>${failure.error}</td></tr>`;\n      }\n      markdown += '</table></details>\\n';\n    }\n    // markdown += `\\nThis is a [hover text](## \"your hover text\") example.`;\n    return '### JUnit Details\\n' + markdown + '\\n';\n  }", "  if (eventInfo.showJunit && !junitInfo) {\n    return 'No JUnit details to present\\n';\n  }\n  return '';\n};\n\nconst buildDiffCoverHtml = (eventInfo: EventInfo, diffsInfo: DiffInfo[]) => {\n  if (!eventInfo.showDiffcover) {\n    return '';\n  } else {\n    if (diffsInfo.length === 0) {\n      return `### Coverage Details :ballot_box_with_check:\\nNo coverage details to present`;\n    } else {\n      let html = `<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr>`;\n      let totalLines = 0;\n      let totalMissing = 0;", "    if (diffsInfo.length === 0) {\n      return `### Coverage Details :ballot_box_with_check:\\nNo coverage details to present`;\n    } else {\n      let html = `<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr>`;\n      let totalLines = 0;\n      let totalMissing = 0;\n      for (const diffInfo of diffsInfo) {\n        if (diffInfo.changedLines.length > 0) {\n          const href = `https://github.com/${eventInfo.owner}/${eventInfo.repo}/blob/${eventInfo.commitSha}/${diffInfo.file}`;\n          const fileWithHref = `<a href=\"${href}\">${diffInfo.file}</a>`;\n          const lines = diffInfo.changedLines.length;\n          totalLines += lines;\n          const missed = diffInfo.missedLines.length;\n          totalMissing += missed;\n          const covered = lines - missed;\n          const percentage = Math.round((covered / lines) * 100);\n          const missedRanges: string[] = getMissedWithRanges(diffInfo);\n          const missedRangesWithHref = missedRanges.map((missed) => {\n            const range = missed\n              .split('-')\n              .map((val) => `L${val}`)\n              .join('-');\n            return `<a href=\"${href}#${range}\">${missed}</a>`;\n          });\n          html += `<tr><td>${fileWithHref}</td><td>${covered}/${lines}</td><td>${percentage}%</td><td>${missedRangesWithHref}</td></tr>`;\n        }\n      }\n      const totalCovered = totalLines - totalMissing;\n      const totalPercentage = Math.round((totalCovered / totalLines) * 100);", "      if (isNaN(totalPercentage)) {\n        return '';\n      }\n      html += `<tr><td>Total</td><td>${totalCovered}/${totalLines}</td><td>${totalPercentage}%</td><td></td></tr>`;\n      html += '</table></details>';\n      if (\n        eventInfo.failUnderCoveragePercentage &&\n        totalPercentage < +eventInfo.minCoveragePercentage\n      ) {\n        core.setFailed('low coverage');\n      }\n      return (\n        `### Coverage Details ${\n          totalPercentage >= +eventInfo.minCoveragePercentage\n            ? `(${totalPercentage}% >= ${eventInfo.minCoveragePercentage}%) :white_check_mark:`\n            : `(${totalPercentage}% < ${eventInfo.minCoveragePercentage}%) :x:`\n        }\\n\\n` + html\n      );\n    }\n  }\n};\n\nconst getMissedWithRanges = (diffInfo: DiffInfo): string[] => {\n  const missedRanges: string[] = [];\n  let currIndex = 0;", "  for (let i = 0; i < diffInfo.missedLines.length; i++) {\n    if (+diffInfo.missedLines[i] + 1 === +diffInfo.missedLines[i + 1]) {\n      if (missedRanges.length === currIndex) {\n        missedRanges.push(`${diffInfo.missedLines[i]}-`);\n      }\n    } else {\n      if (missedRanges.length !== currIndex) {\n        missedRanges[currIndex] = missedRanges[currIndex] + diffInfo.missedLines[i];\n      } else {\n        missedRanges.push(diffInfo.missedLines[i]);\n      }\n      currIndex++;\n    }\n  }\n  return missedRanges;\n};\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { getChangedFiles } from './changedFiles';\nimport { CoverageTypeInfo, DiffInfo, EventInfo } from './types';\nimport { getEventInfo } from './eventInfo';\nimport { diffCover } from './diffCover';\nimport { parseFile as parseLcovFile } from './parsers/lcov';\nimport { parseFile as parseCoberturaFile } from './parsers/cobertura';\nimport { parseFile as parseCloverFile } from './parsers/clover';\nimport { parseFile as parseJacocoFile } from './parsers/jacoco';\nimport { parse as parseJunit } from './parsers/junit';\nimport { buildBody, commentCoverage } from './commentCoverage';", "import { parse as parseJunit } from './parsers/junit';\nimport { buildBody, commentCoverage } from './commentCoverage';\nimport * as core from '@actions/core';\n\nexport const main = async (): Promise<void> => {\n  try {\n    const eventInfo: EventInfo = getEventInfo();\n    const coverageInfo: CoverageTypeInfo = {\n      cobertura:\n        eventInfo.diffcoverRef === 'cobertura'\n          ? await parseCoberturaFile(eventInfo.coberturaPath, `${eventInfo.pwd}/`)\n          : [],\n      clover:\n        eventInfo.diffcoverRef === 'clover'\n          ? await parseCloverFile(eventInfo.cloverPath)\n          : [],\n      lcov:\n        eventInfo.diffcoverRef === 'lcov' ? await parseLcovFile(eventInfo.lcovPath) : [],\n      jacoco:\n        eventInfo.diffcoverRef === 'jacoco'\n          ? await parseJacocoFile(eventInfo.jacocoPath)\n          : [],\n      junit: eventInfo.showJunit ? await parseJunit(eventInfo.junitPath) : undefined,\n    };\n    const changedFile = await getChangedFiles(eventInfo);\n\n    const diffInfo: DiffInfo[] = await diffCover(eventInfo, changedFile, coverageInfo);\n    await commentCoverage(eventInfo, buildBody(eventInfo, coverageInfo.junit, diffInfo));", "  } catch (error) {\n    core.setFailed(error.message);\n  }\n};\n"]}
{"filename": "src/diffCover.ts", "chunked_list": ["import {\n  FilesStatus,\n  EventInfo,\n  CoverageTypeInfo,\n  DiffInfo,\n  DiffCoverRef,\n} from './types';\nimport { execCommand } from './utils';\nimport * as core from '@actions/core';\n", "import * as core from '@actions/core';\n\nexport const diffCover = async (\n  eventInfo: EventInfo,\n  filesStatus: FilesStatus,\n  coverageInfo: CoverageTypeInfo,\n): Promise<DiffInfo[]> => {\n  if (eventInfo.showDiffcover) {\n    const gitLogCommand = `git log --oneline origin/${eventInfo.baseRef}..origin/${eventInfo.headRef} -- | cut -f1 -d' '`;\n    const gitLogExec = await execCommand(gitLogCommand);\n    if (gitLogExec.status !== 'success') {\n      throw new Error(\n        `failed to retrieve git log: ${eventInfo.baseRef}..${eventInfo.headRef}. error: ${gitLogExec.message}`,\n      );\n    }\n    const commitsSha = gitLogExec.stdout?.split('\\n').filter((sha) => sha) || [];\n    core.info(`commitsSha list:[${commitsSha}]`);\n    const changedFiles = [\n      ...filesStatus.added,\n      ...filesStatus.modified,\n      ...filesStatus.changed,\n    ];\n\n    return getDiff(coverageInfo, changedFiles, commitsSha, eventInfo.diffcoverRef);\n  }\n  return [];\n};\n\nconst getDiff = async (\n  coverageInfo: CoverageTypeInfo,\n  changedFiles: string[],\n  commitsSha: string[],\n  referral: DiffCoverRef,\n): Promise<DiffInfo[]> => {\n  const diffInfo: DiffInfo[] = [];", "    if (gitLogExec.status !== 'success') {\n      throw new Error(\n        `failed to retrieve git log: ${eventInfo.baseRef}..${eventInfo.headRef}. error: ${gitLogExec.message}`,\n      );\n    }\n    const commitsSha = gitLogExec.stdout?.split('\\n').filter((sha) => sha) || [];\n    core.info(`commitsSha list:[${commitsSha}]`);\n    const changedFiles = [\n      ...filesStatus.added,\n      ...filesStatus.modified,\n      ...filesStatus.changed,\n    ];\n\n    return getDiff(coverageInfo, changedFiles, commitsSha, eventInfo.diffcoverRef);\n  }\n  return [];\n};\n\nconst getDiff = async (\n  coverageInfo: CoverageTypeInfo,\n  changedFiles: string[],\n  commitsSha: string[],\n  referral: DiffCoverRef,\n): Promise<DiffInfo[]> => {\n  const diffInfo: DiffInfo[] = [];", "  for (const fileCoverInfo of coverageInfo[referral]) {\n    for (const currFile of changedFiles) {\n      const changedLinesExec = await execCommand(\n        `git blame ${currFile} | grep -n '${commitsSha.join('\\\\|')}' | cut -f1 -d:`,\n      );\n      if (changedLinesExec.status === 'success') {\n        const changedLines =\n          changedLinesExec.stdout?.split('\\n').filter((line) => line) || [];\n        if (changedLines.length) {\n          if (fileCoverInfo.lines.details.length) {\n            if (\n              fileCoverInfo.file === currFile ||\n              currFile.includes(fileCoverInfo.file) ||\n              fileCoverInfo.file.includes(currFile)\n            ) {\n              const misses = changedLines.filter(\n                (changedLine: string) =>\n                  fileCoverInfo.lines.details.find(\n                    (details) => details.line === +changedLine,\n                  )?.hit === 0,\n              );\n              core.info(`diffCover on file=${currFile}`);\n              core.info(`misses: [${misses}]`);\n              core.info(\n                `coverage: ${Math.round(\n                  (1 - misses.length / changedLines.length) * 100,\n                )}%`,\n              );\n              diffInfo.push({\n                file: currFile,\n                missedLines: misses,\n                changedLines: changedLines,\n              });\n            }\n          }\n        }\n      } else {\n        throw new Error(\n          `failed to execute \"git blame\" on file: ${currFile}. error: ${changedLinesExec.message}`,\n        );\n      }\n      // core.info(changedLinesExec.stdout);\n    }\n  }\n  return diffInfo;\n};\n", "        if (changedLines.length) {\n          if (fileCoverInfo.lines.details.length) {\n            if (\n              fileCoverInfo.file === currFile ||\n              currFile.includes(fileCoverInfo.file) ||\n              fileCoverInfo.file.includes(currFile)\n            ) {\n              const misses = changedLines.filter(\n                (changedLine: string) =>\n                  fileCoverInfo.lines.details.find(\n                    (details) => details.line === +changedLine,\n                  )?.hit === 0,\n              );\n              core.info(`diffCover on file=${currFile}`);\n              core.info(`misses: [${misses}]`);\n              core.info(\n                `coverage: ${Math.round(\n                  (1 - misses.length / changedLines.length) * 100,\n                )}%`,\n              );\n              diffInfo.push({\n                file: currFile,\n                missedLines: misses,\n                changedLines: changedLines,\n              });\n            }\n          }\n        }\n      } else {\n        throw new Error(\n          `failed to execute \"git blame\" on file: ${currFile}. error: ${changedLinesExec.message}`,\n        );\n      }\n      // core.info(changedLinesExec.stdout);\n    }\n  }\n  return diffInfo;\n};\n"]}
{"filename": "src/eventInfo.ts", "chunked_list": ["import * as core from '@actions/core';\nimport { DiffCoverRef, EventInfo } from './types';\nimport { context } from '@actions/github';\n\nexport const getEventInfo = (): EventInfo => {\n  const eventInfo: EventInfo = {\n    token: core.getInput('github-token', { required: true }),\n    commentTitle: core.getInput('title', { required: false }),\n    owner: context.repo.owner,\n    repo: context.repo.repo,", "    owner: context.repo.owner,\n    repo: context.repo.repo,\n    coberturaPath: core.getInput('cobertura-path', { required: false }),\n    cloverPath: core.getInput('clover-path', { required: false }),\n    lcovPath: core.getInput('lcov-path', { required: false }),\n    jacocoPath: core.getInput('jacoco-path', { required: false }),\n    junitPath: core.getInput('junit-path', { required: false }),\n    showJunit: core.getBooleanInput('show-junit', { required: false }),\n    showDiffcover: core.getBooleanInput('show-diffcover', { required: false }),\n    minCoveragePercentage: core.getInput('min-coverage-percentage', { required: false }),", "    showDiffcover: core.getBooleanInput('show-diffcover', { required: false }),\n    minCoveragePercentage: core.getInput('min-coverage-percentage', { required: false }),\n    failUnderCoveragePercentage: core.getBooleanInput('fail-under-coverage-percentage', {\n      required: false,\n    }),\n    showFailuresInfo: core.getBooleanInput('show-failures-info', { required: false }),\n    overrideComment: core.getBooleanInput('override-comment', { required: false }),\n    commentId: '<!-- tests-coverage-report -->',\n    diffcoverRef: core.getInput('diffcover-ref', { required: false }) as DiffCoverRef,\n    commitSha: '',", "    diffcoverRef: core.getInput('diffcover-ref', { required: false }) as DiffCoverRef,\n    commitSha: '',\n    headRef: '',\n    baseRef: '',\n    pwd: process.env.GITHUB_WORKSPACE || '',\n  };\n  if (context.eventName === 'pull_request' && context.payload) {\n    eventInfo.commitSha = context.payload.pull_request?.head.sha;\n    eventInfo.headRef = context.payload.pull_request?.head.ref;\n    eventInfo.baseRef = context.payload.pull_request?.base.ref;\n  } else if (context.eventName === 'push') {\n    eventInfo.commitSha = context.payload.after;\n    eventInfo.headRef = context.ref;\n  }\n  return eventInfo;\n};\n", "  } else if (context.eventName === 'push') {\n    eventInfo.commitSha = context.payload.after;\n    eventInfo.headRef = context.ref;\n  }\n  return eventInfo;\n};\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { exec, ExecException } from 'node:child_process';\nimport * as core from '@actions/core';\n\nexport interface ExecInfo {\n  status: 'error' | 'success';\n  message?: string;\n  errorCode?: number;\n  stdout?: string;\n}\n\nexport const execCommand = async (command: string): Promise<ExecInfo> => {\n  return new Promise((resolve) => {\n    exec(command, (error: ExecException | null, stdout: string) => {", "      if (error) {\n        core.error(`could not execute command: ${command}. error: ${error.message}`);\n        return resolve({\n          status: 'error',\n          message: error.message,\n          errorCode: error.code,\n        });\n      }\n      resolve({\n        status: 'success',\n        stdout,\n      });\n    });\n  });\n};\n"]}
{"filename": "src/index.ts", "chunked_list": ["import * as core from '@actions/core';\nimport { main } from './main';\n\nmain()\n  .then(() => {\n    core.info('success');\n  })\n  .catch((err) => {\n    core.error(`exception. ${err.message}`);\n  });\n"]}
{"filename": "src/changedFiles.ts", "chunked_list": ["import { getOctokit } from '@actions/github';\nimport { FilesStatus, EventInfo } from './types';\n\nexport const getChangedFiles = async (eventInfo: EventInfo): Promise<FilesStatus> => {\n  const allFiles: FilesStatus = {\n    all: [],\n    added: [],\n    removed: [],\n    modified: [],\n    renamed: [],", "    modified: [],\n    renamed: [],\n    copied: [],\n    changed: [],\n    unchanged: [],\n  };\n  const octokit = getOctokit(eventInfo.token);\n\n  let pages = 1;\n  const pagedFiles = [];\n  for (let currPage = 1; currPage <= pages; currPage++) {\n    const {\n      data: { total_commits, files },\n    } = await octokit.rest.repos.compareCommitsWithBasehead({\n      owner: eventInfo.owner,\n      repo: eventInfo.repo,\n      basehead: `${eventInfo.baseRef}...${eventInfo.headRef}`,\n      per_page: 50,\n      page: currPage,\n    });", "  let pages = 1;\n  const pagedFiles = [];\n  for (let currPage = 1; currPage <= pages; currPage++) {\n    const {\n      data: { total_commits, files },\n    } = await octokit.rest.repos.compareCommitsWithBasehead({\n      owner: eventInfo.owner,\n      repo: eventInfo.repo,\n      basehead: `${eventInfo.baseRef}...${eventInfo.headRef}`,\n      per_page: 50,\n      page: currPage,\n    });", "    if (files) {\n      pages = Math.ceil(total_commits / 50);\n      for (const file of files) {\n        allFiles.all.push(file.filename);\n        allFiles[`${file.status}`].push(file.filename);\n      }\n      pagedFiles.push(...files);\n    }\n  }\n  return allFiles;\n};\n"]}
{"filename": "src/parsers/cobertura.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport fs from 'fs';\nimport path from 'path';\nimport { CoverInfo, CoverInfoBranchesDetails } from '../types';\nimport parseString from 'xml2js';\nimport * as core from '@actions/core';\n\nconst classesFromPackages = (packages: any) => {\n  const classes: any[] = [];\n", "  const classes: any[] = [];\n\n  packages.forEach((packages: any) => {\n    packages.package.forEach((pack: any) => {\n      pack.classes.forEach((c: any) => {\n        classes.push(...c.class);\n      });\n    });\n  });\n", "  });\n\n  return classes;\n};\n\nconst extractLcovStyleBranches = (c: any) => {\n  const branches: CoverInfoBranchesDetails[] = [];\n\n  if (c.lines && c.lines[0].line) {\n    c.lines[0].line.forEach((l: any) => {\n      if (l.$.branch == 'true') {\n        const branchFraction = l.$['condition-coverage'].split(' ');\n        const branchStats = branchFraction[1].match(/\\d+/g);\n        const coveredBranches = Number(branchStats[0]);\n        const totalBranches = Number(branchStats[1]);\n        const leftBranches = totalBranches - coveredBranches;\n        let branchNumber = 0;\n", "  if (c.lines && c.lines[0].line) {\n    c.lines[0].line.forEach((l: any) => {\n      if (l.$.branch == 'true') {\n        const branchFraction = l.$['condition-coverage'].split(' ');\n        const branchStats = branchFraction[1].match(/\\d+/g);\n        const coveredBranches = Number(branchStats[0]);\n        const totalBranches = Number(branchStats[1]);\n        const leftBranches = totalBranches - coveredBranches;\n        let branchNumber = 0;\n\n        for (let i = 0; i < leftBranches; i++) {\n          branches.push({\n            line: Number(l.$.number),\n            branch: branchNumber,\n            taken: 0,\n          });\n          branchNumber++;\n        }\n", "        for (let i = 0; i < leftBranches; i++) {\n          branches.push({\n            line: Number(l.$.number),\n            branch: branchNumber,\n            taken: 0,\n          });\n          branchNumber++;\n        }\n\n        for (let i = 0; i < coveredBranches; i++) {\n          branches.push({\n            line: Number(l.$.number),\n            branch: branchNumber,\n            taken: 1,\n          });\n          branchNumber++;\n        }\n      }\n    });\n  }\n\n  return branches;\n};\n\nconst unpackage = (coverage: any, pwd: string): CoverInfo[] => {\n  const packages = coverage.packages;\n  const source = coverage.sources[0].source[0];\n\n  const classes = classesFromPackages(packages);\n  return classes.map((c) => {\n    const branches = extractLcovStyleBranches(c);\n    const classCov: CoverInfo = {\n      title: c.$.name,\n      // file: c.$.filename,\n      file: path.join(source, c.$.filename).replace(pwd, ''),\n      functions: {\n        found: c.methods && c.methods[0].method ? c.methods[0].method.length : 0,\n        hit: 0,\n        details:\n          !c.methods || !c.methods[0].method\n            ? []\n            : c.methods[0].method.map((m: any) => {\n                return {\n                  name: m.$.name,\n                  line: Number(m.lines[0].line[0].$.number),\n                  hit: Number(m.lines[0].line[0].$.hits),\n                };\n              }),\n      },\n      lines: {\n        found: c.lines && c.lines[0].line ? c.lines[0].line.length : 0,\n        hit: 0,\n        details:\n          !c.lines || !c.lines[0].line\n            ? []\n            : c.lines[0].line.map((l: any) => {\n                return {\n                  line: Number(l.$.number),\n                  hit: Number(l.$.hits),\n                };\n              }),\n      },\n      branches: {\n        found: branches.length,\n        hit: branches.filter((br) => {\n          return br.taken > 0;\n        }).length,\n        details: branches,\n      },\n    };\n\n    classCov.functions.hit = classCov.functions.details.reduce((acc: any, val: any) => {\n      return acc + (val.hit > 0 ? 1 : 0);\n    }, 0);\n\n    classCov.lines.hit = classCov.lines.details.reduce((acc: any, val: any) => {\n      return acc + (val.hit > 0 ? 1 : 0);\n    }, 0);\n\n    return classCov;\n  });\n};\n\nconst parseContent = (xml: string, pwd: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {\n    parseString.parseString(xml, (err, parseResult) => {", "        for (let i = 0; i < coveredBranches; i++) {\n          branches.push({\n            line: Number(l.$.number),\n            branch: branchNumber,\n            taken: 1,\n          });\n          branchNumber++;\n        }\n      }\n    });\n  }\n\n  return branches;\n};\n\nconst unpackage = (coverage: any, pwd: string): CoverInfo[] => {\n  const packages = coverage.packages;\n  const source = coverage.sources[0].source[0];\n\n  const classes = classesFromPackages(packages);\n  return classes.map((c) => {\n    const branches = extractLcovStyleBranches(c);\n    const classCov: CoverInfo = {\n      title: c.$.name,\n      // file: c.$.filename,\n      file: path.join(source, c.$.filename).replace(pwd, ''),\n      functions: {\n        found: c.methods && c.methods[0].method ? c.methods[0].method.length : 0,\n        hit: 0,\n        details:\n          !c.methods || !c.methods[0].method\n            ? []\n            : c.methods[0].method.map((m: any) => {\n                return {\n                  name: m.$.name,\n                  line: Number(m.lines[0].line[0].$.number),\n                  hit: Number(m.lines[0].line[0].$.hits),\n                };\n              }),\n      },\n      lines: {\n        found: c.lines && c.lines[0].line ? c.lines[0].line.length : 0,\n        hit: 0,\n        details:\n          !c.lines || !c.lines[0].line\n            ? []\n            : c.lines[0].line.map((l: any) => {\n                return {\n                  line: Number(l.$.number),\n                  hit: Number(l.$.hits),\n                };\n              }),\n      },\n      branches: {\n        found: branches.length,\n        hit: branches.filter((br) => {\n          return br.taken > 0;\n        }).length,\n        details: branches,\n      },\n    };\n\n    classCov.functions.hit = classCov.functions.details.reduce((acc: any, val: any) => {\n      return acc + (val.hit > 0 ? 1 : 0);\n    }, 0);\n\n    classCov.lines.hit = classCov.lines.details.reduce((acc: any, val: any) => {\n      return acc + (val.hit > 0 ? 1 : 0);\n    }, 0);\n\n    return classCov;\n  });\n};\n\nconst parseContent = (xml: string, pwd: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {\n    parseString.parseString(xml, (err, parseResult) => {", "      if (err) {\n        return reject(err);\n      }\n      if (!parseResult?.coverage) {\n        return reject(new Error('invalid or missing xml content'));\n      }\n      const result = unpackage(parseResult.coverage, pwd);\n      resolve(result);\n    });\n  });\n};\n\nexport const parseFile = async (file: string, pwd: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {", "    if (!file || file === '') {\n      core.info('no cobertura file specified');\n      resolve([]);\n    } else {\n      fs.readFile(\n        file,\n        'utf8',\n        async (err: NodeJS.ErrnoException | null, data: string) => {\n          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {", "          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {\n            try {\n              const info = await parseContent(data, pwd);\n              // console.log('====== cobertura ======');\n              // console.log(JSON.stringify(info, null, 2));\n              resolve(info);\n            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n};\n", "            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n};\n"]}
{"filename": "src/parsers/clover.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport fs from 'fs';\nimport { CoverInfo, CoverInfoFunctionsDetails, CoverInfoLinesDetails } from '../types';\nimport parseString from 'xml2js';\nimport * as core from '@actions/core';\n\nconst classDetailsFromProjects = (projects: any) => {\n  let classDetails: any[] = [];\n  let packageName = null;\n", "  let packageName = null;\n\n  const parseFileObject = (fileObj: any, packageName: string) => {\n    if (fileObj.class) {\n      fileObj['class'].forEach((classObj: any) => {\n        classDetails = classDetails.concat({\n          name: classObj.$.name,\n          metrics: classObj.metrics[0],\n          fileName: fileObj.$.name,\n          fileMetrics: fileObj.metrics[0],\n          lines: fileObj.line,\n          packageName: packageName,\n        });\n      });\n    } else {\n      classDetails = classDetails.concat({\n        name: null,\n        metrics: null,\n        fileName: fileObj.$.name,\n        fileMetrics: fileObj.metrics[0],\n        lines: fileObj.line,\n        packageName: packageName,\n      });\n    }\n  };\n\n  projects.forEach((projectObj: any) => {", "    if (projectObj.package) {\n      projectObj.package.forEach((data: any) => {\n        if (data.$?.name) {\n          packageName = data.$.name;\n        } else {\n          packageName = null;\n        }\n        data.file.forEach(parseFileObject);\n      });\n    }\n    if (projectObj.file) {\n      packageName = null;\n      projectObj.file.forEach(parseFileObject);\n    }\n  });\n  return classDetails;\n};\n\nconst unpackage = (projects: any): CoverInfo[] => {\n  const classDetails = classDetailsFromProjects(projects);\n\n  return classDetails.map((c: any) => {\n    const methodStats: CoverInfoFunctionsDetails[] = [];\n    const lineStats: CoverInfoLinesDetails[] = [];\n", "    if (projectObj.file) {\n      packageName = null;\n      projectObj.file.forEach(parseFileObject);\n    }\n  });\n  return classDetails;\n};\n\nconst unpackage = (projects: any): CoverInfo[] => {\n  const classDetails = classDetailsFromProjects(projects);\n\n  return classDetails.map((c: any) => {\n    const methodStats: CoverInfoFunctionsDetails[] = [];\n    const lineStats: CoverInfoLinesDetails[] = [];\n", "    if (c.lines) {\n      c.lines.forEach((l: any) => {\n        if (l.$.type === 'method') {\n          methodStats.push({\n            name: l.$.name,\n            line: Number(l.$.num),\n            hit: Number(l.$.count),\n          });\n        } else {\n          lineStats.push({\n            line: Number(l.$.num),\n            hit: Number(l.$.count),\n          });\n        }\n      });\n    }\n\n    const classCov: CoverInfo = {\n      title: c.name,\n      file: c.fileName,\n      functions: {\n        found: methodStats.length,\n        hit: 0,\n        details: methodStats,\n      },\n      lines: {\n        found: lineStats.length,\n        hit: 0,\n        details: lineStats,\n      },\n      branches: {\n        found: 0,\n        hit: 0,\n        details: [],\n      },\n    };\n\n    classCov.functions.hit = classCov.functions.details.reduce((acc, val) => {\n      return acc + (val.hit > 0 ? 1 : 0);\n    }, 0);\n\n    classCov.lines.hit = classCov.lines.details.reduce((acc, val) => {\n      return acc + (val.hit > 0 ? 1 : 0);\n    }, 0);\n\n    return classCov;\n  });\n};\n\nconst parseContent = (xml: any): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {\n    parseString.parseString(xml, (err, parseResult) => {", "      if (err) {\n        reject(err);\n      }\n      if (!parseResult?.coverage?.project) {\n        return reject(new Error('invalid or missing xml content'));\n      }\n      const result = unpackage(parseResult.coverage.project);\n      resolve(result);\n    });\n  });\n};\n\nexport const parseFile = async (file: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {", "    if (!file || file === '') {\n      core.info('no clover file specified');\n      resolve([]);\n    } else {\n      fs.readFile(\n        file,\n        'utf8',\n        async (err: NodeJS.ErrnoException | null, data: string) => {\n          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {", "          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {\n            try {\n              const info = await parseContent(data);\n              // console.log('====== clover ======');\n              // console.log(JSON.stringify(info, null, 2));\n              resolve(info);\n            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n};\n", "            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n};\n"]}
{"filename": "src/parsers/junit.ts", "chunked_list": ["/* eslint-disable  @typescript-eslint/no-explicit-any */\nimport fs from 'fs';\nimport { Junit, JunitFailureInfo } from '../types';\nimport parseString from 'xml2js';\nimport * as core from '@actions/core';\n\nconst unpackage = (testsuites: any): Junit => {\n  const main = testsuites['$'] || testsuites.testsuite[0]['$'];\n  const testsuite: any[] = testsuites.testsuite;\n", "  const testsuite: any[] = testsuites.testsuite;\n\n  const errors =\n    testsuite\n      ?.map((test: any) => +test['$'].errors)\n      .reduce((acc: number, curr: number) => acc + curr, 0) || 0;\n\n  const skipped =\n    testsuite\n      ?.map((test: any) => +test['$'].skipped)", "    testsuite\n      ?.map((test: any) => +test['$'].skipped)\n      .reduce((acc: number, curr: number) => acc + curr, 0) || 0;\n\n  const testSuiteFailures = testsuite?.filter((test: any) => +test['$'].failures > 0);\n  const failureCase: JunitFailureInfo[] | undefined = testSuiteFailures\n    .map((testSuiteFailure: any) => {\n      const testCaseFailures: any[] = testSuiteFailure.testcase.filter(\n        (testCase: any) => testCase.failure,\n      );", "        (testCase: any) => testCase.failure,\n      );\n      return testCaseFailures.map((testCaseFailure: any) => ({\n        classname: testCaseFailure['$'].classname.trim(),\n        name: testCaseFailure['$'].name.trim(),\n        time: `${parseFloat(testCaseFailure['$'].time).toFixed(2)}s`,\n        error: getTestFailureMessage(testCaseFailure),\n      }));\n    })\n    .flat();", "    })\n    .flat();\n\n  return {\n    tests: +main.tests,\n    failures: {\n      count: +main.failures,\n      info: failureCase,\n    },\n    errors: +main.errors || errors,", "    },\n    errors: +main.errors || errors,\n    skipped,\n    time: `${parseFloat(main.time).toFixed(2)}s`,\n  };\n};\n\nconst getTestFailureMessage = (testCaseFailure: any): string => {\n  const failure = testCaseFailure?.failure?.[0];\n  if (failure) {\n    if (typeof failure === 'string') {\n      return failure.split('\\n')?.[0]?.trim() || 'unhandled string error';", "  const failure = testCaseFailure?.failure?.[0];\n  if (failure) {\n    if (typeof failure === 'string') {\n      return failure.split('\\n')?.[0]?.trim() || 'unhandled string error';\n    } else if (typeof failure === 'object') {\n      return failure['$']?.message || failure.message || 'unhandled object error';\n    }\n  }\n  return 'unknown failure';\n};\n\nconst parseContent = (xml: string): Promise<Junit> => {\n  return new Promise((resolve, reject) => {\n    parseString.parseString(xml, (err, parseResult) => {", "      if (err) {\n        return reject(err);\n      }\n      if (!parseResult?.testsuites) {\n        return reject(new Error('invalid or missing xml content'));\n      }\n      const result = unpackage(parseResult.testsuites);\n      resolve(result);\n    });\n  });\n};\n\nexport const parse = async (path: string): Promise<Junit | undefined> => {", "  if (!path || path === '') {\n    core.info('no junit file/folder specified');\n    return undefined;\n  }\n  if (fs.lstatSync(path).isFile()) {\n    return parseFile(path);\n  } else if (fs.lstatSync(path).isDirectory()) {\n    return parseFolder(path);\n  }\n};\n\nconst parseFile = async (file: string): Promise<Junit | undefined> => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, 'utf8', async (err: NodeJS.ErrnoException | null, data: string) => {", "      if (err) {\n        core.error(`failed to read file: ${file}. error: ${err.message}`);\n        reject(err);\n      } else {\n        try {\n          const info = await parseContent(data);\n          // console.log('====== junit ======');\n          // console.log(JSON.stringify(info, null, 2));\n          resolve(info);\n        } catch (error) {\n          core.error(`failed to parseContent. err: ${error.message}`);\n          reject(error);\n        }\n      }\n    });\n  });\n};\n\nconst parseFolder = async (folder: string): Promise<Junit | undefined> => {\n  const mergedTestSuites: any = {\n    $: {},\n    testsuite: [],\n  };\n  const files = fs.readdirSync(folder);", "        } catch (error) {\n          core.error(`failed to parseContent. err: ${error.message}`);\n          reject(error);\n        }\n      }\n    });\n  });\n};\n\nconst parseFolder = async (folder: string): Promise<Junit | undefined> => {\n  const mergedTestSuites: any = {\n    $: {},\n    testsuite: [],\n  };\n  const files = fs.readdirSync(folder);", "  for (const file of files) {\n    try {\n      if (file.endsWith('.xml')) {\n        const filePath = `${folder}/${file}`;\n        const testSuiteArray = await getTestsuiteList(filePath);\n        if (testSuiteArray.length === 0) {\n          core.warning(`No tests found in file: ${filePath}`);\n        } else {\n          mergedTestSuites.testsuite.push(...testSuiteArray);\n        }\n      }", "    } catch (error) {\n      core.error(\n        `failed to parse folder file: ${folder}/${file}. error: ${error.message}`,\n      );\n    }\n  }\n  mergedTestSuites.$ = buildMainContent(mergedTestSuites.testsuite);\n  return unpackage(mergedTestSuites);\n};\n\nconst getTestsuiteList = async (filename: string) => {", "  try {\n    const testsuiteList: any[] = [];\n    const xmlContent = fs.readFileSync(filename, 'utf8');\n    const parseResult = await parseString.parseStringPromise(xmlContent);\n    if (Object.keys(parseResult)?.[0] === 'testsuite') {\n      testsuiteList.push(parseResult.testsuite);\n    } else if (Object.keys(parseResult)?.[0] === 'testsuites') {\n      for (const testsuite of parseResult.testsuites.testsuite) {\n        testsuiteList.push(testsuite);\n      }\n    }\n    return testsuiteList;", "  } catch (error) {\n    core.error(`failed to read file: ${filename}. error: ${error.message}`);\n    return [];\n  }\n};\n\nconst buildMainContent = (testSuiteList: any[]) => {\n  const main = {\n    tests: 0,\n    failures: 0,\n    errors: 0,\n    skipped: 0,\n    name: '',\n    time: 0,\n  };", "  for (const testSuite of testSuiteList) {\n    main.tests += +testSuite.$.tests;\n    main.failures += +testSuite.$.failures;\n    main.errors += +testSuite.$.errors;\n    main.skipped += +testSuite.$.skipped;\n    if (main.time < +testSuite.$.time) {\n      main.time = +testSuite.$.time;\n    }\n  }\n  return {\n    tests: `${main.tests}`,\n    failures: `${main.failures}`,\n    errors: `${main.errors}`,\n    skipped: `${main.skipped}`,\n    name: '',\n    time: `${main.time}`,\n  };\n};\n"]}
{"filename": "src/parsers/jacoco.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport fs from 'fs';\nimport { CoverInfo } from '../types';\nimport parseString from 'xml2js';\nimport * as core from '@actions/core';\n\nconst getCounter = (source: any, type: string) => {\n  source.counter = source.counter || [];\n  return (\n    source.counter.filter((counter: any) => {", "  return (\n    source.counter.filter((counter: any) => {\n      return counter.$.type === type;\n    })[0] || {\n      $: {\n        covered: 0,\n        missed: 0,\n      },\n    }\n  );", "    }\n  );\n};\n\nconst unpackage = (report: any): CoverInfo[] => {\n  const packages = report.package;\n\n  let output: CoverInfo[] = [];\n\n  packages.forEach((pack: any) => {", "\n  packages.forEach((pack: any) => {\n    const cov = pack.sourcefile.map((source: any) => {\n      const fullPath = pack.$.name + '/' + source.$.name;\n\n      const methods = getCounter(source, 'METHOD');\n      const lines = getCounter(source, 'LINE');\n      const branches = getCounter(source, 'BRANCH');\n\n      const classCov: CoverInfo = {", "\n      const classCov: CoverInfo = {\n        title: source.$.name,\n        file: fullPath,\n        functions: {\n          found: Number(methods.$.covered) + Number(methods.$.missed),\n          hit: Number(methods.$.covered),\n          details: pack.class.reduce((result: any, currentClass: any) => {\n            return !currentClass.method\n              ? result", "            return !currentClass.method\n              ? result\n              : result.concat(\n                  currentClass.method.map((method: any) => {\n                    const hit = method.counter.some((counter: any) => {\n                      return counter.$.type === 'METHOD' && counter.$.covered === '1';\n                    });\n                    return {\n                      name: method.$.name,\n                      line: Number(method.$.line),", "                      name: method.$.name,\n                      line: Number(method.$.line),\n                      hit: hit ? 1 : 0,\n                    };\n                  }),\n                );\n          }, []),\n        },\n        lines: {\n          found: Number(lines.$.covered) + Number(lines.$.missed),", "        lines: {\n          found: Number(lines.$.covered) + Number(lines.$.missed),\n          hit: Number(lines.$.covered),\n          details: !source.line\n            ? []\n            : source.line.map((l: any) => {\n                return {\n                  line: Number(l.$.nr),\n                  hit: Number(l.$.ci),\n                };", "                  hit: Number(l.$.ci),\n                };\n              }),\n        },\n        branches: {\n          found: Number(branches.$.covered) + Number(branches.$.missed),\n          hit: Number(branches.$.covered),\n          details:\n            source.line\n              ?.filter((l: any) => {", "            source.line\n              ?.filter((l: any) => {\n                return Number(l.$.mb) > 0 || Number(l.$.cb) > 0;\n              })\n              .map((l: any) => {\n                let branches: any[] = [];\n                const count = Number(l.$.mb) + Number(l.$.cb);\n\n                for (let i = 0; i < count; ++i) {\n                  branches = branches.concat({\n                    line: Number(l.$.nr),\n                    block: 0,\n                    branch: Number(i),\n                    taken: i < Number(l.$.cb) ? 1 : 0,\n                  });\n                }\n                return branches;\n              })\n              .flat() || [],\n        },\n      };\n\n      return classCov;\n    });\n\n    output = output.concat(cov);\n  });\n\n  return output;\n};\n\nconst parseContent = (xml: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {\n    parseString.parseString(xml, (err, parseResult) => {", "                for (let i = 0; i < count; ++i) {\n                  branches = branches.concat({\n                    line: Number(l.$.nr),\n                    block: 0,\n                    branch: Number(i),\n                    taken: i < Number(l.$.cb) ? 1 : 0,\n                  });\n                }\n                return branches;\n              })\n              .flat() || [],\n        },\n      };\n\n      return classCov;\n    });\n\n    output = output.concat(cov);\n  });\n\n  return output;\n};\n\nconst parseContent = (xml: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {\n    parseString.parseString(xml, (err, parseResult) => {", "      if (err) {\n        return reject(err);\n      }\n      if (!parseResult?.report) {\n        return reject(new Error('invalid or missing xml content'));\n      }\n      const result = unpackage(parseResult.report);\n      resolve(result);\n    });\n  });\n};\n\nexport const parseFile = async (file: string): Promise<CoverInfo[]> => {\n  return new Promise((resolve, reject) => {", "    if (!file || file === '') {\n      core.info('no jacoco file specified');\n      resolve([]);\n    } else {\n      fs.readFile(\n        file,\n        'utf8',\n        async (err: NodeJS.ErrnoException | null, data: string) => {\n          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {", "          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {\n            try {\n              const info = await parseContent(data);\n              // console.log('====== jacoco ======');\n              // console.log(JSON.stringify(info, null, 2));\n              resolve(info);\n            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n};\n", "            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n};\n"]}
{"filename": "src/parsers/lcov.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport fs from 'fs';\nimport { CoverInfo } from '../types';\nimport * as core from '@actions/core';\n\nconst parseContent = (str: string): CoverInfo[] => {\n  const data: any[] = [];\n  let item: CoverInfo;\n\n  ['end_of_record'].concat(str.split('\\n')).forEach((line: string) => {", "\n  ['end_of_record'].concat(str.split('\\n')).forEach((line: string) => {\n    line = line.trim();\n    const allparts: string[] = line.split(':') || [];\n    const parts: string[] = [allparts.shift() || '', allparts.join(':')];\n    let lines: any[];\n    let fn: any;\n\n    switch (parts[0].toUpperCase()) {\n      case 'TN':", "    switch (parts[0].toUpperCase()) {\n      case 'TN':\n        item.title = parts[1].trim();\n        break;\n      case 'SF':\n        item.file = parts.slice(1).join(':').trim();\n        break;\n      case 'FNF':\n        item.functions.found = Number(parts[1].trim());\n        break;", "        item.functions.found = Number(parts[1].trim());\n        break;\n      case 'FNH':\n        item.functions.hit = Number(parts[1].trim());\n        break;\n      case 'LF':\n        item.lines.found = Number(parts[1].trim());\n        break;\n      case 'LH':\n        item.lines.hit = Number(parts[1].trim());", "      case 'LH':\n        item.lines.hit = Number(parts[1].trim());\n        break;\n      case 'DA':\n        lines = parts[1].split(',');\n        item.lines.details.push({\n          line: Number(lines[0]),\n          hit: Number(lines[1]),\n        });\n        break;", "        });\n        break;\n      case 'FN':\n        fn = parts[1].split(',');\n        item.functions.details.push({\n          name: fn[1],\n          line: Number(fn[0]),\n          hit: 0,\n        });\n        break;", "        });\n        break;\n      case 'FNDA':\n        fn = parts[1].split(',');\n        item.functions.details.some((i: any, k: any) => {\n          if (i.name === fn[1] && i.hit === undefined) {\n            item.functions.details[k].hit = Number(fn[0]);\n            return true;\n          }\n        });\n        break;\n      case 'BRDA':\n        fn = parts[1].split(',');\n        item.branches.details.push({\n          line: Number(fn[0]),\n          block: Number(fn[1]),\n          branch: Number(fn[2]),\n          taken: fn[3] === '-' ? 0 : Number(fn[3]),\n        });\n        break;\n      case 'BRF':\n        item.branches.found = Number(parts[1]);\n        break;\n      case 'BRH':\n        item.branches.hit = Number(parts[1]);\n        break;\n    }\n", "    if (line === 'end_of_record') {\n      if (item) {\n        data.push(item);\n      }\n      item = {\n        title: '',\n        file: '',\n        lines: {\n          found: 0,\n          hit: 0,\n          details: [],\n        },\n        functions: {\n          hit: 0,\n          found: 0,\n          details: [],\n        },\n        branches: {\n          hit: 0,\n          found: 0,\n          details: [],\n        },\n      };\n    }\n  });\n", "  if (!data.length) {\n    core.info('No lcov file content');\n  }\n  return data;\n};\n\nexport function parseFile(file: string): Promise<CoverInfo[]> {\n  return new Promise((resolve, reject) => {\n    if (!file || file === '') {\n      core.info('no lcov file specified');\n      resolve([]);\n    } else {\n      fs.readFile(\n        file,\n        'utf8',\n        async (err: NodeJS.ErrnoException | null, data: string) => {", "    if (!file || file === '') {\n      core.info('no lcov file specified');\n      resolve([]);\n    } else {\n      fs.readFile(\n        file,\n        'utf8',\n        async (err: NodeJS.ErrnoException | null, data: string) => {\n          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {", "          if (err) {\n            core.error(`failed to read file: ${file}. error: ${err.message}`);\n            reject(err);\n          } else {\n            try {\n              const info = parseContent(data);\n              // console.log('====== lcov ======');\n              // console.log(JSON.stringify(info, null, 2));\n              resolve(info);\n            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n}\n", "            } catch (error) {\n              core.error(`failed to parseContent. err: ${error.message}`);\n              reject(error);\n            }\n          }\n        },\n      );\n    }\n  });\n}\n"]}
