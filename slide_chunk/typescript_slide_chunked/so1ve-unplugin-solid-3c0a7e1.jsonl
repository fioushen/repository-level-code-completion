{"filename": "build.config.ts", "chunked_list": ["import { defineBuildConfig } from \"unbuild\";\n\nexport default defineBuildConfig({\n  clean: true,\n  externals: [\n    \"@nuxt/schema\",\n    \"@nuxt/kit\",\n    \"webpack\",\n    \"rollup\",\n    \"vite\",", "    \"rollup\",\n    \"vite\",\n    \"esbuild\",\n    \"rspack\",\n  ],\n});\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {},\n});\n"]}
{"filename": "test/index.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\ndescribe(\"should\", () => {\n  it(\"exported\", () => {\n    expect(1).toBe(1);\n  });\n});\n"]}
{"filename": "src/vite.ts", "chunked_list": ["import unplugin from \"./core\";\n\nexport default unplugin.vite;\n"]}
{"filename": "src/types.ts", "chunked_list": ["export * from \"./core/types\";\n"]}
{"filename": "src/rollup.ts", "chunked_list": ["import unplugin from \"./core\";\n\nexport default unplugin.rollup;\n"]}
{"filename": "src/esbuild.ts", "chunked_list": ["import unplugin from \"./core\";\n\nexport default unplugin.esbuild;\n"]}
{"filename": "src/webpack.ts", "chunked_list": ["import unplugin from \"./core\";\n\nexport default unplugin.webpack;\n"]}
{"filename": "src/astro.ts", "chunked_list": ["import type { Options } from \"./types\";\n\nimport unplugin from \".\";\n\nexport default (options: Options) => ({\n  name: \"unplugin-solid\",\n  hooks: {\n    \"astro:config:setup\": async (astro: any) => {\n      astro.config.vite.plugins ||= [];\n      astro.config.vite.plugins.push(unplugin.vite(options));", "      astro.config.vite.plugins ||= [];\n      astro.config.vite.plugins.push(unplugin.vite(options));\n    },\n  },\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { default } from \"./core\";\n"]}
{"filename": "src/rspack.ts", "chunked_list": ["import unplugin from \"./core\";\n\nexport default unplugin.rspack;\n"]}
{"filename": "src/core/types.ts", "chunked_list": ["import type { TransformOptions } from \"@babel/core\";\nimport type { FilterPattern } from \"@rollup/pluginutils\";\n\ninterface ExtensionOptions {\n  typescript?: boolean;\n}\n\nexport interface Options {\n  /**\n   * A [picomatch](https://github.com/micromatch/picomatch) pattern, or array of\n   * patterns, which specifies the files the plugin should operate on.\n   */\n  include?: FilterPattern;\n  /**\n   * A [picomatch](https://github.com/micromatch/picomatch) pattern, or array of\n   * patterns, which specifies the files to be ignored by the plugin.\n   */\n  exclude?: FilterPattern;\n  /**\n   * This will inject solid-js/dev in place of solid-js in dev mode. Has no\n   * effect in prod. If set to `false`, it won't inject it in dev. This is\n   * useful for extra logs and debugging.\n   *\n   * @default true\n   */\n  dev: boolean;\n  /**\n   * This will force SSR code in the produced files. This is experiemental and\n   * mostly not working yet.\n   *\n   * @default false\n   */\n  ssr: boolean;\n  /**\n   * This will inject HMR runtime in dev mode. Has no effect in prod. If set to\n   * `false`, it won't inject the runtime in dev.\n   *\n   * @default true\n   */\n  hot: boolean;\n  /**\n   * This registers additional extensions that should be processed by\n   * vite-plugin-solid.\n   *\n   * @default undefined\n   */\n  extensions?: (string | [string, ExtensionOptions])[];\n  /**\n   * Pass any additional babel transform options. They will be merged with the\n   * transformations required by Solid.\n   *\n   * @default { }\n   */\n  babel:\n    | TransformOptions\n    | ((source: string, id: string, ssr: boolean) => TransformOptions)\n    | ((source: string, id: string, ssr: boolean) => Promise<TransformOptions>);\n  typescript: {\n    /**\n     * Forcibly enables jsx parsing. Otherwise angle brackets will be treated as", "     * typescript's legacy type assertion var foo = <string>bar;. Also, isTSX:\n     * true requires allExtensions: true.\n     *\n     * @default false\n     */\n    isTSX?: boolean;\n\n    /**\n     * Replace the function used when compiling JSX expressions. This is so that\n     * we know that the import is not a type import, and should not be removed.\n     *\n     * @default React\n     */\n    jsxPragma?: string;\n\n    /**", "     * Replace the function used when compiling JSX expressions. This is so that\n     * we know that the import is not a type import, and should not be removed.\n     *\n     * @default React\n     */\n    jsxPragma?: string;\n\n    /**\n     * Replace the function used when compiling JSX fragment expressions. This\n     * is so that we know that the import is not a type import, and should not\n     * be removed.\n     *\n     * @default React\n     */\n    jsxPragmaFrag?: string;\n\n    /**\n     * Indicates that every file should be parsed as TS or TSX (depending on the\n     * isTSX option).\n     *\n     * @default false\n     */\n    allExtensions?: boolean;\n\n    /**\n     * Enables compilation of TypeScript namespaces.\n     *\n     * @default uses the default set by @babel/plugin-transform-typescript.\n     */\n    allowNamespaces?: boolean;\n\n    /**", "     * Replace the function used when compiling JSX fragment expressions. This\n     * is so that we know that the import is not a type import, and should not\n     * be removed.\n     *\n     * @default React\n     */\n    jsxPragmaFrag?: string;\n\n    /**\n     * Indicates that every file should be parsed as TS or TSX (depending on the\n     * isTSX option).\n     *\n     * @default false\n     */\n    allExtensions?: boolean;\n\n    /**\n     * Enables compilation of TypeScript namespaces.\n     *\n     * @default uses the default set by @babel/plugin-transform-typescript.\n     */\n    allowNamespaces?: boolean;\n\n    /**", "     * When enabled, type-only class fields are only removed if they are\n     * prefixed with the declare modifier:> NOTE: This will be enabled by\n     * default in Babel 8\n     *\n     * @example\n     *\n     * ```ts\n     * class A {\n     *   declare foo: string; // Removed\n     *   bar: string; // Initialized to undefined\n     *   prop?: string; // Initialized to undefined\n     *   prop1!: string; // Initialized to undefined\n     * }\n     * ```\n     *\n     * @default false\n     */\n    allowDeclareFields?: boolean;\n\n    /**\n     * When set to true, the transform will only remove type-only imports\n     * (introduced in TypeScript 3.8). This should only be used if you are using\n     * TypeScript >= 3.8.\n     *\n     * @default false\n     */\n    onlyRemoveTypeImports?: boolean;\n\n    /**", "     * When set to true, Babel will inline enum values rather than using the\n     * usual enum output:\n     *\n     * This option differs from TypeScript's --isolatedModules behavior, which\n     * ignores the const modifier and compiles them as normal enums, and aligns\n     * Babel's behavior with TypeScript's default behavior.\n     *\n     * ```ts\n     * // Input\n     * const enum Animals {\n     *   Fish,\n     * }\n     * console.log(Animals.Fish);\n     *\n     * // Default output\n     * var Animals;\n     *\n     * (function (Animals) {\n     *   Animals[(Animals[\"Fish\"] = 0)] = \"Fish\";\n     * })(Animals || (Animals = {}));\n     *\n     * console.log(Animals.Fish);\n     *\n     * // `optimizeConstEnums` output\n     * console.log(0);\n     * ```\n     *", "     * const enum Animals {\n     *   Fish,\n     * }\n     * console.log(Animals.Fish);\n     *\n     * // Default output\n     * var Animals;\n     *\n     * (function (Animals) {\n     *   Animals[(Animals[\"Fish\"] = 0)] = \"Fish\";\n     * })(Animals || (Animals = {}));\n     *\n     * console.log(Animals.Fish);\n     *\n     * // `optimizeConstEnums` output\n     * console.log(0);\n     * ```\n     *", "     * However, when exporting a const enum Babel will compile it to a plain\n     * object literal so that it doesn't need to rely on cross-file analysis\n     * when compiling it:\n     *\n     * ```ts\n     * // Input\n     * export const enum Animals {\n     *   Fish,\n     * }\n     *\n     * // `optimizeConstEnums` output\n     * export var Animals = {\n     *   Fish: 0,\n     * };\n     * ```\n     *\n     * @default false\n     */\n    optimizeConstEnums?: boolean;\n  };\n  /**\n   * Pass any additional\n   * [babel-plugin-jsx-dom-expressions](https://github.com/ryansolid/dom-expressions/tree/main/packages/babel-plugin-jsx-dom-expressions#plugin-options).\n   * They will be merged with the defaults sets by\n   * [babel-preset-solid](https://github.com/solidjs/solid/blob/main/packages/babel-preset-solid/index.js#L8-L25).\n   */\n  solid: {\n    /**", "     * The name of the runtime module to import the methods from.\n     *\n     * @default \"solid-js/web\"\n     */\n    moduleName?: string;\n\n    /**\n     * The output mode of the compiler. Can be:\n     *\n     * - \"dom\" is standard output\n     * - \"ssr\" is for server side rendering of strings.\n     * - \"universal\" is for using custom renderers from solid-js/universal\n     *\n     * @default \"dom\"\n     */\n    generate?: \"ssr\" | \"dom\" | \"universal\";\n\n    /**\n     * Indicate whether the output should contain hydratable markers.\n     *\n     * @default false\n     */\n    hydratable?: boolean;\n\n    /**\n     * Boolean to indicate whether to enable automatic event delegation on\n     * camelCase.\n     *\n     * @default true\n     */\n    delegateEvents?: boolean;\n\n    /**\n     * Boolean indicates whether smart conditional detection should be used.\n     * This optimizes simple boolean expressions and ternaries in JSX.\n     *\n     * @default true\n     */\n    wrapConditionals?: boolean;\n\n    /**\n     * Boolean indicates whether to set current render context on Custom\n     * Elements and slots. Useful for seemless Context API with Web Components.\n     *\n     * @default true\n     */\n    contextToCustomElements?: boolean;\n\n    /**\n     * Array of Component exports from module, that aren't included by default\n     * with the library. This plugin will automatically import them if it comes\n     * across them in the JSX.\n     */\n    builtIns?: string[];\n  };\n}\n"]}
{"filename": "src/core/utils.ts", "chunked_list": ["import { createRequire } from \"node:module\";\n\nimport type { Alias, AliasOptions } from \"vite\";\n\nconst require = createRequire(import.meta.url);\n\nexport function getExtension(filename: string): string {\n  const index = filename.lastIndexOf(\".\");\n\n  return index < 0\n    ? \"\"\n    : filename.slice(Math.max(0, index)).replace(/\\?.+$/, \"\");\n}\n", "export function containsSolidField(fields: any) {\n  const keys = Object.keys(fields);\n  for (const key of keys) {\n    if (key === \"solid\") {\n      return true;\n    }\n    if (\n      typeof fields[key] === \"object\" &&\n      fields[key] != null &&\n      containsSolidField(fields[key])\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "export function isJestDomInstalled() {\n  try {\n    // attempt to reference a file that will not throw error because expect is missing\n    require(\"@testing-library/jest-dom/dist/utils\");\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * This basically normalize all aliases of the config into the array format of\n * the alias.\n *\n * Eg: alias: { '@': 'src/' } => [{ find: '@', replacement: 'src/' }]\n */\nexport const normalizeAliases = (alias: AliasOptions = []): Alias[] =>\n  Array.isArray(alias)\n    ? alias\n    : Object.entries(alias).map(([find, replacement]) => ({\n        find,\n        replacement,\n      }));\n"]}
{"filename": "src/core/index.ts", "chunked_list": ["// Adapted from https://github.com/solidjs/vite-plugin-solid/blob/master/src/index.ts\nimport { readFileSync } from \"node:fs\";\n\nimport type { TransformOptions } from \"@babel/core\";\nimport { transformAsync } from \"@babel/core\";\n// @ts-expect-error\nimport ts from \"@babel/preset-typescript\";\nimport { createFilter } from \"@rollup/pluginutils\";\n// @ts-expect-error\nimport solid from \"babel-preset-solid\";", "// @ts-expect-error\nimport solid from \"babel-preset-solid\";\nimport { mergeAndConcat } from \"merge-anything\";\nimport solidRefresh from \"solid-refresh/babel\";\nimport { createUnplugin } from \"unplugin\";\nimport type { UserConfig } from \"vite\";\nimport { crawlFrameworkPkgs } from \"vitefu\";\n\nimport type { Options } from \"./types\";\nimport {", "import type { Options } from \"./types\";\nimport {\n  containsSolidField,\n  getExtension,\n  isJestDomInstalled,\n  normalizeAliases,\n} from \"./utils\";\n\nconst runtimePublicPath = \"/@solid-refresh\";\nconst runtimeFilePath = require.resolve(\"solid-refresh/dist/solid-refresh.mjs\");", "const runtimePublicPath = \"/@solid-refresh\";\nconst runtimeFilePath = require.resolve(\"solid-refresh/dist/solid-refresh.mjs\");\nconst runtimeCode = readFileSync(runtimeFilePath, \"utf-8\");\n\nexport default createUnplugin<Partial<Options> | undefined>(\n  (options = {}, meta) => {\n    const filter = createFilter(options.include, options.exclude);\n\n    const isVite = meta.framework === \"vite\";\n    let needHmr = false;", "    const isVite = meta.framework === \"vite\";\n    let needHmr = false;\n    let replaceDev = false;\n    let projectRoot = process.cwd();\n\n    return {\n      name: \"unplugin-solid\",\n      enforce: \"pre\",\n\n      vite: {", "\n      vite: {\n        async config(userConfig, { command }) {\n          // We inject the dev mode only if the user explicitely wants it or if we are in dev (serve) mode\n          replaceDev =\n            options.dev === true ||\n            (options.dev !== false && command === \"serve\");\n          projectRoot = userConfig.root ?? projectRoot;\n\n          if (!userConfig.resolve) {\n            userConfig.resolve = {};\n          }\n          userConfig.resolve.alias = normalizeAliases(userConfig.resolve.alias);\n\n          const solidPkgsConfig = await crawlFrameworkPkgs({\n            viteUserConfig: userConfig,\n            root: projectRoot || process.cwd(),\n            isBuild: command === \"build\",\n            isFrameworkPkgByJson(pkgJson) {\n              return containsSolidField(pkgJson.exports || {});\n            },\n          });\n\n          // fix for bundling dev in production\n          const nestedDeps = replaceDev\n            ? [\n                \"solid-js\",\n                \"solid-js/web\",\n                \"solid-js/store\",\n                \"solid-js/html\",\n                \"solid-js/h\",\n              ]\n            : [];\n\n          const test =\n            userConfig.mode === \"test\"\n              ? {\n                  test: {\n                    globals: true,\n                    ...(options.ssr ? {} : { environment: \"jsdom\" }),\n                    transformMode: {\n                      [options.ssr ? \"ssr\" : \"web\"]: [/\\.[jt]sx?$/],\n                    },\n                    ...(isJestDomInstalled()\n                      ? {\n                          setupFiles: [\n                            \"node_modules/@testing-library/jest-dom/extend-expect.js\",\n                          ],\n                        }\n                      : {}),\n                    deps: { registerNodeLoader: true },\n                    ...(\n                      userConfig as UserConfig & { test: Record<string, any> }\n                    ).test,\n                  },\n                }\n              : {};\n\n          return {\n            /**\n             * We only need esbuild on .ts or .js files. .tsx & .jsx files are\n             * handled by us\n             */\n            esbuild: { include: /\\.ts$/ },\n            resolve: {\n              conditions: [\n                \"solid\",\n                ...(isVite && replaceDev ? [\"development\"] : []),\n                ...(userConfig.mode === \"test\" && !options.ssr\n                  ? [\"browser\"]\n                  : []),\n              ],\n              dedupe: nestedDeps,\n              alias: [\n                { find: /^solid-refresh$/, replacement: runtimePublicPath },\n              ],\n            },\n            optimizeDeps: {\n              include: [...nestedDeps, ...solidPkgsConfig.optimizeDeps.include],\n              exclude: solidPkgsConfig.optimizeDeps.exclude,\n            },\n            ssr: solidPkgsConfig.ssr,\n            ...test,\n          };\n        },\n\n        configResolved(config) {\n          needHmr =\n            config.command === \"serve\" &&\n            config.mode !== \"production\" &&\n            options.hot !== false;\n        },\n\n        resolveId(id) {", "\n          if (!userConfig.resolve) {\n            userConfig.resolve = {};\n          }\n          userConfig.resolve.alias = normalizeAliases(userConfig.resolve.alias);\n\n          const solidPkgsConfig = await crawlFrameworkPkgs({\n            viteUserConfig: userConfig,\n            root: projectRoot || process.cwd(),\n            isBuild: command === \"build\",\n            isFrameworkPkgByJson(pkgJson) {\n              return containsSolidField(pkgJson.exports || {});\n            },\n          });\n\n          // fix for bundling dev in production\n          const nestedDeps = replaceDev\n            ? [\n                \"solid-js\",\n                \"solid-js/web\",\n                \"solid-js/store\",\n                \"solid-js/html\",\n                \"solid-js/h\",\n              ]\n            : [];\n\n          const test =\n            userConfig.mode === \"test\"\n              ? {\n                  test: {\n                    globals: true,\n                    ...(options.ssr ? {} : { environment: \"jsdom\" }),\n                    transformMode: {\n                      [options.ssr ? \"ssr\" : \"web\"]: [/\\.[jt]sx?$/],\n                    },\n                    ...(isJestDomInstalled()\n                      ? {\n                          setupFiles: [\n                            \"node_modules/@testing-library/jest-dom/extend-expect.js\",\n                          ],\n                        }\n                      : {}),\n                    deps: { registerNodeLoader: true },\n                    ...(\n                      userConfig as UserConfig & { test: Record<string, any> }\n                    ).test,\n                  },\n                }\n              : {};\n\n          return {\n            /**\n             * We only need esbuild on .ts or .js files. .tsx & .jsx files are\n             * handled by us\n             */\n            esbuild: { include: /\\.ts$/ },\n            resolve: {\n              conditions: [\n                \"solid\",\n                ...(isVite && replaceDev ? [\"development\"] : []),\n                ...(userConfig.mode === \"test\" && !options.ssr\n                  ? [\"browser\"]\n                  : []),\n              ],\n              dedupe: nestedDeps,\n              alias: [\n                { find: /^solid-refresh$/, replacement: runtimePublicPath },\n              ],\n            },\n            optimizeDeps: {\n              include: [...nestedDeps, ...solidPkgsConfig.optimizeDeps.include],\n              exclude: solidPkgsConfig.optimizeDeps.exclude,\n            },\n            ssr: solidPkgsConfig.ssr,\n            ...test,\n          };\n        },\n\n        configResolved(config) {\n          needHmr =\n            config.command === \"serve\" &&\n            config.mode !== \"production\" &&\n            options.hot !== false;\n        },\n\n        resolveId(id) {", "          if (id === runtimePublicPath) {\n            return id;\n          }\n        },\n\n        load(id) {\n          if (id === runtimePublicPath) {\n            return runtimeCode;\n          }\n        },\n      },\n      async transform(source, id) {\n        const isSsr = !!options.ssr;\n        const currentFileExtension = getExtension(id);\n\n        const extensionsToWatch = [\n          ...(options.extensions ?? []),\n          \".tsx\",\n          \".jsx\",\n        ];\n        const allExtensions = extensionsToWatch.map((extension) =>\n          // An extension can be a string or a tuple [extension, options]\n          typeof extension === \"string\" ? extension : extension[0],\n        );\n", "        if (!filter(id) || !allExtensions.includes(currentFileExtension)) {\n          return null;\n        }\n\n        const inNodeModules = /node_modules/.test(id);\n\n        let solidOptions: { generate: \"ssr\" | \"dom\"; hydratable: boolean };\n\n        if (options.ssr) {\n          solidOptions = isSsr\n            ? { generate: \"ssr\", hydratable: true }\n            : { generate: \"dom\", hydratable: true };\n        } else {\n          solidOptions = { generate: \"dom\", hydratable: false };\n        }\n\n        id = id.replace(/\\?.+$/, \"\");\n\n        const opts: TransformOptions = {\n          babelrc: false,\n          configFile: false,\n          root: projectRoot,\n          filename: id,\n          sourceFileName: id,\n          presets: [[solid, { ...solidOptions, ...(options.solid ?? {}) }]],\n          plugins:\n            isVite && needHmr && !isSsr && !inNodeModules\n              ? [[solidRefresh, { bundler: \"vite\" }]]\n              : [],\n          sourceMaps: true,\n          // Vite handles sourcemap flattening\n          inputSourceMap: false as any,\n        };\n\n        // We need to know if the current file extension has a typescript options tied to it\n        const shouldBeProcessedWithTypescript = extensionsToWatch.some(\n          (extension) => {", "        if (options.ssr) {\n          solidOptions = isSsr\n            ? { generate: \"ssr\", hydratable: true }\n            : { generate: \"dom\", hydratable: true };\n        } else {\n          solidOptions = { generate: \"dom\", hydratable: false };\n        }\n\n        id = id.replace(/\\?.+$/, \"\");\n\n        const opts: TransformOptions = {\n          babelrc: false,\n          configFile: false,\n          root: projectRoot,\n          filename: id,\n          sourceFileName: id,\n          presets: [[solid, { ...solidOptions, ...(options.solid ?? {}) }]],\n          plugins:\n            isVite && needHmr && !isSsr && !inNodeModules\n              ? [[solidRefresh, { bundler: \"vite\" }]]\n              : [],\n          sourceMaps: true,\n          // Vite handles sourcemap flattening\n          inputSourceMap: false as any,\n        };\n\n        // We need to know if the current file extension has a typescript options tied to it\n        const shouldBeProcessedWithTypescript = extensionsToWatch.some(\n          (extension) => {", "            if (typeof extension === \"string\") {\n              return extension.includes(\"tsx\");\n            }\n\n            const [extensionName, extensionOptions] = extension;\n            if (extensionName !== currentFileExtension) {\n              return false;\n            }\n\n            return extensionOptions.typescript;\n          },\n        );\n", "        if (shouldBeProcessedWithTypescript) {\n          (opts.presets ??= []).push([ts, options.typescript ?? {}]);\n        }\n\n        // Default value for babel user options\n        let babelUserOptions: TransformOptions = {};\n\n        if (options.babel) {\n          if (typeof options.babel === \"function\") {\n            const babelOptions = options.babel(source, id, isSsr);\n            babelUserOptions =\n              babelOptions instanceof Promise\n                ? await babelOptions\n                : babelOptions;\n          } else {\n            babelUserOptions = options.babel;\n          }\n        }\n\n        const babelOptions = mergeAndConcat(babelUserOptions, opts);\n\n        const { code, map } = (await transformAsync(source, babelOptions))!;\n\n        return { code: code!, map };\n      },\n    };\n  },\n);\n", "          if (typeof options.babel === \"function\") {\n            const babelOptions = options.babel(source, id, isSsr);\n            babelUserOptions =\n              babelOptions instanceof Promise\n                ? await babelOptions\n                : babelOptions;\n          } else {\n            babelUserOptions = options.babel;\n          }\n        }\n\n        const babelOptions = mergeAndConcat(babelUserOptions, opts);\n\n        const { code, map } = (await transformAsync(source, babelOptions))!;\n\n        return { code: code!, map };\n      },\n    };\n  },\n);\n"]}
