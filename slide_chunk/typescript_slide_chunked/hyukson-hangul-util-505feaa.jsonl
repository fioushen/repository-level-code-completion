{"filename": "test/getLocal.spec.ts", "chunked_list": ["import { getLocal, getLocalByGroups } from \"../src/getLocal\";\n\ndescribe(\"getLocal\", () => {\n  test(\"\uc548\ub155\ud558\uc138\uc694 - ko\", () => {\n    expect(getLocal(\"\uc548\ub155\ud558\uc138\uc694\")).toEqual(\"ko\");\n  });\n\n  test(\"Hello world - en\", () => {\n    expect(getLocal(\"Hello world\")).toEqual(\"en\");\n  });", "    expect(getLocal(\"Hello world\")).toEqual(\"en\");\n  });\n\n  test(\"1234 - number\", () => {\n    expect(getLocal(\"1234\")).toEqual(\"number\");\n  });\n\n  test(\"!@#$%^&*()_+ - special\", () => {\n    expect(getLocal(\"!@#$%^&*()_+\")).toEqual(\"special\");\n  });", "    expect(getLocal(\"!@#$%^&*()_+\")).toEqual(\"special\");\n  });\n\n  test(\"\u3053\u3093\u306b\u3061\u306f\uff01!123 - etc\", () => {\n    expect(getLocal(\"\u3053\u3093\u306b\u3061\u306f\uff01!123\")).toEqual(\"etc\");\n  });\n});\n\ndescribe(\"getLocalByGroups\", () => {\n  test(\"\uc548\ub155\ud558\uc138\uc694 - \uadf8\ub8f9\", () => {", "describe(\"getLocalByGroups\", () => {\n  test(\"\uc548\ub155\ud558\uc138\uc694 - \uadf8\ub8f9\", () => {\n    expect(getLocalByGroups(\"\uc548\ub155\ud558\uc138\uc694\")).toEqual([\n      \"ko\",\n      \"ko\",\n      \"ko\",\n      \"ko\",\n      \"ko\",\n    ]);\n  });", "    ]);\n  });\n\n  test(\"Hello, world! - \uadf8\ub8f9\", () => {\n    expect(getLocalByGroups(\"Hello, world!\")).toEqual([\n      \"en\",\n      \"en\",\n      \"en\",\n      \"en\",\n      \"en\",", "      \"en\",\n      \"en\",\n      \"special\",\n      \"special\",\n      \"en\",\n      \"en\",\n      \"en\",\n      \"en\",\n      \"en\",\n      \"special\",", "      \"en\",\n      \"special\",\n    ]);\n  });\n\n  test(\"1234 - \uadf8\ub8f9\", () => {\n    expect(getLocalByGroups(\"1234\")).toEqual([\n      \"number\",\n      \"number\",\n      \"number\",", "      \"number\",\n      \"number\",\n      \"number\",\n    ]);\n  });\n\n  test(\"!@#$%^&*()_+ - \uadf8\ub8f9\", () => {\n    expect(getLocalByGroups(\"!@#$%^&*()_+\")).toEqual([\n      \"special\",\n      \"special\",", "      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",", "      \"special\",\n      \"special\",\n      \"special\",\n      \"special\",\n    ]);\n  });\n\n  test(\"\u3053\u3093\u306b\u3061\u306f!123 - \uadf8\ub8f9\", () => {\n    const word = \"\u3053\u3093\u306b\u3061\u306f!123\";\n    const result = getLocalByGroups(word);", "    const word = \"\u3053\u3093\u306b\u3061\u306f!123\";\n    const result = getLocalByGroups(word);\n    expect(result).toEqual([\n      \"etc\",\n      \"etc\",\n      \"etc\",\n      \"etc\",\n      \"etc\",\n      \"special\",\n      \"number\",", "      \"special\",\n      \"number\",\n      \"number\",\n      \"number\",\n    ]);\n  });\n\n  test(\"\uc548\ub155\ud558\uc138\uc694! Hello, world! 1234 # - \ud37c\uc13c\ud2b8\", () => {\n    const word = \"\uc548\ub155\ud558\uc138\uc694! Hello, world! 1234 #\";\n    const result = getLocalByGroups(word, true);", "    const word = \"\uc548\ub155\ud558\uc138\uc694! Hello, world! 1234 #\";\n    const result = getLocalByGroups(word, true);\n    expect(result).toEqual({\n      ko: 18.52,\n      en: 37.04,\n      number: 14.81,\n      special: 29.63,\n      etc: 0,\n    });\n  });", "    });\n  });\n\n  test(\"!@#$%^&*()_+ - \ud37c\uc13c\ud2b8\", () => {\n    expect(getLocalByGroups(\"!@#$%^&*()_+\", true)).toEqual({\n      ko: 0,\n      en: 0,\n      number: 0,\n      special: 100,\n      etc: 0,", "      special: 100,\n      etc: 0,\n    });\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const word = new Array(1000000).fill(\"\uc548\ub155\ud558\uc138\uc694! Hello, world! 1234 #\").join('');\n    const result = getLocalByGroups(word, true);\n    expect(result).toEqual({\n      ko: 18.52,", "    expect(result).toEqual({\n      ko: 18.52,\n      en: 37.04,\n      number: 14.81,\n      special: 29.63,\n      etc: 0,\n    });\n  });\n});\n", "});\n"]}
{"filename": "test/formatDate.spec.ts", "chunked_list": ["import { formatDate } from \"../src/formatDate\";\n\nconst date = \"2022-02-22 22:22:22\";\n\ndescribe(\"formatDate\", () => {\n  test(\"formatStyle \uae30\ubcf8\uac12 - new Date()\", () => {\n    expect(formatDate(date)).toEqual(\"2022\ub14402\uc6d422\uc77c 22\uc2dc22\ubd8422\ucd08\");\n  });\n\n  test(\"formatStyle \uae30\ubcf8\uac12 - String\", () => {", "\n  test(\"formatStyle \uae30\ubcf8\uac12 - String\", () => {\n    expect(formatDate(date)).toEqual(\"2022\ub14402\uc6d422\uc77c 22\uc2dc22\ubd8422\ucd08\");\n  });\n\n  test(\"HH:mm:ss YYYY\ub144 MM\uc6d4\", () => {\n    expect(formatDate(date, \"HH:mm:ss YYYY\ub144 MM\uc6d4\")).toEqual(\n      \"22:22:22 2022\ub144 02\uc6d4\"\n    );\n  });", "    );\n  });\n\n  test(\"YYYY\ub144 MM\uc6d4 DD\uc77c dd\uc694\uc77c HH:mm:ss\", () => {\n    expect(formatDate(date, \"YYYY\ub144 MM\uc6d4 DD\uc77c dd\uc694\uc77c HH:mm:ss\")).toEqual(\n      \"2022\ub144 02\uc6d4 22\uc77c \ud654\uc694\uc77c 22:22:22\"\n    );\n  });\n\n  test(\"YYYY-MM-DD HH:mm:ss\", () => {", "\n  test(\"YYYY-MM-DD HH:mm:ss\", () => {\n    expect(formatDate(date, \"YYYY-MM-DD HH:mm:ss\")).toEqual(\"2022-02-22 22:22:22\");\n  });\n});\n"]}
{"filename": "test/distance.spec.ts", "chunked_list": ["import { getDistance, correctByDistance } from \"../src/distance\";\n\ndescribe(\"getDistance\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(getDistance(\"\ud30c\uc778\uc560\ud50c\", \"\")).toEqual(4);\n    expect(getDistance(\"\", \"\ud30c\uc778\uc560\ud50c\")).toEqual(4);\n    expect(getDistance(\"\", \"\")).toEqual(0);\n  });\n\n  test(\"\ud30c\uc778\uc560\ud50c\", () => {", "\n  test(\"\ud30c\uc778\uc560\ud50c\", () => {\n    expect(getDistance(\"\ud30c\uc778\uc560\ud50c\", \"\ud30c\uc77c\ud574\ud50c\")).toEqual(2);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(10000).fill(\"\ud31d\").join(\"\");\n    const input2 = new Array(10000).fill(\"\ud54d\").join(\"\");\n\n    expect(getDistance(input, input2)).toEqual(10000);", "\n    expect(getDistance(input, input2)).toEqual(10000);\n  });\n});\n\ndescribe(\"correctByDistance\", () => {\n  const wordList = [\n    \"\uc0ac\uc790\",\n    \"\ubb34\uacfc\",\n    \"\uc0ac\uacfc\ud30c\uc774\",", "    \"\ubb34\uacfc\",\n    \"\uc0ac\uacfc\ud30c\uc774\",\n    \"\ud30c\uc778\uc560\ud50c\",\n    \"\ub9dd\uace0\",\n    \"\ubcc0\ud638\uc0ac\",\n    \"\uc0ac\uace0\",\n    \"\uc0ac\uacfc\",\n    \"\uade4\",\n    \"\ud1a0\ub07c\",\n    \"\ucf54\ub07c\ub9ac\",", "    \"\ud1a0\ub07c\",\n    \"\ucf54\ub07c\ub9ac\",\n  ];\n\n  test(\"\uc0ac\uacfc\", () => {\n    expect(correctByDistance(\"\uc0ac\uacfc\", wordList)).toEqual([\n      \"\uc0ac\uacfc\",\n      \"\uc0ac\uace0\",\n      \"\uc0ac\uc790\",\n      \"\ubb34\uacfc\",", "      \"\uc0ac\uc790\",\n      \"\ubb34\uacfc\",\n    ]);\n\n    expect(correctByDistance(\"\uc0ac\uacfc\", wordList, { isSplit: false })).toEqual([\n      \"\uc0ac\uacfc\",\n      \"\uc0ac\uc790\",\n      \"\ubb34\uacfc\",\n      \"\uc0ac\uace0\",\n      \"\uc0ac\uacfc\ud30c\uc774\",", "      \"\uc0ac\uace0\",\n      \"\uc0ac\uacfc\ud30c\uc774\",\n      \"\ub9dd\uace0\",\n      \"\uade4\",\n      \"\ud1a0\ub07c\",\n    ]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000).fill(\"\ud31d\").join(\"\");", "  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000).fill(\"\ud31d\").join(\"\");\n    const input2 = new Array(1000)\n      .fill([\n        new Array(1000).fill(\"\ud54d\").join(\"\"),\n        new Array(1000).fill(\"\uc27d\").join(\"\"),\n      ])\n      .flat();\n\n    expect(correctByDistance(input, input2)).toEqual([]);", "\n    expect(correctByDistance(input, input2)).toEqual([]);\n  });\n});\n"]}
{"filename": "test/banmal.spec.ts", "chunked_list": ["import { toBanmal, toHonorific } from \"../src/banmal\";\n\ndescribe(\"toHonorific\", () => {\n  test(\"\ubc18\ub9d0 -> \ub192\uc784\ub9d0\", () => {\n    expect(toHonorific(\"\uc624\ub298\uc740 \uc0ac\uacfc\uc774\ub2e4.\")).toEqual(\"\uc624\ub298\uc740 \uc0ac\uacfc\uc785\ub2c8\ub2e4.\");\n    expect(toHonorific(\"\ub0b4\uc77c\uc740 \uc790\ub450\uc774\ub2e4.\")).toEqual(\"\ub0b4\uc77c\uc740 \uc790\ub450\uc785\ub2c8\ub2e4.\");\n    expect(toHonorific(\"\ub0b4\uac00 \uba39\uc744 \uc0ac\uacfc\uc774\ub2e4.\")).toEqual(\"\ub0b4\uac00 \uba39\uc744 \uc0ac\uacfc\uc785\ub2c8\ub2e4.\");\n    expect(toHonorific(\"\ub098\ub294 \uce5c\uad6c\uc640 \ud568\uaed8 \uac04\ub2e4.\")).toEqual(\n      \"\uc800\ub294 \uce5c\uad6c\uc640 \ud568\uaed8 \uac11\ub2c8\ub2e4.\"\n    );", "      \"\uc800\ub294 \uce5c\uad6c\uc640 \ud568\uaed8 \uac11\ub2c8\ub2e4.\"\n    );\n    expect(toHonorific(\"\uc5b4\uc81c\ub294 \ube44\uac00 \uc654\ub2e4.\")).toEqual(\"\uc5b4\uc81c\ub294 \ube44\uac00 \uc654\uc2b5\ub2c8\ub2e4.\");\n    expect(toHonorific(\"\ub098\ub294, \uc0ac\ub78c\uc774\ub2e4.\")).toEqual(\"\uc800\ub294, \uc0ac\ub78c\uc785\ub2c8\ub2e4.\");\n  });\n});\n\ndescribe(\"toBanmal\", () => {\n  test(\"\ub192\uc784\ub9d0 -> \ubc18\ub9d0\", () => {\n    expect(toBanmal(\"\uc0ac\ub78c\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc0ac\ub78c\uc774 \uc5c6\ub2e4.\");", "  test(\"\ub192\uc784\ub9d0 -> \ubc18\ub9d0\", () => {\n    expect(toBanmal(\"\uc0ac\ub78c\uc774 \uc5c6\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc0ac\ub78c\uc774 \uc5c6\ub2e4.\");\n    expect(toBanmal(\"\ud558\uaca0\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ud558\uaca0\ub2e4.\");\n    expect(toBanmal(\"\ub2e4\uac00\uc635\ub2c8\ub2e4.\")).toEqual(\"\ub2e4\uac00\uc628\ub2e4.\");\n    expect(toBanmal(\"\ud544\uc218\uc785\ub2c8\ub2e4.\")).toEqual(\"\ud544\uc218\uc774\ub2e4.\");\n    expect(toBanmal(\"\uc0dd\uae41\ub2c8\ub2e4.\")).toEqual(\"\uc0dd\uae34\ub2e4.\");\n    expect(toBanmal(\"\uc54a\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc54a\ub2e4.\");\n    expect(toBanmal(\"\ubcf4\uaca0\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ubcf4\uaca0\ub2e4.\");\n    expect(toBanmal(\"\ud558\uc600\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ud558\uc600\ub2e4.\");\n    expect(toBanmal(\"\uac00\ub2a5\ud569\ub2c8\ub2e4.\")).toEqual(\"\uac00\ub2a5\ud558\ub2e4.\");", "    expect(toBanmal(\"\ud558\uc600\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ud558\uc600\ub2e4.\");\n    expect(toBanmal(\"\uac00\ub2a5\ud569\ub2c8\ub2e4.\")).toEqual(\"\uac00\ub2a5\ud558\ub2e4.\");\n    expect(toBanmal(\"\uc911\uc694\ud569\ub2c8\ub2e4.\")).toEqual(\"\uc911\uc694\ud558\ub2e4.\");\n    expect(toBanmal(\"\ud558\uc2ed\ub2c8\ub2e4.\")).toEqual(\"\ud558\uc2e0\ub2e4.\");\n    expect(toBanmal(\"\ubc14\ub78d\ub2c8\ub2e4.\")).toEqual(\"\ubc14\ub780\ub2e4.\");\n    expect(toBanmal(\"\ub098\uc635\ub2c8\ub2e4.\")).toEqual(\"\ub098\uc628\ub2e4.\");\n    expect(toBanmal(\"\ud588\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ud588\ub2e4.\");\n    expect(toBanmal(\"\ubd24\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ubd24\ub2e4.\");\n    expect(toBanmal(\"\ucce4\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ucce4\ub2e4.\");\n    expect(toBanmal(\"\uc30c\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc30c\ub2e4.\");", "    expect(toBanmal(\"\ucce4\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ucce4\ub2e4.\");\n    expect(toBanmal(\"\uc30c\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc30c\ub2e4.\");\n    expect(toBanmal(\"\ud574\uc8fc\uc138\uc694.\")).toEqual(\"\ud574\ub77c.\");\n    expect(toBanmal(\"\uc0c0\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc0c0\ub2e4.\");\n    expect(toBanmal(\"\uc5c8\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc5c8\ub2e4.\");\n    expect(toBanmal(\"\uba39\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uba39\ub2e4.\");\n    expect(toBanmal(\"\uc788\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc788\ub2e4.\");\n    expect(toBanmal(\"\uc88b\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc88b\ub2e4.\");\n    expect(toBanmal(\"\ub9ce\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ub9ce\ub2e4.\");\n    expect(toBanmal(\"\ub193\uc558\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ub193\uc558\ub2e4.\");", "    expect(toBanmal(\"\ub9ce\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ub9ce\ub2e4.\");\n    expect(toBanmal(\"\ub193\uc558\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\ub193\uc558\ub2e4.\");\n    expect(toBanmal(\"\uc5b4\ub835\uc2b5\ub2c8\ub2e4.\")).toEqual(\"\uc5b4\ub835\ub2e4.\");\n    expect(toBanmal(\"\uc8fc\uc6cc\uc8fc\uc138\uc694.\")).toEqual(\"\uc8fc\uc6cc\ub77c.\");\n  });\n});\n"]}
{"filename": "test/isJong.spec.ts", "chunked_list": ["import { isJongByCode, isJong, isJongByGroups } from \"../src/isJong\";\n\ndescribe(\"isJongByCode\", () => {\n  test(\"\u3131\", () => {\n    expect(isJongByCode(12593)).toEqual(true); // \"\u3131\"\n  });\n\n  test(\"\u314a\", () => {\n    expect(isJongByCode(12622)).toEqual(true); // \"\u314a\"\n  });", "    expect(isJongByCode(12622)).toEqual(true); // \"\u314a\"\n  });\n  test(\"\u314a\", () => {\n    expect(isJongByCode(12595)).toEqual(true); // \"\u314a\"\n  });\n\n  test(\"\uac00\", () => {\n    expect(isJongByCode(44032)).toEqual(false); // '\uac00'\n  });\n", "  });\n\n  test(\"a\", () => {\n    expect(isJongByCode(97)).toEqual(false); // \"a\"\n  });\n});\n\ndescribe(\"isJong\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(isJong(\"\")).toEqual(false);", "  test(\"\ube48\uac12\", () => {\n    expect(isJong(\"\")).toEqual(false);\n  });\n\n  test(\"\u3133\u3142\u3137\u3148\", () => {\n    expect(isJong(\"\u3133\u3142\u3137\u3148\")).toEqual(true);\n  });\n\n  test(\"\u3133\u31422\u3137\u3148\", () => {\n    expect(isJong(\"\u3133\u31422\u3137\u3148\")).toEqual(false);", "  test(\"\u3133\u31422\u3137\u3148\", () => {\n    expect(isJong(\"\u3133\u31422\u3137\u3148\")).toEqual(false);\n  });\n\n  test(\"\uac00\ub098\ub2e4\ub77c\", () => {\n    expect(isJong(\"\uac00\ub098\ub2e4\ub77c\")).toEqual(false);\n  });\n\n  test(\"\u3131\u314f\u3137\u314f\", () => {\n    expect(isJong(\"\u3131\u314f\u3137\u314f\")).toEqual(false);", "  test(\"\u3131\u314f\u3137\u314f\", () => {\n    expect(isJong(\"\u3131\u314f\u3137\u314f\")).toEqual(false);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u3142').join('')\n    expect(isJong(input)).toEqual(true);\n  });\n});\n", "});\n\ndescribe(\"isJongByGroups\", () => {\n  test(\"\u3131\u3142\u3137\u3148\", () => {\n    expect(isJongByGroups(\"\u3131\u3142\u3137\u3148\")).toEqual([true, true, true, true]);\n  });\n\n  test(\"\uac00\ub098\ub2e4\ub77c\", () => {\n    expect(isJongByGroups(\"\uac00\ub098\ub2e4\ub77c\")).toEqual([false, false, false, false]);\n  });", "    expect(isJongByGroups(\"\uac00\ub098\ub2e4\ub77c\")).toEqual([false, false, false, false]);\n  });\n  test(\"\u3133\u314f\u3137\u314f\", () => {\n    expect(isJongByGroups(\"\u3133\u314f\u3137\u314f\")).toEqual([true, false, true, false]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u3133').join('')\n    const result = new Array(1000000).fill(true);\n    expect(isJongByGroups(input)).toEqual(result);", "    const result = new Array(1000000).fill(true);\n    expect(isJongByGroups(input)).toEqual(result);\n  });\n});\n"]}
{"filename": "test/encode.spec.ts", "chunked_list": ["import { encode, decode } from \"../src/encode\";\n\ndescribe(\"formatNumber\", () => {\n  test(\"\ubb38\uc790\", () => {\n    expect(decode(encode(\"\uad6c\uc624\"))).toEqual(\"\uad6c\uc624\");\n  });\n\n  test(\"\ud63c\ud569 \ubb38\uc790\", () => {\n    expect(decode(encode(\"\uac10!\uc0ac3\ud569$\ub2c8\ub2e4.\"))).toEqual(\"\uac10!\uc0ac3\ud569$\ub2c8\ub2e4.\");\n  });", "    expect(decode(encode(\"\uac10!\uc0ac3\ud569$\ub2c8\ub2e4.\"))).toEqual(\"\uac10!\uc0ac3\ud569$\ub2c8\ub2e4.\");\n  });\n\n  test(\"\ubc30\uc5f4\", () => {\n    expect(decode(encode([1, 2, 3]))).toEqual([1, 2, 3]);\n  });\n\n  test(\"\uac1d\uccb4\", () => {\n    expect(decode(encode({ a: 1, b: 2 }))).toEqual({ a: 1, b: 2 });\n  });", "    expect(decode(encode({ a: 1, b: 2 }))).toEqual({ a: 1, b: 2 });\n  });\n\n  test(\"\ud63c\ud569 \uac1d\uccb4\", () => {\n    expect(\n      decode(\n        encode([\n          { a: 1, b: 2 },\n          { a: 1, b: 2 },\n        ])", "          { a: 1, b: 2 },\n        ])\n      )\n    ).toEqual([\n      { a: 1, b: 2 },\n      { a: 1, b: 2 },\n    ]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {", "\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(40000).fill(\"\uac10!\uc0ac3\ud569$\ub2c8\ub2e4.\").join('');\n    expect(decode(encode(input))).toEqual(input);\n  });\n});\n"]}
{"filename": "test/divide.spec.ts", "chunked_list": ["import { divide, divideHangul, divideHangulByGroups } from \"../src/divide\";\n\ndescribe(\"divide\", () => {\n  test(\"\ud55c\uae00\uc774 \uc544\ub2cc \uac12\", () => {\n    expect(divide(\"a\")).toEqual([\"a\"]);\n  });\n\n  test(\"\ud55c\", () => {\n    expect(divide(\"\ud55c\")).toEqual([\"\u314e\", \"\u314f\", \"\u3134\"]);\n  });", "    expect(divide(\"\ud55c\")).toEqual([\"\u314e\", \"\u314f\", \"\u3134\"]);\n  });\n\n  test(\"\ud55c - object\", () => {\n    expect(divide(\"\ud55c\", { resultType: \"object\" })).toEqual({\n      cho: \"\u314e\",\n      jung: \"\u314f\",\n      jong: \"\u3134\",\n    });\n  });", "    });\n  });\n\n  test(\"\ud55c - string\", () => {\n    expect(divide(\"\ud55c\", { resultType: \"string\" })).toEqual(\"\u314e\u314f\u3134\");\n  });\n\n  test(\"\ube75\", () => {\n    expect(divide(\"\ube75\")).toEqual([\"\u3143\", \"\u314f\", \"\u3147\"]);\n  });", "    expect(divide(\"\ube75\")).toEqual([\"\u3143\", \"\u314f\", \"\u3147\"]);\n  });\n\n  test(\"\ubdc1\", () => {\n    expect(divide(\"\ubdc1\", { isSplit: true })).toEqual([\n      \"\u3142\",\n      \"\u315c\",\n      \"\u3154\",\n      \"\u3139\",\n      \"\u3131\",", "      \"\u3139\",\n      \"\u3131\",\n    ]);\n    expect(divide(\"\ubdc1\", { isSplit: false })).toEqual([\"\u3142\", \"\u315e\", \"\u313a\"]);\n  });\n});\n\ndescribe(\"divideHangulByGroups\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(divideHangulByGroups(\"\")).toEqual([]);", "  test(\"\ube48\uac12\", () => {\n    expect(divideHangulByGroups(\"\")).toEqual([]);\n  });\n\n  test(\"\uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(divideHangulByGroups(\"\uc548\ub155\ud558\uc138\uc694\")).toEqual([\n      [\"\u3147\", \"\u314f\", \"\u3134\"],\n      [\"\u3134\", \"\u3155\", \"\u3147\"],\n      [\"\u314e\", \"\u314f\"],\n      [\"\u3145\", \"\u3154\"],", "      [\"\u314e\", \"\u314f\"],\n      [\"\u3145\", \"\u3154\"],\n      [\"\u3147\", \"\u315b\"],\n    ]);\n  });\n\n  test(\"Hello, \uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(divideHangulByGroups(\"Hello, \uc548\ub155\ud558\uc138\uc694\")).toEqual([\n      [\"H\"],\n      [\"e\"],", "      [\"H\"],\n      [\"e\"],\n      [\"l\"],\n      [\"l\"],\n      [\"o\"],\n      [\",\"],\n      [\" \"],\n      [\"\u3147\", \"\u314f\", \"\u3134\"],\n      [\"\u3134\", \"\u3155\", \"\u3147\"],\n      [\"\u314e\", \"\u314f\"],", "      [\"\u3134\", \"\u3155\", \"\u3147\"],\n      [\"\u314e\", \"\u314f\"],\n      [\"\u3145\", \"\u3154\"],\n      [\"\u3147\", \"\u315b\"],\n    ]);\n  });\n\n  test(\"\uac12\ubdc1\uc1cf\", () => {\n    expect(divideHangulByGroups(\"\uac12\ubdc1\u3145\uc1cf\")).toEqual([\n      [\"\u3131\", \"\u314f\", \"\u3142\", \"\u3145\"],", "    expect(divideHangulByGroups(\"\uac12\ubdc1\u3145\uc1cf\")).toEqual([\n      [\"\u3131\", \"\u314f\", \"\u3142\", \"\u3145\"],\n      [\"\u3142\", \"\u315c\", \"\u3154\", \"\u3139\", \"\u3131\"],\n      [\"\u3145\"],\n      [\"\u3145\", \"\u3157\", \"\u3150\", \"\u3139\", \"\u3142\"],\n    ]);\n    expect(divideHangulByGroups(\"\uac12\ubdc1\u3145\uc1cf\", { isSplit: false })).toEqual([\n      [\"\u3131\", \"\u314f\", \"\u3144\"],\n      [\"\u3142\", \"\u315e\", \"\u313a\"],\n      [\"\u3145\"],", "      [\"\u3142\", \"\u315e\", \"\u313a\"],\n      [\"\u3145\"],\n      [\"\u3145\", \"\u3159\", \"\u313c\"],\n    ]);\n  });\n});\n\ndescribe(\"divideHangul\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(divideHangul(\"\")).toEqual([]);", "  test(\"\ube48\uac12\", () => {\n    expect(divideHangul(\"\")).toEqual([]);\n  });\n\n  test(\"\uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(divideHangul(\"\uc548\ub155\ud558\uc138\uc694\")).toEqual([\n      \"\u3147\",\n      \"\u314f\",\n      \"\u3134\",\n      \"\u3134\",", "      \"\u3134\",\n      \"\u3134\",\n      \"\u3155\",\n      \"\u3147\",\n      \"\u314e\",\n      \"\u314f\",\n      \"\u3145\",\n      \"\u3154\",\n      \"\u3147\",\n      \"\u315b\",", "      \"\u3147\",\n      \"\u315b\",\n    ]);\n  });\n\n  test(\"Hello, \uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(divideHangul(\"Hello, \uc548\ub155\ud558\uc138\uc694\")).toEqual([\n      \"H\",\n      \"e\",\n      \"l\",", "      \"e\",\n      \"l\",\n      \"l\",\n      \"o\",\n      \",\",\n      \" \",\n      \"\u3147\",\n      \"\u314f\",\n      \"\u3134\",\n      \"\u3134\",", "      \"\u3134\",\n      \"\u3134\",\n      \"\u3155\",\n      \"\u3147\",\n      \"\u314e\",\n      \"\u314f\",\n      \"\u3145\",\n      \"\u3154\",\n      \"\u3147\",\n      \"\u315b\",", "      \"\u3147\",\n      \"\u315b\",\n    ]);\n  });\n\n  test(\"\uac12\ubdc1\uc1cf\", () => {\n    expect(divideHangul(\"\uac12\ubdc1\uc1cf\")).toEqual([\n      \"\u3131\",\n      \"\u314f\",\n      \"\u3142\",", "      \"\u314f\",\n      \"\u3142\",\n      \"\u3145\",\n      \"\u3142\",\n      \"\u315c\",\n      \"\u3154\",\n      \"\u3139\",\n      \"\u3131\",\n      \"\u3145\",\n      \"\u3157\",", "      \"\u3145\",\n      \"\u3157\",\n      \"\u3150\",\n      \"\u3139\",\n      \"\u3142\",\n    ]);\n    expect(divideHangul(\"\uac12\ubdc1\uc1cf\", false)).toEqual([\n      \"\u3131\",\n      \"\u314f\",\n      \"\u3144\",", "      \"\u314f\",\n      \"\u3144\",\n      \"\u3142\",\n      \"\u315e\",\n      \"\u313a\",\n      \"\u3145\",\n      \"\u3159\",\n      \"\u313c\",\n    ]);\n  });", "    ]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = divideHangul(new Array(100000).fill(\"\uac12\uc25b\").join(\"\"));\n    const result = new Array(100000).fill(\"\u3131\u314f\u3142\u3145\u3145\u315c\u3154\u3139\u3142\").join('').split('');\n    expect(input).toEqual(result);\n  });\n});\n", "});\n"]}
{"filename": "test/sortHangul.spec.ts", "chunked_list": ["import { sortByASC, sortByDESC, sortByGroups } from \"../src/sortHangul\";\n\ndescribe(\"sortByASC\", () => {\n  test(\"\uc601\uc5b4 \ubc30\uc5f4\", () => {\n    expect(sortByASC([\"apple\", \"kiwi\", \"banana\"])).toEqual([\n      \"apple\",\n      \"banana\",\n      \"kiwi\",\n    ]);\n  });", "    ]);\n  });\n\n  test(\"\ud55c\uae00 \ubc30\uc5f4\", () => {\n    expect(sortByASC([\"\uc0ac\uacfc\", \"\ud0a4\uc704\", \"\ubc14\ub098\ub098\"])).toEqual([\n      \"\ubc14\ub098\ub098\",\n      \"\uc0ac\uacfc\",\n      \"\ud0a4\uc704\",\n    ]);\n  });", "    ]);\n  });\n\n  test(\"\uc22b\uc790 \ubc30\uc5f4\", () => {\n    expect(sortByASC([1, 5, 1, 4])).toEqual([1, 1, 4, 5]);\n  });\n\n  test(\"\uc544\ubb34\ub7f0 \ubc30\uc5f4\", () => {\n    expect(sortByASC([4, \"a\", \"\uac00\", \"\u3134\"])).toEqual([4, \"\uac00\", \"\u3134\", \"a\"]);\n  });", "    expect(sortByASC([4, \"a\", \"\uac00\", \"\u3134\"])).toEqual([4, \"\uac00\", \"\u3134\", \"a\"]);\n  });\n\n  test(\"\uac1d\uccb4 \ubc30\uc5f4\", () => {\n    const array = [\n      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },\n    ];\n", "    ];\n\n    expect(sortByASC(array)).toEqual([\n      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },\n    ]);\n    expect(sortByASC(array, \"age\")).toEqual([\n      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },", "      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },\n    ]);\n    expect(sortByASC(array, [\"name\", \"age\"])).toEqual([\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 12 },\n      { name: \"kiwi\", age: 42 },\n    ]);\n  });", "    ]);\n  });\n\n  test(\"compare object \uc801\uc6a9\", () => {\n    const array = [\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ];\n", "    ];\n\n    expect(sortByASC(array, \"user.name\")).toEqual([\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ]);\n    expect(sortByASC(array, [\"user.age\", \"user.name\"])).toEqual([\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },", "      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ]);\n    expect(sortByASC(array, \"user.name[0]\")).toEqual([\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ]);\n  });", "    ]);\n  });\n});\n\ndescribe(\"sortByDESC\", () => {\n  test(\"\uc601\uc5b4 \ubc30\uc5f4\", () => {\n    expect(sortByDESC([\"apple\", \"kiwi\", \"banana\"])).toEqual([\n      \"kiwi\",\n      \"banana\",\n      \"apple\",", "      \"banana\",\n      \"apple\",\n    ]);\n  });\n\n  test(\"\ud55c\uae00 \ubc30\uc5f4\", () => {\n    expect(sortByDESC([\"\uc0ac\uacfc\", \"\ud0a4\uc704\", \"\ubc14\ub098\ub098\"])).toEqual([\n      \"\ud0a4\uc704\",\n      \"\uc0ac\uacfc\",\n      \"\ubc14\ub098\ub098\",", "      \"\uc0ac\uacfc\",\n      \"\ubc14\ub098\ub098\",\n    ]);\n  });\n\n  test(\"\uc22b\uc790 \ubc30\uc5f4\", () => {\n    expect(sortByDESC([1, 5, 1, 4])).toEqual([5, 4, 1, 1]);\n  });\n\n  test(\"\uc544\ubb34\ub7f0 \ubc30\uc5f4\", () => {", "\n  test(\"\uc544\ubb34\ub7f0 \ubc30\uc5f4\", () => {\n    expect(sortByDESC([4, \"a\", \"\uac00\", \"\u3134\"])).toEqual([\"a\", \"\u3134\", \"\uac00\", 4]);\n  });\n\n  test(\"\uac1d\uccb4 \ubc30\uc5f4\", () => {\n    const array = [\n      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },", "      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },\n    ];\n\n    expect(sortByDESC(array)).toEqual([\n      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },\n    ]);\n    expect(sortByDESC(array, \"age\")).toEqual([", "    ]);\n    expect(sortByDESC(array, \"age\")).toEqual([\n      { name: \"apple\", age: 42 },\n      { name: \"kiwi\", age: 42 },\n      { name: \"kiwi\", age: 12 },\n    ]);\n    expect(sortByDESC(array, [\"name\", \"age\"])).toEqual([\n      { name: \"kiwi\", age: 42 },\n      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },", "      { name: \"kiwi\", age: 12 },\n      { name: \"apple\", age: 42 },\n    ]);\n  });\n\n  test(\"compare object \uc801\uc6a9\", () => {\n    const array = [\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },", "      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ];\n\n    expect(sortByDESC(array, \"user.name\")).toEqual([\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },", "      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ]);\n    expect(sortByDESC(array, [\"user.age\", \"user.name\"])).toEqual([\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ]);\n    expect(sortByDESC(array, \"user.name[0]\")).toEqual([", "    ]);\n    expect(sortByDESC(array, \"user.name[0]\")).toEqual([\n      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n    ]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {", "\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const array = new Array(9000000).fill({ name: \"apple\", age: 242 });\n\n    expect(sortByDESC(array, \"name\")).toEqual(array);\n  });\n});\n\ndescribe(\"sortByGroups\", () => {\n  test(\"\ud68c\uc0ac \uc624\ub984\ucc28\uc21c\", () => {", "describe(\"sortByGroups\", () => {\n  test(\"\ud68c\uc0ac \uc624\ub984\ucc28\uc21c\", () => {\n    const groups = [\"\ud68c\uc7a5\", \"\uc0ac\uc7a5\", \"\ubd80\uc7a5\", \"\ub300\ub9ac\", \"\uc0ac\uc6d0\"];\n\n    expect(\n      sortByGroups([\"\ub300\ub9ac\", \"\uc0ac\uc6d0\", \"\uc0ac\uc7a5\", \"\ud68c\uc7a5\", \"\ubd80\uc7a5\"], groups)\n    ).toEqual([\"\ud68c\uc7a5\", \"\uc0ac\uc7a5\", \"\ubd80\uc7a5\", \"\ub300\ub9ac\", \"\uc0ac\uc6d0\"]);\n  });\n\n  test(\"\uc624\ub984\ucc28\uc21c \ub0b4\ub9bc\ucc28\uc21c\", () => {", "\n  test(\"\uc624\ub984\ucc28\uc21c \ub0b4\ub9bc\ucc28\uc21c\", () => {\n    const array = [5, \"banana\", 4, \"apple\", \"kiwi\", 1];\n    const groups = [4, \"apple\", \"kiwi\", \"banana\"];\n\n    expect(sortByGroups(array, groups, false)).toEqual([\n      5,\n      1,\n      \"banana\",\n      \"kiwi\",", "      \"banana\",\n      \"kiwi\",\n      \"apple\",\n      4,\n    ]);\n    expect(sortByGroups(array, groups)).toEqual([\n      4,\n      \"apple\",\n      \"kiwi\",\n      \"banana\",", "      \"kiwi\",\n      \"banana\",\n      1,\n      5,\n    ]);\n  });\n\n  test(\"\ubc30\uc5f4, \uadf8\ub8f9 \uc544\ubb34 \uac83\ub3c4 \uc5c6\ub294 \uacbd\uc6b0\", () => {\n    expect(sortByGroups([], [])).toEqual([]);\n  });", "    expect(sortByGroups([], [])).toEqual([]);\n  });\n\n  test(\"\uadf8\ub8f9\uc5d0\ub294 \uc5c6\ub294\ub370, \ubc30\uc5f4\uc5d0\ub294 \uc874\uc7ac\ud558\ub294 \uacbd\uc6b0\", () => {\n    const array = [\"banana\", \"cherry\", \"kiwi\", \"apple\", \"grape\"];\n    const groups = [\"apple\", \"kiwi\", \"banana\"];\n\n    expect(sortByGroups(array, groups)).toEqual([\n      \"apple\",\n      \"kiwi\",", "      \"apple\",\n      \"kiwi\",\n      \"banana\",\n      \"cherry\",\n      \"grape\",\n    ]);\n  });\n\n  test(\"\uadf8\ub8f9\uc5d0\ub294 \uc874\uc7ac\ud558\uc9c0\ub9cc, \ubc30\uc5f4\uc5d0\ub294 \uc5c6\ub294 \uacbd\uc6b0\", () => {\n    const array = [\"banana\", \"kiwi\", \"apple\", \"cherr1\"];", "  test(\"\uadf8\ub8f9\uc5d0\ub294 \uc874\uc7ac\ud558\uc9c0\ub9cc, \ubc30\uc5f4\uc5d0\ub294 \uc5c6\ub294 \uacbd\uc6b0\", () => {\n    const array = [\"banana\", \"kiwi\", \"apple\", \"cherr1\"];\n    const groups = [\"apple\", \"kiwi\", \"banana\", \"cherry\"];\n\n    expect(sortByGroups(array, groups)).toEqual([\n      \"apple\",\n      \"kiwi\",\n      \"banana\",\n      \"cherr1\",\n    ]);", "      \"cherr1\",\n    ]);\n  });\n});\n"]}
{"filename": "test/includesByCho.spec.ts", "chunked_list": ["import { includesByCho, makeRegexByCho } from \"../src/includesByCho\";\n\ndescribe(\"includesByCho\", () => {\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3131\ub098\ub2e4\ub77c\ub9c8\ubc14\u3145\";\n    expect(makeRegexByCho(search)).toEqual(/([\uac00-\uae4b]\ub098\ub2e4\ub77c\ub9c8\ubc14[\uc0ac-\uc2f7])/g);\n  });\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3131\u3131\";\n    expect(makeRegexByCho(search)).toEqual(/([\uac00-\uae4b][\uac00-\uae4b])/g);", "    const search = \"\u3131\u3131\";\n    expect(makeRegexByCho(search)).toEqual(/([\uac00-\uae4b][\uac00-\uae4b])/g);\n  });\n});\n\ndescribe(\"includesByCho\", () => {\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3131\";\n    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(true);", "    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(true);\n  });\n\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3147\";\n    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(false);\n  });\n", "  });\n\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3137\u3139\";\n    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(true);\n  });\n\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3131\u3139\";", "  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\", () => {\n    const search = \"\u3131\u3139\";\n    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(false);\n  });\n\n  test(\"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac to \uac00\u3134\u3137\ub77c\", () => {\n    const search = \"\uac00\u3134\u3137\ub77c\";\n    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(true);", "    const word = \"\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac\";\n    expect(includesByCho(search, word)).toEqual(true);\n  });\n});\n"]}
{"filename": "test/utils.spec.ts", "chunked_list": ["import {\n  isNumber,\n  chunkAtEnd,\n  makePercentByObject,\n  zeroPad,\n  reverseByObject,\n  reverseByArray,\n  getNestedProperty,\n  splitByKey,\n} from \"../src/utils\";", "  splitByKey,\n} from \"../src/utils\";\n\ndescribe(\"isNumber\", () => {\n  test(\"\uc22b\uc790\uac00 \uc544\ub2cc \uac12\", () => {\n    expect(isNumber(\"\")).toEqual(false);\n    expect(isNumber(null)).toEqual(false);\n    expect(isNumber(undefined)).toEqual(false);\n    expect(isNumber(NaN)).toEqual(false);\n    expect(isNumber(\"abc\")).toEqual(false);", "    expect(isNumber(NaN)).toEqual(false);\n    expect(isNumber(\"abc\")).toEqual(false);\n    expect(isNumber(\"test\")).toEqual(false);\n    expect(isNumber(\"100,000.123\")).toEqual(false);\n    expect(isNumber(true)).toEqual(false);\n    expect(isNumber(false)).toEqual(false);\n    expect(isNumber([])).toEqual(false);\n    expect(isNumber({})).toEqual(false);\n  });\n", "  });\n\n  test(\"\uc22b\uc790\", () => {\n    expect(isNumber(0)).toEqual(true);\n    expect(isNumber(123)).toEqual(true);\n    expect(isNumber(-123)).toEqual(true);\n    expect(isNumber(0.123)).toEqual(true);\n    expect(isNumber(123.213)).toEqual(true);\n  });\n});", "  });\n});\n\ndescribe(\"splitByKey\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(splitByKey(\"\")).toEqual([]);\n  });\n\n  test(\"[0].a\", () => {\n    expect(splitByKey(\"[0].a\")).toEqual([\"0\", \"a\"]);", "  test(\"[0].a\", () => {\n    expect(splitByKey(\"[0].a\")).toEqual([\"0\", \"a\"]);\n  });\n\n  test(\"name.detail\", () => {\n    expect(splitByKey(\"name.detail\")).toEqual([\"name\", \"detail\"]);\n  });\n});\n\ndescribe(\"getNestedProperty\", () => {", "\ndescribe(\"getNestedProperty\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(getNestedProperty(\"\", \"\")).toEqual(undefined);\n    expect(getNestedProperty(\"\", {})).toEqual(undefined);\n  });\n\n  test(\"[0].a\", () => {\n    expect(getNestedProperty(\"[2].a\", \"test\")).toEqual(undefined);\n    expect(getNestedProperty(splitByKey(\"[2].a\"), \"test\")).toEqual(undefined);", "    expect(getNestedProperty(\"[2].a\", \"test\")).toEqual(undefined);\n    expect(getNestedProperty(splitByKey(\"[2].a\"), \"test\")).toEqual(undefined);\n    expect(getNestedProperty(\"[0].a\", [{ a: 2 }, { b: 1 }])).toEqual(2);\n    expect(getNestedProperty(\"[0].a\", [{ b: 1 }, { a: 2 }])).toEqual(undefined);\n  });\n\n  test(\"name.detail\", () => {\n    expect(\n      getNestedProperty(\"name.detail\", { name: { detail: \"\ud14c\uc2a4\ud2b8\" } })\n    ).toEqual(\"\ud14c\uc2a4\ud2b8\");", "      getNestedProperty(\"name.detail\", { name: { detail: \"\ud14c\uc2a4\ud2b8\" } })\n    ).toEqual(\"\ud14c\uc2a4\ud2b8\");\n    expect(getNestedProperty(\"name.detail\", { name: \"\ud14c\uc2a4\ud2b8\" })).toEqual(\n      undefined\n    );\n  });\n});\n\ndescribe(\"zeroPad\", () => {\n  test(\"5\", () => {", "describe(\"zeroPad\", () => {\n  test(\"5\", () => {\n    expect(zeroPad(5, 2)).toEqual(\"05\");\n  });\n\n  test(\"test\", () => {\n    expect(zeroPad(\"test\", 10)).toEqual(\"000000test\");\n    expect(zeroPad(\"test\", 10, \"-\")).toEqual(\"------test\");\n  });\n", "  });\n\n  test(\"123\", () => {\n    expect(zeroPad(123, 2)).toEqual(\"123\");\n    expect(zeroPad(123, 5)).toEqual(\"00123\");\n    expect(zeroPad(123, 3, \"-\")).toEqual(\"123\");\n    expect(zeroPad(123, 0)).toEqual(\"123\");\n    expect(zeroPad(12345, 3)).toEqual(\"12345\");\n  });\n", "  });\n\n  test(\"\ube48\uac12\", () => {\n    expect(zeroPad(\"\", 3)).toEqual(\"000\");\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const result = new Array(10000000).fill(\"0\").join(\"\");\n    expect(zeroPad(\"\", 10000000)).toEqual(result);\n  });", "    expect(zeroPad(\"\", 10000000)).toEqual(result);\n  });\n});\n\ndescribe(\"chunkAtEnd\", () => {\n  test(\"abcdefg\", () => {\n    expect(chunkAtEnd(\"abcdefg\", 2)).toEqual([\"fg\", \"de\", \"bc\", \"a\"]);\n    expect(chunkAtEnd(\"abcdefg\", 4)).toEqual([\"defg\", \"abc\"]);\n  });\n", "  });\n\n  test(\"abc\", () => {\n    expect(chunkAtEnd(\"abc\")).toEqual([\"c\", \"b\", \"a\"]);\n    expect(chunkAtEnd(\"abc\", 3)).toEqual([\"abc\"]);\n  });\n\n  test(\"00000001\", () => {\n    expect(chunkAtEnd(\"00000001\", 4)).toEqual([\"0001\", \"0000\"]);\n    expect(chunkAtEnd(\"00000001\", 2)).toEqual([\"01\", \"00\", \"00\", \"00\"]);", "    expect(chunkAtEnd(\"00000001\", 4)).toEqual([\"0001\", \"0000\"]);\n    expect(chunkAtEnd(\"00000001\", 2)).toEqual([\"01\", \"00\", \"00\", \"00\"]);\n  });\n\n  test(\"\ube48\uac12\", () => {\n    expect(chunkAtEnd(\"\")).toEqual([]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(400000).fill(\"0101\").join(\"\");", "  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(400000).fill(\"0101\").join(\"\");\n    const result = new Array(400000).fill(['1', '0', '1', '0']).flat();\n    expect(chunkAtEnd(input, 1)).toEqual(result);\n  });\n});\n\ndescribe(\"makePercentByObject\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(makePercentByObject({})).toEqual({});", "  test(\"\ube48\uac12\", () => {\n    expect(makePercentByObject({})).toEqual({});\n  });\n\n  test(\"3\uac1c \uac12\", () => {\n    expect(makePercentByObject({ a: 10, b: 20, c: 30 })).toEqual({\n      a: 16.67,\n      b: 33.33,\n      c: 50,\n    });", "      c: 50,\n    });\n  });\n\n  test(\"2\uac1c \uac12\", () => {\n    expect(makePercentByObject({ a: 0, b: 10 })).toEqual({ a: 0, b: 100 });\n  });\n});\n\ndescribe(\"reverseByObject\", () => {", "\ndescribe(\"reverseByObject\", () => {\n  test(\"Object\", () => {\n    expect(reverseByObject({ a: 1, b: 2, c: 3 })).toEqual({\n      1: \"a\",\n      2: \"b\",\n      3: \"c\",\n    });\n    expect(reverseByObject({ 1: \"a\", 2: \"b\", 3: \"c\" })).toEqual({\n      a: \"1\",", "    expect(reverseByObject({ 1: \"a\", 2: \"b\", 3: \"c\" })).toEqual({\n      a: \"1\",\n      b: \"2\",\n      c: \"3\",\n    });\n    expect(reverseByObject([\"a\", \"b\", \"c\"])).toEqual({\n      a: \"0\",\n      b: \"1\",\n      c: \"2\",\n    });", "      c: \"2\",\n    });\n  });\n});\n\ndescribe(\"reverseByArray\", () => {\n  test(\"Array\", () => {\n    expect(\n      reverseByArray([\n        [[\"\uc2b5\ub2c8\ub2e4\"], [\"\ub2e4\", \"\uc5b4\", \"\uc74c\"]],", "      reverseByArray([\n        [[\"\uc2b5\ub2c8\ub2e4\"], [\"\ub2e4\", \"\uc5b4\", \"\uc74c\"]],\n        [[\"\uc785\ub2c8\ub2e4\"], [\"\uc774\ub2e4\"]],\n      ])\n    ).toEqual([\n      [[\"\uc774\ub2e4\"], [\"\uc785\ub2c8\ub2e4\"]],\n      [[\"\uc74c\", \"\uc5b4\", \"\ub2e4\"], [\"\uc2b5\ub2c8\ub2e4\"]],\n    ]);\n  });\n", "  });\n\n  test(\"Array\", () => {\n    expect(reverseByArray([1, 2, 3, [4, [5, 6, 7]]])).toEqual([\n      [[7, 6, 5], 4],\n      3,\n      2,\n      1,\n    ]);\n  });", "    ]);\n  });\n});\n"]}
{"filename": "test/convertKey.spec.ts", "chunked_list": ["import { convertKey } from \"../src/convertKey\";\n\ndescribe(\"convertKey\", () => {\n  test(\"\uc601\uc5b4\ub85c \ubcc0\ud658\", () => {\n    expect(convertKey(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\", \"en\")).toEqual(\"dkssyd dkssyd rmfjgrnaks!\");\n  });\n\n  test(\"\ud55c\uae00\ub85c \ubcc0\ud658\", () => {\n    expect(convertKey(\"dkssyd dkssyd rmfjgrnaks!\", \"ko\")).toEqual(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\");\n  });", "    expect(convertKey(\"dkssyd dkssyd rmfjgrnaks!\", \"ko\")).toEqual(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\");\n  });\n\n  test(\"\ud55c\uae00\ub85c \ubcc0\ud658 - \ud569\uce58\uae30 X\", () => {\n    expect(convertKey(\"dkssyd dkssyd rmfjgrnaks!\", \"ko\", false)).toEqual(\"\u3147\u314f\u3134\u3134\u315b\u3147 \u3147\u314f\u3134\u3134\u315b\u3147 \u3131\u3161\u3139\u3153\u314e\u3131\u315c\u3141\u314f\u3134!\");\n  });\n\n  test(\"hello world!\", () => {\n    expect(convertKey(\"\u3157\ub514\u3163\u3150 \uc7ac\uae45!\", \"en\")).toEqual(\"hello world!\");\n  });", "    expect(convertKey(\"\u3157\ub514\u3163\u3150 \uc7ac\uae45!\", \"en\")).toEqual(\"hello world!\");\n  });\n\n  test(\"\u3157\ub514\u3163\u3150 \uc7ac\uae45!\", () => {\n    expect(convertKey(\"hello world!\", \"ko\")).toEqual(\"\u3157\ub514\u3163\u3150 \uc7ac\uae45!\");\n  });\n\n  test(\"\uc774\uc0c1\ud55c \uc5b8\uc5b4\", () => {\n    expect(convertKey(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\", \"special\")).toEqual(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\");\n  });", "    expect(convertKey(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\", \"special\")).toEqual(\"\uc548\ub1fd \uc548\ub1fd \uadf8\ub807\uad6c\ub9cc!\");\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8(\uc601\uc5b4)\", () => {\n    const input = new Array(1000000).fill(\"\u3157\u3137\u3163\u3163\u3150 \u3148\u3150\u3131\u3163\u3147!\").join('')\n    const result = new Array(1000000).fill(\"hello world!\").join('');\n    expect(convertKey(input, \"en\")).toEqual(result);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8(\ud55c\uad6d\uc5b4)\", () => {", "\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8(\ud55c\uad6d\uc5b4)\", () => {\n    const input = new Array(1000000).fill(\"hello world!\").join('');\n    const result = new Array(1000000).fill(\"\u3157\u3137\u3163\u3163\u3150 \u3148\u3150\u3131\u3163\u3147!\").join('')\n    expect(convertKey(input, \"ko\", false)).toEqual(result);\n  });\n});\n"]}
{"filename": "test/combine.spec.ts", "chunked_list": ["import { combine, combineByCode, combineHangul } from \"../src/combine\";\n\ndescribe(\"combineByCode\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(combineByCode()).toEqual(\"\uac00\");\n  });\n\n  test(\"\uc774\uc0c1\ud55c \uac12\", () => {\n    expect(combineByCode(-1, -1, -1)).toEqual(\"\");\n  });", "    expect(combineByCode(-1, -1, -1)).toEqual(\"\");\n  });\n\n  test(\"\uae4b\", () => {\n    expect(combineByCode(1, 0, -1)).toEqual(\"\uae4b\");\n  });\n});\n\ndescribe(\"combine\", () => {\n  test(\"\ube48\uac12\", () => {", "describe(\"combine\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(combine()).toEqual(\"\");\n  });\n\n  test(\"\ud55c\uae00\uc774 \uc544\ub2cc \uac12\", () => {\n    expect(combine(\"a\")).toEqual(\"a\");\n  });\n\n  test(\"\uc544\", () => {", "\n  test(\"\uc544\", () => {\n    expect(combine(\"\u3147\", \"\u314f\")).toEqual(\"\uc544\");\n  });\n\n  test(\"\uc548\", () => {\n    expect(combine(\"\u3147\", \"\u314f\", \"\u3134\")).toEqual(\"\uc548\");\n  });\n\n  test(\"\ubdc1\", () => {", "\n  test(\"\ubdc1\", () => {\n    expect(combine(\"\u3142\", \"\u315e\", \"\u313a\")).toEqual(\"\ubdc1\");\n    expect(combine(\"\u3142\", \"\u315c\u3154\", \"\u3139\u3131\")).toEqual(\"\ubdc1\");\n  });\n});\n\ndescribe(\"combineHangul\", () => {\n  test(\"\uac00\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3134\u314f\u3137\u314f\")).toEqual(\"\uac00\ub098\ub2e4\");", "  test(\"\uac00\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3134\u314f\u3137\u314f\")).toEqual(\"\uac00\ub098\ub2e4\");\n  });\n\n  test(\"\uac04\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac04\ub098\ub2e4\");\n  });\n\n  test(\"\uac12\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u3134\u314f\u3137\u314f\")).toEqual(\"\uac12\ub098\ub2e4\");", "  test(\"\uac12\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u3134\u314f\u3137\u314f\")).toEqual(\"\uac12\ub098\ub2e4\");\n  });\n\n  test(\"\uac12\u3134\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac12\u3134\ub098\ub2e4\");\n  });\n\n  test(\"\uac12\u3145\u3134\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u3145\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac12\u3145\u3134\ub098\ub2e4\");", "  test(\"\uac12\u3145\u3134\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u3145\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac12\u3145\u3134\ub098\ub2e4\");\n  });\n\n  test(\"\uac11\uc0ac\u314f\u3145\u3134\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u314f\u314f\u3145\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac11\uc0ac\u314f\u3145\u3134\ub098\ub2e4\");\n  });\n\n  test(\"\uac11\uc0ac\uc0b0\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u314f\u3145\u314f\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac11\uc0ac\uc0b0\ub098\ub2e4\");", "  test(\"\uac11\uc0ac\uc0b0\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u314f\u3145\u314f\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac11\uc0ac\uc0b0\ub098\ub2e4\");\n  });\n\n  test(\"\uac11\uc0bf\u3134\ub098\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u314f\u3145\u3134\u3134\u314f\u3137\u314f\")).toEqual(\"\uac11\uc0bf\u3134\ub098\ub2e4\");\n  });\n\n  test(\"\uac11\uc0bf\u3134\ub23c\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u314f\u3145\u3134\u3134\u315c\u3154\u3137\u314f\")).toEqual(\"\uac11\uc0bf\u3134\ub23c\ub2e4\");", "  test(\"\uac11\uc0bf\u3134\ub23c\ub2e4\", () => {\n    expect(combineHangul(\"\u3131\u314f\u3142\u3145\u314f\u3145\u3134\u3134\u315c\u3154\u3137\u314f\")).toEqual(\"\uac11\uc0bf\u3134\ub23c\ub2e4\");\n  });\n\n  test(\"\uc218\ubc15\", () => {\n    expect(combineHangul(\"\u3145\u315c\u3142\u314f\u3131\")).toEqual(\"\uc218\ubc15\");\n  });\n\n  test(\"\u3157\ub514\u3163\u3150 \uc7ac\uae45!\", () => {\n    expect(combineHangul(\"\u3157\u3137\u3163\u3163\u3150 \u3142\u314f\u3142\u3157\u3147!\")).toEqual(\"\u3157\ub514\u3163\u3150 \ubc14\ubd09!\");", "  test(\"\u3157\ub514\u3163\u3150 \uc7ac\uae45!\", () => {\n    expect(combineHangul(\"\u3157\u3137\u3163\u3163\u3150 \u3142\u314f\u3142\u3157\u3147!\")).toEqual(\"\u3157\ub514\u3163\u3150 \ubc14\ubd09!\");\n  });\n\n  test(\"\u3157\ub514\u3153\u3155\u315c\u3160\u3163\u3150 \ubc14\ubd09!\", () => {\n    expect(combineHangul(\"\u3157\u3137\u3163\u3153\u3155\u315c\u3160\u3163\u3150 \u3142\u314f\u3142\u3157\u3147!\")).toEqual(\n      \"\u3157\ub514\u3153\u3155\u315c\u3160\u3163\u3150 \ubc14\ubd09!\"\n    );\n  });\n", "  });\n\n  test(\"\u3157\ub514\u3153\u3147\u3145\u314e\u3147\u3147\u3147\uc5ec\u315c\u3160\u3163\u3150 \ubc14\ubd09\", () => {\n    expect(\n      combineHangul(\"\u3157\u3137\u3163\u3153\u3147\u3145\u314e\u3147\u3147\u3147\u3147\u3155\u315c\u3160\u3163\u3150 \u3142\u314f\u3142\u3157\u3147!\")\n    ).toEqual(\"\u3157\ub514\u3153\u3147\u3145\u314e\u3147\u3147\u3147\uc5ec\u315c\u3160\u3163\u3150 \ubc14\ubd09!\");\n  });\n\n  test(\"\ube48\uac12\", () => {\n    expect(combineHangul()).toEqual(\"\");", "  test(\"\ube48\uac12\", () => {\n    expect(combineHangul()).toEqual(\"\");\n  });\n\n  test(\"\ud55c\uae00\uc774 \uc544\ub2cc \uac12\", () => {\n    expect(combineHangul(\"Ab!6k+@_ @\")).toEqual(\"Ab!6k+@_ @\");\n  });\n\n  test(\"\uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(combineHangul([\"\u3147\u314f\u3134\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\"])).toEqual(\"\uc548\ub155\ud558\uc138\uc694\");", "  test(\"\uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(combineHangul([\"\u3147\u314f\u3134\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\"])).toEqual(\"\uc548\ub155\ud558\uc138\uc694\");\n    expect(combineHangul(\"\u3147\u314f\u3134\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\")).toEqual(\"\uc548\ub155\ud558\uc138\uc694\");\n    expect(combineHangul([[\"\u3147\u314f\u3134\u3148\"], [\"\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\"]])).toEqual(\n      \"\uc549\ub155\ud558\uc138\uc694\"\n    );\n    expect(combineHangul([[\"\u3147\u314f\u3134\"], [\"\u3148\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\"]])).toEqual(\n      \"\uc548\u3148\ub155\ud558\uc138\uc694\"\n    );\n    expect(combineHangul([\"\u3147\u314f\u3134\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\"])).toEqual(\"\uc548\ub155\ud558\uc138\uc694\");", "    );\n    expect(combineHangul([\"\u3147\u314f\u3134\u3134\u3155\u3147\u314e\u314f\u3145\u3154\u3147\u315b\"])).toEqual(\"\uc548\ub155\ud558\uc138\uc694\");\n  });\n\n  test(\"\ubaa8\ub4e0 \uacbd\uc6b0\uc758 \uc218\", () => {\n    expect(\n      combineHangul([\n        [\"\u3142\u315c\", \"\u3154\", \"\u3139\u3131\"],\n        \"\u3145\",\n        \"\u3157\",", "        \"\u3145\",\n        \"\u3157\",\n        \"\u3150\",\n        \"\u3139\",\n        \"\u3141\",\n        [\"\u314e\u315c\u3154\u3142\u3145\"],\n        \"\u3131\",\n        [\"\u314f\", \"\u3145\", \"\u314f\"],\n      ])\n    ).toEqual(\"\ubdc1\uc1ce\ud70e\u3131\u314f\uc0ac\");", "      ])\n    ).toEqual(\"\ubdc1\uc1ce\ud70e\u3131\u314f\uc0ac\");\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill(\"\u3131\u314f\u3142\u3145\").join(\"\");\n    const result = new Array(1000000).fill(\"\uac12\").join(\"\");\n    expect(combineHangul(input)).toEqual(result);\n  });\n});", "  });\n});\n"]}
{"filename": "test/formatNumber.spec.ts", "chunked_list": ["import { formatNumber, formatNumberAll } from \"../src/formatNumber\";\n\ndescribe(\"formatNumber\", () => {\n  test(\"1234\", () => {\n    expect(formatNumber(1234)).toEqual(\"1234\");\n  });\n\n  test(\"12345678\", () => {\n    expect(formatNumber(\"12345678\")).toEqual(\"1234\ub9cc 5678\");\n  });", "    expect(formatNumber(\"12345678\")).toEqual(\"1234\ub9cc 5678\");\n  });\n\n  test(\"0001\", () => {\n    expect(formatNumber(\"0001\")).toEqual(\"1\");\n  });\n\n  test(\"0001\", () => {\n    expect(formatNumber(123456789)).toEqual(\"1\uc5b5 2345\ub9cc 6789\");\n  });", "    expect(formatNumber(123456789)).toEqual(\"1\uc5b5 2345\ub9cc 6789\");\n  });\n\n  test(\"0001\", () => {\n    expect(formatNumber(\"1234567890123456\")).toEqual(\n      \"1234\uc870 5678\uc5b5 9012\ub9cc 3456\"\n    );\n  });\n\n  test(\"0001\", () => {", "\n  test(\"0001\", () => {\n    expect(formatNumber(\"0000000000000001\")).toEqual(\"1\");\n  });\n\n  test(\"\uc22b\uc790\uac00 \uc544\ub2cc \uac12\", () => {\n    expect(formatNumber(\"abc\")).toEqual(\"\");\n    expect(formatNumber(null)).toEqual(\"\");\n    expect(formatNumber(undefined)).toEqual(\"\");\n  });", "    expect(formatNumber(undefined)).toEqual(\"\");\n  });\n});\n\ndescribe(\"formatNumberAll\", () => {\n  test(\"1234\", () => {\n    expect(formatNumberAll(1234)).toEqual(\"\ucc9c\uc774\ubc31\uc0bc\uc2ed\uc0ac\");\n  });\n\n  test(\"12345678\", () => {", "\n  test(\"12345678\", () => {\n    expect(formatNumberAll(\"12345678\")).toEqual(\n      \"\ucc9c\uc774\ubc31\uc0bc\uc2ed\uc0ac\ub9cc \uc624\ucc9c\uc721\ubc31\uce60\uc2ed\ud314\"\n    );\n  });\n\n  test(\"0001\", () => {\n    expect(formatNumberAll(\"0001\")).toEqual(\"\uc77c\");\n  });", "    expect(formatNumberAll(\"0001\")).toEqual(\"\uc77c\");\n  });\n\n  test(\"123456789\", () => {\n    expect(formatNumberAll(123456789)).toEqual(\n      \"\uc77c\uc5b5 \uc774\ucc9c\uc0bc\ubc31\uc0ac\uc2ed\uc624\ub9cc \uc721\ucc9c\uce60\ubc31\ud314\uc2ed\uad6c\"\n    );\n  });\n\n  test(\"1234567890123456\", () => {", "\n  test(\"1234567890123456\", () => {\n    expect(formatNumberAll(\"1234567890123456\")).toEqual(\n      \"\ucc9c\uc774\ubc31\uc0bc\uc2ed\uc0ac\uc870 \uc624\ucc9c\uc721\ubc31\uce60\uc2ed\ud314\uc5b5 \uad6c\ucc9c\uc2ed\uc774\ub9cc \uc0bc\ucc9c\uc0ac\ubc31\uc624\uc2ed\uc721\"\n    );\n  });\n\n  test(\"0000000000000001\", () => {\n    expect(formatNumberAll(\"0000000000000001\")).toEqual(\"\uc77c\");\n  });", "    expect(formatNumberAll(\"0000000000000001\")).toEqual(\"\uc77c\");\n  });\n\n  test(\"\uc22b\uc790\uac00 \uc544\ub2cc \uac12\", () => {\n    expect(formatNumberAll(\"abc\")).toEqual(\"\");\n    expect(formatNumberAll(null)).toEqual(\"\");\n    expect(formatNumberAll(undefined)).toEqual(\"\");\n  });\n});\n", "});\n"]}
{"filename": "test/isCho.spec.ts", "chunked_list": ["import { isChoByChar, isCho, isChoByGroups } from \"../src/isCho\";\n\ndescribe(\"isChoByChar\", () => {\n  test(\"\u3131\", () => {\n    expect(isChoByChar(\"\u3131\")).toEqual(true);\n  });\n\n  test(\"\u3134\", () => {\n    expect(isChoByChar(\"\u3134\")).toEqual(true);\n  });", "    expect(isChoByChar(\"\u3134\")).toEqual(true);\n  });\n\n  test(\"\u314e\", () => {\n    expect(isChoByChar(\"\u314e\")).toEqual(true);\n  });\n\n  test(\"\u314f\", () => {\n    expect(isChoByChar(\"\u314f\")).toEqual(false);\n  });", "    expect(isChoByChar(\"\u314f\")).toEqual(false);\n  });\n\n  test(\"\u3153\", () => {\n    expect(isChoByChar(\"\u3153\")).toEqual(false);\n  });\n\n  test(\"\uc57c\", () => {\n    expect(isChoByChar(\"\uc57c\")).toEqual(false);\n  });", "    expect(isChoByChar(\"\uc57c\")).toEqual(false);\n  });\n});\n\ndescribe(\"isCho\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(isCho(\"\")).toEqual(false);\n  });\n\n  test(\"\u3131\u314e\u3134\", () => {", "\n  test(\"\u3131\u314e\u3134\", () => {\n    expect(isCho(\"\u3131\u314e\u3134\")).toEqual(true);\n  });\n\n  test(\"\u314e\u314e\u314e\", () => {\n    expect(isCho(\"\u314e\u314e\u314e\")).toEqual(true);\n  });\n\n  test(\"\u314e\u3134a\", () => {", "\n  test(\"\u314e\u3134a\", () => {\n    expect(isCho(\"\u314e\u3134a\")).toEqual(false);\n  });\n\n  test(\"hello\", () => {\n    expect(isCho(\"hello\")).toEqual(false);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {", "\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u3131').join('')\n    expect(isCho(input)).toEqual(true);\n  });\n});\n\ndescribe(\"isChoByGroups\", () => {\n  test(\"\ube48\uac12\", () => {\n    expect(isChoByGroups(\"\")).toEqual([]);", "  test(\"\ube48\uac12\", () => {\n    expect(isChoByGroups(\"\")).toEqual([]);\n  });\n\n  test(\"\u3131\u314e\u3134\", () => {\n    expect(isChoByGroups(\"\u3131\u314e\u3134\")).toEqual([true, true, true]);\n  });\n\n  test(\"\u314e\u3134a\", () => {\n    expect(isChoByGroups(\"\u314e\u3134a\")).toEqual([true, true, false]);", "  test(\"\u314e\u3134a\", () => {\n    expect(isChoByGroups(\"\u314e\u3134a\")).toEqual([true, true, false]);\n  });\n\n  test(\"\u314e\u314f\u313e\u3146\", () => {\n    expect(isChoByGroups(\"\u314e\u314f\u313e\u3146\")).toEqual([true, false, false, true]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u3131').join('')", "  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u3131').join('')\n    const result = new Array(1000000).fill(true);\n    expect(isChoByGroups(input)).toEqual(result);\n  });\n});\n"]}
{"filename": "test/isHangul.spec.ts", "chunked_list": ["import { isHangul, isHangulByCode, isHangulByGroups } from \"../src/isHangul\";\n\ndescribe(\"isHangulByCode\", () => {\n  test(\"\uc870\ud569\ub41c \ud55c\uae00 \uac12\", () => {\n    expect(isHangulByCode(\"\uc544\".charCodeAt(0))).toEqual(true);\n    expect(isHangulByCode(\"\ubdc1\".charCodeAt(0))).toEqual(true);\n  });\n\n  test(\"\uc870\ud569\ub41c \ud55c\uae00 \uc544\ub2cc \uac12\", () => {\n    expect(isHangulByCode(\"1\".charCodeAt(0))).toEqual(false);", "  test(\"\uc870\ud569\ub41c \ud55c\uae00 \uc544\ub2cc \uac12\", () => {\n    expect(isHangulByCode(\"1\".charCodeAt(0))).toEqual(false);\n    expect(isHangulByCode(\"s\".charCodeAt(0))).toEqual(false);\n    expect(isHangulByCode(\"@\".charCodeAt(0))).toEqual(false);\n    expect(isHangulByCode(\"\u3131\".charCodeAt(0))).toEqual(false);\n    expect(isHangulByCode(\"\u314f\".charCodeAt(0))).toEqual(false);\n  });\n});\n\ndescribe(\"isHangul\", () => {", "\ndescribe(\"isHangul\", () => {\n  test(\"\ud55c\uae00 \uac12\", () => {\n    expect(isHangul(\"\uc790\")).toEqual(true);\n    expect(isHangul(\"\uc548\ub155\ud558\uc138\uc694\")).toEqual(true);\n    expect(isHangul(\"\uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8\")).toEqual(true);\n  });\n\n  test(\"\ud55c\uae00 \uc544\ub2cc \uac12 \ud3ec\ud568\", () => {\n    expect(isHangul(\"Hello, world!\")).toEqual(false);", "  test(\"\ud55c\uae00 \uc544\ub2cc \uac12 \ud3ec\ud568\", () => {\n    expect(isHangul(\"Hello, world!\")).toEqual(false);\n    expect(isHangul(\"12345\")).toEqual(false);\n    expect(isHangul(\"\uc548\ub155\ud558\uc138\uc694, Hello, world!\")).toEqual(false);\n    expect(isHangul(\"Hello! \uc548\ub155!\")).toEqual(false);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\uac12').join('')\n    expect(isHangul(input)).toEqual(true);", "    const input = new Array(1000000).fill('\uac12').join('')\n    expect(isHangul(input)).toEqual(true);\n  });\n});\n\ndescribe(\"isHangulByGroups\", () => {\n  test(\"\uc548\ub155\ud558\uc138\uc694\", () => {\n    expect(isHangulByGroups(\"\uc548\ub155\ud558\uc138\uc694\")).toEqual([\n      true,\n      true,", "      true,\n      true,\n      true,\n      true,\n      true,\n    ]);\n  });\n  test(\"\uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8.\", () => {\n    expect(isHangulByGroups(\"\uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8.\")).toEqual([\n      true,", "    expect(isHangulByGroups(\"\uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8.\")).toEqual([\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n      false,\n    ]);\n  });", "    ]);\n  });\n\n  test(\"Hello, \uc548\ub155!\", () => {\n    expect(isHangulByGroups(\"Hello, \uc548\ub155!\")).toEqual([\n      false,\n      false,\n      false,\n      false,\n      false,", "      false,\n      false,\n      false,\n      false,\n      true,\n      true,\n      false,\n    ]);\n  });\n", "  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\uac12').join('')\n    const result = new Array(1000000).fill(true);\n    expect(isHangulByGroups(input)).toEqual(result);\n  });\n});\n", ""]}
{"filename": "test/normalize.spec.ts", "chunked_list": ["import { normalize } from \"../src/normalize\";\n\ndescribe(\"normalize\", () => {\n  test(\"\uc0ac\uacfc\", () => {\n    expect(normalize('\uc0ac\uacfc')).toEqual('sa gwa');\n  });\n\n  test(\"\uc774\ud0c8\ub9ac\uc544\", () => {\n    expect(normalize('\uc774\ud0c8\ub9ac\uc544')).toEqual('i tar ri a');\n    expect(normalize('\uc774\ud0c8\ub9ac\uc544', false)).toEqual('itarria');", "    expect(normalize('\uc774\ud0c8\ub9ac\uc544')).toEqual('i tar ri a');\n    expect(normalize('\uc774\ud0c8\ub9ac\uc544', false)).toEqual('itarria');\n  });\n\n  test(\"\uadf8 \uc678\", () => {\n    expect(normalize('\uadf8 \uc678')).toEqual('geu oe');\n  });\n\n  test(\"\uc0ac\uacfc! \uadf8\ub9ac\uace0 sagwa!\", () => {\n    expect(normalize('\uc0ac\uacfc! \uadf8\ub9ac\uace0 sagwa!')).toEqual('sa gwa ! geu ri go sagwa!');", "  test(\"\uc0ac\uacfc! \uadf8\ub9ac\uace0 sagwa!\", () => {\n    expect(normalize('\uc0ac\uacfc! \uadf8\ub9ac\uace0 sagwa!')).toEqual('sa gwa ! geu ri go sagwa!');\n    expect(normalize('\uc0ac\uacfc! \uadf8\ub9ac\uace0 sagwa!', false)).toEqual('sagwa! geurigo sagwa!');\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(100000).fill('\uc0ac\uacfc! \uadf8\ub9ac\uace0 sagwa!').join('');\n    const result = new Array(100000).fill('sa gwa ! geu ri go sagwa!').join('');  \n    expect(normalize(input)).toEqual(result);\n  });", "    expect(normalize(input)).toEqual(result);\n  });\n});\n"]}
{"filename": "test/josa.spec.ts", "chunked_list": ["import { formatJosa, josa } from \"../src/josa\";\n\ndescribe(\"formatJosa\", () => {\n  test(\"\uc870\uc0ac\", () => {\n    expect(josa(\"\uc601\ud76c\", '\ub294')).toEqual('\ub294');\n  });\n});\n\ndescribe(\"formatJosa\", () => {\n  test(\"\uc870\uc0ac\", () => {", "describe(\"formatJosa\", () => {\n  test(\"\uc870\uc0ac\", () => {\n    expect(formatJosa(\"I have an apple[\uc740/\ub294]\")).toEqual(\"I have an apple[\uc740/\ub294]\");\n    expect(formatJosa(\"[\uc740/\ub294]\")).toEqual(\"[\uc740/\ub294]\");\n    expect(formatJosa(\"\uc601\ud76c[\uc740/\ub294]\")).toEqual(\"\uc601\ud76c\ub294\");\n    expect(formatJosa(\"\uc778\uc0dd[\uc774\ub780/\ub780]\")).toEqual(\"\uc778\uc0dd\uc774\ub780\");\n    expect(formatJosa(\"\uc778\uc0dd[\ub780/\ud14c\uc2a4\ud2b8]\")).toEqual(\"\uc778\uc0dd\uc774\ub780\");\n  });\n\n  test(\"\ube48\uac12\", () => {", "\n  test(\"\ube48\uac12\", () => {\n    expect(formatJosa()).toEqual(\"\");\n  });\n});\n"]}
{"filename": "test/isJung.spec.ts", "chunked_list": ["import { isJungByCode, isJung, isJungByGroups } from \"../src/isJung\";\n\ndescribe(\"isJungByCode\", () => {\n  test(\"\u314f\", () => {\n    expect(isJungByCode(\"\u314f\".charCodeAt(0))).toEqual(true);\n  });\n\n  test(\"\u3131\", () => {\n    expect(isJungByCode(\"\u3131\".charCodeAt(0))).toEqual(false);\n  });", "    expect(isJungByCode(\"\u3131\".charCodeAt(0))).toEqual(false);\n  });\n\n  test(\"a\", () => {\n    expect(isJungByCode(\"a\".charCodeAt(0))).toEqual(false);\n  });\n});\n\ndescribe(\"isJung\", () => {\n  test(\"\u314f\u3163\u315c\", () => {", "describe(\"isJung\", () => {\n  test(\"\u314f\u3163\u315c\", () => {\n    expect(isJung(\"\u314f\u3163\u315c\")).toEqual(true);\n  });\n\n  test(\"\u314f\u3131\u3163 \", () => {\n    expect(isJung(\"\u314f\u3131\u3163\")).toEqual(false);\n  });\n\n  test(\"\ube48\uac12\", () => {", "\n  test(\"\ube48\uac12\", () => {\n    expect(isJung(\"\")).toEqual(false);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u315c').join('')\n    expect(isJung(input)).toEqual(true);\n  });\n});", "  });\n});\n\ndescribe(\"isJungByGroups\", () => {\n  test(\"\u314f\u3163\u315c\", () => {\n    expect(isJungByGroups(\"\u314f\u3163\u315c\")).toEqual([true, true, true]);\n  });\n\n  test(\"\u314f\u3131\u3163\", () => {\n    expect(isJungByGroups(\"\u314f\u3131\u3163\")).toEqual([true, false, true]);", "  test(\"\u314f\u3131\u3163\", () => {\n    expect(isJungByGroups(\"\u314f\u3131\u3163\")).toEqual([true, false, true]);\n  });\n\n  test(\"\ube48\uac12\", () => {\n    expect(isJungByGroups(\"\")).toEqual([]);\n  });\n\n  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u314f').join('')", "  test(\"\uc2dc\uac04\ucd08\uacfc \ud14c\uc2a4\ud2b8\", () => {\n    const input = new Array(1000000).fill('\u314f').join('')\n    const result = new Array(1000000).fill(true);\n    expect(isJungByGroups(input)).toEqual(result);\n  });\n});\n"]}
{"filename": "src/encode.ts", "chunked_list": ["import { chunkAtEnd } from \"./utils\";\n\nconst a = [\n  escape,\n  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 3).join(\"\"),\n  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 4).join(\"\"),\n  (t: string) => chunkAtEnd(t).join(\"\"),\n  (t: string) =>\n    t\n      .split(\"\")", "    t\n      .split(\"\")\n      .map((v, i) => (i % 3 === 0 ? v + w() : v))\n      .join(\"\"),\n  (t: string) =>\n    t.slice(Math.floor(t.length / 2), t.length) +\n    t.slice(0, Math.floor(t.length / 2)),\n];\nconst s = JSON.stringify;\nconst b = btoa;", "const s = JSON.stringify;\nconst b = btoa;\nconst e = encodeURI;\nconst w = (): any => Math.floor(Math.random() * (a.length));\n\nexport function encode(t: any = \"\", l: number = 0): any {\n  const _t = w();\n\n  const c = l % 3 === 0 ? b(e(s(t))) : a[_t](t);\n\n  return l === 5\n    ? _t + b(e(c))\n    : encode((l % 2 === 1 ? _t : \"\") + c + (l % 2 === 0 ? _t : \"\"), l + 1);\n}\n\nconst n = [\n  unescape,\n  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 3).join(\"\"),\n  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 4).join(\"\"),\n  (t: string) => chunkAtEnd(t).join(\"\"),\n  (t: string) =>\n    t\n      .split(\"\")\n      .map((v, i) => ((i - 1) % 4 === 0 ? \"\" : v))\n      .join(\"\"),\n  (t: string) =>\n    t.slice(Math.ceil(t.length / 2), t.length) +\n    t.slice(0, Math.ceil(t.length / 2)),\n];\nconst x = atob;\nconst d = decodeURI;\nconst p = JSON.parse;\n", "export function decode(t: any = \"\", l: number = 5): any {\n  const _t =\n    l % 2 === 1\n      ? [t.slice(1, t.length), t[0]]\n      : [t.slice(0, t.length - 1), t[t.length - 1]];\n\n  const h = l === 5 ? d(x(_t[0])) : _t[0];\n\n  const c = l % 3 === 0 ? p(d(x(h))) : n[_t[1]](h);\n\n  return l === 0 ? c : decode(c, l - 1);\n}\n"]}
{"filename": "src/normalize.ts", "chunked_list": ["import { NORMALIZE_CHO, NORMALIZE_JUNG, NORMALIZE_JONG } from \"./constant\";\nimport { divideHangulByGroups } from \"./divide\";\n\ntype recordTypes = { cho: number; jung: number; jong: number };\n\nexport function normalize(text: string, isSpace: boolean = true) {\n  const divided = divideHangulByGroups(text, {\n    isSplit: false,\n    resultType: \"index\",\n  }) as recordTypes[];\n\n  const space = isSpace ? \" \" : \"\";\n\n  return divided\n    .map((hangul: recordTypes) => {\n      const char =\n        NORMALIZE_CHO[hangul.cho] +\n        NORMALIZE_JUNG[hangul.jung] +\n        NORMALIZE_JONG[hangul.jong];\n\n      return char ? char + space : hangul;\n    })\n    .join(\"\")\n    .replace(/\\s{2,}/g, ' ')\n    .trim();\n}\n"]}
{"filename": "src/isCho.ts", "chunked_list": ["import { JONG_COMPLETE_HANGUL } from \"./constant\";\nimport { isJongByCode } from \"./isJong\";\n\nexport function isChoByChar(cho: string = \"\") {\n  return isJongByCode(cho.charCodeAt(0)) && !JONG_COMPLETE_HANGUL[cho];\n}\n\nexport function isCho(word: string = \"\") {\n  for (let index = 0; index < word.length; index++) {\n    if (!isChoByChar(word[index])) return false;\n  }\n\n  return !!word;\n}\n", "  for (let index = 0; index < word.length; index++) {\n    if (!isChoByChar(word[index])) return false;\n  }\n\n  return !!word;\n}\n\nexport function isChoByGroups(word: string = \"\") {\n  return word.toString().split(\"\").map(isChoByChar);\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type LocalTypes = \"ko\" | \"en\" | \"number\" | \"special\" | \"etc\";\n\nexport type DivideOptionTypes = {\n  isSplit?: boolean;\n  resultType?: \"object\" | \"string\" | \"array\" | \"index\";\n};\n\nexport type TypingOptionTypes = {\n  content?: string;\n  speed?: number;\n};\n"]}
{"filename": "src/constant.ts", "chunked_list": ["export const CHO_HANGUL = [\n  '\u3131', '\u3132', '\u3134', '\u3137', '\u3138',\n  '\u3139', '\u3141', '\u3142','\u3143', '\u3145',\n  '\u3146', '\u3147', '\u3148', '\u3149', '\u314a',\n  '\u314b', '\u314c', '\u314d', '\u314e',\n];\nexport const JUNG_HANGUL = [\n  '\u314f', '\u3150', '\u3151', '\u3152', '\u3153', '\u3154', \n  '\u3155', '\u3156', '\u3157', '\u3158', '\u3159', '\u315a', \n  '\u315b', '\u315c', '\u315d', '\u315e', '\u315f', ", "  '\u3155', '\u3156', '\u3157', '\u3158', '\u3159', '\u315a', \n  '\u315b', '\u315c', '\u315d', '\u315e', '\u315f', \n  '\u3160', '\u3161', '\u3162', '\u3163',\n];\nexport const JONG_HANGUL = [\n  '', '\u3131', '\u3132', '\u3133', '\u3134', '\u3135', '\u3136', \n  '\u3137', '\u3139', '\u313a', '\u313b', '\u313c', '\u313d', '\u313e', \n  '\u313f', '\u3140', '\u3141', '\u3142', '\u3144', '\u3145', '\u3146', \n  '\u3147', '\u3148', '\u314a', '\u314b', '\u314c', '\u314d','\u314e',\n];", "  '\u3147', '\u3148', '\u314a', '\u314b', '\u314c', '\u314d','\u314e',\n];\n\nexport const JUNG_COMPLETE_HANGUL: Record<string, string> = {\n  \u3158: '\u3157\u314f',\n  \u3159: '\u3157\u3150',\n  \u315a: '\u3157\u3163',\n  \u315d: '\u315c\u3153',\n  \u315e: '\u315c\u3154',\n  \u315f: '\u315c\u3163',", "  \u315e: '\u315c\u3154',\n  \u315f: '\u315c\u3163',\n  \u3162: '\u3161\u3163',\n};\n\nexport const JONG_COMPLETE_HANGUL: Record<string, string> = {\n  \u3133: '\u3131\u3145',\n  \u3135: '\u3134\u3148',\n  \u3136: '\u3134\u314e',\n  \u313a: '\u3139\u3131',", "  \u3136: '\u3134\u314e',\n  \u313a: '\u3139\u3131',\n  \u313b: '\u3139\u3141',\n  \u313c: '\u3139\u3142',\n  \u313d: '\u3139\u3145',\n  \u313e: '\u3139\u314c',\n  \u313f: '\u3139\u314d',\n  \u3140: '\u3139\u314e',\n  \u3144: '\u3142\u3145',\n};", "  \u3144: '\u3142\u3145',\n};\n\nexport const JUNG_START_CHARCODE = JUNG_HANGUL[0].charCodeAt(0);\nexport const JUNG_END_CHARCODE = JUNG_HANGUL[JUNG_HANGUL.length-1].charCodeAt(0);\n\nexport const JONG_START_CHARCODE = JONG_HANGUL[1].charCodeAt(0);\nexport const JONG_END_CHARCODE = JONG_HANGUL[JONG_HANGUL.length-1].charCodeAt(0);\n\nexport const HANGUL_START_CHARCODE = '\uac00'.charCodeAt(0);", "\nexport const HANGUL_START_CHARCODE = '\uac00'.charCodeAt(0);\nexport const HANGUL_END_CHARCODE = '\ud7a3'.charCodeAt(0);\n\nexport const CHO_PERIOD = '\uae4c'.charCodeAt(0) - '\uac00'.charCodeAt(0);\nexport const JONG_PERIOD = '\uac1c'.charCodeAt(0) - '\uac00'.charCodeAt(0);\n\n// use covertKey function\nexport const KEY_MAPS: Record<string, string> = {\n  \u3142: \"q\", \u3143: \"Q\", \u3148: \"w\", \u3149: \"W\",", "export const KEY_MAPS: Record<string, string> = {\n  \u3142: \"q\", \u3143: \"Q\", \u3148: \"w\", \u3149: \"W\",\n  \u3137: \"e\", \u3138: \"E\", \u3131: \"r\", \u3132: \"R\",\n  \u3145: \"t\", \u3146: \"T\", \u315b: \"y\", \u3155: \"u\",\n  \u3151: \"i\", \u3150: \"o\", \u3152: \"O\", \u3154: \"p\", \n  \u3156: \"P\", \u3141: \"a\", \u3134: \"s\",\u3147: \"d\",\n  \u3139: \"f\", \u314e: \"g\", \u3157: \"h\",\u3153: \"j\",\n  \u314f: \"k\", \u3163: \"l\", \u314b: \"z\", \u314c: \"x\",\n  \u314a: \"c\", \u314d: \"v\", \u3160: \"b\", \u315c: \"n\",\n  \u3161: \"m\",", "  \u314a: \"c\", \u314d: \"v\", \u3160: \"b\", \u315c: \"n\",\n  \u3161: \"m\",\n};\n\n// use formatNumber function\nexport const numberUnits = [\"\", \"\uc77c\", \"\uc774\", \"\uc0bc\", \"\uc0ac\", \"\uc624\", \"\uc721\", \"\uce60\", \"\ud314\", \"\uad6c\"];\n\nexport const tenUnits = [\"\", \"\uc2ed\", \"\ubc31\", \"\ucc9c\"];\n\nexport const thousandUnits = [\"\", \"\ub9cc\", \"\uc5b5\", \"\uc870\", \"\uacbd\", \"\ud574\"];", "\nexport const thousandUnits = [\"\", \"\ub9cc\", \"\uc5b5\", \"\uc870\", \"\uacbd\", \"\ud574\"];\n\n// use formatDate function\nexport const WEEK_DAY = [\"\uc77c\", \"\uc6d4\", \"\ud654\", \"\uc218\", \"\ubaa9\", \"\uae08\", \"\ud1a0\"];\n\n// use josa function\nexport const JOSA_LIST: Record<string, string> = {\n  \uc774: \"\uc774/\uac00\",\n  \uac00: \"\uc774/\uac00\",", "  \uc774: \"\uc774/\uac00\",\n  \uac00: \"\uc774/\uac00\",\n  \uc744: \"\uc744/\ub97c\",\n  \ub97c: \"\uc744/\ub97c\",\n  \uc740: \"\uc740/\ub294\",\n  \ub294: \"\uc740/\ub294\",\n  \uc73c\ub85c: \"\uc73c\ub85c/\ub85c\",\n  \ub85c: \"\uc73c\ub85c/\ub85c\",\n  \uc640: \"\uc640/\uacfc\",\n  \uacfc: \"\uc640/\uacfc\",", "  \uc640: \"\uc640/\uacfc\",\n  \uacfc: \"\uc640/\uacfc\",\n  \uc774\ub098: \"\uc774\ub098/\ub098\",\n  \ub098: \"\uc774\ub098/\ub098\",\n  \uc774\uc5d0: \"\uc774\uc5d0/\uc5d0\",\n  \uc5d0: \"\uc774\uc5d0/\uc5d0\",\n  \uc774\ub780: \"\uc774\ub780/\ub780\",\n  \ub780: \"\uc774\ub780/\ub780\",\n}\n", "}\n\n// use normalize function\nexport const NORMALIZE_CHO = [\n  \"g\", \"gg\", \"n\", \"d\", \"dd\",\n  \"r\", \"m\", \"b\", \"bb\", \"s\",\n  \"ss\", \"\", \"j\", \"jj\", \"c\",\n  \"k\", \"t\", \"p\", \"h\"\n];\n", "];\n\nexport const NORMALIZE_JUNG = [\n \"a\", \"ae\", \"ya\", \"yae\", \"eo\",\n \"e\", \"yeo\", \"ye\", \"o\", \"wa\",\n \"wae\", \"oe\", \"yo\", \"u\", \"weo\",\n \"we\", \"wi\", \"yu\", \"eu\", \"eui\",\n \"i\"\n]\nexport const NORMALIZE_JONG = [", "]\nexport const NORMALIZE_JONG = [\n  \"\", \"g\", \"gg\", \"gs\", \"n\", \"nj\",\n  \"nh\", \"d\", \"r\", \"rk\", \"rm\", \n  \"rb\", \"rs\", \"rt\", \"rp\", \"rh\", \n  \"m\", \"b\", \"bs\", \"s\", \"ss\", \n  \"ng\", \"j\", \"c\", \"k\", \"t\", \n  \"p\", \"h\"\n]", "]"]}
{"filename": "src/convertKey.ts", "chunked_list": ["import { combineHangul } from \"./combine\";\nimport { KEY_MAPS } from \"./constant\";\nimport { divideHangul } from \"./divide\";\nimport { LocalTypes } from \"./types\";\nimport { reverseByObject } from \"./utils\";\n\nconst REVERSE_MAPS: Record<string, string> = reverseByObject(KEY_MAPS);\n\nfunction toKo(english: string = \"\") {\n  return english\n    .toString()\n    .split(\"\")\n    .map((char) => REVERSE_MAPS[char] || char)\n    .join(\"\");\n}\n", "function toKo(english: string = \"\") {\n  return english\n    .toString()\n    .split(\"\")\n    .map((char) => REVERSE_MAPS[char] || char)\n    .join(\"\");\n}\n\nfunction toEn(korean: string = \"\") {\n  return korean\n    .toString()\n    .split(\"\")\n    .map((char) => KEY_MAPS[char] || char)\n    .join(\"\");\n}\n", "function toEn(korean: string = \"\") {\n  return korean\n    .toString()\n    .split(\"\")\n    .map((char) => KEY_MAPS[char] || char)\n    .join(\"\");\n}\n\nexport function convertKey(\n  word: string = \"\",\n  toLanguage: LocalTypes = \"ko\",\n  isCombine: boolean = true\n) {\n  const hangul = (\n    isCombine ? divideHangul(word) : word.toString().split(\"\")\n  ).join(\"\");\n\n  // \ud55c\ud0c0\ub85c \ubcc0\ud658", "export function convertKey(\n  word: string = \"\",\n  toLanguage: LocalTypes = \"ko\",\n  isCombine: boolean = true\n) {\n  const hangul = (\n    isCombine ? divideHangul(word) : word.toString().split(\"\")\n  ).join(\"\");\n\n  // \ud55c\ud0c0\ub85c \ubcc0\ud658\n  if (toLanguage === \"ko\") {\n    return isCombine ? combineHangul(toKo(hangul)) : toKo(hangul);\n  }\n\n  // \uc601\ud0c0\ub85c \ubcc0\ud658", "  if (toLanguage === \"ko\") {\n    return isCombine ? combineHangul(toKo(hangul)) : toKo(hangul);\n  }\n\n  // \uc601\ud0c0\ub85c \ubcc0\ud658\n  if (toLanguage === \"en\") {\n    return toEn(hangul);\n  }\n\n  return word;\n}\n"]}
{"filename": "src/banmal.ts", "chunked_list": ["import { reverseByArray } from \"./utils\";\n\nconst FIRST_REGEX = /(\\s)?(^[\uac00-\ud7a3]{0,3}|[\uac00-\ud7a3]{1,3})(\\s*)/;\nconst LAST_REGEX = /([\\.|\\,|\\s])/;\n\nconst formater = [\n  [[\"\uc2b5\ub2c8\ub2e4\"], [\"\ub2e4\"]],\n  [[\"\uc8fc\uc138\uc694\"], [\"\ub77c\"]],\n  [[\"\uc785\ub2c8\ub2e4\"], [\"\uc774\ub2e4\"]],\n  [[\"\ud569\ub2c8\ub2e4\"], [\"\ud558\ub2e4\"]],", "  [[\"\uc785\ub2c8\ub2e4\"], [\"\uc774\ub2e4\"]],\n  [[\"\ud569\ub2c8\ub2e4\"], [\"\ud558\ub2e4\"]],\n  [[\"\uc635\ub2c8\ub2e4\"], [\"\uc628\ub2e4\"]],\n  [[\"\ub429\ub2c8\ub2e4\"], [\"\ub41c\ub2e4\"]],\n  [[\"\uac11\ub2c8\ub2e4\"], [\"\uac04\ub2e4\"]],\n  [[\"\uae41\ub2c8\ub2e4\"], [\"\uae34\ub2e4\"]],\n  [[\"\uc2ed\ub2c8\ub2e4\"], [\"\uc2e0\ub2e4\"]],\n  [[\"\ub78d\ub2c8\ub2e4\"], [\"\ub780\ub2e4\"]],\n  [[\"\uc800\ub294\"], [\"\ub098\ub294\"]],\n];", "  [[\"\uc800\ub294\"], [\"\ub098\ub294\"]],\n];\n\nconst makeRegByFormater = (array: any) => {\n  const result: string[] = [];\n\n  array.forEach((caseList: any) => {\n    const case1List = caseList[0].map(\n      (case1: string) =>\n        new RegExp(FIRST_REGEX.source + case1 + LAST_REGEX.source, \"g\")", "      (case1: string) =>\n        new RegExp(FIRST_REGEX.source + case1 + LAST_REGEX.source, \"g\")\n    );\n\n    const list = case1List.reduce(\n      (acc2: RegExp[], regex: RegExp) =>\n        acc2.concat(\n          caseList[1].map((case2: string) => [\n            regex,\n            `$1\u037e$2\u037e$3\u037e${case2.split(\"\").join(\"\u037e\")}\u037e$4`,", "            regex,\n            `$1\u037e$2\u037e$3\u037e${case2.split(\"\").join(\"\u037e\")}\u037e$4`,\n          ])\n        ),\n      []\n    );\n\n    result.push(...list);\n  });\n", "  });\n\n  return result;\n};\n\nconst BANMAL_REGEX_LIST = makeRegByFormater(formater);\nconst HONORIFIC_REGEX_LIST = makeRegByFormater(reverseByArray(formater));\n\nexport function toBanmal(string: string) {\n  return BANMAL_REGEX_LIST.reduce(\n    (acc: string, [$1, $2]: any) => acc.replace($1, $2),\n    string\n  ).replace(/\u037e/g, \"\");\n}\n", "export function toBanmal(string: string) {\n  return BANMAL_REGEX_LIST.reduce(\n    (acc: string, [$1, $2]: any) => acc.replace($1, $2),\n    string\n  ).replace(/\u037e/g, \"\");\n}\n\nexport function toHonorific(string: string) {\n  return HONORIFIC_REGEX_LIST.reduce(\n    (acc: string, [$1, $2]: any) => acc.replace($1, $2),\n    string\n  ).replace(/\u037e/g, \"\");\n}\n"]}
{"filename": "src/isJong.ts", "chunked_list": ["import { JONG_START_CHARCODE, JONG_END_CHARCODE } from \"./constant\";\n\nexport function isJongByCode(jong: number = 0) {\n  return JONG_START_CHARCODE <= jong && jong <= JONG_END_CHARCODE;\n}\n\nexport function isJong(word: string = \"\") {\n  for (let index = 0; index < word.length; index++) {\n    if (!isJongByCode(word.charCodeAt(index))) return false;\n  }\n\n  return !!word;\n}\n", "    if (!isJongByCode(word.charCodeAt(index))) return false;\n  }\n\n  return !!word;\n}\n\nexport function isJongByGroups(word: string = \"\") {\n  const result: boolean[] = [];\n\n  for (let index = 0; index < word.length; index++) {\n    result.push(isJongByCode(word.charCodeAt(index)));\n  }\n\n  return result;\n}\n", "  for (let index = 0; index < word.length; index++) {\n    result.push(isJongByCode(word.charCodeAt(index)));\n  }\n\n  return result;\n}\n"]}
{"filename": "src/isHangul.ts", "chunked_list": ["import { HANGUL_END_CHARCODE, HANGUL_START_CHARCODE } from \"./constant\";\n\nexport function isHangulByCode(hangul: number = 0) {\n  return HANGUL_START_CHARCODE <= hangul && hangul <= HANGUL_END_CHARCODE;\n}\n\nexport function isHangul(word: string = \"\") {\n  for (let index = 0; index < word.length; index++) {\n    if (!isHangulByCode(word.charCodeAt(index))) return false;\n  }\n\n  return !!word;\n}\n", "    if (!isHangulByCode(word.charCodeAt(index))) return false;\n  }\n\n  return !!word;\n}\n\nexport function isHangulByGroups(word: string = \"\") {\n  const result: boolean[] = [];\n\n  for (let index = 0; index < word.length; index++) {\n    result.push(isHangulByCode(word.charCodeAt(index)));\n  }\n\n  return result;\n}\n", "  for (let index = 0; index < word.length; index++) {\n    result.push(isHangulByCode(word.charCodeAt(index)));\n  }\n\n  return result;\n}\n"]}
{"filename": "src/josa.ts", "chunked_list": ["import { HANGUL_START_CHARCODE, JONG_PERIOD, JOSA_LIST } from \"./constant\";\n\nexport function josa(letter: string = \"\", _josa: string = \"\uc774\") {\n  const hasJong =\n    (letter.charCodeAt(letter.length - 1) - HANGUL_START_CHARCODE) %\n      JONG_PERIOD >\n    0;\n  const josaIndex = hasJong ? 0 : 1;\n\n  const josa = _josa.replace(/\\[|\\]/g, \"\");\n\n  const josaCase = getJosaCasc(josa.split(\"/\")[0]) || josa;\n\n  return josaCase.split(\"/\")[josaIndex] ?? josa;\n}\n\n// \uc624\ub298[\uc740/\ub294] \uc0ac\uacfc[\uc774/\uac00]", "export function formatJosa(letter: string = \"\") {\n  return letter.replace(\n    /[\uac00-\ud7a3]\\[[\uac00-\ud7a3]+\\/[\uac00-\ud7a3]+\\]/g,\n    (match) => match[0] + josa(match[0], match.slice(1))\n  );\n}\n\nfunction getJosaCasc(josa: string = \"\") {\n  return JOSA_LIST[josa] ?? josa;\n}\n"]}
{"filename": "src/isJung.ts", "chunked_list": ["import { JUNG_START_CHARCODE, JUNG_END_CHARCODE } from \"./constant\";\n\nexport function isJungByCode(jung: number = 0) {\n  return JUNG_START_CHARCODE <= jung && jung <= JUNG_END_CHARCODE;\n}\n\nexport function isJung(word: string = \"\") {\n  for (let index = 0; index < word.length; index++) {\n    if (!isJungByCode(word.charCodeAt(index))) return false;\n  }\n\n  return !!word;\n}\n", "    if (!isJungByCode(word.charCodeAt(index))) return false;\n  }\n\n  return !!word;\n}\n\nexport function isJungByGroups(word: string = \"\") {\n  const result: boolean[] = [];\n\n  for (let index = 0; index < word.length; index++) {\n    result.push(isJungByCode(word.charCodeAt(index)));\n  }\n\n  return result;\n}\n", "  for (let index = 0; index < word.length; index++) {\n    result.push(isJungByCode(word.charCodeAt(index)));\n  }\n\n  return result;\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export function isNumber(input: any) {\n  return typeof input === \"number\" && !isNaN(input);\n}\n\nexport function splitByKey(key: string = \"\"): string[] {\n  return key.match(/[\u3131-\ud7a3a-zA-Z0-9]+/g) ?? ([] as any);\n}\n\nexport function getNestedProperty(\n  key: string[] | string = [],\n  object: any = {}\n) {\n  const _key = typeof key === \"string\" ? splitByKey(key) : key;\n", "export function getNestedProperty(\n  key: string[] | string = [],\n  object: any = {}\n) {\n  const _key = typeof key === \"string\" ? splitByKey(key) : key;\n\n  if (!_key.length) return undefined;\n\n  return _key?.reduce((acc, v) => acc?.[v], object);\n}\n", "export function zeroPad(\n  string: number | string = \"\",\n  pow: number = 0,\n  pad: string = \"0\"\n) {\n  let result = String(string);\n  const padString = String(pad);\n\n  for (let i = pow - result.length; i > 0; i--) {\n    result = padString + result;\n  }\n\n  return result;\n}\n", "  for (let i = pow - result.length; i > 0; i--) {\n    result = padString + result;\n  }\n\n  return result;\n}\n\nexport function chunkAtEnd(value: string = \"\", n: number = 1) {\n  const result: string[] = [];\n\n  let start = value.length;\n", "  while ((start -= n) > 0) {\n    result.push(value.substring(start, start + n));\n  }\n\n  if (start > -n) {\n    result.push(value.substring(0, start + n));\n  }\n\n  return result;\n}\n", "export function makePercentByObject(object: any) {\n  const result: Record<string, number> = {};\n\n  let sum = 0;\n\n  for (const key in object) {\n    sum += object[key];\n  }\n\n  for (const key in object) {\n    if (isNumber(object[key])) {\n      result[key] = Number(((object[key] / sum) * 100).toFixed(2));\n    }\n  }\n\n  return result;\n}\n", "  for (const key in object) {\n    if (isNumber(object[key])) {\n      result[key] = Number(((object[key] / sum) * 100).toFixed(2));\n    }\n  }\n\n  return result;\n}\n\nexport function reverseByObject(object: any) {\n  const result: Record<string | number, string> = {};\n", "export function reverseByObject(object: any) {\n  const result: Record<string | number, string> = {};\n\n  for (const key in object) {\n    result[object[key]] = key;\n  }\n\n  return result;\n}\n\nexport function reverseByArray(array: any) {\n  const result: any = [];\n", "export function reverseByArray(array: any) {\n  const result: any = [];\n\n  for (let index = 0; index < array.length; index++) {\n    if (Array.isArray(array[index])) {\n      array[index] = reverseByArray(array[index]);\n    }\n\n    result.unshift(array[index]);\n  }\n\n  return result;\n}"]}
{"filename": "src/index.ts", "chunked_list": ["export { isCho, isChoByGroups } from \"./isCho\";\nexport { isJung, isJungByGroups } from \"./isJung\";\nexport { isJong, isJongByGroups } from \"./isJong\";\nexport { isHangul, isHangulByGroups } from \"./isHangul\";\n\nexport {\n  divideByJong,\n  divideByJung,\n  divideHangul,\n  divideHangulByGroups", "  divideHangul,\n  divideHangulByGroups\n} from \"./divide\";\n\nexport {\n  combineHangul,\n  combineByJung,\n  combineByJong,\n} from \"./combine\";\n", "} from \"./combine\";\n\nexport * from \"./formatDate\";\nexport * from \"./formatNumber\";\n\nexport * from \"./josa\";\nexport * from \"./banmal\";\n\nexport * from \"./encode\";\nexport * from './distance';", "export * from \"./encode\";\nexport * from './distance';\n\nexport * from \"./includesByCho\";\nexport * from \"./sortHangul\";\n\nexport * from \"./getLocal\";\nexport * from \"./convertKey\";\n\nexport * from './normalize';", "\nexport * from './normalize';\n\nexport * from './utils';"]}
{"filename": "src/includesByCho.ts", "chunked_list": ["import { combineByCode } from \"./combine\";\nimport { CHO_HANGUL } from \"./constant\";\n\nexport function makeRegexByCho(search: string = \"\") {\n  const regex = CHO_HANGUL.reduce(\n    (acc: string, cho: string, index: number) =>\n      acc.replace(\n        new RegExp(cho, \"g\"),\n        `[${combineByCode(index, 0, 0)}-${combineByCode(index + 1, 0, -1)}]`\n      ),\n    search\n  );\n\n  return new RegExp(`(${regex})`, \"g\");\n}\n", "export function includesByCho(search: string = \"\", word: string = \"\") {\n  return makeRegexByCho(search).test(word);\n}\n"]}
{"filename": "src/sortHangul.ts", "chunked_list": ["import { splitByKey, getNestedProperty, reverseByObject } from \"./utils\";\n\nconst intlCollator = Intl.Collator();\n\nfunction baseCompare(str1: any, str2: any, orderASC: boolean) {\n  if (orderASC) {\n    return intlCollator.compare(str1, str2);\n  }\n\n  return intlCollator.compare(str2, str1);\n}\n", "function baseSortBy(\n  array: any[] = [],\n  compare?: string[] | string,\n  orderASC: boolean = true\n) {\n  if (Array.isArray(compare)) {\n    const keys = compare.map((x) => splitByKey(x));\n\n    return array.sort((a, b) => {\n      for (let i = 0; i < compare.length; i++) {\n        const result = baseCompare(\n          getNestedProperty(keys[i], a),\n          getNestedProperty(keys[i], b),\n          orderASC\n        );\n", "      for (let i = 0; i < compare.length; i++) {\n        const result = baseCompare(\n          getNestedProperty(keys[i], a),\n          getNestedProperty(keys[i], b),\n          orderASC\n        );\n\n        if (result !== 0) return result;\n      }\n\n      return 0;\n    });\n  }\n", "  if (!compare) {\n    return array.sort((a, b) => baseCompare(a, b, orderASC));\n  }\n\n  const keys = splitByKey(compare);\n\n  return array.sort((a, b) =>\n    baseCompare(\n      getNestedProperty(keys, a),\n      getNestedProperty(keys, b),\n      orderASC\n    )\n  );\n}\n", "export function sortByASC(array: any[] = [], compare?: string[] | string) {\n  return baseSortBy(array, compare, true);\n}\n\nexport function sortByDESC(array: any[] = [], compare?: string[] | string) {\n  return baseSortBy(array, compare, false);\n}\n\n/**\n * orderASC: true -> \uc624\ub984\ucc28\uc21c\n * orderASC: false -> \ub0b4\ub9bc\ucc28\uc21c\n */", "export function sortByGroups(\n  array: any[] = [],\n  groups: (number | string)[] = [],\n  orderASC: boolean = true,\n  compare?: string\n) {\n  const objectBygroup: any = reverseByObject(groups);\n\n  const keys = splitByKey(compare);\n\n  const mapped = array.map((item, index) => {\n    return { index, value: compare ? getNestedProperty(keys, item) : item };\n  });\n\n  const baseSortByGroups = (a: any, b: any) => {\n    const status1 = objectBygroup[a.value] ?? -1;\n    const status2 = objectBygroup[b.value] ?? -1;\n\n    const condition1 = orderASC ? status1 - status2 : status2 - status1;\n    const condition2 = baseCompare(a.value, b.value, orderASC);\n", "    if (status1 === status2) {\n      return condition2 || 0;\n    }\n    if (status1 === -1) {\n      return orderASC ? 1 : -1;\n    }\n    if (status2 === -1) {\n      return orderASC ? -1 : 1;\n    }\n\n    return condition1 || condition2 || 0;\n  };\n\n  return mapped.sort(baseSortByGroups).map((item) => array[item.index]);\n}\n"]}
{"filename": "src/distance.ts", "chunked_list": ["import { divideHangul } from \"./divide\";\nimport { sortByASC } from \"./sortHangul\";\n\nfunction minBy(x1: number, x2: number, x3: number) {\n  return x1 > x2 ? (x2 > x3 ? x3 : x2) : x3 > x1 ? x1 : x3;\n}\n\nconst memo: any = {};\n\n// levenshtein distance\nexport function getDistance(first: string, second: string): number {", "export function getDistance(first: string, second: string): number {\n  if (first === second) return 0;\n  if (!first) return second.length;\n  if (!second) return first.length;\n\n  if (memo[first + '||' + second]) {\n    return memo[first + '||' + second];\n  }\n\n  const getDistance: number[][] = [[]];\n\n  // \ucd08\uae30\uac12 \uc124\uc815", "  for (let j = 0; j <= second.length; j++) {\n    getDistance[0][j] = j;\n  }\n\n  for (let i = 1; i <= first.length; i++) {\n    getDistance[i] = [i];\n\n    for (let j = 1; j <= second.length; j++) {\n      getDistance[i][j] = minBy(\n        getDistance[i - 1][j] + 1,\n        getDistance[i][j - 1] + 1,\n        getDistance[i - 1][j - 1] + (first[i - 1] === second[j - 1] ? 0 : 1)\n      );\n    }\n  }\n\n  memo[first + '||' + second] = getDistance[first.length][second.length];\n\n  return getDistance[first.length][second.length];\n}\n", "export function correctByDistance(\n  word: string,\n  list: string[],\n  option?: { distance?: number; maxSlice?: number; isSplit?: boolean }\n) {\n  const distance = option?.distance ?? Math.max(word.length / 2, 2);\n  const maxSlice = option?.maxSlice ?? 10;\n  const isSplit = option?.isSplit ?? true;\n\n  const minDist = [];\n\n  const dividedWord = divideHangul(word, true).join(\"\");\n", "  for (let index = 0; index < list.length; index++) {\n    const dist = isSplit\n      ? getDistance(dividedWord, divideHangul(list[index], true).join(\"\"))\n      : getDistance(word, list[index]);\n\n    if (dist <= distance) {\n      minDist.push({ dist, word: list[index] });\n    }\n  }\n\n  return sortByASC(minDist, \"dist\")\n    .slice(0, maxSlice)\n    .map((item) => item.word);\n}\n"]}
{"filename": "src/divide.ts", "chunked_list": ["import {\n  CHO_HANGUL,\n  JUNG_HANGUL,\n  JONG_HANGUL,\n  JUNG_COMPLETE_HANGUL,\n  JONG_COMPLETE_HANGUL,\n  CHO_PERIOD,\n  JONG_PERIOD,\n  HANGUL_START_CHARCODE,\n} from \"./constant\";", "  HANGUL_START_CHARCODE,\n} from \"./constant\";\n\nimport { isHangulByCode } from \"./isHangul\";\nimport { DivideOptionTypes } from \"./types\";\n\nexport function divide(word: string = \"\", option: DivideOptionTypes = {}) {\n  const { isSplit, resultType } = option;\n\n  const wordCode = word.charCodeAt(0);\n  const charCode = wordCode - HANGUL_START_CHARCODE;\n", "  if (!isHangulByCode(wordCode)) {\n    return [word[0]];\n  }\n\n  const choIndex = Math.floor(charCode / CHO_PERIOD);\n  const jungIndex = Math.floor((charCode % CHO_PERIOD) / JONG_PERIOD);\n  const jongIndex = charCode % JONG_PERIOD;\n\n  const cho = CHO_HANGUL[choIndex] || \"\";\n  const jung = JUNG_HANGUL[jungIndex] || \"\";\n  const jong = JONG_HANGUL[jongIndex] || \"\";\n\n  // \ub354 \uc138\ubd84\ud558\uac8c \ubd84\ub9ac\ud558\uae30 \u3159 -> \u3157\u3150\n  const dividedJung = isSplit ? divideByJung(jung) : jung;\n  const dividedJong = isSplit ? divideByJong(jong) : jong;\n", "  if (resultType === \"index\") {\n    return { cho: choIndex, jung: jungIndex, jong: jongIndex };\n  }\n\n  if (resultType === \"object\") {\n    return { cho, jung: dividedJung, jong: dividedJong };\n  }\n\n  if (resultType === \"string\") {\n    return cho + dividedJung + dividedJong;\n  }\n\n  return (cho + dividedJung + dividedJong).split(\"\");\n}\n", "  if (resultType === \"string\") {\n    return cho + dividedJung + dividedJong;\n  }\n\n  return (cho + dividedJung + dividedJong).split(\"\");\n}\n\nexport function divideHangulByGroups(\n  word: string = \"\",\n  option: DivideOptionTypes = {}\n) {\n  const isSplit = option?.isSplit ?? true;\n  const resultType = option?.resultType ?? \"array\";\n\n  return word\n    .toString()\n    .split(\"\")\n    .map((char) => divide(char, { isSplit, resultType }));\n}\n", "export function divideHangul(word: string = \"\", isSplit: boolean = true) {\n  const divided = word\n    .toString()\n    .split(\"\")\n    .map((char) => divide(char, { isSplit, resultType: \"string\" }))\n    .join(\"\");\n\n  return divided.split(\"\");\n}\n\nexport function divideByJung(jung: string) {\n  return JUNG_COMPLETE_HANGUL[jung] || jung;\n}\n", "export function divideByJung(jung: string) {\n  return JUNG_COMPLETE_HANGUL[jung] || jung;\n}\n\nexport function divideByJong(jong: string) {\n  return JONG_COMPLETE_HANGUL[jong] || jong;\n}\n"]}
{"filename": "src/combine.ts", "chunked_list": ["import {\n  CHO_HANGUL,\n  CHO_PERIOD,\n  HANGUL_START_CHARCODE,\n  JONG_COMPLETE_HANGUL,\n  JONG_HANGUL,\n  JUNG_COMPLETE_HANGUL,\n  JUNG_HANGUL,\n  JONG_PERIOD,\n} from \"./constant\";", "  JONG_PERIOD,\n} from \"./constant\";\n\nimport { reverseByObject } from \"./utils\";\n\nimport { isCho } from \"./isCho\";\nimport { isJung } from \"./isJung\";\nimport { isJong } from \"./isJong\";\nimport { isHangulByCode } from \"./isHangul\";\n", "import { isHangulByCode } from \"./isHangul\";\n\nconst fromCharCodeMemo: Record<number, string> = {};\n\nexport function combineByCode(\n  cho: number = 0,\n  jung: number = 0,\n  jong: number = 0\n) {\n  const hangulCode =\n    HANGUL_START_CHARCODE + cho * CHO_PERIOD + jung * JONG_PERIOD + jong;\n", "  if (!isHangulByCode(hangulCode)) {\n    return \"\";\n  }\n\n  if (!fromCharCodeMemo[hangulCode]) {\n    fromCharCodeMemo[hangulCode] = String.fromCharCode(hangulCode);\n  }\n\n  return fromCharCodeMemo[hangulCode];\n}\n", "export function combine(\n  cho: string = \"\",\n  jung: string = \"\",\n  jong: string = \"\"\n) {\n  const combineJung = combineByJung(jung);\n  const combineJong = combineByJong(jong);\n\n  const choIndex = CHO_HANGUL.indexOf(cho);\n  const jungIndex = JUNG_HANGUL.indexOf(combineJung);\n  const jongIndex = JONG_HANGUL.indexOf(combineJong);\n", "  if (choIndex === -1 || jungIndex === -1 || jongIndex === -1) {\n    return cho || combineJung || combineJong;\n  }\n\n  return combineByCode(choIndex, jungIndex, jongIndex);\n}\n\nfunction combineLoop(wordList: string[]) {\n  let index = 0;\n  const result: string[] = [];\n", "  while (index < wordList.length) {\n    const first = wordList[index++];\n\n    const cho = isCho(first) ? first : \"\";\n\n    const jung = cho && isJung(wordList[index]) ? wordList[index++] : \"\";\n\n    // \ucd08\uc131 \ub610\ub294 \uc911\uc131 \ud569\uccd0\uc9c0\uc9c0 \uc54a\uace0, \uc885\uc131 \uc758\ubbf8 X,\n    if (!cho || !jung) {\n      result.push(first);\n      continue;\n    }\n\n    // \uc911\uc131\uc774 \uc5c6\uc73c\uba74 \uc18c\uc6a9 X\n    const subJung = JUNG_COMPLETE_HANGUL[combineByJung(jung + wordList[index])]\n      ? wordList[index++]\n      : \"\";\n\n    // \ub2e4\uc74c \ubb38\uc790\uc5d0 \ubaa8\uc74c\uc774 \uc548\uc624\ub294 \uacbd\uc6b0 (\ud569\uccd0\uc9c8 \uac00\ub2a5\uc131 \uc874\uc7ac)\n    const jong =\n      isJong(wordList[index]) && !isJung(wordList[index + 1])\n        ? wordList[index++]\n        : \"\";\n\n    // \ub450 \ubb38\uc790 \ubaa8\ub450 \ucd08\uc131\uc774\uba74\uc11c (\uc774\ubbf8 \ud569\uccd0\uc9c4 \ubb38\uc790 X - \u3144, \u313a X)\n    // \ub2e4\uc74c \ubb38\uc790\uc5d0 \ubaa8\uc74c\uc774 \uc548\uc624\ub294 \uacbd\uc6b0 (\ud569\uccd0\uc9c8 \uac00\ub2a5\uc131 \uc874\uc7ac)\n    const subJong =\n      JONG_COMPLETE_HANGUL[combineByJong(jong + wordList[index])] &&\n      !isJung(wordList[index + 1])\n        ? wordList[index++]\n        : \"\";\n\n    result.push(combine(cho, jung + subJung, jong + subJong));\n  }\n\n  return result.join(\"\");\n}\n", "    if (!cho || !jung) {\n      result.push(first);\n      continue;\n    }\n\n    // \uc911\uc131\uc774 \uc5c6\uc73c\uba74 \uc18c\uc6a9 X\n    const subJung = JUNG_COMPLETE_HANGUL[combineByJung(jung + wordList[index])]\n      ? wordList[index++]\n      : \"\";\n\n    // \ub2e4\uc74c \ubb38\uc790\uc5d0 \ubaa8\uc74c\uc774 \uc548\uc624\ub294 \uacbd\uc6b0 (\ud569\uccd0\uc9c8 \uac00\ub2a5\uc131 \uc874\uc7ac)\n    const jong =\n      isJong(wordList[index]) && !isJung(wordList[index + 1])\n        ? wordList[index++]\n        : \"\";\n\n    // \ub450 \ubb38\uc790 \ubaa8\ub450 \ucd08\uc131\uc774\uba74\uc11c (\uc774\ubbf8 \ud569\uccd0\uc9c4 \ubb38\uc790 X - \u3144, \u313a X)\n    // \ub2e4\uc74c \ubb38\uc790\uc5d0 \ubaa8\uc74c\uc774 \uc548\uc624\ub294 \uacbd\uc6b0 (\ud569\uccd0\uc9c8 \uac00\ub2a5\uc131 \uc874\uc7ac)\n    const subJong =\n      JONG_COMPLETE_HANGUL[combineByJong(jong + wordList[index])] &&\n      !isJung(wordList[index + 1])\n        ? wordList[index++]\n        : \"\";\n\n    result.push(combine(cho, jung + subJung, jong + subJong));\n  }\n\n  return result.join(\"\");\n}\n", "export function combineHangul(str: string | (string | string[])[] = \"\") {\n  const word = typeof str === \"string\" ? str.toString().split(\"\") : str;\n\n  // Group \ud615\uc2dd\uc77c \ub54c, [ ['\u3131\u314f'], '\u3134\u314f', ['\u3137', '\u314f'] ]\n  const result: string[] = [];\n  const _temp: string[] = [];\n\n  for (let index = 0; index < word.length; index++) {\n    const item = word[index];\n\n    if (typeof item === \"string\") {\n      _temp.push(...item.toString().split(\"\"));\n    } else {\n      result.push(\n        combineLoop(_temp.splice(0)).concat(\n          combineLoop(item.join(\"\").split(\"\"))\n        )\n      );\n    }\n  }\n\n  result.push(combineLoop(_temp));\n\n  return result.join(\"\");\n}\n\nconst REVERSE_JUNG_COMPLETE = reverseByObject(JUNG_COMPLETE_HANGUL);\nconst REVERSE_JONG_COMPLETE = reverseByObject(JONG_COMPLETE_HANGUL);\n", "    if (typeof item === \"string\") {\n      _temp.push(...item.toString().split(\"\"));\n    } else {\n      result.push(\n        combineLoop(_temp.splice(0)).concat(\n          combineLoop(item.join(\"\").split(\"\"))\n        )\n      );\n    }\n  }\n\n  result.push(combineLoop(_temp));\n\n  return result.join(\"\");\n}\n\nconst REVERSE_JUNG_COMPLETE = reverseByObject(JUNG_COMPLETE_HANGUL);\nconst REVERSE_JONG_COMPLETE = reverseByObject(JONG_COMPLETE_HANGUL);\n", "export function combineByJung(jung: string) {\n  return REVERSE_JUNG_COMPLETE[jung] || jung;\n}\n\nexport function combineByJong(jong: string) {\n  return REVERSE_JONG_COMPLETE[jong] || jong;\n}\n"]}
{"filename": "src/formatNumber.ts", "chunked_list": ["import { chunkAtEnd, isNumber, zeroPad } from \"./utils\";\nimport { numberUnits, tenUnits, thousandUnits } from \"./constant\";\n\nexport function formatNumber(format: number | string | null = \"\") {\n  if (!isNumber(Number(format))) {\n    return \"\";\n  }\n\n  return chunkAtEnd(String(format), 4)\n    .reduce((acc, item, index) => {\n      const unit = thousandUnits[index] ?? \"\";\n", "      if (!Number(item)) {\n        return acc;\n      }\n\n      return `${Number(item)}${unit} ${acc}`;\n    }, \"\")\n    .trim();\n}\n\nexport function formatNumberAll(format: number | string | null = \"\") {\n  if (!isNumber(Number(format))) {\n    return \"\";\n  }\n\n  return chunkAtEnd(String(format), 4)\n    .reduce((acc, item, index) => {", "export function formatNumberAll(format: number | string | null = \"\") {\n  if (!isNumber(Number(format))) {\n    return \"\";\n  }\n\n  return chunkAtEnd(String(format), 4)\n    .reduce((acc, item, index) => {\n      if (!Number(item)) {\n        return acc;\n      }\n\n      let numberUnit = \"\";\n\n      const zeroItem = zeroPad(item, 4);\n", "      for (let i = 0; i < 4; i++) {\n        const number = Number(zeroItem[i]);\n\n        if (number) {\n          const unit = tenUnits[3 - i];\n\n          numberUnit += `${\n            unit && number === 1 ? \"\" : numberUnits[number]\n          }${unit}`;\n        }\n      }\n\n      const thousandUnit = thousandUnits[index] ?? \"\";\n\n      return `${numberUnit}${numberUnit ? thousandUnit : \"\"} ${acc}`;\n    }, \"\")\n    .trim();\n}\n"]}
{"filename": "src/getLocal.ts", "chunked_list": ["import { LocalTypes } from \"./types\";\nimport { makePercentByObject } from \"./utils\";\n\nconst LANGUAGE_REGEXP: Record<LocalTypes, RegExp> = {\n  ko: /^[\uac00-\ud7a3|\u3131-\u314e|\u314f-\u3163|\\s]+$/,\n  en: /^[a-zA-Z|\\s]+$/,\n  number: /^[0-9]+$/,\n  special: /^[\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\_\\+\\-\\=\\\\\\|\\{\\}\\[\\]\\;\\:\\'\\\"\\<\\,\\.\\>\\/\\?\\s]+$/,\n  etc: /.*/,\n};", "  etc: /.*/,\n};\n\nexport function getLocal(word: string = \"\") {\n  if (LANGUAGE_REGEXP[\"special\"].test(word)) {\n    return \"special\";\n  }\n\n  if (LANGUAGE_REGEXP[\"ko\"].test(word)) {\n    return \"ko\";\n  }\n", "  if (LANGUAGE_REGEXP[\"ko\"].test(word)) {\n    return \"ko\";\n  }\n\n  if (LANGUAGE_REGEXP[\"en\"].test(word)) {\n    return \"en\";\n  }\n\n  if (LANGUAGE_REGEXP[\"number\"].test(word)) {\n    return \"number\";\n  }\n\n  return \"etc\";\n}\n", "  if (LANGUAGE_REGEXP[\"number\"].test(word)) {\n    return \"number\";\n  }\n\n  return \"etc\";\n}\n\nexport function getLocalByGroups(\n  word: string = \"\",\n  isPercent: boolean = false,\n) {\n  const countObject = {\n    ko: 0,\n    en: 0,\n    number: 0,\n    special: 0,\n    etc: 0,\n  };\n  \n  const result: string[] = [];\n", "  for (let index = 0; index < word.length; index++) {\n    const language = getLocal(word[index]);\n\n    if (isPercent) {\n      countObject[language]++;\n    } else {\n      result.push(language);\n    }\n  }\n\n  if (isPercent) {\n    return makePercentByObject(countObject);\n  }\n\n  return result;\n}\n", "  if (isPercent) {\n    return makePercentByObject(countObject);\n  }\n\n  return result;\n}\n"]}
{"filename": "src/formatDate.ts", "chunked_list": ["import { zeroPad } from \"./utils\";\nimport { WEEK_DAY } from \"./constant\";\n\nconst DATE_REGEXER = /Y{2,4}|M{1,2}|D{1,2}|d{1,2}|H{1,2}|m{1,2}|s{1,2}/g;\n\n/**\n * @example\n * YY - 22, YYYY - 2022\n * M: 2, MM: 02,\n * D: 2, DD: 02,", " * M: 2, MM: 02,\n * D: 2, DD: 02,\n * d: 3, dd: '\ud654',\n * H: 2, HH: 02,\n * m: 2, mm: 02,\n * s: 2, ss: 02,\n */\nexport function formatDate(\n  _date: string | Date = new Date(),\n  formatStyle: string = \"YYYY\ub144MM\uc6d4DD\uc77c HH\uc2dcmm\ubd84ss\ucd08\"\n) {\n  const date = new Date(_date);\n\n  const year = zeroPad(date.getFullYear(), 4, \"0\");\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const hour = date.getHours();\n  const minute = date.getMinutes();\n  const second = date.getSeconds();\n  const week = date.getDay();\n", "  function matcher(match: string): any {\n    return (\n      {\n        YY: year.slice(-2),\n        YYYY: year,\n        M: month,\n        MM: zeroPad(month, 2, \"0\"),\n        D: day,\n        DD: zeroPad(day, 2, \"0\"),\n        d: week,\n        dd: WEEK_DAY[week],\n        H: hour,\n        HH: zeroPad(hour, 2, \"0\"),\n        m: minute,\n        mm: zeroPad(minute, 2, \"0\"),\n        s: second,\n        ss: zeroPad(second, 2, \"0\"),\n      }[match] || match\n    );\n  }\n\n  return (\n    formatStyle\n      .replace(DATE_REGEXER, matcher)\n      // \"\ub144\ub144\" \ubc29\uc9c0 -> \"\ub144\"\n      .replace(/(\ub144|\uc6d4|\uc77c|\uc2dc|\ubd84|\ucd08{1})(\ub144|\uc6d4|\uc77c|\uc2dc|\ubd84|\ucd08{1})+/g, \"$1\")\n      .replace(/\\s+/g, \" \")\n  );\n}\n"]}
