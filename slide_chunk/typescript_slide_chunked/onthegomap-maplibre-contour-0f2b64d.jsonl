{"filename": "src/dem-manager.ts", "chunked_list": ["import AsyncCache from \"./cache\";\nimport decodeImage from \"./decode-image\";\nimport { HeightTile } from \"./height-tile\";\nimport generateIsolines from \"./isolines\";\nimport { encodeIndividualOptions, withTimeout } from \"./utils\";\nimport {\n  CancelablePromise,\n  ContourTile,\n  DemTile,\n  Encoding,", "  DemTile,\n  Encoding,\n  FetchResponse,\n  IndividualContourTileOptions,\n} from \"./types\";\nimport encodeVectorTile, { GeomType } from \"./vtpbf\";\nimport { Timer } from \"./performance\";\n\n/**\n * Holds cached tile state, and exposes `fetchContourTile` which fetches the necessary", "/**\n * Holds cached tile state, and exposes `fetchContourTile` which fetches the necessary\n * tiles and returns an encoded contour vector tiles.\n */\nexport interface DemManager {\n  loaded: Promise<any>;\n  fetchTile(\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<FetchResponse>;\n  fetchAndParseTile(\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<DemTile>;\n  fetchContourTile(\n    z: number,\n    x: number,\n    y: number,\n    options: IndividualContourTileOptions,\n    timer?: Timer,\n  ): CancelablePromise<ContourTile>;\n}\n\n/**\n * Caches, decodes, and processes raster tiles in the current thread.\n */", "export class LocalDemManager implements DemManager {\n  tileCache: AsyncCache<string, FetchResponse>;\n  parsedCache: AsyncCache<string, DemTile>;\n  contourCache: AsyncCache<string, ContourTile>;\n  demUrlPattern: string;\n  encoding: Encoding;\n  maxzoom: number;\n  timeoutMs: number;\n  loaded = Promise.resolve();\n  decodeImage: (blob: Blob, encoding: Encoding) => CancelablePromise<DemTile> =\n    decodeImage;\n\n  constructor(\n    demUrlPattern: string,\n    cacheSize: number,\n    encoding: Encoding,\n    maxzoom: number,\n    timeoutMs: number,\n  ) {\n    this.tileCache = new AsyncCache(cacheSize);\n    this.parsedCache = new AsyncCache(cacheSize);\n    this.contourCache = new AsyncCache(cacheSize);\n    this.timeoutMs = timeoutMs;\n    this.demUrlPattern = demUrlPattern;\n    this.encoding = encoding;\n    this.maxzoom = maxzoom;\n  }\n\n  fetchTile(\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<FetchResponse> {\n    const url = this.demUrlPattern\n      .replace(\"{z}\", z.toString())\n      .replace(\"{x}\", x.toString())\n      .replace(\"{y}\", y.toString());\n    timer?.useTile(url);\n    return this.tileCache.getCancelable(url, () => {\n      let cancel = () => {};\n      const options: RequestInit = {};", "      try {\n        const controller = new AbortController();\n        options.signal = controller.signal;\n        cancel = () => controller.abort();\n      } catch (e) {\n        // ignore\n      }\n      timer?.fetchTile(url);\n      const mark = timer?.marker(\"fetch\");\n      return withTimeout(this.timeoutMs, {\n        value: fetch(url, options).then(async (response) => {\n          mark?.();", "          if (!response.ok) {\n            throw new Error(`Bad response: ${response.status} for ${url}`);\n          }\n          return {\n            data: await response.blob(),\n            expires: response.headers.get(\"expires\") || undefined,\n            cacheControl: response.headers.get(\"cache-control\") || undefined,\n          };\n        }),\n        cancel,\n      });\n    });\n  }\n  fetchAndParseTile = (\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<DemTile> => {\n    const self = this;\n    const url = this.demUrlPattern\n      .replace(\"{z}\", z.toString())\n      .replace(\"{x}\", x.toString())\n      .replace(\"{y}\", y.toString());\n\n    timer?.useTile(url);\n\n    return this.parsedCache.getCancelable(url, () => {\n      const tile = self.fetchTile(z, x, y, timer);\n      let canceled = false;\n      let alsoCancel = () => {};\n      return {\n        value: tile.value.then(async (response) => {", "          if (canceled) throw new Error(\"canceled\");\n          const result = self.decodeImage(response.data, self.encoding);\n          alsoCancel = result.cancel;\n          const mark = timer?.marker(\"decode\");\n          const value = await result.value;\n          mark?.();\n          return value;\n        }),\n        cancel: () => {\n          canceled = true;\n          alsoCancel();\n          tile.cancel();\n        },\n      };\n    });\n  };\n\n  fetchDem(\n    z: number,\n    x: number,\n    y: number,\n    options: IndividualContourTileOptions,\n    timer?: Timer,\n  ): CancelablePromise<HeightTile> {\n    const zoom = Math.min(z - (options.overzoom || 0), this.maxzoom);\n    const subZ = z - zoom;\n    const div = 1 << subZ;\n    const newX = Math.floor(x / div);\n    const newY = Math.floor(y / div);\n\n    const { value, cancel } = this.fetchAndParseTile(zoom, newX, newY, timer);\n    const subX = x % div;\n    const subY = y % div;\n\n    return {\n      value: value.then((tile) =>\n        HeightTile.fromRawDem(tile).split(subZ, subX, subY),\n      ),\n      cancel,\n    };\n  }\n\n  fetchContourTile(\n    z: number,\n    x: number,\n    y: number,\n    options: IndividualContourTileOptions,\n    timer?: Timer,\n  ): CancelablePromise<ContourTile> {\n    const {\n      levels,\n      multiplier = 1,\n      buffer = 1,\n      extent = 4096,\n      contourLayer = \"contours\",\n      elevationKey = \"ele\",\n      levelKey = \"level\",\n      subsampleBelow = 100,\n    } = options;\n\n    // no levels means less than min zoom with levels specified", "    if (!levels || levels.length === 0) {\n      return {\n        cancel() {},\n        value: Promise.resolve({ arrayBuffer: new ArrayBuffer(0) }),\n      };\n    }\n    const key = [z, x, y, encodeIndividualOptions(options)].join(\"/\");\n    return this.contourCache.getCancelable(key, () => {\n      const max = 1 << z;\n      let canceled = false;\n      const neighborPromises: (CancelablePromise<HeightTile> | null)[] = [];", "      for (let iy = y - 1; iy <= y + 1; iy++) {\n        for (let ix = x - 1; ix <= x + 1; ix++) {\n          neighborPromises.push(\n            iy < 0 || iy >= max\n              ? null\n              : this.fetchDem(z, (ix + max) % max, iy, options, timer),\n          );\n        }\n      }\n      const value = Promise.all(neighborPromises.map((n) => n?.value)).then(\n        async (neighbors) => {\n          let virtualTile = HeightTile.combineNeighbors(neighbors);", "          if (!virtualTile || canceled) {\n            return { arrayBuffer: new Uint8Array().buffer };\n          }\n          const mark = timer?.marker(\"isoline\");\n\n          if (virtualTile.width >= subsampleBelow) {\n            virtualTile = virtualTile.materialize(2);\n          } else {\n            while (virtualTile.width < subsampleBelow) {\n              virtualTile = virtualTile.subsamplePixelCenters(2).materialize(2);\n            }\n          }\n\n          virtualTile = virtualTile\n            .averagePixelCentersToGrid()\n            .scaleElevation(multiplier)\n            .materialize(1);\n\n          const isolines = generateIsolines(\n            levels[0],\n            virtualTile,\n            extent,\n            buffer,\n          );\n\n          mark?.();\n          const result = encodeVectorTile({\n            extent,\n            layers: {\n              [contourLayer]: {\n                features: Object.entries(isolines).map(([eleString, geom]) => {\n                  const ele = Number(eleString);\n                  return {\n                    type: GeomType.LINESTRING,\n                    geometry: geom,\n                    properties: {\n                      [elevationKey]: ele,\n                      [levelKey]: Math.max(\n                        ...levels.map((l, i) => (ele % l === 0 ? i : 0)),\n                      ),\n                    },\n                  };\n                }),\n              },\n            },\n          });\n          mark?.();\n\n          return { arrayBuffer: result.buffer };\n        },\n      );\n\n      return {\n        value,\n        cancel() {\n          canceled = true;\n          neighborPromises.forEach((n) => n && n.cancel());\n        },\n      };\n    });\n  }\n}\n", "            while (virtualTile.width < subsampleBelow) {\n              virtualTile = virtualTile.subsamplePixelCenters(2).materialize(2);\n            }\n          }\n\n          virtualTile = virtualTile\n            .averagePixelCentersToGrid()\n            .scaleElevation(multiplier)\n            .materialize(1);\n\n          const isolines = generateIsolines(\n            levels[0],\n            virtualTile,\n            extent,\n            buffer,\n          );\n\n          mark?.();\n          const result = encodeVectorTile({\n            extent,\n            layers: {\n              [contourLayer]: {\n                features: Object.entries(isolines).map(([eleString, geom]) => {\n                  const ele = Number(eleString);\n                  return {\n                    type: GeomType.LINESTRING,\n                    geometry: geom,\n                    properties: {\n                      [elevationKey]: ele,\n                      [levelKey]: Math.max(\n                        ...levels.map((l, i) => (ele % l === 0 ? i : 0)),\n                      ),\n                    },\n                  };\n                }),\n              },\n            },\n          });\n          mark?.();\n\n          return { arrayBuffer: result.buffer };\n        },\n      );\n\n      return {\n        value,\n        cancel() {\n          canceled = true;\n          neighborPromises.forEach((n) => n && n.cancel());\n        },\n      };\n    });\n  }\n}\n"]}
{"filename": "src/vtpbf.ts", "chunked_list": ["/*\nAdapted from vt-pbf https://github.com/mapbox/vt-pbf\n\nThe MIT License (MIT)\n\nCopyright (c) 2015 Anand Thakker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights", "of this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR", "\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n", "*/\n\nimport Pbf from \"pbf\";\n\nexport const enum GeomType {\n  UNKNOWN = 0,\n  POINT = 1,\n  LINESTRING = 2,\n  POLYGON = 3,\n}\n", "export type PropertyValue = string | boolean | number;\n\nexport interface Feature {\n  type: GeomType;\n  properties: { [key: string]: PropertyValue };\n  geometry: number[][];\n}\n\nexport interface Layer {\n  features: Feature[];\n  extent?: number;\n}\n", "export interface Layer {\n  features: Feature[];\n  extent?: number;\n}\n\nexport interface Tile {\n  extent?: number;\n  layers: { [id: string]: Layer };\n}\n\ninterface Context {\n  keys: string[];\n  values: PropertyValue[];\n  keycache: { [any: string]: number };\n  valuecache: { [any: string]: number };\n  feature?: Feature;\n}\n\n/**\n * Enodes and serializes a mapbox vector tile as an array of bytes.\n */", "interface Context {\n  keys: string[];\n  values: PropertyValue[];\n  keycache: { [any: string]: number };\n  valuecache: { [any: string]: number };\n  feature?: Feature;\n}\n\n/**\n * Enodes and serializes a mapbox vector tile as an array of bytes.\n */", "export default function encodeVectorTile(tile: Tile): Uint8Array {\n  const pbf = new Pbf();\n  for (const id in tile.layers) {\n    const layer = tile.layers[id];\n    if (!layer.extent) {\n      layer.extent = tile.extent;\n    }\n    pbf.writeMessage(3, writeLayer, { ...layer, id });\n  }\n  return pbf.finish();\n}\n", "function writeLayer(layer: Layer & { id: string }, pbf?: Pbf) {\n  if (!pbf) throw new Error(\"pbf undefined\");\n  pbf.writeVarintField(15, 2);\n  pbf.writeStringField(1, layer.id || \"\");\n  pbf.writeVarintField(5, layer.extent || 4096);\n\n  const context: Context = {\n    keys: [],\n    values: [],\n    keycache: {},\n    valuecache: {},\n  };\n", "  for (const feature of layer.features) {\n    context.feature = feature;\n    pbf.writeMessage(2, writeFeature, context);\n  }\n\n  for (const key of context.keys) {\n    pbf.writeStringField(3, key);\n  }\n\n  for (const value of context.values) {\n    pbf.writeMessage(4, writeValue, value);\n  }\n}\n", "  for (const value of context.values) {\n    pbf.writeMessage(4, writeValue, value);\n  }\n}\n\nfunction writeFeature(context: Context, pbf?: Pbf) {\n  const feature = context.feature;\n  if (!feature || !pbf) throw new Error();\n\n  pbf.writeMessage(2, writeProperties, context);\n  pbf.writeVarintField(3, feature.type);\n  pbf.writeMessage(4, writeGeometry, feature);\n}\n", "function writeProperties(context: Context, pbf?: Pbf) {\n  const feature = context.feature;\n  if (!feature || !pbf) throw new Error();\n  const keys = context.keys;\n  const values = context.values;\n  const keycache = context.keycache;\n  const valuecache = context.valuecache;\n\n  for (const key in feature.properties) {\n    let value = feature.properties[key];\n\n    let keyIndex = keycache[key];", "  for (const key in feature.properties) {\n    let value = feature.properties[key];\n\n    let keyIndex = keycache[key];\n    if (value === null) continue; // don't encode null value properties\n\n    if (typeof keyIndex === \"undefined\") {\n      keys.push(key);\n      keyIndex = keys.length - 1;\n      keycache[key] = keyIndex;\n    }\n    pbf.writeVarint(keyIndex);\n\n    const type = typeof value;", "    if (type !== \"string\" && type !== \"boolean\" && type !== \"number\") {\n      value = JSON.stringify(value);\n    }\n    const valueKey = `${type}:${value}`;\n    let valueIndex = valuecache[valueKey];\n    if (typeof valueIndex === \"undefined\") {\n      values.push(value);\n      valueIndex = values.length - 1;\n      valuecache[valueKey] = valueIndex;\n    }\n    pbf.writeVarint(valueIndex);\n  }\n}\n", "function command(cmd: number, length: number) {\n  return (length << 3) + (cmd & 0x7);\n}\n\nfunction zigzag(num: number) {\n  return (num << 1) ^ (num >> 31);\n}\n\nfunction writeGeometry(feature: Feature, pbf?: Pbf) {\n  if (!pbf) throw new Error();\n  const geometry = feature.geometry;\n  const type = feature.type;\n  let x = 0;\n  let y = 0;", "function writeGeometry(feature: Feature, pbf?: Pbf) {\n  if (!pbf) throw new Error();\n  const geometry = feature.geometry;\n  const type = feature.type;\n  let x = 0;\n  let y = 0;\n  for (const ring of geometry) {\n    let count = 1;\n    if (type === GeomType.POINT) {\n      count = ring.length / 2;\n    }\n    pbf.writeVarint(command(1, count)); // moveto\n    // do not write polygon closing path as lineto\n    const length = ring.length / 2;\n    const lineCount = type === GeomType.POLYGON ? length - 1 : length;", "    if (type === GeomType.POINT) {\n      count = ring.length / 2;\n    }\n    pbf.writeVarint(command(1, count)); // moveto\n    // do not write polygon closing path as lineto\n    const length = ring.length / 2;\n    const lineCount = type === GeomType.POLYGON ? length - 1 : length;\n    for (let i = 0; i < lineCount; i++) {\n      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)); // lineto\n      }\n      const dx = ring[i * 2] - x;\n      const dy = ring[i * 2 + 1] - y;\n      pbf.writeVarint(zigzag(dx));\n      pbf.writeVarint(zigzag(dy));\n      x += dx;\n      y += dy;\n    }", "      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)); // lineto\n      }\n      const dx = ring[i * 2] - x;\n      const dy = ring[i * 2 + 1] - y;\n      pbf.writeVarint(zigzag(dx));\n      pbf.writeVarint(zigzag(dy));\n      x += dx;\n      y += dy;\n    }\n    if (type === GeomType.POLYGON) {\n      pbf.writeVarint(command(7, 1)); // closepath\n    }\n  }\n}\n", "    if (type === GeomType.POLYGON) {\n      pbf.writeVarint(command(7, 1)); // closepath\n    }\n  }\n}\n\nfunction writeValue(value: PropertyValue, pbf?: Pbf) {\n  if (!pbf) throw new Error();\n  if (typeof value === \"string\") {\n    pbf.writeStringField(1, value);\n  } else if (typeof value === \"boolean\") {\n    pbf.writeBooleanField(7, value);", "  if (typeof value === \"string\") {\n    pbf.writeStringField(1, value);\n  } else if (typeof value === \"boolean\") {\n    pbf.writeBooleanField(7, value);\n  } else if (typeof value === \"number\") {\n    if (value % 1 !== 0) {\n      pbf.writeDoubleField(3, value);\n    } else if (value < 0) {\n      pbf.writeSVarintField(6, value);\n    } else {\n      pbf.writeVarintField(5, value);\n    }\n  }\n}\n"]}
{"filename": "src/config.ts", "chunked_list": ["const CONFIG = { workerUrl: \"\" };\nexport default CONFIG;\n"]}
{"filename": "src/decode-image.ts", "chunked_list": ["/* eslint-disable no-restricted-globals */\nimport type Actor from \"./actor\";\nimport { offscreenCanvasSupported } from \"./utils\";\nimport type { MainThreadDispatch } from \"./remote-dem-manager\";\nimport { CancelablePromise, DemTile, Encoding } from \"./types\";\n\nlet offscreenCanvas: OffscreenCanvas;\nlet offscreenContext: OffscreenCanvasRenderingContext2D | null;\nlet canvas: HTMLCanvasElement;\nlet canvasContext: CanvasRenderingContext2D | null;\n\n/**\n * Parses a `raster-dem` image into a DemTile using OffscreenCanvas and createImageBitmap\n * only supported on newer browsers.\n */", "function decodeImageModern(\n  blob: Blob,\n  encoding: Encoding,\n): CancelablePromise<DemTile> {\n  let canceled = false;\n  const promise = createImageBitmap(blob).then((img) => {\n    if (canceled) return null as any as DemTile;\n    if (!offscreenCanvas) {\n      offscreenCanvas = new OffscreenCanvas(img.width, img.height);\n      offscreenContext = offscreenCanvas.getContext(\"2d\", {\n        willReadFrequently: true,\n      }) as OffscreenCanvasRenderingContext2D;\n    }\n\n    return getElevations(img, encoding, offscreenCanvas, offscreenContext);\n  });\n  return {\n    value: promise,\n    cancel: () => {\n      canceled = true;\n    },\n  };\n}\n\n/**\n * Parses a `raster-dem` image into a DemTile using `<img>` element drawn to a `<canvas>`.\n * Only works on the main thread, but works across all browsers.\n */", "function decodeImageOld(\n  blob: Blob,\n  encoding: Encoding,\n): CancelablePromise<DemTile> {\n  if (!canvas) {\n    canvas = document.createElement(\"canvas\");\n    canvasContext = canvas.getContext(\"2d\", {\n      willReadFrequently: true,\n    }) as CanvasRenderingContext2D;\n  }\n  let canceled = false;\n  const img: HTMLImageElement = new Image();\n  const value = new Promise<HTMLImageElement>((resolve, reject) => {\n    img.onload = () => {", "      if (!canceled) resolve(img);\n      URL.revokeObjectURL(img.src);\n      img.onload = null;\n    };\n    img.onerror = () => reject(new Error(\"Could not load image.\"));\n    img.src = blob.size ? URL.createObjectURL(blob) : \"\";\n  }).then((img: HTMLImageElement) =>\n    getElevations(img, encoding, canvas, canvasContext),\n  );\n  return {\n    value,\n    cancel: () => {\n      canceled = true;\n      img.src = \"\";\n    },\n  };\n}\n\n/**\n * Parses a `raster-dem` image in a worker that doesn't support OffscreenCanvas and createImageBitmap\n * by running decodeImageOld on the main thread and returning the result.\n */", "function decodeImageOnMainThread(\n  blob: Blob,\n  encoding: Encoding,\n): CancelablePromise<DemTile> {\n  return ((self as any).actor as Actor<MainThreadDispatch>).send(\n    \"decodeImage\",\n    [],\n    undefined,\n    blob,\n    encoding,\n  );\n}\n", "function isWorker(): boolean {\n  return (\n    // @ts-ignore\n    typeof WorkerGlobalScope !== \"undefined\" &&\n    typeof self !== \"undefined\" &&\n    // @ts-ignore\n    self instanceof WorkerGlobalScope\n  );\n}\n\nconst defaultDecoder: (\n  blob: Blob,\n  encoding: Encoding,\n) => CancelablePromise<DemTile> = offscreenCanvasSupported()\n  ? decodeImageModern\n  : isWorker()\n  ? decodeImageOnMainThread\n  : decodeImageOld;\n\nexport default defaultDecoder;\n", "function getElevations(\n  img: ImageBitmap | HTMLImageElement,\n  encoding: Encoding,\n  canvas: HTMLCanvasElement | OffscreenCanvas,\n  canvasContext:\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D\n    | null,\n): DemTile {\n  canvas.width = img.width;\n  canvas.height = img.height;\n", "  if (!canvasContext) throw new Error(\"failed to get context\");\n\n  canvasContext.drawImage(img, 0, 0, img.width, img.height);\n\n  const rgba = canvasContext.getImageData(0, 0, img.width, img.height).data;\n  return decodeParsedImage(img.width, img.height, encoding, rgba);\n}\n\nexport function decodeParsedImage(\n  width: number,\n  height: number,\n  encoding: Encoding,\n  input: Uint8ClampedArray,\n): DemTile {\n  const decoder: (r: number, g: number, b: number) => number =\n    encoding === \"mapbox\"\n      ? (r, g, b) => -10000 + (r * 256 * 256 + g * 256 + b) * 0.1\n      : (r, g, b) => r * 256 + g + b / 256 - 32768;\n  const data = new Float32Array(width * height);", "export function decodeParsedImage(\n  width: number,\n  height: number,\n  encoding: Encoding,\n  input: Uint8ClampedArray,\n): DemTile {\n  const decoder: (r: number, g: number, b: number) => number =\n    encoding === \"mapbox\"\n      ? (r, g, b) => -10000 + (r * 256 * 256 + g * 256 + b) * 0.1\n      : (r, g, b) => r * 256 + g + b / 256 - 32768;\n  const data = new Float32Array(width * height);", "  for (let i = 0; i < input.length; i += 4) {\n    data[i / 4] = decoder(input[i], input[i + 1], input[i + 2]);\n  }\n  return { width, height, data };\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/** Scheme used to map pixel rgb values elevations. */\nexport type Encoding = \"terrarium\" | \"mapbox\";\nexport interface IsTransferrable {\n  transferrables: Transferable[];\n}\n/** A decoded `raster-rgb` image. */\nexport interface DemTile {\n  width: number;\n  height: number;\n  /** elevation values in row-major order */\n  data: Float32Array;\n}", "export interface TransferrableDemTile extends DemTile, IsTransferrable {}\n/** A rendered contour tile */\nexport interface ContourTile {\n  /** Encoded mapbox vector tile bytes */\n  arrayBuffer: ArrayBuffer;\n}\nexport interface TransferrableContourTile\n  extends ContourTile,\n    IsTransferrable {}\n\nexport interface Cancelable {\n  cancel: () => void;\n}\n", "export interface Cancelable {\n  cancel: () => void;\n}\n\nexport interface CancelablePromise<T> extends Cancelable {\n  value: Promise<T>;\n}\n\nexport interface FetchResponse {\n  data: Blob;\n  expires?: string;\n  cacheControl?: string;\n}\n\n/** Parameters to use when creating a contour vector tile from raw elevation data */", "export interface FetchResponse {\n  data: Blob;\n  expires?: string;\n  cacheControl?: string;\n}\n\n/** Parameters to use when creating a contour vector tile from raw elevation data */\nexport interface ContourTileOptions {\n  /** Factor to scale the elevation meters by to support different units (default 1 for meters) */\n  multiplier?: number;\n  /**\n   * Request `raster-dem` tiles from lower zoom levels to generate the contour vector tile.\n   *\n   * The default value is 0, which means to generate a contour vector tile at z10, it gets\n   * the z10 `raster-dem` tile plus its 8 neighbors\n   *\n   * Setting to 1 requests a z9 tile and uses one quadrant of it so that it only needs up to 3\n   * neighboring tiles to get the neighboring elevation data. It also improves performance with\n   * 512x512 or larger `raster-dem` tiles.\n   */\n  overzoom?: number;\n  /** Key for the elevation property to set on each contour line. */\n  elevationKey?: string;\n  /** Key for the \"level\" property to set on each contour line. Minor lines have level=0, major have level=1 */\n  levelKey?: string;\n  /** Name of the vector tile layer to put contour lines in */\n  contourLayer?: string;\n  /** Grid size of the vector tile (default 4096) */\n  extent?: number;\n  /** How many pixels to generate on each tile into the neighboring tile to reduce rendering artifacts */\n  buffer?: number;\n  /** When overzooming tiles, subsample to scale up to at least this size to make the contour lines smoother at higher zooms. */\n  subsampleBelow?: number;\n}\n", "export interface GlobalContourTileOptions extends ContourTileOptions {\n  /**\n   * Map from zoom level to the `[minor, major]` elevation distance between contour lines.\n   *\n   * Contour lines without an entry will use the threshold for the next lower zoom.\n   *\n   * The `level` tag on each contour line will have an integer that corresponds to the largest index in\n   * this array that the elevation is a multiple of.\n   */\n  thresholds: { [n: number]: number | number[] };\n}\n", "export interface IndividualContourTileOptions extends ContourTileOptions {\n  levels: number[];\n}\n\nexport interface Image {\n  width: number;\n  height: number;\n  data: Uint8Array;\n}\n\nexport interface InitMessage {\n  managerId: number;\n  demUrlPattern: string;\n  cacheSize: number;\n  encoding: Encoding;\n  maxzoom: number;\n  timeoutMs: number;\n}\n", "export interface InitMessage {\n  managerId: number;\n  demUrlPattern: string;\n  cacheSize: number;\n  encoding: Encoding;\n  maxzoom: number;\n  timeoutMs: number;\n}\n\nexport type TimingCategory = \"main\" | \"worker\" | \"fetch\" | \"decode\" | \"isoline\";\n\n/** Performance profile for a tile request */", "export type TimingCategory = \"main\" | \"worker\" | \"fetch\" | \"decode\" | \"isoline\";\n\n/** Performance profile for a tile request */\nexport interface Timing {\n  /** The \"virtual\" tile url using the protocol ID registered with maplibre */\n  url: String;\n  /** Timing origin that all marks are relative to. */\n  origin: number;\n  /** Overall duration of the request */\n  duration: number;\n  /** Time spent fetching all resources, or `undefined` if they were cached */\n  fetch?: number;\n  /** Time spent decoding all raster-rgb images, or `undefined` if it was cached */\n  decode?: number;\n  /** Time spent generating isolines and rendering the vector tile, or `undefined` if it was cached */\n  process?: number;\n  wait: number;\n  /** Number of tiles used for generation, even if they were cached */\n  tilesUsed: number;\n  /** Map from category (fetch, main, isoline) to list of start/end timestamps */\n  marks: {\n    [key in TimingCategory]?: number[][];\n  };\n  /** Detailed timing for all resources actually fetched (not cached) to generate this tile */\n  resources: PerformanceResourceTiming[];\n  /** If the tile failed with an error */\n  error?: boolean;\n}\n"]}
{"filename": "src/performance.ts", "chunked_list": ["import { Timing, TimingCategory } from \"./types\";\n\nexport const perf =\n  typeof performance !== \"undefined\" ? performance : undefined;\nexport const timeOrigin = perf\n  ? perf.timeOrigin || new Date().getTime() - perf.now()\n  : new Date().getTime();\nexport function getResourceTiming(url: string): PerformanceResourceTiming[] {\n  return JSON.parse(\n    JSON.stringify(\n      (perf?.getEntriesByName?.(url) as\n        | PerformanceResourceTiming[]\n        | undefined) || [],\n    ),\n  );\n}", "export function now(): number {\n  return perf ? perf.now() : new Date().getTime();\n}\nfunction flatten<T>(input: T[][]): T[] {\n  const result: T[] = [];\n  for (const list of input) {\n    result.push(...list);\n  }\n  return result;\n}\n\n/** Utility for tracking how long tiles take to generate, and where the time is going. */", "export class Timer {\n  marks: { [key in TimingCategory]?: number[][] } = {};\n  urls: string[] = [];\n  fetched: string[] = [];\n  resources: PerformanceResourceTiming[] = [];\n  markFinish: () => void;\n  tilesFetched: number = 0;\n  timeOrigin: number = timeOrigin;\n  constructor(name: TimingCategory) {\n    this.markFinish = this.marker(name);\n  }\n  finish = (url: string): Timing => {\n    this.markFinish();\n    const get = (type: TimingCategory): number | undefined => {\n      const all = this.marks[type] || [];\n      const max = Math.max(...all.map((ns) => Math.max(...ns)));\n      const min = Math.min(...all.map((ns) => Math.min(...ns)));\n      return Number.isFinite(max) ? max - min : undefined;\n    };\n    const duration = get(\"main\") || 0;\n    const fetch = get(\"fetch\");\n    const decode = get(\"decode\");\n    const process = get(\"isoline\");\n    return {\n      url,\n      tilesUsed: this.tilesFetched,\n      origin: this.timeOrigin,\n      marks: this.marks,\n      resources: [\n        ...this.resources,\n        ...flatten(this.fetched.map(getResourceTiming)),\n      ],\n      duration,\n      fetch,\n      decode,\n      process,\n      wait: duration - (fetch || 0) - (decode || 0) - (process || 0),\n    };\n  };\n  error = (url: string): Timing => ({ ...this.finish(url), error: true });\n  marker = (category: TimingCategory): (() => void) => {", "    if (!this.marks[category]) {\n      this.marks[category] = [];\n    }\n    const marks = [now()];\n    this.marks[category]?.push(marks);\n    return () => marks.push(now());\n  };\n  useTile = (url: string): void => {\n    if (this.urls.indexOf(url) < 0) {\n      this.urls.push(url);\n      this.tilesFetched++;\n    }\n  };\n  fetchTile = (url: string): void => {", "    if (this.urls.indexOf(url) < 0) {\n      this.urls.push(url);\n      this.tilesFetched++;\n    }\n  };\n  fetchTile = (url: string): void => {\n    if (this.fetched.indexOf(url) < 0) {\n      this.fetched.push(url);\n    }\n  };\n  addAll = (timings: Timing) => {\n    this.tilesFetched += timings.tilesUsed;\n    const offset = timings.origin - this.timeOrigin;", "    for (const category in timings.marks) {\n      const key = category as TimingCategory;\n      const ourList = this.marks[key] || (this.marks[key] = []);\n      ourList.push(\n        ...(timings.marks[key]?.map((ns) => ns.map((n) => n + offset)) || []),\n      );\n    }\n    this.resources.push(\n      ...timings.resources.map((rt) => applyOffset(rt, offset)),\n    );\n  };\n}\n\nconst startOrEnd = /(Start$|End$|^start|^end)/;", "function applyOffset(obj: any, offset: number): PerformanceResourceTiming {\n  const result: { [_: string]: number } = {};\n  for (const key in obj) {\n    if (obj[key] !== 0 && startOrEnd.test(key)) {\n      result[key] = Number(obj[key]) + offset;\n    } else {\n      result[key] = obj[key];\n    }\n  }\n  return result as any as PerformanceResourceTiming;\n}\n"]}
{"filename": "src/worker.ts", "chunked_list": ["import Actor from \"./actor\";\nimport { MainThreadDispatch } from \"./remote-dem-manager\";\nimport WorkerDispatch from \"./worker-dispatch\";\n\nconst g: any =\n  typeof self !== \"undefined\"\n    ? self\n    : typeof window !== \"undefined\"\n    ? window\n    : global;", "    ? window\n    : global;\n\ng.actor = new Actor<MainThreadDispatch>(g, new WorkerDispatch());\n"]}
{"filename": "src/worker-dispatch.ts", "chunked_list": ["import { LocalDemManager } from \"./dem-manager\";\nimport { Timer } from \"./performance\";\nimport {\n  CancelablePromise,\n  ContourTile,\n  FetchResponse,\n  IndividualContourTileOptions,\n  InitMessage,\n  TransferrableDemTile,\n} from \"./types\";", "  TransferrableDemTile,\n} from \"./types\";\nimport { prepareContourTile, prepareDemTile } from \"./utils\";\n\nconst noManager = (managerId: number): CancelablePromise<any> => ({\n  cancel() {},\n  value: Promise.reject(new Error(`No manager registered for ${managerId}`)),\n});\n\n/**", "\n/**\n * Receives messages from an actor in the web worker.\n */\nexport default class WorkerDispatch {\n  /** There is one worker shared between all managers in the main thread using the plugin, so need to store each of their configurations. */\n  managers: { [id: number]: LocalDemManager } = {};\n\n  init = (message: InitMessage): CancelablePromise<void> => {\n    this.managers[message.managerId] = new LocalDemManager(\n      message.demUrlPattern,\n      message.cacheSize,\n      message.encoding,\n      message.maxzoom,\n      message.timeoutMs,\n    );\n    return { cancel() {}, value: Promise.resolve() };\n  };\n\n  fetchTile = (\n    managerId: number,\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<FetchResponse> =>\n    this.managers[managerId]?.fetchTile(z, x, y, timer) || noManager(managerId);\n\n  fetchAndParseTile = (\n    managerId: number,\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<TransferrableDemTile> =>\n    prepareDemTile(\n      this.managers[managerId]?.fetchAndParseTile(z, x, y, timer) ||\n        noManager(managerId),\n      true,\n    );\n\n  fetchContourTile = (\n    managerId: number,\n    z: number,\n    x: number,\n    y: number,\n    options: IndividualContourTileOptions,\n    timer?: Timer,\n  ): CancelablePromise<ContourTile> =>\n    prepareContourTile(\n      this.managers[managerId]?.fetchContourTile(z, x, y, options, timer) ||\n        noManager(managerId),\n    );\n}\n"]}
{"filename": "src/vtpbf.test.ts", "chunked_list": ["import Pbf from \"pbf\";\nimport encodeVectorTile, { GeomType } from \"./vtpbf\";\nimport { VectorTile } from \"@mapbox/vector-tile\";\n\ntest(\"empty tile\", () => {\n  expect(\n    encodeVectorTile({\n      layers: {},\n    }).length,\n  ).toBe(0);", "    }).length,\n  ).toBe(0);\n});\n\ntest(\"simple line\", () => {\n  const encoded = encodeVectorTile({\n    layers: {\n      contours: {\n        features: [\n          {", "        features: [\n          {\n            geometry: [[0, 1, 2, 3]],\n            type: GeomType.LINESTRING,\n            properties: {\n              key: \"value\",\n            },\n          },\n        ],\n      },", "        ],\n      },\n    },\n  });\n  const result = new VectorTile(new Pbf(encoded));\n  expect(result.layers).toHaveProperty(\"contours\");\n  expect(result.layers.contours.extent).toBe(4096);\n  expect(result.layers.contours.version).toBe(2);\n  expect(result.layers.contours.length).toBe(1);\n  expect(result.layers.contours.feature(0).properties).toEqual({", "  expect(result.layers.contours.length).toBe(1);\n  expect(result.layers.contours.feature(0).properties).toEqual({\n    key: \"value\",\n  });\n  expect(result.layers.contours.feature(0).loadGeometry()).toEqual([\n    [\n      { x: 0, y: 1 },\n      { x: 2, y: 3 },\n    ],\n  ]);", "    ],\n  ]);\n});\n\ntest(\"multi line\", () => {\n  const encoded = encodeVectorTile({\n    layers: {\n      contours: {\n        features: [\n          {", "        features: [\n          {\n            geometry: [\n              [0, 1, 2, 3],\n              [9, 8, 7, 6],\n            ],\n            type: GeomType.LINESTRING,\n            properties: {\n              key: 1,\n              key2: true,", "              key: 1,\n              key2: true,\n            },\n          },\n        ],\n      },\n    },\n  });\n  const result = new VectorTile(new Pbf(encoded));\n  expect(result.layers.contours.feature(0).properties).toEqual({", "  const result = new VectorTile(new Pbf(encoded));\n  expect(result.layers.contours.feature(0).properties).toEqual({\n    key: 1,\n    key2: true,\n  });\n  expect(result.layers.contours.feature(0).loadGeometry()).toEqual([\n    [\n      { x: 0, y: 1 },\n      { x: 2, y: 3 },\n    ],", "      { x: 2, y: 3 },\n    ],\n    [\n      { x: 9, y: 8 },\n      { x: 7, y: 6 },\n    ],\n  ]);\n});\n", ""]}
{"filename": "src/height-tile.test.ts", "chunked_list": ["import { HeightTile } from \"./height-tile\";\nconst initialTile = HeightTile.fromRawDem({\n  width: 2,\n  height: 2,\n  data: Float32Array.from([0, 1, 2, 3]),\n});\n\ntest(\"raw tile\", () => {\n  expect(initialTile.get(0, 0)).toBe(0);\n  expect(initialTile.get(1, 0)).toBe(1);", "  expect(initialTile.get(0, 0)).toBe(0);\n  expect(initialTile.get(1, 0)).toBe(1);\n  expect(initialTile.get(1, 1)).toBe(3);\n});\n\ntest(\"split height tile\", () => {\n  const split = initialTile.split(1, 0, 0);\n  expect(split.get(0, 0)).toBe(0);\n  expect(split.width).toBe(1);\n  const split2 = initialTile.split(1, 1, 1);", "  expect(split.width).toBe(1);\n  const split2 = initialTile.split(1, 1, 1);\n  expect(split2.get(0, 0)).toBe(3);\n  expect(split2.width).toBe(1);\n});\n\nconst neighbors: HeightTile[] = [];\nfor (let i = 0; i < 9; i++) {\n  const row = Math.floor(i / 3);\n  const start = i * 2 + row * 6;\n  neighbors.push(\n    HeightTile.fromRawDem({\n      width: 2,\n      height: 2,\n      data: Float32Array.from([start, start + 1, start + 6, start + 7]),\n    }),\n  );\n}\n\n// 0  1  | 2  3  | 4  5\n// 6  7  | 8  9  | 10 11\n// ------ ------- ------\n// 12 13 | 14 15 | 16 17\n// 18 19 | 20 21 | 22 23\n// ------ ------- ------\n// 24 25 | 26 27 | 28 29\n// 30 31 | 32 33 | 34 35\ntest(\"neighboring tiles\", () => {\n  const virtualTile = HeightTile.combineNeighbors(neighbors);\n  expect(virtualTile?.get(-1, -1)).toBe(7);\n  expect(virtualTile?.get(0, -1)).toBe(8);\n  expect(virtualTile?.get(1, -1)).toBe(9);\n  expect(virtualTile?.get(2, -1)).toBe(10);\n\n  expect(virtualTile?.get(-1, 0)).toBe(13);\n  expect(virtualTile?.get(0, 0)).toBe(14);\n  expect(virtualTile?.get(1, 0)).toBe(15);\n  expect(virtualTile?.get(2, 0)).toBe(16);\n\n  expect(virtualTile?.get(-1, 2)).toBe(25);\n  expect(virtualTile?.get(0, 2)).toBe(26);\n  expect(virtualTile?.get(1, 2)).toBe(27);\n  expect(virtualTile?.get(2, 2)).toBe(28);\n});\n\n// 0  1  | 2  3  | 4  5\n// 6  7  | 8  9  | 10 11\n// ------ ------- ------\n// 12 13 | 14 15 | 16 17\n// 18 19 | 20 21 | 22 23\n// ------ ------- ------\n// 24 25 | 26 27 | 28 29\n// 30 31 | 32 33 | 34 35\ntest(\"average pixel centers to grid\", () => {\n  const virtualTile =\n    HeightTile.combineNeighbors(neighbors)?.averagePixelCentersToGrid();\n  // 7,8,13,14\n  expect(virtualTile?.get(0, 0)).toBe((7 + 8 + 13 + 14) / 4);\n  expect(virtualTile?.get(1, 0)).toBe((8 + 9 + 14 + 15) / 4);\n  expect(virtualTile?.get(2, 0)).toBe((9 + 10 + 15 + 16) / 4);\n  expect(virtualTile?.get(0, 2)).toBe((19 + 20 + 25 + 26) / 4);\n  expect(virtualTile?.get(2, 2)).toBe((21 + 22 + 27 + 28) / 4);\n  expect(virtualTile).toMatchObject({\n    width: 3,\n    height: 3,\n  });\n});\n\ntest(\"subsample pixel centers\", () => {\n  /*  ___________ ____________\n     |             |            |\n     | old -1,-1   |  old 0,-1  |\n     |      7      |     8      |\n     |new -1,-1>x  |  x<new 0,-1|\n     |_____________|____________|\n     |             |            |\n     | new -1,0>x  |  x<new 0,0 |\n     |       13    |     14     |\n     |   old -1,0  |  old 0,0   |\n     |_____________|____________|\n  */\n  const virtualTile =\n    HeightTile.combineNeighbors(neighbors)?.subsamplePixelCenters(2);\n  expect(virtualTile?.get(0, 0)).toBe((7.75 + 3 * 13.75) / 4);\n  expect(virtualTile?.get(-1, -1)).toBe((7.25 * 3 + 13.25) / 4);\n  expect(virtualTile).toMatchObject({\n    width: 4,\n    height: 4,\n  });\n});\n\ntest(\"subsample and average centers alignment between tiles\", () => {\n  /*  ___________ ____________\n     |             |            |\n     | old -1,-1   |  old 0,-1  |\n     |      7      |     8      |\n     |new -1,-1>x  |  x<new 0,-1|\n     |_____________|____________|\n     |             |            |\n     | new -1,0>x  |  x<new 0,0 |\n     |       13    |     14     |\n     |   old -1,0  |  old 0,0   |\n     |_____________|____________|\n  */\n  const subsampled = HeightTile.combineNeighbors(neighbors)\n    ?.subsamplePixelCenters(2)\n    .averagePixelCentersToGrid();\n  const notSubsampled =\n    HeightTile.combineNeighbors(neighbors)?.averagePixelCentersToGrid();\n\n  expect(subsampled).toMatchObject({\n    width: 5,\n    height: 5,\n  });\n  expect(notSubsampled).toMatchObject({\n    width: 3,\n    height: 3,\n  });\n\n  expect(subsampled?.get(0, 0)).toBe(notSubsampled?.get(0, 0));\n  expect(subsampled?.get(2, 2)).toBe(notSubsampled?.get(1, 1));\n  expect(subsampled?.get(-2, -2)).toBe(notSubsampled?.get(-1, -1));\n});\n"]}
{"filename": "src/actor.test.ts", "chunked_list": ["import Actor from \"./actor\";\nimport { Timer } from \"./performance\";\nimport { CancelablePromise } from \"./types\";\n\nclass Local {\n  received: any[][] = [];\n  localAction = (x: number, y: number, z: number): CancelablePromise<void> => {\n    this.received.push([x, y, z]);\n    return { cancel() {}, value: Promise.resolve() };\n  };\n}\n", "class Remote {\n  received: any[][] = [];\n  canceled = false;\n  remoteAction = (x: number, y: number, z: number): CancelablePromise<void> => {\n    this.received.push([x, y, z]);\n    return { cancel() {}, value: Promise.resolve() };\n  };\n  remotePromise = (x: number, timer?: Timer): CancelablePromise<number> => {\n    const oldNow = performance.now;\n    if (timer) timer.timeOrigin = 100;\n    performance.now = () => oldNow() - 100;\n    const finish = timer?.marker(\"fetch\");\n    performance.now = () => oldNow() - 99;\n    finish?.();\n    performance.now = () => oldNow() + 2;\n    return {\n      cancel() {\n        throw new Error(\"not expected\");\n      },\n      value: Promise.resolve(x),\n    };\n  };\n  remoteFail = (): CancelablePromise<number> => ({\n    cancel() {},\n    value: Promise.reject(new Error(\"error\")),\n  });\n  remoteNever = (): CancelablePromise<number> => ({\n    cancel: () => {\n      this.canceled = true;\n    },\n    value: new Promise(() => {}),\n  });\n}\n\ntest(\"send and cancel messages\", async () => {\n  performance.now = () => 1;\n  const remote = new Remote();\n  const local = new Local();\n  const workerFromMainThread: Worker = {} as any as Worker;\n  const mainThreadFromWorker: Worker = {} as any as Worker;\n  workerFromMainThread.postMessage = (data) =>\n    //@ts-ignore\n    mainThreadFromWorker?.onmessage?.({ data });\n  mainThreadFromWorker.postMessage = (data) =>\n    //@ts-ignore\n    workerFromMainThread?.onmessage?.({ data });\n  const mainActor = new Actor<Remote>(workerFromMainThread, local);\n  const workerActor = new Actor<Local>(mainThreadFromWorker, remote);\n\n  mainActor.send(\"remoteAction\", [], undefined, 1, 2, 3);\n  expect(remote.received).toEqual([[1, 2, 3]]);\n  workerActor.send(\"localAction\", [], undefined, 4, 3, 2);\n  expect(local.received).toEqual([[4, 3, 2]]);\n\n  const timer = new Timer(\"main\");\n  timer.timeOrigin = 0;\n  expect(await mainActor.send(\"remotePromise\", [], timer, 9).value).toBe(9);\n  expect(timer.finish(\"url\")).toMatchObject({\n    duration: 2,\n    fetch: 1,\n    marks: {\n      fetch: [[1, 2]],\n      main: [[1, 3]],\n    },\n  });\n  const { cancel } = mainActor.send(\"remoteNever\", []);\n  expect(remote.canceled).toBeFalsy();\n  cancel();\n  expect(remote.canceled).toBeTruthy();\n\n  await expect(mainActor.send(\"remoteFail\", []).value).rejects.toThrowError(\n    \"Error: error\",\n  );\n});\n", "    if (timer) timer.timeOrigin = 100;\n    performance.now = () => oldNow() - 100;\n    const finish = timer?.marker(\"fetch\");\n    performance.now = () => oldNow() - 99;\n    finish?.();\n    performance.now = () => oldNow() + 2;\n    return {\n      cancel() {\n        throw new Error(\"not expected\");\n      },\n      value: Promise.resolve(x),\n    };\n  };\n  remoteFail = (): CancelablePromise<number> => ({\n    cancel() {},\n    value: Promise.reject(new Error(\"error\")),\n  });\n  remoteNever = (): CancelablePromise<number> => ({\n    cancel: () => {\n      this.canceled = true;\n    },\n    value: new Promise(() => {}),\n  });\n}\n\ntest(\"send and cancel messages\", async () => {\n  performance.now = () => 1;\n  const remote = new Remote();\n  const local = new Local();\n  const workerFromMainThread: Worker = {} as any as Worker;\n  const mainThreadFromWorker: Worker = {} as any as Worker;\n  workerFromMainThread.postMessage = (data) =>\n    //@ts-ignore\n    mainThreadFromWorker?.onmessage?.({ data });\n  mainThreadFromWorker.postMessage = (data) =>\n    //@ts-ignore\n    workerFromMainThread?.onmessage?.({ data });\n  const mainActor = new Actor<Remote>(workerFromMainThread, local);\n  const workerActor = new Actor<Local>(mainThreadFromWorker, remote);\n\n  mainActor.send(\"remoteAction\", [], undefined, 1, 2, 3);\n  expect(remote.received).toEqual([[1, 2, 3]]);\n  workerActor.send(\"localAction\", [], undefined, 4, 3, 2);\n  expect(local.received).toEqual([[4, 3, 2]]);\n\n  const timer = new Timer(\"main\");\n  timer.timeOrigin = 0;\n  expect(await mainActor.send(\"remotePromise\", [], timer, 9).value).toBe(9);\n  expect(timer.finish(\"url\")).toMatchObject({\n    duration: 2,\n    fetch: 1,\n    marks: {\n      fetch: [[1, 2]],\n      main: [[1, 3]],\n    },\n  });\n  const { cancel } = mainActor.send(\"remoteNever\", []);\n  expect(remote.canceled).toBeFalsy();\n  cancel();\n  expect(remote.canceled).toBeTruthy();\n\n  await expect(mainActor.send(\"remoteFail\", []).value).rejects.toThrowError(\n    \"Error: error\",\n  );\n});\n"]}
{"filename": "src/remote-dem-manager.ts", "chunked_list": ["import Actor from \"./actor\";\nimport CONFIG from \"./config\";\nimport type WorkerDispatch from \"./worker-dispatch\";\nimport decodeImage from \"./decode-image\";\nimport type { DemManager } from \"./dem-manager\";\nimport { Timer } from \"./performance\";\nimport {\n  CancelablePromise,\n  ContourTile,\n  DemTile,\n  Encoding,\n  FetchResponse,\n  IndividualContourTileOptions,\n} from \"./types\";\nimport { prepareDemTile } from \"./utils\";\n\nlet _actor: Actor<WorkerDispatch> | undefined;\nlet id = 0;\n", "export class MainThreadDispatch {\n  decodeImage = (blob: Blob, encoding: Encoding) =>\n    prepareDemTile(decodeImage(blob, encoding), false);\n}\n\nfunction defaultActor(): Actor<WorkerDispatch> {\n  if (!_actor) {\n    const worker = new Worker(CONFIG.workerUrl);\n    const dispatch = new MainThreadDispatch();\n    _actor = new Actor(worker, dispatch);\n  }\n  return _actor;\n}\n\n/**\n * Caches, decodes, and processes raster tiles in a shared web worker.\n */", "export default class RemoteDemManager implements DemManager {\n  managerId: number;\n  actor: Actor<WorkerDispatch>;\n  loaded: Promise<any>;\n\n  constructor(\n    demUrlPattern: string,\n    cacheSize: number,\n    encoding: Encoding,\n    maxzoom: number,\n    timeoutMs: number,\n    actor?: Actor<WorkerDispatch>,\n  ) {\n    const managerId = (this.managerId = ++id);\n    this.actor = actor || defaultActor();\n    this.loaded = this.actor.send(\"init\", [], undefined, {\n      cacheSize,\n      demUrlPattern,\n      encoding,\n      maxzoom,\n      managerId,\n      timeoutMs,\n    }).value;\n  }\n\n  fetchTile = (\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<FetchResponse> =>\n    this.actor.send(\"fetchTile\", [], timer, this.managerId, z, x, y);\n  fetchAndParseTile = (\n    z: number,\n    x: number,\n    y: number,\n    timer?: Timer,\n  ): CancelablePromise<DemTile> =>\n    this.actor.send(\"fetchAndParseTile\", [], timer, this.managerId, z, x, y);\n  fetchContourTile = (\n    z: number,\n    x: number,\n    y: number,\n    options: IndividualContourTileOptions,\n    timer?: Timer,\n  ): CancelablePromise<ContourTile> =>\n    this.actor.send(\n      \"fetchContourTile\",\n      [],\n      timer,\n      this.managerId,\n      z,\n      x,\n      y,\n      options,\n    );\n}\n"]}
{"filename": "src/isolines.ts", "chunked_list": ["/*\nAdapted from d3-contour https://github.com/d3/d3-contour\n\nCopyright 2012-2023 Mike Bostock\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH", "\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n", "*/\n\nimport type { HeightTile } from \"./height-tile\";\n\nclass Fragment {\n  start: number;\n  end: number;\n  points: number[];\n\n  constructor(start: number, end: number) {\n    this.start = start;\n    this.end = end;\n    this.points = [];\n    this.append = this.append.bind(this);\n    this.prepend = this.prepend.bind(this);\n  }\n\n  append(x: number, y: number) {\n    this.points.push(Math.round(x), Math.round(y));\n  }\n\n  prepend(x: number, y: number) {\n    this.points.splice(0, 0, Math.round(x), Math.round(y));\n  }\n\n  lineString() {\n    return this.toArray();\n  }\n\n  isEmpty() {\n    return this.points.length < 2;\n  }\n\n  appendFragment(other: Fragment) {\n    this.points.push(...other.points);\n    this.end = other.end;\n  }\n\n  toArray() {\n    return this.points;\n  }\n}\n\nconst CASES: [number, number][][][] = [\n  [],\n  [\n    [\n      [1, 2],\n      [0, 1],\n    ],\n  ],\n  [\n    [\n      [2, 1],\n      [1, 2],\n    ],\n  ],\n  [\n    [\n      [2, 1],\n      [0, 1],\n    ],\n  ],\n  [\n    [\n      [1, 0],\n      [2, 1],\n    ],\n  ],\n  [\n    [\n      [1, 2],\n      [0, 1],\n    ],\n    [\n      [1, 0],\n      [2, 1],\n    ],\n  ],\n  [\n    [\n      [1, 0],\n      [1, 2],\n    ],\n  ],\n  [\n    [\n      [1, 0],\n      [0, 1],\n    ],\n  ],\n  [\n    [\n      [0, 1],\n      [1, 0],\n    ],\n  ],\n  [\n    [\n      [1, 2],\n      [1, 0],\n    ],\n  ],\n  [\n    [\n      [0, 1],\n      [1, 0],\n    ],\n    [\n      [2, 1],\n      [1, 2],\n    ],\n  ],\n  [\n    [\n      [2, 1],\n      [1, 0],\n    ],\n  ],\n  [\n    [\n      [0, 1],\n      [2, 1],\n    ],\n  ],\n  [\n    [\n      [1, 2],\n      [2, 1],\n    ],\n  ],\n  [\n    [\n      [0, 1],\n      [1, 2],\n    ],\n  ],\n  [],\n];\n", "function index(width: number, x: number, y: number, point: [number, number]) {\n  x = x * 2 + point[0];\n  y = y * 2 + point[1];\n  return x + y * (width + 1) * 2;\n}\n\nfunction ratio(a: number, b: number, c: number) {\n  return (b - a) / (c - a);\n}\n\n/**\n * Generates contour lines from a HeightTile\n *\n * @param interval Vertical distance between contours\n * @param tile The input height tile, where values represent the height at the top-left of each pixel\n * @param extent Vector tile extent (default 4096)\n * @param buffer How many pixels into each neighboring tile to include in a tile\n * @returns an object where keys are the elevation, and values are a list of `[x1, y1, x2, y2, ...]`\n * contour lines in tile coordinates\n */", "export default function generateIsolines(\n  interval: number,\n  tile: HeightTile,\n  extent: number = 4096,\n  buffer: number = 1,\n): { [ele: number]: number[][] } {\n  if (!interval) {\n    return {};\n  }\n  const multiplier = extent / (tile.width - 1);\n  let tld: number, trd: number, bld: number, brd: number;\n  let r: number, c: number;\n  const segments: { [ele: string]: number[][] } = {};\n  const fragmentByStartByLevel: Map<number, Map<number, Fragment>> = new Map();\n  const fragmentByEndByLevel: Map<number, Map<number, Fragment>> = new Map();\n", "  function interpolate(\n    point: [number, number],\n    threshold: number,\n    accept: (x: number, y: number) => void,\n  ) {\n    if (point[0] === 0) {\n      // left\n      accept(\n        multiplier * (c - 1),\n        multiplier * (r - ratio(bld, threshold, tld)),\n      );", "    } else if (point[0] === 2) {\n      // right\n      accept(multiplier * c, multiplier * (r - ratio(brd, threshold, trd)));\n    } else if (point[1] === 0) {\n      // top\n      accept(\n        multiplier * (c - ratio(trd, threshold, tld)),\n        multiplier * (r - 1),\n      );\n    } else {\n      // bottom\n      accept(multiplier * (c - ratio(brd, threshold, bld)), multiplier * r);\n    }\n  }\n\n  // Most marching-squares implementations (d3-contour, gdal-contour) make one pass through the matrix per threshold.\n  // This implementation makes a single pass through the matrix, building up all of the contour lines at the\n  // same time to improve performance.", "  for (r = 1 - buffer; r < tile.height + buffer; r++) {\n    trd = tile.get(0, r - 1);\n    brd = tile.get(0, r);\n    let minR = Math.min(trd, brd);\n    let maxR = Math.max(trd, brd);\n    for (c = 1 - buffer; c < tile.width + buffer; c++) {\n      tld = trd;\n      bld = brd;\n      trd = tile.get(c, r - 1);\n      brd = tile.get(c, r);\n      const minL = minR;\n      const maxL = maxR;\n      minR = Math.min(trd, brd);\n      maxR = Math.max(trd, brd);", "      if (isNaN(tld) || isNaN(trd) || isNaN(brd) || isNaN(bld)) {\n        continue;\n      }\n      const min = Math.min(minL, minR);\n      const max = Math.max(maxL, maxR);\n      const start = Math.ceil(min / interval) * interval;\n      const end = Math.floor(max / interval) * interval;\n      for (let threshold = start; threshold <= end; threshold += interval) {\n        const tl = tld > threshold;\n        const tr = trd > threshold;\n        const bl = bld > threshold;\n        const br = brd > threshold;", "        for (const segment of CASES[\n          (tl ? 8 : 0) | (tr ? 4 : 0) | (br ? 2 : 0) | (bl ? 1 : 0)\n        ]) {\n          let fragmentByStart = fragmentByStartByLevel.get(threshold);\n          if (!fragmentByStart)\n            fragmentByStartByLevel.set(\n              threshold,\n              (fragmentByStart = new Map()),\n            );\n          let fragmentByEnd = fragmentByEndByLevel.get(threshold);\n          if (!fragmentByEnd)\n            fragmentByEndByLevel.set(threshold, (fragmentByEnd = new Map()));\n          const start = segment[0];\n          const end = segment[1];\n          const startIndex = index(tile.width, c, r, start);\n          const endIndex = index(tile.width, c, r, end);\n          let f, g;\n", "          if (!fragmentByEnd)\n            fragmentByEndByLevel.set(threshold, (fragmentByEnd = new Map()));\n          const start = segment[0];\n          const end = segment[1];\n          const startIndex = index(tile.width, c, r, start);\n          const endIndex = index(tile.width, c, r, end);\n          let f, g;\n\n          if ((f = fragmentByEnd.get(startIndex))) {\n            fragmentByEnd.delete(startIndex);\n            if ((g = fragmentByStart.get(endIndex))) {\n              fragmentByStart.delete(endIndex);", "          if ((f = fragmentByEnd.get(startIndex))) {\n            fragmentByEnd.delete(startIndex);\n            if ((g = fragmentByStart.get(endIndex))) {\n              fragmentByStart.delete(endIndex);\n              if (f === g) {\n                // closing a ring\n                interpolate(end, threshold, f.append);\n                if (!f.isEmpty()) {\n                  let list = segments[threshold];\n                  if (!list) {\n                    segments[threshold] = list = [];\n                  }\n                  list.push(f.lineString());\n                }\n              } else {\n                // connecting 2 segments\n                f.appendFragment(g);\n                fragmentByEnd.set((f.end = g.end), f);\n              }\n            } else {\n              // adding to the end of f\n              interpolate(end, threshold, f.append);\n              fragmentByEnd.set((f.end = endIndex), f);\n            }", "                  if (!list) {\n                    segments[threshold] = list = [];\n                  }\n                  list.push(f.lineString());\n                }\n              } else {\n                // connecting 2 segments\n                f.appendFragment(g);\n                fragmentByEnd.set((f.end = g.end), f);\n              }\n            } else {\n              // adding to the end of f\n              interpolate(end, threshold, f.append);\n              fragmentByEnd.set((f.end = endIndex), f);\n            }", "          } else if ((f = fragmentByStart.get(endIndex))) {\n            fragmentByStart.delete(endIndex);\n            // extending the start of f\n            interpolate(start, threshold, f.prepend);\n            fragmentByStart.set((f.start = startIndex), f);\n          } else {\n            // starting a new fragment\n            const newFrag = new Fragment(startIndex, endIndex);\n            interpolate(start, threshold, newFrag.append);\n            interpolate(end, threshold, newFrag.append);\n            fragmentByStart.set(startIndex, newFrag);\n            fragmentByEnd.set(endIndex, newFrag);\n          }\n        }\n      }\n    }\n  }\n", "  for (const [level, fragmentByStart] of fragmentByStartByLevel.entries()) {\n    let list: number[][] | null = null;\n    for (const value of fragmentByStart.values()) {\n      if (!value.isEmpty()) {\n        if (list == null) {\n          list = segments[level] || (segments[level] = []);\n        }\n        list.push(value.lineString());\n      }\n    }\n  }\n\n  return segments;\n}\n"]}
{"filename": "src/isolines.test.ts", "chunked_list": ["import { flattenDeep } from \"lodash\";\nimport { HeightTile } from \"./height-tile\";\nimport generateIsolines from \"./isolines\";\n\nrunTestWithRotations(\"corner halfway\", 2, heightTile(1, 1, 1, 3), {\n  2: [[1, 0.5, 0.5, 1]],\n});\n\nrunTestWithRotations(\n  \"corner above most of the way\",", "runTestWithRotations(\n  \"corner above most of the way\",\n  2,\n  heightTile(1, 1, 1, 2.33333),\n  {\n    2: [[1, 0.75, 0.75, 1]],\n  },\n);\n\nrunTestWithRotations(\"two contours\", 2, heightTile(1, 1, 1, 5), {", "\nrunTestWithRotations(\"two contours\", 2, heightTile(1, 1, 1, 5), {\n  2: [[1, 0.25, 0.25, 1]],\n  4: [[1, 0.75, 0.75, 1]],\n});\n\nrunTestWithRotations(\n  \"edge above threshold\",\n  2,\n  heightTile(1, 1, 2.33333, 2.33333),", "  2,\n  heightTile(1, 1, 2.33333, 2.33333),\n  {\n    2: [[1, 0.75, 0, 0.75]],\n  },\n);\n\nrunTestWithRotations(\n  \"edge above threshold\",\n  2,", "  \"edge above threshold\",\n  2,\n  heightTile(1, 1, 2.33333, 2.33333),\n  {\n    2: [[1, 0.75, 0, 0.75]],\n  },\n);\n\nrunTestWithRotations(\"corner up to threshold\", 2, heightTile(1, 1, 1, 2), {});\nrunTestWithRotations(\"omit empty point??\", 2, heightTile(2, 3, 3, 3), {", "runTestWithRotations(\"corner up to threshold\", 2, heightTile(1, 1, 1, 2), {});\nrunTestWithRotations(\"omit empty point??\", 2, heightTile(2, 3, 3, 3), {\n  2: [[0, 0, 0, 0]],\n});\nrunTestWithRotations(\"side up to threshold\", 2, heightTile(1, 2, 1, 2), {});\nrunTestWithRotations(\"side down to threshold\", 2, heightTile(2, 3, 2, 3), {\n  2: [[0, 0, 0, 1]],\n});\nrunTestWithRotations(\n  \"threshold middle\",", "runTestWithRotations(\n  \"threshold middle\",\n  2,\n  heightTile([\n    [1, 1, 1, 1],\n    [1, 2, 1, 1],\n    [1, 2, 1, 1],\n    [1, 1, 1, 1],\n  ]),\n  {},", "  ]),\n  {},\n);\nrunTestWithRotations(\n  \"corner below threshold\",\n  2,\n  heightTile([\n    [1, 2.3333333],\n    [2.3333333, 2.3333333],\n  ]),", "    [2.3333333, 2.3333333],\n  ]),\n  {\n    2: [[0.75, 0, 0, 0.75]],\n  },\n);\nrunTest(\n  \"saddle\",\n  0,\n  2,", "  0,\n  2,\n  heightTile([\n    [1, 2.3333333],\n    [2.3333333, 1],\n  ]),\n  {\n    2: [\n      [0.25, 1, 0, 0.75],\n      [0.75, 0, 1, 0.25],", "      [0.25, 1, 0, 0.75],\n      [0.75, 0, 1, 0.25],\n    ],\n  },\n);\nrunTestWithRotations(\"no contours\", 2, heightTile(1, 1, 1, 1), {});\nrunTestWithRotations(\n  \"connect segments\",\n  2,\n  heightTile([", "  2,\n  heightTile([\n    [1, 3, 3],\n    [1, 1, 3],\n    [1, 1, 1],\n  ]),\n  {\n    2: [[0.5, 0, 1, 0.5, 1.5, 1, 2, 1.5]],\n  },\n);", "  },\n);\nrunTest(\n  \"center point above\",\n  0,\n  2,\n  heightTile([\n    [1, 1, 1],\n    [1, 3, 1],\n    [1, 1, 1],", "    [1, 3, 1],\n    [1, 1, 1],\n  ]),\n  {\n    2: [[1.5, 1, 1, 0.5, 0.5, 1, 1, 1.5, 1.5, 1]],\n  },\n);\nrunTest(\n  \"center point below\",\n  0,", "  \"center point below\",\n  0,\n  2,\n  heightTile([\n    [3, 3, 3],\n    [3, 1, 3],\n    [3, 3, 3],\n  ]),\n  {\n    2: [[1, 1.5, 0.5, 1, 1, 0.5, 1.5, 1, 1, 1.5]],", "  {\n    2: [[1, 1.5, 0.5, 1, 1, 0.5, 1.5, 1, 1, 1.5]],\n  },\n);\n\nfunction heightTile(...values: number[] | number[][][]): HeightTile {\n  const flattened = flattenDeep(values);\n  const size = Math.sqrt(flattened.length);\n  return HeightTile.fromRawDem({\n    width: size,\n    height: size,\n    data: Float32Array.from(flattened),\n  });\n}\n", "function runTestWithRotations(\n  name: string,\n  interval: number,\n  heightTile: HeightTile,\n  expected: { [ele: number]: number[][] },\n) {\n  for (const rotation of [0, 90, 180, 270]) {\n    runTest(\n      `${name} (rotation=${rotation})`,\n      rotation,\n      interval,\n      heightTile,\n      expected,\n    );\n  }\n}\n", "function rotate(\n  [x, y]: [number, number],\n  [ax, ay]: [number, number],\n  angle: number,\n): [number, number] {\n  const theta = (angle * Math.PI) / 180;\n  const sin = Math.sin(theta);\n  const cos = Math.cos(theta);\n\n  const rx = x - ax;\n  const ry = y - ay;\n\n  return [round(ax + rx * cos - ry * sin), round(ay + ry * cos + rx * sin)];\n}\n", "function round(n: number): number {\n  return Math.round(n * 1000 + 0.001) / 1000;\n}\n\nfunction runTest(\n  name: string,\n  rotation: number,\n  interval: number,\n  heightTile: HeightTile,\n  expected: { [ele: number]: number[][] },\n) {\n  test(name, () => {\n    const size = heightTile.width;\n    const center = (size - 1) / 2;\n    const rotatedHeightTile = new HeightTile(\n      heightTile.width,\n      heightTile.height,\n      (x, y) => {", "        if (x < 0 || x >= size) {\n          throw new Error(`x=${x}`);\n        } else if (y < 0 || y >= size) {\n          throw new Error(`y=${y}`);\n        }\n        const [nx, ny] = rotate([x, y], [center, center], rotation).map(\n          round,\n        ) as [number, number];\n        return heightTile.get(nx, ny);\n      },\n    );\n    const isolines = generateIsolines(interval, rotatedHeightTile, 4096, 0);\n    const rotatedResult: { [ele: number]: number[][] } = {};", "    for (const ele in isolines) {\n      rotatedResult[ele] = isolines[ele].map((eles) => {\n        const rotatedLine: number[] = [...eles];\n        for (let i = 0; i < rotatedLine.length; i += 2) {\n          const [x, y] = rotate(\n            [\n              (rotatedLine[i] * (size - 1)) / 4096,\n              (rotatedLine[i + 1] * (size - 1)) / 4096,\n            ],\n            [center, center],\n            rotation,\n          );\n          rotatedLine[i] = x;\n          rotatedLine[i + 1] = y;\n        }\n        return rotatedLine;\n      });\n    }\n    expect(rotatedResult).toEqual(expected);\n  });\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import {\n  CancelablePromise,\n  ContourTile,\n  DemTile,\n  GlobalContourTileOptions,\n  IndividualContourTileOptions,\n  TransferrableContourTile,\n  TransferrableDemTile,\n} from \"./types\";\n\nfunction sortedEntries(object: any): [string, any][] {\n  const entries = Object.entries(object);\n  entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));\n  return entries;\n}\n", "} from \"./types\";\n\nfunction sortedEntries(object: any): [string, any][] {\n  const entries = Object.entries(object);\n  entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));\n  return entries;\n}\n\nfunction encodeThresholds(thresholds: {\n  [n: number]: number | number[];\n}): string {\n  return sortedEntries(thresholds)\n    .map(([key, value]) =>\n      [key, ...(typeof value === \"number\" ? [value] : value)].join(\"*\"),\n    )\n    .join(\"~\");\n}\n", "function encodeThresholds(thresholds: {\n  [n: number]: number | number[];\n}): string {\n  return sortedEntries(thresholds)\n    .map(([key, value]) =>\n      [key, ...(typeof value === \"number\" ? [value] : value)].join(\"*\"),\n    )\n    .join(\"~\");\n}\n\nfunction decodeThresholds(thresholds: string): {\n  [n: number]: number | number[];\n} {\n  return Object.fromEntries(\n    thresholds\n      .split(\"~\")\n      .map((part) => part.split(\"*\").map(Number))\n      .map(([key, ...values]) => [key, values]),\n  );\n}\n", "function decodeThresholds(thresholds: string): {\n  [n: number]: number | number[];\n} {\n  return Object.fromEntries(\n    thresholds\n      .split(\"~\")\n      .map((part) => part.split(\"*\").map(Number))\n      .map(([key, ...values]) => [key, values]),\n  );\n}\n", "export function encodeOptions({\n  thresholds,\n  ...rest\n}: GlobalContourTileOptions): string {\n  return sortedEntries({ thresholds: encodeThresholds(thresholds), ...rest })\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(value)}`,\n    )\n    .join(\"&\");\n}\n", "export function decodeOptions(options: string): GlobalContourTileOptions {\n  return Object.fromEntries(\n    options\n      .replace(/^.*\\?/, \"\")\n      .split(\"&\")\n      .map((part) => {\n        const parts = part.split(\"=\").map(decodeURIComponent);\n        const k = parts[0] as keyof GlobalContourTileOptions;\n        let v: any = parts[1];\n        switch (k) {\n          case \"thresholds\":\n            v = decodeThresholds(v);\n            break;\n          case \"extent\":\n          case \"multiplier\":\n          case \"overzoom\":\n          case \"buffer\":\n            v = Number(v);\n        }\n        return [k, v];\n      }),\n  ) as any as GlobalContourTileOptions;\n}\n", "export function encodeIndividualOptions(\n  options: IndividualContourTileOptions,\n): string {\n  return sortedEntries(options)\n    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n    .join(\",\");\n}\n\nexport function getOptionsForZoom(\n  options: GlobalContourTileOptions,\n  zoom: number,\n): IndividualContourTileOptions {\n  const { thresholds, ...rest } = options;\n\n  let levels: number[] = [];\n  let maxLessThanOrEqualTo: number = -Infinity;\n\n  Object.entries(thresholds).forEach(([zString, value]) => {\n    const z = Number(zString);", "export function getOptionsForZoom(\n  options: GlobalContourTileOptions,\n  zoom: number,\n): IndividualContourTileOptions {\n  const { thresholds, ...rest } = options;\n\n  let levels: number[] = [];\n  let maxLessThanOrEqualTo: number = -Infinity;\n\n  Object.entries(thresholds).forEach(([zString, value]) => {\n    const z = Number(zString);", "    if (z <= zoom && z > maxLessThanOrEqualTo) {\n      maxLessThanOrEqualTo = z;\n      levels = typeof value === \"number\" ? [value] : value;\n    }\n  });\n\n  return {\n    levels,\n    ...rest,\n  };\n}\n", "export function map<T, U>(\n  { cancel, value }: CancelablePromise<T>,\n  mapper: (t: T) => U,\n) {\n  return { cancel, value: value.then(mapper) };\n}\n\nexport function copy(src: ArrayBuffer): ArrayBuffer {\n  const dst = new ArrayBuffer(src.byteLength);\n  new Uint8Array(dst).set(new Uint8Array(src));\n  return dst;\n}\n", "export function prepareDemTile(\n  promise: CancelablePromise<DemTile>,\n  copy: boolean,\n): CancelablePromise<TransferrableDemTile> {\n  return map(promise, ({ data, ...rest }) => {\n    let newData = data;\n    if (copy) {\n      newData = new Float32Array(data.length);\n      newData.set(data);\n    }\n    return { ...rest, data: newData, transferrables: [newData.buffer] };\n  });\n}\n", "export function prepareContourTile(\n  promise: CancelablePromise<ContourTile>,\n): CancelablePromise<TransferrableContourTile> {\n  return map(promise, ({ arrayBuffer }) => {\n    const clone = copy(arrayBuffer);\n    return {\n      arrayBuffer: clone,\n      transferrables: [clone],\n    };\n  });\n}\n\nlet supportsOffscreenCanvas: boolean | null = null;\n", "export function offscreenCanvasSupported(): boolean {\n  if (supportsOffscreenCanvas == null) {\n    supportsOffscreenCanvas =\n      typeof OffscreenCanvas !== \"undefined\" &&\n      new OffscreenCanvas(1, 1).getContext(\"2d\") &&\n      typeof createImageBitmap === \"function\";\n  }\n\n  return supportsOffscreenCanvas || false;\n}\n", "export function withTimeout<T>(\n  timeoutMs: number,\n  { value, cancel }: CancelablePromise<T>,\n): CancelablePromise<T> {\n  let reject: (error: Error) => void = () => {};\n  const timeout = setTimeout(() => {\n    cancel();\n    reject(new Error(\"timed out\"));\n  }, timeoutMs);\n  const cancelPromise: Promise<any> = new Promise((_, rej) => {\n    reject = rej;\n  });\n  return {\n    value: Promise.race([\n      cancelPromise,\n      (async () => {", "        try {\n          return await value;\n        } finally {\n          clearTimeout(timeout);\n        }\n      })(),\n    ]),\n    cancel: () => {\n      clearTimeout(timeout);\n      cancel();\n    },\n  };\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import generateIsolines from \"./isolines\";\nimport { DemSource } from \"./dem-source\";\nimport { decodeParsedImage } from \"./decode-image\";\nimport { LocalDemManager } from \"./dem-manager\";\nimport CONFIG from \"./config\";\nimport { HeightTile } from \"./height-tile\";\n\nconst exported = {\n  generateIsolines,\n  DemSource,", "  generateIsolines,\n  DemSource,\n  HeightTile,\n  LocalDemManager,\n  decodeParsedImage,\n  set workerUrl(url: string) {\n    CONFIG.workerUrl = url;\n  },\n  get workerUrl() {\n    return CONFIG.workerUrl;", "  get workerUrl() {\n    return CONFIG.workerUrl;\n  },\n};\nexport default exported;\n"]}
{"filename": "src/actor.ts", "chunked_list": ["import { Timer } from \"./performance\";\nimport { CancelablePromise, IsTransferrable, Timing } from \"./types\";\nimport { withTimeout } from \"./utils\";\n\nlet id = 0;\n\ninterface Cancel {\n  type: \"cancel\";\n  id: number;\n}\ninterface Response {\n  type: \"response\";\n  id: number;\n  error?: string;\n  response?: any;\n  timings: Timing;\n}", "interface Response {\n  type: \"response\";\n  id: number;\n  error?: string;\n  response?: any;\n  timings: Timing;\n}\ninterface Request {\n  type: \"request\";\n  id?: number;\n  name: string;\n  args: any[];\n}", "type Message = Cancel | Response | Request;\n\ntype MethodsReturning<T, R> = {\n  [K in keyof T]: T[K] extends (...args: any) => R ? T[K] : never;\n};\n\n/**\n * Utility for sending messages to a remote instance of `<T>` running in a web worker\n * from the main thread, or in the main thread running from a web worker.\n */\nexport default class Actor<T> {\n  callbacks: {\n    [id: number]: (\n      error: Error | undefined,\n      message: any,\n      timings: Timing,\n    ) => void;\n  };\n  cancels: { [id: number]: () => void };\n  dest: Worker;\n  timeoutMs: number;\n  constructor(dest: Worker, dispatcher: any, timeoutMs: number = 20_000) {\n    this.callbacks = {};\n    this.cancels = {};\n    this.dest = dest;\n    this.timeoutMs = timeoutMs;\n    this.dest.onmessage = async ({ data }) => {\n      const message: Message = data;", "export default class Actor<T> {\n  callbacks: {\n    [id: number]: (\n      error: Error | undefined,\n      message: any,\n      timings: Timing,\n    ) => void;\n  };\n  cancels: { [id: number]: () => void };\n  dest: Worker;\n  timeoutMs: number;\n  constructor(dest: Worker, dispatcher: any, timeoutMs: number = 20_000) {\n    this.callbacks = {};\n    this.cancels = {};\n    this.dest = dest;\n    this.timeoutMs = timeoutMs;\n    this.dest.onmessage = async ({ data }) => {\n      const message: Message = data;", "      if (message.type === \"cancel\") {\n        const cancel = this.cancels[message.id];\n        delete this.cancels[message.id];\n        if (cancel) {\n          cancel();\n        }\n      } else if (message.type === \"response\") {\n        const callback = this.callbacks[message.id];\n        delete this.callbacks[message.id];\n        if (callback) {\n          callback(\n            message.error ? new Error(message.error) : undefined,\n            message.response,\n            message.timings,\n          );\n        }", "        if (callback) {\n          callback(\n            message.error ? new Error(message.error) : undefined,\n            message.response,\n            message.timings,\n          );\n        }\n      } else if (message.type === \"request\") {\n        const timer = new Timer(\"worker\");\n        const handler: Function = (dispatcher as any)[message.name];\n        const request = handler.apply(handler, [...message.args, timer]);\n        const url = `${message.name}_${message.id}`;", "        if (message.id && request) {\n          this.cancels[message.id] = request.cancel;\n          try {\n            const response = await request.value;\n            const transferrables = (response as IsTransferrable)\n              ?.transferrables;\n            this.postMessage(\n              {\n                id: message.id,\n                type: \"response\",\n                response,\n                timings: timer.finish(url),\n              },\n              transferrables,\n            );", "          } catch (e: any) {\n            this.postMessage({\n              id: message.id,\n              type: \"response\",\n              error: e?.toString() || \"error\",\n              timings: timer.finish(url),\n            });\n          }\n          delete this.cancels[message.id];\n        }\n      }\n    };\n  }\n\n  postMessage(message: Message, transferrables?: Transferable[]) {\n    this.dest.postMessage(message, transferrables || []);\n  }\n\n  /** Invokes a method by name with a set of arguments in the remote context. */\n  send<\n    R,\n    M extends MethodsReturning<T, CancelablePromise<R>>,\n    K extends keyof M & string,\n    P extends Parameters<M[K]>,\n  >(\n    name: K,\n    transferrables: Transferable[],\n    timer?: Timer,\n    ...args: P\n  ): CancelablePromise<R> {\n    const thisId = ++id;\n    const value: Promise<R> = new Promise((resolve, reject) => {\n      this.postMessage(\n        { id: thisId, type: \"request\", name, args },\n        transferrables,\n      );\n      this.callbacks[thisId] = (error, result, timings) => {\n        timer?.addAll(timings);", "        if (error) reject(error);\n        else resolve(result);\n      };\n    });\n\n    return withTimeout(this.timeoutMs, {\n      value,\n      cancel: () => {\n        delete this.callbacks[thisId];\n        this.postMessage({ id: thisId, type: \"cancel\" });\n      },\n    });\n  }\n}\n"]}
{"filename": "src/height-tile.ts", "chunked_list": ["import { DemTile } from \"./types\";\n\nconst MIN_VALID_M = -12000;\nconst MAX_VALID_M = 9000;\nfunction defaultIsValid(number: number): boolean {\n  return !isNaN(number) && number >= MIN_VALID_M && number <= MAX_VALID_M;\n}\n\n/** A tile containing elevation values aligned to a grid. */\nexport class HeightTile {\n  get: (x: number, y: number) => number;\n  width: number;\n  height: number;\n  constructor(\n    width: number,\n    height: number,\n    get: (x: number, y: number) => number,\n  ) {\n    this.get = get;\n    this.width = width;\n    this.height = height;\n  }\n\n  /** Construct a height tile from raw DEM pixel values */\n  static fromRawDem(demTile: DemTile): HeightTile {\n    return new HeightTile(demTile.width, demTile.height, (x, y) => {\n      const value = demTile.data[y * demTile.width + x];\n      return defaultIsValid(value) ? value : NaN;\n    });\n  }\n\n  /**\n   * Construct a height tile from a DEM tile plus it's 8 neighbors, so that\n   * you can request `x` or `y` outside the bounds of the original tile.\n   *\n   * @param neighbors An array containing tiles: `[nw, n, ne, w, c, e, sw, s, se]`\n   */\n  static combineNeighbors(\n    neighbors: (HeightTile | undefined)[],\n  ): HeightTile | undefined {", "export class HeightTile {\n  get: (x: number, y: number) => number;\n  width: number;\n  height: number;\n  constructor(\n    width: number,\n    height: number,\n    get: (x: number, y: number) => number,\n  ) {\n    this.get = get;\n    this.width = width;\n    this.height = height;\n  }\n\n  /** Construct a height tile from raw DEM pixel values */\n  static fromRawDem(demTile: DemTile): HeightTile {\n    return new HeightTile(demTile.width, demTile.height, (x, y) => {\n      const value = demTile.data[y * demTile.width + x];\n      return defaultIsValid(value) ? value : NaN;\n    });\n  }\n\n  /**\n   * Construct a height tile from a DEM tile plus it's 8 neighbors, so that\n   * you can request `x` or `y` outside the bounds of the original tile.\n   *\n   * @param neighbors An array containing tiles: `[nw, n, ne, w, c, e, sw, s, se]`\n   */\n  static combineNeighbors(\n    neighbors: (HeightTile | undefined)[],\n  ): HeightTile | undefined {", "    if (neighbors.length !== 9) {\n      throw new Error(\"Must include a tile plus 8 neighbors\");\n    }\n    const mainTile = neighbors[4];\n    if (!mainTile) {\n      return undefined;\n    }\n    const width = mainTile.width;\n    const height = mainTile.height;\n    return new HeightTile(width, height, (x, y) => {\n      let gridIdx = 0;", "      if (y < 0) {\n        y += height;\n      } else if (y < height) {\n        gridIdx += 3;\n      } else {\n        y -= height;\n        gridIdx += 6;\n      }\n      if (x < 0) {\n        x += width;\n      } else if (x < width) {\n        gridIdx += 1;\n      } else {\n        x -= width;\n        gridIdx += 2;\n      }\n      const grid = neighbors[gridIdx];\n      return grid ? grid.get(x, y) : NaN;\n    });\n  }\n\n  /**\n   * Splits this tile into a `1<<subz` x `1<<subz` grid and returns the tile at coordinates `subx, suby`.\n   */\n  split = (subz: number, subx: number, suby: number): HeightTile => {", "      if (x < 0) {\n        x += width;\n      } else if (x < width) {\n        gridIdx += 1;\n      } else {\n        x -= width;\n        gridIdx += 2;\n      }\n      const grid = neighbors[gridIdx];\n      return grid ? grid.get(x, y) : NaN;\n    });\n  }\n\n  /**\n   * Splits this tile into a `1<<subz` x `1<<subz` grid and returns the tile at coordinates `subx, suby`.\n   */\n  split = (subz: number, subx: number, suby: number): HeightTile => {", "    if (subz === 0) return this;\n    const by = 1 << subz;\n    const dx = (subx * this.width) / by;\n    const dy = (suby * this.height) / by;\n    return new HeightTile(this.width / by, this.height / by, (x, y) =>\n      this.get(x + dx, y + dy),\n    );\n  };\n\n  /**\n   * Returns a new tile scaled up by `factor` with pixel values that are subsampled using\n   * bilinear interpolation between the original height tile values.\n   *\n   * The original and result tile are assumed to represent values taken at the center of each pixel.\n   */\n  subsamplePixelCenters = (factor: number): HeightTile => {\n    const lerp = (a: number, b: number, f: number) =>\n      isNaN(a) ? b : isNaN(b) ? a : a + (b - a) * f;", "    if (factor <= 1) return this;\n    const sub = 0.5 - 1 / (2 * factor);\n    const blerper = (x: number, y: number) => {\n      const dx = x / factor - sub;\n      const dy = y / factor - sub;\n      const ox = Math.floor(dx);\n      const oy = Math.floor(dy);\n      const a = this.get(ox, oy);\n      const b = this.get(ox + 1, oy);\n      const c = this.get(ox, oy + 1);\n      const d = this.get(ox + 1, oy + 1);\n      const fx = dx - ox;\n      const fy = dy - oy;\n      const top = lerp(a, b, fx);\n      const bottom = lerp(c, d, fx);\n      return lerp(top, bottom, fy);\n    };\n    return new HeightTile(this.width * factor, this.height * factor, blerper);\n  };\n\n  /**\n   * Assumes the input tile represented measurements taken at the center of each pixel, and\n   * returns a new tile where values are the height at the top-left of each pixel by averaging\n   * the 4 adjacent pixel values.\n   */\n  averagePixelCentersToGrid = (radius: number = 1): HeightTile =>\n    new HeightTile(this.width + 1, this.height + 1, (x, y) => {\n      let sum = 0,\n        count = 0,\n        v = 0;", "      for (let newX = x - radius; newX < x + radius; newX++) {\n        for (let newY = y - radius; newY < y + radius; newY++) {\n          if (!isNaN((v = this.get(newX, newY)))) {\n            count++;\n            sum += v;\n          }\n        }\n      }\n      return count === 0 ? NaN : sum / count;\n    });\n\n  /** Returns a new tile with elevation values scaled by `multiplier`. */\n  scaleElevation = (multiplier: number): HeightTile =>\n    multiplier === 1\n      ? this\n      : new HeightTile(\n          this.width,\n          this.height,\n          (x, y) => this.get(x, y) * multiplier,\n        );\n\n  /**\n   * Precompute every value from `-bufer, -buffer` to `width + buffer, height + buffer` and serve them\n   * out of a `Float32Array`. Until this method is called, all `get` requests are lazy and call all previous\n   * methods in the chain up to the root DEM tile.\n   */\n  materialize = (buffer: number = 2): HeightTile => {\n    const stride = this.width + 2 * buffer;\n    const data = new Float32Array(stride * (this.height + 2 * buffer));\n    let idx = 0;", "    for (let y = -buffer; y < this.height + buffer; y++) {\n      for (let x = -buffer; x < this.width + buffer; x++) {\n        data[idx++] = this.get(x, y);\n      }\n    }\n    return new HeightTile(\n      this.width,\n      this.height,\n      (x, y) => data[(y + buffer) * stride + x + buffer],\n    );\n  };\n}\n"]}
{"filename": "src/setup-jest.ts", "chunked_list": ["import \"whatwg-fetch\";\nglobal.fetch = jest.fn();\nperformance.now = () => Date.now();\n"]}
{"filename": "src/dem-source.ts", "chunked_list": ["import { DemManager, LocalDemManager } from \"./dem-manager\";\nimport { decodeOptions, encodeOptions, getOptionsForZoom } from \"./utils\";\nimport RemoteDemManager from \"./remote-dem-manager\";\nimport { DemTile, Cancelable, GlobalContourTileOptions, Timing } from \"./types\";\nimport type WorkerDispatch from \"./worker-dispatch\";\nimport Actor from \"./actor\";\nimport { Timer } from \"./performance\";\n\nif (!Blob.prototype.arrayBuffer) {\n  Blob.prototype.arrayBuffer = function arrayBuffer() {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      const fileReader = new FileReader();\n      fileReader.onload = (event) =>\n        resolve(event.target?.result as ArrayBuffer);\n      fileReader.onerror = reject;\n      fileReader.readAsArrayBuffer(this);\n    });\n  };\n}\n\n// for maplibre interop", "if (!Blob.prototype.arrayBuffer) {\n  Blob.prototype.arrayBuffer = function arrayBuffer() {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      const fileReader = new FileReader();\n      fileReader.onload = (event) =>\n        resolve(event.target?.result as ArrayBuffer);\n      fileReader.onerror = reject;\n      fileReader.readAsArrayBuffer(this);\n    });\n  };\n}\n\n// for maplibre interop", "type RequestParameters = {\n  url: string;\n  headers?: any;\n  method?: \"GET\" | \"POST\" | \"PUT\";\n  body?: string;\n  type?: \"string\" | \"json\" | \"arrayBuffer\";\n  credentials?: \"same-origin\" | \"include\";\n  collectResourceTiming?: boolean;\n};\ntype ResponseCallback = (\n  error?: Error | undefined,\n  data?: any | undefined,\n  cacheControl?: string | undefined,\n  expires?: string | undefined,\n) => void;", "type ResponseCallback = (\n  error?: Error | undefined,\n  data?: any | undefined,\n  cacheControl?: string | undefined,\n  expires?: string | undefined,\n) => void;\ntype Protocol = (\n  request: RequestParameters,\n  response: ResponseCallback,\n) => Cancelable;\n\nconst used = new Set<string>();\n\n/**\n * A remote source of DEM tiles that can be connected to maplibre.\n */", "export class DemSource {\n  sharedDemProtocolId: string;\n  contourProtocolId: string;\n  contourProtocolUrlBase: string;\n  manager: DemManager;\n  sharedDemProtocolUrl: string;\n  timingCallbacks: Array<(timing: Timing) => void> = [];\n\n  constructor({\n    url,\n    cacheSize = 100,\n    id = \"dem\",\n    encoding = \"terrarium\",\n    maxzoom = 12,\n    worker = true,\n    timeoutMs = 10_000,\n    actor,\n  }: {\n    /** Remote DEM tile url using `{z}` `{x}` and `{y}` placeholders */\n    url: string;\n    /** Number of most-recently-used tiles to cache */\n    cacheSize?: number;\n    /** Prefix for the maplibre protocol */\n    id?: string;\n    encoding?: \"terrarium\" | \"mapbox\";\n    /** Maximum zoom of tiles contained in the source */\n    maxzoom: number;\n    timeoutMs?: number;\n    /** Handle requests in a shared web worker to reduce UI-thread jank */\n    worker?: boolean;\n    actor?: Actor<WorkerDispatch>;\n  }) {\n    let protocolPrefix = id;\n    let i = 1;", "    while (used.has(protocolPrefix)) {\n      protocolPrefix = id + i++;\n    }\n    used.add(protocolPrefix);\n    this.sharedDemProtocolId = `${protocolPrefix}-shared`;\n    this.contourProtocolId = `${protocolPrefix}-contour`;\n    this.sharedDemProtocolUrl = `${this.sharedDemProtocolId}://{z}/{x}/{y}`;\n    this.contourProtocolUrlBase = `${this.contourProtocolId}://{z}/{x}/{y}`;\n    const ManagerClass = worker ? RemoteDemManager : LocalDemManager;\n    this.manager = new ManagerClass(\n      url,\n      cacheSize,\n      encoding,\n      maxzoom,\n      timeoutMs,\n      actor,\n    );\n  }\n\n  /** Registers a callback to be invoked with a performance report after each tile is requested. */\n  onTiming = (callback: (timing: Timing) => void) => {\n    this.timingCallbacks.push(callback);\n  };\n\n  getDemTile(z: number, x: number, y: number): Promise<DemTile> {\n    return this.manager.fetchAndParseTile(z, x, y).value;\n  }\n\n  /**\n   * Adds contour and shared DEM protocol handlers to maplibre.\n   *\n   * @param maplibre maplibre global object\n   */\n  setupMaplibre = (maplibre: {\n    addProtocol: (id: string, protcol: Protocol) => void;\n  }) => {\n    maplibre.addProtocol(this.sharedDemProtocolId, this.sharedDemProtocol);\n    maplibre.addProtocol(this.contourProtocolId, this.contourProtocol);\n  };\n\n  parseUrl(url: string): [number, number, number] {\n    const [, z, x, y] = /\\/\\/(\\d+)\\/(\\d+)\\/(\\d+)/.exec(url) || [];\n    return [Number(z), Number(x), Number(y)];\n  }\n\n  /**\n   * Callback to be used with maplibre addProtocol to re-use cached DEM tiles across sources.\n   */\n  sharedDemProtocol = (\n    request: RequestParameters,\n    response: ResponseCallback,\n  ): Cancelable => {\n    const [z, x, y] = this.parseUrl(request.url);\n    const timer = new Timer(\"main\");\n    const result = this.manager.fetchTile(z, x, y, timer);\n    let canceled = false;\n    (async () => {\n      let timing: Timing;", "      try {\n        const data = await result.value;\n        timing = timer.finish(request.url);\n        if (canceled) return;\n        const arrayBuffer: ArrayBuffer = await data.data.arrayBuffer();\n        if (canceled) return;\n        response(undefined, arrayBuffer, data.cacheControl, data.expires);\n      } catch (error) {\n        timing = timer.error(request.url);\n        if (canceled) return;\n        response(error as Error);\n      }\n      this.timingCallbacks.forEach((cb) => cb(timing));\n    })();\n    return {\n      cancel: () => {\n        canceled = false;\n        result.cancel();\n      },\n    };\n  };\n\n  /**\n   * Callback to be used with maplibre addProtocol to generate contour vector tiles according\n   * to options encoded in the tile URL pattern generated by `contourProtocolUrl`.\n   */\n  contourProtocol = (\n    request: RequestParameters,\n    response: ResponseCallback,\n  ): Cancelable => {\n    const timer = new Timer(\"main\");\n    const [z, x, y] = this.parseUrl(request.url);\n    const options = decodeOptions(request.url);\n    const result = this.manager.fetchContourTile(\n      z,\n      x,\n      y,\n      getOptionsForZoom(options, z),\n      timer,\n    );\n    let canceled = false;\n    (async () => {\n      let timing: Timing;", "        if (canceled) return;\n        response(error as Error);\n      }\n      this.timingCallbacks.forEach((cb) => cb(timing));\n    })();\n    return {\n      cancel: () => {\n        canceled = false;\n        result.cancel();\n      },\n    };\n  };\n\n  /**\n   * Callback to be used with maplibre addProtocol to generate contour vector tiles according\n   * to options encoded in the tile URL pattern generated by `contourProtocolUrl`.\n   */\n  contourProtocol = (\n    request: RequestParameters,\n    response: ResponseCallback,\n  ): Cancelable => {\n    const timer = new Timer(\"main\");\n    const [z, x, y] = this.parseUrl(request.url);\n    const options = decodeOptions(request.url);\n    const result = this.manager.fetchContourTile(\n      z,\n      x,\n      y,\n      getOptionsForZoom(options, z),\n      timer,\n    );\n    let canceled = false;\n    (async () => {\n      let timing: Timing;", "      try {\n        const data = await result.value;\n        timing = timer.finish(request.url);\n        if (canceled) return;\n        response(undefined, data.arrayBuffer);\n      } catch (error) {\n        if (canceled) return;\n        timing = timer.error(request.url);\n        response(error as Error);\n      }\n      this.timingCallbacks.forEach((cb) => cb(timing));\n    })();\n    return {\n      cancel: () => {\n        canceled = true;\n        result.cancel();\n      },\n    };\n  };\n\n  /**\n   * Returns a URL with the correct maplibre protocol prefix and all `option` encoded in request parameters.\n   */\n  contourProtocolUrl = (options: GlobalContourTileOptions) =>\n    `${this.contourProtocolUrlBase}?${encodeOptions(options)}`;\n}\n"]}
{"filename": "src/e2e.test.ts", "chunked_list": ["import { flattenDeep } from \"lodash\";\nimport Actor from \"./actor\";\nimport WorkerDispatch from \"./worker-dispatch\";\nimport { DemSource } from \"./dem-source\";\nimport { MainThreadDispatch } from \"./remote-dem-manager\";\nimport { CancelablePromise, DemTile, Timing } from \"./types\";\nimport { VectorTile } from \"@mapbox/vector-tile\";\nimport Pbf from \"pbf\";\n\nbeforeEach(() => {", "\nbeforeEach(() => {\n  jest.useFakeTimers({ now: 0, doNotFake: [\"performance\"] });\n});\nafterEach(() => {\n  jest.useRealTimers();\n});\n\njest.mock(\"./decode-image\", () => (): CancelablePromise<DemTile> => {\n  jest.advanceTimersByTime(1);", "jest.mock(\"./decode-image\", () => (): CancelablePromise<DemTile> => {\n  jest.advanceTimersByTime(1);\n  // eslint-disable-next-line global-require\n  const flattenDeep = require(\"lodash/flattenDeep\");\n  const value: DemTile = {\n    data: Float32Array.from(\n      flattenDeep([\n        [5, 5, 5, 5],\n        [5, 15, 15, 5],\n        [5, 15, 15, 5],", "        [5, 15, 15, 5],\n        [5, 15, 15, 5],\n        [5, 5, 5, 5],\n      ]),\n    ),\n    width: 4,\n    height: 4,\n  };\n  return { value: Promise.resolve(value), cancel() {} };\n});", "  return { value: Promise.resolve(value), cancel() {} };\n});\n\nconst remote = new WorkerDispatch();\nconst local = new MainThreadDispatch();\nconst workerFromMainThread: Worker = {} as any as Worker;\nconst mainThreadFromWorker: Worker = {} as any as Worker;\nworkerFromMainThread.postMessage = (data) =>\n  mainThreadFromWorker?.onmessage?.({ data } as any);\nmainThreadFromWorker.postMessage = (data) =>", "  mainThreadFromWorker?.onmessage?.({ data } as any);\nmainThreadFromWorker.postMessage = (data) =>\n  workerFromMainThread?.onmessage?.({ data } as any);\nconst mainActor = new Actor<WorkerDispatch>(workerFromMainThread, local);\nconst workerActor = new Actor<MainThreadDispatch>(mainThreadFromWorker, remote);\n\nconst source = new DemSource({\n  url: \"https://example/{z}/{x}/{y}.png\",\n  cacheSize: 100,\n  encoding: \"terrarium\",", "  cacheSize: 100,\n  encoding: \"terrarium\",\n  maxzoom: 11,\n  worker: true,\n  actor: mainActor,\n});\n\nconst expectedElevations = Float32Array.from(\n  flattenDeep([\n    [5, 5, 5, 5],", "  flattenDeep([\n    [5, 5, 5, 5],\n    [5, 15, 15, 5],\n    [5, 15, 15, 5],\n    [5, 5, 5, 5],\n  ]),\n);\n\ntest(\"e2e fetch tile and shared DEM protocol share cache\", async () => {\n  global.fetch = jest.fn().mockImplementation(async () => {", "test(\"e2e fetch tile and shared DEM protocol share cache\", async () => {\n  global.fetch = jest.fn().mockImplementation(async () => {\n    jest.advanceTimersByTime(1);\n    return new Response(\n      new Blob([Uint8Array.from([1, 2])], { type: \"image/png\" }),\n      {\n        status: 200,\n      },\n    );\n  });", "    );\n  });\n  const tile = await source.getDemTile(1, 2, 3);\n  expect(tile.data).toEqual(expectedElevations);\n  expect(tile.width).toBe(4);\n  expect(tile.height).toBe(4);\n  const tile2 = await source.getDemTile(1, 2, 3);\n  expect(tile2.data).toEqual(expectedElevations);\n\n  const timings: Timing[] = [];", "\n  const timings: Timing[] = [];\n  source.onTiming((timing) => timings.push(timing));\n  const fetched = await new Promise((resolve, reject) => {\n    source.sharedDemProtocol(\n      {\n        url: source.sharedDemProtocolUrl\n          .replace(\"{z}\", \"1\")\n          .replace(\"{x}\", \"2\")\n          .replace(\"{y}\", \"3\"),", "          .replace(\"{x}\", \"2\")\n          .replace(\"{y}\", \"3\"),\n      },\n      (err, data) => {\n        if (err) reject(err);\n        else resolve(data);\n      },\n    );\n  });\n\n  expect(fetched).toEqual(Uint8Array.from([1, 2]).buffer);\n\n  expect(global.fetch).toBeCalledTimes(1);\n  expect(global.fetch).toBeCalledWith(\n    \"https://example/1/2/3.png\",\n    expect.anything(),\n  );\n  expect(timings).toMatchObject([\n    {\n      duration: 0,\n      marks: {\n        main: [[2, 2]],\n        worker: [[2, 2]],\n      },\n      resources: [],\n      url: \"dem-shared://1/2/3\",\n      wait: 0,\n    },\n  ]);\n});\n\ntest(\"e2e contour tile\", async () => {\n  global.fetch = jest.fn().mockImplementation(async () => {\n    jest.advanceTimersByTime(1);\n    return new Response(\n      new Blob([Uint8Array.from([1, 2])], { type: \"image/png\" }),\n      {\n        status: 200,\n      },\n    );\n  });\n  const timings: Timing[] = [];\n  source.onTiming((timing) => timings.push(timing));\n  const contourTile: ArrayBuffer = await new Promise((resolve, reject) => {\n    source.contourProtocol(\n      {\n        url: source\n          .contourProtocolUrl({\n            thresholds: {\n              10: 10,\n            },\n            buffer: 0,\n            contourLayer: \"c\",\n            elevationKey: \"e\",\n            levelKey: \"l\",\n            overzoom: 0,\n          })\n          .replace(\"{z}\", \"10\")\n          .replace(\"{x}\", \"20\")\n          .replace(\"{y}\", \"30\"),\n      },\n      (err, data) => {", "        if (err) reject(err);\n        else resolve(data);\n      },\n    );\n  });\n\n  const tile = new VectorTile(new Pbf(contourTile));\n\n  expect(tile.layers.c.name).toBe(\"c\");\n  expect(tile.layers.c.extent).toBe(4096);\n  expect(tile.layers.c.length).toBe(1);\n  expect(tile.layers.c.feature(0).properties).toEqual({\n    e: 10,\n    l: 0,\n  });\n  const geom = tile.layers.c.feature(0).loadGeometry()[0];\n  expect(geom.length).toEqual(253);\n\n  let xSum = 0,\n    ySum = 0;", "  for (const { x, y } of geom) {\n    xSum += x;\n    ySum += y;\n  }\n  const center = { x: Math.round(xSum / 253), y: Math.round(ySum / 253) };\n  expect(center).toMatchObject({\n    x: 2049,\n    y: 2052,\n  });\n  expect(timings).toMatchObject([\n    {\n      tilesUsed: 9,\n      process: 0,\n      duration: 18,\n      marks: {\n        main: [[0, 18]],\n        worker: [[0, 18]],\n        fetch: [\n          [0, 9],\n          [1, 9],\n          [2, 9],\n          [3, 9],\n          [4, 9],\n          [5, 9],\n          [6, 9],\n          [7, 9],\n          [8, 9],\n        ],\n        decode: [\n          [10, 18],\n          [11, 18],\n          [12, 18],\n          [13, 18],\n          [14, 18],\n          [15, 18],\n          [16, 18],\n          [17, 18],\n          [18, 18],\n        ],\n        isoline: [[18, 18, 18]],\n      },\n      decode: 8,\n      fetch: 9,\n      resources: [],\n      url: \"dem-contour://10/20/30?buffer=0&contourLayer=c&elevationKey=e&levelKey=l&overzoom=0&thresholds=10*10\",\n      wait: 1,\n    },\n  ]);\n\n  // fetch adjacent tile where 6/9 neighbors are already cached\n  jest.setSystemTime(1);\n  performance.getEntriesByName = (name) => [\n    {\n      duration: 1,\n      name,\n      entryType: \"resource\",\n      startTime: performance.now(),\n    } as PerformanceResourceTiming,\n  ];\n  await new Promise((resolve, reject) => {\n    source.contourProtocol(\n      {\n        url: source\n          .contourProtocolUrl({\n            thresholds: {\n              10: 10,\n            },\n            overzoom: 0,\n          })\n          .replace(\"{z}\", \"10\")\n          .replace(\"{x}\", \"21\")\n          .replace(\"{y}\", \"30\"),\n      },\n      (err, data) => {", "        if (err) reject(err);\n        else resolve(data);\n      },\n    );\n  });\n  expect(timings[1]).toMatchObject({\n    tilesUsed: 9,\n    process: 0,\n    duration: 6,\n    decode: 2,\n    fetch: 3,\n    wait: 1,\n    marks: {\n      main: [[1, 7]],\n      worker: [[1, 7]],\n      fetch: [\n        [1, 4],\n        [2, 4],\n        [3, 4],\n      ],\n      decode: [\n        [5, 7],\n        [6, 7],\n        [7, 7],\n      ],\n      isoline: [[7, 7, 7]],\n    },\n    resources: [\n      { duration: 1, startTime: 7, name: \"https://example/10/22/29.png\" },\n      { duration: 1, startTime: 7, name: \"https://example/10/22/30.png\" },\n      { duration: 1, startTime: 7, name: \"https://example/10/22/31.png\" },\n    ],\n    url: \"dem-contour://10/21/30?overzoom=0&thresholds=10*10\",\n  });\n});\n\ntest(\"decode image from worker\", async () => {\n  const result = await workerActor.send(\n    \"decodeImage\",\n    [],\n    undefined,\n    new Blob([], { type: \"image/png\" }),\n    \"terrarium\",\n  ).value;\n  expect(result).toMatchObject({\n    width: 4,\n    height: 4,\n    data: expectedElevations,\n  });\n});\n"]}
{"filename": "src/utils.test.ts", "chunked_list": ["import {\n  GlobalContourTileOptions,\n  IndividualContourTileOptions,\n} from \"./types\";\nimport {\n  decodeOptions,\n  encodeIndividualOptions,\n  encodeOptions,\n  getOptionsForZoom,\n  withTimeout,", "  getOptionsForZoom,\n  withTimeout,\n} from \"./utils\";\n\nconst fullGlobalOptions: GlobalContourTileOptions = {\n  thresholds: {\n    10: 500,\n    11: [100, 1000],\n  },\n  contourLayer: \"contour layer\",", "  },\n  contourLayer: \"contour layer\",\n  elevationKey: \"elevation key\",\n  extent: 123,\n  buffer: 1,\n  levelKey: \"level key\",\n  multiplier: 123,\n  overzoom: 3,\n};\nconst fullGlobalOptionsOut: GlobalContourTileOptions = {", "};\nconst fullGlobalOptionsOut: GlobalContourTileOptions = {\n  ...fullGlobalOptions,\n  thresholds: {\n    10: [500],\n    11: [100, 1000],\n  },\n};\n\nbeforeEach(() => {", "\nbeforeEach(() => {\n  jest.useFakeTimers();\n});\n\nafterEach(() => {\n  jest.clearAllTimers();\n});\n\ntest(\"parse known ContourTileOptions\", () => {", "\ntest(\"parse known ContourTileOptions\", () => {\n  expect(\n    decodeOptions(\n      \"buffer=1&contourLayer=contour%20layer&elevationKey=elevation%20key&extent=123&levelKey=level%20key&multiplier=123&overzoom=3&thresholds=10*500~11*100*1000\",\n    ),\n  ).toEqual(fullGlobalOptionsOut);\n});\n\ntest(\"round-trip ContourTileOptions\", () => {", "\ntest(\"round-trip ContourTileOptions\", () => {\n  expect(\n    decodeOptions(`example.com?${encodeOptions(fullGlobalOptions)}`),\n  ).toEqual(fullGlobalOptionsOut);\n});\n\ntest(\"round-trip minimal ContourTileOptions\", () => {\n  const options: GlobalContourTileOptions = {\n    thresholds: {", "  const options: GlobalContourTileOptions = {\n    thresholds: {\n      10: [500],\n      11: [100, 1000],\n    },\n  };\n  expect(decodeOptions(encodeOptions(options))).toEqual(options);\n});\n\ntest(\"extract levels from global contour options\", () => {", "\ntest(\"extract levels from global contour options\", () => {\n  // eslint-disable-next-line\n  const { thresholds, ...rest } = fullGlobalOptions;\n  expect(getOptionsForZoom(fullGlobalOptions, 9)).toEqual({\n    ...rest,\n    levels: [],\n  });\n  expect(getOptionsForZoom(fullGlobalOptions, 10)).toEqual({\n    ...rest,", "  expect(getOptionsForZoom(fullGlobalOptions, 10)).toEqual({\n    ...rest,\n    levels: [500],\n  });\n  expect(getOptionsForZoom(fullGlobalOptions, 11)).toEqual({\n    ...rest,\n    levels: [100, 1000],\n  });\n  expect(getOptionsForZoom(fullGlobalOptions, 12)).toEqual({\n    ...rest,", "  expect(getOptionsForZoom(fullGlobalOptions, 12)).toEqual({\n    ...rest,\n    levels: [100, 1000],\n  });\n});\n\ntest(\"encode individual options\", () => {\n  const options: IndividualContourTileOptions = {\n    levels: [1, 2],\n    contourLayer: \"contour layer\",", "    levels: [1, 2],\n    contourLayer: \"contour layer\",\n    elevationKey: \"elevation key\",\n    extent: 123,\n    levelKey: \"level key\",\n    multiplier: 123,\n    overzoom: 3,\n  };\n  const origEncoded = encodeIndividualOptions(options);\n  expect(encodeIndividualOptions(options)).toBe(origEncoded);\n  for (const key in options) {\n    const updated: any = { ...options };\n    delete updated[key];\n    const newEncode = encodeIndividualOptions(updated);\n    expect(encodeIndividualOptions(updated)).toBe(newEncode);\n    expect(encodeIndividualOptions(updated)).not.toBe(origEncoded);\n  }\n});\n\ntest(\"withTimeout - times out\", async () => {\n  const cancel = jest.fn();\n  const result = withTimeout(1000, {\n    value: new Promise(() => {}),\n    cancel,\n  });\n  jest.advanceTimersByTime(999);\n  expect(cancel).not.toBeCalled();\n  jest.advanceTimersByTime(2);\n  expect(cancel).toBeCalledTimes(1);\n  await expect(result.value).rejects.toThrow(new Error(\"timed out\"));\n});\n\ntest(\"withTimeout - resolve cancels timer\", async () => {\n  const cancel = jest.fn();\n  const result = withTimeout(1000, {\n    value: Promise.resolve(true),\n    cancel,\n  });\n  await expect(result.value).resolves.toBe(true);\n  jest.advanceTimersByTime(10_000);\n  expect(cancel).not.toBeCalled();\n  await expect(result.value).resolves.toBe(true);\n});\n\ntest(\"withTimeout - reject cancels timer\", async () => {\n  const cancel = jest.fn();\n  const error = new Error(\"rejected\");\n  const result = withTimeout(1000, {\n    value: Promise.reject(error),\n    cancel,\n  });\n  await expect(result.value).rejects.toBe(error);\n  jest.advanceTimersByTime(10_000);\n  expect(cancel).not.toBeCalled();\n  await expect(result.value).rejects.toBe(error);\n});\n\ntest(\"withTimeout - cancel cancels timer\", async () => {\n  const cancel = jest.fn();\n  const result = withTimeout(1000, {\n    value: new Promise(() => {}),\n    cancel,\n  });\n  result.cancel();\n  expect(cancel).toBeCalledTimes(1);\n  jest.advanceTimersByTime(10_000);\n  expect(cancel).toBeCalledTimes(1);\n});\n", "  const origEncoded = encodeIndividualOptions(options);\n  expect(encodeIndividualOptions(options)).toBe(origEncoded);\n  for (const key in options) {\n    const updated: any = { ...options };\n    delete updated[key];\n    const newEncode = encodeIndividualOptions(updated);\n    expect(encodeIndividualOptions(updated)).toBe(newEncode);\n    expect(encodeIndividualOptions(updated)).not.toBe(origEncoded);\n  }\n});\n\ntest(\"withTimeout - times out\", async () => {\n  const cancel = jest.fn();\n  const result = withTimeout(1000, {\n    value: new Promise(() => {}),\n    cancel,\n  });\n  jest.advanceTimersByTime(999);\n  expect(cancel).not.toBeCalled();\n  jest.advanceTimersByTime(2);\n  expect(cancel).toBeCalledTimes(1);\n  await expect(result.value).rejects.toThrow(new Error(\"timed out\"));\n});\n\ntest(\"withTimeout - resolve cancels timer\", async () => {\n  const cancel = jest.fn();\n  const result = withTimeout(1000, {\n    value: Promise.resolve(true),\n    cancel,\n  });\n  await expect(result.value).resolves.toBe(true);\n  jest.advanceTimersByTime(10_000);\n  expect(cancel).not.toBeCalled();\n  await expect(result.value).resolves.toBe(true);\n});\n\ntest(\"withTimeout - reject cancels timer\", async () => {\n  const cancel = jest.fn();\n  const error = new Error(\"rejected\");\n  const result = withTimeout(1000, {\n    value: Promise.reject(error),\n    cancel,\n  });\n  await expect(result.value).rejects.toBe(error);\n  jest.advanceTimersByTime(10_000);\n  expect(cancel).not.toBeCalled();\n  await expect(result.value).rejects.toBe(error);\n});\n\ntest(\"withTimeout - cancel cancels timer\", async () => {\n  const cancel = jest.fn();\n  const result = withTimeout(1000, {\n    value: new Promise(() => {}),\n    cancel,\n  });\n  result.cancel();\n  expect(cancel).toBeCalledTimes(1);\n  jest.advanceTimersByTime(10_000);\n  expect(cancel).toBeCalledTimes(1);\n});\n"]}
{"filename": "src/cache.ts", "chunked_list": ["import { CancelablePromise } from \"./types\";\n\ninterface CacheItem<V> {\n  lastUsed: number;\n  waiting: number;\n  cancel?: () => void;\n  item: Promise<V>;\n}\n\nlet num = 0;\n\n/**\n * LRU Cache for CancelablePromises.\n * The underlying request is only canceled when all callers have canceled their usage of it.\n */", "export default class AsyncCache<K, V> {\n  maxSize: number;\n  items: Map<K, CacheItem<V>>;\n\n  constructor(maxSize: number = 100) {\n    this.maxSize = maxSize;\n    this.items = new Map<K, CacheItem<V>>();\n  }\n\n  size = () => this.items.size;\n\n  get = (key: K, supplier: (key: K) => Promise<V>): Promise<V> =>\n    this.getCancelable(key, (key) => ({\n      value: supplier(key),\n      cancel: () => {},\n    })).value;\n\n  getCancelable = (\n    key: K,\n    supplier: (key: K) => CancelablePromise<V>,\n  ): { value: Promise<V>; cancel: () => void } => {\n    let result: CacheItem<V> | undefined = this.items.get(key);", "    if (!result) {\n      const value = supplier(key);\n      result = {\n        cancel: value.cancel,\n        item: value.value,\n        lastUsed: ++num,\n        waiting: 1,\n      };\n      this.items.set(key, result);\n      this.prune();\n    } else {\n      result.lastUsed = ++num;\n      result.waiting++;\n    }\n    const items = this.items;\n    const value = result.item.then(\n      (r) => r,\n      (e) => {\n        items.delete(key);\n        return Promise.reject(e);\n      },\n    );\n    let canceled = false;\n    return {\n      value,\n      cancel: () => {", "        if (result && result.cancel && !canceled) {\n          canceled = true;\n          if (--result.waiting <= 0) {\n            result.cancel();\n            items.delete(key);\n          }\n        }\n      },\n    };\n  };\n\n  prune() {", "    if (this.items.size > this.maxSize) {\n      let minKey: K | undefined;\n      let minUse = Infinity;\n      this.items.forEach((value, key) => {\n        if (value.lastUsed < minUse) {\n          minUse = value.lastUsed;\n          minKey = key;\n        }\n      });\n      if (typeof minKey !== \"undefined\") {\n        this.items.delete(minKey);\n      }\n    }\n  }\n\n  clear = () => this.items.clear();\n}\n", "      if (typeof minKey !== \"undefined\") {\n        this.items.delete(minKey);\n      }\n    }\n  }\n\n  clear = () => this.items.clear();\n}\n"]}
{"filename": "src/cache.test.ts", "chunked_list": ["import AsyncCache from \"./cache\";\n\ntest(\"get()\", async () => {\n  const requests: { [_: string]: any } = {};\n  const cache = new AsyncCache<number, number>(2);\n  const getter = async (k: number) => {\n    requests[k] = (requests[k] || 0) + 1;\n    return k + 1;\n  };\n  expect(await cache.get(1, getter)).toBe(2);", "  };\n  expect(await cache.get(1, getter)).toBe(2);\n  expect(await cache.get(1, getter)).toBe(2);\n  expect(requests).toEqual({ 1: 1 });\n\n  expect(await cache.get(2, getter)).toBe(3);\n  expect(await cache.get(2, getter)).toBe(3);\n  expect(await cache.get(1, getter)).toBe(2);\n  expect(requests).toEqual({ 1: 1, 2: 1 });\n", "  expect(requests).toEqual({ 1: 1, 2: 1 });\n\n  // prunes 2 (not 1) because 2 was most recently accessed\n  expect(await cache.get(3, getter)).toBe(4);\n  expect(await cache.get(3, getter)).toBe(4);\n  expect(await cache.get(1, getter)).toBe(2);\n  expect(await cache.get(2, getter)).toBe(3);\n  expect(requests).toEqual({ 1: 1, 2: 2, 3: 1 });\n});\n", "});\n\ntest(\"getCancelable()\", () => {\n  let canceledFirst = false;\n  let canceledOthers = false;\n  const cache = new AsyncCache(2);\n  const result1 = cache.getCancelable(1, () => ({\n    value: new Promise(() => {}),\n    cancel: () => {\n      canceledFirst = true;", "    cancel: () => {\n      canceledFirst = true;\n    },\n  }));\n  const result2 = cache.getCancelable(1, () => ({\n    value: new Promise(() => {}),\n    cancel: () => {\n      canceledOthers = true;\n    },\n  }));", "    },\n  }));\n  const result3 = cache.getCancelable(1, () => ({\n    value: new Promise(() => {}),\n    cancel: () => {\n      canceledOthers = true;\n    },\n  }));\n  expect(canceledFirst).toBeFalsy();\n  expect(cache.size()).toBe(1);", "  expect(canceledFirst).toBeFalsy();\n  expect(cache.size()).toBe(1);\n\n  result1.cancel();\n  expect(canceledFirst).toBeFalsy();\n  expect(cache.size()).toBe(1);\n\n  result2.cancel();\n  expect(canceledFirst).toBeFalsy();\n  expect(cache.size()).toBe(1);", "  expect(canceledFirst).toBeFalsy();\n  expect(cache.size()).toBe(1);\n\n  result3.cancel();\n  expect(canceledFirst).toBeTruthy();\n  expect(canceledOthers).toBeFalsy();\n  expect(cache.size()).toBe(0);\n});\n\ntest(\"dont cache failures\", async () => {", "\ntest(\"dont cache failures\", async () => {\n  const cache = new AsyncCache(2);\n  let reject: (e: Error) => void = () => {};\n  const result = cache.getCancelable(1, () => ({\n    value: new Promise((_, rej) => {\n      reject = rej;\n    }),\n    cancel: () => {\n      throw new Error();", "    cancel: () => {\n      throw new Error();\n    },\n  }));\n  const error = new Error();\n  reject(error);\n  await expect(result.value).rejects.toThrow(error);\n  let resolve: (any: any) => void = () => {};\n  const result2 = cache.getCancelable(1, () => ({\n    value: new Promise((res) => {", "  const result2 = cache.getCancelable(1, () => ({\n    value: new Promise((res) => {\n      resolve = res;\n    }),\n    cancel: () => {\n      throw new Error();\n    },\n  }));\n  resolve(\"ok!\");\n  await expect(result2.value).resolves.toBe(\"ok!\");", "  resolve(\"ok!\");\n  await expect(result2.value).resolves.toBe(\"ok!\");\n});\n"]}
