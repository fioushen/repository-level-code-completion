{"filename": "test/scratch.ts", "chunked_list": ["import { Test } from '../dist/cjs/test-built.js'\n\nimport { TestBaseOpts } from '../dist/cjs/test-base.js'\nconst opts: TestBaseOpts = {\n  debug: /\\btap\\b/.test(process.env.NODE_DEBUG || ''),\n  name: 'TAP',\n}\n\nconst t = new Test(opts)\n", "const t = new Test(opts)\n\nt.stream.pipe(process.stdout)\nt.runMain(() => {})\n\nt.beforeEach(() => {\n  console.log('first beforeEach')\n})\nt.beforeEach(() => {\n  console.log('second beforeEach')", "t.beforeEach(() => {\n  console.log('second beforeEach')\n})\nt.afterEach(() => {\n  console.log('parent aftereach')\n})\n\nt.test('hello', {}, t => {\n  t.pass('this is fine')\n  t.beforeEach(() => {", "  t.pass('this is fine')\n  t.beforeEach(() => {\n    console.log('child beforeeach')\n  })\n  t.afterEach(() => {\n    console.log('child aftereach')\n  })\n  t.test('hello child', {}, t => {\n    t.pass('also fine')\n    t.end()", "    t.pass('also fine')\n    t.end()\n  })\n  t.end()\n})\n\nt.end()\n"]}
{"filename": "src/diags.ts", "chunked_list": ["import yaml from 'tap-yaml'\nimport { cleanYamlObject } from './clean-yaml-object.js'\nimport { TestBaseOpts } from './test-base.js'\n\nexport const diags = (\n  obj: { [k: string]: any },\n  options: TestBaseOpts = {}\n) => {\n  const clean = cleanYamlObject(obj, options)\n  if (\n    !clean ||\n    typeof clean !== 'object' ||\n    !Object.keys(clean).length\n  ) {\n    return ''\n  }\n  return (\n    '  ---\\n' +\n    yaml\n      .stringify(clean)\n      .split('\\n')\n      .map(l => (l.trim() ? '  ' + l : l.trim()))\n      .join('\\n') +\n    '  ...\\n'\n  )\n}\n", "  const clean = cleanYamlObject(obj, options)\n  if (\n    !clean ||\n    typeof clean !== 'object' ||\n    !Object.keys(clean).length\n  ) {\n    return ''\n  }\n  return (\n    '  ---\\n' +\n    yaml\n      .stringify(clean)\n      .split('\\n')\n      .map(l => (l.trim() ? '  ' + l : l.trim()))\n      .join('\\n') +\n    '  ...\\n'\n  )\n}\n"]}
{"filename": "src/base.ts", "chunked_list": ["// ok, so, export the root PluginBase, PluginHost, and the Base\n// Both have the stream stuff, and basic TAP parser stuff\n// PluginHost has all the default assertions, so a Plugin can\n// do stuff like `return t.ok()`\n// Base is a parent of PluginBase, and used for stuff like Spawn,\n// Stdin, and Worker subclasses\n//\n// tap.Test is extended from the generated source, so it has all plugins\n\n/*", "\n/*\n## Class heirarchy\n\nBase - streaming, parsing, test status, config loading\n+-- Spawn - run a child proc, consume output as tap stream\n+-- Stdin - consume stdin as tap stream\n+-- Worker - run a worker thread, consume output as tap stream\n+-- TestBase - generate tap stream, built-in set of assertions\n  +-- (builtin plugins...) - add functions for spawn, assertions, snapshot, mock, etc", "+-- TestBase - generate tap stream, built-in set of assertions\n  +-- (builtin plugins...) - add functions for spawn, assertions, snapshot, mock, etc\n    +-- (user plugins...) - whatever the config says to load\n      +-- Test - the test class exposed to user\n        +-- TAP - the root test runner\n*/\n\nimport Domain from 'async-hook-domain'\nimport { AsyncResource } from 'async_hooks'\nimport Minipass, {\n  ContiguousData,\n  Encoding,\n} from 'minipass'\nimport { hrtime } from 'node:process'\nimport { format } from 'node:util'\nimport {\n  FinalResults,\n  Parser,\n  Result,\n  TapError,\n} from 'tap-parser'\nimport Deferred from 'trivial-deferred'\nimport extraFromError from './extra-from-error'\n", "export class TapWrap extends AsyncResource {\n  test: Base\n  constructor(test: Base) {\n    super(`tap.${test.constructor.name}`)\n    this.test = test\n  }\n}\n\nexport class Counts {\n  total: number = 0\n  pass: number = 0\n  fail: number = 0\n  skip: number = 0\n  todo: number = 0\n}\n", "export class Counts {\n  total: number = 0\n  pass: number = 0\n  fail: number = 0\n  skip: number = 0\n  todo: number = 0\n}\n\nexport class Lists {\n  fail: Result[] = []\n  todo: Result[] = []\n  skip: Result[] = []\n  pass: Result[] = []\n}\n\nconst debug =\n  (name: string) =>\n  (...args: any[]) => {\n    const prefix = `TAP ${process.pid} ${name}: `\n    const msg = format(...args).trim()\n    console.error(\n      prefix + msg.split('\\n').join(`\\n${prefix}`)\n    )\n  }\n", "export class Lists {\n  fail: Result[] = []\n  todo: Result[] = []\n  skip: Result[] = []\n  pass: Result[] = []\n}\n\nconst debug =\n  (name: string) =>\n  (...args: any[]) => {\n    const prefix = `TAP ${process.pid} ${name}: `\n    const msg = format(...args).trim()\n    console.error(\n      prefix + msg.split('\\n').join(`\\n${prefix}`)\n    )\n  }\n", "export interface BaseOpts {\n  // parser-related options\n  bail?: boolean\n  strict?: boolean\n  omitVersion?: boolean\n  preserveWhitespace?: boolean\n  skip?: boolean | string\n  todo?: boolean | string\n  timeout?: number\n\n  time?: number\n  tapChildBuffer?: string\n  stack?: string\n\n  // basically only set when running in this project\n  stackIncludesTap?: boolean\n  parent?: Base\n  name?: string\n  childId?: number\n  context?: any\n  indent?: string\n  debug?: boolean\n  parser?: Parser\n  buffered?: boolean\n  silent?: boolean\n}\n", "export class Base {\n  stream: Minipass<string> = new Minipass<string>({\n    encoding: 'utf8',\n  })\n  readyToProcess: boolean = false\n  options: BaseOpts\n  indent: string\n  hook: TapWrap\n  // this actually is deterministically set in the ctor, but\n  // in the hook, so tsc doesn't see it.\n  hookDomain!: Domain\n  timer?: NodeJS.Timeout\n\n  parser: Parser\n  debug: (...args: any[]) => void\n  counts: Counts\n  lists: Lists\n  name: string\n  results?: FinalResults\n  parent?: Base\n\n  bail: boolean\n  strict: boolean\n  omitVersion: boolean\n  preserveWhitespace: boolean\n\n  errors: TapError[]\n  childId: number\n  context: any\n  output: string\n  buffered: boolean\n  bailedOut: string | boolean\n  start: bigint\n  time: number\n  hrtime: bigint\n  silent: boolean\n\n  deferred?: Deferred<FinalResults>\n\n  constructor(options: BaseOpts = {}) {\n    // all tap streams are sync string minipasses\n    this.hook = new TapWrap(this)\n    this.options = options\n    this.counts = new Counts()\n    this.lists = new Lists()\n\n    this.silent = !!options.silent\n\n    // if it's null or an object, inherit from it.  otherwise, copy it.\n    const ctx = options.context", "    if (ctx !== undefined) {\n      this.context =\n        typeof ctx === 'object' ? Object.create(ctx) : ctx\n    } else {\n      this.context = null\n    }\n\n    this.bail = !!options.bail\n    this.strict = !!options.strict\n    this.omitVersion = !!options.omitVersion\n    this.preserveWhitespace = !!options.preserveWhitespace\n    this.buffered = !!options.buffered\n    this.bailedOut = false\n    this.errors = []\n    this.parent = options.parent\n\n    this.time = 0\n    this.hrtime = 0n\n    this.start = 0n\n    this.childId = options.childId || 0\n    // do we need this?  couldn't we just call the Minipass\n    this.output = ''\n    this.indent = options.indent || ''\n    this.name = options.name || '(unnamed test)'\n    this.hook.runInAsyncScope(\n      () =>\n        (this.hookDomain = new Domain((er, type) => {", "          if (!er || typeof er !== 'object')\n            er = { error: er }\n          er.tapCaught = type\n          this.threw(er)\n        }))\n    )\n    this.debug = !!options.debug\n      ? debug(this.name)\n      : () => {}\n\n    this.parser =\n      options.parser ||\n      new Parser({\n        bail: this.bail,\n        strict: this.strict,\n        omitVersion: this.omitVersion,\n        preserveWhitespace: this.preserveWhitespace,\n        name: this.name,\n      })\n    this.setupParser()\n", "    // ensure that a skip or todo on a child class reverts\n    // back to Base's no-op main.\n    if (options.skip || options.todo) {\n      this.main = Base.prototype.main\n    }\n  }\n\n  setupParser() {\n    this.parser.on('line', l => this.online(l))\n    this.parser.once('bailout', reason =>\n      this.onbail(reason)\n    )\n    this.parser.on('complete', result =>\n      this.oncomplete(result)\n    )\n\n    this.parser.on('result', () => this.counts.total++)\n    this.parser.on('pass', () => this.counts.pass++)\n    this.parser.on('todo', res => {\n      this.counts.todo++\n      this.lists.todo.push(res)\n    })\n    this.parser.on('skip', res => {\n      // it is uselessly noisy to print out lists of tests skipped\n      // because of a --grep or --only argument.", "      if (/^filter: (only|\\/.*\\/)$/.test(res.skip)) return\n\n      this.counts.skip++\n      this.lists.skip.push(res)\n    })\n    this.parser.on('fail', res => {\n      this.counts.fail++\n      this.lists.fail.push(res)\n    })\n  }\n\n  setTimeout(n: number) {", "    if (n <= 0) {\n      if (this.timer) {\n        clearTimeout(this.timer)\n      }\n      this.timer = undefined\n    } else {\n      this.timer = setTimeout(() => this.timeout(), n)\n      this.timer.unref()\n    }\n  }\n\n  timeout(options?: { [k: string]: any }) {\n    this.setTimeout(0)\n    options = options || {}\n    options.expired = options.expired || this.name\n    const threw = this.threw(new Error('timeout!'), options)", "    if (threw) {\n      this.emit('timeout', threw)\n    }\n  }\n\n  runMain(cb: () => void) {\n    this.debug('BASE runMain')\n    this.start = hrtime.bigint()\n    this.hook.runInAsyncScope(this.main, this, cb)\n  }\n\n  main(cb: () => void) {\n    cb()\n  }\n\n  onbail(reason?: string) {\n    this.bailedOut = reason || true\n    this.emit('bailout', reason)\n  }\n\n  online(line: string) {\n    this.debug('LINE %j', line, [this.name, this.indent])\n    return this.write(this.indent + line)\n  }\n\n  write(\n    c: ContiguousData,\n    e?: Encoding | (() => any),\n    cb?: () => any\n  ) {", "    if (this.buffered) {\n      this.output += c\n      return true\n    }\n    if (typeof e === 'function') {\n      cb = e\n      e = undefined\n    }\n\n    return this.stream.write(\n      c,\n      e as Encoding | undefined,\n      cb\n    )\n  }\n\n  oncomplete(results: FinalResults) {", "    if (this.start) {\n      this.hrtime = hrtime.bigint() - this.start\n      this.time =\n        results.time || Number(this.hrtime / 1000n)\n    }\n\n    this.debug('ONCOMPLETE %j %j', this.name, results)\n\n    if (this.results) {\n      Object.assign(results, this.results)\n    }\n\n    this.results = results\n    this.emit('complete', results)\n    const errors = results.failures\n      .filter(f => f.tapError)\n      .map(f => {\n        delete f.diag\n        delete f.ok\n        return f\n      })\n", "    if (this.results) {\n      Object.assign(results, this.results)\n    }\n\n    this.results = results\n    this.emit('complete', results)\n    const errors = results.failures\n      .filter(f => f.tapError)\n      .map(f => {\n        delete f.diag\n        delete f.ok\n        return f\n      })\n", "    if (errors.length) {\n      this.errors = errors\n    }\n\n    this.onbeforeend()\n\n    // XXX old tap had a check here to ensure that buffer and pipes\n    // are cleared.  But Minipass \"should\" do this now for us, so\n    // this ought to be fine, but revisit if it causes problems.\n    this.stream.end()\n  }\n\n  // extension points for Test, Spawn, etc.\n  onbeforeend() {}\n  ondone() {}\n\n  once(ev: string, handler: (...a: any[]) => any) {\n    return this.stream.once(ev, handler)\n  }\n  on(ev: string, handler: (...a: any[]) => any) {\n    return this.stream.on(ev, handler)\n  }\n  emit(ev: string, ...data: any[]) {\n    const ret = this.stream.emit(ev, ...data)", "    if (ev === 'end') {\n      this.ondone()\n      this.hook.emitDestroy()\n      this.hookDomain.destroy()\n    }\n    return ret\n  }\n\n  end() {\n    this.stream.end()\n    return this\n  }\n\n  threw(er: any, extra?: any, proxy?: boolean) {\n    this.hook.emitDestroy()\n    this.hookDomain.destroy()", "    if (typeof er === 'string') {\n      er = { message: er }\n    } else if (!er || typeof er !== 'object') {\n      er = { error: er }\n    }\n    if (this.name && !proxy) {\n      er.test = this.name\n    }\n\n    const message = er.message\n    if (!extra) {\n      extra = extraFromError(er, extra, this.options)\n    }\n\n    // if we ended, we have to report it SOMEWHERE, unless we're\n    // already in the process of bailing out, in which case it's\n    // a bit excessive.", "    if (!extra) {\n      extra = extraFromError(er, extra, this.options)\n    }\n\n    // if we ended, we have to report it SOMEWHERE, unless we're\n    // already in the process of bailing out, in which case it's\n    // a bit excessive.\n    if (this.results) {\n      const alreadyBailing = !this.results.ok && this.bail\n      this.results.ok = false\n      if (this.parent) {\n        this.parent.threw(er, extra, true)", "      if (this.parent) {\n        this.parent.threw(er, extra, true)\n      } else if (alreadyBailing) {\n        // we are already bailing out, and this is the top level,\n        // just make our way hastily to the nearest exit.\n        return\n      } else if (!er.stack) {\n        console.error(er)\n      } else {\n        if (message) {\n          er.message = message\n        }\n        delete extra.stack\n        delete extra.at\n        console.error('%s: %s', er.name || 'Error', message)\n        console.error(\n          er.stack.split(/\\n/).slice(1).join('\\n')\n        )\n        console.error(extra)\n      }\n    } else {\n      this.parser.ok = false\n    }\n\n    return extra\n  }\n\n  passing() {\n    return this.parser.ok\n  }\n}\n", "        if (message) {\n          er.message = message\n        }\n        delete extra.stack\n        delete extra.at\n        console.error('%s: %s', er.name || 'Error', message)\n        console.error(\n          er.stack.split(/\\n/).slice(1).join('\\n')\n        )\n        console.error(extra)\n      }\n    } else {\n      this.parser.ok = false\n    }\n\n    return extra\n  }\n\n  passing() {\n    return this.parser.ok\n  }\n}\n"]}
{"filename": "src/clean-yaml-object.ts", "chunked_list": ["import { createTwoFilesPatch } from 'diff'\nimport { readFileSync } from 'node:fs'\nimport { resolve } from 'node:path'\nimport { format, strict } from 'tcompare'\nimport stack from './stack.js'\nimport type { TestBaseOpts } from './test-base.js'\n\nimport { tapDir } from './tap-dir.js'\n\nconst tryReadFile = (path: string) => {\n  try {\n    return readFileSync(path, 'utf8')", "\nconst tryReadFile = (path: string) => {\n  try {\n    return readFileSync(path, 'utf8')\n  } catch (_) {\n    return\n  }\n}\n\nconst hasOwn = (obj: { [k: string]: any }, key: string) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nexport const cleanYamlObject = (\n  object: { [k: string]: any },\n  options: TestBaseOpts\n) => {\n  const res = { ...object }", "  if (hasOwn(res, 'stack') && !hasOwn(res, 'at')) {\n    res.at = stack.parseLine(res.stack.split('\\n')[0])\n  }\n\n  const file = res.at && res.at.file && resolve(res.at.file)\n  if (\n    !options.stackIncludesTap &&\n    file &&\n    file.includes(tapDir)\n  ) {\n    // don't print locations in tap itself, that's almost never useful\n    delete res.at\n  }\n", "  if (\n    file &&\n    res.at &&\n    res.at.file &&\n    res.at.line &&\n    !res.source\n  ) {\n    const content = tryReadFile(file)\n    if (content) {\n      const lines = content.split('\\n')\n      if (res.at.line <= lines.length) {\n        const startLine = Math.max(res.at.line - 2, 0)\n        const endLine = Math.min(\n          res.at.line + 2,\n          lines.length\n        )\n        const caret =\n          res.at.column &&\n          res.at.column <= lines[res.at.line - 1].length\n            ? [new Array(res.at.column).join('-') + '^']\n            : []\n        const context = lines\n          .slice(startLine, res.at.line)\n          .concat(caret)\n          .concat(lines.slice(res.at.line, endLine))\n        const csplit = context.join('\\n').trimEnd()", "    if (content) {\n      const lines = content.split('\\n')\n      if (res.at.line <= lines.length) {\n        const startLine = Math.max(res.at.line - 2, 0)\n        const endLine = Math.min(\n          res.at.line + 2,\n          lines.length\n        )\n        const caret =\n          res.at.column &&\n          res.at.column <= lines[res.at.line - 1].length\n            ? [new Array(res.at.column).join('-') + '^']\n            : []\n        const context = lines\n          .slice(startLine, res.at.line)\n          .concat(caret)\n          .concat(lines.slice(res.at.line, endLine))\n        const csplit = context.join('\\n').trimEnd()", "        if (csplit) res.source = csplit + '\\n'\n      }\n    }\n  }\n\n  // show a line by line string diff\n  // diff the yaml, to make it more humane, especially\n  // when strings or buffers are very large or multi-line\n  // the shipped compare methods will generally supply\n  // their own diff, which is much nicer.\n  if (\n    res.found &&\n    res.wanted &&\n    res.found !== res.wanted &&\n    !res.diff\n  ) {\n    const f = res.found\n    const w = res.wanted", "  if (\n    res.found &&\n    res.wanted &&\n    res.found !== res.wanted &&\n    !res.diff\n  ) {\n    const f = res.found\n    const w = res.wanted\n    if (typeof f === 'string' && typeof w === 'string')\n      res.diff = createTwoFilesPatch(\n        'expected',\n        'actual',\n        w + '\\n',\n        f + '\\n'\n      ).replace(/^=+\\n/, '')", "    if (typeof f === 'string' && typeof w === 'string')\n      res.diff = createTwoFilesPatch(\n        'expected',\n        'actual',\n        w + '\\n',\n        f + '\\n'\n      ).replace(/^=+\\n/, '')\n    else if (\n      f &&\n      w &&\n      typeof f === 'object' &&\n      typeof w === 'object'\n    ) {\n      const s = strict(f, w)", "      if (!s.match) {\n        res.diff = s.diff\n      } else {\n        res.note = 'object identities differ'\n      }\n    } else {\n      // some mixed stringly bits\n      // XXX tcompare needs better string diffs\n      const ff = format(f)\n      const fw = format(w)\n      const fs = (typeof f === 'string' ? f : ff) + '\\n'\n      const ws = (typeof w === 'string' ? w : fw) + '\\n'\n      /* istanbul ignore else - impossible without bug in tcompare */", "      if (fw !== ff) {\n        res.diff = createTwoFilesPatch(\n          'expected',\n          'actual',\n          ws,\n          fs\n        ).replace(/^=+\\n/, '')\n      } else {\n        res.note = 'object identities differ'\n      }\n    }", "    if (res.diff === '--- expected\\n+++ actual\\n') {\n      delete res.diff\n    }\n    if (res.diff) {\n      delete res.found\n      delete res.wanted\n    }\n  }\n\n  for (const [key, value] of Object.entries(res)) {\n    if (shouldDeleteKey(key, value)) {\n      delete res[key]\n    }\n  }\n\n  return res\n}\n\nexport const deleteAlways = new Set([\n  'todo',\n  'time',\n  'childId',\n  'cb',\n  'name',\n  'indent',\n  'skip',\n  'bail',\n  'grep',\n  'grepInvert',\n  'only',\n  'diagnostic',\n  'buffered',\n  'parent',\n  'domainEmitter',\n  'domainThrew',\n  'domain',\n  'saveFixture',\n])\nexport const deleteIfEmpty = new Set([\n  'at',\n  'stack',\n  'compareOptions',\n])\nexport const deleteIfMatch = [\n  /^_?tapChild/,\n  /^tapStream/,\n  /^tapMochaTest/,\n]\nconst shouldDeleteKey = (key: string, value: any) =>\n  deleteAlways.has(key) ||\n  (deleteIfEmpty.has(key) && isEmpty(value)) ||\n  deleteIfMatch.some(r => r.test(key))\n\n// return true if object is empty, including inherited properties\nconst isEmpty = (obj: any): obj is {} => {", "  for (const [key, value] of Object.entries(res)) {\n    if (shouldDeleteKey(key, value)) {\n      delete res[key]\n    }\n  }\n\n  return res\n}\n\nexport const deleteAlways = new Set([\n  'todo',\n  'time',\n  'childId',\n  'cb',\n  'name',\n  'indent',\n  'skip',\n  'bail',\n  'grep',\n  'grepInvert',\n  'only',\n  'diagnostic',\n  'buffered',\n  'parent',\n  'domainEmitter',\n  'domainThrew',\n  'domain',\n  'saveFixture',\n])\nexport const deleteIfEmpty = new Set([\n  'at',\n  'stack',\n  'compareOptions',\n])\nexport const deleteIfMatch = [\n  /^_?tapChild/,\n  /^tapStream/,\n  /^tapMochaTest/,\n]\nconst shouldDeleteKey = (key: string, value: any) =>\n  deleteAlways.has(key) ||\n  (deleteIfEmpty.has(key) && isEmpty(value)) ||\n  deleteIfMatch.some(r => r.test(key))\n\n// return true if object is empty, including inherited properties\nconst isEmpty = (obj: any): obj is {} => {", "  if (!obj) {\n    return true\n  }\n  if (typeof obj !== 'object') {\n    return false\n  }\n  for (const _ in obj) {\n    return false\n  }\n  return true\n}\n"]}
{"filename": "src/test-built.ts", "chunked_list": ["// This file is automatically generated, please do not edit\n\nimport { FinalResults } from 'tap-parser'\nimport parseTestArgs, {\n  TestArgs,\n} from './parse-test-args.js'\nimport { TestBase, TestBaseOpts } from './test-base.js'\n\nconst copyToString = (v: Function) => ({\n  toString: Object.assign(() => v.toString(), {\n    toString: () => 'function toString() { [native code] }',\n  }),\n})\n\nimport plugin0 from \"./plugin/after-each.js\"\nimport plugin1 from \"./plugin/before-each.js\"\nimport plugin2 from \"./plugin/spawn.js\"\nimport plugin3 from \"./plugin/stdin.js\"\n", "const copyToString = (v: Function) => ({\n  toString: Object.assign(() => v.toString(), {\n    toString: () => 'function toString() { [native code] }',\n  }),\n})\n\nimport plugin0 from \"./plugin/after-each.js\"\nimport plugin1 from \"./plugin/before-each.js\"\nimport plugin2 from \"./plugin/spawn.js\"\nimport plugin3 from \"./plugin/stdin.js\"\n", "type PI<O extends TestBaseOpts | any = any> =\n  | ((t: Test, opts: O) => Plug)\n  | ((t: Test) => Plug)\n\nconst plugins: PI[] = [\n  plugin0,\n  plugin1,\n  plugin2,\n  plugin3,\n]\ntype Plug =\n  | TestBase\n  | { t: Test }\n  | ReturnType<typeof plugin0>\n  | ReturnType<typeof plugin1>\n  | ReturnType<typeof plugin2>\n  | ReturnType<typeof plugin3>\n", "type Plug =\n  | TestBase\n  | { t: Test }\n  | ReturnType<typeof plugin0>\n  | ReturnType<typeof plugin1>\n  | ReturnType<typeof plugin2>\n  | ReturnType<typeof plugin3>\n\ntype PlugKeys =\n  | keyof TestBase\n  | 't'\n  | keyof ReturnType<typeof plugin0>\n  | keyof ReturnType<typeof plugin1>\n  | keyof ReturnType<typeof plugin2>\n  | keyof ReturnType<typeof plugin3>\n", "type PlugKeys =\n  | keyof TestBase\n  | 't'\n  | keyof ReturnType<typeof plugin0>\n  | keyof ReturnType<typeof plugin1>\n  | keyof ReturnType<typeof plugin2>\n  | keyof ReturnType<typeof plugin3>\n\ntype SecondParam<\n  T extends [any] | [any, any],\n  Fallback extends unknown = unknown\n> = T extends [any, any] ? T[1] : Fallback\n", "type SecondParam<\n  T extends [any] | [any, any],\n  Fallback extends unknown = unknown\n> = T extends [any, any] ? T[1] : Fallback\n\ntype Plugin0Opts = SecondParam<\n  Parameters<typeof plugin0>,\n  TestBaseOpts\n>\ntype Plugin1Opts = SecondParam<\n  Parameters<typeof plugin1>,\n  TestBaseOpts\n>", "type Plugin1Opts = SecondParam<\n  Parameters<typeof plugin1>,\n  TestBaseOpts\n>\ntype Plugin2Opts = SecondParam<\n  Parameters<typeof plugin2>,\n  TestBaseOpts\n>\ntype Plugin3Opts = SecondParam<\n  Parameters<typeof plugin3>,\n  TestBaseOpts\n>\n", "type Plugin3Opts = SecondParam<\n  Parameters<typeof plugin3>,\n  TestBaseOpts\n>\n\ntype TestOpts = TestBaseOpts\n  & Plugin0Opts\n  & Plugin1Opts\n  & Plugin2Opts\n  & Plugin3Opts\n", "type TTest = TestBase\n  & ReturnType<typeof plugin0>\n  & ReturnType<typeof plugin1>\n  & ReturnType<typeof plugin2>\n  & ReturnType<typeof plugin3>\n\n\nexport interface Test extends TTest {\n  end(): this\n  t: Test\n  test(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n  test(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null>\n\n  todo(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n  todo(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null>\n\n  skip(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n  skip(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null>\n}\n\nconst applyPlugins = (base: Test): Test => {\n  const ext: Plug[] = [\n    ...plugins.map(p => p(base, base.options)),\n    base,\n  ]\n  const getCache = new Map<any, any>()\n  const t = new Proxy(base, {\n    has(_, p) {", "      for (const t of ext) {\n        if (Reflect.has(t, p)) return true\n      }\n      return false\n    },\n    ownKeys() {\n      const k: PlugKeys[] = []\n      for (const t of ext) {\n        const keys = Reflect.ownKeys(t) as PlugKeys[]\n        k.push(...keys)\n      }\n      return [...new Set(k)]\n    },\n    getOwnPropertyDescriptor(_, p) {", "      for (const t of ext) {\n        const prop = Reflect.getOwnPropertyDescriptor(t, p)\n        if (prop) return prop\n      }\n      return undefined\n    },\n    set(_, p, v) {\n      // check to see if there's any setters, and if so, set it there\n      // otherwise, just set on the base\n      for (const t of ext) {\n        let o: Object | null = t", "      for (const t of ext) {\n        let o: Object | null = t\n        while (o) {\n          if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {\n            //@ts-ignore\n            t[p] = v\n            return true\n          }\n          o = Reflect.getPrototypeOf(o)\n        }\n      }\n      //@ts-ignore\n      base[p as keyof TestBase] = v\n      return true\n    },\n    get(_, p) {\n      // cache get results so t.blah === t.blah\n      // we only cache functions, so that getters aren't memoized", "      // Of course, a getter that returns a function will be broken,\n      // at least when accessed from outside the plugin, but that's\n      // a pretty narrow caveat, and easily documented.\n      if (getCache.has(p)) return getCache.get(p)\n      for (const plug of ext) {\n        if (p in plug) {\n          //@ts-ignore\n          const v = plug[p]\n          // Functions need special handling so that they report\n          // the correct toString and are called on the correct object\n          // Otherwise attempting to access #private props will fail.", "          if (typeof v === 'function') {\n            const f: (this: Plug, ...args: any) => any =\n              function (...args: any[]) {\n                const thisArg = this === t ? plug : this\n                return v.apply(thisArg, args)\n              }\n            const vv = Object.assign(f, copyToString(v))\n            const nameProp =\n              Reflect.getOwnPropertyDescriptor(v, 'name')\n            if (nameProp) {\n              Reflect.defineProperty(f, 'name', nameProp)\n            }\n            getCache.set(p, vv)\n            return vv\n          } else {\n            getCache.set(p, v)\n            return v\n          }\n        }\n      }\n    },\n  })\n  Object.assign(base, { t })\n  ext.unshift({ t })\n  return t\n}\n", "            if (nameProp) {\n              Reflect.defineProperty(f, 'name', nameProp)\n            }\n            getCache.set(p, vv)\n            return vv\n          } else {\n            getCache.set(p, v)\n            return v\n          }\n        }\n      }\n    },\n  })\n  Object.assign(base, { t })\n  ext.unshift({ t })\n  return t\n}\n", "export class Test extends TestBase {\n  constructor(opts: TestOpts) {\n    super(opts)\n    return applyPlugins(this)\n  }\n\n  test(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n  test(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null> {\n    const extra = parseTestArgs(...args)\n    extra.todo = true\n    return this.sub(Test, extra, this.test)\n  }\n\n  todo(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n  todo(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null> {\n    const extra = parseTestArgs(...args)\n    extra.todo = true\n    return this.sub(Test, extra, this.todo)\n  }\n\n  skip(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n  skip(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null> {\n    const extra = parseTestArgs(...args)\n    extra.skip = true\n    return this.sub(Test, extra, this.skip)\n  }\n}\n"]}
{"filename": "src/test.ts", "chunked_list": ["// the Test class is built up from PluginBase + all the plugins\nimport { TestBase } from './test-base.js'\n\nexport class Test extends TestBase {}\n"]}
{"filename": "src/stack.ts", "chunked_list": ["import StackUtils from 'stack-utils'\n\nexport default new StackUtils({\n  internals: StackUtils.nodeInternals(),\n  ignoredPackages: []\n})\n"]}
{"filename": "src/test-template.ts", "chunked_list": ["//{{HEADER COMMENT START}}\n// This is the template file used to generate the Test client\n// module.  Prior to being built, it's effectively just a copy\n// of the TestBase class, without any plugins applied.\n//{{HEADER COMMENT END}}\n\nimport { FinalResults } from 'tap-parser'\nimport parseTestArgs, {\n  TestArgs,\n} from './parse-test-args.js'", "  TestArgs,\n} from './parse-test-args.js'\nimport { TestBase, TestBaseOpts } from './test-base.js'\n\nconst copyToString = (v: Function) => ({\n  toString: Object.assign(() => v.toString(), {\n    toString: () => 'function toString() { [native code] }',\n  }),\n})\n\n//{{PLUGIN IMPORT START}}\n//{{PLUGIN IMPORT END}}\n", "type PI<O extends TestBaseOpts | any = any> =\n  | ((t: Test, opts: O) => Plug)\n  | ((t: Test) => Plug)\n\n//{{PLUGINS CODE START}}\ntype Plug = TestBase | { t: Test }\nconst plugins: PI[] = []\ntype PlugKeys = keyof TestBase | 't'\n//{{PLUGINS CODE END}}\n\n//{{OPTS START}}", "type TestOpts = TestBaseOpts\n//{{OPTS END}}\n\n//{{TEST INTERFACE START}}\ntype TTest = TestBase\n//{{TEST INTERFACE END}}\n\nexport interface Test extends TTest {\n  end(): this\n  t: Test\n  test(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n  test(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null>\n\n  todo(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n  todo(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null>\n\n  skip(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n  skip(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null>\n}\n\nconst applyPlugins = (base: Test): Test => {\n  const ext: Plug[] = [\n    ...plugins.map(p => p(base, base.options)),\n    base,\n  ]\n  const getCache = new Map<any, any>()\n  const t = new Proxy(base, {\n    has(_, p) {", "      for (const t of ext) {\n        if (Reflect.has(t, p)) return true\n      }\n      return false\n    },\n    ownKeys() {\n      const k: PlugKeys[] = []\n      for (const t of ext) {\n        const keys = Reflect.ownKeys(t) as PlugKeys[]\n        k.push(...keys)\n      }\n      return [...new Set(k)]\n    },\n    getOwnPropertyDescriptor(_, p) {", "      for (const t of ext) {\n        const prop = Reflect.getOwnPropertyDescriptor(t, p)\n        if (prop) return prop\n      }\n      return undefined\n    },\n    set(_, p, v) {\n      // check to see if there's any setters, and if so, set it there\n      // otherwise, just set on the base\n      for (const t of ext) {\n        let o: Object | null = t", "      for (const t of ext) {\n        let o: Object | null = t\n        while (o) {\n          if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {\n            //@ts-ignore\n            t[p] = v\n            return true\n          }\n          o = Reflect.getPrototypeOf(o)\n        }\n      }\n      //@ts-ignore\n      base[p as keyof TestBase] = v\n      return true\n    },\n    get(_, p) {\n      // cache get results so t.blah === t.blah\n      // we only cache functions, so that getters aren't memoized", "      // Of course, a getter that returns a function will be broken,\n      // at least when accessed from outside the plugin, but that's\n      // a pretty narrow caveat, and easily documented.\n      if (getCache.has(p)) return getCache.get(p)\n      for (const plug of ext) {\n        if (p in plug) {\n          //@ts-ignore\n          const v = plug[p]\n          // Functions need special handling so that they report\n          // the correct toString and are called on the correct object\n          // Otherwise attempting to access #private props will fail.", "          if (typeof v === 'function') {\n            const f: (this: Plug, ...args: any) => any =\n              function (...args: any[]) {\n                const thisArg = this === t ? plug : this\n                return v.apply(thisArg, args)\n              }\n            const vv = Object.assign(f, copyToString(v))\n            const nameProp =\n              Reflect.getOwnPropertyDescriptor(v, 'name')\n            if (nameProp) {\n              Reflect.defineProperty(f, 'name', nameProp)\n            }\n            getCache.set(p, vv)\n            return vv\n          } else {\n            getCache.set(p, v)\n            return v\n          }\n        }\n      }\n    },\n  })\n  Object.assign(base, { t })\n  ext.unshift({ t })\n  return t\n}\n", "            if (nameProp) {\n              Reflect.defineProperty(f, 'name', nameProp)\n            }\n            getCache.set(p, vv)\n            return vv\n          } else {\n            getCache.set(p, v)\n            return v\n          }\n        }\n      }\n    },\n  })\n  Object.assign(base, { t })\n  ext.unshift({ t })\n  return t\n}\n", "export class Test extends TestBase {\n  constructor(opts: TestOpts) {\n    super(opts)\n    return applyPlugins(this)\n  }\n\n  test(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n  test(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null> {\n    const extra = parseTestArgs(...args)\n    extra.todo = true\n    return this.sub(Test, extra, this.test)\n  }\n\n  todo(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n  todo(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null> {\n    const extra = parseTestArgs(...args)\n    extra.todo = true\n    return this.sub(Test, extra, this.todo)\n  }\n\n  skip(\n    name: string,\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    name: string,\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(\n    extra: { [k: string]: any },\n    cb?: (t: Test) => any\n  ): Promise<FinalResults | null>\n  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n  skip(\n    ...args: TestArgs<Test>\n  ): Promise<FinalResults | null> {\n    const extra = parseTestArgs(...args)\n    extra.skip = true\n    return this.sub(Test, extra, this.skip)\n  }\n}\n"]}
{"filename": "src/parse-test-args.ts", "chunked_list": ["import type { Base } from './base.js'\n\nexport type TestArgs<T extends Base> =\n  | [\n      name?: string | number,\n      extra?: { [k: string]: any },\n      cb?: false | ((t: T) => any),\n      defaultName?: string\n    ]\n  | [\n      extra: { [k: string]: any },\n      cb?: ((t: T) => any) | false\n    ]\n  | [name: string | number, cb?: ((t: T) => any) | false]\n  | [cb?: ((t: T) => any) | false]\n  | [name: string]\n  | [extra: { [k: string]: any }]\n", "export default function parseTestArgs<T extends Base>(\n  ...args: TestArgs<T>\n) {\n  let name: string | null | undefined = undefined\n  let extra: { [k: string]: any } | null | undefined =\n    undefined\n  let cb: ((t: T) => any) | null | undefined = undefined\n\n  // this only works if it's literally the 4th argument.\n  // used internally.\n  const defaultName = args[3] || ''\n", "  for (let i = 0; i < 3 && i < args.length; i++) {\n    const arg = args[i]\n    if (\n      name === undefined &&\n      (typeof arg === 'string' || typeof arg === 'number')\n    )\n      name = '' + arg\n    else if (arg && typeof arg === 'object') {\n      extra = arg\n      if (name === undefined) name = null\n    } else if (typeof arg === 'function') {", "      if (name === undefined) name = null\n    } else if (typeof arg === 'function') {\n      if (extra === undefined) extra = {}\n      if (name === undefined) name = null\n      cb = arg\n    } else if (arg === false) {\n      // it's handy while developing to put a ! in front of a\n      // function to temporarily make a test todo\n      continue\n    } else if (typeof arg !== 'undefined')\n      throw new TypeError(\n        'unknown argument passed to parseTestArgs: ' +\n          typeof arg\n      )\n  }\n", "    } else if (typeof arg !== 'undefined')\n      throw new TypeError(\n        'unknown argument passed to parseTestArgs: ' +\n          typeof arg\n      )\n  }\n\n  if (!extra) extra = {}\n\n  if (!cb && defaultName !== '/dev/stdin')\n    extra.todo = extra.todo || true\n", "  if (!cb && defaultName !== '/dev/stdin')\n    extra.todo = extra.todo || true\n\n  if (!name && extra.name) name = extra.name\n\n  if (!name && cb && cb.name) name = cb.name\n\n  name = name || defaultName\n  extra.name = name\n  extra.cb = cb || todoCb\n  return extra\n}\n\nconst todoCb = () => {\n  throw new Error('callback called for TODO test')\n}\n"]}
{"filename": "src/esc.ts", "chunked_list": ["// turn \\ into \\\\ and # into \\#, for stringifying back to TAP\nexport const esc = (str: string) =>\n  str.replace(/\\\\/g, '\\\\\\\\').replace(/#/g, '\\\\#')\n"]}
{"filename": "src/worker.ts", "chunked_list": ["// the .worker() method is only added to the root test object\n// See https://github.com/tapjs/node-tap/issues/812\nexport class Worker {}\n"]}
{"filename": "src/build.ts", "chunked_list": ["#!/usr/bin/env node --loader=ts-node/esm --no-warnings\n\nimport {\n  readdirSync,\n  readFileSync,\n  writeFileSync,\n} from 'node:fs'\nimport { dirname, relative, resolve } from 'node:path'\nif (typeof process.argv[4] !== 'string') {\n  console.error(\n    'usage: build.ts <test template> <plugins dir>'\n  )\n  process.exit(1)\n}\n\nlet template = readFileSync(\n  resolve(process.argv[2]),\n  'utf8'\n)\nconst out = resolve(process.argv[4])\nconst pluginsDir = resolve(process.argv[3])\nconst plugins = readdirSync(pluginsDir).map(\n  p =>\n    './' +\n    relative(\n      dirname(out),\n      resolve(pluginsDir, p).replace(/\\.ts/, '.js')\n    )\n)\n\nconst pluginImport = plugins\n  .map(\n    (p, i) =>\n      `import plugin${i} from ${JSON.stringify(p)}\\n`\n  )\n  .join('')\n\nconst pluginsCode = `const plugins: PI[] = [\n${plugins.map((_, i) => `  plugin${i},\\n`).join('')}]", "if (typeof process.argv[4] !== 'string') {\n  console.error(\n    'usage: build.ts <test template> <plugins dir>'\n  )\n  process.exit(1)\n}\n\nlet template = readFileSync(\n  resolve(process.argv[2]),\n  'utf8'\n)\nconst out = resolve(process.argv[4])\nconst pluginsDir = resolve(process.argv[3])\nconst plugins = readdirSync(pluginsDir).map(\n  p =>\n    './' +\n    relative(\n      dirname(out),\n      resolve(pluginsDir, p).replace(/\\.ts/, '.js')\n    )\n)\n\nconst pluginImport = plugins\n  .map(\n    (p, i) =>\n      `import plugin${i} from ${JSON.stringify(p)}\\n`\n  )\n  .join('')\n\nconst pluginsCode = `const plugins: PI[] = [\n${plugins.map((_, i) => `  plugin${i},\\n`).join('')}]", "type Plug =\n  | TestBase\n  | { t: Test }\n${plugins\n  .map((_, i) => `  | ReturnType<typeof plugin${i}>\\n`)\n  .join('')}\ntype PlugKeys =\n  | keyof TestBase\n  | 't'\n${plugins\n  .map(\n    (_, i) => `  | keyof ReturnType<typeof plugin${i}>\\n`\n  )\n  .join('')}`\n", "const opts = `type SecondParam<\n  T extends [any] | [any, any],\n  Fallback extends unknown = unknown\n> = T extends [any, any] ? T[1] : Fallback\n\n${plugins\n  .map(\n    (_, i) => `type Plugin${i}Opts = SecondParam<\n  Parameters<typeof plugin${i}>,\n  TestBaseOpts\n>\\n`\n  )\n  .join('')}", "type TestOpts = TestBaseOpts${plugins\n  .map((_, i) => `\\n  & Plugin${i}Opts`)\n  .join('')}\n`\n\nconst testInterface = `type TTest = TestBase\n${plugins\n  .map((_, i) => `  & ReturnType<typeof plugin${i}>\\n`)\n  .join('')}\n`\n\nconst swapTag = (\n  src: string,\n  tag: string,\n  code: string\n): string => {\n  const st = '//{{' + tag + ' START}}\\n'\n  const et = '//{{' + tag + ' END}}\\n'\n  const start = src.indexOf(st)\n  const end = src.indexOf(et)\n  return (\n    src.substring(0, start) + code + src.substring(end + et.length)\n  )\n}\n\nconst swapTags = (\n  src: string,\n  tags: { [k: string]: string }\n): string => {\n  let res = src", "  for (const [tag, code] of Object.entries(tags)) {\n    res = swapTag(res, tag, code)\n  }\n  return res\n}\n\nwriteFileSync(\n  out,\n  swapTags(template, {\n    'HEADER COMMENT': `// This file is automatically generated, please do not edit\\n`,\n    'PLUGIN IMPORT': pluginImport,\n    'PLUGINS CODE': pluginsCode,\n    OPTS: opts,\n    'TEST INTERFACE': testInterface,\n  })\n)\n\nexport {}\n"]}
{"filename": "src/spawn.ts", "chunked_list": ["import { Base, BaseOpts } from './base'\n\nimport ProcessInfo from '@tapjs/processinfo'\nimport {\n  ChildProcess,\n  StdioOptions,\n} from 'node:child_process'\nimport { basename } from 'node:path'\n\nexport interface SpawnOpts extends BaseOpts {\n  cwd?: string\n  command?: string\n  args?: string[]\n  stdio?: StdioOptions\n  env?: { [k: string]: string } | typeof process.env\n  exitCode?: number | null\n  signal?: string | null\n}\n", "\nexport interface SpawnOpts extends BaseOpts {\n  cwd?: string\n  command?: string\n  args?: string[]\n  stdio?: StdioOptions\n  env?: { [k: string]: string } | typeof process.env\n  exitCode?: number | null\n  signal?: string | null\n}\n", "export class Spawn extends Base {\n  public declare options: SpawnOpts\n  public cwd: string\n  public command: string\n  public args: string[]\n  public stdio: StdioOptions\n  public env: { [k: string]: string } | typeof process.env\n  public proc: null | ChildProcess\n  public cb: null | (() => void)\n\n  constructor(options: SpawnOpts) {\n    // figure out the name before calling super()\n    const command = options.command", "    if (!command) {\n      throw new TypeError('no command provided')\n    }\n    options = options || {}\n    const cwd =\n      typeof options.cwd === 'string'\n        ? options.cwd\n        : process.cwd()\n    const args = options.args || []\n\n    options.name =\n      options.name || Spawn.procName(cwd, command, args)\n    super(options)\n\n    this.cwd = cwd\n    this.command = command\n    this.args = args", "    if (options.stdio) {\n      if (typeof options.stdio === 'string')\n        this.stdio = [options.stdio, 'pipe', options.stdio]\n      else {\n        this.stdio = options.stdio.slice(0) as StdioOptions\n      }\n    } else {\n      this.stdio = [0, 'pipe', 2]\n    }\n\n    // stdout MUST be a pipe so we can collect tap data\n    ;(this.stdio as string[])[1] = 'pipe'\n    const env = options.env || process.env\n    this.env = {\n      ...env,\n      TAP_CHILD_ID: String(\n        options.childId ||\n          env.TAP_CHILD_ID ||\n          /* istanbul ignore next */ '0'\n      ),\n      TAP: '1',\n      TAP_BAIL: this.bail ? '1' : '0',\n    }\n\n    this.proc = null\n    this.cb = null\n  }\n\n  endAll() {", "    if (this.proc) {\n      this.proc.kill('SIGKILL')\n    }\n    this.parser.abort('test unfinished')\n    this.callCb()\n  }\n\n  callCb() {\n    if (this.cb) {\n      this.cb()\n    }\n    this.cb = null\n  }\n\n  main(cb: () => void) {\n    this.cb = cb\n    this.setTimeout(this.options.timeout || 0)\n\n    this.parser.on('comment', c => {\n      const tomatch = c.match(/# timeout=([0-9]+)\\n$/)", "    if (this.cb) {\n      this.cb()\n    }\n    this.cb = null\n  }\n\n  main(cb: () => void) {\n    this.cb = cb\n    this.setTimeout(this.options.timeout || 0)\n\n    this.parser.on('comment', c => {\n      const tomatch = c.match(/# timeout=([0-9]+)\\n$/)", "      if (tomatch) {\n        this.setTimeout(+tomatch[1])\n      }\n    })\n\n    const options = {\n      cwd: this.cwd,\n      env: this.env,\n      stdio: this.stdio,\n      externalID: this.name,\n    }\n\n    queueMicrotask(async () => {\n      this.emit('preprocess', options)\n      const proc = ProcessInfo.spawn(\n        this.command,\n        this.args,\n        options\n      )\n      /* istanbul ignore next */", "      if (!proc.stdout) {\n        return this.threw(\n          'failed to open child process stdout',\n          this.options\n        )\n      }\n      proc.stdout.pipe(this.parser)\n      proc.on('close', (code, signal) =>\n        this.#onprocclose(code, signal)\n      )\n      proc.on('error', er => this.threw(er))\n      this.emit('process', proc)", "      if (this.parent) {\n        this.parent.emit('spawn', this)\n      }\n    })\n  }\n\n  #onprocclose(code: number | null, signal: string | null) {\n    this.debug('SPAWN close %j %s', code, signal)\n    this.options.exitCode = code\n    this.options.signal = signal\n\n    // spawn closing with no tests is treated as a skip.", "    if (\n      this.results &&\n      this.results.plan &&\n      this.results.plan.skipAll &&\n      !code &&\n      !signal\n    ) {\n      this.options.skip =\n        this.results.plan.skipReason || true\n    }\n", "    if (code || signal) {\n      if (this.results) {\n        this.results.ok = false\n      }\n      this.parser.ok = false\n    }\n    return this.callCb()\n  }\n\n  timeout(options?: { [k: string]: any }) {\n    if (this.proc) {\n      this.proc.kill('SIGTERM')\n      const t = setTimeout(() => {", "    if (this.proc) {\n      this.proc.kill('SIGTERM')\n      const t = setTimeout(() => {\n        if (\n          this.proc &&\n          !this.options.signal &&\n          this.options.exitCode === undefined\n        ) {\n          super.timeout(options)\n          this.proc.kill('SIGKILL')\n        }\n      }, 1000)\n      t.unref()\n    }\n  }\n\n  static procName(\n    cwd: string,\n    command: string,\n    args: string[]\n  ) {\n    return (\n      command === process.execPath\n        ? basename(process.execPath) +\n          ' ' +\n          args\n            .map(a =>\n              a.indexOf(cwd) === 0\n                ? './' +\n                  a\n                    .substring(cwd.length + 1)\n                    .replace(/\\\\/g, '/')\n                : a\n            )\n            .join(' ')\n            .trim()\n        : command + ' ' + args.join(' ')\n    ).replace(/\\\\/g, '/')\n  }\n}\n"]}
{"filename": "src/test-base.ts", "chunked_list": ["// lifecycle methods like beforeEach, afterEach, teardown\n// defined in plugins/lifecycle.ts\n\nimport Minipass from 'minipass'\nimport assert from 'node:assert'\nimport { hrtime } from 'node:process'\nimport { Readable } from 'node:stream'\nimport { format } from 'node:util'\nimport { CallSiteLike } from 'stack-utils'\nimport { FinalResults } from 'tap-parser'", "import { CallSiteLike } from 'stack-utils'\nimport { FinalResults } from 'tap-parser'\nimport Deferred from 'trivial-deferred'\nimport { Base, BaseOpts } from './base.js'\nimport { esc } from './esc.js'\nimport stack from './stack.js'\nimport { TestPoint } from './test-point.js'\nimport { Waiter } from './waiter.js'\n\nconst queueEmpty = <T extends TestBase>(t: T) =>", "\nconst queueEmpty = <T extends TestBase>(t: T) =>\n  t.queue.length === 0 ||\n  (t.queue.length === 1 &&\n    t.queue[0] === 'TAP version 14\\n')\n\nexport interface ClassOf<T> {\n  new (): T\n}\n\nexport type TapPlugin<\n  B extends Object,\n  O extends TestBaseOpts | any = any\n> = ((t: TestBase, opts: O) => B) | ((t: TestBase) => B)\n", "export type TapPlugin<\n  B extends Object,\n  O extends TestBaseOpts | any = any\n> = ((t: TestBase, opts: O) => B) | ((t: TestBase) => B)\n\nexport interface TestBaseOpts extends BaseOpts {\n  /**\n   * The number of jobs to run in parallel. Defaults to 1\n   */\n  jobs?: number\n  /**", "   * Test function called when this Test is executed\n   */\n  cb?: (...args: any[]) => any\n\n  /**\n   * Flag to always/never show diagnostics.  If unset, then\n   * diagnostics are shown for failing test points only.\n   */\n  diagnostic?: boolean\n}\n\nconst normalizeMessageExtra = (\n  defaultMessage: string,\n  message?: string | { [k: string]: any },\n  extra?: { [k: string]: any }\n): [string, { [k: string]: any }] => {", "  if (typeof message === 'string') {\n    return [message || defaultMessage, extra || {}]\n  } else {\n    return [defaultMessage, message || {}]\n  }\n}\n\n/**\n * Sigil for implicit end() calls that should not\n * trigger an error if the user then calls t.end()\n */\nconst IMPLICIT = Symbol('implicit end')\n\n/**\n * Sigil to put in the queue to signal the end of all things\n */\nconst EOF = Symbol('EOF')\n", "export type QueueEntry =\n  | string\n  | TestPoint\n  | Base\n  | typeof EOF\n  | Waiter\n  | [method: string, ...args: any[]]\n\n/**\n * The TestBaseBase class is the base class for all plugins,\n * and eventually thus the Test class.\n *\n * This implements subtest functionality, TAP stream generation,\n * lifecycle events, and only the most basic pass/fail assertions.\n *\n * All other features are added with plugins.\n */\n", " * The TestBaseBase class is the base class for all plugins,\n * and eventually thus the Test class.\n *\n * This implements subtest functionality, TAP stream generation,\n * lifecycle events, and only the most basic pass/fail assertions.\n *\n * All other features are added with plugins.\n */\n\nexport class TestBase extends Base {\n  // NB: generated pluginified Test class needs to declare over this\n  declare parent?: TestBase\n  promise?: Promise<any>\n  jobs: number\n  // #beforeEnd: [method: string | Symbol, ...args: any[]][] = []\n  subtests: Base[] = []\n  pool: Set<Base> = new Set()\n  queue: QueueEntry[] = ['TAP version 14\\n']\n  cb?: (...args: any[]) => any\n  count: number = 0\n  ended: boolean = false\n  assertAt: CallSiteLike | null = null\n  assertStack: string | null = null\n  diagnostic: null | boolean = null\n\n  #planEnd: number = -1\n  #printedResult: boolean = false\n  #explicitEnded: boolean = false\n  #multiEndThrew: boolean = false\n  #n: number = 0\n  #noparallel: boolean = false\n  #occupied: null | Waiter | Base = null\n  #pushedEnd: boolean = false\n  #nextChildId: number = 1\n  #currentAssert: null | ((..._: any) => any) = null\n  #processing: boolean = false\n  #doingStdinOnly: boolean = false\n\n  /**\n   * true if the test has printed at least one TestPoint\n   */\n  get printedResult(): boolean {\n    return this.#printedResult\n  }\n\n  constructor(options: TestBaseOpts) {\n    super(options)\n\n    this.jobs =\n      (options.jobs && Math.max(options.jobs, 1)) || 1\n", "export class TestBase extends Base {\n  // NB: generated pluginified Test class needs to declare over this\n  declare parent?: TestBase\n  promise?: Promise<any>\n  jobs: number\n  // #beforeEnd: [method: string | Symbol, ...args: any[]][] = []\n  subtests: Base[] = []\n  pool: Set<Base> = new Set()\n  queue: QueueEntry[] = ['TAP version 14\\n']\n  cb?: (...args: any[]) => any\n  count: number = 0\n  ended: boolean = false\n  assertAt: CallSiteLike | null = null\n  assertStack: string | null = null\n  diagnostic: null | boolean = null\n\n  #planEnd: number = -1\n  #printedResult: boolean = false\n  #explicitEnded: boolean = false\n  #multiEndThrew: boolean = false\n  #n: number = 0\n  #noparallel: boolean = false\n  #occupied: null | Waiter | Base = null\n  #pushedEnd: boolean = false\n  #nextChildId: number = 1\n  #currentAssert: null | ((..._: any) => any) = null\n  #processing: boolean = false\n  #doingStdinOnly: boolean = false\n\n  /**\n   * true if the test has printed at least one TestPoint\n   */\n  get printedResult(): boolean {\n    return this.#printedResult\n  }\n\n  constructor(options: TestBaseOpts) {\n    super(options)\n\n    this.jobs =\n      (options.jobs && Math.max(options.jobs, 1)) || 1\n", "    if (typeof options.diagnostic === 'boolean') {\n      this.diagnostic = options.diagnostic\n    }\n\n    if (options.cb) {\n      this.#setCB(options.cb)\n    }\n  }\n\n  #setCB<T extends TestBase>(this: T, cb: (t: T) => any) {\n    this.cb = (...args: any[]) =>\n      this.hook.runInAsyncScope(cb, this, ...args)\n  }\n\n  // TAP output generating methods\n  /**\n   * immediately exit this and all parent tests with a TAP\n   * Bail out! message.\n   */\n  bailout(message?: string) {", "    if (this.parent && (this.results || this.ended)) {\n      this.parent.bailout(message)\n    } else {\n      this.#process()\n      message = message\n        ? ' ' + ('' + esc(message)).trim()\n        : ''\n      message = message.replace(/[\\r\\n]/g, ' ')\n      this.parser.write('Bail out!' + message + '\\n')\n    }\n    this.#end(IMPLICIT)\n    this.#process()\n  }\n\n  /**\n   * output a TAP comment, formatted like console.log()\n   */\n  comment(...args: any[]) {\n    const body = format(...args)\n    const message =\n      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() +\n      '\\n'\n", "    if (this.results) {\n      this.write(message)\n    } else {\n      this.queue.push(message)\n    }\n    this.#process()\n  }\n\n  /**\n   * Called when the test times out.\n   * Options are passed as diagnostics to the threw() method\n   */\n  timeout(options: { [k: string]: any }) {\n    options = options || {}\n    options.expired = options.expired || this.name", "    if (this.#occupied && this.#occupied instanceof Base) {\n      this.#occupied.timeout(options)\n    } else {\n      super.timeout(options)\n    }\n    this.#end(IMPLICIT)\n  }\n\n  /**\n   * Set TAP pragma configs to affect the behavior of the parser.\n   * Only `strict` is supported by the parser.\n   */\n  pragma(set: { [k: string]: boolean }) {\n    const p = Object.keys(set).reduce(\n      (acc, i) =>\n        acc + 'pragma ' + (set[i] ? '+' : '-') + i + '\\n',\n      ''\n    )\n    this.queue.push(p)\n    this.#process()\n  }\n\n  /**\n   * Specify the number of Test Points expected by this test.\n   * Outputs a TAP plan line.\n   */\n  plan(n: number, comment?: string) {", "    if (this.bailedOut) {\n      return\n    }\n\n    if (this.#planEnd !== -1) {\n      throw new Error('Cannot set plan more than once')\n    }\n\n    if (typeof n !== 'number' || n < 0) {\n      throw new TypeError('plan must be a number')\n    }\n\n    // Cannot get any tests after a trailing plan, or a plan of 0\n    const ending = this.count !== 0 || n === 0\n", "    if (typeof n !== 'number' || n < 0) {\n      throw new TypeError('plan must be a number')\n    }\n\n    // Cannot get any tests after a trailing plan, or a plan of 0\n    const ending = this.count !== 0 || n === 0\n\n    if (n === 0 && comment && !this.options.skip) {\n      this.options.skip = comment\n    }\n\n    this.#planEnd = n\n    comment = comment ? ' # ' + esc(comment.trim()) : ''\n    this.queue.push('1..' + n + comment + '\\n')\n", "    if (ending) {\n      this.#end(IMPLICIT)\n    } else {\n      this.#process()\n    }\n  }\n\n  /**\n   * A passing (ok) Test Point\n   */\n  pass(message?: string, extra?: { [k: string]: any }) {\n    this.currentAssert = TestBase.prototype.pass\n\n    this.printResult(\n      true,\n      ...normalizeMessageExtra(\n        '(unnamed test)',\n        message,\n        extra\n      )\n    )\n    return true\n  }\n\n  /**\n   * A failing (not ok) Test Point\n   */\n  fail(message?: string, extra?: { [k: string]: any }) {\n    this.currentAssert = TestBase.prototype.fail\n    const [m, e] = normalizeMessageExtra(\n      '(unnamed test)',\n      message,\n      extra\n    )\n    this.printResult(false, m, e)\n    return !!(e.todo || e.skip)\n  }\n\n  /**\n   * The current assertion being processed.  May only be set if\n   * not already set.\n   */\n  get currentAssert() {\n    return this.#currentAssert\n  }\n  /**\n   * The current assertion being processed.  May only be set if\n   * not already set.\n   */\n  set currentAssert(fn: null | ((...a: any[]) => any)) {", "    if (!this.#currentAssert && typeof fn === 'function') {\n      this.#currentAssert = fn\n    }\n  }\n\n  /**\n   * Print a Test Point\n   */\n  printResult(\n    ok: boolean,\n    message: string,\n    extra: { [k: string]: any },\n    front: boolean = false\n  ) {\n    this.#printedResult = true\n\n    const n = this.count + 1\n    this.currentAssert = TestBase.prototype.printResult\n    const fn = this.#currentAssert\n    this.#currentAssert = null\n", "    if (this.#planEnd !== -1 && n > this.#planEnd) {\n      if (!this.passing()) return\n\n      const failMessage = this.#explicitEnded\n        ? 'test after end() was called'\n        : 'test count exceeds plan'\n\n      const er = new Error(failMessage, {\n        cause: {\n          test: this.name,\n          plan: this.#planEnd,\n        },\n      })\n      Error.captureStackTrace(er, fn || undefined)\n      this.threw(er)\n      return\n    }\n\n    extra = extra || {}\n", "    if (extra.expectFail) {\n      ok = !ok\n    }\n\n    if (this.assertAt) {\n      extra.at = this.assertAt\n      this.assertAt = null\n    }\n\n    if (this.assertStack) {\n      extra.stack = this.assertStack\n      this.assertStack = null\n    }\n", "    if (this.assertStack) {\n      extra.stack = this.assertStack\n      this.assertStack = null\n    }\n\n    if (typeof extra.stack === 'string' && !extra.at) {\n      extra.at = stack.parseLine(extra.stack.split('\\n')[0])\n    }\n\n    if (\n      !ok &&\n      !extra.skip &&\n      !extra.at &&\n      typeof fn === 'function'\n    ) {\n      extra.at = stack.at(fn)", "    if (\n      !ok &&\n      !extra.skip &&\n      !extra.at &&\n      typeof fn === 'function'\n    ) {\n      extra.at = stack.at(fn)\n      if (!extra.todo) {\n        extra.stack = stack.captureString(80, fn)\n      }\n    }\n\n    const diagnostic =\n      typeof extra.diagnostic === 'boolean'\n        ? extra.diagnostic\n        : typeof this.diagnostic === 'boolean'\n        ? this.diagnostic\n        : extra.skip || extra.todo\n        ? false\n        : !ok\n", "    if (diagnostic) {\n      extra.diagnostic = true\n    }\n\n    this.count = n\n    message = message + ''\n    const res = { ok, message, extra }\n\n    const tp = new TestPoint(ok, message, extra)\n\n    // when we jump the queue, skip an extra line", "    if (front) {\n      tp.message = tp.message.trimEnd() + '\\n\\n'\n    }\n\n    if (\n      this.#occupied &&\n      this.#occupied instanceof Waiter &&\n      this.#occupied.finishing\n    ) {\n      front = true\n    }\n", "    if (front) {\n      if (\n        extra.tapChildBuffer ||\n        extra.tapChildBuffer === ''\n      ) {\n        this.writeSubComment(tp)\n        this.parser.write(extra.tapChildBuffer)\n      }\n      this.emit('result', res)\n      this.parser.write(tp.ok + ++this.#n + tp.message)\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.parser.write('Bail out! ' + message + '\\n')\n      }\n    } else {\n      this.queue.push(tp)", "      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.parser.write('Bail out! ' + message + '\\n')\n      }\n    } else {\n      this.queue.push(tp)\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.queue.push('Bail out! ' + message + '\\n')\n      }\n    }\n\n    if (this.#planEnd === this.count) {\n      this.#end(IMPLICIT)\n    }\n\n    this.#process()\n  }\n\n  end(): this {\n    this.#end()\n    return super.end()\n  }\n\n  /**\n   * The leading `# Subtest` comment that introduces a child test\n   */\n  writeSubComment<T extends TestPoint | Base>(p: T) {\n    const comment =\n      '# Subtest' +\n      (p.name ? ': ' + esc(p.name) : '') +\n      '\\n'\n    this.parser.write(comment)\n  }\n  // end TAP otput generating methods\n\n  // flow control methods\n\n  /**\n   * Await the end of a Promise before proceeding.\n   * The supplied callback is called with the Waiter object.\n   */\n  waitOn(\n    promise: Promise<any | void>,\n    cb: (w: Waiter) => any,\n    expectReject: boolean = false\n  ): Promise<void> {\n    const w = new Waiter(\n      promise,\n      w => {\n        assert.equal(this.#occupied, w)\n        cb(w)\n        this.#occupied = null\n        this.#process()\n      },\n      expectReject\n    )\n    this.queue.push(w)\n    this.#process()\n    return w.promise\n  }\n\n  #end(implicit?: typeof IMPLICIT) {", "    if (this.#planEnd === this.count) {\n      this.#end(IMPLICIT)\n    }\n\n    this.#process()\n  }\n\n  end(): this {\n    this.#end()\n    return super.end()\n  }\n\n  /**\n   * The leading `# Subtest` comment that introduces a child test\n   */\n  writeSubComment<T extends TestPoint | Base>(p: T) {\n    const comment =\n      '# Subtest' +\n      (p.name ? ': ' + esc(p.name) : '') +\n      '\\n'\n    this.parser.write(comment)\n  }\n  // end TAP otput generating methods\n\n  // flow control methods\n\n  /**\n   * Await the end of a Promise before proceeding.\n   * The supplied callback is called with the Waiter object.\n   */\n  waitOn(\n    promise: Promise<any | void>,\n    cb: (w: Waiter) => any,\n    expectReject: boolean = false\n  ): Promise<void> {\n    const w = new Waiter(\n      promise,\n      w => {\n        assert.equal(this.#occupied, w)\n        cb(w)\n        this.#occupied = null\n        this.#process()\n      },\n      expectReject\n    )\n    this.queue.push(w)\n    this.#process()\n    return w.promise\n  }\n\n  #end(implicit?: typeof IMPLICIT) {", "    if (this.#doingStdinOnly && implicit !== IMPLICIT)\n      throw new Error(\n        'cannot explicitly end while in stdinOnly mode'\n      )\n    this.debug('END implicit=%j', implicit === IMPLICIT)\n    if (this.ended && implicit === IMPLICIT) return\n\n    // beyond here we have to be actually done with things, or else\n    // the semantic checks on counts and such will be off.\n    if (!queueEmpty(this) || this.#occupied) {\n      if (!this.#pushedEnd) {\n        this.queue.push(['#end', implicit])\n      }\n      this.#pushedEnd = true\n      return this.#process()\n    }\n\n    this.ended = true\n", "    if (!queueEmpty(this) || this.#occupied) {\n      if (!this.#pushedEnd) {\n        this.queue.push(['#end', implicit])\n      }\n      this.#pushedEnd = true\n      return this.#process()\n    }\n\n    this.ended = true\n\n    if (implicit !== IMPLICIT && !this.#multiEndThrew) {", "    if (implicit !== IMPLICIT && !this.#multiEndThrew) {\n      if (this.#explicitEnded) {\n        this.#multiEndThrew = true\n        const er = new Error(\n          'test end() method called more than once'\n        )\n        Error.captureStackTrace(\n          er,\n          this.#currentAssert || this.#end\n        )\n        er.cause = {\n          test: this.name,\n        }\n        this.threw(er)\n        return\n      }\n      this.#explicitEnded = true\n    }\n", "    if (this.#planEnd === -1) {\n      this.debug(\n        'END(%s) implicit plan',\n        this.name,\n        this.count\n      )\n      this.plan(this.count)\n    }\n\n    this.queue.push(EOF)\n    this.#process()\n  }\n\n  #process() {", "    if (this.#processing) {\n      return this.debug(' < already processing')\n    }\n    this.debug(\n      '\\nPROCESSING(%s)',\n      this.name,\n      this.queue.length\n    )\n    this.#processing = true\n\n    while (!this.#occupied) {\n      const p = this.queue.shift()", "    while (!this.#occupied) {\n      const p = this.queue.shift()\n      if (!p) {\n        this.debug('> end of queue')\n        break\n      }\n      if (p instanceof Base) {\n        this.debug('> subtest in queue', p.name)\n        this.#processSubtest(p)\n      } else if (p === EOF) {\n        this.debug(' > EOF', this.name)\n        // I AM BECOME EOF, DESTROYER OF STREAMS\n        this.parser.end()", "      } else if (p === EOF) {\n        this.debug(' > EOF', this.name)\n        // I AM BECOME EOF, DESTROYER OF STREAMS\n        this.parser.end()\n      } else if (p instanceof TestPoint) {\n        this.debug(' > TESTPOINT')\n        if (\n          p.extra.tapChildBuffer ||\n          p.extra.tapChildBuffer === ''\n        ) {\n          this.writeSubComment(p)\n          this.parser.write(p.extra.tapChildBuffer)\n        }\n        this.emit('res', p.res)\n        this.parser.write(p.ok + ++this.#n + p.message)", "      } else if (typeof p === 'string') {\n        this.debug(' > STRING')\n        this.parser.write(p)\n      } else if (p instanceof Waiter) {\n        p.ready = true\n        this.#occupied = p\n        p.finish()\n      } else if (Array.isArray(p)) {\n        this.debug(' > METHOD')\n        const m = p.shift() as keyof this\n        if (typeof this[m] !== 'function') {\n          this.debug(\n            ' > weird method not found in queue??',\n            m,\n            typeof this[m]\n          )\n          continue\n        }\n        const fn = (m === '#end' ? this.#end : this[m]) as (\n          ...a: any[]\n        ) => any\n        const ret = fn.call(this, ...p)", "        if (typeof this[m] !== 'function') {\n          this.debug(\n            ' > weird method not found in queue??',\n            m,\n            typeof this[m]\n          )\n          continue\n        }\n        const fn = (m === '#end' ? this.#end : this[m]) as (\n          ...a: any[]\n        ) => any\n        const ret = fn.call(this, ...p)", "        if (\n          ret &&\n          typeof ret === 'object' &&\n          typeof ret.then === 'function'\n        ) {\n          // returned promise\n          ret.then(\n            () => {\n              this.#processing = false\n              this.#process()\n            },\n            (er: unknown) => {\n              this.#processing = false\n              this.threw(er)\n            }\n          )\n          return\n        }\n        /* c8 ignore start */\n      } else {\n        throw new Error('weird thing got in the queue')\n      }\n      /* c8 ignore stop */\n    }\n", "    while (\n      !this.#noparallel &&\n      this.pool.size < this.jobs\n    ) {\n      const p = this.subtests.shift()\n      if (!p) {\n        break\n      }\n\n      if (!p.buffered) {\n        this.#noparallel = true\n        break\n      }\n\n      this.debug('start subtest', p)\n      this.emit('subtestStart', p)\n      this.pool.add(p)", "      if (!p.buffered) {\n        this.#noparallel = true\n        break\n      }\n\n      this.debug('start subtest', p)\n      this.emit('subtestStart', p)\n      this.pool.add(p)\n      if (this.bailedOut) {\n        this.#onBufferedEnd(p)\n      } else {\n        p.runMain(() => this.#onBufferedEnd(p))\n      }\n    }\n\n    this.debug(\n      'done processing',\n      this.queue,\n      this.#occupied\n    )\n    this.#processing = false\n\n    // just in case any tests ended, and we have sync stuff still\n    // waiting around in the queue to be processed", "      if (this.bailedOut) {\n        this.#onBufferedEnd(p)\n      } else {\n        p.runMain(() => this.#onBufferedEnd(p))\n      }\n    }\n\n    this.debug(\n      'done processing',\n      this.queue,\n      this.#occupied\n    )\n    this.#processing = false\n\n    // just in case any tests ended, and we have sync stuff still\n    // waiting around in the queue to be processed", "    if (!this.#occupied && this.queue.length) {\n      this.#process()\n    }\n  }\n\n  #onBufferedEnd<T extends Base>(p: T) {\n    p.ondone = p.constructor.prototype.ondone\n    p.results =\n      p.results || new FinalResults(true, p.parser)\n    p.readyToProcess = true\n    const to = p.options.timeout\n    const dur =\n      to && p.passing() ? hrtime.bigint() - p.start : null", "    if (dur && to && dur > to) {\n      p.timeout()\n    } else {\n      p.setTimeout(0)\n    }\n    this.debug(\n      '%s.#onBufferedEnd',\n      this.name,\n      p.name,\n      p.results.bailout\n    )\n    this.pool.delete(p)\n    p.options.tapChildBuffer = p.output || ''\n    p.options.stack = ''", "    if (p.time) p.options.time = p.time\n    if (this.#occupied === p) this.#occupied = null\n    p.deferred?.resolve(p.results)\n    this.emit('subtestEnd', p)\n    this.#process()\n  }\n\n  #onIndentedEnd<T extends Base>(p: T) {\n    this.emit('subtestProcess', p)\n    p.ondone = p.constructor.prototype.ondone\n    p.results =\n      p.results || new FinalResults(true, p.parser)\n    this.debug('#onIndentedEnd', this.name, p.name)\n    this.#noparallel = false\n    const sti = this.subtests.indexOf(p)", "    if (sti !== -1) this.subtests.splice(sti, 1)\n    p.readyToProcess = true\n    p.options.time = p.time\n    const to = p.options.timeout\n    const dur =\n      to && p.passing() ? hrtime.bigint() - p.start : null\n    if (dur && to && dur > to) {\n      p.timeout()\n    } else {\n      p.setTimeout(0)\n    }\n    this.debug('#onIndentedEnd %s(%s)', this.name, p.name)\n    this.#occupied = null\n    this.debug(\n      'OIE(%s) b>shift into queue',\n      this.name,\n      this.queue\n    )\n    p.options.stack = ''\n\n    this.printResult(p.passing(), p.name, p.options, true)\n\n    this.debug(\n      'OIE(%s) shifted into queue',\n      this.name,\n      this.queue\n    )\n    p.deferred?.resolve(p.results)\n    this.emit('subtestEnd', p)\n    this.#process()\n  }\n\n  /**\n   * @internal\n   */\n  main(cb: () => void) {", "    if (typeof this.options.timeout === 'number') {\n      this.setTimeout(this.options.timeout)\n    }\n    this.debug('MAIN pre', this)\n\n    const end = () => {\n      this.debug(' > implicit end for promise')\n      this.#end(IMPLICIT)\n      done()\n    }\n\n    const done = (er?: Error) => {", "      if (er) this.threw(er)\n\n      if (this.results || this.bailedOut) cb()\n      else this.ondone = () => cb()\n    }\n\n    // This bit of overly clever line-noise wraps the call to user-code\n    // in a try-catch. We can't rely on the domain for this yet, because\n    // the 'end' event can trigger a throw after the domain is unhooked,\n    // but before this is no longer the official \"active test\"\n    const ret = (() => {", "      if (!this.cb) return\n      try {\n        return this.cb(this)\n      } catch (er: any) {\n        if (!er || typeof er !== 'object') {\n          er = { error: er }\n        }\n        er.tapCaught = 'testFunctionThrow'\n        this.threw(er)\n      }\n    })()\n", "    if (ret && ret.then) {\n      this.promise = ret\n      ret.tapAbortPromise = done\n      ret.then(end, (er: any) => {\n        if (!er || typeof er !== 'object') {\n          er = { error: er }\n        }\n        er.tapCaught = 'returnedPromiseRejection'\n        done(er)\n      })\n    } else done()\n\n    this.debug('MAIN post', this)\n  }\n\n  #processSubtest<T extends Base>(p: T) {\n    this.debug(' > subtest')\n    this.#occupied = p", "    if (!p.buffered) {\n      this.emit('subtestStart', p)\n      this.debug(' > subtest indented')\n      p.stream.pipe(this.parser, { end: false })\n      this.writeSubComment(p)\n      this.debug('calling runMain', p.runMain.toString())\n      p.runMain(() => {\n        this.debug('in runMain', p.runMain.toString())\n        this.#onIndentedEnd(p)\n      })\n    } else if (p.readyToProcess) {\n      this.emit('subtestProcess', p)\n      this.debug(' > subtest buffered, finished')\n      // finished!  do the thing!\n      this.#occupied = null", "    } else if (p.readyToProcess) {\n      this.emit('subtestProcess', p)\n      this.debug(' > subtest buffered, finished')\n      // finished!  do the thing!\n      this.#occupied = null\n      if (!p.passing() || !p.silent) {\n        this.printResult(\n          p.passing(),\n          p.name,\n          p.options,\n          true\n        )\n      }\n    } else {\n      this.#occupied = p\n      this.debug(' > subtest buffered, unfinished', p)\n      // unfinished buffered test.\n      // nothing to do yet, just leave it there.\n      this.queue.unshift(p)\n    }\n  }\n\n  /**\n   * Parse stdin as the only tap stream (ie, not as a child test)\n   * If used, then no other subtests or assertions are allowed.\n   */\n  stdinOnly<T extends BaseOpts>(\n    extra?: T & { tapStream?: Readable | Minipass }\n  ) {\n    const stream = ((extra && extra.tapStream) ||\n      process.stdin) as Minipass", "    if (!stream) {\n      throw new Error(\n        'cannot read stdin without stdin stream'\n      )\n    }\n\n    if (\n      this.queue.length !== 1 ||\n      this.queue[0] !== 'TAP version 14\\n' ||\n      this.#processing ||\n      this.results ||\n      this.#occupied ||\n      this.pool.size ||\n      this.subtests.length\n    ) {\n      throw new Error(\n        'Cannot use stdinOnly on a test in progress'\n      )\n    }\n\n    this.#doingStdinOnly = true\n    this.queue.length = 0\n    this.parser.on('child', p => {\n      // pretend to be a rooted parser, so it gets counts.\n      p.root = p\n      const t = new Base({\n        name: p.name,\n        parent: this,\n        parser: p,\n        bail: p.bail,\n        strict: p.strict,\n        omitVersion: p.omitVersion,\n        preserveWhitespace: p.preserveWhitespace,\n        childId: this.#nextChildId++,\n      })\n      this.emit('subtestAdd', t)\n      this.emit('subtestStart', t)\n      this.emit('subtestProcess', t)\n      p.on('complete', () => {\n        t.time = p.time\n        this.emit('subtestEnd', t)\n      })\n    })\n    stream.pause()\n    stream.pipe(this.parser)\n    stream.resume()\n  }\n\n  /**\n   * Mount a subtest, using this Test object as a harness.\n   * Exposed mainly so that it can be used by builtin plugins.\n   *\n   * @internal\n   */\n  sub<T extends Base, O extends TestBaseOpts>(\n    Class: { new (options: O): T },\n    extra: O,\n    caller: (...a: any[]) => unknown\n  ): Promise<FinalResults | null> {", "    if (this.bailedOut) return Promise.resolve(null)\n\n    if (this.results || this.ended) {\n      const er = new Error(\n        'cannot create subtest after parent test ends'\n      )\n      Error.captureStackTrace(er, caller)\n      this.threw(er)\n      return Promise.resolve(null)\n    }\n\n    extra.childId = this.#nextChildId++", "    if (this.shouldSkipChild(extra)) {\n      this.pass(extra.name, extra)\n      return Promise.resolve(null)\n    }\n\n    extra.indent = '    '\n    if (extra.buffered !== undefined) {\n      if (this.jobs > 1) {\n        extra.buffered = true\n      } else {\n        extra.buffered = false\n      }\n    }\n\n    extra.bail =\n      extra.bail !== undefined ? extra.bail : this.bail\n    extra.parent = this\n    extra.stack = stack.captureString(80, caller)\n    extra.context = this.context\n\n    const t = new Class(extra)\n    this.queue.push(t)\n    this.subtests.push(t)\n    this.emit('subtestAdd', t)\n\n    const d = new Deferred<FinalResults>()\n    t.deferred = d\n    this.#process()\n    return d.promise\n  }\n\n  /**\n   * Return true if the child test represented by the options object\n   * should be skipped.  Extended by the grep/only filtering plugins.\n   */\n  shouldSkipChild(extra: { [k: string]: any }) {\n    return !!(extra.skip || extra.todo)\n  }\n\n  // end flow control methods\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './test-base.js'\nexport * from './test.js'\nexport * from './spawn.js'\nexport * from './stdin.js'\nexport * from './base.js'\n"]}
{"filename": "src/generate.ts", "chunked_list": ["#!/usr/bin/env node --require=ts-node/register\nimport { readFileSync, writeFileSync, mkdirSync, rmSync } from 'node:fs'\nimport { resolve } from 'node:path'\nconst dir = resolve(__dirname, '../node_modules/.tapjs/core')\nconst f = resolve(dir, 'index.ts')\nconst tsconfig = resolve('../tsconfig.json')\n\n\n\nconst tsNodeReg = require.resolve('ts-node/register')", "\nconst tsNodeReg = require.resolve('ts-node/register')\n\n\n// get the \n\nconst plugins = [...new Set(readFileSync('plugins.txt', 'utf8')\n  .trim()\n  .split('\\n'))]\n", "  .split('\\n'))]\n\nconst imports: string[] = [\n  '// generated, do not edit',\n  '',\n  `import { PluginHost } from './plugin-host'`,\n  '',\n]\n\nconst inst: string[] = [`export const Host =`]", "\nconst inst: string[] = [`export const Host =`]\n\nplugins.forEach((p, i) => {\n  imports.push(\n    `import { plugin as Plugin${i} } from ${JSON.stringify(\n      p\n    )}`\n  )\n  inst.push(`Plugin${i}(`)", "  )\n  inst.push(`Plugin${i}(`)\n})\n\ninst.push(`PluginHost`, ')'.repeat(plugins.length))\n\nwriteFileSync(\n  'host.ts',\n  `${imports.join('\\n')}\n", "  `${imports.join('\\n')}\n\n${inst.join('\\n')}\n`\n)\n"]}
{"filename": "src/test-point.ts", "chunked_list": ["import { diags } from './diags.js'\nimport { esc } from './esc.js'\nimport { TestBaseOpts } from './test-base.js'\n\nexport interface Result {\n  ok: boolean\n  message: string\n  extra: { [k: string]: any }\n}\n\nexport class TestPoint {\n  ok: 'ok ' | 'not ok '\n  name: string\n  message: string\n  extra: { [key: string]: any }\n  res: Result\n\n  constructor(\n    ok: boolean,\n    message: string,\n    extra?: { [key: string]: any }\n  ) {\n    this.ok = ok ? 'ok ' : 'not ok '\n    extra = extra || {}\n    message = message\n      .trim()\n      .replace(/[\\n\\r]/g, ' ')\n      .replace(/\\t/g, '  ')\n    this.res = { ok, message, extra }\n    this.extra = extra\n    this.name = message\n    this.message = tpMessage(esc(this.name), extra)\n  }\n}\n\nconst tpMessage = (\n  description: string,\n  extra: { [k: string]: any },\n  options: TestBaseOpts = {}\n): string => {\n  let message = description ? ` - ${description}` : ''\n", "export class TestPoint {\n  ok: 'ok ' | 'not ok '\n  name: string\n  message: string\n  extra: { [key: string]: any }\n  res: Result\n\n  constructor(\n    ok: boolean,\n    message: string,\n    extra?: { [key: string]: any }\n  ) {\n    this.ok = ok ? 'ok ' : 'not ok '\n    extra = extra || {}\n    message = message\n      .trim()\n      .replace(/[\\n\\r]/g, ' ')\n      .replace(/\\t/g, '  ')\n    this.res = { ok, message, extra }\n    this.extra = extra\n    this.name = message\n    this.message = tpMessage(esc(this.name), extra)\n  }\n}\n\nconst tpMessage = (\n  description: string,\n  extra: { [k: string]: any },\n  options: TestBaseOpts = {}\n): string => {\n  let message = description ? ` - ${description}` : ''\n", "  if (extra.skip) {\n    message += ' # SKIP'\n    if (typeof extra.skip === 'string') {\n      message += ' ' + esc(extra.skip)\n    }\n  } else if (extra.todo) {\n    message += ' # TODO'\n    if (typeof extra.todo === 'string') {\n      message += ' ' + esc(extra.todo)\n    }\n  } else if (extra.time) {\n    message += ' # time=' + extra.time + 'ms'\n  }\n\n  const diagYaml = extra.diagnostic\n    ? diags(extra, options)\n    : ''\n  message += diagYaml + '\\n'\n\n  return message\n}\n", "  } else if (extra.time) {\n    message += ' # time=' + extra.time + 'ms'\n  }\n\n  const diagYaml = extra.diagnostic\n    ? diags(extra, options)\n    : ''\n  message += diagYaml + '\\n'\n\n  return message\n}\n"]}
{"filename": "src/tap-dir-cjs.ts", "chunked_list": ["// this form only works in the cjs.\n// it'll overwrite tap-dir.js output in cjs mode\nimport { dirname } from 'path'\n//@ts-ignore\nexport const tapDir = dirname(__dirname)\n"]}
{"filename": "src/stdin.ts", "chunked_list": ["import Minipass from 'minipass'\nimport { Base, BaseOpts } from './base'\n\nexport interface StdinOpts extends BaseOpts {\n  tapStream?: NodeJS.ReadableStream | Minipass\n}\n\nexport class Stdin extends Base {\n  inputStream: NodeJS.ReadableStream | Minipass<string | Buffer>\n  constructor(options: StdinOpts) {\n    super({\n      ...options,\n      name: options.name || '/dev/stdin',\n    })\n    this.inputStream = options.tapStream || process.stdin\n    this.inputStream.pause()\n  }\n\n  main(cb: () => void) {\n    this.inputStream.on('error', er => {\n      er.tapCaught = 'stdinError'\n      this.threw(er)\n    })", "    if (this.options.timeout) {\n      this.setTimeout(this.options.timeout)\n    }\n    const s = this.inputStream as Minipass\n    s.pipe(this.parser)\n    if (this.parent) {\n      this.parent.emit('stdin', this)\n    }\n    this.inputStream.resume()\n    this.once('end', cb)\n  }\n\n  threw(er: any, extra?: any, proxy?: boolean) {\n    extra = super.threw(er, extra, proxy)\n    Object.assign(this.options, extra)\n    this.parser.abort(er.message, extra)\n    this.parser.end()\n  }\n}\n"]}
{"filename": "src/tap-dir.ts", "chunked_list": ["// this form only works in the mjs.\n// it'll be overwritten by the tap-dir-cjs.js output in cjs mode\nimport { dirname } from 'path'\nimport {fileURLToPath} from 'url'\n//@ts-ignore\nexport const tapDir = dirname(dirname(fileURLToPath(import.meta.url)))\n"]}
{"filename": "src/extra-from-error.ts", "chunked_list": ["import stack from './stack'\nimport type {BaseOpts} from './base'\n\nexport default (er:any, extra?:{[k: string]:any}, options?:BaseOpts) => {\n  // the yaml module puts big stuff here, pluck it off\n  if (er.source && typeof er.source === 'object' && er.source.context)\n    er.source = { ...er.source, context: null }\n\n  // pull out all fields from options, other than anything starting\n  // with tapChild, or anything already set in the extra object.\n  extra = Object.fromEntries(Object.entries(options || {}).filter(([k]) =>\n    !/^tapChild/.test(k) && !(k in (extra || {}))))\n", "  if (!er || typeof er !== 'object') {\n    extra.error = er\n    return extra\n  }\n\n  // pull out error details\n  const message = er.message ? er.message\n    : er.stack ? er.stack.split('\\n')[0]\n    : ''\n\n  if (er.message) {", "  if (er.message) {\n    try {\n      Object.defineProperty(er, 'message', {\n        value: '',\n        configurable: true\n      })\n    } catch {}\n  }\n\n  const st = er.stack && er.stack.substr(\n    er._babel ? (message + er.codeFrame).length : 0)", "  if (st) {\n    const splitst = st.split('\\n')\n    if (er._babel && er.loc) {\n      const msplit = message.split(': ')\n      const f = msplit[0].trim()\n      extra.message = msplit.slice(1).join(': ')\n        .replace(/ \\([0-9]+:[0-9]+\\)$/, '').trim()\n      const file = f.indexOf(process.cwd()) === 0\n        ? f.substr(process.cwd().length + 1) : f\n      if (file !== 'unknown')\n        delete er.codeFrame\n      extra.at = {\n        file,\n        line: er.loc.line,\n        column: er.loc.column + 1,\n      }\n    } else {\n      // parse out the 'at' bit from the first line.\n      extra.at = stack.parseLine(splitst[1])\n    }\n    extra.stack = stack.clean(splitst)\n  }\n", "      if (file !== 'unknown')\n        delete er.codeFrame\n      extra.at = {\n        file,\n        line: er.loc.line,\n        column: er.loc.column + 1,\n      }\n    } else {\n      // parse out the 'at' bit from the first line.\n      extra.at = stack.parseLine(splitst[1])\n    }\n    extra.stack = stack.clean(splitst)\n  }\n", "  if (message) {\n    try {\n      Object.defineProperty(er, 'message', {\n        value: message,\n        configurable: true\n      })\n    } catch {}\n  }\n\n  if (er.name && er.name !== 'Error') {\n    extra.type = er.name\n  }\n\n  Object.assign(extra, Object.fromEntries(Object.entries(er).filter(([k]) =>\n    k !== 'message')))\n\n  return extra\n}\n", "  if (er.name && er.name !== 'Error') {\n    extra.type = er.name\n  }\n\n  Object.assign(extra, Object.fromEntries(Object.entries(er).filter(([k]) =>\n    k !== 'message')))\n\n  return extra\n}\n"]}
{"filename": "src/waiter.ts", "chunked_list": ["\nexport class Waiter {\n  cb: null | ((w:Waiter)=>any)\n  ready: boolean = false\n  value: any = null\n  resolved: boolean = false\n  rejected: boolean = false\n  done: boolean = false\n  finishing: boolean = false\n  expectReject: boolean\n  promise: Promise<void>\n  resolve: null | ((value?:any)=>void) = null\n\n  constructor (promise: Promise<any|void>, cb:(w:Waiter)=>any, expectReject:boolean = false) {\n    this.cb = cb\n    this.expectReject = !!expectReject\n    this.promise = new Promise<void>(res => this.resolve = res)\n    promise.then(value => {", "      if (this.done) {\n        return\n      }\n\n      this.resolved = true\n      this.value = value\n      this.done = true\n      this.finish()\n    }).catch(er => this.reject(er))\n  }\n\n  reject (er:any) {", "    }).catch(er => this.reject(er))\n  }\n\n  reject (er:any) {\n    if (this.done) {\n      return\n    }\n\n    this.value = er\n    this.rejected = true\n    this.done = true\n    this.finish()\n  }\n\n  abort (er:Error) {", "    if (this.done) {\n      return\n    }\n\n    this.ready = true\n    this.finishing = false\n    this.done = true\n    this.value = er\n    // make it clear that this is a problem by doing\n    // the opposite of what was requested.\n    this.rejected = !this.expectReject\n    return this.finish()\n  }\n\n  finish () {", "    if (this.ready && this.done && !this.finishing) {\n      this.finishing = true\n      this.cb && this.cb(this)\n      this.resolve && this.resolve()\n    }\n  }\n}\n"]}
{"filename": "src/plugin/spawn.ts", "chunked_list": ["import { StdioOptions } from 'child_process'\nimport { FinalResults } from 'tap-parser'\nimport { BaseOpts } from '../base.js'\nimport { Spawn } from '../spawn.js'\nimport { TapPlugin, TestBase } from '../test-base.js'\n\nexport interface SpawnOpts extends BaseOpts {\n  cwd?: string\n  command?: string\n  args?: string[]\n  stdio?: StdioOptions\n  env?: { [k: string]: string } | typeof process.env\n  exitCode?: number | null\n  signal?: string | null\n}\n", "class SpawnPlugin {\n  #t: TestBase\n  constructor(t: TestBase) {\n    this.#t = t\n  }\n  spawn(cmd: string): Promise<FinalResults | null>\n  spawn(\n    cmd: string,\n    options: SpawnOpts,\n    name?: string\n  ): Promise<FinalResults | null>\n  spawn(\n    cmd: string,\n    args: string | string[],\n    name?: string\n  ): Promise<FinalResults | null>\n  spawn(\n    cmd: string,\n    args: string | string[],\n    options: SpawnOpts,\n    name?: string\n  ): Promise<FinalResults | null>\n  spawn(\n    cmd: string,\n    args?: string | string[] | SpawnOpts,\n    options?: SpawnOpts | string,\n    name?: string\n  ): Promise<FinalResults | null> {", "    if (typeof args === 'string') {\n      args = [args]\n    }\n    if (typeof options === 'string') {\n      name = options\n      options = {}\n    }\n    if (typeof args === 'object' && !Array.isArray(args)) {\n      options = args\n      args = []\n    }\n    options = options || {}", "    if (options.name === undefined) {\n      options.name = name\n    }\n    options.command = cmd\n    options.args = args\n    return this.#t.sub(Spawn, options, this.spawn)\n  }\n}\n\nconst plugin: TapPlugin<SpawnPlugin> = (t: TestBase) =>\n  new SpawnPlugin(t)\nexport default plugin\n"]}
{"filename": "src/plugin/after-each.ts", "chunked_list": ["import loop from 'function-loop'\nimport { TapPlugin, TestBase } from '../test-base.js'\nimport type { Test } from '../test-built.js'\n\nclass AfterEach {\n  static #refs = new Map<TestBase, AfterEach>()\n  #t: TestBase\n  constructor(t: TestBase) {\n    this.#t = t\n    AfterEach.#refs.set(t, this)\n    const runMain = t.runMain\n    t.runMain = (cb: () => void) => {\n      runMain.call(t, () => this.#runAfterEach(this.#t, cb))\n    }\n  }\n  #onAfterEach: ((t: Test) => void)[] = []\n  afterEach(fn: (t: Test) => void | Promise<void>) {\n    this.#onAfterEach.push(fn)\n  }\n  #runAfterEach(who: TestBase, cb: () => void) {\n    // run all the afterEach methods from the parent\n    const onerr = (er: any) => {\n      who.threw(er)\n      cb()\n    }\n    const p = this.#t.parent\n    const pae = !!p && AfterEach.#refs.get(p)\n    const run = () => {", "      if (pae) {\n        pae.#runAfterEach(who, cb)\n      } else {\n        cb()\n      }\n    }\n    if (who !== this.#t) {\n      loop(this.#onAfterEach, run, onerr)\n    } else {\n      run()\n    }\n  }\n}\n\nconst plugin: TapPlugin<AfterEach> = (t: TestBase) => new AfterEach(t)\nexport default plugin\n"]}
{"filename": "src/plugin/before-each.ts", "chunked_list": ["/// <reference types=\"node\" />\nimport loop from 'function-loop'\nimport { TestBase } from '../test-base.js'\nimport type { Test } from '../test-built.js'\n\nclass BeforeEach {\n  static #refs = new Map<TestBase, BeforeEach>()\n  #t: TestBase\n  constructor(t: TestBase) {\n    this.#t = t\n    BeforeEach.#refs.set(t, this)\n    const runMain = t.runMain\n    t.runMain = (cb: () => void) => {\n      this.#runBeforeEach(this.#t, () =>\n        runMain.call(t, cb)\n      )\n    }\n  }\n  #onBeforeEach: ((t: Test) => void)[] = []\n  beforeEach(fn: (t: Test) => void | Promise<void>) {\n    this.#onBeforeEach.push(fn)\n  }\n  #runBeforeEach(who: TestBase, cb: () => void) {\n    // run all the beforeEach methods from the parent\n    const onerr = (er: any) => {\n      who.threw(er)\n      cb()\n    }\n    const p = this.#t.parent\n    const pbe = !!p && BeforeEach.#refs.get(p)", "    if (pbe) {\n      pbe.#runBeforeEach(who, () => {\n        loop(this.#onBeforeEach, cb, onerr)\n      })\n    } else if (who !== this.#t) {\n      loop(this.#onBeforeEach, cb, onerr)\n    } else {\n      cb()\n    }\n  }\n}\n\nconst plugin = (t: TestBase) => new BeforeEach(t)\nexport default plugin\n"]}
{"filename": "src/plugin/stdin.ts", "chunked_list": ["import { FinalResults } from 'tap-parser'\nimport parseTestArgs from '../parse-test-args.js'\nimport { Stdin, StdinOpts } from '../stdin.js'\nimport { TapPlugin, TestBase } from '../test-base.js'\n\nclass StdinPlugin {\n  #t: TestBase\n  constructor(t: TestBase) {\n    this.#t = t\n  }\n  stdin(\n    name: string,\n    extra?: StdinOpts\n  ): Promise<FinalResults | null>\n  stdin(extra?: StdinOpts): Promise<FinalResults | null>\n  stdin(\n    name?: string | { [k: string]: any },\n    extra?: StdinOpts\n  ): Promise<FinalResults | null> {", "    if (name && typeof name === 'object') {\n      extra = name\n      name = undefined\n    }\n    extra = parseTestArgs<Stdin>(\n      name,\n      extra,\n      false,\n      '/dev/stdin'\n    )\n    return this.#t.sub(Stdin, extra, this.stdin)\n  }\n}\n\nconst plugin: TapPlugin<StdinPlugin> = (t: TestBase) =>\n  new StdinPlugin(t)\nexport default plugin\n"]}
