{"filename": "vitest.config.ts", "chunked_list": ["import path from 'path';\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'istanbul',\n      reporter: ['text', 'json', 'html'],\n    },\n  },", "    },\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n});\n", ""]}
{"filename": "test/index.spec.ts", "chunked_list": ["import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';\n\nimport { botStartup } from '../src/bot';\nimport { initConfigs } from '../src/config';\nimport { startServer } from '../src/http';\n\ndescribe('src/index.ts', () => {\n  beforeAll(() => {\n    vi.mock('../src/http/index');\n    vi.mock('../src/config/index');", "    vi.mock('../src/http/index');\n    vi.mock('../src/config/index');\n    vi.mock('../src/bot/index');\n  });\n\n  afterAll(() => {\n    vi.clearAllMocks();\n\n    it('should have called', () => {\n      expect(startServer()).toBeCalled();", "    it('should have called', () => {\n      expect(startServer()).toBeCalled();\n    });\n  });\n\n  it('should run correctly all functions', () => {\n    initConfigs();\n    startServer();\n    botStartup();\n", "    botStartup();\n\n    expect(initConfigs).toHaveBeenCalled();\n    expect(startServer).toHaveBeenCalled();\n    expect(startServer).toHaveBeenCalled();\n  });\n});\n"]}
{"filename": "test/config/winston.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { fileLogger, logger } from '../../src/config/winston';\n\ndescribe('src/config/winston.ts', () => {\n  vi.useFakeTimers();\n\n  afterAll(() => {\n    vi.useRealTimers();\n    vi.clearAllMocks();", "    vi.useRealTimers();\n    vi.clearAllMocks();\n  });\n\n  it('should run logger log correctly', () => {\n    const level = 'debug';\n    const message = 'testing logger';\n\n    vi.spyOn(logger, 'log');\n", "    vi.spyOn(logger, 'log');\n\n    logger.log(level, message);\n\n    expect(logger.log).toHaveBeenCalledOnce();\n    expect(logger.log).toBeCalledWith(level, message);\n  });\n\n  it('should run fileLogger log correctly', () => {\n    const level = 'error';", "  it('should run fileLogger log correctly', () => {\n    const level = 'error';\n    const message = 'Some Error has Happened';\n    const error = new Error(message);\n    vi.spyOn(fileLogger, 'log');\n    const systemDate = new Date(2023, 3, 23, 1);\n    vi.setSystemTime(systemDate);\n\n    fileLogger.log(level, message, error);\n", "    fileLogger.log(level, message, error);\n\n    expect(fileLogger.log).toHaveBeenCalledOnce();\n    expect(fileLogger.log).toBeCalledWith(level, message, error);\n  });\n});\n"]}
{"filename": "test/config/index.spec.ts", "chunked_list": ["import * as dotenv from 'dotenv';\nimport { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';\n\nimport { initConfigs } from '../../src/config/index';\nimport { initSentry } from '../../src/config/sentry';\n\ndescribe('src/config/index.ts', () => {\n  beforeAll(() => {\n    vi.mock('dotenv');\n    vi.mock('../../src/config/sentry');", "    vi.mock('dotenv');\n    vi.mock('../../src/config/sentry');\n  });\n\n  afterAll(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should run initConfigs correctly', () => {\n    initConfigs();", "  it('should run initConfigs correctly', () => {\n    initConfigs();\n    expect(dotenv.config).toHaveBeenCalledOnce();\n    expect(initSentry).toHaveBeenCalledOnce();\n  });\n});\n"]}
{"filename": "test/config/sentry.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport Sentry, { Transaction } from '@sentry/node';\n\nimport { initSentry, sentryCapture } from '../../src/config/sentry';\n\ndescribe('src/config/sentry.ts', () => {\n  afterAll(() => {\n    vi.clearAllMocks();\n  });", "    vi.clearAllMocks();\n  });\n\n  it('should run initSentry', () => {\n    vi.spyOn(Sentry, 'init').mockResolvedValueOnce();\n\n    const sentryDns = 'http://sentry-test.com?id=9213812';\n    process.env.SENTRY_DNS = sentryDns;\n    initSentry();\n    expect(Sentry.init).toHaveBeenCalledOnce();", "    initSentry();\n    expect(Sentry.init).toHaveBeenCalledOnce();\n    expect(Sentry.init).toHaveBeenCalledWith({\n      dsn: sentryDns,\n      environment: 'test',\n      tracesSampleRate: 1.0,\n    });\n  });\n\n  it('should run SentryCapture correctly', () => {", "\n  it('should run SentryCapture correctly', () => {\n    const name = 'TEST_ERROR';\n    const testError = new Error('Test Exception has happened');\n\n    const startTransactionSpy = vi\n      .spyOn(Sentry, 'startTransaction')\n      .mockImplementationOnce(() => {\n        return {\n          finish(endTimestamp) {", "        return {\n          finish(endTimestamp) {\n            return endTimestamp;\n          },\n        } as Transaction;\n      });\n\n    vi.spyOn(Sentry, 'captureException').mockImplementation(() => '');\n\n    sentryCapture(name, testError);", "\n    sentryCapture(name, testError);\n\n    expect(startTransactionSpy).toHaveBeenCalledOnce();\n    expect(Sentry.captureException).toHaveBeenCalledOnce();\n    expect(Sentry.captureException).toHaveBeenLastCalledWith(testError);\n  });\n});\n", ""]}
{"filename": "test/sources/source-stream.spec.ts", "chunked_list": ["import { Readable } from 'stream';\nimport { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport {\n  ResultAudioSearch,\n  SourceStream,\n  StreamInfo,\n} from '../../src/sources/source-stream';\n\ndescribe('src/sources/source-stream.ts', () => {", "\ndescribe('src/sources/source-stream.ts', () => {\n  const mockURLStream = 'https://some.stream.io?stream=03310';\n  const mockResultAudio: ResultAudioSearch = {\n    duration: '1:40',\n    id: '1',\n    title: 'some-stream-audio',\n    url: mockURLStream,\n  };\n", "  };\n\n  const mockStreamInfo: StreamInfo = {\n    title: 'some-stream',\n    url: mockURLStream,\n  };\n\n  class TestSourceStream implements SourceStream {\n    getStream(_url: string): Readable | Promise<Readable> {\n      console.log(_url);\n      const readable = new Readable({\n        encoding: 'utf-8',\n      });\n      return readable;\n    }\n\n    getStreamInfo(_input: string): Promise<StreamInfo> {\n      console.log(_input);\n      return Promise.resolve(mockStreamInfo);\n    }\n\n    search(_input: string): ResultAudioSearch[] | Promise<ResultAudioSearch[]> {\n      console.log(_input);\n      return [mockResultAudio];\n    }\n\n    getStreamFromUrl(_url: string): Promise<StreamInfo> {\n      console.log(_url);\n      return Promise.resolve(mockStreamInfo);\n    }\n\n    validate(_input: string): Promise<boolean> {\n      console.log(_input);\n\n      return Promise.resolve(true);\n    }\n  }\n\n  afterAll(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should have correct instance of SourceStream', () => {\n    const testStream = new TestSourceStream();\n    expect(testStream.getStream).toBeDefined();\n    expect(testStream.search).toBeDefined();\n    expect(testStream.getStreamInfo).toBeDefined();\n  });\n\n  it('should run search correctly', () => {\n    vi.spyOn(TestSourceStream.prototype, 'search');\n\n    const testStream = new TestSourceStream();\n    const result = testStream.search('test');\n\n    expect(TestSourceStream.prototype.search).toHaveBeenCalledOnce();\n    expect(TestSourceStream.prototype.search).toBeCalledWith('test');\n    expect(result).toEqual([mockResultAudio]);\n  });\n  it('should run getStreamInfo correctly', async () => {\n    vi.spyOn(TestSourceStream.prototype, 'getStreamInfo');\n\n    const testStream = new TestSourceStream();\n    const result = await testStream.getStreamInfo('test');\n\n    expect(TestSourceStream.prototype.getStreamInfo).toHaveBeenCalledOnce();\n    expect(TestSourceStream.prototype.getStreamInfo).toBeCalledWith('test');\n    expect(result).toEqual(mockStreamInfo);\n  });\n  it('should run getStream correctly', async () => {\n    vi.spyOn(TestSourceStream.prototype, 'getStream');\n\n    const readableStream = new Readable({ encoding: 'utf-8' });\n\n    const testStream = new TestSourceStream();\n    const result = await testStream.getStream('test');\n\n    expect(TestSourceStream.prototype.getStream).toHaveBeenCalledOnce();\n    expect(TestSourceStream.prototype.getStream).toBeCalledWith('test');\n    expect(result).toEqual(readableStream);\n  });\n});\n"]}
{"filename": "test/sources/ytdl-source/ytdl-mocks.ts", "chunked_list": ["import { Readable } from 'stream';\nimport { vi } from 'vitest';\nimport yts from 'yt-search';\n\nexport const mockVideoUrl = 'https://www.youtube.com/watch?v=qGl7b1EPwfA';\n\nexport const mockVideoResult: yts.VideoSearchResult = {\n  duration: {\n    seconds: 40,\n    timestamp: '',", "    seconds: 40,\n    timestamp: '',\n    toString: () => '40',\n  },\n  seconds: 40,\n  title: 'video test 1',\n  url: 'www.youtube.com/watch?=023912',\n  videoId: 'qGl7b1EPwfA',\n} as yts.VideoSearchResult;\n", "} as yts.VideoSearchResult;\n\nexport const mockYtVideoInfo = {\n  player_response: {\n    videoDetails: {\n      title: mockVideoResult.title,\n      videoId: 'qGl7b1EPwfA',\n    },\n  },\n  videoDetails: {", "  },\n  videoDetails: {\n    video_url: mockVideoUrl,\n  },\n};\n\nexport const mockSearchResult: Partial<yts.SearchResult> = {\n  videos: [mockVideoResult],\n};\n\nexport function setupYtdlStub() {\n  vi.mock('ytdl-core', async () => {\n    const original = await vi.importActual<typeof import('ytdl-core')>(\n      'ytdl-core'\n    );\n    const ytdlMock = {\n      ...original,\n      default: (url: string) => {\n        return url === mockVideoUrl ? new Readable() : null;\n      },\n      getInfo: () => mockYtVideoInfo,\n      getURLVideoID: () => mockVideoUrl,\n      validateURL: (url: string) => {\n        console.log('NO MOCK VALIDATE URL');\n        return url.includes('www.youtube.com/watch?v=');\n      },\n    };\n\n    return ytdlMock;\n  });\n\n  vi.mock('yt-search', async () => {\n    return {\n      default: (query: string) => {", "};\n\nexport function setupYtdlStub() {\n  vi.mock('ytdl-core', async () => {\n    const original = await vi.importActual<typeof import('ytdl-core')>(\n      'ytdl-core'\n    );\n    const ytdlMock = {\n      ...original,\n      default: (url: string) => {\n        return url === mockVideoUrl ? new Readable() : null;\n      },\n      getInfo: () => mockYtVideoInfo,\n      getURLVideoID: () => mockVideoUrl,\n      validateURL: (url: string) => {\n        console.log('NO MOCK VALIDATE URL');\n        return url.includes('www.youtube.com/watch?v=');\n      },\n    };\n\n    return ytdlMock;\n  });\n\n  vi.mock('yt-search', async () => {\n    return {\n      default: (query: string) => {", "        if (query === 'test') return Promise.resolve(mockSearchResult);\n        return { videos: [] };\n      },\n    };\n  });\n}\n"]}
{"filename": "test/sources/ytdl-source/ytdl-source.spec.ts", "chunked_list": ["import { Readable } from 'stream';\nimport { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { ERRORS } from '../../../src/shared/errors';\nimport { mockVideoUrl, setupYtdlStub } from './ytdl-mocks';\nsetupYtdlStub();\nimport { YtdlSourceStream } from '../../../src/sources/ytdl-source/ytdl-source';\n\ndescribe('src/sources/ytdl-source/ytdl-source-stream.ts', () => {\n  afterAll(() => {", "describe('src/sources/ytdl-source/ytdl-source-stream.ts', () => {\n  afterAll(() => {\n    vi.resetAllMocks();\n    vi.clearAllMocks();\n    vi.restoreAllMocks();\n  });\n\n  describe('getStream()', () => {\n    it('should run getStream correctly', async () => {\n      const ytdlSource = new YtdlSourceStream();", "    it('should run getStream correctly', async () => {\n      const ytdlSource = new YtdlSourceStream();\n      const stream = await ytdlSource.getStream(mockVideoUrl);\n      expect(stream).toBeDefined();\n      expect(stream).toEqual(new Readable());\n    });\n    it('shoud return RESULT_NOT_FOUND on invalid yt url passed', async () => {\n      const ytdlSource = new YtdlSourceStream();\n\n      await ytdlSource.getStream('invalid_url').catch((e) => {\n        expect(e).toEqual(ERRORS.RESULT_NOT_FOUND);\n      });\n    });\n  });\n\n  describe('getStreamFromUrl()', () => {\n    it('should return youtube video results', async () => {\n      const ytdlSource = new YtdlSourceStream();\n      const results = await ytdlSource.search('test');\n      expect(results).toBeDefined();\n    });\n\n    it('should return RESLT_NOT_FOUND when no results were available', async () => {\n      const ytdlSource = new YtdlSourceStream();", "\n      await ytdlSource.getStream('invalid_url').catch((e) => {\n        expect(e).toEqual(ERRORS.RESULT_NOT_FOUND);\n      });\n    });\n  });\n\n  describe('getStreamFromUrl()', () => {\n    it('should return youtube video results', async () => {\n      const ytdlSource = new YtdlSourceStream();\n      const results = await ytdlSource.search('test');\n      expect(results).toBeDefined();\n    });\n\n    it('should return RESLT_NOT_FOUND when no results were available', async () => {\n      const ytdlSource = new YtdlSourceStream();", "      ytdlSource.search('___').catch((reason) => {\n        expect(reason).toEqual(ERRORS.RESULT_NOT_FOUND);\n      });\n    });\n  });\n\n  describe('search()', () => {\n    it('should run getStreamFromUrl() ', async () => {\n      const source = new YtdlSourceStream();\n      const results = await source.getStreamFromUrl(mockVideoUrl);\n      expect(results).toBeDefined();\n    });\n\n    it('should return undefined due to invalid url', async () => {\n      const source = new YtdlSourceStream();\n      await source\n        .getStreamFromUrl('www.invalid-yt-url')", "        .catch((reason) => expect(reason).toEqual(ERRORS.RESULT_NOT_FOUND));\n    });\n  });\n});\n"]}
{"filename": "test/sources/play-dl-source/play-dl-source.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { PlayDlSourceStream } from '../../../src/sources/play-dl-source/play-dl-source';\n\ndescribe('src/sources/play-dl-source/play-dl-source-stream.ts', () => {\n  afterAll(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('getStream()', () => {", "\n  describe('getStream()', () => {\n    it('should run getStream correctly', async () => {\n      const playDLSource = new PlayDlSourceStream();\n\n      expect(playDLSource).toBeDefined();\n    });\n  });\n});\n", "});\n"]}
{"filename": "test/helpers/helpers.spec.ts", "chunked_list": ["import { describe, expect, it } from 'vitest';\nimport { shuffleArray } from '../../src/helpers/helpers';\n\ndescribe('shuffleArray', () => {\n  it('should return an array with different order', () => {\n    expect(shuffleArray<number>([1, 2, 3, 4])).not.toEqual([1, 2, 3, 4]);\n  });\n\n  it('should return an empty array if it was passed in param', () => {\n    expect(shuffleArray([])).toEqual([]);", "  it('should return an empty array if it was passed in param', () => {\n    expect(shuffleArray([])).toEqual([]);\n  });\n});\n"]}
{"filename": "test/bot/index.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { botStartup } from '../../src/bot/index';\nimport { MarliMusic } from '../../src/bot/marli-music';\n\ndescribe('src/bot/index.ts', () => {\n  afterAll(() => {\n    vi.clearAllMocks();\n  });\n", "  });\n\n  describe('botStartup', () => {\n    it('should return a MarliMusic instance', () => {\n      vi.spyOn(MarliMusic.prototype, 'login').mockReturnValueOnce(\n        Promise.resolve('')\n      );\n      const marliMusic = botStartup();\n\n      expect(marliMusic).toBeDefined();", "\n      expect(marliMusic).toBeDefined();\n    });\n  });\n});\n"]}
{"filename": "test/bot/marli-music.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { MarliMusic } from '../../src/bot/marli-music';\nimport { LocalQueue } from '../../src/queue/queue';\nimport { YtdlSourceStream } from '../../src/sources/ytdl-source/ytdl-source';\n\ndescribe('src/bot/marli-music.ts', () => {\n  afterAll(() => {\n    vi.clearAllMocks();\n  });", "    vi.clearAllMocks();\n  });\n\n  describe('healthCheck', () => {\n    it('should return healthCheck', () => {\n      vi.spyOn(MarliMusic.prototype, 'login').mockImplementation(() =>\n        Promise.resolve('')\n      );\n      const marli = new MarliMusic(\n        {", "      const marli = new MarliMusic(\n        {\n          prefix: '!',\n          token: '123',\n        },\n        new YtdlSourceStream(),\n        new LocalQueue(),\n        { intents: [] }\n      );\n", "      );\n\n      const healthCheckSpy = vi.spyOn(marli, 'healthCheck');\n\n      expect(healthCheckSpy).toBeDefined();\n    });\n  });\n});\n", ""]}
{"filename": "test/bot/default-messages.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { BOT_MESSAGES } from '../../src/bot/containts/default-messages';\n\ndescribe('src/bot/default-messages.ts', () => {\n  afterAll(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('BOT_MESSAGES', () => {", "\n  describe('BOT_MESSAGES', () => {\n    it('should return BOT_MESSAGES', () => {\n      const msg = BOT_MESSAGES.INVALID_COMMAND;\n      expect(msg).toBeDefined();\n    });\n  });\n});\n", ""]}
{"filename": "test/shared/errors.spec.ts", "chunked_list": ["import { describe, expect, it } from 'vitest';\n\nimport { ERRORS } from '../../src/shared/errors';\n\ndescribe('src/shared/errors.ts', () => {\n  it('should contain correct errors', () => {\n    const errors = Object.values(ERRORS).map((msg) => new Error(msg));\n\n    errors.forEach((error) => expect(ERRORS[error.message]).toBeDefined);\n  });", "    errors.forEach((error) => expect(ERRORS[error.message]).toBeDefined);\n  });\n});\n"]}
{"filename": "test/http/index.spec.ts", "chunked_list": ["import supertest from 'supertest';\nimport {\n  afterAll,\n  afterEach,\n  describe,\n  expect,\n  it,\n  SpyInstance,\n  vi,\n} from 'vitest';", "  vi,\n} from 'vitest';\n\nimport { logger } from '../../src/config/winston';\nimport { appServer, httpServer, startServer } from '../../src/http/index';\n\ndescribe('src/http/index.ts', () => {\n  afterEach(() => {\n    httpServer.close();\n  });", "    httpServer.close();\n  });\n\n  afterAll(() => {\n    vi.resetAllMocks();\n  });\n\n  it('should start express server', async () => {\n    const spyUse = vi.spyOn(appServer, 'use');\n    const spyListen: SpyInstance = vi.spyOn(appServer, 'listen');", "    const spyUse = vi.spyOn(appServer, 'use');\n    const spyListen: SpyInstance = vi.spyOn(appServer, 'listen');\n\n    startServer();\n\n    expect(spyListen).toHaveBeenCalledOnce();\n    expect(spyUse).toHaveBeenCalledOnce();\n  });\n\n  it('should log `server listening`', () => {", "\n  it('should log `server listening`', () => {\n    const logSpy = vi.spyOn(logger, 'log');\n\n    startServer();\n    setTimeout(() => {\n      expect(logSpy).toHaveBeenCalledOnce();\n    }, 500);\n  });\n", "  });\n\n  it('should reach route [GET] / ', async () => {\n    startServer();\n    const response = await supertest(appServer).get('/');\n    expect(response.status).toBe(200);\n  });\n});\n", ""]}
{"filename": "test/http/routes/index.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\nimport { mainRouter } from '../../../src/http/routes/index';\n\ndescribe('src/http/routes/index.ts', () => {\n  afterAll(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('mainRouter', () => {", "\n  describe('mainRouter', () => {\n    it('should return mainRouter', () => {\n      const mainRouterSpy = vi.spyOn(mainRouter, 'get');\n      expect(mainRouterSpy).toBeDefined();\n    });\n  });\n});\n", ""]}
{"filename": "src/index.ts", "chunked_list": ["import { botStartup } from './bot';\nimport { initConfigs } from './config';\nimport { startServer } from './http';\n\ninitConfigs();\nbotStartup();\nstartServer();\n"]}
{"filename": "src/config/winston.ts", "chunked_list": ["import dayjs from 'dayjs';\nimport { join } from 'path';\nimport { cwd } from 'process';\nimport winston, { format, transports } from 'winston';\n\nclass Logger {\n  private logger: winston.Logger;\n  constructor(private options: { saveToFile: boolean }) {\n    this.logger = this.makeLogger();\n  }\n\n  public log(level: string, message: string, error?: Error) {\n    return this.logger.log(level, message, error);\n  }\n\n  public debug(level: string, ...args: unknown[]) {\n    return args.map((arg) => this.logger.log(level, arg));\n  }\n\n  public error(message: string, error?: Error) {\n    return this.logger.error(message, error);\n  }\n\n  private makeLogger() {\n    return winston.createLogger({\n      format: format.combine(\n        format.json(),\n        format.timestamp(),\n        format.printf(({ timestamp, level, message }) => {\n          return `[${timestamp}] ${level}: ${message}`;\n        })\n      ),\n      level: 'debug',\n      transports: this.options.saveToFile\n        ? [\n            new winston.transports.Console(),\n            new transports.File({\n              dirname: this.makeFolderName(),\n              filename: this.makeFileName(),\n            }),\n          ]\n        : [new winston.transports.Console()],\n    });\n  }\n\n  private makeFolderName() {\n    return join(cwd(), `logs/winston/${dayjs().format('MM-YYYY')}`);\n  }\n  private makeFileName() {\n    return `${dayjs().format('DD-MM-YYYY')}.log`;\n  }\n}\n\nexport const logger = new Logger({ saveToFile: false });\nexport const fileLogger = new Logger({ saveToFile: true });\n"]}
{"filename": "src/config/sentry.ts", "chunked_list": ["import * as Sentry from '@sentry/node';\n\nexport function initSentry() {\n  Sentry.init({\n    dsn: process.env.SENTRY_DNS,\n    environment: process.env.NODE_ENV || 'development',\n    tracesSampleRate: 1.0,\n  });\n}\n\nexport function sentryCapture(name: string, error: Error) {\n  const transaction = Sentry.startTransaction({\n    name,\n    op: 'transaction',\n  });\n\n  Sentry.captureException(error);\n  transaction.finish();\n}\n", "export function sentryCapture(name: string, error: Error) {\n  const transaction = Sentry.startTransaction({\n    name,\n    op: 'transaction',\n  });\n\n  Sentry.captureException(error);\n  transaction.finish();\n}\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\nimport { initSentry } from './sentry';\n\nexport function initConfigs() {\n  dotenv.config();\n  initSentry();\n}\n"]}
{"filename": "src/sources/source-stream.ts", "chunked_list": ["import { Readable } from 'node:stream';\n\nexport interface ResultAudioSearch {\n  title: string;\n  duration: string;\n  id: string;\n  url: string;\n}\n\nexport interface StreamInfo {\n  title: string;\n  url?: string;\n  artist?: string;\n}\n", "export interface StreamInfo {\n  title: string;\n  url?: string;\n  artist?: string;\n}\n\nexport interface SerachOptionsParams {\n  limit?: number;\n}\n\nexport interface SourceStream {\n  getStream(url: string): Promise<Readable>;\n  search(\n    input: string,\n    options?: SerachOptionsParams\n  ): Promise<ResultAudioSearch[]>;\n  getStreamFromUrl(url: string): Promise<StreamInfo[]>;\n  validate(input: string): Promise<boolean>;\n}\n", "export interface SourceStream {\n  getStream(url: string): Promise<Readable>;\n  search(\n    input: string,\n    options?: SerachOptionsParams\n  ): Promise<ResultAudioSearch[]>;\n  getStreamFromUrl(url: string): Promise<StreamInfo[]>;\n  validate(input: string): Promise<boolean>;\n}\n"]}
{"filename": "src/sources/ytdl-source/ytdl-source.ts", "chunked_list": ["import { Readable } from 'node:stream';\nimport yts from 'yt-search';\nimport ytdl, { getInfo, getURLVideoID, validateURL } from 'ytdl-core';\n\nimport { ERRORS } from '@/shared/errors';\n\nimport { ResultAudioSearch, SourceStream } from '../source-stream';\n\nexport class YtdlSourceStream implements SourceStream {\n  async getStream(url: string): Promise<Readable> {\n    const stream = ytdl(url, {\n      dlChunkSize: 0,\n      filter: 'audioonly',\n      highWaterMark: 1 << 25,\n      quality: 'lowestaudio',\n    });", "export class YtdlSourceStream implements SourceStream {\n  async getStream(url: string): Promise<Readable> {\n    const stream = ytdl(url, {\n      dlChunkSize: 0,\n      filter: 'audioonly',\n      highWaterMark: 1 << 25,\n      quality: 'lowestaudio',\n    });\n    if (!stream) return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n    return Promise.resolve(stream);\n  }\n\n  async search(input: string): Promise<ResultAudioSearch[]> {\n    const result = await yts(input);", "    if (!stream) return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n    return Promise.resolve(stream);\n  }\n\n  async search(input: string): Promise<ResultAudioSearch[]> {\n    const result = await yts(input);\n    if (result.videos.length < 1)\n      return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n    const videos = result.videos.slice(0, 10);\n    return videos.map((video) => ({\n      duration: video.duration.toString(),\n      id: video.videoId,\n      title: video.title,\n      url: video.url,\n    }));\n  }\n\n  async getStreamFromUrl(input: string) {", "    if (input.startsWith('https') && validateURL(input)) {\n      const videoId = getURLVideoID(input);\n\n      const info = await getInfo(videoId);\n\n      return [\n        {\n          title: info.player_response.videoDetails.title,\n          url: info.videoDetails.video_url,\n        },\n      ];\n    }\n    return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n  }\n\n  async validate(url: string): Promise<boolean> {\n    // implementation pending\n    return Boolean(url);\n  }\n}\n"]}
{"filename": "src/sources/play-dl-source/play-dl-source.ts", "chunked_list": ["import { Readable } from 'node:stream';\nimport play, { validate as validateStreamUrl, YouTubeVideo } from 'play-dl';\n\nimport { BotError, ERRORS } from '@/shared/errors';\n\nimport {\n  ResultAudioSearch,\n  SerachOptionsParams,\n  SourceStream,\n} from '../source-stream';", "  SourceStream,\n} from '../source-stream';\nimport { playDlStrategies } from './strategies/strategy';\n\nconst youtubeStreamTypes = ['yt_video'];\nconst spotifyStreamTypes = ['sp_track', 'sp_playlist'];\nconst validStreamTypes = [...youtubeStreamTypes, ...spotifyStreamTypes];\n\nexport class PlayDlSourceStream implements SourceStream {\n  streamType = 'sp_track';\n\n  async getStream(input: string): Promise<Readable> {", "export class PlayDlSourceStream implements SourceStream {\n  streamType = 'sp_track';\n\n  async getStream(input: string): Promise<Readable> {\n    try {\n      const result = await play.stream(input, {\n        quality: 2,\n      });\n\n      return result.stream;\n    } catch (e) {\n      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n    }\n  }\n\n  async search(\n    input: string,\n    options?: SerachOptionsParams\n  ): Promise<ResultAudioSearch[]> {", "    } catch (e) {\n      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n    }\n  }\n\n  async search(\n    input: string,\n    options?: SerachOptionsParams\n  ): Promise<ResultAudioSearch[]> {\n    try {\n      const result = await play.search(input, {\n        ...(options?.limit && { limit: options.limit }),\n        source: {\n          youtube: 'video',\n        },\n      });\n", "    try {\n      const result = await play.search(input, {\n        ...(options?.limit && { limit: options.limit }),\n        source: {\n          youtube: 'video',\n        },\n      });\n\n      if (!result.length) throw new Error(ERRORS.RESULT_NOT_FOUND);\n\n      const resultMap = result.map((video: YouTubeVideo) => ({\n        duration: video.durationRaw.toString(),\n        id: video.id,\n        title: video.title,\n        url: video.url,\n        artist: video.channel?.name || video?.music.shift()?.artist,\n      }));\n", "      if (!result.length) throw new Error(ERRORS.RESULT_NOT_FOUND);\n\n      const resultMap = result.map((video: YouTubeVideo) => ({\n        duration: video.durationRaw.toString(),\n        id: video.id,\n        title: video.title,\n        url: video.url,\n        artist: video.channel?.name || video?.music.shift()?.artist,\n      }));\n\n      if (options?.limit === 1) {\n        return [resultMap.shift()];\n      }\n\n      return resultMap;", "      if (options?.limit === 1) {\n        return [resultMap.shift()];\n      }\n\n      return resultMap;\n    } catch (e) {\n      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n    }\n  }\n\n  async getStreamFromUrl(url: string) {", "    try {\n      if (!url?.trim().startsWith('https')) return;\n\n      const validUrl = await this.validate(url);\n\n      if (!validUrl) throw new Error(ERRORS.INVALID_URL);\n\n      if (spotifyStreamTypes.includes(this.streamType) && play.is_expired()) {\n        await play.refreshToken();\n      }\n\n      const Strategy = playDlStrategies[this.streamType];\n\n      return new Strategy(this).getStreamInfo(url);", "    } catch (e) {\n      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n    }\n  }\n\n  async validate(input: string): Promise<boolean> {\n    this.streamType = String(await validateStreamUrl(input));\n\n    if (Boolean(this.streamType) === false) return false;\n\n    return validStreamTypes.includes(this.streamType);\n  }\n}\n", "    if (Boolean(this.streamType) === false) return false;\n\n    return validStreamTypes.includes(this.streamType);\n  }\n}\n"]}
{"filename": "src/sources/play-dl-source/strategies/youtube-strategy.ts", "chunked_list": ["import play from 'play-dl';\n\nimport { StreamInfo } from '@/sources/source-stream';\n\nimport { IStrategy } from './strategy';\n\nexport class YoutubeStrategy implements IStrategy {\n  async getStreamInfo(url: string): Promise<StreamInfo[]> {\n    const videoInfo = await play.video_info(url);\n\n    return [\n      {\n        title: videoInfo.video_details.title,\n        url: videoInfo.video_details.url,\n        artist:\n          String(videoInfo.video_details.channel.name) ||\n          String(videoInfo.video_details.music.shift().artist),\n      },\n    ];\n  }\n}\n"]}
{"filename": "src/sources/play-dl-source/strategies/strategy.ts", "chunked_list": ["import { StreamInfo } from '@/sources/source-stream';\n\nimport { PlayDlSourceStream } from '../play-dl-source';\nimport {\n  SpotifyPlaylistStrategy,\n  SpotifyTrackStrategy,\n} from './spotify-strategy';\nimport { YoutubeStrategy } from './youtube-strategy';\n\nexport interface StrategyConstructor {\n  new (playDl: PlayDlSourceStream): IStrategy;\n}\n", "\nexport interface StrategyConstructor {\n  new (playDl: PlayDlSourceStream): IStrategy;\n}\n\nexport interface IStrategy {\n  getStreamInfo(url: string): Promise<StreamInfo[]>;\n}\n\nexport const playDlStrategies = {\n  sp_playlist: SpotifyPlaylistStrategy,\n  sp_track: SpotifyTrackStrategy,\n  yt_video: YoutubeStrategy,\n};\n"]}
{"filename": "src/sources/play-dl-source/strategies/spotify-strategy.ts", "chunked_list": ["import play, { SpotifyPlaylist, SpotifyTrack } from 'play-dl';\n\nimport { StreamInfo } from '@/sources/source-stream';\n\nimport { PlayDlSourceStream } from '../play-dl-source';\nimport { IStrategy } from './strategy';\n\nexport class SpotifyTrackStrategy implements IStrategy {\n  constructor(private playDlSourceStream: PlayDlSourceStream) {}\n\n  async getStreamInfo(url: string): Promise<StreamInfo[]> {\n    const spotifyInfo = (await play.spotify(url.trim())) as SpotifyTrack;\n\n    const searched = (\n      await this.playDlSourceStream.search(\n        `${spotifyInfo.name} - ${spotifyInfo?.artists.shift()?.name}`,\n        {\n          limit: 1,\n        }\n      )\n    ).shift();\n\n    return [\n      {\n        title: spotifyInfo.name,\n        url: searched.url,\n        artist: spotifyInfo?.artists.shift().name,\n      },\n    ];\n  }\n}\n", "export class SpotifyPlaylistStrategy implements IStrategy {\n  async getStreamInfo(url: string): Promise<StreamInfo[]> {\n    const playlist = (await play.spotify(url.trim())) as SpotifyPlaylist;\n\n    const tracks = await playlist.all_tracks();\n\n    const spotifyTracks = tracks.map((track) => ({\n      title: track.name,\n      url: undefined,\n      artist: track?.artists.shift().name,\n    }));\n\n    return spotifyTracks;\n  }\n}\n"]}
{"filename": "src/helpers/helpers.ts", "chunked_list": ["export function shuffleArray<T>(array: Array<T>): T[] {\n  let currentIndex = array.length;\n  let randomIndex: number;\n\n  // While there remain elements to shuffle.\n  while (currentIndex != 0) {\n    // Pick a remaining element.\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    // And swap it with the current element.\n    [array[currentIndex], array[randomIndex]] = [\n      array[randomIndex],\n      array[currentIndex],\n    ];\n  }\n\n  return array;\n}\n", "export function fragmentContent(\n  itemsToShow: string,\n  limit = 1000,\n  delimiter = ''\n): string[] {\n  const contentLengh = itemsToShow.length;\n  const parts = Math.ceil(contentLengh / limit);\n\n  let count = 1;\n  let initRange = 0;\n  const result: string[] = [];", "  while (count <= parts) {\n    let finalRange = initRange + limit;\n    if (delimiter && finalRange[finalRange - 1] !== delimiter) {\n      const lastIndexOfDelimiter = itemsToShow.lastIndexOf(\n        delimiter,\n        finalRange\n      );\n      finalRange = lastIndexOfDelimiter + delimiter.length;\n    }\n    const fragment = itemsToShow.slice(initRange, finalRange);\n    result.push(fragment);\n    initRange = finalRange;\n    count++;\n  }\n\n  return result;\n}\n"]}
{"filename": "src/bot/marli-music.ts", "chunked_list": ["import { Client, ClientOptions, Message } from 'discord.js';\n\nimport { sentryCapture } from '@/config/sentry';\nimport { logger } from '@/config/winston';\nimport { Queue } from '@/queue/queue';\nimport { ERRORS } from '@/shared/errors';\nimport { SourceStream } from '@/sources/source-stream';\nimport { AudioPlayer } from '@discordjs/voice';\n\nimport { ALL_COMMANDS, Command } from './commands';", "\nimport { ALL_COMMANDS, Command } from './commands';\nimport { CommandHelp } from './commands/command-help';\nimport { BOT_MESSAGES } from './containts/default-messages';\n\nexport interface BotInfo {\n  prefix: string;\n  token: string;\n}\n\nexport class MarliMusic extends Client {\n  prefix: string;\n  players: Map<string, AudioPlayer> = new Map();\n  static MAX_REPLY_CONTENT_LENGTH = 2000;\n\n  constructor(\n    private botInfo: BotInfo,\n    public sourceStream: SourceStream,\n    public queue: Queue,\n    options?: ClientOptions\n  ) {\n    super(options);\n\n    this.prefix = botInfo.prefix;\n", "export class MarliMusic extends Client {\n  prefix: string;\n  players: Map<string, AudioPlayer> = new Map();\n  static MAX_REPLY_CONTENT_LENGTH = 2000;\n\n  constructor(\n    private botInfo: BotInfo,\n    public sourceStream: SourceStream,\n    public queue: Queue,\n    options?: ClientOptions\n  ) {\n    super(options);\n\n    this.prefix = botInfo.prefix;\n", "    this.login(this.botInfo.token).catch((reason) => {\n      logger.log('error', ERRORS.BOT_STARTUP_ERROR, reason);\n      sentryCapture(ERRORS.BOT_STARTUP_ERROR, new Error(reason));\n    });\n\n    this.once('ready', () => {\n      this.healthCheck();\n    });\n\n    this.on('error', (error: Error) => {\n      logger.error(ERRORS.BOT_STARTUP_ERROR, error);\n      sentryCapture(ERRORS.BOT_STARTUP_ERROR, error);\n    });\n\n    this.on('messageCreate', async (message: Message) =>\n      this.onMessage(message)\n    );\n  }\n\n  public healthCheck() {\n    const healthString = `${this.user.username} online ${this.uptime}`;\n    logger.log('debug', healthString);\n    return healthString;\n  }\n\n  public addPlayer(connection: string) {\n    this.players.set(connection, new AudioPlayer());\n  }\n\n  public getPlayer(connection: string) {", "    if (!this.players.has(connection)) {\n      this.addPlayer(connection);\n    }\n    return this.players.get(connection);\n  }\n\n  public removePlayer(connection: string) {\n    this.players.delete(connection);\n  }\n\n  private async onMessage(message: Message) {", "    if (message.author.bot) return;\n    if (!message.content.startsWith(this.prefix)) return;\n\n    const args = message.content.split(' ');\n    const input = message.content.replace(args[0], '');\n    const commandString = args[0].replace(this.prefix, '');\n\n    if (!ALL_COMMANDS[commandString]) {\n      await message.reply(BOT_MESSAGES.INVALID_COMMAND);\n      await new CommandHelp(this).execute(message);\n      return;\n    }\n\n    const command: Command = new ALL_COMMANDS[commandString](this);\n\n    await command.execute(message, input);\n  }\n}\n"]}
{"filename": "src/bot/index.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\nimport { LocalQueue } from '../queue/queue';\nimport { PlayDlSourceStream } from '../sources/play-dl-source/play-dl-source';\nimport { MarliMusic } from './marli-music';\n\ndotenv.config();\n\nexport function botStartup() {\n  const botInfo = {\n    prefix: process.env.BOT_PREFIX,\n    token: process.env.BOT_TOKEN,\n  };\n  const queue = new LocalQueue();\n  const sourceStream = new PlayDlSourceStream();\n\n  const marliMusic = new MarliMusic(botInfo, sourceStream, queue, {\n    intents: [\n      'Guilds',\n      'GuildMessages',\n      'MessageContent',\n      'GuildVoiceStates',\n      'DirectMessageReactions',\n      'GuildEmojisAndStickers',\n      'GuildMembers',\n      'GuildMessageTyping',\n      'GuildMessageReactions',\n    ],\n  });\n\n  return marliMusic;\n}\n", "export function botStartup() {\n  const botInfo = {\n    prefix: process.env.BOT_PREFIX,\n    token: process.env.BOT_TOKEN,\n  };\n  const queue = new LocalQueue();\n  const sourceStream = new PlayDlSourceStream();\n\n  const marliMusic = new MarliMusic(botInfo, sourceStream, queue, {\n    intents: [\n      'Guilds',\n      'GuildMessages',\n      'MessageContent',\n      'GuildVoiceStates',\n      'DirectMessageReactions',\n      'GuildEmojisAndStickers',\n      'GuildMembers',\n      'GuildMessageTyping',\n      'GuildMessageReactions',\n    ],\n  });\n\n  return marliMusic;\n}\n"]}
{"filename": "src/bot/commands/command-help.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\nimport { ALL_COMMANDS } from './command-map';\n\nexport class CommandHelp extends Command {\n  name = 'help';\n  constructor(bot: MarliMusic) {\n    super(bot);\n  }\n  async execute(message: Message) {", "    try {\n      await this.validate(message, 'help');\n      const commands = Object.keys(ALL_COMMANDS);\n      message.reply(\n        `Type: ${this.bot.prefix}<command> \\n\\nAll Commands:\\n${commands.join(\n          '\\n'\n        )}`\n      );\n    } catch (err) {\n      await this.sendCommandError(err, message);\n    }\n  }\n}\n", "    } catch (err) {\n      await this.sendCommandError(err, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-search.ts", "chunked_list": ["import { Message } from 'discord.js';\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\n\nexport class Search extends Command {\n  name = 'search';\n  constructor(bot: MarliMusic) {\n    super(bot);\n  }\n  async execute(message: Message, input: string) {\n    try {\n      await this.validate(message, input);\n      const source = this.getSourceStream();\n      const searchResult = await source.search(message.content);\n      const limited = searchResult.slice(0, 10);\n      await message.reply(\n        limited\n          .map(\n            (item, index) =>\n              `\\n${index + 1} - ${item.title} - ${item.duration} - ${item.url}`\n          )\n          .join(' ')\n      );", "    try {\n      await this.validate(message, input);\n      const source = this.getSourceStream();\n      const searchResult = await source.search(message.content);\n      const limited = searchResult.slice(0, 10);\n      await message.reply(\n        limited\n          .map(\n            (item, index) =>\n              `\\n${index + 1} - ${item.title} - ${item.duration} - ${item.url}`\n          )\n          .join(' ')\n      );", "    } catch (err) {\n      await this.sendCommandError(err, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-stop.ts", "chunked_list": ["import { Message } from 'discord.js';\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\n\nexport class Stop extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'stop';\n  }\n  async execute(message: Message): Promise<void> {", "    try {\n      await this.validate(message, 'stop');\n      const connectionID = message.member.voice.channelId;\n      const player = this.getPlayer(connectionID);\n      const queue = this.getQueue();\n      player.stop();\n      queue.clear(connectionID);\n      this.removePlayer(connectionID);\n      this.getConnection(message).destroy();\n\n      await message.reply(BOT_MESSAGES.PLAYLIST_ENDED);", "    } catch (err) {\n      await this.sendCommandError(err, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-play.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { StreamInfo } from '@/sources/source-stream';\nimport { AudioPlayerStatus, joinVoiceChannel } from '@discordjs/voice';\n\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\nimport { PlayHook } from './hooks/command-play-hook';\n\nexport class Play extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'play';\n  }\n  async execute(message: Message, input: string) {", "import { PlayHook } from './hooks/command-play-hook';\n\nexport class Play extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'play';\n  }\n  async execute(message: Message, input: string) {\n    try {\n      await this.validate(message, input);\n\n      const voiceMember = message.member.voice;\n\n      const connection = joinVoiceChannel({\n        adapterCreator: voiceMember.guild.voiceAdapterCreator,\n        channelId: voiceMember.channelId,\n        guildId: String(voiceMember.guild.id),\n      });\n\n      const source = this.getSourceStream();\n\n      const queue = this.getQueue();\n\n      const searchedStream = await source.getStreamFromUrl(input);\n\n      const streamInfoCollection =\n        searchedStream ??\n        ((await source.search(input, { limit: 1 })) as StreamInfo[]);\n\n      streamInfoCollection.forEach((streamInfo: StreamInfo) => {\n        queue.add(voiceMember.channelId, {\n          streamInfo,\n          userSearch: input,\n        });\n      });\n\n      const firstSong = streamInfoCollection.shift();\n\n      const player = this.getPlayer(voiceMember.channelId);\n      connection.subscribe(player);\n\n      let replyContent = `${message.author.username} ${BOT_MESSAGES.PUSHED_TO_QUEUE} ${firstSong.title} - ${firstSong.artist}`;\n", "    try {\n      await this.validate(message, input);\n\n      const voiceMember = message.member.voice;\n\n      const connection = joinVoiceChannel({\n        adapterCreator: voiceMember.guild.voiceAdapterCreator,\n        channelId: voiceMember.channelId,\n        guildId: String(voiceMember.guild.id),\n      });\n\n      const source = this.getSourceStream();\n\n      const queue = this.getQueue();\n\n      const searchedStream = await source.getStreamFromUrl(input);\n\n      const streamInfoCollection =\n        searchedStream ??\n        ((await source.search(input, { limit: 1 })) as StreamInfo[]);\n\n      streamInfoCollection.forEach((streamInfo: StreamInfo) => {\n        queue.add(voiceMember.channelId, {\n          streamInfo,\n          userSearch: input,\n        });\n      });\n\n      const firstSong = streamInfoCollection.shift();\n\n      const player = this.getPlayer(voiceMember.channelId);\n      connection.subscribe(player);\n\n      let replyContent = `${message.author.username} ${BOT_MESSAGES.PUSHED_TO_QUEUE} ${firstSong.title} - ${firstSong.artist}`;\n", "      if (player.state.status === AudioPlayerStatus.Idle) {\n        const searchResultUrl =\n          firstSong?.url ??\n          (await this.getResourceUrl(firstSong.title, firstSong.artist));\n\n        player.play(await this.getAudioResource(searchResultUrl));\n\n        const playHook = new PlayHook(this.bot);\n\n        playHook.execute(message);\n\n        replyContent = `${message.author.username} ${BOT_MESSAGES.CURRENT_PLAYING} ${firstSong.title} - ${firstSong.artist}`;\n      }\n\n      await message.channel.send(replyContent);", "    } catch (err) {\n      await this.sendCommandError(err, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-pause.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\n\nexport class Pause extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'pause';\n  }\n  async execute(message: Message): Promise<void> {", "    try {\n      await this.validate(message, 'pause');\n      const connectionID = message.member.voice.channelId;\n      const player = this.getPlayer(connectionID);\n      player.pause();\n      await message.reply({\n        content: `${message.author.username} ${BOT_MESSAGES.MUSIC_PAUSED}`,\n      });\n    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n", "    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-shuffle.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { MarliMusic } from '@/bot/marli-music';\n\nimport { Command } from './command';\nimport { ListQueue } from './command-list-queue';\n\nexport class Shuffle extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'shuffle';\n  }\n\n  async execute(message: Message<boolean>): Promise<void> {", "    try {\n      await this.validate(message, 'shuffle');\n      this.getQueue().shuffle(message.member.voice.channelId);\n      new ListQueue(this.bot).execute(message);\n    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-list-queue.ts", "chunked_list": ["import { Message } from 'discord.js';\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { Command } from './command';\nimport { MarliMusic } from '../marli-music';\nimport { fragmentContent } from '@/helpers/helpers';\n\nexport class ListQueue extends Command {\n  async execute(message: Message<boolean>): Promise<void> {\n    try {\n      await this.validate(message, 'list');\n      const connectionID = message.member.voice.channelId;\n      const queue = this.getQueue();\n      const queueList = queue.getList(connectionID);\n", "    try {\n      await this.validate(message, 'list');\n      const connectionID = message.member.voice.channelId;\n      const queue = this.getQueue();\n      const queueList = queue.getList(connectionID);\n\n      if (!queueList?.length) {\n        message.reply(BOT_MESSAGES.PLAYLIST_EMPTY);\n        return;\n      }\n\n      const itemsToShow = queueList\n        .map(\n          (item, index) =>\n            `\\n${index + 1} - ${item.streamInfo.title} - ${\n              item.streamInfo.artist\n            }\\t`\n        )\n        .join('');\n\n      fragmentContent(\n        itemsToShow,\n        MarliMusic.MAX_REPLY_CONTENT_LENGTH,\n        '\\t'\n      ).forEach(async (fragment) => {\n        await message.reply(fragment);\n      });", "    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-map.ts", "chunked_list": ["import { CommandHelp } from './command-help';\nimport { ListQueue } from './command-list-queue';\nimport { Pause } from './command-pause';\nimport { Play } from './command-play';\nimport { Resume } from './command-resume';\nimport { Search } from './command-search';\nimport { Skip } from './command-skip';\nimport { Stop } from './command-stop';\nimport { Shuffle } from './command-shuffle';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any", "import { Shuffle } from './command-shuffle';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const ALL_COMMANDS: Record<string, any> = {\n  search: Search,\n  play: Play,\n  pause: Pause,\n  resume: Resume,\n  skip: Skip,\n  stop: Stop,\n  queue: ListQueue,", "  stop: Stop,\n  queue: ListQueue,\n  help: CommandHelp,\n  shuffle: Shuffle,\n};\n"]}
{"filename": "src/bot/commands/index.ts", "chunked_list": ["export { ALL_COMMANDS } from './command-map';\nexport { Play } from './command-play';\nexport { Pause } from './command-pause';\nexport { Resume } from './command-resume';\nexport { Search } from './command-search';\nexport { Stop } from './command-stop';\nexport { Skip } from './command-skip';\nexport { Command } from './command';\nexport { ListQueue } from './command-list-queue';\nexport { CommandHelp } from './command-help';", "export { ListQueue } from './command-list-queue';\nexport { CommandHelp } from './command-help';\nexport { Shuffle } from './command-shuffle';\n"]}
{"filename": "src/bot/commands/command-skip.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\nimport { Stop } from './command-stop';\n\nexport class Skip extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'skip';\n  }\n  async execute(message: Message) {", "    try {\n      await this.validate(message, 'skip');\n      const connectionID = message.member.voice.channelId;\n      const player = this.getPlayer(connectionID);\n      const queue = this.getQueue();\n      const playlist = queue.getList(connectionID);\n      if (playlist?.length > 1) {\n        const next = playlist[1];\n\n        if (!next.streamInfo?.url) {\n          next.streamInfo.url = await this.getResourceUrl(\n            next.streamInfo.title,\n            next.streamInfo.artist\n          );\n        }\n\n        const audioResource = await this.getAudioResource(next.streamInfo.url);\n\n        await message.reply(\n          `${BOT_MESSAGES.MUSIC_SKIPPED} ${next.streamInfo.title} - ${next.streamInfo.artist}`\n        );\n        player.play(audioResource);\n        queue.pop(connectionID);\n      } else {\n        player.removeAllListeners();\n        const stop = new Stop(this.bot);\n        await stop.execute(message);\n      }", "        if (!next.streamInfo?.url) {\n          next.streamInfo.url = await this.getResourceUrl(\n            next.streamInfo.title,\n            next.streamInfo.artist\n          );\n        }\n\n        const audioResource = await this.getAudioResource(next.streamInfo.url);\n\n        await message.reply(\n          `${BOT_MESSAGES.MUSIC_SKIPPED} ${next.streamInfo.title} - ${next.streamInfo.artist}`\n        );\n        player.play(audioResource);\n        queue.pop(connectionID);\n      } else {\n        player.removeAllListeners();\n        const stop = new Stop(this.bot);\n        await stop.execute(message);\n      }", "    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command-resume.ts", "chunked_list": ["import { Message } from 'discord.js';\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { MarliMusic } from '../marli-music';\nimport { Command } from './command';\n\nexport class Resume extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n    this.name = 'resume';\n  }\n  async execute(message: Message): Promise<void> {", "    try {\n      await this.validate(message, 'resume');\n      const connectionID = message.member.voice.channelId;\n      const player = this.getPlayer(connectionID);\n      player.unpause();\n      await message.reply({\n        content: `${message.author.username} ${BOT_MESSAGES.MUSIC_RESUMED}`,\n      });\n    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n", "    } catch (error) {\n      await this.sendCommandError(error, message);\n    }\n  }\n}\n"]}
{"filename": "src/bot/commands/command.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { sentryCapture } from '@/config/sentry';\nimport { logger } from '@/config/winston';\nimport { BotError, ERRORS } from '@/shared/errors';\nimport {\n  AudioPlayer,\n  createAudioResource,\n  getVoiceConnection,\n  StreamType,", "  getVoiceConnection,\n  StreamType,\n} from '@discordjs/voice';\n\nimport { BOT_MESSAGES } from '../containts/default-messages';\nimport { MarliMusic } from '../marli-music';\n\nexport abstract class Command {\n  name: string;\n\n  constructor(protected bot: MarliMusic) {}\n\n  abstract execute(message: Message, input?: string): Promise<void>;\n\n  async getAudioResource(url: string) {\n    const source = this.getSourceStream();\n\n    const stream = await source.getStream(url);\n\n    return createAudioResource(stream, {\n      inputType: StreamType.Opus,\n    });\n  }\n\n  async getResourceUrl(title: string, artist: string) {\n    const source = this.getSourceStream();\n\n    const search = (\n      await source.search(`${title} ${artist}`, {\n        limit: 1,\n      })\n    ).shift();\n\n    return search.url;\n  }\n\n  getPlayer(connectionID: string): AudioPlayer {\n    return this.bot.getPlayer(connectionID);\n  }\n\n  removePlayer(connectionID: string) {\n    this.bot.removePlayer(connectionID);\n  }\n\n  getQueue() {\n    return this.bot.queue;\n  }\n\n  getSourceStream() {\n    return this.bot.sourceStream;\n  }\n\n  public getConnection(message: Message) {\n    return getVoiceConnection(message.member.voice.guild.id);\n  }\n\n  async validate(message: Message, input: string): Promise<boolean> {\n    const voiceChannel = message.member.voice.channel;", "    if (!voiceChannel) {\n      throw new BotError(\n        ERRORS.INVALID_COMMAND_USAGE,\n        BOT_MESSAGES.NOT_IN_A_VOICE_CHANNEL\n      );\n    }\n\n    const permissions = voiceChannel.permissionsFor(message.client.user);\n\n    if (!permissions.has('Connect') || !permissions.has('Speak')) {\n      throw new BotError(\n        ERRORS.INVALID_COMMAND_USAGE,\n        BOT_MESSAGES.NO_PERMISSION_JOIN_SPEAK\n      );\n    }\n", "    if (!permissions.has('Connect') || !permissions.has('Speak')) {\n      throw new BotError(\n        ERRORS.INVALID_COMMAND_USAGE,\n        BOT_MESSAGES.NO_PERMISSION_JOIN_SPEAK\n      );\n    }\n\n    if (!input.length) {\n      throw new BotError(\n        ERRORS.INVALID_COMMAND_USAGE,\n        BOT_MESSAGES.INVALID_INPUT_MESSAGE\n      );\n    }\n\n    return true;\n  }\n\n  async sendCommandError(error: BotError, message: Message) {\n    logger.debug('error', error.stack, error);\n    await message.reply({\n      content: error.userMessage || BOT_MESSAGES.BOT_ERROR,\n    });\n    sentryCapture(ERRORS.RESOURCE_ERROR, error);\n  }\n}\n"]}
{"filename": "src/bot/commands/hooks/command-play-hook.ts", "chunked_list": ["import { Message } from 'discord.js';\n\nimport { BOT_MESSAGES } from '@/bot/containts/default-messages';\nimport { MarliMusic } from '@/bot/marli-music';\nimport { logger } from '@/config/winston';\nimport { BotError } from '@/shared/errors';\nimport { AudioPlayerStatus, VoiceConnectionStatus } from '@discordjs/voice';\n\nimport { Command } from '../command';\nimport { Skip } from '../command-skip';", "import { Command } from '../command';\nimport { Skip } from '../command-skip';\n\nexport class PlayHook extends Command {\n  constructor(bot: MarliMusic) {\n    super(bot);\n  }\n\n  async execute(message: Message) {\n    const connectionID = message.member.voice.channelId;\n    const player = this.getPlayer(connectionID);\n    const connection = this.getConnection(message);\n\n    player.on('error', async (error: Error) => {\n      await this.sendCommandError(\n        new BotError(error.stack, BOT_MESSAGES.BOT_ERROR),\n        message\n      );\n    });\n\n    player.on(AudioPlayerStatus.Idle, async () => {\n      const skip = new Skip(this.bot);\n      await skip.execute(message);\n    });\n\n    connection.on('error', async (error: Error) => {\n      await this.sendCommandError(\n        new BotError(error.stack, BOT_MESSAGES.BOT_ERROR),\n        message\n      );\n    });\n\n    connection.on(VoiceConnectionStatus.Disconnected, () => {\n      logger.log('info', 'disconnect');\n      connection.destroy();\n      const connectionID = message.member.voice.channelId;\n      this.removePlayer(connectionID);\n    });\n  }\n}\n"]}
{"filename": "src/bot/containts/default-messages.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst INVALID_COMMAND = process.env.INVALID_COMMAND || 'INVALID COMMAND';\nconst NOT_IN_A_VOICE_CHANNEL =\n  process.env.NOT_IN_A_VOICE_CHANNEL || `YOU'RE NOT IN A VOICE CHANNEL`;\nconst NO_PERMISSION_JOIN_SPEAK =\n  process.env.NO_PERMISSION_JOIN_SPEAK ||\n  'I HAVE NO PERMISSION TO JOIN OR SPEAK';", "  process.env.NO_PERMISSION_JOIN_SPEAK ||\n  'I HAVE NO PERMISSION TO JOIN OR SPEAK';\nconst INVALID_INPUT_MESSAGE =\n  process.env.INVALID_INPUT_MESSAGE || 'INVALID INPUT MESSAGE';\nconst CURRENT_PLAYING = process.env.CURRENT_PLAYING || \"NOW WE'RE PLAYING\";\nconst MUSIC_PAUSED = process.env.MUSIC_STOPPED || 'PAUSED THE MUSIC';\nconst MUSIC_STOPPED = process.env.MUSIC_STOPPED || 'STOPPED THE MUSIC';\nconst MUSIC_RESUMED = process.env.MUSIC_RESUMED || 'RESUMED THE MUSIC';\nconst PUSHED_TO_QUEUE =\n  process.env.PUSHED_TO_QUEUE || 'ADDED A SONG TO THE QUEUE';", "const PUSHED_TO_QUEUE =\n  process.env.PUSHED_TO_QUEUE || 'ADDED A SONG TO THE QUEUE';\nconst MUSIC_SKIPPED = process.env.MUSIC_SKIPPED || 'SKIPPED THE MUSIC';\nconst PLAYLIST_ENDED = process.env.PLAYLIST_ENDED || 'PLAYLIST ENDED';\nconst PLAYLIST_ITEMS = process.env.PLAYLIST_ITEMS || 'PLAYLIST ITEMS';\nconst PLAYLIST_EMPTY = process.env.PLAYLIST_EMPTY || 'PLAYLIST EMPTY';\nconst BOT_ERROR = process.env.BOT_ERROR || 'FAILED TO EXECUTE COMMAND';\n\nexport const BOT_MESSAGES = {\n  CURRENT_PLAYING,", "export const BOT_MESSAGES = {\n  CURRENT_PLAYING,\n  INVALID_COMMAND,\n  INVALID_INPUT_MESSAGE,\n  MUSIC_PAUSED,\n  MUSIC_RESUMED,\n  MUSIC_SKIPPED,\n  MUSIC_STOPPED,\n  NOT_IN_A_VOICE_CHANNEL,\n  NO_PERMISSION_JOIN_SPEAK,", "  NOT_IN_A_VOICE_CHANNEL,\n  NO_PERMISSION_JOIN_SPEAK,\n  PLAYLIST_ENDED,\n  PUSHED_TO_QUEUE,\n  PLAYLIST_ITEMS,\n  PLAYLIST_EMPTY,\n  BOT_ERROR,\n};\n", ""]}
{"filename": "src/shared/errors.ts", "chunked_list": ["export enum ERRORS {\n  NO_SEARCHER_ENGINE = 'NO SEARCH ENGINE SETUP',\n  RESULT_NOT_FOUND = 'Result NOT FOUND',\n  RESOURCE_ERROR = 'RESOURCE ERROR',\n  SUBSCRIPTION_ERROR = 'SUBSCRIPTION ERROR',\n  BOT_STARTUP_ERROR = 'ERROR ON BOT STARTUP',\n  INVALID_URL = 'INVALID URL ERROR',\n  INVALID_COMMAND = 'INVALID COMMAND ERROR',\n  INVALID_COMMAND_USAGE = 'INVALID COMMAND USAGE ERROR',\n}\n", "export enum STATUS_CODES {\n  OK = 200,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  INTERNAL_SERVER_ERROR = 500,\n}\n\nexport class BotError extends Error {\n  public code: STATUS_CODES;\n  public constructor(public message: string, public userMessage: string) {\n    super(message);\n  }\n}\n", "export class BotError extends Error {\n  public code: STATUS_CODES;\n  public constructor(public message: string, public userMessage: string) {\n    super(message);\n  }\n}\n"]}
{"filename": "src/http/index.ts", "chunked_list": ["import express, { Application } from 'express';\nimport { Server } from 'http';\n\nimport { logger } from '../config/winston';\nimport { mainRouter } from './routes';\n\nconst appServer: Application = express();\nlet httpServer: Server;\n\nfunction startServer() {\n  const port = process.env.PORT || 3000;\n  appServer.use('/', mainRouter);\n  httpServer = appServer.listen(port, () => {\n    logger.log('info', `Server listening to: ${port}`);\n  });\n}\n\nexport { appServer, httpServer, startServer };\n", "\nfunction startServer() {\n  const port = process.env.PORT || 3000;\n  appServer.use('/', mainRouter);\n  httpServer = appServer.listen(port, () => {\n    logger.log('info', `Server listening to: ${port}`);\n  });\n}\n\nexport { appServer, httpServer, startServer };\n"]}
{"filename": "src/http/routes/index.ts", "chunked_list": ["import { NextFunction, Request, Response, Router } from 'express';\nimport { join } from 'path';\n\nimport { logger } from '@/config/winston';\n\nconst mainRouter: Router = Router();\n\nmainRouter.get(\n  '/',\n  (_request: Request, response: Response, next: NextFunction) => {", "  '/',\n  (_request: Request, response: Response, next: NextFunction) => {\n    const options = {\n      root: join('public'),\n    };\n    return response.sendFile('index.html', options, (err) => {\n      if (err) {\n        next();\n        logger.log('error', err.message);\n      }\n    });\n  }\n);\n\nmainRouter.post('/health-check', (_request: Request, response: Response) => {\n  return response.json({\n    message: 'Ok',\n  });\n});\n\nexport { mainRouter };\n"]}
{"filename": "src/queue/queue.ts", "chunked_list": ["import { StreamInfo } from '@/sources/source-stream';\n\nimport { shuffleArray } from '../helpers/helpers';\n\nexport interface QueueData {\n  streamInfo: StreamInfo;\n  userSearch: string;\n}\n\nexport abstract class Queue {\n  items: Map<string, QueueData[]> = new Map();\n\n  abstract getList(connection: string): QueueData[];\n\n  abstract add(connection: string, value: QueueData): void;\n\n  abstract pop(connection: string): void;\n\n  abstract clear(connection: string): void;\n\n  abstract shuffle(connection: string): void;\n}\n", "export abstract class Queue {\n  items: Map<string, QueueData[]> = new Map();\n\n  abstract getList(connection: string): QueueData[];\n\n  abstract add(connection: string, value: QueueData): void;\n\n  abstract pop(connection: string): void;\n\n  abstract clear(connection: string): void;\n\n  abstract shuffle(connection: string): void;\n}\n", "export class LocalQueue extends Queue {\n  constructor() {\n    super();\n  }\n\n  getList(connectionID: string): QueueData[] {\n    return this.items.get(connectionID) || [];\n  }\n\n  add(connectionID: string, value: QueueData) {\n    const connectionItems = this.getList(connectionID);\n    connectionItems.push(value);\n    this.items.set(connectionID, connectionItems);\n  }\n\n  pop(connectionID: string) {\n    const connectionItems = this.getList(connectionID);\n    connectionItems.shift();\n    this.items.set(connectionID, connectionItems);\n  }\n\n  clear(connectionID: string): void {\n    this.items.delete(connectionID);\n  }\n\n  shuffle(connectionID: string): void {\n    const list = this.getList(connectionID);\n\n    const shuffledList = shuffleArray<QueueData>(list);\n\n    this.items.set(connectionID, shuffledList);\n  }\n}\n"]}
