{"filename": "src/index.ts", "chunked_list": ["import cors from \"cors\";\nimport express from \"express\";\nimport session from \"express-session\";\nimport helmet from \"helmet\";\nimport createError from \"http-errors\";\nimport passport from \"passport\";\nimport { PrismaSessionStore } from \"@quixo3/prisma-session-store\";\nimport { prisma } from \"./utils/prismaClient\";\nimport route from \"./router\";\nimport connectDB from \"./utils/prismaClient\";", "import route from \"./router\";\nimport connectDB from \"./utils/prismaClient\";\n\nimport type { ErrorType } from \"./types\";\nimport type { NextFunction, Request, Response } from \"express\";\n\nimport(\"./middlewares/passport\");\nimport(\"./middlewares/passportGoogleSSO\");\nimport(\"./middlewares/passportFacebookSSO\");\n", "import(\"./middlewares/passportFacebookSSO\");\n\nconst app = express();\nconst PORT = process.env.PORT || 5001;\n\nif (process.env.NODE_ENV === \"production\") {\n  app.set(\"trust proxy\", 1); // trust first proxy\n}\n\napp.use(\n  session({\n    secret: `${process.env.COOKIE_SECRET}`,\n    resave: true,\n    cookie: {\n      sameSite: process.env.NODE_ENV === \"production\" ? \"none\" : false,\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days (ms)\n      httpOnly: true,\n      secure: process.env.NODE_ENV === \"production\", //development can't serve https (SSL)\n    },\n    //@ts-ignore\n    //we need store session, because it will leak memory under most conditions if\n    //store on memory and the sever can down or break,...\n    store: new PrismaSessionStore(prisma, {\n      checkPeriod: 2 * 60 * 1000, // 2m (ms) => PrismaSessionStore will automatically remove expired sessions\n      dbRecordIdIsSessionId: true,\n      dbRecordIdFunction: undefined,\n    }),\n  })\n);\n\napp.use(cors({ credentials: true, origin: `${process.env.CLIENT_URL}` }));\napp.use(helmet());\napp.use(express.json());\n\n//passport middleware:\napp.use(passport.initialize());\n\n// we don't need passport deserializeUser every route\n// just need for auth route\napp.use((req, res, next) => {", "  if (req.url.match(\"/api/words\") || req.url.match(\"/api/service\")) {\n    console.log(\"run next\");\n    next();\n  } else {\n    console.log(\"handle cookie\");\n    passport.session()(req, res, next);\n  }\n});\n\n//db connection info\n(async function () {\n  await connectDB();\n})();\n\n//routers\nroute(app);\n\napp.get(\"/\", (req, res) => {\n  res.json({\n    message: \"\ud83e\udd84\ud83c\udf08\u2728\ud83d\udc4b\ud83c\udf0e\ud83c\udf0d\ud83c\udf0f\u2728\ud83c\udf08\ud83e\udd84\",\n  });\n});\n\n//catch 404\napp.use((req: Request, res: Response, next: NextFunction) => {\n  next(createError(404, \"404 Not Found!\"));\n});\n\n//error handler\napp.use((err: ErrorType, req: Request, res: Response, next: NextFunction) => {\n  const error: ErrorType =\n    app.get(\"env\") === \"development\" ? err : ({} as ErrorType);\n  const status: number = err.status || 500;\n\n  console.log(\n    `${req.url} --- ${req.method} --- ${JSON.stringify({\n      message: error.message,\n    })}`\n  );\n  return res.status(status).json({\n    status,\n    message: error.message,\n  });\n});\n\napp.listen(PORT, () =>\n  console.log(`\ud83d\ude80 Server ready at: http://localhost:${PORT}`)\n);\n"]}
{"filename": "src/libs/google.dictionary.ts", "chunked_list": ["import axios from \"axios\";\nimport { translate } from \"@vitalets/google-translate-api\";\n\nexport async function googleTranslate({\n  text,\n  target_language,\n  source_language,\n}: {\n  text: string;\n  target_language: string;\n  source_language: string;\n}) {", "  try {\n    const { text: textTranslated } = await translate(text, {\n      to: target_language,\n    });\n\n    return textTranslated;\n  } catch (error) {\n    try {\n      //fallback rate limit:\n      console.log(\"-- RATE LIMIT AND CALL RAPID API HOST FALLBACK --\");\n      const encodedParams = new URLSearchParams();\n      encodedParams.append(\"source_language\", source_language);\n      encodedParams.append(\"target_language\", target_language);\n      encodedParams.append(\"text\", text);\n\n      const options = {\n        method: \"POST\",\n        url: `${process.env.TRANSLATE_URL}`,\n        headers: {\n          \"content-type\": \"application/x-www-form-urlencoded\",\n          \"X-RapidAPI-Key\": `${process.env.RAPID_API_KEY}`,\n          \"X-RapidAPI-Host\": `${process.env.RAPID_API_HOST}`,\n        },\n        data: encodedParams,\n      };\n\n      const { data } = await axios.request(options);\n\n      return await data.data.translatedText;", "    } catch (error) {\n      console.error(\"GOOGLE TRANSLATE ERROR: \", error);\n    }\n  }\n}\n"]}
{"filename": "src/libs/oxford.dictionary.ts", "chunked_list": ["import { OXFORD_DICTIONARY_URL } from \"../configs\";\nimport type { Language } from \"../types\";\nimport axios from \"axios\";\nimport { parse } from \"node-html-parser\";\n\nexport async function getAudioOxford({ word }: { word: string }) {\n  let phonetics;\n\n  try {\n    const raw_phonetics = await (\n      await axios.get(`${OXFORD_DICTIONARY_URL}/definition/english/${word}`)\n    ).data;\n\n    const document = parse(raw_phonetics);\n\n    phonetics = document\n      .querySelectorAll(\".phonetics > div\")\n      ?.map((div, idx) => {\n        return {\n          phrase: div.querySelector(\".phon\")?.textContent,\n          author: `OxfordDictionary_${idx === 0 ? \"English\" : \"American\"}`,\n          url: div.querySelector(\".sound\")?.getAttribute(\"data-src-mp3\"),\n        };\n      });\n\n    return phonetics ? phonetics.slice(0, 2) : phonetics;", "  try {\n    const raw_phonetics = await (\n      await axios.get(`${OXFORD_DICTIONARY_URL}/definition/english/${word}`)\n    ).data;\n\n    const document = parse(raw_phonetics);\n\n    phonetics = document\n      .querySelectorAll(\".phonetics > div\")\n      ?.map((div, idx) => {\n        return {\n          phrase: div.querySelector(\".phon\")?.textContent,\n          author: `OxfordDictionary_${idx === 0 ? \"English\" : \"American\"}`,\n          url: div.querySelector(\".sound\")?.getAttribute(\"data-src-mp3\"),\n        };\n      });\n\n    return phonetics ? phonetics.slice(0, 2) : phonetics;", "  } catch (error) {\n    console.error(\"get audio oxford error: \", error);\n  }\n\n  return phonetics;\n}\n\nexport async function translateOxford({ word }: { word: string }) {\n  try {\n    const rawData = await (\n      await axios.get(`${OXFORD_DICTIONARY_URL}/definition/english/${word}`)\n    ).data;\n\n    const document = parse(rawData);\n\n    const wordContent = document.querySelector(`#${word}_h_1`)?.textContent;\n", "  try {\n    const rawData = await (\n      await axios.get(`${OXFORD_DICTIONARY_URL}/definition/english/${word}`)\n    ).data;\n\n    const document = parse(rawData);\n\n    const wordContent = document.querySelector(`#${word}_h_1`)?.textContent;\n\n    if (!wordContent) throw new Error();\n\n    const typesOfWord = document.querySelector(`span.pos`)?.textContent;\n\n    const senses = document.querySelectorAll(\"span.def\").map((span, index) => {\n      const examples = document\n        .querySelectorAll(`#${word}_sng_${index + 1} > ul > li`)\n        .map((li) => li?.textContent);\n\n      return { sense: span?.textContent, typeOfWord: typesOfWord, examples };\n    });\n\n    return {\n      wordContent,\n      typesOfWord: [typesOfWord],\n      senses,\n    };", "    if (!wordContent) throw new Error();\n\n    const typesOfWord = document.querySelector(`span.pos`)?.textContent;\n\n    const senses = document.querySelectorAll(\"span.def\").map((span, index) => {\n      const examples = document\n        .querySelectorAll(`#${word}_sng_${index + 1} > ul > li`)\n        .map((li) => li?.textContent);\n\n      return { sense: span?.textContent, typeOfWord: typesOfWord, examples };\n    });\n\n    return {\n      wordContent,\n      typesOfWord: [typesOfWord],\n      senses,\n    };", "  } catch (error) {\n    console.log(\"translateOxford error: \", error);\n    return null;\n  }\n}\n"]}
{"filename": "src/libs/glosbe.dictionary.ts", "chunked_list": ["import axios from \"axios\";\nimport { GLOSBE_URL, GLOSBE_TRANSLATOR_API } from \"../configs\";\nimport type { Language } from \"../types\";\nimport { parse } from \"node-html-parser\";\nimport { normalizeString } from \"../utils/string\";\nimport { translate } from \"@vitalets/google-translate-api\";\nimport { googleTranslate } from \"./google.dictionary\";\n\nexport async function getAudioGlosbe({\n  format,\n  word,\n}: {\n  format: Language;\n  word: string;\n}) {\n  let raw_phonetics;\n  let phonetics;\n", "export async function getAudioGlosbe({\n  format,\n  word,\n}: {\n  format: Language;\n  word: string;\n}) {\n  let raw_phonetics;\n  let phonetics;\n\n  try {\n    raw_phonetics = await (\n      await axios.get(`${GLOSBE_URL}/api/audios/${format}/${word}`)\n    ).data;\n\n    phonetics = raw_phonetics?.phraseAudioCarrier?.audioEntries?.map(\n      (entry: any) => {\n        return {\n          phrase: entry.phrase,\n          author: entry.author.name,\n          url: `${GLOSBE_URL}/fb_aud/mp3/${entry.url.mp3}`,\n        };\n      }\n    );", "  try {\n    raw_phonetics = await (\n      await axios.get(`${GLOSBE_URL}/api/audios/${format}/${word}`)\n    ).data;\n\n    phonetics = raw_phonetics?.phraseAudioCarrier?.audioEntries?.map(\n      (entry: any) => {\n        return {\n          phrase: entry.phrase,\n          author: entry.author.name,\n          url: `${GLOSBE_URL}/fb_aud/mp3/${entry.url.mp3}`,\n        };\n      }\n    );", "  } catch (error) {\n    console.error(\"get audio glosbe error: \", error);\n  }\n\n  return phonetics;\n}\n\nexport async function translateWordGlosbe({\n  language_1,\n  language_2,\n  word,\n}: {\n  language_1: Language;\n  language_2: Language;\n  word: string;\n}) {", "  try {\n    const raw = await (\n      await axios.get(`${GLOSBE_URL}/${language_1}/${language_2}/${word}`)\n    ).data;\n\n    //@ts-ignore\n    const document = parse(raw);\n\n    const wordContent = document.querySelector(\"span.break-words\")?.textContent;\n    const typesOfWord = document\n      .querySelectorAll(\n        \"#phraseDetails_activator-0 > div.text-xl.text-gray-900.px-1.pb-1 > span.text-xxs.text-gray-500 > span\"\n      )\n      .map((e) => e?.textContent);\n    const senses = document\n      .querySelectorAll(\n        \"#dictionary-content > article > div > div > section.bg-white.px-1 > div.pl-1 > div > ul.pr-1 > li\"\n      )\n      .map((li) => {\n        const sense = li.querySelector(\"h3\")?.textContent;\n        const typeOfWord = li.querySelector(\n          \"span.text-xxs.text-gray-500 > span\"\n        )?.textContent;\n        const topic = li.querySelector(\"div.py-1 > p > span\");\n\n        // check if word has example or not:\n        const example = li.querySelector(\"div > p.dir-aware-pr-1\")\n          ? {\n              [language_1]: normalizeString(\n                String(li.querySelector(\"div > p.dir-aware-pr-1\")?.textContent)\n              ),\n              [language_2]: normalizeString(\n                String(li.querySelector(\"div > p.px-1.ml-2\")?.textContent)\n              ),\n            }\n          : undefined;\n\n        return {\n          sense,\n          typeOfWord,\n          category: topic ? normalizeString(String(topic).trim()) : undefined,\n          example,\n        };\n      });\n\n    const less_frequent_senses = document\n      .querySelectorAll(\n        \"#less-frequent-translations-container-0 > li > div:nth-child(2) > ul > li\"\n      )\n      .map((li) => li?.textContent);\n\n    const similar_phrases = document\n      .querySelectorAll(\"#simmilar-phrases > ul > li\")\n      .map((li) => {\n        return {\n          [language_1]: li.querySelector(\"a\")?.textContent,\n          [language_2]: normalizeString(\n            String(li.querySelector(\".dir-aware-pl-2\")?.textContent)\n          ),\n        };\n      });\n\n    const examples = document\n      .querySelectorAll(\n        \"#tmem_first_examples > div.px-1.text-sm.text-gray-900.break-words > div > div.py-2.flex\"\n      )\n      .map((div) => {\n        return {\n          [language_1]: normalizeString(\n            String(div.querySelector(\"div:nth-child(1)\")?.textContent)\n          ),\n          [`keyword_${language_1}`]: div.querySelector(\n            \"div:nth-child(1) .keyword\"\n          )\n            ? normalizeString(\n                String(\n                  div.querySelector(\"div:nth-child(1) .keyword\")?.textContent\n                )\n              )\n            : undefined,\n\n          [language_2]: normalizeString(\n            String(div.querySelector(\"div:nth-child(2)\")?.textContent)\n          ),\n          [`keyword_${language_2}`]: div.querySelector(\n            \"div:nth-child(2) .keyword\"\n          )\n            ? normalizeString(\n                String(\n                  div.querySelector(\"div:nth-child(2) .keyword\")?.textContent\n                )\n              )\n            : undefined,\n        };\n      });\n", "    if (typesOfWord && wordContent && senses) {\n      return {\n        wordContent,\n        typesOfWord,\n        senses,\n        less_frequent_senses,\n        similar_phrases,\n        examples,\n      };\n    } else {\n      return null;\n    }", "  } catch (error) {\n    console.log(\"glosbe translate error: \", error);\n    return null;\n  }\n}\n\nexport async function machineTranslation({\n  language_1,\n  language_2,\n  word,\n}: {\n  language_1: Language;\n  language_2: Language;\n  word: string;\n}) {", "  try {\n    const [google] = await Promise.allSettled([\n      // (\n      //   await axios.post(\n      //     `${GLOSBE_TRANSLATOR_API}/translateByLangWithScore?sourceLang=${language_1}&targetLang=${language_2}`,\n      //     word,\n      //     {\n      //       headers: {\n      //         \"Content-Type\": \"text/plain;charset=UTF-8\",\n      //       },\n      //     }\n      //   )\n      // ).data,\n      await googleTranslate({\n        text: word,\n        source_language: language_1,\n        target_language: language_2,\n      }),\n    ]);\n", "    if (google.status === \"fulfilled\") {\n      return { google: google.value };\n    } else {\n      return null;\n    }\n  } catch (error) {\n    console.error(\"machineTranslation error: \", error);\n    return null;\n  }\n}\n", "export async function getGrammarGlosbe({ word }: { word: string }) {\n  // https://vi.glosbe.com/en/vi/straightforward/fragment/details?phraseIndex=0&translationIndex=-1\n  try {\n    const rawData = await (\n      await axios.get(\n        `${GLOSBE_URL}/en/vi/${word}/fragment/details?phraseIndex=0&translationIndex=-1`\n      )\n    ).data;\n\n    const document = parse(rawData);\n\n    const grammars = document\n      .querySelectorAll(\"#grammar_0_-1 > ul > li\")\n      .map((li) => {\n        return li?.textContent;\n      });\n\n    return grammars;", "  } catch (error) {\n    console.log(\"getGrammarGlosbe error: \", error);\n    return null;\n  }\n}\n"]}
{"filename": "src/libs/index.ts", "chunked_list": ["import {\n  getAudioGlosbe,\n  translateWordGlosbe,\n  machineTranslation,\n  getGrammarGlosbe,\n} from \"./glosbe.dictionary\";\nimport { getAudioOxford, translateOxford } from \"./oxford.dictionary\";\nimport { getAudioCambridge, translateCambridge } from \"./cambridge.dictionary\";\n\nexport {", "\nexport {\n  getAudioGlosbe,\n  getAudioOxford,\n  getAudioCambridge,\n  translateWordGlosbe,\n  machineTranslation,\n  translateOxford,\n  translateCambridge,\n  getGrammarGlosbe,", "  translateCambridge,\n  getGrammarGlosbe,\n};\n"]}
{"filename": "src/libs/cambridge.dictionary.ts", "chunked_list": ["import { CAMBRIDGE_DICTIONARY_URL } from \"../configs\";\nimport { parse } from \"node-html-parser\";\nimport axios from \"axios\";\nimport { normalizeString } from \"../utils/string\";\n\nexport async function getAudioCambridge({ word }: { word: string }) {\n  let raw_phonetics;\n  let phonetics;\n\n  try {\n    raw_phonetics = await (\n      await axios.get(\n        `${CAMBRIDGE_DICTIONARY_URL}/vi/dictionary/english/${word}`\n      )\n    ).data;\n\n    const document = parse(raw_phonetics);\n\n    const uk_audio =\n      String(CAMBRIDGE_DICTIONARY_URL) +\n      document.querySelector(\"#audio1 source\")?.getAttribute(\"src\");\n    const uk_phonetic = document.querySelector(\n      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > span.uk.dpron-i > span.pron.dpron\"\n    )?.textContent;\n\n    const raw_us_audio = document\n      .querySelector(\"#audio2 source\")\n      ?.getAttribute(\"src\");\n", "  try {\n    raw_phonetics = await (\n      await axios.get(\n        `${CAMBRIDGE_DICTIONARY_URL}/vi/dictionary/english/${word}`\n      )\n    ).data;\n\n    const document = parse(raw_phonetics);\n\n    const uk_audio =\n      String(CAMBRIDGE_DICTIONARY_URL) +\n      document.querySelector(\"#audio1 source\")?.getAttribute(\"src\");\n    const uk_phonetic = document.querySelector(\n      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > span.uk.dpron-i > span.pron.dpron\"\n    )?.textContent;\n\n    const raw_us_audio = document\n      .querySelector(\"#audio2 source\")\n      ?.getAttribute(\"src\");\n", "    if (!raw_us_audio) return null;\n\n    const us_audio = String(CAMBRIDGE_DICTIONARY_URL) + raw_us_audio;\n\n    const us_phonetic = document.querySelector(\n      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > span.us.dpron-i > span.pron.dpron\"\n    )?.textContent;\n\n    phonetics = [\n      { phrase: uk_phonetic, author: \"Cambridge_English\", url: uk_audio },\n      { phrase: us_phonetic, author: \"Cambridge_American\", url: us_audio },\n    ];", "  } catch (error) {\n    console.error(\"get audio cambridge error: \", error);\n  }\n\n  return phonetics;\n}\n\nexport async function translateCambridge({ word }: { word: string }) {\n  try {\n    const rawData = await (\n      await axios.get(\n        `${CAMBRIDGE_DICTIONARY_URL}/vi/dictionary/english/${word}`\n      )\n    ).data;\n\n    const document = parse(rawData);\n\n    const wordContent = document.querySelector(\n      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > div.di-title > span > span\"\n    )?.textContent;\n", "  try {\n    const rawData = await (\n      await axios.get(\n        `${CAMBRIDGE_DICTIONARY_URL}/vi/dictionary/english/${word}`\n      )\n    ).data;\n\n    const document = parse(rawData);\n\n    const wordContent = document.querySelector(\n      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > div.di-title > span > span\"\n    )?.textContent;\n", "    if (!wordContent) throw new Error();\n\n    const typesOfWord = document\n      .querySelectorAll(\".pr.entry-body__el .pos.dpos\")\n      .map((span) => span?.textContent);\n\n    const senses = document\n      .querySelectorAll(\".pr.entry-body__el\")\n      .map((container) => {\n        const typeOfWord = container.querySelector(\".pos.dpos\")?.textContent;\n        const sense = container.querySelector(\".def.ddef_d.db\")?.textContent;\n        const examples = container\n          .querySelectorAll(\".examp.dexamp\")\n          .map((div) => {\n            return normalizeString(String(div?.textContent));\n          });\n\n        return { typeOfWord, sense, examples };\n      });\n\n    return { wordContent, typesOfWord: [...new Set(typesOfWord)], senses };", "  } catch (error) {\n    console.log(\"translateCambridge error \", error);\n    return null;\n  }\n}\n"]}
{"filename": "src/configs/index.ts", "chunked_list": ["import dotenv from \"dotenv\";\ndotenv.config();\n\nexport const GLOSBE_API = process.env.GLOSBE_API;\nexport const GLOSBE_URL = process.env.GLOSBE_URL;\nexport const GLOSBE_TRANSLATOR_API = process.env.GLOSBE_TRANSLATOR_API;\n\nexport const OXFORD_DICTIONARY_URL = process.env.OXFORD_DICTIONARY_URL;\n\nexport const CAMBRIDGE_DICTIONARY_URL = process.env.CAMBRIDGE_DICTIONARY_URL;", "\nexport const CAMBRIDGE_DICTIONARY_URL = process.env.CAMBRIDGE_DICTIONARY_URL;\n"]}
{"filename": "src/schemas/index.ts", "chunked_list": ["import { z } from \"zod\";\n\nexport const TranslationHistorySchema = z.object({\n  body: z.object({\n    translations_history: z\n      .array(\n        z.object({\n          word: z.string(),\n          sense: z.string(),\n          targetLanguage: z.string(),", "          sense: z.string(),\n          targetLanguage: z.string(),\n          currentLanguage: z.string(),\n        })\n      )\n      .optional(),\n    word: z.string({\n      required_error: \"word is required\",\n    }),\n    sense: z.string({", "    }),\n    sense: z.string({\n      required_error: \"sense is required\",\n    }),\n    targetLanguage: z.string({\n      required_error: \"targetLanguage is required\",\n    }),\n    currentLanguage: z.string({\n      required_error: \"currentLanguage is required\",\n    }),", "      required_error: \"currentLanguage is required\",\n    }),\n  }),\n});\n\nexport const DeleteTranslationHistorySchema = z.object({\n  body: z.object({\n    word: z.string({\n      required_error: \"word is required\",\n    }),", "      required_error: \"word is required\",\n    }),\n    deleteOption: z.string().optional(),\n  }),\n});\n\nexport const FavoriteBodySchema = z.object({\n  body: z.object({\n    word: z.string({ required_error: \"word is required\" }),\n    tag: z.string().optional(),", "    word: z.string({ required_error: \"word is required\" }),\n    tag: z.string().optional(),\n    numberOfDaysToForget: z.number().optional(),\n  }),\n});\n\nexport const FavoriteQuerySchema = z.object({\n  query: z.object({\n    word: z.string({ required_error: \"word is required\" }),\n  }),", "    word: z.string({ required_error: \"word is required\" }),\n  }),\n});\n\nexport const DashboardQuerySchema = z.object({\n  query: z.object({\n    status: z.string({ required_error: \"status is required\" }),\n  }),\n});\n", "});\n\nexport const WordPreviewQuerySchema = z.object({\n  query: z.object({\n    status: z.string({ required_error: \"status is required\" }),\n  }),\n});\n\nexport const PracticeQuerySchema = z.object({\n  query: z.object({", "export const PracticeQuerySchema = z.object({\n  query: z.object({\n    status: z.string({ required_error: \"status is required\" }),\n    tags: z.string({ required_error: \"tags is required\" }),\n  }),\n});\n\nexport const PracticePatchSchema = z.object({\n  body: z.object({\n    wordContent: z.string({ required_error: \"wordContent is required\" }),", "  body: z.object({\n    wordContent: z.string({ required_error: \"wordContent is required\" }),\n    status: z.string({ required_error: \"status is required\" }),\n  }),\n});\n"]}
{"filename": "src/utils/prismaClient.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\nexport const prisma = new PrismaClient();\n\nasync function connectDB() {\n  try {\n    await prisma.$connect();\n    console.log(\"\ud83d\ude80 Database connected successfully\");\n  } catch (error) {\n    console.log(error);\n    process.exit(1);", "  } catch (error) {\n    console.log(error);\n    process.exit(1);\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\nexport default connectDB;\n"]}
{"filename": "src/utils/string.ts", "chunked_list": ["export const normalizeString = (str: string) => {\n  const htmlTagsRegex = /(&nbsp;|<([^>]+)>)/g;\n  return str\n    .trim()\n    .replace(/(\\r\\n|\\n|\\r|\\\")/gm, \"\")\n    .replace(htmlTagsRegex, \"\");\n};\n"]}
{"filename": "src/utils/dbHelper.ts", "chunked_list": ["//@ts-nocheck\nimport { prisma } from \"./prismaClient\";\n// prisma can not nested create in createMany, LMAO:\n// https://github.com/prisma/prisma/issues/5455\nexport async function createManySense(senses, wordId) {\n  await prisma.$transaction(\n    senses.map((e) => {\n      return prisma.sense.create({\n        data: {\n          sense: e.sense,\n          category: e?.category ? e?.category : undefined,\n          example: e?.example\n            ? { create: { en: e.example.en, vi: e.example.vi } }\n            : undefined,\n          typeOfWord: e?.typeOfWord\n            ? {\n                connectOrCreate: {\n                  create: { type: e.typeOfWord },\n                  where: { type: e.typeOfWord },\n                },\n              }\n            : undefined,\n          Word: {\n            connect: { id: wordId },\n          },\n        },\n      });\n    })\n  );\n}\n", "export async function connectTypeOfWord(typesOfWord, word) {\n  await prisma.$transaction(\n    typesOfWord.map((type) => {\n      return prisma.word.update({\n        where: { wordContent: word },\n        data: {\n          typesOfWord: { connect: { type } },\n        },\n      });\n    })\n  );\n}\n"]}
{"filename": "src/utils/getAudio.ts", "chunked_list": ["import { getAudioGlosbe, getAudioOxford, getAudioCambridge } from \"../libs\";\nimport type { Source } from \"../types\";\n\nexport async function getAudioInfo({\n  word,\n  format,\n  source,\n}: {\n  word: string;\n  format: \"en\" | \"vi\";\n  source: Source;\n}) {\n  switch (source) {\n    case \"glosbe\":\n      return await getAudioGlosbe({ format, word });\n    case \"oxford\":\n      return await getAudioOxford({ word });\n    case \"cambridge\":\n      return await getAudioCambridge({ word });\n  }\n}\n"]}
{"filename": "src/constants/index.ts", "chunked_list": [""]}
{"filename": "src/middlewares/zodValidate.ts", "chunked_list": ["import { NextFunction, Request, Response } from \"express\";\nimport { AnyZodObject } from \"zod\";\n\nexport const validate =\n  (schema: AnyZodObject) =>\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      await schema.parseAsync({\n        body: req.body,\n        query: req.query,\n        params: req.params,\n      });\n      return next();", "    } catch (error) {\n      return res.status(400).json(error);\n    }\n  };\n"]}
{"filename": "src/middlewares/passportFacebookSSO.ts", "chunked_list": ["//@ts-nocheck\nimport passport from \"passport\";\nimport passportFacebook from \"passport-facebook\";\nimport { prisma } from \"../utils/prismaClient\";\n\nconst FacebookStrategy = passportFacebook.Strategy;\n\npassport.use(\n  new FacebookStrategy(\n    {", "  new FacebookStrategy(\n    {\n      clientID: `${process.env.FACEBOOK_APP_ID}`,\n      clientSecret: `${process.env.FACEBOOK_APP_SECRET}`,\n      callbackURL: process.env.FACEBOOK_CALLBACK_URL,\n      profileFields: [\"id\", \"displayName\", \"photos\", \"email\"],\n    },\n    async (accessToken, refreshToken, profile, cb) => {\n      try {\n        const user = await prisma.user.upsert({\n          where: { accountId: profile.id },\n          create: {\n            name: `${profile.displayName}`,\n            email: profile.emails[0].value,\n            image: profile.photos[0].value,\n            accountId: profile.id,\n            provider: \"facebook\",\n          },\n          update: {},\n        });\n", "      try {\n        const user = await prisma.user.upsert({\n          where: { accountId: profile.id },\n          create: {\n            name: `${profile.displayName}`,\n            email: profile.emails[0].value,\n            image: profile.photos[0].value,\n            accountId: profile.id,\n            provider: \"facebook\",\n          },\n          update: {},\n        });\n", "        if (user) return cb(null, user);\n      } catch (err) {\n        console.log(\"Error signing up\", err);\n        cb(err, null);\n      }\n    }\n  )\n);\n"]}
{"filename": "src/middlewares/auth.ts", "chunked_list": ["import type { NextFunction, Request, Response } from \"express\";\n\nexport function isUserAuthenticated(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  if (req.user) {\n    next();\n  } else {\n    res.status(403).send(\"You must login first!\");\n  }\n}\n"]}
{"filename": "src/middlewares/passport.ts", "chunked_list": ["import passport from \"passport\";\nimport passportJwt from \"passport-jwt\";\nimport { prisma } from \"../utils/prismaClient\";\n\nconst ExtractJwt = passportJwt.ExtractJwt;\nconst StrategyJwt = passportJwt.Strategy;\n\npassport.use(\n  new StrategyJwt(\n    {", "  new StrategyJwt(\n    {\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      secretOrKey: process.env.JWT_SECRET,\n    },\n    async function (jwtPayload, done) {\n      return prisma.user\n        .findFirst({ where: { id: jwtPayload } })\n        .then((user) => {\n          return done(null, user || undefined);", "        .then((user) => {\n          return done(null, user || undefined);\n        })\n        .catch((err) => {\n          return done(err);\n        });\n    }\n  )\n);\n"]}
{"filename": "src/middlewares/passportGoogleSSO.ts", "chunked_list": ["//@ts-nocheck\nimport passport from \"passport\";\nimport passportGoogle from \"passport-google-oauth20\";\nimport { prisma } from \"../utils/prismaClient\";\n\nconst GoogleStrategy = passportGoogle.Strategy;\n\npassport.use(\n  new GoogleStrategy(\n    {", "  new GoogleStrategy(\n    {\n      clientID: `${process.env.GOOGLE_CLIENT_ID}`,\n      clientSecret: `${process.env.GOOGLE_CLIENT_SECRET}`,\n      callbackURL: process.env.GOOGLE_CALLBACK_URL,\n      passReqToCallback: true,\n    },\n\n    async (req, accessToken, refreshToken, profile, cb) => {\n      try {\n        const user = await prisma.user.upsert({\n          where: { accountId: profile.id },\n          create: {\n            name: `${profile.name.givenName} ${profile.name.familyName}`,\n            email: profile.emails[0].value,\n            image: profile.photos[0].value,\n            accountId: profile.id,\n            provider: \"google\",\n          },\n          update: {},\n        });\n", "    async (req, accessToken, refreshToken, profile, cb) => {\n      try {\n        const user = await prisma.user.upsert({\n          where: { accountId: profile.id },\n          create: {\n            name: `${profile.name.givenName} ${profile.name.familyName}`,\n            email: profile.emails[0].value,\n            image: profile.photos[0].value,\n            accountId: profile.id,\n            provider: \"google\",\n          },\n          update: {},\n        });\n", "        if (user) return cb(null, user);\n      } catch (err) {\n        console.log(\"Error signing up\", err);\n        cb(err, null);\n      }\n    }\n  )\n);\n\npassport.serializeUser((user, cb) => {\n  cb(null, user.id);\n});\n\npassport.deserializeUser(async (id, cb) => {", "  try {\n    const user = await prisma.user.findUnique({\n      where: { id },\n      select: {\n        id: true,\n        email: true,\n        image: true,\n        name: true,\n        provider: true,\n        createdAt: true,\n      },\n    });\n", "    if (user) cb(null, user);\n  } catch (err) {\n    console.log(\"Error deserializing\", err);\n    cb(err, null);\n  }\n});\n"]}
{"filename": "src/types/index.d.ts", "chunked_list": ["export interface ErrorType {\n  status: number;\n  message: string;\n}\n\nexport type Source = \"glosbe\" | \"oxford\" | \"cambridge\";\n\nexport type LanguagePairs = \"vi-en\" | \"en-vi\" | \"en-en\";\n\nexport type Language = \"en\" | \"vi\";\n", "export type Language = \"en\" | \"vi\";\n"]}
{"filename": "src/router/auth.ts", "chunked_list": ["import Router from \"express-promise-router\";\nimport passport from \"passport\";\nimport type { NextFunction, Request, Response } from \"express\";\n\nconst router = Router();\n\nrouter.get(\n  \"/login/google\",\n  passport.authenticate(\"google\", { scope: [\"profile\", \"email\"] })\n);", "  passport.authenticate(\"google\", { scope: [\"profile\", \"email\"] })\n);\n\nrouter.get(\n  \"/login/facebook\",\n  passport.authenticate(\"facebook\", {\n    scope: [\"public_profile\", \"email\"],\n  })\n);\n", ");\n\nrouter.get(\"/logout\", (req: Request, res: Response, next: NextFunction) => {\n  req.logOut((err) => {\n    if (err) {\n      console.log(\"err:: \", err);\n      return next(err);\n    }\n\n    req?.session?.destroy((err) => {\n      if (err) console.error(err);\n    });\n\n    res.clearCookie(\"connect.sid\");\n    return res.status(200).json({ status: \"success\" });\n  });\n});\n\nrouter.get(\n  \"/auth/facebook/callback\",\n  passport.authenticate(\"facebook\", {\n    failureMessage: \"Cannot login to Facebook, please try again later!\",\n    successRedirect: `${process.env.CLIENT_URL}`,\n    failureRedirect: `${process.env.CLIENT_URL}`,\n  }),\n  (req, res) => {\n    console.log(\"User: \", req?.user);\n    return res.status(200).json({ message: '\"Logged\"' });\n  }\n);\n\nrouter.get(\n  \"/auth/google/callback\",\n  passport.authenticate(\"google\", {\n    failureMessage: \"Cannot login to Google, please try again later!\",\n    successRedirect: `${process.env.CLIENT_URL}`,\n    failureRedirect: `${process.env.CLIENT_URL}`,\n  }),\n  (req, res) => {\n    console.log(\"User: \", req?.user);\n    return res.status(200).json({ message: '\"Logged\"' });\n  }\n);\n\nexport default router;\n", "      if (err) console.error(err);\n    });\n\n    res.clearCookie(\"connect.sid\");\n    return res.status(200).json({ status: \"success\" });\n  });\n});\n\nrouter.get(\n  \"/auth/facebook/callback\",\n  passport.authenticate(\"facebook\", {\n    failureMessage: \"Cannot login to Facebook, please try again later!\",\n    successRedirect: `${process.env.CLIENT_URL}`,\n    failureRedirect: `${process.env.CLIENT_URL}`,\n  }),\n  (req, res) => {\n    console.log(\"User: \", req?.user);\n    return res.status(200).json({ message: '\"Logged\"' });\n  }\n);\n\nrouter.get(\n  \"/auth/google/callback\",\n  passport.authenticate(\"google\", {\n    failureMessage: \"Cannot login to Google, please try again later!\",\n    successRedirect: `${process.env.CLIENT_URL}`,\n    failureRedirect: `${process.env.CLIENT_URL}`,\n  }),\n  (req, res) => {\n    console.log(\"User: \", req?.user);\n    return res.status(200).json({ message: '\"Logged\"' });\n  }\n);\n\nexport default router;\n"]}
{"filename": "src/router/service.ts", "chunked_list": ["import type { NextFunction, Request, Response } from \"express\";\nimport { updatePracticeStatus } from \"../controllers/wordController\";\nimport Router from \"express-promise-router\";\nconst router = Router();\n\nrouter.get(\n  \"/service/ping\",\n  (req: Request, res: Response, next: NextFunction) => {\n    const key = req.headers[\"x-api-key\"];\n\n    if (\n      !key ||\n      typeof key !== \"string\" ||\n      key !== `${process.env.CRON_API_KEY}`\n    ) {\n      return res.status(401).end();\n    }\n\n    return res.status(200).json({ message: \"pong\" });\n  }\n);\n\nrouter.get(\"/service/update-practice-status\", updatePracticeStatus);\n\nexport default router;\n", "    const key = req.headers[\"x-api-key\"];\n\n    if (\n      !key ||\n      typeof key !== \"string\" ||\n      key !== `${process.env.CRON_API_KEY}`\n    ) {\n      return res.status(401).end();\n    }\n\n    return res.status(200).json({ message: \"pong\" });\n  }\n);\n\nrouter.get(\"/service/update-practice-status\", updatePracticeStatus);\n\nexport default router;\n"]}
{"filename": "src/router/word.ts", "chunked_list": ["import Router from \"express-promise-router\";\nimport {\n  search,\n  getWordDetail,\n  getAudio,\n  getWordDetailByMachine,\n  getGrammar,\n} from \"../controllers/wordController\";\n\nconst router = Router();", "\nconst router = Router();\n\nrouter.get(\"/words/search\", search);\n\nrouter.get(\"/words/translate/:word\", getWordDetail);\n\nrouter.post(\"/words/machine_translation\", getWordDetailByMachine);\n\nrouter.get(\"/words/grammar/:word\", getGrammar);", "\nrouter.get(\"/words/grammar/:word\", getGrammar);\n\nrouter.get(\"/words/audio/:word\", getAudio);\n\nexport default router;\n"]}
{"filename": "src/router/index.ts", "chunked_list": ["import { Express } from \"express\";\nimport wordRouter from \"./word\";\nimport authRouter from \"./auth\";\nimport userRouter from \"./user\";\nimport serviceRouter from \"./service\";\n\nfunction route(app: Express) {\n  app.use(`/api`, wordRouter);\n  app.use(`/api`, userRouter);\n  app.use(`/api`, authRouter);\n  app.use(`/api`, serviceRouter);\n}\n\nexport default route;\n"]}
{"filename": "src/router/user.ts", "chunked_list": ["import Router from \"express-promise-router\";\nimport { isUserAuthenticated } from \"../middlewares/auth\";\nimport {\n  handleGetUserInfo,\n  handleCreateTranslationHistory,\n  handleGetTranslationHistory,\n  handleDeleteTranslationHistory,\n  handleGetInfoFavorite,\n  handleCreateFavorite,\n  handleDeleteFavorite,", "  handleCreateFavorite,\n  handleDeleteFavorite,\n  handleGetDashboardInfo,\n  handleGetWordsPreview,\n  handleGetWordsPractice,\n  handleUpdatePracticeStatus,\n} from \"../controllers/userController\";\n\nimport {\n  TranslationHistorySchema,", "import {\n  TranslationHistorySchema,\n  DeleteTranslationHistorySchema,\n  FavoriteQuerySchema,\n  FavoriteBodySchema,\n  DashboardQuerySchema,\n  WordPreviewQuerySchema,\n  PracticeQuerySchema,\n  PracticePatchSchema,\n} from \"../schemas\";", "  PracticePatchSchema,\n} from \"../schemas\";\n\nimport { validate } from \"../middlewares/zodValidate\";\n\nconst router = Router();\n\nrouter.get(\"/auth/user\", isUserAuthenticated, handleGetUserInfo);\n\nrouter.patch(", "\nrouter.patch(\n  \"/users/practice\",\n  isUserAuthenticated,\n  validate(PracticePatchSchema),\n  handleUpdatePracticeStatus\n);\n\nrouter.get(\n  \"/users/practice\",", "router.get(\n  \"/users/practice\",\n  isUserAuthenticated,\n  validate(PracticeQuerySchema),\n  //@ts-ignore\n  handleGetWordsPractice\n);\n\nrouter.get(\n  \"/users/dashboard\",", "router.get(\n  \"/users/dashboard\",\n  isUserAuthenticated,\n  validate(DashboardQuerySchema),\n  handleGetDashboardInfo\n);\n\nrouter.get(\n  \"/users/word-preview\",\n  isUserAuthenticated,", "  \"/users/word-preview\",\n  isUserAuthenticated,\n  validate(WordPreviewQuerySchema),\n  //@ts-ignore\n  handleGetWordsPreview\n);\n\nrouter.get(\n  \"/users/favorite\",\n  isUserAuthenticated,", "  \"/users/favorite\",\n  isUserAuthenticated,\n  validate(FavoriteQuerySchema),\n  handleGetInfoFavorite\n);\n\nrouter.post(\n  \"/users/favorite\",\n  isUserAuthenticated,\n  validate(FavoriteBodySchema),", "  isUserAuthenticated,\n  validate(FavoriteBodySchema),\n  handleCreateFavorite\n);\n\nrouter.delete(\n  \"/users/favorite\",\n  isUserAuthenticated,\n  validate(FavoriteBodySchema),\n  handleDeleteFavorite", "  validate(FavoriteBodySchema),\n  handleDeleteFavorite\n);\n\nrouter.post(\n  \"/users/translation-history\",\n  isUserAuthenticated,\n  validate(TranslationHistorySchema),\n  handleCreateTranslationHistory\n);", "  handleCreateTranslationHistory\n);\n\nrouter.get(\n  \"/users/translation-history\",\n  isUserAuthenticated,\n  //@ts-ignore\n  handleGetTranslationHistory\n);\n", ");\n\nrouter.delete(\n  \"/users/translation-history\",\n  isUserAuthenticated,\n  validate(DeleteTranslationHistorySchema),\n  //@ts-ignore\n  handleDeleteTranslationHistory\n);\n", ");\n\nexport default router;\n"]}
{"filename": "src/controllers/wordController.ts", "chunked_list": ["import axios from \"axios\";\nimport type { NextFunction, Request, Response } from \"express\";\nimport { prisma } from \"../utils/prismaClient\";\nimport { GLOSBE_API } from \"../configs\";\nimport {\n  translateWordGlosbe,\n  machineTranslation,\n  getGrammarGlosbe,\n  translateOxford,\n  translateCambridge,", "  translateOxford,\n  translateCambridge,\n} from \"../libs\";\nimport { getAudioInfo } from \"../utils/getAudio\";\nimport { createManySense, connectTypeOfWord } from \"../utils/dbHelper\";\n\nimport type { Language, LanguagePairs, Source } from \"../types\";\ninterface SearchQuery {\n  word: string;\n  format: LanguagePairs;\n  sensesFormat: Language;\n}\n", "interface AudioQuery {\n  source: Source;\n}\n\nexport async function updatePracticeStatus(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const key = req.headers[\"x-api-key\"];\n", "  try {\n    const key = req.headers[\"x-api-key\"];\n\n    if (\n      !key ||\n      typeof key !== \"string\" ||\n      key !== `${process.env.CRON_API_KEY}`\n    ) {\n      return res.status(401).end();\n    }\n\n    const start = new Date(Date.now());\n\n    const practices = await prisma.practice.findMany({\n      where: {\n        status: \"REMEMBERED\",\n      },\n      select: {\n        id: true,\n        numberOfDaysToForget: true,\n        updatedAt: true,\n      },\n    });\n\n    await Promise.allSettled(\n      practices.map(async (e) => {\n        const diffDate = Math.ceil(\n          //@ts-ignore\n          (new Date(Date.now()) - new Date(String(e.updatedAt))) / 86400000\n        );\n", "        if (diffDate >= e.numberOfDaysToForget) {\n          return await prisma.practice.update({\n            where: { id: e.id },\n            data: { status: \"TEMPORARILY_FORGET\" },\n          });\n        } else {\n          // console.log(\"skip!\");\n        }\n      })\n    );\n\n    //@ts-ignore\n    const cost = Math.abs(new Date(Date.now()) - start) / 1000;\n\n    return res\n      .status(200)\n      .json({ updateCost: `${cost} s`, totalRecords: practices.length });", "  } catch (error) {\n    console.error(\"error:: \", error);\n    next(\"500 ERROR\");\n  }\n}\n\nexport async function search(\n  req: Request<{}, {}, {}, SearchQuery>,\n  res: Response,\n  next: NextFunction\n) {\n  const { format, word } = req.query;\n  const _format_ = format.split(\"-\");\n", "  try {\n    if (!format || !word) throw new Error(\"missing query [format, word]\");\n\n    const resData = await (\n      await axios.get(\n        `${GLOSBE_API}/iapi3/wordlist?l1=${_format_[0]}&l2=${_format_[1]}&q=${word}&after=20&before=0&env=vi`\n      )\n    ).data;\n\n    if (resData?.after && Array.isArray(resData?.after)) {\n      const words = resData?.after.map((e: any) => String(e?.phrase));\n      return res.status(200).json({ words });\n    }\n\n    return res.status(404).json({ message: \"word not found\" });", "    if (resData?.after && Array.isArray(resData?.after)) {\n      const words = resData?.after.map((e: any) => String(e?.phrase));\n      return res.status(200).json({ words });\n    }\n\n    return res.status(404).json({ message: \"word not found\" });\n  } catch (error) {\n    console.log(\"SEARCH ERROR: \", error);\n    next();\n  }\n}\n", "export async function getWordDetail(\n  req: Request<\n    Pick<SearchQuery, \"word\">,\n    {},\n    {},\n    Pick<SearchQuery, \"format\"> & AudioQuery\n  >,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const { word } = req.params;\n    const { format, source } = req.query;\n    const _format_ = format.split(\"-\");\n", "  try {\n    const { word } = req.params;\n    const { format, source } = req.query;\n    const _format_ = format.split(\"-\");\n\n    if (!word) throw new Error(\"word missing\");\n    if (!format) throw new Error(\"format missing\");\n\n    //@ts-ignore\n    let resData;\n", "    if (format === \"en-en\") {\n      if (source === \"cambridge\") {\n        resData = await translateCambridge({ word });\n      } else {\n        resData = await translateOxford({ word });\n      }\n\n      if (resData) {\n        return res.status(200).json(resData);\n      } else {\n        throw new Error();\n      }\n    }\n\n    //get word from \"cache\":\n    const wordDb = await prisma.word.findUnique({\n      where: { wordContent: word },\n      include: {\n        examples: true,\n        senses: { include: { example: true, typeOfWord: true } },\n        less_frequent_senses: true,\n        similar_phrases: true,\n        typesOfWord: { select: { type: true } },\n      },\n    });\n\n    //\"cache hit\"", "    if (wordDb) {\n      return res.status(200).json({\n        ...wordDb,\n        typesOfWord: wordDb.typesOfWord.map((e) => e.type),\n        senses: wordDb.senses.map((s) => ({\n          ...s,\n          typeOfWord: s.typeOfWord?.type,\n        })),\n        less_frequent_senses: wordDb.less_frequent_senses.map((e) => e.sense),\n      });\n    }\n\n    console.time(`time scrape ${word}`);\n    resData = await translateWordGlosbe({\n      language_1: _format_[0] as Language,\n      language_2: _format_[1] as Language,\n      word,\n    });\n    console.timeEnd(`time scrape ${word}`);\n", "    if (resData) {\n      //cache data:\n      try {\n        setTimeout(async () => {\n          const [word] = await prisma.$transaction([\n            prisma.word.create({\n              data: {\n                format,\n                //@ts-ignore\n                wordContent: resData.wordContent,\n                less_frequent_senses:\n                  //@ts-ignore\n                  resData?.less_frequent_senses &&\n                  //@ts-ignore\n                  resData?.less_frequent_senses.length > 0\n                    ? {\n                        createMany: {\n                          //@ts-ignore\n                          data: resData?.less_frequent_senses.map((e) => ({\n                            sense: e,\n                          })),\n                        },\n                      }\n                    : undefined,\n                similar_phrases:\n                  //@ts-ignore\n                  resData?.similar_phrases &&\n                  resData?.similar_phrases.length > 0\n                    ? {\n                        createMany: {\n                          //@ts-ignore\n                          data: resData?.similar_phrases.map((e) => ({\n                            en: e.en,\n                            vi: e.vi,\n                          })),\n                        },\n                      }\n                    : undefined,\n                examples:\n                  //@ts-ignore\n                  resData?.examples && resData.examples.length > 0\n                    ? {\n                        createMany: {\n                          //@ts-ignore\n                          data: resData.examples.map((e) => ({\n                            en: e.en,\n                            vi: e.vi,\n                            keyword_en: e?.keyword_en,\n                            keyword_vi: e?.keyword_vi,\n                          })),\n                        },\n                      }\n                    : undefined,\n              },\n            }),\n            prisma.typeOfWord.createMany({\n              data:\n                //@ts-ignore\n                resData.typesOfWord && resData.typesOfWord.length > 0\n                  ? //@ts-ignore\n                    resData.typesOfWord.map((e) => ({ type: e }))\n                  : [],\n              skipDuplicates: true,\n            }),\n          ]);\n\n          //@ts-ignore", "          if (resData.typesOfWord && resData.typesOfWord.length > 0) {\n            await Promise.allSettled([\n              //@ts-ignore\n              await connectTypeOfWord(resData.typesOfWord, word.wordContent),\n              //@ts-ignore\n              await createManySense(resData.senses, word.id),\n            ]);\n          } else {\n            //@ts-ignore\n            await createManySense(resData.senses, word.id);\n          }\n        }, 500);", "      } catch (error) {\n        console.log(\"cache ERROR: \", error);\n      }\n\n      return res.status(200).json(resData);\n    } else {\n      return res.status(404).json({ message: \"word detail not found\" });\n    }\n  } catch (error) {\n    console.log(\"getWordDetail: \", error);\n    next();\n  }\n}\n", "  } catch (error) {\n    console.log(\"getWordDetail: \", error);\n    next();\n  }\n}\n\nexport async function getGrammar(\n  req: Request<Pick<SearchQuery, \"word\">, {}, {}, {}>,\n  res: Response,\n  next: NextFunction\n) {\n  const { word } = req.params;\n\n  const resData = await getGrammarGlosbe({ word });\n", "  if (resData) {\n    return res.status(200).json({ grammars: resData });\n  } else {\n    return res.status(404).json({ message: \"grammars not found\" });\n  }\n}\n\nexport async function getWordDetailByMachine(\n  req: Request<{}, {}, { sentence: string }, Pick<SearchQuery, \"format\">>,\n  res: Response,\n  next: NextFunction\n) {\n  const { sentence } = req.body;\n  const { format } = req.query;\n  const _format_ = format.split(\"-\");\n", "  if (!sentence) throw new Error(\"word missing\");\n  if (!format) throw new Error(\"format missing\");\n\n  try {\n    const resData = await machineTranslation({\n      language_1: _format_[0] as Language,\n      language_2: _format_[1] as Language,\n      word: sentence,\n    });\n\n    if (resData) {\n      return res.status(200).json(resData);\n    }\n\n    return res\n      .status(404)\n      .json({ message: \"word detail by machine not found\" });", "    if (resData) {\n      return res.status(200).json(resData);\n    }\n\n    return res\n      .status(404)\n      .json({ message: \"word detail by machine not found\" });\n  } catch (error) {\n    console.log(\"getWordDetailByMachine error: \", error);\n    next();\n  }\n}\n", "export async function getAudio(\n  req: Request<Pick<SearchQuery, \"word\">, {}, {}, AudioQuery>,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const { word } = req.params;\n    const { source } = req.query;\n\n    const audios = await getAudioInfo({ word, format: \"en\", source });\n\n    return res.status(200).json({ audios });", "  } catch (error) {}\n}\n"]}
{"filename": "src/controllers/userController.ts", "chunked_list": ["import type { NextFunction, Request, Response } from \"express\";\nimport { prisma } from \"../utils/prismaClient\";\nimport type { PracticeStatus } from \"@prisma/client\";\n\nexport async function handleGetUserInfo(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    return res.status(200).json(req.user);", "  try {\n    return res.status(200).json(req.user);\n  } catch (error) {\n    console.error(\"handleGetUserInfo ERROR: \", error);\n    return res.status(500).json(\"ERROR\");\n  }\n}\n\ninterface TranslationHistoryBody {\n  word: string;\n  sense: string;\n  currentLanguage: string;\n  targetLanguage: string;\n  translations_history: TranslationHistoryBody[];\n}\n", "interface TranslationHistoryBody {\n  word: string;\n  sense: string;\n  currentLanguage: string;\n  targetLanguage: string;\n  translations_history: TranslationHistoryBody[];\n}\n\nexport async function handleUpdatePracticeStatus(\n  req: Request<{}, {}, { status: PracticeStatus; wordContent: string }>,\n  res: Response,\n  next: NextFunction\n) {\n  const { user } = req;\n  let { status, wordContent } = req.body;\n", "export async function handleUpdatePracticeStatus(\n  req: Request<{}, {}, { status: PracticeStatus; wordContent: string }>,\n  res: Response,\n  next: NextFunction\n) {\n  const { user } = req;\n  let { status, wordContent } = req.body;\n\n  try {\n    const practiceOwner = await prisma.practice.findUnique({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent,\n        },\n      },\n    });\n\n    const forgottenFrequencyOwner = practiceOwner?.forgottenFrequency\n      ? practiceOwner?.forgottenFrequency\n      : 0;\n\n    const practice = await prisma.practice.update({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent,\n        },\n      },\n      select: {\n        status: true,\n        updatedAt: true,\n      },\n      data: {\n        status,\n        forgottenFrequency:\n          status === \"REMEMBERED\" ? 0 : forgottenFrequencyOwner + 1,\n      },\n    });\n\n    return res.status(200).json(practice);", "  try {\n    const practiceOwner = await prisma.practice.findUnique({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent,\n        },\n      },\n    });\n\n    const forgottenFrequencyOwner = practiceOwner?.forgottenFrequency\n      ? practiceOwner?.forgottenFrequency\n      : 0;\n\n    const practice = await prisma.practice.update({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent,\n        },\n      },\n      select: {\n        status: true,\n        updatedAt: true,\n      },\n      data: {\n        status,\n        forgottenFrequency:\n          status === \"REMEMBERED\" ? 0 : forgottenFrequencyOwner + 1,\n      },\n    });\n\n    return res.status(200).json(practice);", "  } catch (error) {\n    console.error(`handleGetWordsPreview: ${error}`);\n    next(\"handleGetWordsPreview ERROR\");\n  }\n}\n\nexport async function handleGetWordsPractice(\n  req: Request<\n    {},\n    {},\n    {},\n    { status: string; tags: string; page?: number; limit?: number }\n  >,\n  res: Response,\n  next: NextFunction\n) {\n  const { user } = req;\n  let { status, page, tags, limit } = req.query;\n", "  if (!page) page = 1;\n  if (!limit) limit = 20;\n\n  const _status_ = status.split(\"+\");\n  const _tags_ = tags.split(\"+\");\n\n  const orConditions = [\n    ..._status_.map((e) => ({ status: e })),\n    ..._tags_.map((e) => ({ tag: e })),\n  ];\n", "  try {\n    const [practices, totalRecords] = await prisma.$transaction([\n      prisma.practice.findMany({\n        where: {\n          //@ts-ignore\n          userId: user.id,\n          tag: tags ? { in: _tags_ } : undefined,\n          //@ts-ignore\n          status: status ? { in: _status_ } : undefined,\n        },\n        select: {\n          id: true,\n          status: true,\n          tag: true,\n          word: {\n            select: {\n              less_frequent_senses: { select: { sense: true } },\n              format: true,\n              wordContent: true,\n              senses: true,\n            },\n          },\n        },\n        take: Number(limit),\n        skip: (Number(page) - 1) * limit,\n        orderBy: {\n          createdAt: \"desc\",\n        },\n      }),\n      prisma.practice.count({\n        where: {\n          //@ts-ignore\n          userId: user.id,\n          tag: { in: _tags_ },\n          //@ts-ignore\n          status: { in: _status_ },\n        },\n      }),\n    ]);\n\n    return res\n      .status(200)\n      .json({ practices, totalPages: Math.ceil(totalRecords / limit) });", "  } catch (error) {\n    console.error(`handleGetWordsPreview: ${error}`);\n    next(\"handleGetWordsPreview ERROR\");\n  }\n}\n\nexport async function handleGetWordsPreview(\n  req: Request<\n    {},\n    {},\n    {},\n    { status: string; tag?: string; page?: number; limit?: number }\n  >,\n  res: Response,\n  next: NextFunction\n) {\n  const { user } = req;\n  let { status, page, tag, limit } = req.query;\n", "  if (!page) page = 1;\n  if (!limit) limit = 18;\n\n  try {\n    const [words, totalRecords] = await prisma.$transaction([\n      prisma.practice.findMany({\n        where: {\n          //@ts-ignore\n          userId: user.id,\n          //@ts-ignore\n          status,\n          tag,\n        },\n        select: {\n          word: {\n            select: {\n              format: true,\n              wordContent: true,\n              senses: { select: { sense: true } },\n            },\n          },\n        },\n        take: Number(limit),\n        skip: (Number(page) - 1) * limit,\n        orderBy: {\n          createdAt: 'desc'\n        }\n      }),\n      prisma.practice.count({\n        where: {\n          //@ts-ignore\n          userId: user.id,\n          //@ts-ignore\n          status,\n          tag,\n        },\n      }),\n    ]);\n\n    return res\n      .status(200)\n      .json({ words, totalPages: Math.ceil(totalRecords / limit) });", "  } catch (error) {\n    console.error(`handleGetWordsPreview: ${error}`);\n    next(\"handleGetWordsPreview ERROR\");\n  }\n}\n\nexport async function handleGetDashboardInfo(\n  req: Request<{}, {}, {}, { status: string }>,\n  res: Response,\n  next: NextFunction\n) {\n  const { user } = req;\n  const { status } = req.query;\n", "  try {\n    const [statusCounting, historyCounting, favoriteCounting, tags] =\n      await prisma.$transaction([\n        prisma.practice.count({\n          //@ts-ignore\n          where: { userId: user.id, status },\n        }),\n        prisma.translationHistory.count({\n          //@ts-ignore\n          where: { userId: user.id },\n        }),\n        prisma.practice.count({\n          //@ts-ignore\n          where: { userId: user.id },\n        }),\n        prisma.practice.findMany({\n          //@ts-ignore\n          where: { userId: user.id },\n          distinct: [\"tag\"],\n          select: { tag: true },\n        }),\n      ]);\n\n    return res\n      .status(200)\n      .json({ statusCounting, historyCounting, favoriteCounting, tags });", "  } catch (error) {\n    console.error(`handleGetDashboardInfo: ${error}`);\n    next(\"handleGetDashboardInfo ERROR\");\n  }\n}\n\nexport async function handleDeleteFavorite(\n  req: Request<{}, {}, { word: string }>,\n  res: Response,\n  next: NextFunction\n) {\n  const { word } = req.body;\n  const { user } = req;\n", "  try {\n    const deletedStatus = await prisma.practice.delete({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent: word,\n        },\n      },\n    });\n\n    return res.status(200).json(deletedStatus);", "  } catch (error) {\n    console.error(`handleCreateFavorite: ${error}`);\n    next(\"handleCreateFavorite ERROR\");\n  }\n}\n\nexport async function handleCreateFavorite(\n  req: Request<\n    {},\n    {},\n    { word: string; tag?: string; numberOfDaysToForget?: number }\n  >,\n  res: Response,\n  next: NextFunction\n) {\n  const { word, numberOfDaysToForget, tag } = req.body;\n  const { user } = req;\n", "  try {\n    const practiceWord = await prisma.practice.upsert({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent: word,\n        },\n      },\n      create: {\n        word: { connect: { wordContent: word } },\n        //@ts-ignore\n        user: { connect: { id: user.id } },\n        numberOfDaysToForget,\n        tag,\n      },\n      update: {},\n    });\n\n    return res.status(201).json(practiceWord);", "  } catch (error) {\n    console.error(`handleCreateFavorite: ${error}`);\n    next(\"handleCreateFavorite ERROR\");\n  }\n}\n\nexport async function handleGetInfoFavorite(\n  req: Request<{}, {}, {}, { word: string }>,\n  res: Response,\n  next: NextFunction\n) {\n  const { word } = req.query;\n  const { user } = req;\n", "  try {\n    const practiceWord = await prisma.practice.findUnique({\n      where: {\n        userId_wordContent: {\n          //@ts-ignore\n          userId: user.id,\n          wordContent: word,\n        },\n      },\n      select: {\n        createdAt: true,\n      },\n    });\n\n    return res.status(200).json(practiceWord);", "  } catch (error) {\n    console.error(`handleGetInfoFavorite: ${error}`);\n    next(\"handleGetInfoFavorite ERROR\");\n  }\n}\n\nexport async function handleCreateTranslationHistory(\n  req: Request<{}, {}, TranslationHistoryBody, {}>,\n  res: Response,\n  next: NextFunction\n) {\n  const { word, sense, currentLanguage, targetLanguage, translations_history } =\n    req.body;\n  const { user } = req;\n", "  try {\n    //multiple create:\n    if (translations_history && translations_history.length > 0) {\n      const tHistory = await prisma.translationHistory.createMany({\n        data: translations_history.map((e) => ({\n          word: e.word,\n          sense: e.sense,\n          currentLanguage: e.currentLanguage,\n          targetLanguage: e.targetLanguage,\n          //@ts-ignore\n          userId: user.id,\n        })),\n        skipDuplicates: true,\n      });\n\n      return res.status(201).json(tHistory);\n    }\n\n    //single create:\n    const tHistory = await prisma.translationHistory.upsert({\n      where: {\n        userId_word: {\n          //@ts-ignore\n          userId: user.id,\n          word,\n        },\n      },\n      create: {\n        word,\n        sense,\n        currentLanguage,\n        targetLanguage,\n        //@ts-ignore\n        userId: user.id,\n      },\n      update: {},\n    });\n\n    return res.status(201).json(tHistory);", "  } catch (error) {\n    console.error(`handleCreateTranslationHistory: ${error}`);\n    next(\"handleCreateTranslationHistory ERROR\");\n  }\n}\n\nexport async function handleGetTranslationHistory(\n  req: Request<{}, {}, {}, { page: number; limit: number }>,\n  res: Response,\n  next: NextFunction\n) {", "  try {\n    const { user } = req;\n    let { page, limit } = req.query;\n\n    if (!page) page = 1;\n    if (!limit) limit = 18;\n\n    const [translations, totalRecords] = await prisma.$transaction([\n      prisma.translationHistory.findMany({\n        //@ts-ignore\n        where: { userId: user.id },\n        orderBy: {\n          createdAt: \"desc\",\n        },\n        take: Number(limit),\n        skip: (Number(page) - 1) * limit,\n      }),\n      prisma.translationHistory.count({\n        //@ts-ignore\n        where: { userId: user.id },\n      }),\n    ]);\n\n    return res\n      .status(200)\n      .json({ translations, totalPages: Math.ceil(totalRecords / limit) });", "  } catch (error) {\n    console.error(`handleGetTranslationHistory: ${error}`);\n    next(\"handleGetTranslationHistory ERROR\");\n  }\n}\n\nexport async function handleDeleteTranslationHistory(\n  req: Request<{}, {}, { word: string; deleteOption: string }, {}>,\n  res: Response,\n  next: NextFunction\n) {", "  try {\n    const { word, deleteOption } = req.body;\n    const { user } = req;\n\n    if (deleteOption === \"deleteAll\") {\n      const deleteStatus = await prisma.translationHistory.deleteMany({\n        //@ts-ignore\n        where: { userId: user.id },\n      });\n\n      return res.status(200).json({ deleteStatus });\n    }\n\n    const deleteStatus = await prisma.translationHistory.delete({\n      where: {\n        userId_word: {\n          word,\n          //@ts-ignore\n          userId: user.id,\n        },\n      },\n    });\n\n    return res.status(200).json({ deleteStatus });", "  } catch (error) {\n    console.error(`handleDeleteTranslationHistory: ${error}`);\n    next(\"handleDeleteTranslationHistory ERROR\");\n  }\n}\n"]}
