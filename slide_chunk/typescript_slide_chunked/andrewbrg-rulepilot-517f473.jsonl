{"filename": "test/mutator.spec.ts", "chunked_list": ["import axios from \"axios\";\nimport { beforeEach } from \"@jest/globals\";\n\nimport { RulePilot } from \"../src\";\nimport { valid1Json } from \"./rulesets/valid1.json\";\nimport { valid3Json } from \"./rulesets/valid3.json\";\n\nconst mutation1 = async (value) => {\n  const result = await axios.get(\n    `https://restcountries.com/v3.1/name/${value}?fullText=true`", "  const result = await axios.get(\n    `https://restcountries.com/v3.1/name/${value}?fullText=true`\n  );\n  return result.data[0].cca2;\n};\n\nconst mutation2 = async (value) => {\n  const result = await axios.get(\n    `https://restcountries.com/v3.1/name/${value[0]}?fullText=true`\n  );", "    `https://restcountries.com/v3.1/name/${value[0]}?fullText=true`\n  );\n  return result.data[0].cca2;\n};\n\nconst criteria = [\n  {\n    CountryIso: \"United Kingdom\",\n    Leverage: 60,\n    Monetization: \"Real\",", "    Leverage: 60,\n    Monetization: \"Real\",\n  },\n  {\n    CountryIso: \"United Kingdom\",\n    Leverage: 200,\n    Monetization: \"Real\",\n  },\n  {\n    CountryIso: \"United Kingdom\",", "  {\n    CountryIso: \"United Kingdom\",\n    Leverage: 60,\n    Monetization: \"Real\",\n  },\n];\n\ndescribe(\"RulePilot mutator correctly\", () => {\n  beforeEach(() => {\n    console.debug = jest.fn();", "  beforeEach(() => {\n    console.debug = jest.fn();\n    process.env.DEBUG = \"true\";\n  });\n\n  it(\"Performs desired mutation\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"ProfitPercentage\", (value) => value * 2);\n    expect(await rp.evaluate(valid1Json, { ProfitPercentage: 5 })).toEqual(", "    rp.addMutation(\"ProfitPercentage\", (value) => value * 2);\n    expect(await rp.evaluate(valid1Json, { ProfitPercentage: 5 })).toEqual(\n      true\n    );\n  });\n\n  it(\"Performs multiple mutations\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"WinRate\", (value) => value * 2);", "\n    rp.addMutation(\"WinRate\", (value) => value * 2);\n    rp.addMutation(\"AverageTradeDuration\", (value) => value / 2);\n\n    expect(\n      await rp.evaluate(valid1Json, {\n        WinRate: 31,\n        AverageTradeDuration: 60,\n        Duration: 99999999,\n        TotalDaysTraded: 3,", "        Duration: 99999999,\n        TotalDaysTraded: 3,\n      })\n    ).toEqual(true);\n  });\n\n  it(\"Performs async mutation\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"CountryIso\", mutation1);", "\n    rp.addMutation(\"CountryIso\", mutation1);\n\n    expect(\n      await rp.evaluate(valid3Json, {\n        CountryIso: \"United Kingdom\",\n        Leverage: 60,\n        Monetization: \"Real\",\n        foo: {\n          CountryIso: \"United Kingdom\",", "        foo: {\n          CountryIso: \"United Kingdom\",\n        },\n      })\n    ).toEqual(3);\n  });\n\n  it(\"Performs nested mutation\", async () => {\n    const rp = new RulePilot();\n", "    const rp = new RulePilot();\n\n    rp.addMutation(\"foo.bar\", (value) => value * 2);\n    expect(\n      await rp.evaluate(\n        {\n          conditions: [\n            {\n              all: [{ field: \"foo.bar\", operator: \">\", value: 6 }],\n            },", "              all: [{ field: \"foo.bar\", operator: \">\", value: 6 }],\n            },\n          ],\n        },\n        { foo: { bar: 5 } }\n      )\n    ).toEqual(true);\n  });\n\n  it(\"Caches async mutation results\", async () => {", "\n  it(\"Caches async mutation results\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"Leverage\", (value) => value);\n    rp.addMutation(\"CountryIso\", mutation1);\n\n    const result = await rp.evaluate(valid3Json, criteria);\n\n    expect(console.debug).toBeCalledWith(", "\n    expect(console.debug).toBeCalledWith(\n      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n    );\n    expect(console.debug).toBeCalledTimes(9);\n    expect(result).toEqual([3, 2, 3]);\n  });\n\n  it(\"Performs a migration with an array parameter\", async () => {\n    const rp = new RulePilot();", "  it(\"Performs a migration with an array parameter\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"CountryIso\", mutation2);\n\n    const result = await rp.evaluate(\n      {\n        conditions: [\n          {\n            all: [{ field: \"CountryIso\", operator: \"==\", value: \"GB\" }],", "          {\n            all: [{ field: \"CountryIso\", operator: \"==\", value: \"GB\" }],\n          },\n        ],\n      },\n      { CountryIso: [\"United Kingdom\", \"Finland\"] }\n    );\n\n    expect(result).toEqual(true);\n  });", "    expect(result).toEqual(true);\n  });\n\n  it(\"Performs a migration with a nested array parameter\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"foo.bar\", mutation2);\n\n    const result = await rp.evaluate(\n      {", "    const result = await rp.evaluate(\n      {\n        conditions: [\n          {\n            all: [{ field: \"foo.bar\", operator: \"==\", value: \"GB\" }],\n          },\n        ],\n      },\n      { foo: { bar: [\"United Kingdom\", \"Finland\"] } }\n    );", "      { foo: { bar: [\"United Kingdom\", \"Finland\"] } }\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it(\"Mutation cache works properly\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"Leverage\", (value) => value);", "\n    rp.addMutation(\"Leverage\", (value) => value);\n    rp.addMutation(\"CountryIso\", mutation1);\n\n    await rp.evaluate(valid3Json, criteria);\n\n    setTimeout(async () => {\n      const result = await rp.evaluate(valid3Json, criteria);\n      expect(console.debug).toBeCalledWith(\n        'Cache hit on \"CountryIso\" with param \"United Kingdom\"'", "      expect(console.debug).toBeCalledWith(\n        'Cache hit on \"CountryIso\" with param \"United Kingdom\"'\n      );\n      expect(result).toEqual([3, 2, 3]);\n    }, 1500);\n  });\n\n  it(\"Removes a mutation properly\", async () => {\n    const rp = new RulePilot();\n", "    const rp = new RulePilot();\n\n    rp.addMutation(\"CountryIso\", mutation1);\n    rp.removeMutation(\"CountryIso\");\n\n    const result = await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });", "      Monetization: \"Real\",\n    });\n\n    expect(console.debug).not.toHaveBeenCalled();\n    expect(result).toEqual(2);\n  });\n\n  it(\"Clears mutation cache properly\", async () => {\n    const rp = new RulePilot();\n", "    const rp = new RulePilot();\n\n    rp.addMutation(\"CountryIso\", mutation1);\n\n    await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });\n", "    });\n\n    rp.clearMutationCache(\"CountryIso\");\n\n    const result = await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });\n", "    });\n\n    expect(console.debug).not.toHaveBeenCalledWith(\n      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n    );\n    expect(result).toEqual(3);\n  });\n\n  it(\"Clears all mutation cache properly\", async () => {\n    const rp = new RulePilot();", "  it(\"Clears all mutation cache properly\", async () => {\n    const rp = new RulePilot();\n\n    rp.addMutation(\"CountryIso\", mutation1);\n\n    await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });", "      Monetization: \"Real\",\n    });\n\n    rp.clearMutationCache();\n\n    const result = await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });", "      Monetization: \"Real\",\n    });\n\n    expect(console.debug).not.toHaveBeenCalledWith(\n      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n    );\n    expect(result).toEqual(3);\n  });\n\n  it(\"Static methods behave as expected\", async () => {", "\n  it(\"Static methods behave as expected\", async () => {\n    const rp = new RulePilot();\n\n    RulePilot.addMutation(\"CountryIso\", mutation1);\n\n    const result1 = await RulePilot.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",", "      Leverage: 60,\n      Monetization: \"Real\",\n    });\n\n    expect(result1).toEqual(3);\n\n    RulePilot.removeMutation(\"CountryIso\");\n    const result2 = await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,", "      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });\n\n    expect(result2).toEqual(2);\n\n    RulePilot.clearMutationCache();\n    const result3 = await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",", "    const result3 = await rp.evaluate(valid3Json, {\n      CountryIso: \"United Kingdom\",\n      Leverage: 60,\n      Monetization: \"Real\",\n    });\n\n    expect(console.debug).not.toHaveBeenCalledWith(\n      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n    );\n    expect(result3).toEqual(2);", "    );\n    expect(result3).toEqual(2);\n  });\n});\n"]}
{"filename": "test/validator.spec.ts", "chunked_list": ["import { RulePilot, Operator, Condition, Constraint } from \"../src\";\n\nimport { valid1Json } from \"./rulesets/valid1.json\";\nimport { valid3Json } from \"./rulesets/valid3.json\";\n\nimport { invalid1Json } from \"./rulesets/invalid1.json\";\n\ndescribe(\"RulePilot validator correctly\", () => {\n  it(\"Identifies a bad operator\", () => {\n    expect(", "  it(\"Identifies a bad operator\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [\n          {\n            all: [{ field: \"name\", operator: \"*\" as Operator, value: \"test\" }],\n          },\n        ],\n      }).isValid\n    ).toEqual(false);", "      }).isValid\n    ).toEqual(false);\n  });\n\n  it(\"Identifies an invalid field\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [\n          {\n            all: [", "          {\n            all: [\n              {\n                field: true as unknown as string,\n                operator: \"==\",\n                value: \"test\",\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      }).isValid\n    ).toEqual(false);\n  });\n\n  it(\"Identifies an invalid condition\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [", "      RulePilot.validate({\n        conditions: [\n          {\n            all: [\n              {\n                field: \"foo\",\n                operator: \"==\",\n                value: \"bar\",\n              },\n            ],", "              },\n            ],\n            any: [],\n          },\n        ],\n      }).isValid\n    ).toEqual(false);\n  });\n\n  it(\"Identifies an invalid node\", () => {", "\n  it(\"Identifies an invalid node\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [\n          {\n            all: [\n              {\n                operator: \"==\",\n                value: \"bar\",", "                operator: \"==\",\n                value: \"bar\",\n              } as Constraint,\n            ],\n          },\n        ],\n      }).isValid\n    ).toEqual(false);\n  });\n", "  });\n\n  it(\"Identifies an badly constructed condition\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [\n          {\n            foo: [\n              {\n                field: \"foo\",", "              {\n                field: \"foo\",\n                operator: \"==\",\n                value: \"bar\",\n              },\n            ],\n          } as Condition,\n        ],\n      }).isValid\n    ).toEqual(false);", "      }).isValid\n    ).toEqual(false);\n  });\n\n  it(\"Identifies an invalid rule\", () => {\n    const validation = RulePilot.validate(invalid1Json);\n\n    expect(validation.isValid).toEqual(false);\n    expect(validation.error.message).toEqual(\n      'Nested conditions cannot have a property \"result\".'", "    expect(validation.error.message).toEqual(\n      'Nested conditions cannot have a property \"result\".'\n    );\n  });\n\n  it(\"Identifies an empty rule\", () => {\n    const validation = RulePilot.validate({ conditions: [] });\n\n    expect(validation.isValid).toEqual(false);\n    expect(validation.error.message).toEqual(", "    expect(validation.isValid).toEqual(false);\n    expect(validation.error.message).toEqual(\n      \"The conditions property must contain at least one condition.\"\n    );\n  });\n\n  it(\"Identifies invalid values for In/Not In operators\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [", "      RulePilot.validate({\n        conditions: [\n          { all: [{ field: \"name\", operator: \"in\", value: \"test\" }] },\n        ],\n      }).isValid\n    ).toEqual(false);\n\n    expect(\n      RulePilot.validate({\n        conditions: [", "      RulePilot.validate({\n        conditions: [\n          { all: [{ field: \"name\", operator: \"not in\", value: \"test\" }] },\n        ],\n      }).isValid\n    ).toEqual(false);\n  });\n\n  it(\"Validates a correct rule\", () => {\n    expect(", "  it(\"Validates a correct rule\", () => {\n    expect(\n      RulePilot.validate({\n        conditions: [\n          { all: [{ field: \"name\", operator: \"==\", value: \"test\" }] },\n        ],\n      }).isValid\n    ).toEqual(true);\n  });\n", "  });\n\n  it(\"Validates a simple correct rule\", () => {\n    expect(RulePilot.validate(valid1Json).isValid).toEqual(true);\n  });\n\n  it(\"Validates a nested correct rule\", () => {\n    expect(RulePilot.validate(valid3Json).isValid).toEqual(true);\n  });\n});", "  });\n});\n"]}
{"filename": "test/engine.spec.ts", "chunked_list": ["import { RulePilot, Operator, RuleError } from \"../src\";\n\nimport { valid1Json } from \"./rulesets/valid1.json\";\nimport { valid2Json } from \"./rulesets/valid2.json\";\nimport { valid3Json } from \"./rulesets/valid3.json\";\nimport { valid4Json } from \"./rulesets/valid4.json\";\n\nimport { invalid1Json } from \"./rulesets/invalid1.json\";\n\ndescribe(\"RulePilot engine correctly\", () => {", "\ndescribe(\"RulePilot engine correctly\", () => {\n  it(\"Evaluates a simple ruleset\", async () => {\n    expect(\n      await RulePilot.evaluate(valid1Json, { ProfitPercentage: 20 })\n    ).toEqual(true);\n\n    expect(\n      await RulePilot.evaluate(valid1Json, { ProfitPercentage: 2 })\n    ).toEqual(false);", "      await RulePilot.evaluate(valid1Json, { ProfitPercentage: 2 })\n    ).toEqual(false);\n\n    expect(\n      await RulePilot.evaluate(valid1Json, {\n        WinRate: 80,\n        AverageTradeDuration: 5,\n        Duration: 9000000,\n      })\n    ).toEqual(false);", "      })\n    ).toEqual(false);\n\n    expect(\n      await RulePilot.evaluate(valid1Json, {\n        WinRate: 80,\n        AverageTradeDuration: 5,\n        Duration: 9000000,\n        TotalDaysTraded: 5,\n      })", "        TotalDaysTraded: 5,\n      })\n    ).toEqual(true);\n  });\n\n  it(\"Evaluates to false if operator is unknown\", async () => {\n    expect(\n      await RulePilot.evaluate(\n        {\n          conditions: [", "        {\n          conditions: [\n            {\n              all: [\n                { field: \"name\", operator: \"foo\" as Operator, value: \"test\" },\n              ],\n            },\n          ],\n        },\n        { name: \"test\" },", "        },\n        { name: \"test\" },\n        true\n      )\n    ).toEqual(false);\n  });\n\n  it(\"Resolves nested field definitions\", async () => {\n    expect(\n      await RulePilot.evaluate(", "    expect(\n      await RulePilot.evaluate(\n        {\n          conditions: [\n            {\n              all: [{ field: \"foo.bar\", operator: \"==\", value: \"test\" }],\n            },\n          ],\n        },\n        {", "        },\n        {\n          foo: {\n            bar: \"test\",\n          },\n        }\n      )\n    ).toEqual(true);\n  });\n", "  });\n\n  it(\"Handles missing nested field definitions\", async () => {\n    expect(\n      await RulePilot.evaluate(\n        {\n          conditions: [\n            {\n              all: [{ field: \"foo.foo\", operator: \"==\", value: \"test\" }],\n            },", "              all: [{ field: \"foo.foo\", operator: \"==\", value: \"test\" }],\n            },\n          ],\n        },\n        {\n          foo: {\n            bar: \"test\",\n          },\n        }\n      )", "        }\n      )\n    ).toEqual(false);\n  });\n\n  it(\"Handles array of criteria properly\", async () => {\n    expect(\n      await RulePilot.evaluate(\n        {\n          conditions: [", "        {\n          conditions: [\n            {\n              all: [{ field: \"foo.bar\", operator: \"==\", value: \"bar\" }],\n            },\n          ],\n        },\n        [\n          {\n            foo: {", "          {\n            foo: {\n              bar: \"test\",\n            },\n          },\n          {\n            foo: {\n              bar: \"bar\",\n            },\n          },", "            },\n          },\n          {},\n        ]\n      )\n    ).toEqual([false, true, false]);\n  });\n\n  it(\"Throws an error on invalid not runnable ruleset\", () => {\n    expect(", "  it(\"Throws an error on invalid not runnable ruleset\", () => {\n    expect(\n      async () => await RulePilot.evaluate({ conditions: [] }, {})\n    ).rejects.toThrow(RuleError);\n  });\n\n  it(\"Evaluates an invalid but runnable ruleset if marked as trusted\", async () => {\n    expect(await RulePilot.evaluate(invalid1Json, {}, true)).toEqual(2);\n  });\n", "  });\n\n  it(\"Evaluates a nested ruleset\", async () => {\n    expect(await RulePilot.evaluate(valid3Json, {})).toEqual(2);\n    expect(await RulePilot.evaluate(valid3Json, { Leverage: 1000 })).toEqual(3);\n    expect(await RulePilot.evaluate(valid3Json, { Leverage: 999 })).toEqual(2);\n\n    expect(\n      await RulePilot.evaluate(valid3Json, { Category: \"Islamic\" })\n    ).toEqual(4);", "      await RulePilot.evaluate(valid3Json, { Category: \"Islamic\" })\n    ).toEqual(4);\n\n    expect(\n      await RulePilot.evaluate(valid3Json, { Monetization: \"Real\" })\n    ).toEqual(2);\n\n    expect(\n      await RulePilot.evaluate(valid3Json, {\n        Monetization: \"Real\",", "      await RulePilot.evaluate(valid3Json, {\n        Monetization: \"Real\",\n        Leverage: 150,\n        CountryIso: \"FI\",\n      })\n    ).toEqual(3);\n\n    expect(\n      await RulePilot.evaluate(valid3Json, {\n        Monetization: \"Real\",", "      await RulePilot.evaluate(valid3Json, {\n        Monetization: \"Real\",\n        Leverage: 150,\n        CountryIso: \"FI\",\n        foo: \"bar\",\n        another: false,\n      })\n    ).toEqual(3);\n  });\n", "  });\n\n  it(\"Evaluates a simple ruleset with redundant condition\", async () => {\n    expect(await RulePilot.evaluate(valid4Json, { foo: true }, true)).toEqual(\n      2\n    );\n\n    expect(\n      await RulePilot.evaluate(valid4Json, { Category: \"Islamic\" }, true)\n    ).toEqual(4);", "      await RulePilot.evaluate(valid4Json, { Category: \"Islamic\" }, true)\n    ).toEqual(4);\n  });\n\n  it(\"Evaluates a simple ruleset with none type condition\", async () => {\n    expect(\n      await RulePilot.evaluate(valid2Json, {\n        Leverage: 100,\n        WinRate: 80,\n        AverageTradeDuration: 5,\n        Duration: 9000000,\n        TotalDaysTraded: 5,\n      })\n    ).toEqual(true);\n\n    expect(\n      await RulePilot.evaluate(valid2Json, {\n        AverageTradeDuration: 10,\n        Foo: 10,\n      })\n    ).toEqual(true);\n  });\n});\n"]}
{"filename": "test/builder.spec.ts", "chunked_list": ["import { Rule, RulePilot } from \"../src\";\n\ndescribe(\"RulePilot builder correctly\", () => {\n  it(\"Creates a valid ruleset\", () => {\n    const builder = RulePilot.builder();\n    expect(\n      RulePilot.validate(\n        builder\n          .add(\n            builder.condition(\"all\", [", "          .add(\n            builder.condition(\"all\", [\n              builder.constraint(\"field\", \"==\", \"value\"),\n            ])\n          )\n          .build()\n      ).isValid\n    ).toEqual(true);\n  });\n", "  });\n\n  it(\"Creates a complex ruleset properly\", () => {\n    const builder = RulePilot.builder();\n\n    const rule: Rule = builder\n      .add(\n        builder.condition(\n          \"all\",\n          [", "          \"all\",\n          [\n            builder.condition(\"any\", [\n              builder.constraint(\"fieldA\", \"==\", \"bar\"),\n              builder.constraint(\"fieldB\", \">=\", 2),\n            ]),\n            builder.constraint(\"fieldC\", \"not in\", [1, 2, 3]),\n          ],\n          3\n        )", "          3\n        )\n      )\n      .add(builder.condition(\"none\", [], 5))\n      .add(\n        builder.condition(\"any\", [builder.constraint(\"fieldA\", \"==\", \"value\")])\n      )\n      .default(2)\n      .build(true);\n", "      .build(true);\n\n    expect(rule).toEqual({\n      conditions: [\n        {\n          all: [\n            {\n              any: [\n                { field: \"fieldA\", operator: \"==\", value: \"bar\" },\n                { field: \"fieldB\", operator: \">=\", value: 2 },", "                { field: \"fieldA\", operator: \"==\", value: \"bar\" },\n                { field: \"fieldB\", operator: \">=\", value: 2 },\n              ],\n            },\n            { field: \"fieldC\", operator: \"not in\", value: [1, 2, 3] },\n          ],\n          result: 3,\n        },\n        { none: [], result: 5 },\n        {", "        { none: [], result: 5 },\n        {\n          any: [{ field: \"fieldA\", operator: \"==\", value: \"value\" }],\n        },\n      ],\n      default: 2,\n    });\n  });\n\n  it(\"Throws an error when validating an invalid ruleset\", () => {", "\n  it(\"Throws an error when validating an invalid ruleset\", () => {\n    const builder = RulePilot.builder();\n    expect(() =>\n      builder\n        .add(\n          builder.condition(\n            \"all\",\n            [\n              builder.condition(", "            [\n              builder.condition(\n                \"any\",\n                [\n                  builder.constraint(\"fieldA\", \"==\", \"bar\"),\n                  builder.constraint(\"fieldB\", \">=\", 2),\n                ],\n                \"Invalid!!\"\n              ),\n              builder.constraint(\"fieldC\", \"not in\", [1, 2, 3]),", "              ),\n              builder.constraint(\"fieldC\", \"not in\", [1, 2, 3]),\n            ],\n            3\n          )\n        )\n        .build(true)\n    ).toThrowError();\n  });\n});", "  });\n});\n"]}
{"filename": "test/rulesets/valid3.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\nexport const valid3Json: Rule = {\n  conditions: [\n    {\n      any: [\n        {\n          all: [\n            {\n              field: \"CountryIso\",", "            {\n              field: \"CountryIso\",\n              operator: \"in\",\n              value: [\"GB\", \"FI\"],\n            },\n            {\n              field: \"Leverage\",\n              operator: \"<\",\n              value: 200,\n            },", "              value: 200,\n            },\n            {\n              field: \"Monetization\",\n              operator: \"==\",\n              value: \"Real\",\n            },\n          ],\n        },\n        {", "        },\n        {\n          field: \"Leverage\",\n          operator: \">=\",\n          value: 1000,\n        },\n      ],\n      result: 3,\n    },\n    {", "    },\n    {\n      all: [\n        {\n          field: \"Category\",\n          operator: \"==\",\n          value: \"Islamic\",\n        },\n      ],\n      result: 4,", "      ],\n      result: 4,\n    },\n  ],\n  default: 2,\n};\n"]}
{"filename": "test/rulesets/invalid1.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\nexport const invalid1Json: Rule = {\n  conditions: [\n    {\n      any: [\n        {\n          all: [\n            {\n              field: \"CountryIso\",", "            {\n              field: \"CountryIso\",\n              operator: \"in\",\n              value: [\"GB\", \"FI\"],\n            },\n            {\n              field: \"Leverage\",\n              operator: \"<\",\n              value: 200,\n            },", "              value: 200,\n            },\n            {\n              field: \"Monetization\",\n              operator: \"==\",\n              value: \"Real\",\n            },\n          ],\n          // Result property is only allowed on the top level conditions\n          result: \"This is invalid!!!!!!!\",", "          // Result property is only allowed on the top level conditions\n          result: \"This is invalid!!!!!!!\",\n        },\n        {\n          all: [\n            {\n              field: \"Leverage\",\n              operator: \">=\",\n              value: 1000,\n            },", "              value: 1000,\n            },\n          ],\n        },\n      ],\n      result: 3,\n    },\n    {\n      all: [\n        {", "      all: [\n        {\n          field: \"Category\",\n          operator: \"==\",\n          value: \"Islamic\",\n        },\n      ],\n      result: 4,\n    },\n  ],", "    },\n  ],\n  default: 2,\n};\n"]}
{"filename": "test/rulesets/valid2.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\nexport const valid2Json: Rule = {\n  conditions: {\n    any: [\n      {\n        all: [\n          {\n            field: \"Leverage\",\n            operator: \"<=\",", "            field: \"Leverage\",\n            operator: \"<=\",\n            value: 100,\n          },\n          {\n            field: \"WinRate\",\n            operator: \">\",\n            value: 60,\n          },\n          {", "          },\n          {\n            field: \"AverageTradeDuration\",\n            operator: \"<\",\n            value: 60,\n          },\n          {\n            field: \"Duration\",\n            operator: \">\",\n            value: 259200,", "            operator: \">\",\n            value: 259200,\n          },\n          {\n            field: \"TotalDaysTraded\",\n            operator: \">=\",\n            value: 3,\n          },\n        ],\n      },", "        ],\n      },\n      {\n        none: [\n          {\n            field: \"AverageTradeDuration\",\n            operator: \"!=\",\n            value: 10,\n          },\n          {", "          },\n          {\n            field: \"Foo\",\n            operator: \"not in\",\n            value: [10, 11, 12],\n          },\n        ],\n      },\n    ],\n  },", "    ],\n  },\n} as Rule;\n"]}
{"filename": "test/rulesets/valid1.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\nexport const valid1Json: Rule = {\n  conditions: {\n    any: [\n      {\n        all: [\n          {\n            field: \"WinRate\",\n            operator: \">\",", "            field: \"WinRate\",\n            operator: \">\",\n            value: 60,\n          },\n          {\n            field: \"AverageTradeDuration\",\n            operator: \"<\",\n            value: 60,\n          },\n          {", "          },\n          {\n            field: \"Duration\",\n            operator: \">\",\n            value: 259200,\n          },\n          {\n            field: \"TotalDaysTraded\",\n            operator: \">=\",\n            value: 3,", "            operator: \">=\",\n            value: 3,\n          },\n        ],\n      },\n      {\n        all: [\n          {\n            field: \"ProfitPercentage\",\n            operator: \">=\",", "            field: \"ProfitPercentage\",\n            operator: \">=\",\n            value: 10,\n          },\n        ],\n      },\n    ],\n  },\n};\n", "};\n"]}
{"filename": "test/rulesets/valid4.json.ts", "chunked_list": ["import { Condition, Rule } from \"../../src\";\n\nexport const valid4Json: Rule = {\n  conditions: [\n    {\n      any: [\n        {\n          all: [\n            {\n              field: \"CountryIso\",", "            {\n              field: \"CountryIso\",\n              operator: \"in\",\n              value: [\"GB\", \"FI\"],\n            },\n            {\n              field: \"Leverage\",\n              operator: \"<\",\n              value: 200,\n            },", "              value: 200,\n            },\n            {\n              field: \"Monetization\",\n              operator: \"==\",\n              value: \"Real\",\n            },\n          ],\n        },\n        {", "        },\n        {\n          field: \"Leverage\",\n          operator: \">=\",\n          value: 1000,\n        },\n      ],\n      result: 3,\n    },\n    {", "    },\n    {\n      all: [\n        {\n          field: \"Category\",\n          operator: \"==\",\n          value: \"Islamic\",\n        },\n      ],\n      result: 4,", "      ],\n      result: 4,\n    },\n    {\n      foo: \"bar\",\n    } as Condition,\n  ],\n  default: 2,\n};\n", "};\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./types/rule\";\nexport * from \"./types/error\";\nexport { RulePilot } from \"./services/rule-pilot\";\nexport { ValidationResult } from \"./services/validator\";\n"]}
{"filename": "src/types/rule.ts", "chunked_list": ["export type ConditionType = \"any\" | \"all\" | \"none\";\nexport type Operator = \"==\" | \"!=\" | \">\" | \"<\" | \">=\" | \"<=\" | \"in\" | \"not in\";\n\nexport interface Constraint {\n  field: string;\n  operator: Operator;\n  value:\n    | string\n    | number\n    | boolean\n    | object\n    | (string | number | boolean | object)[];\n}\n", "export interface Condition<R = any> {\n  any?: (Constraint | Condition<R>)[];\n  all?: (Constraint | Condition<R>)[];\n  none?: (Constraint | Condition<R>)[];\n  result?: R;\n}\n\nexport interface Rule<R = any> {\n  conditions: Condition<R> | Condition<R>[];\n  default?: R;\n}\n"]}
{"filename": "src/types/error.ts", "chunked_list": ["import { ValidationResult } from \"../services/validator\";\n\nexport class RuleError extends Error {\n  constructor(validationResult: ValidationResult) {\n    super(validationResult.error.message);\n    this.element = validationResult.error.element;\n  }\n\n  /** The name/type of the error. */\n  type: string = RuleError.name;\n\n  /** The element that caused the error. */\n  element: object;\n}\n", "  /** The name/type of the error. */\n  type: string = RuleError.name;\n\n  /** The element that caused the error. */\n  element: object;\n}\n"]}
{"filename": "src/services/evaluator.ts", "chunked_list": ["import { ObjectDiscovery } from \"./object-discovery\";\nimport { Condition, Constraint, Rule } from \"../types/rule\";\n\nexport class Evaluator {\n  private _objectDiscovery: ObjectDiscovery = new ObjectDiscovery();\n\n  /**\n   * Evaluates a rule against a set of criteria and returns the result.\n   * If the criteria is an array (indicating multiple criteria to test),\n   * the rule will be evaluated against each item in the array and\n   * an array of results will be returned.\n   *\n   * @param rule The rule to evaluate.\n   * @param criteria The criteria to evaluate the rule against.\n   */\n  evaluate(rule: Rule, criteria: object | object[]): boolean | any {\n    // Cater for the case where the conditions property is not an array.\n    const conditions =\n      rule.conditions instanceof Array ? rule.conditions : [rule.conditions];\n", "    if (criteria instanceof Array) {\n      const result = [];\n      for (const c of criteria) {\n        result.push(this.evaluateRule(conditions, c, rule?.default));\n      }\n\n      return result;\n    }\n\n    return this.evaluateRule(conditions, criteria, rule?.default);\n  }\n\n  /**\n   * Evaluates a rule against a set of criteria and returns the result.\n   * @param conditions The conditions to evaluate.\n   * @param criteria The criteria to evaluate the conditions against.\n   * @param defaultResult The default result to return if no conditions pass.\n   */\n  private evaluateRule(\n    conditions: Condition[],\n    criteria: object,\n    defaultResult?: any\n  ): boolean | any {\n    // We should evaluate all conditions and return the result\n    // of the first condition that passes.", "    for (const condition of conditions) {\n      const result = this.evaluateCondition(condition, criteria);\n      if (result) {\n        return condition?.result ?? true;\n      }\n    }\n\n    // If no conditions pass, we should return the default result of\n    // the rule or false if no default result is provided.\n    return defaultResult ?? false;\n  }\n\n  /**\n   * Evaluates a condition against a set of criteria and returns the result.\n   * Uses recursion to evaluate nested conditions.\n   * @param condition The condition to evaluate.\n   * @param criteria The criteria to evaluate the condition against.\n   */\n  private evaluateCondition(condition: Condition, criteria: object): boolean {\n    // The condition must have an 'any' or 'all' property.\n    const type = this._objectDiscovery.conditionType(condition);", "    if (!type) {\n      return false;\n    }\n\n    // If the type is 'all' or 'none', we should set the initial\n    // result to true, otherwise we should set it to false.\n    let result = [\"all\", \"none\"].includes(type);\n\n    // Check each node in the condition.\n    for (const node of condition[type]) {\n      let fn;", "    for (const node of condition[type]) {\n      let fn;\n      if (this._objectDiscovery.isCondition(node)) {\n        fn = \"evaluateCondition\";\n      }\n      if (this._objectDiscovery.isConstraint(node)) {\n        fn = \"checkConstraint\";\n      }\n\n      // Process the node\n      switch (type) {\n        case \"any\":\n          result = result || this[fn](node, criteria);\n          break;\n        case \"all\":\n          result = result && this[fn](node, criteria);\n          break;\n        case \"none\":\n          result = result && !this[fn](node, criteria);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Checks a constraint against a set of criteria and returns true whenever the constraint passes.\n   * @param constraint The constraint to evaluate.\n   * @param criteria The criteria to evaluate the constraint with.\n   */\n  private checkConstraint(constraint: Constraint, criteria: object): boolean {\n    // If the value contains '.' we should assume it is a nested property\n    const criterion = constraint.field.includes(\".\")\n      ? this._objectDiscovery.resolveNestedProperty(constraint.field, criteria)\n      : criteria[constraint.field];\n\n    // If the criteria object does not have the field\n    // we are looking for, we should return false.", "    if (!criterion) {\n      return false;\n    }\n\n    switch (constraint.operator) {\n      case \"==\":\n        return criterion == constraint.value;\n      case \"!=\":\n        return criterion != constraint.value;\n      case \">\":\n        return criterion > constraint.value;\n      case \">=\":\n        return criterion >= constraint.value;\n      case \"<\":\n        return criterion < constraint.value;\n      case \"<=\":\n        return criterion <= constraint.value;\n      case \"in\":\n        return (\n          Array.isArray(constraint.value) &&\n          constraint.value.includes(criterion as never)\n        );\n      case \"not in\":\n        return (\n          !Array.isArray(constraint.value) ||\n          !constraint.value.includes(criterion as never)\n        );\n      default:\n        return false;\n    }\n  }\n}\n"]}
{"filename": "src/services/mutator.ts", "chunked_list": ["import { createHash } from \"crypto\";\nimport { EventEmitter } from \"events\";\n\nimport { Logger } from \"./logger\";\nimport { ObjectDiscovery } from \"./object-discovery\";\n\nexport class Mutator {\n  private _cache: Map<string, any> = new Map();\n  private _buffer: Map<string, boolean> = new Map();\n  private _mutations: Map<string, Function> = new Map();\n\n  private _objectDiscovery = new ObjectDiscovery();\n  private _eventEmitter = new EventEmitter();\n\n  /**\n   * Adds a mutation to the mutator instance.\n   * @param name The name of the mutation.\n   * @param mutation The mutation function.\n   */\n  add(name: string, mutation: Function): void {\n    this._mutations.set(name, mutation);\n  }\n\n  /**\n   * Removes a mutation to the mutator instance.\n   * Any cached mutation values for this mutation will be purged.\n   * @param name The name of the mutation.\n   */\n  remove(name: string): void {\n    this.clearCache(name);\n    this._mutations.delete(name);\n  }\n\n  /**\n   * Clears the mutator cache.\n   * The entire cache, or cache for a specific mutator, can be cleared\n   * by passing or omitting the mutator name as an argument.\n   * @param name The mutator name to clear the cache for.\n   */\n  clearCache(name?: string): void {", "    if (!name) {\n      this._cache.clear();\n      return;\n    }\n\n    for (const key of this._cache.keys()) {\n      if (key.startsWith(name)) {\n        this._cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Mutates and returns a criteria object.\n   * @param criteria The criteria to mutate.\n   */\n  async mutate(criteria: object | object[]): Promise<object | object[]> {\n    // Handles checking the mutability of a criteria object\n    // If it is mutable it will be cloned, mutated and returned\n    const exec = async (criteria) => {\n      // If there are no mutations or the criteria does not contain\n      // any of the mutation keys, return the criteria as is.", "      if (!this._mutations.size || !this.hasMutations(criteria)) {\n        return criteria;\n      }\n\n      // Make a copy of the criteria.\n      const copy = { ...criteria };\n\n      // Apply the mutations to the copy and return it.\n      await this.applyMutations(copy);\n      return copy;\n    };\n\n    // If the criteria is an array, we want to apply the mutations\n    // to each item in the array in parallel.", "    if (criteria instanceof Array) {\n      return await Promise.all(\n        criteria.map(\n          (c) =>\n            new Promise(async (resolve) => {\n              resolve(await exec(c));\n            })\n        )\n      );\n    } else {\n      return await exec(criteria);\n    }\n  }\n\n  /**\n   * Checks if the criteria contains any mutate-able properties.\n   * @param criteria The criteria to check.\n   * @param result Whether a mutate-able property has been found.\n   * @param parentPath The parent path to the current property.\n   */\n  private hasMutations(\n    criteria: object,\n    result: boolean = false,\n    parentPath: string = \"\"\n  ): boolean {\n    // If we have already found a mutation, we can stop.", "    if (result) return true;\n\n    for (const key of Object.keys(criteria)) {\n      if (result) return true;\n\n      // Prepare dotted path to the current property.\n      const path = parentPath ? `${parentPath}.${key}` : key;\n\n      // If the value is an object, we should recurse.\n      result = this._objectDiscovery.isObject(criteria[key])\n        ? result || this.hasMutations(criteria[key], result, path)\n        : result || this._mutations.has(path);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recursively applies mutations to the criteria.\n   * @param criteria The criteria to mutate.\n   * @param parentPath The parent path to the current property.\n   */\n  private async applyMutations(\n    criteria: object,\n    parentPath: string = \"\"\n  ): Promise<void> {\n    const promises = Object.keys(criteria).map(\n      async (key) =>\n        new Promise(async (resolve) => {\n          // Prepare dotted path to the current property.\n          const path = parentPath ? `${parentPath}.${key}` : key;\n", "          if (this._objectDiscovery.isObject(criteria[key])) {\n            await this.applyMutations(criteria[key], path);\n          }\n\n          if (this._mutations.has(path)) {\n            criteria[key] = await this.execMutation(key, criteria, path);\n          }\n\n          resolve(criteria[key]);\n        })\n    );\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * Executes a mutation.\n   * Defers duplicate executions to the same object from a memory cache.\n   * @param criteriaProp The criteria property to execute the mutation on.\n   * @param criteria The criteria to execute the mutation with.\n   * @param mutationKey The key of the mutation to execute.\n   */\n  private async execMutation(\n    criteriaProp: string,\n    criteria: unknown,\n    mutationKey: string\n  ): Promise<any> {\n    const value = criteria[criteriaProp];\n\n    // Create a cache key\n    const cacheKey = `${mutationKey}${createHash(\"md5\")\n      .update(value.toString())\n      .digest(\"hex\")}`;\n\n    // If the mutation has already been executed, return the cached result.", "    if (this._cache.has(cacheKey)) {\n      Logger.debug(`Cache hit on \"${mutationKey}\" with param \"${value}\"`);\n      return this._cache.get(cacheKey);\n    }\n\n    // If the mutation is already in progress, wait for it to finish.\n    if (this._buffer.get(cacheKey)) {\n      return await new Promise((resolve) => {\n        Logger.debug(\n          `Waiting on mutation \"${mutationKey}\" with param \"${value}\"`\n        );\n        this._eventEmitter.once(`mutation:${cacheKey}`, (result) => {\n          Logger.debug(\n            `Resolved mutation \"${mutationKey}\" with param \"${value}\"`\n          );\n          resolve(result);\n        });\n      });\n    }\n\n    // Set the buffer to true to indicate that the mutation is in progress.\n    // This prevents duplicate executions of the same mutation.\n    this._buffer.set(cacheKey, true);\n\n    // Execute the mutation\n    Logger.debug(`Running mutation \"${mutationKey}\" with param \"${value}\"`);\n    const mutation = this._mutations.get(mutationKey);\n    const result = await mutation(value, criteria);\n\n    // Cache the result and release the buffer to false.\n    this._cache.set(cacheKey, result);\n    this._buffer.set(cacheKey, false);\n\n    // Emit an event to indicate that the mutation has been executed.\n    this._eventEmitter.emit(`mutation:${cacheKey}`, result);\n\n    return result;\n  }\n}\n"]}
{"filename": "src/services/builder.ts", "chunked_list": ["import {\n  Rule,\n  Operator,\n  Condition,\n  Constraint,\n  ConditionType,\n} from \"../types/rule\";\nimport { Validator } from \"./validator\";\nimport { RuleError } from \"../types/error\";\n\nexport class Builder {\n  constructor(validator: Validator) {\n    this.validator = validator;\n  }\n\n  /** Stores to rule being constructed */\n  private rule: Rule = { conditions: [] };\n\n  /** Holds a reference to the Validator class */\n  private validator: Validator;\n\n  /**\n   * Adds a node (in the root) to the rule being constructed\n   * @param node The node to add to the rule\n   */\n  add(node: Condition): Builder {\n    (this.rule.conditions as Condition[]).push(node);\n    return this;\n  }\n\n  /**\n   * Sets the default value of the rule being constructed\n   * @param value The default value of the rule\n   */\n  default(value: Rule[\"default\"]): Builder {\n    this.rule.default = value;\n    return this;\n  }\n\n  /**\n   * Builds the rule being and returns it\n   * @param validate Whether to validate the rule before returning it\n   * @throws Error if validation is enabled and the rule is invalid\n   */\n  build(validate?: boolean): Rule {", "import { RuleError } from \"../types/error\";\n\nexport class Builder {\n  constructor(validator: Validator) {\n    this.validator = validator;\n  }\n\n  /** Stores to rule being constructed */\n  private rule: Rule = { conditions: [] };\n\n  /** Holds a reference to the Validator class */\n  private validator: Validator;\n\n  /**\n   * Adds a node (in the root) to the rule being constructed\n   * @param node The node to add to the rule\n   */\n  add(node: Condition): Builder {\n    (this.rule.conditions as Condition[]).push(node);\n    return this;\n  }\n\n  /**\n   * Sets the default value of the rule being constructed\n   * @param value The default value of the rule\n   */\n  default(value: Rule[\"default\"]): Builder {\n    this.rule.default = value;\n    return this;\n  }\n\n  /**\n   * Builds the rule being and returns it\n   * @param validate Whether to validate the rule before returning it\n   * @throws Error if validation is enabled and the rule is invalid\n   */\n  build(validate?: boolean): Rule {", "    if (!validate) {\n      return this.rule;\n    }\n\n    const validationResult = this.validator.validate(this.rule);\n    if (validationResult.isValid) {\n      return this.rule;\n    }\n\n    throw new RuleError(validationResult);\n  }\n\n  /**\n   * Creates a new condition node", "   * @param type The type of condition\n   * @param nodes Any child nodes of the condition\n   * @param result The result of the condition node (for granular rules)\n   */\n  condition(\n    type: ConditionType,\n    nodes: Condition[ConditionType],\n    result?: Condition[\"result\"]\n  ): Condition {\n    return {\n      [type]: nodes,\n      ...(result ? { result } : {}),\n    };\n  }\n\n  /**\n   * Creates a new constraint node\n   * @param field The field to apply the constraint to\n   * @param operator The operator to apply to the field\n   * @param value The value to compare the field to\n   */\n  constraint(\n    field: string,\n    operator: Operator,\n    value: Constraint[\"value\"]\n  ): Constraint {\n    return {\n      field,\n      operator,\n      value,\n    };\n  }\n}\n"]}
{"filename": "src/services/logger.ts", "chunked_list": ["export class Logger {\n  static debug(message: string): void {\n    if (!process.env.DEBUG) return;\n    console.debug(message);\n  }\n}\n"]}
{"filename": "src/services/object-discovery.ts", "chunked_list": ["import { Condition, ConditionType, Constraint } from \"../types/rule\";\n\nexport class ObjectDiscovery {\n  /**\n   * Returns the type of condition passed to the function.\n   * @param condition The condition to check.\n   */\n  conditionType(condition: Condition): ConditionType | null {\n    if (\"any\" in condition) return \"any\";\n    if (\"all\" in condition) return \"all\";\n    if (\"none\" in condition) return \"none\";\n\n    return null;\n  }\n\n  /**\n   * Checks an object to see if it is a valid condition.\n   * @param obj The object to check.\n   */\n  isCondition(obj: unknown): obj is Condition {\n    return !this.isObject(obj)\n      ? false\n      : \"any\" in obj || \"all\" in obj || \"none\" in obj;\n  }\n\n  /**\n   * Checks an object to see if it is a valid constraint.\n   * @param obj The object to check.\n   */\n  isConstraint(obj: unknown): obj is Constraint {\n    return !this.isObject(obj)\n      ? false\n      : \"field\" in obj && \"operator\" in obj && \"value\" in obj;\n  }\n\n  /**\n   * Returns true if the passed parameter is an object.\n   * @param obj The item to test.\n   */\n  isObject(obj: unknown): obj is object {\n    return \"object\" === typeof obj && !Array.isArray(obj) && obj !== null;\n  }\n\n  /**\n   * Resolves a nested property from a sting as an object path.\n   * @param path The path to resolve.\n   * @param obj The object to resolve the path against.\n   */\n  resolveNestedProperty(path, obj): any {\n    return path.split(\".\").reduce((prev, curr) => prev?.[curr], obj);\n  }\n}\n", "    if (\"any\" in condition) return \"any\";\n    if (\"all\" in condition) return \"all\";\n    if (\"none\" in condition) return \"none\";\n\n    return null;\n  }\n\n  /**\n   * Checks an object to see if it is a valid condition.\n   * @param obj The object to check.\n   */\n  isCondition(obj: unknown): obj is Condition {\n    return !this.isObject(obj)\n      ? false\n      : \"any\" in obj || \"all\" in obj || \"none\" in obj;\n  }\n\n  /**\n   * Checks an object to see if it is a valid constraint.\n   * @param obj The object to check.\n   */\n  isConstraint(obj: unknown): obj is Constraint {\n    return !this.isObject(obj)\n      ? false\n      : \"field\" in obj && \"operator\" in obj && \"value\" in obj;\n  }\n\n  /**\n   * Returns true if the passed parameter is an object.\n   * @param obj The item to test.\n   */\n  isObject(obj: unknown): obj is object {\n    return \"object\" === typeof obj && !Array.isArray(obj) && obj !== null;\n  }\n\n  /**\n   * Resolves a nested property from a sting as an object path.\n   * @param path The path to resolve.\n   * @param obj The object to resolve the path against.\n   */\n  resolveNestedProperty(path, obj): any {\n    return path.split(\".\").reduce((prev, curr) => prev?.[curr], obj);\n  }\n}\n"]}
{"filename": "src/services/rule-pilot.ts", "chunked_list": ["import { Builder } from \"./builder\";\nimport { Mutator } from \"./mutator\";\nimport { Evaluator } from \"./evaluator\";\nimport { ValidationResult, Validator } from \"./validator\";\n\nimport { Rule } from \"../types/rule\";\nimport { RuleError } from \"../types/error\";\n\nexport class RulePilot {\n  private static _rulePilot = new RulePilot();\n\n  private _mutator: Mutator = new Mutator();\n  private _validator: Validator = new Validator();\n  private _evaluator: Evaluator = new Evaluator();\n\n  /**", "export class RulePilot {\n  private static _rulePilot = new RulePilot();\n\n  private _mutator: Mutator = new Mutator();\n  private _validator: Validator = new Validator();\n  private _evaluator: Evaluator = new Evaluator();\n\n  /**\n   * Returns a rule builder class instance.\n   * Allows for the construction of rules using a fluent interface.\n   */\n  builder(): Builder {\n    return new Builder(this._validator);\n  }\n\n  /**\n   * Adds a mutation to the rule pilot instance.\n   * Mutations allow for the modification of the criteria before\n   * it is evaluated against a rule.\n   *\n   * @param name The name of the mutation.\n   * @param mutation The mutation function.\n   */\n  addMutation(name: string, mutation: Function): RulePilot {\n    this._mutator.add(name, mutation);\n    return this;\n  }\n\n  /**\n   * Removes a mutation to the rule pilot instance.\n   * Any cached mutation values for this mutation will be purged.\n   *\n   * @param name The name of the mutation.\n   */\n  removeMutation(name: string): RulePilot {\n    this._mutator.remove(name);\n    return this;\n  }\n\n  /**\n   * Clears the mutator cache.\n   * The entire cache, or cache for a specific mutator, can be cleared\n   * by passing or omitting the mutator name as an argument.\n   *\n   * @param name The mutator name to clear the cache for.\n   */\n  clearMutationCache(name?: string): RulePilot {\n    this._mutator.clearCache(name);\n    return this;\n  }\n\n  /**\n   * Evaluates a rule against a set of criteria and returns the result.\n   * If the criteria is an array (indicating multiple criteria to test),\n   * the rule will be evaluated against each item in the array and\n   * an array of results will be returned.\n   *\n   * @param rule The rule to evaluate.\n   * @param criteria The criteria to evaluate the rule against.\n   * @param trustRule Set true to avoid validating the rule before evaluating it (faster).\n   * @throws Error if the rule is invalid.\n   */\n  async evaluate<T>(\n    rule: Rule,\n    criteria: object | object[],\n    trustRule = false\n  ): Promise<T> {\n    // Before we evaluate the rule, we should validate it.\n    // If `trustRuleset` is set to true, we will skip validation.\n    const validationResult = !trustRule && this.validate(rule);", "   * Returns a rule builder class instance.\n   * Allows for the construction of rules using a fluent interface.\n   */\n  builder(): Builder {\n    return new Builder(this._validator);\n  }\n\n  /**\n   * Adds a mutation to the rule pilot instance.\n   * Mutations allow for the modification of the criteria before\n   * it is evaluated against a rule.\n   *\n   * @param name The name of the mutation.\n   * @param mutation The mutation function.\n   */\n  addMutation(name: string, mutation: Function): RulePilot {\n    this._mutator.add(name, mutation);\n    return this;\n  }\n\n  /**\n   * Removes a mutation to the rule pilot instance.\n   * Any cached mutation values for this mutation will be purged.\n   *\n   * @param name The name of the mutation.\n   */\n  removeMutation(name: string): RulePilot {\n    this._mutator.remove(name);\n    return this;\n  }\n\n  /**\n   * Clears the mutator cache.\n   * The entire cache, or cache for a specific mutator, can be cleared\n   * by passing or omitting the mutator name as an argument.\n   *\n   * @param name The mutator name to clear the cache for.\n   */\n  clearMutationCache(name?: string): RulePilot {\n    this._mutator.clearCache(name);\n    return this;\n  }\n\n  /**\n   * Evaluates a rule against a set of criteria and returns the result.\n   * If the criteria is an array (indicating multiple criteria to test),\n   * the rule will be evaluated against each item in the array and\n   * an array of results will be returned.\n   *\n   * @param rule The rule to evaluate.\n   * @param criteria The criteria to evaluate the rule against.\n   * @param trustRule Set true to avoid validating the rule before evaluating it (faster).\n   * @throws Error if the rule is invalid.\n   */\n  async evaluate<T>(\n    rule: Rule,\n    criteria: object | object[],\n    trustRule = false\n  ): Promise<T> {\n    // Before we evaluate the rule, we should validate it.\n    // If `trustRuleset` is set to true, we will skip validation.\n    const validationResult = !trustRule && this.validate(rule);", "    if (!trustRule && !validationResult.isValid) {\n      throw new RuleError(validationResult);\n    }\n\n    return this._evaluator.evaluate(rule, await this._mutator.mutate(criteria));\n  }\n\n  /**\n   * Takes in a rule as a parameter and returns a ValidationResult\n   * indicating whether the rule is valid or not.\n   *\n   * Invalid rules will contain an error property which contains a message and the element\n   * that caused the validation to fail.\n   *\n   * @param rule The rule to validate.\n   */\n  validate(rule: Rule): ValidationResult {\n    return this._validator.validate(rule);\n  }\n\n  /**", "   * Returns a rule builder class instance.\n   * Allows for the construction of rules using a fluent interface.\n   */\n  static builder(): Builder {\n    return this._rulePilot.builder();\n  }\n\n  /**\n   * Evaluates a rule against a set of criteria and returns the result.\n   * If the criteria is an array (indicating multiple criteria to test),\n   * the rule will be evaluated against each item in the array and\n   * an array of results will be returned.\n   *\n   * @param rule The rule to evaluate.\n   * @param criteria The criteria to evaluate the rule against.\n   * @param trustRule Set true to avoid validating the rule before evaluating it (faster).\n   * @throws Error if the rule is invalid.\n   */\n  static async evaluate<T>(\n    rule: Rule,\n    criteria: object | object[],\n    trustRule = false\n  ): Promise<T> {\n    return RulePilot._rulePilot.evaluate<T>(rule, criteria, trustRule);\n  }\n\n  /**\n   * Takes in a rule as a parameter and returns a ValidationResult\n   * indicating whether the rule is valid or not.\n   *\n   * Invalid rules will contain an error property which contains a message and the element\n   * that caused the validation to fail.\n   *\n   * @param rule The rule to validate.\n   */\n  static validate(rule: Rule): ValidationResult {\n    return RulePilot._rulePilot.validate(rule);\n  }\n\n  /**\n   * Adds a mutation.\n   *\n   * Mutations allow for the modification of the criteria before\n   * it is evaluated against a rule.\n   *\n   * @param name The name of the mutation.\n   * @param mutation The mutation function.\n   */\n  static addMutation(name: string, mutation: Function): RulePilot {\n    return RulePilot._rulePilot.addMutation(name, mutation);\n  }\n\n  /**\n   * Removes a mutation to the rule pilot instance.\n   * Any cached mutation values for this mutation will be purged.\n   *\n   * @param name The name of the mutation.\n   */\n  static removeMutation(name: string): RulePilot {\n    return RulePilot._rulePilot.removeMutation(name);\n  }\n\n  /**\n   * Clears the mutator cache.\n   * The entire cache, or cache for a specific mutator, can be cleared\n   * by passing or omitting the mutator name as an argument.\n   *\n   * @param name The mutator name to clear the cache for.\n   */\n  static clearMutationCache(name?: string): RulePilot {\n    return RulePilot._rulePilot.clearMutationCache(name);\n  }\n}\n"]}
{"filename": "src/services/validator.ts", "chunked_list": ["import { ObjectDiscovery } from \"./object-discovery\";\nimport { Condition, Constraint, Operator, Rule } from \"../types/rule\";\n\nexport interface ValidationResult {\n  isValid: boolean;\n  error?: {\n    message: string;\n    element: object;\n  };\n}\n", "export class Validator {\n  private objectDiscovery: ObjectDiscovery = new ObjectDiscovery();\n\n  /**\n   * Takes in a rule as a parameter and returns a boolean indicating whether the rule is valid or not.\n   * @param rule The rule to validate.\n   */\n  validate(rule: Rule): ValidationResult {\n    // Assume the rule is valid.\n    let result: ValidationResult = { isValid: true };\n\n    // Check the rule is a valid JSON", "    if (!this.objectDiscovery.isObject(rule)) {\n      return {\n        isValid: false,\n        error: {\n          message: \"The rule must be a valid JSON object.\",\n          element: rule,\n        },\n      };\n    }\n\n    // Cater for the case where the conditions property is not an array.\n    const conditions =\n      rule.conditions instanceof Array ? rule.conditions : [rule.conditions];\n\n    // Validate the 'conditions' property.", "    if (\n      conditions.length === 0 ||\n      (this.objectDiscovery.isObject(conditions[0]) &&\n        !Object.keys(conditions[0]).length)\n    ) {\n      return {\n        isValid: false,\n        error: {\n          message:\n            \"The conditions property must contain at least one condition.\",\n          element: rule,\n        },\n      };\n    }\n\n    // Validate each condition in the rule.", "    for (const condition of conditions) {\n      const subResult = this.validateCondition(condition);\n      result.isValid = result.isValid && subResult.isValid;\n      result.error = result?.error ?? subResult?.error;\n    }\n\n    return result;\n  }\n\n  /** ml/l.k,\n   * Evaluates a condition to ensure it is syntactically correct.\n   * @param condition The condition to validate.\n   * @param depth The current recursion depth\n   */\n  private validateCondition(\n    condition: Condition,\n    depth: number = 0\n  ): ValidationResult {\n    // Check to see if the condition is valid.\n    let result = this.isValidCondition(condition);", "    if (!result.isValid) {\n      return result;\n    }\n\n    // Set the type of condition.\n    const type = this.objectDiscovery.conditionType(condition);\n\n    // Check if the condition is iterable\n    if(!Array.isArray(condition[type])) {\n      return {\n        isValid: false,\n        error: {\n          message: `The condition '${type}' should be iterable.`,\n          element: condition,\n        },\n      };\n    }\n\n    // Validate each item in the condition.", "    if(!Array.isArray(condition[type])) {\n      return {\n        isValid: false,\n        error: {\n          message: `The condition '${type}' should be iterable.`,\n          element: condition,\n        },\n      };\n    }\n\n    // Validate each item in the condition.", "    for (const node of condition[type]) {\n      const isCondition = this.objectDiscovery.isCondition(node);\n      if (isCondition) {\n        const subResult = this.validateCondition(node as Condition, depth + 1);\n        result.isValid = result.isValid && subResult.isValid;\n        result.error = result?.error ?? subResult?.error;\n      }\n\n      const isConstraint = this.objectDiscovery.isConstraint(node);\n      if (isConstraint) {\n        const subResult = this.validateConstraint(node as Constraint);\n        result.isValid = result.isValid && subResult.isValid;\n        result.error = result?.error ?? subResult?.error;\n      }\n", "      if (isConstraint) {\n        const subResult = this.validateConstraint(node as Constraint);\n        result.isValid = result.isValid && subResult.isValid;\n        result.error = result?.error ?? subResult?.error;\n      }\n\n      if (!isConstraint && !isCondition) {\n        return {\n          isValid: false,\n          error: {\n            message: \"Each node should be a condition or constraint.\",\n            element: node,\n          },\n        };\n      }\n\n      // Result is only valid on the root condition.", "      if (depth > 0 && \"result\" in condition) {\n        return {\n          isValid: false,\n          error: {\n            message: 'Nested conditions cannot have a property \"result\".',\n            element: node,\n          },\n        };\n      }\n\n      // If any part fails validation there is no point to continue.", "      if (!result.isValid) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Checks a constraint to ensure it is syntactically correct.\n   * @param constraint The constraint to validate.\n   */\n  private validateConstraint(constraint: Constraint): ValidationResult {", "    if (\"string\" !== typeof constraint.field) {\n      return {\n        isValid: false,\n        error: {\n          message: 'Constraint \"field\" must be of type string.',\n          element: constraint,\n        },\n      };\n    }\n\n    const operators = [\"==\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"in\", \"not in\"];", "    if (!operators.includes(constraint.operator as Operator)) {\n      return {\n        isValid: false,\n        error: {\n          message: 'Constraint \"operator\" has invalid type.',\n          element: constraint,\n        },\n      };\n    }\n\n    // We must check that the value is an array if the operator is 'in' or 'not in'.", "    if (\n      [\"in\", \"not in\"].includes(constraint.operator) &&\n      !Array.isArray(constraint.value)\n    ) {\n      return {\n        isValid: false,\n        error: {\n          message:\n            'Constraint \"value\" must be an array if the \"operator\" is \"in\" or \"not in\"',\n          element: constraint,\n        },\n      };\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Checks an object to see if it is a valid condition.\n   * @param obj The object to check.\n   */\n  private isValidCondition(obj: any): ValidationResult {", "    if (!this.objectDiscovery.isCondition(obj)) {\n      return {\n        isValid: false,\n        error: {\n          message: \"Invalid condition structure.\",\n          element: obj,\n        },\n      };\n    }\n\n    const isAny = \"any\" in obj;\n    const isAll = \"all\" in obj;\n    const isNone = \"none\" in obj;\n\n    // A valid condition must have an 'any', 'all', or 'none' property,\n    // but cannot have more than one.", "    if ((isAny && isAll) || (isAny && isNone) || (isAll && isNone)) {\n      return {\n        isValid: false,\n        error: {\n          message:\n            'A condition cannot have more than one \"any\", \"all\", or \"none\" property.',\n          element: obj,\n        },\n      };\n    }\n\n    return { isValid: true };\n  }\n}\n"]}
