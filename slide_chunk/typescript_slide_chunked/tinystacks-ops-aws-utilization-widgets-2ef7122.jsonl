{"filename": "test/index.test.ts", "chunked_list": ["import { helloWorld } from '../src';\n\ndescribe('index tests', () => {\n  beforeEach(() => {\n    jest.spyOn(global.console, 'log');\n  });\n  afterEach(() => {\n    // for mocks\n    jest.resetAllMocks();\n    // for spies", "    jest.resetAllMocks();\n    // for spies\n    jest.restoreAllMocks();\n  });\n  it('logs hello world to the console', () => {\n    helloWorld();\n\n    expect(global.console.log).toBeCalled();\n    expect(global.console.log).toBeCalledWith('Hello world!');\n  });", "    expect(global.console.log).toBeCalledWith('Hello world!');\n  });\n});"]}
{"filename": "test/mocks/MockCache.ts", "chunked_list": ["export class MockCache {\n  cacheName?: string;\n  options?: Record<string, any>;\n  get: jest.Mock<(key: string) => Promise<any>>;\n  set: jest.Mock<(key: string, value: any) => Promise<void>>;\n  getOrElse: jest.Mock<(key: string, refreshFunction: (...args: any[]) => Promise<any>) => Promise<any>>;\n\n  constructor (cacheName?: string, options?: Record<string, any>) {\n    this.cacheName = cacheName;\n    this.options = options;\n    this.get = jest.fn();\n    this.set = jest.fn();\n    this.getOrElse = jest.fn();\n  }\n\n  reset () {\n    this.get.mockReset();\n    this.set.mockReset();\n    this.getOrElse.mockReset();\n  }\n  \n  restore () {\n    this.get.mockRestore();\n    this.set.mockRestore();\n    this.getOrElse.mockRestore();\n  }\n}\n", "export function mockCache (cacheName: string, options: Record<string, any>): MockCache {\n  return new MockCache(cacheName, options);\n}"]}
{"filename": "test/service-utilizations/aws-cloudwatch-logs-utilization.test.ts", "chunked_list": ["jest.useFakeTimers();\njest.setSystemTime(new Date('2023-04-14T00:00:00.000Z'));\n\nconst mockCloudWatchLogs = jest.fn();\nconst mockDescribeLogGroups = jest.fn();\nconst mockDescribeLogStreams = jest.fn();\nconst mockGetCredentials = jest.fn();\nconst mockPutRetentionPolicy = jest.fn();\nconst mockDeleteLogGroup = jest.fn();\nconst mockCreateExportTask = jest.fn();", "const mockDeleteLogGroup = jest.fn();\nconst mockCreateExportTask = jest.fn();\nconst mockAccount = jest.fn();\nconst mockListRegions = jest.fn();\nconst mockCloudFormation = jest.fn();\nconst mockDescribeStackResources = jest.fn();\nconst mockCloudWatch = jest.fn();\nconst mockGetMetricData = jest.fn();\n\njest.mock('@aws-sdk/client-cloudwatch-logs', () => {", "\njest.mock('@aws-sdk/client-cloudwatch-logs', () => {\n  const original = jest.requireActual('@aws-sdk/client-cloudwatch-logs');\n  return {\n    ...original,\n    CloudWatchLogs: mockCloudWatchLogs\n  };\n});\n\njest.mock('@aws-sdk/client-account', () => {", "\njest.mock('@aws-sdk/client-account', () => {\n  const original = jest.requireActual('@aws-sdk/client-account');\n  return {\n    ...original,\n    Account: mockAccount\n  };\n});\n\njest.mock('@aws-sdk/client-cloudformation', () => {", "\njest.mock('@aws-sdk/client-cloudformation', () => {\n  return {\n    CloudFormation: mockCloudFormation\n  }\n});\n\njest.mock('@aws-sdk/client-cloudwatch', () => {\n  return {\n    CloudWatch: mockCloudWatch", "  return {\n    CloudWatch: mockCloudWatch\n  }\n});\n\nconst TEN_GB_IN_BYTES = 10737418240;\n\nimport { CloudWatchLogs } from \"@aws-sdk/client-cloudwatch-logs\";\nimport { AwsCredentialsProvider } from \"@tinystacks/ops-aws-core-widgets\";\nimport { AwsCloudwatchLogsUtilization } from \"../../src/service-utilizations/aws-cloudwatch-logs-utilization\";", "import { AwsCredentialsProvider } from \"@tinystacks/ops-aws-core-widgets\";\nimport { AwsCloudwatchLogsUtilization } from \"../../src/service-utilizations/aws-cloudwatch-logs-utilization\";\n\ndescribe('AwsCloudwatchLogsUtilization', () => {\n  beforeEach(() => {\n    mockCloudWatchLogs.mockReturnValue({\n      describeLogGroups: mockDescribeLogGroups,\n      describeLogStreams: mockDescribeLogStreams,\n      putRetentionPolicy: mockPutRetentionPolicy,\n      deleteLogGroup: mockDeleteLogGroup,", "      putRetentionPolicy: mockPutRetentionPolicy,\n      deleteLogGroup: mockDeleteLogGroup,\n      createExportTask: mockCreateExportTask\n    });\n    mockAccount.mockReturnValue({\n      listRegions: mockListRegions\n    });\n    mockCloudFormation.mockReturnValue({\n      describeStackResources: mockDescribeStackResources\n    });", "      describeStackResources: mockDescribeStackResources\n    });\n    mockCloudWatch.mockReturnValue({\n      getMetricData: mockGetMetricData\n    });\n  });\n\n  afterEach(() => {\n    // for mocks\n    jest.resetAllMocks();", "    // for mocks\n    jest.resetAllMocks();\n    // for spies\n    jest.restoreAllMocks();\n  });\n\n  describe('getUtilization', () => {\n    beforeEach(() => {\n      mockListRegions.mockResolvedValue({\n        Regions: [{", "      mockListRegions.mockResolvedValue({\n        Regions: [{\n          RegionName: 'us-east-1'\n        }]\n      });\n      mockDescribeStackResources.mockResolvedValue({\n        StackResources: [{\n          StackId: 'mock-stack'\n        }]\n      });", "        }]\n      });\n    });\n    afterEach(() => {\n      // for mocks\n      jest.resetAllMocks();\n      // for spies\n      jest.restoreAllMocks();\n    });\n", "    });\n\n    it('suggests adding a retention policy if one does not exist', async () => {\n      mockDescribeLogGroups.mockResolvedValueOnce({\n        logGroups: [{\n          arn: 'mock-log-group-arn',\n          logGroupName: '/aws/mock-service/mock-resource',\n          retentionInDays: undefined\n        }]\n      });", "        }]\n      });\n      mockDescribeLogStreams.mockResolvedValueOnce({\n        logStreams: [{\n          lastEventTimestamp: new Date()\n        }]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {", "        MetricDataResults: [\n          {\n            Values: [ 0 ]\n          }\n        ]\n      });\n      \n      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n      const provider = {\n        getCredentials: mockGetCredentials", "      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await cloudwatchLogsUtilization.getUtilization(provider);\n\n      expect(mockDescribeLogGroups).toBeCalled();\n      expect(mockDescribeLogGroups).toBeCalledWith({\n        NextToken: undefined\n      });", "        NextToken: undefined\n      });\n\n      expect(mockDescribeLogStreams).toBeCalled();\n      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\n      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n        scenarios: {\n          hasRetentionPolicy: {\n            value: undefined,", "          hasRetentionPolicy: {\n            value: undefined,\n            optimize: {\n              action: 'setRetentionPolicy',\n              isActionable: true,\n              reason: 'this log group does not have a retention policy',\n              monthlySavings: 0\n            }\n          }\n        },", "          }\n        },\n        data: {\n          resourceId: '/aws/mock-service/mock-resource',\n          region: 'us-east-1',\n          associatedResourceId: 'mock-resource',\n          stack: 'mock-stack',\n          hourlyCost: 0,\n          monthlyCost: 0,\n          maxMonthlySavings: 0", "          monthlyCost: 0,\n          maxMonthlySavings: 0\n        }\n      });\n    });\n\n    it('suggests optimizing log group if the log group has not had an event in the past 7 days', async () => {\n      mockDescribeLogGroups.mockResolvedValueOnce({\n        logGroups: [{\n          arn: 'mock-log-group-arn',", "        logGroups: [{\n          arn: 'mock-log-group-arn',\n          logGroupName: 'mock-log-group',\n          retentionInDays: undefined\n        }]\n      });\n      mockDescribeLogStreams.mockResolvedValueOnce({\n        logStreams: [{\n          lastEventTimestamp: Date.now() - (8 * 24 * 60 * 60 * 1000)\n        }]", "          lastEventTimestamp: Date.now() - (8 * 24 * 60 * 60 * 1000)\n        }]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Values: [ 0 ]\n          }\n        ]\n      });", "        ]\n      });\n      \n      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await cloudwatchLogsUtilization.getUtilization(provider);\n", "      await cloudwatchLogsUtilization.getUtilization(provider);\n\n      expect(mockDescribeLogGroups).toBeCalled();\n      expect(mockDescribeLogGroups).toBeCalledWith({\n        NextToken: undefined\n      });\n\n      expect(mockDescribeLogStreams).toBeCalled();\n      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n", "      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\n      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n        scenarios: {\n          hasRetentionPolicy: {\n            value: undefined,\n            optimize: {\n              action: 'setRetentionPolicy',\n              isActionable: true,\n              reason: 'this log group does not have a retention policy',", "              isActionable: true,\n              reason: 'this log group does not have a retention policy',\n              monthlySavings: 0\n            }\n          },\n          lastEventTime: {\n            value: new Date(1680739200000).toLocaleString(),\n            optimize: {\n              action: '',\n              isActionable: false,", "              action: '',\n              isActionable: false,\n              reason: 'this log group has not had an event in over 7 days'\n            }\n          }\n        },\n        data: {\n          resourceId: 'mock-log-group',\n          region: 'us-east-1',\n          stack: 'mock-stack',", "          region: 'us-east-1',\n          stack: 'mock-stack',\n          hourlyCost: 0,\n          monthlyCost: 0,\n          maxMonthlySavings: 0\n        }\n      });\n    });\n\n    it('suggests deleting log group if the log group has not had an event in the past 30 days', async () => {", "\n    it('suggests deleting log group if the log group has not had an event in the past 30 days', async () => {\n      mockDescribeLogGroups.mockResolvedValueOnce({\n        logGroups: [{\n          arn: 'mock-log-group-arn',\n          logGroupName: 'mock-log-group',\n          retentionInDays: undefined\n        }]\n      });\n      mockDescribeLogStreams.mockResolvedValueOnce({", "      });\n      mockDescribeLogStreams.mockResolvedValueOnce({\n        logStreams: [{\n          lastEventTimestamp: Date.now() - (31 * 24 * 60 * 60 * 1000)\n        }]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Values: [ 0 ]", "          {\n            Values: [ 0 ]\n          }\n        ]\n      });\n      \n      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;", "        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await cloudwatchLogsUtilization.getUtilization(provider);\n\n      expect(mockDescribeLogGroups).toBeCalled();\n      expect(mockDescribeLogGroups).toBeCalledWith({\n        NextToken: undefined\n      });\n", "      });\n\n      expect(mockDescribeLogStreams).toBeCalled();\n      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\n      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n        scenarios: {\n          hasRetentionPolicy: {\n            value: undefined,\n            optimize: {", "            value: undefined,\n            optimize: {\n              action: 'setRetentionPolicy',\n              isActionable: true,\n              reason: 'this log group does not have a retention policy',\n              monthlySavings: 0\n            }\n          },\n          lastEventTime: {\n            value: new Date(1678752000000).toLocaleString(),", "          lastEventTime: {\n            value: new Date(1678752000000).toLocaleString(),\n            delete: {\n              action: 'deleteLogGroup',\n              isActionable: true,\n              reason: 'this log group has not had an event in over 30 days',\n              monthlySavings: 0\n            }\n          }\n        },", "          }\n        },\n        data: {\n          resourceId: 'mock-log-group',\n          region: 'us-east-1',\n          stack: 'mock-stack',\n          hourlyCost: 0,\n          monthlyCost: 0,\n          maxMonthlySavings: 0\n        }", "          maxMonthlySavings: 0\n        }\n      });\n    });\n\n    it('suggests creating export task if the log group has more than 100 bytes of stored data', async () => {\n      mockDescribeLogGroups.mockResolvedValueOnce({\n        logGroups: [{\n          arn: 'mock-log-group-arn',\n          logGroupName: 'mock-log-group',", "          arn: 'mock-log-group-arn',\n          logGroupName: 'mock-log-group',\n          retentionInDays: undefined,\n          storedBytes: TEN_GB_IN_BYTES\n        }]\n      });\n      mockDescribeLogStreams.mockResolvedValueOnce({\n        logStreams: [{\n          lastEventTimestamp: Date.now()\n        }]", "          lastEventTimestamp: Date.now()\n        }]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Values: [ 0 ]\n          }\n        ]\n      });", "        ]\n      });\n      \n      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await cloudwatchLogsUtilization.getUtilization(provider);\n", "      await cloudwatchLogsUtilization.getUtilization(provider);\n\n      expect(mockDescribeLogGroups).toBeCalled();\n      expect(mockDescribeLogGroups).toBeCalledWith({\n        NextToken: undefined\n      });\n\n      expect(mockDescribeLogStreams).toBeCalled();\n      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n", "      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\n      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n        scenarios: {\n          hasRetentionPolicy: {\n            value: undefined,\n            optimize: {\n              action: 'setRetentionPolicy',\n              isActionable: true,\n              reason: 'this log group does not have a retention policy',", "              isActionable: true,\n              reason: 'this log group does not have a retention policy',\n              monthlySavings: 0.3\n            }\n          },\n          storedBytes: {\n            value: TEN_GB_IN_BYTES.toString(),\n            scaleDown: {\n              action: 'createExportTask',\n              isActionable: false,", "              action: 'createExportTask',\n              isActionable: false,\n              reason: 'this log group has more than 100 MB of stored data',\n              monthlySavings: 0.3\n            }\n          }\n        },\n        data: {\n          resourceId: 'mock-log-group',\n          region: 'us-east-1',", "          resourceId: 'mock-log-group',\n          region: 'us-east-1',\n          stack: 'mock-stack',\n          hourlyCost: (0.3 / 30) / 24,\n          monthlyCost: 0.3,\n          maxMonthlySavings: 0.3\n        }\n      });\n    });\n  });", "    });\n  });\n\n  describe('doAction', () => {\n    describe('setRetentionPolicy', () => {\n      it('sets retention policy', async () => {\n        mockPutRetentionPolicy.mockResolvedValueOnce({});\n\n        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n        const provider = {", "        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n        const provider = {\n          getCredentials: mockGetCredentials\n        } as unknown as AwsCredentialsProvider;\n        await cloudwatchLogsUtilization.doAction(provider, 'setRetentionPolicy', 'arn:mock-log-group:*', 'us-east-1');\n\n        expect(mockPutRetentionPolicy).toBeCalled();\n        expect(mockPutRetentionPolicy).toBeCalledWith({\n          logGroupName: 'mock-log-group',\n          retentionInDays: 90", "          logGroupName: 'mock-log-group',\n          retentionInDays: 90\n        });\n      });\n    });\n    \n    describe('deleteLogGroup', () => {\n      it('deletes log group', async () => {\n        mockDeleteLogGroup.mockResolvedValueOnce({});\n", "        mockDeleteLogGroup.mockResolvedValueOnce({});\n\n        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n        const provider = {\n          getCredentials: mockGetCredentials\n        } as unknown as AwsCredentialsProvider;\n        await cloudwatchLogsUtilization.doAction(provider, 'deleteLogGroup', 'arn:mock-log-group:*', 'us-east-1');\n\n        expect(mockDeleteLogGroup).toBeCalled();\n        expect(mockDeleteLogGroup).toBeCalledWith({", "        expect(mockDeleteLogGroup).toBeCalled();\n        expect(mockDeleteLogGroup).toBeCalledWith({\n          logGroupName: 'mock-log-group',\n        });\n      });\n    });\n\n    describe('createExportTask', () => {\n      it('creates export task', async () => {\n        mockCreateExportTask.mockResolvedValueOnce({});", "      it('creates export task', async () => {\n        mockCreateExportTask.mockResolvedValueOnce({});\n\n        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n        const cloudwatchLogsClient = new CloudWatchLogs({});\n        await cloudwatchLogsUtilization.createExportTask(cloudwatchLogsClient, 'mock-log-group', 'mock-bucket');\n\n        expect(mockCreateExportTask).toBeCalled();\n        expect(mockCreateExportTask).toBeCalledWith({\n          logGroupName: 'mock-log-group',", "        expect(mockCreateExportTask).toBeCalledWith({\n          logGroupName: 'mock-log-group',\n          destination: 'mock-bucket',\n          from: 0,\n          to: Date.now()\n        });\n      });\n    });\n  });\n});", "  });\n});\n"]}
{"filename": "test/service-utilizations/aws-ecs-utilization.test.ts", "chunked_list": ["\nimport { MockCache } from \"../mocks/MockCache\";\njest.useFakeTimers();\njest.setSystemTime(new Date('2023-04-14T00:00:00.000Z'));\nconst mockGetCredentials = jest.fn();\nconst mockEcs = jest.fn();\nconst mockEc2 = jest.fn();\nconst mockElbV2 = jest.fn();\nconst mockApiGatewayV2 = jest.fn();\nconst mockCloudWatch = jest.fn();", "const mockApiGatewayV2 = jest.fn();\nconst mockCloudWatch = jest.fn();\n\n// ECS\nconst mockDescribeServices = jest.fn();\nconst mockListClusters = jest.fn();\nconst mockListServices = jest.fn();\nconst mockListTasks = jest.fn();\nconst mockDescribeTasks = jest.fn();\nconst mockDescribeContainerInstances = jest.fn();", "const mockDescribeTasks = jest.fn();\nconst mockDescribeContainerInstances = jest.fn();\nconst mockDeleteService = jest.fn();\nconst mockDescribeTaskDefinition = jest.fn();\nconst mockRegisterTaskDefinition = jest.fn();\nconst mockUpdateService = jest.fn();\n\n// EC2\nconst mockDescribeInstances = jest.fn();\nconst mockDescribeInstanceTypes = jest.fn();", "const mockDescribeInstances = jest.fn();\nconst mockDescribeInstanceTypes = jest.fn();\n\n// ElbV2\nconst mockDescribeTargetGroups = jest.fn();\n\n// CloudWatch\nconst mockGetMetricData = jest.fn();\n\n// ApiGatewayV2", "\n// ApiGatewayV2\nconst mockGetApis = jest.fn();\nconst mockGetIntegrations = jest.fn();\n\n// ec2 utils\nconst mockGetInstanceCost = jest.fn();\n\nconst mockCache = new MockCache();\n", "const mockCache = new MockCache();\n\njest.mock('cached', () => () => mockCache);\n\njest.mock('@aws-sdk/client-ecs', () => {\n  const original = jest.requireActual('@aws-sdk/client-ecs');\n  const {\n    ContainerInstance,\n    DesiredStatus,\n    LaunchType,", "    DesiredStatus,\n    LaunchType,\n    ListClustersCommandOutput,\n    ListServicesCommandOutput,\n    ListTasksCommandOutput,\n    Service,\n    Task,\n    TaskDefinitionField,\n    DescribeContainerInstancesCommandOutput\n  } = original;", "    DescribeContainerInstancesCommandOutput\n  } = original;\n  return {\n    ECS: mockEcs,\n    ContainerInstance,\n    DesiredStatus,\n    LaunchType,\n    ListClustersCommandOutput,\n    ListServicesCommandOutput,\n    ListTasksCommandOutput,", "    ListServicesCommandOutput,\n    ListTasksCommandOutput,\n    Service,\n    Task,\n    TaskDefinitionField,\n    DescribeContainerInstancesCommandOutput\n  };\n});\njest.mock('@aws-sdk/client-ec2', () => {\n  const original = jest.requireActual('@aws-sdk/client-ec2');", "jest.mock('@aws-sdk/client-ec2', () => {\n  const original = jest.requireActual('@aws-sdk/client-ec2');\n  const { DescribeInstanceTypesCommandOutput, Instance, InstanceTypeInfo, _InstanceType } = original;\n  return {\n    EC2: mockEc2,\n    DescribeInstanceTypesCommandOutput,\n    Instance,\n    InstanceTypeInfo,\n    _InstanceType\n  };", "    _InstanceType\n  };\n});\njest.mock('@aws-sdk/client-apigatewayv2', () => {\n  const original = jest.requireActual('@aws-sdk/client-apigatewayv2');\n  const {\n    Api,\n    GetApisCommandOutput,\n    Integration\n  } = original;", "    Integration\n  } = original;\n  return {\n    ApiGatewayV2: mockApiGatewayV2,\n    Api,\n    GetApisCommandOutput,\n    Integration\n  };\n});\njest.mock('@aws-sdk/client-elastic-load-balancing-v2', () => ({", "});\njest.mock('@aws-sdk/client-elastic-load-balancing-v2', () => ({\n  ElasticLoadBalancingV2: mockElbV2\n}));\njest.mock('@aws-sdk/client-cloudwatch', () => {\n  const original = jest.requireActual('@aws-sdk/client-cloudwatch');\n  const { MetricDataQuery, MetricDataResult } = original;\n  return {\n    CloudWatch: mockCloudWatch,\n    MetricDataQuery,", "    CloudWatch: mockCloudWatch,\n    MetricDataQuery,\n    MetricDataResult\n  };\n});\njest.mock('../../src/utils/ec2-utils.js', () => {\n  const original = jest.requireActual('../../src/utils/ec2-utils.js');\n  return {\n    ...original,\n    getInstanceCost: mockGetInstanceCost", "    ...original,\n    getInstanceCost: mockGetInstanceCost\n  }\n});\n\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { AwsEcsUtilization } from '../../src/service-utilizations/aws-ecs-utilization';\nimport t2Micro from '../mocks/T2Micro.json';\nimport t2Nano from '../mocks/T2Nano.json';\nimport fargateTaskDef from '../mocks/FargateTaskDef.json';", "import t2Nano from '../mocks/T2Nano.json';\nimport fargateTaskDef from '../mocks/FargateTaskDef.json';\nimport { ALB_REQUEST_COUNT, APIG_REQUEST_COUNT, AVG_CPU, AVG_MEMORY, AVG_NETWORK_BYTES_IN, AVG_NETWORK_BYTES_OUT, DISK_READ_OPS, DISK_WRITE_OPS, MAX_CPU, MAX_MEMORY, MAX_NETWORK_BYTES_IN, MAX_NETWORK_BYTES_OUT } from \"../../src/types/constants.js\";\n\ndescribe('AwsEcsUtilization', () => {\n  beforeEach(() => {\n    mockEcs.mockReturnValue({\n      describeServices: mockDescribeServices,\n      listClusters: mockListClusters,\n      listServices: mockListServices,", "      listClusters: mockListClusters,\n      listServices: mockListServices,\n      listTasks: mockListTasks,\n      describeTasks: mockDescribeTasks,\n      describeContainerInstances: mockDescribeContainerInstances,\n      deleteService: mockDeleteService,\n      describeTaskDefinition: mockDescribeTaskDefinition,\n      registerTaskDefinition: mockRegisterTaskDefinition,\n      updateService: mockUpdateService\n    });", "      updateService: mockUpdateService\n    });\n    mockEc2.mockReturnValue({\n      describeInstances: mockDescribeInstances,\n      describeInstanceTypes: mockDescribeInstanceTypes\n    });\n    mockElbV2.mockReturnValue({\n      describeTargetGroups: mockDescribeTargetGroups\n    })\n    mockCloudWatch.mockReturnValue({", "    })\n    mockCloudWatch.mockReturnValue({\n      getMetricData: mockGetMetricData\n    });\n    mockApiGatewayV2.mockReturnValue({\n      getApis: mockGetApis,\n      getIntegrations: mockGetIntegrations\n    })\n  });\n", "  });\n\n  afterEach(() => {\n    // for mocks\n    jest.resetAllMocks();\n    // for spies\n    jest.restoreAllMocks();\n    mockCache.reset();\n    mockCache.restore();\n  });", "    mockCache.restore();\n  });\n\n  describe('getRegionalUtilization', () => {\n    it('Calls describeServices with cluster name and service arns if provided', async () => {\n      mockDescribeServices.mockResolvedValue({\n        services: []\n      });\n\n      const ecsUtil = new AwsEcsUtilization(true);", "\n      const ecsUtil = new AwsEcsUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n      await ecsUtil.getRegionalUtilization(provider, 'us-east-1', {\n          services: [\n            {\n              clusterArn: 'mock-cluster-a',\n              serviceArn: 'mock-service-a'", "              clusterArn: 'mock-cluster-a',\n              serviceArn: 'mock-service-a'\n            },\n            {\n              clusterArn: 'mock-cluster-a',\n              serviceArn: 'mock-service-a-2'\n            },\n            {\n              clusterArn: 'mock-cluster-b',\n              serviceArn: 'mock-service-b'", "              clusterArn: 'mock-cluster-b',\n              serviceArn: 'mock-service-b'\n            }\n          ]\n        }\n      );\n\n\n      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(2);", "      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(2);\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster-a',\n        services: ['mock-service-a', 'mock-service-a-2']\n      });\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster-b',\n        services: ['mock-service-b']\n      });", "        services: ['mock-service-b']\n      });\n    });\n    it('lists all services if cluster name and service arns if provided', async () => {\n      mockListClusters.mockResolvedValueOnce({\n        clusterArns: ['mock-cluster-a'],\n        nextToken: 'next-token'\n      });\n      mockListClusters.mockResolvedValueOnce({\n        clusterArns: ['mock-cluster-b']", "      mockListClusters.mockResolvedValueOnce({\n        clusterArns: ['mock-cluster-b']\n      });\n      mockListServices.mockResolvedValueOnce({\n        serviceArns: ['mock-service-a'],\n        nextToken: 'next-token'\n      });\n      mockListServices.mockResolvedValueOnce({\n        serviceArns: ['mock-service-a-2']\n      });", "        serviceArns: ['mock-service-a-2']\n      });\n      mockListServices.mockResolvedValueOnce({\n        serviceArns: ['mock-service-b']\n      });\n      mockDescribeServices.mockResolvedValue({\n        services: []\n      });\n\n      const ecsUtil = new AwsEcsUtilization(true);", "\n      const ecsUtil = new AwsEcsUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n      await ecsUtil.getRegionalUtilization(provider, 'us-east-1');\n\n\n      expect(mockListClusters).toBeCalled();\n      expect(mockListClusters).toBeCalledTimes(2);", "      expect(mockListClusters).toBeCalled();\n      expect(mockListClusters).toBeCalledTimes(2);\n      expect(mockListClusters).toBeCalledWith({});\n      expect(mockListClusters).toBeCalledWith({ nextToken: 'next-token' });\n      \n      expect(mockListServices).toBeCalled();\n      expect(mockListServices).toBeCalledTimes(3);\n      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-a' });\n      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-a', nextToken: 'next-token' });\n      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-b' });", "      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-a', nextToken: 'next-token' });\n      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-b' });\n\n      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(2);\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster-a',\n        services: ['mock-service-a', 'mock-service-a-2']\n      });\n      expect(mockDescribeServices).toBeCalledWith({", "      });\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster-b',\n        services: ['mock-service-b']\n      });\n    });\n    it('Suggests termination if a service appears to not be used', async () => {\n      mockDescribeServices.mockResolvedValue({\n        services: [\n          {", "        services: [\n          {\n            serviceArn: 'mock-service',\n            serviceName: 'mock-service',\n            clusterArn: 'mock-cluster',\n            loadBalancers: [\n              {\n                targetGroupArn: 'mock-target-group'\n              }\n            ],", "              }\n            ],\n            serviceRegistries: []\n          }\n        ]\n      });\n\n      mockDescribeTargetGroups.mockResolvedValue({\n        TargetGroups: [\n          {", "        TargetGroups: [\n          {\n            LoadBalancerArns: ['mock-load-balancer']\n          }\n        ]\n      });\n\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {", "        MetricDataResults: [\n          {\n            Id: AVG_CPU,\n            Values: [0.01, 0.02, 0.03]\n          },\n          {\n            Id: MAX_CPU,\n            Values: [0.01, 0.02, 0.03]\n          },\n          {", "          },\n          {\n            Id: AVG_MEMORY,\n            Values: [0.01, 0.02, 0.03]\n          },\n          {\n            Id: MAX_MEMORY,\n            Values: [0.01, 0.02, 0.03]\n          },\n          {", "          },\n          {\n            Id: ALB_REQUEST_COUNT,\n            Values: [0, 0, 0]\n          }\n        ]\n      });\n\n      mockListTasks.mockResolvedValueOnce({\n        taskArns: ['mock-task']", "      mockListTasks.mockResolvedValueOnce({\n        taskArns: ['mock-task']\n      });\n      \n      mockDescribeTasks.mockResolvedValueOnce({\n        tasks: [\n          {\n            cpu: 1024,\n            memory: 4\n          }", "            memory: 4\n          }\n        ]\n      });\n\n      mockDescribeContainerInstances.mockResolvedValueOnce({\n        containerInstances: [\n          {\n            registeredResources: [\n              {", "            registeredResources: [\n              {\n                name: 'CPU',\n                integerValue: '1024'\n              }\n            ],\n            attributes: [\n              {\n                name: 'ecs.instance-type',\n                value: 't3.medium'", "                name: 'ecs.instance-type',\n                value: 't3.medium'\n              }\n            ]\n          }\n        ]\n      });\n\n      mockGetInstanceCost.mockResolvedValueOnce(50);\n", "      mockGetInstanceCost.mockResolvedValueOnce(50);\n\n      const ecsUtil = new AwsEcsUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n      await ecsUtil.getRegionalUtilization(provider.getCredentials(), 'us-east-1', {\n          services: [\n            {\n              clusterArn: 'mock-cluster',", "            {\n              clusterArn: 'mock-cluster',\n              serviceArn: 'mock-service'\n            }\n          ]\n        }\n      );\n      \n      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(1);", "      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(1);\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster',\n        services: ['mock-service']\n      });\n\n      expect(mockDescribeTargetGroups).toBeCalled();\n      expect(mockDescribeTargetGroups).toBeCalledTimes(1);\n      expect(mockDescribeTargetGroups).toBeCalledWith({", "      expect(mockDescribeTargetGroups).toBeCalledTimes(1);\n      expect(mockDescribeTargetGroups).toBeCalledWith({\n        TargetGroupArns: ['mock-target-group']\n      });\n\n      expect(mockGetMetricData).toBeCalled();\n\n      expect(ecsUtil.utilization).toHaveProperty('mock-service', {\n        data: {\n          resourceId: 'mock-service',", "        data: {\n          resourceId: 'mock-service',\n          region: 'us-east-1',\n          hourlyCost: (50 / 30) / 24,\n          monthlyCost: 50\n        },\n        scenarios: {\n          unused: {\n            value: 'true',\n            delete: {", "            value: 'true',\n            delete: {\n              action: 'deleteService',\n              isActionable: true,\n              reason: 'This ECS service appears to be unused based on its CPU utilizaiton, Memory utilizaiton, and network traffic.',\n              monthlySavings: 50\n            }\n          }\n        }\n      });", "        }\n      });\n    });\n    it('Suggests scale down if a fargate service appears to be used but underutilized', async () => {\n      mockDescribeServices.mockResolvedValue({\n        services: [\n          {\n            serviceArn: 'mock-service',\n            serviceName: 'mock-service',\n            clusterArn: 'mock-cluster',", "            serviceName: 'mock-service',\n            clusterArn: 'mock-cluster',\n            launchType: 'FARGATE',\n            loadBalancers: [],\n            serviceRegistries: [\n              {\n                registryArn: 'mock-registry'\n              }\n            ]\n          }", "            ]\n          }\n        ]\n      });\n\n      mockGetApis.mockResolvedValue({\n        Items: [\n          {\n            ApiId: 'mock-api'\n          }", "            ApiId: 'mock-api'\n          }\n        ]\n      });\n      mockGetIntegrations.mockResolvedValue({\n        Items: [\n          {\n            IntegrationUri: 'mock-registry'\n          }\n        ]", "          }\n        ]\n      });\n\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Id: AVG_CPU,\n            Values: [0.10, 0.12, 0.13]\n          },", "            Values: [0.10, 0.12, 0.13]\n          },\n          {\n            Id: MAX_CPU,\n            Values: [0.11, 0.22, 0.33]\n          },\n          {\n            Id: AVG_MEMORY,\n            Values: [0.10, 0.12, 0.13]\n          },", "            Values: [0.10, 0.12, 0.13]\n          },\n          {\n            Id: MAX_MEMORY,\n            Values: [0.11, 0.22, 0.33]\n          },\n          {\n            Id: APIG_REQUEST_COUNT,\n            Values: [10, 20, 30]\n          }", "            Values: [10, 20, 30]\n          }\n        ]\n      });\n\n      mockListTasks.mockResolvedValueOnce({\n        taskArns: ['mock-task']\n      });\n      \n      mockDescribeTasks.mockResolvedValueOnce({", "      \n      mockDescribeTasks.mockResolvedValueOnce({\n        tasks: [\n          {\n            cpu: 1024,\n            memory: 4,\n            attributes: [{\n              name: 'ecs.cpu-architecture',\n              value: 'x86_64'\n            }]", "              value: 'x86_64'\n            }]\n          }\n        ]\n      });\n\n      const ecsUtil = new AwsEcsUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;", "        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n      await ecsUtil.getRegionalUtilization(provider.getCredentials(), 'us-east-1', {\n          services: [\n            {\n              clusterArn: 'mock-cluster',\n              serviceArn: 'mock-service'\n            }\n          ]\n        }", "          ]\n        }\n      );\n      \n      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(1);\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster',\n        services: ['mock-service']\n      });", "        services: ['mock-service']\n      });\n\n      expect(mockGetApis).toBeCalled();\n      expect(mockGetApis).toBeCalledTimes(1);\n\n      expect(mockGetIntegrations).toBeCalled();\n      expect(mockGetIntegrations).toBeCalledTimes(1);\n      expect(mockGetIntegrations).toBeCalledWith({\n        ApiId: 'mock-api'", "      expect(mockGetIntegrations).toBeCalledWith({\n        ApiId: 'mock-api'\n      });\n\n      expect(mockGetMetricData).toBeCalled();\n\n      const monthlyCost = 29.158101562500004;\n      expect(ecsUtil.utilization).toHaveProperty('mock-service', {\n        data: {\n          resourceId: 'mock-service',", "        data: {\n          resourceId: 'mock-service',\n          region: 'us-east-1',\n          hourlyCost: (monthlyCost / 30) / 24,\n          monthlyCost\n        },\n        scenarios: {\n          overAllocated: {\n            value: 'overAllocated',\n            scaleDown: {", "            value: 'overAllocated',\n            scaleDown: {\n              action: 'scaleDownFargateService',\n              isActionable: false,\n              reason: 'This ECS service appears to be over allocated based on its CPU, Memory, and network utilization. We suggest scaling the CPU down to 512 and the Memory to 2048 MiB.',\n              monthlySavings: 8.184501562500003\n            }\n          }\n        }\n      });", "        }\n      });\n    });\n    it('Suggests scale down if an Ec2 services appears to be used but underutilized', async () => {\n      mockDescribeServices.mockResolvedValue({\n        services: [\n          {\n            serviceArn: 'mock-service',\n            serviceName: 'mock-service',\n            clusterArn: 'mock-cluster',", "            serviceName: 'mock-service',\n            clusterArn: 'mock-cluster',\n            loadBalancers: [],\n            serviceRegistries: [\n              {\n                registryArn: 'mock-registry'\n              }\n            ]\n          }\n        ]", "          }\n        ]\n      });\n\n      mockGetApis.mockResolvedValue({\n        Items: [\n          {\n            ApiId: 'mock-api'\n          }\n        ]", "          }\n        ]\n      });\n      mockGetIntegrations.mockResolvedValue({\n        Items: [\n          {\n            IntegrationUri: 'mock-registry'\n          }\n        ]\n      });", "        ]\n      });\n\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Id: AVG_CPU,\n            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n          },\n          {", "          },\n          {\n            Id: MAX_CPU,\n            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n          },\n          {\n            Id: AVG_MEMORY,\n            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n          },\n          {", "          },\n          {\n            Id: MAX_MEMORY,\n            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n          },\n          {\n            Id: APIG_REQUEST_COUNT,\n            Values: [10, 20, 30, 40, 50]\n          }\n        ]", "          }\n        ]\n      });\n\n      mockListTasks.mockResolvedValueOnce({\n        taskArns: ['mock-task']\n      });\n      \n      mockDescribeTasks.mockResolvedValueOnce({\n        tasks: [", "      mockDescribeTasks.mockResolvedValueOnce({\n        tasks: [\n          {\n            cpu: '0',\n            memory: '4096'\n          }\n        ]\n      });\n      \n      mockDescribeContainerInstances.mockResolvedValueOnce({", "      \n      mockDescribeContainerInstances.mockResolvedValueOnce({\n        containerInstances: [\n          {\n            registeredResources: [\n              {\n                name: 'CPU',\n                integerValue: '1024'\n              }\n            ],", "              }\n            ],\n            attributes: [\n              {\n                name: 'ecs.instance-type',\n                value: 't3.medium'\n              }\n            ]\n          }\n        ]", "          }\n        ]\n      });\n      \n      mockDescribeInstanceTypes.mockResolvedValueOnce({\n        InstanceTypes: [\n          t2Nano,\n          t2Micro\n        ]\n      });", "        ]\n      });\n\n      mockGetInstanceCost.mockResolvedValueOnce(50);\n\n      mockCache.getOrElse.mockImplementationOnce((_key, refreshFunction) => {\n        return refreshFunction();\n      });\n\n      const ecsUtil = new AwsEcsUtilization(true);", "\n      const ecsUtil = new AwsEcsUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n      await ecsUtil.getRegionalUtilization(provider, 'us-east-1', {\n          services: [\n            {\n              clusterArn: 'mock-cluster',\n              serviceArn: 'mock-service'", "              clusterArn: 'mock-cluster',\n              serviceArn: 'mock-service'\n            }\n          ]\n        }\n      );\n      \n      expect(mockDescribeServices).toBeCalled();\n      expect(mockDescribeServices).toBeCalledTimes(1);\n      expect(mockDescribeServices).toBeCalledWith({", "      expect(mockDescribeServices).toBeCalledTimes(1);\n      expect(mockDescribeServices).toBeCalledWith({\n        cluster: 'mock-cluster',\n        services: ['mock-service']\n      });\n\n      expect(mockGetApis).toBeCalled();\n      expect(mockGetApis).toBeCalledTimes(1);\n\n      expect(mockGetIntegrations).toBeCalled();", "\n      expect(mockGetIntegrations).toBeCalled();\n      expect(mockGetIntegrations).toBeCalledTimes(1);\n      expect(mockGetIntegrations).toBeCalledWith({\n        ApiId: 'mock-api'\n      });\n\n      expect(mockGetMetricData).toBeCalled();\n\n      expect(ecsUtil.utilization).toHaveProperty('mock-service', {", "\n      expect(ecsUtil.utilization).toHaveProperty('mock-service', {\n        data: {},\n        scenarios: {\n          overAllocated: {\n            value: 'overAllocated',\n            scaleDown: {\n              action: 'scaleDownEc2Service',\n              reason: 'The EC2 instances used in this Service\\'s cluster appears to be over allocated based on its CPU and Memory utilization.  We suggest scaling down to a t2.micro.'\n            }", "              reason: 'The EC2 instances used in this Service\\'s cluster appears to be over allocated based on its CPU and Memory utilization.  We suggest scaling down to a t2.micro.'\n            }\n          }\n        }\n      });\n    });\n  });\n  it('deleteService', async () => {\n    const ecsUtil = new AwsEcsUtilization(true);\n    const provider = {", "    const ecsUtil = new AwsEcsUtilization(true);\n    const provider = {\n      getCredentials: mockGetCredentials\n    } as unknown as AwsCredentialsProvider;\n\n    await ecsUtil.deleteService(provider, 'mock-cluster', 'mock-service', 'us-mock-1');\n\n    expect(mockDeleteService).toBeCalled();\n    expect(mockDeleteService).toBeCalledWith({\n      service: 'mock-service',", "    expect(mockDeleteService).toBeCalledWith({\n      service: 'mock-service',\n      cluster: 'mock-cluster'\n    });\n  });\n  it('scaleDownFargateService', async () => {\n    mockDescribeServices.mockResolvedValue({\n      services: [\n        {\n          serviceArn: 'mock-service',", "        {\n          serviceArn: 'mock-service',\n          serviceName: 'mock-service',\n          clusterArn: 'mock-cluster',\n          taskDefinition: 'mock-task-def',\n          launchType: 'FARGATE',\n          loadBalancers: [],\n          serviceRegistries: [\n            {\n              registryArn: 'mock-registry'", "            {\n              registryArn: 'mock-registry'\n            }\n          ]\n        }\n      ]\n    });\n    mockDescribeTaskDefinition.mockResolvedValue(fargateTaskDef)\n    mockRegisterTaskDefinition.mockResolvedValue({\n      taskDefinition: {", "    mockRegisterTaskDefinition.mockResolvedValue({\n      taskDefinition: {\n        taskDefinitionArn: 'mock-task-def:2'\n      }\n    });\n\n    const ecsUtil = new AwsEcsUtilization(true);\n    const provider = {\n      getCredentials: mockGetCredentials\n    } as unknown as AwsCredentialsProvider;", "      getCredentials: mockGetCredentials\n    } as unknown as AwsCredentialsProvider;\n\n    await ecsUtil.scaleDownFargateService(provider, 'mock-cluster', 'mock-service', 'us-mock-1', 256, 1024);\n\n    expect(mockDescribeServices).toBeCalled();\n    expect(mockDescribeServices).toBeCalledWith({\n      services: ['mock-service'],\n      cluster: 'mock-cluster'\n    });", "      cluster: 'mock-cluster'\n    });\n\n    expect(mockDescribeTaskDefinition).toBeCalled();\n    expect(mockDescribeTaskDefinition).toBeCalledWith({\n      taskDefinition: 'mock-task-def',\n      include: ['TAGS']\n    });\n\n    expect(mockRegisterTaskDefinition).toBeCalled();", "\n    expect(mockRegisterTaskDefinition).toBeCalled();\n    expect(mockRegisterTaskDefinition).toBeCalledWith({\n      cpu: '256',\n      memory: '1024',\n      containerDefinitions: fargateTaskDef.taskDefinition.containerDefinitions,\n      family: fargateTaskDef.taskDefinition.family,\n      executionRoleArn: fargateTaskDef.taskDefinition.executionRoleArn,\n      networkMode: fargateTaskDef.taskDefinition.networkMode,\n      placementConstraints: fargateTaskDef.taskDefinition.placementConstraints,", "      networkMode: fargateTaskDef.taskDefinition.networkMode,\n      placementConstraints: fargateTaskDef.taskDefinition.placementConstraints,\n      requiresCompatibilities: fargateTaskDef.taskDefinition.requiresCompatibilities,\n      taskRoleArn: fargateTaskDef.taskDefinition.taskRoleArn,\n      volumes: fargateTaskDef.taskDefinition.volumes,\n      tags: fargateTaskDef.tags\n    });\n\n    expect(mockUpdateService).toBeCalled();\n    expect(mockUpdateService).toBeCalledWith({", "    expect(mockUpdateService).toBeCalled();\n    expect(mockUpdateService).toBeCalledWith({\n      cluster: 'mock-cluster',\n      service: 'mock-service',\n      taskDefinition: 'mock-task-def:2',\n      forceNewDeployment: true\n    });\n  });\n});", "});"]}
{"filename": "test/service-utilizations/aws-nat-gateway-utilization.test.ts", "chunked_list": ["const mockSts = jest.fn();\nconst mockEc2 = jest.fn();\nconst mockCloudWatch = jest.fn();\nconst mockAccount = jest.fn();\nconst mockCloudFormation = jest.fn();\nconst mockGetCallerIdentity = jest.fn();\nconst mockDescribeNatGateways = jest.fn();\nconst mockDeleteNatGateway = jest.fn();\nconst mockGetMetricData = jest.fn();\nconst mockGetCredentials = jest.fn();", "const mockGetMetricData = jest.fn();\nconst mockGetCredentials = jest.fn();\nconst mockListRegions = jest.fn();\nconst mockDescribeStackResources = jest.fn();\n\njest.mock('@aws-sdk/client-sts', () => {\n  return {\n    STS: mockSts\n  }\n});", "  }\n});\n\njest.mock('@aws-sdk/client-ec2', () => {\n  const original = jest.requireActual('@aws-sdk/client-ec2');\n  return {\n    ...original,\n    EC2: mockEc2\n  };\n});", "  };\n});\n\njest.mock('@aws-sdk/client-cloudwatch', () => {\n  const original = jest.requireActual('@aws-sdk/client-cloudwatch');\n  const { MetricDataQuery, MetricDataResult } = original;\n  return {\n    CloudWatch: mockCloudWatch,\n    MetricDataQuery,\n    MetricDataResult", "    MetricDataQuery,\n    MetricDataResult\n  };\n});\n\njest.mock('@aws-sdk/client-account', () => {\n  const original = jest.requireActual('@aws-sdk/client-account');\n  return {\n    ...original,\n    Account: mockAccount", "    ...original,\n    Account: mockAccount\n  };\n});\n\njest.mock('@aws-sdk/client-cloudformation', () => {\n  return {\n    CloudFormation: mockCloudFormation\n  }\n});", "  }\n});\n\nimport { EC2 } from \"@aws-sdk/client-ec2\";\nimport { AwsCredentialsProvider } from \"@tinystacks/ops-aws-core-widgets\";\nimport { AwsNatGatewayUtilization } from \"../../src/service-utilizations/aws-nat-gateway-utilization\";\nimport { Arns } from \"../../src/types/constants\";\n\ndescribe('AwsNatGatewayUtilization', () => {\n  beforeEach(() => {", "describe('AwsNatGatewayUtilization', () => {\n  beforeEach(() => {\n    mockSts.mockReturnValue({\n      getCallerIdentity: mockGetCallerIdentity\n    });\n    mockGetCallerIdentity.mockResolvedValue({\n      Account: '123456789'\n    });\n    mockEc2.mockReturnValue({\n      describeNatGateways: mockDescribeNatGateways,", "    mockEc2.mockReturnValue({\n      describeNatGateways: mockDescribeNatGateways,\n      deleteNatGateway: mockDeleteNatGateway\n    });\n    mockCloudWatch.mockReturnValue({\n      getMetricData: mockGetMetricData\n    });\n    mockAccount.mockReturnValue({\n      listRegions: mockListRegions\n    });", "      listRegions: mockListRegions\n    });\n    mockCloudFormation.mockReturnValue({\n      describeStackResources: mockDescribeStackResources\n    });\n  });\n\n  afterEach(() => {\n    // for mocks\n    jest.resetAllMocks();", "    // for mocks\n    jest.resetAllMocks();\n    // for spies\n    jest.restoreAllMocks();\n  });\n\n  describe('getUtilization', () => {\n    beforeEach(() => {\n      mockListRegions.mockResolvedValue({\n        Regions: [{", "      mockListRegions.mockResolvedValue({\n        Regions: [{\n          RegionName: 'us-east-1'\n        }]\n      });\n      mockDescribeStackResources.mockResolvedValue({\n        StackResources: [{\n          StackId: 'mock-stack'\n        }]\n      });", "        }]\n      });\n    });\n    afterEach(() => {\n      // for mocks\n      jest.resetAllMocks();\n      // for spies\n      jest.restoreAllMocks();\n    });\n", "    });\n\n    it('suggests deletion if number of active connections is 0', async () => {\n      mockDescribeNatGateways.mockResolvedValueOnce({\n        NatGateways: [{\n          NatGatewayId: 'mock-nat-gateway',\n          SubnetId: 'mock-subnet',\n          VpcId: 'mock-vpc'\n        }]\n      });", "        }]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Id: 'activeConnectionCount',\n            Values: [0]\n          },\n          {\n            Id: 'bytesInFromDestination',", "          {\n            Id: 'bytesInFromDestination',\n            Values: [1]\n          },\n          {\n            Id: 'bytesInFromSource',\n            Values: [1]\n          },\n          {\n            Id: 'bytesOutToDestination',", "          {\n            Id: 'bytesOutToDestination',\n            Values: [1]\n          },\n          {\n            Id: 'bytesOutToSource',\n            Values: [1]\n          }\n        ]\n      });", "        ]\n      });\n\n      const natGatewayUtilization = new AwsNatGatewayUtilization();\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await natGatewayUtilization.getUtilization(provider);\n      ", "      await natGatewayUtilization.getUtilization(provider);\n      \n      expect(mockDescribeNatGateways).toBeCalled();\n      expect(mockDescribeNatGateways).toBeCalledWith({});\n\n      expect(mockGetMetricData).toBeCalled();\n\n      const natGatewayArn = Arns.NatGateway('us-east-1', '123456789', 'mock-nat-gateway');\n      expect(natGatewayUtilization.utilization).toHaveProperty(natGatewayArn, {\n        scenarios: {", "      expect(natGatewayUtilization.utilization).toHaveProperty(natGatewayArn, {\n        scenarios: {\n          activeConnectionCount: {\n            value: '0',\n            delete: {\n              action: 'deleteNatGateway',\n              reason: 'This NAT Gateway has had 0 active connections over the past week. It appears to be unused.'\n            }\n          }\n        },", "          }\n        },\n        data: {\n          resourceId: 'mock-nat-gateway',\n          region: 'us-east-1',\n          stack: 'mock-stack'\n        }\n      });\n    });\n    it('suggests deletion if total throughput is 0', async () => {", "    });\n    it('suggests deletion if total throughput is 0', async () => {\n      mockDescribeNatGateways.mockResolvedValueOnce({\n        NatGateways: [{\n          NatGatewayId: 'mock-nat-gateway',\n          SubnetId: 'mock-subnet',\n          VpcId: 'mock-vpc'\n        }]\n      });\n      mockGetMetricData.mockResolvedValueOnce({", "      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Id: 'activeConnectionCount',\n            Values: [3]\n          },\n          {\n            Id: 'bytesInFromDestination',\n            Values: [0]", "            Id: 'bytesInFromDestination',\n            Values: [0]\n          },\n          {\n            Id: 'bytesInFromSource',\n            Values: [0]\n          },\n          {\n            Id: 'bytesOutToDestination',\n            Values: [0]", "            Id: 'bytesOutToDestination',\n            Values: [0]\n          },\n          {\n            Id: 'bytesOutToSource',\n            Values: [0]\n          }\n        ]\n      });\n", "      });\n\n      const natGatewayUtilization = new AwsNatGatewayUtilization();\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await natGatewayUtilization.getUtilization(provider);\n      \n      expect(mockDescribeNatGateways).toBeCalled();", "      \n      expect(mockDescribeNatGateways).toBeCalled();\n      expect(mockDescribeNatGateways).toBeCalledWith({});\n\n      expect(mockGetMetricData).toBeCalled();\n\n      const natGatewayArn = Arns.NatGateway('us-east-1', '123456789', 'mock-nat-gateway');\n      expect(natGatewayUtilization.utilization).toHaveProperty(natGatewayArn, {\n        scenarios: {\n          totalThroughput: {", "        scenarios: {\n          totalThroughput: {\n            value: '0',\n            delete: {\n              action: 'deleteNatGateway',\n              reason: 'This NAT Gateway has had 0 total throughput over the past week. It appears to be unused.'\n            }\n          }\n        },\n        data: {", "        },\n        data: {\n          resourceId: 'mock-nat-gateway',\n          region: 'us-east-1',\n          stack: 'mock-stack'\n        }\n      });\n    });\n  });\n", "  });\n\n  describe('actions', () => {\n    describe('deleteNatGateway', () => {\n      it('sets retention policy', async () => {\n        mockDeleteNatGateway.mockResolvedValueOnce({});\n\n        const natGatewayUtilization = new AwsNatGatewayUtilization();\n        const ec2Client = new EC2({});\n        await natGatewayUtilization.deleteNatGateway(ec2Client, 'mock-nat-gateway');", "        const ec2Client = new EC2({});\n        await natGatewayUtilization.deleteNatGateway(ec2Client, 'mock-nat-gateway');\n\n        expect(mockDeleteNatGateway).toBeCalled();\n        expect(mockDeleteNatGateway).toBeCalledWith({\n          NatGatewayId: 'mock-nat-gateway'\n        });\n      });\n    });\n  });", "    });\n  });\n});\n"]}
{"filename": "test/service-utilizations/aws-ec2-instance-utilization.test.ts", "chunked_list": ["import { MockCache } from \"../mocks/MockCache\";\njest.useFakeTimers();\njest.setSystemTime(new Date('2023-04-14T00:00:00.000Z'));\nconst mockGetCredentials = jest.fn();\nconst mockEc2 = jest.fn();\nconst mockDescribeInstances = jest.fn();\nconst mockDescribeInstanceTypes = jest.fn();\nconst mockAutoScaling = jest.fn();\nconst mockDescribeAutoScalingInstances = jest.fn();\nconst mockCloudWatch = jest.fn();", "const mockDescribeAutoScalingInstances = jest.fn();\nconst mockCloudWatch = jest.fn();\nconst mockGetMetricData = jest.fn();\nconst mockGetInstanceCost = jest.fn();\nconst mockTerminateInstances = jest.fn();\nconst mockModifyInstanceAttribute = jest.fn();\n\nconst mockCache = new MockCache();\n\njest.mock('cached', () => () => mockCache);", "\njest.mock('cached', () => () => mockCache);\n\njest.mock('@aws-sdk/client-ec2', () => {\n  const original = jest.requireActual('@aws-sdk/client-ec2');\n  const { DescribeInstanceTypesCommandOutput, Instance, InstanceTypeInfo, _InstanceType } = original;\n  return {\n    EC2: mockEc2,\n    DescribeInstanceTypesCommandOutput,\n    Instance,", "    DescribeInstanceTypesCommandOutput,\n    Instance,\n    InstanceTypeInfo,\n    _InstanceType\n  };\n});\njest.mock('@aws-sdk/client-auto-scaling', () => ({\n    AutoScaling: mockAutoScaling\n}));\njest.mock('@aws-sdk/client-cloudwatch', () => {", "}));\njest.mock('@aws-sdk/client-cloudwatch', () => {\n  const original = jest.requireActual('@aws-sdk/client-cloudwatch');\n  const { MetricDataQuery, MetricDataResult } = original;\n  return {\n    CloudWatch: mockCloudWatch,\n    MetricDataQuery,\n    MetricDataResult\n  };\n});", "  };\n});\njest.mock('../../src/utils/ec2-utils.js', () => {\n  const original = jest.requireActual('../../src/utils/ec2-utils.js');\n  return {\n    ...original,\n    getInstanceCost: mockGetInstanceCost\n  }\n});\n", "});\n\nconst mockInstance1 = {\n  InstanceId: 'mock-instance-1',\n  InstanceType: 't2.micro'\n};\nconst mockInstance2 = {\n  InstanceId: 'mock-instance-2',\n  InstanceType: 'm5.medium'\n};", "  InstanceType: 'm5.medium'\n};\n\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { AwsEc2InstanceUtilization } from '../../src/service-utilizations/aws-ec2-instance-utilization';\nimport t2Micro from '../mocks/T2Micro.json';\nimport t2Nano from '../mocks/T2Nano.json';\nimport { AVG_CPU, AVG_NETWORK_BYTES_IN, AVG_NETWORK_BYTES_OUT, DISK_READ_OPS, DISK_WRITE_OPS, MAX_CPU, MAX_NETWORK_BYTES_IN, MAX_NETWORK_BYTES_OUT } from \"../../src/types/constants\";\n\ndescribe('AwsEc2InstanceUtilization', () => {", "\ndescribe('AwsEc2InstanceUtilization', () => {\n  beforeEach(() => {\n    mockEc2.mockReturnValue({\n      describeInstances: mockDescribeInstances,\n      describeInstanceTypes: mockDescribeInstanceTypes,\n      terminateInstances: mockTerminateInstances,\n      modifyInstanceAttribute: mockModifyInstanceAttribute\n    });\n    mockAutoScaling.mockReturnValue({", "    });\n    mockAutoScaling.mockReturnValue({\n      describeAutoScalingInstances: mockDescribeAutoScalingInstances\n    });\n    mockCloudWatch.mockReturnValue({\n      getMetricData: mockGetMetricData\n    });\n  });\n\n  afterEach(() => {", "\n  afterEach(() => {\n    // for mocks\n    jest.resetAllMocks();\n    // for spies\n    jest.restoreAllMocks();\n    mockCache.reset();\n    mockCache.restore();\n  });\n", "  });\n\n  describe('getRegionalUtilization', () => {\n    it('Calls describeInstances with instanceIds if provided', async () => {\n      mockDescribeInstances.mockResolvedValueOnce({\n        Reservations: [], // Return empty to short circuit test\n        NextToken: 'nextToken'\n      });\n      mockDescribeInstances.mockResolvedValueOnce({\n        Reservations: []", "      mockDescribeInstances.mockResolvedValueOnce({\n        Reservations: []\n      });\n      mockDescribeInstanceTypes.mockResolvedValueOnce({});\n\n      const ec2Util = new AwsEc2InstanceUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n      await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1', { instanceIds: ['mock-instance-1', 'mock-instance-2'] });", "      } as unknown as AwsCredentialsProvider;\n      await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1', { instanceIds: ['mock-instance-1', 'mock-instance-2'] });\n\n      expect(mockDescribeInstances).toBeCalled();\n      expect(mockDescribeInstances).toBeCalledTimes(2);\n      expect(mockDescribeInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1', 'mock-instance-2']\n      });\n      expect(mockDescribeInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1', 'mock-instance-2'],", "      expect(mockDescribeInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1', 'mock-instance-2'],\n        NextToken: 'nextToken'\n      });\n    });\n    it('Filters out instances that are part of an ASG', async () => {\n      mockDescribeInstances.mockResolvedValueOnce({\n        Reservations: [\n          {\n            Instances: [mockInstance1]", "          {\n            Instances: [mockInstance1]\n          },\n          {\n            Instances: [mockInstance2]\n          }\n        ]\n      });\n      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n        AutoScalingInstances: [mockInstance1, mockInstance2] // return both to short circuit test", "      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n        AutoScalingInstances: [mockInstance1, mockInstance2] // return both to short circuit test\n      });\n\n      const ec2Util = new AwsEc2InstanceUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1');", "\n      await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1');\n      \n\n      expect(mockDescribeInstances).toBeCalled();\n      expect(mockDescribeInstances).toBeCalledWith({});\n      \n      expect(mockDescribeAutoScalingInstances).toBeCalled();\n      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1', 'mock-instance-2']", "      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1', 'mock-instance-2']\n      });\n      \n      expect(mockDescribeInstanceTypes).not.toBeCalled();\n    });\n    it('Suggests termination if an instance appears to not be used', async () => {\n      mockDescribeInstances.mockResolvedValueOnce({\n        Reservations: [\n          {", "        Reservations: [\n          {\n            Instances: [mockInstance1]\n          }\n        ]\n      });\n      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n        AutoScalingInstances: []\n      });\n      mockDescribeInstanceTypes.mockResolvedValueOnce({", "      });\n      mockDescribeInstanceTypes.mockResolvedValueOnce({\n        InstanceTypes: [\n          t2Micro\n        ]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Id: AVG_CPU,", "          {\n            Id: AVG_CPU,\n            Values: [0.01, 0.02, 0.03]\n          },\n          {\n            Id: MAX_CPU,\n            Values: [0.01, 0.02, 0.03]\n          },\n          {\n            Id: DISK_READ_OPS,", "          {\n            Id: DISK_READ_OPS,\n            Values: [0, 0, 0]\n          },\n          {\n            Id: DISK_WRITE_OPS,\n            Values: [0, 0, 0]\n          },\n          {\n            Id: AVG_NETWORK_BYTES_IN,", "          {\n            Id: AVG_NETWORK_BYTES_IN,\n            Values: [1500, 1750, 2250]\n          },\n          {\n            Id: AVG_NETWORK_BYTES_OUT,\n            Values: [1250, 1500, 1750]\n          }\n        ]\n      });", "        ]\n      });\n      mockGetInstanceCost.mockResolvedValueOnce(50);\n\n      const ec2Util = new AwsEc2InstanceUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      try { \n        await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1');", "\n      try { \n        await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1');\n      } catch (error) {\n        console.error(error);\n      }\n\n      expect(mockDescribeInstances).toBeCalled();\n      expect(mockDescribeInstances).toBeCalledWith({});\n      \n      expect(mockDescribeAutoScalingInstances).toBeCalled();\n      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1']\n      });\n      \n      expect(mockDescribeInstanceTypes).toBeCalled();\n      expect(mockDescribeInstanceTypes).toBeCalledTimes(1);\n      expect(mockDescribeInstanceTypes).toBeCalledWith({\n        InstanceTypes: ['t2.micro']\n      });\n\n      expect(mockGetMetricData).toBeCalled();\n\n      expect(ec2Util.utilization).toHaveProperty('arn:aws:ec2:us-east-1:undefined:instance/mock-instance-1', {\n        data: {\n          resourceId: 'mock-instance-1',\n          region: 'us-east-1',\n          hourlyCost: (50 / 30) / 24,\n          monthlyCost: 50,\n          maxMonthlySavings: 50\n        },\n        scenarios: {\n          unused: {\n            value: 'true',\n            delete: {\n              action: 'terminateInstance',\n              isActionable: true,\n              reason: 'This EC2 instance appears to be unused based on its CPU utilization, disk IOPS, and network traffic.',\n              monthlySavings: 50\n            }\n          }\n        }\n      });\n    });\n    it('Suggests scale down if an instance appears to be used but underutilized', async () => {\n      mockDescribeInstances.mockResolvedValueOnce({\n        Reservations: [\n          {\n            Instances: [mockInstance1]\n          }\n        ]\n      });\n      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n        AutoScalingInstances: []\n      });\n      mockDescribeInstanceTypes.mockResolvedValueOnce({\n        InstanceTypes: [\n          t2Micro\n        ]\n      });\n      mockDescribeInstanceTypes.mockResolvedValueOnce({\n        InstanceTypes: [\n          t2Nano,\n          t2Micro\n        ]\n      });\n      mockGetMetricData.mockResolvedValueOnce({\n        MetricDataResults: [\n          {\n            Id: AVG_CPU,\n            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n          },\n          {\n            Id: MAX_CPU,\n            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n          },\n          {\n            Id: DISK_READ_OPS,\n            Values: [0, 0, 0, 1, 2]\n          },\n          {\n            Id: DISK_WRITE_OPS,\n            Values: [0, 0, 0, 1, 2]\n          },\n          {\n            Id: AVG_NETWORK_BYTES_IN,\n            Values: [1500, 1750, 2250, (1.45 * Math.pow(10, 6)), (1.6 * Math.pow(10, 6))]\n          },\n          {\n            Id: AVG_NETWORK_BYTES_OUT,\n            Values: [1250, 1500, 1750, (4.60 * Math.pow(10, 6)), (5.02 * Math.pow(10, 6))]\n          },\n          {\n            Id: MAX_NETWORK_BYTES_IN,\n            Values: [1500, 1750, 2250, (1.45 * Math.pow(10, 6)), (1.6 * Math.pow(10, 6))]\n          },\n          {\n            Id: MAX_NETWORK_BYTES_OUT,\n            Values: [1250, 1500, 1750, (4.60 * Math.pow(10, 6)), (5.02 * Math.pow(10, 6))]\n          }\n        ]\n      });\n      mockGetInstanceCost.mockResolvedValueOnce(50);\n      mockGetInstanceCost.mockResolvedValueOnce(30);\n\n      mockCache.getOrElse.mockImplementationOnce((_key, refreshFunction) => {\n        return refreshFunction();\n      });\n\n      const ec2Util = new AwsEc2InstanceUtilization(true);\n      const provider = {\n        getCredentials: mockGetCredentials\n      } as unknown as AwsCredentialsProvider;\n\n      await ec2Util.getRegionalUtilization(provider, 'us-east-1');\n\n      expect(mockDescribeInstances).toBeCalled();\n      expect(mockDescribeInstances).toBeCalledWith({});\n      \n      expect(mockDescribeAutoScalingInstances).toBeCalled();\n      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n        InstanceIds: ['mock-instance-1']\n      });\n      \n      expect(mockDescribeInstanceTypes).toBeCalled();\n      expect(mockDescribeInstanceTypes).toBeCalledTimes(2);\n      expect(mockDescribeInstanceTypes).toBeCalledWith({\n        InstanceTypes: [\n          't2.2xlarge',\n          't2.large',\n          't2.medium',\n          't2.micro',\n          't2.nano',\n          't2.small',\n          't2.xlarge'\n        ]\n      });\n\n      expect(mockGetMetricData).toBeCalled();\n\n      expect(ec2Util.utilization).toHaveProperty('arn:aws:ec2:us-east-1:undefined:instance/mock-instance-1', {\n        data: {\n          resourceId: 'mock-instance-1',\n          region: 'us-east-1',\n          hourlyCost: (50 / 30) / 24,\n          monthlyCost: 50,\n          maxMonthlySavings: 20\n        },\n        scenarios: {\n          overAllocated: {\n            value: 'overAllocated',\n            scaleDown: {\n              action: 'scaleDownInstance',\n              isActionable: false,\n              reason: `This EC2 instance appears to be over allocated based on its CPU and network utilization.  We suggest scaling down to a t2.nano`,\n              monthlySavings: 20\n            }\n          }\n        }\n      });\n    });\n  });\n\n  describe('doAction', () => {\n    describe('terminateInstance', () => {\n      it('terminates instance', async () => {\n        mockTerminateInstances.mockResolvedValueOnce({});\n\n        const ec2InstanceUtilization = new AwsEc2InstanceUtilization();\n        const provider = {\n          getCredentials: mockGetCredentials\n        } as unknown as AwsCredentialsProvider;\n        await ec2InstanceUtilization.doAction(provider, 'terminateInstance', 'arn:aws:ec2:us-east-1:undefined:instance/mock-instance-1', 'us-east-1');\n\n        expect(mockTerminateInstances).toBeCalled();\n        expect(mockTerminateInstances).toBeCalledWith({\n          InstanceIds: [ 'mock-instance-1' ],\n        });\n      });\n    });\n\n    describe('scaleDownInstance', () => {\n      it('scales down instance', async () => {\n        mockModifyInstanceAttribute.mockResolvedValueOnce({});\n\n        const ec2InstanceUtilization = new AwsEc2InstanceUtilization();\n        const provider = {\n          getCredentials: mockGetCredentials\n        } as unknown as AwsCredentialsProvider;\n        await ec2InstanceUtilization.scaleDownInstance(provider, 'mock-instance-1', 'us-east-1', 't2-nano');\n\n        expect(mockModifyInstanceAttribute).toBeCalled();\n        expect(mockModifyInstanceAttribute).toBeCalledWith({\n          InstanceId: 'mock-instance-1',\n          InstanceType: {\n            Value: 't2-nano'\n          }\n        });\n      })\n    });\n  });\n});"]}
{"filename": "src/ops-types.ts", "chunked_list": ["import { Provider, Widget } from '@tinystacks/ops-model';\n\n/**\n * @example\n * ```yaml\n * AwsUtilizationRecommendations:\n    type: AwsUtilizationRecommendations\n    displayName: TinyStacks Recommendations\n    providers: \n      - $ref: '#/Console/providers/AwsProvider'", "    providers: \n      - $ref: '#/Console/providers/AwsProvider'\n      - $ref: '#/Console/providers/UtilizationProvider'\n * ```\n */\nexport interface AwsUtilizationRecommendations extends Widget {\n  regions?: string[]\n}\n\nexport interface AwsUtilization extends Widget {\n  region?: string\n}\n\n/**\n * @example\n * ```yaml\n * UtilizationProvider:\n    type: AwsUtilizationProvider\n * ```\n */", "export interface AwsUtilization extends Widget {\n  region?: string\n}\n\n/**\n * @example\n * ```yaml\n * UtilizationProvider:\n    type: AwsUtilizationProvider\n * ```\n */", "export interface AwsUtilizationProvider extends Provider {\n  services?: AwsResourceType[];\n  regions?: string[];\n}\n\nexport type AwsResourceType = 'Account' |\n  'CloudwatchLogs' |\n  'AutoscalingGroup' |\n  'Ec2Instance' |\n  'EcsService' |\n  'NatGateway' |\n  'S3Bucket' |\n  'EbsVolume' |\n  'RdsInstance';"]}
{"filename": "src/aws-utilization-provider.ts", "chunked_list": ["import cached from 'cached';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { BaseProvider } from '@tinystacks/ops-core';\nimport {\n  ActionType,\n  AwsResourceType,\n  AwsServiceOverrides,\n  AwsUtilizationOverrides,\n  HistoryEvent,\n  Utilization", "  HistoryEvent,\n  Utilization\n} from './types/types.js';\nimport { AwsServiceUtilization } from './service-utilizations/aws-service-utilization.js';\nimport { AwsServiceUtilizationFactory } from './service-utilizations/aws-service-utilization-factory.js';\nimport { AwsUtilizationProvider as AwsUtilizationProviderType } from './ops-types.js';\n\nconst utilizationCache = cached<Utilization<string>>('utilization', {\n  backend: {\n    type: 'memory'", "  backend: {\n    type: 'memory'\n  }\n});\n\nconst sessionHistoryCache = cached<Array<HistoryEvent>>('session-history', {\n  backend: {\n    type: 'memory'\n  }\n});", "  }\n});\n\ntype AwsUtilizationProviderProps = AwsUtilizationProviderType & {\n  utilization?: {\n    [key: AwsResourceType | string]: Utilization<string>\n  };\n  region?: string;\n};\n\nclass AwsUtilizationProvider extends BaseProvider {\n  static type = 'AwsUtilizationProvider';\n  services: AwsResourceType[];\n  utilizationClasses: {\n    [key: AwsResourceType | string]: AwsServiceUtilization<string>\n  };\n  utilization: {\n    [key: AwsResourceType | string]: Utilization<string>\n  };\n  region: string;\n\n  constructor (props: AwsUtilizationProviderProps) {\n    super(props);\n    const { \n      services\n    } = props;\n\n    this.utilizationClasses = {};\n    this.utilization = {};\n    this.initServices(services || [\n      'Account',\n      'CloudwatchLogs',\n      'Ec2Instance',\n      'EcsService',\n      'NatGateway',\n      'S3Bucket',\n      'EbsVolume',\n      'RdsInstance'\n    ]);\n  }\n\n  static fromJson (props: AwsUtilizationProviderProps) {\n    return new AwsUtilizationProvider(props);\n  }\n\n  toJson (): AwsUtilizationProviderProps {\n    return {\n      ...super.toJson(),\n      services: this.services,\n      utilization: this.utilization\n    };\n  }\n\n  initServices (services: AwsResourceType[]) {\n    this.services = services;", "class AwsUtilizationProvider extends BaseProvider {\n  static type = 'AwsUtilizationProvider';\n  services: AwsResourceType[];\n  utilizationClasses: {\n    [key: AwsResourceType | string]: AwsServiceUtilization<string>\n  };\n  utilization: {\n    [key: AwsResourceType | string]: Utilization<string>\n  };\n  region: string;\n\n  constructor (props: AwsUtilizationProviderProps) {\n    super(props);\n    const { \n      services\n    } = props;\n\n    this.utilizationClasses = {};\n    this.utilization = {};\n    this.initServices(services || [\n      'Account',\n      'CloudwatchLogs',\n      'Ec2Instance',\n      'EcsService',\n      'NatGateway',\n      'S3Bucket',\n      'EbsVolume',\n      'RdsInstance'\n    ]);\n  }\n\n  static fromJson (props: AwsUtilizationProviderProps) {\n    return new AwsUtilizationProvider(props);\n  }\n\n  toJson (): AwsUtilizationProviderProps {\n    return {\n      ...super.toJson(),\n      services: this.services,\n      utilization: this.utilization\n    };\n  }\n\n  initServices (services: AwsResourceType[]) {\n    this.services = services;", "    for (const service of this.services) {\n      this.utilizationClasses[service] = AwsServiceUtilizationFactory.createObject(service);\n    }\n  }\n\n  async refreshUtilizationData (\n    service: AwsResourceType, \n    credentialsProvider: AwsCredentialsProvider,\n    region: string,\n    overrides?: AwsServiceOverrides\n  ): Promise<Utilization<string>> {", "    try {\n      await this.utilizationClasses[service]?.getUtilization(credentialsProvider, [ region ], overrides);\n      return this.utilizationClasses[service]?.utilization;\n    } catch (e) {\n      console.error(e);\n      return {};\n    }\n  }\n\n  async doAction (\n    service: AwsResourceType,\n    credentialsProvider: AwsCredentialsProvider,\n    actionName: string,\n    actionType: ActionType,\n    resourceArn: string,\n    region: string\n  ) {\n    const event: HistoryEvent = {\n      service,\n      actionType,\n      actionName,\n      resourceArn,\n      region,\n      timestamp: new Date().toISOString()\n    };\n    const history: HistoryEvent[] = await this.getSessionHistory();\n    history.push(event);\n    await this.utilizationClasses[service].doAction(credentialsProvider, actionName, resourceArn, region);\n    await sessionHistoryCache.set('history', history);\n  }\n\n  async hardRefresh (\n    credentialsProvider: AwsCredentialsProvider, region: string, overrides: AwsUtilizationOverrides = {}\n  ) {", "    for (const service of this.services) {\n      const serviceOverrides = overrides[service];\n      this.utilization[service] = await this.refreshUtilizationData(\n        service, credentialsProvider, region, serviceOverrides\n      );\n      await utilizationCache.set(service, this.utilization[service]);\n    }\n\n    return this.utilization;\n  }\n\n  async getUtilization (\n    credentialsProvider: AwsCredentialsProvider, region: string, overrides: AwsUtilizationOverrides = {}\n  ) {", "    for (const service of this.services) {\n      const serviceOverrides = overrides[service];\n      if (serviceOverrides?.forceRefesh) {\n        this.utilization[service] = await this.refreshUtilizationData(\n          service, credentialsProvider, region, serviceOverrides\n        );\n        await utilizationCache.set(service, this.utilization[service]);\n      } else {\n        this.utilization[service] = await utilizationCache.getOrElse(\n          service,\n          async () => await this.refreshUtilizationData(service, credentialsProvider, region, serviceOverrides)\n        );\n      }\n    }\n\n    return this.utilization;\n  }\n\n  async getSessionHistory (): Promise<HistoryEvent[]> {\n    return sessionHistoryCache.getOrElse('history', []);\n  }\n}\n\nexport {\n  AwsUtilizationProvider\n};"]}
{"filename": "src/index.ts", "chunked_list": ["import { AwsUtilization } from './widgets/aws-utilization.js';\nimport { AwsUtilizationProvider } from './aws-utilization-provider.js';\nimport { AwsUtilizationRecommendations } from './widgets/aws-utilization-recommendations.js';\nexport { \n  AwsUtilization,\n  AwsUtilizationProvider,\n  AwsUtilizationRecommendations\n};"]}
{"filename": "src/utils/utilization.ts", "chunked_list": ["import isEmpty from 'lodash.isempty';\nimport { ActionType, HistoryEvent, Scenarios, Utilization } from '../types/types.js';\n\nexport function filterUtilizationForActionType (\n  utilization: { [service: string]: Utilization<string> }, actionType: ActionType,  session: HistoryEvent[]\n):\n{ [service: string]: Utilization<string> } {\n  const filtered: { [service: string]: Utilization<string> } = {};\n\n  if (!utilization) {\n    return filtered;\n  }\n\n  Object.keys(utilization).forEach((service) => {\n    filtered[service] = filterServiceForActionType(utilization, service, actionType, session);\n  });\n  return filtered;\n}\n", "  if (!utilization) {\n    return filtered;\n  }\n\n  Object.keys(utilization).forEach((service) => {\n    filtered[service] = filterServiceForActionType(utilization, service, actionType, session);\n  });\n  return filtered;\n}\n\nexport function filterServiceForActionType (\n  utilization: { [service: string]: Utilization<string> }, service: string, \n  actionType: ActionType, session: HistoryEvent[]\n) {\n  const resourcesInProgress = session.map((historyevent) => {\n    return historyevent.resourceArn;\n  });  \n\n  const serviceUtil = utilization[service];\n  const actionFilteredServiceUtil = \n    Object.entries(serviceUtil).reduce<Utilization<string>>((aggUtil, [id, resource]) => {", "export function filterServiceForActionType (\n  utilization: { [service: string]: Utilization<string> }, service: string, \n  actionType: ActionType, session: HistoryEvent[]\n) {\n  const resourcesInProgress = session.map((historyevent) => {\n    return historyevent.resourceArn;\n  });  \n\n  const serviceUtil = utilization[service];\n  const actionFilteredServiceUtil = \n    Object.entries(serviceUtil).reduce<Utilization<string>>((aggUtil, [id, resource]) => {", "      if(resourcesInProgress.includes(id)){ \n        delete aggUtil[id];\n        return aggUtil;\n      }\n      const filteredScenarios: Scenarios<string> = {};\n      Object.entries(resource.scenarios).forEach(([sType, details]) => {\n        if (Object.hasOwn(details, actionType)) {\n          filteredScenarios[sType] = details;\n        }\n      });\n      ", "      if (!filteredScenarios || isEmpty(filteredScenarios)) {\n        return aggUtil;\n      }\n      \n      aggUtil[id] = {\n        ...resource,\n        scenarios: filteredScenarios \n      };\n      return aggUtil;\n    }, {});\n  return actionFilteredServiceUtil;\n}\n", "export function getNumberOfResourcesFromFilteredActions (filtered: { [service: string]: Utilization<string> }): number {\n  let total = 0;\n  Object.keys(filtered).forEach((s) => {\n    if (!filtered[s] || isEmpty(filtered[s])) return;\n    total += Object.keys(filtered[s]).length;\n  });\n  return total;\n}\n\nexport function getNumberOfResourcesInProgress (session: HistoryEvent[]): { [ key in ActionType ]: number } {\n  const result: { [ key in ActionType ]: number } = {\n    [ActionType.OPTIMIZE]: 0,\n    [ActionType.DELETE]: 0,\n    [ActionType.SCALE_DOWN]: 0\n  };  \n\n  session.forEach((historyEvent) => { \n    result[historyEvent.actionType] ++;\n  });\n\n  return result;\n\n}\n", "export function getNumberOfResourcesInProgress (session: HistoryEvent[]): { [ key in ActionType ]: number } {\n  const result: { [ key in ActionType ]: number } = {\n    [ActionType.OPTIMIZE]: 0,\n    [ActionType.DELETE]: 0,\n    [ActionType.SCALE_DOWN]: 0\n  };  \n\n  session.forEach((historyEvent) => { \n    result[historyEvent.actionType] ++;\n  });\n\n  return result;\n\n}\n", "export function getTotalNumberOfResources ( utilization: { [service: string]: Utilization<string> }): number { \n  let total = 0; \n  Object.keys(utilization).forEach((service) => {\n    if (!utilization[service] || isEmpty(utilization[service])) return;\n    total += Object.keys(utilization[service]).length;\n  });\n\n  return total;\n}\n\nexport function getTotalMonthlySavings (utilization: { [service: string]: Utilization<string> }): string { \n  const usd = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD'\n  });\n  \n  let totalSavings = 0; \n  Object.keys(utilization).forEach((service) => {", "export function getTotalMonthlySavings (utilization: { [service: string]: Utilization<string> }): string { \n  const usd = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD'\n  });\n  \n  let totalSavings = 0; \n  Object.keys(utilization).forEach((service) => {\n    if (!utilization[service] || isEmpty(utilization[service])) return;\n    Object.keys(utilization[service]).forEach((resource) => { \n      totalSavings += utilization[service][resource].data?.maxMonthlySavings || 0;\n    });\n  });\n\n  return usd.format(totalSavings);\n}\n", "    if (!utilization[service] || isEmpty(utilization[service])) return;\n    Object.keys(utilization[service]).forEach((resource) => { \n      totalSavings += utilization[service][resource].data?.maxMonthlySavings || 0;\n    });\n  });\n\n  return usd.format(totalSavings);\n}\n\nexport function sentenceCase (name: string): string { \n  const result = name.replace(/([A-Z])/g, ' $1');\n  return result[0].toUpperCase() + result.substring(1).toLowerCase();\n}\n", "export function sentenceCase (name: string): string { \n  const result = name.replace(/([A-Z])/g, ' $1');\n  return result[0].toUpperCase() + result.substring(1).toLowerCase();\n}\n\nexport function splitServiceName (name: string) {\n  return name?.split(/(?=[A-Z])/).join(' ');\n}"]}
{"filename": "src/utils/stats.ts", "chunked_list": ["import * as stats from 'simple-statistics';\nimport { StabilityStats, StabilityStatsOptions } from '../types/types';\nimport isEmpty from 'lodash.isempty';\n/**\n * \n * @param dataSet - The data to run stats on.\n * @param options - {@link StabilityStatsOptions}\n * @returns - {@link StabilityStats}\n */\nexport function getStabilityStats (dataSet: number[], options?: StabilityStatsOptions): StabilityStats {\n  const {\n    removeOutliers = false,\n    outlierZScore = 5,\n    anomalyThreshold = 0.5,\n    stabilityZScore = 3\n  } = options || {};\n", " */\nexport function getStabilityStats (dataSet: number[], options?: StabilityStatsOptions): StabilityStats {\n  const {\n    removeOutliers = false,\n    outlierZScore = 5,\n    anomalyThreshold = 0.5,\n    stabilityZScore = 3\n  } = options || {};\n\n  if (isEmpty(dataSet)) {\n    return {\n      mean: 0,\n      max: 0,\n      maxZScore: 0,\n      standardDeviation: 0,\n      wasFiltered: false,\n      isStable: false\n    };\n  }\n\n  let wasFiltered = removeOutliers;\n  const mean = stats.mean(dataSet);\n  const stdev = stats.standardDeviation(dataSet);\n  let filteredDataSet = dataSet;\n  let anomalyPercentage;", "  if (isEmpty(dataSet)) {\n    return {\n      mean: 0,\n      max: 0,\n      maxZScore: 0,\n      standardDeviation: 0,\n      wasFiltered: false,\n      isStable: false\n    };\n  }\n\n  let wasFiltered = removeOutliers;\n  const mean = stats.mean(dataSet);\n  const stdev = stats.standardDeviation(dataSet);\n  let filteredDataSet = dataSet;\n  let anomalyPercentage;", "  if (removeOutliers) {\n    const nonAnomolousData = dataSet.filter(val => stats.zScore(val, mean, stdev) < outlierZScore);\n    const dataSetSize = dataSet.length;\n    const anomolousDataSize = dataSetSize - nonAnomolousData.length;\n    anomalyPercentage = (anomolousDataSize / dataSetSize) * 100;\n    if (anomalyPercentage < anomalyThreshold) {\n      filteredDataSet = nonAnomolousData;\n    } else {\n      wasFiltered = false;\n    }\n  }\n  const filteredMean = stats.mean(filteredDataSet);\n  const filteredStdev = stats.standardDeviation(filteredDataSet);\n  const max = stats.max(filteredDataSet);\n  const maxZScore = stats.zScore(max, filteredMean, filteredStdev);\n  const isStable = maxZScore < stabilityZScore;\n  const anomalyPercentageString = anomalyPercentage ? `${Math.round(anomalyPercentage * 10000) / 10000}%` : undefined;\n  return {\n    mean: filteredMean,\n    max,\n    maxZScore,\n    standardDeviation: filteredStdev,\n    anomalyPercentage: anomalyPercentageString,\n    wasFiltered,\n    isStable\n  };\n}"]}
{"filename": "src/utils/ec2-utils.ts", "chunked_list": ["import { Pricing } from '@aws-sdk/client-pricing';\n\nexport async function getInstanceCost (pricingClient: Pricing, instanceType: string) {\n  const res = await pricingClient.getProducts({\n    Filters: [\n      {\n        Type: 'TERM_MATCH',\n        Field: 'instanceType',\n        Value: instanceType\n      },\n      {\n        Type: 'TERM_MATCH',\n        Field: 'regionCode',\n        Value: 'us-east-1'\n      },\n      {\n        Type: 'TERM_MATCH',\n        Field: 'operatingSystem',\n        Value: 'Linux'\n      },\n      {\n        Type: 'TERM_MATCH',\n        Field: 'usageType',\n        Value: `BoxUsage:${instanceType}`\n      },\n      {\n        Type: 'TERM_MATCH',\n        Field: 'preInstalledSw',\n        Value: 'NA'\n      }\n    ],\n    ServiceCode: 'AmazonEC2'\n  });\n\n  const onDemandData = JSON.parse(res.PriceList[0] as string).terms.OnDemand;\n  const onDemandKeys = Object.keys(onDemandData);\n  const priceDimensionsData = onDemandData[onDemandKeys[0]].priceDimensions;\n  const priceDimensionsKeys = Object.keys(priceDimensionsData);\n  const pricePerHour = priceDimensionsData[priceDimensionsKeys[0]].pricePerUnit.USD;\n\n  return pricePerHour * 24 * 30;\n}"]}
{"filename": "src/utils/utils.ts", "chunked_list": ["import { Account, ListRegionsCommandOutput } from '@aws-sdk/client-account';\nimport { STS } from '@aws-sdk/client-sts';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { BaseProvider } from '@tinystacks/ops-core';\nimport isEmpty from 'lodash.isempty';\nimport { AwsUtilizationProvider } from '../aws-utilization-provider.js';\n\n\n\nexport function getAwsUtilizationProvider (providers?: BaseProvider[]): AwsUtilizationProvider {\n  if (!providers || isEmpty(providers)) {\n    throw new Error('No AwsUtilizationProvider provided');\n  }\n\n  const provider = providers.find(p => p.type === AwsUtilizationProvider.type);", "\nexport function getAwsUtilizationProvider (providers?: BaseProvider[]): AwsUtilizationProvider {\n  if (!providers || isEmpty(providers)) {\n    throw new Error('No AwsUtilizationProvider provided');\n  }\n\n  const provider = providers.find(p => p.type === AwsUtilizationProvider.type);\n  if (!provider) {\n    throw new Error('No AwsUtilizationProvider provided');\n  }\n\n  return provider as AwsUtilizationProvider;\n}\n", "export function getAwsCredentialsProvider (providers?: BaseProvider[]): AwsCredentialsProvider {\n  if (!providers || isEmpty(providers)) {\n    throw new Error('No AwsCredentialsProvider provided');\n  }\n\n  const provider = providers.find(p => p.type === AwsCredentialsProvider.type);\n  if (!provider) {\n    throw new Error('No AwsCredentialsProvider provided');\n  }\n\n  return provider as AwsCredentialsProvider;\n}\n", "export function findProvider<T extends BaseProvider> (providers: BaseProvider[] = [], providerType: string): T {\n  if (!providers || isEmpty(providers)) {\n    throw new Error('No providers are available!');\n  }\n\n  const provider = providers.find(p => p.type === providerType);\n  if (!provider) {\n    throw new Error(`No ${providerType}s are available!`);\n  }\n\n  return provider as T;\n}\n", "export async function listAllRegions (awsCredentialsProvider: AwsCredentialsProvider) {\n  const accountClient = new Account({\n    credentials: await awsCredentialsProvider.getCredentials(),\n    region: 'us-east-1'\n  });\n\n  let regions: string[] = [];\n  let listRegionsRes: ListRegionsCommandOutput;\n  do {\n    listRegionsRes = await accountClient.listRegions({\n      RegionOptStatusContains: ['ENABLED', 'ENABLED_BY_DEFAULT'],\n      NextToken: listRegionsRes?.NextToken\n    });\n    regions = [...regions, ...listRegionsRes.Regions.map(region => region.RegionName)];", "  } while (listRegionsRes?.NextToken);\n\n  return regions;\n}\n\nexport async function getAccountId (credentials: any) {\n  const stsClient = new STS({\n    credentials,\n    region: 'us-east-1'\n  });\n\n  return (await stsClient.getCallerIdentity({}))?.Account;\n}\n", "export async function addFullJitter (attempt: number, cap = 5000, base = 3000, min = 3000) {\n  const randomBetween = Math.floor(Math.random() * (Math.min(cap, base * 2 ** attempt) - min + 1) + min);\n  await new Promise(r => setTimeout(r, randomBetween));\n}\n\nexport function rateLimitMap (\n  array: any[], requestsPerSec: number, maxInFlight: number, fn: (...args: any[]) => Promise<void>\n) {\n  return new Promise((resolve, reject) => {\n    let index = 0;\n    let inFlightCntr = 0;\n    let doneCntr = 0;\n    const launchTimes: number[] = [];\n    const results = new Array(array.length);\n\n    // calculate num requests in last second", "    function calcRequestsInLastSecond () {\n      const now = Date.now();\n      // look backwards in launchTimes to see how many were launched within the last second\n      let cnt = 0;\n      for (let i = launchTimes.length - 1; i >= 0; i--) {\n        if (now - launchTimes[i] < 1000) {\n          ++cnt;\n        } else {\n          break;\n        }\n      }\n      return cnt;\n    }\n", "    function runMore () {\n      while (index < array.length && inFlightCntr < maxInFlight && calcRequestsInLastSecond() < requestsPerSec) {\n        (function (i) {\n          ++inFlightCntr;\n          launchTimes.push(Date.now());\n          fn(array[i]).then((val: any) => {\n            results[i] = val;\n            --inFlightCntr;\n            ++doneCntr;\n            runMore();\n          }, reject);\n        })(index);\n        ++index;\n      }\n      // see if we're done", "      if (doneCntr === array.length) {\n        resolve(results);\n      } else if (launchTimes.length >= requestsPerSec) {\n        // calc how long we have to wait before sending more\n        let delta = 1000 - (Date.now() - launchTimes[launchTimes.length - requestsPerSec]);\n        if (delta >= 0) {\n          setTimeout(runMore, ++delta);\n        }\n      }\n    }\n    runMore();\n  });\n}\n", "export function round (val: number, decimalPlace: number) {\n  const factor = 10 ** decimalPlace;\n  return Math.round(val * factor) / factor;\n}\n\nexport function getHourlyCost (monthlyCost: number) {\n  return (monthlyCost / 30) / 24;\n}"]}
{"filename": "src/types/types.ts", "chunked_list": ["import { Tag } from '@aws-sdk/client-ec2';\n\n\nexport type Data = {\n  region: string,\n  resourceId: string,\n  associatedResourceId?: string,\n  stack?: string,\n  hourlyCost?: number,\n  monthlyCost?: number,\n  maxMonthlySavings?: number,\n  [ key: string ]: any;\n  tags?: Tag[];\n}\n", "export type Metrics = { \n  [ metricName: string ]: Metric\n}\n\nexport type Metric = { \n  yAxisLabel: string, \n  yLimits?: number, \n  values: MetricData[]\n}\n\nexport type MetricData = { \n  timestamp?: number | Date;\n  value: number\n}\n", "export type MetricData = { \n  timestamp?: number | Date;\n  value: number\n}\n\nexport enum ActionType {\n  OPTIMIZE='optimize',\n  DELETE='delete',\n  SCALE_DOWN='scaleDown'\n}\n\nexport const actionTypeText = {\n  [ActionType.OPTIMIZE]: 'optimize',\n  [ActionType.DELETE]: 'delete',\n  [ActionType.SCALE_DOWN]: 'scale down'\n};\n\nexport const actionTypeToEnum = {\n  [ActionType.OPTIMIZE.toString()]: ActionType.OPTIMIZE,\n  [ActionType.DELETE.toString()]: ActionType.DELETE,\n  [ActionType.SCALE_DOWN.toString()]: ActionType.SCALE_DOWN\n};\n", "export type Action = {\n  action: string,\n  isActionable: boolean,\n  reason: string\n  monthlySavings?: number\n}\n\nexport type Scenario = {\n  value: string,\n  delete?: Action,\n  scaleDown?: Action,\n  optimize?: Action\n}\n", "export type Scenarios<ScenarioTypes extends string> = {\n  [ scenarioType in ScenarioTypes ]: Scenario\n}\n\nexport type Resource<ScenarioTypes extends string> = {\n  scenarios: Scenarios<ScenarioTypes>,\n  data: Data,\n  metrics: Metrics\n}\n\nexport type Utilization<ScenarioTypes extends string> = {\n  [ resourceArn: string ]: Resource<ScenarioTypes>\n}\n", "export type Utilization<ScenarioTypes extends string> = {\n  [ resourceArn: string ]: Resource<ScenarioTypes>\n}\n\nexport type UserInput = { [ key: string ]: any }\n\nexport type AwsServiceOverrides = {\n  resourceArn: string,\n  scenarioType: string,\n  delete?: boolean,\n  scaleDown?: boolean,\n  optimize?: boolean,\n  forceRefesh?: boolean,\n  userInput?: UserInput\n}\n", "export type AwsUtilizationOverrides = {\n  [ serviceName: string ]: AwsServiceOverrides\n}\n\nexport type StabilityStats = {\n  mean: number;\n  max: number;\n  maxZScore: number;\n  standardDeviation: number;\n  anomalyPercentage?: string;\n  wasFiltered: boolean;\n  isStable: boolean;\n};\n\n/**\n * \n * @param removeOutliers - default false; Whether to remove outliers from the dataset before running the final stats.\n * @param outlierZScore - default 5; The cutoff Z score (number of standard deviations away from the mean) that is\n *                        considered an outlier.\n * @param anomalyThreshold - default 0.5; The maximum threshold, as a percentage, of anomalies in the dataset required\n *                           to perform outlier removal.  If the percentage of outliers in the dataset is higher that\n *                           this threshold, outliers will not be removed.\n * @param stabilityZScore - default 3; The cutoff Z score (non-inclusive) used to check for stability in the dataset.\n *                          If there are values above this, the dataset is considered unstable.\n */", "export type StabilityStatsOptions = {\n  removeOutliers?: boolean;\n  outlierZScore?: number;\n  anomalyThreshold?: number;\n  stabilityZScore?: number;\n};\n\nexport type AwsResourceType = 'Account' |\n  'CloudwatchLogs' |\n  'AutoscalingGroup' |\n  'Ec2Instance' |\n  'EcsService' |\n  'NatGateway' |\n  'S3Bucket' |\n  'EbsVolume' |\n  'RdsInstance';\n", "export type HistoryEvent = {\n  service: AwsResourceType;\n  actionType: ActionType;\n  actionName: string;\n  resourceArn: string;\n  region: string;\n  timestamp: string;\n}"]}
{"filename": "src/types/utilization-recommendations-types.ts", "chunked_list": ["import { Widget } from '@tinystacks/ops-model';\nimport { ActionType, AwsResourceType, HistoryEvent, Utilization } from './types.js';\n\nexport type HasActionType = {\n  actionType: ActionType;\n}\n\nexport type HasUtilization = {\n  utilization: { [key: AwsResourceType | string]: Utilization<string> };\n  sessionHistory: HistoryEvent[];\n\n}\n", "interface RemovableResource {\n  onRemoveResource: (resourceArn: string) => void;\n}\n\ninterface HasResourcesAction {\n  onResourcesAction: (resourceArns: string[], actionType: string) => void;\n}\n\ninterface Refresh {\n  onRefresh: () => void;\n}\n", "interface Refresh {\n  onRefresh: () => void;\n}\n\nexport type UtilizationRecommendationsWidget = Widget & HasActionType & HasUtilization & {\n  region: string\n};\nexport interface Regions {\n  onRegionChange: (region: string) => void;\n  allRegions: string[];\n  region: string;\n}\n", "export type UtilizationRecommendationsUiProps = HasUtilization & HasResourcesAction & Refresh & Regions;\nexport type RecommendationsCallback = (props: RecommendationsOverrides) => void;\nexport type RecommendationsOverrides = {\n  refresh?: boolean;\n  resourceActions?: {\n    actionType: string,\n    resourceArns: string[]\n  };\n  region?: string;\n};\nexport type RecommendationsTableProps = HasActionType & HasUtilization & {\n  onContinue: (resourceArns: string[]) => void;\n  onBack: () => void;\n  onRefresh: () => void;\n};", "export type RecommendationsTableProps = HasActionType & HasUtilization & {\n  onContinue: (resourceArns: string[]) => void;\n  onBack: () => void;\n  onRefresh: () => void;\n};\nexport type RecommendationsActionsSummaryProps = Widget & HasUtilization;\nexport type RecommendationsActionSummaryProps = HasUtilization & Regions & {\n  onContinue: (selectedActionType: ActionType) => void;\n  onRefresh: () => void;\n};\nexport type ConfirmSingleRecommendationProps = RemovableResource & HasActionType & HasResourcesAction & {\n  resourceArn: string;\n};", "export type ConfirmSingleRecommendationProps = RemovableResource & HasActionType & HasResourcesAction & {\n  resourceArn: string;\n};\nexport type ConfirmRecommendationsProps = RemovableResource & HasActionType & HasResourcesAction & HasUtilization & {\n  resourceArns: string[];\n  onBack: () => void;\n};\n\nexport type ServiceTableRowProps = {\n  serviceUtil: Utilization<string>;\n  serviceName: string;\n  children?: React.ReactNode;\n  onServiceCheckChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n  isChecked: boolean;\n};", "export type ServiceTableRowProps = {\n  serviceUtil: Utilization<string>;\n  serviceName: string;\n  children?: React.ReactNode;\n  onServiceCheckChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n  isChecked: boolean;\n};"]}
{"filename": "src/types/constants.ts", "chunked_list": ["import { AwsResourceType } from './types.js';\n\nexport const Arns = {\n  NatGateway (region: string, accountId: string, natGatewayId: string) {\n    return `arn:aws:ec2:${region}:${accountId}:natgateway/${natGatewayId}`;\n  },\n  Ec2 (region: string, accountId: string, instanceId: string) {\n    return `arn:aws:ec2:${region}:${accountId}:instance/${instanceId}`;\n  },\n  S3 (bucketName: string) {", "  },\n  S3 (bucketName: string) {\n    return `arn:aws:s3:::${bucketName}`;\n  },\n  Ebs (region: string, accountId: string, volumeId: string) {\n    return `arn:aws:ec2:${region}:${accountId}:volume/${volumeId}`;\n  }\n};\n\n// Because typescript enums transpile strangely and are even discouraged by typescript themselves:", "\n// Because typescript enums transpile strangely and are even discouraged by typescript themselves:\n// Source: https://www.typescriptlang.org/docs/handbook/enums.html#objects-vs-enums\nexport const AwsResourceTypes: {\n  [key: AwsResourceType | string]: AwsResourceType\n} = {\n  Account: 'Account',\n  CloudwatchLogs: 'CloudwatchLogs',\n  AutoscalingGroup: 'AutoscalingGroup',\n  Ec2Instance: 'Ec2Instance',", "  AutoscalingGroup: 'AutoscalingGroup',\n  Ec2Instance: 'Ec2Instance',\n  EcsService: 'EcsService',\n  NatGateway: 'NatGateway',\n  S3Bucket: 'S3Bucket',\n  EbsVolume: 'EbsVolume',\n  RdsInstance: 'RdsInstance'\n} as const;\n\nexport const ONE_GB_IN_BYTES = 1073741824;", "\nexport const ONE_GB_IN_BYTES = 1073741824;\n\nexport const AVG_CPU = 'avgCpu';\nexport const MAX_CPU = 'maxCpu';\nexport const AVG_MEMORY = 'avgMemory';\nexport const MAX_MEMORY = 'maxMemory';\nexport const DISK_READ_OPS = 'diskReadOps';\nexport const DISK_WRITE_OPS = 'diskWriteOps';\nexport const MAX_NETWORK_BYTES_IN = 'maxNetworkBytesIn';", "export const DISK_WRITE_OPS = 'diskWriteOps';\nexport const MAX_NETWORK_BYTES_IN = 'maxNetworkBytesIn';\nexport const MAX_NETWORK_BYTES_OUT = 'maxNetworkBytesOut';\nexport const AVG_NETWORK_BYTES_IN = 'avgNetworkBytesIn';\nexport const AVG_NETWORK_BYTES_OUT = 'avgNetworkBytesOut';\nexport const ALB_REQUEST_COUNT = 'albRequestCount';\nexport const APIG_REQUEST_COUNT = 'apigRequestCount';"]}
{"filename": "src/service-utilizations/aws-cloudwatch-logs-utilization.ts", "chunked_list": ["import get from 'lodash.get';\nimport { CloudWatch } from '@aws-sdk/client-cloudwatch';\nimport { CloudWatchLogs, DescribeLogGroupsCommandOutput, LogGroup } from '@aws-sdk/client-cloudwatch-logs';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { ONE_GB_IN_BYTES } from '../types/constants.js';\nimport { AwsServiceOverrides } from '../types/types.js';\nimport { getHourlyCost, rateLimitMap } from '../utils/utils.js';\nimport { AwsServiceUtilization } from './aws-service-utilization.js';\n\nconst ONE_HUNDRED_MB_IN_BYTES = 104857600;", "\nconst ONE_HUNDRED_MB_IN_BYTES = 104857600;\nconst NOW = Date.now();\nconst oneMonthAgo = NOW - (30 * 24 * 60 * 60 * 1000);\nconst thirtyDaysAgo = NOW - (30 * 24 * 60 * 60 * 1000);\nconst sevenDaysAgo = NOW - (7 * 24 * 60 * 60 * 1000);\nconst twoWeeksAgo = NOW - (14 * 24 * 60 * 60 * 1000);\n\ntype AwsCloudwatchLogsUtilizationScenarioTypes = 'hasRetentionPolicy' | 'lastEventTime' | 'storedBytes';\nconst AwsCloudWatchLogsMetrics = ['IncomingBytes'];\n", "type AwsCloudwatchLogsUtilizationScenarioTypes = 'hasRetentionPolicy' | 'lastEventTime' | 'storedBytes';\nconst AwsCloudWatchLogsMetrics = ['IncomingBytes'];\n\nexport class AwsCloudwatchLogsUtilization extends AwsServiceUtilization<AwsCloudwatchLogsUtilizationScenarioTypes> {\n  constructor () {\n    super();\n  }\n\n  async doAction (\n    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n  ): Promise<void> {\n    const resourceId = resourceArn.split(':').at(-2);", "    if (actionName === 'deleteLogGroup') {\n      const cwLogsClient = new CloudWatchLogs({\n        credentials: await awsCredentialsProvider.getCredentials(),\n        region\n      });\n\n      await this.deleteLogGroup(cwLogsClient, resourceId);\n    }\n\n    if(actionName === 'setRetentionPolicy'){ \n      const cwLogsClient = new CloudWatchLogs({\n        credentials: await awsCredentialsProvider.getCredentials(),\n        region\n      });\n\n      await this.setRetentionPolicy(cwLogsClient, resourceId, 90);\n    }\n  }\n\n\n  async setRetentionPolicy (cwLogsClient: CloudWatchLogs, logGroupName: string, retentionInDays: number) {\n    await cwLogsClient.putRetentionPolicy({\n      logGroupName,\n      retentionInDays\n    });\n  }\n\n  async deleteLogGroup (cwLogsClient: CloudWatchLogs, logGroupName: string) {\n    await cwLogsClient.deleteLogGroup({\n      logGroupName\n    });\n  }\n\n  async createExportTask (cwLogsClient: CloudWatchLogs, logGroupName: string, bucket: string) {\n    await cwLogsClient.createExportTask({\n      logGroupName,\n      destination: bucket,\n      from: 0,\n      to: Date.now()\n    });\n  }\n\n  private async getAllLogGroups (credentials: any, region: string) {\n    let allLogGroups: LogGroup[] = [];\n    const cwLogsClient = new CloudWatchLogs({\n      credentials,\n      region\n    });\n    let describeLogGroupsRes: DescribeLogGroupsCommandOutput;\n    do {\n      describeLogGroupsRes = await cwLogsClient.describeLogGroups({\n        nextToken: describeLogGroupsRes?.nextToken\n      });\n      allLogGroups = [ ...allLogGroups, ...describeLogGroupsRes?.logGroups || [] ];", "    if(actionName === 'setRetentionPolicy'){ \n      const cwLogsClient = new CloudWatchLogs({\n        credentials: await awsCredentialsProvider.getCredentials(),\n        region\n      });\n\n      await this.setRetentionPolicy(cwLogsClient, resourceId, 90);\n    }\n  }\n\n\n  async setRetentionPolicy (cwLogsClient: CloudWatchLogs, logGroupName: string, retentionInDays: number) {\n    await cwLogsClient.putRetentionPolicy({\n      logGroupName,\n      retentionInDays\n    });\n  }\n\n  async deleteLogGroup (cwLogsClient: CloudWatchLogs, logGroupName: string) {\n    await cwLogsClient.deleteLogGroup({\n      logGroupName\n    });\n  }\n\n  async createExportTask (cwLogsClient: CloudWatchLogs, logGroupName: string, bucket: string) {\n    await cwLogsClient.createExportTask({\n      logGroupName,\n      destination: bucket,\n      from: 0,\n      to: Date.now()\n    });\n  }\n\n  private async getAllLogGroups (credentials: any, region: string) {\n    let allLogGroups: LogGroup[] = [];\n    const cwLogsClient = new CloudWatchLogs({\n      credentials,\n      region\n    });\n    let describeLogGroupsRes: DescribeLogGroupsCommandOutput;\n    do {\n      describeLogGroupsRes = await cwLogsClient.describeLogGroups({\n        nextToken: describeLogGroupsRes?.nextToken\n      });\n      allLogGroups = [ ...allLogGroups, ...describeLogGroupsRes?.logGroups || [] ];", "    } while (describeLogGroupsRes?.nextToken);\n\n    return allLogGroups;\n  }\n\n  private async getEstimatedMonthlyIncomingBytes (\n    credentials: any, region: string, logGroupName: string, lastEventTime: number\n  ) {\n    if (!lastEventTime || lastEventTime < twoWeeksAgo) {\n      return 0;\n    }\n\n    const cwClient = new CloudWatch({\n      credentials,\n      region\n    });\n\n    // total bytes over last month\n    const res = await cwClient.getMetricData({\n      StartTime: new Date(oneMonthAgo),\n      EndTime: new Date(),\n      MetricDataQueries: [\n        {\n          Id: 'incomingBytes',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/Logs',\n              MetricName: 'IncomingBytes',\n              Dimensions: [{ Name: 'LogGroupName', Value: logGroupName }]\n            },\n            Period: 30 * 24 * 12 * 300, // 1 month\n            Stat: 'Sum'\n          }\n        }\n      ]\n    });\n    const monthlyIncomingBytes = get(res, 'MetricDataResults[0].Values[0]', 0);\n\n    return monthlyIncomingBytes;\n  }\n\n  private async getLogGroupData (credentials: any, region: string, logGroup: LogGroup) {\n    const cwLogsClient = new CloudWatchLogs({\n      credentials,\n      region\n    });\n    const logGroupName = logGroup?.logGroupName;\n\n    // get data and cost estimate for stored bytes \n    const storedBytes = logGroup?.storedBytes || 0;\n    const storedBytesCost = (storedBytes / ONE_GB_IN_BYTES) * 0.03;\n    const dataProtectionEnabled = logGroup?.dataProtectionStatus === 'ACTIVATED';\n    const dataProtectionCost = dataProtectionEnabled ? storedBytes * 0.12 : 0;\n    const monthlyStorageCost = storedBytesCost + dataProtectionCost;\n\n    // get data and cost estimate for ingested bytes\n    const describeLogStreamsRes = await cwLogsClient.describeLogStreams({\n      logGroupName,\n      orderBy: 'LastEventTime',\n      descending: true,\n      limit: 1\n    });\n    const lastEventTime = describeLogStreamsRes.logStreams[0]?.lastEventTimestamp;\n    const estimatedMonthlyIncomingBytes = await this.getEstimatedMonthlyIncomingBytes(\n      credentials, \n      region, \n      logGroupName, \n      lastEventTime\n    );\n    const logIngestionCost = (estimatedMonthlyIncomingBytes / ONE_GB_IN_BYTES) * 0.5;\n\n    // get associated resource\n    let associatedResourceId = '';", "    if (!lastEventTime || lastEventTime < twoWeeksAgo) {\n      return 0;\n    }\n\n    const cwClient = new CloudWatch({\n      credentials,\n      region\n    });\n\n    // total bytes over last month\n    const res = await cwClient.getMetricData({\n      StartTime: new Date(oneMonthAgo),\n      EndTime: new Date(),\n      MetricDataQueries: [\n        {\n          Id: 'incomingBytes',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/Logs',\n              MetricName: 'IncomingBytes',\n              Dimensions: [{ Name: 'LogGroupName', Value: logGroupName }]\n            },\n            Period: 30 * 24 * 12 * 300, // 1 month\n            Stat: 'Sum'\n          }\n        }\n      ]\n    });\n    const monthlyIncomingBytes = get(res, 'MetricDataResults[0].Values[0]', 0);\n\n    return monthlyIncomingBytes;\n  }\n\n  private async getLogGroupData (credentials: any, region: string, logGroup: LogGroup) {\n    const cwLogsClient = new CloudWatchLogs({\n      credentials,\n      region\n    });\n    const logGroupName = logGroup?.logGroupName;\n\n    // get data and cost estimate for stored bytes \n    const storedBytes = logGroup?.storedBytes || 0;\n    const storedBytesCost = (storedBytes / ONE_GB_IN_BYTES) * 0.03;\n    const dataProtectionEnabled = logGroup?.dataProtectionStatus === 'ACTIVATED';\n    const dataProtectionCost = dataProtectionEnabled ? storedBytes * 0.12 : 0;\n    const monthlyStorageCost = storedBytesCost + dataProtectionCost;\n\n    // get data and cost estimate for ingested bytes\n    const describeLogStreamsRes = await cwLogsClient.describeLogStreams({\n      logGroupName,\n      orderBy: 'LastEventTime',\n      descending: true,\n      limit: 1\n    });\n    const lastEventTime = describeLogStreamsRes.logStreams[0]?.lastEventTimestamp;\n    const estimatedMonthlyIncomingBytes = await this.getEstimatedMonthlyIncomingBytes(\n      credentials, \n      region, \n      logGroupName, \n      lastEventTime\n    );\n    const logIngestionCost = (estimatedMonthlyIncomingBytes / ONE_GB_IN_BYTES) * 0.5;\n\n    // get associated resource\n    let associatedResourceId = '';", "    if (logGroupName.startsWith('/aws/rds')) {\n      associatedResourceId = logGroupName.split('/')[4];\n    } else if (logGroupName.startsWith('/aws')) {\n      associatedResourceId = logGroupName.split('/')[3];\n    }\n\n    return {\n      storedBytes,\n      lastEventTime,\n      monthlyStorageCost,\n      totalMonthlyCost: logIngestionCost + monthlyStorageCost,\n      associatedResourceId\n    };\n  }\n\n  private async getRegionalUtilization (credentials: any, region: string, _overrides?: AwsServiceOverrides) {\n    const allLogGroups = await this.getAllLogGroups(credentials, region);\n\n    const analyzeLogGroup = async (logGroup: LogGroup) => {\n      const logGroupName = logGroup?.logGroupName;\n      const logGroupArn = logGroup?.arn;\n      const retentionInDays = logGroup?.retentionInDays;", "      if (!retentionInDays) {\n        const {\n          storedBytes,\n          lastEventTime,\n          monthlyStorageCost,\n          totalMonthlyCost,\n          associatedResourceId\n        } = await this.getLogGroupData(credentials, region, logGroup);\n\n        this.addScenario(logGroupArn, 'hasRetentionPolicy', {\n          value: retentionInDays?.toString(),\n          optimize: {\n            action: 'setRetentionPolicy',\n            isActionable: true,\n            reason: 'this log group does not have a retention policy',\n            monthlySavings: monthlyStorageCost\n          }\n        });\n\n        // TODO: change limit compared", "        if (storedBytes > ONE_HUNDRED_MB_IN_BYTES) {\n          this.addScenario(logGroupArn, 'storedBytes', {\n            value: storedBytes.toString(),\n            scaleDown: {\n              action: 'createExportTask',\n              isActionable: false,\n              reason: 'this log group has more than 100 MB of stored data',\n              monthlySavings: monthlyStorageCost\n            }\n          });\n        }\n        ", "        if (lastEventTime < thirtyDaysAgo) {\n          this.addScenario(logGroupArn, 'lastEventTime', {\n            value: new Date(lastEventTime).toLocaleString(),\n            delete: {\n              action: 'deleteLogGroup',\n              isActionable: true,\n              reason: 'this log group has not had an event in over 30 days',\n              monthlySavings: totalMonthlyCost\n            }\n          });\n        } else if (lastEventTime < sevenDaysAgo) {\n          this.addScenario(logGroupArn, 'lastEventTime', {\n            value: new Date(lastEventTime).toLocaleString(),\n            optimize: {\n              isActionable: false,\n              action: '',\n              reason: 'this log group has not had an event in over 7 days'\n            }\n          });\n        }\n\n        await this.fillData(\n          logGroupArn,\n          credentials,\n          region,\n          {\n            resourceId: logGroupName,\n            ...(associatedResourceId && { associatedResourceId }),\n            region,\n            monthlyCost: totalMonthlyCost,\n            hourlyCost: getHourlyCost(totalMonthlyCost)\n          }\n        );\n        \n        AwsCloudWatchLogsMetrics.forEach(async (metricName) => {  \n          await this.getSidePanelMetrics(\n            credentials, \n            region, \n            logGroupArn,\n            'AWS/Logs', \n            metricName, \n            [{ Name: 'LogGroupName', Value: logGroupName }]);\n        });\n      }\n    };\n\n    await rateLimitMap(allLogGroups, 5, 5, analyzeLogGroup);\n  }\n\n  async getUtilization (\n    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsServiceOverrides\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();", "        } else if (lastEventTime < sevenDaysAgo) {\n          this.addScenario(logGroupArn, 'lastEventTime', {\n            value: new Date(lastEventTime).toLocaleString(),\n            optimize: {\n              isActionable: false,\n              action: '',\n              reason: 'this log group has not had an event in over 7 days'\n            }\n          });\n        }\n\n        await this.fillData(\n          logGroupArn,\n          credentials,\n          region,\n          {\n            resourceId: logGroupName,\n            ...(associatedResourceId && { associatedResourceId }),\n            region,\n            monthlyCost: totalMonthlyCost,\n            hourlyCost: getHourlyCost(totalMonthlyCost)\n          }\n        );\n        \n        AwsCloudWatchLogsMetrics.forEach(async (metricName) => {  \n          await this.getSidePanelMetrics(\n            credentials, \n            region, \n            logGroupArn,\n            'AWS/Logs', \n            metricName, \n            [{ Name: 'LogGroupName', Value: logGroupName }]);\n        });\n      }\n    };\n\n    await rateLimitMap(allLogGroups, 5, 5, analyzeLogGroup);\n  }\n\n  async getUtilization (\n    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsServiceOverrides\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();", "    for (const region of regions) {\n      await this.getRegionalUtilization(credentials, region, overrides);\n    }\n  }\n}"]}
{"filename": "src/service-utilizations/aws-service-utilization.ts", "chunked_list": ["import { CloudFormation } from '@aws-sdk/client-cloudformation';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { Data, Metric, Resource, Scenario, Utilization, MetricData } from '../types/types';\nimport { CloudWatch, Dimension } from '@aws-sdk/client-cloudwatch';\n\nexport abstract class AwsServiceUtilization<ScenarioTypes extends string> {\n  private _utilization: Utilization<ScenarioTypes>;\n\n  constructor () {\n    this._utilization = {};\n  }\n", "  /* TODO: all services have a sub getRegionalUtilization function that needs to be deprecated\n   * since calls are now region specific\n   */\n  abstract getUtilization (\n    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: any\n  ): void | Promise<void>;\n\n  abstract doAction (\n    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceId: string, region: string\n  ): void | Promise<void>;\n\n  protected addScenario (resourceArn: string, scenarioType: ScenarioTypes, scenario: Scenario) {", "    if (!(resourceArn in this.utilization)) {\n      this.utilization[resourceArn] = {\n        scenarios: {},\n        data: {}, \n        metrics: {}\n      } as Resource<ScenarioTypes>;\n    }\n    this.utilization[resourceArn].scenarios[scenarioType] = scenario;\n  }\n\n  protected async fillData (\n    resourceArn: string, \n    credentials: any, \n    region: string, \n    data: { [ key: keyof Data ]: Data[keyof Data] }\n  ) {", "    for (const key in data) {\n      this.addData(resourceArn, key, data[key]);\n    }\n    await this.identifyCloudformationStack(\n      credentials, \n      region, \n      resourceArn, \n      data.resourceId,\n      data.associatedResourceId\n    );\n    this.getEstimatedMaxMonthlySavings(resourceArn);\n  }\n\n  protected addData (resourceArn: string, dataType: keyof Data, value: any) {\n    // only add data if recommendation exists for resource", "    if (resourceArn in this.utilization) {\n      this.utilization[resourceArn].data[dataType] = value;\n    }\n  }\n\n  protected addMetric (resourceArn: string, metricName: string, metric: Metric){ \n    if(resourceArn in this.utilization){ \n      this.utilization[resourceArn].metrics[metricName] = metric;\n    }\n  }\n\n  protected async identifyCloudformationStack (\n    credentials: any, region: string, resourceArn: string, resourceId: string, associatedResourceId?: string\n  ) {", "    if (resourceArn in this.utilization) {\n      const cfnClient = new CloudFormation({\n        credentials,\n        region\n      });\n      await cfnClient.describeStackResources({\n        PhysicalResourceId: associatedResourceId ? associatedResourceId : resourceId\n      }).then((res) => {\n        const stack = res.StackResources[0].StackId;\n        this.addData(resourceArn, 'stack', stack);\n      }).catch(() => { return; });\n    }\n  }\n\n  protected getEstimatedMaxMonthlySavings (resourceArn: string) {", "      }).catch(() => { return; });\n    }\n  }\n\n  protected getEstimatedMaxMonthlySavings (resourceArn: string) {\n    // for (const resourceArn in this.utilization) {\n    if (resourceArn in this.utilization) {\n      const scenarios = (this.utilization as Utilization<string>)[resourceArn].scenarios;\n      const maxSavingsPerScenario = Object.values(scenarios).map((scenario) => {\n        return Math.max(\n          scenario.delete?.monthlySavings || 0,\n          scenario.scaleDown?.monthlySavings || 0,\n          scenario.optimize?.monthlySavings || 0\n        );\n      });\n      const maxSavingsForResource = Math.max(...maxSavingsPerScenario);\n      this.addData(resourceArn, 'maxMonthlySavings', maxSavingsForResource);\n    }\n  }\n\n  protected async getSidePanelMetrics (\n    credentials: any, region: string, resourceArn: string, \n    nameSpace: string, metricName: string, dimensions: Dimension[]\n  ){ \n    ", "    if(resourceArn in this.utilization){\n      const cloudWatchClient = new CloudWatch({ \n        credentials: credentials, \n        region: region\n      }); \n\n      const endTime = new Date(Date.now()); \n      const startTime = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); //7 days ago\n      const period = 43200; \n    \n      const metrics = await cloudWatchClient.getMetricStatistics({ \n        Namespace: nameSpace, \n        MetricName: metricName, \n        StartTime: startTime,\n        EndTime: endTime,\n        Period: period,\n        Statistics: ['Average'],\n        Dimensions: dimensions\n      });\n  \n      const values: MetricData[] =  metrics.Datapoints.map(dp => ({ \n        timestamp: dp.Timestamp.getTime(), \n        value: dp.Average\n      })).sort((dp1, dp2) => dp1.timestamp - dp2.timestamp);\n  \n  \n      const metricResuls: Metric = { \n        yAxisLabel: metrics.Label || metricName, \n        values: values\n      }; \n\n      this.addMetric(resourceArn , metricName, metricResuls);\n\n    }\n  }\n\n  public set utilization (utilization: Utilization<ScenarioTypes>) { this._utilization = utilization; }\n\n  public get utilization () { return this._utilization; }\n}"]}
{"filename": "src/service-utilizations/aws-ec2-instance-utilization.ts", "chunked_list": ["import cached from 'cached';\nimport dayjs from 'dayjs';\nimport isNil from 'lodash.isnil';\nimport chunk from 'lodash.chunk';\nimport * as stats from 'simple-statistics';\nimport {\n  DescribeInstanceTypesCommandOutput, DescribeInstancesCommandOutput, EC2, Instance, InstanceTypeInfo, _InstanceType\n} from '@aws-sdk/client-ec2';\nimport { AutoScaling } from '@aws-sdk/client-auto-scaling';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';", "import { AutoScaling } from '@aws-sdk/client-auto-scaling';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport { AwsServiceUtilization } from './aws-service-utilization.js';\nimport {\n  CloudWatch,\n  MetricDataQuery,\n  MetricDataResult\n} from '@aws-sdk/client-cloudwatch';\nimport { getStabilityStats } from '../utils/stats.js';\nimport {", "import { getStabilityStats } from '../utils/stats.js';\nimport {\n  AVG_CPU,\n  MAX_CPU,\n  DISK_READ_OPS,\n  DISK_WRITE_OPS,\n  MAX_NETWORK_BYTES_IN,\n  MAX_NETWORK_BYTES_OUT,\n  AVG_NETWORK_BYTES_IN,\n  AVG_NETWORK_BYTES_OUT", "  AVG_NETWORK_BYTES_IN,\n  AVG_NETWORK_BYTES_OUT\n} from '../types/constants.js';\nimport { AwsServiceOverrides } from '../types/types.js';\nimport { Pricing } from '@aws-sdk/client-pricing';\nimport { getAccountId, getHourlyCost } from '../utils/utils.js';\nimport { getInstanceCost } from '../utils/ec2-utils.js';\nimport { Arns } from '../types/constants.js';\n\nconst cache = cached<string>('ec2-util-cache', {", "\nconst cache = cached<string>('ec2-util-cache', {\n  backend: {\n    type: 'memory'\n  }\n});\n\ntype AwsEc2InstanceUtilizationScenarioTypes = 'unused' | 'overAllocated';\nconst AwsEc2InstanceMetrics = ['CPUUtilization', 'NetworkIn'];\n\ntype AwsEc2InstanceUtilizationOverrides = AwsServiceOverrides & {\n  instanceIds: string[];\n}\n", "type AwsEc2InstanceUtilizationOverrides = AwsServiceOverrides & {\n  instanceIds: string[];\n}\n\nexport class AwsEc2InstanceUtilization extends AwsServiceUtilization<AwsEc2InstanceUtilizationScenarioTypes> {\n  instanceIds: string[];\n  instances: Instance[];\n  accountId: string;\n  DEBUG_MODE: boolean;\n\n  constructor (enableDebugMode?: boolean) {\n    super();\n    this.instanceIds = [];\n    this.instances = [];\n    this.DEBUG_MODE = enableDebugMode || false;\n  }\n\n  async doAction (\n    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n  ): Promise<void> {\n    const resourceId = (resourceArn.split(':').at(-1)).split('/').at(-1);", "    if (actionName === 'terminateInstance') {\n      await this.terminateInstance(awsCredentialsProvider, resourceId, region);\n    }\n  }\n\n  private async describeAllInstances (ec2Client: EC2, instanceIds?: string[]): Promise<Instance[]> {\n    const instances: Instance[] = [];\n    let nextToken;\n    do {\n      const response: DescribeInstancesCommandOutput = await ec2Client.describeInstances({\n        InstanceIds: instanceIds,\n        NextToken: nextToken\n      });\n      response?.Reservations.forEach((reservation) => {\n        instances.push(...reservation.Instances?.filter(i => !isNil(i.InstanceId)) || []);\n      });\n      nextToken = response?.NextToken;", "    } while (nextToken);\n\n    return instances;\n  }\n\n  private getMetricDataQueries (instanceId: string, period: number): MetricDataQuery[] {\n    function metricStat (metricName: string, statistic: string) {\n      return {\n        Metric: {\n          Namespace: 'AWS/EC2',\n          MetricName: metricName,\n          Dimensions: [{\n            Name: 'InstanceId',\n            Value: instanceId\n          }]\n        },\n        Period: period,\n        Stat: statistic\n      };\n    }\n    return [\n      {\n        Id: AVG_CPU,\n        MetricStat: metricStat('CPUUtilization', 'Average')\n      },\n      {\n        Id: MAX_CPU,\n        MetricStat: metricStat('CPUUtilization', 'Maximum')\n      },\n      {\n        Id: DISK_READ_OPS,\n        MetricStat: metricStat('DiskReadOps', 'Sum')\n      },\n      {\n        Id: DISK_WRITE_OPS,\n        MetricStat: metricStat('DiskWriteOps', 'Sum')\n      },\n      {\n        Id: MAX_NETWORK_BYTES_IN,\n        MetricStat: metricStat('NetworkIn', 'Maximum')\n      },\n      {\n        Id: MAX_NETWORK_BYTES_OUT,\n        MetricStat: metricStat('NetworkOut', 'Maximum')\n      },\n      {\n        Id: AVG_NETWORK_BYTES_IN,\n        MetricStat: metricStat('NetworkIn', 'Average')\n      },\n      {\n        Id: AVG_NETWORK_BYTES_OUT,\n        MetricStat: metricStat('NetworkOut', 'Average')\n      }\n    ];\n  }\n\n  private async getInstanceTypes (instanceTypeNames: string[], ec2Client: EC2): Promise<InstanceTypeInfo[]> {\n    const instanceTypes = [];\n    let nextToken;\n    do {\n      const instanceTypeResponse: DescribeInstanceTypesCommandOutput = await ec2Client.describeInstanceTypes({\n        InstanceTypes: instanceTypeNames,\n        NextToken: nextToken\n      });\n      const {\n        InstanceTypes = [],\n        NextToken\n      } = instanceTypeResponse;\n      instanceTypes.push(...InstanceTypes);\n      nextToken = NextToken;", "    } while (nextToken);\n    return instanceTypes;\n  }\n\n  private async getMetrics (args: {\n    instanceId: string;\n    startTime: Date;\n    endTime: Date; \n    period: number;\n    cwClient: CloudWatch;\n  }): Promise<{[ key: string ]: MetricDataResult}> {\n    const {\n      instanceId,\n      startTime,\n      endTime,\n      period,\n      cwClient\n    } = args;\n    const metrics: {[ key: string ]: MetricDataResult} = {};\n    let nextToken;\n    do {\n      const metricDataResponse = await cwClient.getMetricData({\n        MetricDataQueries: this.getMetricDataQueries(instanceId, period),\n        StartTime: startTime,\n        EndTime: endTime\n      });\n      const {\n        MetricDataResults,\n        NextToken\n      } = metricDataResponse || {};\n      MetricDataResults?.forEach((metricData: MetricDataResult) => {\n        const {\n          Id,\n          Timestamps = [],\n          Values = []\n        } = metricData;", "        if (!metrics[Id]) {\n          metrics[Id] = metricData;\n        } else {\n          metrics[Id].Timestamps.push(...Timestamps);\n          metrics[Id].Values.push(...Values);\n        }\n      });\n      nextToken = NextToken;\n    } while (nextToken);\n\n    return metrics;\n  }\n\n  private getInstanceNetworkSetting (networkSetting: string): number | string {\n    const numValue = networkSetting.split(' ').find(word => !Number.isNaN(Number(word)));", "    } while (nextToken);\n\n    return metrics;\n  }\n\n  private getInstanceNetworkSetting (networkSetting: string): number | string {\n    const numValue = networkSetting.split(' ').find(word => !Number.isNaN(Number(word)));\n    if (!isNil(numValue)) return Number(numValue);\n    return networkSetting;\n  }\n\n  async getRegionalUtilization (credentials: any, region: string, overrides?: AwsEc2InstanceUtilizationOverrides) {\n    const ec2Client = new EC2({\n      credentials,\n      region\n    });\n    const autoScalingClient = new AutoScaling({\n      credentials,\n      region\n    });\n    const cwClient = new CloudWatch({\n      credentials,\n      region\n    });\n    const pricingClient = new Pricing({\n      credentials,\n      region\n    });\n  \n    this.instances = await this.describeAllInstances(ec2Client, overrides?.instanceIds);\n    \n    const instanceIds = this.instances.map(i => i.InstanceId);\n    \n    const idPartitions = chunk(instanceIds, 50);", "    for (const partition of idPartitions) {\n      const { AutoScalingInstances = [] } = await autoScalingClient.describeAutoScalingInstances({\n        InstanceIds: partition\n      });\n\n      const asgInstances = AutoScalingInstances.map(instance => instance.InstanceId);\n      \n      this.instanceIds.push(\n        ...partition.filter(instanceId => !asgInstances.includes(instanceId))\n      );\n    }\n\n    this.instances = this.instances.filter(i => this.instanceIds.includes(i.InstanceId));\n    ", "    if (this.instances.length === 0) return;\n\n    const instanceTypeNames = this.instances.map(i => i.InstanceType);\n    const instanceTypes = await this.getInstanceTypes(instanceTypeNames, ec2Client);\n    const allInstanceTypes = Object.values(_InstanceType);\n\n    for (const instanceId of this.instanceIds) {\n      const instanceArn = Arns.Ec2(region, this.accountId, instanceId);\n      const instance = this.instances.find(i => i.InstanceId === instanceId);\n      const instanceType = instanceTypes.find(it => it.InstanceType === instance.InstanceType);\n      const instanceFamily = instanceType.InstanceType?.split('.')?.at(0);\n\n      const now = dayjs();\n      const startTime = now.subtract(2, 'weeks');\n      const fiveMinutes = 5 * 60;\n      const metrics = await this.getMetrics({\n        instanceId,\n        startTime: startTime.toDate(),\n        endTime: now.toDate(),\n        period: fiveMinutes,\n        cwClient\n      });\n\n      const {\n        [AVG_CPU]: avgCpuMetrics,\n        [MAX_CPU]: maxCpuMetrics,\n        [DISK_READ_OPS]: diskReadOps,\n        [DISK_WRITE_OPS]: diskWriteOps,\n        [MAX_NETWORK_BYTES_IN]: maxNetworkBytesIn,\n        [MAX_NETWORK_BYTES_OUT]: maxNetworkBytesOut,\n        [AVG_NETWORK_BYTES_IN]: avgNetworkBytesIn,\n        [AVG_NETWORK_BYTES_OUT]: avgNetworkBytesOut\n      } = metrics;\n\n      const { isStable: avgCpuIsStable } = getStabilityStats(avgCpuMetrics.Values);\n      \n      const {\n        max: maxCpu,\n        isStable: maxCpuIsStable\n      } = getStabilityStats(maxCpuMetrics.Values);\n\n      const lowCpuUtilization = (\n        (avgCpuIsStable && maxCpuIsStable) ||\n        maxCpu < 10 // Source: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html\n      );\n      \n      const allDiskReads = stats.sum(diskReadOps.Values);\n      const allDiskWrites = stats.sum(diskWriteOps.Values);\n      const totalDiskIops = allDiskReads + allDiskWrites;\n      \n      const { isStable: networkInIsStable, mean: networkInAvg } = getStabilityStats(avgNetworkBytesIn.Values);\n      const { isStable: networkOutIsStable, mean: networkOutAvg } = getStabilityStats(avgNetworkBytesOut.Values);\n      \n      const avgNetworkThroughputMb = (networkInAvg + networkOutAvg) / (Math.pow(1024, 2));\n\n      const lowNetworkUtilization = (\n        (networkInIsStable && networkOutIsStable) || \n        // v Source: https://www.trendmicro.com/cloudoneconformity/knowledge-base/aws/EC2/idle-instance.html\n        (avgNetworkThroughputMb < 5) \n      );\n\n      const cost = await getInstanceCost(pricingClient, instanceType.InstanceType);\n      ", "      if (\n        lowCpuUtilization &&\n        totalDiskIops === 0 &&\n        lowNetworkUtilization\n      ) {\n        this.addScenario(instanceArn, 'unused', {\n          value: 'true',\n          delete: {\n            action: 'terminateInstance',\n            isActionable: true,\n            reason: 'This EC2 instance appears to be unused based on its CPU utilization, disk IOPS, ' +\n                    'and network traffic.', \n            monthlySavings: cost\n          }\n        });\n      } else {\n        // TODO: For burstable instance types, we need to factor in credit consumption and baseline utilization\n        const networkInMax = stats.max(maxNetworkBytesIn.Values);\n        const networkOutMax = stats.max(maxNetworkBytesOut.Values);\n        const optimizedVcpuCount = Math.ceil(maxCpu * instanceType.VCpuInfo.DefaultVCpus);\n        const minimumNetworkThroughput = Math.ceil((networkInMax + networkOutMax) / (Math.pow(1024, 3)));\n        const currentNetworkThroughput = this.getInstanceNetworkSetting(instanceType.NetworkInfo.NetworkPerformance);\n        const currentNetworkThroughputIsDefined = typeof currentNetworkThroughput === 'number';\n\n        const instanceTypeNamesInFamily = allInstanceTypes.filter(it => it.startsWith(`${instanceFamily}.`));\n        const cachedInstanceTypes = await cache.getOrElse(\n          instanceFamily, async () => JSON.stringify(await this.getInstanceTypes(instanceTypeNamesInFamily, ec2Client))\n        );\n        const instanceTypesInFamily = JSON.parse(cachedInstanceTypes || '[]');\n\n        const smallerInstances = instanceTypesInFamily.filter((it: InstanceTypeInfo) => {\n          const availableNetworkThroughput = this.getInstanceNetworkSetting(it.NetworkInfo.NetworkPerformance);\n          const availableNetworkThroughputIsDefined = typeof availableNetworkThroughput === 'number';\n          return (\n            it.VCpuInfo.DefaultVCpus >= optimizedVcpuCount &&\n            it.VCpuInfo.DefaultVCpus <= instanceType.VCpuInfo.DefaultVCpus\n          ) &&\n          (\n            (currentNetworkThroughputIsDefined && availableNetworkThroughputIsDefined) ?\n              (\n                availableNetworkThroughput >= minimumNetworkThroughput &&\n                availableNetworkThroughput <= currentNetworkThroughput\n              ) :\n              // Best we can do for t2 burstable network defs is find one that's the same because they're not\n              // quantifiable\n              currentNetworkThroughput === availableNetworkThroughput\n          );\n        }).sort((a: InstanceTypeInfo, b: InstanceTypeInfo) => {\n          const aNetwork = this.getInstanceNetworkSetting(a.NetworkInfo.NetworkPerformance);\n          const aNetworkIsNumeric = typeof aNetwork === 'number';\n          const bNetwork = this.getInstanceNetworkSetting(b.NetworkInfo.NetworkPerformance);\n          const bNetworkIsNumeric = typeof bNetwork === 'number';\n          \n          const networkScore = (aNetworkIsNumeric && bNetworkIsNumeric) ?\n            (aNetwork < bNetwork ? -1 : 1) :\n            0;\n          const vCpuScore = a.VCpuInfo.DefaultVCpus < b.VCpuInfo.DefaultVCpus ? -1 : 1;\n          return networkScore + vCpuScore;\n        });\n\n        const targetInstanceType: InstanceTypeInfo | undefined = smallerInstances?.at(0);\n", "        if (targetInstanceType) {\n          const targetInstanceCost = await getInstanceCost(pricingClient, targetInstanceType.InstanceType);\n          const monthlySavings = cost - targetInstanceCost;\n          this.addScenario(instanceArn, 'overAllocated', {\n            value: 'overAllocated',\n            scaleDown: {\n              action: 'scaleDownInstance',\n              isActionable: false,\n              reason: 'This EC2 instance appears to be over allocated based on its CPU and network utilization.  We ' + \n                      `suggest scaling down to a ${targetInstanceType.InstanceType}`,\n              monthlySavings\n            }\n          });\n        }\n      }\n\n      await this.fillData(\n        instanceArn,\n        credentials,\n        region,\n        {\n          resourceId: instanceId,\n          region,\n          monthlyCost: cost,\n          hourlyCost: getHourlyCost(cost)\n        }\n      );\n\n      AwsEc2InstanceMetrics.forEach(async (metricName) => { \n        await this.getSidePanelMetrics(\n          credentials, \n          region, \n          instanceArn,\n          'AWS/EC2', \n          metricName, \n          [{ Name: 'InstanceId', Value: instanceId }]);\n      });\n    }\n  }\n\n  async getUtilization (\n    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsEc2InstanceUtilizationOverrides\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();\n    this.accountId = await getAccountId(credentials);", "    for (const region of regions) {\n      await this.getRegionalUtilization(credentials, region, overrides);\n    }\n    // this.getEstimatedMaxMonthlySavings();\n  }\n\n  async terminateInstance (awsCredentialsProvider: AwsCredentialsProvider, instanceId: string, region: string) {\n    const credentials = await awsCredentialsProvider.getCredentials();\n    const ec2Client = new EC2({\n      credentials,\n      region\n    });\n    \n    await ec2Client.terminateInstances({\n      InstanceIds: [instanceId]\n    });\n\n    // TODO: Remove scenario?\n  }\n\n  async scaleDownInstance (\n    awsCredentialsProvider: AwsCredentialsProvider, instanceId: string, region: string, instanceType: string\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();\n    const ec2Client = new EC2({\n      credentials,\n      region\n    });\n\n    await ec2Client.modifyInstanceAttribute({\n      InstanceId: instanceId,\n      InstanceType: {\n        Value: instanceType\n      }\n    });\n  }\n}"]}
{"filename": "src/service-utilizations/aws-nat-gateway-utilization.ts", "chunked_list": ["import { CloudWatch } from '@aws-sdk/client-cloudwatch';\nimport { DescribeNatGatewaysCommandOutput, EC2, NatGateway } from '@aws-sdk/client-ec2';\nimport { Pricing } from '@aws-sdk/client-pricing';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport get from 'lodash.get';\nimport { Arns } from '../types/constants.js';\nimport { AwsServiceOverrides } from '../types/types.js';\nimport { getAccountId, getHourlyCost, rateLimitMap } from '../utils/utils.js';\nimport { AwsServiceUtilization } from './aws-service-utilization.js';\n", "import { AwsServiceUtilization } from './aws-service-utilization.js';\n\n/**\n * const DEFAULT_RECOMMENDATION = 'review this NAT Gateway and the Route Tables associated with its VPC. If another' +\n * 'NAT Gateway exists in the VPC, repoint routes to that gateway and delete this gateway. If this is the only' +\n * 'NAT Gateway in your VPC and resources depend on network traffic, retain this gateway.';\n*/\n\ntype AwsNatGatewayUtilizationScenarioTypes = 'activeConnectionCount' | 'totalThroughput';\nconst AwsNatGatewayMetrics = ['ActiveConnectionCount', 'BytesInFromDestination'];\n", "type AwsNatGatewayUtilizationScenarioTypes = 'activeConnectionCount' | 'totalThroughput';\nconst AwsNatGatewayMetrics = ['ActiveConnectionCount', 'BytesInFromDestination'];\n\nexport class AwsNatGatewayUtilization extends AwsServiceUtilization<AwsNatGatewayUtilizationScenarioTypes> {\n  accountId: string;\n  cost: number;\n\n  constructor () {\n    super();\n  }\n\n  async doAction (\n    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n  ): Promise<void> {", "    if (actionName === 'deleteNatGateway') {\n      const ec2Client = new EC2({\n        credentials: await awsCredentialsProvider.getCredentials(),\n        region\n      });\n      const resourceId = resourceArn.split('/')[1];\n      await this.deleteNatGateway(ec2Client, resourceId);\n    }\n  }\n\n  async deleteNatGateway (ec2Client: EC2, natGatewayId: string) {\n    await ec2Client.deleteNatGateway({\n      NatGatewayId: natGatewayId\n    });\n  }\n\n  private async getAllNatGateways (credentials: any, region: string) {\n    const ec2Client = new EC2({\n      credentials,\n      region\n    });\n    let allNatGateways: NatGateway[] = [];\n    let describeNatGatewaysRes: DescribeNatGatewaysCommandOutput;\n    do {\n      describeNatGatewaysRes = await ec2Client.describeNatGateways({\n        NextToken: describeNatGatewaysRes?.NextToken\n      });\n      allNatGateways = [...allNatGateways, ...describeNatGatewaysRes?.NatGateways || []];", "    } while (describeNatGatewaysRes?.NextToken);\n\n    return allNatGateways;\n  }\n\n  private async getNatGatewayMetrics (credentials: any, region: string, natGatewayId: string) {\n    const cwClient = new CloudWatch({\n      credentials,\n      region\n    });\n    const fiveMinutesAgo = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000));\n    const metricDataRes = await cwClient.getMetricData({\n      MetricDataQueries: [\n        {\n          Id: 'activeConnectionCount',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/NATGateway',\n              MetricName: 'ActiveConnectionCount',\n              Dimensions: [{\n                Name: 'NatGatewayId',\n                Value: natGatewayId\n              }]\n            },\n            Period: 5 * 60, // 5 minutes\n            Stat: 'Maximum'\n          }\n        },\n        {\n          Id: 'bytesInFromDestination',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/NATGateway',\n              MetricName: 'BytesInFromDestination',\n              Dimensions: [{\n                Name: 'NatGatewayId',\n                Value: natGatewayId\n              }]\n            },\n            Period: 5 * 60, // 5 minutes\n            Stat: 'Sum'\n          }\n        },\n        {\n          Id: 'bytesInFromSource',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/NATGateway',\n              MetricName: 'BytesInFromSource',\n              Dimensions: [{\n                Name: 'NatGatewayId',\n                Value: natGatewayId\n              }]\n            },\n            Period: 5 * 60, // 5 minutes\n            Stat: 'Sum'\n          }\n        },\n        {\n          Id: 'bytesOutToDestination',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/NATGateway',\n              MetricName: 'BytesOutToDestination',\n              Dimensions: [{\n                Name: 'NatGatewayId',\n                Value: natGatewayId\n              }]\n            },\n            Period: 5 * 60, // 5 minutes\n            Stat: 'Sum'\n          }\n        },\n        {\n          Id: 'bytesOutToSource',\n          MetricStat: {\n            Metric: {\n              Namespace: 'AWS/NATGateway',\n              MetricName: 'BytesOutToSource',\n              Dimensions: [{\n                Name: 'NatGatewayId',\n                Value: natGatewayId\n              }]\n            },\n            Period: 5 * 60, // 5 minutes\n            Stat: 'Sum'\n          }\n        }\n      ],\n      StartTime: fiveMinutesAgo,\n      EndTime: new Date()\n    });\n\n    return metricDataRes.MetricDataResults;\n  }\n\n  private async getRegionalUtilization (credentials: any, region: string) {\n    const allNatGateways = await this.getAllNatGateways(credentials, region);\n\n    const analyzeNatGateway = async (natGateway: NatGateway) => {\n      const natGatewayId = natGateway.NatGatewayId;\n      const natGatewayArn = Arns.NatGateway(region, this.accountId, natGatewayId);\n  \n      const results = await this.getNatGatewayMetrics(credentials, region, natGatewayId);\n      const activeConnectionCount = get(results, '[0].Values[0]') as number;", "      if (activeConnectionCount === 0) {\n        this.addScenario(natGatewayArn, 'activeConnectionCount', {\n          value: activeConnectionCount.toString(),\n          delete: {\n            action: 'deleteNatGateway',\n            isActionable: true,\n            reason: 'This NAT Gateway has had 0 active connections over the past week. It appears to be unused.',\n            monthlySavings: this.cost\n          }\n        });\n      }\n      const totalThroughput = \n        get(results, '[1].Values[0]', 0) + \n        get(results, '[2].Values[0]', 0) + \n        get(results, '[3].Values[0]', 0) +\n        get(results, '[4].Values[0]', 0);", "      if (totalThroughput === 0) {\n        this.addScenario(natGatewayArn, 'totalThroughput', {\n          value: totalThroughput.toString(),\n          delete: {\n            action: 'deleteNatGateway',\n            isActionable: true,\n            reason: 'This NAT Gateway has had 0 total throughput over the past week. It appears to be unused.',\n            monthlySavings: this.cost\n          }\n        });\n      }\n\n      await this.fillData(\n        natGatewayArn,\n        credentials,\n        region,\n        {\n          resourceId: natGatewayId,\n          region,\n          monthlyCost: this.cost,\n          hourlyCost: getHourlyCost(this.cost)\n        }\n      );\n\n      AwsNatGatewayMetrics.forEach(async (metricName) => {  \n        await this.getSidePanelMetrics(\n          credentials, \n          region, \n          natGatewayArn,\n          'AWS/NATGateway', \n          metricName, \n          [{ Name: 'NatGatewayId', Value: natGatewayId }]);\n      });\n    };\n\n    await rateLimitMap(allNatGateways, 5, 5, analyzeNatGateway);\n  }\n\n  async getUtilization (\n    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], _overrides?: AwsServiceOverrides\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();\n    this.accountId = await getAccountId(credentials);\n    this.cost = await this.getNatGatewayPrice(credentials);  ", "    for (const region of regions) {\n      await this.getRegionalUtilization(credentials, region);\n    }\n  }\n\n  private async getNatGatewayPrice (credentials: any) {\n    const pricingClient = new Pricing({\n      credentials,\n      // global but have to specify region\n      region: 'us-east-1'\n    });\n\n    const res = await pricingClient.getProducts({\n      ServiceCode: 'AmazonEC2',\n      Filters: [\n        {\n          Type: 'TERM_MATCH',\n          Field: 'productFamily',\n          Value: 'NAT Gateway'\n        },\n        {\n          Type: 'TERM_MATCH',\n          Field: 'usageType',\n          Value: 'NatGateway-Hours'\n        }\n      ]\n    });\n    const onDemandData = JSON.parse(res.PriceList[0] as string).terms.OnDemand;\n    const onDemandKeys = Object.keys(onDemandData);\n    const priceDimensionsData = onDemandData[onDemandKeys[0]].priceDimensions;\n    const priceDimensionsKeys = Object.keys(priceDimensionsData);\n    const pricePerHour = priceDimensionsData[priceDimensionsKeys[0]].pricePerUnit.USD;\n\n    // monthly cost\n    return pricePerHour * 24 * 30;\n  }\n}"]}
{"filename": "src/service-utilizations/aws-service-utilization-factory.ts", "chunked_list": ["import { awsAccountUtilization } from './aws-account-utilization.js';\nimport { AwsCloudwatchLogsUtilization } from './aws-cloudwatch-logs-utilization.js';\nimport { AwsNatGatewayUtilization } from './aws-nat-gateway-utilization.js';\nimport { s3Utilization } from './aws-s3-utilization.js';\nimport { ebsVolumesUtilization } from './ebs-volumes-utilization.js';\nimport { rdsInstancesUtilization } from './rds-utilization.js';\nimport HttpError from 'http-errors';\nimport { AwsResourceType } from '../types/types.js';\nimport { AwsResourceTypes } from '../types/constants.js';\nimport { AwsEc2InstanceUtilization } from './aws-ec2-instance-utilization.js';", "import { AwsResourceTypes } from '../types/constants.js';\nimport { AwsEc2InstanceUtilization } from './aws-ec2-instance-utilization.js';\nimport { AwsEcsUtilization } from './aws-ecs-utilization.js';\nimport { AwsServiceUtilization } from './aws-service-utilization.js';\n\nexport class AwsServiceUtilizationFactory {\n  static createObject (awsService: AwsResourceType): AwsServiceUtilization<string> {\n    switch (awsService) {\n      case AwsResourceTypes.CloudwatchLogs:\n        return new AwsCloudwatchLogsUtilization();\n      case AwsResourceTypes.S3Bucket: \n        return new s3Utilization(); \n      case AwsResourceTypes.RdsInstance: \n        return new rdsInstancesUtilization();\n      case AwsResourceTypes.Account: \n        return new awsAccountUtilization(); \n      case AwsResourceTypes.NatGateway: \n        return new AwsNatGatewayUtilization(); \n      case AwsResourceTypes.EbsVolume: \n        return new ebsVolumesUtilization();\n      case AwsResourceTypes.Ec2Instance:\n        return new AwsEc2InstanceUtilization();\n      case AwsResourceTypes.EcsService:\n        return new AwsEcsUtilization();\n      default:\n        throw HttpError.BadRequest(`${awsService} is not supported!`);\n    }\n  }\n}"]}
{"filename": "src/service-utilizations/aws-ecs-utilization.ts", "chunked_list": ["import cached from 'cached';\nimport dayjs from 'dayjs';\nimport chunk from 'lodash.chunk';\nimport * as stats from 'simple-statistics';\nimport HttpError from 'http-errors';\nimport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\nimport {\n  ContainerInstance,\n  DesiredStatus,\n  ECS,", "  DesiredStatus,\n  ECS,\n  LaunchType,\n  ListClustersCommandOutput,\n  ListServicesCommandOutput,\n  ListTasksCommandOutput,\n  Service,\n  Task,\n  TaskDefinition,\n  TaskDefinitionField,", "  TaskDefinition,\n  TaskDefinitionField,\n  DescribeContainerInstancesCommandOutput\n} from '@aws-sdk/client-ecs';\nimport {\n  CloudWatch,\n  MetricDataQuery,\n  MetricDataResult\n} from '@aws-sdk/client-cloudwatch';\nimport { ElasticLoadBalancingV2 } from '@aws-sdk/client-elastic-load-balancing-v2';", "} from '@aws-sdk/client-cloudwatch';\nimport { ElasticLoadBalancingV2 } from '@aws-sdk/client-elastic-load-balancing-v2';\nimport {\n  Api,\n  ApiGatewayV2,\n  GetApisCommandOutput,\n  Integration\n} from '@aws-sdk/client-apigatewayv2';\nimport {\n  DescribeInstanceTypesCommandOutput,", "import {\n  DescribeInstanceTypesCommandOutput,\n  EC2,\n  InstanceTypeInfo,\n  _InstanceType\n} from '@aws-sdk/client-ec2';\nimport { getStabilityStats } from '../utils/stats.js';\nimport {\n  AVG_CPU,\n  MAX_CPU,", "  AVG_CPU,\n  MAX_CPU,\n  MAX_MEMORY,\n  AVG_MEMORY,\n  ALB_REQUEST_COUNT,\n  APIG_REQUEST_COUNT\n} from '../types/constants.js';\nimport { AwsServiceUtilization } from './aws-service-utilization.js';\nimport { AwsServiceOverrides } from '../types/types.js';\nimport { getInstanceCost } from '../utils/ec2-utils.js';", "import { AwsServiceOverrides } from '../types/types.js';\nimport { getInstanceCost } from '../utils/ec2-utils.js';\nimport { Pricing } from '@aws-sdk/client-pricing';\nimport { getHourlyCost } from '../utils/utils.js';\nimport get from 'lodash.get';\nimport isEmpty from 'lodash.isempty';\n\nconst cache = cached<string>('ecs-util-cache', {\n  backend: {\n    type: 'memory'", "  backend: {\n    type: 'memory'\n  }\n});\n\ntype AwsEcsUtilizationScenarioTypes = 'unused' | 'overAllocated';\nconst AwsEcsMetrics = ['CPUUtilization', 'MemoryUtilization'];\n\ntype EcsService = {\n  clusterArn: string;\n  serviceArn: string;\n}\n", "type EcsService = {\n  clusterArn: string;\n  serviceArn: string;\n}\n\ntype ClusterServices = {\n  [clusterArn: string]: {\n    serviceArns: string[];\n  }\n}\n", "type FargateScaleRange = {\n  min: number;\n  max: number;\n  increment: number;\n};\n\ntype FargateScaleOption = {\n  [cpu: number]: {\n    discrete?: number[];\n    range?: FargateScaleRange;\n  }\n}\n", "type FargateScale = {\n  cpu: number,\n  memory: number\n}\n\ntype AwsEcsUtilizationOverrides = AwsServiceOverrides & {\n  services: EcsService[];\n}\n\nexport class AwsEcsUtilization extends AwsServiceUtilization<AwsEcsUtilizationScenarioTypes> {\n  serviceArns: string[];\n  services: Service[];\n  ecsClient: ECS;\n  ec2Client: EC2;\n  cwClient: CloudWatch;\n  elbV2Client: ElasticLoadBalancingV2;\n  apigClient: ApiGatewayV2;\n  pricingClient: Pricing;\n  serviceCosts: { [ service: string ]: number };\n  DEBUG_MODE: boolean;\n\n  constructor (enableDebugMode?: boolean) {\n    super();\n    this.serviceArns = [];\n    this.services = [];\n    this.serviceCosts = {};\n    this.DEBUG_MODE = enableDebugMode || false;\n  }\n\n  async doAction (\n    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n  ): Promise<void> {", "export class AwsEcsUtilization extends AwsServiceUtilization<AwsEcsUtilizationScenarioTypes> {\n  serviceArns: string[];\n  services: Service[];\n  ecsClient: ECS;\n  ec2Client: EC2;\n  cwClient: CloudWatch;\n  elbV2Client: ElasticLoadBalancingV2;\n  apigClient: ApiGatewayV2;\n  pricingClient: Pricing;\n  serviceCosts: { [ service: string ]: number };\n  DEBUG_MODE: boolean;\n\n  constructor (enableDebugMode?: boolean) {\n    super();\n    this.serviceArns = [];\n    this.services = [];\n    this.serviceCosts = {};\n    this.DEBUG_MODE = enableDebugMode || false;\n  }\n\n  async doAction (\n    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n  ): Promise<void> {", "    if (actionName === 'deleteService') {\n      await this.deleteService(awsCredentialsProvider, resourceArn.split('/')[1], resourceArn, region);\n    }\n  }\n\n  private async listAllClusters (): Promise<string[]> {\n    const allClusterArns: string[] = [];\n    let nextToken;\n    do {\n      const response: ListClustersCommandOutput = await this.ecsClient.listClusters({\n        nextToken\n      });\n      const {\n        clusterArns = [],\n        nextToken: nextClusterToken\n      } = response || {};\n      allClusterArns.push(...clusterArns);\n      nextToken = nextClusterToken;", "    } while (nextToken);\n\n    return allClusterArns;\n  }\n  \n  private async listServicesForClusters (clusterArn: string): Promise<ClusterServices> {\n    const services: string[] = [];\n    let nextToken;\n    do {\n      const response: ListServicesCommandOutput = await this.ecsClient.listServices({\n        cluster: clusterArn,\n        nextToken\n      });\n      const {\n        serviceArns = [],\n        nextToken: nextServicesToken\n      } = response || {};\n      services.push(...serviceArns);\n      nextToken = nextServicesToken;", "    } while (nextToken);\n\n    return {\n      [clusterArn]: {\n        serviceArns: services\n      }\n    };\n  }\n\n  private async describeAllServices (): Promise<Service[]> {\n    const clusterArns = await this.listAllClusters();\n    const allServices: EcsService[] = [];\n", "    for (const clusterArn of clusterArns) {\n      const servicesForCluster = await this.listServicesForClusters(clusterArn);\n      allServices.push(...servicesForCluster[clusterArn].serviceArns.map(s => ({\n        clusterArn,\n        serviceArn: s\n      })));\n    }\n\n    return this.describeTheseServices(allServices);\n  }\n\n  private async describeTheseServices (ecsServices: EcsService[]): Promise<Service[]> {\n    const clusters = ecsServices.reduce<ClusterServices>((acc, ecsService) => {\n      acc[ecsService.clusterArn] = acc[ecsService.clusterArn] || {\n        serviceArns: []\n      };\n      acc[ecsService.clusterArn].serviceArns.push(ecsService.serviceArn);\n      return acc;\n    }, {});\n   \n    const services: Service[] = [];", "    for (const [clusterArn, clusterServices] of Object.entries(clusters)) {\n      const serviceChunks = chunk(clusterServices.serviceArns, 10);\n      for (const serviceChunk of serviceChunks) {\n        const response = await this.ecsClient.describeServices({\n          cluster: clusterArn,\n          services: serviceChunk\n        });\n        services.push(...(response?.services || []));\n      }\n    }\n\n    return services;\n  }\n\n  private async getLoadBalacerArnForService (service: Service): Promise<string> {\n    const response = await this.elbV2Client.describeTargetGroups({\n      TargetGroupArns: [service.loadBalancers?.at(0)?.targetGroupArn]\n    });\n    return response?.TargetGroups?.at(0)?.LoadBalancerArns?.at(0);\n  }\n\n  private async findIntegration (apiId: string, registryArn: string): Promise<Integration | undefined> {\n    let nextToken: string;\n    let registeredIntegration: Integration;\n    do {\n      const response = await this.apigClient.getIntegrations({\n        ApiId: apiId,\n        NextToken: nextToken\n      });\n      const {\n        Items = [],\n        NextToken\n      } = response || {};\n\n      registeredIntegration = Items.find(i => i.IntegrationUri === registryArn);", "      if (!registeredIntegration) {\n        nextToken = NextToken;\n      }\n    } while (nextToken);\n    \n    return registeredIntegration;\n  }\n\n  private async findRegisteredApi (service: Service, apis: Api[]): Promise<Api | undefined> {\n    const registryArn = service.serviceRegistries?.at(0)?.registryArn;\n    let registeredApi: Api;", "    for (const api of apis) {\n      const registeredIntegration = await this.findIntegration(api.ApiId, registryArn);\n      if (registeredIntegration) {\n        registeredApi = api;\n        break;\n      }\n    }\n    return registeredApi;\n  }\n  \n  private async getApiIdForService (service: Service): Promise<string> {\n    let nextToken: string;\n    let registeredApi: Api;\n    do {\n      const apiResponse: GetApisCommandOutput = await this.apigClient.getApis({ NextToken: nextToken });\n      const {\n        Items = [],\n        NextToken\n      } = apiResponse || {};\n\n      registeredApi = await this.findRegisteredApi(service, Items);", "      if (!registeredApi) {\n        nextToken = NextToken;\n      }    \n    } while (nextToken);\n\n    return registeredApi.ApiId;\n  }\n\n  private async getTask (service: Service): Promise<Task> {\n    const taskListResponse = await this.ecsClient.listTasks({\n      cluster: service.clusterArn,\n      serviceName: service.serviceName,\n      maxResults: 1,\n      desiredStatus: DesiredStatus.RUNNING\n    });\n\n    const {\n      taskArns = []\n    } = taskListResponse || {};\n\n    const describeTasksResponse = await this.ecsClient.describeTasks({\n      cluster: service.clusterArn,\n      tasks: [taskArns.at(0)]\n    });\n\n    const task = describeTasksResponse?.tasks?.at(0);\n    return task;\n  }\n  \n  private async getAllTasks (service: Service): Promise<Task[]> {\n    const taskIds = [];\n    let nextTaskToken;\n    do {\n      const taskListResponse: ListTasksCommandOutput = await this.ecsClient.listTasks({\n        cluster: service.clusterArn,\n        serviceName: service.serviceName,\n        desiredStatus: DesiredStatus.RUNNING,\n        nextToken: nextTaskToken\n      });\n  \n      const {\n        taskArns = [],\n        nextToken\n      } = taskListResponse || {};\n      taskIds.push(...taskArns);\n      nextTaskToken = nextToken;", "    } while (nextTaskToken);\n\n    const allTasks = [];\n    const taskIdPartitions = chunk(taskIds, 100);\n    for (const taskIdPartition of taskIdPartitions) {\n      const describeTasksResponse = await this.ecsClient.describeTasks({\n        cluster: service.clusterArn,\n        tasks: taskIdPartition\n      });\n      const {\n        tasks = []\n      } = describeTasksResponse;\n      allTasks.push(...tasks);\n    }\n\n    return allTasks;\n  }\n\n  private async getInstanceFamilyForContainerInstance (containerInstance: ContainerInstance): Promise<string> {\n    const ec2InstanceResponse = await this.ec2Client.describeInstances({\n      InstanceIds: [containerInstance.ec2InstanceId]\n    });\n    const instanceType = ec2InstanceResponse?.Reservations?.at(0)?.Instances?.at(0)?.InstanceType;\n    const instanceFamily = instanceType?.split('.')?.at(0);\n    return instanceFamily;\n  }\n\n  private async getInstanceTypes (instanceTypeNames: string[]): Promise<InstanceTypeInfo[]> {\n    const instanceTypes = [];\n    let nextToken;\n    do {\n      const instanceTypeResponse: DescribeInstanceTypesCommandOutput = await this.ec2Client.describeInstanceTypes({\n        InstanceTypes: instanceTypeNames,\n        NextToken: nextToken\n      });\n      const {\n        InstanceTypes = [],\n        NextToken\n      } = instanceTypeResponse;\n      instanceTypes.push(...InstanceTypes);\n      nextToken = NextToken;", "    } while (nextToken);\n    return instanceTypes;\n  }\n\n  private getEcsServiceDataQueries (serviceName: string, clusterName: string, period: number): MetricDataQuery[] {\n    function metricStat (metricName: string, statistic: string) {\n      return {\n        Metric: {\n          Namespace: 'AWS/ECS',\n          MetricName: metricName,\n          Dimensions: [\n            {\n              Name: 'ServiceName',\n              Value: serviceName\n            },\n            {\n              Name: 'ClusterName',\n              Value: clusterName\n            }\n          ]\n        },\n        Period: period,\n        Stat: statistic\n      };\n    }\n    return [\n      {\n        Id: AVG_CPU,\n        MetricStat: metricStat('CPUUtilization', 'Average')\n      },\n      {\n        Id: MAX_CPU,\n        MetricStat: metricStat('CPUUtilization', 'Maximum')\n      },\n      {\n        Id: AVG_MEMORY,\n        MetricStat: metricStat('MemoryUtilization', 'Average')\n      },\n      {\n        Id: MAX_MEMORY,\n        MetricStat: metricStat('MemoryUtilization', 'Maximum')\n      }\n    ];\n  }\n\n  private getAlbRequestCountQuery (loadBalancerArn: string, period: number): MetricDataQuery {\n    return {\n      Id: ALB_REQUEST_COUNT,\n      MetricStat: {\n        Metric: {\n          Namespace: 'AWS/ApplicationELB',\n          MetricName: 'RequestCount',\n          Dimensions: [\n            {\n              Name: 'ServiceName',\n              Value: loadBalancerArn\n            }\n          ]\n        },\n        Period: period,\n        Stat: 'Sum'\n      }\n    };\n  }\n  \n  private getApigRequestCountQuery (apiId: string, period: number): MetricDataQuery {\n    return {\n      Id: APIG_REQUEST_COUNT,\n      MetricStat: {\n        Metric: {\n          Namespace: 'AWS/ApiGateway',\n          MetricName: 'Count',\n          Dimensions: [\n            {\n              Name: 'ApiId',\n              Value: apiId\n            }\n          ]\n        },\n        Period: period,\n        Stat: 'Sum'\n      }\n    };\n  }\n\n  private async getMetrics (args: {\n    service: Service,\n    startTime: Date;\n    endTime: Date; \n    period: number;\n  }): Promise<{[ key: string ]: MetricDataResult}> {\n    const {\n      service,\n      startTime,\n      endTime,\n      period\n    } = args;\n\n    const {\n      serviceName,\n      clusterArn,\n      loadBalancers,\n      serviceRegistries\n    } = service;\n\n    const clusterName = clusterArn?.split('/').pop();\n    \n    const queries: MetricDataQuery[] = this.getEcsServiceDataQueries(serviceName, clusterName, period);", "    if (loadBalancers && loadBalancers.length > 0) {\n      const loadBalancerArn = await this.getLoadBalacerArnForService(service);\n      queries.push(this.getAlbRequestCountQuery(loadBalancerArn, period));\n    } else if (serviceRegistries && serviceRegistries.length > 0) {\n      const apiId = await this.getApiIdForService(service);\n      queries.push(this.getApigRequestCountQuery(apiId, period));\n    }\n    \n    const metrics: {[ key: string ]: MetricDataResult} = {};\n    let nextToken;\n    do {\n      const metricDataResponse = await this.cwClient.getMetricData({\n        MetricDataQueries: queries,\n        StartTime: startTime,\n        EndTime: endTime\n      });\n      const {\n        MetricDataResults,\n        NextToken\n      } = metricDataResponse || {};\n      MetricDataResults?.forEach((metricData: MetricDataResult) => {\n        const {\n          Id,\n          Timestamps = [],\n          Values = []\n        } = metricData;", "        if (!metrics[Id]) {\n          metrics[Id] = metricData;\n        } else {\n          metrics[Id].Timestamps.push(...Timestamps);\n          metrics[Id].Values.push(...Values);\n        }\n      });\n      nextToken = NextToken;\n    } while (nextToken);\n\n    return metrics;\n  }\n\n  private createDiscreteValuesForRange (range: FargateScaleRange): number[] {\n    const {\n      min,\n      max,\n      increment\n    } = range;\n    const discreteVales: number[] = [];\n    let i = min;\n    do {\n      i = i + increment;\n      discreteVales.push(i);", "    } while (nextToken);\n\n    return metrics;\n  }\n\n  private createDiscreteValuesForRange (range: FargateScaleRange): number[] {\n    const {\n      min,\n      max,\n      increment\n    } = range;\n    const discreteVales: number[] = [];\n    let i = min;\n    do {\n      i = i + increment;\n      discreteVales.push(i);", "    } while (i <= max);\n    return discreteVales;\n  }\n\n  private async getEc2ContainerInfo (service: Service) {\n    const tasks = await this.getAllTasks(service);\n    const taskCpu = Number(tasks.at(0)?.cpu);\n    const allocatedMemory = Number(tasks.at(0)?.memory);\n\n    let allocatedCpu = taskCpu;\n    let containerInstance: ContainerInstance;\n    let containerInstanceResponse: DescribeContainerInstancesCommandOutput;", "    if (!taskCpu || taskCpu === 0) {\n      const containerInstanceTaskGroupObject = tasks.reduce<{\n        [containerInstanceArn: string]: {\n          containerInstanceArn: string;\n          tasks: Task[];\n        }\n      }>((acc, task) => {\n        const { containerInstanceArn } = task;\n        acc[containerInstanceArn] = acc[containerInstanceArn] || {\n          containerInstanceArn,\n          tasks: []\n        };\n        acc[containerInstanceArn].tasks.push(task);\n        return acc;\n      }, {});\n      const containerInstanceTaskGroups  = Object.values(containerInstanceTaskGroupObject);\n      containerInstanceTaskGroups.sort((a, b) => {", "        if (a.tasks.length > b.tasks.length) {\n          return -1;\n        } else if (a.tasks.length < b.tasks.length) {\n          return 1;\n        }\n        return 0;\n      });\n      \n      const largestContainerInstance = containerInstanceTaskGroups.at(0);\n      const maxTaskCount = get(largestContainerInstance, 'tasks.length') || 0;\n\n      const filteredTaskGroups = containerInstanceTaskGroups\n        .filter(taskGroup => !isEmpty(taskGroup.containerInstanceArn));", "      if (isEmpty(filteredTaskGroups)) {\n        return undefined;\n      } else {\n        containerInstanceResponse = await this.ecsClient.describeContainerInstances({\n          cluster: service.clusterArn,\n          containerInstances: containerInstanceTaskGroups.map(taskGroup => taskGroup.containerInstanceArn)\n        });\n\n        // largest container instance\n        containerInstance = containerInstanceResponse?.containerInstances?.at(0);\n\n        const containerInstanceCpuResource = containerInstance.registeredResources?.find(r => r.name === 'CPU');\n        const containerInstanceCpu = Number(\n          containerInstanceCpuResource?.doubleValue || containerInstanceCpuResource?.integerValue\n          || containerInstanceCpuResource?.longValue\n        );\n\n        allocatedCpu = containerInstanceCpu / maxTaskCount;\n      }\n    } else {\n      containerInstanceResponse = await this.ecsClient.describeContainerInstances({\n        cluster: service.clusterArn,\n        containerInstances: tasks.map(task => task.containerInstanceArn)\n      });\n      containerInstance = containerInstanceResponse?.containerInstances?.at(0);\n    }\n\n    const uniqueEc2Instances = containerInstanceResponse.containerInstances.reduce<Set<string>>((acc, instance) => {\n      acc.add(instance.ec2InstanceId);\n      return acc;\n    }, new Set<string>());\n    const numEc2Instances = uniqueEc2Instances.size;\n    const instanceType = containerInstance.attributes.find(attr => attr.name === 'ecs.instance-type')?.value;\n    const monthlyInstanceCost = await getInstanceCost(this.pricingClient, instanceType);\n    const monthlyCost = monthlyInstanceCost * numEc2Instances;\n    this.serviceCosts[service.serviceName] = monthlyCost;\n\n    return {\n      allocatedCpu,\n      allocatedMemory,\n      containerInstance,\n      instanceType,\n      monthlyCost,\n      numEc2Instances\n    };\n  }\n\n  private async checkForEc2ScaleDown (service: Service, maxCpuPercentage: number, maxMemoryPercentage: number) {\n    const info = await this.getEc2ContainerInfo(service);", "    if (!info) {\n      return;\n    }\n\n    const {\n      allocatedCpu,\n      allocatedMemory,\n      containerInstance,\n      instanceType,\n      monthlyCost,\n      numEc2Instances\n    } = info;\n\n    const maxConsumedVcpus = (maxCpuPercentage * allocatedCpu) / 1024;\n    const maxConsumedMemory = maxMemoryPercentage * allocatedMemory;\n    const instanceVcpus = allocatedCpu / 1024;\n  \n    let instanceFamily = instanceType?.split('.')?.at(0);", "    if (!instanceFamily) {\n      instanceFamily = await this.getInstanceFamilyForContainerInstance(containerInstance);\n    }\n\n    const allInstanceTypes = Object.values(_InstanceType);\n    const instanceTypeNamesInFamily = allInstanceTypes.filter(it => it.startsWith(`${instanceFamily}.`));\n    const cachedInstanceTypes = await cache.getOrElse(\n      instanceFamily, async () => JSON.stringify(await this.getInstanceTypes(instanceTypeNamesInFamily))\n    );\n    const instanceTypesInFamily = JSON.parse(cachedInstanceTypes || '[]');\n\n    const smallerInstances = instanceTypesInFamily.filter((it: InstanceTypeInfo) => {\n      const betterFitCpu = (\n        it.VCpuInfo.DefaultVCpus >= maxConsumedVcpus &&\n        it.VCpuInfo.DefaultVCpus <= instanceVcpus\n      );\n      const betterFitMemory = (\n        it.MemoryInfo.SizeInMiB >= maxConsumedMemory &&\n        it.MemoryInfo.SizeInMiB <= allocatedMemory\n      );\n      return betterFitCpu && betterFitMemory;\n    }).sort((a: InstanceTypeInfo, b: InstanceTypeInfo) => {\n      const vCpuScore = a.VCpuInfo.DefaultVCpus < b.VCpuInfo.DefaultVCpus ? -1 : 1;\n      const memoryScore = a.MemoryInfo.SizeInMiB < b.MemoryInfo.SizeInMiB ? -1 : 1;\n      return memoryScore + vCpuScore;\n    });\n\n    const targetInstanceType: InstanceTypeInfo | undefined = smallerInstances?.at(0);\n", "    if (targetInstanceType) {\n      const targetMonthlyInstanceCost = await getInstanceCost(this.pricingClient, targetInstanceType.InstanceType);\n      const targetMonthlyCost = targetMonthlyInstanceCost * numEc2Instances;\n\n      this.addScenario(service.serviceArn, 'overAllocated', {\n        value: 'true',\n        scaleDown: {\n          action: 'scaleDownEc2Service',\n          isActionable: false,\n          reason: 'The EC2 instances used in this Service\\'s cluster appears to be over allocated based on its CPU' + \n                  `and Memory utilization.  We suggest scaling down to a ${targetInstanceType.InstanceType}.`,\n          monthlySavings: monthlyCost - targetMonthlyCost\n        }\n      });\n    }\n  }\n\n  private calculateFargateCost (platform: string, cpuArch: string, vcpu: number, memory: number, numTasks: number) {\n    let monthlyCost = 0;", "    if (platform.toLowerCase() === 'windows') {\n      monthlyCost = (((0.09148 + 0.046) * vcpu) + (0.01005 * memory)) * numTasks * 24 * 30;\n    } else {\n      if (cpuArch === 'x86_64') {\n        monthlyCost = ((0.04048 * vcpu) + (0.004445 * memory)) * numTasks * 24 * 30; \n      } else {\n        monthlyCost = ((0.03238 * vcpu) + (0.00356 * memory)) * numTasks * 24 * 30;\n      }\n    }\n\n    return monthlyCost;\n  }\n\n  private async getFargateInfo (service: Service) {\n    const tasks = await this.getAllTasks(service);\n    const numTasks = tasks.length;\n    const task = tasks.at(0);\n    const allocatedCpu = Number(task?.cpu);\n    const allocatedMemory = Number(task?.memory);\n\n    const platform = task.platformFamily || '';\n    const cpuArch = (task.attributes.find(attr => attr.name === 'ecs.cpu-architecture'))?.value || 'x86_64';\n    const vcpu = allocatedCpu / 1024;\n    const memory = allocatedMemory / 1024;\n\n    const monthlyCost = this.calculateFargateCost(platform, cpuArch, vcpu, memory, numTasks);\n    this.serviceCosts[service.serviceName] = monthlyCost;\n\n    return {\n      allocatedCpu,\n      allocatedMemory,\n      platform,\n      cpuArch,\n      numTasks,\n      monthlyCost\n    }; \n  }\n\n  private async checkForFargateScaleDown (service: Service, maxCpuPercentage: number, maxMemoryPercentage: number) {\n    // Source:  https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-cpu-memory-error.html\n    const fargateScaleOptions: FargateScaleOption = {\n      256: {\n        discrete: [0.5, 1, 2]\n      },\n      512: {\n        range: {\n          min: 1,\n          max: 4,\n          increment: 1\n        }\n      },\n      1024: {\n        range: {\n          min: 2,\n          max: 8,\n          increment: 1\n        }\n      },\n      2048: {\n        range: {\n          min: 4,\n          max: 16,\n          increment: 1\n        }\n      },\n      4096: {\n        range: {\n          min: 8,\n          max: 30,\n          increment: 1\n        }\n      },\n      8192: {\n        range: {\n          min: 16,\n          max: 60,\n          increment: 4\n        }\n      },\n      16384: {\n        range: {\n          min: 32,\n          max: 120,\n          increment: 4\n        }\n      }\n    };\n\n    const {\n      allocatedCpu,\n      allocatedMemory,\n      platform,\n      cpuArch,\n      numTasks,\n      monthlyCost\n    } = await this.getFargateInfo(service);\n\n    const maxConsumedCpu = maxCpuPercentage * allocatedCpu;\n    const maxConsumedMemory = maxMemoryPercentage * allocatedMemory;\n\n    const lowerCpuOptions = Object.keys(fargateScaleOptions).filter((cpuString) => {\n      const cpu = Number(cpuString);\n      return cpu < allocatedCpu && cpu > maxConsumedCpu; \n    }).sort();\n    let targetScaleOption: FargateScale;", "    for (const cpuOption of lowerCpuOptions) {\n      const scalingOption = fargateScaleOptions[Number(cpuOption)];\n\n      const memoryOptionValues = [];\n      \n      const discreteMemoryOptionValues = scalingOption.discrete || [];\n      memoryOptionValues.push(...discreteMemoryOptionValues);\n      \n      const rangeMemoryOptionsValues = scalingOption.range ?\n        this.createDiscreteValuesForRange(scalingOption.range) : [];\n      memoryOptionValues.push(...rangeMemoryOptionsValues);\n\n      const optimizedMemory = memoryOptionValues.filter(mem => (mem > maxConsumedMemory)).sort().at(0);", "      if (optimizedMemory) {\n        targetScaleOption = {\n          cpu: Number(cpuOption),\n          memory: (optimizedMemory * 1024)\n        };\n        break;\n      }\n    }\n    \n    if (targetScaleOption) {\n      const targetMonthlyCost = this.calculateFargateCost(\n        platform, \n        cpuArch, \n        targetScaleOption.cpu / 1024,\n        targetScaleOption.memory / 1024,\n        numTasks\n      );\n\n      this.addScenario(service.serviceArn, 'overAllocated', {\n        value: 'overAllocated',\n        scaleDown: {\n          action: 'scaleDownFargateService',\n          isActionable: false,\n          reason: 'This ECS service appears to be over allocated based on its CPU, Memory, and network utilization. ' +\n                  `We suggest scaling the CPU down to ${targetScaleOption.cpu} and the Memory to ` +\n                  `${targetScaleOption.memory} MiB.`,\n          monthlySavings: monthlyCost - targetMonthlyCost\n        }\n      });\n    }\n  }\n\n  async getRegionalUtilization (credentials: any, region: string, overrides?: AwsEcsUtilizationOverrides) {\n    this.ecsClient = new ECS({\n      credentials,\n      region\n    });\n    this.ec2Client = new EC2({\n      credentials,\n      region\n    });\n    this.cwClient = new CloudWatch({\n      credentials,\n      region\n    });\n    this.elbV2Client = new ElasticLoadBalancingV2({\n      credentials,\n      region\n    });\n    this.apigClient = new ApiGatewayV2({\n      credentials,\n      region\n    });\n    this.pricingClient = new Pricing({\n      credentials,\n      region\n    });\n", "    if (targetScaleOption) {\n      const targetMonthlyCost = this.calculateFargateCost(\n        platform, \n        cpuArch, \n        targetScaleOption.cpu / 1024,\n        targetScaleOption.memory / 1024,\n        numTasks\n      );\n\n      this.addScenario(service.serviceArn, 'overAllocated', {\n        value: 'overAllocated',\n        scaleDown: {\n          action: 'scaleDownFargateService',\n          isActionable: false,\n          reason: 'This ECS service appears to be over allocated based on its CPU, Memory, and network utilization. ' +\n                  `We suggest scaling the CPU down to ${targetScaleOption.cpu} and the Memory to ` +\n                  `${targetScaleOption.memory} MiB.`,\n          monthlySavings: monthlyCost - targetMonthlyCost\n        }\n      });\n    }\n  }\n\n  async getRegionalUtilization (credentials: any, region: string, overrides?: AwsEcsUtilizationOverrides) {\n    this.ecsClient = new ECS({\n      credentials,\n      region\n    });\n    this.ec2Client = new EC2({\n      credentials,\n      region\n    });\n    this.cwClient = new CloudWatch({\n      credentials,\n      region\n    });\n    this.elbV2Client = new ElasticLoadBalancingV2({\n      credentials,\n      region\n    });\n    this.apigClient = new ApiGatewayV2({\n      credentials,\n      region\n    });\n    this.pricingClient = new Pricing({\n      credentials,\n      region\n    });\n", "    if (overrides?.services) {\n      this.services = await this.describeTheseServices(overrides?.services);\n    } else {\n      this.services = await this.describeAllServices();\n    }\n    \n    if (this.services.length === 0) return;\n\n    for (const service of this.services) {\n      const now = dayjs();\n      const startTime = now.subtract(2, 'weeks');\n      const fiveMinutes = 5 * 60;\n      const metrics = await this.getMetrics({\n        service,\n        startTime: startTime.toDate(),\n        endTime: now.toDate(),\n        period: fiveMinutes\n      });\n\n      const {\n        [AVG_CPU]: avgCpuMetrics,\n        [MAX_CPU]: maxCpuMetrics,\n        [AVG_MEMORY]: avgMemoryMetrics,\n        [MAX_MEMORY]: maxMemoryMetrics,\n        [ALB_REQUEST_COUNT]: albRequestCountMetrics,\n        [APIG_REQUEST_COUNT]: apigRequestCountMetrics\n      } = metrics;\n\n      const { isStable: avgCpuIsStable } = getStabilityStats(avgCpuMetrics.Values);\n      \n      const {\n        max: maxCpu,\n        isStable: maxCpuIsStable\n      } = getStabilityStats(maxCpuMetrics.Values);\n\n      const lowCpuUtilization = (\n        (avgCpuIsStable && maxCpuIsStable) ||\n        maxCpu < 10 // Source: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html\n      );\n      \n      const { isStable: avgMemoryIsStable } = getStabilityStats(avgMemoryMetrics.Values);\n      \n      const {\n        max: maxMemory,\n        isStable: maxMemoryIsStable\n      } = getStabilityStats(maxMemoryMetrics.Values);\n\n      const lowMemoryUtilization = (\n        (avgMemoryIsStable && maxMemoryIsStable) ||\n        maxMemory < 10\n      );\n      \n      const requestCountMetricValues = [\n        ...(albRequestCountMetrics?.Values || []), ...(apigRequestCountMetrics?.Values || [])\n      ];\n      const totalRequestCount = stats.sum(requestCountMetricValues);\n\n      const noNetworkUtilization = totalRequestCount === 0;\n      ", "    for (const service of this.services) {\n      const now = dayjs();\n      const startTime = now.subtract(2, 'weeks');\n      const fiveMinutes = 5 * 60;\n      const metrics = await this.getMetrics({\n        service,\n        startTime: startTime.toDate(),\n        endTime: now.toDate(),\n        period: fiveMinutes\n      });\n\n      const {\n        [AVG_CPU]: avgCpuMetrics,\n        [MAX_CPU]: maxCpuMetrics,\n        [AVG_MEMORY]: avgMemoryMetrics,\n        [MAX_MEMORY]: maxMemoryMetrics,\n        [ALB_REQUEST_COUNT]: albRequestCountMetrics,\n        [APIG_REQUEST_COUNT]: apigRequestCountMetrics\n      } = metrics;\n\n      const { isStable: avgCpuIsStable } = getStabilityStats(avgCpuMetrics.Values);\n      \n      const {\n        max: maxCpu,\n        isStable: maxCpuIsStable\n      } = getStabilityStats(maxCpuMetrics.Values);\n\n      const lowCpuUtilization = (\n        (avgCpuIsStable && maxCpuIsStable) ||\n        maxCpu < 10 // Source: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html\n      );\n      \n      const { isStable: avgMemoryIsStable } = getStabilityStats(avgMemoryMetrics.Values);\n      \n      const {\n        max: maxMemory,\n        isStable: maxMemoryIsStable\n      } = getStabilityStats(maxMemoryMetrics.Values);\n\n      const lowMemoryUtilization = (\n        (avgMemoryIsStable && maxMemoryIsStable) ||\n        maxMemory < 10\n      );\n      \n      const requestCountMetricValues = [\n        ...(albRequestCountMetrics?.Values || []), ...(apigRequestCountMetrics?.Values || [])\n      ];\n      const totalRequestCount = stats.sum(requestCountMetricValues);\n\n      const noNetworkUtilization = totalRequestCount === 0;\n      ", "      if (\n        lowCpuUtilization &&\n        lowMemoryUtilization &&\n        noNetworkUtilization\n      ) {\n        const info = service.launchType === LaunchType.FARGATE ? \n          await this.getFargateInfo(service) : \n          await this.getEc2ContainerInfo(service);\n        if (!info) {\n          return;\n        }\n\n        const { monthlyCost } = info;\n        this.addScenario(service.serviceArn, 'unused', {\n          value: 'true',\n          delete: {\n            action: 'deleteService',\n            isActionable: true,\n            reason: 'This ECS service appears to be unused based on its CPU utilizaiton, Memory utilizaiton, and'\n                  + ' network traffic.',\n            monthlySavings: monthlyCost\n          }\n        });", "        if (!info) {\n          return;\n        }\n\n        const { monthlyCost } = info;\n        this.addScenario(service.serviceArn, 'unused', {\n          value: 'true',\n          delete: {\n            action: 'deleteService',\n            isActionable: true,\n            reason: 'This ECS service appears to be unused based on its CPU utilizaiton, Memory utilizaiton, and'\n                  + ' network traffic.',\n            monthlySavings: monthlyCost\n          }\n        });", "      } else if (maxCpu < 0.8 && maxMemory < 0.8) {\n        if (service.launchType === LaunchType.FARGATE) {\n          await this.checkForFargateScaleDown(service, maxCpu, maxMemory);\n        } else {\n          await this.checkForEc2ScaleDown(service, maxCpu, maxMemory);\n        }\n      }\n\n      const monthlyCost = this.serviceCosts[service.serviceName] || 0;\n      await this.fillData(\n        service.serviceArn,\n        credentials,\n        region,\n        {\n          resourceId: service.serviceName,\n          region,\n          monthlyCost,\n          hourlyCost: getHourlyCost(monthlyCost)\n        }\n      );\n\n      AwsEcsMetrics.forEach(async (metricName) => { \n        await this.getSidePanelMetrics(\n          credentials, \n          region, \n          service.serviceArn,  \n          'AWS/ECS', \n          metricName, \n          [{\n            Name: 'ServiceName',\n            Value: service.serviceName\n          },\n          {\n            Name: 'ClusterName',\n            Value: service.clusterArn?.split('/').pop()\n          }]);\n      });\n    }\n\n    console.info('this.utilization:\\n', JSON.stringify(this.utilization, null, 2));\n  }\n  \n  async getUtilization (\n    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsEcsUtilizationOverrides\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();", "    for (const region of regions) {\n      await this.getRegionalUtilization(credentials, region, overrides);\n    }\n\n  }\n\n  async deleteService (\n    awsCredentialsProvider: AwsCredentialsProvider, clusterName: string, serviceArn: string, region: string\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();\n    const ecsClient = new ECS({\n      credentials,\n      region\n    });\n\n    await ecsClient.deleteService({\n      service: serviceArn,\n      cluster: clusterName\n    });\n  }\n\n  async scaleDownFargateService (\n    awsCredentialsProvider: AwsCredentialsProvider, clusterName: string, serviceArn: string, region: string,\n    cpu: number, memory: number\n  ) {\n    const credentials = await awsCredentialsProvider.getCredentials();\n    const ecsClient = new ECS({\n      credentials,\n      region\n    });\n\n    const serviceResponse = await ecsClient.describeServices({\n      cluster: clusterName,\n      services: [serviceArn]\n    });\n    const taskDefinitionArn = serviceResponse?.services?.at(0)?.taskDefinition;\n    const taskDefResponse = await ecsClient.describeTaskDefinition(\n      { taskDefinition: taskDefinitionArn, include: [TaskDefinitionField.TAGS]  }\n    );\n    const taskDefinition: TaskDefinition = taskDefResponse?.taskDefinition;\n    const tags = taskDefResponse?.tags;    \n\n    const {\n      containerDefinitions,\n      family,\n      ephemeralStorage,\n      executionRoleArn,\n      inferenceAccelerators,\n      ipcMode,\n      networkMode,\n      pidMode,\n      placementConstraints,\n      proxyConfiguration,\n      requiresCompatibilities,\n      runtimePlatform,\n      taskRoleArn,\n      volumes\n    } = taskDefinition;\n\n\n    // TODO: CPU and Memory validation?\n    const revisionResponse = await ecsClient.registerTaskDefinition({\n      cpu: cpu.toString(),\n      memory: memory.toString(),\n      containerDefinitions,\n      family,\n      ephemeralStorage,\n      executionRoleArn,\n      inferenceAccelerators,\n      ipcMode,\n      networkMode,\n      pidMode,\n      placementConstraints,\n      proxyConfiguration,\n      requiresCompatibilities,\n      runtimePlatform,\n      taskRoleArn,\n      volumes,\n      tags\n    });\n \n    await ecsClient.updateService({\n      cluster: clusterName,\n      service: serviceArn,\n      taskDefinition: revisionResponse?.taskDefinition?.taskDefinitionArn,\n      forceNewDeployment: true\n    });\n  }\n  \n  async scaleDownEc2Service (_serviceArn: string, _cpu: number, _memory: number) {\n    /*\n      TODO:\n        Update Asg/Capacity provider? Or update memory/cpu allocation on the tasks? Or both?\n     */\n    throw HttpError.NotImplemented('Automatic scale down for EC2 backed ECS Clusters is not yet supported.');\n  }\n}"]}
