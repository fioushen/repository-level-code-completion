{"filename": "build.config.ts", "chunked_list": ["import { defineBuildConfig } from 'unbuild';\n\nexport default defineBuildConfig({\n  entries: ['src/index', 'src/cli'],\n  declaration: true,\n  clean: true,\n  rollup: {\n    emitCJS: true,\n    inlineDependencies: true\n  }", "    inlineDependencies: true\n  }\n});\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { getCurrentGitBranch, getFirstGitCommit, getLastGitTag, isPrerelease } from './git';\nimport { resolveRepoConfig } from './repo';\nimport type { ChangelogOptions, ResolvedChangelogOptions } from './types';\n\nconst defaultConfig: ChangelogOptions = {\n  cwd: process.cwd(),\n  from: '',\n  to: '',\n  gitMainBranch: 'main',\n  scopeMap: {},", "  gitMainBranch: 'main',\n  scopeMap: {},\n  repo: {},\n  types: {\n    feat: { title: '\ud83d\ude80 Features' },\n    fix: { title: '\ud83d\udc1e Bug Fixes' },\n    perf: { title: '\ud83d\udd25 Performance' },\n    refactor: { title: '\ud83d\udc85 Refactors' },\n    docs: { title: '\ud83d\udcd6 Documentation' },\n    build: { title: '\ud83d\udce6 Build' },", "    docs: { title: '\ud83d\udcd6 Documentation' },\n    build: { title: '\ud83d\udce6 Build' },\n    types: { title: '\ud83c\udf0a Types' },\n    chore: { title: '\ud83c\udfe1 Chore' },\n    examples: { title: '\ud83c\udfc0 Examples' },\n    test: { title: '\u2705 Tests' },\n    style: { title: '\ud83c\udfa8 Styles' },\n    ci: { title: '\ud83e\udd16 CI' }\n  },\n  titles: {", "  },\n  titles: {\n    breakingChanges: '\ud83d\udea8 Breaking Changes'\n  },\n  tokens: {\n    github: process.env.CHANGELOGEN_TOKENS_GITHUB || process.env.GITHUB_TOKEN || process.env.GH_TOKEN\n  },\n  output: 'CHANGELOG.md',\n  contributors: true,\n  capitalize: true,", "  contributors: true,\n  capitalize: true,\n  group: true\n};\n\nexport async function resolveConfig(cwd: string, options: ChangelogOptions) {\n  const { loadConfig } = await import('c12');\n  const config = await loadConfig<ChangelogOptions>({\n    name: 'githublogen',\n    defaults: defaultConfig,\n    overrides: options\n  }).then(r => r.config || defaultConfig);\n\n  config.from = config.from || (await getLastGitTag());\n  config.to = config.to || (await getCurrentGitBranch());\n  config.repo = await resolveRepoConfig(cwd);\n  config.prerelease = config.prerelease ?? isPrerelease(config.to);\n", "  if (config.to === config.from) {\n    config.from = (await getLastGitTag(-1)) || (await getFirstGitCommit());\n  }\n\n  return config as ResolvedChangelogOptions;\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type SemverBumpType = 'major' | 'premajor' | 'minor' | 'preminor' | 'patch' | 'prepatch' | 'prerelease';\n\nexport type RepoProvider = 'github' | 'gitlab' | 'bitbucket';\n\nexport type RepoConfig = {\n  domain?: string;\n  repo?: string;\n  provider?: RepoProvider;\n  token?: string;\n};\n", "export interface ChangelogConfig {\n  cwd: string;\n  types: Record<string, { title: string; semver?: SemverBumpType }>;\n  scopeMap: Record<string, string>;\n  repo: RepoConfig;\n  tokens: Partial<Record<RepoProvider, string>>;\n  from: string;\n  to: string;\n  newVersion?: string;\n  output: string | boolean;\n  gitMainBranch: string;\n}\n", "export interface GitCommitAuthor {\n  name: string;\n  email: string;\n}\n\nexport interface RawGitCommit {\n  message: string;\n  body: string;\n  shortHash: string;\n  author: GitCommitAuthor;\n}\n", "export interface Reference {\n  type: 'hash' | 'issue' | 'pull-request';\n  value: string;\n}\n\nexport interface GithubOptions {\n  repo: string;\n  token: string;\n}\n\nexport interface GithubRelease {\n  id?: string;\n  tag_name: string;\n  name?: string;\n  body?: string;\n  draft?: boolean;\n  prerelease?: boolean;\n}\n", "export interface GithubRelease {\n  id?: string;\n  tag_name: string;\n  name?: string;\n  body?: string;\n  draft?: boolean;\n  prerelease?: boolean;\n}\n\nexport interface GitCommit extends RawGitCommit {\n  description: string;\n  type: string;\n  scope: string;\n  references: Reference[];\n  authors: GitCommitAuthor[];\n  isBreaking: boolean;\n}\n", "export interface GitCommit extends RawGitCommit {\n  description: string;\n  type: string;\n  scope: string;\n  references: Reference[];\n  authors: GitCommitAuthor[];\n  isBreaking: boolean;\n}\n\nexport interface AuthorInfo {\n  commits: string[];\n  login?: string;\n  email: string;\n  name: string;\n}\n", "export interface AuthorInfo {\n  commits: string[];\n  login?: string;\n  email: string;\n  name: string;\n}\n\nexport interface Commit extends GitCommit {\n  resolvedAuthors?: AuthorInfo[];\n}\n", "export interface ChangelogOptions extends ChangelogConfig {\n  /**\n   * Dry run. Skip releasing to GitHub.\n   */\n  dry?: boolean;\n  /**\n   * Whether to include contributors in release notes.\n   *\n   * @default true\n   */\n  contributors?: boolean;\n  /**\n   * Name of the release\n   */\n  name?: string;\n  /**\n   * Mark the release as a draft\n   */\n  draft?: boolean;\n  /**\n   * Mark the release as prerelease\n   */\n  prerelease?: boolean;\n  /**\n   * Custom titles\n   */\n  titles?: {\n    breakingChanges?: string;\n  };\n  /**\n   * Capitalize commit messages\n   * @default true\n   */\n  capitalize?: boolean;\n  /**\n   * Nest commit messages under their scopes\n   * @default true\n   */\n  group?: boolean | 'multiple';\n  /**\n   * Use emojis in section titles\n   * @default true\n   */\n  emoji?: boolean;\n}\n", "export type ResolvedChangelogOptions = Required<ChangelogOptions>;\n"]}
{"filename": "src/git.ts", "chunked_list": ["import type { RawGitCommit, RepoConfig } from './types';\n\nexport async function getGitHubRepo() {\n  const url = await execCommand('git', ['config', '--get', 'remote.origin.url']);\n  const match = url.match(/github\\.com[\\/:]([\\w\\d._-]+?)\\/([\\w\\d._-]+?)(\\.git)?$/i);\n  if (!match) {\n    throw new Error(`Can not parse GitHub repo from url ${url}`);\n  }\n  return `${match[1]}/${match[2]}`;\n}\n", "export async function getGitMainBranchName() {\n  const main = await execCommand('git', ['rev-parse', '--abbrev-ref', 'HEAD']);\n\n  return main;\n}\n\nexport async function getCurrentGitBranch() {\n  const result1 = await execCommand('git', ['tag', '--points-at', 'HEAD']);\n  const main = getGitMainBranchName();\n\n  return result1 || main;\n}\n", "export async function isRepoShallow() {\n  return (await execCommand('git', ['rev-parse', '--is-shallow-repository'])).trim() === 'true';\n}\n\nexport async function getLastGitTag(delta = 0) {\n  const tags = await execCommand('git', ['--no-pager', 'tag', '-l', '--sort=creatordate']).then(r => r.split('\\n'));\n  return tags[tags.length + delta - 1];\n}\n\nexport async function isRefGitTag(to: string) {\n  const { execa } = await import('execa');", "export async function isRefGitTag(to: string) {\n  const { execa } = await import('execa');\n  try {\n    await execa('git', ['show-ref', '--verify', `refs/tags/${to}`], { reject: true });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function getFirstGitCommit() {\n  return execCommand('git', ['rev-list', '--max-parents=0', 'HEAD']);\n}\n", "export function getFirstGitCommit() {\n  return execCommand('git', ['rev-list', '--max-parents=0', 'HEAD']);\n}\n\nexport function isPrerelease(version: string) {\n  return !/^[^.]*[\\d.]+$/.test(version);\n}\n\nasync function execCommand(cmd: string, args: string[]) {\n  const { execa } = await import('execa');\n  const res = await execa(cmd, args);\n  return res.stdout.trim();\n}\n", "async function execCommand(cmd: string, args: string[]) {\n  const { execa } = await import('execa');\n  const res = await execa(cmd, args);\n  return res.stdout.trim();\n}\n\nexport async function getGitDiff(from: string | undefined, to = 'HEAD'): Promise<RawGitCommit[]> {\n  // https://git-scm.com/docs/pretty-formats\n  const r = await execCommand('git', [\n    '--no-pager',\n    'log',\n    `${from ? `${from}...` : ''}${to}`,\n    '--pretty=\"----%n%s|%h|%an|%ae%n%b\"',\n    '--name-status'\n  ]);\n  return r\n    .split('----\\n')\n    .splice(1)\n    .map(line => {\n      const [firstLine, ..._body] = line.split('\\n');\n      const [message, shortHash, authorName, authorEmail] = firstLine.split('|');\n      const $r: RawGitCommit = {\n        message,\n        shortHash,\n        author: { name: authorName, email: authorEmail },\n        body: _body.join('\\n')\n      };\n      return $r;\n    });\n}\n", "export function getGitRemoteURL(cwd: string, remote = 'origin') {\n  return execCommand('git', [`--work-tree=${cwd}`, 'remote', 'get-url', remote]);\n}\n\nexport function getGitPushUrl(config: RepoConfig, token?: string) {\n  if (!token) return null;\n\n  return `https://${token}@${config.domain}/${config.repo}`;\n}\n"]}
{"filename": "src/repo.ts", "chunked_list": ["import { readPackageJSON } from 'pkg-types';\nimport type { Reference, ChangelogConfig, RepoProvider, RepoConfig } from './types';\nimport { getGitRemoteURL } from './git';\n\nconst providerToRefSpec: Record<RepoProvider, Record<Reference['type'], string>> = {\n  github: { 'pull-request': 'pull', hash: 'commit', issue: 'issues' },\n  gitlab: { 'pull-request': 'merge_requests', hash: 'commit', issue: 'issues' },\n  bitbucket: {\n    'pull-request': 'pull-requests',\n    hash: 'commit',", "    'pull-request': 'pull-requests',\n    hash: 'commit',\n    issue: 'issues'\n  }\n};\n\nconst providerToDomain: Record<RepoProvider, string> = {\n  github: 'github.com',\n  gitlab: 'gitlab.com',\n  bitbucket: 'bitbucket.org'", "  gitlab: 'gitlab.com',\n  bitbucket: 'bitbucket.org'\n};\n\nconst domainToProvider: Record<string, RepoProvider> = {\n  'github.com': 'github',\n  'gitlab.com': 'gitlab',\n  'bitbucket.org': 'bitbucket'\n};\n", "};\n\n// https://regex101.com/r/NA4Io6/1\nconst providerURLRegex = /^(?:(?<user>\\w+)@)?(?:(?<provider>[^/:]+):)?(?<repo>\\w+\\/\\w+)(?:\\.git)?$/;\n\nfunction baseUrl(config: RepoConfig) {\n  return `https://${config.domain}/${config.repo}`;\n}\n\nexport function formatReference(ref: Reference, repo?: RepoConfig) {\n  if (!repo?.provider || !(repo.provider in providerToRefSpec)) {\n    return ref.value;\n  }\n  const refSpec = providerToRefSpec[repo.provider];\n  return `[${ref.value}](${baseUrl(repo)}/${refSpec[ref.type]}/${ref.value.replace(/^#/, '')})`;\n}\n", "export function formatReference(ref: Reference, repo?: RepoConfig) {\n  if (!repo?.provider || !(repo.provider in providerToRefSpec)) {\n    return ref.value;\n  }\n  const refSpec = providerToRefSpec[repo.provider];\n  return `[${ref.value}](${baseUrl(repo)}/${refSpec[ref.type]}/${ref.value.replace(/^#/, '')})`;\n}\n\nexport function formatCompareChanges(v: string, config: ChangelogConfig) {\n  const part = config.repo?.provider === 'bitbucket' ? 'branches/compare' : 'compare';\n  return `[compare changes](${baseUrl(config.repo)}/${part}/${config.from}...${v || config.to})`;\n}\n", "export function formatCompareChanges(v: string, config: ChangelogConfig) {\n  const part = config.repo?.provider === 'bitbucket' ? 'branches/compare' : 'compare';\n  return `[compare changes](${baseUrl(config.repo)}/${part}/${config.from}...${v || config.to})`;\n}\n\nexport async function resolveRepoConfig(cwd: string) {\n  // Try closest package.json\n  const pkg = await readPackageJSON(cwd).catch(() => {});\n  if (pkg && pkg.repository) {\n    const url = typeof pkg.repository === 'string' ? pkg.repository : pkg.repository.url;\n    return getRepoConfig(url);\n  }\n", "  if (pkg && pkg.repository) {\n    const url = typeof pkg.repository === 'string' ? pkg.repository : pkg.repository.url;\n    return getRepoConfig(url);\n  }\n\n  const gitRemote = await getGitRemoteURL(cwd).catch(() => {});\n  if (gitRemote) {\n    return getRepoConfig(gitRemote);\n  }\n\n  return {};\n}\n", "export function getRepoConfig(repoUrl = ''): RepoConfig {\n  let provider: RepoProvider | undefined;\n  let repo: string | undefined;\n  let domain: string | undefined;\n\n  let url: URL | undefined;\n  try {\n    url = new URL(repoUrl);\n  } catch {}\n\n  const m = repoUrl.match(providerURLRegex)?.groups ?? {};", "  if (m.repo && m.provider) {\n    repo = m.repo;\n    provider = m.provider in domainToProvider ? domainToProvider[m.provider] : (m.provider as RepoProvider);\n    domain = provider in providerToDomain ? providerToDomain[provider] : provider;\n  } else if (url) {\n    domain = url.hostname;\n    repo = url.pathname\n      .split('/')\n      .slice(1, 3)\n      .join('/')\n      .replace(/\\.git$/, '');\n    provider = domainToProvider[domain];", "  } else if (m.repo) {\n    repo = m.repo;\n    provider = 'github';\n    domain = providerToDomain[provider];\n  }\n\n  return {\n    provider,\n    repo,\n    domain\n  };\n}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["type PartitionFilter<T> = (i: T, idx: number, arr: readonly T[]) => any;\n\n/**\n * Divide an array into two parts by a filter function\n * @category Array\n * @example const [odd, even] = partition([1, 2, 3, 4], i => i % 2 != 0)\n */\nexport function partition<T>(array: readonly T[], f1: PartitionFilter<T>): [T[], T[]];\nexport function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>): [T[], T[], T[]];\nexport function partition<T>(\n  array: readonly T[],\n  f1: PartitionFilter<T>,\n  f2: PartitionFilter<T>,\n  f3: PartitionFilter<T>\n): [T[], T[], T[], T[]];", "export function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>): [T[], T[], T[]];\nexport function partition<T>(\n  array: readonly T[],\n  f1: PartitionFilter<T>,\n  f2: PartitionFilter<T>,\n  f3: PartitionFilter<T>\n): [T[], T[], T[], T[]];\nexport function partition<T>(\n  array: readonly T[],\n  f1: PartitionFilter<T>,\n  f2: PartitionFilter<T>,\n  f3: PartitionFilter<T>,\n  f4: PartitionFilter<T>\n): [T[], T[], T[], T[], T[]];", "export function partition<T>(\n  array: readonly T[],\n  f1: PartitionFilter<T>,\n  f2: PartitionFilter<T>,\n  f3: PartitionFilter<T>,\n  f4: PartitionFilter<T>,\n  f5: PartitionFilter<T>\n): [T[], T[], T[], T[], T[], T[]];\nexport function partition<T>(\n  array: readonly T[],\n  f1: PartitionFilter<T>,\n  f2: PartitionFilter<T>,\n  f3: PartitionFilter<T>,\n  f4: PartitionFilter<T>,\n  f5: PartitionFilter<T>,\n  f6: PartitionFilter<T>\n): [T[], T[], T[], T[], T[], T[], T[]];", "export function partition<T>(\n  array: readonly T[],\n  f1: PartitionFilter<T>,\n  f2: PartitionFilter<T>,\n  f3: PartitionFilter<T>,\n  f4: PartitionFilter<T>,\n  f5: PartitionFilter<T>,\n  f6: PartitionFilter<T>\n): [T[], T[], T[], T[], T[], T[], T[]];\nexport function partition<T>(array: readonly T[], ...filters: PartitionFilter<T>[]): any {\n  const result: T[][] = new Array(filters.length + 1).fill(null).map(() => []);\n\n  array.forEach((e, idx, arr) => {\n    let i = 0;", "export function partition<T>(array: readonly T[], ...filters: PartitionFilter<T>[]): any {\n  const result: T[][] = new Array(filters.length + 1).fill(null).map(() => []);\n\n  array.forEach((e, idx, arr) => {\n    let i = 0;\n    for (const filter of filters) {\n      if (filter(e, idx, arr)) {\n        result[i].push(e);\n        return;\n      }\n      i += 1;\n    }\n    result[i].push(e);\n  });\n  return result;\n}\n", "export function notNullish<T>(v?: T | null): v is NonNullable<T> {\n  return v !== null && v !== undefined;\n}\n\nexport function groupBy<T>(items: T[], key: string, groups: Record<string, T[]> = {}) {\n  for (const item of items) {\n    const v = (item as any)[key] as string;\n    groups[v] = groups[v] || [];\n    groups[v].push(item);\n  }\n  return groups;\n}\n", "export function capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function join(array?: string[], glue = ', ', finalGlue = ' and '): string {\n  if (!array || array.length === 0) return '';\n\n  if (array.length === 1) return array[0];\n\n  if (array.length === 2) return array.join(finalGlue);\n\n  return `${array.slice(0, -1).join(glue)}${finalGlue}${array.slice(-1)}`;\n}\n", "  if (array.length === 2) return array.join(finalGlue);\n\n  return `${array.slice(0, -1).join(glue)}${finalGlue}${array.slice(-1)}`;\n}\n\nexport function upperFirst(string?: string) {\n  return !string ? '' : string[0].toUpperCase() + string.slice(1);\n}\n"]}
{"filename": "src/cli.ts", "chunked_list": ["#!/usr/bin/env node\nimport { blue, bold, cyan, dim, red, yellow } from 'kolorist';\nimport cac from 'cac';\nimport { version } from '../package.json';\nimport { generate } from './generate';\nimport { hasTagOnGitHub, sendRelease } from './github';\nimport { isRepoShallow } from './git';\nimport type { ChangelogOptions } from './types';\n\nconst cli = cac('githublogen');", "\nconst cli = cac('githublogen');\n\ncli\n  .version(version)\n  .option('-t, --token <path>', 'GitHub Token')\n  .option('--from <ref>', 'From tag')\n  .option('--to <ref>', 'To tag')\n  .option('--github <path>', 'GitHub Repository, e.g. soybeanjs/githublogen')\n  .option('--name <name>', 'Name of the release')", "  .option('--github <path>', 'GitHub Repository, e.g. soybeanjs/githublogen')\n  .option('--name <name>', 'Name of the release')\n  .option('--contributors', 'Show contributors section')\n  .option('--prerelease', 'Mark release as prerelease')\n  .option('-d, --draft', 'Mark release as draft')\n  .option('--output <path>', 'Output to file instead of sending to GitHub')\n  .option('--capitalize', 'Should capitalize for each comment message')\n  .option('--emoji', 'Use emojis in section titles', { default: true })\n  .option('--group', 'Nest commit messages under their scopes')\n  .option('--dry', 'Dry run')", "  .option('--group', 'Nest commit messages under their scopes')\n  .option('--dry', 'Dry run')\n  .help();\n\ncli.command('').action(async (args: any) => {\n  try {\n    console.log();\n    console.log(dim(`${bold('github')}logen `) + dim(`v${version}`));\n\n    const cwd = process.cwd();\n\n    const { config, md, commits } = await generate(cwd, args as unknown as ChangelogOptions);\n\n    const markdown = md.replace(/&nbsp;/g, '');\n\n    console.log(cyan(config.from) + dim(' -> ') + blue(config.to) + dim(` (${commits.length} commits)`));\n    console.log(dim('--------------'));\n    console.log();\n    console.log(markdown);\n    console.log();\n    console.log(dim('--------------'));\n", "    if (config.dry) {\n      console.log(yellow('Dry run. Release skipped.'));\n      return;\n    }\n\n    if (!(await hasTagOnGitHub(config.to, config))) {\n      console.error(yellow(`Current ref \"${bold(config.to)}\" is not available as tags on GitHub. Release skipped.`));\n      process.exitCode = 1;\n      return;\n    }\n", "    if (!commits.length && (await isRepoShallow())) {\n      console.error(\n        yellow(\n          'The repo seems to be clone shallowly, which make changelog failed to generate. You might want to specify `fetch-depth: 0` in your CI config.'\n        )\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    await sendRelease(config, md);", "  } catch (e: any) {\n    console.error(red(String(e)));\n    if (e?.stack) {\n      console.error(dim(e.stack?.split('\\n').slice(1).join('\\n')));\n    }\n\n    process.exit(1);\n  }\n});\n\ncli.parse();\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './types';\nexport * from './github';\nexport * from './git';\nexport * from './markdown';\nexport * from './generate';\nexport * from './config';\nexport * from './parse';\n"]}
{"filename": "src/generate.ts", "chunked_list": ["import { getGitDiff } from './git';\nimport { generateMarkdown } from './markdown';\nimport { resolveAuthors } from './github';\nimport { resolveConfig } from './config';\nimport { parseCommits } from './parse';\nimport type { ChangelogOptions } from './types';\n\nexport async function generate(cwd: string, options: ChangelogOptions) {\n  const resolved = await resolveConfig(cwd, options);\n\n  const rawCommits = await getGitDiff(resolved.from, resolved.to);\n  const commits = parseCommits(rawCommits, resolved);\n", "  if (resolved.contributors) {\n    await resolveAuthors(commits, resolved);\n  }\n\n  const md = generateMarkdown(commits, resolved);\n\n  return { config: resolved, md, commits };\n}\n"]}
{"filename": "src/github.ts", "chunked_list": ["import { $fetch } from 'ohmyfetch';\nimport { cyan, green, red, yellow } from 'kolorist';\nimport { notNullish } from './shared';\nimport type { AuthorInfo, ChangelogOptions, Commit } from './types';\n\nexport async function sendRelease(options: ChangelogOptions, content: string) {\n  const headers = getHeaders(options);\n\n  const github = options.repo.repo!;\n\n  let url = `https://api.github.com/repos/${github}/releases`;\n  let method = 'POST';\n", "  try {\n    const exists = await $fetch(`https://api.github.com/repos/${github}/releases/tags/${options.to}`, {\n      headers\n    });\n    if (exists.url) {\n      url = exists.url;\n      method = 'PATCH';\n    }\n  } catch (e) {}\n\n  const body = {\n    body: content,\n    draft: options.draft || false,\n    name: options.name || options.to,\n    prerelease: options.prerelease,\n    tag_name: options.to\n  };\n\n  const webUrl = `https://github.com/${github}/releases/new?title=${encodeURIComponent(\n    String(body.name)\n  )}&body=${encodeURIComponent(String(body.body))}&tag=${encodeURIComponent(String(options.to))}&prerelease=${\n    options.prerelease\n  }`;\n", "  } catch (e) {}\n\n  const body = {\n    body: content,\n    draft: options.draft || false,\n    name: options.name || options.to,\n    prerelease: options.prerelease,\n    tag_name: options.to\n  };\n\n  const webUrl = `https://github.com/${github}/releases/new?title=${encodeURIComponent(\n    String(body.name)\n  )}&body=${encodeURIComponent(String(body.body))}&tag=${encodeURIComponent(String(options.to))}&prerelease=${\n    options.prerelease\n  }`;\n", "  try {\n    console.log(cyan(method === 'POST' ? 'Creating release notes...' : 'Updating release notes...'));\n    const res = await $fetch(url, {\n      method,\n      body: JSON.stringify(body),\n      headers\n    });\n    console.log(green(`Released on ${res.html_url}`));\n  } catch (e) {\n    console.log();\n    console.error(red('Failed to create the release. Using the following link to create it manually:'));\n    console.error(yellow(webUrl));\n    console.log();\n\n    throw e;\n  }\n}\n", "  } catch (e) {\n    console.log();\n    console.error(red('Failed to create the release. Using the following link to create it manually:'));\n    console.error(yellow(webUrl));\n    console.log();\n\n    throw e;\n  }\n}\n\nfunction getHeaders(options: ChangelogOptions) {\n  return {\n    accept: 'application/vnd.github.v3+json',\n    authorization: `token ${options.tokens.github}`\n  };\n}\n", "function getHeaders(options: ChangelogOptions) {\n  return {\n    accept: 'application/vnd.github.v3+json',\n    authorization: `token ${options.tokens.github}`\n  };\n}\n\nexport async function resolveAuthorInfo(options: ChangelogOptions, info: AuthorInfo) {\n  if (info.login) return info;\n\n  // token not provided, skip github resolving", "  if (info.login) return info;\n\n  // token not provided, skip github resolving\n  if (!options.tokens.github) return info;\n\n  try {\n    const data = await $fetch(`https://api.github.com/search/users?q=${encodeURIComponent(info.email)}`, {\n      headers: getHeaders(options)\n    });\n    info.login = data.items[0].login;\n  } catch {}\n", "  if (info.login) return info;\n\n  if (info.commits.length) {\n    try {\n      const data = await $fetch(`https://api.github.com/repos/${options.repo.repo}/commits/${info.commits[0]}`, {\n        headers: getHeaders(options)\n      });\n      info.login = data.author.login;\n    } catch (e) {}\n  }\n\n  return info;\n}\n", "    } catch (e) {}\n  }\n\n  return info;\n}\n\nexport async function resolveAuthors(commits: Commit[], options: ChangelogOptions) {\n  const map = new Map<string, AuthorInfo>();\n  commits.forEach(commit => {\n    commit.resolvedAuthors = commit.authors\n      .map((a, idx) => {", "        if (!a.email || !a.name) {\n          return null;\n        }\n\n        if (!map.has(a.email)) {\n          map.set(a.email, {\n            commits: [],\n            name: a.name,\n            email: a.email\n          });\n        }\n        const info = map.get(a.email)!;\n\n        // record commits only for the first author", "        if (idx === 0) {\n          info.commits.push(commit.shortHash);\n        }\n\n        return info;\n      })\n      .filter(notNullish);\n  });\n  const authors = Array.from(map.values());\n  const resolved = await Promise.all(authors.map(info => resolveAuthorInfo(options, info)));\n\n  const loginSet = new Set<string>();\n  const nameSet = new Set<string>();\n  return resolved\n    .sort((a, b) => (a.login || a.name).localeCompare(b.login || b.name))\n    .filter(i => {", "      if (i.login && loginSet.has(i.login)) {\n        return false;\n      }\n      if (i.login) {\n        loginSet.add(i.login);\n      } else {\n        if (nameSet.has(i.name)) {\n          return false;\n        }\n        nameSet.add(i.name);\n      }\n      return true;\n    });\n}\n", "export async function hasTagOnGitHub(tag: string, options: ChangelogOptions) {\n  try {\n    await $fetch(`https://api.github.com/repos/${options.repo.repo}/git/ref/tags/${tag}`, {\n      headers: getHeaders(options)\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n"]}
{"filename": "src/markdown.ts", "chunked_list": ["import { convert } from 'convert-gitmoji';\nimport { partition, groupBy, capitalize, join } from './shared';\nimport type { Reference, Commit, ResolvedChangelogOptions } from './types';\n\nconst emojisRE =\n  /([\\u2700-\\u27BF]|[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])/g;\n\nfunction formatReferences(references: Reference[], github: string, type: 'issues' | 'hash'): string {\n  const refs = references\n    .filter(i => {\n      if (type === 'issues') {\n        return i.type === 'issue' || i.type === 'pull-request';\n      }\n      return i.type === 'hash';\n    })\n    .map(ref => {", "      if (type === 'issues') {\n        return i.type === 'issue' || i.type === 'pull-request';\n      }\n      return i.type === 'hash';\n    })\n    .map(ref => {\n      if (!github) {\n        return ref.value;\n      }\n      if (ref.type === 'pull-request' || ref.type === 'issue') {\n        return `https://github.com/${github}/issues/${ref.value.slice(1)}`;\n      }\n      return `[<samp>(${ref.value.slice(0, 5)})</samp>](https://github.com/${github}/commit/${ref.value})`;\n    });\n\n  const referencesString = join(refs).trim();\n", "      if (ref.type === 'pull-request' || ref.type === 'issue') {\n        return `https://github.com/${github}/issues/${ref.value.slice(1)}`;\n      }\n      return `[<samp>(${ref.value.slice(0, 5)})</samp>](https://github.com/${github}/commit/${ref.value})`;\n    });\n\n  const referencesString = join(refs).trim();\n\n  if (type === 'issues') {\n    return referencesString && `in ${referencesString}`;\n  }\n  return referencesString;\n}\n", "  if (type === 'issues') {\n    return referencesString && `in ${referencesString}`;\n  }\n  return referencesString;\n}\n\nfunction formatLine(commit: Commit, options: ResolvedChangelogOptions) {\n  const prRefs = formatReferences(commit.references, options.repo.repo || '', 'issues');\n  const hashRefs = formatReferences(commit.references, options.repo.repo || '', 'hash');\n\n  let authors = join([\n    ...new Set(commit.resolvedAuthors?.map(i => (i.login ? `@${i.login}` : `**${i.name}**`)))\n  ])?.trim();", "  if (authors) {\n    authors = `by ${authors}`;\n  }\n\n  let refs = [authors, prRefs, hashRefs].filter(i => i?.trim()).join(' ');\n\n  if (refs) {\n    refs = `&nbsp;-&nbsp; ${refs}`;\n  }\n\n  const description = options.capitalize ? capitalize(commit.description) : commit.description;\n\n  return [description, refs].filter(i => i?.trim()).join(' ');\n}\n", "function formatTitle(name: string, options: ResolvedChangelogOptions) {\n  let $name = name.trim();\n\n  if (!options.emoji) {\n    $name = name.replace(emojisRE, '').trim();\n  }\n\n  return `### &nbsp;&nbsp;&nbsp;${$name}`;\n}\n\nfunction formatSection(commits: Commit[], sectionName: string, options: ResolvedChangelogOptions) {", "function formatSection(commits: Commit[], sectionName: string, options: ResolvedChangelogOptions) {\n  if (!commits.length) {\n    return [];\n  }\n\n  const lines: string[] = ['', formatTitle(sectionName, options), ''];\n\n  const scopes = groupBy(commits, 'scope');\n  let useScopeGroup = options.group;\n\n  // group scopes only when one of the scope have multiple commits", "  if (!Object.entries(scopes).some(([k, v]) => k && v.length > 1)) {\n    useScopeGroup = false;\n  }\n\n  Object.keys(scopes)\n    .sort()\n    .forEach(scope => {\n      let padding = '';\n      let prefix = '';\n      const scopeText = `**${options.scopeMap[scope] || scope}**`;\n      if (scope && (useScopeGroup === true || (useScopeGroup === 'multiple' && scopes[scope].length > 1))) {\n        lines.push(`- ${scopeText}:`);\n        padding = '  ';", "      if (scope && (useScopeGroup === true || (useScopeGroup === 'multiple' && scopes[scope].length > 1))) {\n        lines.push(`- ${scopeText}:`);\n        padding = '  ';\n      } else if (scope) {\n        prefix = `${scopeText}: `;\n      }\n\n      lines.push(...scopes[scope].reverse().map(commit => `${padding}- ${prefix}${formatLine(commit, options)}`));\n    });\n\n  return lines;\n}\n", "export function generateMarkdown(commits: Commit[], options: ResolvedChangelogOptions) {\n  const lines: string[] = [];\n\n  const [breaking, changes] = partition(commits, c => c.isBreaking);\n\n  const group = groupBy(changes, 'type');\n\n  lines.push(...formatSection(breaking, options.titles.breakingChanges!, options));\n\n  for (const type of Object.keys(options.types)) {\n    const items = group[type] || [];\n    lines.push(...formatSection(items, options.types[type].title, options));\n  }\n", "  for (const type of Object.keys(options.types)) {\n    const items = group[type] || [];\n    lines.push(...formatSection(items, options.types[type].title, options));\n  }\n\n  if (!lines.length) {\n    lines.push('*No significant changes*');\n  }\n\n  const url = `https://github.com/${options.repo.repo!}/compare/${options.from}...${options.to}`;\n\n  lines.push('', `##### &nbsp;&nbsp;&nbsp;&nbsp;[View changes on GitHub](${url})`);\n\n  return convert(lines.join('\\n').trim(), true);\n}\n"]}
{"filename": "src/parse.ts", "chunked_list": ["import { notNullish } from './shared';\nimport type { GitCommit, RawGitCommit, GitCommitAuthor, ChangelogConfig, Reference } from './types';\n\n// https://www.conventionalcommits.org/en/v1.0.0/\n// https://regex101.com/r/FSfNvA/1\nconst ConventionalCommitRegex = /(?<type>[a-z]+)(\\((?<scope>.+)\\))?(?<breaking>!)?: (?<description>.+)/i;\nconst CoAuthoredByRegex = /co-authored-by:\\s*(?<name>.+)(<(?<email>.+)>)/gim;\nconst PullRequestRE = /\\([a-z]*(#\\d+)\\s*\\)/gm;\nconst IssueRE = /(#\\d+)/gm;\n\nexport function parseGitCommit(commit: RawGitCommit, config: ChangelogConfig): GitCommit | null {\n  const match = commit.message.match(ConventionalCommitRegex);", "const IssueRE = /(#\\d+)/gm;\n\nexport function parseGitCommit(commit: RawGitCommit, config: ChangelogConfig): GitCommit | null {\n  const match = commit.message.match(ConventionalCommitRegex);\n  if (!match?.groups) {\n    return null;\n  }\n\n  const type = match.groups.type;\n\n  let scope = match.groups.scope || '';\n  scope = config.scopeMap[scope] || scope;\n\n  const isBreaking = Boolean(match.groups.breaking);\n  let description = match.groups.description;\n\n  // Extract references from message\n  const references: Reference[] = [];", "  for (const m of description.matchAll(PullRequestRE)) {\n    references.push({ type: 'pull-request', value: m[1] });\n  }\n  for (const m of description.matchAll(IssueRE)) {\n    if (!references.some(i => i.value === m[1])) {\n      references.push({ type: 'issue', value: m[1] });\n    }\n  }\n  references.push({ value: commit.shortHash, type: 'hash' });\n\n  // Remove references and normalize\n  description = description.replace(PullRequestRE, '').trim();\n\n  // Find all authors\n  const authors: GitCommitAuthor[] = [commit.author];\n\n  const matchs = commit.body.matchAll(CoAuthoredByRegex);\n", "  for (const $match of matchs) {\n    const { name = '', email = '' } = $match.groups || {};\n\n    const author: GitCommitAuthor = {\n      name: name.trim(),\n      email: email.trim()\n    };\n\n    authors.push(author);\n  }\n\n  return {\n    ...commit,\n    authors,\n    description,\n    type,\n    scope,\n    references,\n    isBreaking\n  };\n}\n", "export function parseCommits(commits: RawGitCommit[], config: ChangelogConfig): GitCommit[] {\n  return commits.map(commit => parseGitCommit(commit, config)).filter(notNullish);\n}\n"]}
