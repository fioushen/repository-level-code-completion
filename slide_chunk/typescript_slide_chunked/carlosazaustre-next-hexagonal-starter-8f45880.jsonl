{"filename": "jest.config.ts", "chunked_list": ["import nextJest from 'next/jest';\nimport { pathsToModuleNameMapper } from 'ts-jest';\nimport { compilerOptions } from './tsconfig.json';\n\nconst createJestConfig = nextJest({\n\tdir: './',\n});\n\nconst customJestConfig = {\n\tsetupFilesAfterEnv: ['<rootDir>/jest.setup.js'],", "const customJestConfig = {\n\tsetupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n\tmodulePaths: ['<rootDir>/src', '<rootDir>/tests'],\n\tmoduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths),\n\ttestEnvironment: 'jest-environment-jsdom'\n};\n\nmodule.exports = createJestConfig(customJestConfig);\n", ""]}
{"filename": "cypress.config.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { defineConfig } from \"cypress\";\n\nexport default defineConfig({\n\tvideo: false,\n  e2e: {\n    setupNodeEvents(on, config) {\n      // implement node event listeners here\n    },\n  },", "    },\n  },\n});\n"]}
{"filename": "cypress/support/e2e.ts", "chunked_list": ["// ***********************************************************\n// This example support/e2e.ts is processed and\n// loaded automatically before your test files.\n//\n// This is a great place to put global configuration and\n// behavior that modifies Cypress.\n//\n// You can change the location of this file or turn off\n// automatically serving support files with the\n// 'supportFile' configuration option.", "// automatically serving support files with the\n// 'supportFile' configuration option.\n//\n// You can read more here:\n// https://on.cypress.io/configuration\n// ***********************************************************\n\n// Import commands.js using ES2015 syntax:\nimport './commands'\n", "import './commands'\n\n// Alternatively you can use CommonJS syntax:\n// require('./commands')"]}
{"filename": "cypress/support/commands.ts", "chunked_list": ["/// <reference types=\"cypress\" />\n// ***********************************************\n// This example commands.ts shows you how to\n// create various custom commands and overwrite\n// existing commands.\n//\n// For more comprehensive examples of custom\n// commands please read more here:\n// https://on.cypress.io/custom-commands\n// ***********************************************", "// https://on.cypress.io/custom-commands\n// ***********************************************\n//\n//\n// -- This is a parent command --\n// Cypress.Commands.add('login', (email, password) => { ... })\n//\n//\n// -- This is a child command --\n// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })", "// -- This is a child command --\n// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })\n//\n//\n// -- This is a dual command --\n// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) => { ... })\n//\n//\n// -- This will overwrite an existing command --\n// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })", "// -- This will overwrite an existing command --\n// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })\n//\n// declare global {\n//   namespace Cypress {\n//     interface Chainable {\n//       login(email: string, password: string): Chainable<void>\n//       drag(subject: string, options?: Partial<TypeOptions>): Chainable<Element>\n//       dismiss(subject: string, options?: Partial<TypeOptions>): Chainable<Element>\n//       visit(originalFn: CommandOriginalFn, url: string, options: Partial<VisitOptions>): Chainable<Element>\n//     }\n//   }\n// }"]}
{"filename": "__tests__/modules/posts/application/get/getPostById.spec.ts", "chunked_list": ["import { getPostById } from '@/src/modules/posts/application/get/getPostById';\nimport { createApiPostRepository } from '@/src/modules/posts/infra/ApiPostRepository';\nimport { createApiUserRepository } from '@/src/modules/users/infra/ApiUserRepository';\nimport { createApiCommentRepository } from '@/src/modules/comments/infra/ApiCommentRepository';\nimport { posts, users, comments } from '@/tests/fixtures/mockData.json';\n\nconst postRepository = createApiPostRepository();\nconst userRepository = createApiUserRepository();\nconst commentRepository = createApiCommentRepository();\n", "const commentRepository = createApiCommentRepository();\n\ndescribe('[useCase] getPostById', () => {\n\tafterEach(() => {\n\t\tjest.restoreAllMocks();\n\t});\n\n\ttest('should throw an error if post not found', async () => {\n\t\tjest\n\t\t\t.spyOn(postRepository, 'get')", "\t\tjest\n\t\t\t.spyOn(postRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(undefined));\n\t\tjest\n\t\t\t.spyOn(userRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(undefined));\n\t\tjest\n\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t.mockImplementation(() => Promise.resolve([]));\n", "\t\t\t.mockImplementation(() => Promise.resolve([]));\n\n\t\tconst postId = 999;\n\t\tconst getPost = getPostById(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t);\n\n\t\tawait expect(getPost(postId)).rejects.toThrow(", "\n\t\tawait expect(getPost(postId)).rejects.toThrow(\n\t\t\t`Post with id ${postId} not found`,\n\t\t);\n\t});\n\n\ttest('should return a post with author and comment count when post and author exist', async () => {\n\t\tjest\n\t\t\t.spyOn(postRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(posts[0]));", "\t\t\t.spyOn(postRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(posts[0]));\n\t\tjest\n\t\t\t.spyOn(userRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(users[0]));\n\t\tjest\n\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t.mockImplementation(() =>\n\t\t\t\tPromise.resolve(\n\t\t\t\t\tcomments.filter(comment => comment.postId === posts[0].id),", "\t\t\t\tPromise.resolve(\n\t\t\t\t\tcomments.filter(comment => comment.postId === posts[0].id),\n\t\t\t\t),\n\t\t\t);\n\n\t\tconst postId = 1;\n\t\tconst getPost = getPostById(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,", "\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t);\n\t\tconst result = await getPost(postId);\n\n\t\texpect(result).toEqual({\n\t\t\t...posts[0],\n\t\t\tauthor: {\n\t\t\t\tid: users[0].id,\n\t\t\t\tname: users[0].name,", "\t\t\t\tid: users[0].id,\n\t\t\t\tname: users[0].name,\n\t\t\t},\n\t\t\tcommentCount: comments.filter(comment => comment.postId === postId)\n\t\t\t\t.length,\n\t\t});\n\t});\n\n\ttest('should return a post with undefined author and comment count when post exists but author does not', async () => {\n\t\tjest", "\ttest('should return a post with undefined author and comment count when post exists but author does not', async () => {\n\t\tjest\n\t\t\t.spyOn(postRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(posts[0]));\n\t\tjest\n\t\t\t.spyOn(userRepository, 'get')\n\t\t\t.mockImplementation(() => Promise.resolve(undefined));\n\t\tjest\n\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t.mockImplementation(() =>", "\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t.mockImplementation(() =>\n\t\t\t\tPromise.resolve(\n\t\t\t\t\tcomments.filter(comment => comment.postId === posts[0].id),\n\t\t\t\t),\n\t\t\t);\n\n\t\tconst postId = 1;\n\t\tconst getPost = getPostById(\n\t\t\tpostRepository,", "\t\tconst getPost = getPostById(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t);\n\t\tconst result = await getPost(postId);\n\n\t\texpect(result).toEqual({\n\t\t\t...posts[0],\n\t\t\tauthor: {", "\t\t\t...posts[0],\n\t\t\tauthor: {\n\t\t\t\tid: undefined,\n\t\t\t\tname: undefined,\n\t\t\t},\n\t\t\tcommentCount: comments.filter(comment => comment.postId === postId)\n\t\t\t\t.length,\n\t\t});\n\t});\n});", "\t});\n});\n"]}
{"filename": "__tests__/modules/posts/application/create/createPost.spec.ts", "chunked_list": ["import { Post } from \"@/src/modules/posts/domain/Post\";\nimport { PostDataResponse } from \"@/src/modules/posts/domain/PostDataResponse\";\nimport { PostDataCreate } from \"@/src/modules/posts/domain/PostDataCreate\";\nimport { createPost } from \"@/src/modules/posts/application/create/createPost\";\nimport { createApiPostRepository } from \"@/src/modules/posts/infra/ApiPostRepository\";\nimport { createApiUserRepository } from \"@/src/modules/users/infra/ApiUserRepository\";\nimport { posts, users } from \"@/tests/fixtures/mockData.json\";\n\nconst postRepository = createApiPostRepository();\nconst userRepository = createApiUserRepository();", "const postRepository = createApiPostRepository();\nconst userRepository = createApiUserRepository();\n\ndescribe('[useCase] createPost', () => {\n\ttest('should create a post and return it with author and comment count', async () => {\n\t\tconst postData: PostDataCreate = {\n\t\t\ttitle: 'title',\n\t\t\tbody: 'body',\n\t\t\tuserId: 1,\n\t\t};", "\t\t\tuserId: 1,\n\t\t};\n\t\tconst createdPost: PostDataResponse = {\n\t\t\tid: posts.length + 1,\n\t\t\t...postData,\n\t\t};\n\n\t\tjest.spyOn(postRepository, 'create').mockImplementation(() => Promise.resolve(createdPost));\n\t\tjest.spyOn(userRepository, 'get').mockImplementation(() => Promise.resolve(users[0]));\n", "\t\tjest.spyOn(userRepository, 'get').mockImplementation(() => Promise.resolve(users[0]));\n\n\t\tconst createNewPost = createPost(postRepository, userRepository);\n\t\tconst result: Post = await createNewPost(postData);\n\n\t\texpect(result).toEqual({\n\t\t\t...createdPost,\n\t\t\tcommentCount: 0,\n\t\t\tauthor: users[0],\n\t\t});", "\t\t\tauthor: users[0],\n\t\t});\n\t});\n});\n"]}
{"filename": "__tests__/modules/posts/application/get-all/getAllPosts.spec.ts", "chunked_list": ["import { getAllPosts } from '@/src/modules/posts/application/get-all/getAllPosts';\nimport { createApiPostRepository } from '@/src/modules/posts/infra/ApiPostRepository';\nimport { createApiUserRepository } from '@/src/modules/users/infra/ApiUserRepository';\nimport { createApiCommentRepository } from '@/src/modules/comments/infra/ApiCommentRepository';\nimport { PostMapper } from '@/src/modules/posts/application/mappers/PostMapper';\nimport { posts, users, comments } from '@/tests/fixtures/mockData.json';\n\nconst postRepository = createApiPostRepository();\nconst userRepository = createApiUserRepository();\nconst commentRepository = createApiCommentRepository();", "const userRepository = createApiUserRepository();\nconst commentRepository = createApiCommentRepository();\n\ndescribe('[useCase] getAllPosts', () => {\n\tafterEach(() => {\n\t\tjest.restoreAllMocks();\n\t});\n\n\ttest('should return all posts with author and comment count', async () => {\n\t\tjest", "\ttest('should return all posts with author and comment count', async () => {\n\t\tjest\n\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(posts));\n\t\tjest\n\t\t\t.spyOn(userRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(users));\n\t\tjest\n\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(comments));", "\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(comments));\n\n\t\tconst getPosts = getAllPosts(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t\tPostMapper,\n\t\t);\n\t\tconst result = await getPosts();", "\t\t);\n\t\tconst result = await getPosts();\n\n\t\texpect(result.length).toEqual(posts.length);\n\t});\n\n\ttest('should return all posts with undefined authors and zero comment count if users and comments are empty', async () => {\n\t\tjest\n\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(posts));", "\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(posts));\n\t\tjest\n\t\t\t.spyOn(userRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve([]));\n\t\tjest\n\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve([]));\n\n\t\tconst getPosts = getAllPosts(", "\n\t\tconst getPosts = getAllPosts(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t\tPostMapper,\n\t\t);\n\t\tconst result = await getPosts();\n\n\t\texpect(result.length).toEqual(posts.length);", "\n\t\texpect(result.length).toEqual(posts.length);\n\n\t\tresult.forEach((postWithDetails, index) => {\n\t\t\tconst originalPost = posts[index];\n\n\t\t\texpect(postWithDetails).toEqual({\n\t\t\t\t...originalPost,\n\t\t\t\tauthor: undefined,\n\t\t\t\tcommentCount: 0,", "\t\t\t\tauthor: undefined,\n\t\t\t\tcommentCount: 0,\n\t\t\t});\n\t\t});\n\t});\n\n\ttest('should return an empty array if there are no posts', async () => {\n\t\tjest\n\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve([]));", "\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve([]));\n\t\tjest\n\t\t\t.spyOn(userRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(users));\n\t\tjest\n\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t.mockImplementation(() => Promise.resolve(comments));\n\n\t\tconst getPosts = getAllPosts(", "\n\t\tconst getPosts = getAllPosts(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t\tPostMapper,\n\t\t);\n\t\tconst result = await getPosts();\n\n\t\texpect(result.length).toEqual(0);", "\n\t\texpect(result.length).toEqual(0);\n\t});\n});\n"]}
{"filename": "__tests__/modules/posts/application/mappers/PostMapper.spec.ts", "chunked_list": ["import { PostMapper } from '@/src/modules/posts/application/mappers/PostMapper';\nimport { users, posts, comments } from '@/tests/fixtures/mockData.json';\n\ndescribe('[mapper] PostMapper', () => {\n\tdescribe('createUserMap', () => {\n\t\ttest('should create a user map from users', () => {\n\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\texpect(userMap.size).toEqual(users.length);\n\t\t\texpect(userMap.get(1)).toEqual(users[0]);\n\t\t\texpect(userMap.get(2)).toEqual(users[1]);", "\t\t\texpect(userMap.get(1)).toEqual(users[0]);\n\t\t\texpect(userMap.get(2)).toEqual(users[1]);\n\t\t});\n\n\t\ttest('should handle an empty user list', () => {\n\t\t\tconst userMap = PostMapper.createUserMap([]);\n\t\t\texpect(userMap.size).toEqual(0);\n\t\t});\n\t});\n", "\t});\n\n\tdescribe('createCommentCountMap', () => {\n\t\ttest('should create a comment count map from comments', () => {\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\texpect(commentCountMap.size).toEqual(2);\n\t\t\texpect(commentCountMap.get(1)).toEqual(2);\n\t\t\texpect(commentCountMap.get(2)).toEqual(1);\n\t\t});\n", "\t\t});\n\n\t\ttest('should handle an empty comment list', () => {\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap([]);\n\t\t\texpect(commentCountMap.size).toEqual(0);\n\t\t});\n\t});\n\n\tdescribe('addAuthorAndCommentCountToPosts', () => {\n\t\ttest('should add author and comment count to posts', async () => {", "\tdescribe('addAuthorAndCommentCountToPosts', () => {\n\t\ttest('should add author and comment count to posts', async () => {\n\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\tposts,\n\t\t\t\tuserMap,\n\t\t\t\tcommentCountMap,\n\t\t\t);\n", "\t\t\t);\n\n\t\t\texpect(postsWithDetails.length).toEqual(posts.length);\n\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t...posts[0],\n\t\t\t\tauthor: users[0],\n\t\t\t\tcommentCount: 2,\n\t\t\t});\n\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t...posts[1],", "\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t...posts[1],\n\t\t\t\tauthor: users[1],\n\t\t\t\tcommentCount: 1,\n\t\t\t});\n\t\t});\n\n\t\ttest('should handle an empty post list', async () => {\n\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);", "\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\t[],\n\t\t\t\tuserMap,\n\t\t\t\tcommentCountMap,\n\t\t\t);\n\t\t\texpect(postsWithDetails.length).toEqual(0);\n\t\t});\n", "\t\t});\n\n\t\ttest('should handle posts with missing authors', async () => {\n\t\t\tconst userMap = PostMapper.createUserMap(users.slice(1)); // Excluye al primer usuario\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\tposts,\n\t\t\t\tuserMap,\n\t\t\t\tcommentCountMap,\n\t\t\t);", "\t\t\t\tcommentCountMap,\n\t\t\t);\n\t\t\texpect(postsWithDetails.length).toEqual(posts.length);\n\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t...posts[0],\n\t\t\t\tauthor: undefined,\n\t\t\t\tcommentCount: 2,\n\t\t\t});\n\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t...posts[1],", "\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t...posts[1],\n\t\t\t\tauthor: users[1],\n\t\t\t\tcommentCount: 1,\n\t\t\t});\n\t\t});\n\n\t\ttest('should handle posts with no associated comments', async () => {\n\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap([]);", "\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\tconst commentCountMap = PostMapper.createCommentCountMap([]);\n\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\tposts,\n\t\t\t\tuserMap,\n\t\t\t\tcommentCountMap,\n\t\t\t);\n\t\t\texpect(postsWithDetails.length).toEqual(posts.length);\n\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t...posts[0],", "\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t...posts[0],\n\t\t\t\tauthor: users[0],\n\t\t\t\tcommentCount: 0,\n\t\t\t});\n\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t...posts[1],\n\t\t\t\tauthor: users[1],\n\t\t\t\tcommentCount: 0,\n\t\t\t});", "\t\t\t\tcommentCount: 0,\n\t\t\t});\n\t\t});\n\t});\n});\n"]}
{"filename": "src/pages/api/hello.ts", "chunked_list": ["// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ntype Data = {\n\tname: string;\n};\n\nexport default function handler(\n\treq: NextApiRequest,\n\tres: NextApiResponse<Data>,\n) {\n\tres.status(200).json({ name: 'John Doe' });\n}\n"]}
{"filename": "src/sections/posts/usePostForm.ts", "chunked_list": ["import { useState } from 'react';\nimport { UserRepository } from '@/src/modules/users/domain/UserRepository';\nimport { PostRepository } from '@/src/modules/posts/domain/PostRepository';\nimport { PostDataCreate } from '@/src/modules/posts/domain/PostDataCreate';\nimport { Post } from '@/src/modules/posts/domain/Post';\nimport { createPost } from '@/src/modules/posts/application/create/createPost';\nimport { FormStatus } from '@/src/hooks/useFormData';\nexport function usePostForm(\n\tuserRepository: UserRepository,\n\tpostRepository: PostRepository,\n): {\n\tformStatus: FormStatus;\n\tsubmitForm: (formData: PostDataCreate) => void;\n\tresetFormStatus: () => void;\n\tpostCreated: Post | null;\n} {\n\tconst [formStatus, setFormStatus] = useState(FormStatus.INITIAL);\n\tconst [postCreated, setPostCreated] = useState<Post | null>(null);\n\n\tconst submitForm = async ({ title, body, userId }: PostDataCreate) => {\n\t\tsetFormStatus(FormStatus.LOADING);\n", "\t\ttry {\n\t\t\tconst postCreated = await createPost(\n\t\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n\t\t\t)({ title, body, userId }).catch(() => {\n\t\t\t\tthrow new Error('Error creating post');\n\t\t\t});\n\t\t\tsetPostCreated(postCreated);\n\t\t\tsetFormStatus(FormStatus.SUCCESS);\n\t\t} catch (error) {\n\t\t\tsetFormStatus(FormStatus.ERROR);\n\t\t}\n\t};\n\n\tconst resetFormStatus = () => setFormStatus(FormStatus.INITIAL);\n\n\treturn {\n\t\tformStatus,\n\t\tsubmitForm,\n\t\tresetFormStatus,\n\t\tpostCreated,\n\t};\n}\n", "\t\t} catch (error) {\n\t\t\tsetFormStatus(FormStatus.ERROR);\n\t\t}\n\t};\n\n\tconst resetFormStatus = () => setFormStatus(FormStatus.INITIAL);\n\n\treturn {\n\t\tformStatus,\n\t\tsubmitForm,\n\t\tresetFormStatus,\n\t\tpostCreated,\n\t};\n}\n"]}
{"filename": "src/hooks/usePagination.ts", "chunked_list": ["import { useState, useEffect } from 'react';\nimport { Post } from '@/src/modules/posts/domain/Post';\nimport { PostRepository } from '@/src/modules/posts/domain/PostRepository';\nimport { UserRepository } from '@/src/modules/users/domain/UserRepository';\nimport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\nimport { getPaginatedPosts } from '@/src/modules/posts/application/get-all/getPaginatedPosts';\nimport { PostMapper } from '@/src/modules/posts/application/mappers/PostMapper';\nimport { useLocalStorage } from '@/src/hooks/useLocalStorage';\n\nexport function usePagination(\n\tpostRepository: PostRepository,\n\tuserRepository: UserRepository,\n\tcommentRepository: CommentRepository,\n\tinitialPosts: Post[],\n\tinitialPage: number,\n\titemsPerPage: number,\n): [Post[], number, (page: number) => void] {\n\tconst [currentPosts, setCurrentPosts] = useState<Post[]>(initialPosts);\n\tconst [currentPage, setCurrentPage] = useLocalStorage<number>(\n\t\t'currentPage',\n\t\tinitialPage,\n\t);\n\n\tconst fetchMorePosts = async () => {\n\t\tconst fetchedPosts: Post[] = await getPaginatedPosts(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t\tPostMapper,\n\t\t\titemsPerPage,\n\t\t\tcurrentPage,\n\t\t)();\n\t\tsetCurrentPosts(fetchedPosts);\n\t};\n\n\tuseEffect(() => {\n\t\tfetchMorePosts();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [currentPage]);\n\n\treturn [currentPosts, currentPage, setCurrentPage];\n}\n\nexport default usePagination;\n", "\nexport function usePagination(\n\tpostRepository: PostRepository,\n\tuserRepository: UserRepository,\n\tcommentRepository: CommentRepository,\n\tinitialPosts: Post[],\n\tinitialPage: number,\n\titemsPerPage: number,\n): [Post[], number, (page: number) => void] {\n\tconst [currentPosts, setCurrentPosts] = useState<Post[]>(initialPosts);\n\tconst [currentPage, setCurrentPage] = useLocalStorage<number>(\n\t\t'currentPage',\n\t\tinitialPage,\n\t);\n\n\tconst fetchMorePosts = async () => {\n\t\tconst fetchedPosts: Post[] = await getPaginatedPosts(\n\t\t\tpostRepository,\n\t\t\tuserRepository,\n\t\t\tcommentRepository,\n\t\t\tPostMapper,\n\t\t\titemsPerPage,\n\t\t\tcurrentPage,\n\t\t)();\n\t\tsetCurrentPosts(fetchedPosts);\n\t};\n\n\tuseEffect(() => {\n\t\tfetchMorePosts();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [currentPage]);\n\n\treturn [currentPosts, currentPage, setCurrentPage];\n}\n\nexport default usePagination;\n"]}
{"filename": "src/hooks/useFormData.ts", "chunked_list": ["import { useState } from 'react';\n\nexport const enum FormStatus {\n\tLOADING,\n\tSUCCESS,\n\tERROR,\n\tINITIAL,\n}\n\nexport function useFormData<T>(initialState: T): {\n\tformData: T;\n\tupdateForm: (value: Partial<T>) => void;\n\tresetForm: () => void;\n} {\n\tconst [formData, setFormData] = useState(initialState);\n\n\tconst updateForm = (value: Partial<typeof initialState>) => {\n\t\tsetFormData(oldState => ({ ...oldState, ...value }));\n\t};\n\n\tconst resetForm = () => setFormData(initialState);\n\n\treturn {\n\t\tformData,\n\t\tupdateForm,\n\t\tresetForm,\n\t};\n}\n", "export function useFormData<T>(initialState: T): {\n\tformData: T;\n\tupdateForm: (value: Partial<T>) => void;\n\tresetForm: () => void;\n} {\n\tconst [formData, setFormData] = useState(initialState);\n\n\tconst updateForm = (value: Partial<typeof initialState>) => {\n\t\tsetFormData(oldState => ({ ...oldState, ...value }));\n\t};\n\n\tconst resetForm = () => setFormData(initialState);\n\n\treturn {\n\t\tformData,\n\t\tupdateForm,\n\t\tresetForm,\n\t};\n}\n"]}
{"filename": "src/hooks/useLocalStorage.ts", "chunked_list": ["import { useState, useEffect } from 'react';\n\nexport function useLocalStorage<T>(\n\tkey: string,\n\tinitialValue: T,\n): [T, (value: T) => void] {\n\tconst [storedValue, setStoredValue] = useState<T>(() => {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn initialValue;\n\t\t}\n\n\t\tconst item = window.localStorage.getItem(key);\n\t\treturn item ? JSON.parse(item) : initialValue;\n\t});\n\n\tconst setValue = (value: T) => {\n\t\tsetStoredValue(value);\n", "\t\tif (typeof window !== 'undefined') {\n\t\t\twindow.localStorage.setItem(key, JSON.stringify(value));\n\t\t}\n\t};\n\n\tuseEffect(() => {\n\t\tif (typeof window !== 'undefined') {\n\t\t\tconst handleStorageChange = (e: StorageEvent) => {\n\t\t\t\tif (e.key === key && e.newValue !== e.oldValue) {\n\t\t\t\t\tsetStoredValue(JSON.parse(e.newValue as string));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.addEventListener('storage', handleStorageChange);\n\t\t\treturn () => {\n\t\t\t\twindow.removeEventListener('storage', handleStorageChange);\n\t\t\t};\n\t\t}\n\t}, [key]);\n\n\treturn [storedValue, setValue];\n}\n\nexport default useLocalStorage;\n", "\t\t\t\tif (e.key === key && e.newValue !== e.oldValue) {\n\t\t\t\t\tsetStoredValue(JSON.parse(e.newValue as string));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.addEventListener('storage', handleStorageChange);\n\t\t\treturn () => {\n\t\t\t\twindow.removeEventListener('storage', handleStorageChange);\n\t\t\t};\n\t\t}\n\t}, [key]);\n\n\treturn [storedValue, setValue];\n}\n\nexport default useLocalStorage;\n"]}
{"filename": "src/modules/users/application/get/getUser.ts", "chunked_list": ["import { User } from '../../domain/User';\nimport { UserRepository } from '../../domain/UserRepository';\n\nexport function getUser(userRepository: UserRepository) {\n\treturn async (userId: number): Promise<User | undefined> => {\n\t\treturn await userRepository.get(userId);\n\t};\n}\n"]}
{"filename": "src/modules/users/application/get-all/getAllUsers.ts", "chunked_list": ["import { User } from '../../domain/User';\nimport { UserRepository } from '../../domain/UserRepository';\n\nexport function getAllUsers(userRepository: UserRepository) {\n\treturn async (): Promise<User[]> => {\n\t\treturn await userRepository.getAll();\n\t};\n}\n"]}
{"filename": "src/modules/users/domain/UserRepository.ts", "chunked_list": ["import { User } from './User';\n\nexport interface UserRepository {\n\tget: (id: number) => Promise<User | undefined>;\n\tgetAll: () => Promise<User[]>;\n}\n"]}
{"filename": "src/modules/users/domain/UserAddressGeolocation.ts", "chunked_list": ["export interface UserAddressGeolocation {\n\tlat: string;\n\tlng: string;\n}\n"]}
{"filename": "src/modules/users/domain/UserCompany.ts", "chunked_list": ["export interface UserCompany {\n\tname: string;\n\tcatchPhrase: string;\n\tbs: string;\n}\n"]}
{"filename": "src/modules/users/domain/UserAddress.ts", "chunked_list": ["import { UserAddressGeolocation } from './UserAddressGeolocation';\n\nexport interface UserAddress {\n\tstreet: string;\n\tsuite: string;\n\tcity: string;\n\tzipcode: string;\n\tgeo: UserAddressGeolocation;\n}\n"]}
{"filename": "src/modules/users/domain/User.ts", "chunked_list": ["import { UserAddress } from './UserAddress';\nimport { UserCompany } from './UserCompany';\n\nexport interface User {\n\tid: number;\n\tname: string;\n\temail: string;\n\taddress: UserAddress;\n\tphone: string;\n\twebsite: string;\n\tcompany: UserCompany;\n}\n"]}
{"filename": "src/modules/users/domain/Author.ts", "chunked_list": ["export interface Author {\n\tid: number | undefined;\n\tname: string | undefined;\n}\n"]}
{"filename": "src/modules/users/infra/ApiUserRepository.ts", "chunked_list": ["import { User } from '../domain/User';\nimport { UserRepository } from '../domain/UserRepository';\n\nconst JSONPLACEHOLDER_URL = 'https://jsonplaceholder.typicode.com';\n\nexport function createApiUserRepository(): UserRepository {\n\tconst cache: Map<number, User> = new Map();\n\n\tasync function get(id: number): Promise<User | undefined> {\n\t\tif (cache.has(id)) {\n\t\t\treturn cache.get(id) as User;\n\t\t}\n\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/users/${id}`);\n\t\tconst user = await response.json();\n\t\tcache.set(id, user);\n\n\t\treturn user;\n\t}\n", "\tasync function get(id: number): Promise<User | undefined> {\n\t\tif (cache.has(id)) {\n\t\t\treturn cache.get(id) as User;\n\t\t}\n\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/users/${id}`);\n\t\tconst user = await response.json();\n\t\tcache.set(id, user);\n\n\t\treturn user;\n\t}\n", "\tasync function getAll(): Promise<User[]> {\n\t\tif (cache.size > 0) {\n\t\t\treturn Array.from(cache.values());\n\t\t}\n\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/users`);\n\t\tconst users = await response.json();\n\n\t\tusers.forEach((user: User) => cache.set(user.id, user));\n\n\t\treturn users;\n\t}\n\n\treturn {\n\t\tget,\n\t\tgetAll,\n\t};\n}\n"]}
{"filename": "src/modules/posts/application/get/getPostById.ts", "chunked_list": ["import { UserRepository } from '@/src/modules/users/domain/UserRepository';\nimport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\nimport { PostRepository } from '../../domain/PostRepository';\nimport { Post } from '../../domain/Post';\n\nexport function getPostById(\n\tpostRepository: PostRepository,\n\tuserRepository: UserRepository,\n\tcommentRepository: CommentRepository,\n): (postId: number) => Promise<Post | undefined> {\n\treturn async (postId: number): Promise<Post | undefined> => {\n\t\tconst post = await postRepository.get(postId);\n", "\t\tif (!post) {\n\t\t\tthrow new Error(`Post with id ${postId} not found`);\n\t\t}\n\n\t\tconst [author, comments] = await Promise.all([\n\t\t\tuserRepository.get(post.userId),\n\t\t\tcommentRepository.getAllByPost(postId),\n\t\t]);\n\n\t\tconst postWithAuthorAndCommentCount = {\n\t\t\t...post,\n\t\t\tauthor: {\n\t\t\t\tid: author?.id,\n\t\t\t\tname: author?.name,\n\t\t\t},\n\t\t\tcommentCount: comments.length,\n\t\t};\n\n\t\treturn postWithAuthorAndCommentCount;\n\t};\n}\n"]}
{"filename": "src/modules/posts/application/create/createPost.ts", "chunked_list": ["import { UserRepository } from \"@/src/modules/users/domain/UserRepository\";\nimport { PostRepository } from \"../../domain/PostRepository\";\nimport { Post } from \"../../domain/Post\";\nimport { PostDataCreate } from \"../../domain/PostDataCreate\";\nimport { PostDataResponse } from \"../../domain/PostDataResponse\";\n\nexport function createPost(\n\tpostRepository: PostRepository,\n\tuserRepository: UserRepository,\n): (post: PostDataCreate) => Promise<Post> {\n\treturn async (post: PostDataCreate): Promise<Post> => {\n\t\tconst createdPost = await postRepository.create(post) as PostDataResponse;\n\t\tconst commentCount = 0;\n\t\tconst author = await userRepository.get(post.userId);\n\n\t\t//TODO: ensurePostIsValid\n\n\t\treturn {\n\t\t\t...createdPost,\n\t\t\tauthor,\n\t\t\tcommentCount,\n\t\t};\n\t};\n}\n\n"]}
{"filename": "src/modules/posts/application/get-all/getAllPosts.ts", "chunked_list": ["import { UserRepository } from '@/src/modules/users/domain/UserRepository';\nimport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\nimport { PostRepository } from '../../domain/PostRepository';\nimport { Post } from '../../domain/Post';\nimport { PostMapper } from '../mappers/PostMapper';\n\nexport function getAllPosts(\n\tpostRepository: PostRepository,\n\tuserRepository: UserRepository,\n\tcommentRepository: CommentRepository,\n\tpostMapper: typeof PostMapper,\n): () => Promise<Post[]> {\n\treturn async (): Promise<Post[]> => {\n\t\tconst [posts, users, comments] = await Promise.all([\n\t\t\tpostRepository.getAll(),\n\t\t\tuserRepository.getAll(),\n\t\t\tcommentRepository.getAll(),\n\t\t]);\n\n\t\tconst userMap = postMapper.createUserMap(users);\n\t\tconst commentCountByPostId = postMapper.createCommentCountMap(comments);\n\n\t\treturn await postMapper.addAuthorAndCommentCountToPosts(\n\t\t\tposts,\n\t\t\tuserMap,\n\t\t\tcommentCountByPostId,\n\t\t);\n\t};\n}\n"]}
{"filename": "src/modules/posts/application/get-all/getPaginatedPosts.ts", "chunked_list": ["import { UserRepository } from '@/src/modules/users/domain/UserRepository';\nimport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\nimport { PostRepository } from '../../domain/PostRepository';\nimport { Post } from '../../domain/Post';\nimport { PostMapper } from '../mappers/PostMapper';\n\nexport function getPaginatedPosts(\n\tpostRepository: PostRepository,\n\tuserRepository: UserRepository,\n\tcommentRepository: CommentRepository,\n\tpostMapper: typeof PostMapper,\n\tlimit: number,\n\tpage: number,\n): () => Promise<Post[]> {\n\treturn async (): Promise<Post[]> => {\n\t\tconst [posts, users, comments] = await Promise.all([\n\t\t\tpostRepository.getAllWithPagination(limit, page),\n\t\t\tuserRepository.getAll(),\n\t\t\tcommentRepository.getAll(),\n\t\t]);\n\n\t\tconst userMap = postMapper.createUserMap(users);\n\t\tconst commentCountByPostId = postMapper.createCommentCountMap(comments);\n\n\t\treturn await postMapper.addAuthorAndCommentCountToPosts(\n\t\t\tposts,\n\t\t\tuserMap,\n\t\t\tcommentCountByPostId,\n\t\t);\n\t};\n}\n"]}
{"filename": "src/modules/posts/application/get-all/getAllPostsByUser.ts", "chunked_list": ["import { Post } from '../../domain/Post';\nimport { PostRepository } from '../../domain/PostRepository';\n\nexport function getAllPostsByUser(\n\tpostRepository: PostRepository,\n): (userId: number) => Promise<Post[]> {\n\treturn async (userId: number): Promise<Post[]> => {\n\t\treturn await postRepository.getByUser(userId);\n\t};\n}\n"]}
{"filename": "src/modules/posts/application/mappers/PostMapper.ts", "chunked_list": ["import { Post } from '@/src/modules/posts/domain/Post';\nimport { User } from '@/src/modules/users/domain/User';\nimport { Comment } from '@/src/modules/comments/domain/Comment';\n\nexport const PostMapper = {\n\tcreateUserMap,\n\tcreateCommentCountMap,\n\taddAuthorAndCommentCountToPosts,\n};\n\nfunction createUserMap(users: User[]): Map<number, User> {\n\tconst userMap = new Map<number, User>();\n\n\tusers.forEach(user => userMap.set(user.id, user));\n\n\treturn userMap;\n}\n", "};\n\nfunction createUserMap(users: User[]): Map<number, User> {\n\tconst userMap = new Map<number, User>();\n\n\tusers.forEach(user => userMap.set(user.id, user));\n\n\treturn userMap;\n}\n\nfunction createCommentCountMap(comments: Comment[]): Map<number, number> {\n\tconst commentCountMap = new Map<number, number>();\n\n\tcomments.forEach(comment => {\n\t\tconst count = commentCountMap.get(comment.postId) ?? 0;\n\t\tcommentCountMap.set(comment.postId, count + 1);\n\t});\n\n\treturn commentCountMap;\n}\n", "function createCommentCountMap(comments: Comment[]): Map<number, number> {\n\tconst commentCountMap = new Map<number, number>();\n\n\tcomments.forEach(comment => {\n\t\tconst count = commentCountMap.get(comment.postId) ?? 0;\n\t\tcommentCountMap.set(comment.postId, count + 1);\n\t});\n\n\treturn commentCountMap;\n}\n", "async function addAuthorAndCommentCountToPosts(\n\tposts: Post[],\n\tuserMap = new Map<number, User>(),\n\tcommentCountByPostId: Map<number, number>,\n): Promise<Post[]> {\n\tconst postsWithDetails = posts.map(post => {\n\t\tconst author = userMap.get(post.userId);\n\n\t\treturn {\n\t\t\t...post,\n\t\t\tauthor,\n\t\t\tcommentCount: commentCountByPostId.get(post.id) || 0,\n\t\t};\n\t});\n\n\treturn postsWithDetails;\n}\n"]}
{"filename": "src/modules/posts/domain/PostRepository.ts", "chunked_list": ["import { Post } from './Post';\nimport { PostDataCreate } from './PostDataCreate';\nimport { PostDataResponse } from './PostDataResponse';\n\nexport interface PostRepository {\n\tcreate: (post: PostDataCreate) => Promise<PostDataResponse>;\n\tget: (postId: number) => Promise<Post | undefined>;\n\tgetAllWithPagination: (limit: number, page: number) => Promise<Post[]>;\n\tgetAll: () => Promise<Post[]>;\n\tgetByUser: (userId: number) => Promise<Post[]>;\n}\n"]}
{"filename": "src/modules/posts/domain/PostDataCreate.ts", "chunked_list": ["export interface PostDataCreate {\n\ttitle: string;\n\tbody: string;\n\tuserId: number;\n};\n\n// TODO: add validation function\n// ensurePostIsValid\n"]}
{"filename": "src/modules/posts/domain/Post.ts", "chunked_list": ["import { Author } from '../../users/domain/Author';\n\nexport interface Post {\n\tuserId: number;\n\tid: number;\n\ttitle: string;\n\tbody: string;\n\tauthor?: Author;\n\tcommentCount?: number;\n}\n"]}
{"filename": "src/modules/posts/domain/PostDataResponse.ts", "chunked_list": ["export interface PostDataResponse {\n\tid: number;\n\ttitle: string;\n\tbody: string;\n\tuserId: number;\n};\n\n"]}
{"filename": "src/modules/posts/infra/ApiPostRepository.ts", "chunked_list": ["import { Post } from '../domain/Post';\nimport { PostDataCreate } from '../domain/PostDataCreate';\nimport { PostDataResponse } from '../domain/PostDataResponse'; \nimport { PostRepository } from '../domain/PostRepository';\n\nconst JSONPLACEHOLDER_URL = 'https://jsonplaceholder.typicode.com';\n\nexport function createApiPostRepository(): PostRepository {\n\tconst cache = new Map<number, Post>();\n\n\tasync function get(postId: number): Promise<Post> {", "\tasync function get(postId: number): Promise<Post> {\n\t\tif (cache.has(postId)) {\n\t\t\treturn cache.get(postId) as Post;\n\t\t}\n\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/posts/${postId}`);\n\t\tconst post = await response.json();\n\t\tcache.set(postId, post);\n\n\t\treturn post;\n\t}\n", "\tasync function getAllWithPagination(\n\t\tlimit: number,\n\t\tpage: number,\n\t): Promise<Post[]> {\n\t\tconst offset = (page - 1) * limit;\n\t\tconst response = await fetch(\n\t\t\t`${JSONPLACEHOLDER_URL}/posts?_start=${offset}&_limit=${limit}`,\n\t\t);\n\t\tconst posts = await response.json();\n\n\t\treturn posts;\n\t}\n", "\tasync function getAll(): Promise<Post[]> {\n\t\tif (cache.size > 0) {\n\t\t\treturn Array.from(cache.values());\n\t\t}\n\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/posts`);\n\t\tconst posts = await response.json();\n\n\t\tposts.forEach((post: Post) => cache.set(post.id, post));\n\n\t\treturn posts;\n\t}\n", "\tasync function getByUser(userId: number): Promise<Post[]> {\n\t\tif (cache.size > 0) {\n\t\t\treturn Array.from(cache.values()).filter(post => post.userId === userId);\n\t\t}\n\n\t\tconst response = await fetch(\n\t\t\t`${JSONPLACEHOLDER_URL}/users/${userId}/posts`,\n\t\t);\n\t\tconst posts = await response.json();\n\n\t\tposts.forEach((post: Post) => cache.set(post.id, post));\n\n\t\treturn posts;\n\t}\n", "\tasync function create(post: PostDataCreate): Promise<PostDataResponse> {\n\t\tconst { title, body, userId } = post;\n\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/posts`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\t\ttitle,\n\t\t\t\tbody,\n\t\t\t\tuserId,\n\t\t\t}),\n\t\t\theaders: {\n\t\t\t\t'Content-type': 'application/json; charset=UTF-8',\n\t\t\t},\n\t\t});\n\n\t\tconst createdPost = await response.json();\n\n\t\treturn createdPost;\n\t}\n\n\treturn {\n\t\tcreate,\n\t\tget,\n\t\tgetAllWithPagination,\n\t\tgetAll,\n\t\tgetByUser,\n\t};\n}\n"]}
{"filename": "src/modules/comments/application/get/getCommentById.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\nimport { CommentRepository } from '../../domain/CommentRepository';\n\nexport function getCommentById(commentRepository: CommentRepository) {\n\treturn async (id: number): Promise<Comment | undefined> => {\n\t\treturn await commentRepository.get(id);\n\t};\n}\n"]}
{"filename": "src/modules/comments/application/get-all/getAllCommentsByPost.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\nimport { CommentRepository } from '../../domain/CommentRepository';\n\nexport function getAllCommentsByPost(commentRepository: CommentRepository) {\n\treturn async (postId: number): Promise<Comment[]> => {\n\t\treturn await commentRepository.getAllByPost(postId);\n\t};\n}\n"]}
{"filename": "src/modules/comments/application/get-all/getAllComments.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\nimport { CommentRepository } from '../../domain/CommentRepository';\n\nexport function getAllComments(commentRepository: CommentRepository) {\n\treturn async (): Promise<Comment[]> => {\n\t\treturn await commentRepository.getAll();\n\t};\n}\n"]}
{"filename": "src/modules/comments/application/get-all/getAllCommentsByUser.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\nimport { CommentRepository } from '../../domain/CommentRepository';\n\nexport function getAllCommentsByUser(commentRepository: CommentRepository) {\n\treturn async (userId: number): Promise<Comment[]> => {\n\t\treturn await commentRepository.getAllByUser(userId);\n\t};\n}\n"]}
{"filename": "src/modules/comments/domain/Comment.ts", "chunked_list": ["export interface Comment {\n\tpostId: number;\n\tid: number;\n\tname: string;\n\temail: string;\n\tbody: string;\n}\n"]}
{"filename": "src/modules/comments/domain/CommentRepository.ts", "chunked_list": ["import { Comment } from './Comment';\n\nexport interface CommentRepository {\n\tgetAllByPost: (postId: number) => Promise<Comment[]>;\n\tgetAllByUser: (userId: number) => Promise<Comment[]>;\n\tgetAll: () => Promise<Comment[]>;\n\tget: (commentId: number) => Promise<Comment | undefined>;\n}\n"]}
{"filename": "src/modules/comments/infra/ApiCommentRepository.ts", "chunked_list": ["import { Comment } from '../domain/Comment';\nimport { CommentRepository } from '../domain/CommentRepository';\n\nconst JSONPLACEHOLDER_URL = 'https://jsonplaceholder.typicode.com';\n\nexport function createApiCommentRepository(): CommentRepository {\n\treturn {\n\t\tget,\n\t\tgetAll,\n\t\tgetAllByPost,\n\t\tgetAllByUser,\n\t};\n}\n", "async function get(commentId: number): Promise<Comment> {\n\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/comments/${commentId}`);\n\tconst comment = (await response.json()) as Promise<Comment>;\n\n\treturn comment;\n}\n\nasync function getAll(): Promise<Comment[]> {\n\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/comments`);\n\tconst comments = await response.json();\n\n\treturn comments;\n}\n", "async function getAllByPost(postId: number) {\n\tconst response = await fetch(\n\t\t`${JSONPLACEHOLDER_URL}/posts/${postId}/comments`,\n\t);\n\tconst comments = await response.json();\n\n\treturn comments;\n}\n\nasync function getAllByUser(userId: number) {\n\tconst response = await fetch(\n\t\t`${JSONPLACEHOLDER_URL}/users/${userId}/comments`,\n\t);\n\tconst comments = await response.json();\n\n\treturn comments;\n}\n", "async function getAllByUser(userId: number) {\n\tconst response = await fetch(\n\t\t`${JSONPLACEHOLDER_URL}/users/${userId}/comments`,\n\t);\n\tconst comments = await response.json();\n\n\treturn comments;\n}\n"]}
