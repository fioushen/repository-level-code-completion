{"filename": "vite.config.ts", "chunked_list": ["import path from \"path\";\nimport { defineConfig } from \"vite\";\nimport packageJson from \"./package.json\";\n\nconst getPackageName = () => {\n  return packageJson.name;\n};\n\nconst getPackageNameCamelCase = () => {\n  try {\n    return getPackageName().replace(/-./g, (char) => char[1].toUpperCase());", "const getPackageNameCamelCase = () => {\n  try {\n    return getPackageName().replace(/-./g, (char) => char[1].toUpperCase());\n  } catch (err) {\n    throw new Error(\"Name property in package.json is missing.\");\n  }\n};\n\nconst fileName = {\n  es: `${getPackageName()}.mjs`,\n  cjs: `${getPackageName()}.cjs`,\n  iife: `${getPackageName()}.iife.js`,\n};\n\nconst formats = Object.keys(fileName) as Array<keyof typeof fileName>;\n\nmodule.exports = defineConfig({\n  base: \"./\",\n  build: {\n    lib: {\n      entry: path.resolve(__dirname, \"src/index.ts\"),\n      name: getPackageNameCamelCase(),\n      formats,\n      fileName: (format) => fileName[format],\n    },\n  },\n});\n"]}
{"filename": "test/string.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport * as String from \"../src/string\"\nimport { pipe } from \"../src/Composition\"\n\ndescribe(\"String\", () => {\n    describe(\"isEmpty\", () => {\n        it.each([\n            [true, \"\"],\n            [false, \"something\"],\n        ])(\"returns %o when given %s\", (expected, inp) => {", "            [false, \"something\"],\n        ])(\"returns %o when given %s\", (expected, inp) => {\n            expect(String.isEmpty(inp)).toBe(expected)\n        })\n    })\n\n    describe(\"trim\", () => {\n        it(\"trims\", () => {\n            expect(String.trim(\"  abc \")).toBe(\"abc\")\n        })", "            expect(String.trim(\"  abc \")).toBe(\"abc\")\n        })\n    })\n\n    describe(\"toLowerCase\", () => {\n        it(\"lower-cases\", () => {\n            expect(String.toLowerCase(\"AAbdF\")).toBe(\"aabdf\")\n        })\n    })\n", "    })\n\n    describe(\"toUpperCase\", () => {\n        it(\"upper-cases\", () => {\n            expect(String.toUpperCase(\"Dogs\")).toBe(\"DOGS\")\n        })\n    })\n\n    describe(\"isString\", () => {\n        it.each([", "    describe(\"isString\", () => {\n        it.each([\n            [true, \"\"],\n            [true, \"   \"],\n            [true, \"  addc \"],\n            [true, \"cheese\"],\n            [false, null],\n            [false, undefined],\n            [false, {}],\n            [false, 42],", "            [false, {}],\n            [false, 42],\n        ])(\"returns %o when given %o\", (expected, inp) => {\n            expect(String.isString(inp)).toBe(expected)\n        })\n    })\n\n    describe(\"length\", () => {\n        it(\"returns the length\", () => {\n            expect(String.length(\"cheese\")).toBe(6)", "        it(\"returns the length\", () => {\n            expect(String.length(\"cheese\")).toBe(6)\n        })\n    })\n\n    describe(\"split\", () => {\n        it(\"splits using a string\", () => {\n            expect(pipe(\"C-H-E-D-D-A-R\", String.split(\"-\"))).toStrictEqual([\n                \"C\",\n                \"H\",", "                \"C\",\n                \"H\",\n                \"E\",\n                \"D\",\n                \"D\",\n                \"A\",\n                \"R\",\n            ])\n        })\n", "        })\n\n        it(\"splits using a regex\", () => {\n            expect(pipe(\"org.url.com\", String.split(/\\./))).toStrictEqual([\n                \"org\",\n                \"url\",\n                \"com\",\n            ])\n        })\n    })", "        })\n    })\n\n    describe(\"capitalize\", () => {\n        it.each([\n            [\"\", \"\"],\n            [\"cheese\", \"Cheese\"],\n            [\"Cheese\", \"Cheese\"],\n        ])(\"capitalizes %s -> %s\", (input, expected) => {\n            expect(String.capitalize(input)).toBe(expected)", "        ])(\"capitalizes %s -> %s\", (input, expected) => {\n            expect(String.capitalize(input)).toBe(expected)\n        })\n    })\n\n    describe(\"uncapitalize\", () => {\n        it.each([\n            [\"\", \"\"],\n            [\"cheese\", \"cheese\"],\n            [\"Cheese\", \"cheese\"],", "            [\"cheese\", \"cheese\"],\n            [\"Cheese\", \"cheese\"],\n        ])(\"uncapitalizes %s -> %s\", (input, expected) => {\n            expect(String.uncapitalize(input)).toBe(expected)\n        })\n    })\n})\n"]}
{"filename": "test/AsyncResult.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport * as AsyncResult from \"../src/AsyncResult\"\nimport { Async } from \"../src/Async\"\nimport { Result } from \"../src/Result\"\nimport { pipe } from \"../src/Composition\"\n\ndescribe(\"AsyncResult\", () => {\n    describe(\"constructors\", () => {\n        describe(\"Ok\", () => {\n            it(\"produces a new Ok\", async () => {", "        describe(\"Ok\", () => {\n            it(\"produces a new Ok\", async () => {\n                expect(await pipe(AsyncResult.ok(30), Async.start)).toStrictEqual(\n                    Result.ok(30)\n                )\n            })\n        })\n\n        describe(\"Err\", () => {\n            it(\"produces a new Err\", async () => {", "        describe(\"Err\", () => {\n            it(\"produces a new Err\", async () => {\n                expect(await pipe(AsyncResult.err(\"err\"), Async.start)).toStrictEqual(\n                    Result.err(\"err\")\n                )\n            })\n        })\n    })\n\n    describe(\"map\", () => {", "\n    describe(\"map\", () => {\n        it(\"projects the inner Ok value\", async () => {\n            expect(\n                await pipe(\n                    AsyncResult.ok(10),\n                    AsyncResult.map(n => n + 1),\n                    Async.start\n                )\n            ).toStrictEqual(Result.ok(11))", "                )\n            ).toStrictEqual(Result.ok(11))\n        })\n\n        it(\"does nothing to an Err\", async () => {\n            expect(\n                await pipe(\n                    AsyncResult.err(10),\n                    AsyncResult.map((n: number) => n + 1),\n                    Async.start", "                    AsyncResult.map((n: number) => n + 1),\n                    Async.start\n                )\n            ).toStrictEqual(Result.err(10))\n        })\n    })\n\n    describe(\"mapErr\", () => {\n        it(\"projects the inner Err value\", async () => {\n            expect(", "        it(\"projects the inner Err value\", async () => {\n            expect(\n                await pipe(\n                    AsyncResult.err(\"err\"),\n                    AsyncResult.mapErr(s => s.length),\n                    Async.start\n                )\n            ).toStrictEqual(Result.err(3))\n        })\n", "        })\n\n        it(\"does nothing to an Ok\", async () => {\n            expect(\n                await pipe(\n                    AsyncResult.ok(10),\n                    AsyncResult.mapErr((n: number) => n + 1),\n                    Async.start\n                )\n            ).toStrictEqual(Result.ok(10))", "                )\n            ).toStrictEqual(Result.ok(10))\n        })\n    })\n\n    describe(\"mapBoth\", () => {\n        it(\"projects the inner Ok value on Ok\", async () => {\n            expect(\n                await pipe(\n                    AsyncResult.ok<number, string>(25),", "                await pipe(\n                    AsyncResult.ok<number, string>(25),\n                    AsyncResult.mapBoth(\n                        n => n * 2,\n                        s => s.length\n                    ),\n                    Async.start\n                )\n            ).toStrictEqual(Result.ok(50))\n        })", "            ).toStrictEqual(Result.ok(50))\n        })\n\n        it(\"projects the inner Err value on Err\", async () => {\n            expect(\n                await pipe(\n                    AsyncResult.err<string, number>(\"failure\"),\n                    AsyncResult.mapBoth(\n                        n => n * 2,\n                        s => s.length", "                        n => n * 2,\n                        s => s.length\n                    ),\n                    Async.start\n                )\n            ).toStrictEqual(Result.err(7))\n        })\n    })\n\n    describe(\"bind\", () => {", "\n    describe(\"bind\", () => {\n        it(\"projects the inner Ok value and flattens the result\", async () => {\n            // arrange\n            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n            const f2 = (s: string) => AsyncResult.ok<number, Error>(s.length)\n            // act\n            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.ok(2))", "            // assert\n            expect(actual).toStrictEqual(Result.ok(2))\n        })\n\n        it(\"does nothing to Err values\", async () => {\n            // arrange\n            const f1 = () => AsyncResult.err<Error, string>(new Error(\"err\"))\n            const f2 = (s: string) => AsyncResult.ok<number, Error>(s.length)\n            // act\n            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)", "            // act\n            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n        })\n\n        it(\"returns a flattened Err if the bind projection returns an Err\", async () => {\n            // arrange\n            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n            const f2 = (_: string) => AsyncResult.err<Error, number>(new Error(\"err\"))", "            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n            const f2 = (_: string) => AsyncResult.err<Error, number>(new Error(\"err\"))\n            // act\n            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n        })\n    })\n\n    describe(\"bindResult\", () => {", "\n    describe(\"bindResult\", () => {\n        it(\"projects the inner Ok value and flattens the result\", async () => {\n            // arrange\n            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n            const f2 = (s: string) => Result.ok<number, Error>(s.length)\n            // act\n            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.ok(2))", "            // assert\n            expect(actual).toStrictEqual(Result.ok(2))\n        })\n\n        it(\"does nothing to Err values\", async () => {\n            // arrange\n            const f1 = () => AsyncResult.err<Error, string>(new Error(\"err\"))\n            const f2 = (s: string) => Result.ok<number, Error>(s.length)\n            // act\n            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)", "            // act\n            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n        })\n\n        it(\"returns a flattened Err if the bind projection returns an Err\", async () => {\n            // arrange\n            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n            const f2 = (_: string) => Result.err<Error, number>(new Error(\"err\"))", "            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n            const f2 = (_: string) => Result.err<Error, number>(new Error(\"err\"))\n            // act\n            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n        })\n    })\n\n    describe(\"ofResult\", () => {", "\n    describe(\"ofResult\", () => {\n        it(\"lifts a result into an AsyncResult\", async () => {\n            expect(\n                await pipe(Result.err(\"failure\"), AsyncResult.ofResult, Async.start)\n            ).toStrictEqual(Result.err(\"failure\"))\n        })\n    })\n\n    describe(\"ofAsync\", () => {", "\n    describe(\"ofAsync\", () => {\n        it(\"lifts an Async into an AsyncResult\", async () => {\n            expect(\n                await pipe(Async.of(25), AsyncResult.ofAsync, Async.start)\n            ).toStrictEqual(Result.ok(25))\n        })\n    })\n\n    describe(\"tryCatch\", () => {", "\n    describe(\"tryCatch\", () => {\n        it(\"returns an Ok if the computation does not throw\", async () => {\n            // arrange\n            const f = Async.of(12)\n            // act\n            const actual = await pipe(f, AsyncResult.tryCatch, Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.ok(12))\n        })", "            expect(actual).toStrictEqual(Result.ok(12))\n        })\n\n        it(\"returns an Err if the computation throws\", async () => {\n            // arrange\n            // eslint-disable-next-line @typescript-eslint/require-await\n            const f = async () => {\n                throw new Error(\"failure\")\n            }\n            // act", "            }\n            // act\n            const actual = await pipe(f, AsyncResult.tryCatch, Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err(new Error(\"failure\")))\n        })\n\n        it(\"coerces thrown non-error objects to a stringified error by default\", async () => {\n            // arrange\n            // eslint-disable-next-line @typescript-eslint/require-await", "            // arrange\n            // eslint-disable-next-line @typescript-eslint/require-await\n            const f = async () => {\n                throw \"failure\"\n            }\n            // act\n            const actual = await pipe(f, AsyncResult.tryCatch, Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err(new Error(\"failure\")))\n        })", "            expect(actual).toStrictEqual(Result.err(new Error(\"failure\")))\n        })\n\n        it(\"uses the onThrow function if given\", async () => {\n            // arrange\n            // eslint-disable-next-line @typescript-eslint/require-await\n            const f = async (): Promise<number> => {\n                throw \"failure\"\n            }\n\n            const onThrow = (u: unknown) => ({ err: String(u) })\n            // act\n            const actual = await pipe(AsyncResult.tryCatch(f, onThrow), Async.start)\n            // assert\n            expect(actual).toStrictEqual(Result.err({ err: \"failure\" }))\n        })\n    })\n\n    describe(\"match\", () => {\n        it(\"matches Ok using a lambda\", async () => {\n            // arrange\n            const matcher = {\n                ok: (n: number) => n + 100,\n                err: (s: string) => s.length,\n            }\n            // act\n            const actual = await pipe(\n                AsyncResult.ok<number, string>(10),\n                AsyncResult.match(matcher),\n                Async.start\n            )\n            // assert\n            expect(actual).toBe(110)\n        })\n\n        it(\"matches Ok using a raw value\", async () => {\n            // arrange\n            const matcher = {\n                ok: 99,\n                err: (s: string) => s.length,\n            }\n            // act\n            const actual = await pipe(\n                AsyncResult.ok<number, string>(10),\n                AsyncResult.match(matcher),\n                Async.start\n            )\n            // assert\n            expect(actual).toBe(99)\n        })\n\n        it(\"matches Err using a lambda\", async () => {\n            // arrange\n            const matcher = {\n                ok: (n: number) => n + 100,\n                err: (s: string) => s.length,\n            }\n            // act\n            const actual = await pipe(\n                AsyncResult.err<string, number>(\"fail\"),\n                AsyncResult.match(matcher),\n                Async.start\n            )\n            // assert\n            expect(actual).toBe(4)\n        })\n\n        it(\"matches Err using a raw value\", async () => {\n            // arrange\n            const matcher = {\n                ok: \"\",\n                err: \"argh!\",\n            }\n            // act\n            const actual = await pipe(\n                AsyncResult.err<string, number>(\"\"),\n                AsyncResult.match(matcher),\n                Async.start\n            )\n            // assert\n            expect(actual).toBe(\"argh!\")\n        })\n    })\n\n    describe(\"start\", () => {\n        it(\"invokes the AsyncResult\", async () => {\n            expect(await pipe(AsyncResult.ok(\"A\"), AsyncResult.start)).toStrictEqual(\n                Result.ok(\"A\")\n            )\n        })\n    })\n\n    describe(\"tee\", () => {\n        it(\"executes the side effect on an Ok value\", async () => {\n            const sideEffect = vi.fn<[number], void>()\n            const actual = await pipe(\n                AsyncResult.ofResult(Result.ok(42)),\n                AsyncResult.tee(sideEffect),\n                Async.start\n            )\n            expect(sideEffect).toHaveBeenCalledOnce()\n            expect(sideEffect).toHaveBeenCalledWith(42)\n            expect(actual).toStrictEqual(Result.ok(42))\n        })\n\n        it(\"does not execute the side effect on an Err value\", async () => {\n            const sideEffect = vi.fn<[number], void>()\n            const actual = await pipe(\n                AsyncResult.ofResult(Result.err<string, number>(\"42\")),\n                AsyncResult.tee(sideEffect),\n                Async.start\n            )\n            expect(sideEffect).not.toHaveBeenCalled()\n            expect(actual).toStrictEqual(Result.err(\"42\"))\n        })\n    })\n\n    describe(\"teeErr\", () => {\n        it(\"executes the side effect on an Err value\", async () => {\n            const sideEffect = vi.fn<[number], void>()\n            const actual = await pipe(\n                AsyncResult.ofResult(Result.err(42)),\n                AsyncResult.teeErr(sideEffect),\n                Async.start\n            )\n            expect(sideEffect).toHaveBeenCalledOnce()\n            expect(sideEffect).toHaveBeenCalledWith(42)\n            expect(actual).toStrictEqual(Result.err(42))\n        })\n\n        it(\"does not execute the side effect on an Ok value\", async () => {\n            const sideEffect = vi.fn<[number], void>()\n            const actual = await pipe(\n                AsyncResult.ofResult(Result.ok<string, number>(\"42\")),\n                AsyncResult.teeErr(sideEffect),\n                Async.start\n            )\n            expect(sideEffect).not.toHaveBeenCalled()\n            expect(actual).toStrictEqual(Result.ok(\"42\"))\n        })\n    })\n})\n"]}
{"filename": "test/Array.test.ts", "chunked_list": ["import { it, describe, expect, vi } from \"vitest\"\nimport { pipe, flow } from \"../src/Composition\"\nimport { Option } from \"../src/Option\"\nimport * as Array from \"../src/Array\"\nimport { NonEmptyArray } from \"../src/NonEmptyArray\"\nimport { Result } from \"../src/Result\"\nimport { String } from \"../src/string\"\nimport { OrderingComparer } from \"../src/OrderingComparer\"\nimport { EqualityComparer } from \"../src/EqualityComparer\"\n", "import { EqualityComparer } from \"../src/EqualityComparer\"\n\ndescribe(\"Array\", () => {\n    describe(\"choose\", () => {\n        it(\"projects and keeps only the Some results\", () => {\n            // arrange\n            const arr = [32, null, 55, undefined, 89] as const\n            // act\n            const actual = pipe(\n                arr,", "            const actual = pipe(\n                arr,\n                Array.choose(flow(Option.ofNullish, Option.map(globalThis.String)))\n            )\n            // assert\n            expect(actual).toStrictEqual([\"32\", \"55\", \"89\"])\n        })\n    })\n\n    describe(\"chooseR\", () => {", "\n    describe(\"chooseR\", () => {\n        it(\"projects and keeps only the Ok results\", () => {\n            // arrange\n            const arr = [32, null, 55, undefined, 89] as const\n            // act\n            const actual = pipe(\n                arr,\n                Array.chooseR(\n                    flow(", "                Array.chooseR(\n                    flow(\n                        Option.ofNullish,\n                        Option.map(globalThis.String),\n                        Result.ofOption(() => \"err\")\n                    )\n                )\n            )\n            // assert\n            expect(actual).toStrictEqual([\"32\", \"55\", \"89\"])", "            // assert\n            expect(actual).toStrictEqual([\"32\", \"55\", \"89\"])\n        })\n    })\n\n    describe(\"take\", () => {\n        it(\"keeps only the specificed number of values when the array is longer\", () => {\n            // arrange\n            const arr = [1, 2, 3, 4, 5]\n            // act", "            const arr = [1, 2, 3, 4, 5]\n            // act\n            const actual = pipe(arr, Array.take(3))\n            // assert\n            expect(actual).toStrictEqual([1, 2, 3])\n        })\n\n        it(\"keeps all the itmes if the array is shorter\", () => {\n            // arrange\n            const arr = [1, 2]", "            // arrange\n            const arr = [1, 2]\n            // act\n            const actual = pipe(arr, Array.take(3))\n            // assert\n            expect(actual).toStrictEqual(arr)\n        })\n\n        it(\"returns empty if array is empty\", () => {\n            // act", "        it(\"returns empty if array is empty\", () => {\n            // act\n            const actual = pipe([], Array.take(3))\n            // assert\n            expect(actual).toStrictEqual([])\n        })\n\n        it.each([\n            [-1, []],\n            [3.22, [1, 2, 3]],", "            [-1, []],\n            [3.22, [1, 2, 3]],\n        ])(\"normalizes count to a natural number\", (count, expected) => {\n            // act\n            const actual = pipe([1, 2, 3, 4, 5], Array.take(count))\n            // assert\n            expect(actual).toStrictEqual(expected)\n        })\n    })\n", "    })\n\n    describe(\"skip\", () => {\n        it(\"returns all items after the skipped ones if the array is longer\", () => {\n            // arrange\n            const arr = [1, 2, 3, 4, 5]\n            // act\n            const actual = pipe(arr, Array.skip(3))\n            // asser\n            expect(actual).toStrictEqual([4, 5])", "            // asser\n            expect(actual).toStrictEqual([4, 5])\n        })\n\n        it(\"returns empty if skip count = array length\", () => {\n            // arrange\n            const arr = [1, 2, 3]\n            // act\n            const actual = pipe(arr, Array.skip(3))\n            // assert", "            const actual = pipe(arr, Array.skip(3))\n            // assert\n            expect(actual).toStrictEqual([])\n        })\n\n        it(\"returns empty if skip count > array length\", () => {\n            // arrange\n            const arr = [1, 2, 3]\n            // act\n            const actual = pipe(arr, Array.skip(4))", "            // act\n            const actual = pipe(arr, Array.skip(4))\n            // assert\n            expect(actual).toStrictEqual([])\n        })\n\n        it(\"returns empty if given empty\", () => {\n            // act\n            const actual = pipe([], Array.skip(3))\n            // assert", "            const actual = pipe([], Array.skip(3))\n            // assert\n            expect(actual).toStrictEqual([])\n        })\n\n        it.each([\n            [-1, [1, 2, 3, 4]],\n            [3.22, [4]],\n        ])(\"normalizes count to a natural number\", (count, expected) => {\n            // act", "        ])(\"normalizes count to a natural number\", (count, expected) => {\n            // act\n            const actual = pipe([1, 2, 3, 4], Array.skip(count))\n            // assert\n            expect(actual).toStrictEqual(expected)\n        })\n    })\n\n    describe(\"isEmpty\", () => {\n        it(\"returns true when the array is empty\", () => {", "    describe(\"isEmpty\", () => {\n        it(\"returns true when the array is empty\", () => {\n            expect(Array.isEmpty([])).toBe(true)\n        })\n\n        it(\"returns false when the array is not empty\", () => {\n            expect(Array.isEmpty([42])).toBe(false)\n        })\n    })\n", "    })\n\n    describe(\"isNonEmpty\", () => {\n        it.each([[[1]], [[1, 2]], [[1, 2, 3]]])(\n            \"returns true if the array contains at least one element (%i)\",\n            arr => {\n                expect(Array.isNonEmpty(arr)).toBe(true)\n            }\n        )\n", "        )\n\n        it(\"returns false if the array is empty\", () => {\n            expect(Array.isNonEmpty([])).toBe(false)\n        })\n    })\n\n    describe(\"bind\", () => {\n        it(\"flat maps\", () => {\n            // arrange", "        it(\"flat maps\", () => {\n            // arrange\n            const dupl = <A>(a: A) => [a, a] as const\n            const arr = [\"a\", \"b\", \"c\"]\n            // act\n            const actual = pipe(arr, Array.bind(dupl))\n            // assert\n            expect(actual).toStrictEqual([\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"])\n        })\n    })", "        })\n    })\n\n    describe(\"append\", () => {\n        it.each([\n            [[], [\"new\"]],\n            [[\"old\"], [\"old\", \"new\"]],\n        ])(\"adds an element to the end of an array (%i)\", (arr, expected) => {\n            expect(pipe(arr, Array.append(\"new\"))).toStrictEqual(expected)\n        })", "            expect(pipe(arr, Array.append(\"new\"))).toStrictEqual(expected)\n        })\n    })\n\n    describe(\"prepend\", () => {\n        it.each([\n            [[], [\"new\"]],\n            [[\"old\"], [\"new\", \"old\"]],\n        ])(\"adds an element at the beginning\", (arr, expected) => {\n            expect(pipe(arr, Array.prepend(\"new\"))).toStrictEqual(expected)", "        ])(\"adds an element at the beginning\", (arr, expected) => {\n            expect(pipe(arr, Array.prepend(\"new\"))).toStrictEqual(expected)\n        })\n    })\n\n    describe(\"groupBy\", () => {\n        it(\"returns an empty map given an empty array\", () => {\n            expect(Array.groupBy(globalThis.String)([])).toStrictEqual(new Map())\n        })\n", "        })\n\n        it(\"returns a map of grouped values for a non-empty array\", () => {\n            // arrange\n            const arr = [\"horse\", \"cow\", \"Cheese\", \"Hampster\", \"fox\"]\n            // act\n            const actual = pipe(\n                arr,\n                Array.groupBy(s => s.toLowerCase()[0])\n            )", "                Array.groupBy(s => s.toLowerCase()[0])\n            )\n            // assert\n            expect(actual).toStrictEqual(\n                new Map([\n                    [\"h\", [\"horse\", \"Hampster\"]],\n                    [\"c\", [\"cow\", \"Cheese\"]],\n                    [\"f\", [\"fox\"]],\n                ])\n            )", "                ])\n            )\n        })\n    })\n\n    describe(\"concat\", () => {\n        it(\"adds the new values at the end of the partially applied values\", () => {\n            expect(pipe([\"a\", \"b\"], Array.concat([\"c\", \"d\"]))).toStrictEqual([\n                \"a\",\n                \"b\",", "                \"a\",\n                \"b\",\n                \"c\",\n                \"d\",\n            ])\n        })\n\n        it(\"doesn't choke on empty arrays\", () => {\n            expect(pipe([], Array.concat([]))).toStrictEqual([])\n        })", "            expect(pipe([], Array.concat([]))).toStrictEqual([])\n        })\n    })\n\n    describe(\"concatFirst\", () => {\n        it(\"adds the new values at the beginning of the partially applied values\", () => {\n            expect(pipe([\"a\", \"b\"], Array.concatFirst([\"c\", \"d\"]))).toStrictEqual([\n                \"c\",\n                \"d\",\n                \"a\",", "                \"d\",\n                \"a\",\n                \"b\",\n            ])\n        })\n\n        it(\"doesn't choke on empty arrays\", () => {\n            expect(pipe([], Array.concatFirst([]))).toStrictEqual([])\n        })\n    })", "        })\n    })\n\n    describe(\"match\", () => {\n        it(\"can match with lambdas\", () => {\n            // arrange\n            const matcher = {\n                empty: () => 42,\n                nonEmpty: NonEmptyArray.head,\n            }", "                nonEmpty: NonEmptyArray.head,\n            }\n            // act\n            const actual1 = pipe([], Array.match(matcher))\n            const actual2 = pipe([23, 35], Array.match(matcher))\n            // assert\n            expect(actual1).toBe(42)\n            expect(actual2).toBe(23)\n        })\n", "        })\n\n        it(\"can match with raw values\", () => {\n            // arrange\n            const matcher = {\n                empty: 42,\n                nonEmpty: 24,\n            }\n            // act\n            const actual1 = pipe([], Array.match(matcher))", "            // act\n            const actual1 = pipe([], Array.match(matcher))\n            const actual2 = pipe([23, 35], Array.match(matcher))\n            // assert\n            expect(actual1).toBe(42)\n            expect(actual2).toBe(24)\n        })\n\n        it(\"can accepts nullish matcher values\", () => {\n            // arrange", "        it(\"can accepts nullish matcher values\", () => {\n            // arrange\n            const matcher = {\n                empty: null,\n                nonEmpty: undefined,\n            }\n            // act\n            const actual1 = pipe([], Array.match(matcher))\n            const actual2 = pipe([23, 35], Array.match(matcher))\n            // assert", "            const actual2 = pipe([23, 35], Array.match(matcher))\n            // assert\n            expect(actual1).toBe(null)\n            expect(actual2).toBe(undefined)\n        })\n    })\n\n    describe(\"head\", () => {\n        it(\"returns Some if non-empty\", () => {\n            expect(Array.head([1, 2])).toStrictEqual(Option.some(1))", "        it(\"returns Some if non-empty\", () => {\n            expect(Array.head([1, 2])).toStrictEqual(Option.some(1))\n        })\n\n        it(\"returns None if empty\", () => {\n            expect(Array.head([])).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"tail\", () => {", "\n    describe(\"tail\", () => {\n        it(\"returns `Some` with empty if array is singleton\", () => {\n            expect(Array.tail([1])).toStrictEqual(Option.some([]))\n        })\n\n        it(\"returns `Some` with the remaining elements if array.length > 1\", () => {\n            expect(Array.tail([1, 2, 3])).toStrictEqual(Option.some([2, 3]))\n        })\n", "        })\n\n        it(\"returns `None` if the array is empty\", () => {\n            expect(Array.tail([])).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"chunk\", () => {\n        it(\"returns empty for an empty array\", () => {\n            expect(Array.chunk(1)([])).toStrictEqual([])", "        it(\"returns empty for an empty array\", () => {\n            expect(Array.chunk(1)([])).toStrictEqual([])\n        })\n\n        it(\"returns even chunks if the array is evenly divisible by the chunk size\", () => {\n            expect(pipe([1, 2, 3, 4, 5, 6, 7, 8, 9], Array.chunk(3))).toStrictEqual([\n                [1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9],\n            ])", "                [7, 8, 9],\n            ])\n        })\n\n        it(\"returns uneven chunks if the array is not evenly divisible by the chunk size\", () => {\n            expect(pipe([\"a\", \"b\", \"c\", \"d\", \"e\"], Array.chunk(2))).toStrictEqual([\n                [\"a\", \"b\"],\n                [\"c\", \"d\"],\n                [\"e\"],\n            ])", "                [\"e\"],\n            ])\n        })\n\n        it(\"works for very large arrays when the array is evenly divisible by the chunk size\", () => {\n            // act\n            const actual = pipe(NonEmptyArray.range(1, 10_000), Array.chunk(40))\n            // assert\n            expect(actual).toHaveLength(250)\n            expect(actual.every(arr => arr.length === 40)).toBe(true)", "            expect(actual).toHaveLength(250)\n            expect(actual.every(arr => arr.length === 40)).toBe(true)\n        })\n\n        it(\"works for very large arrays when the array is not evenly divisible by the chunk size\", () => {\n            // act\n            const actual = pipe(NonEmptyArray.range(1, 11_111), Array.chunk(27))\n            // assert\n            expect(actual).toHaveLength(412)\n            expect(", "            expect(actual).toHaveLength(412)\n            expect(\n                actual.every(\n                    (arr, i) =>\n                        i === 411\n                            ? arr.length === 14 // the last chunk only has 14 elements\n                            : arr.length === 27 // all other chunks have exactly 27 elements\n                )\n            )\n        })", "            )\n        })\n\n        it.each([[-50], [0], [0.1442], [1.77]])(\n            \"normalizes the chunk size (%o) to a natural number\",\n            size => {\n                expect(pipe([1, 2, 3], Array.chunk(size))).toStrictEqual([[1], [2], [3]])\n            }\n        )\n", "        )\n\n        it.each([[1], [20], [100]])(\n            \"works for a singleton regardless of chunk size (%o)\",\n            size => {\n                expect(pipe([1], Array.chunk(size))).toStrictEqual([[1]])\n            }\n        )\n    })\n", "    })\n\n    describe(\"contains\", () => {\n        it(\"returns true if the element is in the array (using default === equality)\", () => {\n            expect(pipe([1, 2, 3, 4], Array.contains(2))).toBe(true)\n        })\n\n        it(\"returns false if the element is not in the array (using default === equality)\", () => {\n            expect(pipe([1, 2, 3, 4], Array.contains(5))).toBe(false)\n        })", "            expect(pipe([1, 2, 3, 4], Array.contains(5))).toBe(false)\n        })\n\n        it(\n            \"returns false if a structurally equivalent element is in the array, \" +\n                \"but is not reference equal (using default === equality)\",\n            () => {\n                // arrange\n                const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n                // act", "                const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n                // act\n                const actual = Array.contains({ name: \"john\" })(as)\n                // assert\n                expect(actual).toBe(false)\n            }\n        )\n\n        it(\"returns true if the element is in the array (using EqualityComparer)\", () => {\n            // arrange\n            type Person = { name: string }\n            const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n            const equalityComparer = {\n                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n                    name1 === name2,\n            }\n            // act\n            const actual = Array.contains({ name: \"smith\" }, equalityComparer)(as)\n            // assert\n            expect(actual).toBe(true)\n        })\n\n        it(\"returns false if the element is not in the array (using EqualityComparer)\", () => {\n            // arrange", "        it(\"returns true if the element is in the array (using EqualityComparer)\", () => {\n            // arrange\n            type Person = { name: string }\n            const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n            const equalityComparer = {\n                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n                    name1 === name2,\n            }\n            // act\n            const actual = Array.contains({ name: \"smith\" }, equalityComparer)(as)\n            // assert\n            expect(actual).toBe(true)\n        })\n\n        it(\"returns false if the element is not in the array (using EqualityComparer)\", () => {\n            // arrange", "            type Person = { name: string }\n            const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n            const equalityComparer = {\n                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n                    name1 === name2,\n            }\n            // act\n            const actual = Array.contains({ name: \"joe\" }, equalityComparer)(as)\n            // assert\n            expect(actual).toBe(false)\n        })\n    })\n\n    describe(\"length\", () => {\n        it.each([\n            [[], 0],\n            [[1, 2], 2],\n            [[\"a\", \"b\", \"c\", \"d\"], 4],\n        ])(\n            \"returns the length of the array\",\n            (arr: readonly (string | number)[], expected) => {\n                expect(Array.length(arr)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"uniq\", () => {\n        it(\"returns empty for an empty array\", () => {\n            expect(Array.uniq()([])).toStrictEqual([])\n        })\n\n        it(\"returns unique values (using default triple equals equality)\", () => {\n            expect(\n                pipe(\n                    [\"a\", \"b\", \"b\", \"a\", \"c\", \"d\", \"e\", \"e\", \"e\", \"a\", \"z\"],\n                    Array.uniq()\n                )\n            ).toStrictEqual([\"a\", \"b\", \"c\", \"d\", \"e\", \"z\"])\n        })\n\n        it(\"does not work for objects without an equality comparer\", () => {\n            expect(\n                pipe(\n                    [{ name: \"John\" }, { name: \"John\" }, { name: \"Larry\" }],\n                    Array.uniq()\n                )\n            ).toStrictEqual([{ name: \"John\" }, { name: \"John\" }, { name: \"Larry\" }])\n        })\n\n        it(\"returns uniq elements using the equality comparer if given\", () => {\n            // arrange", "            type Person = { name: string }\n            const people = [\n                { name: \"John\" },\n                { name: \"John\" },\n                { name: \"Larry\" },\n                { name: \"Jeff\" },\n                { name: \"Larry\" },\n            ]\n\n            const equalityComparer = {\n                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n                    name1 === name2,\n            }\n            // act\n            const actual = Array.uniq(equalityComparer)(people)\n            // assert\n            expect(actual).toStrictEqual([\n                { name: \"John\" },\n                { name: \"Larry\" },\n                { name: \"Jeff\" },\n            ])\n        })\n    })\n\n    describe(\"uniqBy\", () => {\n        it(\"returns empty for an empty array\", () => {\n            expect(Array.uniqBy((n: number) => n * 1)([])).toStrictEqual([])\n        })\n\n        it(\"returns un-projected unique values based on the projected values (using default triple equals equality)\", () => {\n            expect(\n                pipe(\n                    [\"a\", \"b\", \"b\", \"a\", \"c\", \"d\", \"e\", \"e\", \"e\", \"a\", \"z\"],\n                    Array.uniqBy(String.toUpperCase)\n                )\n            ).toStrictEqual([\"a\", \"b\", \"c\", \"d\", \"e\", \"z\"])\n        })\n\n        it(\"does not work for projected objects without an equality comparer\", () => {\n            expect(\n                pipe(\n                    [\n                        { name: { first: \"John\" } },\n                        { name: { first: \"John\" } },\n                        { name: { first: \"Larry\" } },\n                    ],\n                    Array.uniqBy(p => p.name)\n                )\n            ).toStrictEqual([\n                { name: { first: \"John\" } },\n                { name: { first: \"John\" } },\n                { name: { first: \"Larry\" } },\n            ])\n        })\n\n        it(\"returns unique un-projected elements using the equality comparer against the projected elements if given\", () => {\n            // arrange", "            type Person = { name: { first: string } }\n            const people: Person[] = [\n                { name: { first: \"John\" } },\n                { name: { first: \"John\" } },\n                { name: { first: \"Larry\" } },\n                { name: { first: \"Jeff\" } },\n                { name: { first: \"Larry\" } },\n            ]\n\n            const equalityComparer = {\n                equals: (n1: { first: string }, n2: { first: string }) =>\n                    n1.first === n2.first,\n            }\n            // act\n            const actual = pipe(\n                people,\n                Array.uniqBy(p => p.name, equalityComparer)\n            )\n            // assert\n            expect(actual).toStrictEqual([\n                { name: { first: \"John\" } },\n                { name: { first: \"Larry\" } },\n                { name: { first: \"Jeff\" } },\n            ])\n        })\n    })\n\n    describe(\"find\", () => {\n        it(\"returns Some(first elem) if the element exists\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4, 5],\n                    Array.find(n => n % 2 === 0)\n                )\n            ).toStrictEqual(Option.some(2))\n        })\n\n        it(\"returns None if the element does not exist\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4, 5],\n                    Array.find(n => n < 0)\n                )\n            ).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"findIndex\", () => {\n        it(\"returns Some(first index) if the element exists\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4, 5],\n                    Array.findIndex(n => n % 2 === 0)\n                )\n            ).toStrictEqual(Option.some(1))\n        })\n\n        it(\"returns None if the element does not exist\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4, 5],\n                    Array.find(n => n < 0)\n                )\n            ).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"reverse\", () => {\n        it(\"returns a new, reversed array\", () => {\n            // arrange\n            const arr = [\"a\", \"b\", \"c\", \"d\"]\n            // act\n            const actual = Array.reverse(arr)\n            // assert\n            expect(actual).toStrictEqual([\"d\", \"c\", \"b\", \"a\"])\n            expect(actual).not.toBe(arr)\n        })\n    })\n\n    describe(\"exists\", () => {\n        it(\"returns true if an element satisfies the predicate\", () => {\n            expect(\n                pipe(\n                    [1, 5, 10, 15],\n                    Array.exists(n => n > 10)\n                )\n            ).toBe(true)\n        })\n\n        it(\"returns false if no element satisfies the predicate\", () => {\n            expect(\n                pipe(\n                    [1, 5, 10, 15],\n                    Array.exists(n => n < 1)\n                )\n            ).toBe(false)\n        })\n    })\n\n    describe(\"flatten\", () => {\n        it(\"flattens a nested array\", () => {\n            expect(pipe([[1, 2], [3, 4], [5], [6], []], Array.flatten)).toStrictEqual([\n                1, 2, 3, 4, 5, 6,\n            ])\n        })\n    })\n\n    describe(\"sort\", () => {\n        it(\"returns empty for an empty array\", () => {\n            expect(Array.sort()([])).toStrictEqual([])\n        })\n\n        it(\"sorts an array using default ASCII sort order if no comparer is given\", () => {\n            expect(\n                pipe([\"Beto\", \"Alfred\", \"Drake\", \"Jimbo\"], Array.sort())\n            ).toStrictEqual([\"Alfred\", \"Beto\", \"Drake\", \"Jimbo\"])\n        })\n\n        it(\"sorts an array using the custom comparer if one is given\", () => {\n            const descNumberOrd: OrderingComparer<number> = {\n                compare(n1: number, n2: number) {\n                    return n1 === n2 ? 0 : n1 < n2 ? 1 : -1\n                },\n            }\n\n            expect(pipe([33, 22, 78], Array.sort(descNumberOrd))).toStrictEqual([\n                78, 33, 22,\n            ])\n        })\n    })\n\n    describe(\"sortBy\", () => {\n        it(\"returns empty for empty array\", () => {\n            expect(Array.sortBy((n: number) => n.toString())([])).toStrictEqual([])\n        })\n\n        it(\"sorts an array using the projected values, using default comparison\", () => {\n            expect(\n                pipe(\n                    [\n                        { name: \"Rex\" },\n                        { name: \"Fido\" },\n                        { name: \"Gerald\" },\n                        { name: \"Albus\" },\n                    ],\n                    Array.sortBy(pet => pet.name)\n                )\n            ).toStrictEqual([\n                { name: \"Albus\" },\n                { name: \"Fido\" },\n                { name: \"Gerald\" },\n                { name: \"Rex\" },\n            ])\n        })\n\n        it(\"sorts an array using the projected values, using the given comparer if provided\", () => {\n            const descNumberOrd: OrderingComparer<number> = {\n                compare(n1, n2) {\n                    return n1 === n2 ? 0 : n1 < n2 ? 1 : -1\n                },\n            }\n\n            expect(\n                pipe(\n                    [{ age: 16 }, { age: 2 }, { age: 8 }, { age: 9 }],\n                    Array.sortBy(pet => pet.age, descNumberOrd)\n                )\n            ).toStrictEqual([{ age: 16 }, { age: 9 }, { age: 8 }, { age: 2 }])\n        })\n    })\n\n    describe(\"except\", () => {\n        it(\"returns empty if the given array is empty\", () => {\n            expect(pipe([], Array.except([1, 2, 3]))).toStrictEqual([])\n        })\n\n        it(\"returns the given array if the excludeThese array is empty\", () => {\n            expect(pipe([1, 2, 3], Array.except<number>([]))).toStrictEqual([1, 2, 3])\n        })\n\n        it(\"returns an array with excluded elements\", () => {\n            expect(\n                pipe([1, 3, 3, 5, 6, 7, 9, 11], Array.except([5, 9, 11, 9]))\n            ).toStrictEqual([1, 3, 3, 6, 7])\n        })\n    })\n\n    describe(\"union\", () => {\n        it(\"returns empty if both arrays are empty\", () => {\n            expect(pipe([], Array.union([]))).toStrictEqual([])\n        })\n\n        it(\"returns the set union of two populated arrays, using default equality\", () => {\n            expect(\n                pipe([1, 2, 7, 8, 8, 14], Array.union([3, 2, 8, 14, 5]))\n            ).toStrictEqual([1, 2, 7, 8, 14, 3, 5])\n        })\n\n        it(\"uses the equality comparer if given\", () => {\n            const petEq = {\n                equals(\n                    { name: name1 }: { name: string },\n                    { name: name2 }: { name: string }\n                ) {\n                    return name1 === name2\n                },\n            }\n            expect(\n                pipe(\n                    [\n                        { name: \"Fido\" },\n                        { name: \"Rufus\" },\n                        { name: \"Rufus\" },\n                        { name: \"Albus\" },\n                    ],\n                    Array.union(\n                        [\n                            { name: \"Johan\" },\n                            { name: \"Rufus\" },\n                            { name: \"Albus\" },\n                            { name: \"Scrappy\" },\n                        ],\n                        petEq\n                    )\n                )\n            ).toStrictEqual([\n                { name: \"Fido\" },\n                { name: \"Rufus\" },\n                { name: \"Albus\" },\n                { name: \"Johan\" },\n                { name: \"Scrappy\" },\n            ])\n        })\n    })\n\n    describe(\"filter\", () => {\n        it(\"filters\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4, 5, 6, 7, 8, 9],\n                    Array.filter(n => n % 2 === 0)\n                )\n            ).toStrictEqual([2, 4, 6, 8])\n        })\n    })\n\n    describe(\"filteri\", () => {\n        it(\"filters with index\", () => {\n            expect(\n                pipe(\n                    [2, 1, 3, 4, 5, 7, 6, 8, 9, 10],\n                    Array.filteri((n, i) => n % 2 !== 0 && i % 2 === 0)\n                )\n            ).toStrictEqual([3, 5, 9])\n        })\n    })\n\n    describe(\"map\", () => {\n        it(\"maps\", () => {\n            expect(\n                pipe([\"a\", \"ab\", \"abc\", \"abcd\"], Array.map(String.length))\n            ).toStrictEqual([1, 2, 3, 4])\n        })\n    })\n\n    describe(\"mapi\", () => {\n        it(\"maps with index\", () => {\n            expect(\n                pipe(\n                    [\"a\", \"ab\", \"abc\", \"abcd\"],\n                    Array.mapi((s, i) => s.length + i)\n                )\n            ).toStrictEqual([1, 3, 5, 7])\n        })\n    })\n\n    describe(\"reduce\", () => {\n        it(\"reduces\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4, 5],\n                    Array.reduce(0, (a, b) => a + b)\n                )\n            ).toBe(15)\n        })\n    })\n\n    describe(\"reduceRight\", () => {\n        it(\"reduces from the right\", () => {\n            expect(\n                pipe(\n                    [\"a\", \"b\", \"c\", \"d\"],\n                    Array.reduceRight(\"\", (a, b) => `${a}${b}`)\n                )\n            ).toBe(\"dcba\")\n        })\n    })\n\n    describe(\"getEqualityComparer\", () => {\n        it(\"always returns true if the arrays are both empty\", () => {\n            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([], [])).toBe(true)\n        })\n\n        it(\"always returns false if the arrays are different lengths\", () => {\n            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([1, 2, 3], [1, 2])).toBe(false)\n        })\n\n        it(\"returns false if the arrays are not equal element-by-element\", () => {\n            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([1, 2, 3], [1, 3, 2])).toBe(false)\n        })\n\n        it(\"returns true if the arrays are equal element-by-element\", () => {\n            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([1, 2, 3], [1, 2, 3])).toBe(true)\n        })\n    })\n\n    describe(\"iter\", () => {", "        it(\"executes a function for each element of the array\", () => {\n            const sideEffect = vi.fn<[], void>()\n            pipe(NonEmptyArray.range(1, 5), Array.iter(sideEffect))\n            expect(sideEffect).toHaveBeenCalledTimes(5)\n            NonEmptyArray.range(1, 5).forEach(n => {\n                expect(sideEffect).toHaveBeenCalledWith(n)\n            })\n        })\n    })\n})\n"]}
{"filename": "test/Option.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport * as Option from \"../src/Option\"\nimport { pipe } from \"../src/Composition\"\nimport { EqualityComparer } from \"../src/EqualityComparer\"\nimport { NonNullish } from \"../src/prelude\"\n\ntype Option<A extends NonNullish> = Option.Option<A>\n\ndescribe(\"Option\", () => {\n    describe(\"constructors\", () => {\n        describe(\"Some\", () => {\n            it(\"creates a new Some instance\", () => {\n                expect(Option.some(42)).toStrictEqual({\n                    _tag: \"Some\",\n                    some: 42,\n                })\n            })\n        })\n\n        describe(\"None\", () => {\n            it(\"creates a new None instance\", () => {\n                expect(Option.none).toStrictEqual({\n                    _tag: \"None\",\n                })\n            })\n        })\n    })\n\n    describe(\"ofNullish\", () => {\n        it.each([[null], [undefined]])(\"converts nullish values (%o) to None\", inp => {\n            expect(Option.ofNullish(inp)).toStrictEqual(Option.none)\n        })\n\n        it.each([\n            [0, Option.some(0)],\n            [42, Option.some(42)],\n            [\"\", Option.some(\"\")],\n            [\"cheese\", Option.some(\"cheese\")],\n            [[], Option.some([])],\n            [[1], Option.some([1])],\n        ])(\"converts non-nullish values (%o) to Some\", (inp, expected) => {\n            expect(Option.ofNullish(inp)).toStrictEqual(expected)\n        })\n    })\n\n    describe(\"toNullish\", () => {\n        it.each([\n            [undefined, null],\n            [false, undefined],\n            [true, null],\n        ])(\"converts None to a nullish value (useNull = %o)\", (useNull, expected) => {\n            expect(Option.toNullish(Option.none, useNull)).toBe(expected)\n        })\n\n        it.each([\n            [0, Option.some(0)],\n            [42, Option.some(42)],\n            [\"\", Option.some(\"\")],\n            [\"cheese\", Option.some(\"cheese\")],\n            [[], Option.some([])],\n            [[1], Option.some([1])],\n        ])(\"converts Some to a raw value (%o)\", (expected, inp) => {\n            expect(Option.toNullish<NonNullish>(inp)).toStrictEqual(expected)\n        })\n    })\n\n    describe(\"isSome\", () => {\n        it(\"returns true for Some\", () => {\n            expect(Option.isSome(Option.some(1))).toBe(true)\n        })\n\n        it(\"returns false for None\", () => {\n            expect(Option.isSome(Option.none)).toBe(false)\n        })\n    })\n\n    describe(\"isNone\", () => {\n        it(\"returns true for None\", () => {\n            expect(Option.isNone(Option.none)).toBe(true)\n        })\n\n        it(\"returns false for Some\", () => {\n            expect(Option.isNone(Option.some(1))).toBe(false)\n        })\n    })\n\n    describe(\"map\", () => {\n        it(\"returns a Some with projected inner value if Some\", () => {\n            const incr = (n: number) => n + 1\n            expect(pipe(Option.some(22), Option.map(incr))).toStrictEqual(Option.some(23))\n        })\n\n        it(\"returns None if given None\", () => {\n            const incr = (n: number) => n + 1\n            expect(pipe(Option.none, Option.map(incr))).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"map2\", () => {\n        it(\"returns the projected value if both Options are Some\", () => {\n            // arrange\n            const add = (a: number, b: number) => a + b\n            // act\n            const actual = pipe([Option.some(2), Option.some(3)], Option.map2(add))\n            // assert\n            expect(actual).toStrictEqual(Option.some(5))\n        })\n\n        it.each([\n            [[Option.none, Option.none]],\n            [[Option.some(2), Option.none]],\n            [[Option.none, Option.some(3)]],\n        ] as const)(\"returns None if either/both of the Options are None\", options => {\n            // arrange\n            const add = (a: number, b: number) => a + b\n            // act\n            const actual = pipe(options, Option.map2(add))\n            // assert\n            expect(actual).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"map3\", () => {\n        it(\"returns the projected value if all 3 Options are Some\", () => {\n            // arrange\n            const add = (a: number, b: number, c: number) => a + b + c\n            // act\n            const actual = pipe(\n                [Option.some(2), Option.some(3), Option.some(4)],\n                Option.map3(add)\n            )\n            // assert\n            expect(actual).toStrictEqual(Option.some(9))\n        })\n\n        it.each([\n            [[Option.none, Option.none, Option.none]],\n            [[Option.some(2), Option.none, Option.none]],\n            [[Option.none, Option.some(3), Option.none]],\n            [[Option.none, Option.none, Option.some(3)]],\n            [[Option.none, Option.some(3), Option.some(3)]],\n            [[Option.some(3), Option.some(3), Option.none]],\n        ] as const)(\n            \"returns None if any one of the Options is None\",\n            (options: readonly [Option<number>, Option<number>, Option<number>]) => {\n                // arrange\n                const add = (a: number, b: number) => a + b\n                // act\n                const actual = pipe(options, Option.map3(add))\n                // assert\n                expect(actual).toStrictEqual(Option.none)\n            }\n        )\n    })\n\n    describe(\"bind\", () => {\n        it(\"returns Some if the given Option is Some and the projection returns Some\", () => {\n            // arrange\n            const appendS = (s: string) => Option.some(`${s}S`)\n            // act\n            const actual = pipe(Option.some(\"cheese\"), Option.bind(appendS))\n            // assert\n            expect(actual).toStrictEqual(Option.some(\"cheeseS\"))\n        })\n\n        it(\"returns None if the given Option is Some but the projection returns None\", () => {\n            // arrange\n            const alwaysNone = () => Option.none\n            // act\n            const actual = pipe(Option.some(\"cheese\"), Option.bind(alwaysNone))\n            // assert\n            expect(actual).toStrictEqual(Option.none)\n        })\n\n        it(\"returns None if the given Option is None, regardless of the projection\", () => {\n            // arrange\n            const alwaysSome = () => Option.some(\"cheese\")\n            // act\n            const actual = pipe(Option.none, Option.bind(alwaysSome))\n            // assert\n            expect(actual).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"defaultValue\", () => {\n        it(\"returns the wrapped value if the Option is Some\", () => {\n            const actual = pipe(Option.some(33), Option.defaultValue(1))\n            expect(actual).toBe(33)\n        })\n\n        it(\"returns the default value if the Option is None\", () => {\n            const actual = pipe(Option.none, Option.defaultValue(1))\n            expect(actual).toBe(1)\n        })\n    })\n\n    describe(\"defaultWith\", () => {\n        it(\"returns the wrapped value if the Option is Some\", () => {\n            const fallbackFn = vi.fn(() => \"default\")\n            const actual = pipe(Option.some(\"cheese\"), Option.defaultWith(fallbackFn))\n            expect(actual).toBe(\"cheese\")\n            expect(fallbackFn).not.toHaveBeenCalled()\n        })\n\n        it(\"returns the default lambda result if the Option is None\", () => {\n            const actual = pipe(\n                Option.none,\n                Option.defaultWith(() => \"default\")\n            )\n            expect(actual).toBe(\"default\")\n        })\n    })\n\n    describe(\"match\", () => {\n        it.each([\n            [Option.some(\"cheese\"), \"cheese!\"],\n            [Option.none, \"!\"],\n        ])(\"can match with lambdas\", (inp, expected) => {\n            // arrange\n            const exclaim = (s: string) => `${s}!`\n\n            const matcher = {\n                some: exclaim,\n                none: () => \"!\",\n            }\n            // act\n            const actual = pipe(inp, Option.match(matcher))\n            // assert\n            expect(actual).toBe(expected)\n        })\n\n        it.each([\n            [Option.some(\"cheese\"), \"cheese!\"],\n            [Option.none, \"!\"],\n        ])(\"can match with raw values\", (inp, expected) => {\n            // arrange\n            const matcher = {\n                some: \"cheese!\",\n                none: \"!\",\n            }\n            // act\n            const actual = pipe(inp, Option.match(matcher))\n            // assert\n            expect(actual).toBe(expected)\n        })\n\n        it.each([\n            [Option.some(22), undefined],\n            [Option.none, 0],\n        ])(\"allows falsy values as matcher values\", (inp, expected) => {\n            // arrange\n            const matcher = {\n                some: undefined,\n                none: 0,\n            }\n            // act\n            const actual = pipe(inp as Option<number>, Option.match(matcher))\n            // assert\n            expect(actual).toBe(expected)\n        })\n    })\n\n    describe(\"filter\", () => {\n        it(\"returns Some if the predicate holds\", () => {\n            expect(\n                pipe(\n                    Option.some(\"cheese\"),\n                    Option.filter(s => s.length < 10)\n                )\n            ).toStrictEqual(Option.some(\"cheese\"))\n        })\n\n        it(\"returns None if the predicate does not hold\", () => {\n            expect(\n                pipe(\n                    Option.some(\"cheese\"),\n                    Option.filter(s => s.length > 10)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns None if given None\", () => {\n            expect(\n                pipe(\n                    Option.none,\n                    Option.filter((s: string) => s.length > 10)\n                )\n            ).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"refine\", () => {", "        it(\"returns Some if the type guard holds\", () => {\n            expect(\n                pipe(\n                    Option.some(\"cheese\"),\n                    Option.refine((s): s is \"cheese\" => s === \"cheese\")\n                )\n            ).toStrictEqual(Option.some(\"cheese\"))\n        })\n\n        it(\"returns None if the predicate does not hold\", () => {\n            expect(\n                pipe(\n                    Option.some(\"cheese\"),\n                    Option.refine((s): s is \"nope\" => s === \"nope\")\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns None if given None\", () => {\n            expect(\n                pipe(\n                    Option.none,\n                    Option.refine((s: string): s is \"cheese\" => s === \"cheese\")\n                )\n            ).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"tryCatch\", () => {", "        it(\"returns Some when function succeeds\", () => {\n            // arrange\n            const f = () => 42\n            // act\n            const actual = Option.tryCatch(f)\n            // assert\n            expect(actual).toStrictEqual(Option.some(42))\n        })\n\n        it(\"returns None when function throws\", () => {\n            // arrange\n            const f = () => {\n                throw new Error(\"\")\n            }\n            // act\n            const actual = Option.tryCatch(f)\n            // assert\n            expect(actual).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"getEqualityComparer\", () => {\n        it.each([\n            [true, \"both are Somes and are equal\", Option.some(1), Option.some(1)],\n            [false, \"both are Somes but are not equal\", Option.some(1), Option.some(2)],\n            [false, \"one is a Some and one is a None\", Option.some(1), Option.none],\n            [false, \"one is a None and one is an Some\", Option.none, Option.some(1)],\n            [true, \"both are Nones\", Option.none, Option.none],\n        ])(\n            \"gets an equality comparer that returns %o when %s\",\n            (expected, _, result1, result2) => {\n                const { equals } = Option.getEqualityComparer(EqualityComparer.Number)\n\n                expect(equals(result1, result2)).toBe(equals(result2, result1))\n                expect(equals(result1, result2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"tee\", () => {\n        it(\"executes a side effect against Some\", () => {\n            const log = vi.fn<[], void>()\n            const actual = pipe(\n                Option.some(32),\n                Option.tee(log),\n                Option.map(n => n * 2)\n            )\n            expect(actual).toStrictEqual(Option.some(64))\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(32)\n        })\n\n        it(\"does not execute a side effect against None\", () => {\n            const log = vi.fn<[], void>()\n            const actual = pipe(\n                Option.none,\n                Option.tee(log),\n                Option.map((n: number) => n * 2)\n            )\n            expect(actual).toBe(Option.none)\n            expect(log).not.toHaveBeenCalled()\n        })\n    })\n})\n", "        it(\"returns None when function throws\", () => {\n            // arrange\n            const f = () => {\n                throw new Error(\"\")\n            }\n            // act\n            const actual = Option.tryCatch(f)\n            // assert\n            expect(actual).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"getEqualityComparer\", () => {\n        it.each([\n            [true, \"both are Somes and are equal\", Option.some(1), Option.some(1)],\n            [false, \"both are Somes but are not equal\", Option.some(1), Option.some(2)],\n            [false, \"one is a Some and one is a None\", Option.some(1), Option.none],\n            [false, \"one is a None and one is an Some\", Option.none, Option.some(1)],\n            [true, \"both are Nones\", Option.none, Option.none],\n        ])(\n            \"gets an equality comparer that returns %o when %s\",\n            (expected, _, result1, result2) => {\n                const { equals } = Option.getEqualityComparer(EqualityComparer.Number)\n\n                expect(equals(result1, result2)).toBe(equals(result2, result1))\n                expect(equals(result1, result2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"tee\", () => {\n        it(\"executes a side effect against Some\", () => {\n            const log = vi.fn<[], void>()\n            const actual = pipe(\n                Option.some(32),\n                Option.tee(log),\n                Option.map(n => n * 2)\n            )\n            expect(actual).toStrictEqual(Option.some(64))\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(32)\n        })\n\n        it(\"does not execute a side effect against None\", () => {\n            const log = vi.fn<[], void>()\n            const actual = pipe(\n                Option.none,\n                Option.tee(log),\n                Option.map((n: number) => n * 2)\n            )\n            expect(actual).toBe(Option.none)\n            expect(log).not.toHaveBeenCalled()\n        })\n    })\n})\n"]}
{"filename": "test/Enums.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport { enumOf, EnumOf } from \"../src/Enums\"\nimport { Result } from \"../src/Result\"\n\nconst Cheese = enumOf(\n    {\n        Gouda: \"Gouda\",\n        Muenster: \"Muenster\",\n        Parmesean: \"Parmesean\",\n    } as const,", "        Parmesean: \"Parmesean\",\n    } as const,\n    \"Cheese\"\n)\ntype Cheese = EnumOf<typeof Cheese>\n\nconst LogLevel = enumOf(\n    {\n        TRACE: 0,\n        DEBUG: 1,\n        CRAZY_PILLS: \"over 9000\",\n    } as const,\n    \"LogLevel\"\n)", "type LogLevel = EnumOf<typeof LogLevel>\n\ndescribe(\"enumOf module\", () => {\n    describe(\"value accessors\", () => {\n        it(\"preserves simple named value access\", () => {\n            expect(Cheese.Gouda).toBe(\"Gouda\")\n            expect(Cheese.Muenster).toBe(\"Muenster\")\n            expect(Cheese.Parmesean).toBe(\"Parmesean\")\n            expect(LogLevel.TRACE).toBe(0)\n            expect(LogLevel.DEBUG).toBe(1)\n            expect(LogLevel.CRAZY_PILLS).toBe(\"over 9000\")\n        })\n    })\n\n    describe(\"values array\", () => {", "        it(\"automatically produces a values property with all possible enum values\", () => {\n            expect(Cheese.values).toStrictEqual([\"Gouda\", \"Muenster\", \"Parmesean\"])\n            expect(LogLevel.values).toStrictEqual([0, 1, \"over 9000\"])\n        })\n    })\n\n    describe(\"parse\", () => {\n        it.each([\n            [\"muenster \", Cheese.Muenster],\n            [\"GOUDA\", Cheese.Gouda],\n            [\"  gOuDa \", Cheese.Gouda],\n            [\"Muenster\", Cheese.Muenster],\n        ])(\n            \"decodes valid input %s -> %s regardless of case or surrounding whitespace\",\n            (input, expected) => {\n                expect(Cheese.parse(input)).toStrictEqual(Result.ok(expected))\n            }\n        )\n\n        it.each([[\"i am 12\"], [\"swiss\"], [\"Mue- n-ster\"]])(\n            \"fails invalid input: %s\",\n            input => {\n                expect(Cheese.parse(input)).toStrictEqual(\n                    Result.err(\n                        expect.stringMatching(", "                            /Must be an enum value in the set Cheese{.*}/\n                        )\n                    )\n                )\n            }\n        )\n\n        it.each([[null], [undefined]])(\"fails for nullish input %o\", input => {\n            expect(Cheese.parse(input)).toStrictEqual(\n                Result.err(\"Enum Cheese cannot be null/undefined\")\n            )\n        })\n\n        it.each([\n            [{ name: \"cheese\" }],\n            [\n                () => {\n                    return\n                },\n            ],\n        ])(\"fails for inputs of an incorrect type\", input => {\n            expect(Cheese.parse(input)).toStrictEqual(\n                Result.err(\"Enum Cheese must be a string or number\")\n            )\n        })\n    })\n\n    describe(\"match\", () => {\n        it.each([\n            [0, \"trace!\"],\n            [1, \"debug!\"],\n            [\"over 9000\", \"you're on crazy pills!\"],\n        ] as const)(\"it matches inputs (%o -> %s)\", (input, expected) => {\n            // arrange\n            const matcher = {\n                TRACE: \"trace!\",\n                DEBUG: () => \"debug!\",\n                CRAZY_PILLS() {\n                    return \"you're on crazy pills!\"\n                },\n            }\n            // act\n            const actual = LogLevel.match(matcher)(input)\n            // assert\n            expect(actual).toBe(expected)\n        })\n\n        it.each([\n            [LogLevel.TRACE, null],\n            [LogLevel.DEBUG, undefined],\n            [LogLevel.CRAZY_PILLS, 0],\n        ])(\n            \"allows specifying null/undefined/falsy values in the matcher branches\",\n            (input, expected) => {\n                // arrange\n                const matcher = {\n                    TRACE: null,\n                    DEBUG: undefined,\n                    CRAZY_PILLS: 0,\n                }\n                // act\n                const actual = LogLevel.match(matcher)(input)\n                // assert\n                expect(actual).toBe(expected)\n            }\n        )\n\n        it(\"throws a helpful error message if the matcher is missing a required case (if someone ignores compiler errors)\", () => {\n            // arrange\n            const matcher = {\n                DEBUG: () => \"debug!\",\n                CRAZY_PILLS() {\n                    return `you're on crazy pills!`\n                },\n            }\n            // act & assert\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n            expect(() => LogLevel.match(matcher as any)(0)).toThrow(\n                `Expected a matcher containing a case for 'TRACE'.`\n            )\n        })\n", "        it(\"throws a helpful error message if the matcher gets passed an invalid enum value (if someone ignores compiler errors)\", () => {\n            // arrange\n            const matcher = {\n                TRACE: \"trace!\",\n                DEBUG: () => \"debug!\",\n                CRAZY_PILLS() {\n                    return \"you're on crazy pills!\"\n                },\n            }\n            // act & assert\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n            expect(() => LogLevel.match(matcher)(2 as any)).toThrow(", "                `Expected to match against an enum where '2' is a valid value.`\n            )\n        })\n    })\n\n    describe(\"matchOrElse\", () => {\n        it.each([\n            [0, \"trace!\"],\n            [1, \"unmatched\"],\n            [\"over 9000\", \"you're on crazy pills!\"],\n        ] as const)(\"it matches inputs (%o -> %s)\", (input, expected) => {\n            // arrange\n            const matcher = {\n                TRACE: \"trace!\",\n                CRAZY_PILLS() {\n                    return \"you're on crazy pills!\"\n                },\n                orElse: \"unmatched\",\n            }\n            // act\n            const actual = LogLevel.matchOrElse(matcher)(input)\n            // assert\n            expect(actual).toBe(expected)\n        })\n\n        it.each([\n            [Cheese.Gouda, null],\n            [Cheese.Muenster, undefined],\n            [Cheese.Parmesean, \"\"],\n        ])(\n            \"allows specifying null/undefined/falsy values in the matcher branches\",\n            (input, expected) => {\n                // arrange\n                const matcher = {\n                    Gouda: null,\n                    Muenster: undefined,\n                    Parmesean: \"\",\n                    orElse: \"\",\n                }\n                // act\n                const actual = Cheese.matchOrElse(matcher)(input)\n                // assert\n                expect(actual).toBe(expected)\n            }\n        )\n", "        it(\"throws a helpful error message if the matcher gets passed an invalid enum value (somehow?)\", () => {\n            // arrange\n            const matcher = {\n                TRACE: \"trace!\",\n                DEBUG: () => \"debug!\",\n                CRAZY_PILLS() {\n                    return \"you're on crazy pills!\"\n                },\n                orElse: () => \"unmatched\",\n            }\n            // act & assert\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n            expect(() => LogLevel.matchOrElse(matcher)(2 as any)).toThrow(", "                `Expected to match against an enum where '2' is a valid value.`\n            )\n        })\n    })\n})\n"]}
{"filename": "test/OrderingComparer.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport * as OrderingComparer from \"../src/OrderingComparer\"\n\ninterface Person {\n    readonly name: string\n}\n\ninterface Cat {\n    readonly name: string\n    readonly age: number\n    readonly livesRemaining: number\n}\n\ndescribe(\"OrderingComparer\", () => {\n    describe(\"ofCompare\", () => {\n        it(\"costructs a new OrderingComparer from a compare function\", () => {\n            const { compare } = OrderingComparer.ofCompare<number>(\n                (n1, n2) => (n1 === n2 ? 0 : n1 > n2 ? -1 : 1) // numbers in desc order\n            )\n            expect(compare(5, 5)).toBe(0)\n            expect(compare(6, 5)).toBe(-1)\n            expect(compare(5, 6)).toBe(1)\n            expect(compare(100, 0)).toBe(-1)\n            expect(compare(0, 100)).toBe(1)\n        })\n    })\n\n    describe(\"Number\", () => {\n        it(\"sorts numbers in ascending order\", () => {\n            const { compare } = OrderingComparer.Number\n\n            const shuffledNumbers = [-11, -13, 2, 0, 45, 1, 8, 2, 100, -1]\n\n            expect(shuffledNumbers.slice(0).sort(compare)).toStrictEqual([\n                -13, -11, -1, 0, 1, 2, 2, 8, 45, 100,\n            ])\n        })\n    })\n\n    describe(\"reverse\", () => {\n        it(\"reverses the sort order\", () => {\n            const { compare } = OrderingComparer.reverse(OrderingComparer.Number)\n\n            const shuffledNumbers = [-11, -13, 2, 0, 45, 1, 8, 2, 100, -1]\n\n            expect(shuffledNumbers.slice(0).sort(compare)).toStrictEqual([\n                100, 45, 8, 2, 2, 1, 0, -1, -11, -13,\n            ])\n        })\n    })\n\n    describe(\"deriveFrom\", () => {\n        it(\"can use an existing OrderingComparer to make a new one with a map function\", () => {\n            const { compare } = OrderingComparer.deriveFrom<string, Person>(\n                OrderingComparer.String,\n                p => p.name\n            )\n\n            const unsortedPeople = [\n                { name: \"Johnny\" },\n                { name: \"Larry\" },\n                { name: \"Amy\" },\n                { name: \"Kevin\" },\n            ]\n\n            expect(unsortedPeople.slice(0).sort(compare)).toStrictEqual([\n                { name: \"Amy\" },\n                { name: \"Johnny\" },\n                { name: \"Kevin\" },\n                { name: \"Larry\" },\n            ])\n        })\n    })\n\n    describe(\"getComposite\", () => {\n        it(\"applies multiple OrderingComparers in a 'and then by,' 'and then by,' fashion\", () => {\n            // arrange\n            const byName = OrderingComparer.deriveFrom<string, Cat>(\n                OrderingComparer.String,\n                c => c.name\n            )\n            const byAge = OrderingComparer.deriveFrom<number, Cat>(\n                OrderingComparer.Number,\n                c => c.age\n            )\n            const byLivesRemainingDesc = OrderingComparer.deriveFrom<number, Cat>(\n                OrderingComparer.reverse(OrderingComparer.Number),\n                c => c.livesRemaining\n            )\n\n            const { compare } = OrderingComparer.getComposite(\n                byName,\n                byAge,\n                byLivesRemainingDesc\n            )\n\n            const shuffledCats: Cat[] = [\n                { name: \"Gerald\", age: 5, livesRemaining: 9 },\n                { name: \"Rufus\", age: 10, livesRemaining: 3 },\n                { name: \"Gerald\", age: 5, livesRemaining: 7 },\n                { name: \"Arnold\", age: 1, livesRemaining: 9 },\n                { name: \"Rufus\", age: 10, livesRemaining: 1 },\n                { name: \"Gerald\", age: 7, livesRemaining: 8 },\n            ]\n\n            const sortedCats: Cat[] = [\n                { name: \"Arnold\", age: 1, livesRemaining: 9 },\n                { name: \"Gerald\", age: 5, livesRemaining: 9 },\n                { name: \"Gerald\", age: 5, livesRemaining: 7 },\n                { name: \"Gerald\", age: 7, livesRemaining: 8 },\n                { name: \"Rufus\", age: 10, livesRemaining: 3 },\n                { name: \"Rufus\", age: 10, livesRemaining: 1 },\n            ]\n            // act\n            const actual = shuffledCats.slice(0).sort(compare)\n            // assert\n            expect(actual).toStrictEqual(sortedCats)\n        })\n    })\n\n    describe(\"Date\", () => {\n        it(\"sorts dates in ascending order\", () => {\n            const { compare } = OrderingComparer.Date\n            expect(\n                [\n                    new Date(2023, 2, 15),\n                    new Date(2025, 2, 15),\n                    new Date(2022, 2, 15),\n                    new Date(2020, 2, 15),\n                ]\n                    .slice(0)\n                    .sort(compare)\n            ).toStrictEqual([\n                new Date(2020, 2, 15),\n                new Date(2022, 2, 15),\n                new Date(2023, 2, 15),\n                new Date(2025, 2, 15),\n            ])\n        })\n    })\n\n    describe(\"deriveEqualityComparer\", () => {\n        it(\"returns an instance that also includes an equality comparer\", () => {\n            const { equals } = OrderingComparer.deriveEqualityComparer(\n                OrderingComparer.Number\n            )\n            expect(equals(1, 1)).toBe(true)\n            expect(equals(1, 2)).toBe(false)\n            expect(equals(2, 1)).toBe(false)\n        })\n    })\n\n    describe(\"gt\", () => {\n        it.each([\n            [true, \"a > b\", 2, 1],\n            [false, \"a = b\", 1, 1],\n            [false, \"a < b\", 0, 1],\n        ])(\"returns %o when %s\", (expected, _, first, second) => {\n            expect(OrderingComparer.gt(OrderingComparer.Number)(first, second)).toBe(\n                expected\n            )\n        })\n    })\n\n    describe(\"geq\", () => {\n        it.each([\n            [true, \"a > b\", 2, 1],\n            [true, \"a = b\", 1, 1],\n            [false, \"a < b\", 0, 1],\n        ])(\"returns %o when %s\", (expected, _, first, second) => {\n            expect(OrderingComparer.geq(OrderingComparer.Number)(first, second)).toBe(\n                expected\n            )\n        })\n    })\n\n    describe(\"lt\", () => {\n        it.each([\n            [false, \"a > b\", 2, 1],\n            [false, \"a = b\", 1, 1],\n            [true, \"a < b\", 0, 1],\n        ])(\"returns %o when %s\", (expected, _, first, second) => {\n            expect(OrderingComparer.lt(OrderingComparer.Number)(first, second)).toBe(\n                expected\n            )\n        })\n    })\n\n    describe(\"leq\", () => {\n        it.each([\n            [false, \"a > b\", 2, 1],\n            [true, \"a = b\", 1, 1],\n            [true, \"a < b\", 0, 1],\n        ])(\"returns %o when %s\", (expected, _, first, second) => {\n            expect(OrderingComparer.leq(OrderingComparer.Number)(first, second)).toBe(\n                expected\n            )\n        })\n    })\n\n    describe(\"isBetween\", () => {\n        it.each([\n            [true, \"on upper bound\", 1, 5, 5],\n            [true, \"on lower bound\", 1, 5, 1],\n            [true, \"within upper and lower bounds\", 1, 5, 3],\n            [false, \"above upper bound\", 1, 5, 6],\n            [false, \"below lower bound\", 1, 5, 0],\n        ])(\n            \"returns %o when test value is %s\",\n            (expected, _, lowerBound, upperBound, test) => {\n                expect(\n                    OrderingComparer.isBetween(OrderingComparer.Number)(\n                        lowerBound,\n                        upperBound\n                    )(test)\n                ).toBe(expected)\n            }\n        )\n    })\n})\n"]}
{"filename": "test/DeferredResult.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport * as DeferredResult from \"../src/DeferredResult\"\nimport { Deferred } from \"../src/Deferred\"\nimport { Result } from \"../src/Result\"\nimport { pipe } from \"../src/Composition\"\n\ntype DeferredResult<A, E> = DeferredResult.DeferredResult<A, E>\n\ndescribe(\"DeferredResult\", () => {\n    describe(\"match\", () => {\n        it.each([\n            [\n                \"notStarted\",\n                Deferred.notStarted as DeferredResult<number, string>,\n                \"Not Started\",\n            ],\n            [\n                \"inProgress\",\n                Deferred.inProgress as DeferredResult<number, string>,\n                \"In Progress\",\n            ],\n            [\n                \"resolvedOk\",\n                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n                \"Ok\",\n            ],\n            [\n                \"resolvedErr\",\n                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n                \"Err\",\n            ],\n        ])(\n            \"uses the raw value for each match case if given (%s)\",\n            (_, input, expected) => {\n                expect(\n                    pipe(\n                        input,\n                        DeferredResult.match({\n                            notStarted: \"Not Started\",\n                            inProgress: \"In Progress\",\n                            resolvedOk: \"Ok\",\n                            resolvedErr: \"Err\",\n                        })\n                    )\n                ).toBe(expected)\n            }\n        )\n\n        it.each([\n            [\"notStarted\", Deferred.notStarted as DeferredResult<number, string>, \"\"],\n            [\"inProgress\", Deferred.inProgress as DeferredResult<number, string>, 0],\n            [\n                \"resolvedOk\",\n                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n                null,\n            ],\n            [\n                \"resolvedErr\",\n                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n                undefined,\n            ],\n        ])(\n            \"correctly returns falsy and nullish raw values for each match case if given (%s)\",\n            (_, input, expected) => {\n                expect(\n                    pipe(\n                        input,\n                        DeferredResult.match<\n                            number,\n                            string,\n                            number | string | null | undefined\n                        >({\n                            notStarted: \"\",\n                            inProgress: 0,\n                            resolvedOk: null,\n                            resolvedErr: undefined,\n                        })\n                    )\n                ).toBe(expected)\n            }\n        )\n\n        it.each([\n            [\n                \"notStarted\",\n                Deferred.notStarted as DeferredResult<number, string>,\n                \"Not Started\",\n            ],\n            [\n                \"inProgress\",\n                Deferred.inProgress as DeferredResult<number, string>,\n                \"In Progress\",\n            ],\n            [\n                \"resolvedOk\",\n                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n                \"Ok(20)\",\n            ],\n            [\n                \"resolvedErr\",\n                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n                \"Err(fail)\",\n            ],\n        ])(\n            \"correctly uses lambda functions for each match case if given (%s)\",\n            (_, input, expected) => {\n                expect(\n                    pipe(\n                        input,\n                        DeferredResult.match({\n                            notStarted: () => \"Not Started\",\n                            inProgress: () => \"In Progress\",\n                            resolvedOk: a => `Ok(${a})`,\n                            resolvedErr: e => `Err(${e})`,\n                        })\n                    )\n                ).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"matchOrElse\", () => {\n        it.each([\n            [\n                \"notStarted\",\n                Deferred.notStarted as DeferredResult<number, string>,\n                \"Default\",\n            ],\n            [\n                \"inProgress\",\n                Deferred.inProgress as DeferredResult<number, string>,\n                \"Default\",\n            ],\n            [\n                \"resolvedOk\",\n                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n                \"Ok\",\n            ],\n            [\n                \"resolvedErr\",\n                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n                \"Err\",\n            ],\n        ])(\n            \"uses the raw value for each match case if given (%s)\",\n            (_, input, expected) => {\n                expect(\n                    pipe(\n                        input,\n                        DeferredResult.matchOrElse({\n                            resolvedOk: \"Ok\",\n                            resolvedErr: \"Err\",\n                            orElse: \"Default\",\n                        })\n                    )\n                ).toBe(expected)\n            }\n        )\n\n        it.each([\n            [\"notStarted\", Deferred.notStarted as DeferredResult<number, string>, 0],\n            [\"inProgress\", Deferred.inProgress as DeferredResult<number, string>, 0],\n            [\n                \"resolvedOk\",\n                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n                \"\",\n            ],\n            [\n                \"resolvedErr\",\n                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n                undefined,\n            ],\n        ])(\n            \"correctly returns falsy and nullish raw values for each match case if given (%s)\",\n            (_, input, expected) => {\n                expect(\n                    pipe(\n                        input,\n                        DeferredResult.matchOrElse<\n                            number,\n                            string,\n                            number | string | undefined\n                        >({\n                            resolvedOk: \"\",\n                            resolvedErr: undefined,\n                            orElse: 0,\n                        })\n                    )\n                ).toBe(expected)\n            }\n        )\n\n        it.each([\n            [\n                \"notStarted\",\n                Deferred.notStarted as DeferredResult<number, string>,\n                \"Default\",\n            ],\n            [\n                \"inProgress\",\n                Deferred.inProgress as DeferredResult<number, string>,\n                \"Default\",\n            ],\n            [\n                \"resolvedOk\",\n                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n                \"Ok(20)\",\n            ],\n            [\n                \"resolvedErr\",\n                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n                \"Err(fail)\",\n            ],\n        ])(\n            \"correctly uses lambda functions for each match case if given (%s)\",\n            (_, input, expected) => {\n                expect(\n                    pipe(\n                        input,\n                        DeferredResult.matchOrElse({\n                            resolvedOk: a => `Ok(${a})`,\n                            resolvedErr: e => `Err(${e})`,\n                            orElse: () => \"Default\",\n                        })\n                    )\n                ).toBe(expected)\n            }\n        )\n    })\n})\n"]}
{"filename": "test/Result.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport * as Result from \"../src/Result\"\nimport { Option } from \"../src/Option\"\nimport { pipe } from \"../src/Composition\"\nimport { EqualityComparer } from \"../src/EqualityComparer\"\n\ntype Result<A, E> = Result.Result<A, E>\n\ndescribe(\"Result\", () => {\n    describe(\"constructors\", () => {\n        describe(\"Ok\", () => {\n            it(\"returns a new Ok object\", () => {\n                expect(Result.ok(\"cheese\")).toStrictEqual({\n                    _tag: \"Ok\",\n                    ok: \"cheese\",\n                })\n            })\n        })\n\n        describe(\"Err\", () => {\n            it(\"returns a new Err object\", () => {\n                expect(Result.err(\"melted\")).toStrictEqual({\n                    _tag: \"Err\",\n                    err: \"melted\",\n                })\n            })\n        })\n    })\n\n    describe(\"match\", () => {\n        it(\"can match using lambdas\", () => {\n            // arrange\n            const matcher = {\n                ok: (s: string) => s.length,\n                err: (e: number) => e,\n            }\n            // act\n            const actual1 = pipe(Result.of(\"stink!\"), Result.match(matcher))\n            const actual2 = pipe(Result.err(404), Result.match(matcher))\n            // assert\n            expect(actual1).toBe(6)\n            expect(actual2).toBe(404)\n        })\n\n        it(\"can match using raw values\", () => {\n            // arrange\n            const matcher = {\n                ok: \"ok?\",\n                err: \"err!\",\n            }\n            // act\n            const actual1 = pipe(Result.ok(\"stink!\"), Result.match(matcher))\n            const actual2 = pipe(Result.err(404), Result.match(matcher))\n            // assert\n            expect(actual1).toBe(\"ok?\")\n            expect(actual2).toBe(\"err!\")\n        })\n\n        it(\"allows nullish matcher values\", () => {\n            // arrange\n            const matcher = {\n                ok: null,\n                err: undefined,\n            }\n            // act\n            const actual1 = pipe(Result.ok(\"stink!\"), Result.match(matcher))\n            const actual2 = pipe(Result.err(404), Result.match(matcher))\n            // assert\n            expect(actual1).toBe(null)\n            expect(actual2).toBe(undefined)\n        })\n\n        it(\"allows falsy matcher values\", () => {\n            // arrange\n            const matcher = {\n                ok: 0,\n                err: \"\",\n            }\n            // act\n            const actual1 = pipe(\n                Result.ok(\"stink!\"),\n                Result.match<string, never, number | string>(matcher)\n            )\n            const actual2 = pipe(\n                Result.err(404),\n                Result.match<never, number, number | string>(matcher)\n            )\n            // assert\n            expect(actual1).toBe(0)\n            expect(actual2).toBe(\"\")\n        })\n    })\n\n    describe(\"map\", () => {\n        it(\"returns a mapped Ok if given an Ok\", () => {\n            expect(\n                pipe(\n                    Result.ok(55),\n                    Result.map(n => n * 2)\n                )\n            ).toStrictEqual(Result.ok(110))\n        })\n\n        it(\"ignores Err values\", () => {\n            expect(\n                pipe(\n                    Result.err(\"cheese melted\"),\n                    Result.map((n: number) => n * 2)\n                )\n            ).toStrictEqual(Result.err(\"cheese melted\"))\n        })\n    })\n\n    describe(\"mapErr\", () => {\n        it(\"returns a mapped Err if given an Err\", () => {\n            expect(\n                pipe(\n                    Result.err(55),\n                    Result.mapErr(n => n * 2)\n                )\n            ).toStrictEqual(Result.err(110))\n        })\n\n        it(\"ignores Ok values\", () => {\n            expect(\n                pipe(\n                    Result.ok(\"cheese\"),\n                    Result.mapErr((n: number) => n * 2)\n                )\n            ).toStrictEqual(Result.ok(\"cheese\"))\n        })\n    })\n\n    describe(\"map2\", () => {\n        it(\"returns the projected value if both results are Ok\", () => {\n            // arrange\n            const concat = (a: string, b: string) => `${a}${b}`\n            // act\n            const actual = pipe(\n                [Result.ok(\"a\"), Result.ok(\"b\")] as const,\n                Result.map2(concat)\n            )\n            // assert\n            expect(actual).toStrictEqual(Result.ok(\"ab\"))\n        })\n\n        it.each([\n            [[Result.err(\"err1\"), Result.err(\"err2\")], Result.err(\"err1\")],\n            [[Result.ok(20), Result.err(\"err\")], Result.err(\"err\")],\n            [[Result.err(\"err\"), Result.ok(20)], Result.err(\"err\")],\n        ] as const)(\n            \"returns the first Err if either/both result is Err\",\n            (\n                results: readonly [Result<number, string>, Result<number, string>],\n                expected\n            ) => {\n                // arrange\n                const add = (a: number, b: number) => a + b\n                // act\n                const actual = pipe(results, Result.map2(add))\n                // assert\n                expect(actual).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"map3\", () => {\n        it(\"returns the projected value if all three results are Ok\", () => {\n            // arrange\n            const concat = (a: string, b: string, c: string) => `${a}${b}${c}`\n            // act\n            const actual = pipe(\n                [Result.ok(\"a\"), Result.ok(\"b\"), Result.ok(\"c\")] as const,\n                Result.map3(concat)\n            )\n            // assert\n            expect(actual).toStrictEqual(Result.ok(\"abc\"))\n        })\n\n        it.each([\n            [\n                [Result.err(\"err1\"), Result.err(\"err2\"), Result.err(\"err3\")],\n                Result.err(\"err1\"),\n            ],\n            [[Result.ok(20), Result.err(\"err1\"), Result.err(\"err2\")], Result.err(\"err1\")],\n            [[Result.err(\"err1\"), Result.ok(20), Result.err(\"err2\")], Result.err(\"err1\")],\n            [[Result.err(\"err1\"), Result.err(\"err2\"), Result.ok(20)], Result.err(\"err1\")],\n            [[Result.err(\"err\"), Result.ok(10), Result.ok(20)], Result.err(\"err\")],\n            [[Result.ok(10), Result.ok(20), Result.err(\"err\")], Result.err(\"err\")],\n        ] as const)(\n            \"returns the first found Err if any Result is Err\",\n            (\n                results: readonly [\n                    Result<number, string>,\n                    Result<number, string>,\n                    Result<number, string>\n                ],\n                expected\n            ) => {\n                // arrange\n                const add = (a: number, b: number, c: number) => a + b + c\n                // act\n                const actual = pipe(results, Result.map3(add))\n                // assert\n                expect(actual).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"mapBoth\", () => {\n        it(\"returns a mapped Err if given an Err\", () => {\n            expect(\n                pipe(\n                    Result.err(55),\n                    Result.mapBoth(\n                        (n: number) => n * 2,\n                        n => n + 1\n                    )\n                )\n            ).toStrictEqual(Result.err(56))\n        })\n\n        it(\"returns a mapped Ok if given an Ok\", () => {\n            expect(\n                pipe(\n                    Result.ok(\"cheese\"),\n                    Result.mapBoth(\n                        s => s.length,\n                        (s: string) => s.concat(\"eek\")\n                    )\n                )\n            ).toStrictEqual(Result.ok(6))\n        })\n    })\n\n    describe(\"defaultValue\", () => {\n        it(\"returns the Ok value for Oks\", () => {\n            expect(pipe(Result.ok(1), Result.defaultValue(0))).toBe(1)\n        })\n\n        it(\"returns the fallback value for Errs\", () => {\n            expect(pipe(Result.err(\"cheese\"), Result.defaultValue(0))).toBe(0)\n        })\n    })\n\n    describe(\"defaultWith\", () => {\n        it(\"returns the Ok value for Oks\", () => {\n            const f = vi.fn()\n            expect(pipe(Result.ok(1), Result.defaultWith(f))).toBe(1)\n            expect(f).not.toHaveBeenCalled()\n        })\n\n        it(\"returns the fallback value for Errs\", () => {\n            const f = vi.fn(() => 0)\n            expect(pipe(Result.err(\"cheese\"), Result.defaultWith(f))).toBe(0)\n            expect(f).toHaveBeenCalledOnce()\n        })\n    })\n\n    describe(\"bind\", () => {\n        it(\"maps the Ok value to a new Result\", () => {\n            expect(\n                pipe(\n                    Result.ok(1),\n                    Result.bind(n =>\n                        n > 0 ? Result.ok(\"positive\") : Result.err(\"not positive\")\n                    ),\n                    Result.defaultValue(\"\")\n                )\n            ).toBe(\"positive\")\n        })\n\n        it(\"does nothing to an Err\", () => {\n            expect(\n                pipe(\n                    Result.err(\"error\"),\n                    Result.bind((n: number) =>\n                        n > 0 ? Result.ok(\"positive\") : Result.err(\"not positive\")\n                    )\n                )\n            ).toStrictEqual(Result.err(\"error\"))\n        })\n    })\n\n    describe(\"isOk\", () => {\n        it(\"returns true for Ok\", () => {\n            expect(Result.isOk(Result.ok(1))).toBe(true)\n        })\n\n        it(\"returns false for Err\", () => {\n            expect(Result.isOk(Result.err(1))).toBe(false)\n        })\n    })\n\n    describe(\"isErr\", () => {\n        it(\"returns true for Err\", () => {\n            expect(Result.isErr(Result.err(1))).toBe(true)\n        })\n\n        it(\"returns false for Ok\", () => {\n            expect(Result.isErr(Result.ok(1))).toBe(false)\n        })\n    })\n\n    describe(\"tryCatch\", () => {", "        it(\"yields an Ok if the function succeeds\", () => {\n            // arrange\n            const f = () => 22\n            // act\n            const actual = Result.tryCatch(f)\n            // assert\n            expect(actual).toStrictEqual(Result.ok(22))\n        })\n\n        it.each([\n            [new TypeError(\"type error\"), new TypeError(\"type error\")],\n            [42, new Error(\"42\")],\n        ])(", "            [new TypeError(\"type error\"), new TypeError(\"type error\")],\n            [42, new Error(\"42\")],\n        ])(\n            \"yields an Err if the function throws (using default behavior when onThrow is omitted)\",\n            (thrown, expected) => {\n                // arrange\n                const f = () => {\n                    throw thrown\n                }\n                // act\n                const actual = Result.tryCatch(f)\n                // assert\n                expect(actual).toStrictEqual(Result.err(expected))\n            }\n        )\n", "        it(\"yields an Err if the function throws (using onThrow when provided)\", () => {\n            // arrange\n            const f = (): number => {\n                throw new Error(\"cheese\")\n            }\n            // act\n            const actual = Result.tryCatch(f, () => \"aw, shucks\")\n            // assert\n            expect(actual).toStrictEqual(Result.err(\"aw, shucks\"))\n        })\n    })\n\n    describe(\"tee\", () => {\n        it(\"executes a side effect without affecting the wrapped Ok\", () => {\n            // arrange\n            const log = vi.fn()\n            // act\n            const actual = pipe(\n                Result.ok(20),\n                Result.tee(log),\n                Result.map(n => n * 3)\n            )\n            // assert\n            expect(actual).toStrictEqual(Result.ok(60))\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(20)\n        })\n\n        it(\"does not execute the side effect for an Err\", () => {\n            // arrange\n            const log = vi.fn()\n            // act\n            const actual = pipe(\n                Result.err(\"err\"),\n                Result.tee(log),\n                Result.map((n: number) => n * 3)\n            )\n            // assert\n            expect(actual).toStrictEqual(Result.err(\"err\"))\n            expect(log).not.toHaveBeenCalled()\n        })\n    })\n\n    describe(\"teeErr\", () => {\n        it(\"executes a side effect without affecting the wrapped Err\", () => {\n            // arrange\n            const log = vi.fn()\n            // act\n            const actual = pipe(\n                Result.err<string, number>(\"err\"),\n                Result.teeErr(e => {\n                    log(e)\n                }),\n                Result.mapErr((s: string) => s.length)\n            )\n            // assert\n            expect(actual).toStrictEqual(Result.err(3))\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(\"err\")\n        })\n\n        it(\"does not execute the side effect for an Ok\", () => {\n            // arrange\n            const log = vi.fn()\n            // act\n            const actual = pipe(\n                Result.ok(\"ok\"),\n                Result.teeErr(log),\n                Result.mapErr((n: number) => n * 3)\n            )\n            // assert\n            expect(actual).toStrictEqual(Result.ok(\"ok\"))\n            expect(log).not.toHaveBeenCalled()\n        })\n    })\n\n    describe(\"ofOption\", () => {\n        it(\"returns Ok if given a Some\", () => {\n            expect(\n                pipe(\n                    Option.some(100),\n                    Result.ofOption(() => \"cheese\")\n                )\n            ).toStrictEqual(Result.ok(100))\n        })\n\n        it(\"returns Err if given a None\", () => {\n            expect(\n                pipe(\n                    Option.none,\n                    Result.ofOption(() => \"cheese\")\n                )\n            ).toStrictEqual(Result.err(\"cheese\"))\n        })\n    })\n\n    describe(\"getEqualityComparer\", () => {\n        it.each([\n            [true, \"both are Errs and are equal\", Result.err(1), Result.err(1)],\n            [false, \"both are Errs but are not equal\", Result.err(1), Result.err(2)],\n            [false, \"one is an Ok and one is an Err\", Result.ok(1), Result.err(1)],\n            [false, \"one is an Err and one is an Ok\", Result.err(1), Result.ok(1)],\n            [true, \"both are Oks and are equal\", Result.ok(1), Result.ok(1)],\n            [false, \"both are Oks but are not equal\", Result.ok(1), Result.ok(2)],\n        ])(\n            \"gets an equality comparer that returns %o when %s\",\n            (expected, _, result1, result2) => {\n                const { equals } = Result.getEqualityComparer(\n                    EqualityComparer.Number,\n                    EqualityComparer.Number\n                )\n\n                expect(equals(result1, result2)).toBe(equals(result2, result1))\n                expect(equals(result1, result2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"refine\", () => {\n        it(\"returns the refined result if Ok passes the refinement\", () => {\n            const isCat = (s: string): s is \"cat\" => s === \"cat\"\n            expect(\n                pipe(\n                    Result.ok(\"cat\"),\n                    Result.refine(isCat, () => \"not a cat\")\n                )\n            ).toStrictEqual(Result.ok(\"cat\"))\n        })\n\n        it(\"returns the onFail result if Ok does not pass the refinement\", () => {\n            const isCat = (s: string): s is \"cat\" => s === \"cat\"\n            expect(\n                pipe(\n                    Result.ok(\"dog\"),\n                    Result.refine(isCat, a => `${a} is not cat`)\n                )\n            ).toStrictEqual(Result.err(\"dog is not cat\"))\n        })\n\n        it(\"passes Errs through\", () => {\n            const isCat = (s: string): s is \"cat\" => s === \"cat\"\n            expect(\n                pipe(\n                    Result.err<number, string>(0),\n                    Result.refine(isCat, () => 10)\n                )\n            ).toStrictEqual(Result.err(0))\n        })\n    })\n})\n"]}
{"filename": "test/Nullable.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport * as Nullable from \"../src/Nullable\"\nimport { pipe } from \"../src/Composition\"\nimport { EqualityComparer } from \"../src/EqualityComparer\"\nimport { Array } from \"../src/Array\"\nimport { NonNullish } from \"../src/prelude\"\n\ntype Nullable<A extends NonNullish> = Nullable.Nullable<A>\n\ndescribe(\"Nullable\", () => {\n    describe(\"defaultValue\", () => {\n        it.each([[null], [undefined]])(\n            \"returns the default value if given a nullish\",\n            n => {\n                expect(pipe(n, Nullable.defaultValue(42))).toBe(42)\n            }\n        )\n\n        it.each([[\"\"], [[]], [0], [\"cheese\"], [42], [{}]])(\n            \"returns the value if given a non-nullish (including falsy, non-nullish)\",\n            val => {\n                expect(pipe(val, Nullable.defaultValue<NonNullish>(0))).toBe(val)\n            }\n        )\n    })\n\n    describe(\"defaultWith\", () => {\n        it.each([[null], [undefined]])(\n            \"returns the default value if given a nullish\",\n            n => {\n                expect(\n                    pipe(\n                        n,\n                        Nullable.defaultWith(() => 42)\n                    )\n                ).toBe(42)\n            }\n        )\n\n        it.each([[\"\"], [[]], [0], [\"cheese\"], [42], [{}]])(\n            \"returns the value if given a non-nullish (including falsy, non-nullish)\",\n            val => {\n                expect(\n                    pipe(\n                        val,\n                        Nullable.defaultWith<NonNullish>(() => 0)\n                    )\n                ).toBe(val)\n            }\n        )\n    })\n\n    describe(\"map\", () => {\n        it.each([[null], [undefined]])(\n            \"returns the same nullish value if given a nullish\",\n            n => {\n                expect(\n                    pipe(\n                        n,\n                        Nullable.map(u => typeof u)\n                    )\n                ).toBe(n)\n            }\n        )\n\n        it.each([\n            [\"\", \"string\"],\n            [[], \"object\"],\n            [0, \"number\"],\n            [\"cheese\", \"string\"],\n            [42, \"number\"],\n            [{}, \"object\"],\n        ])(", "            \"returns the result of the map function if given a non-nullish (including falsy, non-nullish)\",\n            (val, expected) => {\n                expect(\n                    pipe(\n                        val,\n                        Nullable.map<NonNullish, string>(u => typeof u)\n                    )\n                ).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"bind\", () => {\n        it.each([[null], [undefined]])(\n            \"returns the same nullish value if given a nullish\",\n            n => {\n                expect(\n                    pipe(\n                        n,\n                        Nullable.bind(() => \"cheese\")\n                    )\n                ).toBe(n)\n            }\n        )\n\n        it.each([\n            [null, null],\n            [undefined, undefined],\n        ])(", "            \"returns the nullish value produced by the bind function if it produces a nullish\",\n            (bindFnResult, expected) => {\n                const bindFn = vi.fn(() => bindFnResult)\n                expect(pipe(\"\", Nullable.bind(bindFn))).toBe(expected)\n            }\n        )\n\n        it.each([\n            [() => 42, 42],\n            [() => \"\", \"\"],\n            [() => [], []],\n            [() => ({}), {}],\n            [() => \"A\", \"A\"],\n        ])(", "            \"returns the result of the bind function if it produces a value\",\n            (bindFn, expected) => {\n                expect(pipe(\"\", Nullable.bind(bindFn))).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"getEqualityComparer\", () => {\n        it.each([\n            [null, undefined],\n            [undefined, null],\n            [null, null],\n            [undefined, undefined],\n        ])(\"produces an EqualityComparer that considers %o equivalent to %o\", (a, b) => {\n            // arrange\n            const { equals } = Nullable.getEqualityComparer(EqualityComparer.String)\n            // act & assert\n            expect(equals(a, b)).toBe(equals(b, a))\n            expect(equals(a, b)).toBe(true)\n        })\n\n        it.each([[null], [undefined]])(\n            \"produces an EqualityComparer that doesn't consider [] equivalent to %o\",\n            falsy => {\n                // arrange\n                const { equals } = Nullable.getEqualityComparer(\n                    Array.getEqualityComparer(EqualityComparer.String)\n                )\n                // act & assert\n                expect(equals([], falsy)).toBe(false)\n            }\n        )\n\n        it.each([[null], [undefined]])(\n            'produces an EqualityComparer that doesn\\'t consider \"\" equivalent to %o',\n            falsy => {\n                // arrange\n                const { equals } = Nullable.getEqualityComparer(EqualityComparer.String)\n                // act & assert\n                expect(equals(\"\", falsy)).toBe(false)\n            }\n        )\n\n        it.each([\n            [null, \"cheese\", false],\n            [undefined, \"cheese\", false],\n            [\"rawr\", \"monster\", false],\n            [\"\", \"\", true],\n            [\"hello\", \"hello\", true],\n        ])(\n            \"produces an EqualityComparer that considers equals(%o, %o) to be %o\",\n            (a, b, expected) => {\n                // arrange\n                const { equals } = Nullable.getEqualityComparer(EqualityComparer.String)\n                // act\n                expect(equals(a, b)).toBe(expected)\n            }\n        )\n    })\n})\n"]}
{"filename": "test/Deferred.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport * as Deferred from \"../src/Deferred\"\nimport { pipe } from \"../src/Composition\"\n\ndescribe(\"Deferred\", () => {\n    describe(\"match\", () => {\n        it.each([\n            [Deferred.notStarted, \"not started\"],\n            [Deferred.inProgress, \"in progress\"],\n            [Deferred.resolved(42), \"resolved: 42\"],", "            [Deferred.inProgress, \"in progress\"],\n            [Deferred.resolved(42), \"resolved: 42\"],\n        ])(\"matches every case for %o\", (input, expected) => {\n            // act\n            const actual = pipe(\n                input,\n                Deferred.match({\n                    notStarted: \"not started\",\n                    inProgress: () => \"in progress\",\n                    resolved: n => `resolved: ${n}`,", "                    inProgress: () => \"in progress\",\n                    resolved: n => `resolved: ${n}`,\n                })\n            )\n            // assert\n            expect(actual).toBe(expected)\n        })\n    })\n\n    describe(\"matchOrElse\", () => {", "\n    describe(\"matchOrElse\", () => {\n        it.each([\n            [Deferred.notStarted, \"not started\"],\n            [Deferred.inProgress, \"unmatched\"],\n            [Deferred.resolved(42), \"resolved\"],\n        ])(\"matches only specified cases for %o\", (input, expected) => {\n            // act\n            const actual = pipe(\n                input,", "            const actual = pipe(\n                input,\n                Deferred.matchOrElse({\n                    notStarted: \"not started\",\n                    resolved: \"resolved\",\n                    orElse: () => \"unmatched\",\n                })\n            )\n            // assert\n            expect(actual).toBe(expected)", "            // assert\n            expect(actual).toBe(expected)\n        })\n\n        it(\"considers falsy matcher values as valid\", () => {\n            // arrange\n            const def1 = Deferred.inProgress\n            const def2 = Deferred.notStarted\n            const def3 = Deferred.resolved(\"resolve this, bro\")\n            // act", "            const def3 = Deferred.resolved(\"resolve this, bro\")\n            // act\n            const actual1 = pipe(\n                def1,\n                Deferred.matchOrElse({\n                    inProgress: false,\n                    orElse: true,\n                })\n            )\n            const actual2 = pipe(", "            )\n            const actual2 = pipe(\n                def2,\n                Deferred.matchOrElse({\n                    notStarted: 0,\n                    orElse: 1,\n                })\n            )\n            const actual3 = pipe(\n                def3,", "            const actual3 = pipe(\n                def3,\n                Deferred.matchOrElse({\n                    resolved: false,\n                    orElse: true,\n                })\n            )\n            // assert\n            expect(actual1).toBe(false)\n            expect(actual2).toBe(0)", "            expect(actual1).toBe(false)\n            expect(actual2).toBe(0)\n            expect(actual3).toBe(false)\n        })\n    })\n\n    describe(\"isUnresolved\", () => {\n        it.each([\n            [true, \"in progress\", Deferred.inProgress],\n            [true, \"not started\", Deferred.notStarted],", "            [true, \"in progress\", Deferred.inProgress],\n            [true, \"not started\", Deferred.notStarted],\n            [false, \"resolved\", Deferred.resolved({})],\n        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n            // act\n            const actual = Deferred.isUnresolved(val)\n            // assert\n            expect(actual).toBe(expected)\n        })\n    })", "        })\n    })\n\n    describe(\"isInProgress\", () => {\n        it.each([\n            [true, \"in progress\", Deferred.inProgress],\n            [false, \"not started\", Deferred.notStarted],\n            [false, \"resolved\", Deferred.resolved({})],\n        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n            // act", "        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n            // act\n            const actual = Deferred.isInProgress(val)\n            // assert\n            expect(actual).toBe(expected)\n        })\n    })\n\n    describe(\"isResolvedWith\", () => {\n        it.each([", "    describe(\"isResolvedWith\", () => {\n        it.each([\n            [\"in progress\", Deferred.inProgress],\n            [\"not started\", Deferred.notStarted],\n        ])(\"returns false if deferred is %s\", (_, val) => {\n            // act\n            const actual = Deferred.isResolvedWith({})(val)\n            // assert\n            expect(actual).toBe(false)\n        })", "            expect(actual).toBe(false)\n        })\n\n        it(\"returns false if deferred is resolved, but not Eq-equivalent to expected\", () => {\n            // arrange\n            const def = Deferred.resolved(89)\n            // act\n            const actual = Deferred.isResolvedWith<number>(12)(def)\n            // assert\n            expect(actual).toBe(false)", "            // assert\n            expect(actual).toBe(false)\n        })\n\n        it(\"returns true if deferred is resolved, and is Eq-equivalent to expected\", () => {\n            // arrange\n            const def = Deferred.resolved(89)\n            // act\n            const actual = Deferred.isResolvedWith<number>(89)(def)\n            // assert", "            const actual = Deferred.isResolvedWith<number>(89)(def)\n            // assert\n            expect(actual).toBe(true)\n        })\n    })\n\n    describe(\"isResolved\", () => {\n        it.each([\n            [false, \"in progress\", Deferred.inProgress],\n            [false, \"not started\", Deferred.notStarted],", "            [false, \"in progress\", Deferred.inProgress],\n            [false, \"not started\", Deferred.notStarted],\n            [true, \"resolved\", Deferred.resolved({})],\n        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n            // act\n            const actual = Deferred.isResolved(val)\n            // assert\n            expect(actual).toBe(expected)\n        })\n    })", "        })\n    })\n})\n"]}
{"filename": "test/Map.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport * as Map from \"../src/Map\"\nimport { Option } from \"../src/Option\"\nimport { String } from \"../src/string\"\nimport { pipe } from \"../src/Composition\"\nimport { OrderingComparer } from \"../src/OrderingComparer\"\nimport { EqualityComparer } from \"../src/EqualityComparer\"\n\ninterface Cheese {\n    readonly name: string\n    readonly age: number\n}\n\nconst cheeseByAgeComparer: OrderingComparer<Cheese> = {\n    compare: (c1, c2) => (c1.age === c2.age ? 0 : c1.age < c2.age ? -1 : 1),\n}\n\nconst cheeseEqualityComparer: EqualityComparer<Cheese> = {\n    equals: (c1, c2) => c1.name === c2.name && c1.age === c2.age,\n}\n\ndescribe(\"Map\", () => {\n    describe(\"set\", () => {\n        it(\"sets a new key/value on an empty map\", () => {\n            expect(pipe(Map.empty(), Map.set([\"Albus\", 12]))).toStrictEqual(\n                Map.ofArray([[\"Albus\", 12]])\n            )\n        })\n\n        it(\"sets a new key/value on a non-empty map without the same key using default equality\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Fido\", 44]]), Map.set([\"Albus\", 12]))\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"Fido\", 44],\n                    [\"Albus\", 12],\n                ])\n            )\n        })\n\n        it(\"overrides a key/value to a non-empty map with the same key using default equality\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Fido\", 44]]), Map.set([\"Fido\", 12]))\n            ).toStrictEqual(Map.ofArray([[\"Fido\", 12]]))\n        })\n\n        it(\"sets a new key/value on a non-empty map without the same key using custom equality\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"AA\"]]),\n                    Map.set([{ name: \"Cheddar\", age: 0.5 }, \"C\"], cheeseEqualityComparer)\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [{ name: \"Gouda\", age: 2 }, \"AA\"],\n                    [{ name: \"Cheddar\", age: 0.5 }, \"C\"],\n                ])\n            )\n        })\n\n        it(\"overrides a new key/value on a non-empty map with the same key using custom equality\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"AA\"]]),\n                    Map.set([{ name: \"Gouda\", age: 2 }, \"B\"], cheeseEqualityComparer)\n                )\n            ).toStrictEqual(Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"B\"]]))\n        })\n    })\n\n    describe(\"findWithKey\", () => {\n        it(\"returns None if the map is empty\", () => {\n            expect(pipe(new globalThis.Map(), Map.findWithKey(\"Abby\"))).toStrictEqual(\n                Option.none\n            )\n        })\n\n        it(\"returns None if the key is not in the Map (using default equality)\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Jared\", 25]]), Map.findWithKey(\"Fubo\"))\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns Some if the key is in the Map (using default equality)\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Jared\", 25]]), Map.findWithKey(\"Jared\"))\n            ).toStrictEqual(Option.some([\"Jared\", 25]))\n        })\n\n        it(\"returns None if the key is not in the Map (using custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Muenster\", age: 4 }, 25]]),\n                    Map.findWithKey({ name: \"Muenster\", age: 3 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns Some if the key is in the Map (using custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Muenster\", age: 4 }, 25]]),\n                    Map.findWithKey({ name: \"Muenster\", age: 4 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(Option.some([{ name: \"Muenster\", age: 4 }, 25]))\n        })\n    })\n\n    describe(\"containsKey\", () => {\n        it.each([\n            [true, \"e\", \"in\"],\n            [false, \"f\", \"not in\"],\n        ])(\n            \"returns %o if the key (%s) is %s the map (default equality)\",\n            (expected, letter) => {\n                const letterCounts = Map.ofArray([\n                    [\"a\", 21],\n                    [\"e\", 17],\n                ])\n                expect(pipe(letterCounts, Map.containsKey(letter))).toBe(expected)\n            }\n        )\n\n        it.each([\n            [true, { name: \"Provolone\", age: 1.5 }, \"in\"],\n            [false, { name: \"Brie\", age: 0.5 }, \"not in\"],\n        ])(\n            \"returns %o if the key (%s) is %s the map (custom equality)\",\n            (expected, key) => {\n                const cheeseRankings = Map.ofArray([\n                    [{ name: \"Provolone\", age: 1.5 }, \"A+\"],\n                    [{ name: \"Cheddar\", age: 2 }, \"B-\"],\n                ])\n                expect(\n                    pipe(cheeseRankings, Map.containsKey(key, cheeseEqualityComparer))\n                ).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"find\", () => {\n        it.each([\n            [Option.some(17), \"e\", \"in\"],\n            [Option.none, \"f\", \"not in\"],\n        ])(\n            \"returns the value (%o) if the key (%s) is %s the map (default equality)\",\n            (expected, letter) => {\n                const letterCounts = Map.ofArray([\n                    [\"a\", 21],\n                    [\"e\", 17],\n                ])\n                expect(pipe(letterCounts, Map.find(letter))).toStrictEqual(expected)\n            }\n        )\n\n        it.each([\n            [Option.some(\"A+\"), { name: \"Provolone\", age: 1.5 }, \"in\"],\n            [Option.none, { name: \"Brie\", age: 0.5 }, \"not in\"],\n        ])(\n            \"returns the value (%o) if the key (%s) is %s the map (custom equality)\",\n            (expected, key) => {\n                const cheeseRankings = Map.ofArray([\n                    [{ name: \"Provolone\", age: 1.5 }, \"A+\"],\n                    [{ name: \"Cheddar\", age: 2 }, \"B-\"],\n                ])\n                expect(\n                    pipe(cheeseRankings, Map.find(key, cheeseEqualityComparer))\n                ).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"map\", () => {\n        it(\"returns an empty map if given an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.map(() => 0)\n                )\n            ).toStrictEqual(Map.empty())\n        })\n\n        it(\"returns a new map containing mapped values\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"John\", 23],\n                        [\"George\", 8],\n                        [\"Jimmy\", 88],\n                    ]),\n                    Map.map((name, age) => `${name}:${age - 3}`)\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"John\", \"John:20\"],\n                    [\"George\", \"George:5\"],\n                    [\"Jimmy\", \"Jimmy:85\"],\n                ])\n            )\n        })\n    })\n\n    describe(\"findKey\", () => {\n        it(\"returns None for an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.findKey((n: number) => n === 20)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns the first key for which the predicate returns true (default sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"b\", 2],\n                        [\"d\", 4],\n                        [\"a\", 1],\n                        [\"c\", 3],\n                    ]),\n                    Map.findKey(s => s.length === 1)\n                )\n            ).toStrictEqual(Option.some(\"a\"))\n        })\n\n        it(\"returns None if no key matches the predicate (default sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"b\", 2],\n                        [\"d\", 4],\n                        [\"a\", 1],\n                        [\"c\", 3],\n                    ]),\n                    Map.findKey(s => s.length === 2)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns the first key for which the predicate returns true (custom sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Mozzarella\", age: 2 }, 2],\n                        [{ name: \"Provolone\", age: 1 }, 4],\n                        [{ name: \"Provolone\", age: 0.5 }, 1],\n                        [{ name: \"Cheddar\", age: 3 }, 3],\n                    ]),\n                    Map.findKey(\n                        cheese => cheese.name === \"Provolone\",\n                        cheeseByAgeComparer\n                    )\n                )\n            ).toStrictEqual(Option.some({ name: \"Provolone\", age: 0.5 }))\n        })\n\n        it(\"returns None if no key matches the predicate (custom sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Mozzarella\", age: 2 }, 2],\n                        [{ name: \"Provolone\", age: 1 }, 4],\n                        [{ name: \"Provolone\", age: 0.5 }, 1],\n                        [{ name: \"Cheddar\", age: 3 }, 3],\n                    ]),\n                    Map.findKey(cheese => cheese.name === \"Muenster\", cheeseByAgeComparer)\n                )\n            ).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"empty\", () => {\n        it(\"returns an empty map\", () => {\n            expect(Map.empty()).toStrictEqual(new globalThis.Map())\n        })\n    })\n\n    describe(\"exists\", () => {\n        it(\"returns false for an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.exists(() => true)\n                )\n            ).toBe(false)\n        })\n\n        it(\"returns false if no value in the map matches the predicate\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 3],\n                        [\"Mouse\", 0],\n                    ]),\n                    Map.exists(n => n < 0)\n                )\n            ).toBe(false)\n        })\n\n        it(\"returns true if at least one value in the map matches the predicate\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 3],\n                        [\"Mouse\", 0],\n                    ]),\n                    Map.exists(n => n > 2)\n                )\n            ).toBe(true)\n        })\n    })\n\n    describe(\"change\", () => {\n        describe(\"default equality\", () => {\n            it(\"returns the map unchanged if the key doesn't exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [\"Cat\", 1],\n                            [\"Dog\", 2],\n                        ]),\n                        Map.change(\"Mouse\", n => n + 1)\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 2],\n                    ])\n                )\n            })\n\n            it(\"returns the map with changed binding if the key does exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [\"Cat\", 1],\n                            [\"Dog\", 2],\n                        ]),\n                        Map.change(\"Dog\", n => n + 1)\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 3],\n                    ])\n                )\n            })\n        })\n\n        describe(\"custom equality\", () => {\n            it(\"returns the map unchanged if the key doesn't exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [{ name: \"Cheddar\", age: 1 }, 1],\n                            [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                        ]),\n                        Map.change(\n                            { name: \"Provolone\", age: 0 },\n                            n => n + 1,\n                            cheeseEqualityComparer\n                        )\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [{ name: \"Cheddar\", age: 1 }, 1],\n                        [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                    ])\n                )\n            })\n\n            it(\"returns the map with changed binding if the key does exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [{ name: \"Cheddar\", age: 1 }, 1],\n                            [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                        ]),\n                        Map.change(\n                            { name: \"Cheddar\", age: 1 },\n                            n => n + 1,\n                            cheeseEqualityComparer\n                        )\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [{ name: \"Cheddar\", age: 1 }, 2],\n                        [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                    ])\n                )\n            })\n        })\n    })\n\n    describe(\"remove\", () => {\n        it(\"removes the key from the map (default equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord<string, number>({\n                        DinJarin: 10,\n                        Meredith: 20,\n                        Grogu: 9001,\n                    }),\n                    Map.remove(\"Meredith\")\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"DinJarin\", 10],\n                    [\"Grogu\", 9001],\n                ])\n            )\n        })\n\n        it(\"doesn't change the map if the key doesn't exist (default equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord<string, number>({\n                        DinJarin: 10,\n                        Grogu: 9001,\n                    }),\n                    Map.remove(\"Jimmy\")\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"DinJarin\", 10],\n                    [\"Grogu\", 9001],\n                ])\n            )\n        })\n\n        it(\"removes the key from the map (custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray(\n                        [\n                            [{ name: \"American\", age: 0.1 }, 0],\n                            [{ name: \"Provolone\", age: 2 }, 23],\n                            [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                        ],\n                        cheeseEqualityComparer\n                    ),\n                    Map.remove({ name: \"Provolone\", age: 2 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(\n                Map.ofArray(\n                    [\n                        [{ name: \"American\", age: 0.1 }, 0],\n                        [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                    ],\n                    cheeseEqualityComparer\n                )\n            )\n        })\n\n        it(\"doesn't change the map if the key doesn't exist (custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray(\n                        [\n                            [{ name: \"American\", age: 0.1 }, 0],\n                            [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                        ],\n                        cheeseEqualityComparer\n                    ),\n                    Map.remove({ name: \"Provolone\", age: 2 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(\n                Map.ofArray(\n                    [\n                        [{ name: \"American\", age: 0.1 }, 0],\n                        [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                    ],\n                    cheeseEqualityComparer\n                )\n            )\n        })\n    })\n\n    describe(\"iter\", () => {\n        it(\"never calls the given fucntion for an empty map\", () => {\n            const fn = vi.fn()\n            pipe(Map.empty(), Map.iter(fn))\n            expect(fn).not.toHaveBeenCalled()\n        })\n", "interface Cheese {\n    readonly name: string\n    readonly age: number\n}\n\nconst cheeseByAgeComparer: OrderingComparer<Cheese> = {\n    compare: (c1, c2) => (c1.age === c2.age ? 0 : c1.age < c2.age ? -1 : 1),\n}\n\nconst cheeseEqualityComparer: EqualityComparer<Cheese> = {\n    equals: (c1, c2) => c1.name === c2.name && c1.age === c2.age,\n}\n\ndescribe(\"Map\", () => {\n    describe(\"set\", () => {\n        it(\"sets a new key/value on an empty map\", () => {\n            expect(pipe(Map.empty(), Map.set([\"Albus\", 12]))).toStrictEqual(\n                Map.ofArray([[\"Albus\", 12]])\n            )\n        })\n\n        it(\"sets a new key/value on a non-empty map without the same key using default equality\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Fido\", 44]]), Map.set([\"Albus\", 12]))\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"Fido\", 44],\n                    [\"Albus\", 12],\n                ])\n            )\n        })\n\n        it(\"overrides a key/value to a non-empty map with the same key using default equality\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Fido\", 44]]), Map.set([\"Fido\", 12]))\n            ).toStrictEqual(Map.ofArray([[\"Fido\", 12]]))\n        })\n\n        it(\"sets a new key/value on a non-empty map without the same key using custom equality\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"AA\"]]),\n                    Map.set([{ name: \"Cheddar\", age: 0.5 }, \"C\"], cheeseEqualityComparer)\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [{ name: \"Gouda\", age: 2 }, \"AA\"],\n                    [{ name: \"Cheddar\", age: 0.5 }, \"C\"],\n                ])\n            )\n        })\n\n        it(\"overrides a new key/value on a non-empty map with the same key using custom equality\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"AA\"]]),\n                    Map.set([{ name: \"Gouda\", age: 2 }, \"B\"], cheeseEqualityComparer)\n                )\n            ).toStrictEqual(Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"B\"]]))\n        })\n    })\n\n    describe(\"findWithKey\", () => {\n        it(\"returns None if the map is empty\", () => {\n            expect(pipe(new globalThis.Map(), Map.findWithKey(\"Abby\"))).toStrictEqual(\n                Option.none\n            )\n        })\n\n        it(\"returns None if the key is not in the Map (using default equality)\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Jared\", 25]]), Map.findWithKey(\"Fubo\"))\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns Some if the key is in the Map (using default equality)\", () => {\n            expect(\n                pipe(Map.ofArray([[\"Jared\", 25]]), Map.findWithKey(\"Jared\"))\n            ).toStrictEqual(Option.some([\"Jared\", 25]))\n        })\n\n        it(\"returns None if the key is not in the Map (using custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Muenster\", age: 4 }, 25]]),\n                    Map.findWithKey({ name: \"Muenster\", age: 3 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns Some if the key is in the Map (using custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([[{ name: \"Muenster\", age: 4 }, 25]]),\n                    Map.findWithKey({ name: \"Muenster\", age: 4 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(Option.some([{ name: \"Muenster\", age: 4 }, 25]))\n        })\n    })\n\n    describe(\"containsKey\", () => {\n        it.each([\n            [true, \"e\", \"in\"],\n            [false, \"f\", \"not in\"],\n        ])(\n            \"returns %o if the key (%s) is %s the map (default equality)\",\n            (expected, letter) => {\n                const letterCounts = Map.ofArray([\n                    [\"a\", 21],\n                    [\"e\", 17],\n                ])\n                expect(pipe(letterCounts, Map.containsKey(letter))).toBe(expected)\n            }\n        )\n\n        it.each([\n            [true, { name: \"Provolone\", age: 1.5 }, \"in\"],\n            [false, { name: \"Brie\", age: 0.5 }, \"not in\"],\n        ])(\n            \"returns %o if the key (%s) is %s the map (custom equality)\",\n            (expected, key) => {\n                const cheeseRankings = Map.ofArray([\n                    [{ name: \"Provolone\", age: 1.5 }, \"A+\"],\n                    [{ name: \"Cheddar\", age: 2 }, \"B-\"],\n                ])\n                expect(\n                    pipe(cheeseRankings, Map.containsKey(key, cheeseEqualityComparer))\n                ).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"find\", () => {\n        it.each([\n            [Option.some(17), \"e\", \"in\"],\n            [Option.none, \"f\", \"not in\"],\n        ])(\n            \"returns the value (%o) if the key (%s) is %s the map (default equality)\",\n            (expected, letter) => {\n                const letterCounts = Map.ofArray([\n                    [\"a\", 21],\n                    [\"e\", 17],\n                ])\n                expect(pipe(letterCounts, Map.find(letter))).toStrictEqual(expected)\n            }\n        )\n\n        it.each([\n            [Option.some(\"A+\"), { name: \"Provolone\", age: 1.5 }, \"in\"],\n            [Option.none, { name: \"Brie\", age: 0.5 }, \"not in\"],\n        ])(\n            \"returns the value (%o) if the key (%s) is %s the map (custom equality)\",\n            (expected, key) => {\n                const cheeseRankings = Map.ofArray([\n                    [{ name: \"Provolone\", age: 1.5 }, \"A+\"],\n                    [{ name: \"Cheddar\", age: 2 }, \"B-\"],\n                ])\n                expect(\n                    pipe(cheeseRankings, Map.find(key, cheeseEqualityComparer))\n                ).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"map\", () => {\n        it(\"returns an empty map if given an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.map(() => 0)\n                )\n            ).toStrictEqual(Map.empty())\n        })\n\n        it(\"returns a new map containing mapped values\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"John\", 23],\n                        [\"George\", 8],\n                        [\"Jimmy\", 88],\n                    ]),\n                    Map.map((name, age) => `${name}:${age - 3}`)\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"John\", \"John:20\"],\n                    [\"George\", \"George:5\"],\n                    [\"Jimmy\", \"Jimmy:85\"],\n                ])\n            )\n        })\n    })\n\n    describe(\"findKey\", () => {\n        it(\"returns None for an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.findKey((n: number) => n === 20)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns the first key for which the predicate returns true (default sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"b\", 2],\n                        [\"d\", 4],\n                        [\"a\", 1],\n                        [\"c\", 3],\n                    ]),\n                    Map.findKey(s => s.length === 1)\n                )\n            ).toStrictEqual(Option.some(\"a\"))\n        })\n\n        it(\"returns None if no key matches the predicate (default sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"b\", 2],\n                        [\"d\", 4],\n                        [\"a\", 1],\n                        [\"c\", 3],\n                    ]),\n                    Map.findKey(s => s.length === 2)\n                )\n            ).toStrictEqual(Option.none)\n        })\n\n        it(\"returns the first key for which the predicate returns true (custom sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Mozzarella\", age: 2 }, 2],\n                        [{ name: \"Provolone\", age: 1 }, 4],\n                        [{ name: \"Provolone\", age: 0.5 }, 1],\n                        [{ name: \"Cheddar\", age: 3 }, 3],\n                    ]),\n                    Map.findKey(\n                        cheese => cheese.name === \"Provolone\",\n                        cheeseByAgeComparer\n                    )\n                )\n            ).toStrictEqual(Option.some({ name: \"Provolone\", age: 0.5 }))\n        })\n\n        it(\"returns None if no key matches the predicate (custom sort)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Mozzarella\", age: 2 }, 2],\n                        [{ name: \"Provolone\", age: 1 }, 4],\n                        [{ name: \"Provolone\", age: 0.5 }, 1],\n                        [{ name: \"Cheddar\", age: 3 }, 3],\n                    ]),\n                    Map.findKey(cheese => cheese.name === \"Muenster\", cheeseByAgeComparer)\n                )\n            ).toStrictEqual(Option.none)\n        })\n    })\n\n    describe(\"empty\", () => {\n        it(\"returns an empty map\", () => {\n            expect(Map.empty()).toStrictEqual(new globalThis.Map())\n        })\n    })\n\n    describe(\"exists\", () => {\n        it(\"returns false for an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.exists(() => true)\n                )\n            ).toBe(false)\n        })\n\n        it(\"returns false if no value in the map matches the predicate\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 3],\n                        [\"Mouse\", 0],\n                    ]),\n                    Map.exists(n => n < 0)\n                )\n            ).toBe(false)\n        })\n\n        it(\"returns true if at least one value in the map matches the predicate\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 3],\n                        [\"Mouse\", 0],\n                    ]),\n                    Map.exists(n => n > 2)\n                )\n            ).toBe(true)\n        })\n    })\n\n    describe(\"change\", () => {\n        describe(\"default equality\", () => {\n            it(\"returns the map unchanged if the key doesn't exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [\"Cat\", 1],\n                            [\"Dog\", 2],\n                        ]),\n                        Map.change(\"Mouse\", n => n + 1)\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 2],\n                    ])\n                )\n            })\n\n            it(\"returns the map with changed binding if the key does exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [\"Cat\", 1],\n                            [\"Dog\", 2],\n                        ]),\n                        Map.change(\"Dog\", n => n + 1)\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [\"Cat\", 1],\n                        [\"Dog\", 3],\n                    ])\n                )\n            })\n        })\n\n        describe(\"custom equality\", () => {\n            it(\"returns the map unchanged if the key doesn't exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [{ name: \"Cheddar\", age: 1 }, 1],\n                            [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                        ]),\n                        Map.change(\n                            { name: \"Provolone\", age: 0 },\n                            n => n + 1,\n                            cheeseEqualityComparer\n                        )\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [{ name: \"Cheddar\", age: 1 }, 1],\n                        [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                    ])\n                )\n            })\n\n            it(\"returns the map with changed binding if the key does exist\", () => {\n                expect(\n                    pipe(\n                        Map.ofArray([\n                            [{ name: \"Cheddar\", age: 1 }, 1],\n                            [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                        ]),\n                        Map.change(\n                            { name: \"Cheddar\", age: 1 },\n                            n => n + 1,\n                            cheeseEqualityComparer\n                        )\n                    )\n                ).toStrictEqual(\n                    Map.ofArray([\n                        [{ name: \"Cheddar\", age: 1 }, 2],\n                        [{ name: \"Mozzarella\", age: 0.25 }, 2],\n                    ])\n                )\n            })\n        })\n    })\n\n    describe(\"remove\", () => {\n        it(\"removes the key from the map (default equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord<string, number>({\n                        DinJarin: 10,\n                        Meredith: 20,\n                        Grogu: 9001,\n                    }),\n                    Map.remove(\"Meredith\")\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"DinJarin\", 10],\n                    [\"Grogu\", 9001],\n                ])\n            )\n        })\n\n        it(\"doesn't change the map if the key doesn't exist (default equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord<string, number>({\n                        DinJarin: 10,\n                        Grogu: 9001,\n                    }),\n                    Map.remove(\"Jimmy\")\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"DinJarin\", 10],\n                    [\"Grogu\", 9001],\n                ])\n            )\n        })\n\n        it(\"removes the key from the map (custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray(\n                        [\n                            [{ name: \"American\", age: 0.1 }, 0],\n                            [{ name: \"Provolone\", age: 2 }, 23],\n                            [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                        ],\n                        cheeseEqualityComparer\n                    ),\n                    Map.remove({ name: \"Provolone\", age: 2 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(\n                Map.ofArray(\n                    [\n                        [{ name: \"American\", age: 0.1 }, 0],\n                        [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                    ],\n                    cheeseEqualityComparer\n                )\n            )\n        })\n\n        it(\"doesn't change the map if the key doesn't exist (custom equality)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray(\n                        [\n                            [{ name: \"American\", age: 0.1 }, 0],\n                            [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                        ],\n                        cheeseEqualityComparer\n                    ),\n                    Map.remove({ name: \"Provolone\", age: 2 }, cheeseEqualityComparer)\n                )\n            ).toStrictEqual(\n                Map.ofArray(\n                    [\n                        [{ name: \"American\", age: 0.1 }, 0],\n                        [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n                    ],\n                    cheeseEqualityComparer\n                )\n            )\n        })\n    })\n\n    describe(\"iter\", () => {\n        it(\"never calls the given fucntion for an empty map\", () => {\n            const fn = vi.fn()\n            pipe(Map.empty(), Map.iter(fn))\n            expect(fn).not.toHaveBeenCalled()\n        })\n", "        it(\"executes the given function for every key/value pair\", () => {\n            // arrange\n            const fn = vi.fn()\n            // act\n            pipe(\n                Map.ofRecord({\n                    \"red team\": 44,\n                    \"blue team\": 48,\n                    \"green team\": 13,\n                }),\n                Map.iter(fn)\n            )\n            // assert\n            expect(fn).toHaveBeenCalledTimes(3)\n            ;(\n                [\n                    [\"red team\", 44],\n                    [\"blue team\", 48],\n                    [\"green team\", 13],\n                ] as const\n            ).forEach(([k, v]) => expect(fn).toHaveBeenCalledWith(k, v))\n        })\n    })\n\n    describe(\"isEmpty\", () => {\n        it.each([\n            [true, \"empty\", []],\n            [\n                false,\n                \"not empty\",\n                [\n                    [\"key1\", \"val1\"],\n                    [\"key2\", \"val2\"],\n                ],\n            ],\n        ] as const)(\"returns %o if the map is %s\", (expected, _, bindings) => {\n            expect(pipe(Map.ofArray(bindings), Map.isEmpty)).toBe(expected)\n        })\n    })\n\n    describe(\"size\", () => {\n        it.each([\n            [0, []],\n            [1, [[\"dog\", 1]]],\n            [\n                3,\n                [\n                    [\"dog\", 1],\n                    [\"cat\", 2],\n                    [\"mouse\", 3],\n                ],\n            ],\n        ] as const)(\"returns the size (%i) of the map\", (expected, bindings) => {\n            expect(pipe(Map.ofArray(bindings), Map.size)).toBe(expected)\n        })\n    })\n\n    describe(\"keys\", () => {\n        it.each([\n            [\"empty\", [], []],\n            [\n                \"non-empty\",\n                [\n                    [\"Johnny\", 1],\n                    [\"Amy\", 2],\n                    [\"Leonard\", 3],\n                ],\n                [\"Amy\", \"Johnny\", \"Leonard\"],\n            ],\n        ] as const)(\n            \"returns the keys in the expected order when the map is %s (default comparison)\",\n            (_, bindings, expected) => {\n                expect(pipe(Map.ofArray(bindings), Map.keys())).toStrictEqual(expected)\n            }\n        )\n\n        it.each([\n            [\"empty\", [], []],\n            [\n                \"non-empty\",\n                [\n                    [{ name: \"Muenster\", age: 3 }, \"A+\"],\n                    [{ name: \"Cheddar\", age: 2 }, \"B\"],\n                    [{ name: \"Kraft Single\", age: 4 }, \"F-\"],\n                ],\n                [\n                    { name: \"Cheddar\", age: 2 },\n                    { name: \"Muenster\", age: 3 },\n                    { name: \"Kraft Single\", age: 4 },\n                ],\n            ],\n        ])(\n            \"returns the keys in the expected order when the map is %s (custom comparison)\",\n            (_, bindings, expected) => {\n                expect(\n                    pipe(\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n                        Map.ofArray<Cheese, string>(bindings as any),\n                        Map.keys(cheeseByAgeComparer)\n                    )\n                ).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"values\", () => {\n        it.each([\n            [\"empty\", [], []],\n            [\n                \"non-empty\",\n                [\n                    [\"Johnny\", 2],\n                    [\"Amy\", 3],\n                    [\"Leonard\", 1],\n                ],\n                [1, 2, 3],\n            ],\n        ] as const)(\n            \"returns the values in the expected order (including duplicates) when the map is %s (default comparison)\",\n            (_, bindings, expected) => {\n                expect(pipe(Map.ofArray(bindings), Map.values())).toStrictEqual(expected)\n            }\n        )\n\n        it.each([\n            [\"empty\", [], []],\n            [\n                \"non-empty\",\n                [\n                    [\"1\", { name: \"Muenster\", age: 3 }],\n                    [\"2\", { name: \"Cheddar\", age: 2 }],\n                    [\"3\", { name: \"Kraft Single\", age: 4 }],\n                ],\n                [\n                    { name: \"Cheddar\", age: 2 },\n                    { name: \"Muenster\", age: 3 },\n                    { name: \"Kraft Single\", age: 4 },\n                ],\n            ],\n        ])(\n            \"returns the values in the expected order (including duplicates) when the map is %s (custom comparison)\",\n            (_, bindings, expected) => {\n                expect(\n                    pipe(\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n                        Map.ofArray<string, Cheese>(bindings as any),\n                        Map.values(cheeseByAgeComparer)\n                    )\n                ).toStrictEqual(expected)\n            }\n        )\n    })\n\n    describe(\"toArray\", () => {\n        it(\"returns an empty array for an empty map\", () => {\n            expect(pipe(new globalThis.Map(), Map.toArray())).toStrictEqual([])\n        })\n\n        it(\"returns an array of tuples sorted by key (default comparison)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"b\", 2],\n                        [\"d\", 4],\n                        [\"c\", 3],\n                        [\"a\", 1],\n                    ]),\n                    Map.toArray()\n                )\n            ).toStrictEqual([\n                [\"a\", 1],\n                [\"b\", 2],\n                [\"c\", 3],\n                [\"d\", 4],\n            ])\n        })\n\n        it(\"returns an array of tuples sorted by key (custom comparison)\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Gouda\", age: 2 }, 2],\n                        [{ name: \"Mozzarella\", age: 4 }, 4],\n                        [{ name: \"Garganzola\", age: 3 }, 3],\n                        [{ name: \"Swiss\", age: 1 }, 1],\n                    ]),\n                    Map.toArray(cheeseByAgeComparer)\n                )\n            ).toStrictEqual([\n                [{ name: \"Swiss\", age: 1 }, 1],\n                [{ name: \"Gouda\", age: 2 }, 2],\n                [{ name: \"Garganzola\", age: 3 }, 3],\n                [{ name: \"Mozzarella\", age: 4 }, 4],\n            ])\n        })\n    })\n\n    describe(\"filter\", () => {\n        it(\"returns an empty map if given an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.filter(() => true)\n                )\n            ).toStrictEqual(Map.empty())\n        })\n\n        it(\"filters out keys that fail the predicate\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord({\n                        cheese: \"yum\",\n                        soup: \"yum\",\n                        veggies: \"bleh\",\n                        crackers: \"yum\",\n                        \"lima beans\": \"bleh\",\n                    }),\n                    Map.filter((_, v) => v === \"yum\")\n                )\n            ).toStrictEqual(\n                Map.ofArray([\n                    [\"cheese\", \"yum\"],\n                    [\"soup\", \"yum\"],\n                    [\"crackers\", \"yum\"],\n                ])\n            )\n        })\n    })\n\n    describe(\"every\", () => {\n        it(\"returns true for an empty map\", () => {\n            expect(\n                pipe(\n                    Map.empty(),\n                    Map.every(() => false)\n                )\n            ).toBe(true)\n        })\n\n        it(\"returns true if every key/value pair holds true\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord({\n                        John: \"Hancock\",\n                        James: \"Monroe\",\n                        Alexander: \"Hamilton\",\n                    }),\n                    Map.every((first, last) => first.length > 0 && last.length > 0)\n                )\n            ).toBe(true)\n        })\n\n        it(\"returns false if not every key/value pair holds true\", () => {\n            expect(\n                pipe(\n                    Map.ofRecord({\n                        John: \"\",\n                        James: \"Monroe\",\n                        Alexander: \"Hamilton\",\n                    }),\n                    Map.every((first, last) => first.length > 0 && last.length > 0)\n                )\n            ).toBe(false)\n        })\n    })\n\n    describe(\"reduce\", () => {\n        it(\"reduces using default sort order\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"a\", \"1\"],\n                        [\"c\", \"3\"],\n                        [\"b\", \"2\"],\n                    ]),\n                    Map.reduce(\"\", (acc, k, v) => `${acc}${k}${v}`)\n                )\n            ).toBe(\"a1b2c3\")\n        })\n\n        it(\"reduces using custom sort order\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Parmesean\", age: 1 }, \"Parm\"],\n                        [{ name: \"Gouda\", age: 3 }, \"Goodie\"],\n                        [{ name: \"Gruyere\", age: 2 }, \"Weird Swiss\"],\n                    ]),\n                    Map.reduce(\n                        \"\",\n                        (acc, { name }, v) => `${acc}\\n${name}-${v}`,\n                        cheeseByAgeComparer\n                    ),\n                    String.trim\n                )\n            ).toBe(\n                pipe(\n                    `\nParmesean-Parm\nGruyere-Weird Swiss\nGouda-Goodie\n                    `,\n                    String.trim\n                )\n            )\n        })\n    })\n\n    describe(\"reduceRight\", () => {\n        it(\"reduces in reverse order, using default sort order\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [\"a\", \"1\"],\n                        [\"c\", \"3\"],\n                        [\"b\", \"2\"],\n                    ]),\n                    Map.reduceRight(\"\", (acc, k, v) => `${acc}${k}${v}`)\n                )\n            ).toBe(\"c3b2a1\")\n        })\n\n        it(\"reduces in reverse order using custom sort order\", () => {\n            expect(\n                pipe(\n                    Map.ofArray([\n                        [{ name: \"Parmesean\", age: 1 }, \"Parm\"],\n                        [{ name: \"Gouda\", age: 3 }, \"Goodie\"],\n                        [{ name: \"Gruyere\", age: 2 }, \"Weird Swiss\"],\n                    ]),\n                    Map.reduceRight(\n                        \"\",\n                        (acc, { name }, v) => `${acc}\\n${name}-${v}`,\n                        cheeseByAgeComparer\n                    ),\n                    String.trim\n                )\n            ).toBe(\n                pipe(\n                    `\nGouda-Goodie\nGruyere-Weird Swiss\nParmesean-Parm\n                    `,\n                    String.trim\n                )\n            )\n        })\n    })\n})\n"]}
{"filename": "test/EqualityComparer.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport * as EqualityComparer from \"../src/EqualityComparer\"\n\ninterface ParentThing {\n    readonly id: string\n    readonly child: Thing\n}\n\ninterface Thing {\n    readonly id: number\n}\n\ndescribe(\"EqualityComparer\", () => {\n    describe(\"ofEquals\", () => {\n        const thing = { id: 1 }\n\n        it.each([\n            [true, \"equal\", { id: 12 }, { id: 12 }],\n            [false, \"not equal\", { id: 3 }, { id: 9 }],\n            [true, \"same exact reference\", thing, thing],\n        ])(\n            \"constructs an equality comparer from an equals function (returns %o when %s)\",\n            (expected, _, t1, t2) => {\n                const eq = EqualityComparer.ofEquals<Thing>(\n                    (thing1, thing2) => thing1.id === thing2.id\n                )\n\n                expect(eq.equals(t1, t2)).toBe(eq.equals(t2, t1))\n                expect(eq.equals(t1, t2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"deriveFrom\", () => {\n        const thing = { id: 1 }\n\n        it.each([\n            [true, \"equal\", { id: 12 }, { id: 12 }],\n            [false, \"not equal\", { id: 3 }, { id: 9 }],\n            [true, \"same exact reference\", thing, thing],\n        ])(\n            \"constructs an equality comparer from an existing one + a (contra)map function [returns %o when %s]\",\n            (expected, _, t1, t2) => {\n                const eq = EqualityComparer.deriveFrom<number, Thing>(\n                    EqualityComparer.Number,\n                    thing => thing.id\n                )\n\n                expect(eq.equals(t1, t2)).toBe(eq.equals(t2, t1))\n                expect(eq.equals(t1, t2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"ofStruct\", () => {\n        const eqChild = EqualityComparer.ofStruct<Thing>({\n            id: EqualityComparer.Number,\n        })\n\n        const eqParent = EqualityComparer.ofStruct<ParentThing>({\n            id: EqualityComparer.String,\n            child: eqChild,\n        })\n\n        it(\"returns true if comparing the exact same reference\", () => {\n            const parent: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            expect(eqParent.equals(parent, parent)).toBe(true)\n        })\n\n        it(\"returns true if comparing two structurally equivalent values\", () => {\n            const p1: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            const p2: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            expect(eqParent.equals(p1, p2)).toBe(eqParent.equals(p2, p1))\n            expect(eqParent.equals(p1, p2)).toBe(true)\n        })\n\n        it(\"returns false if comparing two structurally inequivalent values\", () => {\n            const p1: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            const p2: ParentThing = {\n                id: \"10\",\n                child: { id: 20 },\n            }\n\n            expect(eqParent.equals(p1, p2)).toBe(eqParent.equals(p2, p1))\n            expect(eqParent.equals(p1, p2)).toBe(false)\n        })\n    })\n\n    describe(\"Date\", () => {\n        const piDay = new Date(2023, 2, 14)\n\n        it.each([\n            [true, \"equal\", new Date(2023, 2, 15), new Date(2023, 2, 15)],\n            [true, \"same exact reference\", piDay, piDay],\n            [false, \"not equal\", new Date(2023, 2, 15), new Date(2025, 1, 15)],\n        ])(\n            \"provides equality for dates (returns %o when %s)\",\n            (expected, _, dt1, dt2) => {\n                const { equals } = EqualityComparer.Date\n                expect(equals(dt1, dt2)).toBe(equals(dt2, dt1))\n                expect(equals(dt1, dt2)).toBe(expected)\n            }\n        )\n    })\n})\n", "interface Thing {\n    readonly id: number\n}\n\ndescribe(\"EqualityComparer\", () => {\n    describe(\"ofEquals\", () => {\n        const thing = { id: 1 }\n\n        it.each([\n            [true, \"equal\", { id: 12 }, { id: 12 }],\n            [false, \"not equal\", { id: 3 }, { id: 9 }],\n            [true, \"same exact reference\", thing, thing],\n        ])(\n            \"constructs an equality comparer from an equals function (returns %o when %s)\",\n            (expected, _, t1, t2) => {\n                const eq = EqualityComparer.ofEquals<Thing>(\n                    (thing1, thing2) => thing1.id === thing2.id\n                )\n\n                expect(eq.equals(t1, t2)).toBe(eq.equals(t2, t1))\n                expect(eq.equals(t1, t2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"deriveFrom\", () => {\n        const thing = { id: 1 }\n\n        it.each([\n            [true, \"equal\", { id: 12 }, { id: 12 }],\n            [false, \"not equal\", { id: 3 }, { id: 9 }],\n            [true, \"same exact reference\", thing, thing],\n        ])(\n            \"constructs an equality comparer from an existing one + a (contra)map function [returns %o when %s]\",\n            (expected, _, t1, t2) => {\n                const eq = EqualityComparer.deriveFrom<number, Thing>(\n                    EqualityComparer.Number,\n                    thing => thing.id\n                )\n\n                expect(eq.equals(t1, t2)).toBe(eq.equals(t2, t1))\n                expect(eq.equals(t1, t2)).toBe(expected)\n            }\n        )\n    })\n\n    describe(\"ofStruct\", () => {\n        const eqChild = EqualityComparer.ofStruct<Thing>({\n            id: EqualityComparer.Number,\n        })\n\n        const eqParent = EqualityComparer.ofStruct<ParentThing>({\n            id: EqualityComparer.String,\n            child: eqChild,\n        })\n\n        it(\"returns true if comparing the exact same reference\", () => {\n            const parent: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            expect(eqParent.equals(parent, parent)).toBe(true)\n        })\n\n        it(\"returns true if comparing two structurally equivalent values\", () => {\n            const p1: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            const p2: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            expect(eqParent.equals(p1, p2)).toBe(eqParent.equals(p2, p1))\n            expect(eqParent.equals(p1, p2)).toBe(true)\n        })\n\n        it(\"returns false if comparing two structurally inequivalent values\", () => {\n            const p1: ParentThing = {\n                id: \"101\",\n                child: { id: 20 },\n            }\n\n            const p2: ParentThing = {\n                id: \"10\",\n                child: { id: 20 },\n            }\n\n            expect(eqParent.equals(p1, p2)).toBe(eqParent.equals(p2, p1))\n            expect(eqParent.equals(p1, p2)).toBe(false)\n        })\n    })\n\n    describe(\"Date\", () => {\n        const piDay = new Date(2023, 2, 14)\n\n        it.each([\n            [true, \"equal\", new Date(2023, 2, 15), new Date(2023, 2, 15)],\n            [true, \"same exact reference\", piDay, piDay],\n            [false, \"not equal\", new Date(2023, 2, 15), new Date(2025, 1, 15)],\n        ])(\n            \"provides equality for dates (returns %o when %s)\",\n            (expected, _, dt1, dt2) => {\n                const { equals } = EqualityComparer.Date\n                expect(equals(dt1, dt2)).toBe(equals(dt2, dt1))\n                expect(equals(dt1, dt2)).toBe(expected)\n            }\n        )\n    })\n})\n"]}
{"filename": "test/function.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport { tee, teeAsync } from \"../src/function\"\nimport { flow, pipe } from \"../src/Composition\"\n\ndescribe(\"function\", () => {\n    describe(\"tee\", () => {\n        it(\"executes the side effect and passes through the value\", () => {\n            // arrange\n            const log = vi.fn()\n            const double = (n: number) => n * 2", "            const log = vi.fn()\n            const double = (n: number) => n * 2\n            // act\n            const actual = pipe(42, tee(log), double, String)\n            // assert\n            expect(actual).toBe(\"84\")\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(42)\n        })\n    })", "        })\n    })\n\n    describe(\"teeAsync\", () => {\n        it(\"executes the side effect on the resolved value and passes through the promise\", async () => {\n            // arrange\n            const log: (n: number) => void = vi.fn()\n            const double = (n: number) => n * 2\n            // act\n            const actual = await pipe(Promise.resolve(42), teeAsync(log), p =>", "            // act\n            const actual = await pipe(Promise.resolve(42), teeAsync(log), p =>\n                p.then(flow(double, String))\n            )\n            // assert\n            expect(actual).toBe(\"84\")\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(42)\n        })\n    })", "        })\n    })\n})\n"]}
{"filename": "test/Async.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\nimport { pipe } from \"../src/Composition\"\nimport * as Async from \"../src/Async\"\n\ntype Async<A> = Async.Async<A>\n\ndescribe(\"Async\", () => {\n    describe(\"constructors\", () => {\n        describe(\"of\", () => {\n            it(\"wraps a value in an Async\", async () => {\n                expect(await Async.of(22)()).toBe(22)\n            })\n        })\n\n        describe(\"ofPromise\", () => {\n            it(\"wraps a promise in a lambda\", async () => {\n                expect(\n                    await pipe(\n                        Promise.resolve(\"zebra skin\"),\n                        Async.ofPromise,\n                        Async.map(s => s.length),\n                        Async.start\n                    )\n                ).toBe(10)\n            })\n        })\n    })\n\n    describe(\"map\", () => {\n        it(\"maps the inner value\", async () => {\n            expect(\n                await pipe(\n                    Async.of(\"cheese\"),\n                    Async.map(s => `${s} melted`),\n                    Async.start\n                )\n            ).toBe(\"cheese melted\")\n        })\n    })\n\n    describe(\"bind\", () => {\n        it(\"flatMaps the inner value\", async () => {\n            // arrange\n            const asyncIncr = (n: number) => Async.of(n + 1)\n            // act\n            const actual = await pipe(Async.of(2), Async.bind(asyncIncr), Async.start)\n            // assert\n            expect(actual).toBe(3)\n        })\n    })\n\n    describe(\"flatten\", () => {\n        it(\"flattens a nested structure\", async () => {\n            expect(await pipe(Async.of(Async.of(\"a\")), Async.flatten, Async.start)).toBe(\n                \"a\"\n            )\n        })\n    })\n\n    describe(\"sequential\", () => {\n        it(\"executes the computations in series and collects the results\", async () => {\n            // arrange\n            vi.useFakeTimers()\n\n            const comp1 = pipe(Async.of(\"1\"))\n            const comp2 = pipe(Async.of(\"2\"), Async.delay(500))\n            const comp3 = pipe(Async.of(\"3\"), Async.delay(1000))\n            // act\n            const promise = pipe([comp3, comp2, comp1], Async.sequential, Async.start)\n            await vi.runAllTimersAsync()\n            const actual = await promise\n            // assert\n            expect(actual).toStrictEqual([\"3\", \"2\", \"1\"])\n            // cleanup\n            vi.useRealTimers()\n        })\n    })\n\n    describe(\"parallel\", () => {\n        it(\"executes the computations in parallel and collects the results\", async () => {\n            // arrange\n            vi.useFakeTimers()\n            const log = vi.fn()\n\n            const comp1 = pipe(Async.of(\"1\"), Async.tee(log))\n            const comp2 = pipe(Async.of(\"2\"), Async.delay(500), Async.tee(log))\n            const comp3 = pipe(Async.of(\"3\"), Async.delay(1000), Async.tee(log))\n            // act\n            const promise = pipe([comp3, comp2, comp1], Async.parallel, Async.start)\n            await vi.runAllTimersAsync()\n            const actual = await promise\n            // assert\n            expect(log).toHaveBeenCalledTimes(3)\n            expect(log.mock.calls).toStrictEqual([[\"1\"], [\"2\"], [\"3\"]])\n            ;[\"1\", \"2\", \"3\"].forEach(i => {\n                expect(actual).toContain(i)\n            })\n            // cleanup\n            vi.useRealTimers()\n        })\n    })\n\n    describe(\"asyncify\", () => {", "        it(\"converts a function with a single argument\", async () => {\n            // arrange\n            const fakeIO = (fileName: string) => Promise.resolve([\".txt\", fileName])\n\n            const asyncified = Async.asyncify(fakeIO)\n            // act\n            const actual = await asyncified(\"file\")()\n            // assert\n            expect(actual).toStrictEqual([\".txt\", \"file\"])\n        })\n", "        it(\"converts a function with multiple arguments\", async () => {\n            // arrange\n            const fakeIO = (fileName: string, lineNumber: number) =>\n                Promise.resolve([\".txt\", fileName, `L${lineNumber}`])\n\n            const asyncified = Async.asyncify(fakeIO)\n            // act\n            const actual = await asyncified(\"file\", 32)()\n            // assert\n            expect(actual).toStrictEqual([\".txt\", \"file\", \"L32\"])\n        })\n", "        it(\"converts a function with multiple, mixed, array, object, and primitive arguments\", async () => {\n            // arrange\n            const fakeIO = (\n                fileName: string,\n                extension: \".txt\" | \".md\",\n                lines: number[],\n                options?: { skipChecks?: boolean }\n            ) =>\n                Promise.resolve([\n                    extension,\n                    fileName,\n                    `Lines:${lines.join(\",\")}`,\n                    `Options:{ skipChecks = ${options?.skipChecks} }`,\n                ])\n\n            const asyncified = Async.asyncify(fakeIO)\n            // act\n            const actual = await asyncified(\"file\", \".md\", [2, 8, 22], {\n                skipChecks: false,\n            })()\n            // assert\n            expect(actual).toStrictEqual([\n                \".md\",\n                \"file\",\n                \"Lines:2,8,22\",\n                \"Options:{ skipChecks = false }\",\n            ])\n        })\n    })\n\n    describe(\"tee\", () => {\n        it(\"allows executing an arbitrary side effect without affecting the inner value\", async () => {\n            // arrange\n            const log = vi.fn<number[], void>()\n            const logDouble = (n: number) => log(n * 2)\n            // act\n            const actual = await pipe(\n                Async.of(100),\n                Async.tee(logDouble),\n                Async.map(String),\n                Async.start\n            )\n            // assert\n            expect(actual).toBe(\"100\")\n            expect(log).toHaveBeenCalledOnce()\n            expect(log).toHaveBeenCalledWith(200)\n        })\n    })\n\n    describe(\"start\", () => {\n        it(\"is equivalent to invoking the async as a lambda\", async () => {\n            // arrange\n            const mock = vi.fn(() => Promise.resolve(\"a\"))\n            const f: Async<string> = () => mock()\n            // act\n            const actual1 = await Async.start(f)\n            const actual2 = await f()\n            // assert\n            expect(mock).toHaveBeenCalledTimes(2)\n            expect(actual1).toBe(\"a\")\n            expect(actual2).toBe(\"a\")\n        })\n    })\n\n    describe(\"never\", () => {\n        it(\"never resolves\", () => {\n            // arrange\n            vi.useFakeTimers()\n            const f = vi.fn()\n            // act\n            void pipe(Async.never, Async.tee(f), Async.start)\n            vi.advanceTimersByTime(10_000_000)\n            // assert\n            expect(f).not.toHaveBeenCalled()\n            // cleanup\n            vi.useRealTimers()\n        })\n    })\n\n    describe(\"delay\", () => {\n        it(\"normalizes the delay to a natural number\", async () => {\n            // act\n            const setTimeoutSpy = vi.spyOn(globalThis, \"setTimeout\")\n            const actual = await pipe(Async.unit, Async.delay(-100), Async.start)\n            // assert\n            expect(actual).toBeDefined()\n            expect(setTimeoutSpy).toHaveBeenCalledWith(expect.anything(), 0)\n            expect(setTimeoutSpy).not.toHaveBeenCalledWith(expect.anything(), -100)\n        })\n    })\n})\n"]}
{"filename": "test/NonEmptyArray.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\nimport * as NonEmptyArray from \"../src/NonEmptyArray\"\nimport { pipe } from \"../src/Composition\"\nimport { String } from \"../src/string\"\nimport { OrderingComparer } from \"../src/OrderingComparer\"\nimport { EqualityComparer } from \"../src/EqualityComparer\"\n\ndescribe(\"NonEmptyArray\", () => {\n    describe(\"head\", () => {\n        it(\"returns the first element\", () => {", "    describe(\"head\", () => {\n        it(\"returns the first element\", () => {\n            expect(NonEmptyArray.head([12])).toBe(12)\n            expect(NonEmptyArray.head([\"a\", \"b\", \"c\"])).toBe(\"a\")\n        })\n    })\n\n    describe(\"destruct\", () => {\n        it(\"can destructure a singleton\", () => {\n            expect(NonEmptyArray.destruct([\"a\"])).toStrictEqual({", "        it(\"can destructure a singleton\", () => {\n            expect(NonEmptyArray.destruct([\"a\"])).toStrictEqual({\n                head: \"a\",\n                tail: [],\n            })\n        })\n\n        it(\"can destructure a non-singleton\", () => {\n            expect(NonEmptyArray.destruct([\"a\", \"b\", \"c\"])).toStrictEqual({\n                head: \"a\",", "            expect(NonEmptyArray.destruct([\"a\", \"b\", \"c\"])).toStrictEqual({\n                head: \"a\",\n                tail: [\"b\", \"c\"],\n            })\n        })\n    })\n\n    describe(\"map\", () => {\n        it(\"maps\", () => {\n            expect(", "        it(\"maps\", () => {\n            expect(\n                pipe(\n                    [1, 2, 3, 4] as const,\n                    NonEmptyArray.map(n => n * 3)\n                )\n            ).toStrictEqual([3, 6, 9, 12])\n        })\n    })\n", "    })\n\n    describe(\"bind\", () => {\n        it(\"flatMaps\", () => {\n            expect(\n                pipe(\n                    [\"a\", \"ab\", \"abc\", \"abcd\"] as const,\n                    NonEmptyArray.bind(String.split(\"\"))\n                )\n            ).toStrictEqual([\"a\", \"a\", \"b\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"d\"])", "                )\n            ).toStrictEqual([\"a\", \"a\", \"b\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"d\"])\n        })\n    })\n\n    describe(\"of\", () => {\n        it(\"produces a single-element array\", () => {\n            expect(NonEmptyArray.of(\"abc\")).toStrictEqual([\"abc\"])\n        })\n    })", "        })\n    })\n\n    describe(\"range\", () => {\n        it.each([\n            [1, 5, [1, 2, 3, 4, 5]],\n            [-3, 1, [-3, -2, -1, 0, 1]],\n            [0, 0, [0]],\n            [1, -20, [1]],\n            [4.1142, 11.0034, [4, 5, 6, 7, 8, 9, 10, 11]],", "            [1, -20, [1]],\n            [4.1142, 11.0034, [4, 5, 6, 7, 8, 9, 10, 11]],\n        ])(\"produces the expected result %i\", (start, end, expected) => {\n            expect(NonEmptyArray.range(start, end)).toStrictEqual(expected)\n        })\n    })\n\n    describe(\"make\", () => {\n        it(\"makes\", () => {\n            expect(NonEmptyArray.make(5, i => `${i + 1}`)).toStrictEqual([", "        it(\"makes\", () => {\n            expect(NonEmptyArray.make(5, i => `${i + 1}`)).toStrictEqual([\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n            ])\n        })\n", "        })\n\n        it(\"normalizes length to a natural number\", () => {\n            expect(NonEmptyArray.make(-20.11, () => \"a\")).toStrictEqual([\"a\"])\n        })\n    })\n\n    describe(\"reverse\", () => {\n        it(\"reverses\", () => {\n            expect(NonEmptyArray.reverse([1, 2, 3, 4, 5])).toStrictEqual([5, 4, 3, 2, 1])", "        it(\"reverses\", () => {\n            expect(NonEmptyArray.reverse([1, 2, 3, 4, 5])).toStrictEqual([5, 4, 3, 2, 1])\n        })\n    })\n\n    describe(\"sort\", () => {\n        it(\"sorts\", () => {\n            expect(\n                pipe([4, 8, -1, -5, 0], NonEmptyArray.sort(OrderingComparer.Number))\n            ).toStrictEqual([-5, -1, 0, 4, 8])", "                pipe([4, 8, -1, -5, 0], NonEmptyArray.sort(OrderingComparer.Number))\n            ).toStrictEqual([-5, -1, 0, 4, 8])\n        })\n    })\n\n    describe(\"getEqualityComparer\", () => {\n        it(\"always returns false if the arrays are different lengths\", () => {\n            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([1, 2, 3], [1, 2])).toBe(false)\n        })", "            expect(equals([1, 2, 3], [1, 2])).toBe(false)\n        })\n\n        it(\"returns false if the arrays are not equal element-by-element\", () => {\n            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([1, 2, 3], [1, 3, 2])).toBe(false)\n        })\n\n        it(\"returns true if the arrays are equal element-by-element\", () => {\n            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)", "        it(\"returns true if the arrays are equal element-by-element\", () => {\n            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)\n            expect(equals([1, 2, 3], [1, 2, 3])).toBe(true)\n        })\n    })\n})\n"]}
{"filename": "test/Variants.test.ts", "chunked_list": ["import { describe, it, expect, test } from \"vitest\"\nimport { variant, variantC, VariantOf } from \"../src/Variants\"\n\nconst BasicTest = variant({\n    emptyCase: {},\n    dataCase: (datum: string) => ({ datum }),\n    \"1234\": (field: number) => ({ field }),\n})\ntype BasicTest = VariantOf<typeof BasicTest>\n\ndescribe(\"Basic Tests\", () => {\n    describe(\"constructors\", () => {\n        it(\"generates a constructor (or constant for empty case) for every case\", () => {\n            expect(BasicTest.emptyCase).toStrictEqual({ _tag: \"EmptyCase\" })\n            expect(BasicTest.dataCase(\"ipsum\")).toStrictEqual({\n                _tag: \"DataCase\",\n                datum: \"ipsum\",\n            })\n            expect(BasicTest[1234](999)).toStrictEqual({ _tag: \"1234\", field: 999 })\n        })\n    })\n\n    describe(\"match\", () => {\n        const matcher = {\n            emptyCase: \"empty\",\n            dataCase: ({ datum }: { datum: string }) => `datum=${datum}`,\n            \"1234\": ({ field }: { field: number }) => `field=${field}`,\n        }\n\n        it.each([\n            [\"empty\", BasicTest.emptyCase],\n            [\"datum=ipsum\", BasicTest.dataCase(\"ipsum\")],\n            [\"field=999\", BasicTest[1234](999)],\n        ] as const)(\"produces %s for %o\", (expected, instance: BasicTest) => {\n            expect(BasicTest.match(matcher)(instance)).toBe(expected)\n        })\n    })\n\n    describe(\"matchOrElse\", () => {\n        const matcher = {\n            emptyCase: \"empty\",\n            dataCase: ({ datum }: { datum: string }) => `datum=${datum}`,\n            orElse: \"not matched\",\n        }\n\n        it.each([\n            [\"empty\", BasicTest.emptyCase],\n            [\"datum=ipsum\", BasicTest.dataCase(\"ipsum\")],\n            [\"not matched\", BasicTest[1234](999)],\n        ] as const)(\"produces %s for %o\", (expected, instance: BasicTest) => {\n            expect(BasicTest.matchOrElse(matcher)(instance)).toBe(expected)\n        })\n    })\n\n    describe(\"types\", () => {\n        it(\"contains the expected types in the types 'magic' property\", () => {\n            expect(BasicTest.types.emptyCase).toBe(\"EmptyCase\")\n            expect(BasicTest.types.dataCase).toBe(\"DataCase\")\n            expect(BasicTest.types[1234]).toBe(\"1234\")\n        })\n    })\n})\n\nconst ScopedTest = variantC(\n    {\n        dog: (name: string) => ({ name }),\n        cat: (livesLeft: number) => ({ livesLeft }),\n        fish: {},\n    },\n    \"type\",\n    \"Pets/\"\n)", "type BasicTest = VariantOf<typeof BasicTest>\n\ndescribe(\"Basic Tests\", () => {\n    describe(\"constructors\", () => {\n        it(\"generates a constructor (or constant for empty case) for every case\", () => {\n            expect(BasicTest.emptyCase).toStrictEqual({ _tag: \"EmptyCase\" })\n            expect(BasicTest.dataCase(\"ipsum\")).toStrictEqual({\n                _tag: \"DataCase\",\n                datum: \"ipsum\",\n            })\n            expect(BasicTest[1234](999)).toStrictEqual({ _tag: \"1234\", field: 999 })\n        })\n    })\n\n    describe(\"match\", () => {\n        const matcher = {\n            emptyCase: \"empty\",\n            dataCase: ({ datum }: { datum: string }) => `datum=${datum}`,\n            \"1234\": ({ field }: { field: number }) => `field=${field}`,\n        }\n\n        it.each([\n            [\"empty\", BasicTest.emptyCase],\n            [\"datum=ipsum\", BasicTest.dataCase(\"ipsum\")],\n            [\"field=999\", BasicTest[1234](999)],\n        ] as const)(\"produces %s for %o\", (expected, instance: BasicTest) => {\n            expect(BasicTest.match(matcher)(instance)).toBe(expected)\n        })\n    })\n\n    describe(\"matchOrElse\", () => {\n        const matcher = {\n            emptyCase: \"empty\",\n            dataCase: ({ datum }: { datum: string }) => `datum=${datum}`,\n            orElse: \"not matched\",\n        }\n\n        it.each([\n            [\"empty\", BasicTest.emptyCase],\n            [\"datum=ipsum\", BasicTest.dataCase(\"ipsum\")],\n            [\"not matched\", BasicTest[1234](999)],\n        ] as const)(\"produces %s for %o\", (expected, instance: BasicTest) => {\n            expect(BasicTest.matchOrElse(matcher)(instance)).toBe(expected)\n        })\n    })\n\n    describe(\"types\", () => {\n        it(\"contains the expected types in the types 'magic' property\", () => {\n            expect(BasicTest.types.emptyCase).toBe(\"EmptyCase\")\n            expect(BasicTest.types.dataCase).toBe(\"DataCase\")\n            expect(BasicTest.types[1234]).toBe(\"1234\")\n        })\n    })\n})\n\nconst ScopedTest = variantC(\n    {\n        dog: (name: string) => ({ name }),\n        cat: (livesLeft: number) => ({ livesLeft }),\n        fish: {},\n    },\n    \"type\",\n    \"Pets/\"\n)", "type ScopedTest = VariantOf<typeof ScopedTest>\n\nconst ConflictScopedTest = variantC(\n    {\n        dog: (name: string) => ({ name }),\n        cat: (livesLeft: number) => ({ livesLeft }),\n        fish: {},\n    },\n    \"type\",\n    \"Animals/\"\n)\n\ndescribe(\"Scoped Tests\", () => {\n    describe(\"constructors\", () => {\n        it(\"generates a constructor for every entry\", () => {\n            expect(ScopedTest.dog(\"Fido\")).toStrictEqual({\n                type: \"Pets/Dog\",\n                name: \"Fido\",\n            })\n            expect(ScopedTest.cat(7)).toStrictEqual({\n                type: \"Pets/Cat\",\n                livesLeft: 7,\n            })\n            expect(ScopedTest.fish).toStrictEqual({ type: \"Pets/Fish\" })\n        })\n    })\n\n    describe(\"match\", () => {\n        const matcher = {\n            dog: ({ name }: { name: string }) => `Woof! My name is ${name}.`,\n            cat: ({ livesLeft }: { livesLeft: number }) =>\n                `Meow! I have ${livesLeft} lives left.`,\n            fish: () => \"Blub blub.\",\n        }\n\n        it.each([\n            [\"Woof! My name is Fido.\", ScopedTest.dog(\"Fido\")],\n            [\"Meow! I have 7 lives left.\", ScopedTest.cat(7)],\n            [\"Blub blub.\", ScopedTest.fish],\n        ] as const)(\"produces %s for %o\", (expected, instance: ScopedTest) => {\n            expect(ScopedTest.match(matcher)(instance)).toBe(expected)\n        })\n    })\n\n    describe(\"matchOrElse\", () => {\n        const matcher = {\n            dog: \"dog\",\n            cat: \"cat\",\n            orElse: () => \"not a mammal\",\n        }\n\n        it.each([\n            [\"dog\", ScopedTest.dog(\"Fido\")],\n            [\"cat\", ScopedTest.cat(7)],\n            [\"not a mammal\", ScopedTest.fish],\n        ] as const)(\"produces %s for %o\", (expected, instance: ScopedTest) => {\n            expect(ScopedTest.matchOrElse(matcher)(instance)).toBe(expected)\n        })\n    })\n\n    describe(\"types\", () => {\n        it(\"contains the expected types in the types 'magic' property\", () => {\n            expect(ScopedTest.types.dog).toBe(\"Pets/Dog\")\n            expect(ScopedTest.types.cat).toBe(\"Pets/Cat\")\n            expect(ScopedTest.types.fish).toBe(\"Pets/Fish\")\n        })\n    })\n})\n\ndescribe(\"Conflicting Scope Tests\", () => {\n    describe(\"matchOrElse\", () => {\n        test(\"a variant with the same structure will not match if their scopes are different\", () => {\n            // arrange\n            const matcher = {\n                dog: \"pets dog\",\n                cat: \"pets cat\",\n                fish: \"pets fish\",\n                orElse: \"not in scope\",\n            }\n\n            const differentlyScoped = ConflictScopedTest.dog(\"Fido\")\n            // act\n            // `as any` is because redux reducers don't get type-checked at runtime\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n            const actual = ScopedTest.matchOrElse(matcher)(differentlyScoped as any)\n            // assert\n            expect(actual).toBe(\"not in scope\")\n        })\n    })\n\n    describe(\"match\", () => {\n        test(\"a variant with the same structure will not match if their scopes are different\", () => {\n            // arrange\n            const matcher = {\n                dog: () => \"pets dog\",\n                cat: () => \"pets cat\",\n                fish: () => \"pets fish\",\n            }\n\n            const differentlyScoped = ConflictScopedTest.dog(\"Fido\")\n            // act & assert\n            // `as any` is because redux reducers don't get type-checked at runtime\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n            expect(() => ScopedTest.match(matcher)(differentlyScoped as any)).toThrow(", "                \"Expected to be given a variant with scope Pets/. Actual type was Animals/Dog\"\n            )\n        })\n    })\n})\n"]}
{"filename": "src/DeferredResult.ts", "chunked_list": ["/**\n * The `DeferredResult` type is simply a convenient alias for a {@link Deferred} with an\n * inner value of a result {@link Result}. The `DeferredResult` type is frequently useful\n * for modeling the state of an asynchronous operation in something like a Redux store or\n * the `State` type of a React `useReducer` hook.\n *\n * The most common use case for this module is to make a decision about what text/UI\n * components to display to a user based on the state of some asynchronous operation that\n * is potentially ongoing.\n *\n * See docs for {@link match} and {@link matchOrElse} for code examples.\n *\n * @module\n */\n\nimport { pipe } from \"./Composition\"\nimport { Deferred } from \"./Deferred\"\nimport { assertExhaustive, Identity } from \"./prelude\"\nimport { Result } from \"./Result\"\n", "export type DeferredResult<A, E> = Deferred<Result<A, E>>\n\n/** @ignore */\ninterface DeferredResultMatcher<A, E, R> {\n    readonly notStarted: (() => R) | R\n    readonly inProgress: (() => R) | R\n    readonly resolvedOk: ((ok: A) => R) | R\n    readonly resolvedErr: ((ok: E) => R) | R\n}\n\n/** @ignore */", "interface PartialDeferredResultMatcher<A, E, R>\n    extends Partial<DeferredResultMatcher<A, E, R>> {\n    readonly orElse: (() => R) | R\n}\n\nconst isRawValue = <A, E, R>(caseFn: R | ((ok: A) => R) | ((err: E) => E)): caseFn is R =>\n    typeof caseFn !== \"function\"\n\nconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n    isRawValue(match) ? match : match(arg)\n\nconst objHasOptionalProp = <T extends object, P extends keyof T>(\n    prop: P,\n    obj: T\n): obj is Identity<T & Required<{ [key in P]: T[P] }>> => Object.hasOwn(obj, prop)\n\n/**\n * Exhaustive pattern match against a `DeferredResult`. Provide a raw value or", " * lambda function to use in each case: `notStarted`, `inProgress`, `resolvedOk`,\n * and `resolvedErr`. For `resolvedOk` and `resolvedErr`, the lambda function\n * will be given the attached \"ok\" or \"err\" data attached to the `Result`.\n *\n * @param matcher The matcher object containing the value or function to use in each case.\n *\n * @returns The result of evaluating the matcher case appropriate to the value.\n *\n * @group Pattern Matching\n *\n * @example\n * ```ts\n * declare const apiCallResponse: DeferredResult<Fruit, ApiError>\n * pipe(\n *     apiCallResponse,\n *     DeferredResult.match({\n *         notStarted: \"Not Started\",\n *         inProgress: \"In Progress\",\n *         resolvedOk: fruit => `Fruit is: ${fruit.name}`,\n *         resolvedErr: apiError => `Error was: ${ApiError.toString(apiError)}`\n *     })\n * )\n * ```\n */\nexport const match =\n    <A, E, R>(matcher: DeferredResultMatcher<A, E, R>) =>\n    (deferredResult: DeferredResult<A, E>) => {\n        switch (deferredResult._tag) {\n            case \"InProgress\":\n                return getMatcherResult(matcher.inProgress, undefined)\n            case \"NotStarted\":\n                return getMatcherResult(matcher.notStarted, undefined)\n            case \"Resolved\":\n                return pipe(\n                    deferredResult.resolved,\n                    Result.match({\n                        ok: a => getMatcherResult(matcher.resolvedOk, a),\n                        err: e => getMatcherResult(matcher.resolvedErr, e),\n                    })\n                )\n            /* c8 ignore next 2 */\n            default:\n                return assertExhaustive(deferredResult)\n        }\n    }\n\n/**\n * Non-exhaustive pattern match against a `DeferredResult` value. Provide a raw", " * value or a lambda function to use in the cases you care about. (But don't provide\n * all the cases; if you want an exhaustive pattern match, use {@link match} instead.)\n * Must provide an `orElse` matcher case to use if no other match case is hit.\n *\n * This function is especially useful for when you really only care about the \"resolved\"\n * cases, for instance.\n *\n * @param matcher The matcher object containing the value or function to use in each case.\n *\n * @returns The result of evaluating the matcher case appropriate to the value.\n *\n * @group Pattern Matching\n *\n * @example\n * ```ts\n *     declare const apiResponse: DeferredResult<Fruit, ApiError>\n *     pipe(\n *         apiResponse,\n *         DeferredResult.matchOrElse({\n *             resolvedOk: fruit => `Got fruit! ${fruit.name}`,\n *             resolvedErr: apiError => `Oh noes! ${apiError.message}`,\n *             orElse: \"Still loading...\"\n *         })\n *     )\n * ```\n */\nexport const matchOrElse =\n    <A, E, R>(matcher: PartialDeferredResultMatcher<A, E, R>) =>\n    (deferredResult: DeferredResult<A, E>) => {\n        switch (deferredResult._tag) {\n            case \"InProgress\":\n                return objHasOptionalProp(\"inProgress\", matcher)\n                    ? getMatcherResult(matcher.inProgress, undefined)\n                    : getMatcherResult(matcher.orElse, undefined)\n            case \"NotStarted\":\n                return objHasOptionalProp(\"notStarted\", matcher)\n                    ? getMatcherResult(matcher.notStarted, undefined)\n                    : getMatcherResult(matcher.orElse, undefined)\n            case \"Resolved\":\n                return pipe(\n                    deferredResult.resolved,\n                    Result.match({\n                        ok: a =>\n                            objHasOptionalProp(\"resolvedOk\", matcher)\n                                ? getMatcherResult(matcher.resolvedOk, a)\n                                : getMatcherResult(matcher.orElse, undefined),\n                        err: e =>\n                            objHasOptionalProp(\"resolvedErr\", matcher)\n                                ? getMatcherResult(matcher.resolvedErr, e)\n                                : getMatcherResult(matcher.orElse, undefined),\n                    })\n                )\n            /* c8 ignore next 2 */\n            default:\n                return assertExhaustive(deferredResult)\n        }\n    }\n\n/* c8 ignore start */\n/** @ignore */\nexport const DeferredResult = {\n    match,\n    matchOrElse,\n}\n/* c8 ignore start */\n"]}
{"filename": "src/Async.ts", "chunked_list": ["/**\n * The `Async` type represents a \"lazy\" or \"cold\" asynchronous\n * operation. This is in contrast to the default behavior of the\n * `Promise` type, which is \"hot\" by nature. That is, once you have\n * instantiated a `Promise`, whatever asynchronous or background\n * work it represents has already begun.\n *\n * The `Async` type is intended to be used to model computations that\n * should never fail. (Meaning, if a failure does occur, it is likely an\n * exceptional case and throwing an Error makes sense.) If you need\n * to model asynchronous computations that may fail, please use `AsyncResult`.\n *", " * The primary motivation for using a \"cold\" `Async` type is to\n * enable things like\n *\n * * deciding whether to use in-parallel or in-series sequencing\n * * avoiding unnecessary work (If an `Async` is constructed, but\n *   never started, no work is performed.)\n *\n * This API is curried and has been optimized for use right-to-left\n * function composition like `pipe` or `flow`.\n *\n * @example\n * ```ts\n * await pipe(\n *     [\n *         () => doThing1Async(),                   // `doThing1Async` returns a Promise\n *         () => doThing2Async(),                   // `doThing2Async` returns a Promise\n *     ],                                           // Async<string>[]\n *     Async.sequential,                            // Async<readonly string[]>\n *     Async.map(Array.map(s => s.toLowerCase())),  // Async<readonly string[]>\n *     Async.start                                  // Promise<readonly string[]>\n * ) // => [\"completed thing 1\", \"completed thing 2\"]\n * ```\n *", " * function composition like `pipe` or `flow`.\n *\n * @example\n * ```ts\n * await pipe(\n *     [\n *         () => doThing1Async(),                   // `doThing1Async` returns a Promise\n *         () => doThing2Async(),                   // `doThing2Async` returns a Promise\n *     ],                                           // Async<string>[]\n *     Async.sequential,                            // Async<readonly string[]>\n *     Async.map(Array.map(s => s.toLowerCase())),  // Async<readonly string[]>\n *     Async.start                                  // Promise<readonly string[]>\n * ) // => [\"completed thing 1\", \"completed thing 2\"]\n * ```\n *", " * @module Async\n */\n\n/** Represents a \"lazy\" or \"cold\" `Promise`. (See module-level documentation for more.) */\nexport interface Async<A> {\n    (): Promise<A>\n}\n\n/**\n * Constructs an Async from a raw value. Primarily useful for\n * writing tests, or for coercing some value into an Async for\n * use in a pipeline.\n *\n * @group Constructors\n *\n * @example\n * await Async.of(42)() // => 42\n */\nexport const of =\n    <A>(a: A): Async<A> =>\n    () =>\n        Promise.resolve(a)\n\n/**\n * Maps the inner value using the given function, producing\n * a new `Async`.\n *\n * @group Mapping\n *\n * @example\n * declare const getSecretValueFromApi: () => Promise<number>\n *\n * await pipe(\n *     getSecretValueFromApi,   // assume always returns 1\n *     Async.map(n => n + 1),   // Async<number>\n *     Async.start              // Promise<number>\n * ) // => 2\n */\nexport const map =\n    <A, B>(f: (a: A) => B) =>\n    (async: Async<A>): Async<B> =>\n    () =>\n        async().then(f)\n\n/**", " * Maps the inner value using the given function which also\n * returns an `Async`, and flattens the result. Also called\n * `flatMap`.\n *\n * @group Mapping\n *\n * @example\n * ```\n * await pipe(\n *     Async.of(\"a\"),\n *     Async.bind(s => Async.of(`${s}+b`)),\n *     Async.start\n * ) // => \"a+b\"\n * ```\n */\nexport const bind =\n    <A, B>(f: (a: A) => Async<B>) =>\n    (async: Async<A>): Async<B> =>\n    () =>\n        async().then(a => f(a)())\n\n/**\n * Alias of {@link bind}.\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/**\n * Unwraps a nested `Async<Async<A>>` structure so that\n * the inner value is only wrapped in a single `Async`.\n * (Note: {@link bind} can be thought of as just a map +\n * flatten operation.)\n *\n * @group Mapping\n *\n * @example\n * const nested = Async.of(Async.of(30))   // => Async<Async<number>>\n * const flattened = Async.flatten(nested) // => Async<number>\n */\nexport const flatten =\n    <A>(async: Async<Async<A>>): Async<A> =>\n    () =>\n        async().then(inner => inner())\n\n/**\n * An `Async` of an arbitrary non-nullish value. Useful for\n * adding delays at the beginning of a pipeline. Mostly used\n * in writing test code.\n *\n * @group Utils\n *\n * @example\n * ```\n * // Add a delay to the beginning of an `Async` pipeline\n * pipe(\n *     Async.unit,\n *     Async.delay(5_000),      // wait 5 seconds\n *     Async.map(console.log)\n * ) // logs `{}` after 5 seconds\n * ```\n */\nexport const unit: Async<unknown> = of({})\n\n/**\n * Adds an arbitrary delay to an `Async` computation.\n *\n * @group Utils\n *\n * @param delayInMilliseconds Normalized to a non-negative integer.\n *\n * @example\n * ```ts\n * pipe(\n *     Async.unit,\n *     Async.delay(5000), // wait 5 seconds\n *     Async.map(console.log)\n * ) // logs `{}` after 5 seconds\n * ```\n */\nexport const delay =\n    (delayInMilliseconds: number) =>\n    <A>(async: Async<A>): Async<A> =>\n    async () => {\n        const delay = delayInMilliseconds <= 0 ? 0 : Math.floor(delayInMilliseconds)\n        await new Promise(resolve => setTimeout(resolve, delay))\n\n        return await async()\n    }\n\n/**\n * Converts an array of `Async` computations into a single `Async`\n * computation that represents the in-series execution of each\n * individual `Async` computation.\n *\n * @group Sequencing\n *\n * @remarks\n * Order is guaranteed. The order of the given computations will be\n * preserved in the resultant array.\n */\nexport const sequential =\n    <A>(asyncs: readonly Async<A>[]): Async<readonly A[]> =>\n    async () => {\n        const results: A[] = []\n", "        for (let i = 0; i < asyncs.length; i++) {\n            results.push(await asyncs[i]())\n        }\n\n        return results\n    }\n\n/**\n * Invokes the `Async`. Identical to calling the `Async` as\n * a function. Useful for more expressive function pipelines.\n *\n * @group Utils\n *\n * @returns A `Promise` that will resolve to the result of the `Async` computation.\n *\n * @example\n * // simply invoke\n * const a = await Async.of(1)(); // => 1\n * // use a named function, useful for pipelining\n * const b = await pipe(\n *     Async.of(1),\n *     Async.start\n * ) // => 1\n */\nexport const start = <A>(async: Async<A>): Promise<A> => async()\n\n/**\n * Converts an array of `Async` computations into one `Async` computation\n * which represents the in-parallel execution of all the given `Async`\n * computations.\n *\n * @group Sequencing\n *\n * @remarks\n * This is effectively an alias for `Promise.all`. Order is not guaranteed.\n */\nexport const parallel =\n    <A>(asyncs: readonly Async<A>[]): Async<readonly A[]> =>\n    () =>\n        Promise.all(asyncs.map(start))\n\n/**\n * Wraps a `Promise` inside an `Async`.\n *\n * @group Constructors\n * @group Utils\n *\n * @remarks\n * **Note:** this does not mean that the given promise is made \"cold.\"\n * By definition, the given `Promise` is already \"hot\" when it is passed\n * to this function.\n *", " * a function. Useful for more expressive function pipelines.\n *\n * @group Utils\n *\n * @returns A `Promise` that will resolve to the result of the `Async` computation.\n *\n * @example\n * // simply invoke\n * const a = await Async.of(1)(); // => 1\n * // use a named function, useful for pipelining\n * const b = await pipe(\n *     Async.of(1),\n *     Async.start\n * ) // => 1\n */\nexport const start = <A>(async: Async<A>): Promise<A> => async()\n\n/**\n * Converts an array of `Async` computations into one `Async` computation\n * which represents the in-parallel execution of all the given `Async`\n * computations.\n *\n * @group Sequencing\n *\n * @remarks\n * This is effectively an alias for `Promise.all`. Order is not guaranteed.\n */\nexport const parallel =\n    <A>(asyncs: readonly Async<A>[]): Async<readonly A[]> =>\n    () =>\n        Promise.all(asyncs.map(start))\n\n/**\n * Wraps a `Promise` inside an `Async`.\n *\n * @group Constructors\n * @group Utils\n *\n * @remarks\n * **Note:** this does not mean that the given promise is made \"cold.\"\n * By definition, the given `Promise` is already \"hot\" when it is passed\n * to this function.\n *", " * If you want to convert a function that returns a `Promise` into a\n * function that returns an `Async`, see {@link asyncify}.\n *\n * @example\n * declare const safeWriteToFile: (content: string) => Promise<number>;\n * // Promises are always \"hot\" as soon as they are instantiated\n * const statusPromise = safeWriteToFile(\"I love cheese\"); // => Promise<number>\n * const statusAsync = Async.ofPromise(statusPromise);     // => Async<number>\n */\nexport const ofPromise =\n    <A>(promise: Promise<A>): Async<A> =>\n    () =>\n        promise\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**", " * Converts a function that returns a `Promise` into one that returns\n * an `Async` instead.\n *\n * @group Utils\n */\nexport const asyncify =\n    <F extends (...args: any[]) => Promise<any>>(\n        f: F\n    ): ((...args: Parameters<F>) => Async<Awaited<ReturnType<F>>>) =>\n    (...args: Parameters<F>) =>\n    () =>\n        f(...args)\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Execute an arbitrary side-effect within a pipeline of\n * `Async` functions. Useful for logging and debugging.\n * Passes the inner value through unchanged. This function\n * is sometimes called `do` or `tap`.\n *\n * @group Utils\n *\n * @param f Should not mutate its arguments. See {@link map} if you want to map the inner value.\n *\n * @example\n * ```ts\n * await pipe(\n *     Async.of(20),\n *     Async.delay(2_000),\n *     Async.tee(console.log), // logs `20` after 2 seconds\n *     Async.map(double),      // double receives the un-altered value `20`\n *     Async.start\n * ) // => 40 (after 2 seconds)\n * ```\n */\nexport const tee =\n    <A>(f: (a: A) => void) =>\n    (async: Async<A>): Async<A> =>\n    async () => {\n        const a = await async()\n        f(a)\n        return a\n    }\n\n/**\n * `Async` computation that never resolves. Primarily useful\n * for writing test code.\n *\n * @group Utils\n */\nexport const never: Async<never> = () =>\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    new Promise(() => {})\n\n/* c8 ignore start */\n/** @ignore */\nexport const Async = {\n    of,\n    map,\n    bind,\n    flatMap,\n    flatten,\n    sequential,\n    parallel,\n    start,\n    ofPromise,\n    delay,\n    unit,\n    asyncify,\n    never,\n    tee,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/OrderingComparer.ts", "chunked_list": ["/**\n * An `OrderingComparer` represents the ability to deterministcally sort a set of values.\n * Meaning, it should always give back the same sort order given the same set of values.\n *\n * The `compare` function returns `-1` if the first item is _less than_ the second\n * item. It returns `1` if the first item is _greater than_ the second item in the\n * sort order. It returns `0` if the first item is equivalent  to the second item\n * with reference to the sort order.\n *\n * **Note:** An `OrderingComparer` is not structurally compatible with an `Ord` from `fp-ts`\n * by default. You can get an `Ord`-compatible structure via {@link deriveEqualityComparer}.\n *\n * @example", " * interface Pet {\n *    readonly name: string\n *    readonly age: number\n * }\n *\n * class PetByAgeDescComparer implements OrderingComparer<Pet> {\n *    compare(p1: Pet, p2: Pet) {\n *        return p1.age === p2.age ? 0 : p1.age < p2.age ? 1 : -1\n *    }\n * }\n *", " * @module OrderingComparer\n */\n\nimport { String as S } from \"./string\"\nimport { EqualityComparer } from \"./EqualityComparer\"\n\n/**\n * A more strict version of the default JavaScript compare function result.\n * (i.e., `-1` and `1` are required specifically, not just `< 0` or `> 0`)\n */\ntype CompareResult =\n    | -1 // the first value is considered _less than_ the second value\n    | 0 // the first value is considered _the same as_ the second value\n    | 1 // the first value is considered _greater than_ the second value\n", "type CompareResult =\n    | -1 // the first value is considered _less than_ the second value\n    | 0 // the first value is considered _the same as_ the second value\n    | 1 // the first value is considered _greater than_ the second value\n\nexport interface OrderingComparer<A> {\n    compare(a1: A, a2: A): CompareResult\n}\n\n/**\n * Construct a new `OrderingComparer` based on a compare function that returns\n * `-1`, `0`, or `1`. See docs for {@link OrderingComparer}.\n *", " * Construct a new `OrderingComparer` based on a compare function that returns\n * `-1`, `0`, or `1`. See docs for {@link OrderingComparer}.\n *\n * **Note:** this function already checks for reference equality and will return\n * `0` in that case. (So the compare function you pass here does not necessarily\n * need to check for reference equality.)\n *\n * @group Constructors\n *\n * @returns A new `OrderingComparer` instance.\n */\nexport const ofCompare = <A>(\n    compare: OrderingComparer<A>[\"compare\"]\n): OrderingComparer<A> => ({\n    compare: (a1, a2) => (a1 === a2 ? 0 : compare(a1, a2)),\n})\n\n/**\n * Reverse the sort order produced by an `OrderingComparer`. For example, you could use this\n * to generate an `OrderingComparer` that would sort numbers in descending order.\n *\n * @group Utils\n *\n * @returns A new `OrderingComparer` with its sort order inverted.\n *\n * @example\n * const numberDesc = OrderingComparer.reverse(OrderingComparer.Number)\n */\nexport const reverse = <A>({ compare }: OrderingComparer<A>): OrderingComparer<A> =>\n    ofCompare((a1, a2) => compare(a2, a1))\n\n/**\n * Given you already have an `OrderingComparer` for some type `A`, and you know how to\n * map from some other type `B` to type `A`, you can effectively \"re-use\" your `OrderingComparer`\n * for type `B`. Also referred to commonly as `contramap`, because the mapping is going\n * from `B`&rarr;`A`, not from `A`&rarr;`B`.\n *\n * @group Utils\n * @group Constructors\n *\n * @param known The `OrderingComparer` that you already have.", " * @param map The function that can map from `B`&rarr;`A`.\n *\n * @returns A new `OrderingComparer` instance.\n */\nexport const deriveFrom = <A, B>(\n    known: OrderingComparer<A>,\n    map: (b: B) => A\n): OrderingComparer<B> => ({\n    compare: (b1, b2) => (b1 === b2 ? 0 : known.compare(map(b1), map(b2))),\n})\n\n/**\n * The default `OrderingComparer`. Converts both values to strings (if they\n * are not already) and does the default ASCII-based alphabetical comparison.\n *\n * @group Primitives\n */\nexport const Default: OrderingComparer<never> = ofCompare((a1, a2) => {\n    const a1String: string = S.isString(a1) ? a1 : globalThis.String(a1)\n    const a2String: string = S.isString(a2) ? a2 : globalThis.String(a2)\n\n    return a1String < a2String ? -1 : a1String > a2String ? 1 : 0\n})\n\n/**\n * Combine or merge multiple `OrderingComparer`s together **in a specific order**.\n * Conceptually, this means, \"Sort these values by this first, then this, then this\"\n * and so on.\n *\n * For example if you have an `OrderingComparer` that sorts strings alphabetically in\n * a case-insensitive manner (say, `alphabeticalCiComparer`) and an `OrderingComparer`\n * that sorts strings by their length (say, `lengthComparer`), you could generate a new\n * \"composite\" `OrderingComparer` that sorts alphabetically (case-insensitive) **and\n * then by** length.\n *\n * @example\n * const alphabeticalCiThenLengthComparer =\n *     OrderingComparer.getComposite(alphabeticalCiComparer, lengthComparer)\n *\n * @group Utils\n *\n * @remarks\n * If no comparers are passed, will default to {@link Default}\n *\n * @returns A new `OrderingComparer` instance.\n */\nexport const getComposite = <A>(\n    ...comparers: readonly OrderingComparer<A>[]\n): OrderingComparer<A> => {\n    /* c8 ignore next 3 */", "    if (comparers.length < 1) {\n        return Default\n    }\n\n    return ofCompare((a1, a2) =>\n        comparers.reduce<CompareResult>(\n            (result, nextComparer) =>\n                result !== 0 ? result : nextComparer.compare(a1, a2),\n            0\n        )\n    )\n}\n\n/**\n * An `OrderingComparer` for the built-in `number` type, in ascending order.\n *\n * @group Primitives\n */\nexport const Number: OrderingComparer<number> = ofCompare((n1, n2) =>\n    n2 - n1 > 0 ? -1 : 1\n)\n\n/**\n * An `OrderingComparer` for the built-in `string` type. Equivalent to {@link Default}.\n *\n * @group Primitives\n */\nexport const String: OrderingComparer<string> = Default\n\n/**\n * An `OrderingComparer` for the built-in `date` type, in ascending order.\n *\n * @group Primitives\n */\nexport const Date: OrderingComparer<Date> = deriveFrom(Number, date => date.valueOf())\n\n/**\n * Get a combined `OrderingComparer` and `EqualityComparer` by using the check,\n * \"Does the compare return `0`?\" as the equals function. This produces a type\n * that is compatible with `Ord` from `fp-ts`.\n *\n * @returns A new instance that implements both `EqualityComparer` and `OrderingComparer`\n *\n * @group Utils\n */\nexport const deriveEqualityComparer = <A>(\n    orderingComparer: OrderingComparer<A>\n): OrderingComparer<A> & EqualityComparer<A> => ({\n    compare: orderingComparer.compare,\n    equals: (a1, a2) => a1 === a2 || orderingComparer.compare(a1, a2) === 0,\n})\n\n/**\n * Get whether the _first_ value is **greater than** the _second_ value.\n *\n * @param orderingComparer The `OrderingComparer` to use for the comparison.\n *\n * @group Comparisons\n */\nexport const gt =\n    <A>({ compare }: OrderingComparer<A>) =>\n    (first: A, second: A): boolean =>\n        compare(first, second) === 1\n\n/**\n * Get whether the _first_ value is **greater than or equal to** the _second_ value.\n *\n * @param orderingComparer The `OrderingComparer` to use for the comparison.\n *\n * @group Comparisons\n */\nexport const geq =\n    <A>({ compare }: OrderingComparer<A>) =>\n    (first: A, second: A): boolean =>\n        compare(first, second) >= 0\n\n/**\n * Get whether the _first_ value is **less than** the _second_ value.\n *\n * @param orderingComparer The `OrderingComparer` to use for the comparison.\n *\n * @group Comparisons\n */\nexport const lt =\n    <A>({ compare }: OrderingComparer<A>) =>\n    (first: A, second: A): boolean =>\n        compare(first, second) === -1\n\n/**\n * Get whether the _first_ value is **less than or equal to** the _second_ value.\n *\n * @param orderingComparer The `OrderingComparer` to use for the comparison.\n *\n * @group Comparisons\n */\nexport const leq =\n    <A>({ compare }: OrderingComparer<A>) =>\n    (first: A, second: A): boolean =>\n        compare(first, second) <= 0\n\n/**\n * Get whether the value is between the upper and lower bound (inclusive).\n *\n * @group Comparisons\n */\nexport const isBetween =\n    <A>(orderingComparer: OrderingComparer<A>) =>\n    (lowerBound: A, upperBound: A) =>\n    (a: A): boolean =>\n        geq(orderingComparer)(a, lowerBound) && leq(orderingComparer)(a, upperBound)\n\n/* c8 ignore start */\n/** @ignore */\nexport const OrderingComparer = {\n    ofCompare,\n    reverse,\n    deriveFrom,\n    Default,\n    Number,\n    String,\n    Date,\n    getComposite,\n    deriveEqualityComparer,\n    gt,\n    geq,\n    lt,\n    leq,\n    isBetween,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/AsyncResult.ts", "chunked_list": ["/**\n * An `AsyncResult` represents an asynchronous computation that may either\n * succeed or fail (but should never throw). It is identical to `Async<Result<A, E>`.\n * This module simply provides convenience functions for working with that\n * type because they are so frequently used in real-world programming.\n *\n * Like `Async`, `AsyncResult` represents a \"cold\" computation that must be\n * explicitly invoked/started, in contrast to `Promise`s, which are \"hot.\"\n *\n * **Note:** You can use `Async.start` to start `AsyncResult`s because they are\n * just `Async`s with a constrained inner value type.\n *", " * @module AsyncResult\n */\n\nimport { Result } from \"./Result\"\nimport { Async } from \"./Async\"\nimport { pipe } from \"./Composition\"\n\n/**\n * @typeParam A The type of the `Ok` branch.\n * @typeParam E The type of the `Err` branch.\n */", " * @typeParam A The type of the `Ok` branch.\n * @typeParam E The type of the `Err` branch.\n */\nexport interface AsyncResult<A, E> {\n    (): Promise<Result<A, E>>\n}\n\n/**\n * Construct a new `Ok` instance.\n *\n * @group Constructors\n *\n * @returns A new `AsyncResult` containing the given ok value.\n */\nexport const ok =\n    <A, E = never>(ok: A): AsyncResult<A, E> =>\n    () =>\n        Promise.resolve(Result.ok(ok))\n\n/**\n * Construct a new `Err` instance.\n *\n * @group Constructors\n *\n * @returns A new `AsyncResult` using the given err value.\n */\nexport const err =\n    <E, A = never>(err: E): AsyncResult<A, E> =>\n    () =>\n        Promise.resolve(Result.err(err))\n\n/**", " * Maps the wrapped `Ok` value using the given function and\n * returns a new `AsyncResult`. Passes `Err` values through as-is.\n *\n * @group Mapping\n *\n * @example\n * await pipe(\n *     AsyncResult.ok(10),\n *     AsyncResult.map(n => n * 2),\n *     Async.start\n * ) // => Result.ok(20)\n */\nexport const map =\n    <A, B>(f: (a: A) => B) =>\n    <E>(async: AsyncResult<A, E>): AsyncResult<B, E> =>\n    () =>\n        async().then(Result.map(f))\n\n/**", " * Maps the wrapped `Err` value using the given function and\n * returns a new `AsyncResult`. Passes `Ok` values through as-is.\n *\n * @group Mapping\n *\n * @example\n * await pipe(\n *     AsyncResult.err(\"err\"),\n *     AsyncResult.mapErr(s => s.length),\n *     Async.start\n * ) // => Result.err(3)\n */\nexport const mapErr =\n    <Ea, Eb>(f: (a: Ea) => Eb) =>\n    <A>(async: AsyncResult<A, Ea>): AsyncResult<A, Eb> =>\n    () =>\n        async().then(Result.mapErr(f))\n\n/**\n * Takes two functions: one to map an `Ok`, one to map an `Err`.\n * Returns a new AsyncResult with the projected value based", " * on which function was used. Equivalent to calling {@link map} =\n * followed by {@link mapErr}.\n *\n * @group Mapping\n */\nexport const mapBoth =\n    <A1, A2, E1, E2>(mapOk: (a: A1) => A2, mapErr: (e: E1) => E2) =>\n    (async: AsyncResult<A1, E1>) =>\n    () =>\n        async().then(Result.mapBoth(mapOk, mapErr))\n\n/**", " * Maps the wrapped `Ok` value using a given function that\n * also returns an AsyncResult, and flattens the result.\n * Also commonly known as `flatpMap`.\n *\n * @group Mapping\n *\n * @example\n * declare const getNumberOfLines: (fileName: string) => AsyncResult<number, Error>\n * declare const sendToServer: (numLines: number) => AsyncResult<{}, Error>\n *\n * await pipe(\n *     \"log.txt\",                       // string\n *     getNumberOfLines,                // AsyncResult<number, Error>\n *     AsyncResult.bind(sendToServer),  // AsyncResult<{}, Error>\n *     Async.start                      // Promise<Result<{}, Error>>\n * )\n * // returns Result.ok({}) if everything succeeds\n * // otherwise returns Result.err(Error) if something\n * // fell down along the way\n */\nexport const bind =\n    <A, B, E>(f: (a: A) => AsyncResult<B, E>) =>\n    (async: AsyncResult<A, E>): AsyncResult<B, E> =>\n    async () => {\n        const result = await async()\n        return await pipe(\n            result,\n            Result.match({\n                ok: f,\n                err: e => err(e),\n            }),\n            Async.start\n        )\n    }\n\n/**\n * Alias for {@link bind}.\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/**\n * Projects the wrapped `Ok` value using a given _synchronous_ function\n * that returns a `Result` and flattens that result into a new `AsyncResult`.\n * Primarily useful for composing together asynchronous workflows with\n * synchronous functions that may also fail. (e.g., parsing a JSON string)\n *\n * @group Mapping\n *\n * @example\n * declare const networkRequest: (url: string) => AsyncResult<JsonValue, Error>;\n * declare const parseJson: (j: JsonValue) => Result<MyType, string>;\n *\n * await pipe(\n *     url,                                 // string\n *     networkRequest,                      // AsyncResult<JsonValue, Error>\n *     AsyncResult.bindResult(flow(\n *         parseJson,                       // Result<MyType, string>\n *         Result.mapErr(s => new Error(s)) // Result<MyType, Error>\n *     )),                                  // AsyncResult<MyType, Error>\n *     Async.start                          // Promise<Result<MyType, Error>>\n * )\n * // returns Result.ok(MyType) instance if everything succeeds,\n * // otherwise returns Result.err(Error)F if something fell over\n */\nexport const bindResult =\n    <A, B, E>(f: (a: A) => Result<B, E>) =>\n    (async: AsyncResult<A, E>): AsyncResult<B, E> =>\n    () =>\n        async().then(Result.bind(f))\n\n/**\n * Alias for {@link bindResult}.\n *\n * @group Mapping\n */\nexport const flatMapResult = bindResult\n\n/**", " * Use this function to \"lift\" a `Result` value into the `AsyncResult` type.\n * Essentially, this just wraps a `Result` into a lambda that returns an\n * immediately-resolved `Promise` containing the `Result`.\n *\n * @group Utils\n * @group Constructors\n */\nexport const ofResult =\n    <A, E>(result: Result<A, E>): AsyncResult<A, E> =>\n    () =>\n        Promise.resolve(result)\n\n/**", " * Use this function to \"lift\" an `Async` computation into an `AsyncResult`.\n * Essentially, this just wraps the `Async`'s inner value into a `Result.ok`.\n *\n * @group Utils\n * @group Constructors\n */\nexport const ofAsync =\n    <A, E = unknown>(async: Async<A>): AsyncResult<A, E> =>\n    () =>\n        async().then(a => Result.ok(a))\n\n/* eslint-disable func-style */\n/**\n * Converts an `Async` computation that might reject into an\n * Async computation that never rejects and returns a `Result`.\n * (Remember that an `Async` is just a lambda returning a `Promise`.)\n *", " * If the `onThrow` callback function is given, it will be used to\n * convert the thrown object into the Err branch. By default, the thrown\n * object will be `string`-ed and wrapped in an Error if it is not an Error already.\n *\n * @group Utils\n *\n * @example\n * ```\n * declare const doHttpThing: (url: string) => Promise<number>;\n *\n * await pipe(\n *     AsyncResult.tryCatch(() => doHttpThing(\"/cats\")),    // AsyncResult<number, Error>\n *     AsyncResult.mapErr(e => e.message),                  // AsyncResult<number, string>\n *     Async.start                                          // Promise<Result<number, string>>\n * )\n * // yields `Result.ok(number)` if the call succeeded\n * // otherwise yields `Result.err(string)`\n * ```\n */", "export function tryCatch<A>(mightThrow: Async<A>): AsyncResult<A, Error>\nexport function tryCatch<A, E = unknown>(\n    mightThrow: Async<A>,\n    onThrow: (thrown: unknown) => E\n): AsyncResult<A, E>\nexport function tryCatch<A, E = unknown>(\n    mightThrow: Async<A>,\n    onThrow?: (err: unknown) => E\n): AsyncResult<A, unknown> {\n    return async () => {\n        const toError = (err: unknown) =>\n            err instanceof Error ? err : Error(String(err))\n", "        try {\n            return Result.ok(await mightThrow())\n        } catch (err) {\n            if (onThrow != null) {\n                return Result.err(onThrow(err))\n            }\n            return Result.err(toError(err))\n        }\n    }\n}\n/* eslint-enable func-style */\n\n/**\n * @ignore\n */", "interface AsyncResultMatcher<A, E, R> {\n    readonly ok: R | ((ok: A) => R)\n    readonly err: R | ((err: E) => R)\n}\n\n/**\n * Exhaustive pattern match against an `AsyncResult`. Pass a matcher\n * object with cases for `ok` and `err` using either raw values or\n * lambdas accepting the data associated with each case.\n *\n * This pattern match unwraps the inner `Result` and returns an `Async`\n * computation containing the result of the match. Use {@link start} to\n * convert the `Async` into a `Promise` which can be `await`-ed.\n *\n * @group Pattern Matching\n *\n * @example\n * await pipe(\n *     AsyncResult.ok(\"alright!\"),\n *     AsyncResult.match({\n *         ok: String.capitalize,\n *         err: \"bah, humbug!\",\n *     }),\n *     Async.start\n * ) // => \"Alright!\"\n */\nexport const match =\n    <A, E, R>(matcher: AsyncResultMatcher<A, E, R>) =>\n    (async: AsyncResult<A, E>): Async<R> =>\n    () =>\n        async().then(Result.match(matcher))\n\n/**\n * Equivalent to both Async.start or simply invoking\n * the AsyncResult as a function. Aliased here for convenience.\n *\n * @group Utils\n */\nexport const start = <A, E>(async: AsyncResult<A, E>) => async()\n\n/**\n * Execute an arbitrary side-effect on the inner `Ok` value of an `AsyncResult`\n * within a pipeline of functions. Useful for logging and debugging. Passes\n * the inner value through unchanged. Sometimes referred to as `do` or `tap`.\n *\n * The side-effect will be invoked once the underlying `Promise` has resolved.\n *\n * @param f The side-effect to execute. Should not mutate its arguments.\n * @returns The `AsyncResult`, unchanged.\n *\n * @group Utils\n */\nexport const tee =\n    <A>(f: (a: A) => void) =>\n    <E>(async: AsyncResult<A, E>): AsyncResult<A, E> =>\n        Async.tee<Result<A, E>>(Result.tee(f))(async)\n\n/**\n * Execute an arbitrary side-effect on the inner `Err` value of an `AsyncResult`\n * within a pipeline of functions. Useful for logging and debugging. Passes\n * the inner value through unchanged. Sometimes referred to as `do` or `tap`.\n *\n * The side-effect will be invoked once the underlying `Promise` has resolved.\n *\n * @param f The side-effect to execute. Should not mutate its arguments.\n * @returns The `AsyncResult`, unchanged.\n *\n * @group Utils\n */\nexport const teeErr =\n    <E>(f: (a: E) => void) =>\n    <A>(async: AsyncResult<A, E>): AsyncResult<A, E> =>\n        Async.tee<Result<A, E>>(Result.teeErr(f))(async)\n\n/* c8 ignore start */\n/** @ignore */\nexport const AsyncResult = {\n    ok,\n    err,\n    map,\n    mapErr,\n    mapBoth,\n    bind,\n    flatMap,\n    bindResult,\n    flatMapResult,\n    ofResult,\n    ofAsync,\n    tryCatch,\n    match,\n    start,\n    tee,\n    teeErr,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/Deferred.ts", "chunked_list": ["/**\n * The `Deferred` type represents the state of some asynchronous operation. The\n * operation can either be `NotStarted`, `InProgress`, or `Resolved`. When the\n * operation is resolved, it has some data attached to it that represents the\n * outcome of the asyncrhonous work.\n *\n * This type is frequently used with `Result` as the data of the `Resolved`\n * branch, because it is a common situation to model the outcome of an asynchronous\n * operation that can fail.\n *\n * This type is especially helpful in Redux stores (or in the React `useReducer`\n * state) because it allows you to determinstically model the state of an async\n * operation as one value. I.e., instead of using separate flags that are\n * _implicitly_ related to each other (e.g., `notStarted`, `loading`, `result`),\n * you know for a fact that the async work can only be in one of three states,\n * and the data present on the resolved state is _only_ present on the resolved\n * state.\n *\n * @example\n * declare const def: Deferred<ApiResponse>\n *\n * pipe(\n *     def,\n *     Deferred.match({\n *         notStarted: \"Not Started\",\n *         inProgress: \"In Progress\",\n *         resolved: response => response.body\n *     })\n * )\n *", " * This type is especially helpful in Redux stores (or in the React `useReducer`\n * state) because it allows you to determinstically model the state of an async\n * operation as one value. I.e., instead of using separate flags that are\n * _implicitly_ related to each other (e.g., `notStarted`, `loading`, `result`),\n * you know for a fact that the async work can only be in one of three states,\n * and the data present on the resolved state is _only_ present on the resolved\n * state.\n *\n * @example\n * declare const def: Deferred<ApiResponse>\n *\n * pipe(\n *     def,\n *     Deferred.match({\n *         notStarted: \"Not Started\",\n *         inProgress: \"In Progress\",\n *         resolved: response => response.body\n *     })\n * )\n *", " * @module Deferred\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { Tagged, assertExhaustive } from \"./prelude\"\nimport { pipe } from \"./Composition\"\nimport { EqualityComparer } from \"./EqualityComparer\"\n\n/** The `NotStarted` type. */\nexport interface NotStarted extends Tagged<\"NotStarted\", object> {}\n\n/** The `InProgress` type. */", "export interface NotStarted extends Tagged<\"NotStarted\", object> {}\n\n/** The `InProgress` type. */\nexport interface InProgress extends Tagged<\"InProgress\", object> {}\n\n/** The `Resolved` type. */\nexport interface Resolved<A> extends Tagged<\"Resolved\", { resolved: A }> {}\n\n/** A discriminated union type representing a `Deferred` value. */\nexport type Deferred<A> = NotStarted | InProgress | Resolved<A>\n\n/**\n * The static `NotStarted` instance.\n *\n * @group Constructors\n */\nexport const notStarted: Deferred<never> = Object.freeze({ _tag: \"NotStarted\" })\n\n/**\n * The static `InProgress` instance.\n *\n * @group Constructors\n */\nexport const inProgress: Deferred<never> = Object.freeze({ _tag: \"InProgress\" })\n\n/**\n * Construct a new `Resolved` instance with the given data attached.\n *\n * @param a The data that will be wrapped in the `Deferred`.\n *\n * @group Constructors\n */\nexport const resolved = <A>(a: A): Deferred<A> => ({ _tag: \"Resolved\", resolved: a })\n\n/** @ignore */", "/** A discriminated union type representing a `Deferred` value. */\nexport type Deferred<A> = NotStarted | InProgress | Resolved<A>\n\n/**\n * The static `NotStarted` instance.\n *\n * @group Constructors\n */\nexport const notStarted: Deferred<never> = Object.freeze({ _tag: \"NotStarted\" })\n\n/**\n * The static `InProgress` instance.\n *\n * @group Constructors\n */\nexport const inProgress: Deferred<never> = Object.freeze({ _tag: \"InProgress\" })\n\n/**\n * Construct a new `Resolved` instance with the given data attached.\n *\n * @param a The data that will be wrapped in the `Deferred`.\n *\n * @group Constructors\n */\nexport const resolved = <A>(a: A): Deferred<A> => ({ _tag: \"Resolved\", resolved: a })\n\n/** @ignore */", "interface DeferredMatcher<A, R> {\n    readonly notStarted: (() => R) | R\n    readonly inProgress: (() => R) | R\n    readonly resolved: ((a: A) => R) | R\n}\n\n/** @ignore */\ninterface PartialDeferredMatcher<A, R> extends Partial<DeferredMatcher<A, R>> {\n    readonly orElse: (() => R) | R\n}\n", "type Func<T> = (...args: any[]) => T\n\ntype FuncOrValue<T> = Func<T> | T\n\nconst resultOrValue = <T>(f: FuncOrValue<T>, ...args: any[]) => {\n    const isFunc = (f: FuncOrValue<T>): f is Func<T> => typeof f === \"function\"\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return isFunc(f) ? f(...args) : f\n}\n\n/**\n * Exhaustively pattern match against a `Deferred` value. Provide either\n * a value or a lambda to use for each case. If you provide a lambda to the\n * `resolved` case, it will be given the data associated with the `Resolved`\n * instance.\n *\n * See docs for {@link Deferred} for example.\n *\n * @param matcher The matcher object to use.\n *\n * @group Pattern Matching\n *\n * @example\n * ```\n * declare const def: Deferred<MyApiResponse>\n * pipe(\n *     def,\n *     Deferred.match({\n *         notStarted: \"\",\n *         inProgress: \"Loading...\",\n *         resolved: resp => resp?.body ?? \"\"\n *     })\n * ) // => the string produced in each case, depending on the value of `def`\n * ```\n */\nexport const match =\n    <A, R>(matcher: DeferredMatcher<A, R>) =>\n    (deferred: Deferred<A>) => {\n        switch (deferred._tag) {\n            case \"NotStarted\":\n                return resultOrValue(matcher.notStarted)\n            case \"InProgress\":\n                return resultOrValue(matcher.inProgress)\n            case \"Resolved\":\n                return resultOrValue(matcher.resolved, deferred.resolved)\n            /* c8 ignore next 2 */\n            default:\n                return assertExhaustive(deferred) as R\n        }\n    }\n\n/**\n * Non-exhaustive pattern match against a `Deferred`. Provide a lambda or raw value\n * to return for the various cases. (But don't specify all the cases. You should use\n * {@link match} if you want exhaustive case checking.) Then also provide a raw value\n * or lambda to use for the `orElse` case if the check falls through all other cases.\n *\n * @group Pattern Matching\n *\n * @example\n * ```\n * declare const def: Deferred<number>\n * pipe(\n *     def,\n *     Deferred.matchOrElse({\n *         resolved: statusCode => `Status: ${statusCode}`,\n *         orElse: 'Not Finished' // effectively captures both \"in progress\" and \"not started\" cases together\n *     })\n * )\n * ```\n */\nexport const matchOrElse =\n    <A, R>(matcher: PartialDeferredMatcher<A, R>) =>\n    (deferred: Deferred<A>) => {\n        switch (deferred._tag) {\n            case \"NotStarted\":\n                return resultOrValue(\n                    matcher.notStarted != null ? matcher.notStarted : matcher.orElse\n                )\n            case \"InProgress\":\n                return resultOrValue(\n                    matcher.inProgress != null ? matcher.inProgress : matcher.orElse\n                )\n            case \"Resolved\":\n                return matcher.resolved != null\n                    ? resultOrValue(matcher.resolved, deferred.resolved)\n                    : resultOrValue(matcher.orElse)\n            /* c8 ignore next 2 */\n            default:\n                return resultOrValue(matcher.orElse)\n        }\n    }\n\n/**\n * Get whether the `Deferred` is either in progress or not started.\n *\n * @group Utils\n */\nexport const isUnresolved: <A>(deferred: Deferred<A>) => boolean = matchOrElse({\n    resolved: false,\n    orElse: true,\n})\n\n/**\n * Gets whether the `Deferred` is in progress.\n *\n * @group Utils\n */\nexport const isInProgress = <A>(deferred: Deferred<A>): deferred is InProgress =>\n    pipe(\n        deferred,\n        matchOrElse({\n            inProgress: true,\n            orElse: false,\n        })\n    )\n\n/**\n * Gets whether the `Deferred` is resolved.\n *\n * @group Utils\n */\nexport const isResolved = <A>(deferred: Deferred<A>): deferred is Resolved<A> =>\n    pipe(\n        deferred,\n        matchOrElse({\n            resolved: true,\n            orElse: false,\n        })\n    )\n\n/**\n * Gets whether the `Deferred` is resolved with data equal to a specific value.\n * Uses the `EqualityComparer` if given, otherwise defaults to reference (triple\n * equals) equality.\n *\n * @group Pattern Matching\n * @group Utils\n *\n * @example\n * pipe(\n *     Deferred.resolved(101),\n *     Deferred.isResolvedWith(100, EqualityComparer.Number)\n *     // number is just a trivial example here, not required\n * ) // => false\n */\nexport const isResolvedWith = <A>(\n    expected: A,\n    equalityComparer: EqualityComparer<A> = EqualityComparer.Default\n) =>\n    matchOrElse<A, boolean>({\n        resolved: actual => equalityComparer.equals(actual, expected),\n        orElse: false,\n    })\n\n/* c8 ignore start */\n/** @ignore */\nexport const Deferred = {\n    notStarted,\n    inProgress,\n    resolved,\n    match,\n    matchOrElse,\n    isUnresolved,\n    isResolved,\n    isInProgress,\n    isResolvedWith,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/Nullable.ts", "chunked_list": ["/**\n * The `Nullable` type is, unsurprisingly, the opposite of the built-in `NonNullable`\n * type. Sometimes, it is advantageous to model values as `Nullable` instead of using\n * the `Option` type. This module is designed to provide a set of useful functions for\n * seamlessly working with `Nullable` values in function composition pipelines.\n *\n * _Some_ of this behavior can be reproduced with JavaScript's nullish-coalescing `??`\n * operator, and the nullish-safe accessor `?.` operator. However, those operators lend\n * themselves primarily to OO-style programming, not function pipelining or composition.\n * These functions are curried and are designed to be used with right-to-left function\n * composition like `pipe` and `flow`.\n *\n * @example\n * ```\n * declare const str: Nullable<string>\n * pipe(\n *     str,\n *     Nullable.map(s => `\u00a1${s}!`),\n *     Nullable.map(String.reverse),\n *     Nullable.defaultWith(() => \"\")   // could also have used Nullable.defaultValue(\"\")\n * ) // => \"!yoha\u00a1\", if str is \"ahoy\"; \"\" if str is null or undefined\n * ```\n *", " * themselves primarily to OO-style programming, not function pipelining or composition.\n * These functions are curried and are designed to be used with right-to-left function\n * composition like `pipe` and `flow`.\n *\n * @example\n * ```\n * declare const str: Nullable<string>\n * pipe(\n *     str,\n *     Nullable.map(s => `\u00a1${s}!`),\n *     Nullable.map(String.reverse),\n *     Nullable.defaultWith(() => \"\")   // could also have used Nullable.defaultValue(\"\")\n * ) // => \"!yoha\u00a1\", if str is \"ahoy\"; \"\" if str is null or undefined\n * ```\n *", " * @module Nullable\n */\nimport { EqualityComparer } from \"./EqualityComparer\"\nimport { NonNullish } from \"./prelude\"\n\nexport type Nullable<A extends NonNullish> = A | null | undefined\n\n/**\n * Get an `EqualityComparer` that considers `null` and `undefined` equivalent, and\n * compares non-nullish values based on the given `EqualityComparer`.\n *\n * @group Utils\n *\n * @example\n * ```\n * const { equals } = Nullable.getEqualityComparer(EqualityComparer.Number)\n * equals(null, undefined) // => true\n * equals(3, undefined) // => false\n * equals(null, 4) // => false\n * equals(4, 4) // => true\n * equals(4, 5) // => false\n * ```\n */\nexport const getEqualityComparer = <A extends NonNullish>(\n    equalityComparer: EqualityComparer<A>\n) =>\n    EqualityComparer.ofEquals<Nullable<A>>(\n        (a1, a2) =>\n            (a1 == null && a2 == null) ||\n            (a1 != null && a2 != null && equalityComparer.equals(a1, a2))\n    )\n\n/**\n * Similar to `Option.defaultValue`. If the given nullable value is nullish, returns\n * the given fallback/default value. If the given nullable value is non-nullish,\n * returns the value.\n *\n * @remarks\n * This is more or less equivalent to the `??` nullish-coalescing operator, it just", " * works more nicely in function composition pipelines.\n *\n * @param a The default/fallback value to use.\n *\n * @returns A non-nullable value.\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     undefined,\n *     Nullable.defaultValue(\"\")\n * ) // => \"\"\n */\nexport const defaultValue =\n    <A extends NonNullish>(a: A) =>\n    (nullable: Nullable<A>): NonNullable<A> =>\n        nullable != null ? nullable : a\n\n/**\n * Similar to `Option.defaultWith`. If the given nullable value is nullish,\n * computes the fallback/default value using the given function. If the given\n * nullable value is non-nullish, returns the value.\n *", " * @param f The function to use to compute the default/fallback value.\n *\n * @returns A non-nullable value.\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     null,\n *     Nullable.defaultWith(() => 42)\n * ) // => 42\n */\nexport const defaultWith =\n    <A extends NonNullish>(f: () => A) =>\n    (nullable: Nullable<A>): NonNullable<A> =>\n        nullable != null ? nullable : f()\n\n/**", " * Similar to `Option.map`. Uses the given function to map the nullable value\n * if it is non-nullish. Passes through nullish values unchanged.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     32,\n *     Nullable.map(n => n * 2)\n * ) // => 64\n *\n * pipe(\n *     undefined,\n *     Nullable.map((n: number) => n * 2)\n * ) // => undefined\n */\nexport const map =\n    <A extends NonNullish, B extends NonNullish>(f: (a: A) => B) =>\n    (nullable: Nullable<A>): Nullable<B> =>\n        nullable != null ? f(nullable) : nullable\n\n/**", " * Similar to `Option.bind`. Maps the nullable value using a function that itself\n * returns a possibly nullish value, and flattens the result.\n *\n * @group Mapping\n *\n * @example\n * ```\n * type Person = { readonly name?: string }\n *\n * declare const person: Nullable<Person>\n *\n * pipe(\n *     person,\n *     Nullable.bind(p => p.name),\n *     Nullable.defaultValue(\"\")\n * )\n * // => \"Joe\" if both `person` and `person.name` are defined\n * // => \"\" if either `person` or `person.name` is undefined\n * ```\n */\nexport const bind =\n    <A extends NonNullish, B extends NonNullish>(f: (a: A) => Nullable<B>) =>\n    (nullable: Nullable<A>): Nullable<B> =>\n        nullable != null ? f(nullable) : nullable\n\n/**\n * Alias for {@link bind}.\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/* c8 ignore start */\n/** @ignore */\nexport const Nullable = {\n    getEqualityComparer,\n    defaultValue,\n    defaultWith,\n    map,\n    bind,\n    flatMap,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/prelude.ts", "chunked_list": ["/* c8 ignore start */\n/** A helper function to get TypeScript to enforce exhaustive\n * case checking in switch blocks.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n/** @ignore */\nexport const assertExhaustive = (_: never): never => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`assertExhaustive failed at runtime! It was called with ${_}`)\n}\n/* c8 ignore end */\n\n/**", " * Internal utility type to get slight improvements in\n * intellisense for complex TypeScript object types.\n *\n * @ignore\n */\nexport type Identity<T> = T extends object\n    ? NonNullish & {\n          [P in keyof T]: T[P]\n      }\n    : T\n\n/**", " * Internal utility type for discriminated unions.\n *\n * @ignore\n */\nexport type Tagged<Tag extends string, A extends object> = Identity<\n    Readonly<\n        {\n            _tag: Tag\n        } & A\n    >\n>\n\n/**", " * Describes a function that is used in filtering operations\n * to determine if an element passes some set of criteria.\n *\n * See `Array.filter` for an example usage.\n */\nexport interface Predicate<A> {\n    (a: A): boolean\n}\n\n/**\n * A sub-type of a Predicate. Represents a type guard that\n * holds when the given element can be determined to be a more\n * specific type.\n *\n * See `String.isString` for an example.\n */", " * A sub-type of a Predicate. Represents a type guard that\n * holds when the given element can be determined to be a more\n * specific type.\n *\n * See `String.isString` for an example.\n */\nexport interface Refinement<A, B extends A> {\n    (a: A): a is B\n}\n\n/** @ignore */\n// eslint-disable-next-line @typescript-eslint/ban-types", "export type NonNullish = {}\n"]}
{"filename": "src/Array.ts", "chunked_list": ["/**\n * A suite of useful functions for working with readonly arrays. These functions\n * provide a curried API that works seamlessly with right-to-left function\n * composition and preserve the `readonly` type.\n *\n * @module Array\n */\nimport { Predicate, Refinement, NonNullish } from \"./prelude\"\nimport { Option } from \"./Option\"\nimport { Result } from \"./Result\"\nimport { pipe } from \"./Composition\"\nimport { EqualityComparer } from \"./EqualityComparer\"\nimport { OrderingComparer } from \"./OrderingComparer\"\nimport { NonEmptyArray } from \"./NonEmptyArray\"\n\n/* eslint-disable func-style */\n/**\n * Curried and readonly version of the built-in `filter`.", " * Accepts a plain predicate function or a refinement\n * function (a.k.a. type guard).\n *\n * @group Filtering\n */\nexport function filter<A, B extends A>(\n    refinement: Refinement<A, B>\n): (as: readonly A[]) => readonly B[]\nexport function filter<A>(\n    predicate: Predicate<A>\n): <B extends A>(bs: readonly B[]) => readonly B[]", "export function filter<A>(\n    predicate: Predicate<A>\n): <B extends A>(bs: readonly B[]) => readonly B[]\nexport function filter<A>(predicate: Predicate<A>): (as: readonly A[]) => readonly A[]\nexport function filter<A>(f: Predicate<A>) {\n    return <B extends A>(as: readonly B[]) => as.filter(f)\n}\n/* eslint-enable func-style */\n\n/**\n * Like {@link filter}, but the predicate function also accepts the\n * index of the element as an argument.\n *\n * @group Filtering\n */\nexport const filteri =\n    <A>(f: (a: A, i: number) => boolean) =>\n    (as: readonly A[]): readonly A[] =>\n        as.filter(f)\n\n/**\n * Curried and readonly version of the built-in `map`.\n *\n * @group Mapping\n */\nexport const map =\n    <A, B>(f: (a: A) => B) =>\n    (as: readonly A[]): readonly B[] =>\n        as.map(f)\n\n/**", " * Like {@link filter}, but the predicate function also accepts the\n * index of the element as an argument.\n *\n * @group Filtering\n */\nexport const filteri =\n    <A>(f: (a: A, i: number) => boolean) =>\n    (as: readonly A[]): readonly A[] =>\n        as.filter(f)\n\n/**\n * Curried and readonly version of the built-in `map`.\n *\n * @group Mapping\n */\nexport const map =\n    <A, B>(f: (a: A) => B) =>\n    (as: readonly A[]): readonly B[] =>\n        as.map(f)\n\n/**", " * Like {@link map} but the map function also accepts the\n * index of the element as an argument.\n *\n * @group Mapping\n */\nexport const mapi =\n    <A, B>(f: (a: A, i: number) => B) =>\n    (as: readonly A[]): readonly B[] =>\n        as.map(f)\n\n/**\n * Maps each value of the array into an `Option`, and keeps only the inner\n * values of those `Option`s that are`Some`. Essentially, this is a combined map +\n * filter operation where each element of the array is mapped into an `Option`\n * and an `isSome` check is used as the filter function.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     [32, null, 55, undefined, 89],   // (number | null | undefined)[]\n *     Array.choose(x => pipe(\n *         x,                           // number | null | undefined\n *         Option.ofNullish,            // Option<number>\n *         Option.map(String)           // Option<string>\n *     ))                               // string[]\n * ) // => [\"32\", \"55\", \"89\"]\n */\nexport const choose =\n    <A, B extends NonNullish>(f: (a: A) => Option<B>) =>\n    (as: readonly A[]): readonly B[] => {\n        const bs: B[] = []\n", "        for (let i = 0; i < as.length; i++) {\n            const maybeB = f(as[i])\n            if (Option.isSome(maybeB)) {\n                bs.push(maybeB.some)\n            }\n        }\n\n        return bs\n    }\n\n/**\n * Like {@link choose}, but maps each value of the array into a `Result`,\n * and keeps only the values where the projection returns `Ok`. Essentially,\n * this is a combined map + filter operation where each element of the array\n * is mapped into an `Result` and an `isOk` check is used as the filter function.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     [32, null, 55, undefined, 89],       // (number | null | undefined)[]\n *     Array.chooseR(x => pipe(\n *         x,                               // number | null | undefined\n *         Option.ofNullish,                // Option<number>\n *         Option.map(String),              // Option<string>\n *         Result.ofOption(() => \"err\")     // Result<string, string>\n *     ))                                   // string[]\n * ) // => [\"32\", \"55\", \"89\"]\n */\nexport const chooseR =\n    <A, E, B>(f: (a: A) => Result<B, E>) =>\n    (as: readonly A[]): readonly B[] => {\n        const bs: B[] = []\n", "        for (let i = 0; i < as.length; i++) {\n            const result = f(as[i])\n            if (Result.isOk(result)) {\n                bs.push(result.ok)\n            }\n        }\n\n        return bs\n    }\n\n/**\n * Get the first element of the array (wrapped in `Some`) if\n * non-empty, otherwise `None`.\n *\n * @group Utils\n * @group Pattern Matching\n *\n * @example\n * ```ts\n * Array.head([]) // => `Option.none`\n * Array.head([1, 2, 3]) // => `Option.some(1)`\n * ```\n */\nexport const head = <A extends NonNullish>(as: readonly A[]): Option<A> =>\n    as.length > 0 ? Option.some(as[0]) : Option.none\n\n/**\n * Alias of {@link head}.\n *\n * @group Utils\n * @group Pattern Matching\n */\nexport const first = head\n\n/**\n * Get a new array containing all values except the first\n * one (wrapped in `Some`) if non-empty, otherwise `None`.\n *\n * @group Utils\n * @group Pattern Matching\n *\n * @example\n * pipe(\n *     [1, 2, 3, 4],\n *     Array.tail\n * ) // => Option.some([2, 3, 4])\n */\nexport const tail = <A>(as: readonly A[]): Option<readonly A[]> => {", "    if (as.length === 0) {\n        return Option.none\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_, ...tail] = as\n    return Option.some(tail)\n}\n\n/**\n * Get the first `n` elements of the array. Will return the entire\n * array if `n` is greater than the length of the array.\n *\n * @param count is normalized to a non-negative integer\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     [1, 2, 3, 4, 5, 6],\n *     Array.take(3)\n * ) // => [1, 2, 3]\n */\nexport const take =\n    (count: number) =>\n    <A>(as: readonly A[]): readonly A[] => {\n        const c = count <= 0 ? 0 : Math.floor(count)\n", "        if (c > as.length) {\n            return as\n        }\n\n        const out: A[] = []\n\n        for (let i = 0; i < as.length && i < c; i++) {\n            out.push(as[i])\n        }\n\n        return out\n    }\n\n/**\n * Get the remaining elements of the array\n * after skipping `n` elements. Returns empty if the\n * skip count goes past the end of the array.\n *\n * @group Utils\n *\n * @param count is normalized to a non-negative integer\n *\n * @example\n * pipe(\n *     [1, 2, 3, 4, 5, 6],\n *     Array.skip(3)\n * ) // => [4, 5, 6]\n */\nexport const skip =\n    (count: number) =>\n    <A>(as: readonly A[]): readonly A[] => {\n        const c = count <= 0 ? 0 : Math.floor(count)\n", "        if (c >= as.length) {\n            return []\n        }\n\n        const out: A[] = []\n\n        for (let i = c; i < as.length; i++) {\n            out.push(as[i])\n        }\n\n        return out\n    }\n\n/**\n * Curried and readonly version of the built-in `Array.prototype.reduce`. Takes\n * the initial value first instead of last.\n *\n * @group Utils\n * @group Folding\n */\nexport const reduce =\n    <A, B>(initialValue: B, reducer: (acc: B, next: A) => B) =>\n    (as: readonly A[]): B =>\n        as.reduce(reducer, initialValue)\n\n/**\n * Curried and readonly version of the built-in `Array.prototype.reduceRight`.\n * Takes the initial value first instead of last.\n *\n * @group Utils\n * @group Folding\n */\nexport const reduceRight =\n    <A, B>(initialValue: B, reducer: (acc: B, next: A) => B) =>\n    (as: readonly A[]): B =>\n        as.reduceRight(reducer, initialValue)\n\nconst isRawValue = <A, R>(caseFn: R | ((ok: A) => R)): caseFn is R =>\n    typeof caseFn !== \"function\"\n\nconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n    isRawValue(match) ? match : match(arg)\n\n/**\n * @ignore\n */", "interface ArrayMatcher<A, R> {\n    empty: (() => R) | R\n    nonEmpty: ((as: NonEmptyArray<A>) => R) | R\n}\n\n/**\n * Exhaustive pattern match against an array to \"unwrap\" its values. Provide\n * a matcher object to handle both the `empty` and `nonEmpty` cases.\n * The matcher can use lambdas or raw values. In the `nonEmpty` case,\n * the lambda will be given a `NonEmptyArray`.\n *\n * @group Pattern Matching\n *\n * @example\n * ```ts\n * pipe(\n *     [\"a\", \"b\"],\n *     Array.match({\n *         empty: () => \"default\",\n *         nonEmpty: Array.reduceRight(\"\", (a, b) => `${a}${b}`)\n *     })\n * ) // => \"ba\"\n * ```\n */\nexport const match =\n    <A, R>(matcher: ArrayMatcher<A, R>) =>\n    (as: readonly A[]): R =>\n        as.length > 0\n            ? getMatcherResult(matcher.nonEmpty, as as NonEmptyArray<A>)\n            : getMatcherResult(matcher.empty, undefined)\n\n/**\n * Type guard that tests whether the given array is equivalent\n * to the empty tuple type.\n *\n * @group Type Guards\n * @group Utils\n */\nexport const isEmpty = <A>(as: readonly A[]): as is readonly [] => as.length === 0\n\n/**\n * Type guard that tests whether the given array is a `NonEmptyArray`\n *\n * @group Type Guards\n * @group Utils\n */\nexport const isNonEmpty = <A>(as: readonly A[]): as is NonEmptyArray<A> => as.length > 0\n\n/**\n * Also commonly known as `flatMap`. Maps each element of the array", " * given a function that itself returns an array, then flattens the result.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     [1, 2, 3],\n *     Array.bind(n => [n, n])\n * ) // => [1, 1, 2, 2, 3, 3]\n */\nexport const bind =\n    <A, B>(f: (a: A) => readonly B[]) =>\n    (as: readonly A[]): readonly B[] =>\n        as.flatMap(f)\n\n/**\n * Alias of {@link bind}.\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/**\n * Add an element to the _end_ of an array. Always returns\n * a `NonEmptyArray`.\n *\n * @group Utils\n */\nexport const append =\n    <A>(a: A) =>\n    (as: readonly A[]): NonEmptyArray<A> =>\n        [...as, a] as unknown as NonEmptyArray<A>\n\n/**\n * Also known as `cons`. Insert an element at the beginning\n * of an array. Always returns a `NonEmptyArray`.\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     [2, 3],\n *     Array.prepend(1)\n * ) // => [1, 2, 3]\n */\nexport const prepend =\n    <A>(a: A) =>\n    (as: readonly A[]): NonEmptyArray<A> =>\n        [a, ...as]\n\n/**\n * Return a Map of keys to groups, where the selector function\n * is used to generate a string key that determines in which group\n * each array element is placed.\n *\n * @group Grouping\n * @group Utils\n *\n * @example\n * pipe(\n *     [1, 2, 1, 2, 3, 3, 5],\n *     Array.groupBy(String)\n * )\n * // structurally equivalent to\n * new Map([\n *     ['1', [1, 1]],\n *     ['2', [2, 2]],\n *     ['3', [3, 3]],\n *     ['5', [5]]\n * ])\n */\nexport const groupBy =\n    <A>(selector: (a: A) => string) =>\n    (as: readonly A[]): ReadonlyMap<string, NonEmptyArray<A>> => {\n        const groups: Map<string, NonEmptyArray<A>> = new Map()\n\n        as.forEach(a => {\n            const key = selector(a)\n\n            return groups.has(key)\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  groups.set(key, pipe(groups.get(key)!, append(a)))\n                : groups.set(key, [a])\n        })\n\n        return groups\n    }\n\n/**\n * Add an array of values to the _end_ of the subsequently\n * passed (partially applied) array, in a way that makes sense\n * when reading top-to-bottom/left-to-right using `pipe`.\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     [1, 2],\n *     Array.concat([3, 4])\n * ) // => [1, 2, 3, 4]\n */\nexport const concat =\n    <A>(addToEnd: readonly A[]) =>\n    (as: readonly A[]): readonly A[] =>\n        [...as, ...addToEnd]\n\n/**\n * Like {@link concat}, except this adds an array of values to the\n * _beginning_ of the subsequently (partially applied) array,\n * in a way that makes more sense when _not_ using `pipe`.\n *\n * @group Utils\n *\n * @example\n * ```ts\n * // Reads \"backwards\" when used with `pipe`\n * pipe(\n *     [\"a\", \"b\"],\n *     Array.concatFirst([\"c\", \"d\"])\n * ) // => [\"c\", \"d\", \"a\", \"b\"]\n * // Reads better when *not* used with `pipe`\n * Array.concatFirst([\"a\", \"b\"])([\"c\", \"d\"]) // => [\"a\", \"b\", \"c\", \"d\"]\n * ```\n */\nexport const concatFirst =\n    <A>(addToFront: readonly A[]) =>\n    (as: readonly A[]): readonly A[] =>\n        [...addToFront, ...as]\n\n/**\n * Returns true if at least one element of the array\n * satisfies the given predicate. Curried version of\n * `Array.prototype.some`.\n *\n * @group Utils\n */\nexport const exists =\n    <A>(predicate: (a: A) => boolean) =>\n    (as: readonly A[]): boolean =>\n        as.some(predicate)\n\n/**\n * Alias of {@link exists}.\n *\n * @group Utils\n */\nexport const some = exists\n\n/**\n * Equivalent to calling `Array.prototype.flat()` with a depth of 1.\n *\n * @group Utils\n */\nexport const flatten = <A>(as: readonly (readonly A[])[]): readonly A[] => as.flat()\n\n/**\n * Split an array into chunks of a specified size. The final\n * chunk will contain fewer elements than the specified size if\n * the array is not evenly divisible by the specified size.\n *\n * @remarks\n * **Note:** Will return `[]`, _not_ `[[]]` if given an empty array.\n *\n * @param maxChunkSize Normalized to a positive integer.\n *\n * @example\n * pipe(\n *     [\"a\", \"b\", \"c\", \"d\", \"e\"],\n *     Array.chunk(2)\n * ) // => [[\"a\", \"b\"], [\"c\", \"d\"], [\"e\"]]\n *\n * @group Utils\n * @group Grouping\n */\nexport const chunk =\n    (maxChunkSize: number) =>\n    <A>(as: readonly A[]): readonly NonEmptyArray<A>[] => {", "        if (isEmpty(as)) {\n            return []\n        }\n\n        const chunkSize = maxChunkSize <= 1 ? 1 : Math.floor(maxChunkSize)\n\n        const numChunks = Math.ceil(as.length / chunkSize)\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const chunks: A[][] = [...globalThis.Array(numChunks)].map(() => [])\n\n        let chunkIndex = 0\n", "        for (let i = 0; i < as.length; i++) {\n            if (i !== 0 && i % chunkSize === 0) {\n                chunkIndex++\n            }\n            chunks[chunkIndex].push(as[i])\n        }\n\n        return chunks as unknown as readonly NonEmptyArray<A>[]\n    }\n\n/**\n * Get the length of an array.\n *\n * @group Utils\n */\nexport const length = <A>(as: readonly A[]) => as.length\n\n/**\n * Returns true if the given element is in the array.\n * Optionally, pass an `EqualityComparer` to use. Uses\n * reference (triple equals) equality by default.\n *\n * @group Utils\n */\nexport const contains =\n    <A>(a: A, equalityComparer: EqualityComparer<A> = EqualityComparer.Default) =>\n    (as: readonly A[]): boolean => {", "        if (isEmpty(as)) {\n            return false\n        }\n\n        const predicate = (test: A) => equalityComparer.equals(a, test)\n\n        return as.some(predicate)\n    }\n\n/**\n * Return a new array containing only unique values. If\n * passed, uses the `EqualityComparer` to test uniqueness.\n * Defaults to using reference equality (triple equals).\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     [3, 2, 1, 2, 1, 4, 9],\n *     Array.uniq()\n * ) // => [3, 2, 1, 4, 9]\n */\nexport const uniq =\n    <A>(equalityComparer?: EqualityComparer<A>) =>\n    (as: readonly A[]): readonly A[] => {", "        if (isEmpty(as)) {\n            return []\n        }\n\n        const out: A[] = []\n\n        as.forEach(a => {\n            if (!contains(a, equalityComparer)(out)) {\n                out.push(a)\n            }\n        })\n\n        return out\n    }\n\n/**\n * Returns a new array containing only unique values as determined", " * by mapping each element with the given function and optionally\n * passing an equality comparer to use on the mapped elements.\n * Defaults to using reference equality (triple equals).\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     [{ name: \"Rufus\" }, { name: \"Rex\" }, { name: \"Rufus\" }],\n *     Array.uniqBy(p => p.name)\n * ) // => [{ name: \"Rufus\" }, { name: \"Rex\" }]\n */\nexport const uniqBy =\n    <A, B>(f: (a: A) => B, equalityComparer?: EqualityComparer<B>) =>\n    (as: readonly A[]): readonly A[] => {", "        if (isEmpty(as)) {\n            return []\n        }\n\n        const out: A[] = []\n        const projections: B[] = []\n\n        as.forEach(a => {\n            const projected = f(a)\n            if (!contains(projected, equalityComparer)(projections)) {\n                projections.push(projected)\n                out.push(a)\n            }\n        })\n\n        return out\n    }\n\n/**\n * Get a new array with elements sorted. If given, will use the\n * `OrderingComparer`. Otherwise, uses the default JavaScript ASCII-based sort.\n *\n * @group Utils\n *\n * @example\n * declare const petByNameComparer: OrderingComparer<Pet>\n *\n * const pets: readonly Pet[] = [\n *     { name: \"Fido\" },\n *     { name: \"Albus\" },\n *     { name: \"Rex\" },\n *     { name: \"Gerald\" }\n * ]\n *\n * pipe(\n *     pets,\n *     Array.sort(petByNameComparer),\n *     Array.map(p => p.name)\n * ) // => [ \"Albus\", \"Fido\", \"Gerald\", \"Rex\" ]\n */\nexport const sort =\n    <A>(orderingComparer?: OrderingComparer<A>) =>\n    (as: readonly A[]): readonly A[] => {", "            if (!contains(projected, equalityComparer)(projections)) {\n                projections.push(projected)\n                out.push(a)\n            }\n        })\n\n        return out\n    }\n\n/**\n * Get a new array with elements sorted. If given, will use the\n * `OrderingComparer`. Otherwise, uses the default JavaScript ASCII-based sort.\n *\n * @group Utils\n *\n * @example\n * declare const petByNameComparer: OrderingComparer<Pet>\n *\n * const pets: readonly Pet[] = [\n *     { name: \"Fido\" },\n *     { name: \"Albus\" },\n *     { name: \"Rex\" },\n *     { name: \"Gerald\" }\n * ]\n *\n * pipe(\n *     pets,\n *     Array.sort(petByNameComparer),\n *     Array.map(p => p.name)\n * ) // => [ \"Albus\", \"Fido\", \"Gerald\", \"Rex\" ]\n */\nexport const sort =\n    <A>(orderingComparer?: OrderingComparer<A>) =>\n    (as: readonly A[]): readonly A[] => {", "        if (isEmpty(as)) {\n            return []\n        }\n\n        return as.slice(0).sort(orderingComparer?.compare)\n    }\n\n/**\n * Get a new array with elements sorted based on the sort-order\n * of each mapped element produced by the given mapping function.\n * If given, will use the `OrderingComparer`. Otherwise, defaults to an\n * OrderingComparer that `String`s the mapped element and uses the\n * default ASCII-based sort.\n *\n * @group Utils\n */\nexport const sortBy =\n    <A, B>(\n        f: (a: A) => B,\n        orderingComparer: OrderingComparer<B> = OrderingComparer.Default\n    ) =>\n    (as: readonly A[]): readonly A[] =>\n        isEmpty(as)\n            ? []\n            : as.slice(0).sort((o1: A, o2: A) => orderingComparer.compare(f(o1), f(o2)))\n\n/**\n * Get a new array with the elements in reverse order.\n *\n * @group Utils\n */\nexport const reverse = <A>(as: readonly A[]): readonly A[] => as.slice(0).reverse()\n\n/**\n * Get the _first_ element in the array (wrapped in a `Some`) that\n * returns `true` for the given predicate, or `None` if no such\n * element exists.\n *\n * @group Utils\n */\nexport const find =\n    <A extends NonNullish>(predicate: Predicate<A>) =>\n    (as: readonly A[]): Option<A> =>\n        Option.ofNullish(as.find(predicate))\n\n/**\n * Get the _first_ index of the array (wrapped in a `Some`) for\n * which the element at that index returns true for the given predicate,\n * or `None` if no such index/element exists.\n *\n * @group Utils\n */\nexport const findIndex =\n    <A>(predicate: Predicate<A>) =>\n    (as: readonly A[]): Option<number> => {\n        const result = as.findIndex(predicate)\n        return result < 0 ? Option.none : Option.some(result)\n    }\n\n/**\n * Get a new array containing only those elements that are not\n * in the given `excludeThese` array. If given, will use the\n * EqualityComparer. Otherwise, defaults to reference equality\n * (triple equals).\n *\n * @group Utils\n *\n * @example\n * pipe(\n *     [1, 2, 3, 4, 5],\n *     Array.except([2, 5])\n * ) // => [1, 3, 4]\n */\nexport const except =\n    <A>(excludeThese: readonly A[], equalityComparer?: EqualityComparer<A>) =>\n    (as: readonly A[]): readonly A[] => {", "        if (isEmpty(as)) {\n            return []\n        }\n\n        if (isEmpty(excludeThese)) {\n            return as\n        }\n\n        const out: A[] = []\n\n        for (let i = 0; i < as.length; i++) {", "        for (let i = 0; i < as.length; i++) {\n            if (!pipe(excludeThese, contains(as[i], equalityComparer))) {\n                out.push(as[i])\n            }\n        }\n\n        return out\n    }\n\n/**\n * Get a new array containing the set union of two arrays, defined as the\n * set of elements contained in both arrays. **Remember:** sets only contain\n * unique elements. If you just need to join two arrays together, use {@link concat}.\n *\n * @group Utils\n */\nexport const union =\n    <A>(unionWith: readonly A[], equalityComparer?: EqualityComparer<A>) =>\n    (as: readonly A[]): readonly A[] =>\n        isEmpty(unionWith) && isEmpty(as)\n            ? []\n            : pipe(as, concat(unionWith), uniq(equalityComparer))\n\n/**\n * Get an {@link EqualityComparer} that represents structural equality for an array", " * of type `A` by giving this function an `EqualityComparer` for each `A` element.\n *\n * @group Equality\n * @group Utils\n *\n * @param equalityComparer The `EqualityComparer` to use for element-by-element comparison.\n *\n * @returns A new `EqualityComparer` instance\n *\n * @example\n * const eq = Array.getEqualityComparer(EqualityComparer.Number)\n * eq.equals([1, 2, 3], [1, 2, 3]) // => true\n * eq.equals([1, 3], [3, 1]) // => false\n */\nexport const getEqualityComparer = <A>({\n    equals,\n}: EqualityComparer<A>): EqualityComparer<readonly A[]> =>\n    EqualityComparer.ofEquals((arr1, arr2) => {", "        if (isEmpty(arr1) && isEmpty(arr2)) {\n            return true\n        }\n\n        if (arr1.length !== arr2.length) {\n            return false\n        }\n\n        for (let i = 0; i < arr1.length; i++) {\n            if (!equals(arr1[i], arr2[i])) {\n                return false\n            }\n        }\n\n        return true\n    })\n\n/**\n * Does not affect the passed array at runtime. (Effectively executes an identity\n * function) Removes the `readonly` part of the **type** only.\n *\n * @group Utils\n */\nexport const asMutable = <A>(as: readonly A[]) => as as A[]\n\n/**\n * Execute an arbitrary side effect for each element of the array. Essentially a\n * curried version of the built-in `forEach` method.\n *\n * @group Utils\n */\nexport const iter =\n    <A>(f: (a: A) => void) =>\n    (as: readonly A[]): void =>\n        as.forEach(a => f(a))\n\n/** @ignore */\nexport const Array = {\n    filter,\n    filteri,\n    map,\n    mapi,\n    bind,\n    flatMap,\n    choose,\n    chooseR,\n    head,\n    first,\n    tail,\n    take,\n    skip,\n    reduce,\n    reduceRight,\n    match,\n    isEmpty,\n    isNonEmpty,\n    append,\n    prepend,\n    groupBy,\n    concat,\n    concatFirst,\n    exists,\n    some,\n    flatten,\n    chunk,\n    length,\n    contains,\n    uniq,\n    uniqBy,\n    sort,\n    sortBy,\n    reverse,\n    find,\n    findIndex,\n    except,\n    union,\n    getEqualityComparer,\n    asMutable,\n    iter,\n}\n/* c8 ignore end */\n", "        for (let i = 0; i < arr1.length; i++) {\n            if (!equals(arr1[i], arr2[i])) {\n                return false\n            }\n        }\n\n        return true\n    })\n\n/**\n * Does not affect the passed array at runtime. (Effectively executes an identity\n * function) Removes the `readonly` part of the **type** only.\n *\n * @group Utils\n */\nexport const asMutable = <A>(as: readonly A[]) => as as A[]\n\n/**\n * Execute an arbitrary side effect for each element of the array. Essentially a\n * curried version of the built-in `forEach` method.\n *\n * @group Utils\n */\nexport const iter =\n    <A>(f: (a: A) => void) =>\n    (as: readonly A[]): void =>\n        as.forEach(a => f(a))\n\n/** @ignore */\nexport const Array = {\n    filter,\n    filteri,\n    map,\n    mapi,\n    bind,\n    flatMap,\n    choose,\n    chooseR,\n    head,\n    first,\n    tail,\n    take,\n    skip,\n    reduce,\n    reduceRight,\n    match,\n    isEmpty,\n    isNonEmpty,\n    append,\n    prepend,\n    groupBy,\n    concat,\n    concatFirst,\n    exists,\n    some,\n    flatten,\n    chunk,\n    length,\n    contains,\n    uniq,\n    uniqBy,\n    sort,\n    sortBy,\n    reverse,\n    find,\n    findIndex,\n    except,\n    union,\n    getEqualityComparer,\n    asMutable,\n    iter,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/Result.ts", "chunked_list": ["/**\n * The `Result` type represents the outcome of a completed operation\n * that either succeeded with some `Ok` value (also called a \"success\"\n * or \"right\" value), or failed with some `Err` value (also called a\n * \"failure\" or \"left\" value).\n *\n * Generally speaking, `Result` is not intended to _replace_ exception\n * handling, but to augment it, so that exceptions can be used to handle\n * truly _exceptional_ things. (i.e., Is it really exceptional that a\n * network request failed?)\n *", " * This API has been optimized for use with left-to-right function composition\n * using `pipe` and `flow`.\n *\n * @example\n * ```\n * pipe(\n *     Result.tryCatch(() => readFileMightThrow()),\n *     Result.mapErr(FileError.create),\n *     Result.bind(fileText => pipe(\n *         Result.tryCatch(() => transmitMightThrow(fileText)),\n *         Result.mapErr(FileError.create)\n *     )),\n *     Result.map(transmitResponse => transmitResponse?.status),\n *     Result.defaultValue(\"failed\")\n * )\n * // may return, e.g., \"pending\" if everything worked\n * // or \"failed\" if something fell down along the way\n * ```\n *", " * @module Result\n */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { Tagged, assertExhaustive, Refinement, NonNullish } from \"./prelude\"\nimport { Option } from \"./Option\"\nimport { flow, pipe } from \"./Composition\"\nimport { EqualityComparer } from \"./EqualityComparer\"\n\nexport interface Ok<A> extends Tagged<\"Ok\", { ok: A }> {}\nexport interface Err<E> extends Tagged<\"Err\", { err: E }> {}\n", "export interface Ok<A> extends Tagged<\"Ok\", { ok: A }> {}\nexport interface Err<E> extends Tagged<\"Err\", { err: E }> {}\n\nexport type Result<A, E> = Ok<A> | Err<E>\n\n/**\n * Construct a new Ok instance.\n *\n * @group Constructors\n *\n * @returns A new Ok instance containing the given value.\n */\nexport const ok = <A, E = never>(ok: A): Result<A, E> => ({\n    _tag: \"Ok\",\n    ok,\n})\n\n/**\n * Construct a new Err instance.\n *\n * @group Constructors\n *\n * @returns A new Err instance with the given value. */\nexport const err = <E, A = never>(err: E): Result<A, E> => ({\n    _tag: \"Err\",\n    err,\n})\n\n/**\n * Alias for {@link ok}.\n *\n * @group Constructors\n */\nexport const of = ok\n\n/**\n * @ignore\n */", "interface ResultMatcher<A, E, R> {\n    readonly ok: R | ((ok: A) => R)\n    readonly err: R | ((err: E) => R)\n}\n\nconst isRawValue = <A, E, R>(caseFn: R | ((ok: A) => R) | ((err: E) => E)): caseFn is R =>\n    typeof caseFn !== \"function\"\n\nconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n    isRawValue(match) ? match : match(arg)\n\n/**\n * Exhaustive pattern match against a `Result` to \"unwrap\" its inner", " * value. Pass a matcher function with cases for `ok` and `err` that\n * can either be lambdas or raw values.\n *\n * @group Pattern Matching\n *\n * @example\n * ```\n * pipe(\n *     Result.err(\"failure\"),\n *     Result.match({\n *         ok: a => `${a.length}`,\n *         err: s => `${s}!`\n *     })\n * ) // => \"failure!\"\n * ```\n */\nexport const match =\n    <A, E, R>(matcher: ResultMatcher<A, E, R>) =>\n    (result: Result<A, E>) => {\n        switch (result._tag) {\n            case \"Ok\":\n                return getMatcherResult(matcher.ok, result.ok)\n            case \"Err\":\n                return getMatcherResult(matcher.err, result.err)\n            /* c8 ignore next 2 */\n            default:\n                return assertExhaustive(result)\n        }\n    }\n\n/**", " * Filter a `Result` using a type guard (a.k.a. `Refinement` function) that, if\n * it succeeds, will return an `Ok` with a narrowed type. If it fails, will use\n * the given `onFail` function to produce an error branch.\n *\n * @group Utils\n * @group Filtering\n *\n * @example\n * ```\n * const isCat = (s: string): s is \"cat\" => s === \"cat\"\n * pipe(\n *     Result.ok(\"dog\"),\n *     Result.refine(isCat, a => `\"${a}\" is not \"cat\"!`)\n * ) // => Result.err('\"dog\" is not \"cat\"!')\n * ```\n */\nexport const refine =\n    <A, B extends A, E>(refinement: Refinement<A, B>, onFail: (a: A) => E) =>\n    (result: Result<A, E>): Result<B, E> =>\n        pipe(\n            result,\n            match({\n                ok: a => (refinement(a) ? ok(a) : err(onFail(a))),\n                err: e => err(e),\n            })\n        )\n\n/**", " * Map the inner `Ok` value using the given function and\n * return a new `Result`. Passes `Err` values through as-is.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     Result.ok(2),\n *     Result.map(n => n + 3)\n * ) // => Result.ok(5)\n */\nexport const map =\n    <A, B>(f: (a: A) => B) =>\n    <E>(result: Result<A, E>): Result<B, E> =>\n        pipe(\n            result,\n            match({\n                ok: a => ok(f(a)),\n                err: e => err(e),\n            })\n        )\n\n/**", " * Map the inner `Err` value using the given function and\n * return a new `Result`. `Ok` values are passed through as-is.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     Result.err(\"cheese melted\"),\n *     Result.mapErr(s => s.length)\n * ) // => Result.err(13)\n */\nexport const mapErr =\n    <E1, E2>(f: (e: E1) => E2) =>\n    <A>(result: Result<A, E1>) =>\n        pipe(\n            result,\n            match({\n                ok: a => ok(a),\n                err: e => err(f(e)),\n            })\n        )\n\n/**\n * Map both branches of the Result by specifying a lambda\n * to use in either case. Equivalent to calling {@link map} followed\n * by {@link mapErr}.\n *\n * @group Mapping\n */\nexport const mapBoth = <A1, E1, A2, E2>(mapOk: (a: A1) => A2, mapErr: (e: E1) => E2) =>\n    match<A1, E1, Result<A2, E2>>({\n        ok: a => ok(mapOk(a)),\n        err: e => err(mapErr(e)),\n    })\n\n/**\n * Return the inner `Ok` value or the given default value\n * if the Result is an Err.\n *\n * @group Pattern Matching\n */\nexport const defaultValue =\n    <A>(a: A) =>\n    <E>(result: Result<A, E>) =>\n        pipe(\n            result,\n            match({\n                ok: a => a,\n                err: a,\n            })\n        )\n\n/**\n * Return the inner `Ok` value or use the given lambda\n * to compute the default value if the `Result` is an `Err`.\n *\n * @group Pattern Matching\n */\nexport const defaultWith =\n    <A>(f: () => A) =>\n    <E>(result: Result<A, E>) =>\n        pipe(\n            result,\n            match({\n                ok: a => a,\n                err: f,\n            })\n        )\n\n/**", " * Maps the inner `Ok` value using a function that\n * also returns a `Result`, and flattens the result.\n * `Err` values are passed through as-is. This function\n * is also referred to as `flatMap`.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     Result.ok(\"a\"),\n *     Result.bind(s =>\n *         s === \"a\" ? Result.ok(\"got an a!\") : Result.err(\"not an a\")\n *     ),\n *     Result.defaultValue(\"\")\n * ) // => \"got an a!\"\n */\nexport const bind = <A, E, B>(f: (a: A) => Result<B, E>) =>\n    match<A, E, Result<B, E>>({\n        ok: f,\n        err: e => err(e),\n    })\n\n/**\n * Alias for {@link bind}.\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/**", " * A type guard (a.k.a. `Refinement`) that holds if the result\n * is an `Ok`. Allows the TypeScript compiler to narrow the type\n * and allow type-safe access to `.ok`.\n *\n * @group Type Guards\n */\nexport const isOk = <A, E = never>(result: Result<A, E>): result is Ok<A> =>\n    result._tag === \"Ok\"\n\n/**\n * A type guard (a.k.a. `Refinement`) that holds if the result is", " * A type guard (a.k.a. `Refinement`) that holds if the result is\n * an `Err`. Allows the TypeScript compiler to narrow the type and\n * allow safe access to `.err`.\n *\n * @group Type Guards\n */\nexport const isErr = <E, A = never>(result: Result<A, E>): result is Err<E> =>\n    result._tag === \"Err\"\n\n/**\n * Map a tuple of `Result`s.\n *", " * If given two `Ok` values, uses the given mapper function and produces\n * a new `Ok` instance with the result. If either of the `Result`s are an\n * `Err`, returns an `Err`. If both results are an `Err`, returns the first\n * one and ignores the second.\n *\n * @remarks\n * This is effectively a shortcut to pattern matching a 2-tuple of Results.\n *\n * @group Mapping\n */\nexport const map2 =\n    <A, B, C>(map: (a: A, b: B) => C) =>\n    <E>(results: readonly [Result<A, E>, Result<B, E>]): Result<C, E> => {", "        if (isOk(results[0]) && isOk(results[1])) {\n            return ok(map(results[0].ok, results[1].ok))\n        } else if (isErr(results[0])) {\n            return err(results[0].err)\n        } else {\n            return err((results[1] as Err<E>).err)\n        }\n    }\n\n/**\n * Map a 3-tuple of `Result`s.\n *", " * If given three `Ok` values, uses the given mapper function and returns\n * a new `Ok` value with the result. If any of the `Result`s are an `Err`,\n * returns an `Err`.\n *\n * If multiple `Result`s are an `Err`, returns the first one found and\n * ignores the others.\n *\n * @remarks\n * This is effectively a shortcut to pattern matching a 3-tuple of Results.\n *\n * @group Pattern Matching\n */\nexport const map3 =\n    <A, B, C, D>(map: (a: A, b: B, c: C) => D) =>\n    <E>(results: readonly [Result<A, E>, Result<B, E>, Result<C, E>]): Result<D, E> => {", "        if (isOk(results[0]) && isOk(results[1]) && isOk(results[2])) {\n            return ok(map(results[0].ok, results[1].ok, results[2].ok))\n        } else if (isErr(results[0])) {\n            return err(results[0].err)\n        } else if (isErr(results[1])) {\n            return err(results[1].err)\n        } else {\n            return err((results[2] as Err<E>).err)\n        }\n    }\n\n/* eslint-disable func-style */\n/**", " * Attempts to invoke a function that may throw. If the function\n * succeeds, returns an Ok with the result. If the function throws,\n * returns an Err containing the thrown Error, optionally transformed.\n *\n * @group Utils\n *\n * @param onThrow\n * Optional. If given, accepts the thrown `unknown` object and produces\n * the Err branch. If omitted, the thrown object will be stringified and\n * wrapped in a new Error instance if it is not already an Error instance.\n */", "export function tryCatch<A>(mightThrow: () => A): Result<A, Error>\nexport function tryCatch<A, E = unknown>(\n    mightThrow: () => A,\n    onThrow: (thrown: unknown) => E\n): Result<A, E>\nexport function tryCatch<A, E = unknown>(\n    mightThrow: () => A,\n    onThrow?: (err: unknown) => E\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Result<A, any> {\n    const toError = (err: unknown) => (err instanceof Error ? err : Error(String(err)))\n", "    try {\n        return ok(mightThrow())\n    } catch (err) {\n        if (onThrow != null) {\n            return Result.err(onThrow(err))\n        }\n        return Result.err(toError(err))\n    }\n}\n/* eslint-enable func-style */\n\n/**", " * Allows some arbitrary side-effect function to be called\n * using the wrapped `Ok` value. Useful for debugging and logging.\n *\n * @group Utils\n *\n * @param f Should not mutate its arguments. Use {@link map} if you\n * want to map the inner value of the Result instead.\n *\n * @example\n * ```\n * pipe(\n *     Result.ok(23),\n *     Result.tee(console.log), // logs `23`\n *     Result.map(n => n + 1), // inner value is unchanged\n *     Result.defaultValue(0)\n * ) // => 24\n * ```\n */\nexport const tee =\n    <A>(f: (a: A) => void) =>\n    <E>(result: Result<A, E>): Result<A, E> =>\n        pipe(\n            result,\n            match({\n                ok: a => {\n                    f(a)\n                    return ok(a)\n                },\n                err: e => err(e),\n            })\n        )\n\n/**", " * Allows some arbitrary side-effect function to be called\n * using the wrapped `Err` value. Useful for debugging and logging.\n *\n * @param f Should not mutate its arguments. Use {@link mapErr} if\n * you want to map the inner `Err` value.\n *\n * @group Utils\n *\n * @example\n * ```\n * pipe(\n *     Result.err(\"melted\"),\n *     Result.teeErr(console.log),   // logs `melted`\n *     Result.mapErr(s => s.length), // inner value is unchanged\n * ) // => Result.err(6)\n * ```\n */\nexport const teeErr =\n    <E>(f: (e: E) => void) =>\n    <A>(result: Result<A, E>): Result<A, E> =>\n        pipe(\n            result,\n            match({\n                ok: a => ok(a),\n                err: e => {\n                    f(e)\n                    return err(e)\n                },\n            })\n        )\n\n/**\n * Converts an `Option` to a `Result`.\n *\n * @group Constructors\n * @group Utils\n *\n * @param onNone Used to convert a `None` branch into an `Err` branch.\n *\n * @returns a new `Result`.\n */\nexport const ofOption = <A extends NonNullish, E>(onNone: () => E) =>\n    Option.match<A, Result<A, E>>({\n        some: ok,\n        none: flow(onNone, err),\n    })\n\n/**", " * Get an `EqualityComparer` for an `Result<A, E>` by giving this function an\n * `EqualityComparer` for type `A` and one for type `E`. Represents structural\n * (value-based) equality for the `Result` type.\n *\n * @group Equality\n * @group Utils\n *\n * @param equalityComparerA The `EqualityComparer` to use for the inner ok value.\n * @param equalityComparerE The `EqualityComparer` to use for the inner err value.\n *\n * @returns A new `EqualityComparer` instance\n */\nexport const getEqualityComparer = <A, E>(\n    equalityComparerA: EqualityComparer<A>,\n    equalityComparerE: EqualityComparer<E>\n): EqualityComparer<Result<A, E>> =>\n    EqualityComparer.ofEquals((r1, r2) => {", "        if (isErr(r1) && isErr(r2) && equalityComparerE.equals(r1.err, r2.err)) {\n            return true\n        }\n\n        return pipe(\n            [r1, r2] as const,\n            map2((a1: A, a2: A) => equalityComparerA.equals(a1, a2)),\n            defaultValue(false)\n        )\n    })\n\n/* c8 ignore start */\n/** @ignore */\nexport const Result = {\n    ok,\n    of,\n    err,\n    isOk,\n    isErr,\n    match,\n    map,\n    map2,\n    map3,\n    mapErr,\n    mapBoth,\n    bind,\n    flatMap,\n    defaultValue,\n    defaultWith,\n    tryCatch,\n    tee,\n    teeErr,\n    ofOption,\n    getEqualityComparer,\n    refine,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/string.ts", "chunked_list": ["/**\n * The string module is a suite of functions that are useful for string manipulation and\n * properly, designed for seamless use in function composition pipelines.\n *\n * @module String\n */\nimport { NonEmptyArray } from \"./NonEmptyArray\"\n\n/**\n * A boolean check that also serves as a type guard which narrows the\n * type to the string literal `\"\"`.\n *\n * @group Utils\n * @group Type Guards\n *\n * @returns boolean\n */\nexport const isEmpty = (s: string): s is \"\" => s === \"\"\n\n/**\n * Curried version of the built-in trim method.\n *\n * @group Utils\n */\nexport const trim = (s: string) => s.trim()\n\n/**\n * Curried version of the built-in toLowerCase method.\n *\n * @group Utils\n */\nexport const toLowerCase = (s: string) => s.toLowerCase()\n\n/**\n * Curried version of the built-in toUpperCase method.\n *\n * @group Utils\n */\nexport const toUpperCase = (s: string) => s.toUpperCase()\n\n/**\n * Type guard that holds true when `u` is a string.\n *\n * @group Type Guards\n *\n * @returns boolean\n */\nexport const isString = (u: unknown): u is string => typeof u === \"string\"\n\n/**\n * Get the length of a string.\n *\n * @group Utils\n */\nexport const length = (s: string) => s.length\n\n/**\n * Reverses a string.\n *\n * @group Utils\n */\nexport const reverse = (s: string) => s.split(\"\").reverse().join(\"\")\n\n/**\n * A curried version of the built-in split method that\n * is guaranteed to always return at least one entry. If\n * the split fails to produce at least one entry, the entire\n * input string is returned as a single-element array.\n *\n * @group Utils\n */\nexport const split =\n    (separator: string | RegExp) =>\n    (s: string): NonEmptyArray<string> => {\n        const result = s.split(separator)\n        return result.length > 0 ? (result as unknown as NonEmptyArray<string>) : [s]\n    }\n\n/**\n * Capitalize the first letter of a string.\n *\n * @group Utils\n */\nexport const capitalize = (s: string) => {", " * A boolean check that also serves as a type guard which narrows the\n * type to the string literal `\"\"`.\n *\n * @group Utils\n * @group Type Guards\n *\n * @returns boolean\n */\nexport const isEmpty = (s: string): s is \"\" => s === \"\"\n\n/**\n * Curried version of the built-in trim method.\n *\n * @group Utils\n */\nexport const trim = (s: string) => s.trim()\n\n/**\n * Curried version of the built-in toLowerCase method.\n *\n * @group Utils\n */\nexport const toLowerCase = (s: string) => s.toLowerCase()\n\n/**\n * Curried version of the built-in toUpperCase method.\n *\n * @group Utils\n */\nexport const toUpperCase = (s: string) => s.toUpperCase()\n\n/**\n * Type guard that holds true when `u` is a string.\n *\n * @group Type Guards\n *\n * @returns boolean\n */\nexport const isString = (u: unknown): u is string => typeof u === \"string\"\n\n/**\n * Get the length of a string.\n *\n * @group Utils\n */\nexport const length = (s: string) => s.length\n\n/**\n * Reverses a string.\n *\n * @group Utils\n */\nexport const reverse = (s: string) => s.split(\"\").reverse().join(\"\")\n\n/**\n * A curried version of the built-in split method that\n * is guaranteed to always return at least one entry. If\n * the split fails to produce at least one entry, the entire\n * input string is returned as a single-element array.\n *\n * @group Utils\n */\nexport const split =\n    (separator: string | RegExp) =>\n    (s: string): NonEmptyArray<string> => {\n        const result = s.split(separator)\n        return result.length > 0 ? (result as unknown as NonEmptyArray<string>) : [s]\n    }\n\n/**\n * Capitalize the first letter of a string.\n *\n * @group Utils\n */\nexport const capitalize = (s: string) => {", "    if (s.length < 1) {\n        return \"\"\n    }\n\n    const [head, ...tail] = s.split(\"\")\n\n    return [head.toUpperCase(), ...tail].join(\"\")\n}\n\n/**\n * Uncapitalize the first letter of a string.\n *\n * @group Utils\n */\nexport const uncapitalize = (s: string) => {", "    if (s.length < 1) {\n        return \"\"\n    }\n\n    const [head, ...tail] = s.split(\"\")\n\n    return [head.toLowerCase(), ...tail].join(\"\")\n}\n\n/* c8 ignore start */\n/** @ignore */\nexport const String = {\n    isEmpty,\n    trim,\n    toLowerCase,\n    toUpperCase,\n    isString,\n    split,\n    length,\n    reverse,\n    capitalize,\n    uncapitalize,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/NonEmptyArray.ts", "chunked_list": ["/**\n * A `NonEmptyArray` is an array that is guaranteed by the type system to have\n * at least one element. This type is useful for correctly modeling certain\n * behaviors where empty arrays are absurd. It also makes it safer to work with\n * functionality like destructuring the array or getting the first value.\n *\n * **Note:** A `NonEmptyArray` is just a _more specific_ type of readonly array,\n * so any functions from the `Array` module can also be used with `NonEmptyArray`s.\n *\n * @module NonEmptyArray\n */\n\nimport { EqualityComparer } from \"./EqualityComparer\"\nimport { OrderingComparer } from \"./OrderingComparer\"\n\n/** Represents a readonly array with at least one element. */", " * @module NonEmptyArray\n */\n\nimport { EqualityComparer } from \"./EqualityComparer\"\nimport { OrderingComparer } from \"./OrderingComparer\"\n\n/** Represents a readonly array with at least one element. */\nexport interface NonEmptyArray<A> extends ReadonlyArray<A> {\n    0: A\n}\n\n/**\n * Get the first element of a non-empty array.\n *\n * @group Utils\n * @group Pattern Matching\n */\nexport const head = <A>(as: NonEmptyArray<A>) => as[0]\n\n/**\n * Alias of {@link head}.\n *\n * @group Pattern Matching\n * @group Utils\n */\nexport const first = head\n\n/**\n * Destructure the non-empty array into an object containing\n * the head and the tail.\n *\n * @group Pattern Matching\n *\n * @example\n * NonEmptyArray.destruct([1, 2, 3]) // => { head: 1, tail: [2, 3] }\n */\nexport const destruct = <A>(\n    as: NonEmptyArray<A>\n): {\n    readonly head: A\n    readonly tail: readonly A[]\n} => ({\n    head: as[0],\n    tail: as.slice(1),\n})\n\n/**\n * Curried version of the built-in map that maintains\n * strong NonEmptyArray typing.\n *\n * @group Mapping\n *\n * @returns A new non-empty array containing the mapped elements.\n */\nexport const map =\n    <A, B>(f: (a: A) => B) =>\n    (as: NonEmptyArray<A>): NonEmptyArray<B> =>\n        as.map(f) as unknown as NonEmptyArray<B>\n\n/**", " * Uses the given function to map each element into a non-empty array,\n * then flattens the results. Commonly called flatMap` or `chain`.\n *\n * @group Mapping\n *\n * @returns A new non-empty array containing the mapped/flattened elements.\n */\nexport const bind =\n    <A, B>(f: (a: A) => NonEmptyArray<B>) =>\n    (as: NonEmptyArray<A>): NonEmptyArray<B> =>\n        as.flatMap(f) as unknown as NonEmptyArray<B>\n\n/**\n * Alias for {@link bind}.\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/**\n * Constructs a new non-empty array containing exactly one element.\n *\n * @group Constructors\n */\nexport const of = <A>(a: A): NonEmptyArray<A> => [a]\n\n/**\n * Create a new array by enumerating the integers between\n * the given start and end, inclusive of both start and end.\n *\n * Both start and end are normalized to integers, and end is\n * normalized to always be at least equal to start.\n *\n * @group Constructors\n * @group Utils\n *\n * @example\n * NonEmptyArray.range(1, 5)    // => [1, 2, 3, 4, 5]\n * NonEmptyArray.range(-10, 1)  // => [-10, -9, -8, ..., 1]\n * NonEmptyArray.range(2, -5)   // => [2]\n * NonEmptyArray.range(1, 1)    // => [1]\n */\nexport const range = (\n    startInclusive: number,\n    endInclusive: number\n): NonEmptyArray<number> => {\n    const start = Math.floor(startInclusive)\n    const end = Math.floor(endInclusive)\n", "    if (start >= end) {\n        return [start]\n    }\n\n    const out: number[] = []\n    for (let i = start; i <= end; i++) {\n        out.push(i)\n    }\n    return out as unknown as NonEmptyArray<number>\n}\n\n/**\n * Construct a new non-empty array with the specified number", " * of elements, using a constructor function for each element\n * that takes a zero-based index of the element being constructed.\n *\n * @param length is normalized to a non-negative integer\n *\n * @group Constructors\n * @group Utils\n *\n * @example\n * ```\n * NonEmptyArray.make(3, i => `${i}`) // => [\"0\", \"1\", \"2\"]\n * ```\n */\nexport const make = <A>(\n    length: number,\n    createElement: (i: number) => A\n): NonEmptyArray<A> => {\n    const n = length <= 1 ? 1 : Math.floor(length)\n    return [...Array(n).keys()].map(createElement) as unknown as NonEmptyArray<A>\n}\n\n/**\n * Reverses an array. Preserves correct types.\n *\n * @group Utils\n *\n * @returns A new non-empty array with elements in reverse order.\n *\n * @example\n * pipe(\n *  NonEmptyArray.range(1, 5),\n *  NonEmptyArray.reverse\n * ) // => [5, 4, 3, 2, 1]\n */\nexport const reverse = <A>(as: NonEmptyArray<A>): NonEmptyArray<A> =>\n    as.slice(0).reverse() as unknown as NonEmptyArray<A>\n\n/**\n * Sort the array using the given `OrderingComaparer`, or the default\n * ASCII-based comparer if not given.\n *\n * @group Utils\n *\n * @returns A new non-emty array with elements sorted.\n */\nexport const sort =\n    <A>(orderingComparer: OrderingComparer<A> = OrderingComparer.Default) =>\n    (as: NonEmptyArray<A>): NonEmptyArray<A> =>\n        as.slice(0).sort(orderingComparer.compare) as unknown as NonEmptyArray<A>\n\n/**\n * Get an `EqualityComparer` that represents structural equality for a non-empty array", " * of type `A` by giving this function an `EqualityComparer` for each `A` element.\n *\n * @group Equality\n * @group Utils\n *\n * @param equalityComparer The `EqualityComparer` to use for element-by-element comparison.\n *\n * @returns A new `EqualityComparer` instance\n */\nexport const getEqualityComparer = <A>({\n    equals,\n}: EqualityComparer<A>): EqualityComparer<NonEmptyArray<A>> =>\n    EqualityComparer.ofEquals((arr1, arr2) => {", "        if (arr1.length !== arr2.length) {\n            return false\n        }\n\n        for (let i = 0; i < arr1.length; i++) {\n            if (!equals(arr1[i], arr2[i])) {\n                return false\n            }\n        }\n\n        return true\n    })\n\n/* c8 ignore start */\n/** @ignore */\nexport const NonEmptyArray = {\n    head,\n    first,\n    destruct,\n    map,\n    bind,\n    flatMap,\n    of,\n    range,\n    make,\n    reverse,\n    sort,\n    getEqualityComparer,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/function.ts", "chunked_list": ["/**\n * Execute some arbitrary side-effect function on the given value\n * and return the value unchanged. Sometimes this function is\n * referred to as `tap` or `do`.\n *\n * Used mostly for logging or tracing in function pipelines.\n *\n * @group Utils\n *\n * @example\n * ```\n * pipe(\n *     42,\n *     tee(console.log), // logs 42\n *     double,\n *     tee(console.log), // logs 84\n *     String,\n *     tee(console.log)  // logs \"84\"\n * ) // => \"84\"\n * ```\n */\nexport const tee =\n    <A>(f: (a: A) => void) =>\n    (a: A) => {\n        f(a)\n        return a\n    }\n\n/**", " * Execute some arbitrary side-effect function on the value\n * resolved from the `Promise` and return the value unchanged.\n * Sometimes this function is referred to as `tap` or `do`.\n *\n * Used primarily for logging or tracing in function pipelines.\n *\n * @remarks\n * If you are working with `Async` computations, use {@link Async.tee} instead.\n *\n * @group Utils\n *\n * @example\n * ```\n * await pipe(\n *     Promise.resolve(10),\n *     teeAsync(console.log), // logs `10`. Using `tee` would log the Promise object\n *     p => p.then(n => n * 2)\n * ) // => 20\n * ```\n */\nexport const teeAsync =\n    <A>(f: (a: A) => void) =>\n    (p: Promise<A>) =>\n        p.then(a => {\n            f(a)\n            return a\n        })\n"]}
{"filename": "src/Variants.ts", "chunked_list": ["/**\nVariants allow you to more easily create and work with discriminated unions than you can\nout-of-the-box with TypeScript.\n\n**This bears repeating:** the type that is exported by `VariantOf` is _just_ a plain\ndiscriminated union. It's like a discriminated union PLUS.\n\nIf you find yourself working with many kinds of discriminated union types in TypeScript,\nyou will likely be writing a ton of boilerplate code over and over for each one: record\ntype definitions, manually exporting a union type, then writing a constructor function\nfor each case, followed by writing each `match` and `matchOrElse` function by hand while\nmaking sure to enforce exhaustive checks manually. This also has the unfortunate side effect", "type definitions, manually exporting a union type, then writing a constructor function\nfor each case, followed by writing each `match` and `matchOrElse` function by hand while\nmaking sure to enforce exhaustive checks manually. This also has the unfortunate side effect\nof increasing your unit test API surface area, since each `match` function now needs to be\nunit tested individually. Using variants allows us to skip both the boilerplate code and\nthe boilerplate test code.\n\nMoreover, using variant-flavored discriminated unions means we can sprinkle in other helpful\nfeatures like scoping, where you can reuse the same variant structure but scope the discriminants\nwithout making the rest of the code more verbose. This is particularly useful for things like\nredux actions which conventionally are scoped like `domainArea/actionName`, but when dealing\nwith each case, you don't want to have to manually write out things like `domainArea/` over and over.\n\n## Basic usage\n", "In this example below, we have a `Pet` object and `Pet` type that we're exporting. It may seem\nsurprising for the object and the type to have the exact same name, but TypeScript is able to\ninfer from context which you're trying to reference. (That is because one name lives in the world\nof _types_ and the other name lives in the world of _values_.)\n\n```ts\nexport const Pet = variant({\n    dog: (name: string) => ({ name }),\n    cat: (livesLeft: number) => ({ livesLeft }),\n    fish: {},\n})", "export type Pet = VariantOf<typeof Pet>\n```\n\n**Aside:** if you squint hard enough, you should see that this API is designed to read concisely,\nlike [ML-family](<https://en.wikipedia.org/wiki/ML_(programming_language)>) languages that have more\nfirst-class support for discriminated unions. For example, in F#, a similar type definition might look like:\n\n```fsharp\ntype Pet =\n    | Dog of name: string\n    | Cat of livesLeft: int\n    | Fish\n```\n\nThe `Pet` object will give you access to the [helper methods](#helper-methods) mentioned below while", "type Pet =\n    | Dog of name: string\n    | Cat of livesLeft: int\n    | Fish\n```\n\nThe `Pet` object will give you access to the [helper methods](#helper-methods) mentioned below while\nthe `Pet` type gives you a type in the shape of your discriminated union.\n\n```ts\nimport { Pet } from \"@/types\"\n\n// Simple constructor\nconst myPet = Pet.dog(\"Rex\")\n\n// Simple matching\nconst sayHelloToPet = Pet.match({\n    dog: \"Hello dog!\",\n    cat: \"Hello cat!\",\n    fish: \"Blub blub fish!\",\n})\n\n// Equivalent to:\nconst sayHelloToPetWithSwitch = (pet: Pet) => {\n    switch (pet._tag) {\n        case \"Dog\":\n            return \"Hello dog!\";\n        case \"Cat\":\n            return \"Hello cat!\";\n        case \"Fish\":\n            return \"Blub blub fish!\";\n        default:\n            return \"This should not happen!\"; // Have to handle this case somehow\n    }\n}\n", "// The generated `Pet` type is:\ntype PetByHand =\n  | {\n      _tag: \"Dog\";\n      name: string;\n    }\n  | {\n      _tag: \"Cat\";\n      livesLeft: number;\n    }\n  | {\n      _tag: \"Fish\";\n    };\n", "// ^^ Note that this type is JUST a standard TS discriminated union! \n```\n\n## Concepts\n\n### Discriminant\n\nThe discriminant will be the property that is used to distinguish between the various types.\n\nBy default, this property is `_tag` but using {@link variantC}, you can call this property\nsomething else. For example, for Redux actions, you will want to use `type` as the discriminant\nproperty (as is virtually always used with Redux actions).\n\nAs an example, consider the `Pet` variant type.\n\n```ts\nconst Pet = variant({\n    dog: (name: string) => ({ name }),\n    cat: (livesLeft: number) => ({ livesLeft }),\n    fish: {},\n})", "type Pet = VariantOf<typeof Pet>\n```\n\nOur `Pet` type will look like:\n\n```ts\n{\n    _tag: \"Dog\",\n    name: string;\n} |\n{\n    _tag: \"Cat\",\n    livesLeft: number\n} |\n{\n    _tag: \"Fish\"\n}\n```\n\nAs you can see, the property names we pass into `variant` get translated into the different possible\nvalues of the discriminant property (`_tag`).\n\n### Scope\n\nScopes can be used when you have the possibility of different variant types with the same name, such\nthat one can't be passed in for another. This is common with our [Redux actions](#redux-actions) where\nmultiple action variants might share the same name (e.g., `rowAdded`).\n\nPractically speaking, this means that instead of the `AvailabilityHours.rowAdded` and `AvailabilityDates.rowAdded`\nboth having a discriminant property of `rowAdded`, they have `AvailabilityHours/rowAdded` and\n`AvailabilityDates/rowAdded`, respectively. See the example below for an illustration of this. (Note\nRedux actions use `type`, instead of `_tag` as we did above.)\n\nAvailability Hours:\n\n```ts\n{\n  type: \"AvailabilityHours/RowAdded\";\n}\n```\n\nAvailability Dates:\n\n```ts\n{\n  type: \"AvailabilityDates/RowAdded\";\n}\n```\n\nAs you can see, it is now impossible to pass in the `rowAdded` action from AvailabilityHours", "into a function that expects an AvailabilityDates action variant, and vice versa. The compiler\nsimply won't let you do it!\n\n## Helper Methods\n\nAll examples below use the following `Pet` variant type to illustrate their usages.\n\n```ts\nconst Pet = variant({\n    dog: (name: string) => ({ name }),\n    cat: (livesLeft: number) => ({ livesLeft }),\n    fish: {},\n})", "type Pet = VariantOf<typeof Pet>\n```\n\n### Constructors\n\nUsed to create an instance of a particular variant type. If a function is used for the variant\ntype (like `dog` and `cat` above) then that function becomes the constructor function. Otherwise\nif there is no function and just an empty object (like `fish` above), then there is no traditional\nconstructor function, but just a static instance you can reference.\n\n**Note:** Because TypeScript is a structurally typed language, discriminated union constructors\nbehave somewhat differently than in other languages where discriminated unions are more prevalent.\nFor instance, the `Pet.dog` constructor below doesn't return the type `Pet`, but actually returns\nthe literal object type `{ _tag: 'dog', name: string }`, which is _assignable to_ `Pet`. In some cases,\nthis is very desirable because you know the exact shape of the object without pattern matching.\nIn other cases, it can lead the TypeScript compiler to make more restrictive (or \"narrow\") type\ninferences than you may expect. This is a compiler-level behavior, so just something to watch out for!\n\n```ts\nconst rexTheDog = Pet.dog(\"Rex\")\nconst nineLivesTheCat = Pet.cat(9)\nconst myGoldFish = Pet.fish\n```\n\n### match\n\n`match` can be used similarly to a `switch` but is much more concise and\nforces exhaustive checking at compile time.\n\n```ts\nconst isFish = Pet.match({\n    dog: false,\n    cat: false,\n    fish: true\n})\n\nconst pet = ???; // Assume we won't know what kind of pet until runtime.\n", "if (isFish(pet)) {\n    console.log(\"You got yourself a fish there!\")\n}\n```\n\nAs you can see above, hard coded literals can be given to the matcher, but lambda functions also work!\nIf given a lambda, you'll automatically have type-safe access to the unique properties of that variant\ntype. (This is essentially equivalent to the semantics of pattern matching.)\n\nLambdas are especially useful if (a) you need to access the destructured case data (e.g., the dog's\nname like below) to produce the result, or (b) you want to avoid doing an expensive or long-running\ncomputation unless it is actually needed.\n\n```ts\nconst describePet = Pet.match({\n    dog: ({ name }) => `This dog's name is ${name}.`,\n    cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n    fish: () => \"This is just a fish, nothing special about it.\"", "Lambdas are especially useful if (a) you need to access the destructured case data (e.g., the dog's\nname like below) to produce the result, or (b) you want to avoid doing an expensive or long-running\ncomputation unless it is actually needed.\n\n```ts\nconst describePet = Pet.match({\n    dog: ({ name }) => `This dog's name is ${name}.`,\n    cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n    fish: () => \"This is just a fish, nothing special about it.\"\n    // Note: the \"fish\" case wouldn't need to be a function since the fish variant\n    // type does not have any data on it.\n})\n\nconst pet = ??? // Assume we won't know what kind of pet until runtime.\n\nconsole.log(\"Say hello to my pet!\")\nconsole.log(describePet(pet))\n```\n\nNote you can also mix and match between hard-coded literals and functions. Since `fish` has no additional data,\nI would probably write the above like this.\n\n```ts\nconst describePet = Pet.match({\n  dog: ({ name }) => `This dog's name is ${name}.`,\n  cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n  fish: \"This is just a fish, nothing special about it.\",\n})\n```\n\n### matchOrElse\n\nThere are plenty of instances where you don't want your matching to be exhaustive but instead have a\n\"default\" (`orElse`) case. Like in the `isFish` example above, it feels a bit redundant to mark\neverything not a `fish` with `false`, right? With `matchOrElse`, you could simplify\nit to the following:\n\n```ts\nconst isFish = Pet.matchOrElse({\n    fish: true\n    orElse: false\n})\n```\n\n`matchOrElse` can take any number of variant types (except all of them, use `match` in that case \ud83d\ude01) so you\naren't restricted to just \"fish or else!\".\n\n```ts\nconst isInterestingPet = Pet.matchOrElse({\n    dog: true,\n    cat: true,\n    orElse: false,\n})\n```\n\n(This assumes we're confident that `dog` and `cat` are the only interesting pets that we will ever have,\nwhich may not be a safe assumption \ud83d\ude09)\n\nJust like `match`, `matchOrElse` can also take functions that will give you the data attached to the\nparticular variant instance:\n\n```ts\nconst describePet = Pet.match({\n    dog: ({ name }) => `This dog's name is ${name}.`,\n    cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n    orElse: \"Sorry, nothing interesting about this pet.\",\n})\n```\n\n### types\n\nSimply gives you an object that gives you all the variant types with their corresponding discriminant\nproperty value. We've found this to be mostly useful for tests (especially tests where we need to verify\nthat certain redux actions have been dispatched in a particular order).\n\n```ts\nconst dogTag = Pet.types.dog // Evaluates to \"Dog\"\n```\n\nIf a scope is included in the variants, this will also be included here.\n\n```ts\nconst rowAdded = AvailabilityHours.types.rowAdded // Evaluates to \"AvailabilityHours/RowAdded\"\n```\n\n## VariantC\n\nIn the majority of cases, usage of `variantC` should not be necessary. The `C` stands for \"customize\",\nso this version of `variant` allows you to customize your variant slightly. Currently the two things\nthat can be customized are the [discriminant property](#discriminant) and the [scope](#scope).\n\nWe use `variantC` (but abstracted away) with our [Redux Actions](#redux-actions) to use scope names\n(because that is more important with redux actions where collisions are more likely) and rename our\ndiscriminant property to `type` (per redux action convention).\n\nAnother (very contrived) example of using `variantC` might be:\n\n```ts\nconst discriminantProperty = \"petKind\"\nconst scope = \"CoolPets/\"\nconst CustomPet = variantC(\n    {\n        dog: (name: string) => ({ name }),\n        cat: (livesLeft: number) => ({ livesLeft }),\n        fish: {},\n    },\n    discriminantProperty,\n    scope\n)", "    // Note: the \"fish\" case wouldn't need to be a function since the fish variant\n    // type does not have any data on it.\n})\n\nconst pet = ??? // Assume we won't know what kind of pet until runtime.\n\nconsole.log(\"Say hello to my pet!\")\nconsole.log(describePet(pet))\n```\n\nNote you can also mix and match between hard-coded literals and functions. Since `fish` has no additional data,\nI would probably write the above like this.\n\n```ts\nconst describePet = Pet.match({\n  dog: ({ name }) => `This dog's name is ${name}.`,\n  cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n  fish: \"This is just a fish, nothing special about it.\",\n})\n```\n\n### matchOrElse\n\nThere are plenty of instances where you don't want your matching to be exhaustive but instead have a\n\"default\" (`orElse`) case. Like in the `isFish` example above, it feels a bit redundant to mark\neverything not a `fish` with `false`, right? With `matchOrElse`, you could simplify\nit to the following:\n\n```ts\nconst isFish = Pet.matchOrElse({\n    fish: true\n    orElse: false\n})\n```\n\n`matchOrElse` can take any number of variant types (except all of them, use `match` in that case \ud83d\ude01) so you\naren't restricted to just \"fish or else!\".\n\n```ts\nconst isInterestingPet = Pet.matchOrElse({\n    dog: true,\n    cat: true,\n    orElse: false,\n})\n```\n\n(This assumes we're confident that `dog` and `cat` are the only interesting pets that we will ever have,\nwhich may not be a safe assumption \ud83d\ude09)\n\nJust like `match`, `matchOrElse` can also take functions that will give you the data attached to the\nparticular variant instance:\n\n```ts\nconst describePet = Pet.match({\n    dog: ({ name }) => `This dog's name is ${name}.`,\n    cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n    orElse: \"Sorry, nothing interesting about this pet.\",\n})\n```\n\n### types\n\nSimply gives you an object that gives you all the variant types with their corresponding discriminant\nproperty value. We've found this to be mostly useful for tests (especially tests where we need to verify\nthat certain redux actions have been dispatched in a particular order).\n\n```ts\nconst dogTag = Pet.types.dog // Evaluates to \"Dog\"\n```\n\nIf a scope is included in the variants, this will also be included here.\n\n```ts\nconst rowAdded = AvailabilityHours.types.rowAdded // Evaluates to \"AvailabilityHours/RowAdded\"\n```\n\n## VariantC\n\nIn the majority of cases, usage of `variantC` should not be necessary. The `C` stands for \"customize\",\nso this version of `variant` allows you to customize your variant slightly. Currently the two things\nthat can be customized are the [discriminant property](#discriminant) and the [scope](#scope).\n\nWe use `variantC` (but abstracted away) with our [Redux Actions](#redux-actions) to use scope names\n(because that is more important with redux actions where collisions are more likely) and rename our\ndiscriminant property to `type` (per redux action convention).\n\nAnother (very contrived) example of using `variantC` might be:\n\n```ts\nconst discriminantProperty = \"petKind\"\nconst scope = \"CoolPets/\"\nconst CustomPet = variantC(\n    {\n        dog: (name: string) => ({ name }),\n        cat: (livesLeft: number) => ({ livesLeft }),\n        fish: {},\n    },\n    discriminantProperty,\n    scope\n)", "type CustomPet = VariantOf<typeof CustomPet>\n```\n@module Variants\n*/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\nimport { Identity } from \"./prelude\"\nimport { String } from \"./string\"\n\n/**************\n * Helper Types\n ***************/", "type DefaultDiscriminant = \"_tag\"\n\ntype DefaultScope = \"\"\n\ntype Func = (...args: any[]) => any\n\ntype EmptyObjGuard<T> = T extends ObjectGuard<infer O>\n    ? object extends O\n        ? O\n        : never\n    : never\n", "type Scoped<T extends string, Scope extends string = \"\"> = Scope extends \"\"\n    ? T\n    : `${Scope}${T}`\n\ntype ObjectGuard<T extends object> = Exclude<T, any[] | Func>\n\ntype NonEmptyStringKeys<T> = Exclude<Extract<keyof T, string>, \"\">\n\n/********************\n * Foundational Types\n *********************/\n", "type VariantInputObject = Record<string, Func | object>\n\ntype Variant<\n    Case extends string,\n    Data extends object = object,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = Identity<\n    {\n        readonly [key in Discriminant]: Scoped<Case, Scope>\n    } & Readonly<Data>\n>\n", "type CaseReturnType<T> = T extends (...args: any[]) => infer R\n    ? R extends object\n        ? R\n        : never\n    : EmptyObjGuard<T>\n\ntype VariantConstructor<\n    Args extends any[],\n    Case extends string,\n    Data extends object = object,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = (...args: Args) => Variant<Case, Data, Discriminant, Scope>\n", "type VariantConstructorOrValue<\n    T,\n    Case extends string,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = ObjectGuard<CaseReturnType<T>> extends never\n    ? [never, \"Only objects are allowed as variant data. Wrap variant data in an object.\"]\n    : T extends Func\n    ? VariantConstructor<Parameters<T>, Case, CaseReturnType<T>, Discriminant, Scope>\n    : Variant<Case, CaseReturnType<T>, Discriminant, Scope>\n", "type VariantConstructors<\n    Input extends VariantInputObject = Record<string, never>,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = {\n    readonly [Case in NonEmptyStringKeys<Input>]: VariantConstructorOrValue<\n        Input[Case],\n        Capitalize<Case>,\n        Discriminant,\n        Scope\n    >\n}\n", "type _VariantOf<\n    Input extends VariantInputObject,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = {\n    [Case in NonEmptyStringKeys<Input>]: Identity<\n        Variant<Capitalize<Case>, CaseReturnType<Input[Case]>, Discriminant, Scope>\n    >\n}[NonEmptyStringKeys<Input>]\n\n/*****************\n * Composite Types\n ******************/\n", "type VariantMatcher<A, Input extends VariantInputObject = Record<string, never>> = {\n    readonly [Case in keyof Input]: ((data: CaseReturnType<Input[Case]>) => A) | A\n}\n\ntype VariantMatch<\n    Input extends VariantInputObject = Record<string, never>,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = <A>(\n    matcher: VariantMatcher<A, Input>\n) => (instance: _VariantOf<Input, Discriminant, Scope>) => A\n", "type PartialVariantMatcher<\n    A,\n    Input extends VariantInputObject = Record<string, never>\n> = Partial<VariantMatcher<A, Input>> & {\n    readonly orElse: (() => A) | A\n}\n\ntype VariantMatchOrElse<\n    Input extends VariantInputObject = Record<string, never>,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = <A>(\n    partialMatcher: PartialVariantMatcher<A, Input>\n) => (instance: _VariantOf<Input, Discriminant, Scope>) => A\n", "type VariantTypes<\n    Input extends VariantInputObject = Record<string, never>,\n    Scope extends string = DefaultScope\n> = {\n    readonly [Case in NonEmptyStringKeys<Input>]: Scoped<Capitalize<Case>, Scope>\n}\n\ntype VariantModule<\n    Input extends VariantInputObject = Record<string, never>,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n> = {\n    readonly match: VariantMatch<Input, Discriminant, Scope>\n    readonly matchOrElse: VariantMatchOrElse<Input, Discriminant, Scope>\n    readonly types: Identity<VariantTypes<Input, Scope>>\n} & VariantConstructors<Input, Discriminant, Scope>\n\n/**", " * Extracts a \"plain old\" discriminated union type from a `VariantModule` constructed\n * with {@link variant} or {@link  variantC}.\n */\nexport type VariantOf<V> = V extends VariantModule<\n    infer Input,\n    infer Discriminant,\n    infer Scope\n>\n    ? Identity<_VariantOf<Input, Discriminant, Scope>>\n    : [never, \"Error: V must be a variant module\"]\n\n/**********************\n * Generative Functions\n ***********************/\n\nconst isFunc = (f: Func | object): f is Func => typeof f === \"function\"\n\nconst getVariantCtors = <\n    T extends VariantInputObject,\n    Discriminant extends string = DefaultDiscriminant,\n    Scope extends string = DefaultScope\n>(\n    inp: T,\n    discriminant: Discriminant,\n    scope: Scope\n): VariantConstructors<T, Discriminant, Scope> =>\n    Object.entries(inp).reduce((acc, entry) => {\n        const [_case, ctor] = entry\n        const capitalizedCase = String.capitalize(_case)\n        const scopedCapitalizedCase =\n            scope.length > 0 ? `${scope}${capitalizedCase}` : `${capitalizedCase}`\n\n        return Object.assign(acc, {\n            [_case]: isFunc(ctor)\n                ? (...args: any[]) => ({\n                      [discriminant]: scopedCapitalizedCase,\n                      ...ctor(...args),\n                  })\n                : { [discriminant]: scopedCapitalizedCase },\n        })\n    }, {}) as VariantConstructors<T, Discriminant, Scope>\n\nconst getVariantTypes = <T extends VariantInputObject, Scope extends string = \"\">(\n    inp: T,\n    scope: Scope\n): Identity<VariantTypes<T, Scope>> =>\n    Object.entries(inp).reduce((acc, entry) => {\n        const [_case] = entry\n        const capitalizedCase = String.capitalize(_case)\n        const scopedCapitalizedCase =\n            scope.length > 0 ? `${scope}${capitalizedCase}` : `${capitalizedCase}`\n\n        return Object.assign(acc, { [_case]: scopedCapitalizedCase })\n    }, {}) as Identity<VariantTypes<T, Scope>>\n\nconst unscope = <Scope extends string>(type: string, scope: Scope) =>\n    scope.length > 0 ? type.replace(new RegExp(`${scope}`), \"\") : type\n\nconst getMatchFn =\n    <\n        T extends VariantInputObject,\n        Discriminant extends string = DefaultDiscriminant,\n        Scope extends string = DefaultScope\n    >(\n        discriminant: Discriminant,\n        scope: Scope\n    ): VariantMatch<T, Discriminant> =>\n    matcher =>\n    instance => {\n        const unscopedUncapitalizedType = String.uncapitalize(\n            unscope(instance[discriminant], scope)\n        )\n", "        if (!Object.hasOwn(matcher, unscopedUncapitalizedType)) {\n            throw new TypeError(\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `Expected to be given a variant with scope ${scope}. Actual type was ${instance[discriminant]}`\n            )\n        }\n\n        const branch = matcher[unscopedUncapitalizedType]\n\n        const data = { ...instance }\n        delete data[discriminant]\n\n        return typeof branch === \"function\" ? (branch as any)(data) : branch\n    }\n\nconst getMatchOrElseFn =\n    <\n        T extends VariantInputObject,\n        Discriminant extends string = DefaultDiscriminant,\n        Scope extends string = DefaultScope\n    >(\n        discriminant: Discriminant,\n        scope: Scope\n    ): VariantMatchOrElse<T, Discriminant> =>\n    matcher =>\n    instance => {\n        const unscopedUncapitalizedType = String.uncapitalize(\n            unscope(instance[discriminant], scope)\n        )\n", "        if (Object.hasOwn(matcher, unscopedUncapitalizedType)) {\n            const branch = matcher[unscopedUncapitalizedType]\n\n            const data = { ...instance }\n            delete data[discriminant]\n\n            return typeof branch === \"function\" ? branch(data) : branch\n        }\n\n        return typeof matcher.orElse === \"function\"\n            ? (matcher.orElse as any)()\n            : matcher.orElse\n    }\n", "/** _C_ stands for customize! Returns a module object containing case\n * constructors a mapping of cases to (possibly) scoped `types` (i.e., tags),\n * and `match`/`matchOrElse` functions. **This function allows you to pass\n * your own discriminant (e.g., `\"type\"`) and scope (e.g., `\"Namespace/\"`).**\n *\n * Changing the scope allows you to re-use the exact same variant structure\n * without risking conflicting types or matcher functions. **Use a scope\n * for redux actions to namespace them.**\n *\n * This does not handle generic variants, like `Option<T>`.\n *\n * @example\n * ```\n * export const Action = variantC({\n *     loadStuffStarted: {},\n *     loadStuffFinished: (response: string) => ({ response }),\n * }, \"type\", \"Namespace/\")", " * export type Action = VariantOf<typeof Action>\n *\n * // Access type names\n * const types = Action.types // => { loadStuffStarted: \"Namespace/LoadStuffStarted\", loadStuffFinished: \"Namespace/LoadStuffFinished\" }\n *\n * // Construct a new instance\n * const myAction = Action.loadStuffFinished(\"200 OK\") // => { type: \"Namespace/LoadStuffFinished\", response: \"200 OK\" }\n *\n * // Perform a match\n * const matchResult = pipe(\n *     myAction,\n *     Action.match({\n *       loadStuffStarted: \"stuff started!\",\n *       loadStuffFinished: ({ response }) => `Finished, response=${response}`,\n *     })\n * ) // => \"Finished, response=200 OK\"\n * ```\n */\nexport const variantC = <\n    T extends VariantInputObject,\n    Discriminant extends string,\n    Scope extends string\n>(\n    inp: T,\n    discriminant: Discriminant,\n    scope: Scope\n): VariantModule<T, Discriminant, Scope> => ({\n    ...getVariantCtors(inp, discriminant, scope),\n    match: getMatchFn(discriminant, scope),\n    matchOrElse: getMatchOrElseFn(discriminant, scope),\n    types: getVariantTypes(inp, scope),\n})\n\n/**", " * Returns a module object containing case constructors, a mapping of cases to\n * (possibly) scoped `types` (i.e., tags), and `match`/`matchOrElse` functions.\n * **This function uses the default discriminant of `\"_tag\"` and no scope.**\n *\n * This **does not** handle generic variants, like `Option<T>`.\n *\n * @example\n * ```\n * export const Pet = variant({\n *   dog: (name: string) => ({ name }),\n *   cat: (livesLeft: number) => ({ livesLeft }),\n *   fish: {},\n * })", " * export type Pet = VariantOf<typeof Pet>\n *\n * // Access type names (useful in Redux scenarios)\n * const types = Pet.types // => { dog: \"Dog\", cat: \"Cat\", fish: \"Fish\" }\n *\n * // Construct a new instance\n * const myDog = Pet.dog(\"Fido\") // => { _tag: \"Dog\", name: \"Fido\" }\n *\n * // Perform a match\n * const matchResult = pipe(\n *     myDog,\n *     Pet.matchOrElse({\n *         dog: ({ name }) => `Woof! I am ${name}`,\n *         orElse: \"not a dog\",\n *     })\n * ) // => \"Woof! I am Fido\"\n * ```\n */\nexport const variant = <T extends VariantInputObject>(\n    inp: T\n): VariantModule<T, DefaultDiscriminant, DefaultScope> => ({\n    ...getVariantCtors(inp, \"_tag\", \"\"),\n    match: getMatchFn(\"_tag\", \"\"),\n    matchOrElse: getMatchOrElseFn(\"_tag\", \"\"),\n    types: getVariantTypes(inp, \"\"),\n})\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { pipe, flow } from \"./Composition\"\nexport { tee, teeAsync } from \"./function\"\nexport { String } from \"./string\"\nexport { EqualityComparer } from \"./EqualityComparer\"\nexport { OrderingComparer } from \"./OrderingComparer\"\nexport { Nullable } from \"./Nullable\"\nexport { Option } from \"./Option\"\nexport { Result } from \"./Result\"\nexport { Async } from \"./Async\"\nexport { AsyncResult } from \"./AsyncResult\"", "export { Async } from \"./Async\"\nexport { AsyncResult } from \"./AsyncResult\"\nexport { Array } from \"./Array\"\nexport { NonEmptyArray } from \"./NonEmptyArray\"\nexport { Map } from \"./Map\"\nexport { Deferred } from \"./Deferred\"\nexport type { EnumOf } from \"./Enums\"\nexport { enumOf } from \"./Enums\"\nexport type { VariantOf } from \"./Variants\"\nexport { variant, variantC } from \"./Variants\"", "export type { VariantOf } from \"./Variants\"\nexport { variant, variantC } from \"./Variants\"\nexport { DeferredResult } from \"./DeferredResult\"\n"]}
{"filename": "src/Enums.ts", "chunked_list": ["/**\nSee [Enums considered harmful](https://www.youtube.com/watch?v=jjMbPt_H3RQ) for the motivation\nbehind this custom type. (Also worth noting is that in TypeScript 5.0 [all Enums are considered\nunions](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#all-enums-are-union-enums).)\n\nSimilar to [variants](variants.md) for disciminated unions, `enumOf` allows you to more easily\nand safely create and work with enums in TypeScript.\n\n## Basic Example\n", "## Basic Example\n\n```ts\nexport const MyEnum = enumOf(\n    {\n        Dog = \"Dog\",\n        Cat = \"Cat\",\n        ZEBRA = 1234,\n    } as const, // the `as const` won't be required in TypeScript 5.0\n    \"MyEnum\" // friendly name is optional; used to generate helpful parser errors", "    } as const, // the `as const` won't be required in TypeScript 5.0\n    \"MyEnum\" // friendly name is optional; used to generate helpful parser errors\n) \n\nexport type MyEnum = EnumOf<typeof MyEnum> // => \"Dog\" | \"Cat\" | 1234\n```\n\n## Methods\n\n### Standard enum-style accessors\n\n```ts\nconst dog = MyEnum.Dog // => \"Dog\"\nconst zebra = MyEnum.ZEBRA // => 1234\n```\n\n### Values\n\nAccess array of all valid values, correctly typed (but without any ordering guarantees).\n\n```ts\nconst myEnumValues = MyEnum.values // => [\"Dog\", \"Cat\", 1234]\n```\n\n### Parser\n", "Get a safe parser function for this enum automagically!\n\n```ts\nconst parsed = MyEnum.parse(\"cat\") // => a `Result<MyEnum, string>`, in this case `Result.ok(\"Cat\")`\n```\n\n### Match\n\nSee `match` in the {@link Variants} module docs for more details on matchers.\n\n```ts\nconst speak: (e: MyEnum) => string = MyEnum.match({\n    Dog: \"woof woof\",\n    Cat: () => \"meow\",\n    ZEBRA: \"is my skin white with black stripes or black with white stripes??\",\n})\n\nspeak(myEnum)\n```\n\n### MatchOrElse\n", "See `match` in the {@link Variants} module docs for more details on matchers.\n\n```ts\nconst speak: (e: MyEnum) => string = MyEnum.match({\n    Dog: \"woof woof\",\n    Cat: () => \"meow\",\n    ZEBRA: \"is my skin white with black stripes or black with white stripes??\",\n})\n\nspeak(myEnum)\n```\n\n### MatchOrElse\n", "See `matchOrElse` in the {@link Variants} module docs for more details on partial matchers.\n\n```ts\nconst speak: (e: MyEnum) => string = MyEnum.matchOrElse({\n    Dog: \"woof woof\",\n    Cat: () => \"meow\",\n    orELse: \"I cannot speak.\",\n})\n\nspeak(myEnum)\n```\n", "@module Enums\n*/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Result } from \"./Result\"\nimport { String } from \"./string\"\nimport { Option } from \"./Option\"\nimport { pipe, flow } from \"./Composition\"\nimport { Array } from \"./Array\"\nimport { Identity, NonNullish } from \"./prelude\"\n\n/** @ignore */", "type StringKeys<T extends object> = Extract<keyof T, string>\n\n/**\n * A plain object that serves as the definition of the enum type.\n * Until TypeScript 5.0 is released, you need to specify `as const`\n * on this object definition.\n */\ntype RawEnum = Record<string, string | number>\n\n/** @ignore */\ntype StringKeyValues<T extends RawEnum> = Identity<T[StringKeys<T>]>\n\n/** @ignore */", "type StringKeyValues<T extends RawEnum> = Identity<T[StringKeys<T>]>\n\n/** @ignore */\ntype EnumMatcher<A, R extends RawEnum> = {\n    readonly [Label in StringKeys<R>]: (() => A) | A\n}\n\n/** @ignore */\ntype PartialEnumMatcher<A, R extends RawEnum> = Partial<EnumMatcher<A, R>> & {\n    readonly orElse: (() => A) | A\n}\n", "type PartialEnumMatcher<A, R extends RawEnum> = Partial<EnumMatcher<A, R>> & {\n    readonly orElse: (() => A) | A\n}\n\ntype EnumMatch<R extends RawEnum> = <A>(\n    matcher: EnumMatcher<A, R>\n) => (value: StringKeyValues<R>) => A\n\ntype EnumMatchOrElse<R extends RawEnum> = <A>(\n    matcher: PartialEnumMatcher<A, R>\n) => (value: StringKeyValues<R>) => A\n\n/**\n * The output of the {@link enumOf} function. Produces an object that serves both as", "type EnumMatchOrElse<R extends RawEnum> = <A>(\n    matcher: PartialEnumMatcher<A, R>\n) => (value: StringKeyValues<R>) => A\n\n/**\n * The output of the {@link enumOf} function. Produces an object that serves both as\n * the enum as well as a namespace for helper functions related to that enum.\n */\ntype EnumModule<R extends RawEnum> = Identity<\n    {\n        readonly [Label in StringKeys<R>]: R[Label]\n    } & {\n        /**", "type EnumModule<R extends RawEnum> = Identity<\n    {\n        readonly [Label in StringKeys<R>]: R[Label]\n    } & {\n        /**\n         * Returns a readonly array containing the set of all possible enum values. No\n         * guarantees are made regarding the order of items in the resultant array.\n         */\n        readonly values: ReadonlyArray<StringKeyValues<R>>\n\n        /**", "         * For string enum values, the parse function will trim and coerce values to lowercase\n         * before comparison. (This has no effect on numeric enum values.) Thus, if an\n         * enum is defined as `'Yes' | 'No'`, this decoder will parse `'yes'`, `' yES'`,\n         * and `' YES '` correctly into the canonical `'Yes'` enum value.\n         */\n        readonly parse: (u: unknown) => Result<StringKeyValues<R>, string>\n\n        /**\n         * Use this function for an exhaustive case check that doesn't require using\n         * a switch/case block or any kind of assertExhaustive check.\n         */\n        readonly match: EnumMatch<R>\n\n        /**", "         * Use this function for an exhaustive case check that doesn't require using\n         * a switch/case block or any kind of assertExhaustive check.\n         */\n        readonly match: EnumMatch<R>\n\n        /**\n         * Use this function for a partial case check that doesn't require using\n         * a switch/case block.\n         */\n        readonly matchOrElse: EnumMatchOrElse<R>\n    }\n>\n\n/**", " * Gets the union type representing all possible enum values.\n */\nexport type EnumOf<T> = T extends EnumModule<infer R>\n    ? StringKeyValues<R>\n    : [never, \"Error: T must be an EnumModule\"]\n\nconst getParserErrorMessage = <T extends RawEnum>(\n    enumValues: EnumModule<T>[\"values\"],\n    enumFriendlyName: string\n) => `Must be an enum value in the set ${enumFriendlyName}{ ${enumValues.join(\", \")} }`\n\nconst toTrimmedLowerCase = (a: string | number) =>\n    pipe(\n        Option.some(a),\n        Option.refine(String.isString),\n        Option.map(flow(String.trim, String.toLowerCase)),\n        Option.defaultValue(a)\n    )\n\nconst isStringOrNumber = (u: NonNullish): u is string | number =>\n    typeof u === \"string\" || typeof u === \"number\"\n\nconst getParseFn =\n    <R extends RawEnum>(enumValues: EnumModule<R>[\"values\"], enumFriendlyName: string) =>\n    (u: unknown): Result<StringKeyValues<R>, string> =>\n        pipe(\n            Option.ofNullish(u),\n            Result.ofOption(\n                () =>\n                    `Enum${\n                        enumFriendlyName ? ` ${enumFriendlyName}` : \"\"\n                    } cannot be null/undefined`\n            ),\n            Result.refine(\n                isStringOrNumber,\n                () =>\n                    `Enum${\n                        enumFriendlyName ? ` ${enumFriendlyName}` : \"\"\n                    } must be a string or number`\n            ),\n            Result.map(toTrimmedLowerCase),\n            Result.bind(testVal =>\n                pipe(\n                    enumValues,\n                    Array.find(val => toTrimmedLowerCase(val) === testVal),\n                    Option.match({\n                        some: a => Result.ok(a),\n                        none: () =>\n                            Result.err(\n                                getParserErrorMessage(enumValues, enumFriendlyName)\n                            ),\n                    })\n                )\n            )\n        )\n\nconst isFunc = (f: unknown): f is (...args: any[]) => any => typeof f === \"function\"\n\nconst getMatchFn =\n    <R extends RawEnum>(raw: R): EnumMatch<R> =>\n    matcher =>\n    value => {\n        const enumEntry = Object.entries(raw).find(([, v]) => v === value)\n", ") => `Must be an enum value in the set ${enumFriendlyName}{ ${enumValues.join(\", \")} }`\n\nconst toTrimmedLowerCase = (a: string | number) =>\n    pipe(\n        Option.some(a),\n        Option.refine(String.isString),\n        Option.map(flow(String.trim, String.toLowerCase)),\n        Option.defaultValue(a)\n    )\n\nconst isStringOrNumber = (u: NonNullish): u is string | number =>\n    typeof u === \"string\" || typeof u === \"number\"\n\nconst getParseFn =\n    <R extends RawEnum>(enumValues: EnumModule<R>[\"values\"], enumFriendlyName: string) =>\n    (u: unknown): Result<StringKeyValues<R>, string> =>\n        pipe(\n            Option.ofNullish(u),\n            Result.ofOption(\n                () =>\n                    `Enum${\n                        enumFriendlyName ? ` ${enumFriendlyName}` : \"\"\n                    } cannot be null/undefined`\n            ),\n            Result.refine(\n                isStringOrNumber,\n                () =>\n                    `Enum${\n                        enumFriendlyName ? ` ${enumFriendlyName}` : \"\"\n                    } must be a string or number`\n            ),\n            Result.map(toTrimmedLowerCase),\n            Result.bind(testVal =>\n                pipe(\n                    enumValues,\n                    Array.find(val => toTrimmedLowerCase(val) === testVal),\n                    Option.match({\n                        some: a => Result.ok(a),\n                        none: () =>\n                            Result.err(\n                                getParserErrorMessage(enumValues, enumFriendlyName)\n                            ),\n                    })\n                )\n            )\n        )\n\nconst isFunc = (f: unknown): f is (...args: any[]) => any => typeof f === \"function\"\n\nconst getMatchFn =\n    <R extends RawEnum>(raw: R): EnumMatch<R> =>\n    matcher =>\n    value => {\n        const enumEntry = Object.entries(raw).find(([, v]) => v === value)\n", "        if (!enumEntry) {\n            throw new TypeError(\n                `Expected to match against an enum where '${value}' is a valid value.`\n            )\n        }\n\n        const enumLabel = enumEntry[0]\n        if (!Object.hasOwn(matcher, enumLabel)) {\n            throw new TypeError(\n                `Expected a matcher containing a case for '${enumLabel}'.`\n            )\n        }\n\n        const matcherBranch = matcher[enumLabel]\n        return isFunc(matcherBranch) ? matcherBranch() : matcherBranch\n    }\n\nconst getMatchOrElseFn =\n    <R extends RawEnum>(raw: R): EnumMatchOrElse<R> =>\n    matcher =>\n    value => {\n        const enumEntry = Object.entries(raw).find(([, v]) => v === value)\n", "        if (!enumEntry) {\n            throw new TypeError(\n                `Expected to match against an enum where '${value}' is a valid value.`\n            )\n        }\n\n        const enumLabel = enumEntry[0]\n        if (Object.hasOwn(matcher, enumLabel)) {\n            const branch = matcher[enumLabel]\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return isFunc(branch) ? branch() : branch\n        }\n\n        return isFunc(matcher.orElse) ? matcher.orElse() : matcher.orElse\n    }\n\n/**", " * Generates an \"enum module\" from a raw object. For motivation behind using a custom\n * generative function instead of the built-in `enum` types, see [this video](https://youtu.be/jjMbPt_H3RQ).\n *\n * This function augments a raw \"enum object\" with several useful capabilities: `values`, `parse`, `match`,\n * and `matchOrElse`.\n *   - `values` contains the list of valid enum values\n *   - `parse` is a parser funciton auto-magically created for this enum\n *   - `match` is a pipeable function that allows exhaustive pattern matching\n *   - `matchOrElse` is a pipeable function that allows inexhaustive pattern matching\n *\n * @remarks", " *   - `matchOrElse` is a pipeable function that allows inexhaustive pattern matching\n *\n * @remarks\n * You can use the `parse` function together with `io-ts` to easily create a decoder for this enum.\n *\n * @example\n * ```ts\n * export const MyEnum = enumOf({\n *   Dog = 'Dog',\n *   Cat = 'Cat',\n *   ZEBRA = 1234,\n * } as const, 'MyEnum') // => friendly name optional; used to generate helpful decoder errors", " * export type MyEnum = EnumOf<typeof MyEnum>; //=> 'Dog' | 'Cat' | 1234\n *\n * // Standard enum-style accessors\n * const dog = MyEnum.Dog; // => 'Dog'\n * const zebra = MyEnum.ZEBRA; // => 1234\n *\n * // Access array of all valid values, correctly typed\n * const myEnumValues = MyEnum.values; // => ['Dog', 'Cat', 1234]\n *\n * // Get a decoder instance for this enum automagically\n * const myDecoder = MyEnum.decoder; // => a `D.Decoder<unknown, 'Dog' | 'Cat' | 1234>`\n *", " * // Get a decoder instance for this enum automagically\n * const myDecoder = MyEnum.decoder; // => a `D.Decoder<unknown, 'Dog' | 'Cat' | 1234>`\n *\n * // Match an enum value against all its cases (compiler ensures exhaustiveness)\n * const value: MyEnum = 'Cat';\n * const matchResult = pipe(\n *   value,\n *   MyEnum.match({\n *     Dog: 'woof woof',\n *     Cat: () => 'meow',\n *     ZEBRA: 'is my skin white with black stripes or black with white stripes??'\n *   })\n * ) // => 'meow'\n * ```\n */\nexport const enumOf = <T extends RawEnum>(\n    raw: T,\n    enumFriendlyName = \"\"\n): EnumModule<T> => {\n    const entriesWithStringKeys = Object.entries(raw).reduce(\n        (acc, [label, value]) => ({\n            ...acc,\n            [label]: value,\n        }),\n        {}\n    )\n\n    const values = Object.values(raw)\n\n    return {\n        ...entriesWithStringKeys,\n        values,\n        parse: getParseFn(values, enumFriendlyName),\n        match: getMatchFn(raw),\n        matchOrElse: getMatchOrElseFn(raw),\n    } as unknown as EnumModule<T>\n}\n"]}
{"filename": "src/Map.ts", "chunked_list": ["/**\n * A suite of useful functions for working with the built-in `Map` type.\n *\n * @module Map\n */\nimport { NonNullish, Predicate } from \"./prelude\"\nimport { Option } from \"./Option\"\nimport { pipe } from \"./Composition\"\nimport { EqualityComparer } from \"./EqualityComparer\"\nimport { OrderingComparer } from \"./OrderingComparer\"\n\n/**\n * Lookup a key/value pair (wrapped in a `Some`) from a `Map` using the given key.\n * If the `Map` doesn't contain the key, returns `None`.\n *\n * Uses the given equality comparer if passed. Otherwise, defaults to reference\n * equality (triple equals) for equality comparisons.\n *\n * @group Lookups\n *\n * @returns An `Option` containing a tuple of the key and value.\n */\nexport const findWithKey =\n    <K>(key: K, { equals }: EqualityComparer<K> = EqualityComparer.Default) =>\n    <V>(map: ReadonlyMap<K, V>): Option<[K, V]> => {", "        if (map.size < 1) {\n            return Option.none\n        }\n\n        for (const [k, v] of map) {\n            if (equals(k, key)) {\n                return Option.some([k, v])\n            }\n        }\n\n        return Option.none\n    }\n\n/**\n * Test whether a `Map` contains the given key. Uses the given `EqualityComparer`\n * if passed. Otherwise, defaults to reference equality (triple equals).\n *\n * @group Lookups\n *\n * @returns `true` if the key is in the `Map`, `false` otherwise.\n */\nexport const containsKey =\n    <K>(key: K, equalityComparer: EqualityComparer<K> = EqualityComparer.Default) =>\n    <V>(map: ReadonlyMap<K, V>): boolean =>\n        pipe(map, findWithKey(key, equalityComparer), Option.isSome)\n\n/**\n * Get a value associated with the given key from the `Map`. Returns a `Some`\n * containing the value, or `None` if the key is not in the `Map`.\n *\n * Uses the given equality comparer if passed, otherwise defaults to using\n * reference equality (triple equals) for equality comparison.\n *\n * @group Lookups\n */\nexport const find =\n    <K>(key: K, equalityComparer: EqualityComparer<K> = EqualityComparer.Default) =>\n    <V extends NonNullish>(map: ReadonlyMap<K, V>): Option<V> =>\n        pipe(\n            map,\n            findWithKey(key, equalityComparer),\n            Option.map(([, v]) => v)\n        )\n\n/**\n * Adds a key/value pair to a `Map`. If the given key already exists\n * the value at that key will be updated with the given value.\n *\n * Will use the equality comparer if given, otherwise defaults to using\n * reference equality (triple equals) for equality comparisons.\n *\n * @group Transformations\n *\n * @returns A new `Map` with the added key/value pair\n */\nexport const set =\n    <K, V>(\n        [key, value]: readonly [K, V],\n        equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n    ) =>\n    (map: ReadonlyMap<K, V>): ReadonlyMap<K, V> => {", "        if (map.size < 1) {\n            const out = empty<K, V>()\n            out.set(key, value)\n            return out\n        }\n\n        const copy = new globalThis.Map(map)\n\n        return pipe(\n            map,\n            findWithKey(key, equalityComparer),\n            Option.match({\n                none: () => {\n                    copy.set(key, value)\n                    return copy\n                },\n                some: ([k]) => {\n                    copy.set(k, value)\n                    return copy\n                },\n            })\n        )\n    }\n\n/**\n * Make a new `Map` by producing a new each value for each key using\n * the given function.\n *\n * @group Mapping\n * @group Transformations\n */\nexport const map =\n    <K, V, R>(f: (k: K, v: V) => R) =>\n    (map: ReadonlyMap<K, V>): ReadonlyMap<K, R> => {", "        if (map.size < 1) {\n            return empty<K, R>()\n        }\n\n        const out = empty<K, R>()\n\n        for (const [k, v] of map) {\n            out.set(k, f(k, v))\n        }\n\n        return out\n    }\n\n/**", " * Get the first key for which the given predicate function returns\n * true, wrapped in a `Some`. If no key is found, returns `None`. Uses\n * the given `OrderingComparer` if passed, otherwise defaults to default\n * ASCII-based sort.\n *\n * @group Lookups\n */\nexport const findKey =\n    <K extends NonNullish>(\n        predicate: Predicate<K>,\n        orderingComparer: OrderingComparer<K> = OrderingComparer.Default\n    ) =>\n    <V>(map: ReadonlyMap<K, V>): Option<K> =>\n        Option.ofNullish(keys(orderingComparer)(map).find(predicate))\n\n/**\n * Creates a new empty map. Essentially an alias for `new globalThis.Map()`.\n * Provided for convience to avoid having to use `globalThis`.\n *\n * @group Constructors\n */\nexport const empty = <K = never, V = never>() => new globalThis.Map<K, V>()\n\n/**\n * Returns `true` if at least one _value_ in the `Map` returns `true`\n * for the given predicate function.\n *\n * @group Lookups\n * @group Utils\n */\nexport const exists =\n    <V>(predicate: Predicate<V>) =>\n    <K>(map: ReadonlyMap<K, V>): boolean => {", "        if (map.size < 1) {\n            return false\n        }\n\n        for (const [, v] of map) {\n            if (predicate(v)) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n/**\n * Replace the value at a given key in the map using the given\n * replacement function. Will use the given `EqualityComparer`\n * if passed. Otherwise defaults to reference equality (triple equals).\n *\n * If the key isn't in the map, returns the map unchanged.\n *\n * @group Transformations\n */\nexport const change =\n    <K, V>(\n        key: K,\n        f: (v: V) => V,\n        equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n    ) =>\n    (map: ReadonlyMap<K, V>): ReadonlyMap<K, V> =>\n        pipe(\n            map,\n            findWithKey(key, equalityComparer),\n            Option.match({\n                some: ([k, v]) => {\n                    const copy = new globalThis.Map(map)\n                    copy.set(k, f(v))\n                    return copy\n                },\n                none: map,\n            })\n        )\n\n/**\n * Get the number of key/value pairs in the map.\n *\n * @group Utils\n */\nexport const size = <K, V>(map: ReadonlyMap<K, V>) => map.size\n\n/**\n * Returns whether the map contains any key/value pairs.\n *\n * @group Utils\n *\n * @returns `true` if the map has no bindings, `false` otherwise.\n */\nexport const isEmpty = <K, V>(map: ReadonlyMap<K, V>) => map.size < 1\n\n/**\n * Get only the keys from the map as an array. Will use the given `OrderingComparer`\n * to sort the keys, otherwise will the default ASCII-based sort.\n *\n * @group Utils\n */\nexport const keys =\n    <K>({ compare }: OrderingComparer<K> = OrderingComparer.Default) =>\n    <V>(map: ReadonlyMap<K, V>): readonly K[] =>\n        Array.from(map.keys()).sort(compare)\n\n/**\n * Gets all the values from the map as an array, including duplicates. Values\n * will be sorted using the default ASCII-based sort or the `OrderingComparer`\n * if it is given.\n \n * @group Utils\n */\nexport const values =\n    <V>(orderingComparer: OrderingComparer<V> = OrderingComparer.Default) =>\n    <K>(map: ReadonlyMap<K, V>): readonly V[] => {\n        const values: V[] = []\n", "        for (const [, v] of map) {\n            values.push(v)\n        }\n\n        return values.sort(orderingComparer.compare)\n    }\n\n/**\n * Returns the map as an array of key-value tuples. The array will be sorted by\n * key, using the given `OrderingComparer` or falling back to the default ASCII-based\n * sort.\n *\n * @group Transformations\n * @group Utils\n */\nexport const toArray =\n    <K>(orderingComparer: OrderingComparer<K> = OrderingComparer.Default) =>\n    <V>(map: ReadonlyMap<K, V>): readonly (readonly [K, V])[] =>\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        keys(orderingComparer)(map).map(key => [key, map.get(key)!])\n\n/**\n * Also commonly referred to as `fold` or `aggregate`. Applies each key/value", " * pair in the map to a \"reducer\" (or \"folding\") function to build up a final\n * accumulated value.\n *\n * Key/value pairs will be given to the reducer function based on the sort-order\n * of the keys. That order can be specified by passing the `OrderingComparer`.\n * Defaults to the standard ASCII-based sort.\n *\n * @group Transformations\n * @group Utils\n *\n * @param f\n * The reducer function. Accepts the accumulator value, the key, and the value and\n * produces the next incremental accumulator value.\n */\nexport const reduce =\n    <S, K, V>(\n        init: S,\n        f: (acc: S, k: K, v: V) => S,\n        orderingComparer: OrderingComparer<K> = OrderingComparer.Default\n    ) =>\n    (map: ReadonlyMap<K, V>): S =>\n        toArray(orderingComparer)(map).reduce((s, [k, v]) => f(s, k, v), init)\n\n/**\n * Like {@link reduce}, but the key-value pairs are passed to the reducer in\n * _reverse_ sort-order.\n */\nexport const reduceRight =\n    <S, K, V>(\n        init: S,\n        f: (acc: S, k: K, v: V) => S,\n        orderingComparer: OrderingComparer<K> = OrderingComparer.Default\n    ) =>\n    (map: ReadonlyMap<K, V>): S =>\n        toArray(orderingComparer)(map).reduceRight((s, [k, v]) => f(s, k, v), init)\n\n/**\n * Get a new map containing only the key/value pairs for which the given", " * predicate function returns `true`.\n *\n * @group Transformations\n * @group Filtering\n */\nexport const filter =\n    <K, V>(f: (k: K, v: V) => boolean) =>\n    (map: ReadonlyMap<K, V>): ReadonlyMap<K, V> => {\n        if (map.size < 1) {\n            return empty()\n        }\n\n        const out = empty<K, V>()\n", "        if (map.size < 1) {\n            return empty()\n        }\n\n        const out = empty<K, V>()\n\n        for (const [k, v] of map) {\n            if (f(k, v)) {\n                out.set(k, v)\n            }\n        }\n\n        return out\n    }\n\n/**\n * Test whether every key/value pair in a map returns `true` for the\n * given predicate function.\n *\n * @group Utils\n */\nexport const every =\n    <K, V>(f: (k: K, v: V) => boolean) =>\n    (map: ReadonlyMap<K, V>): boolean => {", "        if (map.size < 1) {\n            return true\n        }\n\n        for (const [k, v] of map) {\n            if (!f(k, v)) {\n                return false\n            }\n        }\n\n        return true\n    }\n\n/**", " * Execute an arbitrary side-effect function for every key/value pair in the map.\n * Does not affect the values contained in the map. Can be helpful for logging\n * or debugging.\n *\n * @group Utils\n *\n * @param f Should not mutate its arguments. See {@link map} if you want to\n * transform the map into a new map.\n *\n * @returns void\n */\nexport const iter =\n    <K, V>(f: (k: K, v: V) => void) =>\n    (map: ReadonlyMap<K, V>): void => {", "        if (map.size < 1) {\n            return\n        }\n\n        for (const [k, v] of map) {\n            f(k, v)\n        }\n    }\n\n/**\n * Convert an array of tuples into a map of key/value pairs.\n *\n * @group Constructors\n */\nexport const ofArray = <K, V>(\n    array: readonly (readonly [K, V])[],\n    equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n): ReadonlyMap<K, V> => {", "    if (array.length < 1) {\n        return new globalThis.Map()\n    }\n\n    return array.reduce<ReadonlyMap<K, V>>(\n        (map, kvp) => set(kvp, equalityComparer)(map),\n        empty()\n    )\n}\n\n/**\n * Remove the given key from the map. Will use the `EqualityComparer` if passed,\n * otherwise defaults to reference equality (triple equals). The map will be\n * returned unchanged if the key is not found in the map.\n *\n * @group Transformations\n */\nexport const remove =\n    <K>(key: K, equalityComparer: EqualityComparer<K> = EqualityComparer.Default) =>\n    <V>(map: ReadonlyMap<K, V>) =>\n        pipe(\n            map,\n            findWithKey(key, equalityComparer),\n            Option.match({\n                some: ([k]) => {\n                    const copy = new globalThis.Map(map)\n                    copy.delete(k)\n                    return copy\n                },\n                none: map,\n            })\n        )\n\n/**\n * Convert a `Record` object into a map of key/value pairs. Uses `Object.entries`\n * under-the-hood, so keep in mind there are some gotchas about what comprise\n * an object's \"own, enumerable\" properties. Designed primarily to be used for\n * simple objects like those deserialized from a JSON blob, for instance.\n *\n * Will use the given `EqualityComparer` to determine key uniqueness if given.\n * Otherwise, defaults to reference equality (triple equals).\n *\n * @group Constructors\n */\nexport const ofRecord = <K extends string, V>(\n    record: Record<K, V>,\n    equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n) =>\n    Object.entries<V>(record).reduce<ReadonlyMap<K, V>>(\n        (map, [k, v]) => set([k as K, v], equalityComparer)(map),\n        empty()\n    )\n\n/* c8 ignore start */\n/** @ignore */\nexport const Map = {\n    exists,\n    containsKey,\n    findWithKey,\n    find,\n    findKey,\n    set,\n    remove,\n    change,\n    map,\n    filter,\n    every,\n    iter,\n    empty,\n    size,\n    isEmpty,\n    reduce,\n    reduceRight,\n    toArray,\n    ofArray,\n    ofRecord,\n    keys,\n    values,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/Composition.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable prefer-rest-params */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable func-style */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable  @typescript-eslint/no-unsafe-call */\n\n/// ATTRIBUTION: https://github.com/gcanti/fp-ts/blob/master/src/function.ts\n", "/// ATTRIBUTION: https://github.com/gcanti/fp-ts/blob/master/src/function.ts\n\n/**\n- [Jump to Pipe](#pipelining-with-pipe)\n- [Jump to Flow](#flowing-with-flow)\n\nBoth JavaScript and TypeScript have great support for the functional programming paradigm because\nthey support functions as first-class values. That is, functions can be assigned to variables, passed\naround as arguments to other functions, and can be freely constructed and typed in the same way as\nany other values.\n", "The functional programming paradigm takes this a step further by making function composition the\nprimary (but not always exclusive!) means by which large and complex applications are built.\n\nReact itself is a prime example. Using Function Components to construct a user interface is essentially\njust composing lots of small functions (read: components) together to make one larger function (the \nroot component of your application component tree).\n\n### Math-y definition\n\nIn its most abstract and pure mathematical sense, function composition is simply taking the result\nfrom one function and passing it to another function. Consider the following code snippet:\n\n```ts\nconst f = (n: number) => n * 20\nconst g = (n: number) => n + 4\n\n// define a new function `h` that is the _composition_ of `f` and `g`\nconst h = (n: number) => f(g(n))\n```\n\nNotice that the composition essentially reflects passing the value first to `g`, then passing the\nresultant value immediately to `f`. Of course, we can keep composing functions all the way down the\nroad like `f(g(h(z(42)))`.\n\n## Pipelining with `pipe`\n", "In its most abstract and pure mathematical sense, function composition is simply taking the result\nfrom one function and passing it to another function. Consider the following code snippet:\n\n```ts\nconst f = (n: number) => n * 20\nconst g = (n: number) => n + 4\n\n// define a new function `h` that is the _composition_ of `f` and `g`\nconst h = (n: number) => f(g(n))\n```\n\nNotice that the composition essentially reflects passing the value first to `g`, then passing the\nresultant value immediately to `f`. Of course, we can keep composing functions all the way down the\nroad like `f(g(h(z(42)))`.\n\n## Pipelining with `pipe`\n", "Because function composition is so useful and prevalent in the functional paradigm, it helps to make\nit as readable and convenient as possible.\n\nThe `pipe` operator is a way to re-organize function composition so that it reads linearly, like a\npipeline... hence its name! Using the `pipe` operator, the nested mess above could be written as follows:\n\n```ts\nconst result = pipe(\n    42,\n    z,\n    h,\n    g,\n    f\n)\n```\n\nIn plain english: \"Start with the value 42. Pass that value to `z`. Then pass the resultant value to `h`.\nThen pass the resultant value to `g`. Then pass the resultant value to `f`.\"\n\n**Note:** Pipelining requires unary functions (functions that take a single argument) to work properly. This", "is why generally functionally-oriented libraries like this one favor curried function signatures.\n\n### Examples\n\nFunction composition with `pipe` is the primary motivation for using currying and partially applying\nfunctions. Consider the following annotated code example:\n\n```ts\n// lets assume we have access to some basic string functions with these signatures\ndeclare const capitalize: (s: string) => string\ndeclare const exclaim: (s: string) => string\ndeclare const duplicate: (s: string) => [string, string]\n\n// note that the following functions are curried\ndeclare const split: (splitter: string) => (s: string) => string[]\ndeclare const join: (joiner: string) => (as: string[]) => string\ndeclare const map: <A, B>(f: (a: A) => B) => (as: A[]) => B[]\ndeclare const flatMap: <A, B>(f: (a: A) => B[]) => (as: A[]) => B[]\n\nconst result = pipe(\n    \"hello there\",\n    split(\" \"),                             // [\"hello\", \"there\"]\n    map(s => pipe(s, capitalize, exclaim)), // [\"Hello!\", \"There!\"]\n    flatMap(duplicate),                     // [\"Hello!\", \"Hello!\", \"There!\", \"There!\"]\n    join(\"<>\")                              // \"Hello!<>Hello!<>There!<>There!\"\n);\n```\n", "As you can see, this fashion of function composition allows us to \"snap together\" (like LEGO bricks)\nsmall and simple functions to build up more complicated logic and data transformation pipelines that...\n\n1. are more _declarative_ than _imperative_&mdash;they describe what we would like done at a high level,\n   they don't tell the computer how exactly to do it\n2. require no intermediate throw-away values\n\nFor instance, you could rewrite the above pipeline along these lines:\n\n```ts\nconst splitResult = \"hello there\".split(\" \")\nconst mapResult = splitResult.map(s => {\n  const capitalized = capitalize(s);\n  return exclaim(capitalized);\n})\nconst flatMapResult = mapResult.flatMap(duplicate)\nconst joinResult = flatMapResult.join(\"<>\")\n```\n\nSee how you have to manually declare the result of each step and pass that explicitly to the next \"step\"\nin the flow?\n\nOf course, in this instance, you could _probably_ achieve a similar syntax with fluent method chaining,\nbecause JavaScript provides a lot of prototype methods for strings and arrays that are interoperable.\nBut that is something of a special case for strings and arrays in particular. More importantly, method\nchaining requires you to [monkey patch](https://en.wikipedia.org/wiki/Monkey_patch) the global prototype\nto be able to fluently chain non-built-in functions together.\n\nThis example is just to demonstrate how the `pipe` allows you to get rid of the usually-required intermediate\nresult assignments that are threaded through to the next call using any arbitrary functions, _regardless\nof what is available as instance methods_.\n\n### TC39 proposal\n\nThere is a [stage 2 proposal](https://github.com/tc39/proposal-pipeline-operator) to make the pipeline operator\n(`|>`) built-in to JavaScript because it is a high-demand language feature. TypeScript generally implements\nTC39 proposals once they hit stage 3.\n\n## Flowing with `flow`\n\nLet's revisit part of the example from above:\n\n```ts\nconst result = pipe(\n    \"hello there\",\n    split(\" \"),\n    map(s => pipe(s, capitalize, exclaim)), // notice how `s` is only used as the initial value for `pipe`?\n    flatMap(duplicate),\n    join(\"<>\")\n)\n```\n\nWhenever you see a lambda where the lambda argument is only used as the initial value, you can likely\nreplace that with `flow`.\n\nSo, the above could be re-written:\n\n```ts\nconst result = pipe(\n    \"hello there\",\n    split(\" \"),\n    map(flow(\n        capitalize,\n        exclaim\n    )),\n    flatMap(duplicate),\n    join(\"<>\")\n)\n```\n\nYou can think of `flow` like `pipe` where the initial value becomes the implicit first argument to the", "function. So, for example, these two function definitions are equivalent:\n\n```ts\ndeclare const double: (n: number) => number\ndeclare const addTwenty: (n: number) => number\n\nconst doubleThenAddTwenty1 = (n: number) => pipe(n, double, addTwenty);\nconst doubleThenAddTwenty2 = flow(double, addTwenty);\n```\n\nThe fancy term for `flow` is left-to-right function composition. But, frankly, it is generally easier\nto just think about `flow` as a `pipe` where the initial value of the `pipe` becomes the implicit first", "The fancy term for `flow` is left-to-right function composition. But, frankly, it is generally easier\nto just think about `flow` as a `pipe` where the initial value of the `pipe` becomes the implicit first\nargument to the function that `flow` produces.\n\nOr, another way to think about it is that `pipe` starts with a **value** then accepts a pipeline of\nfunctions, and returns a **value**. `flow`, on the other hand, starts with a **function** and accepts =\nother functions to compose together and returns a **function** that is \"waiting\" to be passed a value.\n\nYet another way to conceptualize it is that immediately passing a value to a function composed with\n`flow` is identical to using `pipe` starting with the value, so the following two are identical:\n\n```ts\nconst result1 = pipe(\"help\", capitalize, exclaim);\n\nconst result2 = flow(capitalize, exclaim)(\"help\");\n```\n\n### A word of warning\n", "Yet another way to conceptualize it is that immediately passing a value to a function composed with\n`flow` is identical to using `pipe` starting with the value, so the following two are identical:\n\n```ts\nconst result1 = pipe(\"help\", capitalize, exclaim);\n\nconst result2 = flow(capitalize, exclaim)(\"help\");\n```\n\n### A word of warning\n", "Because of how TypeScript's compiler works, `pipe` will almost always give you better type inference\nthan `flow`. Especially when you start to work with generic types like `Option`s or `Array`s, you\nwill likely find that TypeScript gets confused rather frequently if you overuse `flow`, so don't abuse it!\n\nMoreover, abusing or overusing `flow` can actually end up making your code _less_ readable than\nit would be with more straightforward `pipe`s.\n\n**As a rule of thumb**, you should _usually_ constrain your use of `flow` to small local functions\nwhere you already have good type inference, like in the example above.\n\n@module Composition\n*/\n\n/* c8 ignore start */", "where you already have good type inference, like in the example above.\n\n@module Composition\n*/\n\n/* c8 ignore start */\n/** Left-to-right function composition. See module-level docs for more. */\nexport function flow<A extends ReadonlyArray<unknown>, B>(\n    ab: (...a: A) => B\n): (...a: A) => B\nexport function flow<A extends ReadonlyArray<unknown>, B, C>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C\n): (...a: A) => C", "export function flow<A extends ReadonlyArray<unknown>, B, C>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C\n): (...a: A) => C\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D\n): (...a: A) => D\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E\n): (...a: A) => E", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E\n): (...a: A) => E\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F\n): (...a: A) => F", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G\n): (...a: A) => G\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H\n): (...a: A) => H", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H\n): (...a: A) => H\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I\n): (...a: A) => I", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I\n): (...a: A) => I\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J\n): (...a: A) => J", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(\n    ab: (...a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J\n): (...a: A) => J", "export function flow(\n    ab: Function,\n    bc?: Function,\n    cd?: Function,\n    de?: Function,\n    ef?: Function,\n    fg?: Function,\n    gh?: Function,\n    hi?: Function,\n    ij?: Function\n): unknown {\n    switch (arguments.length) {\n        case 1:\n            return ab\n        case 2:\n            return function (this: unknown) {\n                return bc!(ab.apply(this, arguments))\n            }\n        case 3:\n            return function (this: unknown) {\n                return cd!(bc!(ab.apply(this, arguments)))\n            }\n        case 4:\n            return function (this: unknown) {\n                return de!(cd!(bc!(ab.apply(this, arguments))))\n            }\n        case 5:\n            return function (this: unknown) {\n                return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n            }\n        case 6:\n            return function (this: unknown) {\n                return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n            }\n        case 7:\n            return function (this: unknown) {\n                return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n            }\n        case 8:\n            return function (this: unknown) {\n                return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n            }\n        case 9:\n            return function (this: unknown) {\n                return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n            }\n    }\n    return\n}\n/* c8 ignore end */\n\n// ATTRIBUTION: https://github.com/gcanti/fp-ts/blob/master/src/function.ts\n\n/* c8 ignore start */\n/**", " * A version of left-to-right function composition that starts with a _value_.\n * Commonly referred to as function pipelining, for obvious reasons.\n *\n * See module-level docs for more.\n */\nexport function pipe<A>(a: A): A\nexport function pipe<A, B>(a: A, ab: (a: A) => B): B\nexport function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C\nexport function pipe<A, B, C, D>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D\n): D", "export function pipe<A, B, C, D>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D\n): D\nexport function pipe<A, B, C, D, E>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E\n): E", "export function pipe<A, B, C, D, E, F>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F\n): F\nexport function pipe<A, B, C, D, E, F, G>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G\n): G", "export function pipe<A, B, C, D, E, F, G>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G\n): G\nexport function pipe<A, B, C, D, E, F, G, H>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H\n): H", "export function pipe<A, B, C, D, E, F, G, H>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H\n): H\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I\n): I", "export function pipe<A, B, C, D, E, F, G, H, I>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I\n): I", "export function pipe<A, B, C, D, E, F, G, H, I, J>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J\n): J", "export function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K\n): K", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L\n): L", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M\n): M", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N\n): N", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O\n): O\n", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P\n): P\n", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q\n): Q\n", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R\n): R\n", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S\n): S\n", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T\n): T", "export function pipe(\n    a: unknown,\n    ab?: Function,\n    bc?: Function,\n    cd?: Function,\n    de?: Function,\n    ef?: Function,\n    fg?: Function,\n    gh?: Function,\n    hi?: Function\n): unknown {\n    switch (arguments.length) {\n        case 1:\n            return a\n        case 2:\n            return ab!(a)\n        case 3:\n            return bc!(ab!(a))\n        case 4:\n            return cd!(bc!(ab!(a)))\n        case 5:\n            return de!(cd!(bc!(ab!(a))))\n        case 6:\n            return ef!(de!(cd!(bc!(ab!(a)))))\n        case 7:\n            return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n        case 8:\n            return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n        case 9:\n            return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n        default: {\n            let ret = arguments[0]", "            for (let i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret)\n            }\n            return ret\n        }\n    }\n}\n/* c8 ignore end */\n"]}
{"filename": "src/EqualityComparer.ts", "chunked_list": ["/**\n * An `EqualityComparer` is intended to model deterministic or \"decideable\" equality\n * between two values. Meaning, it should always give back the same result for the\n * same inputs.\n *\n * Generally you won't need to worry about these things, but in case you come up against\n * some weird edge cases, `EqualityComparer`s should always satisfy these rules:\n *   1. always return `true` if given two values that are the same object reference\n *       - `myEqComparer.equals(a, a) === true`\n *   1. always return `true` for equivalent variables, regardless of the order in which they are passed", " *       - `myEqComparer.equals(a, a) === true`\n *   1. always return `true` for equivalent variables, regardless of the order in which they are passed\n *       - `myEqComparer.equals(a, b) === myEqComparer.equals(b, a)`\n *   1. should be transitive such that if `a` = `b` and `b` = `c`, then `a` = `c`\n *\n * **Note:** An `EqualityComparer` is structurally compatible with the `Eq` type from `fp-ts`.\n *\n * @example\n * interface Pet {\n *    readonly name: string\n *    readonly age: number\n * }\n *", " * interface Pet {\n *    readonly name: string\n *    readonly age: number\n * }\n *\n * class PetByNameComparer implements EqualityComparer<Pet> {\n *    equals(p1: Pet, p2: Pet): boolean {\n *        return p1.name === p2.name\n *    }\n * }\n *", " * @module EqualityComparer\n */\nexport interface EqualityComparer<A> {\n    equals(a1: A, a2: A): boolean\n}\n\n/**\n * Construct a new `EqualityComparer` instance by providing an `equals` function\n * that can decide equality between two values.\n *\n * @group Constructors\n *\n * @returns A new `EqualityComparer` instance.\n */\nexport const ofEquals = <A>(\n    equals: EqualityComparer<A>[\"equals\"]\n): EqualityComparer<A> => ({\n    equals: (a1, a2) => a1 === a2 || equals(a1, a2),\n})\n\n/**\n * Given you already have an `EqualityComparer` for some type `A`, and you know how to\n * map from some other type `B` to `A`, you can effectively \"re-use\" your `EqualityComparer`\n * for type `B`. Also referred to commonly as `contramap`, because the mapping is going\n * from `B`&rarr;`A`, not from `A`&rarr;`B`.\n *\n * @group Utils\n * @group Constructors\n *\n * @param known The `EqualityComparer` that you already have.", " * @param map The function that can map from `B`&rarr;`A`.\n *\n * @returns A new `EqualityComparer` instance.\n */\nexport const deriveFrom = <A, B>(\n    known: EqualityComparer<A>,\n    map: (b: B) => A\n): EqualityComparer<B> => ({\n    equals: (b1, b2) => b1 === b2 || known.equals(map(b1), map(b2)),\n})\n", "type EqualityComparerRecord<A extends object> = {\n    readonly [Key in keyof A]: EqualityComparer<A[Key]>\n}\n\n/**\n * Get an `EqualityComparer` that represents _structural_ equality for a type that\n * conforms to the given shape of type `A`. It is generally required to use `ofStruct`\n * for any complex object type for which you would like property-by-property comparison,\n * because JavaScript has no concept of structural or value-based equality.\n *\n * Will perform property-by-property equality comparsion for each property of the object,\n * using the given `EqualityComparer` instance for each property.\n *\n * @group Utils\n * @group Constructors\n *\n * @returns A new `EqualityComparer` instance.\n */\nexport const ofStruct = <A extends object>(\n    struct: EqualityComparerRecord<A>\n): EqualityComparer<Readonly<A>> =>\n    ofEquals((a1, a2) => {", "        for (const key in struct) {\n            if (!struct[key].equals(a1[key], a2[key])) {\n                return false\n            }\n        }\n        return true\n    })\n\n/**\n * The default `EqualityComparer`, which uses reference (triple equals) equality.\n *\n * @group Primitives\n */\nexport const Default: EqualityComparer<never> = Object.freeze(\n    ofEquals((a1, a2) => a1 === a2)\n)\n\n/**\n * An `EqualityComparer` for the built-in `Date` type.\n *\n * @group Primitives\n */\nexport const Date: EqualityComparer<Date> = ofEquals(\n    (dt1, dt2) => dt1.valueOf() === dt2.valueOf()\n)\n\n/**\n * An `EqualityComparer` for the built-in `string` type.\n *\n * @group Primitives\n */\nexport const String: EqualityComparer<string> = Default\n\n/**\n * An `EqualityComparer` for the built-in `number` type.\n *\n * @group Primitives\n */\nexport const Number: EqualityComparer<number> = Default\n\n/* c8 ignore start */\n/** @ignore */\nexport const EqualityComparer = {\n    ofEquals,\n    ofStruct,\n    deriveFrom,\n    Default,\n    Date,\n    String,\n    Number,\n}\n/* c8 ignore end */\n"]}
{"filename": "src/Option.ts", "chunked_list": ["/**\n * An `Option` represents a value that is, well, optional\u2014\n * it can either be present or absent. This is particularly\n * useful for modeling nullable values while avoiding the\n * possibility of null reference errors.\n *\n * @group Types\n *\n * @remarks\n * The functions in this module are curried and are optimized\n * for use with left-to-right function composition like `pipe`\n * and `flow`.\n *", " * @remarks\n * The functions in this module are curried and are optimized\n * for use with left-to-right function composition like `pipe`\n * and `flow`.\n *\n * **Note:** There is a generic type constraint on option that\n * excludes `null`, `undefined`, and `void` types. This is\n * intentional, because `Option<undefined>` or `Option<null>` make\n * little to no sense conceptually.\n *\n *\n * @example\n * ```\n * pipe(\n *     56,\n *     Option.ofNullish,\n *     Option.filter(n => n > 50),\n *     Option.map(String),\n *     Option.match({\n *         some: a => `${a}!`,\n *         none: \"!\"\n *     }),\n *     console.info\n * ) // logs \"56!\"\n * ```\n *", " * @module Option\n */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { Tagged, assertExhaustive, Refinement, NonNullish } from \"./prelude\"\nimport { pipe } from \"./Composition\"\nimport { EqualityComparer } from \"./EqualityComparer\"\n\nexport interface Some<A extends NonNullish> extends Tagged<\"Some\", { some: A }> {}\nexport interface None extends Tagged<\"None\", object> {}\n\nexport type Option<A extends NonNullish> = Some<A> | None\n\n/**\n * Creates a new `Some` instance.\n *\n * @group Constructors\n *\n * @returns a new `Some` instance containing the given value\n */\nexport const some = <A extends NonNullish>(some: A): Option<A> => ({\n    _tag: \"Some\",\n    some,\n})\n\n/**\n * Alias for the Some constructor. See {@link some}.\n *\n * @group Constructors\n */\nexport const of = some\n\n/**\n * The static None instance.\n *\n * @group Constructors\n */\nexport const none: Option<never> = Object.freeze({ _tag: \"None\" })\n\n/**\n * @ignore\n */", "export interface None extends Tagged<\"None\", object> {}\n\nexport type Option<A extends NonNullish> = Some<A> | None\n\n/**\n * Creates a new `Some` instance.\n *\n * @group Constructors\n *\n * @returns a new `Some` instance containing the given value\n */\nexport const some = <A extends NonNullish>(some: A): Option<A> => ({\n    _tag: \"Some\",\n    some,\n})\n\n/**\n * Alias for the Some constructor. See {@link some}.\n *\n * @group Constructors\n */\nexport const of = some\n\n/**\n * The static None instance.\n *\n * @group Constructors\n */\nexport const none: Option<never> = Object.freeze({ _tag: \"None\" })\n\n/**\n * @ignore\n */", "type OptionMatcher<A, R> = {\n    readonly some: R | ((some: A) => R)\n    readonly none: R | (() => R)\n}\n\nconst isRawValue = <A, R>(caseFn: R | ((ok: A) => R)): caseFn is R =>\n    typeof caseFn !== \"function\"\n\nconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n    isRawValue(match) ? match : match(arg)\n\n/**\n * Exhaustively pattern match against an `Option` in order\n * to \"unwrap\" the inner value. Provide either a raw value\n * or lambda to use for each case (`Some` or `None`). This", " * function is curried.\n *\n * @group Pattern Matching\n *\n * @example\n * pipe(\n *     Option.some(42),\n *     Option.match({\n *         some: n => n * 2,\n *         none: 0,\n *     })\n * ) // => 84\n */\nexport const match =\n    <A extends NonNullish, R>(matcher: OptionMatcher<A, R>) =>\n    (option: Option<A>) => {\n        switch (option._tag) {\n            case \"Some\":\n                return getMatcherResult(matcher.some, option.some)\n            case \"None\":\n                return getMatcherResult(matcher.none, void 0)\n            /* c8 ignore next 2 */\n            default:\n                return assertExhaustive(option)\n        }\n    }\n\n/**\n * Maps the wrapped `Some` value using the given function.\n * Passes through `None` as-is.\n *\n * @group Mapping\n *\n * @example\n * pipe(\n *     Option.some(\"cheese\"),\n *     Option.map(s => s.length),\n *     Option.defaultValue(0)\n * ) // => 6\n */\nexport const map = <A extends NonNullish, B extends NonNullish>(f: (a: A) => B) =>\n    match<A, Option<B>>({\n        some: a => some(f(a)),\n        none: none,\n    })\n\n/**\n * Tests the wrapped `Some` value using the given predicate.\n * If the wrapped value fails the check, returns `None`.\n * `None` is passed through as-is.\n *\n * @group Filtering\n *\n * @example\n * pipe(\n *     Option.some(70),\n *     Option.filter(n => n <= 25),\n *     Option.defaultValue(0)\n * ) // => 0\n */\nexport const filter = <A extends NonNullish>(f: (a: A) => boolean) =>\n    match<A, Option<A>>({\n        some: a => (f(a) ? some(a) : none),\n        none: none,\n    })\n\n/**", " * Use a type guard (a.k.a. `Refinement`) to filter the wrapped value.\n * If the type guard holds for the wrapped value, returns `Some` with\n * the narrowed type. `None` is passed through as-is.\n *\n * @group Filtering\n *\n * @example\n * ```\n * const isString = (u: unknown): u is string => typeof u === \"string\"\n *\n * pipe(\n *     Option.some(\"cheese\" as any),    // Option<any>", " *     Option.refine(isString),         // Option<string> (type is narrowed by the guard)\n *     Option.map(s => s.length)        // Option<number> (TS infers the type of `s`)\n * ) // => Option.some(6)\n * ```\n */\nexport const refine = <A extends NonNullish, B extends A>(f: Refinement<A, B>) =>\n    match<A, Option<B>>({\n        some: a => (f(a) ? some(a) : none),\n        none: none,\n    })\n\n/**\n * Returns the wrapped value if the `Option` is `Some`,\n * otherwise uses the given value as a default value.\n *\n * @group Pattern Matching\n *\n * @example\n * pipe(\n *     Option.none,\n *     Option.defaultValue(\"ABC\")\n * ) // => \"ABC\"\n */\nexport const defaultValue = <A extends NonNullish>(a: A) =>\n    match<A, A>({\n        some: a => a,\n        none: a,\n    })\n\n/**\n * Returns the wrapped value if `Some`. Otherwise, uses the\n * given lambda to compute and return a default value.\n *\n * @group Pattern Matching\n *\n * @example\n * pipe(\n *     Option.some(\"123\"),\n *     Option.defaultWith(() => \"\")\n * ) // => \"123\"\n *\n * @example\n * pipe(\n *     Option.none,\n *     Option.defaultWith(() => \"\")\n * ) // => \"\"\n */\nexport const defaultWith = <A extends NonNullish>(f: () => A) =>\n    match<A, A>({\n        some: a => a,\n        none: f,\n    })\n\n/**", " * Maps an `Option` using a function that returns another\n * `Option` and flattens the result. Sometimes called `flatMap`.\n *\n * @group Mapping\n *\n * @example\n * ```ts\n * declare mightFailA: () => Option<string>\n * declare mightFailB: (s: string) => Option<number>\n *\n * pipe(\n *     mightFailA(),                // Option<string>\n *     Option.bind(mightFailB),     // Option<number>\n *     Option.defaultWith(() => 0)  // number\n * )\n * // => 200 if both mightFail functions return `Some`", " * // => 0 if either function returns `None`\n * ```\n */\nexport const bind = <A extends NonNullish, B extends NonNullish>(\n    f: (a: A) => Option<B>\n) =>\n    match<A, Option<B>>({\n        some: f,\n        none: none,\n    })\n\n/**\n * Alias of {@link bind}\n *\n * @group Mapping\n */\nexport const flatMap = bind\n\n/**", " * A type guard determining whether an `Option` instance is a `Some`.\n *\n * @group Type Guards\n *\n * @example\n * Option.isSome(Option.some(1)) // => true\n * Option.isSome(Option.none) // => false\n */\nexport const isSome = <A extends NonNullish>(o: Option<A>): o is Some<A> =>\n    o._tag === \"Some\"\n\n/**", " * A type guard determining whether an `Option` instance is a `None`.\n *\n * @group Type Guards\n * @example\n * Option.isNone(Option.none) // => true\n * Option.isNone(Option.some(1)) // => false\n */\nexport const isNone = <A extends NonNullish>(o: Option<A>): o is None => o._tag === \"None\"\n\n/**\n * Returns a `Some` containing the value returned from the map function\n * if both `Option`s  are `Some`s. Otherwise, returns `None`.\n *\n * This is a kind of shortcut for pattern matching a tuple of `Option`s.\n *\n * @group Mapping\n * @group Pattern Matching\n *\n * @example\n * pipe(\n *     [Option.some(10), Option.some(20)],\n *     Option.map2((a, b) => a + b),\n *     Option.defaultValue(0)\n * ) // => 30\n */\nexport const map2 =\n    <A extends NonNullish, B extends NonNullish, C extends NonNullish>(\n        map: (a: A, b: B) => C\n    ) =>\n    (options: readonly [Option<A>, Option<B>]): Option<C> => {", "        if (isSome(options[0]) && isSome(options[1])) {\n            return some(map(options[0].some, options[1].some))\n        }\n\n        return none\n    }\n\n/**\n * Returns a Some containing the value returned from the map function\n * if all three `Option`s are `Some`s. Otherwise, returns `None`.\n *\n * This is a kind of shortcut for pattern matching a 3-tuple of `Option`s.\n *\n * @group Mapping\n * @group Pattern Matching\n *\n * @example\n * pipe(\n *     [Option.some(10), Option.some(20), Option.some(30)],\n *     Option.map3((a, b, c) => a + b + c),\n *     Option.defaultValue(0)\n * ) // => 60\n *\n * @example\n * pipe(\n *     [Option.none, Option.some(20), Option.some(30)],\n *     Option.map3((a, b, c) => a + b + c),\n *     Option.defaultValue(0)\n * ) // => 0\n */\nexport const map3 =\n    <\n        A extends NonNullish,\n        B extends NonNullish,\n        C extends NonNullish,\n        D extends NonNullish\n    >(\n        map: (a: A, b: B, c: C) => D\n    ) =>\n    (options: readonly [Option<A>, Option<B>, Option<C>]): Option<D> => {", "        if (isSome(options[0]) && isSome(options[1]) && isSome(options[2])) {\n            return some(map(options[0].some, options[1].some, options[2].some))\n        }\n\n        return none\n    }\n\n/**\n * Constructs an `Option` from a potentially nullish value.\n * Nullish values will result in a `None` instance. Other\n * values will result in a `Some` instance containing the\n * value now constrained to be `NonNullable`.\n *\n * @group Constructors\n *\n * @example\n * Option.ofNullish(null) // => Option.none\n * Option.ofNullish(undefined) // => Option.none\n * Option.ofNullish(1) // => Option.some(1)\n */\nexport const ofNullish = <A>(a: A): Option<NonNullable<A>> => (a != null ? some(a) : none)\n\n/**\n * Converts an `Option` to a nullish value. (`null | undefined`)\n *\n * @group Pattern Matching\n *\n * @param useNull Defaults to `true`. Specify `false` to use `undefined` instead of `null` for `None`s\n */\nexport const toNullish = <A extends NonNullish>(\n    o: Option<A>,\n    useNull = true\n): A | null | undefined =>\n    pipe(\n        o,\n        match({\n            some: a => a,\n            none: useNull ? null : undefined,\n        })\n    )\n\n/**", " * Attempt to perform a function that may throw. If the\n * function throws, returns `None` and swallows the Error.\n *\n * @group Error Handling\n */\nexport const tryCatch = <A extends NonNullish>(mightThrow: () => A): Option<A> => {\n    try {\n        return some(mightThrow())\n    } catch (_) {\n        return none\n    }\n}\n\n/**", "    } catch (_) {\n        return none\n    }\n}\n\n/**\n * Get an `EqualityComparer` for an `Option<A>` by giving this function an\n * `EqualityComparer` for type `A`. Represents structural (value-based) equality\n * for the `Option` type.\n *\n * @group Equality\n * @group Utils\n *\n * @param equalityComparer The `EqualityComparer` to use for the inner value.\n * @returns A new `EqualityComparer` instance\n */\nexport const getEqualityComparer = <A extends NonNullish>({\n    equals,\n}: EqualityComparer<A>): EqualityComparer<Option<A>> =>\n    // `ofEquals` has a built-in reference equality check, which captures the None/None case\n    EqualityComparer.ofEquals((opt1, opt2) =>\n        pipe(\n            [opt1, opt2] as const,\n            map2((a1: A, a2: A) => equals(a1, a2)),\n            defaultValue(false)\n        )\n    )\n\n/**\n * Execute an arbitrary side effect using the inner value of the `Option`. Useful\n * for debugging and logging purposes. Will not have any effect for `None`s.\n *\n * @param f The side effect to execute.\n *\n * @returns The `Option`, unchanged.\n *\n * @group Utils\n */\nexport const tee =\n    <A extends NonNullish>(f: (a: A) => void) =>\n    (option: Option<A>) =>\n        pipe(\n            option,\n            map(a => {\n                f(a)\n                return a\n            })\n        )\n\n/* c8 ignore start */\n/** @ignore */\nexport const Option = {\n    some,\n    of,\n    none,\n    ofNullish,\n    toNullish,\n    match,\n    map,\n    map2,\n    map3,\n    bind,\n    flatMap,\n    defaultValue,\n    defaultWith,\n    isSome,\n    isNone,\n    filter,\n    refine,\n    tryCatch,\n    getEqualityComparer,\n    tee,\n}\n/* c8 ignore end */\n"]}
