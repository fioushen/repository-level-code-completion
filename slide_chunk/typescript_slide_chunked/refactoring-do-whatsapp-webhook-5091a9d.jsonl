{"filename": "tests/wehbook.test.ts", "chunked_list": ["import { Webhook } from '../src';\n\ndescribe('WhatsApp Cloud API webhook suite', () => {\n  let webhook: Webhook;\n\n  beforeEach(() => {\n    webhook = new Webhook({\n      endpoint: '/webhook',\n      port: 3000,\n      verificationToken: '123abc',", "      port: 3000,\n      verificationToken: '123abc',\n      observer: () => {},\n    });\n  });\n\n  it('Should defined a webhook instance', () => {\n    const sut = webhook;\n    expect(sut).toBeDefined();\n  });", "    expect(sut).toBeDefined();\n  });\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { Logger } from './logger';\nexport * from './webhook';\n"]}
{"filename": "src/webhook/index.ts", "chunked_list": ["export { MessageType } from './enums';\nexport { Webhook } from './webhook';\nexport * from './interfaces';\n"]}
{"filename": "src/webhook/webhook.ts", "chunked_list": ["import { IncomingMessage, ServerResponse } from 'node:http';\n\nimport { ReceivedMessage } from './interfaces/received-message.interface';\nimport { WebhookOptions } from './interfaces';\nimport { MessageProccesor } from './utils';\nimport { HttpServer } from '../server';\nimport { Logger } from '../logger';\n\nexport class Webhook {\n  constructor(private readonly options: WebhookOptions) {}\n\n  async run() {\n    const server = new HttpServer();\n\n    server.get(this.options.endpoint, (req: IncomingMessage, res: ServerResponse) => {\n      Logger.log('Entro');\n      const requestPath = new URL(req.url as string, `https://${req.headers.host}`);\n\n      const verifyToken = requestPath.searchParams.get('hub.verify_token');\n      const challenge = requestPath.searchParams.get('hub.challenge');\n", "export class Webhook {\n  constructor(private readonly options: WebhookOptions) {}\n\n  async run() {\n    const server = new HttpServer();\n\n    server.get(this.options.endpoint, (req: IncomingMessage, res: ServerResponse) => {\n      Logger.log('Entro');\n      const requestPath = new URL(req.url as string, `https://${req.headers.host}`);\n\n      const verifyToken = requestPath.searchParams.get('hub.verify_token');\n      const challenge = requestPath.searchParams.get('hub.challenge');\n", "      if (verifyToken && verifyToken === this.options.verificationToken) {\n        res.write(challenge);\n        Logger.log('Cloud API Token has been successfully verified.');\n      } else {\n        res.writeHead(400);\n      }\n\n      return res.end();\n    });\n\n    server.post(this.options.endpoint, (req: IncomingMessage, res: ServerResponse) => {\n      let body: any = '';\n\n      req.on('data', (chunk: any) => {\n        body += chunk.toString();\n      });\n\n      req.on('end', () => {\n        body = JSON.parse(body);\n\n        const isInvalidMessage = !body.object || !body.entry?.[0]?.changes?.[0]?.value;\n", "        if (isInvalidMessage) {\n          res.writeHead(400);\n          return res.end();\n        }\n\n        const isStatusMessage = body?.entry?.[0]?.changes?.[0]?.value?.statuses;\n\n        if (isStatusMessage) {\n          res.writeHead(202);\n          return res.end();\n        }\n\n        Logger.log('New message received');\n\n        const receivedMessage = body as ReceivedMessage;\n        const proccessedMessage = MessageProccesor.process(receivedMessage);\n\n        this.options.observer(proccessedMessage);\n\n        res.writeHead(200);\n        return res.end();\n      });\n    });\n\n    return new Promise((resolve) => {\n      server.listen(this.options.port, () => {\n        resolve(`Webhook is running on port ${this.options.port}`);\n      });\n    });\n  }\n}\n"]}
{"filename": "src/webhook/utils/message-proccesor.util.ts", "chunked_list": ["import { ReceivedMessage, ProcessedMessage } from '../interfaces';\nimport { MessageType } from '../enums';\n\nexport class MessageProccesor {\n  static process(message: ReceivedMessage): ProcessedMessage {\n    const currentMessage = message.entry[0].changes[0].value.messages[0];\n    const messageAuthor = message.entry[0].changes[0].value.contacts[0].profile.name;\n\n    let proccessedMessage: ProcessedMessage;\n\n    switch (currentMessage.type) {\n      case MessageType.text:\n        proccessedMessage = {\n          id: currentMessage.id,\n          from: currentMessage.from,\n          name: messageAuthor,\n          timestamp: currentMessage.timestamp,\n          data: currentMessage[currentMessage.type],\n          type: MessageType.text,\n        };\n\n        break;\n\n      case MessageType.image:\n      case MessageType.document:\n      case MessageType.audio:\n      case MessageType.video:\n      case MessageType.sticker:\n      case MessageType.location:\n      case MessageType.contacts:\n        proccessedMessage = {\n          id: currentMessage.id,\n          from: currentMessage.from,\n          name: messageAuthor,\n          timestamp: currentMessage.timestamp,\n          data: currentMessage[currentMessage.type],", "          type: MessageType[currentMessage.type as MessageType],\n        };\n\n        break;\n\n      case MessageType.interactive:\n        proccessedMessage = {\n          id: currentMessage.id,\n          from: currentMessage.from,\n          name: messageAuthor,\n          timestamp: currentMessage.timestamp,\n          data: currentMessage[currentMessage.type],", "          type: MessageType[currentMessage.type as MessageType],\n        };\n\n        break;\n\n      case MessageType.order:\n        proccessedMessage = {\n          id: currentMessage.id,\n          from: currentMessage.from,\n          name: messageAuthor,\n          timestamp: currentMessage.timestamp,\n          data: {\n            product_items: currentMessage[currentMessage.type].product_items,\n            catalog_id: currentMessage[currentMessage.type].catalog_id,\n          },", "          type: MessageType[currentMessage.type as MessageType],\n        };\n\n        break;\n\n      default:\n        throw new Error(`Invalid message type: ${currentMessage.type}`);\n    }\n\n    if (currentMessage.context) {\n      proccessedMessage.context = currentMessage.context;\n    }\n\n    return proccessedMessage;\n  }\n}\n", "    if (currentMessage.context) {\n      proccessedMessage.context = currentMessage.context;\n    }\n\n    return proccessedMessage;\n  }\n}\n"]}
{"filename": "src/webhook/utils/index.ts", "chunked_list": ["export { MessageProccesor } from './message-proccesor.util';\n"]}
{"filename": "src/webhook/interfaces/received-message.interface.ts", "chunked_list": ["import { MessageType } from '../enums';\n\ninterface Metadata {\n  display_phone_number: string;\n  phone_number_id: string;\n}\n\ninterface Value {\n  messaging_product: string;\n  metadata: Metadata;\n  contacts: Contact[];\n  messages: Message[];\n}\n", "interface Profile {\n  name: string;\n}\n\ninterface Contact {\n  profile: Profile;\n  wa_id: string;\n}\n\ninterface Message {\n  from: string;\n  id: string;\n  timestamp: string;\n  type: MessageType;\n  [key: string]: any;\n}\n", "interface Message {\n  from: string;\n  id: string;\n  timestamp: string;\n  type: MessageType;\n  [key: string]: any;\n}\n\ninterface Changes {\n  value: Value;\n  field: string;\n}\n", "interface Changes {\n  value: Value;\n  field: string;\n}\n\ninterface Entry {\n  id: string;\n  changes: Changes[];\n}\n\nexport interface ReceivedMessage {\n  object: string;\n  entry: Entry[];\n}\n", "export interface ReceivedMessage {\n  object: string;\n  entry: Entry[];\n}\n"]}
{"filename": "src/webhook/interfaces/processed-message.interface.ts", "chunked_list": ["import { MessageType } from '../enums';\n\nexport interface ProcessedMessage {\n  id: string;\n  from: string;\n  name: string;\n  type: MessageType;\n  data: any;\n  timestamp: string;\n  context?: any;\n}\n"]}
{"filename": "src/webhook/interfaces/index.ts", "chunked_list": ["export { ProcessedMessage } from './processed-message.interface';\nexport { ReceivedMessage } from './received-message.interface';\nexport { WebhookOptions } from './webhook-options';\nexport * from './messages';\n"]}
{"filename": "src/webhook/interfaces/webhook-options.ts", "chunked_list": ["type MessageObserver = (message: any) => void;\n\nexport interface WebhookOptions {\n  endpoint: string;\n  port: number;\n  verificationToken: string;\n  observer: MessageObserver;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/sticker-message.interface.ts", "chunked_list": ["import { MediaMessage } from \"./base.interface\";\n\nexport interface StickerMessage extends MediaMessage {\n  animated: boolean;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/contact-message.interface.ts", "chunked_list": ["interface Name {\n  first_name: string;\n  formatted_name: string;\n}\n\ninterface Phone {\n  phone: string;\n  type: string;\n}\n\nexport interface ContactMessage {\n  name: Name;\n  phones: Phone[];\n}\n", "export interface ContactMessage {\n  name: Name;\n  phones: Phone[];\n}\n"]}
{"filename": "src/webhook/interfaces/messages/text-message.interface.ts", "chunked_list": ["export interface TextMessage {\n  body: string;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/base.interface.ts", "chunked_list": ["export interface Reply {\n  id: string;\n  title: string;\n}\n\nexport interface MediaMessage {\n  id: string;\n  sha256: string;\n  mime_type: string;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/document-message.interface.ts", "chunked_list": ["import { MediaMessage } from \"./base.interface\";\n\nexport interface DocumentMessage extends MediaMessage {\n  filename: string;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/location-message.interface.ts", "chunked_list": ["export interface LocationMessage {\n  latitude: string;\n  longitude: string;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/image-message.interface.ts", "chunked_list": ["import { MediaMessage } from \"./base.interface\";\n\nexport interface ImageMessage extends MediaMessage {}\n"]}
{"filename": "src/webhook/interfaces/messages/index.ts", "chunked_list": ["export {\n  InteractiveMessage,\n  ButtonReply,\n  ListReply,\n} from \"./interactive-message.interface\";\nexport { DocumentMessage } from \"./document-message.interface\";\nexport { LocationMessage } from \"./location-message.interface\";\nexport { StickerMessage } from \"./sticker-message.interface\";\nexport { ContactMessage } from \"./contact-message.interface\";\nexport { ImageMessage } from \"./image-message.interface\";", "export { ContactMessage } from \"./contact-message.interface\";\nexport { ImageMessage } from \"./image-message.interface\";\nexport { AudioMessage } from \"./audio-message.interface\";\nexport { OrderMessage } from \"./order-message.interface\";\nexport { VideoMessage } from \"./video-message.interface\";\nexport { TextMessage } from \"./text-message.interface\";\n"]}
{"filename": "src/webhook/interfaces/messages/interactive-message.interface.ts", "chunked_list": ["import { Reply } from \"./base.interface\";\n\nexport interface ListReply extends Reply {\n  description: string;\n}\n\nexport interface ButtonReply extends Reply {}\n\nexport interface InteractiveMessage {\n  type: string;\n  list_reply?: ListReply;\n  button_reply?: ButtonReply;\n}\n", "export interface InteractiveMessage {\n  type: string;\n  list_reply?: ListReply;\n  button_reply?: ButtonReply;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/audio-message.interface.ts", "chunked_list": ["import { MediaMessage } from \"./base.interface\";\n\nexport interface AudioMessage extends MediaMessage {\n  voice: boolean;\n}\n"]}
{"filename": "src/webhook/interfaces/messages/order-message.interface.ts", "chunked_list": ["interface ProductItem {\n  product_retailer_id: string;\n  quantity: number;\n  item_price: number;\n  currency: string;\n}\n\nexport interface OrderMessage {\n  catalog_id: string;\n  product_items: ProductItem[];\n}\n"]}
{"filename": "src/webhook/interfaces/messages/video-message.interface.ts", "chunked_list": ["import { MediaMessage } from \"./base.interface\";\n\nexport interface VideoMessage extends MediaMessage {}\n"]}
{"filename": "src/webhook/enums/message-type.enum.ts", "chunked_list": ["export enum MessageType {\n  message = 'message',\n  text = 'text',\n  image = 'image',\n  document = 'document',\n  audio = 'audio',\n  order = 'order',\n  video = 'video',\n  sticker = 'sticker',\n  location = 'location',\n  contacts = 'contacts',\n  interactive = 'interactive',\n  button_reply = 'button_reply',\n  list_reply = 'list_reply',\n}\n"]}
{"filename": "src/webhook/enums/index.ts", "chunked_list": ["export { MessageType } from './message-type.enum';\n"]}
{"filename": "src/server/http-server.ts", "chunked_list": ["import { IncomingMessage, ServerResponse, createServer } from 'http';\n\nimport { RequestHandler, Route } from './types';\n\nexport class HttpServer {\n  private routes: Route[] = [];\n\n  public use(handler: RequestHandler) {\n    this.routes.push({ method: 'USE', path: '', handler });\n  }\n\n  public get(path: string, handler: RequestHandler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n\n  public post(path: string, handler: RequestHandler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n\n  public listen(port: number, callback?: () => void) {\n    const server = createServer((req: IncomingMessage, res: ServerResponse) => {\n      console.log(req.url);\n      const matchingRoutes = this.routes.filter(\n        (route) =>\n          (route.path === req.url?.substring(0, route.path.length) || route.path === '*') &&\n          (route.method === req.method || route.method === 'USE'),\n      );\n\n      let currentRoute = 0;\n\n      const next = () => {\n        currentRoute++;", "        if (currentRoute < matchingRoutes.length) {\n          matchingRoutes[currentRoute].handler(req, res, next);\n        }\n      };\n\n      if (matchingRoutes.length > 0) {\n        matchingRoutes[currentRoute].handler(req, res, next);\n      } else {\n        res.writeHead(404, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ statusCode: 404, message: 'Resource not found' }));\n      }\n    });\n\n    server.listen(port, callback);\n  }\n}\n"]}
{"filename": "src/server/index.ts", "chunked_list": ["export { HttpServer } from './http-server';\n"]}
{"filename": "src/server/types/index.ts", "chunked_list": ["import { IncomingMessage, ServerResponse } from 'node:http';\n\nexport type RequestHandler = (req: IncomingMessage, res: ServerResponse, next: () => void) => void;\n\nexport type Route = {\n  method: string;\n  path: string;\n  handler: RequestHandler;\n};\n"]}
{"filename": "src/logger/logger.enum.ts", "chunked_list": ["export enum LogLevel {\n  INFO = 'INFO',\n  ERROR = 'ERROR',\n  WARNING = 'WARNING',\n}\n"]}
{"filename": "src/logger/logger.ts", "chunked_list": ["import { LogLevel } from './logger.enum';\n\nexport class Logger {\n  static log(message: any): void {\n    const date = new Date().toISOString();\n\n    console.log({\n      level: LogLevel.INFO,\n      message: `${LogLevel.INFO} [${date}]: ${message}`,\n      date,\n    });\n  }\n\n  static error(message: any): void {\n    const date = new Date().toISOString();\n\n    console.log({\n      level: LogLevel.ERROR,\n      message: `${LogLevel.ERROR} [${date}]: ${message}`,\n      date,\n    });\n  }\n\n  static warning(message: any): void {\n    const date = new Date().toISOString();\n\n    console.log({\n      level: LogLevel.WARNING,\n      message: `${LogLevel.WARNING} [${date}]: ${message}`,\n      date,\n    });\n  }\n}\n"]}
{"filename": "src/logger/index.ts", "chunked_list": ["export { LogLevel } from './logger.enum';\nexport { Logger } from './logger';\n"]}
