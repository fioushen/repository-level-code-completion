{"filename": "src/insomniaDbTypes.ts", "chunked_list": ["/* eslint @typescript-eslint/no-explicit-any: 0 */\n\n// These are all types from the Insomnia source code\n// All type declarations are located in \"packages/insomnia/src/models/*\"\n// Most types are declared in files inside this folder with the same name\n\n// index.ts\nexport interface BaseModel {\n  _id: string;\n  type: string;\n  // TSCONVERSION -- parentId is always required for all models, except 4:\n  //   - Stats, Settings, and Project, which never have a parentId\n  //   - Workspace optionally has a parentId (which will be the id of a Project)\n  parentId: string; // or null\n  modified: number;\n  created: number;\n  isPrivate: boolean;\n  name: string;\n}\n\n// Environment", "export type Environment = {\n  name: string;\n  data: Record<string, any>;\n  dataPropertyOrder: Record<string, any> | null;\n  color: string | null;\n  metaSortKey: number;\n  // For sync control\n  isPrivate: boolean;\n} & BaseModel;\n\n// Project", "export type Project = {\n  name: string,\n  remoteId?: string, // Only remote projects have a remote id\n} & BaseModel;\n\n// Workspace\nexport type Workspace = {\n  name: string;\n  description: string;\n  certificates?: any; // deprecate\n  scope: 'design' | 'collection',\n} & BaseModel;\n\n// WorkspaceMeta", "export type WorkspaceMeta = {\n  activeActivity: string | null;\n  activeEnvironmentId: string | null;\n  activeRequestId: string | null;\n  activeUnitTestSuiteId: string | null;\n  cachedGitLastAuthor: string | null;\n  cachedGitLastCommitTime: number | null;\n  cachedGitRepositoryBranch: string | null;\n  gitRepositoryId: string | null;\n  hasSeen: boolean;\n  paneHeight: number;\n  paneWidth: number;\n  parentId: string | null;\n  sidebarFilter: string;\n  sidebarHidden: boolean;\n  sidebarWidth: number;\n  pushSnapshotOnInitialize: boolean;\n} & BaseModel;\n\n// Request", "export type BaseRequest = {\n    url: string;\n  name: string;\n  description: string;\n  method: string;\n  body: RequestBody;\n  parameters: RequestParameter[];\n  headers: RequestHeader[];\n  authentication: Record<string, string>; // This should be RequestAuthentication but is not used in the project\n  metaSortKey: number;\n  isPrivate: boolean;\n  // Settings\n  settingStoreCookies: boolean;\n  settingSendCookies: boolean;\n  settingDisableRenderRequestBody: boolean;\n  settingEncodeUrl: boolean;\n  settingRebuildPath: boolean;\n  settingFollowRedirects: 'global' | 'on' | 'off';\n} & BaseModel;\n", "export interface RequestHeader {\n  name: string;\n  value: string;\n  description?: string;\n  disabled?: boolean;\n}\nexport interface RequestParameter {\n  name: string;\n  value: string;\n  disabled?: boolean;\n  id?: string;\n  fileName?: string;\n}", "export interface RequestBodyParameter {\n  name: string;\n  value: string;\n  description?: string;\n  disabled?: boolean;\n  multiline?: string;\n  id?: string;\n  fileName?: string;\n  type?: string;\n}\nexport interface RequestBody {\n  mimeType?: string | null;\n  text?: string;\n  fileName?: string;\n  params?: RequestBodyParameter[];\n}\n\n// RequestMeta", "export interface RequestBody {\n  mimeType?: string | null;\n  text?: string;\n  fileName?: string;\n  params?: RequestBodyParameter[];\n}\n\n// RequestMeta\nexport type RequestMeta = {\n  parentId: string;\n  previewMode: 'friendly' | 'source' | 'raw'; // This is PreviewMode from ../common/constants\n  responseFilter: string;\n  responseFilterHistory: string[];\n  activeResponseId: string | null;\n  savedRequestBody: Record<string, any>;\n  pinned: boolean;\n  lastActive: number;\n  downloadPath: string | null;\n  expandedAccordionKeys: Partial<Record<'OAuth2AdvancedOptions', boolean>>;\n} & BaseModel;\n\n// RequestGroup", "export type RequestMeta = {\n  parentId: string;\n  previewMode: 'friendly' | 'source' | 'raw'; // This is PreviewMode from ../common/constants\n  responseFilter: string;\n  responseFilterHistory: string[];\n  activeResponseId: string | null;\n  savedRequestBody: Record<string, any>;\n  pinned: boolean;\n  lastActive: number;\n  downloadPath: string | null;\n  expandedAccordionKeys: Partial<Record<'OAuth2AdvancedOptions', boolean>>;\n} & BaseModel;\n\n// RequestGroup", "export type RequestGroup = {\n  name: string;\n  description: string;\n  environment: Record<string, any>;\n  environmentPropertyOrder: Record<string, any> | null;\n  metaSortKey: number;\n} & BaseModel;\n\n// RequestGroupMeta\nexport type RequestGroupMeta = {\n  collapsed: boolean,\n} & BaseModel;\n\n// ApiSpec", "export type RequestGroupMeta = {\n  collapsed: boolean,\n} & BaseModel;\n\n// ApiSpec\nexport type ApiSpec = {\n  fileName: string;\n  contentType: 'json' | 'yaml';\n  contents: string;\n} & BaseModel\n\n// Unittest Suite", "export type UnittestSuite = {\n  name: string,\n} & BaseModel\n\n// Unittest\nexport type UnitTest = {\n  name: string;\n  code: string;\n  requestId: string | null;\n} & BaseModel;\n"]}
{"filename": "src/autoExport.ts", "chunked_list": ["import fs from 'node:fs';\nimport { join } from 'path';\nimport InternalDb from './db/InternalDb';\nimport { getActiveProjectId } from './db/localStorageUtils';\nimport { exportProject } from './exportData';\nimport { importProject, readProjectData } from './importData';\nimport renderModal from './ui/react/renderModal';\nimport confirmModal from './ui/react/confirmModal';\n\nlet prevExport = '';\nexport default async function autoExport() {\n  const projectId = getActiveProjectId();", "\nlet prevExport = '';\nexport default async function autoExport() {\n  const projectId = getActiveProjectId();\n  if (!projectId) {\n    return;\n  }\n\n  const config = InternalDb.create();\n  const { repositoryPath: path, autoExport } = config.getProject(projectId);\n  if (!path || !autoExport || projectId === 'proj_default-project') {\n    return;\n  }\n\n  const [projectData, workspaces] = await exportProject(projectId);\n  const newExportJson = JSON.stringify([projectData, workspaces]);", "  if (!path || !autoExport || projectId === 'proj_default-project') {\n    return;\n  }\n\n  const [projectData, workspaces] = await exportProject(projectId);\n  const newExportJson = JSON.stringify([projectData, workspaces]);\n  if (newExportJson === prevExport) {\n    // Nothing to export, so lets try to Import\n    await autoImportProject(path);\n    return;\n  }\n\n  prevExport = newExportJson;\n  const targetFile = join(path, 'project.json');\n  fs.writeFileSync(targetFile, JSON.stringify(projectData, null, 2));\n", "  for (const workspace of workspaces) {\n    const targetFile = join(path, workspace.id + '.json');\n    fs.writeFileSync(targetFile, JSON.stringify(workspace, null, 2));\n  }\n}\n\nlet prevImport = '';\nasync function autoImportProject(path: string) {\n  let project, workspaceData;\n  try {\n    [project, workspaceData] = readProjectData(path);", "  try {\n    [project, workspaceData] = readProjectData(path);\n  } catch (e) {\n    console.error('[IPGI] Error while gathering import data during auto import. This might not be a bug', e);\n    return;\n  }\n  const newImportJson = JSON.stringify([project, workspaceData]);\n\n  // Do not import the first time\n  if (prevImport === '') {\n    prevImport = newImportJson;\n    return;\n  }\n", "  if (prevImport === '') {\n    prevImport = newImportJson;\n    return;\n  }\n\n  if (prevImport === newImportJson) {\n    // Nothing to import\n    return;\n  }\n\n  const doImport = await renderModal<boolean>(confirmModal(\n    'Import project',\n    'Import chhanged project data? Insomnia will restart.',\n  ));", "  if (!doImport) {\n    return;\n  }\n\n  await importProject(project, workspaceData);\n  // Force Insomnia to read all data\n  // @ts-ignore\n  window.main.restart();\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { BaseRequest, WorkspaceMeta, RequestGroup, RequestGroupMeta, RequestMeta, Workspace, Environment, BaseModel, UnittestSuite, UnitTest, ApiSpec } from './insomniaDbTypes';\n\nexport type GitSavedProject = {\n  name: string,\n  id: string,\n  remoteId: string | null,\n  workspaceIds: string[],\n}\n\nexport type GitSavedWorkspace = {\n  name: string,\n  id: string,\n  workspace: Workspace,\n  meta: GitSavedWorkspaceMeta,\n  requests: GitSavedRequest[],\n  environments: Environment[],\n  apiSpec?: ApiSpec,\n  unitTestSuites: GitSavedUnitTestSuite[],\n}\n", "export type GitSavedWorkspace = {\n  name: string,\n  id: string,\n  workspace: Workspace,\n  meta: GitSavedWorkspaceMeta,\n  requests: GitSavedRequest[],\n  environments: Environment[],\n  apiSpec?: ApiSpec,\n  unitTestSuites: GitSavedUnitTestSuite[],\n}\n", "export type GitSavedUnitTestSuite = {\n  testSuite: UnittestSuite,\n  tests: UnitTest[],\n}\n\nexport type GitSavedRequest = {\n  type: 'request',\n  id: string,\n  request: BaseRequest,\n  meta: RequestMeta,\n} | {\n  type: 'group',\n  id: string,\n  group: RequestGroup,\n  meta: RequestGroupMeta,\n  children: GitSavedRequest[],\n}\n", "export type GitSavedWorkspaceMeta = Pick<WorkspaceMeta, 'activeActivity' | 'activeEnvironmentId' | 'activeRequestId' | keyof BaseModel>\n"]}
{"filename": "src/OldIds.ts", "chunked_list": ["import { GitSavedRequest, GitSavedWorkspace } from './types';\n\nexport default class OldIds {\n  private constructor(\n    private environmentIds: string[],\n    private requestIds: string[],\n    private requestGroupIds: string[],\n    private testSuites: string[],\n    private tests: string[],\n  ) {}\n\n  public static createEmpty(): OldIds {\n    return new OldIds([], [], [], [], []);\n  }\n\n  public static fromOldData(data: GitSavedWorkspace): OldIds {\n    const environmentIds = data.environments.map((env) => env._id);\n\n    const requestIds = [];\n    const requestGroupIds = [];\n\n    OldIds.getIdsRecursive(data.requests, requestIds, requestGroupIds);\n\n    const tests = [];\n    const testSuites = data.unitTestSuites.map((testSuite) => {", "      for (const test of testSuite.tests) {\n        tests.push(test._id);\n      }\n\n      return testSuite.testSuite._id;\n    });\n\n    return new OldIds(environmentIds, requestIds, requestGroupIds, testSuites, tests);\n  }\n\n  private static getIdsRecursive(requests: GitSavedRequest[], requestIds: string[], requestGroupIds: string[]) {", "    for (const request of requests) {\n      if (request.type === 'group') {\n        requestGroupIds.push(request.id);\n        OldIds.getIdsRecursive(request.children, requestIds, requestGroupIds);\n        continue;\n      }\n\n      requestIds.push(request.id);\n    }\n  }\n\n  public getEnvironmentIds(): string[] {\n    return this.environmentIds;\n  }\n  public removeEnvironmentId(id: string): void {\n    const index = this.environmentIds.indexOf(id);", "    if (index !== -1) {\n      this.environmentIds.splice(index, 1);\n    }\n  }\n\n  public getRequestIds(): string[] {\n    return this.requestIds;\n  }\n  public removeRequestId(id: string): void {\n    const index = this.requestIds.indexOf(id);\n    if (index !== -1) {\n      this.requestIds.splice(index, 1);\n    }\n  }\n\n  public getRequestGroupId(): string[] {\n    return this.requestGroupIds;\n  }\n  public removeRequestGroupId(id: string): void {\n    const index = this.requestGroupIds.indexOf(id);", "    if (index !== -1) {\n      this.requestIds.splice(index, 1);\n    }\n  }\n\n  public getRequestGroupId(): string[] {\n    return this.requestGroupIds;\n  }\n  public removeRequestGroupId(id: string): void {\n    const index = this.requestGroupIds.indexOf(id);\n    if (index !== -1) {\n      this.requestGroupIds.splice(index, 1);\n    }\n  }\n\n  public getTestSuites(): string[] {\n    return this.testSuites;\n  }\n  public removeTestSuites(id: string): void {\n    const index = this.testSuites.indexOf(id);", "    if (index !== -1) {\n      this.requestGroupIds.splice(index, 1);\n    }\n  }\n\n  public getTestSuites(): string[] {\n    return this.testSuites;\n  }\n  public removeTestSuites(id: string): void {\n    const index = this.testSuites.indexOf(id);\n    if (index !== -1) {\n      this.testSuites.splice(index, 1);\n    }\n  }\n\n  public getTests(): string[] {\n    return this.tests;\n  }\n  public removeTest(id: string): void {\n    const index = this.tests.indexOf(id);", "    if (index !== -1) {\n      this.testSuites.splice(index, 1);\n    }\n  }\n\n  public getTests(): string[] {\n    return this.tests;\n  }\n  public removeTest(id: string): void {\n    const index = this.tests.indexOf(id);\n    if (index !== -1) {\n      this.tests.splice(index, 1);\n    }\n  }\n}\n", "    if (index !== -1) {\n      this.tests.splice(index, 1);\n    }\n  }\n}\n"]}
{"filename": "src/exportData.ts", "chunked_list": ["import BaseDb from './db/BaseDb';\nimport { BaseRequest, RequestMeta, RequestGroup, RequestGroupMeta, Workspace, WorkspaceMeta, Environment, Project, ApiSpec, UnittestSuite, UnitTest } from './insomniaDbTypes';\nimport { GitSavedProject, GitSavedRequest, GitSavedUnitTestSuite, GitSavedWorkspace, GitSavedWorkspaceMeta } from './types';\nimport { randomBytes } from 'crypto';\n\nfunction createDefaultFolderMeta(parentId: string): RequestGroupMeta {\n  return {\n    collapsed: true,\n    parentId,\n    created: Date.now(),\n    isPrivate: false,\n    modified: Date.now(),\n    type: 'RequestGroupMeta',\n    _id: 'fldm_' + randomBytes(16).toString('hex'),\n    name: '', // This is not used by insomnia.\n  };\n}\n", "function createDefaultRequestMeta(parentId: string): RequestMeta {\n  return {\n    parentId,\n    previewMode: \"friendly\", // PREVIEW_MODE_FRIENDLY\n    responseFilter: '',\n    responseFilterHistory: [],\n    activeResponseId: null,\n    savedRequestBody: {},\n    pinned: false,\n    lastActive: 0,\n    downloadPath: null,\n    expandedAccordionKeys: {},\n    created: Date.now(),\n    isPrivate: false,\n    modified: Date.now(),\n    type: 'RequestMeta',\n    _id: 'reqm_' + randomBytes(16).toString('hex'),\n    name: '', // This is not used by insomnia.\n  }\n}\n", "export async function exportProject(projectId: string): Promise<[GitSavedProject, GitSavedWorkspace[]]> {\n  // Load the Project\n  const projectDb = new BaseDb<Project>('Project');\n  const fullProject = await projectDb.findById(projectId);\n  if (!fullProject) {\n    throw new Error('Project not found with id ' + projectId);\n  }\n\n  const project: GitSavedProject = {\n    id: fullProject._id,\n    name: fullProject.name,\n    remoteId: fullProject.remoteId,\n    workspaceIds: [],\n  };\n\n  // Load all workspaces\n  const workspaceDb = new BaseDb<Workspace>('Workspace');\n  const workspaces = await workspaceDb.findBy('parentId', fullProject._id);\n\n  const savedWorkspaces: GitSavedWorkspace[] = [];", "  for (const workspace of workspaces) {\n    savedWorkspaces.push(await exportWorkspaceData(workspace._id));\n    project.workspaceIds.push(workspace._id);\n  }\n\n  return [project, savedWorkspaces];\n}\n\n// ParentId is either the WorkspaceId for TopLevel requests or an FolderId for nested requests\nasync function getRequestsForParentId(\n  parentId: string,\n  requestDb: BaseDb<BaseRequest>,\n  requestMetaDb: BaseDb<RequestMeta>,\n  requestGroupDb: BaseDb<RequestGroup>,\n  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n): Promise<GitSavedRequest[]> {\n  const gitSavedRequests: GitSavedRequest[] = [];\n\n  const requests = await requestDb.findBy('parentId', parentId);", "async function getRequestsForParentId(\n  parentId: string,\n  requestDb: BaseDb<BaseRequest>,\n  requestMetaDb: BaseDb<RequestMeta>,\n  requestGroupDb: BaseDb<RequestGroup>,\n  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n): Promise<GitSavedRequest[]> {\n  const gitSavedRequests: GitSavedRequest[] = [];\n\n  const requests = await requestDb.findBy('parentId', parentId);\n  for (const request of requests) {\n    const metas = await requestMetaDb.findBy('parentId', request._id);\n    // When duplicating a Workspace the Request meta is not automaticly created\n    // As a workaround we use the default object.\n    // See: https://github.com/Kong/insomnia/blob/develop/packages/insomnia/src/models/request-meta.ts#L32\n    const meta = metas[0] || createDefaultRequestMeta(request._id);\n\n    gitSavedRequests.push({\n      type: 'request',\n      id: request._id,\n      meta,\n      request,\n    });\n  }\n\n  const groups = await requestGroupDb.findBy('parentId', parentId);", "  for (const request of requests) {\n    const metas = await requestMetaDb.findBy('parentId', request._id);\n    // When duplicating a Workspace the Request meta is not automaticly created\n    // As a workaround we use the default object.\n    // See: https://github.com/Kong/insomnia/blob/develop/packages/insomnia/src/models/request-meta.ts#L32\n    const meta = metas[0] || createDefaultRequestMeta(request._id);\n\n    gitSavedRequests.push({\n      type: 'request',\n      id: request._id,\n      meta,\n      request,\n    });\n  }\n\n  const groups = await requestGroupDb.findBy('parentId', parentId);", "  for (const group of groups) {\n    const metas = await requestGroupMetaDb.findBy('parentId', group._id);\n    // Create default GroupMetadata when nothing was found. Not sure when this happens but should fix #3\n    const meta = metas[0] || createDefaultFolderMeta(group._id);\n\n    gitSavedRequests.push({\n      type: 'group',\n      id: group._id,\n      group,\n      children: await getRequestsForParentId(group._id, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb),\n      meta,\n    });\n  }\n\n  return gitSavedRequests;\n}\n", "async function getTestSuites(workspaceId: string): Promise<GitSavedUnitTestSuite[]> {\n  const savedUnittestSuites: GitSavedUnitTestSuite[] = [];\n\n  const unitTestSuitesDb = new BaseDb<UnittestSuite>('UnitTestSuite');\n  const unittestDb = new BaseDb<UnitTest>('UnitTest');\n\n  const unitTestSuites = await unitTestSuitesDb.findBy('parentId', workspaceId);\n\n  for (const testSuite of unitTestSuites) {\n    const tests = await unittestDb.findBy('parentId', testSuite._id);\n\n    savedUnittestSuites.push({\n      tests,\n      testSuite,\n    });\n  }\n\n  return savedUnittestSuites;\n}\n", "  for (const testSuite of unitTestSuites) {\n    const tests = await unittestDb.findBy('parentId', testSuite._id);\n\n    savedUnittestSuites.push({\n      tests,\n      testSuite,\n    });\n  }\n\n  return savedUnittestSuites;\n}\n", "async function getApiSpec(workspaceId: string): Promise<ApiSpec | null> {\n  const apiSpecDb = new BaseDb<ApiSpec>('ApiSpec');\n\n  const apiSpecs = await apiSpecDb.findBy('parentId', workspaceId);\n\n  return apiSpecs[0] ?? null;\n}\n\nexport async function exportWorkspaceData(workspaceId: string): Promise<GitSavedWorkspace> {\n  // Find workspace\n  const workspaceDb = new BaseDb<Workspace>('Workspace');\n  const workspace = await workspaceDb.findById(workspaceId);", "export async function exportWorkspaceData(workspaceId: string): Promise<GitSavedWorkspace> {\n  // Find workspace\n  const workspaceDb = new BaseDb<Workspace>('Workspace');\n  const workspace = await workspaceDb.findById(workspaceId);\n  if (!workspace) {\n    throw new Error('No Workspace found for id: ' + workspaceId);\n  }\n  const name = workspace.name;\n\n  // Find WorkspaceMeta\n  const workspaceMetaDb = new BaseDb<WorkspaceMeta>('WorkspaceMeta');\n\n  const fullMetas = await workspaceMetaDb.findBy('parentId', workspaceId);\n  const fullMeta = fullMetas[0];\n\n  const meta: GitSavedWorkspaceMeta = {\n    _id: fullMeta._id,\n    created: fullMeta.created,\n    isPrivate: fullMeta.isPrivate,\n    modified: fullMeta.modified,\n    name: fullMeta.name,\n    parentId: fullMeta.parentId,\n    type: fullMeta.type,\n\n    activeActivity: fullMeta.activeActivity,\n    activeEnvironmentId: fullMeta.activeEnvironmentId,\n    activeRequestId: fullMeta.activeRequestId,\n  };\n\n  const requestDb = new BaseDb<BaseRequest>('Request');\n  const requestMetaDb = new BaseDb<RequestMeta>('RequestMeta');\n\n  const requestGroupDb = new BaseDb<RequestGroup>('RequestGroup');\n  const requestGroupMetaDb = new BaseDb<RequestGroupMeta>('RequestGroupMeta');\n\n  const requests = await getRequestsForParentId(workspaceId, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n\n  // Find environments\n  const environmentDb = new BaseDb<Environment>('Environment');\n  const baseEnvironments = await environmentDb.findBy('parentId', workspaceId);", "  if (baseEnvironments.length === 0) {\n    throw new Error('No BaseEnvironment found for parentId: ' + workspaceId);\n  }\n  const baseEnvironment = baseEnvironments[0];\n\n  // Get all SubEnv -> Filter out private ones -> Add the BaseEnv to the Top\n  const environments = (await environmentDb.findBy('parentId', baseEnvironment._id))\n    .filter((env) => env.isPrivate === false);\n  environments.unshift(baseEnvironment);\n\n  const apiSpec = await getApiSpec(workspaceId);\n  const unitTestSuites = await getTestSuites(workspaceId);\n\n  return {\n    id: workspaceId,\n    name,\n    workspace,\n    meta,\n    requests,\n    environments,\n    apiSpec,\n    unitTestSuites,\n  };\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { exportProject, exportWorkspaceData } from './exportData';\nimport fs from 'node:fs';\nimport { importWorkspaceData } from './importData';\nimport InternalDb from './db/InternalDb';\nimport { getActiveProjectId, getActiveWorkspace } from './db/localStorageUtils';\nimport { join } from 'node:path';\nimport importNewProjectButton from './ui/importNewProjectButton';\nimport projectDropdown from './ui/projectDropdown';\nimport alertModal from './ui/react/alertModal';\nimport renderModal from './ui/react/renderModal';", "import alertModal from './ui/react/alertModal';\nimport renderModal from './ui/react/renderModal';\nimport injectStyles from './ui/injectStyles';\nimport autoExport from './autoExport';\n\n// Inject UI elements.\n// @ts-ignore\nconst currentVersion = (window.gitIntegrationInjectCounter || 0) + 1;\n// @ts-ignore\nwindow.gitIntegrationInjectCounter = currentVersion;", "// @ts-ignore\nwindow.gitIntegrationInjectCounter = currentVersion;\n\nfunction doInject() {\n  // @ts-ignore\n  // Check if the window was reloaded. When it was reloaded the Global counter changed\n  if (window.gitIntegrationInjectCounter !== currentVersion) {\n    return;\n  }\n\n  injectStyles();\n  projectDropdown();\n  importNewProjectButton();\n\n  window.requestAnimationFrame(doInject);\n}\nwindow.requestAnimationFrame(doInject);\n\nsetInterval(autoExport, 5000);\n\nmodule.exports.workspaceActions = [\n  {\n    label: 'Export workspace to Git',\n    icon: 'download',\n    action: async () => {\n      const projectId = getActiveProjectId();\n      const workspaceId = getActiveWorkspace();\n\n      const config = InternalDb.create();\n      const path = config.getProjectPath(projectId);", "      if (!path || projectId === 'proj_default-project') {\n        await renderModal(alertModal(\n          'Cannot export workspace',\n          'You must first configure the project folder before exporting',\n        ));\n        return;\n      }\n\n      const data = await exportWorkspaceData(workspaceId);\n      const targetFile = join(path, workspaceId + '.json');\n      fs.writeFileSync(targetFile, JSON.stringify(data, null, 2));\n    },\n  },\n  {\n    label: 'Import workspace from Git',\n    icon: 'upload',\n    action: async () => {\n      const projectId = getActiveProjectId();\n      const workspaceId = getActiveWorkspace();\n\n      const config = InternalDb.create();\n      const path = config.getProjectPath(projectId);", "      if (!path || projectId === 'proj_default-project') {\n        await renderModal(alertModal(\n          'Cannot import workspace',\n          'You must first configure the project folder before importing',\n        ));\n        return;\n      }\n\n      const targetFile = join(path, workspaceId + '.json');\n      const dataRaw = JSON.parse(fs.readFileSync(targetFile).toString());\n      await importWorkspaceData(dataRaw);\n      // Force Insomnia to read all data\n      // @ts-ignore\n      window.main.restart();\n    },\n  },\n];\n"]}
{"filename": "src/insomniaTypes.ts", "chunked_list": ["/* eslint @typescript-eslint/no-unused-vars: 0 */\nimport { Readable } from 'node:stream';\n\n/** context.request: https://docs.insomnia.rest/insomnia/context-object-reference#contextrequest */\ninterface RequestContext {\n  getId(): string;\n  getName(): string;\n  getUrl(): string;\n  setUrl(url: string): void;\n  getMethod(): string;\n  setMethod(method: string): void;\n  getHeaders(): Array<{ name: string, value: string }>;\n  getHeader(name: string): string | null;\n  hasHeader(name: string): boolean;\n  removeHeader(name: string): void;\n  setHeader(name: string, value: string): void;\n  addHeader(name: string, value: string): void;\n  getParameter(name: string): string | null;\n  getParameters(): Array<{ name: string, value: string }>;\n  setParameter(name: string, value: string): void;\n  hasParameter(name: string): boolean;\n  addParameter(name: string, value: string): void;\n  removeParameter(name: string): void;\n  getBody(): RequestBody;\n  setBody(body: RequestBody): void;\n  getEnvironmentVariable(name: string): unknown;\n  getEnvironment(): object;\n  setAuthenticationParameter(name: string, value: string): void;\n  getAuthentication(): object;\n  setCookie(name: string, value: string): void;\n  settingSendCookies(enabled: boolean): void;\n  settingStoreCookies(enabled: boolean): void;\n  settingEncodeUrl(enabled: boolean): void;\n  settingDisableRenderRequestBody(enabled: boolean): void;\n  settingFollowRedirects(enabled: boolean): void;\n}\n", "interface RequestBody {\n  mimeType?: string;\n  text?: string;\n  fileName?: string;\n  params?: RequestBodyParameter[];\n}\n\ninterface RequestBodyParameter {\n  name: string;\n  value: string;\n  description?: string;\n  disabled?: boolean;\n  multiline?: string;\n  id?: string;\n  fileName?: string;\n  type?: string;\n}\n\n/** context.response: https://docs.insomnia.rest/insomnia/context-object-reference#contextresponse */", "interface ResponseContext {\n  getRequestId(): string;\n  getStatusCode(): number;\n  getStatusMessage(): string;\n  getBytesRead(): number;\n  getTime(): number;\n  getBody(): Buffer | null;\n  getBodyStream(): Readable;\n  setBody(body: Buffer);\n  getHeader(name: string): string | Array<string> | null;\n  getHeaders(): Array<{ name: string, value: string }> | undefined;\n  hasHeader(name: string): boolean,\n}\n\n/** context.store: https://docs.insomnia.rest/insomnia/context-object-reference#contextstore */", "interface StoreContext {\n  hasItem(key: string): Promise<boolean>;\n  setItem(key: string, value: string): Promise<void>;\n  getItem(key: string): Promise<string | null>;\n  removeItem(key: string): Promise<void>;\n  clear(): Promise<void>;\n  all(): Promise<Array<{ key: string, value: string }>>;\n}\n\n/** context.app: https://docs.insomnia.rest/insomnia/context-object-reference#contextapp */\ninterface AppContext {\n  getInfo(): { version: string, platform: string };\n  alert(title: string, message?: string): Promise<void>;\n\n  dialog(title: string, body: HTMLElement, options?: {\n    onHide?: () => void;\n    tall?: boolean;\n    skinny?: boolean;\n    wide?: boolean;\n  }): void;\n\n  prompt(title: string, options?: {\n    label?: string;\n    defaultValue?: string;\n    submitName?: string;\n    cancelable?: boolean;\n  }): Promise<string>;\n\n  getPath(name: string): string;\n\n  showSaveDialog(options?: {\n    defaultPath?: string;\n  }): Promise<string | null>;\n\n  clipboard: {\n    readText(): string;\n    writeText(text: string): void;\n    clear(): void;\n  };\n}\n\n/** context.data https://docs.insomnia.rest/insomnia/context-object-reference#contextdata */", "interface AppContext {\n  getInfo(): { version: string, platform: string };\n  alert(title: string, message?: string): Promise<void>;\n\n  dialog(title: string, body: HTMLElement, options?: {\n    onHide?: () => void;\n    tall?: boolean;\n    skinny?: boolean;\n    wide?: boolean;\n  }): void;\n\n  prompt(title: string, options?: {\n    label?: string;\n    defaultValue?: string;\n    submitName?: string;\n    cancelable?: boolean;\n  }): Promise<string>;\n\n  getPath(name: string): string;\n\n  showSaveDialog(options?: {\n    defaultPath?: string;\n  }): Promise<string | null>;\n\n  clipboard: {\n    readText(): string;\n    writeText(text: string): void;\n    clear(): void;\n  };\n}\n\n/** context.data https://docs.insomnia.rest/insomnia/context-object-reference#contextdata */", "interface ImportOptions {\n    workspaceId?: string;\n    workspaceScope?: 'design' | 'collection';\n}\n\ninterface DataContext {\n    import: {\n        uri(uri: string, options?: ImportOptions): Promise<void>;\n        raw(text: string, options?: ImportOptions): Promise<void>;\n    },\n    export: {\n        insomnia(options?: { \n            includePrivate?: boolean,\n            format?: 'json' | 'yaml',\n        }): Promise<string>;\n        har(options?: { includePrivate?: boolean }): Promise<string>;\n    }\n}\n\n/** context.network https://docs.insomnia.rest/insomnia/context-object-reference#contextnetwork */", "interface NetworkContext {\n    sendRequest(request: Request): Promise<Response>;\n}\n"]}
{"filename": "src/importData.ts", "chunked_list": ["import { join } from 'node:path';\nimport fs from 'node:fs';\nimport BaseDb from './db/BaseDb';\nimport { exportWorkspaceData } from './exportData';\nimport { Workspace, WorkspaceMeta, BaseRequest, RequestMeta, RequestGroup, RequestGroupMeta, Environment, Project, ApiSpec, UnittestSuite, UnitTest } from './insomniaDbTypes';\nimport OldIds from './OldIds';\nimport { GitSavedRequest, GitSavedWorkspace, GitSavedProject } from './types';\n\nexport function readProjectData(path: string): [GitSavedProject, GitSavedWorkspace[]] {\n  // Read the Project file\n  const projectFile = join(path, 'project.json');\n  // TODO: Validate this using Zod\n  const project: GitSavedProject = JSON.parse(fs.readFileSync(projectFile).toString());\n\n  // Read all the workspace data\n  const workspaceData: GitSavedWorkspace[] = [];", "export function readProjectData(path: string): [GitSavedProject, GitSavedWorkspace[]] {\n  // Read the Project file\n  const projectFile = join(path, 'project.json');\n  // TODO: Validate this using Zod\n  const project: GitSavedProject = JSON.parse(fs.readFileSync(projectFile).toString());\n\n  // Read all the workspace data\n  const workspaceData: GitSavedWorkspace[] = [];\n  for (const workspaceId of project.workspaceIds) {\n    const workspaceFile = join(path, workspaceId + '.json');\n    // TODO: Validate this using Zod\n    const workspace: GitSavedWorkspace = JSON.parse(fs.readFileSync(workspaceFile).toString());\n    workspaceData.push(workspace);\n  }\n\n  return [project, workspaceData];\n}\n", "  for (const workspaceId of project.workspaceIds) {\n    const workspaceFile = join(path, workspaceId + '.json');\n    // TODO: Validate this using Zod\n    const workspace: GitSavedWorkspace = JSON.parse(fs.readFileSync(workspaceFile).toString());\n    workspaceData.push(workspace);\n  }\n\n  return [project, workspaceData];\n}\n\nexport async function importProject(project: GitSavedProject, workspaces: GitSavedWorkspace[]) {\n  // Upsert the Project\n  const projectDb = new BaseDb<Project>('Project');\n  await projectDb.upsert({\n    _id: project.id,\n    name: project.name,\n    remoteId: project.remoteId,\n    created: Date.now(),\n    isPrivate: false,\n    modified: Date.now(),\n    parentId: null,\n    type: 'Project',\n  });\n\n  const workspaceDb = new BaseDb<Workspace>('Workspace');\n  const workspaceMetaDb = new BaseDb<Workspace>('WorkspaceMeta');\n  let oldWorkspaces = (await workspaceDb.findBy('parentId', project.id)).map((ws) => ws._id);\n\n  // Update all Workspaces", "export async function importProject(project: GitSavedProject, workspaces: GitSavedWorkspace[]) {\n  // Upsert the Project\n  const projectDb = new BaseDb<Project>('Project');\n  await projectDb.upsert({\n    _id: project.id,\n    name: project.name,\n    remoteId: project.remoteId,\n    created: Date.now(),\n    isPrivate: false,\n    modified: Date.now(),\n    parentId: null,\n    type: 'Project',\n  });\n\n  const workspaceDb = new BaseDb<Workspace>('Workspace');\n  const workspaceMetaDb = new BaseDb<Workspace>('WorkspaceMeta');\n  let oldWorkspaces = (await workspaceDb.findBy('parentId', project.id)).map((ws) => ws._id);\n\n  // Update all Workspaces", "  for (const workspace of workspaces) {\n    oldWorkspaces = oldWorkspaces.filter((oldWs) => oldWs !== workspace.id);\n\n    await importWorkspaceData(workspace);\n  }\n\n  // Delete old workspaces\n  for (const oldWorkspace of oldWorkspaces) {\n    await workspaceDb.deleteBy('_id', oldWorkspace);\n    await workspaceMetaDb.deleteBy('parentId', oldWorkspace);\n  }\n}\n", "async function upsertRequestsRecursive(\n  requests: GitSavedRequest[],\n  oldIds: OldIds,\n  requestDb: BaseDb<BaseRequest>,\n  requestMetaDb: BaseDb<RequestMeta>,\n  requestGroupDb: BaseDb<RequestGroup>,\n  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n) {\n  for (const request of requests) {\n    if (request.type === 'group') {\n      await requestGroupDb.upsert(request.group);\n      await requestGroupMetaDb.upsert(request.meta);\n\n      oldIds.removeRequestGroupId(request.id);\n\n      await upsertRequestsRecursive(request.children, oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n      continue;\n    }\n\n    await requestDb.upsert(request.request);\n    await requestMetaDb.upsert(request.meta);\n\n    oldIds.removeRequestId(request.id);\n  }\n}\n", "  for (const request of requests) {\n    if (request.type === 'group') {\n      await requestGroupDb.upsert(request.group);\n      await requestGroupMetaDb.upsert(request.meta);\n\n      oldIds.removeRequestGroupId(request.id);\n\n      await upsertRequestsRecursive(request.children, oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n      continue;\n    }\n\n    await requestDb.upsert(request.request);\n    await requestMetaDb.upsert(request.meta);\n\n    oldIds.removeRequestId(request.id);\n  }\n}\n", "async function removeOldData(\n  oldIds: OldIds,\n  requestDb: BaseDb<BaseRequest>,\n  requestMetaDb: BaseDb<RequestMeta>,\n  requestGroupDb: BaseDb<RequestGroup>,\n  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n  environmentDb: BaseDb<Environment>,\n  testSuitesDb: BaseDb<UnittestSuite>,\n  testDb: BaseDb<UnitTest>,\n) {\n  for (const envId of oldIds.getEnvironmentIds()) {\n    await environmentDb.deleteBy('_id', envId);\n  }\n", "  for (const envId of oldIds.getEnvironmentIds()) {\n    await environmentDb.deleteBy('_id', envId);\n  }\n\n  for (const requestId of oldIds.getRequestIds()) {\n    await requestDb.deleteBy('_id', requestId);\n    await requestMetaDb.deleteBy('parentId', requestId);\n  }\n\n  for (const requestGroupId of oldIds.getRequestGroupId()) {\n    await requestGroupDb.deleteBy('_id', requestGroupId);\n    await requestGroupMetaDb.deleteBy('parentId', requestGroupId);\n  }\n", "  for (const requestGroupId of oldIds.getRequestGroupId()) {\n    await requestGroupDb.deleteBy('_id', requestGroupId);\n    await requestGroupMetaDb.deleteBy('parentId', requestGroupId);\n  }\n\n  for (const testSuites of oldIds.getTestSuites()) {\n    await testSuitesDb.deleteBy('_id', testSuites);\n  }\n\n  for (const test of oldIds.getTests()) {\n    await testDb.deleteBy('_id', test);\n  }\n}\n", "  for (const test of oldIds.getTests()) {\n    await testDb.deleteBy('_id', test);\n  }\n}\n\nexport async function importWorkspaceData(data: GitSavedWorkspace): Promise<void> {\n  const workspaceDb = new BaseDb<Workspace>('Workspace');\n\n  // Collect OldIds of Requests / Folders so we can delete deleted Docs at the end\n  const oldIds = await workspaceDb.findById(data.id)\n    ? OldIds.fromOldData(await exportWorkspaceData(data.id))\n    : OldIds.createEmpty();\n\n  // Update Workspace metadata\n  await workspaceDb.upsert(data.workspace);\n\n  const workspaceMetaDb = new BaseDb<WorkspaceMeta>('WorkspaceMeta');\n  const fullMeta: WorkspaceMeta = {\n    ...data.meta,\n    // These are the Default value from 'models/workspace-meta::init()'. TODO: Load the old WorkspaceMetadata here\n    activeUnitTestSuiteId: null,\n    cachedGitLastAuthor: null,\n    cachedGitLastCommitTime: null,\n    cachedGitRepositoryBranch: null,\n    gitRepositoryId: null,\n    hasSeen: true,\n    paneHeight: 0.5,\n    paneWidth: 0.5,\n    parentId: data.id,\n    sidebarFilter: '',\n    sidebarHidden: false,\n    sidebarWidth: 19,\n    pushSnapshotOnInitialize: false,\n  };\n  await workspaceMetaDb.upsert(fullMeta);\n\n  const requestDb = new BaseDb<BaseRequest>('Request');\n  const requestMetaDb = new BaseDb<RequestMeta>('RequestMeta');\n\n  const requestGroupDb = new BaseDb<RequestGroup>('RequestGroup');\n  const requestGroupMetaDb = new BaseDb<RequestGroupMeta>('RequestGroupMeta');\n\n  await upsertRequestsRecursive(data.requests, oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n\n  const environmentDb = new BaseDb<Environment>('Environment');", "  for (const environment of data.environments) {\n    await environmentDb.upsert(environment);\n\n    oldIds.removeEnvironmentId(environment._id);\n  }\n\n  if (data.apiSpec) {\n    const apiSpecDb = new BaseDb<ApiSpec>('ApiSpec');\n    await apiSpecDb.upsert(data.apiSpec);\n  }\n\n  const unitTestSuitesDb = new BaseDb<UnittestSuite>('UnitTestSuite');\n  const unitTestDb = new BaseDb<UnitTest>('UnitTest');\n", "  for (const testSuite of data.unitTestSuites) {\n    await unitTestSuitesDb.upsert(testSuite.testSuite);\n    oldIds.removeTestSuites(testSuite.testSuite._id);\n\n    for (const test of testSuite.tests) {\n      await unitTestDb.upsert(test);\n      oldIds.removeTest(test._id);\n    }\n  }\n\n  await removeOldData(\n    oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb, environmentDb, unitTestSuitesDb, unitTestDb,\n  );\n}\n"]}
{"filename": "src/db/localStorageUtils.ts", "chunked_list": ["export function getActiveProjectId(): string | null {\n  const projectId = localStorage.getItem('locationHistoryEntry').split('/')[4];\n  return projectId || null;\n}\n\nexport function getActiveWorkspace(): string | null {\n  const projectId = localStorage.getItem('locationHistoryEntry').split('/')[6];\n  return projectId || null;\n}\n"]}
{"filename": "src/db/BaseDb.ts", "chunked_list": ["import Nedb from 'nedb';\nimport fsPath from 'node:path';\nimport { BaseModel } from '../insomniaDbTypes';\n\ntype DbTargets = 'Request' | 'RequestMeta' | 'RequestGroup' | 'RequestGroupMeta' | 'Workspace' | 'WorkspaceMeta' | 'Project' | 'Environment' | 'ApiSpec' | 'UnitTest' | 'UnitTestSuite';\n\nexport default class BaseDb<T extends BaseModel> {\n  private neDb: Nedb;\n\n  constructor(target: DbTargets) {\n    // @ts-ignore\n    const filename = fsPath.join(window.app.getPath('userData'), `insomnia.${target}.db`);\n\n    this.neDb = new Nedb({\n      autoload: true,\n      filename,\n      corruptAlertThreshold: 0.9,\n      inMemoryOnly: false,\n    });\n  }\n\n  public create(doc: T) {\n    this.neDb.insert(doc);\n  }\n\n  public update(doc: T) {\n    this.neDb.update(\n      { _id: doc._id },\n      doc,\n    );\n  }\n\n  public async upsert(doc: T) {", "    if (!await this.findById(doc._id)) {\n      this.create(doc);\n      return;\n    }\n    this.update(doc);\n  }\n\n  public async findById(id: string): Promise<T | null> {\n    return new Promise((resolve, reject) => {\n      this.neDb.findOne({ _id: id }, (err, doc) => {\n        if (err) {\n          reject(err);\n        }\n\n        resolve(doc);\n      });\n    });\n  }\n\n  public async findBy(field: keyof T, query: string): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n      this.neDb.find({ [field]: query }, (err, docs) => {", "        if (err) {\n          reject(err);\n        }\n\n        resolve(doc);\n      });\n    });\n  }\n\n  public async findBy(field: keyof T, query: string): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n      this.neDb.find({ [field]: query }, (err, docs) => {", "        if (err) {\n          reject(err);\n        }\n\n        resolve(docs);\n      });\n    });\n  }\n\n  public async findAll(): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n      this.neDb.find({}, (err, docs) => {", "        if (err) {\n          reject(err);\n        }\n\n        resolve(docs);\n      });\n    });\n  }\n\n  public deleteBy(field: keyof T, query: string): void {\n    this.neDb.remove({ [field]: query });\n  }\n}\n"]}
{"filename": "src/db/InternalDb.ts", "chunked_list": ["import fsPath from 'node:path';\nimport fs from 'node:fs';\n\nexport type ProjectConfig = {\n  id: string,\n  repositoryPath: string | null,\n  remote: string | null,\n  autoExport?: boolean\n  // TODO: For later, enable Sync using GitHub / GitLab OAuth-Apis (#1)\n}\n", "type InternalConfig = {\n  projects: ProjectConfig[],\n};\n\nexport default class InternalDb {\n  private config: InternalConfig;\n\n  private constructor() {\n    // @ts-ignore\n    const filename = fsPath.join(window.app.getPath('userData'), 'insomnia.plugin.git-integration.json');\n", "    if (!fs.existsSync(filename)) {\n      fs.writeFileSync(filename, '');\n    }\n\n    // TODO: Validate this with ZOD\n    const rawConfig = fs.readFileSync(filename).toString();\n    if (!rawConfig || rawConfig.trim().length === 0) {\n      this.config = { projects: [] };\n      return;\n    }\n    this.config = JSON.parse(rawConfig.toString());\n  }\n\n  private save() {\n    // @ts-ignore\n    const filename = fsPath.join(window.app.getPath('userData'), 'insomnia.plugin.git-integration.json');\n\n    fs.writeFileSync(filename, JSON.stringify(this.config, null, 2));\n  }\n\n  private static db: InternalDb;\n", "  // This class is a singleton\n  public static create(): InternalDb {\n    if (!InternalDb.db) {\n      InternalDb.db = new InternalDb();\n    }\n\n    return InternalDb.db;\n  }\n\n  public isProjectConfigured(projectId: string): boolean {\n    return this.config.projects.find((project) => project.id === projectId) !== undefined;\n  }\n\n  public getProjectPath(projectId: string): string | null {\n    return this.getProject(projectId).repositoryPath;\n  }\n\n  public getProject(projectId: string): ProjectConfig {\n    const index = this.config.projects.findIndex((p) => p.id === projectId);", "    if (index === -1) {\n      return {\n        id: projectId,\n        remote: null,\n        repositoryPath: null,\n        autoExport: false,\n      };\n    }\n\n    return this.config.projects[index];\n  }\n\n  public upsertProject(project: ProjectConfig) {\n    const existingIndex = this.config.projects.findIndex((p) => p.id === project.id);", "    if (existingIndex !== -1) {\n      this.config.projects[existingIndex] = project;\n      this.save();\n      return;\n    }\n\n    this.config.projects.push(project);\n    this.save();\n  }\n}\n"]}
{"filename": "src/ui/injectStyles.ts", "chunked_list": ["import fs from 'node:fs';\nimport path from 'node:path';\n\nexport default function injectStyles() {\n  const head = document.querySelector('head');\n  const existing = document.querySelector('#git-integration-styles');\n  if (!head || existing) {\n    return;\n  }\n\n  const styleTag = document.createElement('style');\n  styleTag.id = 'git-integration-styles';\n  styleTag.innerHTML = fs.readFileSync(path.join(__dirname, 'style.css')).toString();\n  head.appendChild(styleTag);\n}\n"]}
{"filename": "src/ui/importNewProjectButton.ts", "chunked_list": ["import { join } from 'node:path';\nimport InternalDb from '../db/InternalDb';\nimport { importProject } from '../importData';\nimport { GitSavedProject, GitSavedWorkspace } from '../types';\nimport fs from 'node:fs';\nimport alertModal from './react/alertModal';\nimport renderModal from './react/renderModal';\n\nexport default function importNewProjectButton() {\n  const createProjectBtn = document.querySelector('i[data-testid=\"CreateProjectButton\"]');\n  if (!createProjectBtn) {\n    return;\n  }\n\n  const existing = document.getElementById('git-integration-import-project');", "export default function importNewProjectButton() {\n  const createProjectBtn = document.querySelector('i[data-testid=\"CreateProjectButton\"]');\n  if (!createProjectBtn) {\n    return;\n  }\n\n  const existing = document.getElementById('git-integration-import-project');\n  if (existing) {\n    return;\n  }\n\n  const wrapper = createProjectBtn.parentElement?.parentElement;", "  if (!wrapper) {\n    return;\n  }\n\n  const importProjectBtn = document.createElement('button');\n  importProjectBtn.id = 'git-integration-import-project';\n  importProjectBtn.role = 'button';\n  importProjectBtn.className = 'ipgi-import-btn';\n  importProjectBtn.innerHTML = '<i class=\"fa fa-git\"></i>';\n\n  importProjectBtn.addEventListener('click', async () => {\n    // @ts-ignore\n    const openResult = await window.dialog.showOpenDialog({ properties: ['openDirectory'] });", "    if (openResult.canceled || openResult.filePaths.lenght === 0) {\n      return;\n    }\n    const targetDir = openResult.filePaths[0];\n    const projectFile = join(targetDir, 'project.json');\n    if (!fs.existsSync(projectFile)) {\n      await renderModal(alertModal(\n        'Invalid folder',\n        'This folder does not contain files to import (e.g. \"project.json\", \"wrk_*.json\")',\n      ));\n      return;\n    }\n\n    // TODO: Validate this using Zod\n    const project: GitSavedProject = JSON.parse(fs.readFileSync(projectFile).toString());\n\n    const configDb = InternalDb.create();\n    const projectConfig = configDb.getProject(project.id);\n\n    projectConfig.repositoryPath = openResult.filePaths[0];\n\n    configDb.upsertProject(projectConfig);\n\n    // Read all the workspace data\n    const workspaceData: GitSavedWorkspace[] = [];", "    for (const workspaceId of project.workspaceIds) {\n      const workspaceFile = join(targetDir, workspaceId + '.json');\n      // TODO: Validate this using Zod\n      const workspace: GitSavedWorkspace = JSON.parse(fs.readFileSync(workspaceFile).toString());\n      workspaceData.push(workspace);\n    }\n\n    await importProject(project, workspaceData);\n\n    // Force Insomnia to read all data again.\n    // Wrapped with requestIdleCallback to make sure NeDB had enough time to save everything\n    // @ts-ignore\n    window.requestIdleCallback(window.main.restart);\n  });\n\n  wrapper.appendChild(importProjectBtn);\n}\n"]}
{"filename": "src/ui/projectDropdown/gitPushButton.ts", "chunked_list": ["import { SimpleGit } from 'simple-git';\nimport alertModal from '../react/alertModal';\nimport renderModal from '../react/renderModal';\nimport { getActiveProjectId } from '../../db/localStorageUtils';\nimport InternalDb from '../../db/InternalDb';\n\nexport default function gitPushButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n  const gitPushButton = document.createElement('li');\n  gitPushButton.className = 'ipgi-dropdown-btn-wrapper';\n  gitPushButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-code-pull-request\">\n        </i>\n        Push\n      </div>\n    </div>\n  `;\n  gitPushButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n", "    try {\n      const branch = await gitClient.branchLocal();\n      const remotes = await gitClient.getRemotes();\n      if (!remotes[0]) {\n        await renderModal(alertModal('Unable to push', 'No remotes defined for git repository'));\n        return;\n      }\n\n      const projectId = getActiveProjectId();\n      if (!projectId) {\n        await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n        return;\n      }\n\n      const projectConfigDb = InternalDb.create();\n      const projectConfig = projectConfigDb.getProject(projectId);\n\n      const remote = projectConfig.remote ?? remotes[0].name;\n\n      const pushResult = await gitClient.push(remote, branch.current);\n\n      let message = `Pushed to ${remote}/${branch.current}.`;", "      if (!projectId) {\n        await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n        return;\n      }\n\n      const projectConfigDb = InternalDb.create();\n      const projectConfig = projectConfigDb.getProject(projectId);\n\n      const remote = projectConfig.remote ?? remotes[0].name;\n\n      const pushResult = await gitClient.push(remote, branch.current);\n\n      let message = `Pushed to ${remote}/${branch.current}.`;", "      if (pushResult.update) {\n        message += ` Remote is now at \"${pushResult.update.hash.to}\" (was at \"${pushResult.update.hash.from}\" before)`\n      }\n\n      await renderModal(alertModal('Pushed commits', message));\n    } catch (error) {\n      await renderModal(alertModal('Push failed', 'An error occurred while pushing commits', error));\n    }\n  });\n\n  // This makes the hover effect work\n  gitPushButton.addEventListener('mouseover', () => {\n    gitPushButton.className = 'sc-crXcEl UvQbr';\n  });\n  gitPushButton.addEventListener('mouseout', () => {\n    gitPushButton.className = 'sc-crXcEl dTKZde';\n  });\n\n  return gitPushButton;\n}\n"]}
{"filename": "src/ui/projectDropdown/gitCommitButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\nimport InternalDb from '../../db/InternalDb';\nimport fs from 'node:fs';\nimport { exportProject } from '../../exportData';\nimport { join } from 'node:path';\nimport { SimpleGit } from 'simple-git';\nimport renderModal from '../react/renderModal';\nimport alertModal from '../react/alertModal';\nimport gitCommitMessage from '../react/gitCommitMessage';\n\nexport default function gitCommitButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n  const gitCommitButton = document.createElement('li');\n  gitCommitButton.className = 'ipgi-dropdown-btn-wrapper';\n  gitCommitButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-check\">\n        </i>\n        Commit changes\n      </div>\n    </div>\n  `;\n  gitCommitButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n\n    const projectId = getActiveProjectId();", "import gitCommitMessage from '../react/gitCommitMessage';\n\nexport default function gitCommitButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n  const gitCommitButton = document.createElement('li');\n  gitCommitButton.className = 'ipgi-dropdown-btn-wrapper';\n  gitCommitButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-check\">\n        </i>\n        Commit changes\n      </div>\n    </div>\n  `;\n  gitCommitButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n\n    const projectId = getActiveProjectId();", "    if (!projectId) {\n      await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n      return;\n    }\n\n    const config = InternalDb.create();\n    const path = config.getProjectPath(projectId);\n    if (!path || projectId === 'proj_default-project') {\n      await renderModal(alertModal(\n        'Cannot export Project',\n        'You must first configure the project folder before exporting the project',\n      ));\n      return;\n    }\n\n    const [projectData, workspaces] = await exportProject(projectId);\n\n    const targetFile = join(path, 'project.json');\n    fs.writeFileSync(targetFile, JSON.stringify(projectData, null, 2));\n    await gitClient.add(targetFile);\n", "    for (const workspace of workspaces) {\n      const targetFile = join(path, workspace.id + '.json');\n      fs.writeFileSync(targetFile, JSON.stringify(workspace, null, 2));\n\n      await gitClient.add(targetFile);\n    }\n\n    const status = await gitClient.status();\n    if (status.staged.length === 0) {\n      await renderModal(alertModal('No changes', 'There are no changes to commited'));\n      return;\n    }\n\n    const commitMessage = await renderModal<string>(gitCommitMessage(path));", "    if (status.staged.length === 0) {\n      await renderModal(alertModal('No changes', 'There are no changes to commited'));\n      return;\n    }\n\n    const commitMessage = await renderModal<string>(gitCommitMessage(path));\n    if (!commitMessage) {\n      return;\n    }\n\n    try {\n      await gitClient.commit(commitMessage);", "    try {\n      await gitClient.commit(commitMessage);\n    } catch (error) {\n      await renderModal(alertModal('commit failed', 'An error occurred while fetching', error));\n    }\n  });\n\n  // This makes the hover effect work\n  gitCommitButton.addEventListener('mouseover', () => {\n    gitCommitButton.className = 'sc-crXcEl UvQbr';\n  });\n  gitCommitButton.addEventListener('mouseout', () => {\n    gitCommitButton.className = 'sc-crXcEl dTKZde';\n  });\n\n  return gitCommitButton;\n}\n"]}
{"filename": "src/ui/projectDropdown/gitFetchButton.ts", "chunked_list": ["import { SimpleGit } from 'simple-git';\nimport alertModal from '../react/alertModal';\nimport renderModal from '../react/renderModal';\n\nexport default function gitFetchButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n  const gitFetchButton = document.createElement('li');\n  gitFetchButton.className = 'ipgi-dropdown-btn-wrapper';\n  gitFetchButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-cloud-arrow-down\">\n        </i>\n        Fetch\n      </div>\n    </div>\n  `;\n  gitFetchButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n", "    try {\n      await gitClient.fetch();\n    } catch (error) {\n      await renderModal(alertModal('Fetch failed', 'An error occurred while fetching', error));\n    }\n  });\n\n  // This makes the hover effect work\n  gitFetchButton.addEventListener('mouseover', () => {\n    gitFetchButton.className = 'sc-crXcEl UvQbr';\n  });\n  gitFetchButton.addEventListener('mouseout', () => {\n    gitFetchButton.className = 'sc-crXcEl dTKZde';\n  });\n\n  return gitFetchButton;\n}\n"]}
{"filename": "src/ui/projectDropdown/defaultProjectInfo.ts", "chunked_list": ["export default function defaultProjectInfo(): HTMLElement {\n  const defaultProjectInfo = document.createElement('li');\n  defaultProjectInfo.className = 'ipgi-dropdown-btn-wrapper';\n  // Remove the Curser Pointer\n  defaultProjectInfo.style.cursor = 'unset';\n  defaultProjectInfo.innerHTML = `\n    <div class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        Git integration does not work<br /> with the default project\n      </div>\n    </div>\n  `;\n\n  return defaultProjectInfo;\n}\n"]}
{"filename": "src/ui/projectDropdown/gitPullButton.ts", "chunked_list": ["import { SimpleGit } from 'simple-git';\nimport renderModal from '../react/renderModal';\nimport alertModal from '../react/alertModal';\nimport InternalDb from '../../db/InternalDb';\nimport { getActiveProjectId } from '../../db/localStorageUtils';\n\nexport default function gitPullButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n  const gitPullButton = document.createElement('li');\n  gitPullButton.className = 'ipgi-dropdown-btn-wrapper';\n  gitPullButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-code-merge\">\n        </i>\n        Pull\n      </div>\n    </div>\n  `;\n  gitPullButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n", "    try {\n      const branch = await gitClient.branchLocal();\n      const remotes = await gitClient.getRemotes();\n      if (!remotes[0]) {\n        await renderModal(alertModal('Unable to pull', 'No remotes defined for git repository'));\n        return;\n      }\n\n      const projectId = getActiveProjectId();\n      if (!projectId) {\n        await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n        return;\n      }\n\n      const projectConfigDb = InternalDb.create();\n      const projectConfig = projectConfigDb.getProject(projectId);\n\n      const remote = projectConfig.remote ?? remotes[0].name;\n      const pullResult = await gitClient.pull(remote, branch.current);\n\n      await renderModal(alertModal(\n        'Pull succeded',\n        `Pulled ${pullResult.files.length} changed files from ${remotes[0].name}/${branch.current}. Use \"Import Project\" to update the insomnia project`,\n      ));", "      if (!projectId) {\n        await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n        return;\n      }\n\n      const projectConfigDb = InternalDb.create();\n      const projectConfig = projectConfigDb.getProject(projectId);\n\n      const remote = projectConfig.remote ?? remotes[0].name;\n      const pullResult = await gitClient.pull(remote, branch.current);\n\n      await renderModal(alertModal(\n        'Pull succeded',\n        `Pulled ${pullResult.files.length} changed files from ${remotes[0].name}/${branch.current}. Use \"Import Project\" to update the insomnia project`,\n      ));", "    } catch (error) {\n      await renderModal(alertModal('Pull failed', 'An error occurred while pulling new commits', error));\n    }\n  });\n\n  // This makes the hover effect work\n  gitPullButton.addEventListener('mouseover', () => {\n    gitPullButton.className = 'sc-crXcEl UvQbr';\n  });\n  gitPullButton.addEventListener('mouseout', () => {\n    gitPullButton.className = 'sc-crXcEl dTKZde';\n  });\n\n  return gitPullButton;\n}\n"]}
{"filename": "src/ui/projectDropdown/importProjectButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\nimport InternalDb from '../../db/InternalDb';\nimport { importProject, readProjectData } from '../../importData';\nimport alertModal from '../react/alertModal';\nimport renderModal from '../react/renderModal';\n\nexport default function importProjectButton(projectDropdown: Element): HTMLElement {\n  const importProjectButton = document.createElement('li');\n  importProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n  importProjectButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-download\">\n        </i>\n        Import Project\n      </div>\n    </div>\n  `;\n  importProjectButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n\n    const projectId = getActiveProjectId();", "    if (!projectId) {\n      await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n      return;\n    }\n\n    const config = InternalDb.create();\n    const path = config.getProjectPath(projectId);\n    if (!path || projectId === 'proj_default-project') {\n      await renderModal(alertModal(\n        'Cannot import Project',\n        'You must first configure the project folder before exporting the project',\n      ));\n      return;\n    }\n\n    const [project, workspaceData] = readProjectData(path);\n    await importProject(project, workspaceData);\n\n    // Force Insomnia to read all data again.\n    // Wrapped with requestIdleCallback to make sure NeDB had enough time to save everything\n    // @ts-ignore\n    window.requestIdleCallback(window.main.restart);\n  });\n\n  return importProjectButton;\n}\n"]}
{"filename": "src/ui/projectDropdown/exportProjectButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\nimport InternalDb from '../../db/InternalDb';\nimport fs from 'node:fs';\nimport { exportProject } from '../../exportData';\nimport { join } from 'node:path';\nimport renderModal from '../react/renderModal';\nimport alertModal from '../react/alertModal';\n\nexport default function exportProjectButton(projectDropdown: Element): HTMLElement {\n  const exportProjectButton = document.createElement('li');\n  exportProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n  exportProjectButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-upload\">\n        </i>\n        Export Project\n      </div>\n    </div>\n  `;\n  exportProjectButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n\n    const projectId = getActiveProjectId();", "export default function exportProjectButton(projectDropdown: Element): HTMLElement {\n  const exportProjectButton = document.createElement('li');\n  exportProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n  exportProjectButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-upload\">\n        </i>\n        Export Project\n      </div>\n    </div>\n  `;\n  exportProjectButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n\n    const projectId = getActiveProjectId();", "    if (!projectId) {\n      return;\n    }\n\n    const config = InternalDb.create();\n    const path = config.getProjectPath(projectId);\n    if (!path || projectId === 'proj_default-project') {\n      await renderModal(alertModal(\n        'Cannot export Project',\n        'You must first configure the project folder before exporting the project',\n      ));\n      return;\n    }\n\n    const [projectData, workspaces] = await exportProject(projectId);\n\n    const targetFile = join(path, 'project.json');\n    fs.writeFileSync(targetFile, JSON.stringify(projectData, null, 2));\n", "    for (const workspace of workspaces) {\n      const targetFile = join(path, workspace.id + '.json');\n      fs.writeFileSync(targetFile, JSON.stringify(workspace, null, 2));\n    }\n  });\n  \n  // This makes the hover effect work\n  exportProjectButton.addEventListener('mouseover', () => {\n    exportProjectButton.className = 'sc-crXcEl UvQbr';\n  });\n  exportProjectButton.addEventListener('mouseout', () => {\n    exportProjectButton.className = 'sc-crXcEl dTKZde';\n  });\n\n  return exportProjectButton;\n}\n"]}
{"filename": "src/ui/projectDropdown/index.ts", "chunked_list": ["import { simpleGit } from 'simple-git';\nimport InternalDb from '../../db/InternalDb';\nimport { getActiveProjectId } from '../../db/localStorageUtils';\nimport configureGitRepoButton from './configureGitRepoButton';\nimport exportProjectButton from './exportProjectButton';\nimport importProjectButton from './importProjectButton';\nimport gitCommitButton from './gitCommitButton';\nimport gitPushButton from './gitPushButton';\nimport gitPullButton from './gitPullButton';\nimport gitFetchButton from './gitFetchButton';", "import gitPullButton from './gitPullButton';\nimport gitFetchButton from './gitFetchButton';\nimport defaultProjectInfo from './defaultProjectInfo';\n\nexport default function projectDropdown() {\n  // Check if the dropdown is opened\n  const projectDropdown = document.querySelector('ul[aria-label=\"Create New Dropdown\"]');\n  if (projectDropdown === null) {\n    return;\n  }\n\n  // Check if we are already added the new options\n  const exising = document.getElementById('git-integration-project-dropdown');", "  if (exising) {\n    return;\n  }\n\n  // Create a wrapper element\n  const li = document.createElement('li');\n  li.id = 'git-integration-project-dropdown';\n  li.role = 'presentation';\n  projectDropdown.appendChild(li);\n\n  // Create a seperator for the buttoons\n  const seperatetor = document.createElement('div');\n  seperatetor.innerHTML = `\n    <span id=\"react-aria6002839293-469\" aria-hidden=\"true\" class=\"ipgi-dropdown-heading-text\">Git integration</span>\n    <hr role=\"separator\" class=\"ipgi-dropdown-heading-divider\">\n  `;\n  seperatetor.className = 'ipgi-dropdown-heading';\n  li.appendChild(seperatetor);\n\n  // Create a Button group\n  const buttonGroup = document.createElement('ul');\n  buttonGroup.role = 'group';\n  buttonGroup.ariaLabel = 'Git integration import';\n  buttonGroup.className = 'ipgi-dropdown-btn-group';\n  li.appendChild(buttonGroup);\n\n  const projectId = getActiveProjectId();\n  const config = InternalDb.create();\n  const path = config.getProjectPath(projectId);\n\n  // proj_default-project is the default 'Insomnia' project. We cant import / export that", "  if (projectId === 'proj_default-project') {\n    buttonGroup.appendChild(defaultProjectInfo());\n    return;\n  }\n  buttonGroup.appendChild(configureGitRepoButton(projectDropdown));\n\n  // Don't show export / import btns when path is not configured\n  if (!path) {\n    return;\n  }\n  buttonGroup.appendChild(exportProjectButton(projectDropdown));\n  buttonGroup.appendChild(importProjectButton(projectDropdown));\n\n  // Git buttons. Will only be added when \"git status\" succeeds\n  const gitClient = simpleGit(path);\n\n  gitClient.status().then(() => {\n    buttonGroup.appendChild(gitCommitButton(projectDropdown, gitClient));\n    buttonGroup.appendChild(gitPushButton(projectDropdown, gitClient));\n    buttonGroup.appendChild(gitFetchButton(projectDropdown, gitClient));\n    buttonGroup.appendChild(gitPullButton(projectDropdown, gitClient));", "  }).catch(() => {\n    // Error occurres when git is not inited. No need to handle that\n    return;\n  });\n}\n"]}
{"filename": "src/ui/projectDropdown/configureGitRepoButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\nimport alertModal from '../react/alertModal';\nimport renderModal from '../react/renderModal';\nimport configureProject from '../react/configureProject';\n\nexport default function configureGitRepoButton(projectDropdown: Element): HTMLElement {\n  const configureProjectButton = document.createElement('li');\n  configureProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n  configureProjectButton.innerHTML = `\n    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n      <div class=\"ipgi-dropdown-btn-text\">\n        <i class=\"ipgi-dropdown-btn-icon fa fa-cog\"></i>\n        Configure project\n      </div>\n    </div>\n  `;\n  configureProjectButton.addEventListener('click', async () => {\n    // \"Close\" the dropdown\n    projectDropdown.remove();\n\n    const projectId = getActiveProjectId();", "    if (projectId === 'proj_default-project' || !projectId) {\n      await renderModal(alertModal(\n        'Cannnot configure Folder',\n        'Cannot configure folder for default repository. Please create a now Project',\n      ));\n      return;\n    }\n\n    await renderModal(configureProject(projectId));\n  });\n\n  // Hover effect\n  configureProjectButton.addEventListener('mouseover', () => {\n    configureProjectButton.className = 'sc-crXcEl UvQbr';\n  });\n  configureProjectButton.addEventListener('mouseout', () => {\n    configureProjectButton.className = 'sc-crXcEl dTKZde';\n  });\n\n  return configureProjectButton;\n}\n"]}
{"filename": "src/ui/react/UnmountContext.ts", "chunked_list": ["import { createContext } from 'react';\n\nexport default createContext<(value?: unknown) => void>(() => { throw new Error('Unmount function not set'); });\n"]}
{"filename": "src/ui/react/configureProject/useGitRepoInfo.ts", "chunked_list": ["import { useCallback, useEffect, useState } from 'react';\nimport simpleGit from 'simple-git';\n\ntype GitRepoInfo = {\n  commitsAhead: number,\n  commitsBehind: number,\n  currentBranch: string | null,\n  stagedFiles: string[],\n  unstagedFiles: string[],\n  remotes: string[],\n  inited: boolean,\n}\n\nconst defaultInfo: GitRepoInfo = {\n  commitsAhead: 0,\n  commitsBehind: 0,\n  currentBranch: null,\n  inited: false,\n  remotes: [],\n  unstagedFiles: [],\n  stagedFiles: [],\n};\n", "export default function useGitRepoInfo(path: string): [ GitRepoInfo, () => void ] {\n  const [gitRepoInfo, setGitRepoInfo] = useState(defaultInfo);\n\n  const updateInfo = useCallback(() => {\n    (async () => {\n      // Spread here to create a new Object. React will not see changes if the object reference is the same\n      const info: GitRepoInfo = {...defaultInfo};\n\n      const gitClient = simpleGit(path);\n      try {\n        const status = await gitClient.status();\n\n        info.inited = true;\n        info.stagedFiles = status.staged;\n        info.unstagedFiles = status.not_added;\n        info.currentBranch = status.current;\n        info.commitsAhead = status.ahead;\n        info.commitsBehind = status.behind;", "      try {\n        const status = await gitClient.status();\n\n        info.inited = true;\n        info.stagedFiles = status.staged;\n        info.unstagedFiles = status.not_added;\n        info.currentBranch = status.current;\n        info.commitsAhead = status.ahead;\n        info.commitsBehind = status.behind;\n      } catch (error) {\n        setGitRepoInfo(info);\n        return;\n      }\n\n      const remotes = await gitClient.getRemotes();\n      info.remotes = remotes.map((remote) => remote.name);\n\n      setGitRepoInfo(info);", "      } catch (error) {\n        setGitRepoInfo(info);\n        return;\n      }\n\n      const remotes = await gitClient.getRemotes();\n      info.remotes = remotes.map((remote) => remote.name);\n\n      setGitRepoInfo(info);\n    })().catch((error) => {\n      console.error('Error while fetching git repo info', error);\n    });\n  }, [path]);\n\n  useEffect(() => {\n    updateInfo();\n  }, [path]);\n\n  return [gitRepoInfo, updateInfo];\n}\n", "    })().catch((error) => {\n      console.error('Error while fetching git repo info', error);\n    });\n  }, [path]);\n\n  useEffect(() => {\n    updateInfo();\n  }, [path]);\n\n  return [gitRepoInfo, updateInfo];\n}\n"]}
{"filename": "src/ui/react/configureProject/useConfigureProject.ts", "chunked_list": ["import { useMemo, useState } from 'react';\nimport useGitRepoInfo from './useGitRepoInfo';\nimport { ProjectConfig } from '../../../db/InternalDb';\n\nexport default function useConfigureProject(initalState: ProjectConfig) {\n  const [project, setProject] = useState(initalState);\n\n  const [repoInfo, updateRepoInfo] = useGitRepoInfo(project.repositoryPath || '/');\n\n  const visible = useMemo(() => {\n    const visible = {\n      init: false,\n      remotes: false,\n    };\n", "    if (!repoInfo.inited && project.repositoryPath) {\n      visible.init = true;\n    }\n\n    if (repoInfo.inited) {\n      visible.remotes = true;\n    }\n\n    return visible;\n  }, [repoInfo, project]);\n\n  return {\n    project,\n    setProject,\n    repoInfo,\n    updateRepoInfo,\n    visible,\n  };\n}\n"]}
