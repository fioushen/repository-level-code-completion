{"filename": "src/models.ts", "chunked_list": ["import { appraiseCard } from './appraise';\nimport { IAuthProvider, IDataSource } from './dependencies';\n\nexport const toClientPlayer = (player: IDataSource.IPlayer, authProvider: IAuthProvider) => {\n    return {\n        ...player,\n        authToken: authProvider.getAuthTokenForPlayer(player),\n    };\n}\n", "}\n\nexport const toClientDeck = (player: IDataSource.IPlayer, deck: IDataSource.ICardDeck | null) => {\n    if (!deck) return null;\n    return {\n        id: deck.createdAt,\n        label: deck.label,\n        cards: deck.cards.map(appraiseCard),\n        isActiveDeck: player.activeDeckId === deck.createdAt,\n    };\n};"]}
{"filename": "src/appraise.ts", "chunked_list": ["const MINT_HEIGHT_THRESHOLD = 3200000;\n\nexport type CoreScriptNames = typeof _CoreScriptNames[IAppraisedCard['faction']][number];\n\nexport interface IAppraisedCard {\n    nftId: string;\n    faction: 'backdoor' | 'bruteforce' | 'malware';\n    coreScript: CoreScriptNames;\n    tier: number;\n    cpu: number;\n    mem: number;\n    url: string;\n}\n\n/**\n * Generates card stats based on the number of digits in the last 9 chars of the nftId,\n */\nexport const appraiseCard = ({ nftId, mintHeight, url }: { nftId: string, mintHeight: number, url: string }): IAppraisedCard => {\n    // Last 9 chars of the nftId determine the card qualifier, Q\n    const Q = nftId.substring(nftId.length - 8).split('');\n\n    // Q[0] determines faction\n    //   Since 34 potential characters does not divide cleanly by 3 factions,\n    //   distribution will not come out even - Backdoor will appear 10% less than other factions\n    let faction: IAppraisedCard['faction'];\n    const factionQualifier = Q[0]!.charCodeAt(0);", "    if (factionQualifier < 99) faction = 'backdoor'; // 0-9, a, b (10 chars, '1' and 'b' do not exist)\n    else if (factionQualifier < 111) faction = 'bruteforce'; // c-n (11 chars, 'i' does not exist)\n    else faction = 'malware'; // o-z (11 chars, 'o' does not exist)\n\n    // The sum of the char codes of Q, sumQ, determines faction core script\n    const sumQ = Q.reduce((sum, c) => sum + c.charCodeAt(0), 0);\n    const coreScripts = _CoreScriptNames[faction];\n    const coreScript = coreScripts[sumQ % coreScripts.length]!;\n\n    // Q[2:] is the card statistics qualifier, SQ, each granted statistic increases card tier\n    const SQ = Q.slice(2);\n    const tier = SQ.reduce((sum, c) => isNaN(+c) ? sum : (sum + 1), 0);", "    if (tier < 2 || mintHeight >= MINT_HEIGHT_THRESHOLD) {\n        // Less than 2 digits or minted after threshold is a T1; either 1/2 or 2/1\n        const singleQualifier = Q[1]; // Only either 's' or 'q'\n        const cpu = singleQualifier === 's' ? 2 : 1;\n        const mem = 3 - cpu;\n        return {\n            nftId,\n            faction,\n            tier: 1,\n            cpu,\n            mem,\n            coreScript,\n            url,\n        };\n    }\n\n    // For each character c in SQ, grant CPU or MEM if c is numeric, nothing otherwise\n    //   Since there are only 9 possible digits per character, we use 2-5 for MEM, 6-9 for CPU, 0 is treated special\n    let cpu = 1;\n    let mem = 1;", "    for (const c of SQ) {\n        if (+c > 5) {\n            cpu++; // 6, 7, 8, 9\n        } else if (+c > 0) {\n            mem++; // 2, 3, 4, 5 ('1' does not exist)\n        } else if (+c === 0) {\n            // For 0, we flip a coin on the char code sum of Q which results in 50:50 CPU:MEM distribution\n            (sumQ % 2) ? (cpu++) : (mem++);\n        }\n    }\n\n    return {\n        nftId,\n        faction,\n        tier,\n        cpu,\n        mem,\n        coreScript,\n        url,\n    };\n};\n\nconst _CoreScriptNames = {\n    backdoor: [\n        'bd_exploit',\n        'bd_decode',\n        'bd_secure',\n    ] as const,\n\n    bruteforce: [\n        'bf_firewall',\n        'bf_overclock',\n        'bf_spam',\n    ] as const,\n\n    malware: [\n        'mw_redirect',\n        'mw_freeware',\n        'mw_worm',\n    ] as const,\n};\n(_CoreScriptNames as Record<IAppraisedCard['faction'], readonly string[]>);\n"]}
{"filename": "src/net-utils.ts", "chunked_list": ["export enum StatusCodes {\n    ok = 200,\n\n    /**\n     *  Missing or incorrect params\n     */\n    badRequest = 400,\n\n    /**\n     * Auth failed\n     */\n    unauthorized = 401,\n\n    /**\n     * Server state is incompatible with request, e.g. leaving a game without being in a game.\n     * This could be due to stale state on the client or wrong client logic.\n     */\n    forbidden = 403, // retry won't help\n\n    /**\n     * Resource specified in the request does not exist and it is unknown whether it ever existed\n     */\n    notFound = 404,\n\n    /**\n     * API exists but wrong method was used\n     */\n    methodNotAllowed = 405,\n\n    /**\n     * Request is no longer valid and should start over from handshake.\n     */\n    timeout = 408,\n\n    /**\n     * Request was valid at the time it was received but server state changed since. The request\n     * should be retried.\n     */\n    conflict = 409,\n\n    /**\n     * Resource specified in the request did exist at one point but not anymore\n     */\n    gone = 410,\n\n    /**\n     * Slow down\n     */\n    tooManyRequests = 429,\n\n    /**\n     * Uncaught/unhandled server error - should not happen\n     */\n    internalServerError = 500,\n\n    /**\n     * A downstream resource that the server depends on is unavailable\n     */\n    badGateway = 502, // downstream resource error\n\n    /**\n     * Planned outage\n     */\n    serviceUnavailable = 503,\n}\n", "export interface IHttpRequest {\n    path: string;\n    httpMethod: string;\n    headers?: { [header: string]: string; };\n    queryStringParameters?: { [header: string]: string; };\n    body?: string;\n}\n\nexport type IHttpRouteHandler = (\n    path: string[],\n    query: Record<string, string | number>,\n    body: Record<string, any>,\n    req: IHttpRequest,\n) => Promise<[StatusCodes] | [StatusCodes, Record<string, any>] | [StatusCodes, Record<string, any>, Record<string, string>] | undefined>;\n", "export type IHttpRouteHandler = (\n    path: string[],\n    query: Record<string, string | number>,\n    body: Record<string, any>,\n    req: IHttpRequest,\n) => Promise<[StatusCodes] | [StatusCodes, Record<string, any>] | [StatusCodes, Record<string, any>, Record<string, string>] | undefined>;\n\nexport class RouteError extends Error {\n    constructor(\n        public statusCode: StatusCodes,\n        message: string,\n    ) {\n        super(message);\n    }\n}"]}
{"filename": "src/extensions.d.ts", "chunked_list": ["declare interface Array<T> {\n    findAndRemoveFirst(predicate: (item: T) => boolean): boolean;\n    random(): T;\n    randomOrUndefined(): T | undefined;\n    removeFirst(item: T): boolean;\n    filter(booleanCtor: typeof Boolean): NonNullableVoid<T>[];\n}\n\ndeclare type NonNullableVoid<T> = Exclude<NonNullable<T>, void>;\ndeclare type StringsStartingWith<T extends string, K extends string> = T extends `${K}${infer _X}` ? T : never;\ndeclare type KeyOfFilteredByValueType<T, F> = NonNullable<{ [K in keyof T]: T[K] extends F ? K : never }[keyof T]>;", "declare type NonNullableVoid<T> = Exclude<NonNullable<T>, void>;\ndeclare type StringsStartingWith<T extends string, K extends string> = T extends `${K}${infer _X}` ? T : never;\ndeclare type KeyOfFilteredByValueType<T, F> = NonNullable<{ [K in keyof T]: T[K] extends F ? K : never }[keyof T]>;\ndeclare type TypeConstructor<T> = { new(...args: any[]): T };"]}
{"filename": "src/dependencies.d.ts", "chunked_list": ["import { GameEngine } from './game/game-engine';\nimport { IHttpRequest } from './net-utils';\n\ndeclare namespace IDataSource {\n    export type GetterSingle<MODEL> = (id: string) => Promise<MODEL | null>;\n    export type GetterPair<MODEL> = (id1: string, id2: string) => Promise<MODEL | null>;\n\n    export type UpdateRequest = any;\n    export type Updater<MODEL> = {\n        /**\n         * Creates an UpdateRequest for the specified item that can be used with execUpdates(...).\n         */\n        make(item: MODEL, overwrite?: boolean): UpdateRequest;\n\n        /**\n         * Updates the specified item. Fails if the specified item has changed since it was retrieved if `overwrite` is true.\n         */\n        exec(item: MODEL, overwrite?: boolean): Promise<typeof item>;\n    };\n", "    export type Updater<MODEL> = {\n        /**\n         * Creates an UpdateRequest for the specified item that can be used with execUpdates(...).\n         */\n        make(item: MODEL, overwrite?: boolean): UpdateRequest;\n\n        /**\n         * Updates the specified item. Fails if the specified item has changed since it was retrieved if `overwrite` is true.\n         */\n        exec(item: MODEL, overwrite?: boolean): Promise<typeof item>;\n    };\n", "    export type Query<KEY, MODEL> = (key: NonNullable<KEY>, limit?: number, ct?: string) => Promise<{ items: MODEL[]; ct?: typeof ct; }>;\n\n    export interface ICardDeck {\n        readonly playerId: string;\n        readonly createdAt: string;\n        cards: { nftId: string, mintHeight: number, url: string }[];\n        label: string;\n    }\n    export type CardDecks = {\n        get: GetterPair<ICardDeck>;\n        update: Updater<ICardDeck>;\n        queryByDid: Query<ICardDeck['playerId'], ICardDeck>;\n    };\n\n", "    export type CardDecks = {\n        get: GetterPair<ICardDeck>;\n        update: Updater<ICardDeck>;\n        queryByDid: Query<ICardDeck['playerId'], ICardDeck>;\n    };\n\n\n    export interface ICoopGame {\n        id: string;\n        difficulty: number;\n        createdAt: string;\n        gameState: 'open' | 'private' | `ended_${string}`;\n        playersIds: Set<string>;\n        ingorePlayerIds: Set<string>;\n        startedAt: string;\n        endedAt: string;\n        isCompleted: boolean;\n        _dbTtl?: number;\n    }", "    export type CoopGames = {\n        get: GetterSingle<ICoopGame>;\n        update: Updater<ICoopGame>;\n        queryByGameState: Query<ICoopGame['gameState'], ICoopGame>;\n    };\n\n\n    export interface IPlayer {\n        id: string;\n        createdAt: string;\n        lastSeenAt: string;\n        secret: string;\n        authExpiresAt: string;\n        activeGameId: string;\n        activeDeckId: string;\n        score: number;\n    }", "    export type Players = {\n        get: GetterSingle<IPlayer>;\n        update: Updater<IPlayer>;\n    };\n\n\n    export interface IPlayerCoopGame {\n        playerId: string;\n        endedAt: string;\n        gameId: string;\n        gameResult: 'win' | 'loss' | 'abandoned' | 'unknown';\n        teammates: string[];\n        score: number;\n        turns: number;\n        difficulty: number;\n        rulesetIds: string[];\n    }", "    export type PlayerCoopGame = {\n        update: Updater<IPlayerCoopGame>;\n        queryByPlayerId: Query<string, IPlayerCoopGame>;\n    }\n\n\n    export type GameData = {\n        get: GetterSingle<GameEngine.IGameData>;\n        update: Updater<GameEngine.IGameData>;\n    };\n\n", "    export type Leaderboard = {\n        getTopN(n: number): Promise<[string, number][]>;\n        set(playerId: string, score: number): Promise<void>;\n    };\n}\ndeclare interface IDataSource {\n    CardDecks: IDataSource.CardDecks;\n    CoopGames: IDataSource.CoopGames;\n    GameData: IDataSource.GameData;\n    Leaderboard: IDataSource.Leaderboard;\n    PlayerCoopGames: IDataSource.PlayerCoopGame;\n    Players: IDataSource.Players;\n\n    /**\n     * Transactionlly executes all UpdateRequests; no changes are made if any one of the UpdateRquests fail.\n     */\n    execUpdates(...updateRequests: IDataSource.UpdateRequest[]): Promise<void>;\n}\n\n", "declare interface IAuthProvider {\n    generateNewSecret(): string;\n    getAuthTokenForPlayer(player: IDataSource.IPlayer): string;\n    getPlayerFromRequest(req: IHttpRequest): Promise<IDataSource.IPlayer>;\n    getPlayerIdFromRequest(req: IHttpRequest): string;\n}\n\n\ndeclare namespace IPlayerPushProvider {\n    export interface IPushMessage {\n        [key: string]: any;\n        type: string;\n    }\n}", "    export interface IPushMessage {\n        [key: string]: any;\n        type: string;\n    }\n}\ndeclare interface IPlayerPushProvider {\n    push(playerId: string, messages: IPlayerPushProvider.IPushMessage[]): Promise<void>;\n}\n\n\ndeclare interface IRateLimitProvider {\n    shouldRateLimitCreateGame(playerId: string): Promise<boolean>;\n    shouldRateLimitSearchGame(playerId: string): Promise<boolean>;\n}\n\n", "declare interface IRateLimitProvider {\n    shouldRateLimitCreateGame(playerId: string): Promise<boolean>;\n    shouldRateLimitSearchGame(playerId: string): Promise<boolean>;\n}\n\n\ndeclare interface IMetricsProvider {\n    userPresence(playerId: string): void;\n    httpRequest(path: string, status: number): void;\n    wsRequest(api: string, isSuccess: boolean): void;\n\n    newUser(playerId: string): void;\n    deckUpdated(playerId: string, deckId: string): void;\n    nftOwnershipConflict(playerId: string): void;\n    gameCreated(gameId: string, playerId: string, initialRulesetId: string, visibility: string, difficulty: number): void;\n    gameStarted(gameId: string, initialRulesetId: string, players: string[], fromMatchmaking: boolean): void;\n    gameJoined(gameId: string, midGame: boolean): void;\n    gameEnded(gameId: string, result: string, rulesets: string[], players: string[], turns: number, totalScore: number): void;\n    playerCardPlayed(gameId: string, currentRulesetId: string, playerId: string, card: GameEngine.IPlayerCardState, scriptName: string): void;\n    idlePlayerRemoved(gameId: string, idlePlayerId: string): void;\n\n    flush(): Promise<void>;\n}"]}
{"filename": "src/reference-example.ts", "chunked_list": ["import * as moment from 'moment';\nimport { createCoopHandler } from './apis/coop.api';\nimport { IAuthProvider, IDataSource, IPlayerPushProvider, IRateLimitProvider } from './dependencies';\nimport { CardMod } from './game/card-mods';\nimport { CardScript } from './game/card-scripts';\nimport { GameEngine, createGameEngineProvider } from './game/game-engine';\nimport { GameEngineUtils } from './game/game-engine-utils';\nimport { IHttpRequest, IHttpRouteHandler, StatusCodes } from './net-utils';\nimport { FULL_DATETIME_FORMAT } from './utils';\n", "import { FULL_DATETIME_FORMAT } from './utils';\n\n/**\n * Main entry point\n */\n// TODO: this should be replaced with node:http or expressjs\nexport const handleRequest = async (req: IHttpRequest) => {\n    const split = req.path.split('/').filter(Boolean);\n\n    const subPath = split.slice(1);", "\n    const subPath = split.slice(1);\n    const body = req.body ? JSON.parse(req.body) : null;\n    const query = req.queryStringParameters || {};\n\n    let handler: IHttpRouteHandler | undefined = undefined;\n\n    switch (split[0]) {\n        case 'coop':\n            handler = coopHandler;", "        case 'coop':\n            handler = coopHandler;\n\n        // ... Note: implement remaining route handlers\n    }\n\n    const result = handler ? (await handler(subPath, query, body, req)) : null;\n    return result || [StatusCodes.badRequest, { reason: 'invalid api' }];\n};\n", "};\n\n\n/**\n * Dependencies\n */\n\n// Note: replace with an actual database\nconst cardDecksTable = createMockTableDualKey<IDataSource.ICardDeck>('playerId', 'createdAt');\nconst coopGamesTable = createMockTableSingleKey<IDataSource.ICoopGame>('id');", "const cardDecksTable = createMockTableDualKey<IDataSource.ICardDeck>('playerId', 'createdAt');\nconst coopGamesTable = createMockTableSingleKey<IDataSource.ICoopGame>('id');\nconst playersTable = createMockTableSingleKey<IDataSource.IPlayer>('id');\nconst playerCoopGamesTable = createMockTableSingleKey<IDataSource.IPlayerCoopGame>('playerId');\nconst dataSource: IDataSource = {\n    CardDecks: {\n        ...cardDecksTable,\n        async queryByDid(did) {\n            return { items: [...cardDecksTable._db.values()].filter(x => x.playerId === did) };\n        },", "            return { items: [...cardDecksTable._db.values()].filter(x => x.playerId === did) };\n        },\n    },\n    CoopGames: {\n        ...coopGamesTable,\n        async queryByGameState(gameState) {\n            return { items: [...coopGamesTable._db.values()].filter(x => x.gameState === gameState) };\n        },\n    },\n    GameData: {", "    },\n    GameData: {\n        ...createMockTableSingleKey<GameEngine.IGameData>('id'),\n    },\n    Players: {\n        ...playersTable,\n    },\n    PlayerCoopGames: {\n        ...playerCoopGamesTable,\n        async queryByPlayerId(playerId: string) {", "        ...playerCoopGamesTable,\n        async queryByPlayerId(playerId: string) {\n            return { items: [...playerCoopGamesTable._db.values()].filter(x => x.playerId === playerId) };\n        },\n    },\n    Leaderboard: {\n        getTopN(_n) { return [] as any; },\n        async set(_playerId, _score) { },\n    },\n", "    },\n\n    async execUpdates(...updateRequests) {\n        updateRequests.forEach(x => x());\n    },\n};\n\n// Note: replace with an actual auth provider\nconst authProvider: IAuthProvider = {\n    generateNewSecret: () => `${Math.random()}`,", "const authProvider: IAuthProvider = {\n    generateNewSecret: () => `${Math.random()}`,\n    getAuthTokenForPlayer: player => player.secret,\n    getPlayerFromRequest: async () => [...playersTable._db.values()][0]!,\n    getPlayerIdFromRequest: () => [...playersTable._db.values()][0]?.id!,\n};\n\n// Note: replace with an actual push provider\nconst pushProvider: IPlayerPushProvider = {\n    async push(playerId, messages) {", "const pushProvider: IPlayerPushProvider = {\n    async push(playerId, messages) {\n        console.log(`Push messages for player [${playerId}]:`);\n        messages.forEach(x => console.log(x));\n    }\n};\n\nconst rateLimitProvider: IRateLimitProvider = {\n    async shouldRateLimitCreateGame(_playerId) {\n        return false;", "    async shouldRateLimitCreateGame(_playerId) {\n        return false;\n    },\n    async shouldRateLimitSearchGame(_playerId) {\n        return false;\n    },\n};\n\n// Note: replace with custom game content\nconst gameContent: GameEngine.IRuleset = {", "// Note: replace with custom game content\nconst gameContent: GameEngine.IRuleset = {\n    cardMods: { /** Custom card modifiers **/ },\n    cardScripts: { /** Custom card scripts **/ },\n\n    initGame(engine) {\n        const testEnemy: GameEngine.IEnemyCardState = {\n            id: engine.nextId(),\n            enemyClass: 'testEnemy',\n            cpu: 1,", "            enemyClass: 'testEnemy',\n            cpu: 1,\n            mem: 1,\n            maxMem: 1,\n            mods: [],\n            scripts: [],\n            sec: 10,\n        };\n        testEnemy.mods.push(new CardMod.Content._standardAi().serialize());\n        testEnemy.scripts.push(new CardScript.Content._attack(testEnemy, engine.gameData.difficulty).serialize());", "        testEnemy.mods.push(new CardMod.Content._standardAi().serialize());\n        testEnemy.scripts.push(new CardScript.Content._attack(testEnemy, engine.gameData.difficulty).serialize());\n        GameEngineUtils.addEnemy(engine, testEnemy, 0, true);\n    },\n\n    addAdditionalScriptsFor(_card) {\n        // Note: Called by GameEngine when a player is joined; this hook allows for dynamic scripts for a given card\n    },\n};\n", "};\n\nconst gameEngine = createGameEngineProvider({ mfrm: gameContent }, dataSource, pushProvider);\nconst coopHandler = createCoopHandler(dataSource, gameEngine, authProvider, rateLimitProvider);\n\n\n/**\n * Example\n */\n(async () => {", " */\n(async () => {\n    /**\n     * Players are normally created via /players/connectDid; to keep this example concise,\n     * we'll inject one with CO8's DID into the mock database.\n     */\n    const mockPlayer = {\n        id: 'did:chia:1sc5hxvcs26e4zsc7uvlfuc7x9sjj5aw6cu0g8vcyvscy49ffp8zqwh63tq',\n\n        activeDeckId: '',", "\n        activeDeckId: '',\n        activeGameId: '',\n        secret: '',\n        authExpiresAt: '2100-01-01',\n        createdAt: moment.utc().format(FULL_DATETIME_FORMAT),\n        lastSeenAt: moment.utc().format(FULL_DATETIME_FORMAT),\n        score: 0,\n    }\n    playersTable._db.set(mockPlayer.id, mockPlayer);", "    }\n    playersTable._db.set(mockPlayer.id, mockPlayer);\n\n    /**\n     * This calls into /coop/create which is a complex API.\n     * Step thru this to learn about how the route handlers work.\n     */\n    console.log('Creating game...');\n    await handleRequest({\n        httpMethod: 'POST',", "    await handleRequest({\n        httpMethod: 'POST',\n        path: '/coop/create',\n        body: JSON.stringify({\n            gameVisibility: 'private',\n            difficulty: 1,\n        }),\n    });\n    console.log('Game created, gameId: ' + mockPlayer.activeGameId);\n", "    console.log('Game created, gameId: ' + mockPlayer.activeGameId);\n\n    /**\n     * Games normally start automatically when enough players join via /coop/join or /coop/search,\n     * to keep this example concise, we'll start it directly via the gameEngine reference.\n     * Step thru this to learn about how the game engine works.\n     */\n    console.log('Starting game...');\n    await gameEngine.startGame(mockPlayer.activeGameId);\n})();", "    await gameEngine.startGame(mockPlayer.activeGameId);\n})();\n\n\n/**\n * In-memory DB helpers\n * Note: this is a mock database that only satisfies the example above and is\n * not meant to be starting point for production.\n */\nfunction createMockTableSingleKey<T extends Record<string, any>>(idKey: keyof T) {\n    const _db = new Map<string, T>();\n    return {\n        _db,\n\n        async get(id: string) {\n            return _db.get(id) || null;\n        },\n        update: {\n            make(item: T) {\n                return () => this.exec(item);\n            },\n            async exec(item: T) {\n                _db.set(item[idKey], item);\n                return item;\n            },\n        },\n    };\n}\n", " */\nfunction createMockTableSingleKey<T extends Record<string, any>>(idKey: keyof T) {\n    const _db = new Map<string, T>();\n    return {\n        _db,\n\n        async get(id: string) {\n            return _db.get(id) || null;\n        },\n        update: {\n            make(item: T) {\n                return () => this.exec(item);\n            },\n            async exec(item: T) {\n                _db.set(item[idKey], item);\n                return item;\n            },\n        },\n    };\n}\n", "function createMockTableDualKey<T extends Record<string, any>>(id1Key: keyof T, id2Key: keyof T) {\n    const _db = new Map<string, T>();\n    return {\n        _db,\n\n        async get(id1: string, id2: string) {\n            return _db.get(`${id1}_${id2}`) || null;\n        },\n        update: {\n            make(item: T) {\n                return () => this.exec(item);\n            },\n            async exec(item: T) {\n                _db.set(`${item[id1Key]}_${item[id2Key]}`, item);\n                return item;\n            },\n        },\n    };\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import './extensions';\n\nexport const FULL_DATETIME_FORMAT = 'YYYY-MM-DDTHH:mm:ss';\nexport const DATE_FORMAT = 'YYYY-MM-DD';\nexport const SECS_IN_MIN = 60;\nexport const MINS_IN_HOUR = 60;\nexport const HOURS_IN_DAY = 24;\nexport const SECS_IN_HOUR = SECS_IN_MIN * MINS_IN_HOUR;\nexport const MINS_IN_DAY = MINS_IN_HOUR * HOURS_IN_DAY;\nexport const SECS_IN_DAY = MINS_IN_DAY * SECS_IN_MIN;", "export const MINS_IN_DAY = MINS_IN_HOUR * HOURS_IN_DAY;\nexport const SECS_IN_DAY = MINS_IN_DAY * SECS_IN_MIN;\n\nexport const jsonReplacer = (_: string, value: any) => {\n    if (value instanceof Map) {\n        return {\n            __reviverType: 'map',\n            value: Object.fromEntries(value.entries()),\n        };\n    }\n    return value;\n};\n\nexport const jsonReviver = (_: string, value: any) => {", "    if (value?.__reviverType === 'map') {\n        return new Map(Object.entries(value.value));\n    }\n    return value;\n};\n\nexport const clamp = (value: number, min: number, max: number) => {\n    return value < min ? min : (value > max) ? max : value;\n}\n\nexport const rand = (minIncl: number, maxExcl: number) =>\n    minIncl + Math.random() * (maxExcl - minIncl);\n\nexport const randInt = (min: number, max: number) =>\n    Math.round(rand(min, max));\n\nexport const round = (num: number, precision: number) =>\n    +num.toFixed(precision);"]}
{"filename": "src/external-dependencies.ts", "chunked_list": ["///<reference lib='dom' />\n\nexport namespace ExtDeps {\n    export interface INft {\n        nftId: string;\n        wallet: string;\n        firstBlock: number;\n        lastBlock: number;\n        urls: string[];\n        did?: string;\n    }\n", "    export interface IDidProof {\n        latestCoinId: string;\n        pubkey: string;\n        signature: string;\n        message: string;\n    };\n\n    export async function getNft(nftId: string) {\n        try {\n            const resp = await fetch('https://api.chiapi.io/v0/nfts/' + nftId);\n            if (resp.ok) {\n                return await resp.json() as { nft: INft };\n            }\n        } catch {\n        }\n        return null;\n    }\n", "        try {\n            const resp = await fetch('https://api.chiapi.io/v0/nfts/' + nftId);\n            if (resp.ok) {\n                return await resp.json() as { nft: INft };\n            }\n        } catch {\n        }\n        return null;\n    }\n\n    export async function getNftsByDidOrWallet(didOrWallet: string, count?: number, ct?: string) {", "    export async function getNftsByDidOrWallet(didOrWallet: string, count?: number, ct?: string) {\n        try {\n            const queryParams = [count && `count=${count}`, ct && `ct=${ct}`].filter(Boolean);\n            const query = queryParams.length ? `?${queryParams.join('&')}` : '';\n\n            const resp = await fetch(`https://api.chiapi.io/v0/nfts/${didOrWallet}${query}`);\n            return await resp.json() as { nfts: INft[], ct?: string };\n        } catch {\n        }\n        return null;\n    }\n", "    export async function verifyDidProof(proof: IDidProof) {\n        try {\n            const resp = await fetch(`https://api.chiapi.io/v0/dids/verify`, {\n                method: 'POST',\n                body: JSON.stringify({ proof }),\n                headers: {\n                    'content-type': 'application/json',\n                },\n            });\n            return await resp.json() as { did: string };\n        } catch {\n        }\n        return null;\n    }\n}"]}
{"filename": "src/extensions.ts", "chunked_list": ["/// <reference path='extensions.d.ts' />\n\nArray.prototype.removeFirst = function (item) {\n    const i = this.indexOf(item);\n    if (i === -1) return false;\n    this.splice(i, 1);\n    return true;\n};\n\nArray.prototype.findAndRemoveFirst = function (predicate) {\n    for (let i = 0; i < this.length; i++) {", "    for (let i = 0; i < this.length; i++) {\n        if (predicate(this[i])) {\n            this.splice(i, 1);\n            return true;\n        }\n    }\n    return false;\n};\n\nArray.prototype.random = function () {\n    const item = this.randomOrUndefined();", "    if (!item) {\n        throw new Error('Array is empty');\n    }\n    return item;\n};\n\nArray.prototype.randomOrUndefined = function () {\n    if (!this.length) return undefined;\n    return this[Math.random() * this.length | 0];\n};"]}
{"filename": "src/apis/cards.api.ts", "chunked_list": ["import { appraiseCard } from '../appraise';\nimport { ExtDeps } from '../external-dependencies';\nimport { IHttpRouteHandler, StatusCodes } from \"../net-utils\";\n\nexport const createCardsHandler = (): IHttpRouteHandler => {\n    return async (path, query) => {\n        const id = path[0];\n        if (id) {\n            if (id.startsWith('xch1') || id.startsWith('did:chia:1')) {\n                return _handleCardsDidOrXch(id, query.ct as string, +(query.count || 5));\n            }\n", "            if (id.startsWith('xch1') || id.startsWith('did:chia:1')) {\n                return _handleCardsDidOrXch(id, query.ct as string, +(query.count || 5));\n            }\n\n            if (id.startsWith('nft1')) {\n                return _handleCardsNft(id);\n            }\n        }\n        return [StatusCodes.badRequest, { reason: 'invalid id' }];\n    };\n\n", "    async function _handleCardsNft(nftId: string): Promise<ReturnType<IHttpRouteHandler>> {\n        const resp = await ExtDeps.getNft(nftId);\n        if (resp?.nft) {\n            return [StatusCodes.ok, {\n                card: {\n                    ...appraiseCard({ nftId: resp.nft.nftId, mintHeight: resp.nft.firstBlock, url: resp.nft.urls[0] || '' }),\n                    urls: resp.nft.urls,\n                },\n            }];\n        }\n        return [StatusCodes.notFound, { reason: 'nft not found' }];\n    }\n", "    async function _handleCardsDidOrXch(did: string, ct?: string, count = 5): Promise<ReturnType<IHttpRouteHandler>> {\n        const resp = await ExtDeps.getNftsByDidOrWallet(did, count, ct);\n        if (resp?.nfts.length) {\n            return [StatusCodes.ok, {\n                cards: resp.nfts.map(nft => ({\n                    ...appraiseCard({ nftId: nft.nftId, mintHeight: nft.firstBlock, url: nft.urls[0] || '' }),\n                    urls: nft.urls,\n                })),\n                ct: resp.ct,\n            }];\n        }\n\n        return [StatusCodes.notFound, { reason: 'no nfts found' }];\n    }\n}"]}
{"filename": "src/apis/decks.api.ts", "chunked_list": ["import * as moment from 'moment';\nimport { z } from 'zod';\nimport { IAuthProvider, IDataSource, IMetricsProvider } from '../dependencies';\nimport { ExtDeps } from '../external-dependencies';\nimport { toClientDeck, toClientPlayer } from '../models';\nimport { IHttpRouteHandler, StatusCodes } from '../net-utils';\nimport { FULL_DATETIME_FORMAT } from '../utils';\n\nexport const createDeckHandler = (ds: IDataSource, authProvider: IAuthProvider, metrics?: IMetricsProvider): IHttpRouteHandler =>\n    async (path, query, body, req) => {", "export const createDeckHandler = (ds: IDataSource, authProvider: IAuthProvider, metrics?: IMetricsProvider): IHttpRouteHandler =>\n    async (path, query, body, req) => {\n        switch (path[0]) {\n            case 'activate': {\n                const schema = z.object({\n                    deckId: z.string(),\n                });\n\n                const payload = schema.parse(body);\n", "                const payload = schema.parse(body);\n\n                const player = await authProvider.getPlayerFromRequest(req);\n                const deck = await ds.CardDecks.get(player.id, payload.deckId);\n                if (!deck) return [StatusCodes.notFound];\n\n                player.activeDeckId = deck.createdAt;\n                await ds.Players.update.exec(player);\n\n                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider), deck: toClientDeck(player, deck) }];\n            }\n\n            case 'create': {\n                const schema = z.object({\n                    deckLabel: z.string().min(1).max(20),\n                    nftIds: z.array(z.string().startsWith('nft1')).length(6),\n                });\n\n                const payload = schema.parse(body);\n\n                const player = await authProvider.getPlayerFromRequest(req);\n                const nfts = (await Promise.all((payload.nftIds).slice(0, 6).map(ExtDeps.getNft))).filter(Boolean).map(x => x.nft);", "                if (nfts.length !== 6) {\n                    return [StatusCodes.forbidden, { reason: `not enough nftIds, need 6, got ${nfts.length}` }];\n                }\n\n                const deck = await ds.CardDecks.update.exec({\n                    playerId: player.id,\n                    createdAt: moment.utc().format(FULL_DATETIME_FORMAT),\n                    label: payload.deckLabel,\n                    cards: nfts.map(x => ({ nftId: x.nftId, mintHeight: x.firstBlock, url: x.urls[0] || '' })),\n                });\n\n                metrics?.deckUpdated(player.id, deck.createdAt);\n                return [StatusCodes.ok, { deck: toClientDeck(player, deck) }];\n            }\n\n            case 'list': {\n                const schema = z.object({\n                    ct: z.string().optional(),\n                });\n\n                const q = schema.parse(query);\n\n                const player = await authProvider.getPlayerFromRequest(req);\n                const decks = await Promise.all((await ds.CardDecks.queryByDid(player.id, 10, q.ct)).items);", "                if (!decks.length) {\n                    const defaultDeck = await getOrCreateActiveDeck(player, ds);\n                    defaultDeck && decks.push(defaultDeck)\n                }\n                return [StatusCodes.ok, { decks: decks.map(deck => toClientDeck(player, deck)) }];\n            }\n\n            case 'update': {\n                const schema = z.object({\n                    deckId: z.string(),\n                    deckLabel: z.string().min(1).max(20),\n                    nftIds: z.array(z.string().startsWith('nft1')).length(6),\n                });\n\n                const payload = schema.parse(body);\n\n                const uniqueNftIds = new Set<string>(payload.nftIds);", "                if (uniqueNftIds.size !== 6) {\n                    return [StatusCodes.badRequest, { reason: 'nftIds must contain 6 unique NFT ids that belong to the player' }];\n                }\n\n                const player = await authProvider.getPlayerFromRequest(req);\n                const deck = await ds.CardDecks.get(player.id, payload.deckId);\n                if (!deck) {\n                    return [StatusCodes.notFound, { reason: 'invalid deck id' }];\n                }\n\n                payload.deckLabel && (deck.label = deck.label);\n                const nfts = (await Promise.all((payload.nftIds).map(ExtDeps.getNft))).filter((x): x is NonNullable<typeof x> => x?.nft.did === player.id).map(x => x.nft);", "                if (nfts.length !== payload.nftIds.length) {\n                    return [StatusCodes.notFound, { reason: 'one or more nft ids were not found, or did not belong to the player' }];\n                }\n\n                deck.cards = nfts.map(x => ({ nftId: x.nftId, mintHeight: x.firstBlock, url: x.urls[0] || '' }));\n                await ds.CardDecks.update.exec(deck);\n\n                metrics?.deckUpdated(player.id, deck.createdAt);\n                return [StatusCodes.ok, { deck: toClientDeck(player, deck) }];\n            }\n\n            case 'activeDeck': {\n                const player = await authProvider.getPlayerFromRequest(req);\n                return [StatusCodes.ok, { deck: toClientDeck(player, await getOrCreateActiveDeck(player, ds)) }];\n            }\n\n            default: {", "                if (!path[0]) {\n                    return;\n                }\n\n                const player = await authProvider.getPlayerFromRequest(req);\n                const deck = await ds.CardDecks.get(player.id, path[0]);\n                if (!deck) {\n                    return [StatusCodes.notFound];\n                }\n\n                return [StatusCodes.ok, { deck: toClientDeck(player, deck) }];\n            }\n        }\n    };\n\nexport const getOrCreateActiveDeck = async (player: IDataSource.IPlayer, ds: IDataSource) => {\n    let deck = player.activeDeckId ? (await ds.CardDecks.get(player.id, player.activeDeckId)) : null;", "    if (deck) {\n        return deck;\n    }\n\n    const cards = (await ExtDeps.getNftsByDidOrWallet(player.id, 6))?.nfts.filter(Boolean) || [];\n    if (cards.length < 6) {\n        return null;\n    }\n\n    const nowStr = moment.utc().format(FULL_DATETIME_FORMAT);\n    player.activeDeckId = nowStr;\n    deck = {\n        playerId: player.id,\n        createdAt: nowStr,\n        cards: cards.map(x => ({ nftId: x.nftId, mintHeight: x.firstBlock, url: x.urls[0] || '' })),\n        label: 'default',\n    };\n\n    await ds.execUpdates(\n        ds.Players.update.make(player, true),\n        ds.CardDecks.update.make(deck, true),\n    );\n\n    return deck;\n};"]}
{"filename": "src/apis/coop.api.ts", "chunked_list": ["import { randomBytes } from 'crypto';\nimport * as moment from 'moment';\nimport { z } from 'zod';\nimport { appraiseCard } from '../appraise';\nimport { IAuthProvider, IDataSource, IMetricsProvider, IRateLimitProvider } from '../dependencies';\nimport { ExtDeps } from '../external-dependencies';\nimport { GameEngine, GameEngineProvider } from '../game/game-engine';\nimport { toClientPlayer } from '../models';\nimport { IHttpRequest, IHttpRouteHandler, RouteError, StatusCodes } from '../net-utils';\nimport { DATE_FORMAT, FULL_DATETIME_FORMAT } from '../utils';", "import { IHttpRequest, IHttpRouteHandler, RouteError, StatusCodes } from '../net-utils';\nimport { DATE_FORMAT, FULL_DATETIME_FORMAT } from '../utils';\nimport { getOrCreateActiveDeck } from './decks.api';\n\nexport const createCoopHandler = (ds: IDataSource, gameEngineProvider: GameEngineProvider, authProvider: IAuthProvider, rateLimit: IRateLimitProvider, metrics?: IMetricsProvider): IHttpRouteHandler => {\n    return async function handler(path, query, body, req): ReturnType<IHttpRouteHandler> {\n        switch (path[0]) {\n            case 'create': {\n                const schema = z.object({\n                    gameVisibility: z.union([z.literal('public'), z.literal('private'), z.literal('solo')]),\n                    difficulty: z.number(),\n                });\n\n                const payload = schema.parse(body);\n\n                const player = await _expectAuthPlayerNotInGame(req);\n                const deck = await _expectValidActiveDeck(player, true);\n", "                if (await rateLimit.shouldRateLimitCreateGame(player.id)) {\n                    return [StatusCodes.tooManyRequests];\n                }\n\n                const now = moment.utc();\n                const game: IDataSource.ICoopGame = {\n                    id: randomBytes(16).toString('hex'),\n                    createdAt: now.format(FULL_DATETIME_FORMAT),\n                    difficulty: payload.difficulty,\n                    playersIds: new Set([player.id]),\n                    gameState: payload.gameVisibility === 'public' ? 'open' : 'private',\n                    startedAt: '',\n                    endedAt: '',\n                    ingorePlayerIds: new Set(),\n                    isCompleted: false,\n                    _dbTtl: moment.utc(now).add({ days: 1 }).unix(),\n                };\n\n                const initialRulesetId = 'mfrm';\n                metrics?.gameCreated(game.id, player.id, initialRulesetId, payload.gameVisibility, payload.difficulty);\n\n                await gameEngineProvider.createGame(game.id, initialRulesetId, payload.difficulty);\n                await gameEngineProvider.addPlayer(game.id, player.id, deck.cards.map(x => x.nftId));", "                if (payload.gameVisibility === 'solo') {\n                    await _onGameStart(game, false);\n                }\n\n                player.activeGameId = game.id;\n                await ds.execUpdates(\n                    ds.CoopGames.update.make(game),\n                    ds.Players.update.make(player),\n                );\n\n                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider), status: 'gamecreated' }];\n            }\n\n            case 'history': {\n                const playerId = authProvider.getPlayerIdFromRequest(req);\n                const games = await ds.PlayerCoopGames.queryByPlayerId(playerId, +(query.count || 10), query.ct ? `${query.ct}` : undefined);\n                return [StatusCodes.ok, games];\n            }\n\n            case 'join': {\n                const schema = z.object({\n                    teammateDid: z.string().nonempty(),\n                    fromMatchmaking: z.boolean().optional(),\n                });\n\n                const payload = schema.parse(body);\n\n                const [player, teammate] = await Promise.all([\n                    _expectAuthPlayerNotInGame(req),\n                    ds.Players.get(payload.teammateDid),\n                ]);\n", "                if (!teammate?.activeGameId) {\n                    return [StatusCodes.notFound];\n                }\n\n                const [deck, game] = await Promise.all([\n                    _expectValidActiveDeck(player, true),\n                    _expectCoopGameJoinable(teammate.activeGameId),\n                ]);\n\n                const gameData = await gameEngineProvider.addPlayer(game.id, player.id, deck.cards.map(x => x.nftId));\n\n                player.activeGameId = game.id;\n                game.playersIds.add(player.id);\n                game.ingorePlayerIds.delete(player.id);\n                await ds.execUpdates(\n                    ds.Players.update.make(player),\n                    ds.CoopGames.update.make(game),\n                );\n", "                if (!game.startedAt && game.playersIds.size >= 2) {\n                    await _onGameStart(game, !!payload.fromMatchmaking);\n                }\n\n                metrics?.gameJoined(game.id, gameData.turn >= 2);\n                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider), status: 'gamejoined' }];\n            }\n\n            case 'leave': {\n                const { player, game } = await _expectAuthPlayerInGame(req);\n\n                player.activeGameId = '';", "                if (!game.gameState.startsWith('ended')) {\n                    game.playersIds.delete(player.id);\n                    game.ingorePlayerIds.add(player.id);\n                }\n\n                await ds.execUpdates(\n                    ds.Players.update.make(player),\n                    ds.CoopGames.update.make(game),\n                );\n\n                try {\n                    const gameData = await gameEngineProvider.getGameData(game.id);\n                    const playerState = gameData.players.get(player.id);", "                try {\n                    const gameData = await gameEngineProvider.getGameData(game.id);\n                    const playerState = gameData.players.get(player.id);\n                    if (!game.gameState.startsWith('ended') && playerState && gameData.state !== 'created' && gameData.turn > 1) {\n                        const now = moment.utc().format(FULL_DATETIME_FORMAT);\n                        await ds.PlayerCoopGames.update.exec({\n                            playerId: player.id,\n                            endedAt: now,\n                            gameId: game.id,\n                            gameResult: _getGameResult(gameData),\n                            score: playerState.score,\n                            teammates: _getOtherPlayerIds(player.id, game),\n                            turns: gameData.turn,\n                            difficulty: gameData.difficulty,\n                            rulesetIds: gameData.rulesetIds,\n                        }, true);\n                    }", "                } catch (e: any) {\n                    console.error(e);\n                }\n\n                try {\n                    await gameEngineProvider.removePlayer(game.id, player.id, 'leave');\n                } catch {\n                    // Respect the player's request to leave even if the gameData couldn't be updated for some reason\n                }\n\n                if (!game.playersIds.size) {\n                    await finalizeGame(game.id, true, ds, gameEngineProvider, metrics);\n                }\n\n                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider) }];\n            }\n\n            case 'rankings': {\n                const rankings = await ds.Leaderboard.getTopN(20);\n                return [StatusCodes.ok, { rankings }];\n            }\n\n            case 'search': {\n                const player = await _expectAuthPlayerNotInGame(req);\n\n                // Don't need to validate nft ownership yet, either join() or create() will do this\n                const deck = await _expectValidActiveDeck(player, false);\n\n                let ct: any = undefined;\n                do {\n                    const result = await ds.CoopGames.queryByGameState('open', 10, ct);\n                    const games = result.items.sort((a, b) => a.ingorePlayerIds.size - b.ingorePlayerIds.size);\n", "                if (!game.playersIds.size) {\n                    await finalizeGame(game.id, true, ds, gameEngineProvider, metrics);\n                }\n\n                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider) }];\n            }\n\n            case 'rankings': {\n                const rankings = await ds.Leaderboard.getTopN(20);\n                return [StatusCodes.ok, { rankings }];\n            }\n\n            case 'search': {\n                const player = await _expectAuthPlayerNotInGame(req);\n\n                // Don't need to validate nft ownership yet, either join() or create() will do this\n                const deck = await _expectValidActiveDeck(player, false);\n\n                let ct: any = undefined;\n                do {\n                    const result = await ds.CoopGames.queryByGameState('open', 10, ct);\n                    const games = result.items.sort((a, b) => a.ingorePlayerIds.size - b.ingorePlayerIds.size);\n", "                    for (const game of games) {\n                        if (game.playersIds.size < 2 && !game.ingorePlayerIds.has(player.id)) {\n                            const gameData = await ds.GameData.get(game.id);\n\n                            if (!gameData || !game.playersIds.size) {\n                                // GameData already TTL'd this is a dead session\n                                await finalizeGame(game.id, true, ds, gameEngineProvider, metrics);\n                                continue;\n                            }\n\n                            if (gameData.players.size >= 2 || (gameData.state !== 'created' && gameData.state !== 'started')) {\n                                // Game is full or not in a joinable state\n                                continue;\n                            }\n", "                            if (gameData.players.size >= 2 || (gameData.state !== 'created' && gameData.state !== 'started')) {\n                                // Game is full or not in a joinable state\n                                continue;\n                            }\n\n                            if (await rateLimit.shouldRateLimitSearchGame(player.id)) {\n                                return [StatusCodes.tooManyRequests];\n                            }\n                            return await handler(['join'], {}, { teammateDid: [...gameData.pendingPlayers.keys()][0] || [...gameData.players.keys()][0], fromMatchmaking: true }, req);\n                        }\n                    }\n\n                    ct = result.ct;", "                } while (ct);\n\n                // No joinable game found - proceed to create a public game\n\n                const difficulty = body?.difficulty || (1 + (deck.cards.map(appraiseCard).reduce((sum, x) => sum + x.tier, 0) / deck.cards.length) | 0);\n\n                return await handler(['create'], {}, { gameVisibility: 'public', difficulty }, req);\n            }\n\n            case 'start': {\n                const { game } = await _expectAuthPlayerInGame(req);\n                const gameData = await ds.GameData.get(game.id);", "                if (gameData?.state !== 'created') {\n                    return [StatusCodes.forbidden];\n                }\n\n                await _onGameStart(game, false);\n\n                return [StatusCodes.ok];\n            }\n        }\n        return;\n    }\n\n", "    async function _onGameStart(game: IDataSource.ICoopGame, fromMatchmaking: boolean) {\n        const gameData = await gameEngineProvider.startGame(game.id);\n\n        const now = moment.utc();\n        game.startedAt = now.format(FULL_DATETIME_FORMAT);\n        game._dbTtl = 9999999999;\n        await ds.CoopGames.update.exec(game);\n\n        metrics?.gameStarted(game.id, gameData.rulesetIds[0] || 'unknown', [...gameData.players.keys()], fromMatchmaking);\n    }\n", "    async function _expectAuthPlayerInGame(req: IHttpRequest) {\n        const player = await authProvider.getPlayerFromRequest(req);\n        if (!player.activeGameId) throw new RouteError(StatusCodes.forbidden, 'player has no active game id');\n\n        const game = await ds.CoopGames.get(player.activeGameId);\n        if (game) {\n            return {\n                player,\n                game,\n            };\n        }\n\n        player.activeGameId = '';\n        await ds.Players.update.exec(player);\n        throw new RouteError(StatusCodes.forbidden, 'player is not in game');\n    }\n", "    async function _expectAuthPlayerNotInGame(req: IHttpRequest) {\n        const player = await authProvider.getPlayerFromRequest(req);\n        if (player.activeGameId) throw new RouteError(StatusCodes.forbidden, 'player has an active game id');\n        return player;\n    }\n\n    async function _expectCoopGameJoinable(gameId: string) {\n        const game = await ds.CoopGames.get(gameId);\n        if (!game) throw new RouteError(StatusCodes.forbidden, 'game not found');\n        if (game.playersIds.size >= 2) throw new RouteError(StatusCodes.forbidden, 'game is full');\n        if (game.endedAt) throw new RouteError(StatusCodes.forbidden, 'game has ended');\n        return game;\n    }\n", "        if (!game) throw new RouteError(StatusCodes.forbidden, 'game not found');\n        if (game.playersIds.size >= 2) throw new RouteError(StatusCodes.forbidden, 'game is full');\n        if (game.endedAt) throw new RouteError(StatusCodes.forbidden, 'game has ended');\n        return game;\n    }\n\n    async function _expectValidActiveDeck(player: IDataSource.IPlayer, validateNftOwnership: boolean) {\n        const deck = await getOrCreateActiveDeck(player, ds);\n        if (!deck) throw new RouteError(StatusCodes.forbidden, 'player has no active deck');\n\n        if (validateNftOwnership) {\n            const nfts = await Promise.all(deck.cards.map(x => ExtDeps.getNft(x.nftId)));", "        if (!deck) throw new RouteError(StatusCodes.forbidden, 'player has no active deck');\n\n        if (validateNftOwnership) {\n            const nfts = await Promise.all(deck.cards.map(x => ExtDeps.getNft(x.nftId)));\n            if (nfts.find(x => !x || x.nft.did !== player.id)) {\n                metrics?.nftOwnershipConflict(player.id);\n                throw new RouteError(StatusCodes.conflict, 'some cards do not belong to the did');\n            }\n        }\n\n        return deck;\n    }\n};\n\n", "export async function finalizeGame(gameId: string, removePlayers: boolean, ds: IDataSource, gameEngineProvider: GameEngineProvider, metrics?: IMetricsProvider) {\n    const game = await ds.CoopGames.get(gameId);\n    if (!game) throw new Error('game not found: ' + gameId);\n    if (game.gameState.startsWith('ended')) return;\n\n\n    const now = moment.utc();\n    game.gameState = `ended_${now.format(DATE_FORMAT)}`;\n    game.endedAt = now.format(FULL_DATETIME_FORMAT);\n    let gameData: GameEngine.IGameData | undefined = undefined;\n\n    let gameResult: IDataSource.IPlayerCoopGame['gameResult'] = 'unknown';", "    try {\n        gameData = await gameEngineProvider.getGameData(game.id);\n        gameResult = _getGameResult(gameData);\n    } catch { }\n\n    metrics?.gameEnded(\n        game.id,\n        gameResult,\n        gameData?.rulesetIds || [],\n        [...game.playersIds], gameData?.turn || -1, [...gameData?.players.values() || []].reduce((sum, x) => sum + x.score, 0),\n    );\n\n    const playerUpdates = (await Promise.all([...game.playersIds].map(async playerId => {\n        const player = await ds.Players.get(playerId);", "        if (!player) {\n            console.error(`_onGameEnd: player ${playerId} in ${game.id} not found`);\n            return;\n        }\n        if (player.activeGameId === game.id) {\n            removePlayers && (player.activeGameId = '');\n\n            const playerState = gameData?.players.get(playerId);\n            if (playerState?.score) {\n                player.score += playerState?.score || 0;\n                await ds.Leaderboard.set(player.id, player.score);\n            }\n\n            return [\n                ds.PlayerCoopGames.update.make({\n                    playerId,\n                    endedAt: game.endedAt,\n                    gameId: game.id,\n                    gameResult,\n                    score: playerState?.score || 0,\n                    teammates: _getOtherPlayerIds(playerId, game),\n                    turns: gameData?.turn || -1,\n                    difficulty: game.difficulty,\n                    rulesetIds: gameData?.rulesetIds || [],\n                }, true),\n                ds.Players.update.make(player, true),\n            ];\n        }\n        return;\n    }))).filter(Boolean).flat();\n\n    await ds.execUpdates(\n        ...playerUpdates,\n        ds.CoopGames.update.make(game),\n    );\n", "            if (playerState?.score) {\n                player.score += playerState?.score || 0;\n                await ds.Leaderboard.set(player.id, player.score);\n            }\n\n            return [\n                ds.PlayerCoopGames.update.make({\n                    playerId,\n                    endedAt: game.endedAt,\n                    gameId: game.id,\n                    gameResult,\n                    score: playerState?.score || 0,\n                    teammates: _getOtherPlayerIds(playerId, game),\n                    turns: gameData?.turn || -1,\n                    difficulty: game.difficulty,\n                    rulesetIds: gameData?.rulesetIds || [],\n                }, true),\n                ds.Players.update.make(player, true),\n            ];\n        }\n        return;\n    }))).filter(Boolean).flat();\n\n    await ds.execUpdates(\n        ...playerUpdates,\n        ds.CoopGames.update.make(game),\n    );\n", "    try {\n        await gameEngineProvider.endGame(game.id);\n    } catch {\n    }\n}\n\nfunction _getGameResult(gameData: GameEngine.IGameData): IDataSource.IPlayerCoopGame['gameResult'] {\n    switch (gameData.state) {\n        case 'abandoned': return 'abandoned';\n        case 'players_lost': return 'loss';\n        case 'players_won': return 'win';\n        case 'started': return 'abandoned';\n        default:\n            return 'unknown';\n    }\n}\n", "function _getOtherPlayerIds(playerId: string, game: IDataSource.ICoopGame) {\n    return [\n        ...[...game.playersIds.keys()].filter(x => x !== playerId),\n        // ...[...game.ingorePlayerIds.keys()].filter(x => x !== playerId),\n    ];\n}"]}
{"filename": "src/apis/players.api.ts", "chunked_list": ["import * as moment from 'moment';\nimport { z } from 'zod';\nimport { IAuthProvider, IDataSource, IMetricsProvider } from '../dependencies';\nimport { ExtDeps } from '../external-dependencies';\nimport { toClientPlayer } from '../models';\nimport { IHttpRouteHandler, StatusCodes } from '../net-utils';\nimport { FULL_DATETIME_FORMAT } from '../utils';\n\nexport const createPlayerHandler = (ds: IDataSource, authProvider: IAuthProvider, metrics?: IMetricsProvider): IHttpRouteHandler =>\n    async (path, _query, body, req) => {", "export const createPlayerHandler = (ds: IDataSource, authProvider: IAuthProvider, metrics?: IMetricsProvider): IHttpRouteHandler =>\n    async (path, _query, body, req) => {\n        switch (path[0]) {\n            case 'connectDid': {\n                const schema = z.object({\n                    didProof: z.object({\n                        latestCoinId: z.string(),\n                        pubkey: z.string(),\n                        signature: z.string(),\n                    }),", "                        signature: z.string(),\n                    }),\n                });\n\n                const payload = schema.parse(body);\n\n                const did = (await ExtDeps.verifyDidProof({\n                    ...payload.didProof,\n                    message: 'Proof of DID ownership for ChiaTCG',\n                }))?.did;\n                if (!did) {\n                    return [StatusCodes.unauthorized, { reason: 'unable to validate did proof' }];\n                }\n\n                let player = await ds.Players.get(did);\n                const isNew = !player;\n                const now = moment.utc();\n                const newSecret = authProvider.generateNewSecret();\n                const newAuthExpireAt = moment.utc(now).add({ days: 14 }).format(FULL_DATETIME_FORMAT);", "                    message: 'Proof of DID ownership for ChiaTCG',\n                }))?.did;\n                if (!did) {\n                    return [StatusCodes.unauthorized, { reason: 'unable to validate did proof' }];\n                }\n\n                let player = await ds.Players.get(did);\n                const isNew = !player;\n                const now = moment.utc();\n                const newSecret = authProvider.generateNewSecret();\n                const newAuthExpireAt = moment.utc(now).add({ days: 14 }).format(FULL_DATETIME_FORMAT);", "                if (!player) {\n                    const nowStr = now.format(FULL_DATETIME_FORMAT);\n                    player = await ds.Players.update.exec({\n                        id: did,\n                        createdAt: nowStr,\n                        lastSeenAt: nowStr,\n                        secret: newSecret,\n                        authExpiresAt: newAuthExpireAt,\n                        activeGameId: '',\n                        activeDeckId: 'default',\n                        score: 0,\n                    });\n                    metrics?.newUser(player.id);\n                } else {\n                    ds.Leaderboard.set(player.id, player.score);\n                    player.secret = newSecret;\n                    player.authExpiresAt = newAuthExpireAt;\n                    await ds.Players.update.exec(player);\n                }\n\n                return [StatusCodes.ok, {\n                    player: toClientPlayer(player, authProvider),\n                    status: isNew ? 'new' : 'existing',\n                }];\n            }\n\n            case 'me': {\n                const player = await authProvider.getPlayerFromRequest(req);\n                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider) }];\n            }\n        }\n        return;\n    };"]}
{"filename": "src/tests/appraise.test.ts", "chunked_list": ["import { randomInt } from 'crypto';\nimport { appraiseCard } from '../appraise';\n\nconst excludedChars = ['1', 'b', 'i', 'o'];\nconst testSize = 1000000;\n\nfunction generateId() {\n    let id = 'nft1'.padEnd(54, '_');\n    while (id.length < 62) {\n        const i = randomInt(0, 36);\n        let c: string;", "    while (id.length < 62) {\n        const i = randomInt(0, 36);\n        let c: string;\n        if (i >= 10) {\n            c = String.fromCharCode(97 + i - 10);\n        } else {\n            c = String.fromCharCode(48 + i);\n        }\n\n        if (!excludedChars.includes(c)) {\n            id += c;\n        }\n    }\n    id = id.substring(0, 55) + (Math.random() < 0.5 ? 's' : 'q') + id.substring(56);\n    return id;\n}\n\ntest('appraiseCard', () => {\n    const results = {\n        factions: {\n            backdoor: 0,\n            bruteforce: 0,\n            malware: 0,\n        },\n        scripts: {\n            bd_exploit: 0,\n            bd_decode: 0,\n            bd_secure: 0,\n            bf_firewall: 0,\n            bf_overclock: 0,\n            bf_spam: 0,\n            mw_redirect: 0,\n            mw_freeware: 0,\n            mw_worm: 0,\n        },\n        tiers: [0, 0, 0, 0, 0, 0, 0],\n        cpu: 0,\n        mem: 0,\n    };\n", "        if (!excludedChars.includes(c)) {\n            id += c;\n        }\n    }\n    id = id.substring(0, 55) + (Math.random() < 0.5 ? 's' : 'q') + id.substring(56);\n    return id;\n}\n\ntest('appraiseCard', () => {\n    const results = {\n        factions: {\n            backdoor: 0,\n            bruteforce: 0,\n            malware: 0,\n        },\n        scripts: {\n            bd_exploit: 0,\n            bd_decode: 0,\n            bd_secure: 0,\n            bf_firewall: 0,\n            bf_overclock: 0,\n            bf_spam: 0,\n            mw_redirect: 0,\n            mw_freeware: 0,\n            mw_worm: 0,\n        },\n        tiers: [0, 0, 0, 0, 0, 0, 0],\n        cpu: 0,\n        mem: 0,\n    };\n", "    for (let i = 0; i < testSize; i++) {\n        const card = appraiseCard({ nftId: generateId(), mintHeight: 1, url: '' });\n        results.factions[card.faction]++;\n        results.tiers[card.tier]++;\n        results.cpu += card.cpu;\n        results.mem += card.mem;\n        results.scripts[card.coreScript]++;\n\n        if (card.cpu + card.mem !== card.tier + 2) {\n            // This assertion is not done using expect() as it would slow down the test too much\n            throw new Error('CPU + MEM is expected to be Tier + 2');\n        }\n    }\n\n    expect(results.factions.bruteforce / results.factions.malware).toBeCloseTo(1, 1);\n    expect(results.factions.bruteforce / results.factions.backdoor).toBeCloseTo(1.1, 1);\n    expect(results.cpu / results.mem).toBeCloseTo(1);\n\n    expect(results.scripts.bd_decode / results.scripts.bd_exploit).toBeCloseTo(1, 1);\n    expect(results.scripts.bd_decode / results.scripts.bd_secure).toBeCloseTo(1, 1);\n    expect(results.scripts.bf_firewall / results.scripts.bf_overclock).toBeCloseTo(1, 1);\n    expect(results.scripts.bf_firewall / results.scripts.bf_spam).toBeCloseTo(1, 1);\n    expect(results.scripts.mw_redirect / results.scripts.mw_freeware).toBeCloseTo(1, 1);\n    expect(results.scripts.mw_redirect / results.scripts.mw_worm).toBeCloseTo(1, 1);\n\n    expect(results.tiers[1]! / testSize).toBeCloseTo(.46156);\n    expect(results.tiers[2]! / testSize).toBeCloseTo(.31667);\n    expect(results.tiers[3]! / testSize).toBeCloseTo(.16521);\n    expect(results.tiers[4]! / testSize).toBeCloseTo(.04849);\n    expect(results.tiers[5]! / testSize).toBeCloseTo(.00759, 3);\n    // Cannot reliably test T6 as the numbers are so small but if T1-T5 pass then by process of elimination we can assert T6 is correct\n});", "        if (card.cpu + card.mem !== card.tier + 2) {\n            // This assertion is not done using expect() as it would slow down the test too much\n            throw new Error('CPU + MEM is expected to be Tier + 2');\n        }\n    }\n\n    expect(results.factions.bruteforce / results.factions.malware).toBeCloseTo(1, 1);\n    expect(results.factions.bruteforce / results.factions.backdoor).toBeCloseTo(1.1, 1);\n    expect(results.cpu / results.mem).toBeCloseTo(1);\n\n    expect(results.scripts.bd_decode / results.scripts.bd_exploit).toBeCloseTo(1, 1);\n    expect(results.scripts.bd_decode / results.scripts.bd_secure).toBeCloseTo(1, 1);\n    expect(results.scripts.bf_firewall / results.scripts.bf_overclock).toBeCloseTo(1, 1);\n    expect(results.scripts.bf_firewall / results.scripts.bf_spam).toBeCloseTo(1, 1);\n    expect(results.scripts.mw_redirect / results.scripts.mw_freeware).toBeCloseTo(1, 1);\n    expect(results.scripts.mw_redirect / results.scripts.mw_worm).toBeCloseTo(1, 1);\n\n    expect(results.tiers[1]! / testSize).toBeCloseTo(.46156);\n    expect(results.tiers[2]! / testSize).toBeCloseTo(.31667);\n    expect(results.tiers[3]! / testSize).toBeCloseTo(.16521);\n    expect(results.tiers[4]! / testSize).toBeCloseTo(.04849);\n    expect(results.tiers[5]! / testSize).toBeCloseTo(.00759, 3);\n    // Cannot reliably test T6 as the numbers are so small but if T1-T5 pass then by process of elimination we can assert T6 is correct\n});"]}
{"filename": "src/game/card-script-parts.ts", "chunked_list": ["import { CardMod } from './card-mods';\nimport { CardScript } from './card-scripts';\nimport { GameEngine } from './game-engine';\nimport { GameEngineUtils } from './game-engine-utils';\n\nexport namespace CardScriptParts {\n    export interface IScriptPart {\n        (engine: GameEngine.IGameEngine, sourceCard: GameEngine.ICardState, targetCard: GameEngine.ICardState): void;\n    }\n\n    export const _Chance = (chance: number, curriedPart: IScriptPart): IScriptPart =>\n        (engine, sourceCard, targetCard) => {", "            if (Math.random() < chance) {\n                curriedPart(engine, sourceCard, targetCard);\n            }\n        };\n\n    export const _TargetHasMod = <T extends CardMod.ModLibrary, K extends keyof T>(modName: K, curry: (mod: InstanceType<T[K]>) => IScriptPart): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            const mod = targetCard.mods.find(x => x[0] === modName);\n            if (mod) {\n                curry(CardMod.deserialize(engine, mod) as InstanceType<T[K]>)(engine, sourceCard, targetCard);\n            }\n        };\n\n    export const AddMod = (mod: CardMod): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            CardMod.addMod(engine, targetCard, mod, sourceCard);\n        };\n\n    export const Attack = (damage: number, dontTriggerOut = false, dontTriggerIn = false): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            const secExceeded = SecDmg(damage, dontTriggerOut, dontTriggerIn)(engine, sourceCard, targetCard) as unknown;", "            if (mod) {\n                curry(CardMod.deserialize(engine, mod) as InstanceType<T[K]>)(engine, sourceCard, targetCard);\n            }\n        };\n\n    export const AddMod = (mod: CardMod): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            CardMod.addMod(engine, targetCard, mod, sourceCard);\n        };\n\n    export const Attack = (damage: number, dontTriggerOut = false, dontTriggerIn = false): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            const secExceeded = SecDmg(damage, dontTriggerOut, dontTriggerIn)(engine, sourceCard, targetCard) as unknown;", "            if (secExceeded) {\n                MemDmg(1)(engine, sourceCard, targetCard);\n            }\n        };\n\n    export const SecDmg = (secDmg: number, dontTriggerOut = false, dontTriggerIn = false): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            let resolvedDamage = secDmg;\n            if (!dontTriggerOut) {\n                resolvedDamage += GameEngineUtils.triggerMods('onSecDamageOut', { engine, sourceCard, contextCard: targetCard }, resolvedDamage)\n                    .reduce((sum, x) => sum + (!!x ? x.secDmgBonus : 0), 0);\n            }\n", "            if (!dontTriggerOut) {\n                resolvedDamage += GameEngineUtils.triggerMods('onSecDamageOut', { engine, sourceCard, contextCard: targetCard }, resolvedDamage)\n                    .reduce((sum, x) => sum + (!!x ? x.secDmgBonus : 0), 0);\n            }\n\n            if (!dontTriggerIn) {\n                resolvedDamage += GameEngineUtils.triggerMods('onSecDamageIn', { engine, sourceCard: targetCard, contextCard: sourceCard }, resolvedDamage, sourceCard)\n                    .reduce((sum, x) => sum + (!!x ? x.secDmgBonus : 0), 0);\n            }\n\n            if (CardMod.findModOfType(targetCard, CardMod.Content.impervious)) {\n                return false;\n            }\n\n            resolvedDamage = Math.max(0, resolvedDamage);\n\n            const secExceeded = resolvedDamage > targetCard.sec;\n            GameEngineUtils.changeSec(engine, targetCard, -resolvedDamage, false, sourceCard);\n            return secExceeded;\n        };\n\n    export const MemDmg = (memDmg: number): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            GameEngineUtils.triggerMods('onMemDmgOut', { engine, sourceCard, contextCard: targetCard }, memDmg);\n            GameEngineUtils.triggerMods('onMemDmgIn', { engine, sourceCard: targetCard, contextCard: sourceCard }, memDmg);\n", "            if (CardMod.findModOfType(targetCard, CardMod.Content.impervious)) {\n                return false;\n            }\n\n            resolvedDamage = Math.max(0, resolvedDamage);\n\n            const secExceeded = resolvedDamage > targetCard.sec;\n            GameEngineUtils.changeSec(engine, targetCard, -resolvedDamage, false, sourceCard);\n            return secExceeded;\n        };\n\n    export const MemDmg = (memDmg: number): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            GameEngineUtils.triggerMods('onMemDmgOut', { engine, sourceCard, contextCard: targetCard }, memDmg);\n            GameEngineUtils.triggerMods('onMemDmgIn', { engine, sourceCard: targetCard, contextCard: sourceCard }, memDmg);\n", "            if (CardMod.findModOfType(targetCard, CardMod.Content.impervious)) {\n                return;\n            }\n\n            targetCard.mem -= memDmg;\n            engine.broadcast.push({\n                type: 'memDamage',\n                cardId: targetCard.id,\n                newMem: targetCard.mem,\n                value: -memDmg,\n            });\n\n            const player = GameEngineUtils.findPlayerByCardIdMaybe(engine.gameData, sourceCard.id);\n            player && (player.stats.memDmg += memDmg);\n", "            if (targetCard.mem <= 0) {\n                GameEngineUtils.removeCard(engine, targetCard, sourceCard);\n            }\n        };\n\n    export const ChangeCpu = (cpuDelta: number): IScriptPart =>\n        (engine, _sourceCard, targetCard) => {\n            GameEngineUtils.changeCpu(engine, targetCard, cpuDelta);\n        };\n\n    export const RaiseMem = (memBonus: number): IScriptPart =>\n        (engine, _sourceCard, targetCard) => {\n            targetCard.mem += memBonus;\n            engine.broadcast.push({\n                type: 'memBonus',\n                cardId: targetCard.id,\n                newMem: targetCard.mem,\n                value: memBonus,\n            });\n        };\n\n    export const RaiseSec = (secBonus: number): IScriptPart =>\n        (engine, sourceCard, targetCard) => {\n            GameEngineUtils.changeSec(engine, targetCard, secBonus, false, sourceCard);\n        };\n\n    export const RedirectIntentRandom: IScriptPart =\n        (engine, _sourceCard, targetCard) => {", "            if (!GameEngineUtils.isEnemyCard(engine.gameData, targetCard) || !targetCard.intent) return;\n\n            const script = CardScript.deserialize(engine, targetCard, targetCard.intent.scriptData);\n            if (script.targetFinder === CardScript.TargetFinders.Self) return;\n\n            const targets = script.targetFinder(engine.gameData, targetCard);\n            if (!targets.length || (targets.length === 1 && targets[0]?.id === targetCard.intent.targetCardId)) return;\n\n            const origTargetId = targetCard.intent.targetCardId;\n            while (targetCard.intent.targetCardId === origTargetId) {\n                targetCard.intent.targetCardId = targets.random().id;\n            }\n\n            engine.broadcast.push({\n                type: 'cardIntent',\n                cardId: targetCard.id,\n                intent: targetCard.intent,\n            });\n        };\n\n    export const RemoveMod = <T extends CardMod.ModLibrary, K extends (keyof T & string)>(modName: K, mustRemove = false): IScriptPart =>\n        (engine, sourceCard, targetCard) => {", "            while (targetCard.intent.targetCardId === origTargetId) {\n                targetCard.intent.targetCardId = targets.random().id;\n            }\n\n            engine.broadcast.push({\n                type: 'cardIntent',\n                cardId: targetCard.id,\n                intent: targetCard.intent,\n            });\n        };\n\n    export const RemoveMod = <T extends CardMod.ModLibrary, K extends (keyof T & string)>(modName: K, mustRemove = false): IScriptPart =>\n        (engine, sourceCard, targetCard) => {", "            if (mustRemove) {\n                if (!targetCard.mods.find(x => x[0] === modName)) {\n                    throw new Error(`Could not find [${modName}] to remove`);\n                }\n            }\n            CardMod.removeModByName(engine, targetCard, modName, sourceCard);\n        };\n\n    export const SpawnEnemy = (enemyClass: string, spawnPosition?: 'relLeft' | 'relRight' | 'absLeft' | 'absRight', generateIntent = false): IScriptPart =>\n        (engine, sourceCard, _targetCard) => {\n            let spawnIndex = engine.gameData.enemies.findIndex(x => x.id === sourceCard.id);\n            switch (spawnPosition) {\n                case 'absLeft': spawnIndex = 0; break;\n                case 'absRight': spawnIndex = engine.gameData.enemies.length; break;\n                case 'relRight': spawnIndex++; break;\n            }\n            GameEngineUtils.spawnEnemy(engine, enemyClass, spawnIndex, generateIntent);\n        };\n}"]}
{"filename": "src/game/card-mods.ts", "chunked_list": ["import { CardScript } from './card-scripts';\nimport { GameEngine } from './game-engine';\nimport { GameEngineUtils } from './game-engine-utils';\n\nexport abstract class CardMod {\n    duration = -1;\n    stackingConfig: Parameters<typeof CardMod['makeStackingData']>[0] = { behavior: CardMod.StackingBehavior.neverReplace };\n\n    readonly modName: string;\n\n    constructor(\n        private _extraModData?: IArguments,\n    ) {\n        this.modName = this.constructor.name;\n    }\n\n    onSecDamageIn?(deps: CardMod.ICardModDeps, damage: number, attacker: GameEngine.ICardState): { secDmgBonus: number } | void;\n    onSecDamageOut?(deps: CardMod.ICardModDeps, baseDmg: number): { secDmgBonus: number } | void;\n\n    onMemDmgIn?(deps: CardMod.ICardModDeps, memDmg: number): void;\n    onMemDmgOut?(deps: CardMod.ICardModDeps, memDmg: number): void;\n\n    onInitMod?(deps: CardMod.ICardModDeps): void;\n    onRemoveMod?(deps: CardMod.ICardModDeps): void;\n    onCardDestroyed?(deps: CardMod.ICardModDeps): void;\n    onStackMod?(deps: CardMod.ICardModDeps, stackDelta: number): void;\n    onTurnStart?(deps: CardMod.ICardModDeps): void;\n    onTurnEnd?(deps: CardMod.ICardModDeps): void;\n    onEnemyDestroyed?(deps: CardMod.ICardModDeps): void;\n\n    serialize() {\n        const stackingData = CardMod.makeStackingData(this.stackingConfig);\n        const modData = [this.modName, stackingData] as CardMod.ModData;\n        (this.duration >= 0) && (modData.push(CardMod.makeDurationData(this.duration)));\n        this._extraModData && modData.push(...this._extraModData);\n        return modData;\n    }\n\n    static addMod(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, mod: CardMod, contextCard?: GameEngine.ICardState) {\n        const modData = mod.serialize();\n\n        switch (mod.stackingConfig.behavior) {\n            case CardMod.StackingBehavior.append: {\n                card.mods.push(modData);\n                break;\n            }\n\n            case CardMod.StackingBehavior.neverReplace: {\n                const existingModData = card.mods.find(x => x[0] === mod.modName);", "                if (existingModData) return;\n\n                card.mods.push(modData);\n                break;\n            }\n\n            case CardMod.StackingBehavior.ranked: {\n                const existingModData = card.mods.find(x => x[0] === mod.modName);\n                if (existingModData) {\n                    const existingStackingData = existingModData[1] as CardMod.RankedStackingData;\n                    if (existingStackingData[2] >= mod.stackingConfig.rank) {\n                        return;\n                    }\n                    this.removeMod(engine, card, existingModData, contextCard);", "                if (existingModData) {\n                    const existingStackingData = existingModData[1] as CardMod.RankedStackingData;\n                    if (existingStackingData[2] >= mod.stackingConfig.rank) {\n                        return;\n                    }\n                    this.removeMod(engine, card, existingModData, contextCard);\n                    if (card.isRemoved) return;\n                }\n                card.mods.push(modData);\n                break;\n            }\n\n            case CardMod.StackingBehavior.replace: {\n                const existingModData = card.mods.find(x => x[0] === mod.modName);", "                if (existingModData) {\n                    this.removeMod(engine, card, existingModData, contextCard);\n                    if (card.isRemoved) return;\n                }\n                card.mods.push(modData);\n                break;\n            }\n\n            case CardMod.StackingBehavior.stack: {\n                const existingModData = card.mods.find(x => x[0] === mod.modName);\n                if (existingModData) {\n                    const existingStackingData = existingModData[1] as CardMod.RankedStackingData;\n                    existingStackingData && (existingStackingData[2] += mod.stackingConfig.stackCount);\n                    engine.broadcast.push({\n                        type: 'modStackChanged',\n                        cardId: card.id,\n                        modData: existingModData,\n                        stackDelta: mod.stackingConfig.stackCount,\n                        newStackCount: existingStackingData[2],\n                    });\n                    this.trigger('onStackMod', existingModData, { engine, sourceCard: card, contextCard }, mod.stackingConfig.stackCount);\n                    return;\n                }\n                card.mods.push(modData);\n                break;\n            }\n        }\n\n        engine.broadcast.push({\n            type: 'modAdded',\n            cardId: card.id,\n            modData,\n        });\n        this.trigger('onInitMod', modData, { engine, sourceCard: card, contextCard });\n    }\n\n    static areEqual(left: CardMod.ModData, right: CardMod.ModData) {\n        // Caveat: could collide since join() flattens array but highly unlikely\n        return left.join('') === right.join('');\n    }\n\n    static deserialize(engine: GameEngine.IGameEngine, modData: CardMod.ModData) {\n        const modCtor = engine.ruleset.cardMods?.[modData[0]];", "                if (existingModData) {\n                    const existingStackingData = existingModData[1] as CardMod.RankedStackingData;\n                    existingStackingData && (existingStackingData[2] += mod.stackingConfig.stackCount);\n                    engine.broadcast.push({\n                        type: 'modStackChanged',\n                        cardId: card.id,\n                        modData: existingModData,\n                        stackDelta: mod.stackingConfig.stackCount,\n                        newStackCount: existingStackingData[2],\n                    });\n                    this.trigger('onStackMod', existingModData, { engine, sourceCard: card, contextCard }, mod.stackingConfig.stackCount);\n                    return;\n                }\n                card.mods.push(modData);\n                break;\n            }\n        }\n\n        engine.broadcast.push({\n            type: 'modAdded',\n            cardId: card.id,\n            modData,\n        });\n        this.trigger('onInitMod', modData, { engine, sourceCard: card, contextCard });\n    }\n\n    static areEqual(left: CardMod.ModData, right: CardMod.ModData) {\n        // Caveat: could collide since join() flattens array but highly unlikely\n        return left.join('') === right.join('');\n    }\n\n    static deserialize(engine: GameEngine.IGameEngine, modData: CardMod.ModData) {\n        const modCtor = engine.ruleset.cardMods?.[modData[0]];", "        if (!modCtor) throw new Error('mod not found: ' + modData.join());\n\n        const durationData = this.findDurationData(modData);\n        const mod = new modCtor(...modData.slice(durationData ? 3 : 2));\n        durationData && (mod.duration = durationData[1]);\n\n        const stackingData = modData[1];\n        mod.stackingConfig.behavior = stackingData[1];\n        switch (stackingData[1]) {\n            case CardMod.StackingBehavior.ranked:\n                (mod.stackingConfig as any).rank = stackingData[2];\n                break;\n            case CardMod.StackingBehavior.stack:\n                (mod.stackingConfig as any).stackCount = stackingData[2];\n                break;\n        }\n        return mod;\n    }\n\n    static findDurationData(modData: CardMod.ModData) {\n        const maybeDurationData = modData[2];\n        return (Array.isArray(maybeDurationData) && maybeDurationData[0] === '$duration') ? (modData[2] as CardMod.DurationData) : undefined;\n    }\n\n    static findModOfType(card: GameEngine.ICardState, modType: CardMod.ModConstructor) {\n        return card.mods.find(x => x[0] === modType.name);\n    }\n\n    static getStackCount(modData: CardMod.ModData) {\n        return modData[1][1] === CardMod.StackingBehavior.stack ? modData[1][2] : 0;\n    }\n\n    static makeDurationData(duration: number): CardMod.DurationData {\n        return ['$duration', duration];\n    }\n\n    static makeStackingData(\n        stackConfig: { behavior: CardMod.StackingBehavior.append }\n            | { behavior: CardMod.StackingBehavior.neverReplace }\n            | { behavior: CardMod.StackingBehavior.ranked, rank: number }\n            | { behavior: CardMod.StackingBehavior.replace }\n            | { behavior: CardMod.StackingBehavior.stack, stackCount: number }\n    ) {\n        const stackingData = ['$stack', stackConfig.behavior];\n        (stackConfig.behavior === CardMod.StackingBehavior.ranked) && stackingData.push(stackConfig.rank);\n        (stackConfig.behavior === CardMod.StackingBehavior.stack) && stackingData.push(stackConfig.stackCount);\n        return stackingData as CardMod.StackingData;\n    }\n\n    static removeMod(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, modData: CardMod.ModData, contextCard?: GameEngine.ICardState) {\n        engine.broadcast.push({\n            type: 'modRemoved',\n            cardId: card.id,\n            modData,\n        });\n", "        if (!card.mods.find(x => this.areEqual(x, modData))) {\n            throw new Error('mod not found');\n        }\n\n        this.trigger('onRemoveMod', modData, { engine, sourceCard: card, contextCard });\n        card.mods.findAndRemoveFirst(x => this.areEqual(x, modData));\n    }\n\n    static removeModByName<T extends CardMod.ModLibrary, K extends keyof T>(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, modName: K, contextCard?: GameEngine.ICardState) {\n        const mod = card.mods.find(x => x[0] === modName);\n        mod && this.removeMod(engine, card, mod, contextCard);\n    }\n\n    static trigger<T extends CardMod.ModEvent>(ev: T, modData: CardMod.ModData, ...args: Parameters<NonNullable<CardMod[typeof ev]>>) {\n        const deps = args[0];\n        const modDataFromCard = deps.sourceCard.mods.find(x => this.areEqual(x, modData));", "        if (!modDataFromCard) {\n            throw new Error(`card [${deps.sourceCard.id}] does not have mod [${modData.join()}], mods are ${deps.sourceCard.mods.join('|')}`);\n        }\n\n        const mod = this.deserialize(deps.engine, modDataFromCard);\n        const evnt = mod[ev];\n        const evntRetVal = evnt ? (evnt as any).apply(mod, args) : undefined;\n        if (deps.sourceCard.isRemoved) {\n            return;\n        }\n", "        if (ev === 'onTurnStart') {\n            const durationData = this.findDurationData(modDataFromCard);\n            if (durationData) {\n                if (durationData[1] > 1) {\n                    durationData[1]--;\n\n                    deps.engine.broadcast.push({\n                        type: 'modDurationChanged',\n                        cardId: deps.sourceCard.id,\n                        modData: modData,\n                        newDuration: durationData[1],\n                    });\n                } else {\n                    this.removeMod(deps.engine, deps.sourceCard, modData);\n                }\n            }\n        }\n        return evntRetVal as ReturnType<NonNullable<CardMod[T]>> | undefined;\n    }\n}\nexport namespace CardMod {", "    export type ModData = [string, StackingData, ...unknown[],];\n    export type DurationData = ['$duration', number];\n    export type EnemyModData = unknown[];\n    export type ModConstructor = TypeConstructor<CardMod>;\n    export type ModEvent = KeyOfFilteredByValueType<CardMod, ((deps: ICardModDeps, ...args: any) => any) | undefined> & StringsStartingWith<keyof CardMod, 'on'>;\n    export type ModLibrary = Record<string, ModConstructor>;\n\n    export type AppendStackingData = ['$stack', StackingBehavior.append];\n    export type NeverReplaceStackingData = ['$stack', StackingBehavior.neverReplace];\n    export type RankedStackingData = ['$stack', StackingBehavior.ranked, number];\n    export type ReplaceStackingData = ['$stack', StackingBehavior.replace];", "    export type NeverReplaceStackingData = ['$stack', StackingBehavior.neverReplace];\n    export type RankedStackingData = ['$stack', StackingBehavior.ranked, number];\n    export type ReplaceStackingData = ['$stack', StackingBehavior.replace];\n    export type StackStackingData = ['$stack', StackingBehavior.stack, number];\n    export type StackingData = AppendStackingData | NeverReplaceStackingData | RankedStackingData | ReplaceStackingData | StackStackingData;\n\n    export enum StackingBehavior {\n        append,\n        neverReplace,\n        ranked,\n        replace,\n        stack,\n    }\n", "    export interface ICardModDeps {\n        engine: GameEngine.IGameEngine;\n        sourceCard: GameEngine.ICardState;\n        contextCard?: GameEngine.ICardState;\n    }\n\n    export namespace Content {\n        // Defines a card modifier - the class name is treated as the mod name\n        export class backdoor extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.ranked as const,\n                rank: 0,\n            };\n\n            constructor(public damage: number) {\n                // Any extra data to serialize into this.modData as a 'memo' which can serve two purposes:\n                // 1) the client relies on the memo to display modifier effects in the UI instead calculating it independently\n                // 2) memo is passed back into the constructor during deserialization, useful for dynamic AI modifiers,\n                //      see _standardAi below for example\n                super(arguments);\n\n                this.stackingConfig.rank = damage;\n            }\n        }\n", "        export class backdoor extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.ranked as const,\n                rank: 0,\n            };\n\n            constructor(public damage: number) {\n                // Any extra data to serialize into this.modData as a 'memo' which can serve two purposes:\n                // 1) the client relies on the memo to display modifier effects in the UI instead calculating it independently\n                // 2) memo is passed back into the constructor during deserialization, useful for dynamic AI modifiers,\n                //      see _standardAi below for example\n                super(arguments);\n\n                this.stackingConfig.rank = damage;\n            }\n        }\n", "        export class diagnostics extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.stack as const,\n                stackCount: 0,\n            };\n\n            constructor(public secBonus: number, override duration: number) {\n                super(arguments);\n\n                this.stackingConfig.stackCount = secBonus;\n            }\n\n            override onTurnEnd(deps: ICardModDeps): void {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, this.stackingConfig.stackCount, false);\n            }\n        }\n", "        export class firewall extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.ranked as const,\n                rank: 0,\n            };\n\n            constructor(override duration: number) {\n                super(arguments);\n                this.stackingConfig.rank = duration;\n            }\n\n            override onInitMod(deps: ICardModDeps) {", "                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    return;\n                }\n\n                GameEngineUtils.revalidateIntents(deps.engine, true);\n            }\n        }\n\n        export class impervious extends CardMod {\n            constructor(override duration = -1) {\n                super(arguments);\n            }\n\n            override onSecDamageIn(_deps: ICardModDeps, _damage: number, _attacker: GameEngine.ICardState) {\n                return {\n                    secDmgBonus: -9999,\n                };\n            }\n        }\n", "        export class impervious extends CardMod {\n            constructor(override duration = -1) {\n                super(arguments);\n            }\n\n            override onSecDamageIn(_deps: ICardModDeps, _damage: number, _attacker: GameEngine.ICardState) {\n                return {\n                    secDmgBonus: -9999,\n                };\n            }\n        }\n", "        export class lag extends CardMod {\n            constructor(override duration: number) {\n                super(arguments);\n            }\n\n            override onInitMod(deps: CardMod.ICardModDeps) {\n                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, true);\n                }\n            }\n\n            override onTurnStart(deps: CardMod.ICardModDeps) {", "                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, true);\n                }\n            }\n\n            override onRemoveMod(deps: ICardModDeps): void {\n                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, false);\n                }\n            }\n        }\n", "                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, false);\n                }\n            }\n        }\n\n        export class offline extends CardMod {\n            constructor(override duration: number) {\n                super(arguments);\n            }\n\n            override onInitMod(deps: CardMod.ICardModDeps) {", "        export class offline extends CardMod {\n            constructor(override duration: number) {\n                super(arguments);\n            }\n\n            override onInitMod(deps: CardMod.ICardModDeps) {\n                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n                }\n                GameEngineUtils.revalidateIntents(deps.engine, GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard));\n            }\n\n            override onTurnStart(deps: CardMod.ICardModDeps) {", "                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, true);\n                }\n            }\n\n            override onRemoveMod(deps: ICardModDeps): void {\n                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, false);\n                }\n            }\n        }\n", "                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n                } else {\n                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, false);\n                }\n            }\n        }\n\n        export class secured extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.stack as const,\n                stackCount: 0,\n            };\n\n            constructor(public tempSecBonus: number, override duration: number) {\n                super(arguments);\n                this.stackingConfig.stackCount = tempSecBonus;\n            }\n\n            override onInitMod(deps: ICardModDeps) {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, this.stackingConfig.stackCount, false);\n            }\n\n            override onStackMod(deps: ICardModDeps, stackDelta: number): void {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, stackDelta, false);\n            }\n\n            override onRemoveMod(deps: ICardModDeps) {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, -this.stackingConfig.stackCount, true);\n            }\n        }\n", "        export class secured extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.stack as const,\n                stackCount: 0,\n            };\n\n            constructor(public tempSecBonus: number, override duration: number) {\n                super(arguments);\n                this.stackingConfig.stackCount = tempSecBonus;\n            }\n\n            override onInitMod(deps: ICardModDeps) {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, this.stackingConfig.stackCount, false);\n            }\n\n            override onStackMod(deps: ICardModDeps, stackDelta: number): void {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, stackDelta, false);\n            }\n\n            override onRemoveMod(deps: ICardModDeps) {\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, -this.stackingConfig.stackCount, true);\n            }\n        }\n", "        export class _waveBonus_extraMove extends CardMod {\n            override onInitMod(deps: ICardModDeps): void {\n                const player = GameEngineUtils.findPlayerByCardId(deps.engine.gameData, deps.sourceCard.id);\n                player.movesPerTurn++;\n                player.movesLeft = player.movesPerTurn;\n                deps.engine.broadcast.push({\n                    type: 'movesPerTurnsChange',\n                    playerId: player.id,\n                    newMovesLeft: player.movesLeft,\n                    newMovesPerTurn: player.movesPerTurn,\n                });\n            }\n        }\n", "        export class _winOnDeath extends CardMod {\n            override onCardDestroyed(deps: ICardModDeps) {\n                const player = deps.contextCard ? GameEngineUtils.findPlayerByCardIdMaybe(deps.engine.gameData, deps.contextCard.id) : null;\n                player && player.stats.kills++;\n                deps.engine.onWinGame();\n                player && player.stats.kills--;\n            }\n        }\n\n        export class _standardAi extends CardMod {\n            override onTurnStart(deps: ICardModDeps) {", "        export class _standardAi extends CardMod {\n            override onTurnStart(deps: ICardModDeps) {\n                if (!GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    throw new Error('not an enemy card');\n                }\n                GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n            }\n\n            override onTurnEnd(deps: ICardModDeps) {\n                if (!GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    throw new Error('not an enemy card');\n                }\n                GameEngineUtils.executeIntent(deps.engine, deps.sourceCard);\n            }\n        }\n", "                if (!GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n                    throw new Error('not an enemy card');\n                }\n                GameEngineUtils.executeIntent(deps.engine, deps.sourceCard);\n            }\n        }\n\n        export class _yieldScript extends CardMod {\n            constructor(\n                public scriptData: CardScript.ScriptData,\n                override duration: number,\n            ) {\n                super(arguments);\n            }\n\n            override onRemoveMod(deps: ICardModDeps) {\n                CardScript.addScript(deps.engine, deps.sourceCard, this.scriptData);\n            }\n        }\n", "        export class _waveTrigger extends CardMod {\n            constructor(\n                public rulesetIds: string[],\n                override duration = -1,\n            ) {\n                super(arguments);\n            }\n\n            override onInitMod(deps: ICardModDeps): void {\n                deps.engine.gameData.difficulty < 3 && GameEngineUtils.changeSec(deps.engine, deps.sourceCard, 25, true);\n            }\n\n            override onCardDestroyed(deps: ICardModDeps) {\n                deps.engine.onNextWave(this.rulesetIds.random());\n                deps.contextCard && CardMod.addMod(deps.engine, deps.contextCard, new _waveBonus_extraMove());\n            }\n\n            override onRemoveMod(deps: ICardModDeps): void {\n                CardMod.addMod(deps.engine, deps.sourceCard, new _winOnDeath());\n            }\n        }\n    }\n}\n"]}
{"filename": "src/game/card-scripts.ts", "chunked_list": ["import { CoreScriptNames } from '../appraise';\nimport { IPlayerPushProvider } from '../dependencies';\nimport { randInt, round } from '../utils';\nimport { CardMod } from './card-mods';\nimport { CardScriptParts } from './card-script-parts';\nimport { GameEngine } from './game-engine';\nimport { GameEngineUtils } from './game-engine-utils';\n\nexport class CardScript {\n    cooldownMax = -1;\n    cooldownCur = 0;\n\n    readonly scriptName: string;\n\n    constructor(\n        private _extraScriptData: unknown[],\n        public targetFinder: CardScript.ITargetFinder,\n        public targetScriptParts: { targetResolver: CardScript.ITargetResolver, parts: CardScriptParts.IScriptPart[] }[],\n    ) {\n        this.scriptName = this.constructor.name;\n    }\n\n    serialize() {\n        const retVal = [this.scriptName, ...this._extraScriptData] as CardScript.ScriptData;\n        (this.cooldownCur > 0 || this.cooldownMax > 0) && retVal.push(CardScript.makeCooldownData(this.cooldownMax, this.cooldownCur));\n        return retVal;\n    }\n\n    static addScript(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptData: CardScript.ScriptData) {\n        card.scripts.push(scriptData);\n        engine.broadcast.push({\n            type: 'scriptAdded',\n            cardId: card.id,\n            scriptData,\n        });\n    }\n\n    static areEqual(left: CardScript.ScriptData, right: CardScript.ScriptData) {\n        // Caveat: could collide since join() flattens array but highly unlikely\n        return left.join('') === right.join('');\n    }\n\n    static deserialize(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptData: CardScript.ScriptData) {\n        const scriptCtor = engine.ruleset.cardScripts?.[scriptData[0]];", "export class CardScript {\n    cooldownMax = -1;\n    cooldownCur = 0;\n\n    readonly scriptName: string;\n\n    constructor(\n        private _extraScriptData: unknown[],\n        public targetFinder: CardScript.ITargetFinder,\n        public targetScriptParts: { targetResolver: CardScript.ITargetResolver, parts: CardScriptParts.IScriptPart[] }[],\n    ) {\n        this.scriptName = this.constructor.name;\n    }\n\n    serialize() {\n        const retVal = [this.scriptName, ...this._extraScriptData] as CardScript.ScriptData;\n        (this.cooldownCur > 0 || this.cooldownMax > 0) && retVal.push(CardScript.makeCooldownData(this.cooldownMax, this.cooldownCur));\n        return retVal;\n    }\n\n    static addScript(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptData: CardScript.ScriptData) {\n        card.scripts.push(scriptData);\n        engine.broadcast.push({\n            type: 'scriptAdded',\n            cardId: card.id,\n            scriptData,\n        });\n    }\n\n    static areEqual(left: CardScript.ScriptData, right: CardScript.ScriptData) {\n        // Caveat: could collide since join() flattens array but highly unlikely\n        return left.join('') === right.join('');\n    }\n\n    static deserialize(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptData: CardScript.ScriptData) {\n        const scriptCtor = engine.ruleset.cardScripts?.[scriptData[0]];", "        if (!scriptCtor) throw new Error('script not found: ' + scriptData.join());\n\n        const script = new scriptCtor(card, ...scriptData.slice(1));\n        const cooldownData = CardScript.findCooldownData(scriptData);\n        if (cooldownData) {\n            script.cooldownCur = cooldownData[1];\n            script.cooldownMax = cooldownData[2];\n        }\n        return script;\n    }\n\n    static execute(engine: GameEngine.IGameEngine, sourceCard: GameEngine.ICardState, sourceCardScript: CardScript.ScriptData, targetCard: GameEngine.ICardState) {\n        engine.broadcast.push({\n            type: 'cardExecuting',\n            cardId: sourceCard.id,\n            targetCardId: targetCard.id,\n            scriptData: sourceCardScript,\n        });\n", "        if (this.isOnCooldown(sourceCardScript)) {\n            throw new Error('Script is on cooldown: ' + sourceCardScript.join());\n        }\n\n        const scriptDataFromCard = sourceCard.scripts.find(x => CardScript.areEqual(x, sourceCardScript));\n        const isEnemy = GameEngineUtils.isEnemyCard(engine.gameData, sourceCard);\n        if (!isEnemy) {\n            if (!scriptDataFromCard) {\n                throw new Error('PlayerCard does not have script: ' + sourceCardScript.join());\n            }\n        }\n\n        const cooldownData = CardScript.findCooldownData(scriptDataFromCard || sourceCardScript);", "        if (cooldownData) {\n            cooldownData[1] = cooldownData[2] + 1;\n        }\n\n        const script = this.deserialize(engine, sourceCard, sourceCardScript);\n        const targets = script.targetFinder(engine.gameData, sourceCard);\n        if (!isEnemy && (!targets.length || !targets.find(x => x.id === targetCard.id))) {\n            throw new Error('Invalid target ' + targets.map(x => x.id).join());\n        }\n\n        for (const pair of script.targetScriptParts) {\n            const resolvedTargets = pair.targetResolver(engine.gameData, sourceCard, targetCard);", "        for (const pair of script.targetScriptParts) {\n            const resolvedTargets = pair.targetResolver(engine.gameData, sourceCard, targetCard);\n            for (const part of pair.parts) {\n                for (const resolvedTarget of resolvedTargets) {\n                    if (resolvedTarget.isRemoved) continue;\n\n                    part(engine, sourceCard, resolvedTarget);\n                }\n            }\n        }\n\n        engine.broadcast.push({\n            type: 'cardExecuted',\n            cardId: sourceCard.id,\n            targetCardId: targetCard.id,\n            scriptData: scriptDataFromCard || sourceCardScript,\n        });\n    }\n\n    static findCooldownData(data: CardScript.ScriptData) {\n        return data.find((x): x is CardScript.CooldownData => Array.isArray(x) && x[0] === '$cooldown');\n    }\n\n    static fromScriptName(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptName: string) {\n        return this.deserialize(engine, card, [scriptName]).serialize();\n    }\n\n    static isOnCooldown(data: CardScript.ScriptData) {\n        return (this.findCooldownData(data)?.[1] || 0) > 0;\n    }\n\n    static makeCooldownData(max: number, cur = 0): CardScript.CooldownData {\n        return ['$cooldown', cur, max];\n    }\n\n    static removeScript(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptType: CardScript.ScriptConstructor) {\n        const removed = card.scripts.findAndRemoveFirst(x => x[0] === scriptType.name);", "        if (!removed) throw new Error('script not found: ' + scriptType.name);\n\n        engine.broadcast.push({\n            type: 'scriptRemoved',\n            cardId: card.id,\n            removedScript: scriptType.name,\n        });\n    }\n\n    static tickCooldowns(card: GameEngine.ICardState, broadcast: IPlayerPushProvider.IPushMessage[]) {\n        for (const script of card.scripts) {\n            const cooldownData = CardScript.findCooldownData(script);", "        for (const script of card.scripts) {\n            const cooldownData = CardScript.findCooldownData(script);\n            if (!cooldownData?.[1]) {\n                continue;\n            }\n\n            cooldownData[1]--;\n\n            broadcast.push({\n                type: 'scriptChanged',\n                cardId: card.id,\n                scriptData: script,\n            });\n        }\n    }\n}\nexport namespace CardScript {", "    export type ScriptData = [string, ...unknown[]];\n    export type CooldownData = ['$cooldown', number, number];\n    export type ScriptConstructor = { new(card: GameEngine.ICardState, ...args: any[]): CardScript };\n    export type ScriptLibrary = Record<string, ScriptConstructor>;\n\n    export interface ITargetResolver {\n        (gameData: GameEngine.IGameData, sourceCard: GameEngine.ICardState, targetCard: GameEngine.ICardState): GameEngine.ICardState[];\n    }\n\n    export interface ITargetFinder {\n        (gameData: GameEngine.IGameData, card: GameEngine.ICardState): GameEngine.ICardState[];\n    }\n\n    export namespace TargetResolvers {\n        export const Self: ITargetResolver = (_, sourceCard) => [sourceCard];\n\n        export const Target: ITargetResolver = (_, _2, targetCard) => [targetCard];\n\n        export const TargetAndAdjacents: ITargetResolver = (gameData, _, targetCard) => {\n            const cards = GameEngineUtils.isEnemyCard(gameData, targetCard) ? gameData.enemies : (GameEngineUtils.findPlayerByCardId(gameData, targetCard.id).cards);\n            const i = cards.findIndex(x => x.id === targetCard.id);\n            return [cards[i], cards[i - 1], cards[i + 1]].filter(Boolean);\n        };\n\n        export const AllAllies: ITargetResolver = (gameData, sourceCard) => {", "    export interface ITargetFinder {\n        (gameData: GameEngine.IGameData, card: GameEngine.ICardState): GameEngine.ICardState[];\n    }\n\n    export namespace TargetResolvers {\n        export const Self: ITargetResolver = (_, sourceCard) => [sourceCard];\n\n        export const Target: ITargetResolver = (_, _2, targetCard) => [targetCard];\n\n        export const TargetAndAdjacents: ITargetResolver = (gameData, _, targetCard) => {\n            const cards = GameEngineUtils.isEnemyCard(gameData, targetCard) ? gameData.enemies : (GameEngineUtils.findPlayerByCardId(gameData, targetCard.id).cards);\n            const i = cards.findIndex(x => x.id === targetCard.id);\n            return [cards[i], cards[i - 1], cards[i + 1]].filter(Boolean);\n        };\n\n        export const AllAllies: ITargetResolver = (gameData, sourceCard) => {", "            if (GameEngineUtils.isEnemyCard(gameData, sourceCard)) {\n                return TargetFinders._excludeOffline(gameData.enemies);\n            } else {\n                return TargetFinders._excludeOffline(GameEngineUtils.getPlayerCards(gameData));\n            }\n        };\n\n        export const RandomAlly: ITargetResolver = (gameData, sourceCard, targetCard) => {\n            return [AllAllies(gameData, sourceCard, targetCard).random()];\n        };\n\n        export const AllOpponents: ITargetResolver = (gameData, sourceCard) => {", "            if (GameEngineUtils.isEnemyCard(gameData, sourceCard)) {\n                return TargetFinders._excludeImperviousAndOffline(GameEngineUtils.getPlayerCards(gameData));\n            } else {\n                return TargetFinders._excludeImperviousAndOffline(gameData.enemies);\n            }\n        };\n\n        export const RandomOpponent: ITargetResolver = (gameData, sourceCard, targetCard) => {\n            return TargetFinders._excludeImperviousAndOffline([AllOpponents(gameData, sourceCard, targetCard).random()]);\n        };\n    }\n\n    export namespace TargetFinders {\n        export const Self: ITargetFinder = (_gameData, card) => [card];\n\n        export const Allies = (excludeSelf = false): ITargetFinder =>\n            (gameData, card) => {\n                let targets: GameEngine.ICardState[] = GameEngineUtils.isEnemyCard(gameData, card) ? gameData.enemies : GameEngineUtils.getPlayerCards(gameData);\n                excludeSelf && (targets = targets.filter(x => x.id !== card.id));\n                return _excludeOffline(targets);\n            };\n\n        export const Opponents = (ignoreTaunt = false): ITargetFinder =>\n            (gameData, card) => {\n                const targets = GameEngineUtils.isEnemyCard(gameData, card) ? GameEngineUtils.getPlayerCards(gameData) : gameData.enemies;\n                const standardTargets = _excludeImperviousAndOffline(targets);", "                if (!ignoreTaunt) {\n                    const taunts = _filterForFirewall(standardTargets);\n                    if (taunts.length) {\n                        return taunts;\n                    }\n                }\n                return standardTargets;\n            };\n\n        export const Any = (ignoreTaunt = false): ITargetFinder =>\n            (gameData, card) => [\n                ...Opponents(ignoreTaunt)(gameData, card),\n                ...Allies()(gameData, card),\n            ];\n\n        export const _ModFilter = <T extends CardMod.ModLibrary, K extends (keyof T & string)>(modFilter: K[], targetFinder: ITargetFinder): ITargetFinder =>\n            (gameData, card) => {\n                const targets = targetFinder(gameData, card);\n                const modMatches = targets.filter(target => target.mods.find(modData => modFilter.find(x => x === modData[0])));\n                return _excludeImperviousAndOffline(modMatches);\n            };\n\n        const _excludeImpervious = (cards: GameEngine.ICardState[]) => {\n            return cards.filter(x => !x.mods.find(y => y[0] === CardMod.Content.impervious.name));\n        };\n\n        export const _excludeOffline = (cards: GameEngine.ICardState[]) => {\n            return cards.filter(x => !x.mods.find(y => y[0] === CardMod.Content.offline.name));\n        };\n\n        export const _excludeImperviousAndOffline = (cards: GameEngine.ICardState[]) => _excludeImpervious(_excludeOffline(cards));\n\n        const _filterForFirewall = (cards: GameEngine.ICardState[]) => {\n            return cards.filter(x => x.mods.find(y => y[0] === CardMod.Content.firewall.name));\n        };\n    }\n\n    export namespace Content {", "        // Defines a card script - the class name is treated as the script name\n        export class bd_decode extends CardScript {\n            constructor(\n                // MUST always be the first parameter even if not used\n                card: GameEngine.ICardState,\n                // Not used but declared to show how the memo is passed back here, see first argument in super(...) below\n                _secDamage: number,\n            ) {\n                const secDamage = GameEngineUtils.scaleByCpuMem(12, card.cpu);\n                const bdChance = round(GameEngineUtils.scaleByCpuMem(20, card.mem, 'high') / 100, 2);\n                const bdDamage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\n                super(\n                    // Any extra data to serialize into scriptData[1:] as a 'memo' which can serve two purposes:\n                    // 1) the client relies on the memo to display potential card effects in the UI instead calculating it independently\n                    // 2) memo is passed back into the constructor during deserialization, useful for dynamic AI scripts\n                    [secDamage, bdChance, bdDamage],\n\n                    // Which cards are valid targets for this card; AI will typically .random()\n                    TargetFinders.Opponents(),\n\n                    // A composition of CardScriptParts that get executed when this card is played; this allows for\n                    // composition effects such as \"((damage and debuff) to target) AND (chance to stun neighbors)\":\n                    // The first part would use the Target resolver and Attack and ApplyMod parts\n                    // The second part would use the Neighbors resolver and curry Stun part into _Chance part\n                    [\n                        {\n                            // Given a chosen target, which actual targets these parts will execute on; this allows\n                            // a card to, for example, deal damage to the neighbors of the specified target\n                            targetResolver: TargetResolvers.Target,\n\n                            // CardScriptParts to execute on the resolved targets\n                            parts: [\n                                CardScriptParts.SecDmg(secDamage),\n                                CardScriptParts._Chance(bdChance,\n                                    CardScriptParts.AddMod(\n                                        new CardMod.Content.backdoor(bdDamage),\n                                    )\n                                ),\n                            ],\n                        }\n                    ],\n                );\n            }\n        }\n", "        export class bd_exploit extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const damage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n                const bdChance = round(GameEngineUtils.scaleByCpuMem(40, card.mem, 'more') / 100, 2);\n\n                super(\n                    [damage, bdChance],\n                    (gameData: GameEngine.IGameData, card: GameEngine.ICardState) => [\n                        ...TargetFinders.Opponents()(gameData, card),\n                        ...TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n                            TargetFinders.Opponents(true))(gameData, card),\n                    ],\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts._TargetHasMod<typeof CardMod.Content, 'backdoor'>('backdoor', mod => CardScriptParts.SecDmg(mod.stackingConfig.rank, true)),\n                                CardScriptParts.Attack(damage),\n                                CardScriptParts._Chance(bdChance,\n                                    CardScriptParts.AddMod(\n                                        new CardMod.Content.backdoor(damage),\n                                    )\n                                ),\n                            ],\n                        }\n                    ],\n                );\n            }\n        }\n", "        export class bd_secure extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const secBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\n                super(\n                    [secBonus],\n                    TargetFinders.Any(),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.RaiseSec(secBonus),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = 1;\n            }\n        }\n", "        export class bf_spam extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const damage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\n                super(\n                    [damage],\n                    TargetFinders.Opponents(),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.Attack(damage),\n                                CardScriptParts.Attack(damage),\n                            ],\n                        }\n                    ]\n                );\n            }\n        }\n", "        export class bf_firewall extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const secBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n                const modDuration = Math.ceil(card.mem / 2);\n\n                super(\n                    [secBonus, modDuration],\n                    TargetFinders.Self,\n                    [\n                        {\n                            targetResolver: TargetResolvers.Self,\n                            parts: [\n                                CardScriptParts.RaiseSec(secBonus),\n                                CardScriptParts.AddMod(\n                                    new CardMod.Content.firewall(modDuration),\n                                ),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = 1;\n            }\n        }\n", "        export class bf_overclock extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const damage = GameEngineUtils.scaleByCpuMem(17, card.cpu);\n                const lagChance = round((100 - GameEngineUtils.scaleByCpuMem(30, card.mem)) / 100, 2);\n                const lagDuration = 2;\n\n                super(\n                    [damage, lagChance, lagDuration],\n                    CardScript.TargetFinders.Opponents(),\n                    [\n                        {\n                            targetResolver: CardScript.TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.Attack(damage),\n                            ],\n                        },\n                        {\n                            targetResolver: CardScript.TargetResolvers.Self,\n                            parts: [\n                                CardScriptParts._Chance(lagChance,\n                                    CardScriptParts.AddMod(\n                                        new CardMod.Content.lag(lagDuration),\n                                    ),\n                                ),\n                            ],\n                        }\n                    ],\n                );\n            }\n        }\n", "        export class mw_freeware extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const minBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n                const maxBonus = GameEngineUtils.scaleByCpuMem(12, card.cpu, 'more');\n\n                super(\n                    [minBonus, maxBonus],\n                    TargetFinders.Any(),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.RaiseSec(randInt(minBonus, maxBonus)),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = 1;\n            }\n        }\n", "        export class mw_redirect extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const tempSecBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n                const duration = Math.ceil(card.mem / 2);\n\n                super(\n                    [tempSecBonus, duration],\n                    TargetFinders.Allies(true),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.AddMod(\n                                    new CardMod.Content.secured(tempSecBonus, duration),\n                                ),\n                                CardScriptParts.AddMod(\n                                    new CardMod.Content.firewall(duration),\n                                ),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = 1;\n            }\n        }\n", "        export class mw_worm extends CardScript {\n            constructor(card: GameEngine.ICardState) {\n                const minDamage = GameEngineUtils.scaleByCpuMem(7, card.cpu);\n                const maxDamage = GameEngineUtils.scaleByCpuMem(13, card.cpu);\n\n                super(\n                    [minDamage, maxDamage],\n                    TargetFinders.Opponents(),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.Attack(randInt(minDamage, maxDamage)),\n                            ],\n                        }\n                    ],\n                );\n            }\n        }\n", "        export class _attack extends CardScript {\n            constructor(card: GameEngine.ICardState, difficulty: number, strength: 'weak' | 'normal' | 'strong' = 'normal', cooldown = 0) {\n                let minDmg = 0;\n                let maxDmg = 0;\n                switch (strength) {\n                    case 'weak':\n                        minDmg = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n                        maxDmg = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n                        break;\n                    case 'normal':\n                        minDmg = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n                        maxDmg = GameEngineUtils.scaleByCpuMem(12, card.cpu);\n                        break;\n                    case 'strong':\n                        minDmg = GameEngineUtils.scaleByCpuMem(11, card.cpu);\n                        maxDmg = GameEngineUtils.scaleByCpuMem(15, card.cpu);\n                        break;\n                }\n                minDmg = GameEngineUtils.scaleByDifficulty(minDmg, difficulty);\n                maxDmg = GameEngineUtils.scaleByDifficulty(maxDmg, difficulty);\n\n                super(\n                    [difficulty, strength, cooldown, minDmg, maxDmg],\n                    TargetFinders.Opponents(),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.Attack(randInt(minDmg, maxDmg)),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = cooldown;\n            }\n        }\n", "        export class _defend extends CardScript {\n            constructor(card: GameEngine.ICardState, difficulty: number, strength: 'weak' | 'normal' | 'strong' = 'normal', cooldown = 0) {\n                let minBonus = 0;\n                let maxBonus = 0;\n                switch (strength) {\n                    case 'weak':\n                        minBonus = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n                        maxBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n                        break;\n                    case 'normal':\n                        minBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n                        maxBonus = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n                        break;\n                    case 'strong':\n                        minBonus = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n                        maxBonus = GameEngineUtils.scaleByCpuMem(11, card.cpu);\n                        break;\n                }\n                minBonus = GameEngineUtils.scaleByDifficulty(minBonus, difficulty);\n                maxBonus = GameEngineUtils.scaleByDifficulty(maxBonus, difficulty);\n\n                super(\n                    [difficulty, strength, cooldown, minBonus, maxBonus],\n                    TargetFinders.Allies(),\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.RaiseSec(randInt(minBonus, maxBonus)),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = cooldown;\n            }\n        }\n", "        export class _firewallSelf extends CardScript {\n            constructor(_card: GameEngine.ICardState, duration = 1, cooldown = 0, startingCooldown = 0) {\n                super(\n                    [duration, cooldown],\n                    TargetFinders.Self,\n                    [\n                        {\n                            targetResolver: TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.AddMod(\n                                    new CardMod.Content.firewall(duration + 1),\n                                ),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownCur = startingCooldown;\n                this.cooldownMax = cooldown;\n            }\n        }\n", "        export class _spawn extends CardScript {\n            constructor(_card: GameEngine.ICardState, enemyClass: string, spawnPosition: Parameters<typeof CardScriptParts['SpawnEnemy']>[1] = 'relLeft', generateIntent = false, cooldown = 0) {\n                super(\n                    [enemyClass, spawnPosition, generateIntent, cooldown],\n                    TargetFinders.Self,\n                    [\n                        {\n                            targetResolver: TargetResolvers.Self,\n                            parts: [\n                                CardScriptParts.SpawnEnemy(enemyClass, spawnPosition, generateIntent),\n                            ],\n                        }\n                    ],\n                );\n                this.cooldownMax = cooldown;\n            }\n        }\n    }\n    (Content as Record<CoreScriptNames, ScriptConstructor>);\n}"]}
{"filename": "src/game/game-engine.ts", "chunked_list": ["import * as moment from 'moment';\nimport { IAppraisedCard, appraiseCard } from '../appraise';\nimport { IDataSource, IMetricsProvider, IPlayerPushProvider } from '../dependencies';\nimport { ExtDeps } from '../external-dependencies';\nimport { SECS_IN_MIN } from '../utils';\nimport { CardMod } from './card-mods';\nimport { CardScript } from './card-scripts';\nimport { GameContent_v1 } from './game-content-v1';\nimport { GameEngineUtils } from './game-engine-utils';\n", "import { GameEngineUtils } from './game-engine-utils';\n\nexport namespace GameEngine {\n    interface _ICommonCardState {\n        id: number;\n        cpu: number;\n        mem: number;\n        sec: number;\n        mods: CardMod.ModData[];\n        scripts: CardScript.ScriptData[];\n\n        isRemoved?: boolean;\n    }\n", "    export interface IGameData {\n        id: string;\n        difficulty: number;\n        state: 'created' | 'started' | 'players_won' | 'players_lost' | 'abandoned';\n\n        enemies: IEnemyCardState[];\n        maxEnemies: number;\n        players: Map<string, IPlayerState>;\n        defaultMovesPerTurn: number;\n        turn: number;\n        nextId: number;\n        pendingPlayers: Map<string, string[]>;\n        rulesetIds: string[];\n    }\n", "    export interface IPlayerState {\n        id: string;\n        cards: IPlayerCardState[];\n        endedTurn: boolean;\n        idleKickTime: number;\n        movesLeft: number;\n        movesPerTurn: number;\n        score: number;\n        stats: {\n            kills: number;\n            secDmg: number;\n            memDmg: number;\n            secBonus: number;\n        };\n    }\n", "    export interface IPlayerCardState extends _ICommonCardState {\n        card: IAppraisedCard;\n        isUsed: boolean;\n    }\n\n    export interface IEnemyCardState extends _ICommonCardState {\n        enemyClass: string;\n        intent?: { scriptData: CardScript.ScriptData, targetCardId: number };\n        maxMem: number;\n    }\n    export type ICardState = IPlayerCardState | IEnemyCardState;\n", "    export type ICardState = IPlayerCardState | IEnemyCardState;\n\n    export abstract class GameEngineError extends Error {\n        constructor(\n            public gameId: string,\n        ) {\n            super();\n            this.message = `${this.constructor.name} processing game ${gameId}`;\n        }\n    }\n", "    export class GameNotFoundError extends GameEngineError { }\n\n    export interface IRulesetContent {\n        cardMods?: CardMod.ModLibrary;\n        cardScripts?: CardScript.ScriptLibrary;\n        enemyCards?: Record<string, (engine: IGameEngine) => IEnemyCardState>;\n    }\n\n    export interface IRuleset extends IRulesetContent {\n        initGame(engine: IGameEngine): void;\n        addAdditionalScriptsFor?(engine: GameEngine.IGameEngine, card: IPlayerCardState): void;\n    }\n", "    export interface IRuleset extends IRulesetContent {\n        initGame(engine: IGameEngine): void;\n        addAdditionalScriptsFor?(engine: GameEngine.IGameEngine, card: IPlayerCardState): void;\n    }\n\n    export function mergeRulesetContents(...rulesets: IRulesetContent[]): IRulesetContent {\n        const modLibs = rulesets.map(x => x.cardMods).filter(Boolean);\n        const scriptLibs = rulesets.map(x => x.cardScripts).filter(Boolean);\n        const enemyLibs = rulesets.map(x => x.enemyCards).filter(Boolean);\n        return {\n            cardMods: Object.fromEntries(modLibs.map(modLib => Object.keys(modLib).map(modName => [modName, modLib[modName]!] as const)).flat()),\n            cardScripts: Object.fromEntries(scriptLibs.map(scriptLib => Object.keys(scriptLib).map(scriptName => [scriptName, scriptLib[scriptName]!] as const)).flat()),\n            enemyCards: Object.fromEntries(enemyLibs.map(enemyLib => Object.keys(enemyLib).map(enemyClass => [enemyClass, enemyLib[enemyClass]!] as const)).flat()),\n        };\n    }\n", "    export type IGameEngine = InstanceType<ReturnType<typeof createGameEngineProvider>>;\n}\n\nexport const createGameEngineProvider = (rulesets: Record<string, GameEngine.IRuleset>, ds: IDataSource, playerPushProvider: IPlayerPushProvider, metrics?: IMetricsProvider) => {\n    return class _Engine {\n        readonly broadcast: IPlayerPushProvider.IPushMessage[] = [];\n        ruleset!: GameEngine.IRuleset;\n\n        constructor(\n            readonly gameData: GameEngine.IGameData,\n        ) {\n            const currentRuleset = rulesets[gameData.rulesetIds.at(-1)!];", "            if (!currentRuleset) throw new Error('invalid initial ruleSet id: ' + gameData.rulesetIds[0]);\n            this._setRuleset(currentRuleset);\n        }\n\n        private static async _withEngine(gameId: string, stateAssertion: GameEngine.IGameData['state'][], func: (engine: _Engine) => Promise<void>): Promise<GameEngine.IGameData> {\n            const gameData = await ds.GameData.get(gameId);\n            if (!gameData) throw new GameEngine.GameNotFoundError(gameId);\n\n            const engine = new _Engine(gameData);\n            try {\n                if (stateAssertion.length && !stateAssertion.includes(gameData.state)) throw new Error('wrong game state, expected: ' + stateAssertion.join() + ', got: ' + gameData.state);\n\n                await func(engine);\n                await ds.GameData.update.exec(gameData);", "            try {\n                if (stateAssertion.length && !stateAssertion.includes(gameData.state)) throw new Error('wrong game state, expected: ' + stateAssertion.join() + ', got: ' + gameData.state);\n\n                await func(engine);\n                await ds.GameData.update.exec(gameData);\n            } catch (e: any) {\n                e.broadcast = engine.broadcast;\n                throw e;\n            }\n\n            if (engine.broadcast.length) {\n                await Promise.all(\n                    [...gameData.players.keys()].map(playerId => playerPushProvider.push(playerId, engine.broadcast)),\n                );\n            }\n\n            return gameData;\n        }\n\n        static async createGame(gameId: string, rulesetId: string, difficulty: number) {\n            const ruleset = rulesets[rulesetId];", "            if (engine.broadcast.length) {\n                await Promise.all(\n                    [...gameData.players.keys()].map(playerId => playerPushProvider.push(playerId, engine.broadcast)),\n                );\n            }\n\n            return gameData;\n        }\n\n        static async createGame(gameId: string, rulesetId: string, difficulty: number) {\n            const ruleset = rulesets[rulesetId];", "            if (!ruleset) throw new Error('invalid ruleSet id: ' + rulesetId);\n\n            const existingGameData = await ds.GameData.get(gameId);\n            if (existingGameData) throw new Error('game with id already exists: ' + gameId);\n\n            const gameData: GameEngine.IGameData = {\n                id: gameId,\n                difficulty: Math.max(1, difficulty),\n                state: 'created',\n                turn: 1,\n                players: new Map(),\n                defaultMovesPerTurn: 3,\n                enemies: [],\n                maxEnemies: 9,\n                nextId: 1,\n                pendingPlayers: new Map(),\n                rulesetIds: [rulesetId],\n            };\n            await ds.GameData.update.exec(gameData);\n        }\n\n        static async startGame(gameId: string) {\n            const gameData = await _Engine._withEngine(gameId, ['created'], async engine => {", "                for (const [playerId, cardIds] of engine.gameData.pendingPlayers) {\n                    const playerState = await engine._createPlayerState(playerId, cardIds);\n                    engine.gameData.players.set(playerId, playerState);\n                    engine.broadcast.push({ type: 'playerJoin', playerState });\n                }\n\n                engine.gameData.pendingPlayers.clear();\n                engine.gameData.state = 'started';\n                engine.broadcast.push({ type: 'gameStart' });\n                engine.ruleset.initGame(engine);\n            });\n            return gameData;\n        }\n\n        static async endGame(gameId: string) {\n            return await _Engine._withEngine(gameId, ['created', 'started'], async engine => {\n                engine.gameData.state = 'abandoned';\n                engine.broadcast.push({ type: 'gameEnd' });\n            });\n        }\n\n        static async addPlayer(gameId: string, playerId: string, cardIds: string[]) {\n            return await _Engine._withEngine(gameId, ['created', 'started'], async engine => {", "                if (engine.gameData.players.has(playerId)) throw new Error('player already in game');\n                if (engine.gameData.players.size >= 2) throw new Error('game is full: ' + gameId);\n\n                if (engine.gameData.state === 'started') {\n                    const playerState = await engine._createPlayerState(playerId, cardIds);\n                    engine.gameData.players.set(playerId, playerState);\n\n                    if (engine.gameData.turn >= 2) {\n                        playerState.endedTurn = true;\n                        playerState.movesLeft = 0;\n                    }\n\n                    engine.broadcast.push({\n                        type: 'playerJoin',\n                        playerState,\n                    });\n                } else {\n                    engine.gameData.pendingPlayers.set(playerId, cardIds);\n                }\n            });\n        }\n\n        static async removePlayer(gameId: string, playerId: string, reason: 'idle' | 'leave') {\n            return await _Engine._withEngine(gameId, [], async engine => {", "                if (!engine.gameData.players.delete(playerId)) throw new Error('player not found');\n                engine.broadcast.push({ type: 'playerLeave', playerId, reason });\n                GameEngineUtils.revalidateIntents(engine, true);\n\n                for (const remainingPlayer of engine.gameData.players.values()) {\n                    remainingPlayer.endedTurn = false;\n                    engine.broadcast.push({\n                        type: 'playerToggleEndTurn',\n                        playerId: remainingPlayer.id,\n                        state: false,\n                    });\n                }\n            });\n        }\n\n        static async requestCardTargets(gameId: string, playerId: string, cardId: number, scriptName: string) {\n            const gameData = await _Engine.getGameData(gameId);\n            const card = GameEngineUtils.findPlayerCardById(gameData, cardId);\n            let targets = [] as number[];", "            try {\n                if (card.isUsed) {\n                    return;\n                }\n\n                const scriptData = card.scripts.find(x => x[0] === scriptName);\n                if (!scriptData) {\n                    throw new Error(`Script [${scriptName}] not found in card [${cardId}]`);\n                }\n\n                if (CardScript.isOnCooldown(scriptData)) {\n                    return;\n                }\n\n                const engine = new _Engine(gameData);\n                const script = CardScript.deserialize(engine, card, scriptData);\n                targets = script.targetFinder(gameData, card).map(x => x.id);", "                if (CardScript.isOnCooldown(scriptData)) {\n                    return;\n                }\n\n                const engine = new _Engine(gameData);\n                const script = CardScript.deserialize(engine, card, scriptData);\n                targets = script.targetFinder(gameData, card).map(x => x.id);\n            } finally {\n                await playerPushProvider.push(playerId, [{\n                    type: 'cardTargets',\n                    cardId,\n                    scriptName,\n                    targetCardIds: targets,\n                }]);\n            }\n        }\n\n        static async intent(gameId: string, playerId: string, sourceCardId?: string, sourceCardScript?: string, targetCardId?: string) {\n            const gameData = await _Engine.getGameData(gameId);\n            const pushMessage: IPlayerPushProvider.IPushMessage[] = [{\n                type: 'cardIntent',\n                cardId: sourceCardId,\n                intent: {\n                    scriptData: sourceCardScript,\n                    targetCardId,\n                },\n                playerId,\n            }];\n            await Promise.all(\n                [...gameData.players.keys()].filter(x => x !== playerId).map(x => playerPushProvider?.push(x, pushMessage)),\n            );\n        }\n\n        static async makeMove(gameId: string, playerId: string, sourceCardId: number, sourceCardScript: CardScript.ScriptData, targetCardId: number) {\n            return await _Engine._withEngine(gameId, ['started'], async engine => {\n                const playerState = GameEngineUtils.findPlayerByCardId(engine.gameData, sourceCardId);", "                if (playerState.id !== playerId) {\n                    throw new Error(`Player ${playerId} cannot make move on card ${sourceCardId} from owner ${playerState.id}`);\n                }\n                if (!playerState.movesLeft) {\n                    throw new Error(`No moves left`);\n                }\n                const sourceCard = playerState.cards.find(x => x.id === sourceCardId)!;\n                if (sourceCard.isUsed) {\n                    throw new Error(`Card is used`);\n                }\n\n                const now = moment.now();\n                playerState.idleKickTime = now + 2 * SECS_IN_MIN * 1000;\n                playerState.movesLeft--;\n\n                const targetCard = GameEngineUtils.findCardById(engine.gameData, targetCardId);\n                CardScript.execute(engine, sourceCard, sourceCardScript, targetCard);\n                GameEngineUtils.changeCardIsUsed(engine, sourceCard, true);\n\n                metrics?.playerCardPlayed(gameId, engine.gameData.rulesetIds[0] || 'unknown', playerId, sourceCard, sourceCardScript[0]);\n            });\n        }\n\n        static async toggleEndTurn(gameId: string, playerId: string) {\n            return await _Engine._withEngine(gameId, ['started'], async engine => {\n                const playerState = engine.gameData.players.get(playerId);", "                if (!playerState) throw new Error('player not found');\n\n                if (playerState.endedTurn) {\n                    playerState.endedTurn = false;\n                    engine.broadcast.push({\n                        type: 'playerToggleEndTurn',\n                        playerId,\n                        state: false,\n                    });\n                    return;\n                }\n\n                playerState.endedTurn = true;\n                engine.broadcast.push({\n                    type: 'playerToggleEndTurn',\n                    playerId,\n                    state: true,\n                });\n", "                if (![...engine.gameData.players.values()].reduce((numNotReady, playerState) => playerState.endedTurn ? numNotReady : (numNotReady + 1), 0)) {\n                    const now = moment.now();\n                    [...engine.gameData.players.values()].forEach(x => x.idleKickTime = now + 2 * SECS_IN_MIN * 1000);\n\n                    engine.onEndTurn();\n                    if (engine.gameData.state !== 'started') {\n                        // Stop if the game was won/lost due to an EndTurn effect\n                        return;\n                    }\n                    engine.onTurnStart();\n                }\n            });\n        }\n\n        static async kickTeammateIfIdle(gameId: string, kickRequestingPlayerId: string) {\n            let kickedPlayerId = '';\n            await _Engine._withEngine(gameId, ['started'], async engine => {\n                const playerToKick = [...engine.gameData.players.values()].find(x => x.id !== kickRequestingPlayerId) || '';", "                if (!playerToKick) throw new Error('kickIfIdle: player not found');\n\n                if (playerToKick.idleKickTime < moment.now()) {\n                    if (!engine.gameData.players.delete(playerToKick.id)) throw new Error('player not found');\n\n                    engine.broadcast.push({ type: 'playerLeave', playerId: playerToKick.id, reason: 'idle' });\n                    GameEngineUtils.revalidateIntents(engine, true);\n\n                    for (const remainingPlayer of engine.gameData.players.values()) {\n                        remainingPlayer.endedTurn = false;\n                        engine.broadcast.push({\n                            type: 'playerToggleEndTurn',\n                            playerId: remainingPlayer.id,\n                            state: false,\n                        });\n                    }\n\n                    kickedPlayerId = playerToKick.id;\n                }\n            });\n            return kickedPlayerId || null;\n        }\n\n        static async getGameData(gameId: string) {\n            const gameData = await ds.GameData.get(gameId);", "                    for (const remainingPlayer of engine.gameData.players.values()) {\n                        remainingPlayer.endedTurn = false;\n                        engine.broadcast.push({\n                            type: 'playerToggleEndTurn',\n                            playerId: remainingPlayer.id,\n                            state: false,\n                        });\n                    }\n\n                    kickedPlayerId = playerToKick.id;\n                }\n            });\n            return kickedPlayerId || null;\n        }\n\n        static async getGameData(gameId: string) {\n            const gameData = await ds.GameData.get(gameId);", "            if (!gameData) throw new GameEngine.GameNotFoundError(gameId);\n            return gameData;\n        }\n\n        private async _createPlayerState(playerId: string, cardIds: string[]): Promise<GameEngine.IPlayerState> {\n            const cards = (await Promise.all(cardIds.map(ExtDeps.getNft)))\n                .filter((resp): resp is NonNullable<typeof resp> => !!resp?.nft)\n                .map(resp => appraiseCard({ nftId: resp.nft.nftId, mintHeight: resp.nft.firstBlock, url: resp.nft.urls[0] || '' }));\n\n            if (cards.length !== cardIds.length) {\n                throw `could not resolve all cards for player ${playerId}`;\n            }\n\n            const player: GameEngine.IPlayerState = {\n                id: playerId,\n                cards: cards.map(card => ({\n                    id: this.nextId(),\n                    card,\n                    isUsed: false,\n                    cpu: card.cpu,\n                    mem: card.mem,\n                    sec: card.mem * 6 + card.cpu * 3,\n                    mods: [],\n                    scripts: [],\n                })),\n                endedTurn: false,\n                movesLeft: this.gameData.defaultMovesPerTurn,\n                movesPerTurn: this.gameData.defaultMovesPerTurn,\n                stats: {\n                    kills: 0,\n                    memDmg: 0,\n                    secBonus: 0,\n                    secDmg: 0,\n                },\n                score: 0,\n                idleKickTime: moment.now() + 2 * SECS_IN_MIN * 1000,\n            };", "            if (cards.length !== cardIds.length) {\n                throw `could not resolve all cards for player ${playerId}`;\n            }\n\n            const player: GameEngine.IPlayerState = {\n                id: playerId,\n                cards: cards.map(card => ({\n                    id: this.nextId(),\n                    card,\n                    isUsed: false,\n                    cpu: card.cpu,\n                    mem: card.mem,\n                    sec: card.mem * 6 + card.cpu * 3,\n                    mods: [],\n                    scripts: [],\n                })),\n                endedTurn: false,\n                movesLeft: this.gameData.defaultMovesPerTurn,\n                movesPerTurn: this.gameData.defaultMovesPerTurn,\n                stats: {\n                    kills: 0,\n                    memDmg: 0,\n                    secBonus: 0,\n                    secDmg: 0,\n                },\n                score: 0,\n                idleKickTime: moment.now() + 2 * SECS_IN_MIN * 1000,\n            };", "            for (const card of player.cards) {\n                card.scripts = [\n                    CardScript.fromScriptName(this, card, card.card.coreScript),\n                ];\n                this.ruleset.addAdditionalScriptsFor && this.ruleset.addAdditionalScriptsFor(this, card);\n            }\n            return player;\n        }\n\n        findRuleset(rulesetId: string) {\n            return rulesets[rulesetId];\n        }\n\n        onTurnStart() {\n            this.gameData.turn++;\n            this.broadcast.push({\n                type: 'newTurn',\n                turn: this.gameData.turn,\n            });\n", "            for (const player of this.gameData.players.values()) {\n                player.endedTurn = false;\n                player.movesLeft = player.movesPerTurn;\n            }\n\n            const playerCards = GameEngineUtils.getPlayerCards(this.gameData);\n            for (const playerCard of playerCards) {\n                GameEngineUtils.changeCardIsUsed(this, playerCard, false);\n            }\n\n            for (const playerCard of [...playerCards]) {", "            for (const playerCard of [...playerCards]) {\n                if (!playerCards.includes(playerCard)) continue;\n                GameEngineUtils.triggerMods('onTurnStart', { engine: this, sourceCard: playerCard });\n            }\n\n            for (const enemy of [...this.gameData.enemies]) {\n                if (!this.gameData.enemies.includes(enemy)) continue;\n                GameEngineUtils.triggerMods('onTurnStart', { engine: this, sourceCard: enemy });\n            }\n\n            this._checkGameOver();\n        }\n\n        onEndTurn() {\n            const playerCards = GameEngineUtils.getPlayerCards(this.gameData);", "            for (const playerCard of [...playerCards]) {\n                if (!playerCards.includes(playerCard)) continue;\n                GameEngineUtils.triggerMods('onTurnEnd', { engine: this, sourceCard: playerCard });\n                CardScript.tickCooldowns(playerCard, this.broadcast);\n            }\n\n            this.broadcast.push({\n                type: 'playerTurnEnded',\n            });\n\n            for (const enemy of [...this.gameData.enemies]) {", "            for (const enemy of [...this.gameData.enemies]) {\n                if (!this.gameData.enemies.includes(enemy)) continue;\n                GameEngineUtils.triggerMods('onTurnEnd', { engine: this, sourceCard: enemy });\n                CardScript.tickCooldowns(enemy, this.broadcast);\n            }\n\n            this.broadcast.push({\n                type: 'enemyTurnEnded',\n            });\n\n            this._checkGameOver();\n        }\n\n        onNextWave(nextRulesetId: string) {", "            while (this.gameData.enemies[0]) {\n                GameEngineUtils.removeCard(this, this.gameData.enemies[0]);\n            }\n\n            [...this.gameData.players.values()].forEach(player => {\n                player.endedTurn = false;\n                player.movesLeft = player.movesPerTurn;\n                player.cards.forEach(card => {\n                    card.isUsed = false;\n                });\n            });\n\n            this.gameData.turn++;\n            this.broadcast.push({\n                type: 'nextWave',\n                turn: this.gameData.turn,\n                nextRulesetId,\n            });\n\n            const nextRuleset = this.findRuleset(nextRulesetId);", "            if (!nextRuleset) {\n                throw new Error('invalid rulesetId: ' + nextRulesetId);\n            }\n\n            this.gameData.rulesetIds.push(nextRulesetId);\n            this._setRuleset(nextRuleset);\n            nextRuleset.initGame(this);\n        }\n\n        onWinGame() {\n            this.gameData.state = 'players_won';\n\n            this.broadcast.push({\n                type: 'players_won',\n                stats: [...this.gameData.players.values()].map(player => {\n                    let score =\n                        player.cards.length * 50\n                        + player.stats.kills * 25\n                        + player.stats.memDmg * 50\n                        + player.stats.secDmg\n                        + player.stats.secBonus * 2\n                        + ((this.gameData.rulesetIds.length - 1) * 2000);\n                    score = GameEngineUtils.scaleByDifficulty(score, this.gameData.difficulty + 1);\n                    player.score = score;\n\n                    return { playerId: player.id, stats: player.stats, score };\n                }),\n            });\n        }\n\n        nextId() {\n            return this.gameData.nextId++;\n        }\n\n        private _checkGameOver() {", "            if (!GameEngineUtils.getPlayerCards(this.gameData).length) {\n                this.gameData.state = 'players_lost';\n                this.broadcast.push({\n                    type: 'players_lost',\n                });\n            }\n        }\n\n        private _setRuleset(nextRuleset: GameEngine.IRuleset) {\n            this.ruleset = {\n                addAdditionalScriptsFor: GameContent_v1.addAdditionalScriptsFor,\n\n                ...nextRuleset,\n\n                ...GameEngine.mergeRulesetContents(\n                    nextRuleset,\n                    {\n                        cardMods: CardMod.Content,\n                        cardScripts: CardScript.Content,\n                    },\n                    {\n                        cardMods: GameContent_v1.cardMods,\n                        cardScripts: GameContent_v1.cardScripts,\n                        enemyCards: GameContent_v1.enemyCards,\n                    }\n                ),\n            };\n        }\n    }\n}", "export type GameEngineProvider = ReturnType<typeof createGameEngineProvider>;"]}
{"filename": "src/game/game-content-v1.ts", "chunked_list": ["import { randInt } from '../utils';\nimport { CardMod } from './card-mods';\nimport { CardScriptParts } from './card-script-parts';\nimport { CardScript } from './card-scripts';\nimport { GameEngine } from './game-engine';\nimport { GameEngineUtils } from './game-engine-utils';\n\nconst _cardMods = {\n    // Increases incoming damage\n    exposed: class extends CardMod {\n        override stackingConfig = {\n            behavior: CardMod.StackingBehavior.stack as const,\n            stackCount: 0,\n        };\n\n        constructor(public stackCount: number) {\n            super(arguments);\n            this.stackingConfig.stackCount = stackCount;\n        }\n\n        override onSecDamageIn(_deps: CardMod.ICardModDeps, _damage: number, _attacker: GameEngine.ICardState) {\n            return { secDmgBonus: this.stackingConfig.stackCount };\n        }\n    },\n\n    // Returns damage to attacker", "    // Increases incoming damage\n    exposed: class extends CardMod {\n        override stackingConfig = {\n            behavior: CardMod.StackingBehavior.stack as const,\n            stackCount: 0,\n        };\n\n        constructor(public stackCount: number) {\n            super(arguments);\n            this.stackingConfig.stackCount = stackCount;\n        }\n\n        override onSecDamageIn(_deps: CardMod.ICardModDeps, _damage: number, _attacker: GameEngine.ICardState) {\n            return { secDmgBonus: this.stackingConfig.stackCount };\n        }\n    },\n\n    // Returns damage to attacker", "    feedback: class extends CardMod {\n        override stackingConfig = {\n            behavior: CardMod.StackingBehavior.stack as const,\n            stackCount: 0,\n        };\n\n        constructor(public damage: number) {\n            super(arguments);\n            this.stackingConfig.stackCount = damage;\n        }\n\n        override onSecDamageIn(deps: CardMod.ICardModDeps, _damage: number, attacker: GameEngine.ICardState) {\n            CardScriptParts.SecDmg(this.stackingConfig.stackCount, false, true)(deps.engine, deps.sourceCard, attacker);\n        }\n    },\n\n    // Increases CPU", "    optimized: class extends CardMod {\n        override stackingConfig = {\n            behavior: CardMod.StackingBehavior.stack as const,\n            stackCount: 0,\n        };\n\n        constructor(cpuBonus: number, override duration: number) {\n            super(arguments);\n            this.stackingConfig.stackCount = cpuBonus;\n        }\n\n        override onInitMod(deps: CardMod.ICardModDeps) {\n            GameEngineUtils.changeCpu(deps.engine, deps.sourceCard, this.stackingConfig.stackCount);\n        }\n\n        override onStackMod(deps: CardMod.ICardModDeps, stackDelta: number) {\n            deps.sourceCard.cpu += stackDelta;\n            deps.engine.broadcast.push({\n                type: 'cpuChanged',\n                cardId: deps.sourceCard.id,\n                newCpu: deps.sourceCard.cpu,\n            });\n\n            GameEngineUtils.recalculateScripts(deps.engine, deps.sourceCard);\n        }\n\n        override onRemoveMod(deps: CardMod.ICardModDeps) {\n            deps.sourceCard.cpu -= this.stackingConfig.stackCount;\n            deps.engine.broadcast.push({\n                type: 'cpuChanged',\n                cardId: deps.sourceCard.id,\n                newCpu: deps.sourceCard.cpu,\n            });\n\n            GameEngineUtils.recalculateScripts(deps.engine, deps.sourceCard);\n        }\n    },\n\n    // Damages on turn end", "    virus: class extends CardMod {\n        override stackingConfig = {\n            behavior: CardMod.StackingBehavior.stack as const,\n            stackCount: 0,\n        };\n\n        constructor(public dot: number) {\n            super(arguments);\n            this.stackingConfig.stackCount = dot;\n        }\n\n        override onTurnEnd(deps: CardMod.ICardModDeps) {\n            CardScriptParts.SecDmg(this.stackingConfig.stackCount, true, true)(deps.engine, deps.sourceCard, deps.sourceCard);\n        }\n    },\n};\n\nconst _cardScripts = {\n    //\n    // Backdoor scripts\n    //\n\n    // Swap MEM for CPU", "    bd_caching: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [],\n                (gameData, card) => CardScript.TargetFinders.Allies()(gameData, card).filter(x => x.mem > 1),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.RaiseMem(-1),\n                            CardScriptParts.ChangeCpu(1),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Raise MEM", "    bd_defrag: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            const memBonus = 1;\n\n            super(\n                [memBonus],\n                CardScript.TargetFinders.Any(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.RaiseMem(1),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 4;\n        }\n    },\n\n    // Heal over time", "    bd_diagnostics: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const secBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n            const duration = 1 + Math.round(card.mem / 2);\n\n            super(\n                [secBonus, duration],\n                CardScript.TargetFinders.Any(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new CardMod.Content.diagnostics(secBonus, duration)\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 4;\n        }\n    },\n\n    // Attack and stun (Backdoor finisher)", "    bd_disrupt: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const damage = GameEngineUtils.scaleByCpuMem(9, card.cpu);\n            const stunDuration = 1;\n\n            super(\n                [damage, stunDuration],\n                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n                    CardScript.TargetFinders.Opponents(true),\n                ),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.Attack(damage),\n                            CardScriptParts.AddMod(\n                                new CardMod.Content.lag(stunDuration),\n                            ),\n                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n\n    // Attack and raise CPU on kill", "    bd_extraction: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [],\n                (gameData, card) =>\n                    CardScript.TargetFinders.Opponents(true)(gameData, card)\n                        .filter(target => !target.sec && target.mem === 1),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.Attack(1, true, true),\n                        ],\n                    },\n                    {\n                        targetResolver: CardScript.TargetResolvers.Self,\n                        parts: [\n                            CardScriptParts.ChangeCpu(1),\n                        ],\n                    },\n                ],\n            );\n        }\n    },\n\n    // Raises CPU", "    bd_optimize: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const cpuBonus = 1;\n            const duration = Math.round(card.cpu / 2);\n\n            super(\n                [cpuBonus, duration],\n                CardScript.TargetFinders.Allies(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new _cardMods.optimized(cpuBonus, duration),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 4;\n        }\n    },\n\n    // Raises SEC", "    bd_patch: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const secBonus = GameEngineUtils.scaleByCpuMem(11, card.cpu);\n\n            super(\n                [secBonus],\n                CardScript.TargetFinders.Any(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.RaiseSec(secBonus),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n\n    // Steal SEC and remove Firewall (Backdoor finisher)", "    bd_proxy: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const secDelta = GameEngineUtils.scaleByCpuMem(5, card.cpu);\n\n            super(\n                [secDelta],\n                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n                    CardScript.TargetFinders.Opponents(true),\n                ),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.SecDmg(secDelta),\n                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'firewall'>('firewall'),\n                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n                        ],\n                    },\n                    {\n                        targetResolver: CardScript.TargetResolvers.Self,\n                        parts: [\n                            CardScriptParts.RaiseSec(secDelta),\n                        ],\n                    },\n                ],\n            );\n        }\n    },\n\n    // Steal SEC and causes offline (Backdoor finisher)", "    bd_reboot: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            const secDelta = GameEngineUtils.scaleByCpuMem(5, _card.cpu);\n            const offlineDuration = 1;\n\n            super(\n                [secDelta, offlineDuration],\n                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n                    CardScript.TargetFinders.Opponents(true),\n                ),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.SecDmg(secDelta),\n                            CardScriptParts.AddMod(\n                                new CardMod.Content.offline(offlineDuration),\n                            ),\n                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n                        ],\n                    },\n                    {\n                        targetResolver: CardScript.TargetResolvers.Self,\n                        parts: [\n                            CardScriptParts.RaiseSec(secDelta),\n                        ],\n                    },\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n\n    // Cause Exposed (Backdoor finisher)", "    bd_trace: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const stacks = GameEngineUtils.scaleByCpuMem(7, card.cpu);\n\n            super(\n                [stacks],\n                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n                    CardScript.TargetFinders.Opponents(true),\n                ),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new _cardMods.exposed(stacks),\n                            ),\n                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n\n    // Attack and remove 1 MEM", "    bd_tunnel: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            const memDmg = 1;\n\n            super(\n                [memDmg],\n                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n                    CardScript.TargetFinders.Opponents(true),\n                ),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.MemDmg(memDmg),\n                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 3;\n        }\n    },\n\n    //\n    // Bruteforce scripts\n    //\n\n    // Swap CPU for MEM", "    bf_compression: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [],\n                (gameData, card) =>\n                    CardScript.TargetFinders.Allies()(gameData, card).filter(x => x.cpu > 1),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.ChangeCpu(-1),\n                            CardScriptParts.RaiseMem(1),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Cause Offline", "    bf_ddos: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            const offlineDuration = 1;\n\n            super(\n                [offlineDuration],\n                CardScript.TargetFinders.Any(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new CardMod.Content.offline(offlineDuration),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 3;\n        }\n    },\n\n    // Cause Lag", "    bf_dos: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            const lagDuration = 1;\n\n            super(\n                [lagDuration],\n                CardScript.TargetFinders.Any(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new CardMod.Content.lag(lagDuration),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 4;\n        }\n    },\n\n    // Gain feedback", "    bf_feedback: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const damage = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n            const cooldown = Math.max(0, 4 - Math.round(card.mem / 2));\n\n            super(\n                [damage, cooldown],\n                CardScript.TargetFinders.Self,\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Self,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new GameContent_v1.cardMods.feedback(damage),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = cooldown;\n        }\n    },\n\n    // Triple SEC attack", "    bf_flood: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const damage = GameEngineUtils.scaleByCpuMem(3, card.cpu);\n            const numAttacks = 3;\n\n            super(\n                [damage, numAttacks],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            ...Array.from(Array(numAttacks)).map(() => CardScriptParts.SecDmg(damage)),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n\n    // AOE attack", "    bf_multicast: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const damage = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n\n            super(\n                [damage],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.TargetAndAdjacents,\n                        parts: [\n                            CardScriptParts.Attack(damage),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Raise SEC", "    bf_obfuscate: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const secBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\n            super(\n                [secBonus],\n                CardScript.TargetFinders.Any(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.RaiseSec(secBonus),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 3;\n        }\n    },\n\n    // Strong attack", "    bf_pod: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const damage = GameEngineUtils.scaleByCpuMem(16, card.cpu);\n\n            super(\n                [damage],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.Attack(damage),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n\n    // Raises CPU", "    bf_precompute: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const cpuBonus = 1;\n            const duration = Math.round(card.cpu / 2);\n\n            super(\n                [cpuBonus, duration],\n                CardScript.TargetFinders.Allies(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new _cardMods.optimized(cpuBonus, duration),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 4;\n        }\n    },\n\n\n    //\n    // Malware scripts\n    //\n\n    // Causes Lag", "    mw_bloatware: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [1],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new CardMod.Content.lag(1),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 3;\n        }\n    },\n\n    // Swap for another card's secondary script", "    mw_copypaste: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [],\n                CardScript.TargetFinders.Allies(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            (engine, sourceCard, targetCard) => {\n                                CardScript.removeScript(engine, sourceCard, _cardScripts.mw_copypaste);\n", "                                if (!targetCard.scripts[1]) return;\n\n                                CardScript.addScript(engine, sourceCard, CardScript.fromScriptName(engine, sourceCard, targetCard.scripts[1][0]));\n                            },\n                        ],\n                    }\n                ],\n            );\n        }\n    },\n\n    // Grant Feedback", "    mw_honeypot: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const damage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n            const cooldown = Math.max(0, 4 - Math.round(card.mem / 2));\n\n            super(\n                [damage, cooldown],\n                CardScript.TargetFinders.Allies(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new GameContent_v1.cardMods.feedback(damage),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = cooldown;\n        }\n    },\n\n    // Steal SEC", "    mw_leech: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const secDelta = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\n            super(\n                [secDelta],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.SecDmg(secDelta),\n                        ],\n                    },\n                    {\n                        targetResolver: CardScript.TargetResolvers.Self,\n                        parts: [\n                            CardScriptParts.RaiseSec(secDelta),\n                        ],\n                    },\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Attack random target", "    mw_phishing: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const minDamage = GameEngineUtils.scaleByCpuMem(9, card.cpu);\n            const maxDamage = GameEngineUtils.scaleByCpuMem(18, card.cpu);\n\n            super(\n                [minDamage, maxDamage],\n                CardScript.TargetFinders.Self,\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.RandomOpponent,\n                        parts: [\n                            CardScriptParts.Attack(randInt(minDamage, maxDamage)),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Redistribute CPU/MEM", "    mw_reimage: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [],\n                CardScript.TargetFinders.Allies(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            (engine, _sourceCard, targetCard) => {\n                                const totalStats = targetCard.cpu + targetCard.mem;\n                                const newCpu = randInt(1, totalStats - 1);\n                                const cpuDelta = newCpu - targetCard.cpu;\n                                GameEngineUtils.changeCpu(engine, targetCard, cpuDelta);\n\n                                const newMem = totalStats - newCpu;\n                                const memDelta = newMem - targetCard.mem;\n                                GameEngineUtils.changeMem(engine, targetCard, memDelta);\n                            },\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Raise SEC on random ally", "    mw_shareware: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const minBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n            const maxBonus = GameEngineUtils.scaleByCpuMem(20, card.cpu);\n\n            super(\n                [minBonus, maxBonus],\n                CardScript.TargetFinders.Self,\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.RandomAlly,\n                        parts: [\n                            CardScriptParts.RaiseSec(randInt(minBonus, maxBonus)),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 3;\n        }\n    },\n\n    // Redirect intent", "    mw_spoof: class extends CardScript {\n        constructor(_card: GameEngine.ICardState) {\n            super(\n                [],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.RedirectIntentRandom,\n                        ],\n                    }\n                ],\n            );\n        }\n    },\n\n    // Cause Exposed", "    mw_spyware: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const stacks = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n\n            super(\n                [stacks],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new _cardMods.exposed(stacks),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 1;\n        }\n    },\n\n    // Cause Virus", "    mw_virus: class extends CardScript {\n        constructor(card: GameEngine.ICardState) {\n            const dot = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n            super(\n                [dot],\n                CardScript.TargetFinders.Opponents(),\n                [\n                    {\n                        targetResolver: CardScript.TargetResolvers.Target,\n                        parts: [\n                            CardScriptParts.AddMod(\n                                new _cardMods.virus(dot),\n                            ),\n                        ],\n                    }\n                ],\n            );\n            this.cooldownMax = 2;\n        }\n    },\n};\n\nexport const GameContent_v1 = {\n    cardMods: _cardMods,\n    cardScripts: _cardScripts,\n    enemyCards: {},\n\n    initGame(_engine: GameEngine.IGameEngine) {\n        throw new Error('not a startable scenario');\n    },\n\n    addAdditionalScriptsFor(engine: GameEngine.IGameEngine, card: GameEngine.IPlayerCardState) {", "        if (card.card.tier < 2) return;\n\n        switch (card.card.faction) {\n            case 'backdoor':\n                card.scripts.push(CardScript.deserialize(engine, card, [Object.keys(_cardScripts).filter(x => x.startsWith('bd_')).random()]).serialize());\n                return;\n\n            case 'bruteforce':\n                card.scripts.push(CardScript.deserialize(engine, card, [Object.keys(_cardScripts).filter(x => x.startsWith('bf_')).random()]).serialize());\n                return;\n\n            case 'malware':\n                card.scripts.push(CardScript.deserialize(engine, card, [Object.keys(_cardScripts).filter(x => x.startsWith('mw_')).random()]).serialize());\n                return;\n        }\n    },\n};\n(GameContent_v1 as GameEngine.IRuleset);"]}
{"filename": "src/game/game-engine-utils.ts", "chunked_list": ["import { clamp, round } from '../utils';\nimport { CardMod } from './card-mods';\nimport { CardScript } from './card-scripts';\nimport { GameEngine } from './game-engine';\n\nexport namespace GameEngineUtils {\n    export function addEnemy(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState, spawnIndex: number, generateIntent: boolean) {\n        if (engine.gameData.enemies.length >= engine.gameData.maxEnemies) return;\n\n        spawnIndex = clamp(spawnIndex, 0, engine.gameData.enemies.length);\n        engine.gameData.enemies.splice(spawnIndex, 0, enemy);\n        engine.broadcast.push({\n            type: 'cardAdded',\n            enemy,\n            position: spawnIndex,\n        });\n\n        GameEngineUtils.triggerMods('onInitMod', { engine, sourceCard: enemy });\n", "        if (generateIntent) {\n            GameEngineUtils.generateIntent(engine, enemy);\n        }\n        return enemy;\n    }\n\n    export function changeCardIsUsed(engine: GameEngine.IGameEngine, card: GameEngine.IPlayerCardState, isUsed: boolean) {\n        card.isUsed = isUsed;\n        engine.broadcast.push({\n            type: 'cardIsUsedChanged',\n            cardId: card.id,\n            isUsed,\n        });\n    }\n", "    export function clearIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState) {\n        const intent = enemy.intent;\n        if (!intent) {\n            return false;\n        }\n\n        enemy.intent = undefined;\n        engine.broadcast.push({\n            type: 'cardIntent',\n            cardId: enemy.id,\n        });\n        return true;\n    }\n", "    export function changeCpu(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, cpuDelta: number) {\n        card.cpu += cpuDelta;\n        engine.broadcast.push({\n            type: 'cpuChanged',\n            cardId: card.id,\n            newCpu: card.cpu,\n            cpuDelta,\n        });\n\n        GameEngineUtils.recalculateScripts(engine, card);\n    }\n", "    export function changeMem(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, memDelta: number) {\n        card.mem += memDelta;\n        engine.broadcast.push({\n            type: 'memChanged',\n            cardId: card.id,\n            newMem: card.mem,\n            memDelta,\n        });\n\n        GameEngineUtils.recalculateScripts(engine, card);\n    }\n", "    export function changeSec(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, secDelta: number, isPassive: boolean, contextCard?: GameEngine.ICardState) {\n        const clampedSecDelta = (card.sec < -secDelta) ? -card.sec : secDelta;\n        card.sec += clampedSecDelta;\n        engine.broadcast.push({\n            type: isPassive ? 'secChange' : (secDelta < 0 ? 'secDamage' : 'secBonus'),\n            cardId: card.id,\n            newSec: card.sec,\n            value: secDelta,\n        });\n\n        if (!isPassive && contextCard) {\n            const player = GameEngineUtils.findPlayerByCardIdMaybe(engine.gameData, contextCard.id);", "        if (!isPassive && contextCard) {\n            const player = GameEngineUtils.findPlayerByCardIdMaybe(engine.gameData, contextCard.id);\n            if (player) {\n                (clampedSecDelta >= 0) ? (player.stats.secBonus += clampedSecDelta) : (player.stats.secDmg += -clampedSecDelta);\n            }\n        }\n    }\n\n    export function executeIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState, dontClearIntent = false) {\n        const intent = enemy.intent;\n        if (!intent) {\n            return false;\n        }\n\n        enemy.intent = dontClearIntent ? enemy.intent : undefined;\n\n        let targetCard: GameEngine.ICardState | undefined;", "    export function executeIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState, dontClearIntent = false) {\n        const intent = enemy.intent;\n        if (!intent) {\n            return false;\n        }\n\n        enemy.intent = dontClearIntent ? enemy.intent : undefined;\n\n        let targetCard: GameEngine.ICardState | undefined;\n        if (intent.targetCardId >= 0) {\n            targetCard = findCardByIdMaybe(engine.gameData, intent.targetCardId);", "        if (intent.targetCardId >= 0) {\n            targetCard = findCardByIdMaybe(engine.gameData, intent.targetCardId);\n            if (!targetCard) {\n                // Intent target could've been removed between intent generation and execution\n                return false;\n            }\n        } else {\n            targetCard = enemy;\n        }\n\n        CardScript.execute(engine, enemy, intent.scriptData, targetCard);\n        return true;\n    }\n", "    export function findCardById(gameData: GameEngine.IGameData, cardId: number) {\n        const card = findCardByIdMaybe(gameData, cardId);\n        if (card) return card;\n\n        throw new Error('card not found');\n    }\n\n    export function findCardByIdMaybe(gameData: GameEngine.IGameData, cardId: number) {\n        const enemy = gameData.enemies.find(x => x.id === cardId);\n        if (enemy) return enemy;\n\n        const player = findPlayerByCardIdMaybe(gameData, cardId);", "        if (enemy) return enemy;\n\n        const player = findPlayerByCardIdMaybe(gameData, cardId);\n        if (player) {\n            return player.cards.find(x => x.id === cardId);\n        }\n        return;\n    }\n\n    export function findPlayerCardById(gameData: GameEngine.IGameData, cardId: number) {\n        const player = findPlayerByCardIdMaybe(gameData, cardId);", "    export function findPlayerCardById(gameData: GameEngine.IGameData, cardId: number) {\n        const player = findPlayerByCardIdMaybe(gameData, cardId);\n        if (!player) throw new Error('player not found');\n\n        return player.cards.find(x => x.id === cardId)!;\n    }\n\n    export function findPlayerByCardId(gameData: GameEngine.IGameData, cardId: number) {\n        const player = findPlayerByCardIdMaybe(gameData, cardId);\n        if (player) return player;\n\n        throw new Error('player not found');\n    }\n", "        if (player) return player;\n\n        throw new Error('player not found');\n    }\n\n    export function findPlayerByCardIdMaybe(gameData: GameEngine.IGameData, cardId: number) {\n        return [...gameData.players.values()].find(x => x.cards.find(x => x.id === cardId));\n    }\n\n    export function generateIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState) {\n        enemy.intent = undefined;\n\n        const isOffline = !!enemy.mods.find(x => x[0] === 'offline');", "    export function generateIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState) {\n        enemy.intent = undefined;\n\n        const isOffline = !!enemy.mods.find(x => x[0] === 'offline');\n        if (isOffline) return;\n\n        const scriptData = enemy.scripts.filter(x => !CardScript.isOnCooldown(x)).randomOrUndefined();\n        if (!scriptData) {\n            return;\n        }\n\n        const script = CardScript.deserialize(engine, enemy, scriptData);\n        const target = script.targetFinder(engine.gameData, enemy).randomOrUndefined();", "        if (!target) {\n            return;\n        }\n\n        enemy.intent = {\n            scriptData,\n            targetCardId: target.id,\n        };\n\n        engine.broadcast.push({\n            type: 'cardIntent',\n            cardId: enemy.id,\n            intent: enemy.intent,\n        });\n    }\n", "    export function getEnemyIds(gameData: GameEngine.IGameData) {\n        return gameData.enemies.map(x => x.id);\n    }\n\n    export function getPlayerIds(gameData: GameEngine.IGameData, ...excludePlayer: string[]) {\n        return [...gameData.players.keys()].filter(x => !excludePlayer.includes(x));\n    }\n\n    export function getPlayerCards(gameData: GameEngine.IGameData) {\n        return [...gameData.players.values()].map(x => x.cards).flat();\n    }\n", "    export function getPlayerCards(gameData: GameEngine.IGameData) {\n        return [...gameData.players.values()].map(x => x.cards).flat();\n    }\n\n    export function getPlayerCardIds(gameData: GameEngine.IGameData) {\n        return getPlayerCards(gameData).map(x => x.id);\n    }\n\n    export function isEnemyCard(gameData: GameEngine.IGameData, card: GameEngine.ICardState): card is GameEngine.IEnemyCardState {\n        return !!gameData.enemies.find(x => x.id === card.id);\n    }\n", "    export function isEnemyCard(gameData: GameEngine.IGameData, card: GameEngine.ICardState): card is GameEngine.IEnemyCardState {\n        return !!gameData.enemies.find(x => x.id === card.id);\n    }\n\n    export function isPlayerCard(gameData: GameEngine.IGameData, card: GameEngine.ICardState): card is GameEngine.IPlayerCardState {\n        return !isEnemyCard(gameData, card);\n    }\n\n    export function recalculateScripts(engine: GameEngine.IGameEngine, card: GameEngine.ICardState) {\n        if (card.isRemoved) return;\n\n        card.scripts = card.scripts.map(x => CardScript.deserialize(engine, card, x).serialize());\n        engine.broadcast.push(...card.scripts.map(x => ({\n            type: 'scriptChanged',\n            cardId: card.id,\n            scriptData: x,\n        })));\n", "    export function recalculateScripts(engine: GameEngine.IGameEngine, card: GameEngine.ICardState) {\n        if (card.isRemoved) return;\n\n        card.scripts = card.scripts.map(x => CardScript.deserialize(engine, card, x).serialize());\n        engine.broadcast.push(...card.scripts.map(x => ({\n            type: 'scriptChanged',\n            cardId: card.id,\n            scriptData: x,\n        })));\n\n        if (isEnemyCard(engine.gameData, card) && card.intent?.scriptData) {\n            card.intent.scriptData = CardScript.deserialize(engine, card, card.intent.scriptData).serialize();\n            engine.broadcast.push({\n                type: 'cardIntent',\n                cardId: card.id,\n                intent: card.intent,\n            });\n        }\n    }\n", "        if (isEnemyCard(engine.gameData, card) && card.intent?.scriptData) {\n            card.intent.scriptData = CardScript.deserialize(engine, card, card.intent.scriptData).serialize();\n            engine.broadcast.push({\n                type: 'cardIntent',\n                cardId: card.id,\n                intent: card.intent,\n            });\n        }\n    }\n\n    export function revalidateIntents(engine: GameEngine.IGameEngine, regenerateIfInvalid: boolean) {", "    export function revalidateIntents(engine: GameEngine.IGameEngine, regenerateIfInvalid: boolean) {\n        for (const enemy of engine.gameData.enemies) {\n            if (!enemy.intent || enemy.intent.targetCardId === -1) {\n                continue;\n            }\n\n            const script = CardScript.deserialize(engine, enemy, enemy.intent.scriptData);\n            const validTargets = script.targetFinder(engine.gameData, enemy);\n            if (validTargets.find(x => x.id === enemy.intent?.targetCardId)) {\n                continue;\n            }\n\n            enemy.intent = undefined;", "            if (validTargets.find(x => x.id === enemy.intent?.targetCardId)) {\n                continue;\n            }\n\n            enemy.intent = undefined;\n            if (regenerateIfInvalid) {\n                generateIntent(engine, enemy);\n            }\n        }\n    }\n", "    export function removeCard(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, contextCard?: GameEngine.ICardState) {\n        if (card.isRemoved) {\n            return;\n        }\n\n        if (isEnemyCard(engine.gameData, card)) {\n            engine.gameData.enemies.removeFirst(card)\n\n            engine.broadcast.push({\n                type: 'cardRemoved',\n                cardId: card.id,\n            });\n\n            GameEngineUtils.triggerMods('onCardDestroyed', { engine, contextCard, sourceCard: card });\n            card.isRemoved = true;\n", "            for (const enemy of [...engine.gameData.enemies]) {\n                if (enemy.isRemoved) continue;\n                triggerMods('onEnemyDestroyed', { engine, sourceCard: card, contextCard });\n            }\n\n            if (contextCard) {\n                const player = findPlayerByCardIdMaybe(engine.gameData, contextCard.id);\n                player && player.stats.kills++;\n            }\n\n            GameEngineUtils.revalidateIntents(engine, true);\n        } else {\n            const player = GameEngineUtils.findPlayerByCardId(engine.gameData, card.id);\n            player.cards.removeFirst(card);\n\n            engine.broadcast.push({\n                type: 'cardRemoved',\n                cardId: card.id,\n            });\n\n            GameEngineUtils.triggerMods('onCardDestroyed', { engine, contextCard, sourceCard: card });\n            card.isRemoved = true;\n\n            GameEngineUtils.revalidateIntents(engine, false);\n        }\n    }\n", "    export function scaleByCpuMem(baseValue: number, cpuMem: number, cpuMemScaling: 'normal' | 'less' | 'more' | 'minimal' | 'high' = 'normal') {\n        let valuePerCpu = baseValue / 2;\n        switch (cpuMemScaling) {\n            case 'high': valuePerCpu * 1.5; break;\n            case 'more': valuePerCpu * 1.25; break;\n            case 'less': valuePerCpu * .75; break;\n            case 'minimal': valuePerCpu * .5; break;\n        }\n\n        return Math.round(baseValue + ((cpuMem - 1) * valuePerCpu));\n    }\n", "    export function scaleByDifficulty(value: number, difficulty: number, decimals = 0) {\n        return round(value * Math.pow(1.1, difficulty - 1), decimals);\n    }\n\n    export function spawnEnemy(engine: GameEngine.IGameEngine, enemyClass: string, spawnIndex: number, generateIntent: boolean) {\n        const enemyFactory = engine.ruleset.enemyCards?.[enemyClass];\n        if (!enemyFactory) throw new Error('EnemyClass not found for spawning: ' + enemyClass);\n        const enemy = enemyFactory(engine);\n        enemy.enemyClass = enemyClass;\n        return addEnemy(engine, enemy, spawnIndex, generateIntent);\n    }\n", "    export function triggerMods<T extends CardMod.ModEvent>(ev: T, ...args: Parameters<NonNullable<CardMod[typeof ev]>>): ReturnType<NonNullable<CardMod[typeof ev]>>[] {\n        const deps = args[0];\n        const card = deps.sourceCard;\n        return [...card.mods]\n            .map(modData => (!card.isRemoved && card.mods.find(x => CardMod.areEqual(x, modData))) ? CardMod.trigger(ev, modData, ...args) : undefined)\n            .filter(Boolean);\n    }\n}"]}
{"filename": "src/game/rulesets/reaper.ts", "chunked_list": ["import { randInt } from '../../utils';\nimport { CardMod } from '../card-mods';\nimport { CardScriptParts } from '../card-script-parts';\nimport { CardScript } from '../card-scripts';\nimport { GameContent_v1 } from '../game-content-v1';\nimport { GameEngine } from '../game-engine';\nimport { GameEngineUtils } from '../game-engine-utils';\n\nexport const RulesetReaper = {\n    cardMods: {\n        reaper_feederCorrupted: class extends CardMod {\n\n        },\n", "export const RulesetReaper = {\n    cardMods: {\n        reaper_feederCorrupted: class extends CardMod {\n\n        },\n\n        reaper_feederPower: class extends CardMod {\n            override onSecDamageIn(deps: CardMod.ICardModDeps, damage: number, attacker: GameEngine.ICardState) {\n                if (deps.sourceCard.sec - damage > 0) return;\n\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, -deps.sourceCard.sec, true);\n                CardMod.removeModByName(deps.engine, deps.sourceCard, this.constructor.name, attacker);\n                CardMod.addMod(deps.engine, deps.sourceCard, new RulesetReaper.cardMods.reaper_feederCorrupted(), attacker);\n                CardMod.addMod(deps.engine, deps.sourceCard, new CardMod.Content.impervious(), attacker);\n\n                const player = GameEngineUtils.findPlayerByCardIdMaybe(deps.engine.gameData, attacker.id);\n                player && player.stats.kills++;\n\n                return { secDmgBonus: -9999 };\n            }\n        },\n    },\n\n    cardScripts: {", "                if (deps.sourceCard.sec - damage > 0) return;\n\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, -deps.sourceCard.sec, true);\n                CardMod.removeModByName(deps.engine, deps.sourceCard, this.constructor.name, attacker);\n                CardMod.addMod(deps.engine, deps.sourceCard, new RulesetReaper.cardMods.reaper_feederCorrupted(), attacker);\n                CardMod.addMod(deps.engine, deps.sourceCard, new CardMod.Content.impervious(), attacker);\n\n                const player = GameEngineUtils.findPlayerByCardIdMaybe(deps.engine.gameData, attacker.id);\n                player && player.stats.kills++;\n\n                return { secDmgBonus: -9999 };\n            }\n        },\n    },\n\n    cardScripts: {", "        reaper_bossEat: class extends CardScript {\n            constructor(_card: GameEngine.ICardState) {\n                super(\n                    [],\n                    (gameData, _card) => {\n                        return gameData.enemies.filter(x => x.enemyClass === RulesetReaper.enemyCards.reaper_feeder.name);\n                    },\n                    [\n                        {\n                            targetResolver: CardScript.TargetResolvers.Target,\n                            parts: [\n                                (engine, source, target) => {\n                                    GameEngineUtils.removeCard(engine, target, source);\n", "                                    if (target.mods.find(x => x[0] === RulesetReaper.cardMods.reaper_feederCorrupted.name)) {\n                                        GameEngineUtils.changeSec(engine, source, -50, false);\n                                        if (source.sec <= 0) {\n                                            GameEngineUtils.removeCard(engine, source);\n                                            return;\n                                        }\n                                    } else {\n                                        GameEngineUtils.changeSec(engine, source, Math.round(target.sec / 2), false);\n                                        GameEngineUtils.changeCpu(engine, source, 1);\n                                        for (const guardian of engine.gameData.enemies.filter(x => x.enemyClass === RulesetReaper.enemyCards.reaper_guardian.name)) {\n                                            CardMod.addMod(engine, guardian, new GameContent_v1.cardMods.optimized(1, -1));\n                                        }\n                                    }\n\n                                    const highDiff = engine.gameData.difficulty >= 7;", "                                        for (const guardian of engine.gameData.enemies.filter(x => x.enemyClass === RulesetReaper.enemyCards.reaper_guardian.name)) {\n                                            CardMod.addMod(engine, guardian, new GameContent_v1.cardMods.optimized(1, -1));\n                                        }\n                                    }\n\n                                    const highDiff = engine.gameData.difficulty >= 7;\n                                    if (engine.gameData.enemies.length <= (highDiff ? 6 : 4)) {\n                                        while (engine.gameData.enemies.findIndex(x => x.id === source.id) < (highDiff ? 4 : 3)) {\n                                            CardScriptParts.SpawnEnemy('reaper_feeder', 'absLeft')(engine, source, target);\n                                        }\n                                        while (engine.gameData.enemies.length < (highDiff ? 9 : 7)) {\n                                            CardScriptParts.SpawnEnemy('reaper_feeder', 'absRight')(engine, source, target);\n                                        }\n                                    }\n                                },\n                            ],\n                        }\n                    ],\n                );\n            }\n        },\n    },\n\n    enemyCards: {\n        reaper_feeder: (engine: GameEngine.IGameEngine): GameEngine.IEnemyCardState => {\n            return {\n                id: engine.nextId(),\n                enemyClass: 'reaper_feeder',\n                cpu: 0,\n                mem: 0,\n                maxMem: 0,\n                sec: randInt(\n                    GameEngineUtils.scaleByDifficulty(50, engine.gameData.difficulty),\n                    GameEngineUtils.scaleByDifficulty(100, engine.gameData.difficulty),\n                ),\n                mods: [\n                    new RulesetReaper.cardMods.reaper_feederPower().serialize(),\n                ],\n                scripts: [],\n            };\n        },\n\n        reaper_guardian: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: 'reaper_guardian',\n                cpu: 2,\n                mem: 0,\n                maxMem: 0,\n                sec: 1,\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                    new CardMod.Content.impervious().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n            );\n            return enemy;\n        },\n\n\n        reaper_lesser_guardian: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: 'reaper_lesser_guardian',\n                cpu: 2,\n                mem: 0,\n                maxMem: 0,\n                sec: 1,\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                    new CardMod.Content.impervious().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak', 1).serialize(),\n            );\n            return enemy;\n        },\n    },\n\n    initGame(engine: GameEngine.IGameEngine) {\n        const boss: GameEngine.IEnemyCardState = {\n            id: engine.nextId(),\n            enemyClass: 'reaper_boss',\n            cpu: 0,\n            mem: 0,\n            maxMem: 0,\n            sec: GameEngineUtils.scaleByDifficulty(250, engine.gameData.difficulty),\n            mods: [\n                new CardMod.Content._standardAi().serialize(),\n                new CardMod.Content._winOnDeath().serialize(),\n                new CardMod.Content.impervious().serialize(),\n            ],\n            scripts: [],\n        };\n\n        boss.scripts.push(\n            new RulesetReaper.cardScripts.reaper_bossEat(boss).serialize(),\n        );\n\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_feeder(engine), 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_lesser_guardian(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_guardian(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, boss, 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_guardian(engine), 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_lesser_guardian(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_feeder(engine), 0, true);\n    },\n};\n", "                                        while (engine.gameData.enemies.length < (highDiff ? 9 : 7)) {\n                                            CardScriptParts.SpawnEnemy('reaper_feeder', 'absRight')(engine, source, target);\n                                        }\n                                    }\n                                },\n                            ],\n                        }\n                    ],\n                );\n            }\n        },\n    },\n\n    enemyCards: {\n        reaper_feeder: (engine: GameEngine.IGameEngine): GameEngine.IEnemyCardState => {\n            return {\n                id: engine.nextId(),\n                enemyClass: 'reaper_feeder',\n                cpu: 0,\n                mem: 0,\n                maxMem: 0,\n                sec: randInt(\n                    GameEngineUtils.scaleByDifficulty(50, engine.gameData.difficulty),\n                    GameEngineUtils.scaleByDifficulty(100, engine.gameData.difficulty),\n                ),\n                mods: [\n                    new RulesetReaper.cardMods.reaper_feederPower().serialize(),\n                ],\n                scripts: [],\n            };\n        },\n\n        reaper_guardian: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: 'reaper_guardian',\n                cpu: 2,\n                mem: 0,\n                maxMem: 0,\n                sec: 1,\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                    new CardMod.Content.impervious().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n            );\n            return enemy;\n        },\n\n\n        reaper_lesser_guardian: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: 'reaper_lesser_guardian',\n                cpu: 2,\n                mem: 0,\n                maxMem: 0,\n                sec: 1,\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                    new CardMod.Content.impervious().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak', 1).serialize(),\n            );\n            return enemy;\n        },\n    },\n\n    initGame(engine: GameEngine.IGameEngine) {\n        const boss: GameEngine.IEnemyCardState = {\n            id: engine.nextId(),\n            enemyClass: 'reaper_boss',\n            cpu: 0,\n            mem: 0,\n            maxMem: 0,\n            sec: GameEngineUtils.scaleByDifficulty(250, engine.gameData.difficulty),\n            mods: [\n                new CardMod.Content._standardAi().serialize(),\n                new CardMod.Content._winOnDeath().serialize(),\n                new CardMod.Content.impervious().serialize(),\n            ],\n            scripts: [],\n        };\n\n        boss.scripts.push(\n            new RulesetReaper.cardScripts.reaper_bossEat(boss).serialize(),\n        );\n\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_feeder(engine), 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_lesser_guardian(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_guardian(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, boss, 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_guardian(engine), 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_lesser_guardian(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_feeder(engine), 0, true);\n    },\n};\n"]}
{"filename": "src/game/rulesets/goliath.ts", "chunked_list": ["import { CardMod } from '../card-mods';\nimport { CardScript } from '../card-scripts';\nimport { GameContent_v1 } from '../game-content-v1';\nimport { GameEngine } from '../game-engine';\nimport { GameEngineUtils } from '../game-engine-utils';\n\nconst GOLIATH_ID = 9999;\n\nexport const RulesetGoliath = {\n    cardMods: {\n        goliath_power_supply: class extends CardMod {\n            override onCardDestroyed(deps: CardMod.ICardModDeps) {\n                const goliath = GameEngineUtils.findCardById(deps.engine.gameData, GOLIATH_ID);\n                CardMod.addMod(deps.engine, goliath, new RulesetGoliath.cardMods.goliath_boss_power(), deps.sourceCard);\n            }\n        },\n", "export const RulesetGoliath = {\n    cardMods: {\n        goliath_power_supply: class extends CardMod {\n            override onCardDestroyed(deps: CardMod.ICardModDeps) {\n                const goliath = GameEngineUtils.findCardById(deps.engine.gameData, GOLIATH_ID);\n                CardMod.addMod(deps.engine, goliath, new RulesetGoliath.cardMods.goliath_boss_power(), deps.sourceCard);\n            }\n        },\n\n        goliath_shield_supply: class extends CardMod {\n            override onCardDestroyed(deps: CardMod.ICardModDeps) {\n                const goliath = GameEngineUtils.findCardById(deps.engine.gameData, GOLIATH_ID);\n                CardMod.addMod(deps.engine, goliath, new RulesetGoliath.cardMods.goliath_boss_shield(), deps.sourceCard);\n            }\n        },\n", "        goliath_shield_supply: class extends CardMod {\n            override onCardDestroyed(deps: CardMod.ICardModDeps) {\n                const goliath = GameEngineUtils.findCardById(deps.engine.gameData, GOLIATH_ID);\n                CardMod.addMod(deps.engine, goliath, new RulesetGoliath.cardMods.goliath_boss_shield(), deps.sourceCard);\n            }\n        },\n\n        goliath_boss_ai: class extends CardMod {\n            override onTurnStart(deps: CardMod.ICardModDeps) {\n                GameEngineUtils.generateIntent(deps.engine, deps.sourceCard as GameEngine.IEnemyCardState);\n            }\n\n            override onTurnEnd(deps: CardMod.ICardModDeps) {\n                const boss = deps.sourceCard as GameEngine.IEnemyCardState;\n                const targetId = boss.intent?.targetCardId;", "                if (!targetId) return;\n\n                let numAttacks = 1;\n                const powerBuff = CardMod.findModOfType(boss, RulesetGoliath.cardMods.goliath_boss_power);\n                if (powerBuff) {\n                    const powerStacks = CardMod.getStackCount(powerBuff);\n                    numAttacks += powerStacks;\n                }\n\n                for (let i = 0; i < numAttacks - 1; i++) {\n                    GameEngineUtils.executeIntent(deps.engine, boss, true);\n                }\n                GameEngineUtils.executeIntent(deps.engine, boss);\n            }\n\n            override onMemDmgIn(deps: CardMod.ICardModDeps, memDmg: number) {", "                for (let i = 0; i < numAttacks - 1; i++) {\n                    GameEngineUtils.executeIntent(deps.engine, boss, true);\n                }\n                GameEngineUtils.executeIntent(deps.engine, boss);\n            }\n\n            override onMemDmgIn(deps: CardMod.ICardModDeps, memDmg: number) {\n                if (deps.sourceCard.mem - memDmg <= 0) return;\n\n                const boss = deps.sourceCard as GameEngine.IEnemyCardState;\n                let secBonus = 100;\n                const shieldBuff = CardMod.findModOfType(boss, RulesetGoliath.cardMods.goliath_boss_shield);", "                if (shieldBuff) {\n                    secBonus += CardMod.getStackCount(shieldBuff) * 100;\n                }\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, GameEngineUtils.scaleByDifficulty(secBonus, deps.engine.gameData.difficulty), false, deps.sourceCard);\n\n                for (const enemy of [...deps.engine.gameData.enemies]) {\n                    if (enemy === boss) continue;\n\n                    CardMod.addMod(deps.engine, enemy, new GameContent_v1.cardMods.optimized(1, -1), boss);\n                }\n            }\n        },\n", "        goliath_boss_power: class extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.stack as const,\n                stackCount: 1,\n            };\n        },\n\n        goliath_boss_shield: class extends CardMod {\n            override stackingConfig = {\n                behavior: CardMod.StackingBehavior.stack as const,\n                stackCount: 1,\n            };\n        },\n    },\n\n    enemyCards: {\n        goliath_power_node: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: '',\n\n                cpu: 2,\n                mem: 2,\n                maxMem: 2,\n                sec: GameEngineUtils.scaleByDifficulty(35, engine.gameData.difficulty),\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                    new RulesetGoliath.cardMods.goliath_power_supply().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak').serialize(),\n            );\n            return enemy;\n        },\n\n        goliath_shield_node: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: '',\n\n                cpu: 1,\n                mem: 2,\n                maxMem: 2,\n                sec: GameEngineUtils.scaleByDifficulty(45, engine.gameData.difficulty),\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                    new RulesetGoliath.cardMods.goliath_shield_supply().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._defend(enemy, engine.gameData.difficulty, 'weak').serialize(),\n                new CardScript.Content._firewallSelf(enemy, 1, 2).serialize(),\n            );\n            return enemy;\n        },\n    },\n\n    initGame(engine: GameEngine.IGameEngine) {\n        const boss: GameEngine.IEnemyCardState = {\n            id: GOLIATH_ID,\n            enemyClass: 'goliath_boss',\n            cpu: 2,\n            mem: 4,\n            maxMem: 4,\n            sec: GameEngineUtils.scaleByDifficulty(100, engine.gameData.difficulty),\n            mods: [\n                new RulesetGoliath.cardMods.goliath_boss_ai().serialize(),\n                new CardMod.Content._winOnDeath().serialize(),\n            ],\n            scripts: [],\n        };\n\n        boss.scripts.push(\n            new CardScript.Content._attack(boss, engine.gameData.difficulty).serialize(),\n        );\n\n        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_power_node.name, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n        GameEngineUtils.addEnemy(engine, boss, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_power_node.name, 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n    },\n};"]}
{"filename": "src/game/rulesets/intro.ts", "chunked_list": ["import { CardMod } from '../card-mods';\nimport { CardScript } from '../card-scripts';\nimport { GameEngine } from '../game-engine';\nimport { GameEngineUtils } from '../game-engine-utils';\n\nexport const RulesetMfrm = {\n    enemyCards: {\n        intro_sentinel: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),", "            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: 'intro_sentinel',\n                cpu: 2,\n                mem: 2,\n                maxMem: 2,\n                sec: GameEngineUtils.scaleByDifficulty(50, engine.gameData.difficulty),\n                mods: [new CardMod.Content._standardAi().serialize()],\n                scripts: [],\n            };", "                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n                new CardScript.Content._defend(enemy, engine.gameData.difficulty).serialize(),\n                new CardScript.Content._firewallSelf(enemy, 1, 2).serialize(),\n            );\n            return enemy;\n        },\n", "        },\n\n        intro_perimeter: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: 'intro_perimeter',\n                cpu: 1,\n                mem: 1,\n                maxMem: 1,\n                sec: GameEngineUtils.scaleByDifficulty(30, engine.gameData.difficulty),", "                maxMem: 1,\n                sec: GameEngineUtils.scaleByDifficulty(30, engine.gameData.difficulty),\n                mods: [new CardMod.Content._standardAi().serialize()],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak').serialize(),\n            );\n            return enemy;\n        },", "            return enemy;\n        },\n    },\n\n    initGame(engine: GameEngine.IGameEngine) {\n        const boss: GameEngine.IEnemyCardState = {\n            id: engine.nextId(),\n            enemyClass: 'intro_boss',\n            cpu: 3,\n            mem: 3,", "            cpu: 3,\n            mem: 3,\n            maxMem: 3,\n            sec: GameEngineUtils.scaleByDifficulty(125, engine.gameData.difficulty),\n            mods: [],\n            scripts: [],\n        };\n        boss.mods.push(\n            new CardMod.Content._standardAi().serialize(),\n            new CardMod.Content._waveTrigger(['reaper', 'goliath', 'stasis', 'stasis'], 12).serialize(),", "            new CardMod.Content._standardAi().serialize(),\n            new CardMod.Content._waveTrigger(['reaper', 'goliath', 'stasis', 'stasis'], 12).serialize(),\n            new CardMod.Content._yieldScript(new CardScript.Content._spawn(boss, RulesetMfrm.enemyCards.intro_perimeter.name, undefined, undefined, 2).serialize(), 2).serialize(),\n        );\n        boss.scripts.push(\n            new CardScript.Content._defend(boss, engine.gameData.difficulty).serialize(),\n        );\n\n        GameEngineUtils.addEnemy(engine, boss, 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_sentinel(engine), 0, true);", "        GameEngineUtils.addEnemy(engine, boss, 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_sentinel(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), 0, true);\n        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_sentinel(engine), engine.gameData.enemies.length, true);\n        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), engine.gameData.enemies.length, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), engine.gameData.enemies.length, true);\n    }\n};", "};"]}
{"filename": "src/game/rulesets/stasis.ts", "chunked_list": ["import { CardMod } from '../card-mods';\nimport { CardScriptParts } from '../card-script-parts';\nimport { CardScript } from '../card-scripts';\nimport { GameEngine } from '../game-engine';\nimport { GameEngineUtils } from '../game-engine-utils';\n\nexport const RulesetStasis = {\n    cardMods: {\n        stasis_boss_ai: class extends CardMod.Content._standardAi {\n            override onMemDmgIn(deps: CardMod.ICardModDeps, memDmg: number) {\n                if (deps.sourceCard.mem - memDmg <= 0) return;\n", "        stasis_boss_ai: class extends CardMod.Content._standardAi {\n            override onMemDmgIn(deps: CardMod.ICardModDeps, memDmg: number) {\n                if (deps.sourceCard.mem - memDmg <= 0) return;\n\n                for (const playerCard of GameEngineUtils.getPlayerCards(deps.engine.gameData)) {\n                    CardMod.addMod(deps.engine, playerCard, new CardMod.Content.lag(1), deps.sourceCard);\n                }\n\n                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, GameEngineUtils.scaleByDifficulty(125, deps.engine.gameData.difficulty), false, deps.contextCard);\n\n                if (![...deps.engine.gameData.enemies].find(x => x.enemyClass === RulesetStasis.enemyCards.stasis_disruptor.name)) {\n                    GameEngineUtils.spawnEnemy(deps.engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n                }\n            }\n        },\n    },\n\n    enemyCards: {\n        stasis_disruptor: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: '',\n\n                cpu: 1,\n                mem: 3,\n                maxMem: 3,\n                sec: GameEngineUtils.scaleByDifficulty(35, engine.gameData.difficulty),\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n                new RulesetStasis.cardScripts.stasis_disrupt(enemy, engine.gameData.difficulty).serialize(),\n            );\n            return enemy;\n        },\n\n        stasis_shocker: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: '',\n\n                cpu: 1,\n                mem: 2,\n                maxMem: 2,\n                sec: GameEngineUtils.scaleByDifficulty(45, engine.gameData.difficulty),\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n            );\n            return enemy;\n        },\n    },\n\n    cardScripts: {", "                if (![...deps.engine.gameData.enemies].find(x => x.enemyClass === RulesetStasis.enemyCards.stasis_disruptor.name)) {\n                    GameEngineUtils.spawnEnemy(deps.engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n                }\n            }\n        },\n    },\n\n    enemyCards: {\n        stasis_disruptor: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: '',\n\n                cpu: 1,\n                mem: 3,\n                maxMem: 3,\n                sec: GameEngineUtils.scaleByDifficulty(35, engine.gameData.difficulty),\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n                new RulesetStasis.cardScripts.stasis_disrupt(enemy, engine.gameData.difficulty).serialize(),\n            );\n            return enemy;\n        },\n\n        stasis_shocker: (engine: GameEngine.IGameEngine) => {\n            const enemy: GameEngine.IEnemyCardState = {\n                id: engine.nextId(),\n                enemyClass: '',\n\n                cpu: 1,\n                mem: 2,\n                maxMem: 2,\n                sec: GameEngineUtils.scaleByDifficulty(45, engine.gameData.difficulty),\n                mods: [\n                    new CardMod.Content._standardAi().serialize(),\n                ],\n                scripts: [],\n            };\n            enemy.scripts.push(\n                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n            );\n            return enemy;\n        },\n    },\n\n    cardScripts: {", "        stasis_disrupt: class extends CardScript {\n            constructor(card: GameEngine.ICardState, difficulty: number) {\n                const dmg = GameEngineUtils.scaleByDifficulty(GameEngineUtils.scaleByCpuMem(5, card.cpu), difficulty);\n\n                super(\n                    [difficulty, dmg],\n                    CardScript.TargetFinders.Opponents(),\n                    [\n                        {\n                            targetResolver: CardScript.TargetResolvers.Target,\n                            parts: [\n                                CardScriptParts.Attack(dmg),\n                                CardScriptParts.AddMod(new CardMod.Content.lag(2)),\n                            ],\n                        }\n                    ],\n                );\n            }\n        }\n    },\n\n    initGame(engine: GameEngine.IGameEngine) {\n        const boss: GameEngine.IEnemyCardState = {\n            id: engine.nextId(),\n            enemyClass: 'stasis_boss',\n            cpu: 3,\n            mem: 3,\n            maxMem: 3,\n            sec: GameEngineUtils.scaleByDifficulty(125, engine.gameData.difficulty),\n            mods: [\n                new RulesetStasis.cardMods.stasis_boss_ai().serialize(),\n                new CardMod.Content._winOnDeath().serialize(),\n            ],\n            scripts: [],\n        };\n\n        boss.scripts.push(\n            new CardScript.Content._attack(boss, engine.gameData.difficulty, 'strong').serialize(),\n            new RulesetStasis.cardScripts.stasis_disrupt(boss, engine.gameData.difficulty).serialize(),\n        );\n\n        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_shocker.name, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n        GameEngineUtils.addEnemy(engine, boss, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_shocker.name, 0, true);\n        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n    },\n};"]}
