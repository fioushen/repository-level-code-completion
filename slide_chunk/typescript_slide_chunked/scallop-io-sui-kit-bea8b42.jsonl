{"filename": "test/index.spec.ts", "chunked_list": ["import * as dotenv from 'dotenv';\nimport { describe, it, expect } from 'vitest';\nimport { SuiKit, SuiTxBlock } from '../src/index';\nimport { SuiOwnedObject } from '../src/libs/suiModel';\n\ndotenv.config();\n\n/**\n *  Remove `.skip` to proceed with testing according to requirements.\n */", " *  Remove `.skip` to proceed with testing according to requirements.\n */\ndescribe('Test Scallop Kit', async () => {\n  const fullnodeUrls = [\n    'https://api.shinami.com/node/v1/sui_mainnet_af69715eb5088e2eb2000069999a65d8',\n    'https://sui-mainnet.blockvision.org/v1/2Sf0z3YB6WWNOcn8HuUWHjdp4Sb',\n    'https://fullnode.mainnet.sui.io:443',\n  ];\n  const suiKit = new SuiKit({\n    // secretKey: process.env.SECRET_KEY,", "  const suiKit = new SuiKit({\n    // secretKey: process.env.SECRET_KEY,\n    mnemonics: process.env.MNEMONICS,\n    fullnodeUrls,\n  });\n\n  it('Manage account', async () => {\n    const coinType = '0x2::sui::SUI';\n    const addr = suiKit.getAddress({ accountIndex: 0 });\n    const balance = (await suiKit.getBalance(coinType, { accountIndex: 0 }))", "    const addr = suiKit.getAddress({ accountIndex: 0 });\n    const balance = (await suiKit.getBalance(coinType, { accountIndex: 0 }))\n      .totalBalance;\n    console.log(`Account ${0}: ${addr} has ${balance} SUI`);\n\n    expect(!!addr).toBe(true);\n  });\n\n  it('use multiple fullnodeUrls', async () => {\n    const tx = new SuiTxBlock();", "  it('use multiple fullnodeUrls', async () => {\n    const tx = new SuiTxBlock();\n    const gas = new SuiOwnedObject({\n      objectId:\n        '0x6d8528380c0e91611f674af8ae12a509cd63288607bc07c981a1f15fb7d3a19b',\n    });\n    await suiKit.updateObjects([gas]);\n    tx.moveCall('0x2::sui::getSUI');\n    tx.setSender(suiKit.currentAddress());\n    tx.setGasPrice(1000);", "    tx.setSender(suiKit.currentAddress());\n    tx.setGasPrice(1000);\n    tx.setGasPayment([\n      { objectId: gas.objectId, version: gas.version!, digest: gas.digest! },\n    ]);\n    tx.setGasBudget(10 ** 7);\n    const res = await suiKit.signAndSendTxn(tx);\n    console.log(res);\n  });\n", "  });\n\n  it('getObjects', async () => {\n    const res = await suiKit.getObjects([\n      '0x6d8528380c0e91611f674af8ae12a509cd63288607bc07c981a1f15fb7d3a19c',\n    ]);\n    console.log(res);\n  });\n});\n", "});\n"]}
{"filename": "src/suiKit.ts", "chunked_list": ["/**\n * @description This file is used to aggregate the tools that used to interact with SUI network.\n */\nimport {\n  RawSigner,\n  TransactionBlock,\n  DevInspectResults,\n  SuiTransactionBlockResponse,\n} from '@mysten/sui.js';\nimport { SuiAccountManager } from './libs/suiAccountManager';", "} from '@mysten/sui.js';\nimport { SuiAccountManager } from './libs/suiAccountManager';\nimport { SuiTxBlock } from './libs/suiTxBuilder';\nimport { SuiInteractor, getDefaultConnection } from './libs/suiInteractor';\nimport { SuiSharedObject, SuiOwnedObject } from './libs/suiModel';\nimport { SuiKitParams, DerivePathParams, SuiTxArg, SuiVecTxArg } from './types';\n\n/**\n * @class SuiKit\n * @description This class is used to aggregate the tools that used to interact with SUI network.\n */", " * @class SuiKit\n * @description This class is used to aggregate the tools that used to interact with SUI network.\n */\nexport class SuiKit {\n  public accountManager: SuiAccountManager;\n  public suiInteractor: SuiInteractor;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type\n   */\n  constructor({\n    mnemonics,\n    secretKey,\n    networkType,\n    fullnodeUrls,\n  }: SuiKitParams = {}) {\n    // Init the account manager\n    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });\n    // Init the rpc provider\n    fullnodeUrls = fullnodeUrls || [getDefaultConnection(networkType).fullnode];\n    this.suiInteractor = new SuiInteractor(fullnodeUrls);\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.\n   * else:\n   * it will generate signer from the mnemonic with the given derivePathParams.\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getSigner(derivePathParams?: DerivePathParams) {\n    const keyPair = this.accountManager.getKeyPair(derivePathParams);\n    return new RawSigner(keyPair, this.suiInteractor.currentProvider);\n  }\n\n  /**\n   * @description Switch the current account with the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    this.accountManager.switchAccount(derivePathParams);\n  }\n\n  /**\n   * @description Get the address of the account for the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    return this.accountManager.getAddress(derivePathParams);\n  }\n  currentAddress() {\n    return this.accountManager.currentAddress;\n  }\n\n  provider() {\n    return this.suiInteractor.currentProvider;\n  }\n\n  async getBalance(coinType?: string, derivePathParams?: DerivePathParams) {\n    const owner = this.accountManager.getAddress(derivePathParams);\n    return this.suiInteractor.currentProvider.getBalance({ owner, coinType });\n  }\n\n  async getObjects(objectIds: string[]) {\n    return this.suiInteractor.getObjects(objectIds);\n  }\n\n  /**\n   * @description Update objects in a batch\n   * @param suiObjects\n   */\n  async updateObjects(suiObjects: (SuiSharedObject | SuiOwnedObject)[]) {\n    return this.suiInteractor.updateObjects(suiObjects);\n  }\n\n  async signTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ) {\n    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    const signer = this.getSigner(derivePathParams);\n    return signer.signTransactionBlock({ transactionBlock: tx });\n  }\n\n  async signAndSendTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ): Promise<SuiTransactionBlockResponse> {\n    const { transactionBlockBytes, signature } = await this.signTxn(\n      tx,\n      derivePathParams\n    );\n    return this.suiInteractor.sendTx(transactionBlockBytes, signature);\n  }\n\n  /**\n   * Transfer the given amount of SUI to the recipient\n   * @param recipient\n   * @param amount\n   * @param derivePathParams\n   */\n  async transferSui(\n    recipient: string,\n    amount: number,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.transferSui(recipient, amount);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Transfer to mutliple recipients\n   * @param recipients the recipients addresses\n   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients\n   * @param derivePathParams\n   */\n  async transferSuiToMany(\n    recipients: string[],\n    amounts: number[],\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.transferSuiToMany(recipients, amounts);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Transfer the given amounts of coin to multiple recipients\n   * @param recipients the list of recipient address\n   * @param amounts the amounts to transfer for each recipient", "   * @param coinType any custom coin type but not SUI\n   * @param derivePathParams the derive path params for the current signer\n   */\n  async transferCoinToMany(\n    recipients: string[],\n    amounts: number[],\n    coinType: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    const owner = this.accountManager.getAddress(derivePathParams);\n    const totalAmount = amounts.reduce((a, b) => a + b, 0);\n    const coins = await this.suiInteractor.selectCoins(\n      owner,\n      totalAmount,\n      coinType\n    );\n    tx.transferCoinToMany(\n      coins.map((c) => c.objectId),\n      owner,\n      recipients,\n      amounts\n    );\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  async transferCoin(\n    recipient: string,\n    amount: number,\n    coinType: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    return this.transferCoinToMany(\n      [recipient],\n      [amount],\n      coinType,\n      derivePathParams\n    );\n  }\n\n  async transferObjects(\n    objects: string[],\n    recipient: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.transferObjects(objects, recipient);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  async moveCall(callParams: {\n    target: string;\n    arguments?: (SuiTxArg | SuiVecTxArg)[];\n    typeArguments?: string[];\n    derivePathParams?: DerivePathParams;\n  }) {\n    const {\n      target,\n      arguments: args = [],\n      typeArguments = [],\n      derivePathParams,\n    } = callParams;\n    const tx = new SuiTxBlock();\n    tx.moveCall(target, args, typeArguments);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount\n   * @param amount\n   * @param coinType\n   * @param owner\n   */\n  async selectCoinsWithAmount(\n    amount: number,\n    coinType: string,\n    owner?: string\n  ) {\n    owner = owner || this.accountManager.currentAddress;\n    const coins = await this.suiInteractor.selectCoins(owner, amount, coinType);\n    return coins.map((c) => c.objectId);\n  }\n\n  /**\n   * stake the given amount of SUI to the validator\n   * @param amount the amount of SUI to stake\n   * @param validatorAddr the validator address\n   * @param derivePathParams the derive path params for the current signer\n   */\n  async stakeSui(\n    amount: number,\n    validatorAddr: string,\n    derivePathParams?: DerivePathParams\n  ) {\n    const tx = new SuiTxBlock();\n    tx.stakeSui(amount, validatorAddr);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.\n   * Since the transaction is not submitted, its gas cost is not charged.\n   * @param tx the transaction to execute\n   * @param derivePathParams the derive path params\n   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.\n   */\n  async inspectTxn(\n    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n    derivePathParams?: DerivePathParams\n  ): Promise<DevInspectResults> {\n    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    return this.suiInteractor.currentProvider.devInspectTransactionBlock({\n      transactionBlock: tx,\n      sender: this.getAddress(derivePathParams),\n    });\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export {\n  TransactionBlock,\n  SUI_CLOCK_OBJECT_ID,\n  SUI_SYSTEM_STATE_OBJECT_ID,\n} from '@mysten/sui.js';\nexport { SuiKit } from './suiKit';\nexport { SuiAccountManager } from './libs/suiAccountManager';\nexport { SuiTxBlock } from './libs/suiTxBuilder';\nexport type * from './types';\n", "export type * from './types';\n"]}
{"filename": "src/libs/suiInteractor/suiInteractor.ts", "chunked_list": ["import {\n  SuiTransactionBlockResponse,\n  SuiTransactionBlockResponseOptions,\n  JsonRpcProvider,\n  Connection,\n  getObjectDisplay,\n  getObjectFields,\n  getObjectId,\n  getObjectType,\n  getObjectVersion,", "  getObjectType,\n  getObjectVersion,\n  getSharedObjectInitialVersion,\n} from '@mysten/sui.js';\nimport { ObjectData } from 'src/types';\nimport { SuiOwnedObject, SuiSharedObject } from '../suiModel';\nimport { delay } from './util';\n\n/**\n * `SuiTransactionSender` is used to send transaction with a given gas coin.", "/**\n * `SuiTransactionSender` is used to send transaction with a given gas coin.\n * It always uses the gas coin to pay for the gas,\n * and update the gas coin after the transaction.\n */\nexport class SuiInteractor {\n  public readonly providers: JsonRpcProvider[];\n  public currentProvider: JsonRpcProvider;\n  constructor(fullNodeUrls: string[]) {\n    if (fullNodeUrls.length === 0)\n      throw new Error('fullNodeUrls must not be empty');\n    this.providers = fullNodeUrls.map(\n      (url) => new JsonRpcProvider(new Connection({ fullnode: url }))\n    );\n    this.currentProvider = this.providers[0];\n  }\n\n  switchToNextProvider() {\n    const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    this.currentProvider =\n      this.providers[(currentProviderIdx + 1) % this.providers.length];\n  }\n\n  async sendTx(\n    transactionBlock: Uint8Array | string,\n    signature: string | string[]\n  ): Promise<SuiTransactionBlockResponse> {\n    const txResOptions: SuiTransactionBlockResponseOptions = {\n      showEvents: true,\n      showEffects: true,\n      showObjectChanges: true,\n      showBalanceChanges: true,\n    };\n\n    // const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    // const providers = [\n    //   ...this.providers.slice(currentProviderIdx, this.providers.length),\n    //   ...this.providers.slice(0, currentProviderIdx),\n    // ]\n", "    if (fullNodeUrls.length === 0)\n      throw new Error('fullNodeUrls must not be empty');\n    this.providers = fullNodeUrls.map(\n      (url) => new JsonRpcProvider(new Connection({ fullnode: url }))\n    );\n    this.currentProvider = this.providers[0];\n  }\n\n  switchToNextProvider() {\n    const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    this.currentProvider =\n      this.providers[(currentProviderIdx + 1) % this.providers.length];\n  }\n\n  async sendTx(\n    transactionBlock: Uint8Array | string,\n    signature: string | string[]\n  ): Promise<SuiTransactionBlockResponse> {\n    const txResOptions: SuiTransactionBlockResponseOptions = {\n      showEvents: true,\n      showEffects: true,\n      showObjectChanges: true,\n      showBalanceChanges: true,\n    };\n\n    // const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    // const providers = [\n    //   ...this.providers.slice(currentProviderIdx, this.providers.length),\n    //   ...this.providers.slice(0, currentProviderIdx),\n    // ]\n", "    for (const provider of this.providers) {\n      try {\n        const res = await provider.executeTransactionBlock({\n          transactionBlock,\n          signature,\n          options: txResOptions,\n        });\n        return res;\n      } catch (err) {\n        console.warn(\n          `Failed to send transaction with fullnode ${provider.connection.fullnode}: ${err}`\n        );\n        await delay(2000);\n      }\n    }\n    throw new Error('Failed to send transaction with all fullnodes');\n  }\n  async getObjects(ids: string[]) {\n    const options = {\n      showContent: true,\n      showDisplay: true,\n      showType: true,\n      showOwner: true,\n    };\n\n    // const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    // const providers = [\n    //   ...this.providers.slice(currentProviderIdx, this.providers.length),\n    //   ...this.providers.slice(0, currentProviderIdx),\n    // ]\n", "      } catch (err) {\n        console.warn(\n          `Failed to send transaction with fullnode ${provider.connection.fullnode}: ${err}`\n        );\n        await delay(2000);\n      }\n    }\n    throw new Error('Failed to send transaction with all fullnodes');\n  }\n  async getObjects(ids: string[]) {\n    const options = {\n      showContent: true,\n      showDisplay: true,\n      showType: true,\n      showOwner: true,\n    };\n\n    // const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n    // const providers = [\n    //   ...this.providers.slice(currentProviderIdx, this.providers.length),\n    //   ...this.providers.slice(0, currentProviderIdx),\n    // ]\n", "    for (const provider of this.providers) {\n      try {\n        const objects = await provider.multiGetObjects({ ids, options });\n        const parsedObjects = objects.map((object) => {\n          const objectId = getObjectId(object);\n          const objectType = getObjectType(object);\n          const objectVersion = getObjectVersion(object);\n          const objectDigest = object.data ? object.data.digest : undefined;\n          const initialSharedVersion = getSharedObjectInitialVersion(object);\n          const objectFields = getObjectFields(object);\n          const objectDisplay = getObjectDisplay(object);\n          return {\n            objectId,\n            objectType,\n            objectVersion,\n            objectDigest,\n            objectFields,\n            objectDisplay,\n            initialSharedVersion,\n          };\n        });\n        return parsedObjects as ObjectData[];", "      } catch (err) {\n        await delay(2000);\n        console.warn(\n          `Failed to get objects with fullnode ${provider.connection.fullnode}: ${err}`\n        );\n      }\n    }\n    throw new Error('Failed to get objects with all fullnodes');\n  }\n\n  async getObject(id: string) {\n    const objects = await this.getObjects([id]);\n    return objects[0];\n  }\n\n  /**\n   * @description Update objects in a batch\n   * @param suiObjects\n   */\n  async updateObjects(suiObjects: (SuiOwnedObject | SuiSharedObject)[]) {\n    const objectIds = suiObjects.map((obj) => obj.objectId);\n    const objects = await this.getObjects(objectIds);", "    for (const object of objects) {\n      const suiObject = suiObjects.find(\n        (obj) => obj.objectId === object.objectId\n      );\n      if (suiObject instanceof SuiSharedObject) {\n        suiObject.initialSharedVersion = object.initialSharedVersion;\n      } else if (suiObject instanceof SuiOwnedObject) {\n        suiObject.version = object.objectVersion;\n        suiObject.digest = object.objectDigest;\n      }\n    }\n  }\n\n  /**\n   * @description Select coins that add up to the given amount.\n   * @param addr the address of the owner\n   * @param amount the amount that is needed for the coin\n   * @param coinType the coin type, default is '0x2::SUI::SUI'\n   */\n  async selectCoins(\n    addr: string,\n    amount: number,\n    coinType: string = '0x2::SUI::SUI'\n  ) {\n    const selectedCoins: {\n      objectId: string;\n      digest: string;\n      version: string;\n    }[] = [];\n    let totalAmount = 0;\n    let hasNext = true,\n      nextCursor: string | null = null;", "    while (hasNext && totalAmount < amount) {\n      const coins = await this.currentProvider.getCoins({\n        owner: addr,\n        coinType: coinType,\n        cursor: nextCursor,\n      });\n      // Sort the coins by balance in descending order\n      coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));\n      for (const coinData of coins.data) {\n        selectedCoins.push({\n          objectId: coinData.coinObjectId,\n          digest: coinData.digest,\n          version: coinData.version,\n        });\n        totalAmount = totalAmount + parseInt(coinData.balance);", "      for (const coinData of coins.data) {\n        selectedCoins.push({\n          objectId: coinData.coinObjectId,\n          digest: coinData.digest,\n          version: coinData.version,\n        });\n        totalAmount = totalAmount + parseInt(coinData.balance);\n        if (totalAmount >= amount) {\n          break;\n        }\n      }\n\n      nextCursor = coins.nextCursor;\n      hasNext = coins.hasNextPage;\n    }\n", "    if (!selectedCoins.length) {\n      throw new Error('No valid coins found for the transaction.');\n    }\n    return selectedCoins;\n  }\n}\n"]}
{"filename": "src/libs/suiInteractor/defaultConfig.ts", "chunked_list": ["import {\n  localnetConnection,\n  devnetConnection,\n  testnetConnection,\n  mainnetConnection,\n} from '@mysten/sui.js';\nimport type { Connection } from '@mysten/sui.js';\nimport type { NetworkType } from 'src/types';\nexport const defaultGasBudget = 10 ** 8; // 0.1 SUI, should be enough for most of the transactions\nexport const defaultGasPrice = 1000; // 1000 MIST", "export const defaultGasBudget = 10 ** 8; // 0.1 SUI, should be enough for most of the transactions\nexport const defaultGasPrice = 1000; // 1000 MIST\n\n/**\n * @description Get the default fullnode url and faucet url for the given network type\n * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n * @returns { fullNode: string, websocket: string, faucet?: string }\n */\nexport const getDefaultConnection = (\n  networkType: NetworkType = 'devnet'", "export const getDefaultConnection = (\n  networkType: NetworkType = 'devnet'\n): Connection => {\n  switch (networkType) {\n    case 'localnet':\n      return localnetConnection;\n    case 'devnet':\n      return devnetConnection;\n    case 'testnet':\n      return testnetConnection;", "    case 'testnet':\n      return testnetConnection;\n    case 'mainnet':\n      return mainnetConnection;\n    default:\n      return devnetConnection;\n  }\n};\n", ""]}
{"filename": "src/libs/suiInteractor/index.ts", "chunked_list": ["export { SuiInteractor } from './suiInteractor';\nexport { getDefaultConnection } from './defaultConfig';\n"]}
{"filename": "src/libs/suiInteractor/util.ts", "chunked_list": ["export const delay = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n"]}
{"filename": "src/libs/suiTxBuilder/index.ts", "chunked_list": ["import {\n  TransactionBlock,\n  SUI_SYSTEM_STATE_OBJECT_ID,\n  TransactionExpiration,\n  SuiObjectRef,\n  SharedObjectRef,\n  JsonRpcProvider,\n  TransactionType,\n  Transactions,\n  ObjectCallArg,", "  Transactions,\n  ObjectCallArg,\n} from '@mysten/sui.js';\nimport { convertArgs } from './util';\nimport type { SuiTxArg, SuiObjectArg, SuiVecTxArg } from 'src/types';\n\nexport class SuiTxBlock {\n  public txBlock: TransactionBlock;\n  constructor(transaction?: TransactionBlock) {\n    this.txBlock = new TransactionBlock(transaction);\n  }\n\n  //======== override methods of TransactionBlock ============\n\n  address(value: string) {\n    return this.txBlock.pure(value, 'address');\n  }\n  pure(value: unknown, type?: string) {\n    return this.txBlock.pure(value, type);\n  }\n  object(value: string | ObjectCallArg) {\n    return this.txBlock.object(value);\n  }\n  objectRef(ref: SuiObjectRef) {\n    return this.txBlock.objectRef(ref);\n  }\n  sharedObjectRef(ref: SharedObjectRef) {\n    return this.txBlock.sharedObjectRef(ref);\n  }\n  setSender(sender: string) {\n    return this.txBlock.setSender(sender);\n  }\n  setSenderIfNotSet(sender: string) {\n    return this.txBlock.setSenderIfNotSet(sender);\n  }\n  setExpiration(expiration?: TransactionExpiration) {\n    return this.txBlock.setExpiration(expiration);\n  }\n  setGasPrice(price: number | bigint) {\n    return this.txBlock.setGasPrice(price);\n  }\n  setGasBudget(budget: number | bigint) {\n    return this.txBlock.setGasBudget(budget);\n  }\n  setGasOwner(owner: string) {\n    return this.txBlock.setGasOwner(owner);\n  }\n  setGasPayment(payments: SuiObjectRef[]) {\n    return this.txBlock.setGasPayment(payments);\n  }\n\n  add(transaction: TransactionType) {\n    return this.txBlock.add(transaction);\n  }\n  serialize() {\n    return this.txBlock.serialize();\n  }\n  build(\n    params: {\n      provider?: JsonRpcProvider;\n      onlyTransactionKind?: boolean;\n    } = {}\n  ) {\n    return this.txBlock.build(params);\n  }\n  getDigest({ provider }: { provider?: JsonRpcProvider } = {}) {\n    return this.txBlock.getDigest({ provider });\n  }\n\n  get gas() {\n    return this.txBlock.gas;\n  }\n  get blockData() {\n    return this.txBlock.blockData;\n  }\n\n  transferObjects(objects: SuiObjectArg[], recipient: string) {\n    const tx = this.txBlock;\n    tx.transferObjects(convertArgs(this.txBlock, objects), tx.pure(recipient));\n    return this;\n  }\n  splitCoins(coin: SuiObjectArg, amounts: number[]) {\n    const tx = this.txBlock;\n    const coinObject = convertArgs(this.txBlock, [coin])[0];\n    const res = tx.splitCoins(\n      coinObject,\n      amounts.map((m) => tx.pure(m))\n    );\n    return amounts.map((_, i) => res[i]);\n  }\n  mergeCoins(destination: SuiObjectArg, sources: SuiObjectArg[]) {\n    const destinationObject = convertArgs(this.txBlock, [destination])[0];\n    const sourceObjects = convertArgs(this.txBlock, sources);\n    return this.txBlock.mergeCoins(destinationObject, sourceObjects);\n  }\n  publish(...args: Parameters<(typeof Transactions)['Publish']>) {\n    return this.txBlock.publish(...args);\n  }\n  upgrade(...args: Parameters<(typeof Transactions)['Upgrade']>) {\n    return this.txBlock.upgrade(...args);\n  }\n  makeMoveVec(...args: Parameters<(typeof Transactions)['MakeMoveVec']>) {\n    return this.txBlock.makeMoveVec(...args);\n  }\n\n  /**\n   * @description Move call\n   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`\n   * @param args the arguments of the move call, such as `['0x1', '0x2']`", "   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`\n   */\n  moveCall(\n    target: string,\n    args: (SuiTxArg | SuiVecTxArg)[] = [],\n    typeArgs: string[] = []\n  ) {\n    // a regex for pattern `${string}::${string}::${string}`\n    const regex =\n      /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;\n    const match = target.match(regex);", "    if (match === null)\n      throw new Error(\n        'Invalid target format. Expected `${string}::${string}::${string}`'\n      );\n    const convertedArgs = convertArgs(this.txBlock, args);\n    const tx = this.txBlock;\n    return tx.moveCall({\n      target: target as `${string}::${string}::${string}`,\n      arguments: convertedArgs,\n      typeArguments: typeArgs,\n    });\n  }\n\n  //======== enhance methods ============\n  transferSuiToMany(recipients: string[], amounts: number[]) {\n    // require recipients.length === amounts.length", "    if (recipients.length !== amounts.length) {\n      throw new Error(\n        'transferSuiToMany: recipients.length !== amounts.length'\n      );\n    }\n\n    const tx = this.txBlock;\n    const coins = tx.splitCoins(\n      tx.gas,\n      amounts.map((amount) => tx.pure(amount))\n    );\n    recipients.forEach((recipient, index) => {\n      tx.transferObjects([coins[index]], tx.pure(recipient));\n    });\n    return this;\n  }\n\n  transferSui(recipient: string, amount: number) {\n    return this.transferSuiToMany([recipient], [amount]);\n  }\n\n  takeAmountFromCoins(coins: SuiObjectArg[], amount: number) {\n    const tx = this.txBlock;\n    const coinObjects = convertArgs(this.txBlock, coins);\n    const mergedCoin = coinObjects[0];", "    if (coins.length > 1) {\n      tx.mergeCoins(mergedCoin, coinObjects.slice(1));\n    }\n    const [sendCoin] = tx.splitCoins(mergedCoin, [tx.pure(amount)]);\n    return [sendCoin, mergedCoin];\n  }\n\n  splitSUIFromGas(amounts: number[]) {\n    const tx = this.txBlock;\n    return tx.splitCoins(\n      tx.gas,\n      amounts.map((m) => tx.pure(m))\n    );\n  }\n\n  splitMultiCoins(coins: SuiObjectArg[], amounts: number[]) {\n    const tx = this.txBlock;\n    const coinObjects = convertArgs(this.txBlock, coins);\n    const mergedCoin = coinObjects[0];", "    if (coins.length > 1) {\n      tx.mergeCoins(mergedCoin, coinObjects.slice(1));\n    }\n    const splitedCoins = tx.splitCoins(\n      mergedCoin,\n      amounts.map((m) => tx.pure(m))\n    );\n    return { splitedCoins, mergedCoin };\n  }\n\n  transferCoinToMany(\n    inputCoins: SuiObjectArg[],\n    sender: string,\n    recipients: string[],\n    amounts: number[]\n  ) {\n    // require recipients.length === amounts.length", "    if (recipients.length !== amounts.length) {\n      throw new Error(\n        'transferSuiToMany: recipients.length !== amounts.length'\n      );\n    }\n    const tx = this.txBlock;\n    const { splitedCoins, mergedCoin } = this.splitMultiCoins(\n      inputCoins,\n      amounts\n    );\n    recipients.forEach((recipient, index) => {\n      tx.transferObjects([splitedCoins[index]], tx.pure(recipient));\n    });\n    tx.transferObjects([mergedCoin], tx.pure(sender));\n    return this;\n  }\n\n  transferCoin(\n    inputCoins: SuiObjectArg[],\n    sender: string,\n    recipient: string,\n    amount: number\n  ) {\n    return this.transferCoinToMany(inputCoins, sender, [recipient], [amount]);\n  }\n\n  stakeSui(amount: number, validatorAddr: string) {\n    const tx = this.txBlock;\n    const [stakeCoin] = tx.splitCoins(tx.gas, [tx.pure(amount)]);\n    tx.moveCall({\n      target: '0x3::sui_system::request_add_stake',\n      arguments: [\n        tx.object(SUI_SYSTEM_STATE_OBJECT_ID),\n        stakeCoin,\n        tx.pure(validatorAddr),\n      ],\n    });\n    return tx;\n  }\n}\n"]}
{"filename": "src/libs/suiTxBuilder/util.ts", "chunked_list": ["import {\n  normalizeSuiObjectId,\n  TransactionArgument,\n  TransactionBlock,\n} from '@mysten/sui.js';\nimport { SuiTxArg, SuiInputTypes } from 'src/types';\n\nexport const getDefaultSuiInputType = (value: any): SuiInputTypes => {\n  if (typeof value === 'string' && value.startsWith('0x')) {\n    return 'object';\n  } else if (typeof value === 'number' || typeof value === 'bigint') {\n    return 'u64';", "  if (typeof value === 'string' && value.startsWith('0x')) {\n    return 'object';\n  } else if (typeof value === 'number' || typeof value === 'bigint') {\n    return 'u64';\n  } else if (typeof value === 'boolean') {\n    return 'bool';\n  } else {\n    return 'object';\n  }\n};\n\n/**\n * Since we know the elements in the array are the same type", " * If type is not provided, we will try to infer the type from the first element\n * By default,\n *\n * string starting with `0x` =====> object id\n * number, bigint ====> u64\n * boolean =====> bool\n *\n *\n * If type is provided, we will use the type to convert the array\n * @param args\n * @param type 'address' | 'bool' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'object'\n */", " * If type is provided, we will use the type to convert the array\n * @param args\n * @param type 'address' | 'bool' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'object'\n */\nexport function makeVecParam(\n  txBlock: TransactionBlock,\n  args: SuiTxArg[],\n  type?: SuiInputTypes\n) {\n  if (args.length === 0)\n    throw new Error('Transaction builder error: Empty array is not allowed');\n  const defaultSuiType = getDefaultSuiInputType(args[0]);", "  if (args.length === 0)\n    throw new Error('Transaction builder error: Empty array is not allowed');\n  const defaultSuiType = getDefaultSuiInputType(args[0]);\n  if (type === 'object' || (!type && defaultSuiType === 'object')) {\n    const objects = args.map((arg) =>\n      typeof arg === 'string'\n        ? txBlock.object(normalizeSuiObjectId(arg))\n        : (arg as any)\n    );\n    return txBlock.makeMoveVec({ objects });\n  } else {\n    const vecType = type || defaultSuiType;\n    return txBlock.pure(args, `vector<${vecType}>`);\n  }\n}\n", "export function isMoveVecArg(arg: any) {\n  const isFullMoveVecArg =\n    arg && arg.value && Array.isArray(arg.value) && arg.vecType;\n  const isSimpleMoveVecArg = Array.isArray(arg);\n  return isFullMoveVecArg || isSimpleMoveVecArg;\n}\n\nexport function convertArgs(\n  txBlock: TransactionBlock,\n  args: any[]\n): TransactionArgument[] {\n  return args.map((arg) => {", "    if (typeof arg === 'string' && arg.startsWith('0x')) {\n      // We always treat string starting with `0x` as object id\n      return txBlock.object(normalizeSuiObjectId(arg));\n    } else if (isMoveVecArg(arg)) {\n      // if it's an array arg, we will convert it to move vec\n      const vecType = arg.vecType || undefined;\n      return vecType\n        ? makeVecParam(txBlock, arg.value, vecType)\n        : makeVecParam(txBlock, arg);\n    } else if (typeof arg !== 'object') {\n      // Other basic types such as string, number, boolean are converted to pure value\n      return txBlock.pure(arg);\n    } else {\n      // We do nothing, because it's most likely already a move value\n      return arg;\n    }\n  });\n}\n", "    } else if (typeof arg !== 'object') {\n      // Other basic types such as string, number, boolean are converted to pure value\n      return txBlock.pure(arg);\n    } else {\n      // We do nothing, because it's most likely already a move value\n      return arg;\n    }\n  });\n}\n"]}
{"filename": "src/libs/suiModel/suiOwnedObject.ts", "chunked_list": ["import { Infer } from 'superstruct';\nimport {\n  getObjectChanges,\n  SuiTransactionBlockResponse,\n  ObjectCallArg,\n  ObjectId,\n} from '@mysten/sui.js';\n\nexport class SuiOwnedObject {\n  public readonly objectId: string;\n  public version?: number | string;\n  public digest?: string;\n\n  constructor(param: { objectId: string; version?: string; digest?: string }) {\n    this.objectId = param.objectId;\n    this.version = param.version;\n    this.digest = param.digest;\n  }\n\n  /**\n   * Check if the object is fully initialized.\n   * So that when it's used as an input, it won't be necessary to fetch from fullnode again.\n   * Which can save time when sending transactions.\n   */\n  isFullObject(): boolean {\n    return !!this.version && !!this.digest;\n  }\n\n  asCallArg(): Infer<typeof ObjectCallArg> | Infer<typeof ObjectId> {", "export class SuiOwnedObject {\n  public readonly objectId: string;\n  public version?: number | string;\n  public digest?: string;\n\n  constructor(param: { objectId: string; version?: string; digest?: string }) {\n    this.objectId = param.objectId;\n    this.version = param.version;\n    this.digest = param.digest;\n  }\n\n  /**\n   * Check if the object is fully initialized.\n   * So that when it's used as an input, it won't be necessary to fetch from fullnode again.\n   * Which can save time when sending transactions.\n   */\n  isFullObject(): boolean {\n    return !!this.version && !!this.digest;\n  }\n\n  asCallArg(): Infer<typeof ObjectCallArg> | Infer<typeof ObjectId> {", "    if (!this.version || !this.digest) {\n      return this.objectId;\n    }\n    return {\n      Object: {\n        ImmOrOwned: {\n          objectId: this.objectId,\n          version: this.version,\n          digest: this.digest,\n        },\n      },\n    };\n  }\n\n  /**\n   * Update object version & digest based on the transaction response.\n   * @param txResponse\n   */\n  updateFromTxResponse(txResponse: SuiTransactionBlockResponse) {\n    const changes = getObjectChanges(txResponse);", "    if (!changes) {\n      throw new Error('Bad transaction response!');\n    }\n    for (const change of changes) {\n      if (change.type === 'mutated' && change.objectId === this.objectId) {\n        this.digest = change.digest;\n        this.version = change.version;\n        return;\n      }\n    }\n    throw new Error('Could not find object in transaction response!');\n  }\n}\n"]}
{"filename": "src/libs/suiModel/index.ts", "chunked_list": ["export { SuiOwnedObject } from './suiOwnedObject';\nexport { SuiSharedObject } from './suiSharedObject';\n"]}
{"filename": "src/libs/suiModel/suiSharedObject.ts", "chunked_list": ["import { Infer } from 'superstruct';\nimport { ObjectCallArg, ObjectId } from '@mysten/sui.js';\n\nexport class SuiSharedObject {\n  public readonly objectId: string;\n  public initialSharedVersion?: number | string;\n\n  constructor(param: {\n    objectId: string;\n    initialSharedVersion?: number;\n    mutable?: boolean;\n  }) {\n    this.objectId = param.objectId;\n    this.initialSharedVersion = param.initialSharedVersion;\n  }\n\n  asCallArg(\n    mutable: boolean = false\n  ): Infer<typeof ObjectCallArg> | Infer<typeof ObjectId> {", "    if (!this.initialSharedVersion) {\n      return this.objectId;\n    }\n    return {\n      Object: {\n        Shared: {\n          objectId: this.objectId,\n          initialSharedVersion: this.initialSharedVersion,\n          mutable,\n        },\n      },\n    };\n  }\n}\n"]}
{"filename": "src/libs/suiAccountManager/keypair.ts", "chunked_list": ["import { Ed25519Keypair } from '@mysten/sui.js';\nimport type { DerivePathParams } from 'src/types';\n\n/**\n * @description Get ed25519 derive path for SUI\n * @param derivePathParams\n */\nexport const getDerivePathForSUI = (\n  derivePathParams: DerivePathParams = {}\n) => {", "  derivePathParams: DerivePathParams = {}\n) => {\n  const {\n    accountIndex = 0,\n    isExternal = false,\n    addressIndex = 0,\n  } = derivePathParams;\n  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;\n};\n", "};\n\n/**\n * the format is m/44'/784'/accountIndex'/${isExternal ? 1 : 0}'/addressIndex'\n *\n * accountIndex is the index of the account, default is 0.\n *\n * isExternal is the type of the address, default is false. Usually, the external address is used to receive coins. The internal address is used to change coins.\n *\n * addressIndex is the index of the address, default is 0. It's used to generate multiple addresses for one account.\n *\n * @description Get keypair from mnemonics and derive path\n * @param mnemonics\n * @param derivePathParams\n */\nexport const getKeyPair = (\n  mnemonics: string,\n  derivePathParams: DerivePathParams = {}\n) => {\n  const derivePath = getDerivePathForSUI(derivePathParams);\n  return Ed25519Keypair.deriveKeypair(mnemonics, derivePath);\n};\n"]}
{"filename": "src/libs/suiAccountManager/crypto.ts", "chunked_list": ["import { generateMnemonic as genMnemonic } from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\n\nexport const generateMnemonic = (numberOfWords: 12 | 24 = 24) => {\n  const strength = numberOfWords === 12 ? 128 : 256;\n  return genMnemonic(wordlist, strength);\n};\n"]}
{"filename": "src/libs/suiAccountManager/index.ts", "chunked_list": ["import { Ed25519Keypair } from '@mysten/sui.js';\nimport { getKeyPair } from './keypair';\nimport { hexOrBase64ToUint8Array, normalizePrivateKey } from './util';\nimport { generateMnemonic } from './crypto';\nimport type { AccountMangerParams, DerivePathParams } from 'src/types';\n\nexport class SuiAccountManager {\n  private mnemonics: string;\n  private secretKey: string;\n  public currentKeyPair: Ed25519Keypair;\n  public currentAddress: string;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   */\n  constructor({ mnemonics, secretKey }: AccountMangerParams = {}) {\n    // If the mnemonics or secretKey is provided, use it\n    // Otherwise, generate a random mnemonics with 24 words\n    this.mnemonics = mnemonics || '';\n    this.secretKey = secretKey || '';", "    if (!this.mnemonics && !this.secretKey) {\n      this.mnemonics = generateMnemonic(24);\n    }\n\n    // Init the current account\n    this.currentKeyPair = this.secretKey\n      ? Ed25519Keypair.fromSecretKey(\n          normalizePrivateKey(hexOrBase64ToUint8Array(this.secretKey))\n        )\n      : getKeyPair(this.mnemonics);\n    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.\n   * else:\n   * it will generate keyPair from the mnemonic with the given derivePathParams.\n   */\n  getKeyPair(derivePathParams?: DerivePathParams) {", "    if (!derivePathParams || !this.mnemonics) return this.currentKeyPair;\n    return getKeyPair(this.mnemonics, derivePathParams);\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.\n   * else:\n   * it will generate address from the mnemonic with the given derivePathParams.\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentAddress;\n    return getKeyPair(this.mnemonics, derivePathParams)\n      .getPublicKey()\n      .toSuiAddress();\n  }\n\n  /**\n   * Switch the current account with the given derivePathParams.\n   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.\n   */\n  switchAccount(derivePathParams: DerivePathParams) {", "    if (!derivePathParams || !this.mnemonics) return this.currentAddress;\n    return getKeyPair(this.mnemonics, derivePathParams)\n      .getPublicKey()\n      .toSuiAddress();\n  }\n\n  /**\n   * Switch the current account with the given derivePathParams.\n   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.\n   */\n  switchAccount(derivePathParams: DerivePathParams) {", "    if (this.mnemonics) {\n      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);\n      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n    }\n  }\n}\n"]}
{"filename": "src/libs/suiAccountManager/util.ts", "chunked_list": ["import { fromB64 } from '@mysten/sui.js';\n\n/**\n * @description This regular expression matches any string that contains only hexadecimal digits (0-9, A-F, a-f).\n * @param str\n */\nexport const isHex = (str: string) =>\n  /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);\n\n/**", "\n/**\n * @description This regular expression matches any string that contains only base64 digits (0-9, A-Z, a-z, +, /, =).\n * Note that the \"=\" signs at the end are optional padding characters that may be present in some base64 encoded strings.\n * @param str\n */\nexport const isBase64 = (str: string) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);\n\n/**\n * Convert a hex string to Uint8Array", "/**\n * Convert a hex string to Uint8Array\n * @param hexStr\n */\nexport const fromHEX = (hexStr: string): Uint8Array => {\n  if (!hexStr) {\n    throw new Error('cannot parse empty string to Uint8Array');\n  }\n  const intArr = hexStr\n    .replace('0x', '')\n    .match(/.{1,2}/g)\n    ?.map((byte) => parseInt(byte, 16));\n", "  if (!intArr || intArr.length === 0) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n};\n\n/**\n * @description Convert a hex or base64 string to Uint8Array\n */\nexport const hexOrBase64ToUint8Array = (str: string): Uint8Array => {\n  if (isHex(str)) {\n    return fromHEX(str);", "  if (isHex(str)) {\n    return fromHEX(str);\n  } else if (isBase64(str)) {\n    return fromB64(str);\n  } else {\n    throw new Error('The string is not a valid hex or base64 string.');\n  }\n};\n\nconst PRIVATE_KEY_SIZE = 32;\nconst LEGACY_PRIVATE_KEY_SIZE = 64;\n/**\n * normalize a private key\n * A private key is a 32-byte array.\n * But there are two different formats for private keys:\n * 1. A 32-byte array\n * 2. A 64-byte array with the first 32 bytes being the private key and the last 32 bytes being the public key\n * 3. A 33-byte array with the first byte being 0x00 (sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning)\n */\nexport const normalizePrivateKey = (key: Uint8Array): Uint8Array => {", "  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {\n    // This is a legacy secret key, we need to strip the public key bytes and only read the first 32 bytes\n    key = key.slice(0, PRIVATE_KEY_SIZE);\n  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {\n    // sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning\n    return key.slice(1);\n  } else if (key.length === PRIVATE_KEY_SIZE) {\n    return key;\n  }\n  throw new Error('invalid secret key');\n};\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["import { Infer } from 'superstruct';\nimport {\n  DisplayFieldsResponse,\n  ObjectCallArg,\n  ObjectContentFields,\n  SharedObjectRef,\n  SuiObjectRef,\n  TransactionArgument,\n} from '@mysten/sui.js';\n\nexport type AccountMangerParams = {\n  mnemonics?: string;\n  secretKey?: string;\n};\n", "} from '@mysten/sui.js';\n\nexport type AccountMangerParams = {\n  mnemonics?: string;\n  secretKey?: string;\n};\n\nexport type DerivePathParams = {\n  accountIndex?: number;\n  isExternal?: boolean;\n  addressIndex?: number;\n};\n", "export type NetworkType = 'testnet' | 'mainnet' | 'devnet' | 'localnet';\n\nexport type SuiKitParams = {\n  mnemonics?: string;\n  secretKey?: string;\n  fullnodeUrls?: string[];\n  faucetUrl?: string;\n  networkType?: NetworkType;\n};\n\nexport type ObjectData = {\n  objectId: string;\n  objectType: string;\n  objectVersion: number;\n  objectDigest: string;\n  initialSharedVersion?: number;\n  objectDisplay: DisplayFieldsResponse;\n  objectFields: ObjectContentFields;\n};\n", "export type ObjectData = {\n  objectId: string;\n  objectType: string;\n  objectVersion: number;\n  objectDigest: string;\n  initialSharedVersion?: number;\n  objectDisplay: DisplayFieldsResponse;\n  objectFields: ObjectContentFields;\n};\n\nexport type SuiTxArg =\n  | Infer<typeof TransactionArgument>\n  | Infer<typeof ObjectCallArg>\n  | string\n  | number\n  | bigint\n  | boolean;\n", "export type SuiTxArg =\n  | Infer<typeof TransactionArgument>\n  | Infer<typeof ObjectCallArg>\n  | string\n  | number\n  | bigint\n  | boolean;\n\nexport type SuiObjectArg =\n  | SharedObjectRef\n  | Infer<typeof SuiObjectRef>\n  | string\n  | Infer<typeof ObjectCallArg>\n  | Infer<typeof TransactionArgument>;\n", "export type SuiObjectArg =\n  | SharedObjectRef\n  | Infer<typeof SuiObjectRef>\n  | string\n  | Infer<typeof ObjectCallArg>\n  | Infer<typeof TransactionArgument>;\n\nexport type SuiVecTxArg =\n  | { value: SuiTxArg[]; vecType: SuiInputTypes }\n  | SuiTxArg[];\n\n/**\n * These are the basics types that can be used in the SUI\n */", "export type SuiBasicTypes =\n  | 'address'\n  | 'bool'\n  | 'u8'\n  | 'u16'\n  | 'u32'\n  | 'u64'\n  | 'u128'\n  | 'u256';\n\nexport type SuiInputTypes = 'object' | SuiBasicTypes;\n", "export type SuiInputTypes = 'object' | SuiBasicTypes;\n"]}
