{"filename": "src/index.ts", "chunked_list": ["export * from \"./helpers\";\nexport * from \"./interfaces/IContentLoading\";\nexport * from \"./store/contextStore\";\nexport * from \"./store/resettableStore\";\n"]}
{"filename": "src/interfaces/dotNestedKeys.ts", "chunked_list": ["type DotPrefix<T extends string> = T extends \"\" ? \"\" : `.${T}`;\n\nexport type DotNestedKeys<T> = (\n  T extends object\n    ? T extends Array<any>\n      ? \"\"\n      :\n          | {\n              [K in Exclude<keyof T, symbol>]: `${K}${DotPrefix<\n                DotNestedKeys<T[K]>\n              >}`;\n            }[Exclude<keyof T, symbol>]\n          | keyof T\n    : \"\"\n) extends infer D\n  ? Extract<D, string>\n  : never;\n", "export type DotNestedValue<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  O extends Record<string, any>,\n  Path extends string\n> = Path extends `${infer Head}.${infer Tail}`\n  ? DotNestedValue<O[Head], Tail>\n  : O[Path];\n\nexport type ValueOf<T> = T extends Record<infer _K, infer V> ? V : never;\n", "export type ValueOf<T> = T extends Record<infer _K, infer V> ? V : never;\n"]}
{"filename": "src/interfaces/IContentLoading.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type ILoadingStatus =\n  | \"init\"\n  | \"loading\"\n  | \"loaded\"\n  | \"waiting\"\n  | \"progress\"\n  | \"error\";\n\nexport interface IContentLoading<Content, Payload = undefined> {\n  content: Content | null;\n  status: ILoadingStatus;\n  error?: any;\n  payload?: Payload | null;\n  requestId?: string;\n}\n\nexport const initialContentLoading = <Content, Payload>(\n  value: Content | null,\n  initialStatus?: ILoadingStatus\n): IContentLoading<Content, Payload> => ({\n  content: value,\n  status: initialStatus || \"loading\",\n  error: undefined,\n  payload: undefined,\n  requestId: undefined,\n});\n", "export interface IContentLoading<Content, Payload = undefined> {\n  content: Content | null;\n  status: ILoadingStatus;\n  error?: any;\n  payload?: Payload | null;\n  requestId?: string;\n}\n\nexport const initialContentLoading = <Content, Payload>(\n  value: Content | null,\n  initialStatus?: ILoadingStatus\n): IContentLoading<Content, Payload> => ({\n  content: value,\n  status: initialStatus || \"loading\",\n  error: undefined,\n  payload: undefined,\n  requestId: undefined,\n});\n", "export type ILeitenLoading<Payload, Result> = Omit<\n  IContentLoading<Result, Payload>,\n  \"content\"\n>;\n\nexport const initialLeitenLoading = <Payload, Result>(\n  initialStatus?: ILoadingStatus\n): ILeitenLoading<Payload, Result> => ({\n  status: initialStatus || \"init\",\n  error: undefined,\n  payload: undefined,\n  requestId: undefined,\n});\n"]}
{"filename": "src/helpers/leitenPrimitive.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, set } from \"lodash-es\";\nimport { StoreApi } from \"zustand\";\n\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\ninterface ILeitenPrimitiveEffects<VALUE, State> {\n  patchEffect?: (value: VALUE) => Partial<State>;\n  sideEffect?: (value: { prev: VALUE; next: VALUE }) => void;\n}\n", "export type ILeitenPrimitive<VALUE> = {\n  set: (value: VALUE) => void;\n  get: () => VALUE;\n  clear: () => void;\n};\n\nexport const leitenPrimitive = <\n  Store extends object,\n  P extends DotNestedKeys<Store>\n>(\n  store: StoreApi<Store>,\n  path: P extends string ? P : never,\n  effects?: ILeitenPrimitiveEffects<DotNestedValue<Store, P>, Store>\n): ILeitenPrimitive<DotNestedValue<Store, P>> => {", "  type VALUE = DotNestedValue<Store, P>;\n\n  const initialValue = get(store.getState(), path, \"_empty\") as VALUE;\n  if (initialValue === \"_empty\") {\n    throw new Error(\"[leitenPrimitive] The defined path does not exist\");\n  }\n\n  const getState = (): VALUE => {\n    const value = get(store.getState(), path, \"_empty\") as VALUE | \"_empty\";\n    return value !== \"_empty\" ? value : initialValue;\n  };\n\n  const setState = (next: VALUE) => {\n    const prev = getState();\n    const draftState = produce(store.getState(), (draft) => {\n      set(draft, path, next);\n    });\n    const nextState = effects?.patchEffect\n      ? { ...draftState, ...effects.patchEffect(next) }\n      : draftState;\n    store.setState(nextState);\n    effects?.sideEffect?.({ prev, next });\n  };\n\n  const clear = () => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, initialValue);\n    });\n    store.setState(nextState);\n  };\n\n  return { set: setState, get: getState, clear };\n};\n"]}
{"filename": "src/helpers/leitenNormalizedList.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, set } from \"lodash-es\";\nimport { StoreApi } from \"zustand/esm\";\n\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\nimport { ILeitenList } from \"./leitenList\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\ntype NormalizedType<ITEM> = Record<string, ITEM>;\ntype ValueOf<T> = T extends Record<infer _K, infer V> ? V : never;\n\nexport const leitenNormalizedList = <\n  Store extends object,\n  P extends DotNestedKeys<Store>\n>(\n  store: StoreApi<Store>,\n  path: P extends string\n    ? DotNestedValue<Store, P> extends Record<string, unknown>\n      ? P\n      : never\n    : never,\n  params: {\n    compare?: (\n      left: ValueOf<DotNestedValue<Store, P>>,\n      right: ValueOf<DotNestedValue<Store, P>>\n    ) => boolean;\n    sideEffect?: () => void;\n    patchEffect?: (\n      items: NormalizedType<ValueOf<DotNestedValue<Store, P>>>\n    ) => Partial<Store>;\n    getKey: (item: ValueOf<DotNestedValue<Store, P>>) => string;\n  }\n): ILeitenList<ValueOf<DotNestedValue<Store, P>>> & {\n  removeByKey: (value: string | string[]) => void;\n  get: () => NormalizedType<ValueOf<DotNestedValue<Store, P>>>;\n} => {", "\ntype NormalizedType<ITEM> = Record<string, ITEM>;\ntype ValueOf<T> = T extends Record<infer _K, infer V> ? V : never;\n\nexport const leitenNormalizedList = <\n  Store extends object,\n  P extends DotNestedKeys<Store>\n>(\n  store: StoreApi<Store>,\n  path: P extends string\n    ? DotNestedValue<Store, P> extends Record<string, unknown>\n      ? P\n      : never\n    : never,\n  params: {\n    compare?: (\n      left: ValueOf<DotNestedValue<Store, P>>,\n      right: ValueOf<DotNestedValue<Store, P>>\n    ) => boolean;\n    sideEffect?: () => void;\n    patchEffect?: (\n      items: NormalizedType<ValueOf<DotNestedValue<Store, P>>>\n    ) => Partial<Store>;\n    getKey: (item: ValueOf<DotNestedValue<Store, P>>) => string;\n  }\n): ILeitenList<ValueOf<DotNestedValue<Store, P>>> & {\n  removeByKey: (value: string | string[]) => void;\n  get: () => NormalizedType<ValueOf<DotNestedValue<Store, P>>>;\n} => {", "  type ITEM = ValueOf<DotNestedValue<Store, P>>;\n\n  const initialValue = get(\n    store.getState(),\n    path,\n    \"_empty\"\n  ) as NormalizedType<ITEM>;\n  if ((initialValue as any) === \"_empty\" || typeof initialValue !== \"object\") {\n    throw new Error(\n      \"[leitenNormalizedList] The defined path does not match the required structure\"\n    );\n  }\n\n  const compare = params?.compare || defaultCompareList;\n\n  const setState = (value: NormalizedType<ITEM>) => {\n    const draftState = produce(store.getState(), (draft) => {\n      set(draft, path, value);\n    });\n    const nextState = params?.patchEffect\n      ? { ...draftState, ...params.patchEffect(value) }\n      : draftState;\n    store.setState(nextState);\n    params?.sideEffect?.();\n  };\n\n  const _get = (): NormalizedType<ITEM> => {\n    const list = get(store.getState(), path, \"_empty\") as\n      | NormalizedType<ITEM>\n      | \"_empty\";", "    if (list !== \"_empty\") {\n      return list;\n    } else {\n      return initialValue;\n    }\n  };\n\n  const getMap = (items: ITEM[]): NormalizedType<ITEM> => {\n    return items.reduce<NormalizedType<ITEM>>((acc, val) => {\n      const key = params.getKey(val);\n      acc[key] = val;\n      return acc;\n    }, {});\n  };\n\n  const _set = (items: ITEM[]) => {\n    setState(getMap(items));\n  };\n\n  const add = (items: ITEM | ITEM[]) => {\n    setState({\n      ..._get(),\n      ...getMap(Array.isArray(items) ? items : [items]),\n    });\n  };\n\n  const clear = () => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, initialValue);\n    });\n    store.setState(nextState);\n  };\n\n  const removeByKey = (removeKeys: string[] | string) => {\n    const acc: NormalizedType<ITEM> = {};", "    for (const [key, item] of Object.entries(_get())) {\n      if (\n        Array.isArray(removeKeys)\n          ? !removeKeys.includes(key)\n          : removeKeys !== key\n      ) {\n        acc[key] = item;\n      }\n    }\n    setState(acc);\n  };\n\n  const remove = (remove: ITEM[] | ITEM) => {\n    const acc: NormalizedType<ITEM> = {};", "    for (const [key, item] of Object.entries(_get())) {\n      if (\n        Array.isArray(remove)\n          ? !remove.some((i) => compare(item, i))\n          : !compare(item, remove)\n      ) {\n        acc[key] = item;\n      }\n    }\n    setState(acc);\n  };\n\n  const filter = (validate: (item: ITEM) => boolean) => {\n    setState(\n      Object.fromEntries(\n        Object.entries(_get()).filter(([_, item]) => validate(item))\n      )\n    );\n  };\n\n  const update = (items: ITEM[] | ITEM) => {\n    const updated = getMap(Array.isArray(items) ? items : [items]);\n    setState({ ..._get(), ...updated });\n  };\n\n  const toggle = (item: ITEM) => {\n    const key = params.getKey(item);\n    const isChecked = key in _get();\n", "    if (isChecked) {\n      removeByKey(key);\n    } else {\n      add(item);\n    }\n  };\n\n  return {\n    set: _set,\n    get: _get,\n    clear,\n    toggle,\n    update,\n    filter,\n    remove,\n    add,\n    removeByKey,\n  };\n};\n\nexport const defaultCompareList = <ITEM>(left: ITEM, right: ITEM): boolean =>\n  left === right;\n"]}
{"filename": "src/helpers/leitenList.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, isArray, set } from \"lodash-es\";\nimport { StoreApi } from \"zustand/esm\";\n\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\nimport { defaultCompareList } from \"./leitenNormalizedList\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type ILeitenList<ITEM> = {\n  set: (items: ITEM[]) => void;\n  add: (items: ITEM[] | ITEM) => void;\n  remove: (items: ITEM[] | ITEM) => void;\n  toggle: (item: ITEM) => void;\n  update: (item: ITEM[] | ITEM) => void;\n  clear: () => void;\n  filter: (validate: (item: ITEM) => boolean) => void;\n};", "\nexport type ILeitenList<ITEM> = {\n  set: (items: ITEM[]) => void;\n  add: (items: ITEM[] | ITEM) => void;\n  remove: (items: ITEM[] | ITEM) => void;\n  toggle: (item: ITEM) => void;\n  update: (item: ITEM[] | ITEM) => void;\n  clear: () => void;\n  filter: (validate: (item: ITEM) => boolean) => void;\n};\ntype ArrayElement<ArrType> = ArrType extends readonly (infer ElementType)[]\n  ? ElementType\n  : never;\n", "type ArrayElement<ArrType> = ArrType extends readonly (infer ElementType)[]\n  ? ElementType\n  : never;\n\nexport interface ILeitenListEffects<ITEM, State> {\n  compare?: (left: ITEM, right: ITEM) => boolean;\n  sideEffect?: () => void;\n  patchEffect?: (items: ITEM[]) => Partial<State>;\n}\n\nexport const leitenList = <\n  Store extends object,\n  P extends DotNestedKeys<Store>\n>(\n  store: StoreApi<Store>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  path: P extends string\n    ? DotNestedValue<Store, P> extends Array<any> | null\n      ? P\n      : never\n    : never,\n  params?: ILeitenListEffects<ArrayElement<DotNestedValue<Store, P>>, Store>\n): ILeitenList<ArrayElement<DotNestedValue<Store, P>>> & {\n  get: () => ArrayElement<DotNestedValue<Store, P>>[];\n} => {", "  type ITEM = ArrayElement<DotNestedValue<Store, P>>;\n  const initialValue = get(store.getState(), path, \"_empty\") as ITEM[];\n  if ((initialValue as any) === \"_empty\") {\n    throw new Error(\n      \"[leitenList] The defined path does not match the required structure\"\n    );\n  }\n\n  const compare = params?.compare || defaultCompareList;\n\n  const _set = (value: ITEM[]) => {\n    const draftState = produce(store.getState(), (draft) => {\n      set(draft, path, value);\n    });\n    const nextState = params?.patchEffect\n      ? { ...draftState, ...params.patchEffect(value) }\n      : draftState;\n    store.setState(nextState);\n    params?.sideEffect?.();\n  };\n\n  const _get = (): ITEM[] => {\n    const array = get(store.getState(), path, initialValue);", "    if (isArray(array)) {\n      return array;\n    } else {\n      return [];\n    }\n  };\n\n  const add = (items: ITEM[] | ITEM) => {\n    if (Array.isArray(items)) {\n      const values = items.filter((existing) =>\n        _get().every((item) => !compare(existing, item))\n      );\n      _set([..._get(), ...values]);\n    } else {\n      const values = _get().every((item) => !compare(items, item))\n        ? [items]\n        : [];\n      _set([..._get(), ...values]);\n    }\n  };\n\n  const clear = () => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, initialValue || []);\n    });\n    store.setState(nextState);\n  };\n\n  const remove = (items: ITEM[] | ITEM) => {", "    if (Array.isArray(items)) {\n      const values = items.filter((existing) =>\n        _get().every((item) => !compare(existing, item))\n      );\n      _set([..._get(), ...values]);\n    } else {\n      const values = _get().every((item) => !compare(items, item))\n        ? [items]\n        : [];\n      _set([..._get(), ...values]);\n    }\n  };\n\n  const clear = () => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, initialValue || []);\n    });\n    store.setState(nextState);\n  };\n\n  const remove = (items: ITEM[] | ITEM) => {", "    if (Array.isArray(items)) {\n      _set(\n        _get().filter(\n          (item) => !items.find((removeItem) => compare(item, removeItem))\n        )\n      );\n    } else {\n      _set(_get().filter((item) => !compare(item, items)));\n    }\n  };\n\n  const filter = (validate: (item: ITEM) => boolean) => {\n    _set(_get().filter(validate));\n  };\n\n  const update = (items: ITEM[] | ITEM) => {", "    if (Array.isArray(items)) {\n      _set(\n        _get().map((existing) => {\n          const item = items.find((item) => compare(existing, item));\n          return item || existing;\n        })\n      );\n    } else {\n      _set(\n        _get().map((existing) => (compare(existing, items) ? items : existing))\n      );\n    }\n  };\n\n  const toggle = (item: ITEM) => {\n    const exist = !!_get().find((_item) => compare(item, _item));\n", "    if (exist) {\n      remove(item);\n    } else {\n      add(item);\n    }\n  };\n\n  return { set: _set, get: _get, clear, toggle, update, filter, remove, add };\n};\n"]}
{"filename": "src/helpers/leitenFilterRequest.ts", "chunked_list": ["import { cloneDeep, get, isEqual } from \"lodash-es\";\nimport { StoreApi, UseBoundStore } from \"zustand\";\n\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\nimport { ILeitenPrimitive, leitenPrimitive } from \"./leitenPrimitive\";\nimport {\n  ILeitenRecord,\n  ILeitenRecordEffects,\n  leitenRecord,\n} from \"./leitenRecord\";", "  leitenRecord,\n} from \"./leitenRecord\";\nimport {\n  IExtraArgument,\n  ILeitenRequestOptions,\n  leitenRequest,\n  resettableStoreSubscription,\n} from \"./leitenRequest\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */", "\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\ntype RecordFilter<T> = {\n  (initialObject?: T): IObjectDifferent[];\n} & ILeitenRecord<T>;\ntype PrimitiveFilter<Y> = {\n  (initialObject?: Y): IObjectDifferent[];\n} & ILeitenPrimitive<Y>;\n\nexport const leitenFilterRequest = <\n  Store extends object,\n  Path extends DotNestedKeys<Store>,\n  Result extends DotNestedValue<Store, Path> | null | void\n>(\n  store: UseBoundStore<StoreApi<Store>>,\n  path: Path extends string\n    ? Result extends void\n      ? Path\n      : DotNestedValue<Store, Path> extends Result | null\n      ? Path\n      : never\n    : never,\n  request: (params: void, extraArgument?: IExtraArgument) => Promise<Result>,\n  options?: ILeitenRequestOptions<void, Result>\n) => {\n  const leiten = leitenRequest(store, path, request, {\n    ...options,\n    action: (args) => {\n      updatePrevFilters();\n      return options?.action?.(args);\n    },\n  });\n\n  const filters: Record<string, ILeitenRecord<any> | ILeitenPrimitive<any>> =\n    {};\n  let prevFilters: Record<string, any> = {};\n  const initialFilters: Record<string, any> = {};\n\n  const createFilter = <Path extends DotNestedKeys<Store>>(\n    path: Path extends string ? Path : never,\n    options?: ILeitenRecordEffects<DotNestedValue<Store, Path>, Store>\n  ): DotNestedValue<Store, Path> extends object\n    ? RecordFilter<DotNestedValue<Store, Path>>\n    : PrimitiveFilter<DotNestedValue<Store, Path>> => {", "    type Response = DotNestedValue<Store, Path> extends object\n      ? RecordFilter<DotNestedValue<Store, Path>>\n      : PrimitiveFilter<DotNestedValue<Store, Path>>;\n    const initial = get(store.getState(), path, undefined);\n\n    function hook(\n      initialObject?: DotNestedValue<Store, Path>\n    ): IObjectDifferent[] {\n      return store((state) =>\n        getObjectDifference(\n          get(state, path, initialObject || initial),\n          initialObject || initial\n        )\n      );\n    }\n\n    const controller =\n      typeof initial !== \"object\" ? leitenPrimitive : leitenRecord;\n\n    const record = controller(store, path, {\n      sideEffect: (side) => {\n        options?.sideEffect?.(side);\n        action(path).then();\n      },\n      patchEffect: options?.patchEffect,\n    });\n    prevFilters[path] = record.get();\n    filters[path] = record;\n    initialFilters[path] = record.get();\n\n    return Object.assign(hook, record) as Response;\n  };\n\n  const listen = <\n    ExternalStore extends object,\n    ExternalPath extends DotNestedKeys<ExternalStore>\n  >(\n    store: UseBoundStore<StoreApi<ExternalStore>>,\n    path: ExternalPath extends string ? ExternalPath : never,\n    options?: {\n      sideEffect?: (value: {\n        prev: DotNestedValue<ExternalStore, ExternalPath>;\n        next: DotNestedValue<ExternalStore, ExternalPath>;\n      }) => void;\n    }\n  ) => {\n    let prevValue = get(store.getState(), path);\n    const haveSubscription = () =>\n      !!Object.values((leiten as any)._usages || {}).filter((item) => item)\n        .length;\n\n    return store.subscribe((state) => {\n      const value = get(state, path);\n", "      if (haveSubscription() && !isEqual(prevValue, value)) {\n        prevValue = value;\n        options?.sideEffect?.({ prev: prevValue, next: value });\n\n        pureAction().then();\n      }\n    });\n  };\n\n  const pureAction = async () => {\n    updatePrevFilters();\n    leiten.action();\n  };\n\n  const action = async (path: string) => {\n    const filter = get(store.getState(), path);\n", "    if (JSON.stringify(filter) !== JSON.stringify(prevFilters[path])) {\n      leiten.action();\n    }\n  };\n\n  const updatePrevFilters = () => {\n    prevFilters = Object.keys(filters).reduce(\n      (acc, item) => ({\n        ...acc,\n        [item]: get(store.getState(), item),\n      }),\n      {}\n    );\n  };\n\n  resettableStoreSubscription(store, () => {\n    prevFilters = cloneDeep(initialFilters);\n  });\n\n  const clearAll = () => {\n    leiten.clear();\n    Object.keys(filters).forEach((key) => filters[key].clear());\n    leiten.action();\n  };\n\n  return Object.assign(leiten, { createFilter, clearAll, listen });\n};\n", "export interface IObjectDifferent<S = any> {\n  field: string;\n  prev: S;\n  next: S;\n}\n\nexport const getObjectDifference = <S>(\n  next: any,\n  prev: any\n): IObjectDifferent<S>[] => {\n  if (typeof next !== \"object\") {", "  if (typeof next !== \"object\") {\n    if (!isEqual(next, prev)) {\n      return [{ field: \"_\", prev, next }];\n    } else {\n      return [];\n    }\n  } else {\n    return Object.keys(next).reduce((result, field) => {\n      if (!isEqual(next[field], prev[field])) {\n        result.push({ field, prev: prev[field], next: next[field] });\n      }\n      return result;\n    }, [] as IObjectDifferent<S>[]);\n  }\n};\n", "      if (!isEqual(next[field], prev[field])) {\n        result.push({ field, prev: prev[field], next: next[field] });\n      }\n      return result;\n    }, [] as IObjectDifferent<S>[]);\n  }\n};\n"]}
{"filename": "src/helpers/leitenRequest.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, isEqual, set } from \"lodash-es\";\nimport { nanoid } from \"nanoid\";\nimport { useEffect, useState } from \"react\";\nimport { StoreApi } from \"zustand\";\nimport { shallow } from \"zustand/shallow\";\n\nimport { useLeitenRequests } from \"../hooks/useLeitenRequest\";\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\nimport {", "import { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\nimport {\n  ILeitenLoading,\n  ILoadingStatus,\n  initialLeitenLoading,\n} from \"../interfaces/IContentLoading\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type UseRequestType<Payload, Result> = <\n  U = ILeitenLoading<Payload, Result>\n>(\n  selector?: (state: ILeitenLoading<Payload, Result>) => U,\n  equals?: (a: U, b: U) => boolean\n) => U;\n", "\nexport type UseRequestType<Payload, Result> = <\n  U = ILeitenLoading<Payload, Result>\n>(\n  selector?: (state: ILeitenLoading<Payload, Result>) => U,\n  equals?: (a: U, b: U) => boolean\n) => U;\n\nexport interface ILeitenRequest<Payload, Result>\n  extends UseRequestType<Payload, Result> {\n  abort: () => void;\n  clear: () => void;\n  action: (\n    params: Payload,\n    extraParams?: { status?: ILoadingStatus; requestId?: string }\n  ) => void;\n  set: (value: Partial<Result> | void, rewrite?: boolean) => void;\n  key: string;\n  get: () => ILeitenLoading<Payload, Result>;\n}\n", "export interface ILeitenRequest<Payload, Result>\n  extends UseRequestType<Payload, Result> {\n  abort: () => void;\n  clear: () => void;\n  action: (\n    params: Payload,\n    extraParams?: { status?: ILoadingStatus; requestId?: string }\n  ) => void;\n  set: (value: Partial<Result> | void, rewrite?: boolean) => void;\n  key: string;\n  get: () => ILeitenLoading<Payload, Result>;\n}\n", "export interface ILeitenRequestCallback<Payload, Result> {\n  previousResult: Result;\n  result: Result;\n  payload: Payload;\n  requestId: string;\n  error?: string;\n}\n\nexport interface ILeitenRequestOptions<Payload, Result> {\n  fulfilled?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\">\n  ) => void;\n  rejected?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"result\">\n  ) => void;\n  abort?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\" | \"result\">\n  ) => void;\n  resolved?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"result\" | \"error\">\n  ) => void;\n  action?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\" | \"result\">\n  ) => void;\n  initialStatus?: ILoadingStatus;\n  optimisticUpdate?: (params: Payload) => Result;\n}\n\nexport const leitenRequest = <\n  Store extends object,\n  P extends DotNestedKeys<Store>,\n  Payload,\n  Result extends DotNestedValue<Store, P> | null | void\n>(\n  store: StoreApi<Store>,\n  path: P extends string\n    ? Result extends void\n      ? P\n      : DotNestedValue<Store, P> extends Result | null\n      ? P\n      : never\n    : never,\n  payloadCreator: (\n    params: Payload,\n    extraArgument?: IExtraArgument\n  ) => Promise<Result>,\n  options?: ILeitenRequestOptions<Payload, Result>\n): ILeitenRequest<Payload, Result> => {\n  const key = nanoid(12);\n  const initialState = initialLeitenLoading<Payload, Result>(\n    options?.initialStatus\n  );\n  const initialContent = get(store.getState(), path, null) as Result;\n\n  const setState = (state: ILeitenLoading<Payload, Result>) => {\n    useLeitenRequests.setState({ [key]: state });\n  };\n  setState(initialState); //init request\n\n  const setContent = (content: Result) => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, content);\n    });\n    store.setState(nextState);\n  };\n\n  const getState = (): ILeitenLoading<Payload, Result> => {\n    return useLeitenRequests.getState()[key] || initialState;\n  };\n\n  const getContent = (): Result => {\n    const result = get(store.getState(), path, \"_empty\") as Result | \"_empty\";", "export interface ILeitenRequestOptions<Payload, Result> {\n  fulfilled?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\">\n  ) => void;\n  rejected?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"result\">\n  ) => void;\n  abort?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\" | \"result\">\n  ) => void;\n  resolved?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"result\" | \"error\">\n  ) => void;\n  action?: (\n    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\" | \"result\">\n  ) => void;\n  initialStatus?: ILoadingStatus;\n  optimisticUpdate?: (params: Payload) => Result;\n}\n\nexport const leitenRequest = <\n  Store extends object,\n  P extends DotNestedKeys<Store>,\n  Payload,\n  Result extends DotNestedValue<Store, P> | null | void\n>(\n  store: StoreApi<Store>,\n  path: P extends string\n    ? Result extends void\n      ? P\n      : DotNestedValue<Store, P> extends Result | null\n      ? P\n      : never\n    : never,\n  payloadCreator: (\n    params: Payload,\n    extraArgument?: IExtraArgument\n  ) => Promise<Result>,\n  options?: ILeitenRequestOptions<Payload, Result>\n): ILeitenRequest<Payload, Result> => {\n  const key = nanoid(12);\n  const initialState = initialLeitenLoading<Payload, Result>(\n    options?.initialStatus\n  );\n  const initialContent = get(store.getState(), path, null) as Result;\n\n  const setState = (state: ILeitenLoading<Payload, Result>) => {\n    useLeitenRequests.setState({ [key]: state });\n  };\n  setState(initialState); //init request\n\n  const setContent = (content: Result) => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, content);\n    });\n    store.setState(nextState);\n  };\n\n  const getState = (): ILeitenLoading<Payload, Result> => {\n    return useLeitenRequests.getState()[key] || initialState;\n  };\n\n  const getContent = (): Result => {\n    const result = get(store.getState(), path, \"_empty\") as Result | \"_empty\";", "    if (result !== \"_empty\") {\n      return result || initialContent;\n    } else {\n      return initialContent;\n    }\n  };\n\n  const _set = (value: Partial<Result> | void, rewrite = false) => {\n    if (typeof value === \"object\") {\n      const state = getContent();\n      const objectContent = rewrite\n        ? ({ ...value } as Result)\n        : ({ ...state, ...value } as Result);\n      const content = typeof value === \"object\" ? objectContent : value;\n      setContent(content);\n    } else {\n      value !== undefined && value !== null && setContent(value);\n    }\n  };\n\n  let previousResult: Result = getContent();\n\n  const reactions = {\n    action: (payload: Payload, status?: ILoadingStatus, requestId?: string) => {\n      setState({\n        status: status ?? \"loading\",\n        payload,\n        error: undefined,\n        requestId: requestId,\n      });\n      options?.action?.({\n        previousResult,\n        requestId: requestId || \"\",\n        payload,\n      });\n      previousResult = getContent();\n", "    if (typeof value === \"object\") {\n      const state = getContent();\n      const objectContent = rewrite\n        ? ({ ...value } as Result)\n        : ({ ...state, ...value } as Result);\n      const content = typeof value === \"object\" ? objectContent : value;\n      setContent(content);\n    } else {\n      value !== undefined && value !== null && setContent(value);\n    }\n  };\n\n  let previousResult: Result = getContent();\n\n  const reactions = {\n    action: (payload: Payload, status?: ILoadingStatus, requestId?: string) => {\n      setState({\n        status: status ?? \"loading\",\n        payload,\n        error: undefined,\n        requestId: requestId,\n      });\n      options?.action?.({\n        previousResult,\n        requestId: requestId || \"\",\n        payload,\n      });\n      previousResult = getContent();\n", "      if (options?.optimisticUpdate) {\n        setContent(options.optimisticUpdate(payload));\n      }\n    },\n    fulfilled: (result: Result, payload: Payload, requestId: string) => {\n      const state = getState();\n      if (requestId === state.requestId) {\n        setState({ ...state, status: \"loaded\" });\n        if (\n          result !== undefined &&\n          (!options?.optimisticUpdate || !isEqual(previousResult, result))\n        ) {\n          setContent(result);\n        }\n        options?.fulfilled?.({ previousResult, requestId, payload, result });\n      }\n    },\n    rejected: (payload: Payload, error: string, requestId?: string) => {\n      const state = getState();\n      setState({ ...state, status: \"error\", error });\n      options?.rejected?.({\n        previousResult,\n        requestId: requestId || \"\",\n        payload,\n        error,\n      });", "        if (\n          result !== undefined &&\n          (!options?.optimisticUpdate || !isEqual(previousResult, result))\n        ) {\n          setContent(result);\n        }\n        options?.fulfilled?.({ previousResult, requestId, payload, result });\n      }\n    },\n    rejected: (payload: Payload, error: string, requestId?: string) => {\n      const state = getState();\n      setState({ ...state, status: \"error\", error });\n      options?.rejected?.({\n        previousResult,\n        requestId: requestId || \"\",\n        payload,\n        error,\n      });", "      if (options?.optimisticUpdate) {\n        setContent(previousResult);\n      }\n    },\n    abort: (payload: Payload, requestId: string) => {\n      setState(initialState);\n      options?.abort?.({ previousResult, requestId, payload });\n      if (options?.optimisticUpdate) {\n        setContent(previousResult);\n      }\n    },\n    resolved: (payload: Payload, requestId: string) => {\n      options?.resolved?.({ previousResult, requestId, payload });\n    },\n  };\n\n  const { action, abort } = createAsyncActions(payloadCreator, reactions);\n\n  const _abort = () => {\n    abort();\n  };\n\n  const clear = () => {\n    setState(initialState);\n    setContent(initialContent);\n  };\n\n  const usages: Record<string, boolean> = {};\n  const useRequest: UseRequestType<Payload, Result> = (selector, equals) => {\n    const [id] = useState(() => nanoid());\n\n    useEffect(() => {\n      usages[id] = true;\n\n      return () => {\n        usages[id] = false;\n      };\n    }, []);\n\n    return useLeitenRequests(\n      (state) => (selector || nonTypedReturn)(state[key] || initialState),\n      shallow || equals\n    );\n  };\n\n  resettableStoreSubscription(store, () => setState(initialState));\n\n  const _get = () => {\n    return useLeitenRequests.getState()[key];\n  };\n\n  return Object.assign(useRequest, {\n    abort: _abort,\n    action,\n    clear,\n    set: _set,\n    key,\n    get: _get,\n    _usages: usages,\n  });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst nonTypedReturn = (value: any) => value;\n\nexport const resettableStoreSubscription = (\n  store: StoreApi<object>,\n  callback: () => void\n) => {\n  setTimeout(() => {\n    const resettable =\n      (store.getState() as any)[\"_resettableLifeCycle\"] !== undefined;", "    if (resettable) {\n      store.subscribe((next, prev) => {\n        if (\n          (next as any)[\"_resettableLifeCycle\"] === false &&\n          (prev as any)[\"_resettableLifeCycle\"] === true\n        )\n          callback();\n      });\n    }\n  }, 0);\n};\n", "function createAsyncActions<Payload, Result>(\n  payloadCreator: (\n    params: Payload,\n    extraArgument?: IExtraArgument\n  ) => Promise<Result>,\n  extra?: IReaction<Payload, Result>\n) {\n  let controller = new AbortController();\n  let signal = controller.signal;\n\n  const abort = () => {\n    controller.abort();\n    controller = new AbortController();\n    signal = controller.signal;\n  };\n\n  const action = (\n    params: Payload,\n    options?: { status?: ILoadingStatus; requestId?: string }\n  ) => {\n    const requestId = options?.requestId || nanoid();\n    extra?.action?.(params, options?.status, requestId);\n    payloadCreator(params, { signal })\n      .then((result) => {\n        extra?.fulfilled?.(result, params, requestId);\n      })", "      .catch((error) => {\n        if (error.message === \"The user aborted a request.\") {\n          extra?.abort?.(params, requestId);\n        } else {\n          extra?.rejected?.(params, error, requestId);\n        }\n      })\n      .finally(() => {\n        extra?.resolved?.(params, requestId);\n      });\n  };\n  return { action, abort };\n}\n", "interface IReaction<Payload, Result> {\n  fulfilled?: (result: Result, params: Payload, requestId: string) => void;\n  rejected?: (params: Payload, error: string, requestId?: string) => void;\n  abort?: (params: Payload, requestId: string) => void;\n  resolved?: (params: Payload, requestId: string) => void;\n  action?: (\n    params: Payload,\n    status?: ILoadingStatus,\n    requestId?: string\n  ) => void;\n}\n", "export type IExtraArgument = {\n  signal: AbortSignal;\n  // requestId: string\n};\n"]}
{"filename": "src/helpers/leitenGroupRequest.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, set } from \"lodash-es\";\nimport { StoreApi } from \"zustand/esm\";\nimport { shallow } from \"zustand/shallow\";\n\nimport { useLeitenRequests } from \"../hooks/useLeitenRequest\";\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\nimport {\n  ILeitenLoading,\n  ILoadingStatus,", "  ILeitenLoading,\n  ILoadingStatus,\n  initialLeitenLoading,\n} from \"../interfaces/IContentLoading\";\nimport {\n  ILeitenRequest,\n  ILeitenRequestOptions,\n  leitenRequest,\n  resettableStoreSubscription,\n} from \"./leitenRequest\";", "  resettableStoreSubscription,\n} from \"./leitenRequest\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport interface ILeitenGroupRequestParams<Params> {\n  key: string;\n  params: Params;\n}\n\nexport interface IGroupCallOptions {\n  status?: ILoadingStatus;\n  requestId?: string;\n}\n", "export interface IGroupCallOptions {\n  status?: ILoadingStatus;\n  requestId?: string;\n}\n\nexport type AcceptableGroupRequestType<Store extends object> =\n  void | DotNestedValue<Store, DotNestedKeys<Store>> | null;\n\ntype LeitenState<Payload, Result> = ILeitenLoading<\n  ILeitenGroupRequestParams<Payload>,\n  Result\n>;\n", "type LeitenState<Payload, Result> = ILeitenLoading<\n  ILeitenGroupRequestParams<Payload>,\n  Result\n>;\n\ntype UseRequestType<Payload, Result> = <U = LeitenState<Payload, Result>>(\n  key: string,\n  selector?: (state: LeitenState<Payload, Result>) => U,\n  equals?: (a: U, b: U) => boolean\n) => U;\n", "type UseGroupRequestType<Payload, Result> = <U = LeitenState<Payload, Result>>(\n  selector?: (state: Record<string, LeitenState<Payload, Result>>) => U,\n  equals?: (a: U, b: U) => boolean\n) => U;\n\nexport type ILeitenGroupRequest<Payload, Result> = {\n  clear: (key?: string) => void;\n  action: (\n    params: ILeitenGroupRequestParams<Payload>[],\n    options?: IGroupCallOptions\n  ) => void;\n  requests: Record<\n    string,\n    ILeitenRequest<ILeitenGroupRequestParams<Payload>, Result>\n  >;\n} & UseRequestType<Payload, Result> &\n  UseGroupRequestType<Payload, Result>;\n", "export interface ILeitenGroupRequestOption<Payload, Result>\n  extends ILeitenRequestOptions<ILeitenGroupRequestParams<Payload>, Result> {\n  initialContent?: Result | ((key: string) => Result);\n}\n\nexport interface ILeitenGroupRequestArrayOption<Payload, Result>\n  extends ILeitenGroupRequestOption<Payload, Result> {\n  getKey: (value: Result) => string;\n}\n\nexport const leitenGroupRequest = <\n  Store extends object,\n  P extends DotNestedKeys<Store>,\n  Payload,\n  Result extends DotNestedValue<Store, P> extends Record<\n    string,\n    AcceptableGroupRequestType<Store>\n  >\n    ? DotNestedValue<Store, P>[string]\n    : DotNestedValue<Store, P> extends Array<AcceptableGroupRequestType<Store>>\n    ? DotNestedValue<Store, P>[number]\n    : DotNestedValue<Store, P>\n>(\n  store: StoreApi<Store>,\n  path: P extends string\n    ? Result extends void\n      ? P\n      : DotNestedValue<Store, P> extends Record<string, Result> | Array<Result>\n      ? P\n      : never\n    : never,\n  payloadCreator: (\n    params: ILeitenGroupRequestParams<Payload>\n  ) => Promise<Result>,\n  options?: DotNestedValue<Store, P> extends Record<\n    string,\n    AcceptableGroupRequestType<Store>\n  >\n    ? ILeitenGroupRequestOption<Payload, Result>\n    : ILeitenGroupRequestArrayOption<Payload, Result>\n): ILeitenGroupRequest<Payload, Result> => {\n  const initialRequestState = initialLeitenLoading<\n    ILeitenGroupRequestParams<Payload>,\n    Result\n  >(options?.initialStatus);\n  let requests: Record<\n    string,\n    ILeitenRequest<ILeitenGroupRequestParams<Payload>, Result>\n  > = {};\n\n  const isArray = Array.isArray(get(store.getState(), path));\n\n  const getPathToArrayItem = (key: string) => {\n    const raw = get(store.getState(), path, []);\n    const source = Array.isArray(raw) ? raw : [];\n    const find = source.findIndex(\n      (s) =>\n        (options as ILeitenGroupRequestArrayOption<Payload, Result>)?.getKey?.(\n          s\n        ) === key\n    );\n    const index = find !== -1 ? find : source.length;\n    const withKey = (path + `[\"${index}\"]`) as DotNestedKeys<Store>;\n    return { withKey, isNew: find === -1 };\n  };\n\n  const add = (key: string) => {\n    let pathWithKey = \"\" as DotNestedKeys<Store>;\n    let payload = payloadCreator;", "    if (isArray) {\n      const before = getPathToArrayItem(key);\n      pathWithKey = before.withKey;\n      // eslint-disable-next-line\n      // @ts-ignore\n      payload = async (params: ILeitenGroupRequestParams<Payload>) => {\n        const result = await payloadCreator(params);\n        const after = getPathToArrayItem(key);\n        if ((before.isNew && after.isNew) || !after.isNew) {\n          const nextState = produce(store.getState(), (draft) => {\n            set(draft, after.withKey, result);\n          });\n          store.setState(nextState);\n        }\n      };\n    } else {\n      pathWithKey = (path + `.${key}`) as DotNestedKeys<Store>;", "        if ((before.isNew && after.isNew) || !after.isNew) {\n          const nextState = produce(store.getState(), (draft) => {\n            set(draft, after.withKey, result);\n          });\n          store.setState(nextState);\n        }\n      };\n    } else {\n      pathWithKey = (path + `.${key}`) as DotNestedKeys<Store>;\n      if (options?.initialContent) {\n        const initial = checkInitial(options.initialContent)\n          ? options.initialContent(key)\n          : options.initialContent;\n        const nextState = produce(store.getState(), (draft) => {\n          set(draft, pathWithKey, initial);\n        });\n        store.setState(nextState);\n      }\n    }\n    requests[key] = leitenRequest(store, pathWithKey, payload, options);\n  };\n\n  const action = (\n    params: ILeitenGroupRequestParams<Payload>[],\n    options?: IGroupCallOptions\n  ) => {\n    params.forEach(({ key, params }) => {\n      const request = requests[key];\n      const payload = { key, params };\n", "      if (options?.initialContent) {\n        const initial = checkInitial(options.initialContent)\n          ? options.initialContent(key)\n          : options.initialContent;\n        const nextState = produce(store.getState(), (draft) => {\n          set(draft, pathWithKey, initial);\n        });\n        store.setState(nextState);\n      }\n    }\n    requests[key] = leitenRequest(store, pathWithKey, payload, options);\n  };\n\n  const action = (\n    params: ILeitenGroupRequestParams<Payload>[],\n    options?: IGroupCallOptions\n  ) => {\n    params.forEach(({ key, params }) => {\n      const request = requests[key];\n      const payload = { key, params };\n", "      if (request && !isArray) {\n        request.action(payload, options);\n      } else {\n        add(key);\n        requests[key].action(payload);\n      }\n    });\n  };\n\n  const clear = (key?: string) => {\n    if (key) {\n      !isArray && requests[key].clear();\n      delete requests[key];\n    } else {\n      set(store, path, {});\n      requests = {};\n    }\n  };\n\n  const useRequest: UseRequestType<Payload, Result> = (\n    key,\n    selector,\n    equals\n  ) => {\n    return useLeitenRequests((state) => {\n      const id = requests[key]?.key;\n      return (selector || nonTypedReturn)(\n        (id && state[id]) || initialRequestState\n      );\n    }, shallow || equals);\n  };\n\n  const useGroupRequest: UseGroupRequestType<Payload, Result> = (\n    selector,\n    equals\n  ) => {\n    return useLeitenRequests(\n      (state: Record<string, LeitenState<Payload, Result>>) => {\n        const keys = Object.entries(requests).map(([id, value]) => ({\n          id,\n          key: value.key,\n        }));\n        const requestsStore: typeof state = keys.reduce((acc, { id, key }) => {\n          return Object.assign(acc, { [id]: state[key] });\n        }, {} as typeof state);\n\n        return (selector || nonTypedReturn)(requestsStore);\n      },\n      shallow || equals\n    );\n  };\n", "    if (key) {\n      !isArray && requests[key].clear();\n      delete requests[key];\n    } else {\n      set(store, path, {});\n      requests = {};\n    }\n  };\n\n  const useRequest: UseRequestType<Payload, Result> = (\n    key,\n    selector,\n    equals\n  ) => {\n    return useLeitenRequests((state) => {\n      const id = requests[key]?.key;\n      return (selector || nonTypedReturn)(\n        (id && state[id]) || initialRequestState\n      );\n    }, shallow || equals);\n  };\n\n  const useGroupRequest: UseGroupRequestType<Payload, Result> = (\n    selector,\n    equals\n  ) => {\n    return useLeitenRequests(\n      (state: Record<string, LeitenState<Payload, Result>>) => {\n        const keys = Object.entries(requests).map(([id, value]) => ({\n          id,\n          key: value.key,\n        }));\n        const requestsStore: typeof state = keys.reduce((acc, { id, key }) => {\n          return Object.assign(acc, { [id]: state[key] });\n        }, {} as typeof state);\n\n        return (selector || nonTypedReturn)(requestsStore);\n      },\n      shallow || equals\n    );\n  };\n", "  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n    key: string,\n    selector?: (state: LeitenState<Payload, Result>) => U,\n    equals?: (a: U, b: U) => boolean\n  ): U;\n  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n    selector?: (state: Record<string, LeitenState<Payload, Result>>) => U,\n    equals?: (a: U, b: U) => boolean\n  ): U;\n  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n    first?:\n      | string\n      | ((state: Record<string, LeitenState<Payload, Result>>) => U),\n    second?:\n      | ((state: LeitenState<Payload, Result>) => U)\n      | ((a: U, b: U) => boolean),\n    third?: (a: U, b: U) => boolean\n  ): U {", "  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n    first?:\n      | string\n      | ((state: Record<string, LeitenState<Payload, Result>>) => U),\n    second?:\n      | ((state: LeitenState<Payload, Result>) => U)\n      | ((a: U, b: U) => boolean),\n    third?: (a: U, b: U) => boolean\n  ): U {\n    if (first !== undefined && typeof first === \"string\") {\n      return useRequest(first, second as any, third);\n    } else {\n      return useGroupRequest(first as any, second as any) as any;\n    }\n  }\n\n  resettableStoreSubscription(store, () => clear());\n\n  return Object.assign(hook, { clear, action, requests, call: action });\n};\n\nconst nonTypedReturn = (value: any) => value;\nconst checkInitial = <Result>(\n  value: Result | ((key: string) => Result)\n): value is (key: string) => Result => typeof value === \"function\";\n", "    if (first !== undefined && typeof first === \"string\") {\n      return useRequest(first, second as any, third);\n    } else {\n      return useGroupRequest(first as any, second as any) as any;\n    }\n  }\n\n  resettableStoreSubscription(store, () => clear());\n\n  return Object.assign(hook, { clear, action, requests, call: action });\n};\n\nconst nonTypedReturn = (value: any) => value;\nconst checkInitial = <Result>(\n  value: Result | ((key: string) => Result)\n): value is (key: string) => Result => typeof value === \"function\";\n"]}
{"filename": "src/helpers/leitenGroupFilterRequest.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, set } from \"lodash-es\";\nimport { StoreApi } from \"zustand\";\nimport { UseBoundStore } from \"zustand/esm\";\n\nimport {\n  DotNestedKeys,\n  DotNestedValue,\n  ValueOf,\n} from \"../interfaces/dotNestedKeys\";", "  ValueOf,\n} from \"../interfaces/dotNestedKeys\";\nimport { getObjectDifference, IObjectDifferent } from \"./leitenFilterRequest\";\nimport {\n  AcceptableGroupRequestType,\n  ILeitenGroupRequestArrayOption,\n  ILeitenGroupRequestOption,\n  ILeitenGroupRequestParams,\n  leitenGroupRequest,\n} from \"./leitenGroupRequest\";", "  leitenGroupRequest,\n} from \"./leitenGroupRequest\";\nimport { ILeitenRecordEffects } from \"./leitenRecord\";\nimport { resettableStoreSubscription } from \"./leitenRequest\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const leitenGroupFilterRequest = <\n  Store extends object,\n  P extends DotNestedKeys<Store>,\n  Result extends DotNestedValue<Store, P> extends Record<", "  P extends DotNestedKeys<Store>,\n  Result extends DotNestedValue<Store, P> extends Record<\n    string,\n    AcceptableGroupRequestType<Store>\n  >\n    ? NonNullable<DotNestedValue<Store, P>[string]>\n    : DotNestedValue<Store, P> extends Array<AcceptableGroupRequestType<Store>>\n    ? NonNullable<DotNestedValue<Store, P>[number]>\n    : DotNestedValue<Store, P>\n>(", "    : DotNestedValue<Store, P>\n>(\n  store: UseBoundStore<StoreApi<Store>>,\n  path: P extends string\n    ? Result extends void\n      ? P\n      : DotNestedValue<Store, P> extends Record<string, Result> | Array<Result>\n      ? P\n      : never\n    : never,", "      : never\n    : never,\n  request: (params: ILeitenGroupRequestParams<void>) => Promise<Result>,\n  options?: DotNestedValue<Store, P> extends Record<\n    string,\n    AcceptableGroupRequestType<Store>\n  >\n    ? ILeitenGroupRequestOption<void, Result>\n    : ILeitenGroupRequestArrayOption<void, Result>\n) => {", "    : ILeitenGroupRequestArrayOption<void, Result>\n) => {\n  const leiten = leitenGroupRequest(store, path, request, {\n    ...options,\n    action: (args) => {\n      const key = args.payload.key;\n      updatePrevFilters(key);\n      return options?.action?.(args);\n    },\n  } as DotNestedValue<Store, P> extends Record<string, AcceptableGroupRequestType<Store>> ? ILeitenGroupRequestOption<void, Result> : ILeitenGroupRequestArrayOption<void, Result>);", "    },\n  } as DotNestedValue<Store, P> extends Record<string, AcceptableGroupRequestType<Store>> ? ILeitenGroupRequestOption<void, Result> : ILeitenGroupRequestArrayOption<void, Result>);\n\n  const filters: Record<string, IGroupRecord<any>> = {};\n  const prevFilters: Record<string, Record<string, any>> = {};\n\n  const createFilter = <Path extends DotNestedKeys<Store>>(\n    path: Path extends string\n      ? DotNestedValue<Store, Path> extends Record<string, unknown>\n        ? Path", "      ? DotNestedValue<Store, Path> extends Record<string, unknown>\n        ? Path\n        : never\n      : never,\n    options: ILeitenRecordEffects<\n      ValueOf<DotNestedValue<Store, Path>>,\n      Store\n    > & {\n      initialValue: ValueOf<DotNestedValue<Store, Path>>;\n    }", "      initialValue: ValueOf<DotNestedValue<Store, Path>>;\n    }\n  ) => {\n    prevFilters[path] = {};\n    type VALUE = ValueOf<DotNestedValue<Store, Path>>;\n\n    function hook(\n      key: string,\n      referenceObject?: VALUE\n    ): IObjectDifferent<VALUE>[] {\n      return store((state) =>\n        getObjectDifference(get(state, `${path}.${key}`), referenceObject)\n      );\n    }\n\n    const getState = (key: string): VALUE | undefined => {\n      return get(store.getState(), `${path}.${key}`, undefined);\n    };\n\n    const setState = (key: string, next: VALUE) => {\n      const prev = getState(key);\n      const draftState = produce(store.getState(), (draft) => {\n        set(draft, `${path}.${key}`, next);\n      });\n      const nextState = options.patchEffect\n        ? { ...draftState, ...options.patchEffect(next) }\n        : draftState;\n      store.setState(nextState);\n      options.sideEffect?.({ prev: prev || options.initialValue, next });\n      action(key, path, options.initialValue);\n    };\n\n    const clear = (key: string) => {\n      setState(key, options.initialValue);\n    };\n\n    const patch = (key: string, value: Partial<VALUE>) => {\n      const prev: object = (getState(key) || options.initialValue) as any;\n      setState(key, { ...prev, ...value } as VALUE);\n    };\n\n    const record = { clear, patch, set: setState, get: getState };\n\n    filters[path] = record;\n\n    return Object.assign(hook, record);\n  };\n\n  const action = async (key: string, path: string, initialValue: any) => {\n    const nextFilters = get(store.getState(), `${path}.${key}`);\n", "    if (\n      JSON.stringify(nextFilters) !==\n      JSON.stringify(prevFilters[path][key] || initialValue)\n    ) {\n      leiten.action([{ key, params: undefined }]);\n    }\n  };\n\n  const updatePrevFilters = (key: string) => {\n    Object.keys(filters).forEach((item) => {\n      prevFilters[item][key] = get(store.getState(), `${item}.${key}`);\n    });\n  };\n\n  resettableStoreSubscription(store, () => {\n    Object.keys(filters).forEach((path) => {\n      prevFilters[path] = {};\n    });\n  });\n\n  const clearAll = () => {\n    leiten.clear();\n    const keys = Object.keys(leiten.requests);\n    Object.keys(filters).forEach((key) =>\n      keys.forEach((k) => filters[key]?.clear(k))\n    );\n  };\n\n  return Object.assign(leiten, { createFilter, clearAll });\n};\n", "interface IGroupRecord<VALUE> {\n  clear: (key: string) => void;\n  patch: (key: string, value: Partial<VALUE>) => void;\n  set: (key: string, next: VALUE) => void;\n  get: (key: string) => VALUE | undefined;\n}\n"]}
{"filename": "src/helpers/leitenRecord.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, set } from \"lodash-es\";\nimport { StoreApi } from \"zustand/esm\";\n\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport interface ILeitenRecordEffects<VALUE, State> {\n  patchEffect?: (value: VALUE) => Partial<State>;\n  sideEffect?: (value: { prev: VALUE; next: VALUE }) => void;\n}\n", "export interface ILeitenRecordEffects<VALUE, State> {\n  patchEffect?: (value: VALUE) => Partial<State>;\n  sideEffect?: (value: { prev: VALUE; next: VALUE }) => void;\n}\n\nexport interface ILeitenRecord<VALUE> {\n  patch: (value: Partial<VALUE>) => void;\n  set: (value: VALUE) => void;\n  get: () => VALUE;\n  clear: () => void;\n}\n\nexport const leitenRecord = <\n  Store extends object,\n  P extends DotNestedKeys<Store>\n>(\n  store: StoreApi<Store>,\n  path: P extends string\n    ? DotNestedValue<Store, P> extends Array<any>\n      ? never\n      : DotNestedValue<Store, P> extends object | null\n      ? P\n      : never\n    : never,\n  effects?: ILeitenRecordEffects<DotNestedValue<Store, P>, Store>\n): ILeitenRecord<DotNestedValue<Store, P>> => {", "  type VALUE = DotNestedValue<Store, P>;\n\n  const initialValue = get(store.getState(), path, \"_empty\") as VALUE;\n  if (initialValue === \"_empty\" || typeof initialValue !== \"object\") {\n    throw new Error(\n      \"[leitenRecord] The defined path does not match the required structure\"\n    );\n  }\n\n  const getState = (): VALUE => {\n    const value = get(store.getState(), path, \"_empty\") as VALUE | \"_empty\";\n    return value !== \"_empty\" ? value : initialValue;\n  };\n\n  const setState = (next: VALUE) => {\n    const prev = getState();\n    const draftState = produce(store.getState(), (draft) => {\n      set(draft, path, next);\n    });\n    const nextState = effects?.patchEffect\n      ? { ...draftState, ...effects.patchEffect(next) }\n      : draftState;\n    store.setState(nextState);\n    effects?.sideEffect?.({ prev, next });\n  };\n\n  const clear = () => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, initialValue);\n    });\n    store.setState(nextState);\n  };\n\n  const patch = (value: Partial<VALUE>) => {\n    setState({ ...getState(), ...value });\n  };\n\n  return { clear, set: setState, get: getState, patch };\n};\n"]}
{"filename": "src/helpers/index.ts", "chunked_list": ["export * from \"../hooks/useLeitenModals\";\nexport * from \"../hooks/useLeitenRequest\";\nexport * from \"./leitenFilterRequest\";\nexport * from \"./leitenGroupFilterRequest\";\nexport * from \"./leitenGroupRequest\";\nexport * from \"./leitenList\";\nexport * from \"./leitenModal\";\nexport * from \"./leitenNormalizedList\";\nexport * from \"./leitenPrimitive\";\nexport * from \"./leitenRecord\";", "export * from \"./leitenPrimitive\";\nexport * from \"./leitenRecord\";\nexport * from \"./leitenRequest\";\n"]}
{"filename": "src/helpers/leitenModal.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { get, set } from \"lodash-es\";\nimport { nanoid } from \"nanoid\";\nimport { StoreApi } from \"zustand\";\nimport { shallow } from \"zustand/shallow\";\n\nimport {\n  leitenModalManagerAction,\n  useLeitenModalStack,\n} from \"../hooks/useLeitenModals\";", "  useLeitenModalStack,\n} from \"../hooks/useLeitenModals\";\nimport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\ntype ActionType = \"OPEN\" | \"CLOSE\" | \"TOGGLE\" | \"SET_DATA\";\n\nexport interface ILeitenModal<Data> {\n  open: (data?: Data, replace?: boolean) => void;\n  close: () => void;\n  action: (params: {\n    type: ActionType;\n    payload?: Data;\n    replace?: boolean;\n  }) => void;\n\n  (): [boolean, boolean];\n}\n\nexport const leitenModal = <\n  Store extends object,\n  P extends DotNestedKeys<Store>\n>(\n  store: StoreApi<Store>,\n  path: P extends string ? P : never,\n  extra?: {\n    reaction?: (params: {\n      type: ActionType;\n      payload?: DotNestedValue<Store, P>;\n    }) => void;\n    clearOnClose?: boolean;\n  }\n): ILeitenModal<DotNestedValue<Store, P>> => {", "  type Data = DotNestedValue<Store, P>;\n\n  const initialData = get(store.getState(), path, \"_empty\") as Data;\n  if (initialData === \"_empty\") {\n    throw new Error(\"[leitenModal] The defined path does not exist\");\n  }\n\n  const key = nanoid(10);\n\n  const setContent = (value: Data) => {\n    const nextState = produce(store.getState(), (draft) => {\n      set(draft, path, value);\n    });\n    store.setState(nextState);\n  };\n\n  const setState = (value: boolean, replace?: boolean) => {\n    leitenModalManagerAction(key, value, replace);\n  };\n\n  const action = (params: {\n    type: ActionType;\n    payload?: Data;\n    replace?: boolean;\n  }) => {", "    if (params.type === \"CLOSE\") {\n      setState(false);\n      if (extra?.clearOnClose) {\n        setContent(initialData);\n      }\n    } else if (params.type === \"OPEN\") {\n      setState(true, params.replace);\n      params.payload && setContent(params.payload);\n    } else if (params.type === \"TOGGLE\") {\n      const isOpen = () => useLeitenModalStack.getState().queue.includes(key);\n\n      setState(!isOpen());", "    } else if (params.type === \"TOGGLE\") {\n      const isOpen = () => useLeitenModalStack.getState().queue.includes(key);\n\n      setState(!isOpen());\n      if (!isOpen() && extra?.clearOnClose) {\n        setContent(initialData);\n      }\n    } else if (params.type === \"SET_DATA\") {\n      params.payload && setContent(params.payload);\n    }\n    extra?.reaction?.(params);\n  };\n\n  const open = (data?: DotNestedValue<Store, P>, replace?: boolean) => {\n    action({ type: \"OPEN\", payload: data, replace });\n  };\n\n  const close = () => action({ type: \"CLOSE\" });\n\n  const useOpen = () => {\n    return useLeitenModalStack((state) => {\n      const open = state.queue.includes(key);\n      const hidden = open && state.queue[state.queue.length - 1] !== key;\n      return [open, hidden] as [boolean, boolean];\n    }, shallow);\n  };\n\n  return Object.assign(useOpen, { action, close, open });\n};\n"]}
{"filename": "src/hooks/useLeitenModals.ts", "chunked_list": ["import { produce } from \"immer\";\nimport { create } from \"zustand\";\n\nexport interface LeitenModalManagerState {\n  queue: string[];\n}\n\nexport const useLeitenModalStack = create<LeitenModalManagerState>(() => ({\n  queue: [],\n}));\n\nexport const leitenModalManagerAction = (\n  key: string,\n  value: boolean,\n  replace?: boolean\n) => {\n  const nextState = produce(useLeitenModalStack.getState(), (draft) => {\n    let queue = draft.queue.filter((modal) => modal !== key);", "    if (replace) {\n      queue = [];\n    }\n    if (value) {\n      queue.push(key);\n    }\n    draft.queue = queue;\n  });\n  useLeitenModalStack.setState(nextState);\n};\n"]}
{"filename": "src/hooks/useLeitenRequest.ts", "chunked_list": ["import { create } from \"zustand\";\n\nimport {\n  ILeitenLoading,\n  initialLeitenLoading,\n} from \"../interfaces/IContentLoading\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const useLeitenRequests = create<{\n  [key: string]: ILeitenLoading<any, any>;", "export const useLeitenRequests = create<{\n  [key: string]: ILeitenLoading<any, any>;\n}>(() => ({}));\n\ntype TupleOfKeys = [string] | string[];\ntype TupleOfStates<T extends TupleOfKeys> = {\n  [K in keyof T]: ILeitenLoading<any, any>;\n};\n\nexport const leitenMap = <T extends TupleOfKeys, Response>(\n  keys: T,\n  selector: (values: TupleOfStates<T>) => Response\n) => {\n  return (state: { [key: string]: ILeitenLoading<any, any> }) =>\n    selector(\n      keys.map(\n        (key) => state[key] || initialLeitenLoading()\n      ) as TupleOfStates<T>\n    );\n};\n"]}
{"filename": "src/examples/requests.ts", "chunked_list": ["export interface IKeyword {\n  value: string;\n  bid: number;\n}\n\nexport interface ICard {\n  value: string;\n  type: \"bid\" | \"defaultBid\";\n}\n\nexport interface IUser {\n  name: string;\n  surname: string;\n  keywords: IKeyword[];\n  cards: string[];\n}\n\nexport const getUser = async (\n  id: string,\n  signal?: AbortSignal\n): Promise<IUser> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const result: IUser = {\n        name: \"Name\" + id,\n        surname: \"Surname\",\n        keywords: [],\n        cards: [\"1\", \"2\"],\n      };\n      resolve(result);\n    }, 2000);\n  });\n};\n\nexport const updateUser = async (user: IUser): Promise<void> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      // console.log(user); // send to server\n      resolve();\n    }, 2000);\n  });\n};\n\nexport const getCard = async (param: string): Promise<ICard> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const result: ICard = {\n        type: \"bid\",\n        value: \"test\" + param,\n      };\n      resolve(result);\n    }, 2000);\n  });\n};\n", "export interface IUser {\n  name: string;\n  surname: string;\n  keywords: IKeyword[];\n  cards: string[];\n}\n\nexport const getUser = async (\n  id: string,\n  signal?: AbortSignal\n): Promise<IUser> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const result: IUser = {\n        name: \"Name\" + id,\n        surname: \"Surname\",\n        keywords: [],\n        cards: [\"1\", \"2\"],\n      };\n      resolve(result);\n    }, 2000);\n  });\n};\n\nexport const updateUser = async (user: IUser): Promise<void> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      // console.log(user); // send to server\n      resolve();\n    }, 2000);\n  });\n};\n\nexport const getCard = async (param: string): Promise<ICard> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const result: ICard = {\n        type: \"bid\",\n        value: \"test\" + param,\n      };\n      resolve(result);\n    }, 2000);\n  });\n};\n", "export interface IChartFilter {\n  period: \"today\" | \"yesterday\" | \"latsWeek\" | \"lastMonth\";\n  type: \"sales\" | \"income\";\n}\n\nexport const getChart = async (\n  filter: IChartFilter,\n  signal?: AbortSignal\n): Promise<number[]> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const result: number[] = Array(100).fill(2);\n      resolve(result);\n    }, 2000);\n  });\n};\n"]}
