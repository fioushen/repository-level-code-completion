{"filename": "src/prompt.ts", "chunked_list": ["import * as p from '@clack/prompts';\nimport { execaCommand } from 'execa';\nimport { cyan, dim } from 'kolorist';\nimport {\n  getExplanation,\n  getRevision,\n  getScriptAndInfo,\n} from './helpers/completion';\nimport { getConfig } from './helpers/config';\nimport { projectName } from './helpers/constants';", "import { getConfig } from './helpers/config';\nimport { projectName } from './helpers/constants';\nimport { KnownError } from './helpers/error';\nimport clipboardy from 'clipboardy';\nimport i18n from './helpers/i18n';\n\nconst init = async () => {\n  try {\n    const { LANGUAGE: language } = await getConfig();\n    i18n.setLanguage(language);\n  } catch {\n    i18n.setLanguage('en');\n  }\n};\n\nconst examples: string[] = [];\ninit().then(() => {\n  examples.push(i18n.t('delete all log files'));\n  examples.push(i18n.t('list js files'));\n  examples.push(i18n.t('fetch me a random joke'));\n  examples.push(i18n.t('list all commits'));\n});\n\nconst sample = <T>(arr: T[]): T | undefined => {\n  const len = arr == null ? 0 : arr.length;\n  return len ? arr[Math.floor(Math.random() * len)] : undefined;\n};\n", "async function runScript(script: string) {\n  p.outro(`${i18n.t('Running')}: ${script}`);\n  console.log('');\n  await execaCommand(script, {\n    stdio: 'inherit',\n    shell: process.env.SHELL || true,\n  }).catch(() => {\n    // Nothing needed, it'll output to stderr\n  });\n}\n", "async function getPrompt(prompt?: string) {\n  const group = p.group(\n    {\n      prompt: () =>\n        p.text({\n          message: i18n.t('What would you like me to do?'),\n          placeholder: `${i18n.t('e.g.')} ${sample(examples)}`,\n          initialValue: prompt,\n          defaultValue: i18n.t('Say hello'),\n          validate: (value) => {\n            if (!value) return i18n.t('Please enter a prompt.');\n          },\n        }),\n    },\n    {\n      onCancel: () => {\n        p.cancel(i18n.t('Goodbye!'));\n        process.exit(0);\n      },\n    }\n  );\n  return (await group).prompt;\n}\n", "            if (!value) return i18n.t('Please enter a prompt.');\n          },\n        }),\n    },\n    {\n      onCancel: () => {\n        p.cancel(i18n.t('Goodbye!'));\n        process.exit(0);\n      },\n    }\n  );\n  return (await group).prompt;\n}\n", "async function promptForRevision() {\n  const group = p.group(\n    {\n      prompt: () =>\n        p.text({\n          message: i18n.t('What would you like me to change in this script?'),\n          placeholder: i18n.t('e.g. change the folder name'),\n          validate: (value) => {\n            if (!value) return i18n.t('Please enter a prompt.');\n          },\n        }),\n    },\n    {\n      onCancel: () => {\n        p.cancel(i18n.t('Goodbye!'));\n        process.exit(0);\n      },\n    }\n  );\n  return (await group).prompt;\n}\n", "            if (!value) return i18n.t('Please enter a prompt.');\n          },\n        }),\n    },\n    {\n      onCancel: () => {\n        p.cancel(i18n.t('Goodbye!'));\n        process.exit(0);\n      },\n    }\n  );\n  return (await group).prompt;\n}\n", "export async function prompt({\n  usePrompt,\n  silentMode,\n}: { usePrompt?: string; silentMode?: boolean } = {}) {\n  const {\n    OPENAI_KEY: key,\n    SILENT_MODE,\n    OPENAI_API_ENDPOINT: apiEndpoint,\n    MODEL: model,\n  } = await getConfig();\n  const skipCommandExplanation = silentMode || SILENT_MODE;\n\n  console.log('');\n  p.intro(`${cyan(`${projectName}`)}`);\n\n  const thePrompt = usePrompt || (await getPrompt());\n  const spin = p.spinner();\n  spin.start(i18n.t(`Loading...`));\n  const { readInfo, readScript } = await getScriptAndInfo({\n    prompt: thePrompt,\n    key,\n    model,\n    apiEndpoint,\n  });\n  spin.stop(`${i18n.t('Your script')}:`);\n  console.log('');\n  const script = await readScript(process.stdout.write.bind(process.stdout));\n  console.log('');\n  console.log('');\n  console.log(dim('\u2022'));", "  if (!skipCommandExplanation) {\n    spin.start(i18n.t(`Getting explanation...`));\n    const info = await readInfo(process.stdout.write.bind(process.stdout));\n    if (!info) {\n      const { readExplanation } = await getExplanation({\n        script,\n        key,\n        apiEndpoint,\n      });\n      spin.stop(`${i18n.t('Explanation')}:`);\n      console.log('');\n      await readExplanation(process.stdout.write.bind(process.stdout));\n      console.log('');\n      console.log('');\n      console.log(dim('\u2022'));\n    }\n  }\n\n  await runOrReviseFlow(script, key, model, apiEndpoint, silentMode);\n}\n", "async function runOrReviseFlow(\n  script: string,\n  key: string,\n  model: string,\n  apiEndpoint: string,\n  silentMode?: boolean\n) {\n  const emptyScript = script.trim() === '';\n\n  const answer: symbol | (() => any) = await p.select({\n    message: emptyScript\n      ? i18n.t('Revise this script?')\n      : i18n.t('Run this script?'),\n    options: [\n      ...(emptyScript\n        ? []\n        : [\n            {\n              label: '\u2705 ' + i18n.t('Yes'),\n              hint: i18n.t('Lets go!'),\n              value: async () => {\n                await runScript(script);\n              },\n            },\n            {\n              label: '\ud83d\udcdd ' + i18n.t('Edit'),\n              hint: i18n.t('Make some adjustments before running'),\n              value: async () => {\n                const newScript = await p.text({\n                  message: i18n.t('you can edit script here:'),\n                  initialValue: script,\n                });", "                if (!p.isCancel(newScript)) {\n                  await runScript(newScript);\n                }\n              },\n            },\n          ]),\n      {\n        label: '\ud83d\udd01 ' + i18n.t('Revise'),\n        hint: i18n.t('Give feedback via prompt and get a new result'),\n        value: async () => {\n          await revisionFlow(script, key, model, apiEndpoint, silentMode);\n        },\n      },\n      {\n        label: '\ud83d\udccb ' + i18n.t('Copy'),\n        hint: i18n.t('Copy the generated script to your clipboard'),\n        value: async () => {\n          await clipboardy.write(script);\n          p.outro(i18n.t('Copied to clipboard!'));\n        },\n      },\n      {\n        label: '\u274c ' + i18n.t('Cancel'),\n        hint: i18n.t('Exit the program'),\n        value: () => {\n          p.cancel(i18n.t('Goodbye!'));\n          process.exit(0);\n        },\n      },\n    ],\n  });\n", "  if (typeof answer === 'function') {\n    await answer();\n  }\n}\n\nasync function revisionFlow(\n  currentScript: string,\n  key: string,\n  model: string,\n  apiEndpoint: string,\n  silentMode?: boolean\n) {\n  const revision = await promptForRevision();\n  const spin = p.spinner();\n  spin.start(i18n.t(`Loading...`));\n  const { readScript } = await getRevision({\n    prompt: revision,\n    code: currentScript,\n    key,\n    model,\n    apiEndpoint,\n  });\n  spin.stop(`${i18n.t(`Your new script`)}:`);\n\n  console.log('');\n  const script = await readScript(process.stdout.write.bind(process.stdout));\n  console.log('');\n  console.log('');\n  console.log(dim('\u2022'));\n", "  if (!silentMode) {\n    const infoSpin = p.spinner();\n    infoSpin.start(i18n.t(`Getting explanation...`));\n    const { readExplanation } = await getExplanation({\n      script,\n      key,\n      model,\n      apiEndpoint,\n    });\n\n    infoSpin.stop(`${i18n.t('Explanation')}:`);\n    console.log('');\n    await readExplanation(process.stdout.write.bind(process.stdout));\n    console.log('');\n    console.log('');\n    console.log(dim('\u2022'));\n  }\n\n  await runOrReviseFlow(script, key, model, apiEndpoint, silentMode);\n}\n\nexport const parseAssert = (name: string, condition: any, message: string) => {", "  if (!condition) {\n    throw new KnownError(\n      `${i18n.t('Invalid config property')} ${name}: ${message}`\n    );\n  }\n};\n"]}
{"filename": "src/cli.ts", "chunked_list": ["import { cli } from 'cleye';\nimport { red } from 'kolorist';\nimport { version } from '../package.json';\nimport config from './commands/config';\nimport update from './commands/update';\nimport chat from './commands/chat';\nimport { commandName } from './helpers/constants';\nimport { handleCliError } from './helpers/error';\nimport { prompt } from './prompt';\n", "import { prompt } from './prompt';\n\ncli(\n  {\n    name: commandName,\n    version: version,\n    flags: {\n      prompt: {\n        type: String,\n        description: 'Prompt to run',", "        type: String,\n        description: 'Prompt to run',\n        alias: 'p',\n      },\n      silent: {\n        type: Boolean,\n        description: 'Less verbose, skip printing the command explanation ',\n        alias: 's',\n      },\n    },", "      },\n    },\n    commands: [config, chat, update],\n  },\n  (argv) => {\n    const silentMode = argv.flags.silent;\n    const promptText = argv._.join(' ');\n\n    if (promptText.trim() === 'update') {\n      update.callback?.(argv);\n    } else {", "    if (promptText.trim() === 'update') {\n      update.callback?.(argv);\n    } else {\n      prompt({ usePrompt: promptText, silentMode }).catch((error) => {\n        console.error(`\\n${red('\u2716')} ${error.message}`);\n        handleCliError(error);\n        process.exit(1);\n      });\n    }\n  }\n);\n"]}
{"filename": "src/commands/config.ts", "chunked_list": ["import { command } from 'cleye';\nimport { red } from 'kolorist';\nimport {\n  hasOwn,\n  getConfig,\n  setConfigs,\n  showConfigUI,\n} from '../helpers/config.js';\nimport { KnownError, handleCliError } from '../helpers/error.js';\nimport i18n from '../helpers/i18n.js';", "import { KnownError, handleCliError } from '../helpers/error.js';\nimport i18n from '../helpers/i18n.js';\n\nexport default command(\n  {\n    name: 'config',\n    parameters: ['[mode]', '[key=value...]'],\n    help: {\n      description: 'Configure the CLI',\n    },", "      description: 'Configure the CLI',\n    },\n  },\n  (argv) => {\n    (async () => {\n      const { mode, keyValue: keyValues } = argv._;\n\n      if (mode === 'ui' || !mode) {\n        await showConfigUI();\n        return;\n      }\n", "      if (!keyValues.length) {\n        console.error(\n          `${i18n.t('Error')}: ${i18n.t(\n            'Missing required parameter'\n          )} \"key=value\"\\n`\n        );\n        argv.showHelp();\n        return process.exit(1);\n      }\n\n      if (mode === 'get') {\n        const config = await getConfig();", "      if (mode === 'get') {\n        const config = await getConfig();\n        for (const key of keyValues) {\n          if (hasOwn(config, key)) {\n            console.log(`${key}=${config[key as keyof typeof config]}`);\n          } else {\n            throw new KnownError(\n              `${i18n.t('Invalid config property')}: ${key}`\n            );\n          }\n        }\n        return;\n      }\n", "      if (mode === 'set') {\n        await setConfigs(\n          keyValues.map((keyValue) => keyValue.split('=') as [string, string])\n        );\n        return;\n      }\n\n      throw new KnownError(`${i18n.t('Invalid mode')}: ${mode}`);\n    })().catch((error) => {\n      console.error(`\\n${red('\u2716')} ${error.message}`);\n      handleCliError(error);\n      process.exit(1);\n    });\n  }\n);\n", "    })().catch((error) => {\n      console.error(`\\n${red('\u2716')} ${error.message}`);\n      handleCliError(error);\n      process.exit(1);\n    });\n  }\n);\n"]}
{"filename": "src/commands/chat.ts", "chunked_list": ["import { command } from 'cleye';\nimport { spinner, intro, outro, text, isCancel } from '@clack/prompts';\nimport { cyan, green } from 'kolorist';\nimport { generateCompletion, readData } from '../helpers/completion';\nimport { getConfig } from '../helpers/config';\nimport { streamToIterable } from '../helpers/stream-to-iterable';\nimport { ChatCompletionRequestMessage } from 'openai';\nimport i18n from '../helpers/i18n';\n\nexport default command(", "\nexport default command(\n  {\n    name: 'chat',\n    help: {\n      description:\n        'Start a new chat session to send and receive messages, continue replying until the user chooses to exit.',\n    },\n  },\n  async () => {", "  },\n  async () => {\n    const {\n      OPENAI_KEY: key,\n      OPENAI_API_ENDPOINT: apiEndpoint,\n      MODEL: model,\n    } = await getConfig();\n    const chatHistory: ChatCompletionRequestMessage[] = [];\n\n    console.log('');", "\n    console.log('');\n    intro(i18n.t('Starting new conversation'));\n    const prompt = async () => {\n      const msgYou = `${i18n.t('You')}:`;\n      const userPrompt = (await text({\n        message: `${cyan(msgYou)}`,\n        placeholder: i18n.t(`send a message ('exit' to quit)`),\n        validate: (value) => {\n          if (!value) return i18n.t('Please enter a prompt.');\n        },\n      })) as string;\n", "        validate: (value) => {\n          if (!value) return i18n.t('Please enter a prompt.');\n        },\n      })) as string;\n\n      if (isCancel(userPrompt) || userPrompt === 'exit') {\n        outro(i18n.t('Goodbye!'));\n        process.exit(0);\n      }\n\n      const infoSpin = spinner();\n      infoSpin.start(i18n.t(`THINKING...`));\n      chatHistory.push({\n        role: 'user',\n        content: userPrompt,\n      });\n      const { readResponse } = await getResponse({\n        prompt: chatHistory,\n        key,\n        model,\n        apiEndpoint,\n      });\n\n      infoSpin.stop(`${green('AI Shell:')}`);\n      console.log('');\n      const fullResponse = await readResponse(\n        process.stdout.write.bind(process.stdout)\n      );\n      chatHistory.push({\n        role: 'assistant',\n        content: fullResponse,\n      });\n      console.log('');\n      console.log('');\n      prompt();\n    };\n\n    prompt();\n  }\n);\n", "async function getResponse({\n  prompt,\n  number = 1,\n  key,\n  model,\n  apiEndpoint,\n}: {\n  prompt: string | ChatCompletionRequestMessage[];\n  number?: number;\n  model?: string;\n  key: string;\n  apiEndpoint: string;\n}) {\n  const stream = await generateCompletion({\n    prompt,\n    key,\n    model,\n    number,\n    apiEndpoint,\n  });\n\n  const iterableStream = streamToIterable(stream);\n\n  return { readResponse: readData(iterableStream, () => true) };\n}\n"]}
{"filename": "src/commands/update.ts", "chunked_list": ["import { command } from 'cleye';\nimport { execaCommand } from 'execa';\nimport { dim } from 'kolorist';\nimport i18n from '../helpers/i18n';\n\nexport default command(\n  {\n    name: 'update',\n    help: {\n      description: 'Update AI Shell to the latest version',", "    help: {\n      description: 'Update AI Shell to the latest version',\n    },\n  },\n  async () => {\n    console.log('');\n    const command = `npm update -g @builder.io/ai-shell`;\n    console.log(dim(`${i18n.t('Running')}: ${command}`));\n    console.log('');\n    await execaCommand(command, {", "    console.log('');\n    await execaCommand(command, {\n      stdio: 'inherit',\n      shell: process.env.SHELL || true,\n    }).catch(() => {\n      // No need to handle, will go to stderr\n    });\n    console.log('');\n  }\n);\n"]}
{"filename": "src/helpers/os-detect.ts", "chunked_list": ["import os from 'os';\nimport path from 'path';\nimport i18n from './i18n';\n\nexport function detectShell() {\n  try {\n    // Detect if we're running on win32 and assume powershell\n    if (os.platform() === 'win32') {\n      return 'powershell';\n    }\n    // otherwise return current shell; default to bash\n    return path.basename(os.userInfo().shell ?? 'bash');", "  } catch (err: unknown) {\n    if (err instanceof Error) {\n      throw new Error(\n        `${i18n.t('Shell detection failed unexpectedly')}: ${err.message}`\n      );\n    }\n  }\n}\n"]}
{"filename": "src/helpers/completion.ts", "chunked_list": ["import { OpenAIApi, Configuration, ChatCompletionRequestMessage } from 'openai';\nimport dedent from 'dedent';\nimport { IncomingMessage } from 'http';\nimport { KnownError } from './error';\nimport { streamToIterable } from './stream-to-iterable';\nimport { detectShell } from './os-detect';\nimport type { AxiosError } from 'axios';\nimport { streamToString } from './stream-to-string';\nimport './replace-all-polyfill';\nimport i18n from './i18n';", "import './replace-all-polyfill';\nimport i18n from './i18n';\n\nconst explainInSecondRequest = true;\n\nfunction getOpenAi(key: string, apiEndpoint: string) {\n  const openAi = new OpenAIApi(\n    new Configuration({ apiKey: key, basePath: apiEndpoint })\n  );\n  return openAi;\n}\n\n// Openai outputs markdown format for code blocks. It oftne uses\n// a github style like: \"```bash\"\nconst shellCodeStartRegex = /```[^\\n]*/gi;\n", "export async function getScriptAndInfo({\n  prompt,\n  key,\n  model,\n  apiEndpoint,\n}: {\n  prompt: string;\n  key: string;\n  model?: string;\n  apiEndpoint: string;\n}) {\n  const fullPrompt = getFullPrompt(prompt);\n  const stream = await generateCompletion({\n    prompt: fullPrompt,\n    number: 1,\n    key,\n    model,\n    apiEndpoint,\n  });\n  const iterableStream = streamToIterable(stream);\n  const codeBlock = '```';\n  return {\n    readScript: readData(iterableStream, () => true, shellCodeStartRegex),\n    readInfo: readData(\n      iterableStream,\n      (content) => content.endsWith(codeBlock),\n      shellCodeStartRegex\n    ),\n  };\n}\n", "export async function generateCompletion({\n  prompt,\n  number = 1,\n  key,\n  model,\n  apiEndpoint,\n}: {\n  prompt: string | ChatCompletionRequestMessage[];\n  number?: number;\n  model?: string;\n  key: string;\n  apiEndpoint: string;\n}) {\n  const openAi = getOpenAi(key, apiEndpoint);", "  try {\n    const completion = await openAi.createChatCompletion(\n      {\n        model: model || 'gpt-3.5-turbo',\n        messages: Array.isArray(prompt)\n          ? prompt\n          : [{ role: 'user', content: prompt }],\n        n: Math.min(number, 10),\n        stream: true,\n      },\n      { responseType: 'stream' }\n    );\n\n    return completion.data as unknown as IncomingMessage;", "  } catch (err) {\n    const error = err as AxiosError;\n\n    if (error.code === 'ENOTFOUND') {\n      throw new KnownError(\n        `Error connecting to ${error.request.hostname} (${error.request.syscall}). Are you connected to the internet?`\n      );\n    }\n\n    const response = error.response;\n    let message = response?.data as string | object | IncomingMessage;", "    if (response && message instanceof IncomingMessage) {\n      message = await streamToString(\n        response.data as unknown as IncomingMessage\n      );\n      try {\n        // Handle if the message is JSON. It should be but occasionally will\n        // be HTML, so lets handle both\n        message = JSON.parse(message);\n      } catch (e) {\n        // Ignore\n      }\n    }\n\n    const messageString = message && JSON.stringify(message, null, 2);", "      } catch (e) {\n        // Ignore\n      }\n    }\n\n    const messageString = message && JSON.stringify(message, null, 2);\n    if (response?.status === 429) {\n      throw new KnownError(\n        dedent`\n        Request to OpenAI failed with status 429. This is due to incorrect billing setup or excessive quota usage. Please follow this guide to fix it: https://help.openai.com/en/articles/6891831-error-code-429-you-exceeded-your-current-quota-please-check-your-plan-and-billing-details\n\n        You can activate billing here: https://platform.openai.com/account/billing/overview . Make sure to add a payment method if not under an active grant from OpenAI.\n\n        Full message from OpenAI:\n      ` +\n          '\\n\\n' +\n          messageString +\n          '\\n'\n      );", "    } else if (response && message) {\n      throw new KnownError(\n        dedent`\n        Request to OpenAI failed with status ${response?.status}:\n      ` +\n          '\\n\\n' +\n          messageString +\n          '\\n'\n      );\n    }\n\n    throw error;\n  }\n}\n", "export async function getExplanation({\n  script,\n  key,\n  model,\n  apiEndpoint,\n}: {\n  script: string;\n  key: string;\n  model?: string;\n  apiEndpoint: string;\n}) {\n  const prompt = getExplanationPrompt(script);\n  const stream = await generateCompletion({\n    prompt,\n    key,\n    number: 1,\n    model,\n    apiEndpoint,\n  });\n  const iterableStream = streamToIterable(stream);\n  return { readExplanation: readData(iterableStream, () => true) };\n}\n", "export async function getRevision({\n  prompt,\n  code,\n  key,\n  model,\n  apiEndpoint,\n}: {\n  prompt: string;\n  code: string;\n  key: string;\n  model?: string;\n  apiEndpoint: string;\n}) {\n  const fullPrompt = getRevisionPrompt(prompt, code);\n  const stream = await generateCompletion({\n    prompt: fullPrompt,\n    key,\n    number: 1,\n    model,\n    apiEndpoint,\n  });\n  const iterableStream = streamToIterable(stream);\n  return {\n    readScript: readData(iterableStream, () => true),\n  };\n}\n\nexport const readData =\n  (\n    iterableStream: AsyncGenerator<string, void>,\n    startSignal: (content: string) => boolean,\n    excluded?: RegExp\n  ) =>\n  (writer: (data: string) => void): Promise<string> =>\n    new Promise(async (resolve) => {\n      let data = '';\n      let content = '';\n      let dataStart = false;\n      let waitUntilNewline = false;\n\n      for await (const chunk of iterableStream) {\n        const payloads = chunk.toString().split('\\n\\n');\n", "        for (const payload of payloads) {\n          if (payload.includes('[DONE]')) {\n            dataStart = false;\n            resolve(data);\n            return;\n          }\n\n          if (payload.startsWith('data:')) {\n            content = parseContent(payload);\n            if (!dataStart && content.match(excluded ?? '')) {\n              dataStart = startSignal(content);", "            if (!dataStart && content.match(excluded ?? '')) {\n              dataStart = startSignal(content);\n              if (!content.includes('\\n')) {\n                waitUntilNewline = true;\n              }\n              if (excluded) break;\n            }\n\n            if (content && waitUntilNewline) {\n              if (!content.includes('\\n')) {\n                continue;\n              }\n              waitUntilNewline = false;\n            }\n", "            if (content && waitUntilNewline) {\n              if (!content.includes('\\n')) {\n                continue;\n              }\n              waitUntilNewline = false;\n            }\n\n            if (dataStart && content) {\n              const contentWithoutExcluded = excluded\n                ? content.replaceAll(excluded, '')\n                : content;\n              data += contentWithoutExcluded;\n              writer(contentWithoutExcluded);\n            }\n          }\n        }\n      }\n", "      function parseContent(payload: string): string {\n        const data = payload.replaceAll(/(\\n)?^data:\\s*/g, '');\n        try {\n          const delta = JSON.parse(data.trim());\n          return delta.choices?.[0].delta?.content ?? '';\n        } catch (error) {\n          return `Error with JSON.parse and ${payload}.\\n${error}`;\n        }\n      }\n\n      resolve(data);\n    });\n", "function getExplanationPrompt(script: string) {\n  return dedent`\n    ${explainScript} Please reply in ${i18n.getCurrentLanguagenName()}\n\n    The script: ${script}\n  `;\n}\n\nfunction getShellDetails() {\n  const shellDetails = detectShell();\n\n  return dedent`\n      The target shell is ${shellDetails}\n  `;\n}\nconst shellDetails = getShellDetails();\n\nconst explainScript = dedent`\n  Please provide a clear, concise description of the script, using minimal words. Outline the steps in a list format.\n`;\n", "function getShellDetails() {\n  const shellDetails = detectShell();\n\n  return dedent`\n      The target shell is ${shellDetails}\n  `;\n}\nconst shellDetails = getShellDetails();\n\nconst explainScript = dedent`\n  Please provide a clear, concise description of the script, using minimal words. Outline the steps in a list format.\n`;\n", "function getOperationSystemDetails() {\n  const os = require('@nexssp/os/legacy');\n  return os.name();\n}\nconst generationDetails = dedent`\n    Only reply with the single line command surrounded by three backticks. It must be able to be directly run in the target shell. Do not include any other text.\n\n    Make sure the command runs on ${getOperationSystemDetails()} operating system.\n  `;\n\nfunction getFullPrompt(prompt: string) {\n  return dedent`\n    Create a single line command that one can enter in a terminal and run, based on what is specified in the prompt.\n\n    ${shellDetails}\n\n    ${generationDetails}\n\n    ${explainInSecondRequest ? '' : explainScript}\n\n    The prompt is: ${prompt}\n  `;\n}\n", "function getFullPrompt(prompt: string) {\n  return dedent`\n    Create a single line command that one can enter in a terminal and run, based on what is specified in the prompt.\n\n    ${shellDetails}\n\n    ${generationDetails}\n\n    ${explainInSecondRequest ? '' : explainScript}\n\n    The prompt is: ${prompt}\n  `;\n}\n", "function getRevisionPrompt(prompt: string, code: string) {\n  return dedent`\n    Update the following script based on what is asked in the following prompt.\n\n    The script: ${code}\n\n    The prompt: ${prompt}\n\n    ${generationDetails}\n  `;\n}\n"]}
{"filename": "src/helpers/config.ts", "chunked_list": ["import fs from 'fs/promises';\nimport path from 'path';\nimport os from 'os';\nimport ini from 'ini';\nimport type { TiktokenModel } from '@dqbd/tiktoken';\nimport { commandName } from './constants';\nimport { KnownError, handleCliError } from './error';\nimport * as p from '@clack/prompts';\nimport { red } from 'kolorist';\nimport i18n from './i18n';", "import { red } from 'kolorist';\nimport i18n from './i18n';\n\nconst { hasOwnProperty } = Object.prototype;\nexport const hasOwn = (object: unknown, key: PropertyKey) =>\n  hasOwnProperty.call(object, key);\n\nconst languagesOptions = Object.entries(i18n.languages).map(([key, value]) => ({\n  value: key,\n  label: value,", "  value: key,\n  label: value,\n}));\n\nconst parseAssert = (name: string, condition: any, message: string) => {\n  if (!condition) {\n    throw new KnownError(\n      `${i18n.t('Invalid config property')} ${name}: ${message}`\n    );\n  }\n};\n\nconst configParsers = {\n  OPENAI_KEY(key?: string) {", "    if (!key) {\n      throw new KnownError(\n        `Please set your OpenAI API key via \\`${commandName} config set OPENAI_KEY=<your token>\\`` // TODO: i18n\n      );\n    }\n\n    return key;\n  },\n  MODEL(model?: string) {\n    if (!model || model.length === 0) {\n      return 'gpt-3.5-turbo';\n    }\n\n    return model as TiktokenModel;\n  },\n  SILENT_MODE(mode?: string) {\n    return String(mode).toLowerCase() === 'true';\n  },\n  OPENAI_API_ENDPOINT(apiEndpoint?: string) {\n    return apiEndpoint || 'https://api.openai.com/v1';\n  },\n  LANGUAGE(language?: string) {\n    return language || 'en';\n  },\n} as const;\n", "    if (!model || model.length === 0) {\n      return 'gpt-3.5-turbo';\n    }\n\n    return model as TiktokenModel;\n  },\n  SILENT_MODE(mode?: string) {\n    return String(mode).toLowerCase() === 'true';\n  },\n  OPENAI_API_ENDPOINT(apiEndpoint?: string) {\n    return apiEndpoint || 'https://api.openai.com/v1';\n  },\n  LANGUAGE(language?: string) {\n    return language || 'en';\n  },\n} as const;\n", "type ConfigKeys = keyof typeof configParsers;\n\ntype RawConfig = {\n  [key in ConfigKeys]?: string;\n};\n\ntype ValidConfig = {\n  [Key in ConfigKeys]: ReturnType<(typeof configParsers)[Key]>;\n};\n\nconst configPath = path.join(os.homedir(), '.ai-shell');\n\nconst fileExists = (filePath: string) =>\n  fs.lstat(filePath).then(\n    () => true,\n    () => false\n  );\n\nconst readConfigFile = async (): Promise<RawConfig> => {\n  const configExists = await fileExists(configPath);", "  if (!configExists) {\n    return Object.create(null);\n  }\n\n  const configString = await fs.readFile(configPath, 'utf8');\n  return ini.parse(configString);\n};\n\nexport const getConfig = async (\n  cliConfig?: RawConfig\n): Promise<ValidConfig> => {\n  const config = await readConfigFile();\n  const parsedConfig: Record<string, unknown> = {};\n", "  for (const key of Object.keys(configParsers) as ConfigKeys[]) {\n    const parser = configParsers[key];\n    const value = cliConfig?.[key] ?? config[key];\n    parsedConfig[key] = parser(value);\n  }\n\n  return parsedConfig as ValidConfig;\n};\n\nexport const setConfigs = async (keyValues: [key: string, value: string][]) => {\n  const config = await readConfigFile();\n", "  for (const [key, value] of keyValues) {\n    if (!hasOwn(configParsers, key)) {\n      throw new KnownError(`${i18n.t('Invalid config property')}: ${key}`);\n    }\n\n    const parsed = configParsers[key as ConfigKeys](value);\n    config[key as ConfigKeys] = parsed as any;\n  }\n\n  await fs.writeFile(configPath, ini.stringify(config), 'utf8');\n};\n\nexport const showConfigUI = async () => {", "  try {\n    const config = await getConfig();\n    const choice = (await p.select({\n      message: i18n.t('Set config') + ':',\n      options: [\n        {\n          label: i18n.t('OpenAI Key'),\n          value: 'OPENAI_KEY',\n          hint: hasOwn(config, 'OPENAI_KEY')\n            ? // Obfuscate the key\n              'sk-...' + config.OPENAI_KEY.slice(-3)\n            : i18n.t('(not set)'),\n        },\n        {\n          label: i18n.t('OpenAI API Endpoint'),\n          value: 'OPENAI_API_ENDPOINT',\n          hint: hasOwn(config, 'OPENAI_API_ENDPOINT')\n            ? config.OPENAI_API_ENDPOINT\n            : i18n.t('(not set)'),\n        },\n        {\n          label: i18n.t('Silent Mode'),\n          value: 'SILENT_MODE',\n          hint: hasOwn(config, 'SILENT_MODE')\n            ? config.SILENT_MODE.toString()\n            : i18n.t('(not set)'),\n        },\n        {\n          label: i18n.t('Model'),\n          value: 'MODEL',\n          hint: hasOwn(config, 'MODEL') ? config.MODEL : i18n.t('(not set)'),\n        },\n        {\n          label: i18n.t('Language'),\n          value: 'LANGUAGE',\n          hint: hasOwn(config, 'LANGUAGE')\n            ? config.LANGUAGE\n            : i18n.t('(not set)'),\n        },\n        {\n          label: i18n.t('Cancel'),\n          value: 'cancel',\n          hint: i18n.t('Exit the program'),\n        },\n      ],\n    })) as ConfigKeys | 'cancel' | symbol;\n", "    if (p.isCancel(choice)) return;\n\n    if (choice === 'OPENAI_KEY') {\n      const key = await p.text({\n        message: i18n.t('Enter your OpenAI API key'),\n        validate: (value) => {\n          if (!value.length) {\n            return i18n.t('Please enter a key');\n          }\n        },\n      });", "      if (p.isCancel(key)) return;\n      await setConfigs([['OPENAI_KEY', key]]);\n    } else if (choice === 'OPENAI_API_ENDPOINT') {\n      const apiEndpoint = await p.text({\n        message: i18n.t('Enter your OpenAI API Endpoint'),\n      });\n      if (p.isCancel(apiEndpoint)) return;\n      await setConfigs([['OPENAI_API_ENDPOINT', apiEndpoint]]);\n    } else if (choice === 'SILENT_MODE') {\n      const silentMode = await p.confirm({\n        message: i18n.t('Enable silent mode?'),\n      });", "    } else if (choice === 'SILENT_MODE') {\n      const silentMode = await p.confirm({\n        message: i18n.t('Enable silent mode?'),\n      });\n      if (p.isCancel(silentMode)) return;\n      await setConfigs([['SILENT_MODE', silentMode ? 'true' : 'false']]);\n    } else if (choice === 'MODEL') {\n      const model = await p.text({\n        message: i18n.t('Enter the model you want to use'),\n      });\n      if (p.isCancel(model)) return;\n      await setConfigs([['MODEL', model]]);", "      if (p.isCancel(model)) return;\n      await setConfigs([['MODEL', model]]);\n    } else if (choice === 'LANGUAGE') {\n      const language = (await p.select({\n        message: i18n.t('Enter the language you want to use'),\n        options: languagesOptions,\n      })) as string;\n      if (p.isCancel(language)) return;\n      await setConfigs([['LANGUAGE', language]]);\n      i18n.setLanguage(language);\n    }", "    if (choice === 'cancel') return;\n    showConfigUI();\n  } catch (error: any) {\n    console.error(`\\n${red('\u2716')} ${error.message}`);\n    handleCliError(error);\n    process.exit(1);\n  }\n};\n"]}
{"filename": "src/helpers/stream-to-string.ts", "chunked_list": ["import { IncomingMessage } from 'http';\n\nexport async function streamToString(stream: IncomingMessage): Promise<string> {\n  let str = '';\n  for await (const chunk of stream) {\n    str += chunk;\n  }\n  return str;\n}\n"]}
{"filename": "src/helpers/stream-to-iterable.ts", "chunked_list": ["import { IncomingMessage } from 'http';\n\nexport async function* streamToIterable(stream: IncomingMessage) {\n  let previous = '';\n  for await (const chunk of stream) {\n    const bufferChunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);\n    previous += bufferChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1).trimEnd();", "    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1).trimEnd();\n      if (line.startsWith('data: ')) yield line;\n      previous = previous.slice(eolIndex + 1);\n    }\n  }\n}\n"]}
{"filename": "src/helpers/replace-all-polyfill.ts", "chunked_list": ["/**\n * String.prototype.replaceAll() polyfill\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n * @author Chris Ferdinandi\n * @license MIT\n */\n\nif (!String.prototype.replaceAll) {\n  String.prototype.replaceAll = function (str, newStr) {\n    if (\n      Object.prototype.toString.call(str).toLowerCase() === '[object regexp]'\n    ) {\n      return this.replace(str, newStr as string);\n    }\n\n    return this.replace(new RegExp(str, 'g'), newStr as string);\n  };\n}\n", "    if (\n      Object.prototype.toString.call(str).toLowerCase() === '[object regexp]'\n    ) {\n      return this.replace(str, newStr as string);\n    }\n\n    return this.replace(new RegExp(str, 'g'), newStr as string);\n  };\n}\n"]}
{"filename": "src/helpers/i18n.ts", "chunked_list": ["import i18next from 'i18next';\nimport zhHansTranslation from '../locales/zh-Hans.json';\nimport zhHantTranslation from '../locales/zh-Hant.json';\nimport esTranslation from '../locales/es.json';\nimport jpTranslation from '../locales/jp.json';\nimport koTranslation from '../locales/ko.json';\nimport frTranslation from '../locales/fr.json';\nimport deTranslation from '../locales/de.json';\nimport ruTranslation from '../locales/ru.json';\nimport ukTranslation from '../locales/uk.json';", "import ruTranslation from '../locales/ru.json';\nimport ukTranslation from '../locales/uk.json';\nimport viTranslation from '../locales/vi.json';\nimport arTranslation from '../locales/ar.json';\nimport ptTranslation from '../locales/pt.json';\nimport idTranslation from '../locales/id.json';\n\nlet currentlang: string = 'en';\n\nconst languages: Record<string, string> = {", "\nconst languages: Record<string, string> = {\n  en: 'English',\n  'zh-Hans': '\u7b80\u4f53\u4e2d\u6587', // simplified Chinese\n  'zh-Hant': '\u7e41\u9ad4\u4e2d\u6587', // traditional Chinese\n  es: 'Espa\u00f1ol', // Spanish\n  jp: '\u65e5\u672c\u8a9e', // Japanese\n  ko: '\ud55c\uad6d\uc5b4', // Korean\n  fr: 'Fran\u00e7ais', // French\n  de: 'Deutsch', // German", "  fr: 'Fran\u00e7ais', // French\n  de: 'Deutsch', // German\n  ru: '\u0420\u0443\u0441\u0441\u043a\u0438\u0439', // Russian\n  uk: '\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430', // Ukrainian\n  vi: 'Ti\u1ebfng Vi\u1ec7t', // Vietnamese\n  ar: '\u0627\u0644\u0639\u0631\u0628\u064a\u0629', // Arabic\n  pt: 'Portugu\u00eas', // Portuguese\n  id: 'Indonesia', // Indonesia\n};\n", "};\n\ni18next.init({\n  lng: currentlang,\n  fallbackLng: 'en',\n  resources: {\n    'zh-Hans': {\n      translation: zhHansTranslation,\n    },\n    'zh-Hant': {", "    },\n    'zh-Hant': {\n      translation: zhHantTranslation,\n    },\n    es: {\n      translation: esTranslation,\n    },\n    jp: {\n      translation: jpTranslation,\n    },", "      translation: jpTranslation,\n    },\n    ko: {\n      translation: koTranslation,\n    },\n    fr: {\n      translation: frTranslation,\n    },\n    de: {\n      translation: deTranslation,", "    de: {\n      translation: deTranslation,\n    },\n    ru: {\n      translation: ruTranslation,\n    },\n    uk: {\n      translation: ukTranslation,\n    },\n    vi: {", "    },\n    vi: {\n      translation: viTranslation,\n    },\n    ar: {\n      translation: arTranslation,\n    },\n    pt: {\n      translation: ptTranslation,\n    },", "      translation: ptTranslation,\n    },\n    id: {\n      translation: idTranslation,\n    },\n  },\n});\n\n/**\n * Adds a public method called \"t\" that takes a string parameter and returns a string.", "/**\n * Adds a public method called \"t\" that takes a string parameter and returns a string.\n * @param key - The translation key to look up.\n * @returns The translated string.\n */\nconst t = (key: string): string => {\n  if (!currentlang || currentlang === 'en') return key;\n  return i18next.t(key) as string;\n};\n\nconst setLanguage = (lang: string) => {\n  currentlang = lang || 'en';\n  i18next.changeLanguage(currentlang);\n};\n\nconst getCurrentLanguagenName = () => {\n  return languages[currentlang];\n};\n\nexport default { setLanguage, t, getCurrentLanguagenName, languages };\n"]}
{"filename": "src/helpers/constants.ts", "chunked_list": ["import pkg from '../../package.json';\n\nexport const commandName = 'ai';\nexport const projectName = 'AI Shell';\nexport const repoUrl = pkg.repository.url;\n"]}
{"filename": "src/helpers/error.ts", "chunked_list": ["import { dim } from 'kolorist';\nimport { version } from '../../package.json';\nimport i18n from './i18n';\n\nexport class KnownError extends Error {}\n\nconst indent = ' '.repeat(4);\n\nexport const handleCliError = (error: any) => {\n  if (error instanceof Error && !(error instanceof KnownError)) {\n    if (error.stack) {\n      console.error(dim(error.stack.split('\\n').slice(1).join('\\n')));\n    }\n    console.error(`\\n${indent}${dim(`ai-shell v${version}`)}`);\n    console.error(\n      `\\n${indent}${i18n.t(\n        'Please open a Bug report with the information above'\n      )}:`\n    );\n    console.error(`${indent}https://github.com/BuilderIO/ai-shell/issues/new`);\n  }\n};\n", "  if (error instanceof Error && !(error instanceof KnownError)) {\n    if (error.stack) {\n      console.error(dim(error.stack.split('\\n').slice(1).join('\\n')));\n    }\n    console.error(`\\n${indent}${dim(`ai-shell v${version}`)}`);\n    console.error(\n      `\\n${indent}${i18n.t(\n        'Please open a Bug report with the information above'\n      )}:`\n    );\n    console.error(`${indent}https://github.com/BuilderIO/ai-shell/issues/new`);\n  }\n};\n"]}
