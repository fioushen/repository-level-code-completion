{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from \"vitest/config\"\n\nexport default defineConfig({})\n"]}
{"filename": "src/typeMap.ts", "chunked_list": ["import * as graphql from \"graphql\"\n\nimport { AppContext } from \"./context.js\"\n\nexport type TypeMapper = ReturnType<typeof typeMapper>\n\nexport const typeMapper = (context: AppContext, config: { preferPrismaModels?: true }) => {\n\tconst referencedGraphQLTypes = new Set<string>()\n\tconst referencedPrismaModels = new Set<string>()\n\tconst customScalars = new Set<string>()\n\n\tconst clear = () => {\n\t\treferencedGraphQLTypes.clear()\n\t\tcustomScalars.clear()\n\t\treferencedPrismaModels.clear()\n\t}\n\n\tconst getReferencedGraphQLThingsInMapping = () => {\n\t\treturn {\n\t\t\ttypes: [...referencedGraphQLTypes.keys()],\n\t\t\tscalars: [...customScalars.keys()],\n\t\t\tprisma: [...referencedPrismaModels.keys()],\n\t\t}\n\t}\n\n\tconst map = (\n\t\ttype: graphql.GraphQLType,\n\t\tmapConfig: {\n\t\t\tparentWasNotNull?: true\n\t\t\tpreferNullOverUndefined?: true\n\t\t\ttypenamePrefix?: string\n\t\t}\n\t): string | undefined => {\n\t\tconst prefix = mapConfig.typenamePrefix ?? \"\"\n\n\t\t// The AST for GQL uses a parent node to indicate the !, we need the opposite\n\t\t// for TS which uses '| undefined' after.", "\t\tif (graphql.isNonNullType(type)) {\n\t\t\treturn map(type.ofType, { parentWasNotNull: true, ...mapConfig })\n\t\t}\n\n\t\t// So we can add the | undefined\n\t\tconst getInner = () => {\n\t\t\tif (graphql.isListType(type)) {\n\t\t\t\tconst typeStr = map(type.ofType, mapConfig)\n\t\t\t\tif (!typeStr) return \"any\"\n\n\t\t\t\tif (graphql.isNonNullType(type.ofType)) {\n\t\t\t\t\treturn `${typeStr}[]`\n\t\t\t\t} else {\n\t\t\t\t\treturn `Array<${typeStr}>`\n\t\t\t\t}\n\t\t\t}\n", "\t\t\t\tif (!typeStr) return \"any\"\n\n\t\t\t\tif (graphql.isNonNullType(type.ofType)) {\n\t\t\t\t\treturn `${typeStr}[]`\n\t\t\t\t} else {\n\t\t\t\t\treturn `Array<${typeStr}>`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (graphql.isScalarType(type)) {\n\t\t\t\tswitch (type.toString()) {\n\t\t\t\t\tcase \"Int\":\n\t\t\t\t\t\treturn \"number\"\n\t\t\t\t\tcase \"Float\":\n\t\t\t\t\t\treturn \"number\"\n\t\t\t\t\tcase \"String\":\n\t\t\t\t\t\treturn \"string\"\n\t\t\t\t\tcase \"Boolean\":\n\t\t\t\t\t\treturn \"boolean\"\n\t\t\t\t}\n\n\t\t\t\tcustomScalars.add(type.name)\n\t\t\t\treturn type.name\n\t\t\t}\n", "\t\t\tif (graphql.isScalarType(type)) {\n\t\t\t\tswitch (type.toString()) {\n\t\t\t\t\tcase \"Int\":\n\t\t\t\t\t\treturn \"number\"\n\t\t\t\t\tcase \"Float\":\n\t\t\t\t\t\treturn \"number\"\n\t\t\t\t\tcase \"String\":\n\t\t\t\t\t\treturn \"string\"\n\t\t\t\t\tcase \"Boolean\":\n\t\t\t\t\t\treturn \"boolean\"\n\t\t\t\t}\n\n\t\t\t\tcustomScalars.add(type.name)\n\t\t\t\treturn type.name\n\t\t\t}\n", "\t\t\tif (graphql.isObjectType(type)) {\n\t\t\t\tif (config.preferPrismaModels && context.prisma.has(type.name)) {\n\t\t\t\t\treferencedPrismaModels.add(type.name)\n\t\t\t\t\treturn \"P\" + type.name\n\t\t\t\t} else {\n\t\t\t\t\t// GraphQL only type\n\t\t\t\t\treferencedGraphQLTypes.add(type.name)\n\t\t\t\t\treturn prefix + type.name\n\t\t\t\t}\n\t\t\t}\n", "\t\t\tif (graphql.isInterfaceType(type)) {\n\t\t\t\treturn prefix + type.name\n\t\t\t}\n\n\t\t\tif (graphql.isUnionType(type)) {\n\t\t\t\tconst types = type.getTypes()\n\t\t\t\treturn types.map((t) => map(t, mapConfig)).join(\" | \")\n\t\t\t}\n\n\t\t\tif (graphql.isEnumType(type)) {\n\t\t\t\treturn prefix + type.name\n\t\t\t}\n", "\t\t\tif (graphql.isEnumType(type)) {\n\t\t\t\treturn prefix + type.name\n\t\t\t}\n\n\t\t\tif (graphql.isInputObjectType(type)) {\n\t\t\t\treferencedGraphQLTypes.add(type.name)\n\n\t\t\t\treturn prefix + type.name\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\tthrow new Error(`Unknown type ${type} - ${JSON.stringify(type, null, 2)}`)\n\t\t}\n\n\t\tconst suffix = mapConfig.parentWasNotNull ? \"\" : mapConfig.preferNullOverUndefined ? \"| null\" : \" | undefined\"\n\t\treturn getInner() + suffix\n\t}\n\n\treturn { map, clear, getReferencedGraphQLThingsInMapping }\n}\n"]}
{"filename": "src/prismaModeller.ts", "chunked_list": ["import { Property as PrismaProperty, Schema as PrismaSchemaBlocks } from \"@mrleebo/prisma-ast\"\n\ninterface Model {\n\tleadingComments: string\n\tproperties: Map<\n\t\tstring,\n\t\t{\n\t\t\tleadingComments: string\n\t\t\tproperty: PrismaProperty\n\t\t}\n\t>\n}\n", "export type PrismaMap = ReadonlyMap<string, Model>\n\nexport const prismaModeller = (schema: PrismaSchemaBlocks) => {\n\tconst types = new Map<string, Model>()\n\n\tlet leadingComments: string[] = []\n\tschema.list.forEach((b) => {\n\t\tif (b.type === \"comment\") {\n\t\t\tleadingComments.push(b.text.replace(\"/// \", \"\").replace(\"// \", \"\"))\n\t\t}\n", "\t\tif (b.type === \"model\") {\n\t\t\tconst properties = new Map<\n\t\t\t\tstring,\n\t\t\t\t{\n\t\t\t\t\tleadingComments: string\n\t\t\t\t\tproperty: PrismaProperty\n\t\t\t\t}\n\t\t\t>()\n\n\t\t\tlet leadingFieldComments: string[] = []\n\t\t\t// Loop through all the properties and keep track of the\n\t\t\t// comments before them\n\t\t\tb.properties.forEach((p) => {", "\t\t\t\tif (p.type === \"comment\") {\n\t\t\t\t\tleadingFieldComments.push(p.text.replace(\"/// \", \"\").replace(\"// \", \"\"))\n\t\t\t\t} else if (p.type === \"break\") {\n\t\t\t\t\tleadingFieldComments.push(\"\")\n\t\t\t\t} else if (p.type === \"attribute\" || p.type === \"field\") {\n\t\t\t\t\tproperties.set(p.name, {\n\t\t\t\t\t\tleadingComments: leadingFieldComments.join(\"\\n\"),\n\t\t\t\t\t\tproperty: p,\n\t\t\t\t\t})\n\t\t\t\t\tleadingFieldComments = []\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttypes.set(b.name, {\n\t\t\t\tproperties,\n\t\t\t\tleadingComments: leadingComments.join(\"\\n\"),\n\t\t\t})\n\n\t\t\tleadingComments = []\n\t\t}\n\t})\n\n\treturn types\n}\n"]}
{"filename": "src/sharedSchema.ts", "chunked_list": ["/// The main schema for objects and inputs\n\nimport * as graphql from \"graphql\"\nimport * as tsMorph from \"ts-morph\"\n\nimport { AppContext } from \"./context.js\"\nimport { formatDTS, getPrettierConfig } from \"./formatDTS.js\"\nimport { typeMapper } from \"./typeMap.js\"\n\nexport const createSharedSchemaFiles = (context: AppContext) => {", "\nexport const createSharedSchemaFiles = (context: AppContext) => {\n\tcreateSharedExternalSchemaFile(context)\n\tcreateSharedReturnPositionSchemaFile(context)\n\n\treturn [\n\t\tcontext.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedFilename),\n\t\tcontext.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedInternalFilename),\n\t]\n}", "\t]\n}\n\nfunction createSharedExternalSchemaFile(context: AppContext) {\n\tconst gql = context.gql\n\tconst types = gql.getTypeMap()\n\tconst knownPrimitives = [\"String\", \"Boolean\", \"Int\"]\n\n\tconst { prisma, fieldFacts } = context\n\tconst mapper = typeMapper(context, {})\n\n\tconst externalTSFile = context.tsProject.createSourceFile(`/source/${context.pathSettings.sharedFilename}`, \"\")\n\n\tObject.keys(types).forEach((name) => {", "\t\tif (name.startsWith(\"__\")) {\n\t\t\treturn\n\t\t}\n\n\t\tif (knownPrimitives.includes(name)) {\n\t\t\treturn\n\t\t}\n\n\t\tconst type = types[name]\n\t\tconst pType = prisma.get(name)\n", "\t\tif (graphql.isObjectType(type) || graphql.isInterfaceType(type) || graphql.isInputObjectType(type)) {\n\t\t\t// This is slower than it could be, use the add many at once api\n\t\t\tconst docs = []\n\t\t\tif (pType?.leadingComments) {\n\t\t\t\tdocs.push(pType.leadingComments)\n\t\t\t}\n\n\t\t\tif (type.description) {\n\t\t\t\tdocs.push(type.description)\n\t\t\t}\n\n\t\t\texternalTSFile.addInterface({\n\t\t\t\tname: type.name,\n\t\t\t\tisExported: true,\n\t\t\t\tdocs: [],\n\t\t\t\tproperties: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"__typename\",\n\t\t\t\t\t\ttype: `\"${type.name}\"`,\n\t\t\t\t\t\thasQuestionToken: true,\n\t\t\t\t\t},\n\t\t\t\t\t...Object.entries(type.getFields()).map(([fieldName, obj]: [string, graphql.GraphQLField<object, object>]) => {\n\t\t\t\t\t\tconst docs = []\n\t\t\t\t\t\tconst prismaField = pType?.properties.get(fieldName)", "\t\t\t\t\t\tconst type = obj.type as graphql.GraphQLType\n\n\t\t\t\t\t\tif (prismaField?.leadingComments.length) {\n\t\t\t\t\t\t\tdocs.push(prismaField.leadingComments.trim())\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if (obj.description) docs.push(obj.description);\n\t\t\t\t\t\tconst hasResolverImplementation = fieldFacts.get(name)?.[fieldName]?.hasResolverImplementation\n\t\t\t\t\t\tconst isOptionalInSDL = !graphql.isNonNullType(type)\n\t\t\t\t\t\tconst doesNotExistInPrisma = false // !prismaField;\n\n\t\t\t\t\t\tconst field: tsMorph.OptionalKind<tsMorph.PropertySignatureStructure> = {\n\t\t\t\t\t\t\tname: fieldName,\n\t\t\t\t\t\t\ttype: mapper.map(type, { preferNullOverUndefined: true }),\n\t\t\t\t\t\t\tdocs,\n\t\t\t\t\t\t\thasQuestionToken: hasResolverImplementation ?? (isOptionalInSDL || doesNotExistInPrisma),\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn field\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t})\n\t\t}\n", "\t\tif (graphql.isEnumType(type)) {\n\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\tname: type.name,\n\t\t\t\ttype:\n\t\t\t\t\t'\"' +\n\t\t\t\t\ttype\n\t\t\t\t\t\t.getValues()\n\t\t\t\t\t\t.map((m) => (m as { value: string }).value)\n\t\t\t\t\t\t.join('\" | \"') +\n\t\t\t\t\t'\"',\n\t\t\t})\n\t\t}\n\t})\n\n\tconst { scalars } = mapper.getReferencedGraphQLThingsInMapping()", "\tif (scalars.length) {\n\t\texternalTSFile.addTypeAliases(\n\t\t\tscalars.map((s) => ({\n\t\t\t\tname: s,\n\t\t\t\ttype: \"any\",\n\t\t\t}))\n\t\t)\n\t}\n\n\tconst fullPath = context.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedFilename)\n\tconst config = getPrettierConfig(fullPath)\n\tconst formatted = formatDTS(fullPath, externalTSFile.getText(), config)\n\tcontext.sys.writeFile(fullPath, formatted)\n}\n", "function createSharedReturnPositionSchemaFile(context: AppContext) {\n\tconst { gql, prisma, fieldFacts } = context\n\tconst types = gql.getTypeMap()\n\tconst mapper = typeMapper(context, { preferPrismaModels: true })\n\n\tconst typesToImport = [] as string[]\n\tconst knownPrimitives = [\"String\", \"Boolean\", \"Int\"]\n\n\tconst externalTSFile = context.tsProject.createSourceFile(\n\t\t`/source/${context.pathSettings.sharedInternalFilename}`,\n\t\t`\n// You may very reasonably ask yourself, 'what is this file?' and why do I need it.\n\n// Roughly, this file ensures that when a resolver wants to return a type - that", "// type will match a prisma model. This is useful because you can trivially extend\n// the type in the SDL and not have to worry about type mis-matches because the thing\n// you returned does not include those functions.\n\n// This gets particularly valuable when you want to return a union type, an interface, \n// or a model where the prisma model is nested pretty deeply (GraphQL connections, for example.)\n\n`\n\t)\n\n\tObject.keys(types).forEach((name) => {", "\t\tif (name.startsWith(\"__\")) {\n\t\t\treturn\n\t\t}\n\n\t\tif (knownPrimitives.includes(name)) {\n\t\t\treturn\n\t\t}\n\n\t\tconst type = types[name]\n\t\tconst pType = prisma.get(name)\n", "\t\tif (graphql.isObjectType(type) || graphql.isInterfaceType(type) || graphql.isInputObjectType(type)) {\n\t\t\t// Return straight away if we have a matching type in the prisma schema\n\t\t\t// as we dont need it\n\t\t\tif (pType) {\n\t\t\t\ttypesToImport.push(name)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\texternalTSFile.addInterface({\n\t\t\t\tname: type.name,\n\t\t\t\tisExported: true,\n\t\t\t\tdocs: [],\n\t\t\t\tproperties: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"__typename\",\n\t\t\t\t\t\ttype: `\"${type.name}\"`,\n\t\t\t\t\t\thasQuestionToken: true,\n\t\t\t\t\t},\n\t\t\t\t\t...Object.entries(type.getFields()).map(([fieldName, obj]: [string, graphql.GraphQLField<object, object>]) => {\n\t\t\t\t\t\tconst hasResolverImplementation = fieldFacts.get(name)?.[fieldName]?.hasResolverImplementation\n\t\t\t\t\t\tconst isOptionalInSDL = !graphql.isNonNullType(obj.type)\n\t\t\t\t\t\tconst doesNotExistInPrisma = false // !prismaField;\n\n\t\t\t\t\t\tconst field: tsMorph.OptionalKind<tsMorph.PropertySignatureStructure> = {\n\t\t\t\t\t\t\tname: fieldName,\n\t\t\t\t\t\t\ttype: mapper.map(obj.type, { preferNullOverUndefined: true }),\n\t\t\t\t\t\t\thasQuestionToken: hasResolverImplementation || isOptionalInSDL || doesNotExistInPrisma,\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn field\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t})\n\t\t}\n", "\t\tif (graphql.isEnumType(type)) {\n\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\tname: type.name,\n\t\t\t\ttype:\n\t\t\t\t\t'\"' +\n\t\t\t\t\ttype\n\t\t\t\t\t\t.getValues()\n\t\t\t\t\t\t.map((m) => (m as { value: string }).value)\n\t\t\t\t\t\t.join('\" | \"') +\n\t\t\t\t\t'\"',\n\t\t\t})\n\t\t}\n\t})\n\n\tconst { scalars, prisma: prismaModels } = mapper.getReferencedGraphQLThingsInMapping()", "\tif (scalars.length) {\n\t\texternalTSFile.addTypeAliases(\n\t\t\tscalars.map((s) => ({\n\t\t\t\tname: s,\n\t\t\t\ttype: \"any\",\n\t\t\t}))\n\t\t)\n\t}\n\n\tconst allPrismaModels = [...new Set([...prismaModels, ...typesToImport])].sort()\n\tif (allPrismaModels.length) {\n\t\texternalTSFile.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: `@prisma/client`,\n\t\t\tnamedImports: allPrismaModels.map((p) => `${p} as P${p}`),\n\t\t})\n\n\t\tallPrismaModels.forEach((p) => {\n\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\tisExported: true,\n\t\t\t\tname: p,\n\t\t\t\ttype: `P${p}`,\n\t\t\t})\n\t\t})\n\t}\n\n\tconst fullPath = context.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedInternalFilename)\n\tconst config = getPrettierConfig(fullPath)\n\tconst formatted = formatDTS(fullPath, externalTSFile.getText(), config)\n\tcontext.sys.writeFile(fullPath, formatted)\n}\n", "\tif (allPrismaModels.length) {\n\t\texternalTSFile.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: `@prisma/client`,\n\t\t\tnamedImports: allPrismaModels.map((p) => `${p} as P${p}`),\n\t\t})\n\n\t\tallPrismaModels.forEach((p) => {\n\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\tisExported: true,\n\t\t\t\tname: p,\n\t\t\t\ttype: `P${p}`,\n\t\t\t})\n\t\t})\n\t}\n\n\tconst fullPath = context.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedInternalFilename)\n\tconst config = getPrettierConfig(fullPath)\n\tconst formatted = formatDTS(fullPath, externalTSFile.getText(), config)\n\tcontext.sys.writeFile(fullPath, formatted)\n}\n"]}
{"filename": "src/typeFacts.ts", "chunked_list": ["export type FieldFacts = Record<string, FieldFact>\n\nexport interface FieldFact {\n\thasResolverImplementation?: true\n\t// isPrismaBacked?: true;\n}\n\n// The data-model for the service file which contains the SDL matched functions\n\n/** A representation of the code inside the source file's  */\nexport type CodeFacts = Record<string, ModelResolverFacts | undefined>\n", "export type CodeFacts = Record<string, ModelResolverFacts | undefined>\n\nexport interface ModelResolverFacts {\n\t/** Should we type the type as a generic with an override  */\n\thasGenericArg: boolean\n\t/** Individual resolvers found for this model */\n\tresolvers: Map<string, ResolverFuncFact>\n\t/** The name (or lack of) for the GraphQL type which we are mapping  */\n\ttypeName: string | \"maybe_query_mutation\"\n}\n", "export interface ResolverFuncFact {\n\t/** How many args are defined? */\n\tfuncArgCount: number\n\t/** Is it declared as an async fn */\n\tisAsync: boolean\n\t/** is 'function abc() {}' */\n\tisFunc: boolean\n\t/** is 'const ABC = {}' */\n\tisObjLiteral: boolean\n\t/** We don't know what declaration is */\n\tisUnknown: boolean\n\t/** The name of the fn */\n\tname: string\n}\n"]}
{"filename": "src/run.ts", "chunked_list": ["// TODO: Remove?\nimport { basename, join } from \"node:path\"\n\nimport { getSchema as getPrismaSchema } from \"@mrleebo/prisma-ast\"\nimport * as graphql from \"graphql\"\nimport { Project } from \"ts-morph\"\nimport typescript from \"typescript\"\n\nimport { AppContext } from \"./context.js\"\nimport { PrismaMap, prismaModeller } from \"./prismaModeller.js\"", "import { AppContext } from \"./context.js\"\nimport { PrismaMap, prismaModeller } from \"./prismaModeller.js\"\nimport { lookAtServiceFile } from \"./serviceFile.js\"\nimport { createSharedSchemaFiles } from \"./sharedSchema.js\"\nimport { CodeFacts, FieldFacts } from \"./typeFacts.js\"\n\nexport function run(\n\tappRoot: string,\n\ttypesRoot: string,\n\tconfig: { deleteOldGraphQLDTS?: boolean; runESLint?: boolean; sys?: typescript.System } = {}\n) {\n\tconst sys = config.sys ?? typescript.sys\n\tconst project = new Project({ useInMemoryFileSystem: true })\n\n\tlet gqlSchema: graphql.GraphQLSchema | undefined\n\tconst getGraphQLSDLFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\tconst schema = sys.readFile(settings.graphQLSchemaPath)", "\t\tif (!schema) throw new Error(\"No schema found at \" + settings.graphQLSchemaPath)\n\t\tgqlSchema = graphql.buildSchema(schema)\n\t}\n\n\tlet prismaSchema: PrismaMap = new Map()\n\tconst getPrismaSchemaFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\tconst prismaSchemaText = sys.readFile(settings.prismaDSLPath)\n\t\tif (!prismaSchemaText) throw new Error(\"No prisma file found at \" + settings.prismaDSLPath)\n\t\tconst prismaSchemaBlocks = getPrismaSchema(prismaSchemaText)\n\t\tprismaSchema = prismaModeller(prismaSchemaBlocks)\n\t}\n\n\tconst settings: AppContext[\"pathSettings\"] = {\n\t\troot: appRoot,\n\t\tgraphQLSchemaPath: join(appRoot, \".redwood\", \"schema.graphql\"),\n\t\tapiServicesPath: join(appRoot, \"api\", \"src\", \"services\"),\n\t\tprismaDSLPath: join(appRoot, \"api\", \"db\", \"schema.prisma\"),\n\t\tsharedFilename: \"shared-schema-types.d.ts\",\n\t\tsharedInternalFilename: \"shared-return-types.d.ts\",\n\t\ttypesFolderRoot: typesRoot,\n\t}\n\n\tgetGraphQLSDLFromFile(settings)\n\tgetPrismaSchemaFromFile(settings)\n", "\tif (!gqlSchema) throw new Error(\"No GraphQL Schema was created during setup\")\n\n\tconst appContext: AppContext = {\n\t\tgql: gqlSchema,\n\t\tprisma: prismaSchema,\n\t\ttsProject: project,\n\t\tcodeFacts: new Map<string, CodeFacts>(),\n\t\tfieldFacts: new Map<string, FieldFacts>(),\n\t\tpathSettings: settings,\n\t\tsys,\n\t\tjoin,\n\t\tbasename,\n\t}\n\n\tconst serviceFilesToLookAt = [] as string[]", "\tfor (const dirEntry of sys.readDirectory(appContext.pathSettings.apiServicesPath)) {\n\t\t// These are generally the folders\n\t\tif (sys.directoryExists(dirEntry)) {\n\t\t\tconst folderPath = join(appContext.pathSettings.apiServicesPath, dirEntry)\n\t\t\t// And these are the files in them\n\t\t\tfor (const subdirEntry of sys.readDirectory(folderPath)) {\n\t\t\t\tconst folderPath = join(appContext.pathSettings.apiServicesPath, dirEntry)\n\t\t\t\tif (\n\t\t\t\t\tsys.fileExists(folderPath) &&\n\t\t\t\t\tsubdirEntry.endsWith(\".ts\") &&\n\t\t\t\t\t!subdirEntry.includes(\".test.ts\") &&\n\t\t\t\t\t!subdirEntry.includes(\"scenarios.ts\")\n\t\t\t\t) {\n\t\t\t\t\tserviceFilesToLookAt.push(join(folderPath, subdirEntry))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// empty the types folder", "\tfor (const dirEntry of sys.readDirectory(appContext.pathSettings.typesFolderRoot)) {\n\t\tconst fileToDelete = join(appContext.pathSettings.typesFolderRoot, dirEntry)\n\t\tif (sys.deleteFile && sys.fileExists(fileToDelete)) {\n\t\t\tsys.deleteFile(fileToDelete)\n\t\t}\n\t}\n\n\t// This needs to go first, as it sets up fieldFacts\n\tfor (const path of serviceFilesToLookAt) {\n\t\tlookAtServiceFile(path, appContext)\n\t}\n\n\tcreateSharedSchemaFiles(appContext)\n\t// console.log(`Updated`, typesRoot)\n", "\tfor (const path of serviceFilesToLookAt) {\n\t\tlookAtServiceFile(path, appContext)\n\t}\n\n\tcreateSharedSchemaFiles(appContext)\n\t// console.log(`Updated`, typesRoot)\n\n\tif (config.runESLint) {\n\t\t// console.log(\"Running ESLint...\")\n\t\t// const process = Deno.run({\n\t\t// \tcwd: appRoot,\n\t\t// \tcmd: [\"yarn\", \"eslint\", \"--fix\", \"--ext\", \".d.ts\", appContext.settings.typesFolderRoot],\n\t\t// \tstdin: \"inherit\",\n\t\t// \tstdout: \"inherit\",\n\t\t// })\n\t\t// await process.status()\n\t}\n", "\tif (sys.deleteFile && config.deleteOldGraphQLDTS) {\n\t\tconsole.log(\"Deleting old graphql.d.ts\")\n\t\tsys.deleteFile(join(appRoot, \"api\", \"src\", \"graphql.d.ts\"))\n\t}\n}\n"]}
{"filename": "src/main.ts", "chunked_list": ["export const run = () => {\n\tconsole.log(\"Hello, world!\")\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import type { System } from \"typescript\"\n\nexport interface SDLCodeGenOptions {\n\t/** We'll use the one which comes with TypeScript if one isn't given */\n\tsystem?: System\n}\n\n// These are directly ported from Redwood at\n// packages/project-config/src/paths.ts\n\n// Slightly amended to reduce the constraints on the Redwood team to make changes to this obj!\n", "interface NodeTargetPaths {\n\tbase: string\n\tconfig: string\n\t// dataMigrations: string\n\t// db: string\n\tdbSchema: string\n\tdirectives: string\n\t// dist: string\n\t// functions: string\n\t// generators: string\n\tgraphql: string\n\tlib: string\n\tmodels: string\n\tservices: string\n\tsrc: string\n\ttypes: string\n}\n", "export interface RedwoodPaths {\n\tapi: NodeTargetPaths\n\tbase: string\n\tgenerated: {\n\t\t// base: string\n\t\t// prebuild: string\n\t\tschema: string\n\t\t// types: {\n\t\t// \tincludes: string\n\t\t// \tmirror: string\n\t\t// }\n\t}\n\tscripts: string\n\tweb: any\n}\n"]}
{"filename": "src/serviceFile.ts", "chunked_list": ["import * as graphql from \"graphql\"\n\nimport { AppContext } from \"./context.js\"\nimport { formatDTS, getPrettierConfig } from \"./formatDTS.js\"\nimport { getCodeFactsForJSTSFileAtPath } from \"./serviceFile.codefacts.js\"\nimport { CodeFacts, ModelResolverFacts, ResolverFuncFact } from \"./typeFacts.js\"\nimport { TypeMapper, typeMapper } from \"./typeMap.js\"\nimport { capitalizeFirstLetter, createAndReferOrInlineArgsForField, inlineArgsForField } from \"./utils.js\"\n\nexport const lookAtServiceFile = (file: string, context: AppContext) => {", "\nexport const lookAtServiceFile = (file: string, context: AppContext) => {\n\tconst { gql, prisma, pathSettings: settings, codeFacts: serviceFacts, fieldFacts } = context\n\n\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\tif (!gql) throw new Error(`No schema when wanting to look at service file: ${file}`)\n\tif (!prisma) throw new Error(`No prisma schema when wanting to look at service file: ${file}`)\n\n\t// This isn't good enough, needs to be relative to api/src/services\n\tconst fileKey = file.replace(settings.apiServicesPath, \"\")\n\n\tconst thisFact: CodeFacts = {}\n\n\tconst filename = context.basename(file)\n\n\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\tconst queryType = gql.getQueryType()!", "\tif (!queryType) throw new Error(\"No query type\")\n\n\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\tconst mutationType = gql.getMutationType()!\n\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\tif (!mutationType) throw new Error(\"No mutation type\")\n\n\tconst externalMapper = typeMapper(context, { preferPrismaModels: true })\n\tconst returnTypeMapper = typeMapper(context, {})\n\n\t// The description of the source file\n\tconst fileFacts = getCodeFactsForJSTSFileAtPath(file, context)", "\tif (Object.keys(fileFacts).length === 0) return\n\n\t// Tracks prospective prisma models which are used in the file\n\tconst extraPrismaReferences = new Set<string>()\n\n\t// The file we'll be creating in-memory throughout this fn\n\tconst fileDTS = context.tsProject.createSourceFile(`source/${fileKey}.d.ts`, \"\", { overwrite: true })\n\n\t// Basically if a top level resolver reference Query or Mutation\n\tconst knownSpecialCasesForGraphQL = new Set<string>()\n", "\t// Add the root function declarations\n\tconst rootResolvers = fileFacts.maybe_query_mutation?.resolvers\n\tif (rootResolvers)\n\t\trootResolvers.forEach((v) => {\n\t\t\tconst isQuery = v.name in queryType.getFields()\n\t\t\tconst isMutation = v.name in mutationType.getFields()\n\t\t\tconst parentName = isQuery ? queryType.name : isMutation ? mutationType.name : undefined\n\t\t\tif (parentName) {\n\t\t\t\taddDefinitionsForTopLevelResolvers(parentName, v)\n\t\t\t} else {\n\t\t\t\t// Add warning about unused resolver\n\t\t\t\tfileDTS.addStatements(`\\n// ${v.name} does not exist on Query or Mutation`)\n\t\t\t}\n\t\t})\n", "\t// Add the root function declarations\n\tObject.values(fileFacts).forEach((model) => {\n\t\tif (!model) return\n\t\tconst skip = [\"maybe_query_mutation\", queryType.name, mutationType.name]\n\t\tif (skip.includes(model.typeName)) return\n\n\t\taddCustomTypeModel(model)\n\t})\n\n\t// Set up the module imports at the top\n\tconst sharedGraphQLObjectsReferenced = externalMapper.getReferencedGraphQLThingsInMapping()\n\tconst sharedGraphQLObjectsReferencedTypes = [...sharedGraphQLObjectsReferenced.types, ...knownSpecialCasesForGraphQL]\n\tconst sharedInternalGraphQLObjectsReferenced = returnTypeMapper.getReferencedGraphQLThingsInMapping()\n\n\tconst aliases = [...new Set([...sharedGraphQLObjectsReferenced.scalars, ...sharedInternalGraphQLObjectsReferenced.scalars])]", "\t// Set up the module imports at the top\n\tconst sharedGraphQLObjectsReferenced = externalMapper.getReferencedGraphQLThingsInMapping()\n\tconst sharedGraphQLObjectsReferencedTypes = [...sharedGraphQLObjectsReferenced.types, ...knownSpecialCasesForGraphQL]\n\tconst sharedInternalGraphQLObjectsReferenced = returnTypeMapper.getReferencedGraphQLThingsInMapping()\n\n\tconst aliases = [...new Set([...sharedGraphQLObjectsReferenced.scalars, ...sharedInternalGraphQLObjectsReferenced.scalars])]\n\tif (aliases.length) {\n\t\tfileDTS.addTypeAliases(\n\t\t\taliases.map((s) => ({\n\t\t\t\tname: s,\n\t\t\t\ttype: \"any\",\n\t\t\t}))\n\t\t)\n\t}\n\n\tconst prismases = [\n\t\t...new Set([\n\t\t\t...sharedGraphQLObjectsReferenced.prisma,\n\t\t\t...sharedInternalGraphQLObjectsReferenced.prisma,\n\t\t\t...extraPrismaReferences.values(),\n\t\t]),\n\t]\n\n\tconst validPrismaObjs = prismases.filter((p) => prisma.has(p))", "\tif (validPrismaObjs.length) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: \"@prisma/client\",\n\t\t\tnamedImports: validPrismaObjs.map((p) => `${p} as P${p}`),\n\t\t})\n\t}\n\n\tif (fileDTS.getText().includes(\"GraphQLResolveInfo\")) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: \"graphql\",\n\t\t\tnamedImports: [\"GraphQLResolveInfo\"],\n\t\t})\n\t}\n", "\tif (fileDTS.getText().includes(\"GraphQLResolveInfo\")) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: \"graphql\",\n\t\t\tnamedImports: [\"GraphQLResolveInfo\"],\n\t\t})\n\t}\n\n\tif (fileDTS.getText().includes(\"RedwoodGraphQLContext\")) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: \"@redwoodjs/graphql-server/dist/types\",\n\t\t\tnamedImports: [\"RedwoodGraphQLContext\"],\n\t\t})\n\t}\n", "\tif (fileDTS.getText().includes(\"RedwoodGraphQLContext\")) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: \"@redwoodjs/graphql-server/dist/types\",\n\t\t\tnamedImports: [\"RedwoodGraphQLContext\"],\n\t\t})\n\t}\n\n\tif (sharedInternalGraphQLObjectsReferenced.types.length) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: `./${settings.sharedInternalFilename.replace(\".d.ts\", \"\")}`,\n\t\t\tnamedImports: sharedInternalGraphQLObjectsReferenced.types.map((t) => `${t} as RT${t}`),\n\t\t})\n\t}\n", "\tif (sharedInternalGraphQLObjectsReferenced.types.length) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: `./${settings.sharedInternalFilename.replace(\".d.ts\", \"\")}`,\n\t\t\tnamedImports: sharedInternalGraphQLObjectsReferenced.types.map((t) => `${t} as RT${t}`),\n\t\t})\n\t}\n\n\tif (sharedGraphQLObjectsReferencedTypes.length) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: `./${settings.sharedFilename.replace(\".d.ts\", \"\")}`,\n\t\t\tnamedImports: sharedGraphQLObjectsReferencedTypes,\n\t\t})\n\t}\n\n\tserviceFacts.set(fileKey, thisFact)\n\n\tconst dtsFilename = filename.endsWith(\".ts\") ? filename.replace(\".ts\", \".d.ts\") : filename.replace(\".js\", \".d.ts\")\n\tconst dtsFilepath = context.join(context.pathSettings.typesFolderRoot, dtsFilename)\n\n\t// Some manual formatting tweaks so we align with Redwood's setup more\n\tconst dts = fileDTS\n\t\t.getText()\n\t\t.replace(`from \"graphql\";`, `from \"graphql\";\\n`)\n\t\t.replace(`from \"@redwoodjs/graphql-server/dist/types\";`, `from \"@redwoodjs/graphql-server/dist/types\";\\n`)\n\n\tconst shouldWriteDTS = !!dts.trim().length", "\tif (sharedGraphQLObjectsReferencedTypes.length) {\n\t\tfileDTS.addImportDeclaration({\n\t\t\tisTypeOnly: true,\n\t\t\tmoduleSpecifier: `./${settings.sharedFilename.replace(\".d.ts\", \"\")}`,\n\t\t\tnamedImports: sharedGraphQLObjectsReferencedTypes,\n\t\t})\n\t}\n\n\tserviceFacts.set(fileKey, thisFact)\n\n\tconst dtsFilename = filename.endsWith(\".ts\") ? filename.replace(\".ts\", \".d.ts\") : filename.replace(\".js\", \".d.ts\")\n\tconst dtsFilepath = context.join(context.pathSettings.typesFolderRoot, dtsFilename)\n\n\t// Some manual formatting tweaks so we align with Redwood's setup more\n\tconst dts = fileDTS\n\t\t.getText()\n\t\t.replace(`from \"graphql\";`, `from \"graphql\";\\n`)\n\t\t.replace(`from \"@redwoodjs/graphql-server/dist/types\";`, `from \"@redwoodjs/graphql-server/dist/types\";\\n`)\n\n\tconst shouldWriteDTS = !!dts.trim().length", "\tif (!shouldWriteDTS) return\n\n\tconst config = getPrettierConfig(dtsFilepath)\n\tconst formatted = formatDTS(dtsFilepath, dts, config)\n\n\tcontext.sys.writeFile(dtsFilepath, formatted)\n\treturn dtsFilepath\n\n\tfunction addDefinitionsForTopLevelResolvers(parentName: string, config: ResolverFuncFact) {\n\t\tconst { name } = config\n\t\tlet field = queryType.getFields()[name]", "\tfunction addDefinitionsForTopLevelResolvers(parentName: string, config: ResolverFuncFact) {\n\t\tconst { name } = config\n\t\tlet field = queryType.getFields()[name]\n\t\tif (!field) {\n\t\t\tfield = mutationType.getFields()[name]\n\t\t}\n\n\t\tconst interfaceDeclaration = fileDTS.addInterface({\n\t\t\tname: `${capitalizeFirstLetter(config.name)}Resolver`,\n\t\t\tisExported: true,\n\t\t\tdocs: field.astNode\n\t\t\t\t? [\"SDL: \" + graphql.print(field.astNode)]\n\t\t\t\t: [\"@deprecated: Could not find this field in the schema for Mutation or Query\"],\n\t\t})\n\n\t\tconst args = createAndReferOrInlineArgsForField(field, {\n\t\t\tname: interfaceDeclaration.getName(),\n\t\t\tfile: fileDTS,\n\t\t\tmapper: externalMapper.map,\n\t\t})\n", "\t\tif (parentName === queryType.name) knownSpecialCasesForGraphQL.add(queryType.name)\n\t\tif (parentName === mutationType.name) knownSpecialCasesForGraphQL.add(mutationType.name)\n\n\t\tconst argsParam = args ?? \"object\"\n\n\t\tconst returnType = returnTypeForResolver(returnTypeMapper, field, config)\n\n\t\tinterfaceDeclaration.addCallSignature({\n\t\t\tparameters: [\n\t\t\t\t{ name: \"args\", type: argsParam, hasQuestionToken: config.funcArgCount < 1 },\n\t\t\t\t{\n\t\t\t\t\tname: \"obj\",\n\t\t\t\t\ttype: `{ root: ${parentName}, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }`,\n\t\t\t\t\thasQuestionToken: config.funcArgCount < 2,\n\t\t\t\t},\n\t\t\t],\n\t\t\treturnType,\n\t\t})\n\t}\n", "\t/** Ideally, we want to be able to write the type for just the object  */\n\tfunction addCustomTypeModel(modelFacts: ModelResolverFacts) {\n\t\tconst modelName = modelFacts.typeName\n\t\textraPrismaReferences.add(modelName)\n\n\t\t// Make an interface, this is the version we are replacing from graphql-codegen:\n\t\t// Account: MergePrismaWithSdlTypes<PrismaAccount, MakeRelationsOptional<Account, AllMappedModels>, AllMappedModels>;\n\t\tconst gqlType = gql.getType(modelName)\n\t\tif (!gqlType) {\n\t\t\t// throw new Error(`Could not find a GraphQL type named ${d.getName()}`);\n\t\t\tfileDTS.addStatements(`\\n// ${modelName} does not exist in the schema`)\n\t\t\treturn\n\t\t}\n", "\t\tif (!gqlType) {\n\t\t\t// throw new Error(`Could not find a GraphQL type named ${d.getName()}`);\n\t\t\tfileDTS.addStatements(`\\n// ${modelName} does not exist in the schema`)\n\t\t\treturn\n\t\t}\n\n\t\tif (!graphql.isObjectType(gqlType)) {\n\t\t\tthrow new Error(`In your schema ${modelName} is not an object, which we can only make resolver types for`)\n\t\t}\n\n\t\tconst fields = gqlType.getFields()\n\n\t\t// See:   https://github.com/redwoodjs/redwood/pull/6228#issue-1342966511\n\t\t// For more ideas\n\n\t\tconst hasGenerics = modelFacts.hasGenericArg\n\n\t\t// This is what they would have to write\n\t\tconst resolverInterface = fileDTS.addInterface({\n\t\t\tname: `${modelName}TypeResolvers`,\n\t\t\ttypeParameters: hasGenerics ? [\"Extended\"] : [],\n\t\t\tisExported: true,\n\t\t})\n", "\t\t// The parent type for the resolvers\n\t\tfileDTS.addTypeAlias({\n\t\t\tname: `${modelName}AsParent`,\n\t\t\ttypeParameters: hasGenerics ? [\"Extended\"] : [],\n\t\t\ttype: `P${modelName} ${createParentAdditionallyDefinedFunctions()} ${hasGenerics ? \" & Extended\" : \"\"}`,\n\t\t\t// docs: [\"The prisma model, mixed with fns already defined inside the resolvers.\"],\n\t\t})\n\n\t\tconst modelFieldFacts = fieldFacts.get(modelName) ?? {}\n\n\t\t// Loop through the resolvers, adding the fields which have resolvers implemented in the source file\n\t\tmodelFacts.resolvers.forEach((resolver) => {\n\t\t\tconst field = fields[resolver.name]", "\t\t\tif (field) {\n\t\t\t\tconst fieldName = resolver.name\n\t\t\t\tif (modelFieldFacts[fieldName]) modelFieldFacts[fieldName].hasResolverImplementation = true\n\t\t\t\telse modelFieldFacts[fieldName] = { hasResolverImplementation: true }\n\n\t\t\t\tconst argsType = inlineArgsForField(field, { mapper: externalMapper.map }) ?? \"undefined\"\n\t\t\t\tconst param = hasGenerics ? \"<Extended>\" : \"\"\n\n\t\t\t\tconst firstQ = resolver.funcArgCount < 1 ? \"?\" : \"\"\n\t\t\t\tconst secondQ = resolver.funcArgCount < 2 ? \"?\" : \"\"\n\t\t\t\tconst innerArgs = `args${firstQ}: ${argsType}, obj${secondQ}: { root: ${modelName}AsParent${param}, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }`\n\n\t\t\t\tconst returnType = returnTypeForResolver(returnTypeMapper, field, resolver)\n\n\t\t\t\tconst docs = field.astNode ? [`SDL: ${graphql.print(field.astNode)}`] : []\n\t\t\t\t// For speed we should switch this out to addProperties eventually\n\t\t\t\tresolverInterface.addProperty({\n\t\t\t\t\tname: fieldName,\n\t\t\t\t\tleadingTrivia: \"\\n\",\n\t\t\t\t\tdocs,\n\t\t\t\t\ttype: resolver.isFunc || resolver.isUnknown ? `(${innerArgs}) => ${returnType ?? \"any\"}` : returnType,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tresolverInterface.addCallSignature({\n\t\t\t\t\tdocs: [` @deprecated: SDL ${modelName}.${resolver.name} does not exist in your schema`],\n\t\t\t\t})\n\t\t\t}\n\t\t})\n", "\t\tfunction createParentAdditionallyDefinedFunctions() {\n\t\t\tconst fns: string[] = []\n\t\t\tmodelFacts.resolvers.forEach((resolver) => {\n\t\t\t\tconst existsInGraphQLSchema = fields[resolver.name]\n\t\t\t\tif (!existsInGraphQLSchema) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`The service file ${filename} has a field ${resolver.name} on ${modelName} that does not exist in the generated schema.graphql`\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst prefix = !existsInGraphQLSchema ? \"\\n// This field does not exist in the generated schema.graphql\\n\" : \"\"\n\t\t\t\tconst returnType = returnTypeForResolver(externalMapper, existsInGraphQLSchema, resolver)\n\t\t\t\t// fns.push(`${prefix}${resolver.name}: () => Promise<${externalMapper.map(type, {})}>`)\n\t\t\t\tfns.push(`${prefix}${resolver.name}: () => ${returnType}`)\n\t\t\t})\n", "\t\t\tif (fns.length < 1) return \"\"\n\t\t\treturn \"& {\" + fns.join(\", \\n\") + \"}\"\n\t\t}\n\n\t\tfieldFacts.set(modelName, modelFieldFacts)\n\t}\n\n\treturn dtsFilename\n}\n\nfunction returnTypeForResolver(mapper: TypeMapper, field: graphql.GraphQLField<unknown, unknown> | undefined, resolver: ResolverFuncFact) {", "function returnTypeForResolver(mapper: TypeMapper, field: graphql.GraphQLField<unknown, unknown> | undefined, resolver: ResolverFuncFact) {\n\tif (!field) return \"void\"\n\n\tconst tType = mapper.map(field.type, { preferNullOverUndefined: true, typenamePrefix: \"RT\" }) ?? \"void\"\n\n\tlet returnType = tType\n\tconst all = `${tType} | Promise<${tType}> | (() => Promise<${tType}>)`\n\n\tif (resolver.isFunc && resolver.isAsync) returnType = `Promise<${tType}>`\n\telse if (resolver.isFunc) returnType = all\n\telse if (resolver.isObjLiteral) returnType = tType", "\tif (resolver.isFunc && resolver.isAsync) returnType = `Promise<${tType}>`\n\telse if (resolver.isFunc) returnType = all\n\telse if (resolver.isObjLiteral) returnType = tType\n\telse if (resolver.isUnknown) returnType = all\n\n\treturn returnType\n}\n"]}
{"filename": "src/formatDTS.ts", "chunked_list": ["// https://prettier.io/docs/en/api.html\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet prettier: any | null = null\ntry {\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\tprettier = await import(\"prettier\")\n} catch (er) {\n\tconsole.error(er)\n\tprettier = null\n}\n\nexport const getPrettierConfig = (path: string): unknown => {", "\tif (!prettier) return {}\n\n\t// I confirmed that this lookup hits caches in Redwood\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\tconst opts = prettier.default.resolveConfig.sync(path) ?? {}\n\treturn opts\n}\n\nexport const formatDTS = (path: string, content: string, config: unknown): string => {\n\tif (!prettier) return content\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\treturn prettier.default.format(content, { ...(config as object), filepath: path }) as string\n}\n", "\tif (!prettier) return content\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\treturn prettier.default.format(content, { ...(config as object), filepath: path }) as string\n}\n"]}
{"filename": "src/cli.ts", "chunked_list": ["// import { parse, path } from \"./deps.ts\";\n// import { run } from \"./run.ts\";\n\n// const args = parse(Deno.args, {\n//   boolean: [\n//     \"eslint-fix\",\n//     \"rm-default-api-types\",\n//   ],\n// });\n// const params = args._;", "// });\n// const params = args._;\n\n// let appRoot = Deno.cwd();\n// if (params.length > 0) {\n//   appRoot = path.join(Deno.cwd(), params[0] as string);\n// }\n\n// let types = path.join(appRoot, \"api/src/lib/types\");\n// if (params.length > 1) {\n//   types = path.join(Deno.cwd(), params[1] as string);\n// }\n\n// run(appRoot, types, {\n//   runESLint: !!args[\"eslint-fix\"],\n//   deleteOldGraphQLDTS: !!args[\"rm-default-api-types\"],\n// });\n", "// if (params.length > 1) {\n//   types = path.join(Deno.cwd(), params[1] as string);\n// }\n\n// run(appRoot, types, {\n//   runESLint: !!args[\"eslint-fix\"],\n//   deleteOldGraphQLDTS: !!args[\"rm-default-api-types\"],\n// });\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import * as graphql from \"graphql\"\nimport * as tsMorph from \"ts-morph\"\n\nimport { TypeMapper } from \"./typeMap.js\"\n\nexport const varStartsWithUppercase = (v: tsMorph.VariableDeclaration) => v.getName()[0].startsWith(v.getName()[0].toUpperCase())\nexport const nameDoesNotStartsWithUnderscore = (v: tsMorph.VariableDeclaration) => !v.getName()[0].startsWith(\"_\")\n\nexport const capitalizeFirstLetter = (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n", "export const capitalizeFirstLetter = (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n\nexport const variableDeclarationIsAsync = (vd: tsMorph.VariableDeclaration) => {\n\tconst res = !!vd.getFirstChildByKind(tsMorph.SyntaxKind.AsyncKeyword)\n\treturn res\n}\n\nexport const inlineArgsForField = (field: graphql.GraphQLField<unknown, unknown>, config: { mapper: TypeMapper[\"map\"] }) => {\n\treturn field.args.length\n\t\t? // Always use an args obj", "\treturn field.args.length\n\t\t? // Always use an args obj\n\t\t  `{${field.args\n\t\t\t\t.map((f) => {\n\t\t\t\t\tconst type = config.mapper(f.type, {})\n\t\t\t\t\tif (!type) throw new Error(`No type for ${f.name} on ${field.name}!`)\n\n\t\t\t\t\tconst q = type.includes(\"undefined\") ? \"?\" : \"\"\n\t\t\t\t\tconst displayType = type.replace(\"| undefined\", \"\")\n\t\t\t\t\treturn `${f.name}${q}: ${displayType}`\n\t\t\t\t})\n\t\t\t\t.join(\", \")}}`\n\t\t: undefined\n}\n\nexport const createAndReferOrInlineArgsForField = (\n\tfield: graphql.GraphQLField<unknown, unknown>,\n\tconfig: {\n\t\tfile: tsMorph.SourceFile\n\t\tmapper: TypeMapper[\"map\"]\n\t\tname: string\n\t\tnoSeparateType?: true\n\t}\n) => {\n\tconst inlineArgs = inlineArgsForField(field, config)", "\tif (!inlineArgs) return undefined\n\tif (inlineArgs.length < 120) return inlineArgs\n\n\tconst argsInterface = config.file.addInterface({\n\t\tname: `${config.name}Args`,\n\t\tisExported: true,\n\t})\n\n\tfield.args.forEach((a) => {\n\t\targsInterface.addProperty({\n\t\t\tname: a.name,\n\t\t\ttype: config.mapper(a.type, {}),\n\t\t})\n\t})\n\n\treturn `${config.name}Args`\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { getSchema as getPrismaSchema } from \"@mrleebo/prisma-ast\"\nimport * as graphql from \"graphql\"\nimport { Project } from \"ts-morph\"\nimport typescript from \"typescript\"\n\nimport { AppContext } from \"./context.js\"\nimport { PrismaMap, prismaModeller } from \"./prismaModeller.js\"\nimport { lookAtServiceFile } from \"./serviceFile.js\"\nimport { createSharedSchemaFiles } from \"./sharedSchema.js\"\nimport { CodeFacts, FieldFacts } from \"./typeFacts.js\"", "import { createSharedSchemaFiles } from \"./sharedSchema.js\"\nimport { CodeFacts, FieldFacts } from \"./typeFacts.js\"\nimport { RedwoodPaths } from \"./types.js\"\n\nexport * from \"./main.js\"\nexport * from \"./types.js\"\n\nimport { basename, join } from \"node:path\"\n\n/** The API specifically for Redwood */\nexport function runFullCodegen(preset: \"redwood\", config: { paths: RedwoodPaths }): { paths: string[] }\n", "\n/** The API specifically for Redwood */\nexport function runFullCodegen(preset: \"redwood\", config: { paths: RedwoodPaths }): { paths: string[] }\n\nexport function runFullCodegen(preset: string, config: unknown): { paths: string[] }\n\nexport function runFullCodegen(preset: string, config: unknown): { paths: string[] } {\n\tif (preset !== \"redwood\") throw new Error(\"Only Redwood codegen is supported at this time\")\n\tconst paths = (config as { paths: RedwoodPaths }).paths\n\tconst sys = typescript.sys\n\n\tconst pathSettings: AppContext[\"pathSettings\"] = {\n\t\troot: paths.base,\n\t\tapiServicesPath: paths.api.services,\n\t\tprismaDSLPath: paths.api.dbSchema,\n\t\tgraphQLSchemaPath: paths.generated.schema,\n\t\tsharedFilename: \"shared-schema-types.d.ts\",\n\t\tsharedInternalFilename: \"shared-return-types.d.ts\",\n\t\ttypesFolderRoot: paths.api.types,\n\t}\n\n\tconst project = new Project({ useInMemoryFileSystem: true })\n\n\tlet gqlSchema: graphql.GraphQLSchema | undefined\n\tconst getGraphQLSDLFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\tconst schema = sys.readFile(settings.graphQLSchemaPath)", "\t\tif (!schema) throw new Error(\"No schema found at \" + settings.graphQLSchemaPath)\n\t\tgqlSchema = graphql.buildSchema(schema)\n\t}\n\n\tlet prismaSchema: PrismaMap = new Map()\n\tconst getPrismaSchemaFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\tconst prismaSchemaText = sys.readFile(settings.prismaDSLPath)\n\t\tif (!prismaSchemaText) throw new Error(\"No prisma file found at \" + settings.prismaDSLPath)\n\t\tconst prismaSchemaBlocks = getPrismaSchema(prismaSchemaText)\n\t\tprismaSchema = prismaModeller(prismaSchemaBlocks)\n\t}\n\n\tgetGraphQLSDLFromFile(pathSettings)\n\tgetPrismaSchemaFromFile(pathSettings)\n", "\tif (!gqlSchema) throw new Error(\"No GraphQL Schema was created during setup\")\n\n\tconst appContext: AppContext = {\n\t\tgql: gqlSchema,\n\t\tprisma: prismaSchema,\n\t\ttsProject: project,\n\t\tcodeFacts: new Map<string, CodeFacts>(),\n\t\tfieldFacts: new Map<string, FieldFacts>(),\n\t\tpathSettings,\n\t\tsys,\n\t\tjoin,\n\t\tbasename,\n\t}\n\n\t// TODO: Maybe Redwood has an API for this? Its grabbing all the services\n\tconst serviceFiles = appContext.sys.readDirectory(appContext.pathSettings.apiServicesPath)\n\tconst serviceFilesToLookAt = serviceFiles.filter((file) => {", "\t\tif (file.endsWith(\".test.ts\")) return false\n\t\tif (file.endsWith(\"scenarios.ts\")) return false\n\t\treturn file.endsWith(\".ts\") || file.endsWith(\".tsx\") || file.endsWith(\".js\")\n\t})\n\n\tconst filepaths = [] as string[]\n\n\t// Create the two shared schema files\n\tconst sharedDTSes = createSharedSchemaFiles(appContext)\n\tfilepaths.push(...sharedDTSes)\n\n\t// This needs to go first, as it sets up fieldFacts", "\tfor (const path of serviceFilesToLookAt) {\n\t\tconst dts = lookAtServiceFile(path, appContext)\n\t\tif (dts) filepaths.push(dts)\n\t}\n\n\treturn {\n\t\tpaths: filepaths,\n\t}\n}\n"]}
{"filename": "src/ambient.d.ts", "chunked_list": ["declare module \"prettier\"\n"]}
{"filename": "src/serviceFile.codefacts.ts", "chunked_list": ["import * as tsMorph from \"ts-morph\"\n\nimport { AppContext } from \"./context.js\"\nimport { CodeFacts, ModelResolverFacts, ResolverFuncFact } from \"./typeFacts.js\"\nimport { varStartsWithUppercase } from \"./utils.js\"\n\nexport const getCodeFactsForJSTSFileAtPath = (file: string, context: AppContext) => {\n\tconst { pathSettings: settings } = context\n\tconst fileKey = file.replace(settings.apiServicesPath, \"\")\n", "\tconst fileKey = file.replace(settings.apiServicesPath, \"\")\n\n\t// const priorFacts = serviceInfo.get(fileKey)\n\tconst fileFact: CodeFacts = {}\n\n\tconst fileContents = context.sys.readFile(file)\n\tconst referenceFileSourceFile = context.tsProject.createSourceFile(`/source/${fileKey}`, fileContents, { overwrite: true })\n\tconst vars = referenceFileSourceFile.getVariableDeclarations().filter((v) => v.isExported())\n\n\tconst resolverContainers = vars.filter(varStartsWithUppercase)", "\n\tconst resolverContainers = vars.filter(varStartsWithUppercase)\n\n\tconst queryOrMutationResolvers = vars.filter((v) => !varStartsWithUppercase(v))\n\tqueryOrMutationResolvers.forEach((v) => {\n\t\tconst parent = \"maybe_query_mutation\"\n\t\tconst facts = getResolverInformationForDeclaration(v.getInitializer())\n\n\t\t// Start making facts about the services\n\t\tconst fact: ModelResolverFacts = fileFact[parent] ?? {", "\t\t// Start making facts about the services\n\t\tconst fact: ModelResolverFacts = fileFact[parent] ?? {\n\t\t\ttypeName: parent,\n\t\t\tresolvers: new Map(),\n\t\t\thasGenericArg: false,\n\t\t}\n\t\tfact.resolvers.set(v.getName(), { name: v.getName(), ...facts })\n\t\tfileFact[parent] = fact\n\t})\n", "\t})\n\n\t// Next all the capital consts\n\tresolverContainers.forEach((c) => {\n\t\taddCustomTypeResolvers(c)\n\t})\n\n\treturn fileFact\n\n\tfunction addCustomTypeResolvers(variableDeclaration: tsMorph.VariableDeclaration) {\n\t\tconst declarations = variableDeclaration.getVariableStatementOrThrow().getDeclarations()\n\n\t\tdeclarations.forEach((d) => {\n\t\t\tconst name = d.getName()\n\t\t\t// only do it if the first letter is a capital", "\n\tfunction addCustomTypeResolvers(variableDeclaration: tsMorph.VariableDeclaration) {\n\t\tconst declarations = variableDeclaration.getVariableStatementOrThrow().getDeclarations()\n\n\t\tdeclarations.forEach((d) => {\n\t\t\tconst name = d.getName()\n\t\t\t// only do it if the first letter is a capital\n\t\t\tif (!name.match(/^[A-Z]/)) return\n\n\t\t\tconst type = d.getType()\n\t\t\tconst hasGenericArg = type.getText().includes(\"<\")\n\n\t\t\t// Start making facts about the services\n\t\t\tconst fact: ModelResolverFacts = fileFact[name] ?? {\n\t\t\t\ttypeName: name,\n\t\t\t\tresolvers: new Map(),\n\t\t\t\thasGenericArg,\n\t\t\t}\n\n\t\t\t// Grab the const Thing = { ... }\n\t\t\tconst obj = d.getFirstDescendantByKind(tsMorph.SyntaxKind.ObjectLiteralExpression)", "\t\t\tif (!obj) {\n\t\t\t\tthrow new Error(`Could not find an object literal ( e.g. a { } ) in ${d.getName()}`)\n\t\t\t}\n\n\t\t\tobj.getProperties().forEach((p) => {\n\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.SpreadAssignment)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.PropertyAssignment) && p.hasInitializer()) {\n\t\t\t\t\tconst name = p.getName()\n\t\t\t\t\tfact.resolvers.set(name, { name, ...getResolverInformationForDeclaration(p.getInitializerOrThrow()) })\n\t\t\t\t}\n", "\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.PropertyAssignment) && p.hasInitializer()) {\n\t\t\t\t\tconst name = p.getName()\n\t\t\t\t\tfact.resolvers.set(name, { name, ...getResolverInformationForDeclaration(p.getInitializerOrThrow()) })\n\t\t\t\t}\n\n\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.FunctionDeclaration) && p.getName()) {\n\t\t\t\t\tconst name = p.getName()\n\t\t\t\t\t// @ts-expect-error - lets let this go for now\n\t\t\t\t\tfact.resolvers.set(name, { name, ...getResolverInformationForDeclaration(p) })\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tfileFact[d.getName()] = fact\n\t\t})\n\t}\n}\n\nconst getResolverInformationForDeclaration = (initialiser: tsMorph.Expression | undefined): Omit<ResolverFuncFact, \"name\"> => {\n\t// Who knows what folks could do, lets not crash", "\tif (!initialiser) {\n\t\treturn {\n\t\t\tfuncArgCount: 0,\n\t\t\tisFunc: false,\n\t\t\tisAsync: false,\n\t\t\tisUnknown: true,\n\t\t\tisObjLiteral: false,\n\t\t}\n\t}\n\n\t// resolver is a fn", "\tif (initialiser.isKind(tsMorph.SyntaxKind.ArrowFunction) || initialiser.isKind(tsMorph.SyntaxKind.FunctionExpression)) {\n\t\treturn {\n\t\t\tfuncArgCount: initialiser.getParameters().length,\n\t\t\tisFunc: true,\n\t\t\tisAsync: initialiser.isAsync(),\n\t\t\tisUnknown: false,\n\t\t\tisObjLiteral: false,\n\t\t}\n\t}\n\n\t// resolver is a raw obj", "\tif (\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.ObjectLiteralExpression) ||\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.StringLiteral) ||\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.NumericLiteral) ||\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.TrueKeyword) ||\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.FalseKeyword) ||\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.NullKeyword) ||\n\t\tinitialiser.isKind(tsMorph.SyntaxKind.UndefinedKeyword)\n\t) {\n\t\treturn {\n\t\t\tfuncArgCount: 0,\n\t\t\tisFunc: false,\n\t\t\tisAsync: false,\n\t\t\tisUnknown: false,\n\t\t\tisObjLiteral: true,\n\t\t}\n\t}\n\n\t// who knows\n\treturn {\n\t\tfuncArgCount: 0,\n\t\tisFunc: false,\n\t\tisAsync: false,\n\t\tisUnknown: true,\n\t\tisObjLiteral: false,\n\t}\n}\n"]}
{"filename": "src/context.ts", "chunked_list": ["import * as graphql from \"graphql\"\nimport * as tsMorph from \"ts-morph\"\nimport { FormatCodeSettings, System } from \"typescript\"\n\nimport { PrismaMap } from \"./prismaModeller.js\"\nimport { CodeFacts, FieldFacts } from \"./typeFacts.js\"\n\nexport interface AppContext {\n\t/** POSIX-y fn not built into System */\n\tbasename: (path: string) => string\n\t/** \"service\" should be code here */\n\tcodeFacts: Map<string, CodeFacts>\n\t/** A global set of facts about resolvers focused from the GQL side  */\n\tfieldFacts: Map<string, FieldFacts>\n\t/** When we emit .d.ts files, it runs the ts formatter over the file first - you can override the default settings  */\n\tformatCodeSettings?: FormatCodeSettings\n\t/** So you can override the formatter */\n\tgql: graphql.GraphQLSchema\n\t/** POSXIY- fn not built into System */\n\tjoin: (...paths: string[]) => string\n\t/** Where to find particular files */\n\tpathSettings: {\n\t\tapiServicesPath: string\n\t\tgraphQLSchemaPath: string\n\t\tprismaDSLPath: string\n\t\troot: string\n\t\tsharedFilename: string\n\t\tsharedInternalFilename: string\n\t\ttypesFolderRoot: string\n\t}\n\n\t/** A map of prisma models */\n\tprisma: PrismaMap\n\t/** An implementation of the TypeScript system, this can be grabbed pretty\n\t * easily from the typescript import, or you can use your own like tsvfs in browsers.\n\t */\n\tsys: System\n\t/** ts-morph is used to abstract over the typescript compiler API, this project file\n\t * is a slightly augmented version of the typescript Project api.\n\t */\n\ttsProject: tsMorph.Project\n}\n"]}
{"filename": "src/tests/serviceFile.test.ts", "chunked_list": ["import { readFileSync } from \"fs\"\nimport { expect, it } from \"vitest\"\n\nimport { getCodeFactsForJSTSFileAtPath } from \"../serviceFile.codefacts.js\"\nimport { lookAtServiceFile } from \"../serviceFile.js\"\nimport { getDTSFilesForRun } from \"./testRunner.js\"\n\nit(\"reads a service file\", () => {\n\tconst { appContext, vfsMap } = getDTSFilesForRun({})\n", "\tconst { appContext, vfsMap } = getDTSFilesForRun({})\n\n\tvfsMap.set(\n\t\t\"/api/src/services/example.ts\",\n\t\t`\nexport const game = () => {}\nexport function game2() {}\n    `\n\t)\n\n\texpect(vfsMap.has(\"/types/example.d.ts\")).toBeFalsy()\n\tlookAtServiceFile(\"/api/src/services/example.ts\", appContext)\n\n\t// this isn't really very useful as a test, but it proves it doesn't crash?\n})\n\nit(\"generates useful service facts from a (truncated) real file\", () => {\n\tconst { appContext, vfsMap } = getDTSFilesForRun({})\n\n\tvfsMap.set(\"/api/src/services/userProfile.ts\", readFileSync(\"./src/tests/vendor/puzzmo/one-offs/userProfiles.ts\", \"utf8\"))\n\n\tconst facts = getCodeFactsForJSTSFileAtPath(\"/api/src/services/userProfile.ts\", appContext)\n\texpect(facts).toMatchInlineSnapshot(`\n\t\t{\n\t\t  \"UserProfile\": {\n\t\t    \"hasGenericArg\": false,\n\t\t    \"resolvers\": Map {\n\t\t      \"id\" => {\n\t\t        \"funcArgCount\": 2,\n\t\t        \"isAsync\": false,\n\t\t        \"isFunc\": true,\n\t\t        \"isObjLiteral\": false,\n\t\t        \"isUnknown\": false,\n\t\t        \"name\": \"id\",\n\t\t      },\n\t\t      \"user\" => {\n\t\t        \"funcArgCount\": 2,\n\t\t        \"isAsync\": false,\n\t\t        \"isFunc\": true,\n\t\t        \"isObjLiteral\": false,\n\t\t        \"isUnknown\": false,\n\t\t        \"name\": \"user\",\n\t\t      },\n\t\t    },\n\t\t    \"typeName\": \"UserProfile\",\n\t\t  },\n\t\t  \"maybe_query_mutation\": {\n\t\t    \"hasGenericArg\": false,\n\t\t    \"resolvers\": Map {\n\t\t      \"updateUserProfile\" => {\n\t\t        \"funcArgCount\": 1,\n\t\t        \"isAsync\": false,\n\t\t        \"isFunc\": true,\n\t\t        \"isObjLiteral\": false,\n\t\t        \"isUnknown\": false,\n\t\t        \"name\": \"updateUserProfile\",\n\t\t      },\n\t\t      \"addLeaderboardToUserProfile\" => {\n\t\t        \"funcArgCount\": 1,\n\t\t        \"isAsync\": true,\n\t\t        \"isFunc\": true,\n\t\t        \"isObjLiteral\": false,\n\t\t        \"isUnknown\": false,\n\t\t        \"name\": \"addLeaderboardToUserProfile\",\n\t\t      },\n\t\t      \"removeLeaderboardFromUserProfile\" => {\n\t\t        \"funcArgCount\": 1,\n\t\t        \"isAsync\": true,\n\t\t        \"isFunc\": true,\n\t\t        \"isObjLiteral\": false,\n\t\t        \"isUnknown\": false,\n\t\t        \"name\": \"removeLeaderboardFromUserProfile\",\n\t\t      },\n\t\t      \"deleteUserProfile\" => {\n\t\t        \"funcArgCount\": 1,\n\t\t        \"isAsync\": false,\n\t\t        \"isFunc\": true,\n\t\t        \"isObjLiteral\": false,\n\t\t        \"isUnknown\": false,\n\t\t        \"name\": \"deleteUserProfile\",\n\t\t      },\n\t\t    },\n\t\t    \"typeName\": \"maybe_query_mutation\",\n\t\t  },\n\t\t}\n\t`)\n})\n"]}
{"filename": "src/tests/testRunner.ts", "chunked_list": ["import { getSchema as getPrismaSchema } from \"@mrleebo/prisma-ast\"\nimport { createSystem } from \"@typescript/vfs\"\nimport { buildSchema } from \"graphql\"\nimport { basename, join } from \"path\"\nimport { Project } from \"ts-morph\"\n\nimport { AppContext } from \"../context.js\"\nimport { prismaModeller } from \"../prismaModeller.js\"\nimport { lookAtServiceFile } from \"../serviceFile.js\"\nimport type { CodeFacts, FieldFacts } from \"../typeFacts.js\"", "import { lookAtServiceFile } from \"../serviceFile.js\"\nimport type { CodeFacts, FieldFacts } from \"../typeFacts.js\"\n\ninterface Run {\n\tgamesService?: string\n\tprismaSchema?: string\n\tsdl?: string\n}\n\nexport function getDTSFilesForRun(run: Run) {\n\tconst prisma = getPrismaSchema(run.prismaSchema ?? \"\")\n\tlet gqlSDL = run.sdl ?? \"\"", "export function getDTSFilesForRun(run: Run) {\n\tconst prisma = getPrismaSchema(run.prismaSchema ?? \"\")\n\tlet gqlSDL = run.sdl ?? \"\"\n\tif (!gqlSDL.includes(\"type Query\")) gqlSDL += \"type Query { _: String }\\n\"\n\tif (!gqlSDL.includes(\"type Mutation\")) gqlSDL += \"type Mutation { __: String }\"\n\n\tconst schema = buildSchema(gqlSDL)\n\tconst project = new Project({ useInMemoryFileSystem: true })\n\n\tconst vfsMap = new Map<string, string>()\n\n\tconst vfs = createSystem(vfsMap)\n\n\tconst appContext: AppContext = {\n\t\tgql: schema,\n\t\tprisma: prismaModeller(prisma),\n\t\ttsProject: project,\n\t\tfieldFacts: new Map<string, FieldFacts>(),\n\t\tcodeFacts: new Map<string, CodeFacts>(),\n\t\tpathSettings: {\n\t\t\troot: \"/\",\n\t\t\tgraphQLSchemaPath: \"/.redwood/schema.graphql\",\n\t\t\tapiServicesPath: \"/api/src/services\",\n\t\t\tprismaDSLPath: \"/api/db/schema.prisma\",\n\t\t\tsharedFilename: \"shared-schema-types.d.ts\",\n\t\t\tsharedInternalFilename: \"shared-return-types.d.ts\",\n\t\t\ttypesFolderRoot: \"/types\",\n\t\t},\n\t\tsys: vfs,\n\t\tbasename,\n\t\tjoin,\n\t}\n", "\tif (run.gamesService) {\n\t\tvfsMap.set(\"/api/src/services/games.ts\", run.gamesService)\n\t\tlookAtServiceFile(\"/api/src/services/games.ts\", appContext)\n\t}\n\n\treturn {\n\t\tvfsMap,\n\t\tappContext,\n\t}\n}\n\nexport const graphql = (strings: TemplateStringsArray): string => strings[0]\nexport const prisma = (strings: TemplateStringsArray): string => strings[0]\n"]}
{"filename": "src/tests/features/warnOnSuperfluousResolvers.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\nimport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\nit(\"It prints a warning, and doesn't crash when you have resolvers which exist but are not on the parent\", () => {\n\tconst prismaSchema = prisma`\nmodel Game {\n    id            Int          @id @default(autoincrement())\n    homeTeamID    Int\n    awayTeamID    Int", "    homeTeamID    Int\n    awayTeamID    Int\n}\n`\n\n\tconst sdl = graphql`\n\t\ttype Game {\n\t\t\tid: Int!\n\t\t\thomeTeamId: Int!\n\t\t\tawayTeamId: Int!\n\t\t}\n\t`\n\n\tconst services = `\nimport { db } from \"src/lib/db\";\n\nexport const Game: GameResolvers = {\n    someRandomThing: () => \"hello\"\n};\n\n`\n\n\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService: services, prismaSchema })\n\n\texpect(vfsMap.get(\"/types/games.d.ts\")!).toContain(\"// This field does not exist in the generated schema.graphql\\n\")\n})\n"]}
{"filename": "src/tests/features/supportGenericExtension.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\nimport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\nit(\"It allows you to add a generic parameter\", () => {\n\tconst prismaSchema = prisma`\nmodel Game {\n    id            Int          @id @default(autoincrement())\n    homeTeamID    Int\n    awayTeamID    Int", "    homeTeamID    Int\n    awayTeamID    Int\n}\n`\n\n\tconst sdl = graphql`\n\t\ttype Game {\n\t\t\tid: Int!\n\t\t\thomeTeamId: Int!\n\t\t\tawayTeamId: Int!\n\t\t}\n\t`\n\n\tconst services = `\nimport { db } from \"src/lib/db\";\n\nexport const Game: GameResolvers<{ type: string }> = {};\n`\n\n\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService: services, prismaSchema })\n", "\texpect(vfsMap.get(\"/types/games.d.ts\")!).toContain(\"interface GameTypeResolvers<Extended>\")\n\n\texpect(vfsMap.get(\"/types/games.d.ts\")!).toContain(\"GameAsParent<Extended> = PGame & Extended\")\n\n\texpect(vfsMap.get(\"/types/games.d.ts\"))!.toMatchInlineSnapshot(`\n\t\t\"import type { Game as PGame } from \\\\\"@prisma/client\\\\\";\n\n\t\texport interface GameTypeResolvers<Extended> {}\n\n\t\ttype GameAsParent<Extended> = PGame & Extended;\n\t\t\"\n\t`)\n})\n", "\t\ttype GameAsParent<Extended> = PGame & Extended;\n\t\t\"\n\t`)\n})\n"]}
{"filename": "src/tests/features/returnTypePositionsWhichPreferPrisma.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\nimport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\nit(\"supports a return position where a prisma object can be given, if the extra fn are defined as resolvers\", () => {\n\tconst prismaSchema = prisma`\nmodel Game {\n    id            Int          @id @default(autoincrement())\n    homeTeamID    Int\n    awayTeamID    Int", "    homeTeamID    Int\n    awayTeamID    Int\n}\n`\n\n\tconst sdl = graphql`\n\t\ttype Game {\n\t\t\tid: Int!\n\t\t\thomeTeamID: Int!\n\t\t\tawayTeamID: Int!\n\n\t\t\t# This is new, and _not_ on the prisma model\n\t\t\tsummary: String!\n\t\t}\n", "\t\ttype Query {\n\t\t\tgame: Game\n\t\t}\n\t`\n\n\tconst services = `\nimport { db } from \"src/lib/db\";\n\nexport const game = () => {}\n\nexport const Game = {\n  summary: (_obj, { root }) => \"\"\n};\n`\n\n\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService: services, prismaSchema })\n\tconst dts = vfsMap.get(\"/types/games.d.ts\")!\n\n\texpect(dts.trimStart()).toMatchInlineSnapshot(\n\t\t`\n\t\t\"import type { Game as PGame } from \\\\\"@prisma/client\\\\\";\n\t\timport type { GraphQLResolveInfo } from \\\\\"graphql\\\\\";\n\n\t\timport type { RedwoodGraphQLContext } from \\\\\"@redwoodjs/graphql-server/dist/types\\\\\";\n\n\t\timport type { Game as RTGame } from \\\\\"./shared-return-types\\\\\";\n\t\timport type { Query } from \\\\\"./shared-schema-types\\\\\";\n\n\t\t/** SDL: game: Game */", "\t\texport interface GameResolver {\n\t\t  (\n\t\t    args?: object,\n\t\t    obj?: {\n\t\t      root: Query;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t}\n", "\t\texport interface GameTypeResolvers {\n\t\t  /** SDL: summary: String! */\n\t\t  summary: (\n\t\t    args: undefined,\n\t\t    obj: {\n\t\t      root: GameAsParent;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ) => string | Promise<string> | (() => Promise<string>);\n\t\t}\n", "\t\ttype GameAsParent = PGame & {\n\t\t  summary: () => string | Promise<string> | (() => Promise<string>);\n\t\t};\n\t\t\"\n\t`\n\t)\n})\n"]}
{"filename": "src/tests/features/preferPromiseFnWhenKnown.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\nimport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\nit(\"uses a rn to promise when we see an async tag\", () => {\n\tconst prismaSchema = prisma`\nmodel Game {\n    id            Int          @id @default(autoincrement())\n    homeTeamID    Int\n    awayTeamID    Int", "    homeTeamID    Int\n    awayTeamID    Int\n}\n`\n\n\tconst sdl = graphql`\n\t\ttype Game {\n\t\t\tid: Int!\n\t\t\thomeTeamID: Int!\n\t\t\tawayTeamID: Int!\n\n\t\t\tsummarySync: String!\n\t\t\tsummaryAsync: String!\n\t\t\tsummary: String!\n\t\t}\n", "\t\ttype Query {\n\t\t\tgameObj: Game\n\t\t\tgameSync: Game\n\t\t\tgameAsync: Game\n\t\t\tgameAsync1Arg: Game\n\t\t\tgameAsync2Arg: Game\n\t\t}\n\t`\n\n\tconst gamesService = `\nimport { db } from \"src/lib/db\";\n\nexport const gameSync = () => {}\nexport const gameAsync = async () => {}\nexport const gameAsync1Arg = (arg) => {}\nexport const gameAsync2Arg = (arg, obj) => {}\nexport const gameObj = {}\n\nexport const Game = {\n  summary: \"\",\n  summarySync: () => \"\",\n  summaryAsync: async () => \"\"\n};\n`\n\n\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService, prismaSchema })\n\tconst dts = vfsMap.get(\"/types/games.d.ts\")!\n\texpect(dts.trim()).toMatchInlineSnapshot(`\n\t\t\"import type { Game as PGame } from \\\\\"@prisma/client\\\\\";\n\t\timport type { GraphQLResolveInfo } from \\\\\"graphql\\\\\";\n\n\t\timport type { RedwoodGraphQLContext } from \\\\\"@redwoodjs/graphql-server/dist/types\\\\\";\n\n\t\timport type { Game as RTGame } from \\\\\"./shared-return-types\\\\\";\n\t\timport type { Query } from \\\\\"./shared-schema-types\\\\\";\n\n\t\t/** SDL: gameSync: Game */", "\t\texport interface GameSyncResolver {\n\t\t  (\n\t\t    args?: object,\n\t\t    obj?: {\n\t\t      root: Query;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t}\n\n\t\t/** SDL: gameAsync: Game */", "\t\texport interface GameAsyncResolver {\n\t\t  (\n\t\t    args?: object,\n\t\t    obj?: {\n\t\t      root: Query;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ): Promise<RTGame | null>;\n\t\t}\n\n\t\t/** SDL: gameAsync1Arg: Game */", "\t\texport interface GameAsync1ArgResolver {\n\t\t  (\n\t\t    args: object,\n\t\t    obj?: {\n\t\t      root: Query;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t}\n\n\t\t/** SDL: gameAsync2Arg: Game */", "\t\texport interface GameAsync2ArgResolver {\n\t\t  (\n\t\t    args: object,\n\t\t    obj: {\n\t\t      root: Query;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t}\n\n\t\t/** SDL: gameObj: Game */", "\t\texport interface GameObjResolver {\n\t\t  (\n\t\t    args?: object,\n\t\t    obj?: {\n\t\t      root: Query;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ): RTGame | null;\n\t\t}\n", "\t\texport interface GameTypeResolvers<Extended> {\n\t\t  /** SDL: summary: String! */\n\t\t  summary: string;\n\n\t\t  /** SDL: summarySync: String! */\n\t\t  summarySync: (\n\t\t    args?: undefined,\n\t\t    obj?: {\n\t\t      root: GameAsParent<Extended>;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ) => string | Promise<string> | (() => Promise<string>);\n\n\t\t  /** SDL: summaryAsync: String! */\n\t\t  summaryAsync: (\n\t\t    args?: undefined,\n\t\t    obj?: {\n\t\t      root: GameAsParent<Extended>;\n\t\t      context: RedwoodGraphQLContext;\n\t\t      info: GraphQLResolveInfo;\n\t\t    }\n\t\t  ) => Promise<string>;\n\t\t}\n", "\t\ttype GameAsParent<Extended> = PGame & {\n\t\t  summary: () => string;\n\t\t  summarySync: () => string | Promise<string> | (() => Promise<string>);\n\t\t  summaryAsync: () => Promise<string>;\n\t\t} & Extended;\"\n\t`)\n})\n"]}
{"filename": "src/tests/vendor/soccersage-output/predictions.d.ts", "chunked_list": ["import type { CreatePredictionInput, UpdatePredictionInput } from \"./shared-schema-types\";\nimport type { StandingsResult as RTStandingsResult, Prediction as RTPrediction, User as RTUser, Team as RTTeam, Game as RTGame } from \"./shared-return-types\";\nimport type { User as PUser, Team as PTeam, Game as PGame, Prediction as PPrediction } from \"@prisma/client\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\n/** SDL: standings(seasonId: Int!): StandingsResult */\nexport interface StandingsResolver {\n  (args: { seasonId: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTStandingsResult | null>;\n}\n\n/** SDL: predictions: [Prediction!]! */", "export interface PredictionsResolver {\n  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction[] | Promise<RTPrediction[]> | (() => Promise<RTPrediction[]>);\n}\n\n/** SDL: myPredictions: [Prediction!]! */\nexport interface MyPredictionsResolver {\n  (args: object, obj: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction[] | Promise<RTPrediction[]> | (() => Promise<RTPrediction[]>);\n}\n\n/** SDL: prediction(id: Int!): Prediction */\nexport interface PredictionResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | null | Promise<RTPrediction | null> | (() => Promise<RTPrediction | null>);\n}\n\n/** SDL: createPrediction(input: CreatePredictionInput!): Prediction! */", "export interface PredictionResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | null | Promise<RTPrediction | null> | (() => Promise<RTPrediction | null>);\n}\n\n/** SDL: createPrediction(input: CreatePredictionInput!): Prediction! */\nexport interface CreatePredictionResolver {\n  (args: { input: CreatePredictionInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n}\n\n/** SDL: updatePrediction(id: Int!, input: UpdatePredictionInput!): Prediction! */\nexport interface UpdatePredictionResolver {\n  (args: { id: number, input: UpdatePredictionInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n}\n\n/** SDL: deletePrediction(id: Int!): Prediction! */", "export interface UpdatePredictionResolver {\n  (args: { id: number, input: UpdatePredictionInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n}\n\n/** SDL: deletePrediction(id: Int!): Prediction! */\nexport interface DeletePredictionResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n}\n\ntype PredictionAsParent = PPrediction & {\n  id: () => Promise<number>,\n  teamId: () => Promise<number | undefined>,\n  gameId: () => Promise<number>,\n  userId: () => Promise<number>,\n  prediction: () => Promise<string>,\n  user: () => Promise<PUser | undefined>,\n  team: () => Promise<PTeam | undefined>,\n  game: () => Promise<PGame>\n};\n", "type PredictionAsParent = PPrediction & {\n  id: () => Promise<number>,\n  teamId: () => Promise<number | undefined>,\n  gameId: () => Promise<number>,\n  userId: () => Promise<number>,\n  prediction: () => Promise<string>,\n  user: () => Promise<PUser | undefined>,\n  team: () => Promise<PTeam | undefined>,\n  game: () => Promise<PGame>\n};\n", "export interface PredictionTypeResolvers {\n\n  /** SDL: id: Int! */\n  id: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: teamId: Int */\n  teamId: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | null | Promise<number | null> | (() => Promise<number | null>);\n\n  /** SDL: gameId: Int! */\n  gameId: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: userId: Int! */\n  userId: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: prediction: String! */\n  prediction: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: user: User */\n  user: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTUser | null | Promise<RTUser | null> | (() => Promise<RTUser | null>);\n\n  /** SDL: team: Team */\n  team: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTTeam | null | Promise<RTTeam | null> | (() => Promise<RTTeam | null>);\n\n  /** SDL: game: Game! */\n  game: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n}\n"]}
{"filename": "src/tests/vendor/soccersage-output/games.d.ts", "chunked_list": ["import type { CreateGameInput, UpdateGameInput } from \"./shared-schema-types\";\nimport type { Game as RTGame, Prediction as RTPrediction, Team as RTTeam, Season as RTSeason } from \"./shared-return-types\";\nimport type { Prediction as PPrediction, Team as PTeam, Season as PSeason, Game as PGame } from \"@prisma/client\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\n/** SDL: games: [Game!]! */\nexport interface GamesResolver {\n  (args: object, obj: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame[] | Promise<RTGame[]> | (() => Promise<RTGame[]>);\n}\n\n/** SDL: upcomingGames: [Game!]! */", "export interface UpcomingGamesResolver {\n  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame[] | Promise<RTGame[]> | (() => Promise<RTGame[]>);\n}\n\n/** SDL: game(id: Int!): Game */\nexport interface GameResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n}\n\n/** SDL: createGame(input: CreateGameInput!): Game! */\nexport interface CreateGameResolver {\n  (args: { input: CreateGameInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n}\n\n/** SDL: updateGame(id: Int!, input: UpdateGameInput!): Game! */", "export interface CreateGameResolver {\n  (args: { input: CreateGameInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n}\n\n/** SDL: updateGame(id: Int!, input: UpdateGameInput!): Game! */\nexport interface UpdateGameResolver {\n  (args: { id: number, input: UpdateGameInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n}\n\n/** SDL: deleteGame(id: Int!): Game! */\nexport interface DeleteGameResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTGame>;\n}\n", "export interface DeleteGameResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTGame>;\n}\n\ntype GameAsParent<Extended> = PGame & {\n  predictions: () => Promise<Array<PPrediction>>,\n  homeTeam: () => Promise<PTeam>,\n  awayTeam: () => Promise<PTeam>,\n  season: () => Promise<PSeason>\n} & Extended;\n", "export interface GameTypeResolvers<Extended> {\n\n  /** SDL: predictions: [Prediction]! */\n  predictions: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\n  /** SDL: homeTeam: Team! */\n  homeTeam: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n\n  /** SDL: awayTeam: Team! */\n  awayTeam: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n\n  /** SDL: season: Season! */\n  season: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n}\n"]}
{"filename": "src/tests/vendor/soccersage-output/shared-schema-types.d.ts", "chunked_list": ["export interface CreateGameInput {\n  __typename?: \"CreateGameInput\";\n  awayTeamId: number;\n  awayTeamScore?: number | null;\n  homeTeamId: number;\n  homeTeamScore?: number | null;\n  isCompleted?: boolean | null;\n  seasonId: number;\n  startDateTime: DateTime;\n}\n", "export interface CreatePredictionInput {\n  __typename?: \"CreatePredictionInput\";\n  gameId: number;\n  prediction: string;\n  seasonId: number;\n  teamId?: number | null;\n  userId: number;\n}\n\nexport interface CreateSeasonInput {\n  __typename?: \"CreateSeasonInput\";\n  endDate: DateTime;\n  name: string;\n  startDate: DateTime;\n}\n", "export interface CreateSeasonInput {\n  __typename?: \"CreateSeasonInput\";\n  endDate: DateTime;\n  name: string;\n  startDate: DateTime;\n}\n\nexport interface CreateTeamInput {\n  __typename?: \"CreateTeamInput\";\n  logoUrl?: string | null;\n  name: string;\n}\n", "export interface CreateUserInput {\n  __typename?: \"CreateUserInput\";\n  email: string;\n  hashedPassword: string;\n  resetToken?: string | null;\n  resetTokenExpiresAt?: DateTime | null;\n  roles: string;\n  salt: string;\n  username: string;\n}\n", "export interface Game {\n  __typename?: \"Game\";\n  awayTeam?: Team;\n  awayTeamId: number;\n  awayTeamScore?: number | null;\n  homeTeam?: Team;\n  homeTeamId: number;\n  homeTeamScore?: number | null;\n  id: number;\n  isCompleted: boolean;\n  predictions?: Array<Prediction>;\n  season?: Season;\n  seasonId: number;\n  startDateTime: DateTime;\n}\n", "export interface Mutation {\n  __typename?: \"Mutation\";\n  createGame: Game;\n  createPrediction: Prediction;\n  createSeason: Season;\n  createTeam: Team;\n  createUser: User;\n  deleteGame: Game;\n  deletePrediction: Prediction;\n  deleteSeason: Season;\n  deleteTeam: Team;\n  deleteUser: User;\n  resetPassword: User;\n  sendResetPasswordEmail?: SuccessInput | null;\n  updateGame: Game;\n  updatePrediction: Prediction;\n  updateSeason: Season;\n  updateTeam: Team;\n  updateUser: User;\n}\n", "export interface Prediction {\n  __typename?: \"Prediction\";\n  game?: Game;\n  gameId?: number;\n  id?: number;\n  prediction?: string;\n  team?: Team | null;\n  teamId?: number | null;\n  user?: User | null;\n  userId?: number;\n}\n", "export interface Query {\n  __typename?: \"Query\";\n  game?: Game | null;\n  games: Game[];\n  myPredictions: Prediction[];\n  prediction?: Prediction | null;\n  predictions: Prediction[];\n  redwood?: Redwood | null;\n  season?: Season | null;\n  seasons: Season[];\n  standings?: StandingsResult | null;\n  team?: Team | null;\n  teams: Team[];\n  upcomingGames: Game[];\n  user?: User | null;\n  users: User[];\n}\n", "export interface Redwood {\n  __typename?: \"Redwood\";\n  currentUser?: JSON | null;\n  prismaVersion?: string | null;\n  version?: string | null;\n}\n\nexport interface Season {\n  __typename?: \"Season\";\n  Prediction?: Array<Prediction>;\n  endDate?: DateTime;\n  id?: number;\n  name?: string;\n  startDate?: DateTime;\n}\n", "export interface StandingsData {\n  __typename?: \"StandingsData\";\n  email: string;\n  score: number;\n  userId: string;\n  username: string;\n}\n\nexport interface StandingsResult {\n  __typename?: \"StandingsResult\";\n  userIdRankings: StandingsData[];\n}\n", "export interface StandingsResult {\n  __typename?: \"StandingsResult\";\n  userIdRankings: StandingsData[];\n}\n\nexport interface SuccessInput {\n  __typename?: \"SuccessInput\";\n  message?: string | null;\n  success?: boolean | null;\n}\n", "export interface Team {\n  __typename?: \"Team\";\n  Prediction?: Array<Prediction>;\n  awayTeamGames?: Array<Game>;\n  homeTeamGames?: Array<Game>;\n  id?: number;\n  logoUrl?: string | null;\n  name?: string;\n}\n\nexport interface UpdateGameInput {\n  __typename?: \"UpdateGameInput\";\n  awayTeamId?: number | null;\n  awayTeamScore?: number | null;\n  homeTeamId?: number | null;\n  homeTeamScore?: number | null;\n  isCompleted?: boolean | null;\n  seasonId?: number | null;\n  startDateTime?: DateTime | null;\n}\n", "export interface UpdateGameInput {\n  __typename?: \"UpdateGameInput\";\n  awayTeamId?: number | null;\n  awayTeamScore?: number | null;\n  homeTeamId?: number | null;\n  homeTeamScore?: number | null;\n  isCompleted?: boolean | null;\n  seasonId?: number | null;\n  startDateTime?: DateTime | null;\n}\n", "export interface UpdatePredictionInput {\n  __typename?: \"UpdatePredictionInput\";\n  gameId?: number | null;\n  prediction?: string | null;\n  teamId?: number | null;\n  userId?: number | null;\n}\n\nexport interface UpdateSeasonInput {\n  __typename?: \"UpdateSeasonInput\";\n  endDate?: DateTime | null;\n  name?: string | null;\n  startDate?: DateTime | null;\n}\n", "export interface UpdateSeasonInput {\n  __typename?: \"UpdateSeasonInput\";\n  endDate?: DateTime | null;\n  name?: string | null;\n  startDate?: DateTime | null;\n}\n\nexport interface UpdateTeamInput {\n  __typename?: \"UpdateTeamInput\";\n  logoUrl?: string | null;\n  name?: string | null;\n}\n", "export interface UpdateUserInput {\n  __typename?: \"UpdateUserInput\";\n  email?: string | null;\n  hashedPassword?: string | null;\n  resetToken?: string | null;\n  resetTokenExpiresAt?: DateTime | null;\n  roles?: string | null;\n  salt?: string | null;\n  username?: string | null;\n}\n", "export interface User {\n  __typename?: \"User\";\n  email?: string;\n  hashedPassword?: string;\n  id?: number;\n  predictions?: Array<Prediction>;\n  resetToken?: string | null;\n  resetTokenExpiresAt?: DateTime | null;\n  roles?: string;\n  salt?: string;\n  username?: string;\n}\n", "type DateTime = any;\ntype JSON = any;\n"]}
{"filename": "src/tests/vendor/soccersage-output/seasons.d.ts", "chunked_list": ["import type { CreateSeasonInput, UpdateSeasonInput } from \"./shared-schema-types\";\nimport type { Season as RTSeason, Prediction as RTPrediction } from \"./shared-return-types\";\nimport type { Prediction as PPrediction, Season as PSeason } from \"@prisma/client\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\n/** SDL: seasons: [Season!]! */\nexport interface SeasonsResolver {\n  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason[] | Promise<RTSeason[]> | (() => Promise<RTSeason[]>);\n}\n\n/** SDL: season(id: Int!): Season */", "export interface SeasonResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | null | Promise<RTSeason | null> | (() => Promise<RTSeason | null>);\n}\n\n/** SDL: createSeason(input: CreateSeasonInput!): Season! */\nexport interface CreateSeasonResolver {\n  (args: { input: CreateSeasonInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n}\n\n/** SDL: updateSeason(id: Int!, input: UpdateSeasonInput!): Season! */\nexport interface UpdateSeasonResolver {\n  (args: { id: number, input: UpdateSeasonInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n}\n\n/** SDL: deleteSeason(id: Int!): Season! */", "export interface UpdateSeasonResolver {\n  (args: { id: number, input: UpdateSeasonInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n}\n\n/** SDL: deleteSeason(id: Int!): Season! */\nexport interface DeleteSeasonResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n}\n\ntype SeasonAsParent = PSeason & {\n  id: () => Promise<number>,\n  name: () => Promise<string>,\n  startDate: () => Promise<DateTime>,\n  endDate: () => Promise<DateTime>,\n  Prediction: () => Promise<Array<PPrediction>>\n};\n", "type SeasonAsParent = PSeason & {\n  id: () => Promise<number>,\n  name: () => Promise<string>,\n  startDate: () => Promise<DateTime>,\n  endDate: () => Promise<DateTime>,\n  Prediction: () => Promise<Array<PPrediction>>\n};\n\nexport interface SeasonTypeResolvers {\n\n  /** SDL: id: Int! */\n  id: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: name: String! */\n  name: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: startDate: DateTime! */\n  startDate: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | Promise<DateTime> | (() => Promise<DateTime>);\n\n  /** SDL: endDate: DateTime! */\n  endDate: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | Promise<DateTime> | (() => Promise<DateTime>);\n\n  /** SDL: Prediction: [Prediction]! */\n  Prediction: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n}\n", "export interface SeasonTypeResolvers {\n\n  /** SDL: id: Int! */\n  id: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: name: String! */\n  name: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: startDate: DateTime! */\n  startDate: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | Promise<DateTime> | (() => Promise<DateTime>);\n\n  /** SDL: endDate: DateTime! */\n  endDate: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | Promise<DateTime> | (() => Promise<DateTime>);\n\n  /** SDL: Prediction: [Prediction]! */\n  Prediction: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n}\n", "type DateTime = any;\n"]}
{"filename": "src/tests/vendor/soccersage-output/shared-return-types.d.ts", "chunked_list": ["import type { Game as PGame, Prediction as PPrediction, Season as PSeason, Team as PTeam, User as PUser } from \"@prisma/client\";\n\n// You may very reasonably ask yourself, 'what is this file?' and why do I need it.\n\n// Roughly, this file ensures that when a resolver wants to return a type - that\n// type will match a prisma model. This is useful because you can trivially extend\n// the type in the SDL and not have to worry about type mis-matches because the thing\n// you returned does not include those functions.\n\n// This gets particularly useful when you want to return a union type, an interface, \n// or a model where the prisma model is nested pretty deeply (connections, for example.)", "export interface CreateGameInput {\n  __typename?: \"CreateGameInput\";\n  awayTeamId: number;\n  awayTeamScore?: number | null;\n  homeTeamId: number;\n  homeTeamScore?: number | null;\n  isCompleted?: boolean | null;\n  seasonId: number;\n  startDateTime: DateTime;\n}\n", "export interface CreatePredictionInput {\n  __typename?: \"CreatePredictionInput\";\n  gameId: number;\n  prediction: string;\n  seasonId: number;\n  teamId?: number | null;\n  userId: number;\n}\n\nexport interface CreateSeasonInput {\n  __typename?: \"CreateSeasonInput\";\n  endDate: DateTime;\n  name: string;\n  startDate: DateTime;\n}\n", "export interface CreateSeasonInput {\n  __typename?: \"CreateSeasonInput\";\n  endDate: DateTime;\n  name: string;\n  startDate: DateTime;\n}\n\nexport interface CreateTeamInput {\n  __typename?: \"CreateTeamInput\";\n  logoUrl?: string | null;\n  name: string;\n}\n", "export interface CreateUserInput {\n  __typename?: \"CreateUserInput\";\n  email: string;\n  hashedPassword: string;\n  resetToken?: string | null;\n  resetTokenExpiresAt?: DateTime | null;\n  roles: string;\n  salt: string;\n  username: string;\n}\n", "export interface Mutation {\n  __typename?: \"Mutation\";\n  createGame: PGame;\n  createPrediction: PPrediction;\n  createSeason: PSeason;\n  createTeam: PTeam;\n  createUser: PUser;\n  deleteGame: PGame;\n  deletePrediction: PPrediction;\n  deleteSeason: PSeason;\n  deleteTeam: PTeam;\n  deleteUser: PUser;\n  resetPassword: PUser;\n  sendResetPasswordEmail?: SuccessInput | null;\n  updateGame: PGame;\n  updatePrediction: PPrediction;\n  updateSeason: PSeason;\n  updateTeam: PTeam;\n  updateUser: PUser;\n}\n", "export interface Query {\n  __typename?: \"Query\";\n  game?: PGame | null;\n  games: PGame[];\n  myPredictions: PPrediction[];\n  prediction?: PPrediction | null;\n  predictions: PPrediction[];\n  redwood?: Redwood | null;\n  season?: PSeason | null;\n  seasons: PSeason[];\n  standings?: StandingsResult | null;\n  team?: PTeam | null;\n  teams: PTeam[];\n  upcomingGames: PGame[];\n  user?: PUser | null;\n  users: PUser[];\n}\n", "export interface Redwood {\n  __typename?: \"Redwood\";\n  currentUser?: JSON | null;\n  prismaVersion?: string | null;\n  version?: string | null;\n}\n\nexport interface StandingsData {\n  __typename?: \"StandingsData\";\n  email: string;\n  score: number;\n  userId: string;\n  username: string;\n}\n", "export interface StandingsResult {\n  __typename?: \"StandingsResult\";\n  userIdRankings: StandingsData[];\n}\n\nexport interface SuccessInput {\n  __typename?: \"SuccessInput\";\n  message?: string | null;\n  success?: boolean | null;\n}\n", "export interface UpdateGameInput {\n  __typename?: \"UpdateGameInput\";\n  awayTeamId?: number | null;\n  awayTeamScore?: number | null;\n  homeTeamId?: number | null;\n  homeTeamScore?: number | null;\n  isCompleted?: boolean | null;\n  seasonId?: number | null;\n  startDateTime?: DateTime | null;\n}\n", "export interface UpdatePredictionInput {\n  __typename?: \"UpdatePredictionInput\";\n  gameId?: number | null;\n  prediction?: string | null;\n  teamId?: number | null;\n  userId?: number | null;\n}\n\nexport interface UpdateSeasonInput {\n  __typename?: \"UpdateSeasonInput\";\n  endDate?: DateTime | null;\n  name?: string | null;\n  startDate?: DateTime | null;\n}\n", "export interface UpdateSeasonInput {\n  __typename?: \"UpdateSeasonInput\";\n  endDate?: DateTime | null;\n  name?: string | null;\n  startDate?: DateTime | null;\n}\n\nexport interface UpdateTeamInput {\n  __typename?: \"UpdateTeamInput\";\n  logoUrl?: string | null;\n  name?: string | null;\n}\n", "export interface UpdateUserInput {\n  __typename?: \"UpdateUserInput\";\n  email?: string | null;\n  hashedPassword?: string | null;\n  resetToken?: string | null;\n  resetTokenExpiresAt?: DateTime | null;\n  roles?: string | null;\n  salt?: string | null;\n  username?: string | null;\n}\n", "type DateTime = any;\ntype JSON = any;\nexport type Game = PGame;\nexport type Prediction = PPrediction;\nexport type Season = PSeason;\nexport type Team = PTeam;\nexport type User = PUser;\n"]}
{"filename": "src/tests/vendor/soccersage-output/users.d.ts", "chunked_list": ["import type { CreateUserInput, UpdateUserInput } from \"./shared-schema-types\";\nimport type { User as RTUser, SuccessInput as RTSuccessInput, Prediction as RTPrediction } from \"./shared-return-types\";\nimport type { Prediction as PPrediction, User as PUser } from \"@prisma/client\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\n/** SDL: users: [User!]! */\nexport interface UsersResolver {\n  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser[] | Promise<RTUser[]> | (() => Promise<RTUser[]>);\n}\n\n/** SDL: user(id: Int!): User */", "export interface UserResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | null | Promise<RTUser | null> | (() => Promise<RTUser | null>);\n}\n\n/** SDL: createUser(input: CreateUserInput!): User! */\nexport interface CreateUserResolver {\n  (args: { input: CreateUserInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n}\n\n/** SDL: updateUser(id: Int!, input: UpdateUserInput!): User! */\nexport interface UpdateUserResolver {\n  (args: { id: number, input: UpdateUserInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n}\n\n/** SDL: deleteUser(id: Int!): User! */", "export interface UpdateUserResolver {\n  (args: { id: number, input: UpdateUserInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n}\n\n/** SDL: deleteUser(id: Int!): User! */\nexport interface DeleteUserResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n}\n\n/** SDL: sendResetPasswordEmail(email: String!): SuccessInput */\nexport interface SendResetPasswordEmailResolver {\n  (args: { email: string }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTSuccessInput | null>;\n}\n\n/** SDL: resetPassword(password: String!, resetToken: String!): User! */", "export interface SendResetPasswordEmailResolver {\n  (args: { email: string }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTSuccessInput | null>;\n}\n\n/** SDL: resetPassword(password: String!, resetToken: String!): User! */\nexport interface ResetPasswordResolver {\n  (args: { password: string, resetToken: string }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTUser>;\n}\n\ntype UserAsParent = PUser & {\n  id: () => Promise<number>,\n  email: () => Promise<string>,\n  username: () => Promise<string>,\n  hashedPassword: () => Promise<string>,\n  resetToken: () => Promise<string | undefined>,\n  resetTokenExpiresAt: () => Promise<DateTime | undefined>,\n  salt: () => Promise<string>,\n  roles: () => Promise<string>,\n  predictions: () => Promise<Array<PPrediction>>\n};\n", "type UserAsParent = PUser & {\n  id: () => Promise<number>,\n  email: () => Promise<string>,\n  username: () => Promise<string>,\n  hashedPassword: () => Promise<string>,\n  resetToken: () => Promise<string | undefined>,\n  resetTokenExpiresAt: () => Promise<DateTime | undefined>,\n  salt: () => Promise<string>,\n  roles: () => Promise<string>,\n  predictions: () => Promise<Array<PPrediction>>\n};\n", "export interface UserTypeResolvers {\n\n  /** SDL: id: Int! */\n  id: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: email: String! */\n  email: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: username: String! */\n  username: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: hashedPassword: String! */\n  hashedPassword: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: resetToken: String */\n  resetToken: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | null | Promise<string | null> | (() => Promise<string | null>);\n\n  /** SDL: resetTokenExpiresAt: DateTime */\n  resetTokenExpiresAt: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | null | Promise<DateTime | null> | (() => Promise<DateTime | null>);\n\n  /** SDL: salt: String! */\n  salt: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: roles: String! */\n  roles: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: predictions: [Prediction]! */\n  predictions: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n}\n", "type DateTime = any;\n"]}
{"filename": "src/tests/vendor/soccersage-output/teams.d.ts", "chunked_list": ["import type { CreateTeamInput, UpdateTeamInput } from \"./shared-schema-types\";\nimport type { Team as RTTeam, Prediction as RTPrediction, Game as RTGame } from \"./shared-return-types\";\nimport type { Prediction as PPrediction, Game as PGame, Team as PTeam } from \"@prisma/client\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\n/** SDL: teams: [Team!]! */\nexport interface TeamsResolver {\n  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam[] | Promise<RTTeam[]> | (() => Promise<RTTeam[]>);\n}\n\n/** SDL: team(id: Int!): Team */", "export interface TeamResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | null | Promise<RTTeam | null> | (() => Promise<RTTeam | null>);\n}\n\n/** SDL: createTeam(input: CreateTeamInput!): Team! */\nexport interface CreateTeamResolver {\n  (args: { input: CreateTeamInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n}\n\n/** SDL: updateTeam(id: Int!, input: UpdateTeamInput!): Team! */\nexport interface UpdateTeamResolver {\n  (args: { id: number, input: UpdateTeamInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n}\n\n/** SDL: deleteTeam(id: Int!): Team! */", "export interface UpdateTeamResolver {\n  (args: { id: number, input: UpdateTeamInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n}\n\n/** SDL: deleteTeam(id: Int!): Team! */\nexport interface DeleteTeamResolver {\n  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n}\n\ntype TeamAsParent = PTeam & {\n  id: () => Promise<number>,\n  name: () => Promise<string>,\n  logoUrl: () => Promise<string | undefined>,\n  Prediction: () => Promise<Array<PPrediction>>,\n  homeTeamGames: () => Promise<Array<PGame>>,\n  awayTeamGames: () => Promise<Array<PGame>>\n};\n", "type TeamAsParent = PTeam & {\n  id: () => Promise<number>,\n  name: () => Promise<string>,\n  logoUrl: () => Promise<string | undefined>,\n  Prediction: () => Promise<Array<PPrediction>>,\n  homeTeamGames: () => Promise<Array<PGame>>,\n  awayTeamGames: () => Promise<Array<PGame>>\n};\n\nexport interface TeamTypeResolvers {\n\n  /** SDL: id: Int! */\n  id: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: name: String! */\n  name: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: logoUrl: String */\n  logoUrl: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | null | Promise<string | null> | (() => Promise<string | null>);\n\n  /** SDL: Prediction: [Prediction]! */\n  Prediction: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\n  /** SDL: homeTeamGames: [Game]! */\n  homeTeamGames: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTGame> | Promise<Array<RTGame>> | (() => Promise<Array<RTGame>>);\n\n  /** SDL: awayTeamGames: [Game]! */\n  awayTeamGames: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTGame> | Promise<Array<RTGame>> | (() => Promise<Array<RTGame>>);\n}\n", "export interface TeamTypeResolvers {\n\n  /** SDL: id: Int! */\n  id: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\n  /** SDL: name: String! */\n  name: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\n  /** SDL: logoUrl: String */\n  logoUrl: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | null | Promise<string | null> | (() => Promise<string | null>);\n\n  /** SDL: Prediction: [Prediction]! */\n  Prediction: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\n  /** SDL: homeTeamGames: [Game]! */\n  homeTeamGames: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTGame> | Promise<Array<RTGame>> | (() => Promise<Array<RTGame>>);\n\n  /** SDL: awayTeamGames: [Game]! */\n  awayTeamGames: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTGame> | Promise<Array<RTGame>> | (() => Promise<Array<RTGame>>);\n}\n"]}
{"filename": "src/tests/vendor/puzzmo/one-offs/userProfiles.ts", "chunked_list": ["// @ts-ignore\n\nimport { dnull } from \"dnull\"\n\nimport { db } from \"src/lib/db\"\n\nimport {\n\tUpdateUserProfileResolver,\n\tDeleteUserProfileResolver,\n\tUserProfileTypeResolvers,", "\tDeleteUserProfileResolver,\n\tUserProfileTypeResolvers,\n\tAddLeaderboardToUserProfileResolver,\n\tRemoveLeaderboardFromUserProfileResolver,\n} from \"src/lib/types/userProfiles\"\n\nexport const updateUserProfile: UpdateUserProfileResolver = ({ input, id }) => {}\n\nexport const addLeaderboardToUserProfile: AddLeaderboardToUserProfileResolver = async ({ leaderboardStableID }) => {}\n", "export const addLeaderboardToUserProfile: AddLeaderboardToUserProfileResolver = async ({ leaderboardStableID }) => {}\n\nexport const removeLeaderboardFromUserProfile: RemoveLeaderboardFromUserProfileResolver = async ({ leaderboardStableID }) => {}\n\nexport const deleteUserProfile: DeleteUserProfileResolver = (args) => {\n\tconst { id } = args\n\treturn db.userProfile.delete({ where: { userID: id.replace(\":userprofile\", \"\") } })\n}\n\nexport const UserProfile: UserProfileTypeResolvers = {", "\nexport const UserProfile: UserProfileTypeResolvers = {\n\tid: (_, { root }) => root.userID + \":userprofile\",\n\tuser: (_obj, { root }) => db.user.findFirst({ where: { id: root.userID } }),\n}\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/teams.sdl.ts", "chunked_list": ["export const schema = gql`\n    type Team {\n        id: Int!\n        name: String!\n        logoUrl: String\n        Prediction: [Prediction]!\n        homeTeamGames: [Game]!\n        awayTeamGames: [Game]!\n    }\n\n    type Query {\n        teams: [Team!]! @requireAuth\n        team(id: Int!): Team @requireAuth\n    }\n\n    input CreateTeamInput {\n        name: String!\n        logoUrl: String\n    }\n\n    input UpdateTeamInput {\n        name: String\n        logoUrl: String\n    }\n", "    type Query {\n        teams: [Team!]! @requireAuth\n        team(id: Int!): Team @requireAuth\n    }\n\n    input CreateTeamInput {\n        name: String!\n        logoUrl: String\n    }\n\n    input UpdateTeamInput {\n        name: String\n        logoUrl: String\n    }\n", "    type Mutation {\n        createTeam(input: CreateTeamInput!): Team! @requireAuth\n        updateTeam(id: Int!, input: UpdateTeamInput!): Team! @requireAuth\n        deleteTeam(id: Int!): Team! @requireAuth\n    }\n`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/games.sdl.ts", "chunked_list": ["export const schema = gql`\n    type Game {\n        id: Int!\n        homeTeamId: Int!\n        awayTeamId: Int!\n        seasonId: Int!\n        homeTeamScore: Int\n        awayTeamScore: Int\n        isCompleted: Boolean!\n        predictions: [Prediction]!\n        homeTeam: Team!\n        awayTeam: Team!\n        season: Season!\n        startDateTime: DateTime!\n\n        # This does not exist in prisma, and would", "        # screw up a return type of db.game in many places\n        teamsWhoPredictedHomeWin: [Team!]!\n    }\n\n    type Query {\n        games: [Game!]! @skipAuth\n        upcomingGames: [Game!]! @skipAuth\n        game(id: Int!): Game @requireAuth\n    }\n\n    input CreateGameInput {\n        homeTeamId: Int!\n        awayTeamId: Int!\n        seasonId: Int!\n        startDateTime: DateTime!\n        homeTeamScore: Int\n        awayTeamScore: Int\n        isCompleted: Boolean\n    }\n\n    input UpdateGameInput {\n        homeTeamId: Int\n        awayTeamId: Int\n        homeTeamScore: Int\n        awayTeamScore: Int\n        seasonId: Int\n        isCompleted: Boolean\n        startDateTime: DateTime\n    }\n", "    type Mutation {\n        createGame(input: CreateGameInput!): Game! @requireAuth\n        updateGame(id: Int!, input: UpdateGameInput!): Game! @requireAuth\n        deleteGame(id: Int!): Game! @requireAuth\n    }\n`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/users.sdl.ts", "chunked_list": ["export const schema = gql`\n    type User {\n        id: Int!\n        username: String!\n        email: String!\n        hashedPassword: String!\n        salt: String!\n        resetToken: String\n        resetTokenExpiresAt: DateTime\n        roles: String!\n        predictions: [Prediction]!\n    }\n", "    type Query {\n        users: [User!]! @requireAuth\n        user(id: Int!): User @requireAuth\n    }\n\n    input CreateUserInput {\n        email: String!\n        username: String!\n        hashedPassword: String!\n        salt: String!\n        resetToken: String\n        resetTokenExpiresAt: DateTime\n        roles: String!\n    }\n\n    input UpdateUserInput {\n        username: String\n        email: String\n        hashedPassword: String\n        salt: String\n        resetToken: String\n        resetTokenExpiresAt: DateTime\n        roles: String\n    }\n", "    type SuccessInput {\n        success: Boolean\n        message: String\n    }\n\n    type Mutation {\n        createUser(input: CreateUserInput!): User! @requireAuth\n        updateUser(id: Int!, input: UpdateUserInput!): User! @requireAuth\n        deleteUser(id: Int!): User! @requireAuth\n        sendResetPasswordEmail(email: String!): SuccessInput @skipAuth\n        resetPassword(resetToken: String!, password: String!): User! @skipAuth\n    }\n`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/seasons.sdl.ts", "chunked_list": ["export const schema = gql`\n    type Season {\n        id: Int!\n        name: String!\n        startDate: DateTime!\n        endDate: DateTime!\n        Prediction: [Prediction]!\n    }\n\n    type Query {\n        seasons: [Season!]! @requireAuth\n        season(id: Int!): Season @requireAuth\n    }\n\n    input CreateSeasonInput {\n        name: String!\n        startDate: DateTime!\n        endDate: DateTime!\n    }\n\n    input UpdateSeasonInput {\n        name: String\n        startDate: DateTime\n        endDate: DateTime\n    }\n", "    type Query {\n        seasons: [Season!]! @requireAuth\n        season(id: Int!): Season @requireAuth\n    }\n\n    input CreateSeasonInput {\n        name: String!\n        startDate: DateTime!\n        endDate: DateTime!\n    }\n\n    input UpdateSeasonInput {\n        name: String\n        startDate: DateTime\n        endDate: DateTime\n    }\n", "    type Mutation {\n        createSeason(input: CreateSeasonInput!): Season! @requireAuth\n        updateSeason(id: Int!, input: UpdateSeasonInput!): Season! @requireAuth\n        deleteSeason(id: Int!): Season! @requireAuth\n    }\n`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/predictions.sdl.ts", "chunked_list": ["export const schema = gql`\n    type Prediction {\n        id: Int!\n        userId: Int!\n        gameId: Int!\n        teamId: Int\n        prediction: String!\n        team: Team\n        game: Game!\n        user: User\n    }\n", "    type StandingsData {\n        userId: String!\n        username: String!\n        email: String!\n        score: Int!\n    }\n\n    type StandingsResult {\n        userIdRankings: [StandingsData!]!\n    }\n", "    type Query {\n        predictions: [Prediction!]! @requireAuth\n        myPredictions: [Prediction!]! @requireAuth\n        prediction(id: Int!): Prediction @requireAuth\n        standings(seasonId: Int!): StandingsResult @skipAuth\n    }\n\n    input CreatePredictionInput {\n        userId: Int!\n        gameId: Int!\n        seasonId: Int!\n        teamId: Int\n        prediction: String!\n    }\n\n    input UpdatePredictionInput {\n        userId: Int\n        gameId: Int\n        teamId: Int\n        prediction: String\n    }\n", "    type Mutation {\n        createPrediction(input: CreatePredictionInput!): Prediction!\n            @requireAuth\n        updatePrediction(id: Int!, input: UpdatePredictionInput!): Prediction!\n            @requireAuth\n        deletePrediction(id: Int!): Prediction! @requireAuth\n    }\n`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/seasons/seasons.ts", "chunked_list": ["import type {\n    QueryResolvers,\n    MutationResolvers,\n    SeasonResolvers,\n} from 'types/graphql';\n\nimport { db } from 'src/lib/db';\n\nexport const seasons: QueryResolvers['seasons'] = () => {\n    return db.season.findMany();", "export const seasons: QueryResolvers['seasons'] = () => {\n    return db.season.findMany();\n};\n\nexport const season: QueryResolvers['season'] = ({ id }) => {\n    return db.season.findUnique({\n        where: { id },\n    });\n};\n", "};\n\nexport const createSeason: MutationResolvers['createSeason'] = ({ input }) => {\n    return db.season.create({\n        data: input,\n    });\n};\n\nexport const updateSeason: MutationResolvers['updateSeason'] = ({\n    id,", "export const updateSeason: MutationResolvers['updateSeason'] = ({\n    id,\n    input,\n}) => {\n    return db.season.update({\n        data: input,\n        where: { id },\n    });\n};\n", "};\n\nexport const deleteSeason: MutationResolvers['deleteSeason'] = ({ id }) => {\n    return db.season.delete({\n        where: { id },\n    });\n};\n\nexport const Season: SeasonResolvers = {\n    id: (_obj, { root }) => root.id,", "export const Season: SeasonResolvers = {\n    id: (_obj, { root }) => root.id,\n    name: (_obj, { root }) => root.name,\n    startDate: (_obj, { root }) => root.startDate,\n    endDate: (_obj, { root }) => root.endDate,\n    Prediction: (_obj, { root }) =>\n        db.season.findUnique({ where: { id: root.id } }).Prediction(),\n};\n", ""]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/seasons/seasons.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\nexport const standard = defineScenario<Prisma.SeasonCreateArgs>({\n    season: {\n        one: {\n            data: {\n                name: 'String2358270',\n                startDate: '2022-06-29T23:14:20Z',\n                endDate: '2022-06-29T23:14:20Z',\n            },", "                endDate: '2022-06-29T23:14:20Z',\n            },\n        },\n        two: {\n            data: {\n                name: 'String9676386',\n                startDate: '2022-06-29T23:14:20Z',\n                endDate: '2022-06-29T23:14:20Z',\n            },\n        },", "            },\n        },\n    },\n});\n\nexport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/users/users.ts", "chunked_list": ["import crypto from \"crypto\"\n\nimport { addDays } from \"date-fns\"\nimport nodemailer from \"nodemailer\"\nimport type { MutationResolvers, QueryResolvers, UserResolvers } from \"types/graphql\"\n\nimport { hashPassword } from \"@redwoodjs/api\"\nimport { RedwoodGraphQLError } from \"@redwoodjs/graphql-server\"\n\nimport { db } from \"src/lib/db\"", "\nimport { db } from \"src/lib/db\"\nimport { generateResetPasswordToken } from \"src/lib/generate-reset-password-token\"\n\nconst transporter = nodemailer.createTransport({\n\tservice: \"gmail\",\n\tauth: {\n\t\tuser: process.env.EMAIL_USER,\n\t\tpass: process.env.EMAIL_PASS,\n\t},", "\t\tpass: process.env.EMAIL_PASS,\n\t},\n})\n\nexport const users: QueryResolvers[\"users\"] = () => {\n\treturn db.user.findMany()\n}\n\nexport const user: QueryResolvers[\"user\"] = ({ id }) => {\n\treturn db.user.findUnique({", "export const user: QueryResolvers[\"user\"] = ({ id }) => {\n\treturn db.user.findUnique({\n\t\twhere: { id },\n\t})\n}\n\nexport const createUser: MutationResolvers[\"createUser\"] = ({ input }) => {\n\treturn db.user.create({\n\t\tdata: input,\n\t})", "\t\tdata: input,\n\t})\n}\n\nexport const updateUser: MutationResolvers[\"updateUser\"] = ({ id, input }) => {\n\treturn db.user.update({\n\t\tdata: input,\n\t\twhere: { id },\n\t})\n}", "\t})\n}\n\nexport const deleteUser: MutationResolvers[\"deleteUser\"] = ({ id }) => {\n\treturn db.user.delete({\n\t\twhere: { id },\n\t})\n}\n\nexport const sendResetPasswordEmail: MutationResolvers[\"sendResetPasswordEmail\"] = async ({ email }) => {", "\nexport const sendResetPasswordEmail: MutationResolvers[\"sendResetPasswordEmail\"] = async ({ email }) => {\n\tconst lowerCaseEmail = email.toLowerCase()\n\tconsole.log(\"Received ID to email to reset: \" + lowerCaseEmail)\n\n\tconst associatedUser = await db.user.findUnique({\n\t\twhere: { email: lowerCaseEmail },\n\t})\n\n\tif (!associatedUser) {\n\t\tconsole.log(\"Could not find associated user\")\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: \"Could not find user with email: \" + lowerCaseEmail,\n\t\t}\n\t}\n\n\tconst resetToken = generateResetPasswordToken(16)\n\n\tawait db.user.update({\n\t\twhere: { email: lowerCaseEmail },\n\t\tdata: { resetToken, resetTokenExpiresAt: addDays(new Date(), 1) },\n\t})\n\n\tconsole.log(\"Prepping mail options\")\n\tconst resetPasswordLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`\n\tconst mailOptions = {\n\t\tfrom: process.env.EMAIL_USER,\n\t\tto: lowerCaseEmail,\n\t\tsubject: \"Please Reset Your Passowrd\",\n\t\thtml: `You are receiveing this because you have requested to reseet your password at predictor.io.\n            Please click on the following link, or paste this into your browser to complete the process: <br>\n            <a href=\"${resetPasswordLink}\">${resetPasswordLink}</a><br><br>\n\n            If you did not request this, please respond to ${process.env.EMAIL_USER} and delete the email.`,\n\t}\n\n\tconsole.log(\"Sending reset password email\")", "\n\tif (!associatedUser) {\n\t\tconsole.log(\"Could not find associated user\")\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: \"Could not find user with email: \" + lowerCaseEmail,\n\t\t}\n\t}\n\n\tconst resetToken = generateResetPasswordToken(16)\n\n\tawait db.user.update({\n\t\twhere: { email: lowerCaseEmail },\n\t\tdata: { resetToken, resetTokenExpiresAt: addDays(new Date(), 1) },\n\t})\n\n\tconsole.log(\"Prepping mail options\")\n\tconst resetPasswordLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`\n\tconst mailOptions = {\n\t\tfrom: process.env.EMAIL_USER,\n\t\tto: lowerCaseEmail,\n\t\tsubject: \"Please Reset Your Passowrd\",\n\t\thtml: `You are receiveing this because you have requested to reseet your password at predictor.io.\n            Please click on the following link, or paste this into your browser to complete the process: <br>\n            <a href=\"${resetPasswordLink}\">${resetPasswordLink}</a><br><br>\n\n            If you did not request this, please respond to ${process.env.EMAIL_USER} and delete the email.`,\n\t}\n\n\tconsole.log(\"Sending reset password email\")", "\ttry {\n\t\tawait transporter.sendMail(mailOptions)\n\t} catch (error) {\n\t\tconst errorMessage = \"An unknown error occurred when sending reset password email: \" + error\n\t\tconsole.error(errorMessage)\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tmessage: errorMessage,\n\t\t}\n\t}\n\tconsole.log(\"Reset password email sent\")\n\n\treturn {\n\t\tsuccess: true,\n\t\tmessage: \"An email has been sent to: \" + lowerCaseEmail + \". Please check your inbox.\",\n\t}\n}\n\nexport const resetPassword: MutationResolvers[\"resetPassword\"] = async ({ resetToken, password }) => {\n\tconst associatedUser = await db.user.findFirst({\n\t\twhere: { resetToken },\n\t})\n", "\tif (associatedUser.resetToken !== resetToken) {\n\t\tthrow new RedwoodGraphQLError(\"Could not find user with reset token.\")\n\t}\n\n\tconst salt = crypto.randomBytes(16).toString(\"base64\")\n\tconst [hashedPassword] = hashPassword(password, salt)\n\n\treturn await db.user.update({\n\t\twhere: {\n\t\t\tid: associatedUser.id,\n\t\t},\n\t\tdata: {\n\t\t\thashedPassword,\n\t\t\tsalt,\n\t\t\tresetToken: null,\n\t\t},\n\t})\n}\n\nexport const User: UserResolvers = {\n\tid: (_obj, { root }) => root.id,\n\temail: (_obj, { root }) => root.email,\n\tusername: (_obj, { root }) => root.username,\n\thashedPassword: (_obj, { root }) => root.hashedPassword,\n\tresetToken: (_obj, { root }) => root.resetToken,\n\tresetTokenExpiresAt: (_obj, { root }) => root.resetTokenExpiresAt,\n\tsalt: (_obj, { root }) => root.salt,\n\troles: (_obj, { root }) => root.roles,\n\tpredictions: (_obj, { root }) => db.user.findUnique({ where: { id: root.id } }).predictions(),\n}\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/users/users.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\nexport const standard = defineScenario<Prisma.UserCreateArgs>({\n    user: {\n        one: {\n            data: {\n                username: 'test',\n                email: 'String8843735',\n                hashedPassword: 'String',\n                salt: 'String',", "                hashedPassword: 'String',\n                salt: 'String',\n                roles: 'String',\n            },\n        },\n        two: {\n            data: {\n                username: 'test2',\n                email: 'String9261536',\n                hashedPassword: 'String',", "                email: 'String9261536',\n                hashedPassword: 'String',\n                salt: 'String',\n                roles: 'String',\n            },\n        },\n    },\n});\n\nexport type StandardScenario = typeof standard;\n", "\nexport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/teams/teams.ts", "chunked_list": ["import type {\n    QueryResolvers,\n    MutationResolvers,\n    TeamResolvers,\n} from 'types/graphql';\n\nimport { db } from 'src/lib/db';\n\nexport const teams: QueryResolvers['teams'] = () => {\n    return db.team.findMany();", "export const teams: QueryResolvers['teams'] = () => {\n    return db.team.findMany();\n};\n\nexport const team: QueryResolvers['team'] = ({ id }) => {\n    return db.team.findUnique({\n        where: { id },\n    });\n};\n", "};\n\nexport const createTeam: MutationResolvers['createTeam'] = ({ input }) => {\n    return db.team.create({\n        data: input,\n    });\n};\n\nexport const updateTeam: MutationResolvers['updateTeam'] = ({ id, input }) => {\n    return db.team.update({", "export const updateTeam: MutationResolvers['updateTeam'] = ({ id, input }) => {\n    return db.team.update({\n        data: input,\n        where: { id },\n    });\n};\n\nexport const deleteTeam: MutationResolvers['deleteTeam'] = ({ id }) => {\n    return db.team.delete({\n        where: { id },", "    return db.team.delete({\n        where: { id },\n    });\n};\n\nexport const Team: TeamResolvers = {\n    id: (_obj, { root }) => root.id,\n    name: (_obj, { root }) => root.name,\n    logoUrl: (_obj, { root }) => root.logoUrl,\n    Prediction: (_obj, { root }) =>", "    logoUrl: (_obj, { root }) => root.logoUrl,\n    Prediction: (_obj, { root }) =>\n        db.team.findUnique({ where: { id: root.id } }).Prediction(),\n    homeTeamGames: (_obj, { root }) =>\n        db.team.findUnique({ where: { id: root.id } }).homeTeamGames(),\n    awayTeamGames: (_obj, { root }) =>\n        db.team.findUnique({ where: { id: root.id } }).awayTeamGames(),\n};\n", ""]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/teams/teams.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\nexport const standard = defineScenario<Prisma.TeamCreateArgs>({\n    team: {\n        one: { data: { name: 'String7701370' } },\n        two: { data: { name: 'String3485322' } },\n    },\n});\n\nexport type StandardScenario = typeof standard;\n", "\nexport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/games/games.ts", "chunked_list": ["import type {\n  CreateGameResolver,\n  DeleteGameResolver,\n  GameResolver,\n  GamesResolver,\n  UpcomingGamesResolver,\n  UpdateGameResolver,\n} from \"../../../../../soccersage-output/games.d.ts\";\n\nimport { db } from \"src/lib/db\";", "\nimport { db } from \"src/lib/db\";\n\nexport const games: GamesResolver = (args, obj) => {\n  return db.game.findMany({\n    orderBy: {\n      startDateTime: \"asc\",\n    },\n  });\n};", "  });\n};\n\nexport const upcomingGames: UpcomingGamesResolver = () => {\n  return db.game.findMany({\n    where: { isCompleted: false, startDateTime: { gt: new Date() } },\n  });\n};\n\nexport const game: GameResolver = ({ id }) => {", "\nexport const game: GameResolver = ({ id }) => {\n  return db.game.findUnique({\n    where: { id },\n  });\n};\n\nexport const createGame: CreateGameResolver = ({ input }) => {\n  return db.game.create({\n    data: input,", "  return db.game.create({\n    data: input,\n  });\n};\n\nexport const updateGame: UpdateGameResolver = ({ id, input }) => {\n  return db.game.update({\n    data: input,\n    where: { id },\n  });", "    where: { id },\n  });\n};\n\nexport const deleteGame: DeleteGameResolver = async ({ id }) => {\n  await db.prediction.deleteMany({\n    where: { gameId: id },\n  });\n\n  return db.game.delete({", "\n  return db.game.delete({\n    where: { id },\n  });\n};\n\nexport const Game: GameResolvers<{ predictions?: any[] }> = {\n  predictions: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).predictions(),\n  homeTeam: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).homeTeam(),\n  awayTeam: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).awayTeam(),", "  homeTeam: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).homeTeam(),\n  awayTeam: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).awayTeam(),\n  season: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).season(),\n};\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/games/games.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\nexport const standard = defineScenario<Prisma.GameCreateArgs>({\n    game: {\n        one: {\n            data: {\n                homeTeam: { create: { name: 'String8184842' } },\n                awayTeam: { create: { name: 'String342092' } },\n                startDateTime: new Date(),\n                season: {", "                startDateTime: new Date(),\n                season: {\n                    create: {\n                        name: 'String8184842',\n                        startDate: new Date(),\n                        endDate: new Date(),\n                    },\n                },\n            },\n        },", "            },\n        },\n        two: {\n            data: {\n                homeTeam: { create: { name: 'String2664163' } },\n                awayTeam: { create: { name: 'String9522390' } },\n                startDateTime: new Date(),\n                season: {\n                    create: {\n                        name: 'String9522390',", "                    create: {\n                        name: 'String9522390',\n                        startDate: new Date(),\n                        endDate: new Date(),\n                    },\n                },\n            },\n        },\n    },\n});", "    },\n});\n\nexport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/predictions/predictions.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\nexport const standard = defineScenario<Prisma.PredictionCreateArgs>({\n    prediction: {\n        one: {\n            data: {\n                user: {\n                    create: {\n                        username: 'test',\n                        email: 'test1',", "                        username: 'test',\n                        email: 'test1',\n                        hashedPassword: 'test',\n                        salt: 'test',\n                        roles: 'test',\n                    },\n                },\n                prediction: 'String',\n                game: {\n                    create: {", "                game: {\n                    create: {\n                        homeTeamScore: 5278373,\n                        awayTeamScore: 9262607,\n                        homeTeam: { create: { name: 'String3223999' } },\n                        awayTeam: { create: { name: 'String5108965' } },\n                        startDateTime: new Date('2022-10-27'),\n                        season: {\n                            create: {\n                                name: 'String5108965',", "                            create: {\n                                name: 'String5108965',\n                                startDate: new Date(),\n                                endDate: new Date(),\n                            },\n                        },\n                    },\n                },\n                season: {\n                    create: {", "                season: {\n                    create: {\n                        name: 'Test season 1',\n                        startDate: new Date('2022-05-01'),\n                        endDate: new Date('2022-05-31'),\n                    },\n                },\n            },\n        },\n        two: {", "        },\n        two: {\n            data: {\n                user: {\n                    create: {\n                        username: 'test2',\n                        email: 'test2',\n                        hashedPassword: 'test',\n                        salt: 'test',\n                        roles: 'test',", "                        salt: 'test',\n                        roles: 'test',\n                    },\n                },\n                prediction: 'String',\n                game: {\n                    create: {\n                        homeTeamScore: 2210328,\n                        awayTeamScore: 4786303,\n                        homeTeam: { create: { name: 'String2218724' } },", "                        awayTeamScore: 4786303,\n                        homeTeam: { create: { name: 'String2218724' } },\n                        awayTeam: { create: { name: 'String3400904' } },\n                        startDateTime: new Date('2022-06-01'),\n                        season: {\n                            create: {\n                                name: 'String3400904',\n                                startDate: new Date(),\n                                endDate: new Date(),\n                            },", "                                endDate: new Date(),\n                            },\n                        },\n                    },\n                },\n                season: {\n                    create: {\n                        name: 'Test season 2',\n                        startDate: new Date('2022-06-01'),\n                        endDate: new Date('2022-06-30'),", "                        startDate: new Date('2022-06-01'),\n                        endDate: new Date('2022-06-30'),\n                    },\n                },\n            },\n        },\n    },\n});\n\nexport type StandardScenario = typeof standard;\n", "\nexport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/predictions/predictions.ts", "chunked_list": ["import type {\n    Game,\n    MutationResolvers,\n    Prediction as PredictionType,\n    PredictionResolvers,\n    QueryResolvers,\n    User,\n} from 'types/graphql';\n\nimport { getFirstUserFromContext } from 'src/lib/auth';", "\nimport { getFirstUserFromContext } from 'src/lib/auth';\nimport { db } from 'src/lib/db';\n\ntype PartialGame = Omit<\n    Game,\n    'homeTeam' | 'awayTeam' | 'predictions' | 'season'\n>;\ntype PartialUser = Omit<User, 'predictions' | 'resetTokenExpiresAt'>;\n\ntype PartialPrediction = Omit<PredictionType, 'game' | 'user'> & {\n    game: PartialGame;\n    user: PartialUser;\n};\n\n//TODO: Re-use these functions from the PredictionCard\nconst getWinningTeamId = (game: PartialGame) => {", "type PartialUser = Omit<User, 'predictions' | 'resetTokenExpiresAt'>;\n\ntype PartialPrediction = Omit<PredictionType, 'game' | 'user'> & {\n    game: PartialGame;\n    user: PartialUser;\n};\n\n//TODO: Re-use these functions from the PredictionCard\nconst getWinningTeamId = (game: PartialGame) => {\n    if (game.homeTeamScore > game.awayTeamScore) {\n        return game.homeTeamId;", "    if (game.homeTeamScore > game.awayTeamScore) {\n        return game.homeTeamId;\n    } else if (game.awayTeamScore > game.homeTeamScore) {\n        return game.awayTeamId;\n    }\n\n    return null;\n};\n\nconst getPredictionStatus = (\n    prediction: PartialPrediction\n): 'incomplete' | 'correct' | 'incorrect' => {", "    if (!prediction.game.isCompleted) {\n        return 'incomplete';\n    }\n\n    const winningTeamId = getWinningTeamId(prediction.game);\n\n    return winningTeamId === prediction.teamId ? 'correct' : 'incorrect';\n};\n\nexport const standings: QueryResolvers['standings'] = async ({ seasonId }) => {\n    // TODO: This logic finds all predictions, and includes the associated game for each prediction.\n    // While this works with small amounts of data, this will not scale very well, due to the\n    // re-retrieval of game data for each prediction.\n    // Other options to consider if/when more users join:\n    // 1. - Query for all predictions in a season and all games in a season concurrently.\n    //   a. - This is still not as performant as possible, but would reduce duplicate data and retain live standings.\n    // 2. - Store standings in a separate schema, and have a CRON job that updates them once an hour.\n    //   a. - This would allow for a much more performant solution, but would remove the ability to have live standings.\n    const predictions = await db.prediction.findMany({\n        where: { seasonId },\n        include: {\n            game: true,\n            user: true,\n        },\n    });\n\n    const userPredictionMap = predictions.reduce<{\n        [key: string]: PartialPrediction[];\n    }>((acc, prediction) => {", "        if (acc[prediction.userId]) {\n            acc[prediction.userId].push(prediction);\n        } else {\n            acc[prediction.userId] = [prediction];\n        }\n\n        return acc;\n    }, {});\n\n    // TODO: Define the exact scoring algorithm that we would like to use\n    const userIdRankings = Object.entries(userPredictionMap).map(\n        ([userId, predictions]) => {\n            const { email, username } = predictions[0].user;\n            const score = predictions.reduce<number>((acc, prediction) => {\n                const predictionStatus = getPredictionStatus(prediction);\n                switch (predictionStatus) {\n                    case 'correct':\n                        return acc + 1;\n                    default:\n                        return acc;\n                }\n            }, 0);\n\n            return {\n                email,\n                username,\n                userId,\n                score,\n            };\n        }\n    );\n\n    return {\n        userIdRankings,\n    };\n};\n\nexport const predictions: QueryResolvers['predictions'] = () => {\n    return db.prediction.findMany();\n};\n\nexport const myPredictions: QueryResolvers['myPredictions'] = (\n    _temp,\n    { context }\n) => {\n    const user = getFirstUserFromContext(context);\n    return db.prediction.findMany({\n        where: { userId: user.id },\n    });\n};\n\nexport const prediction: QueryResolvers['prediction'] = ({ id }) => {\n    return db.prediction.findUnique({\n        where: { id },\n    });\n};\n\nexport const createPrediction: MutationResolvers['createPrediction'] = ({\n    input,\n}) => {\n    return db.prediction.create({\n        data: input,\n    });\n};\n\nexport const updatePrediction: MutationResolvers['updatePrediction'] = ({\n    id,\n    input,\n}) => {\n    return db.prediction.update({\n        data: input,\n        where: { id },\n    });\n};\n\nexport const deletePrediction: MutationResolvers['deletePrediction'] = ({\n    id,\n}) => {\n    return db.prediction.delete({\n        where: { id },\n    });\n};\n\nexport const Prediction: PredictionResolvers = {\n    id: (_obj, { root }) => root.id,\n    teamId: (_obj, { root }) => root.teamId,\n    gameId: (_obj, { root }) => root.gameId,\n    userId: (_obj, { root }) => root.userId,\n    prediction: (_obj, { root }) => root.prediction,\n    user: (_obj, { root }) =>\n        db.user.findUnique({ where: { id: root.userId } }),\n    team: (_obj, { root }) =>\n        db.prediction.findUnique({ where: { id: root.id } }).team(),\n    game: (_obj, { root }) =>\n        db.prediction.findUnique({ where: { id: root.id } }).game(),\n};\n"]}
