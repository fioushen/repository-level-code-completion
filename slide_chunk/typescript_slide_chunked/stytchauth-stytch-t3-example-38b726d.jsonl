{"filename": "next-env.d.ts", "chunked_list": ["/// <reference types=\"next\" />\n/// <reference types=\"next/image-types/global\" />\n\n// NOTE: This file should not be edited\n// see https://nextjs.org/docs/basic-features/typescript for more information.\n"]}
{"filename": "prisma/seed.ts", "chunked_list": ["import { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  console.log(`\ud83c\udf89\ud83c\udf89\ud83c\udf89 Seeding Finished \ud83c\udf89\ud83c\udf89\ud83c\udf89`);\n}\n\nmain()\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n", "  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n"]}
{"filename": "src/middleware.ts", "chunked_list": ["import { NextResponse, type NextRequest } from 'next/server';\nimport { loadStytch } from '~/server/stytch';\n\nexport const config = {\n  matcher: ['/profile', '/login'],\n};\n\nexport const middleware = async (req: NextRequest) => {\n  const res = NextResponse.next();\n  const { pathname } = req.nextUrl;\n\n  // Pull the session JWT from the cookie.\n  const jwtToken = req.cookies.get('session_jwt')?.value;\n\n  // If there is a JWT, we need to verify it with Stytch to make sure it is valid and take the appropriate action.", "  if (jwtToken) {\n    // Authenticate the JWT with Stytch; this will tell us if the session is still valid.\n    try {\n      const stytch = loadStytch();\n      await stytch.sessions.authenticateJwt(jwtToken);\n\n      // If the session is valid and they are on the login screen, redirect them to the profile screen.\n      if (pathname === '/login') {\n        return NextResponse.redirect(new URL('/profile', req.url));\n      }\n    // If there is an error, the session is invalid, delete the cookie and redirect them to the login screen.", "    } catch (err) {\n      res.cookies.delete('session_jwt');\n      return NextResponse.redirect(new URL('/login', req.url), { headers: res.headers });\n    }\n  }\n\n  // If there is no token, the user does not have an active session, redirect them to the login screen.\n  if (!jwtToken && pathname === '/profile') {\n    return NextResponse.redirect(new URL('/login', req.url));\n  }\n\n  return res;\n};\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import * as trpcNext from '@trpc/server/adapters/next';\nimport { createContext } from '~/server/context';\nimport { appRouter } from '~/server/routers/_app';\n\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  batching: {\n    enabled: true,\n  },", "    enabled: true,\n  },\n});\n"]}
{"filename": "src/components/index.ts", "chunked_list": ["export * from './AccountLogout';\nexport * from './Button';\nexport * from './Input';\nexport * from './LoginButton';\nexport * from './LoginEmail';\nexport * from './LoginSms';\nexport * from './PhoneInput';\nexport * from './Profile';\nexport * from './SiteHeader';\nexport * from './VerifyOtp';", "export * from './SiteHeader';\nexport * from './VerifyOtp';\nexport * from './Welcome';"]}
{"filename": "src/utils/trpc.ts", "chunked_list": ["import { httpBatchLink, loggerLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport { type AppRouter } from '~/server/routers/_app';\n\nfunction getBaseUrl() {\n  if (typeof window !== 'undefined')\n    // browser should use relative path\n    return '';\n\n  if (process.env.VERCEL_URL)\n    // reference for vercel.com\n    return `https://${process.env.VERCEL_URL}`;\n\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`;\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      abortOnUnmount: true,\n      queryClientConfig: {\n        defaultOptions: {\n          queries: {\n            staleTime: Infinity,\n            refetchOnWindowFocus: false,\n          },\n        },\n      },\n      transformer: superjson,\n      links: [\n        loggerLink({\n          enabled: (opts) =>\n            process.env.NODE_ENV === 'development' || (opts.direction === 'down' && opts.result instanceof Error),\n        }),\n        httpBatchLink({ url: `${getBaseUrl()}/api/trpc` }),\n      ],\n    };\n  },\n  ssr: false,\n});\n", "  if (process.env.VERCEL_URL)\n    // reference for vercel.com\n    return `https://${process.env.VERCEL_URL}`;\n\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`;\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      abortOnUnmount: true,\n      queryClientConfig: {\n        defaultOptions: {\n          queries: {\n            staleTime: Infinity,\n            refetchOnWindowFocus: false,\n          },\n        },\n      },\n      transformer: superjson,\n      links: [\n        loggerLink({\n          enabled: (opts) =>\n            process.env.NODE_ENV === 'development' || (opts.direction === 'down' && opts.result instanceof Error),\n        }),\n        httpBatchLink({ url: `${getBaseUrl()}/api/trpc` }),\n      ],\n    };\n  },\n  ssr: false,\n});\n"]}
{"filename": "src/utils/phone-countries.ts", "chunked_list": ["import { Country } from 'react-phone-number-input';\n\n/**\n * These are the countries that Stytch supports at the time of writing\n * https://stytch.com/docs/passcodes#unsupported-countries.\n *\n * This list is used to populate the country dropdown on the phone number input\n * in the login form. Simply remove any countries that you don't want to support. You may\n * want to limit support due to cost, fraud, or because you do not do business in that country.\n **/", " * want to limit support due to cost, fraud, or because you do not do business in that country.\n **/\n\nexport const STYTCH_SUPPORTED_SMS_COUNTRIES: Country[] = [\n  'US', // will be selected by default on phone number input\n  'CA',\n  // 'AU',\n  // 'BR',\n  // 'DE',\n  // 'ES',", "  // 'DE',\n  // 'ES',\n  // 'FR',\n  // 'GB',\n  // 'MX',\n];\n"]}
{"filename": "src/utils/regex.ts", "chunked_list": ["// This regex is used to validate that the phone number entered by the user is valid.\nexport const VALID_PHONE_NUMBER = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/;\n"]}
{"filename": "src/server/trpc.ts", "chunked_list": ["import { initTRPC, TRPCError } from '@trpc/server';\nimport superjson from 'superjson';\nimport { Context } from './context';\n\n/**\n * This is your entry point to setup the root configuration for tRPC on the server.\n * - `initTRPC` should only be used once per app.\n * - We export only the functionality that we use so we can enforce which base procedures should be used\n *\n * Learn how to create protected base procedures and other things below:", " *\n * Learn how to create protected base procedures and other things below:\n * @see https://trpc.io/docs/v10/router\n * @see https://trpc.io/docs/v10/procedures\n */\n\nconst t = initTRPC.context<Context>().create({\n  /**\n   * @see https://trpc.io/docs/v10/data-transformers\n   */", "   * @see https://trpc.io/docs/v10/data-transformers\n   */\n  transformer: superjson,\n  /**\n   * @see https://trpc.io/docs/v10/error-formatting\n   */\n  errorFormatter({ shape }) {\n    return shape;\n  },\n});", "  },\n});\n\n/**\n * Reusable middleware that checks if users are authenticated.\n **/\nconst isAuthed = t.middleware(async ({ next, ctx }) => {\n  if (!ctx.req || !ctx.res) {\n    throw new Error('You are missing `req` or `res` in your call.');\n  }\n", "  if (!ctx.session) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return next({\n    ctx: {\n      session: ctx.session,\n      req: ctx.req,\n      res: ctx.res,\n    },\n  });\n});\n\n/**\n * Create a router\n * @see https://trpc.io/docs/v10/router\n */\nexport const router = t.router;\n\n/**\n * Create an unprotected procedure\n * @see https://trpc.io/docs/v10/procedures\n **/\nexport const publicProcedure = t.procedure;\n\n/**\n * Protected procedure\n **/\nexport const protectedProcedure = t.procedure.use(isAuthed);\n\n/**\n * @see https://trpc.io/docs/v10/middlewares\n */\nexport const middleware = t.middleware;\n\n/**\n * @see https://trpc.io/docs/v10/merging-routers\n */\nexport const mergeRouters = t.mergeRouters;\n"]}
{"filename": "src/server/stytch.ts", "chunked_list": ["import * as stytch from 'stytch';\n\nlet client: stytch.Client;\n\n// Initialize the Stytch client.\nexport const loadStytch = () => {\n  if (!client) {\n    client = new stytch.Client({\n      project_id: process.env.STYTCH_PROJECT_ID!,\n      secret: process.env.STYTCH_SECRET!,\n      env: process.env.STYTCH_PROJECT_ENV === 'live' ? stytch.envs.live : stytch.envs.test,\n    });\n  }\n\n  return client;\n};\n"]}
{"filename": "src/server/prisma.ts", "chunked_list": ["/**\n * Instantiates a single instance PrismaClient and save it on the global object.\n * @link https://www.prisma.io/docs/support/help-articles/nextjs-prisma-client-dev-practices\n */\nimport { PrismaClient } from '@prisma/client';\n\nconst prismaGlobal = global as typeof global & {\n  prisma?: PrismaClient;\n};\n", "};\n\nexport const prisma: PrismaClient =\n  prismaGlobal.prisma ||\n  new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  });\n\nif (process.env.NODE_ENV !== 'production') {\n  prismaGlobal.prisma = prisma;\n}\n", "if (process.env.NODE_ENV !== 'production') {\n  prismaGlobal.prisma = prisma;\n}\n"]}
{"filename": "src/server/context.ts", "chunked_list": ["import * as trpc from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { deleteCookie, getCookie } from 'cookies-next';\nimport { type StytchCustomClaims, type StytchSessionWithCustomClaims } from '~/types/stytch';\nimport { prisma } from './prisma';\nimport { loadStytch } from './stytch';\n\nexport async function createContext(opts?: trpcNext.CreateNextContextOptions) {\n  const req = opts?.req;\n  const res = opts?.res;\n\n  const stytch = loadStytch();\n\n  let session: StytchSessionWithCustomClaims | undefined = undefined;\n  const jwtToken = getCookie('session_jwt', { req, res })?.toString();\n", "  if (jwtToken) {\n    try {\n      const authenticateJwtResponse = await stytch.sessions.authenticateJwt(jwtToken);\n      session = {\n        ...authenticateJwtResponse.session,\n        custom_claims: authenticateJwtResponse.session.custom_claims as StytchCustomClaims,\n      };\n    } catch (err) {\n      deleteCookie('session_jwt', { req, res });\n    }\n  }\n\n  return { req, res, prisma, stytch, session };\n}\n", "export type Context = trpc.inferAsyncReturnType<typeof createContext>;\n"]}
{"filename": "src/server/routers/auth.ts", "chunked_list": ["import { TRPCError } from '@trpc/server';\nimport { deleteCookie, setCookie } from 'cookies-next';\nimport { parsePhoneNumber } from 'react-phone-number-input';\nimport { StytchError } from 'stytch';\nimport { z } from 'zod';\nimport { protectedProcedure, publicProcedure, router } from '~/server/trpc';\nimport { VALID_PHONE_NUMBER } from '~/utils/regex';\nimport { STYTCH_SUPPORTED_SMS_COUNTRIES } from '~/utils/phone-countries';\n\n// Change these values to adjust the length of a user's session. 30 day sessions, like we use here, is usually a good default,", "\n// Change these values to adjust the length of a user's session. 30 day sessions, like we use here, is usually a good default,\n// but you may find a shorter or longer duration to work better for your app.\nconst SESSION_DURATION_MINUTES = 43200;\n\n// SESSION_DURATION_SECONDS is used to set the age of the cookie that we set in the user's browser.\nconst SESSION_DURATION_SECONDS = SESSION_DURATION_MINUTES * 60;\n\nexport const authRouter = router({\n  // This route is used to send an OTP via email to a user.", "export const authRouter = router({\n  // This route is used to send an OTP via email to a user.\n  loginEmail: publicProcedure\n    .input(\n      z.object({\n        email: z.string().email('Invalid email address').min(1, 'Email address is required'),\n      }),\n    )\n    .output(\n      z.object({", "    .output(\n      z.object({\n        methodId: z.string(),\n        userCreated: z.boolean(),\n      }),\n    )\n    .mutation(async ({ input, ctx }) => {\n      try {\n        // 1. Login or create the user in Stytch. If the user has been seen before, a vanilla login will be performed, if they\n        // haven't been seen before, a signup email will be sent and a new Stytch User will be created.\n        const loginOrCreateResponse = await ctx.stytch.otps.email.loginOrCreate({\n          email: input.email,\n          create_user_as_pending: true,\n        });\n\n        // 2. Create the user in your Prisma database.\n        //\n        // Because Stytch auth lives in your backend, you can perform all of your\n        // normal business logic in sync with your authentication, e.g. syncing your user DB, adding the user to a mailing list,\n        // or provisioning them a Stripe customer, etc.\n        //\n        // If you're coming from Auth0, you might have Rules, Hooks, or Actions that perform this logic. With Stytch, there is\n        // no need for this logic to live outside of your codebase separate from your backend.", "        if (loginOrCreateResponse.user_created) {\n          await ctx.prisma.user.create({ data: { stytchUserId: loginOrCreateResponse.user_id } });\n        }\n\n        return {\n          // The method_id is used during the OTP Authenticate step to ensure the OTP code belongs to the user who initiated the\n          // the login flow.\n          methodId: loginOrCreateResponse.email_id,\n          // The user_created flag is used to determine if the user was created during this login flow. This is useful for\n          // determining if you should show a welcome message, or take some other action, for new vs. existing users.\n          userCreated: loginOrCreateResponse.user_created,\n        };", "      } catch (err) {\n        if (err instanceof StytchError) {\n          throw new TRPCError({ code: 'BAD_REQUEST', message: err.error_message, cause: err });\n        }\n\n        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', cause: err });\n      }\n    }),\n\n  // This route is used to send an SMS OTP to a user.\n  loginSms: publicProcedure\n    .input(\n      z.object({\n        phone: z.string().regex(VALID_PHONE_NUMBER, 'Invalid phone number').min(1, 'Phone number is required'),\n      }),\n    )\n    .output(\n      z.object({\n        methodId: z.string(),\n        userCreated: z.boolean(),\n      }),\n    )\n    .mutation(async ({ input, ctx }) => {\n      const phoneNumber = parsePhoneNumber(input.phone);\n", "      if (!phoneNumber?.country || !STYTCH_SUPPORTED_SMS_COUNTRIES.includes(phoneNumber.country)) {\n        throw new TRPCError({\n          code: 'BAD_REQUEST',\n          message: `Sorry, we don't support sms login for your country yet.`,\n        });\n      }\n\n      try {\n        // 1. Login or create the user in Stytch. If the user has been seen before, a vanilla login will be performed, if they\n        // haven't been seen before, an SMS will be sent and a new Stytch User will be created.\n        const loginOrCreateResponse = await ctx.stytch.otps.sms.loginOrCreate({\n          phone_number: input.phone,\n          create_user_as_pending: true,\n        });\n\n        // 2. Create the user in your Prisma database.\n        //\n        // Because Stytch auth lives in your backend, you can perform all of your\n        // normal business logic in sync with your authentication, e.g. syncing your user DB, adding the user to a mailing list,\n        // or provisioning them a Stripe customer, etc.\n        //\n        // If you're coming from Auth0, you might have Rules, Hooks, or Actions that perform this logic. With Stytch, there is\n        // no need for this logic to live outside of your codebase separate from your backend.", "        if (loginOrCreateResponse.user_created) {\n          await ctx.prisma.user.create({ data: { stytchUserId: loginOrCreateResponse.user_id } });\n        }\n\n        return {\n          // The method_id is used during the OTP Authenticate step to ensure the OTP code belongs to the user who initiated the\n          // the login flow.\n          methodId: loginOrCreateResponse.phone_id,\n          // The user_created flag is used to determine if the user was created during this login flow. This is useful for\n          // determining if you should show a welcome message, or take some other action, for new vs. existing users.\n          userCreated: loginOrCreateResponse.user_created,\n        };", "      } catch (err) {\n        if (err instanceof StytchError) {\n          throw new TRPCError({ code: 'BAD_REQUEST', message: err.error_message, cause: err });\n        }\n\n        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', cause: err });\n      }\n    }),\n\n  // This route handles authenticating an OTP as input by the user and adding custom claims to their resulting session.\n  authenticateOtp: publicProcedure\n    .input(\n      z.object({\n        code: z.string().length(6, 'OTP must be 6 digits'),\n        methodId: z.string(),\n      }),\n    )\n    .output(\n      z.object({\n        id: z.string(),\n      }),\n    )\n    .mutation(async ({ input, ctx }) => {", "      try {\n        // 1. OTP Authenticate step; here we'll validate that the OTP + Method (phone_id or email_id) are valid and belong to\n        // the same user who initiated the login flow.\n        const authenticateResponse = await ctx.stytch.otps.authenticate({\n          code: input.code,\n          method_id: input.methodId,\n          session_duration_minutes: SESSION_DURATION_MINUTES,\n        });\n\n        // 2. Get the user from your Prisma database.\n        //\n        // Here you could also include any other business logic, e.g. firing logs in your own stack, on successful completion of the login flow.\n        const dbUser = await ctx.prisma.user.findUniqueOrThrow({\n          where: { stytchUserId: authenticateResponse.user.user_id },\n          select: {\n            id: true,\n          },\n        });\n\n        // Examples of business logic you might want to include on successful user creation:\n        //\n        // Create a Stripe customer for the user.\n        // await ctx.stripe.customers.create({ name: authenticateResponse.user.name.first_name });\n        //\n        // Subscribe the user to a mailing list.\n        // await ctx.mailchimp.lists.addListMember(\"list_id\", { email_address: authenticateResponse.user.emails[0].email, status: \"subscribed\" });\n\n        // 3. Optional: Add custom claims to the session. These claims will be available in the JWT returned by Stytch.\n        // \n        // Alternatively this can also be accomplished via a custom JWT template set in the Stytch Dashboard if there are values you want on \n        // all JWTs issued for your sessions.\n        const sessionResponse = await ctx.stytch.sessions.authenticate({\n          // Here we add the Prisma user ID to the session as a custom claim.\n          session_custom_claims: { db_user_id: dbUser.id },\n          session_jwt: authenticateResponse.session_jwt,\n          session_duration_minutes: SESSION_DURATION_MINUTES,\n        });\n\n        // 4. Set the session JWT as a cookie in the user's browser.\n        setCookie('session_jwt', sessionResponse.session_jwt, {\n          req: ctx.req,\n          res: ctx.res,\n          httpOnly: true,\n          maxAge: SESSION_DURATION_SECONDS,\n          secure: process.env.NODE_ENV === 'production',\n          sameSite: 'strict',\n        });\n\n        return {\n          id: dbUser.id,\n        };", "      } catch (err) {\n        if (err instanceof StytchError) {\n          throw new TRPCError({ code: 'BAD_REQUEST', message: err.error_message, cause: err });\n        }\n\n        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', cause: err });\n      }\n    }),\n\n  // This route logs a user out of their session by revoking it with Stytch. \n  //\n  // Note, because JWTs are valid for their lifetime (here we've set it to 30 days), the JWT would still\n  // locally parse, i.e. using an open source JWT parsing library, as valid. We always encourage you to\n  // authenticate a session with Stytch's API directly to ensure that it is still valid.\n  logout: protectedProcedure.mutation(async ({ ctx }) => {\n    await ctx.stytch.sessions.revoke({ session_id: ctx.session.session_id });\n    deleteCookie('session_jwt', { req: ctx.req, res: ctx.res });\n\n    return { success: true };\n  }),\n});\n"]}
{"filename": "src/server/routers/_app.ts", "chunked_list": ["import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';\nimport { router } from '~/server/trpc';\nimport { authRouter } from './auth';\nimport { userRouter } from './user';\n\nexport const appRouter = router({\n  auth: authRouter,\n  user: userRouter,\n});\n\nexport type AppRouter = typeof appRouter;", "export type AppRouter = typeof appRouter;\nexport type RouterInput = inferRouterInputs<AppRouter>;\nexport type RouterOutput = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/server/routers/user.ts", "chunked_list": ["import { publicProcedure, router } from '~/server/trpc';\n\nexport const userRouter = router({\n  // This route fetches the current, logged-in user.\n  current: publicProcedure.query(async ({ ctx }) => {\n    const session = ctx.session;\n\n    if (!session) return null;\n\n    const [stytchUser, dbUser] = await Promise.all([\n      ctx.stytch.users.get(session.user_id),\n      ctx.prisma.user.findUniqueOrThrow({\n        where: { id: session.custom_claims.db_user_id },\n        select: {\n          id: true,\n        },\n      }),\n    ]);\n\n    return {\n      id: dbUser.id,\n      stytch_user_id: stytchUser.user_id,\n      emails: stytchUser.emails,\n      phoneNumbers: stytchUser.phone_numbers,\n      status: stytchUser.status,\n    };\n  }),\n});\n"]}
{"filename": "src/types/stytch.ts", "chunked_list": ["import { type Session } from 'stytch/types/lib/b2c/shared_b2c';\n\nexport type StytchAuthMethods = 'otp_email' | 'otp_sms';\n\nexport type StytchCustomClaims = {\n  db_user_id: string;\n};\n\nexport interface StytchSessionWithCustomClaims extends Session {\n  custom_claims: StytchCustomClaims;\n}\n", "export interface StytchSessionWithCustomClaims extends Session {\n  custom_claims: StytchCustomClaims;\n}\n"]}
