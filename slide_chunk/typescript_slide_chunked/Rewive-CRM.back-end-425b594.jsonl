{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from './../src/app.module';\n\ndescribe('AppController (e2e)', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({", "  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('/ (GET)', () => {", "\n  it('/ (GET)', () => {\n    return request(app.getHttpServer())\n      .get('/')\n      .expect(200)\n      .expect('Hello World!');\n  });\n});\n", ""]}
{"filename": "src/main.ts", "chunked_list": ["import { ValidationPipe } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { FastifyAdapter, NestFastifyApplication } from '@nestjs/platform-fastify';\nimport { AppModule } from './app.module';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ConfigService } from '@nestjs/config';\nimport helmet from '@fastify/helmet'\n\nasync function bootstrap() {\n  const configService = new ConfigService();\n  const app = await NestFactory.create<NestFastifyApplication>(\n    AppModule,\n    new FastifyAdapter({\n      maxParamLength: configService.get('MAX_PARAMS_LENGTH'),\n    }),\n  );\n\n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true,\n      transform: true,\n    }),\n  );\n  \n  app.getHttpAdapter().getInstance().register(helmet);\n  const config = new DocumentBuilder()\n    .setTitle('CRM')\n    .setDescription('API CRM')\n    .setVersion('1.0')\n    .addTag('crm')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  await app.listen(configService.get('PORT'));\n}\nbootstrap();", "async function bootstrap() {\n  const configService = new ConfigService();\n  const app = await NestFactory.create<NestFastifyApplication>(\n    AppModule,\n    new FastifyAdapter({\n      maxParamLength: configService.get('MAX_PARAMS_LENGTH'),\n    }),\n  );\n\n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true,\n      transform: true,\n    }),\n  );\n  \n  app.getHttpAdapter().getInstance().register(helmet);\n  const config = new DocumentBuilder()\n    .setTitle('CRM')\n    .setDescription('API CRM')\n    .setVersion('1.0')\n    .addTag('crm')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  await app.listen(configService.get('PORT'));\n}\nbootstrap();"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\ninterface AuthResponse {\n  status: string;\n}\n\n@Injectable()\nexport class AppService {\n  CheckAuth(): AuthResponse {\n    return {status: \"OK\"};\n  }\n}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { JwtStrategy } from './strategy/jwt.strategy';\nimport { AuthModule } from './auth/auth.module';\nimport { UsersModule } from './users/users.module';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ThrottlerModule } from '@nestjs/throttler';\n", "import { ThrottlerModule } from '@nestjs/throttler';\n\n@Module({\n  imports: [\n    MongooseModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        uri: configService.get('MONGODB_URI'),\n      }),\n      inject: [ConfigService],", "      }),\n      inject: [ConfigService],\n    }),\n    ThrottlerModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        ttl: configService.get('TTL'),\n        limit: configService.get('LIMIT'),\n      }),\n      inject: [ConfigService],", "      }),\n      inject: [ConfigService],\n    }),\n    ConfigModule.forRoot({\n      envFilePath: '.env',\n    }),\n    AuthModule,\n    UsersModule,\n  ],\n  controllers: [AppController],", "  ],\n  controllers: [AppController],\n  providers: [AppService, JwtStrategy],\n})\nexport class AppModule {}"]}
{"filename": "src/app.controller.ts", "chunked_list": ["import { Controller, Get , UseGuards } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { JwtAuthGuard } from './guards/jwt-auth.guards';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @UseGuards(JwtAuthGuard)\n  @Get('/')\n  CheckAuth(): object {\n    return this.appService.CheckAuth();\n  }\n}\n"]}
{"filename": "src/strategy/jwt.strategy.ts", "chunked_list": ["import { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n    constructor() {\n        super({\n            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n            ignoreExpiration: false,\n            secretOrKey: process.env.JWT_SECRET,\n        });\n    }\n\n    async validate(payload: any) {\n        return { userId: payload.sub, username: payload.username };\n    }\n}"]}
{"filename": "src/users/users.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { JwtStrategy } from '../strategy/jwt.strategy';\nimport { UsersController } from '../users/users.controller';\nimport { UsersService } from '../users/users.service';\nimport { Users, UsersSchema } from './models';\n", "import { Users, UsersSchema } from './models';\n\n@Module({\n  imports: [\n    MongooseModule.forFeature([{ name: Users.name, schema: UsersSchema }]),\n    PassportModule,\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        secret: configService.get('JWT_SECRET'),", "      useFactory: (configService: ConfigService) => ({\n        secret: configService.get('JWT_SECRET'),\n        signOptions: { expiresIn: configService.get('JWT_EXPIRES_IN') },\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  controllers: [UsersController],\n  providers: [UsersService, JwtStrategy],\n})\nexport class UsersModule {}", "  providers: [UsersService, JwtStrategy],\n})\nexport class UsersModule {}"]}
{"filename": "src/users/users.service.ts", "chunked_list": ["import { Injectable, ConflictException, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Users, UsersDocument } from './models';\nimport { CreateUsersDto, UpdateUsersDto, DeleteUsersDto, IdUsersDto } from './dto';\n\n@Injectable()\nexport class UsersService {\n    constructor(@InjectModel(Users.name) private usersModel: Model<UsersDocument>) {}\n\n    async findAll(): Promise<Users[]> {\n        return this.usersModel.find().exec();\n    }\n\n    async findOne(idUsersDto: IdUsersDto): Promise<Users> {", "        try {\n            const user = await this.usersModel.findById(idUsersDto.id).orFail();\n            return user;\n        } catch (error) {\n            if (error.name === 'DocumentNotFoundError') {\n                throw new NotFoundException('User not found');\n            }\n            throw new BadRequestException('Invalid id');\n        }\n    }\n\n    async create(createUsersDto: CreateUsersDto): Promise<Users> {\n        const existingUser = await this.usersModel.findOne({ email: createUsersDto.email });", "        if (existingUser) {\n            throw new ConflictException('User with this email already exists');\n        }\n        const createdUser = new this.usersModel(createUsersDto);\n        return createdUser.save();\n    }\n\n    async update(ctachidUsersDto: IdUsersDto, updateUsersDto: UpdateUsersDto): Promise<Users> {\n        try {\n            const updatedUser = await this.usersModel.findByIdAndUpdate(ctachidUsersDto.id, updateUsersDto, { new: true }).orFail();\n            return updatedUser;", "        try {\n            const updatedUser = await this.usersModel.findByIdAndUpdate(ctachidUsersDto.id, updateUsersDto, { new: true }).orFail();\n            return updatedUser;\n        } catch (error) {\n            if (error.name === 'DocumentNotFoundError') {\n                throw new NotFoundException('User not found');\n            }\n            throw new BadRequestException('Invalid id');\n        }\n    }\n\n    async remove(deleteUsersDto: DeleteUsersDto): Promise<{ status: string }> {", "        try {\n            await this.usersModel.findByIdAndDelete(deleteUsersDto.id).orFail();\n            return { status: 'Deleted' };\n        } catch (error) {\n            if (error.name === 'DocumentNotFoundError') {\n                throw new NotFoundException('User not found');\n            }\n            throw new BadRequestException('Invalid id');\n        }\n    }\n}"]}
{"filename": "src/users/users.controller.ts", "chunked_list": ["import { Controller, Post, Get, Body, UseGuards, Param, Patch, Delete } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { CreateUsersDto, DeleteUsersDto, UpdateUsersDto, IdUsersDto } from './dto'\nimport { JwtAuthGuard } from '../guards/jwt-auth.guards';\nimport { ThrottlerGuard } from '@nestjs/throttler';\n\n@UseGuards(ThrottlerGuard) \n@Controller('api/users')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) { }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('/')\n  async findAll() {\n    return this.usersService.findAll();\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get(':id')\n  async findOne(@Param() idUsersDto: IdUsersDto) {\n    return this.usersService.findOne(idUsersDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Post('/create')\n  async create(@Body() createUsersDto: CreateUsersDto) {\n    return this.usersService.create(createUsersDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Patch(':id')\n  async update(@Param() catchidUsersDto: IdUsersDto, @Body() updateUsersDto: UpdateUsersDto) {\n    console.log('update route called with:', catchidUsersDto, updateUsersDto);\n    return this.usersService.update(catchidUsersDto, updateUsersDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Delete(':id')\n  async remove(@Param() deleteUsersDto: DeleteUsersDto) {\n    return this.usersService.remove(deleteUsersDto);\n  }\n}", "export class UsersController {\n  constructor(private readonly usersService: UsersService) { }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('/')\n  async findAll() {\n    return this.usersService.findAll();\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get(':id')\n  async findOne(@Param() idUsersDto: IdUsersDto) {\n    return this.usersService.findOne(idUsersDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Post('/create')\n  async create(@Body() createUsersDto: CreateUsersDto) {\n    return this.usersService.create(createUsersDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Patch(':id')\n  async update(@Param() catchidUsersDto: IdUsersDto, @Body() updateUsersDto: UpdateUsersDto) {\n    console.log('update route called with:', catchidUsersDto, updateUsersDto);\n    return this.usersService.update(catchidUsersDto, updateUsersDto);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Delete(':id')\n  async remove(@Param() deleteUsersDto: DeleteUsersDto) {\n    return this.usersService.remove(deleteUsersDto);\n  }\n}"]}
{"filename": "src/users/models/index.ts", "chunked_list": ["export * from './users.model';"]}
{"filename": "src/users/models/users.model.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type UsersDocument = Users & Document;\n\n@Schema()\nexport class Users {\n  @Prop()\n  name: string;\n\n  @Prop()\n  lastname: string;\n\n  @Prop()\n  patronymic: string;\n\n  @Prop()\n  email: string;\n\n  @Prop()\n  password: string;\n\n  @Prop({ type: Number })\n  age: number;\n}\n\nexport const UsersSchema = SchemaFactory.createForClass(Users);"]}
{"filename": "src/users/dto/users-create.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString, IsEmail, IsInt } from 'class-validator';\n\nexport class CreateUsersDto {\n  @IsString()\n  @IsNotEmpty()\n  public name: string;\n\n  @IsString()\n  @IsNotEmpty()\n  public lastname: string;\n\n  @IsString()\n  @IsNotEmpty()\n  public patronymic: string;\n\n  @IsEmail()\n  @IsNotEmpty()\n  public email: string;\n\n  @IsInt()\n  @IsNotEmpty()\n  public age: number;\n}"]}
{"filename": "src/users/dto/users-update.dto.ts", "chunked_list": ["import { IsNotEmpty, IsOptional, IsString, IsEmail, IsInt, IsMongoId } from 'class-validator';\n\nexport class UpdateUsersDto {\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  public name: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  public lastname: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  public patronymic: string;\n\n  @IsEmail()\n  @IsOptional()\n  @IsNotEmpty()\n  public email: string;\n\n  @IsInt()\n  @IsOptional()\n  @IsNotEmpty()\n  public age: number;\n}"]}
{"filename": "src/users/dto/users-delete.dto.ts", "chunked_list": ["import { IsString, IsMongoId } from 'class-validator';\n\nexport class DeleteUsersDto {\n  @IsString()\n  @IsMongoId()\n  public id: string;\n}"]}
{"filename": "src/users/dto/index.ts", "chunked_list": ["export * from './users-create.dto';\nexport * from './users-delete.dto';\nexport * from './users-update.dto';\nexport * from './users-id.dto';"]}
{"filename": "src/users/dto/users-id.dto.ts", "chunked_list": ["import { IsString, IsMongoId } from 'class-validator';\n\nexport class IdUsersDto {\n  @IsString()\n  @IsMongoId()\n  public id: string;\n}"]}
{"filename": "src/auth/auth.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { AuthController } from './auth.controller';\nimport { AuthService } from './auth.service';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { Auth, AuthSchema } from './models';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { JwtStrategy } from '../strategy/jwt.strategy';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n", "import { ConfigModule, ConfigService } from '@nestjs/config';\n\n@Module({\n  imports: [\n    MongooseModule.forFeature([{ name: Auth.name, schema: AuthSchema }]),\n    PassportModule,\n    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        secret: configService.get('JWT_SECRET'),", "      useFactory: (configService: ConfigService) => ({\n        secret: configService.get('JWT_SECRET'),\n        signOptions: { expiresIn: configService.get('JWT_EXPIRES_IN') },\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [AuthService, JwtStrategy],\n})\nexport class AuthModule { }", "  providers: [AuthService, JwtStrategy],\n})\nexport class AuthModule { }"]}
{"filename": "src/auth/auth.controller.ts", "chunked_list": ["import { Controller, Post, Get, Body, Request, Param, UseGuards } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { SignAuthDto, LoginAuthDto, ConfirmAuthDto } from './dto';\nimport { ThrottlerGuard } from '@nestjs/throttler';\n\n@UseGuards(ThrottlerGuard) \n@Controller('api/auth')\nexport class AuthController {\n    constructor(private readonly authService: AuthService) { }\n\n    @Post('/sign')\n    async sign(@Body() signAuthDto: SignAuthDto) {\n        return this.authService.sign(signAuthDto);\n    }\n\n    @Post('/login')\n    async login(@Body() loginAuthDto: LoginAuthDto, @Request() req) {\n        return this.authService.login(loginAuthDto);\n    }\n\n    @Get('confirm/:token')\n    async confirm(@Param() confirmAuthDto: ConfirmAuthDto) {\n        return this.authService.confirm(confirmAuthDto);\n    }\n}"]}
{"filename": "src/auth/auth.service.ts", "chunked_list": ["import { Injectable, ConflictException, UnauthorizedException, NotFoundException, } from '@nestjs/common';\nimport { TokenExpiredError } from 'jsonwebtoken';\nimport { Model } from 'mongoose';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Auth } from './models/auth.model';\nimport { LoginAuthDto, SignAuthDto, ConfirmAuthDto } from './dto'\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport * as argon2 from 'argon2';\n\ninterface AuthResponse {\n    status: string;\n}\n\n@Injectable()", "import * as argon2 from 'argon2';\n\ninterface AuthResponse {\n    status: string;\n}\n\n@Injectable()\nexport class AuthService {\n    constructor(\n        @InjectModel(Auth.name) private AuthModel: Model<Auth>,\n        private jwtService: JwtService,\n    ) {}\n\n    async sign(SignAuthDto: SignAuthDto): Promise<object> {\n        // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0441 \u0442\u0430\u043a\u0438\u043c \u0436\u0435 \u0430\u0434\u0440\u0435\u0441\u043e\u043c \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u043d\u043d\u043e\u0439 \u043f\u043e\u0447\u0442\u044b\n        const existingUser = await this.AuthModel.findOne({ email: SignAuthDto.email });", "        if (existingUser) {\n            throw new ConflictException('Email already exists');\n        }\n\n        // \u0425\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u043e\u043b\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e argon2i\n        const hashedPassword = await argon2.hash(SignAuthDto.password, { type: argon2.argon2i });\n\n        // \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0445\u0435\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \u043f\u0430\u0440\u043e\u043b\u0435\u043c\n        const createdAuth = new this.AuthModel({ ...SignAuthDto, password: hashedPassword });\n        const result = await createdAuth.save();\n\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430 JWT\n        const token = this.jwtService.sign({ id: result._id }, { expiresIn: '30d' });\n\n        // \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430 \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445\n        result.token = token;\n        await result.save();\n\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430 \u0434\u043b\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0441 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0435\u0439 \u0438 \u0441\u0440\u043e\u043a\u043e\u043c \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f\n        const confirmtoken = this.jwtService.sign(\n            { id: result._id, type: 'confirmation', email: SignAuthDto.email },\n            { expiresIn: '7d' },\n        );\n\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0441\u044b\u043b\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438\n        const confirmationLink = `http://localhost:${new ConfigService().get('PORT')}/api/auth/confirm/${confirmtoken}`;\n\n        return { access_token: token, link: confirmationLink };\n    }\n\n    async login(LoginAuthDto: LoginAuthDto): Promise<object> {\n        // \u041f\u043e\u0438\u0441\u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u043d\u043d\u043e\u0439 \u043f\u043e\u0447\u0442\u044b\n        const user = await this.AuthModel.findOne({ email: LoginAuthDto.email });", "        if (!user) {\n            throw new UnauthorizedException('Invalid email or password');\n        }\n\n        // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u0435\u0439 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e argon2.verify()\n        const passwordMatch = await argon2.verify(user.password, LoginAuthDto.password);\n        if (!passwordMatch) {\n            throw new UnauthorizedException('Invalid email or password');\n        }\n\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u0430 JWT\n        const token = this.jwtService.sign({ id: user._id });\n\n        return { access_token: token };\n    }\n\n    async confirm(confirmAuthDto: ConfirmAuthDto): Promise<object> {\n        let payload: { id: any; };", "        try {\n            // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0442\u043e\u043a\u0435\u043d\u0430 JWT\n            payload = this.jwtService.verify(confirmAuthDto.token);\n        } catch (error) {\n            if (error instanceof TokenExpiredError) {\n                throw new UnauthorizedException('Token expired');\n            } else {\n                throw new UnauthorizedException('Invalid token');\n            }\n        }\n\n        // \u041f\u043e\u0438\u0441\u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0443 \u0438\u0437 \u0442\u043e\u043a\u0435\u043d\u0430\n        const user = await this.AuthModel.findById(payload.id);", "        if (!user) {\n            throw new NotFoundException('User not found');\n        }\n\n        // \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0430\u0442\u0443\u0441\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043d\u0430 \"\u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u043d\u044b\u0439\"\n        user.confirmed = true;\n        await user.save();\n\n        return { status: 'Confirmed' };\n    }\n\n    CheckAuth(): AuthResponse {\n        return { status: \"OK\" };\n    }\n}"]}
{"filename": "src/auth/models/auth.model.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { HydratedDocument } from 'mongoose';\n\nexport type AuthDocument = HydratedDocument<Auth>;\n\n@Schema()\nexport class Auth {\n  @Prop()\n  name: string;\n\n  @Prop()\n  lastname: string;\n\n  @Prop()\n  email: string;\n\n  @Prop()\n  password: string;\n\n  @Prop()\n  token: string;\n\n  @Prop({ default: false })\n  confirmed: boolean;\n}\n\nexport const AuthSchema = SchemaFactory.createForClass(Auth);"]}
{"filename": "src/auth/models/index.ts", "chunked_list": ["export * from './auth.model';"]}
{"filename": "src/auth/dto/auth-sign.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString, IsEmail } from 'class-validator';\n\nexport class SignAuthDto {\n    @IsString()\n    @IsNotEmpty()\n    public name: string;\n\n    @IsString()\n    @IsNotEmpty()\n    public lastname: string;\n\n    @IsString()\n    @IsNotEmpty()\n    @IsEmail()\n    public email: string;\n\n    @IsString()\n    @IsNotEmpty()\n    public password: string;\n  }"]}
{"filename": "src/auth/dto/index.ts", "chunked_list": ["export * from './auth-sign.dto';\nexport * from './auth-login.dto';\nexport * from './auth-confirm.dto';"]}
{"filename": "src/auth/dto/auth-login.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString, IsEmail } from 'class-validator';\n\nexport class LoginAuthDto {\n    @IsString()\n    @IsNotEmpty()\n    @IsEmail()\n    public email: string;\n\n    @IsString()\n    @IsNotEmpty()\n    public password: string;\n  }"]}
{"filename": "src/auth/dto/auth-confirm.dto.ts", "chunked_list": ["import { IsString, IsNotEmpty, MaxLength } from 'class-validator';\n\nexport class ConfirmAuthDto {\n    @IsString()\n    @IsNotEmpty()\n    @MaxLength(300)\n    public token: string;\n}"]}
{"filename": "src/guards/jwt-auth.guards.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}"]}
