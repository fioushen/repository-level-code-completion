{"filename": "src/GroupSection.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { GroupSection } from \"./GroupSection\";\nimport { TextSection } from \"./TextSection\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"GroupSection\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();", "    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a GroupSection\", () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            assert.equal(section.sections.length, 1);", "            ]);\n            assert.equal(section.sections.length, 1);\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\\n\");\n        });\n\n        it(\"should create a GroupSection with a custom params\", () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")", "            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")\n            ], 'user', 100, false, \" \");\n            assert.equal(section.sections.length, 1);\n            assert.equal(section.role, 'user');\n            assert.equal(section.tokens, 100);\n            assert.equal(section.required, false);\n            assert.equal(section.separator, \" \");\n        });\n    });", "        });\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a TextSection to an array of messages\", async () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);", "            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a output as being too long\", async () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")\n            ]);", "                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should render multiple TextSections as a single messages\", async () => {\n            const section = new GroupSection([", "        it(\"should render multiple TextSections as a single messages\", async () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello\", \"user\"),\n                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello\\n\\nWorld\" }]);\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });", "            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render a hierarchy of sections to a single message\", async () => {\n            const section = new GroupSection([\n                new GroupSection([\n                    new TextSection(\"Hello\", \"user\")\n                ]),\n                new TextSection(\"World\", \"user\")\n            ]);", "                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello\\n\\nWorld\" }]);\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"renderAsText\", () => {", "\n    describe(\"renderAsText\", () => {\n        it(\"should render a TextSection to a string\", async () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);", "            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a text output as being too long\", async () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"Hello World\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should render multiple TextSections to a string\", async () => {\n            const section = new GroupSection([\n                new TextSection(\"Hello\", \"user\"),\n                new TextSection(\"World\", \"user\")", "                new TextSection(\"Hello\", \"user\"),\n                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render a hierarchy of sections to a string\", async () => {", "\n        it(\"should render a hierarchy of sections to a string\", async () => {\n            const section = new GroupSection([\n                new GroupSection([\n                    new TextSection(\"Hello\", \"user\")\n                ]),\n                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n});\n"]}
{"filename": "src/ConversationHistory.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\nimport { Utilities } from \"./Utilities\";\n\n/**\n * A section that renders the conversation history.\n */\nexport class ConversationHistory extends PromptSectionBase {\n    public readonly variable: string;\n    public readonly userPrefix: string;\n    public readonly assistantPrefix: string;\n\n    /**\n     * Creates a new 'ConversationHistory' instance.\n     * @param variable Name of memory variable used to store the histories `Message[]`.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `proportional` with a value of `1.0`.\n     * @param required Optional. Indicates if this section is required. Defaults to `false`.\n     * @param userPrefix Optional. Prefix to use for user messages when rendering as text. Defaults to `user: `.\n     * @param assistantPrefix Optional. Prefix to use for assistant messages when rendering as text. Defaults to `assistant: `.\n     */\n    public constructor(variable: string, tokens: number = 1.0, required: boolean = false, userPrefix: string = 'user: ', assistantPrefix: string = 'assistant: ', separator: string = '\\n') {\n        super(tokens, required, separator);\n        this.variable = variable;\n        this.userPrefix = userPrefix;\n        this.assistantPrefix = assistantPrefix;\n    }\n\n    public async renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>> {\n      // Get messages from memory\n      const history: Message[] = memory.has(this.variable) ? (memory.get(this.variable) as Message[]).slice() : [];\n\n      // Populate history and stay under the token budget\n      let tokens = 0;\n      const budget = this.tokens > 1.0 ? Math.min(this.tokens, maxTokens) : maxTokens;\n      const separatorLength = tokenizer.encode(this.separator).length;\n      const lines: string[] = [];", "      for (let i = history.length - 1; i >= 0; i--) {\n          const msg = history[i];\n            const message: Message = { role: msg.role, content: Utilities.toString(tokenizer, msg.content) };\n          const prefix = message.role === 'user' ? this.userPrefix : this.assistantPrefix;\n          const line = prefix + message.content;\n          const length = tokenizer.encode(line).length + (lines.length > 0 ? separatorLength : 0);\n\n          // Add initial line if required\n          if (lines.length === 0 && this.required) {\n              tokens += length;\n              lines.unshift(line);\n              continue;\n          }\n\n          // Stop if we're over the token budget", "          if (lines.length === 0 && this.required) {\n              tokens += length;\n              lines.unshift(line);\n              continue;\n          }\n\n          // Stop if we're over the token budget\n          if (tokens + length > budget) {\n              break;\n          }\n\n          // Add line\n          tokens += length;\n          lines.unshift(line);\n      }\n\n      return { output: lines.join(this.separator), length: tokens, tooLong: tokens > maxTokens };\n   }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Get messages from memory\n        const history: Message[] = memory.has(this.variable) ? (memory.get(this.variable) as Message[]).slice() : [];\n\n        // Populate messages and stay under the token budget\n        let tokens = 0;\n        const budget = this.tokens > 1.0 ? Math.min(this.tokens, maxTokens) : maxTokens;\n        const messages: Message[] = [];", "        for (let i = history.length - 1; i >= 0; i--) {\n            // Clone message\n            const msg = history[i];\n            const message: Message = Object.assign({}, msg);\n            if (msg.content !== null) {\n                message.content = Utilities.toString(tokenizer, msg.content);\n            }\n\n            // Get message length\n            const length = tokenizer.encode(PromptSectionBase.getMessageText(message)).length;\n\n            // Add initial message if required", "            if (messages.length === 0 && this.required) {\n                tokens += length;\n                messages.unshift(message);\n                continue;\n            }\n\n            // Stop if we're over the token budget\n            if (tokens + length > budget) {\n                break;\n            }\n\n            // Add message\n            tokens += length;\n            messages.unshift(message);\n        }\n\n        return { output: messages, length: tokens, tooLong: tokens > maxTokens };\n    }\n}"]}
{"filename": "src/FunctionRegistry.ts", "chunked_list": ["import { PromptFunctions, PromptFunction, PromptMemory, Tokenizer } from \"./types\";\n\n/**\n * Registry of functions that can be invoked from a prompt template.\n */\nexport class FunctionRegistry implements PromptFunctions {\n    private readonly _functions: Map<string, PromptFunction> = new Map<string, PromptFunction>();\n\n    /**\n     * Creates a new 'FunctionRegistry' instance.\n     * @param functions Optional. Functions to add to this registry.\n     */\n    public constructor(functions?: Record<string, PromptFunction>) {", "        if (functions) {\n            for (const key in functions) {\n                this._functions.set(key, functions[key]);\n            }\n        }\n    }\n\n    public has(name: string): boolean {\n        return this._functions.has(name);\n    }\n\n    public get(name: string): PromptFunction {\n        const fn = this._functions.get(name);", "        if (!fn) {\n            throw new Error(`Function '${name}' not found.`);\n        }\n\n        return fn;\n    }\n\n    public addFunction(name: string, value: PromptFunction): void {\n        if (this._functions.has(name)) {\n            throw new Error(`Function '${name}' already exists.`);\n        }\n\n        this._functions.set(name, value);\n    }\n\n    public invoke(key: string, memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: string[]): Promise<any> {\n        const fn = this.get(key);\n        return fn(memory, functions, tokenizer, args);\n    }\n}", "        if (this._functions.has(name)) {\n            throw new Error(`Function '${name}' already exists.`);\n        }\n\n        this._functions.set(name, value);\n    }\n\n    public invoke(key: string, memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: string[]): Promise<any> {\n        const fn = this.get(key);\n        return fn(memory, functions, tokenizer, args);\n    }\n}"]}
{"filename": "src/SystemMessage.ts", "chunked_list": ["import { TemplateSection } from \"./TemplateSection\";\n\n/**\n * A system message.\n */\nexport class SystemMessage extends TemplateSection {\n    /**\n     * Creates a new 'SystemMessage' instance.\n     * @param template Template to use for this section.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     */\n    public constructor(template: string, tokens: number = -1) {\n        super(template, 'system', tokens, true, '\\n', '');\n    }\n}"]}
{"filename": "src/UserMessage.ts", "chunked_list": ["import { TemplateSection } from \"./TemplateSection\";\n\n/**\n * A user message.\n */\nexport class UserMessage extends TemplateSection {\n    /**\n     * Creates a new 'UserMessage' instance.\n     * @param template Template to use for this section.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param userPrefix Optional. Prefix to use for user messages when rendering as text. Defaults to `user: `.\n     */\n    public constructor(template: string, tokens: number = -1, userPrefix: string = 'user: ') {\n        super(template, 'user', tokens, true, '\\n', userPrefix);\n    }\n}"]}
{"filename": "src/Prompt.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { LayoutEngine } from \"./LayoutEngine\";\n/**\n * Top level prompt section.\n * @remarks\n * Prompts are compositional such that they can be nested to create complex prompt hierarchies.\n */\nexport class Prompt extends LayoutEngine {\n    /**\n     * Creates a new 'Prompt' instance.\n     * @param sections Sections to render.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n\\n`.\n     */\n    public constructor(sections: PromptSection[], tokens: number = -1, required: boolean = true, separator: string = '\\n\\n') {\n        super(sections, tokens, required, separator);\n    }\n}\n"]}
{"filename": "src/LayoutEngine.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\n\n/**\n * Base layout engine that renders a set of `auto`, `fixed`, or `proportional` length sections.\n * @remarks\n * This class is used internally by the `Prompt` and `GroupSection` classes to render their sections.\n */\nexport class LayoutEngine implements PromptSection {\n    public readonly sections: PromptSection[];\n    public readonly required: boolean;\n    public readonly tokens: number;\n    public readonly separator: string;\n\n    public constructor(sections: PromptSection[], tokens: number, required: boolean, separator: string) {\n        this.sections = sections;\n        this.required = required;\n        this.tokens = tokens;\n        this.separator = separator;\n    }\n\n    public async renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>> {\n        // Start a new layout\n        // - Adds all sections from the current LayoutEngine hierarchy to a flat array\n        const layout: PromptSectionLayout<string>[] = [];\n        this.addSectionsToLayout(this.sections, layout);\n\n        // Layout sections\n        const remaining = await this.layoutSections(\n            layout,\n            maxTokens,\n            (section) => section.renderAsText(memory, functions, tokenizer, maxTokens),\n            (section, remaining) => section.renderAsText(memory, functions, tokenizer, remaining),\n            true,\n            tokenizer\n        );\n\n        // Build output\n        const output: string[] = [];", "        for (let i = 0; i < layout.length; i++) {\n            const section = layout[i];\n            if (section.layout) {\n                output.push(section.layout.output);\n            }\n        }\n\n        const text = output.join(this.separator);\n        return { output: text, length: tokenizer.encode(text).length, tooLong: remaining < 0 };\n    }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Start a new layout\n        // - Adds all sections from the current LayoutEngine hierarchy to a flat array\n        const layout: PromptSectionLayout<Message[]>[] = [];\n        this.addSectionsToLayout(this.sections, layout);\n\n        // Layout sections\n        const remaining = await this.layoutSections(\n            layout,\n            maxTokens,\n            (section) => section.renderAsMessages(memory, functions, tokenizer, maxTokens),\n            (section, remaining) => section.renderAsMessages(memory, functions, tokenizer, remaining)\n        );\n\n        // Build output\n        const output: Message[] = [];", "        for (let i = 0; i < layout.length; i++) {\n            const section = layout[i];\n            if (section.layout) {\n                output.push(...section.layout.output);\n            }\n        }\n\n        return { output: output, length: this.getLayoutLength(layout), tooLong: remaining < 0 };\n    }\n\n    private addSectionsToLayout<T>(sections: PromptSection[], layout: PromptSectionLayout<T>[]): void {", "        for (let i = 0; i < sections.length; i++) {\n            const section = sections[i];\n            if (section instanceof LayoutEngine) {\n                this.addSectionsToLayout(section.sections, layout);\n            } else {\n                layout.push({ section: section });\n            }\n        }\n    }\n\n    private async layoutSections<T>(\n        layout: PromptSectionLayout<T>[],\n        maxTokens: number,\n        cbFixed: (section: PromptSection) => Promise<RenderedPromptSection<T>>,\n        cbProportional: (section: PromptSection, remaining: number) => Promise<RenderedPromptSection<T>>,\n        textLayout: boolean = false,\n        tokenizer?: Tokenizer\n    ): Promise<number> {\n        // Layout fixed sections\n        await this.layoutFixedSections(layout, cbFixed);\n\n        // Get tokens remaining and drop optional sections if too long\n        let remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);", "        while (remaining < 0 && this.dropLastOptionalSection(layout)) {\n            remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);\n        }\n\n        // Layout proportional sections\n        if (this.needsMoreLayout(layout) && remaining > 0) {\n            // Layout proportional sections\n            await this.layoutProportionalSections(layout, (section) => cbProportional(section, remaining));\n\n            // Get tokens remaining and drop optional sections if too long\n            remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);", "            while (remaining < 0 && this.dropLastOptionalSection(layout)) {\n                remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);\n            }\n        }\n\n        return remaining;\n    }\n\n    private async layoutFixedSections<T>(layout: PromptSectionLayout<T>[], callback: (section: PromptSection) => Promise<RenderedPromptSection<T>>): Promise<void> {\n        const promises: Promise<RenderedPromptSection<T>>[] = [];\n        for (let i = 0; i < layout.length; i++) {\n            const section = layout[i];", "        for (let i = 0; i < layout.length; i++) {\n            const section = layout[i];\n            if (section.section.tokens < 0 || section.section.tokens > 1.0) {\n                promises.push(callback(section.section).then((output) => section.layout = output));\n            }\n        }\n\n        await Promise.all(promises);\n    }\n\n    private async layoutProportionalSections<T>(layout: PromptSectionLayout<T>[], callback: (section: PromptSection) => Promise<RenderedPromptSection<T>>): Promise<void> {\n        const promises: Promise<RenderedPromptSection<T>>[] = [];", "        for (let i = 0; i < layout.length; i++) {\n            const section = layout[i];\n            if (section.section.tokens >= 0.0 && section.section.tokens <= 1.0) {\n                promises.push(callback(section.section).then((output) => section.layout = output));\n            }\n        }\n\n        await Promise.all(promises);\n    }\n\n    private getLayoutLength<T>(layout: PromptSectionLayout<T>[], textLayout: boolean = false, tokenizer?: Tokenizer): number {", "        if (textLayout && tokenizer) {\n            const output: string[] = [];\n            for (let i = 0; i < layout.length; i++) {\n                const section = layout[i];\n                if (section.layout) {\n                    output.push(section.layout.output as string);\n                }\n            }\n            return tokenizer.encode(output.join(this.separator)).length;\n        } else {\n            let length = 0;", "            for (let i = 0; i < layout.length; i++) {\n                const section = layout[i];\n                if (section.layout) {\n                    length += section.layout.length;\n                }\n            }\n\n            return length;\n        }\n    }\n\n    private dropLastOptionalSection<T>(layout: PromptSectionLayout<T>[]): boolean {", "        for (let i = layout.length - 1; i >= 0; i--) {\n            const section = layout[i];\n            if (!section.section.required) {\n                layout.splice(i, 1);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private needsMoreLayout<T>(layout: PromptSectionLayout<T>[]): boolean {", "        for (let i = 0; i < layout.length; i++) {\n            const section = layout[i];\n            if (!section.layout) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n", "interface PromptSectionLayout<T> {\n    section: PromptSection;\n    layout?: RenderedPromptSection<T>;\n}"]}
{"filename": "src/PromptSectionBase.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\n\nexport class TestSection extends PromptSectionBase {\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        return this.returnMessages([{ role: 'test', content: 'Hello Big World' }], 3, tokenizer, maxTokens);\n    }\n}\n", "export class TestSection extends PromptSectionBase {\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        return this.returnMessages([{ role: 'test', content: 'Hello Big World' }], 3, tokenizer, maxTokens);\n    }\n}\n\nexport class MultiTestSection extends PromptSectionBase {\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        return this.returnMessages([{ role: 'test', content: 'Hello Big' },{ role: 'test', content: 'World' }], 3, tokenizer, maxTokens);\n    }\n}\n\ndescribe(\"PromptSectionBase\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a TestSection\", () => {\n            const section = new TestSection();\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\");\n            assert.equal(section.textPrefix, \"\");\n        });\n\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a TestSection to an array of messages\", async () => {\n            const section = new TestSection();\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big World\" }]);\n            assert.equal(rendered.length, 3);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should truncate a fixed length TestSection\", async () => {\n            const section = new TestSection(2);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a fixed length TestSection as being tooLong\", async () => {\n            const section = new TestSection(2);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should drop messages to truncate a fixed length MultiTestSection\", async () => {\n            const section = new MultiTestSection(2);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"renderAsText\", () => {\n        it(\"should render a TestSection to a string\", async () => {\n            const section = new TestSection();\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello Big World\");\n            assert.equal(rendered.length, 3);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should truncate a fixed length TestSection\", async () => {\n            const section = new TestSection(4, true, \"\\n\", \"user: \");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"user: Hello Big\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a fixed length TestSection as being tooLong\", async () => {\n            const section = new TestSection(4, true, \"\\n\", \"user: \");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"user: Hello Big\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, true);\n        });\n    });\n});\n"]}
{"filename": "src/AssistantMessage.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { AssistantMessage } from \"./AssistantMessage\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"AssistantMessage\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();", "    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a AssistantMessage\", () => {\n            const section = new AssistantMessage(\"Hello World\");\n            assert.equal(section.template, \"Hello World\");\n            assert.equal(section.role, \"assistant\");\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);", "            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\");\n            assert.equal(section.textPrefix, \"assistant: \");\n        });\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a AssistantMessage to an array of messages\", async () => {\n            const section = new AssistantMessage(\"Hello World\");", "        it(\"should render a AssistantMessage to an array of messages\", async () => {\n            const section = new AssistantMessage(\"Hello World\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"assistant\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"renderAsText\", () => {", "\n    describe(\"renderAsText\", () => {\n        it(\"should render a TemplateSection to a string\", async () => {\n            const section = new AssistantMessage(\"Hello World\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"assistant: Hello World\");\n            assert.equal(rendered.length, 6);\n            assert.equal(rendered.tooLong, false);\n        });\n    });", "        });\n    });\n});\n"]}
{"filename": "src/TemplateSection.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\nimport { Utilities } from \"./Utilities\";\n\n/**\n * A template section that will be rendered as a message.\n * @remarks\n * This section type is used to render a template as a message. The template can contain\n * parameters that will be replaced with values from memory or call functions to generate\n * dynamic content.\n *\n * Template syntax:\n * - `{{$memoryKey}}` - Renders the value of the specified memory key.", " * - `{{functionName}}` - Calls the specified function and renders the result.\n * - `{{functionName arg1 arg2 ...}}` - Calls the specified function with the provided list of arguments.\n *\n * Function arguments are optional and separated by spaces. They can be quoted using `'`, `\"`, or `\\`` delimiters.\n */\nexport class TemplateSection extends PromptSectionBase {\n    private _parts: PartRenderer[] = [];\n\n    public readonly template: string;\n    public readonly role: string;\n\n    /**\n     * Creates a new 'TemplateSection' instance.\n     * @param template Template to use for this section.\n     * @param role Message role to use for this section.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n`.\n     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n     */\n    public constructor(template: string, role: string, tokens: number = -1, required: boolean = true, separator: string = '\\n', textPrefix?: string) {\n        super(tokens, required, separator, textPrefix);\n        this.template = template;\n        this.role = role;\n        this.parseTemplate();\n    }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Render parts in parallel\n        const renderedParts = await Promise.all(this._parts.map((part) => part(memory, functions, tokenizer, maxTokens)));\n\n        // Join all parts\n        const text = renderedParts.join('');\n        const length = tokenizer.encode(text).length;\n\n        // Return output\n        return this.returnMessages([{ role: this.role, content: text }], length, tokenizer, maxTokens);\n    }\n\n    private parseTemplate(): void {\n        // Parse template\n        let part = '';\n        let state = ParseState.inText;\n        let stringDelim = '';", "        for (let i = 0; i < this.template.length; i++) {\n            const char = this.template[i];\n            switch (state) {\n                case ParseState.inText:\n                    if (char === '{' && this.template[i + 1] === '{') {\n                        if (part.length > 0) {\n                            this._parts.push(this.createTextRenderer(part));\n                            part = '';\n                        }\n\n                        state = ParseState.inParameter;\n                        i++;\n                    } else {\n                        part += char;\n                    }\n                    break;\n                case ParseState.inParameter:", "                    if (char === '}' && this.template[i + 1] === '}') {\n                        if (part.length > 0) {\n                            if (part[0] === '$') {\n                                this._parts.push(this.createVariableRenderer(part.substring(1)));\n                            } else {\n                                this._parts.push(this.createFunctionRenderer(part));\n                            }\n                            part = '';\n                        }\n\n                        state = ParseState.inText;\n                        i++;", "                    } else if ([\"'\", '\"', '`'].includes(char)) {\n                        stringDelim = char;\n                        state = ParseState.inString;\n                        part += char;\n                    } else {\n                        part += char;\n                    }\n                    break;\n                case ParseState.inString:\n                    part += char;\n                    if (char === stringDelim) {\n                        state = ParseState.inParameter;\n                    }\n                    break;\n            }\n        }\n\n        // Ensure we ended in the correct state", "                    if (char === stringDelim) {\n                        state = ParseState.inParameter;\n                    }\n                    break;\n            }\n        }\n\n        // Ensure we ended in the correct state\n        if (state !== ParseState.inText) {\n            throw new Error(`Invalid template: ${this.template}`);\n        }\n\n        // Add final part", "        if (state !== ParseState.inText) {\n            throw new Error(`Invalid template: ${this.template}`);\n        }\n\n        // Add final part\n        if (part.length > 0) {\n            this._parts.push(this.createTextRenderer(part));\n        }\n    }\n\n    private createTextRenderer(text: string): PartRenderer {\n        return (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<string> => {\n            return Promise.resolve(text);\n        };\n    }\n\n    private createVariableRenderer(name: string): PartRenderer {\n        return (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<string> => {\n            const vaue = memory.get(name);\n            return Promise.resolve(Utilities.toString(tokenizer, vaue));\n        };\n    }\n\n    private createFunctionRenderer(param: string): PartRenderer {\n        let name = '';\n        let args: string[] = [];", "        function savePart() {\n            if (part.length > 0) {\n                if (!name) {\n                    name = part;\n                } else {\n                    args.push(part);\n                }\n                part = '';\n            }\n        }\n", "        // Parse function name and args\n        let part = '';\n        let state = ParseState.inText;\n        let stringDelim = '';\n        for (let i = 0; i < param.length; i++) {\n            const char = param[i];\n            switch (state) {\n                case ParseState.inText:\n                    if ([\"'\", '\"', '`'].includes(char)) {\n                        savePart();\n                        stringDelim = char;\n                        state = ParseState.inString;", "                    if ([\"'\", '\"', '`'].includes(char)) {\n                        savePart();\n                        stringDelim = char;\n                        state = ParseState.inString;\n                    } else if (char == ' ') {\n                        savePart();\n                    } else {\n                        part += char;\n                    }\n                    break;\n                case ParseState.inString:", "                    if (char === stringDelim) {\n                        savePart();\n                        state = ParseState.inText;\n                    } else {\n                        part += char;\n                    }\n                    break;\n            }\n        }\n\n        // Add final part\n        savePart();\n\n        // Return renderer\n        return async (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<string> => {\n            const value = await functions.invoke(name, memory, functions, tokenizer, args);\n            return Utilities.toString(tokenizer, value);\n        };\n    }\n\n}\n", "type PartRenderer = (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number) => Promise<string>;\n\nenum ParseState {\n    inText,\n    inParameter,\n    inString\n}"]}
{"filename": "src/types.ts", "chunked_list": ["\nexport interface PromptSection {\n    /**\n     * If true the section is mandatory otherwise it can be safely dropped.\n     */\n    readonly required: boolean;\n\n    /**\n     * The requested token budget for this section.\n     * - Values between 0.0 and 1.0 represent a percentage of the total budget and the section will be layed out proportionally to all other sections.\n     * - Values greater than 1.0 represent the max number of tokens the section should be allowed to consume.\n     */\n    readonly tokens: number;\n\n    /**\n     * Renders the section as a string of text.\n     * @param memory Memory that can be referenced by the section.\n     * @param functions Registry of functions that can be used by the section.\n     * @param tokenizer Tokenizer to use when rendering the section.\n     * @param maxTokens Maximum number of tokens allowed to be rendered.\n     */\n    renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>>;\n\n    /**\n     * Renders the section as a list of messages.\n     * @param memory Memory that can be referenced by the section.\n     * @param functions Registry of functions that can be used by the section.\n     * @param tokenizer Tokenizer to use when rendering the section.\n     * @param maxTokens Maximum number of tokens allowed to be rendered.\n     */\n    renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>>;\n}\n", "export interface RenderedPromptSection<T> {\n    /**\n     * The section that was rendered.\n     */\n    output: T;\n\n    /**\n     * The number of tokens that were rendered.\n     */\n    length: number;\n\n    /**\n     * If true the section was truncated because it exceeded the maxTokens budget.\n     */\n    tooLong: boolean;\n}\n", "export interface Message<TContent = string> {\n    /**\n     * The messages role. Typically 'system', 'user', 'assistant', 'function'.\n     */\n    role: string;\n\n    /**\n     * Text of the message.\n     */\n    content: TContent|null;\n\n    /**", "     * Optional. A named function to call.\n     */\n    function_call?: FunctionCall;\n\n    /**\n     * Optional. Name of the function that was called.\n     */\n    name?: string;\n}\n\nexport interface FunctionCall {\n    name?: string;\n    arguments?: string;\n}\n", "export interface FunctionCall {\n    name?: string;\n    arguments?: string;\n}\n\nexport interface PromptMemory {\n    has(key: string): boolean;\n    get<TValue = any>(key: string): TValue;\n    set<TValue = any>(key: string, value: TValue): void;\n    delete(key: string): void;\n    clear(): void;\n}\n", "export interface PromptFunctions {\n    has(name: string): boolean;\n    get(name: string): PromptFunction;\n    invoke(name: string, memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: string[]): Promise<any>;\n}\n\nexport interface Tokenizer {\n    decode(tokens: number[]): string;\n    encode(text: string): number[];\n}\n", "export type PromptFunction<TArgs = any> = (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: TArgs) => Promise<any>;"]}
{"filename": "src/VolatileMemory.ts", "chunked_list": ["import { PromptMemory } from \"./types\";\n\n/**\n * An in-memory store that lives for the length of the process.\n */\nexport class VolatileMemory implements PromptMemory {\n    private readonly _memory: Map<string, any> = new Map<string, any>();\n\n    /**\n     * Creates a new 'VolatileMemory' instance.\n     * @param memory Optional. Variables to initialize this instance with.\n     */\n    public constructor(memory?: Record<string, any>) {", "        if (memory) {\n            for (const key in memory) {\n                this._memory.set(key, memory[key]);\n            }\n        }\n    }\n\n    public has(key: string): boolean {\n        return this._memory.has(key);\n    }\n\n    public get(key: string): any {\n        const value = this._memory.get(key);", "        if (value !== null && typeof value === \"object\") {\n            return JSON.parse(JSON.stringify(value));\n        } else {\n            return value;\n        }\n    }\n\n    public set(key: string, value: any): void {\n        if (value !== null && typeof value === \"object\") {\n            const clone = JSON.parse(JSON.stringify(value));\n            this._memory.set(key, clone);\n        } else {\n            this._memory.set(key, value);\n        }\n    }\n\n    public delete(key: string): void {\n        this._memory.delete(key);\n    }\n\n    public clear(): void {\n        this._memory.clear();\n    }\n}", "        if (value !== null && typeof value === \"object\") {\n            const clone = JSON.parse(JSON.stringify(value));\n            this._memory.set(key, clone);\n        } else {\n            this._memory.set(key, value);\n        }\n    }\n\n    public delete(key: string): void {\n        this._memory.delete(key);\n    }\n\n    public clear(): void {\n        this._memory.clear();\n    }\n}"]}
{"filename": "src/Prompt.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { Prompt } from \"./Prompt\";\nimport { TextSection } from \"./TextSection\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"Prompt\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();", "    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a Prompt\", () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            assert.equal(prompt.sections.length, 1);", "            ]);\n            assert.equal(prompt.sections.length, 1);\n            assert.equal(prompt.tokens, -1);\n            assert.equal(prompt.required, true);\n            assert.equal(prompt.separator, \"\\n\\n\");\n        });\n\n        it(\"should create a Prompt with a custom params\", () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")", "            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")\n            ], 100, false, \" \");\n            assert.equal(prompt.sections.length, 1);\n            assert.equal(prompt.tokens, 100);\n            assert.equal(prompt.required, false);\n            assert.equal(prompt.separator, \" \");\n        });\n    });\n", "    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a TextSection to an array of messages\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);", "            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a output as being too long\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 1);", "            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should render multiple TextSections to an array of messages\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\"),", "            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\"),\n                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello\" }, { role: \"user\", content: \"World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render a hierarchy of prompts to an array of messages\", async () => {\n            const prompt = new Prompt([\n                new Prompt([\n                    new TextSection(\"Hello\", \"user\")\n                ]),\n                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);", "            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello\" }, { role: \"user\", content: \"World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"renderAsText\", () => {\n        it(\"should render a TextSection to a string\", async () => {", "    describe(\"renderAsText\", () => {\n        it(\"should render a TextSection to a string\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });", "            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a text output as being too long\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);", "            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should render multiple TextSections to a string\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\"),\n                new TextSection(\"World\", \"user\")\n            ]);", "                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render a hierarchy of prompts to a string\", async () => {\n            const prompt = new Prompt([", "        it(\"should render a hierarchy of prompts to a string\", async () => {\n            const prompt = new Prompt([\n                new Prompt([\n                    new TextSection(\"Hello\", \"user\")\n                ]),\n                new TextSection(\"World\", \"user\")\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);", "            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"proportional rendering\", () => {\n        it(\"should render both fixed and proportional sections as messages\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),", "            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),\n                new TextSection(\"There Big\", \"user\", 1.0, false),\n                new TextSection(\"World\", \"user\", 10, true)\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [\n                { role: \"user\", content: \"Hello\" },\n                { role: \"user\", content: \"There Big\" },\n                { role: \"user\", content: \"World\" }", "                { role: \"user\", content: \"There Big\" },\n                { role: \"user\", content: \"World\" }\n            ]);\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render both fixed and proportional sections as text\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),", "            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),\n                new TextSection(\"There Big\", \"user\", 1.0, false),\n                new TextSection(\"World\", \"user\", 10, true)\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello\\n\\nThere Big\\n\\nWorld\");\n            assert.equal(rendered.length, 8);\n            assert.equal(rendered.tooLong, false);\n        });", "            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render only fixed sections\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),\n                new TextSection(\"World\", \"user\", 10, true)\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 2);\n            assert.deepEqual(rendered.output, [", "            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 2);\n            assert.deepEqual(rendered.output, [\n                { role: \"user\", content: \"Hello\" },\n                { role: \"user\", content: \"World\" }\n            ]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should drop optional sections as needed\", async () => {", "\n        it(\"should drop optional sections as needed\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),\n                new TextSection(\"There Big\", \"user\", 0.5, false),\n                new TextSection(\"World\", \"user\", 0.5, true)\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 4);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);", "            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should drop multiple optional sections as needed\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),\n                new TextSection(\"There\", \"user\", 10, false),\n                new TextSection(\"Big\", \"user\", 10, false),", "                new TextSection(\"There\", \"user\", 10, false),\n                new TextSection(\"Big\", \"user\", 10, false),\n                new TextSection(\"World\", \"user\", 10, true)\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 2);\n            assert.deepEqual(rendered.output, [\n                { role: \"user\", content: \"Hello\" },\n                { role: \"user\", content: \"World\" }\n            ]);\n            assert.equal(rendered.length, 2);", "            ]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should keep required sections even if too long\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello\", \"user\", 10, true),\n                new TextSection(\"There Big\", \"user\", 0.5, false),\n                new TextSection(\"World\", \"user\", 0.5, true)", "                new TextSection(\"There Big\", \"user\", 0.5, false),\n                new TextSection(\"World\", \"user\", 0.5, true)\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 2);\n            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should skip rendering proportional sections if fixed sections too big\", async () => {", "\n        it(\"should skip rendering proportional sections if fixed sections too big\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello There\", \"user\", 10, true),\n                new TextSection(\"Big\", \"user\", 0.5, true),\n                new TextSection(\"World\", \"user\", 0.5, true)\n            ]);\n            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"Hello There\");\n            assert.equal(rendered.length, 2);", "            assert.equal(rendered.output, \"Hello There\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should skip rendering proportional sections if fixed sections too big for messages\", async () => {\n            const prompt = new Prompt([\n                new TextSection(\"Hello There\", \"user\", 10, true),\n                new TextSection(\"Big\", \"user\", 0.5, true),\n                new TextSection(\"World\", \"user\", 0.5, true)", "                new TextSection(\"Big\", \"user\", 0.5, true),\n                new TextSection(\"World\", \"user\", 0.5, true)\n            ]);\n            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello There\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n    });\n});", "    });\n});\n"]}
{"filename": "src/FunctionRegistry.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"FunctionRegistry\", () => {\n    describe(\"constructor\", () => {\n        it(\"should create a FunctionRegistry\", () => {\n            const registry = new FunctionRegistry();\n            assert.notEqual(registry, null);", "            const registry = new FunctionRegistry();\n            assert.notEqual(registry, null);\n            assert.equal(registry.has(\"test\"), false);\n        });\n\n        it(\"should create a FunctionRegistry with initial functions\", () => {\n            const registry = new FunctionRegistry({\n                \"test\": async (memory, functions, tokenizer, args) => { }\n            });\n            assert.notEqual(registry, null);", "            });\n            assert.notEqual(registry, null);\n            assert.equal(registry.has(\"test\"), true);\n        });\n    });\n\n    describe(\"addFunction\", () => {\n        it(\"should add a function\", () => {\n            const registry = new FunctionRegistry();\n            registry.addFunction(\"test\", async (memory, functions, tokenizer, args) => { });", "            const registry = new FunctionRegistry();\n            registry.addFunction(\"test\", async (memory, functions, tokenizer, args) => { });\n            assert.equal(registry.has(\"test\"), true);\n        });\n\n        it(\"should throw when adding a function that already exists\", () => {\n            const registry = new FunctionRegistry({\n                \"test\": async (memory, functions, tokenizer, args) => { }\n            });\n            assert.throws(() => registry.addFunction(\"test\", async (memory, functions, tokenizer, args) => { }));\n        });\n    });\n\n    describe(\"get\", () => {\n        it(\"should get a function\", () => {\n            const registry = new FunctionRegistry({\n                \"test\": async (memory, functions, tokenizer, args) => { }\n            });\n            const fn = registry.get(\"test\");\n            assert.notEqual(fn, null);\n        });\n", "        it(\"should throw when getting a function that doesn't exist\", () => {\n            const registry = new FunctionRegistry();\n            assert.throws(() => registry.get(\"test\"));\n        });\n    });\n\n    describe(\"has\", () => {\n        it(\"should return false when a function doesn't exist\", () => {\n            const registry = new FunctionRegistry();\n            assert.equal(registry.has(\"test\"), false);\n        });\n", "        it(\"should return true when a function exists\", () => {\n            const registry = new FunctionRegistry({\n                \"test\": async (memory, functions, tokenizer, args) => { }\n            });\n            assert.equal(registry.has(\"test\"), true);\n        });\n    });\n\n    describe(\"invoke\", () => {\n        const memory = new VolatileMemory();\n        const tokenizer = new GPT3Tokenizer();\n\n        it(\"should invoke a function\", async () => {\n            let called = false;\n            const registry = new FunctionRegistry({\n                \"test\": async (memory, functions, tokenizer, args) => {\n                    assert.equal(args.length, 1);\n                    assert.equal(args[0], \"Hello World\");\n                    called = true;\n                }\n            });\n            await registry.invoke(\"test\", memory, registry, tokenizer, [\"Hello World\"]);\n            assert.equal(called, true);\n        });\n", "        it(\"should throw when invoking a function that doesn't exist\", () => {\n            const registry = new FunctionRegistry();\n            assert.throws(() => registry.invoke(\"test\", memory, registry, tokenizer, [\"Hello World\"]));\n        });\n    });\n});\n"]}
{"filename": "src/VolatileMemory.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { VolatileMemory } from \"./VolatileMemory\";\n\ndescribe(\"VolatileMemory\", () => {\n    describe(\"constructor\", () => {\n        it(\"should create a VolatileMemory\", () => {\n            const memory = new VolatileMemory();\n            assert.notEqual(memory, null);\n        });\n", "        });\n\n        it(\"should create a VolatileMemory with initial values\", () => {\n            const memory = new VolatileMemory({\n                \"test\": 123\n            });\n            assert.notEqual(memory, null);\n            assert.equal(memory.has(\"test\"), true);\n        });\n    });", "        });\n    });\n\n    const obj = { foo: 'bar' };\n    const memory = new VolatileMemory();\n    describe(\"set\", () => {\n        it(\"should set a primitive value\", () => {\n            memory.set(\"test\", 123);\n            assert.equal(memory.has(\"test\"), true);\n        });", "            assert.equal(memory.has(\"test\"), true);\n        });\n\n        it(\"should set an object\", () => {\n            memory.set(\"test2\", obj);\n            assert.equal(memory.has(\"test2\"), true);\n        });\n    });\n\n    describe(\"get\", () => {", "\n    describe(\"get\", () => {\n        it(\"should get a primitive value\", () => {\n            const value = memory.get(\"test\");\n            assert.equal(value, 123);\n        });\n\n        it(\"should get an object that's a clone\", () => {\n            const value = memory.get(\"test2\");\n            assert.deepEqual(value, { foo: 'bar' });", "            const value = memory.get(\"test2\");\n            assert.deepEqual(value, { foo: 'bar' });\n            assert.notEqual(value, obj);\n        });\n\n        it(\"should return undefined when getting a value that doesn't exist\", () => {\n            const value = memory.get(\"test3\");\n            assert.equal(value, undefined);\n        });\n    });", "        });\n    });\n\n    describe(\"has\", () => {\n        it(\"should return false when a value doesn't exist\", () => {\n            assert.equal(memory.has(\"test3\"), false);\n        });\n\n        it(\"should return true when a value exists\", () => {\n            assert.equal(memory.has(\"test\"), true);", "        it(\"should return true when a value exists\", () => {\n            assert.equal(memory.has(\"test\"), true);\n        });\n    });\n\n    describe(\"delete\", () => {\n        it(\"should delete a value\", () => {\n            memory.delete(\"test\");\n            assert.equal(memory.has(\"test\"), false);\n            assert.equal(memory.has(\"test2\"), true);", "            assert.equal(memory.has(\"test\"), false);\n            assert.equal(memory.has(\"test2\"), true);\n        });\n    });\n\n    describe(\"clear\", () => {\n        it(\"should clear all values\", () => {\n            memory.set(\"test\", 123);\n            memory.clear();\n            assert.equal(memory.has(\"test\"), false);", "            memory.clear();\n            assert.equal(memory.has(\"test\"), false);\n            assert.equal(memory.has(\"test2\"), false);\n        });\n    });\n});\n"]}
{"filename": "src/TextSection.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\n\n/**\n * A section of text that will be rendered as a message.\n */\nexport class TextSection extends PromptSectionBase {\n    private _length: number = -1;\n\n    public readonly text: string;\n    public readonly role: string;\n\n    /**\n     * Creates a new 'TextSection' instance.\n     * @param text Text to use for this section.\n     * @param role Message role to use for this section.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n`.\n     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n     */\n    public constructor(text: string, role: string, tokens: number = -1, required: boolean = true, separator: string = '\\n', textPrefix?: string) {\n        super(tokens, required, separator, textPrefix);\n        this.text = text;\n        this.role = role;\n    }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Calculate and cache length", "        if (this._length < 0) {\n            this._length = tokenizer.encode(this.text).length;\n        }\n\n        // Return output\n        return this.returnMessages([{ role: this.role, content: this.text }], this._length, tokenizer, maxTokens);\n    }\n}"]}
{"filename": "src/TextSection.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { TextSection } from \"./TextSection\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"TextSection\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();", "    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a TextSection\", () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            assert.equal(section.text, \"Hello World\");\n            assert.equal(section.role, \"user\");\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);", "            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\");\n        });\n\n        it(\"should create a TextSection with other params\", () => {\n            const section = new TextSection(\"Hello World\", \"system\", 2.0, false);\n            assert.equal(section.text, \"Hello World\");\n            assert.equal(section.role, \"system\");\n            assert.equal(section.tokens, 2.0);", "            assert.equal(section.role, \"system\");\n            assert.equal(section.tokens, 2.0);\n            assert.equal(section.required, false);\n            assert.equal(section.separator, \"\\n\");\n        });\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a TextSection to an array of messages\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");", "        it(\"should render a TextSection to an array of messages\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a output as being too long\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");", "        it(\"should identify a output as being too long\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should support multiple message render calls\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");", "        it(\"should support multiple message render calls\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            const rendered1 = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered1.output, [{ role: \"user\", content: \"Hello World\" }]);\n\n            const rendered2 = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered2.output, [{ role: \"user\", content: \"Hello World\" }]);\n        });\n    });\n", "    });\n\n    describe(\"renderAsText\", () => {\n        it(\"should render a TextSection to a string\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });", "            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a text output as being too long\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });", "            assert.equal(rendered.tooLong, true);\n        });\n\n        it(\"should support multiple text render calls\", async () => {\n            const section = new TextSection(\"Hello World\", \"user\");\n            const rendered1 = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered1.output, \"Hello World\");\n\n            const rendered2 = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered2.output, \"Hello World\");", "            const rendered2 = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered2.output, \"Hello World\");\n        });\n    });\n});\n"]}
{"filename": "src/TemplateSection.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { TemplateSection } from \"./TemplateSection\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"TemplateSection\", () => {\n    const memory = new VolatileMemory({\n        foo: 'bar'\n    });", "        foo: 'bar'\n    });\n    const functions = new FunctionRegistry({\n        'test': async (memory, functions, tokenizer, args) => 'Hello World',\n        'test2': async (memory, functions, tokenizer, args) => args[0],\n        'test3': async (memory, functions, tokenizer, args) => args.join(' '),\n    });\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {", "\n    describe(\"constructor\", () => {\n        it(\"should create a TemplateSection\", () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");\n            assert.equal(section.template, \"Hello World\");\n            assert.equal(section.role, \"user\");\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\");\n        });", "            assert.equal(section.separator, \"\\n\");\n        });\n\n        it(\"should create a TemplateSection with other params\", () => {\n            const section = new TemplateSection(\"Hello World\", \"system\", 2.0, false);\n            assert.equal(section.template, \"Hello World\");\n            assert.equal(section.role, \"system\");\n            assert.equal(section.tokens, 2.0);\n            assert.equal(section.required, false);\n            assert.equal(section.separator, \"\\n\");", "            assert.equal(section.required, false);\n            assert.equal(section.separator, \"\\n\");\n        });\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a TemplateSection to an array of messages\", async () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);", "            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a output as being too long\", async () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);", "            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n    });\n\n    describe(\"renderAsText\", () => {\n        it(\"should render a TemplateSection to a string\", async () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");", "        it(\"should render a TemplateSection to a string\", async () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should identify a text output as being too long\", async () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");", "        it(\"should identify a text output as being too long\", async () => {\n            const section = new TemplateSection(\"Hello World\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, true);\n        });\n    });\n\n    describe(\"template syntax\", () => {", "\n    describe(\"template syntax\", () => {\n        it(\"should render a template with a {{$variable}}\", async () => {\n            const section = new TemplateSection(\"Hello {{$foo}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello bar\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render a template with a {{$variable}} and a {{function}}\", async () => {\n            const section = new TemplateSection(\"Hello {{$foo}} {{test}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello bar Hello World\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render a template with a {{function}} and arguments\", async () => {\n            const section = new TemplateSection(\"Hello {{test2 World}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render a template with a {{function}} and quoted arguments\", async () => {\n            const section = new TemplateSection(\"Hello {{test2 'Big World'}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello Big World\");\n            assert.equal(rendered.length, 3);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render a template with a {{function}} and backtick arguments\", async () => {\n            const section = new TemplateSection(\"Hello {{test2 `Big World`}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello Big World\");\n            assert.equal(rendered.length, 3);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render a template with a {{function}} and multiple arguments\", async () => {\n            const section = new TemplateSection(\"Hello {{test3 'Big' World}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello Big World\");\n            assert.equal(rendered.length, 3);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should skip {{}} empty template params\", async () => {\n            const section = new TemplateSection(\"{{}}\", \"user\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"\");\n            assert.equal(rendered.length, 0);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should throw an error for an invalid template\", () => {\n            try {\n                const section = new TemplateSection(\"Hello {{test3 'Big' World}\", \"user\");\n                assert.fail(\"Should have thrown an error\");\n            } catch (e: unknown) {\n                assert.equal((e as Error).message, \"Invalid template: Hello {{test3 'Big' World}\");\n            }\n        });\n\n        it(\"should throw an error for an invalid {{function 'arg}}\", () => {", "            try {\n                const section = new TemplateSection(\"Hello {{test3 'Big}}\", \"user\");\n                assert.fail(\"Should have thrown an error\");\n            } catch (e: unknown) {\n                assert.equal((e as Error).message, \"Invalid template: Hello {{test3 'Big}}\");\n            }\n        });\n    });\n});\n"]}
{"filename": "src/GPT3Tokenizer.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"GPT3Tokenizer\", () => {\n    describe(\"constructor\", () => {\n        it(\"should create a GPT3Tokenizer\", () => {\n            const tokenizer = new GPT3Tokenizer();\n            assert.notEqual(tokenizer, null);\n        });\n    });", "        });\n    });\n\n    let encoded: number[] = [];\n    describe(\"encode\", () => {\n        it(\"should encode a string\", async () => {\n            const tokenizer = new GPT3Tokenizer();\n            encoded = await tokenizer.encode(\"Hello World\");\n            assert.equal(encoded.length, 2);\n            assert.equal(typeof encoded[0], \"number\");", "            assert.equal(encoded.length, 2);\n            assert.equal(typeof encoded[0], \"number\");\n        });\n    });\n\n    describe(\"decode\", () => {\n        it(\"should decode an array of numbers\", async () => {\n            const tokenizer = new GPT3Tokenizer();\n            const decoded = await tokenizer.decode(encoded);\n            assert.equal(decoded, \"Hello World\");", "            const decoded = await tokenizer.decode(encoded);\n            assert.equal(decoded, \"Hello World\");\n        });\n    });\n});\n"]}
{"filename": "src/SystemMessage.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { SystemMessage } from \"./SystemMessage\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"SystemMessage\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();", "    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a SystemMessage\", () => {\n            const section = new SystemMessage(\"Hello World\");\n            assert.equal(section.template, \"Hello World\");\n            assert.equal(section.role, \"system\");\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);", "            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\");\n        });\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a SystemMessage to an array of messages\", async () => {\n            const section = new SystemMessage(\"Hello World\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);", "            const section = new SystemMessage(\"Hello World\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"renderAsText\", () => {\n        it(\"should render a TemplateSection to a string\", async () => {", "    describe(\"renderAsText\", () => {\n        it(\"should render a TemplateSection to a string\", async () => {\n            const section = new SystemMessage(\"Hello World\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"Hello World\");\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n});", "    });\n});\n"]}
{"filename": "src/GroupSection.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\nimport { LayoutEngine } from \"./LayoutEngine\";\n\n/**\n * A group of sections that will rendered as a single message.\n */\nexport class GroupSection extends PromptSectionBase {\n    private readonly _layoutEngine: LayoutEngine;\n\n    public readonly sections: PromptSection[];\n    public readonly role: string;\n\n    /**\n     *\n     * @param sections List of sections to group together.\n     * @param role Optional. Message role to use for this section. Defaults to `system`.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n\\n`.\n     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n     */\n    public constructor(sections: PromptSection[], role: string = 'system', tokens: number = -1, required: boolean = true, separator: string = '\\n\\n', textPrefix?: string) {\n        super(tokens, required, separator, textPrefix);\n        this._layoutEngine = new LayoutEngine(sections, tokens, required, separator);\n        this.sections = sections;\n        this.role = role;\n    }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Render sections to text\n        const { output, length, tooLong } = await this._layoutEngine.renderAsText(memory, functions, tokenizer, maxTokens);\n\n        // Return output as a single message\n        return this.returnMessages([{ role: this.role, content: output }], length, tokenizer, maxTokens);\n    }\n}"]}
{"filename": "src/AssistantMessage.ts", "chunked_list": ["import { TemplateSection } from \"./TemplateSection\";\n\n/**\n * A message sent by the assistant.\n */\nexport class AssistantMessage extends TemplateSection {\n    /**\n     * Creates a new 'AssistantMessage' instance.\n     * @param template Template to use for this section.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param assistantPrefix Optional. Prefix to use for assistant messages when rendering as text. Defaults to `assistant: `.\n     */\n    public constructor(template: string, tokens: number = -1, assistantPrefix: string = 'assistant: ') {\n        super(template, 'assistant', tokens, true, '\\n', assistantPrefix);\n    }\n}"]}
{"filename": "src/ConversationHistory.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { ConversationHistory } from \"./ConversationHistory\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"ConversationHistory\", () => {\n    const memory = new VolatileMemory({\n        \"history\": [\n            { role: \"user\", content: \"Hello\" },", "        \"history\": [\n            { role: \"user\", content: \"Hello\" },\n            { role: \"assistant\", content: \"Hi\" },\n        ],\n        \"longHistory\": [\n            { role: \"user\", content: \"Hello\" },\n            { role: \"assistant\", content: \"Hi! How can I help you?\" },\n            { role: \"user\", content: \"I'd like to book a flight\" },\n            { role: \"assistant\", content: \"Sure, where would you like to go?\" },\n        ]", "            { role: \"assistant\", content: \"Sure, where would you like to go?\" },\n        ]\n    });\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a ConversationHistory\", () => {\n            const section = new ConversationHistory('history');\n            assert.equal(section.variable, 'history');", "            const section = new ConversationHistory('history');\n            assert.equal(section.variable, 'history');\n            assert.equal(section.tokens, 1.0);\n            assert.equal(section.required, false);\n            assert.equal(section.separator, \"\\n\");\n            assert.equal(section.userPrefix, \"user: \");\n            assert.equal(section.assistantPrefix, \"assistant: \");\n            assert.equal(section.textPrefix, \"\");\n        });\n", "        });\n\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a ConversationHistory to an array of messages\", async () => {\n            const section = new ConversationHistory('history', 100);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [\n                { role: \"user\", content: \"Hello\" },", "            assert.deepEqual(rendered.output, [\n                { role: \"user\", content: \"Hello\" },\n                { role: \"assistant\", content: \"Hi\" },\n            ]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should truncate its output to match available budget\", async () => {\n            const section = new ConversationHistory('history', 1);", "        it(\"should truncate its output to match available budget\", async () => {\n            const section = new ConversationHistory('history', 1);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n            assert.deepEqual(rendered.output, [\n                { role: \"assistant\", content: \"Hi\" },\n            ]);\n            assert.equal(rendered.length, 1);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render nothing when there's no history\", async () => {\n            const section = new ConversationHistory('nohistory', 100);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, []);\n            assert.equal(rendered.length, 0);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should render nothing for a long last message\", async () => {\n            const section = new ConversationHistory('longHistory', 100);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 2);\n            assert.deepEqual(rendered.output, []);\n            assert.equal(rendered.length, 0);\n            assert.equal(rendered.tooLong, false);\n        });\n", "        });\n\n        it(\"should always render the last message when section is required\", async () => {\n            const section = new ConversationHistory('longHistory', 100, true);\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 2);\n            assert.deepEqual(rendered.output, [\n                { role: \"assistant\", content: \"Sure, where would you like to go?\" },\n            ]);\n            assert.equal(rendered.length, 9);\n            assert.equal(rendered.tooLong, true);", "            assert.equal(rendered.length, 9);\n            assert.equal(rendered.tooLong, true);\n        });\n    });\n\n    describe(\"renderAsText\", () => {\n        it(\"should render a ConversationHistory to a string\", async () => {\n            const section = new ConversationHistory('history', 100);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"user: Hello\\nassistant: Hi\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"user: Hello\\nassistant: Hi\");\n            assert.equal(rendered.length, 8);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should truncate its output to match available budget\", async () => {\n            const section = new ConversationHistory('history', 1);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 4);\n            assert.equal(rendered.output, \"assistant: Hi\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 4);\n            assert.equal(rendered.output, \"assistant: Hi\");\n            assert.equal(rendered.length, 4);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render nothing when there's no history\", async () => {\n            const section = new ConversationHistory('nohistory', 100);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"\");\n            assert.equal(rendered.length, 0);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should render nothing for a long last message\", async () => {\n            const section = new ConversationHistory('longHistory', 100);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 2);\n            assert.equal(rendered.output, \"\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 2);\n            assert.equal(rendered.output, \"\");\n            assert.equal(rendered.length, 0);\n            assert.equal(rendered.tooLong, false);\n        });\n\n        it(\"should always render the last message when section is required\", async () => {\n            const section = new ConversationHistory('longHistory', 100, true);\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 2);\n            assert.equal(rendered.output, \"assistant: Sure, where would you like to go?\");", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 2);\n            assert.equal(rendered.output, \"assistant: Sure, where would you like to go?\");\n            assert.equal(rendered.length, 12);\n            assert.equal(rendered.tooLong, true);\n        });\n    });\n});\n"]}
{"filename": "src/PromptSectionBase.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\n\n/**\n * Abstract Base class for most prompt sections.\n */\nexport abstract class PromptSectionBase implements PromptSection {\n    public readonly required: boolean;\n    public readonly tokens: number;\n    public readonly separator: string;\n    public readonly textPrefix: string;\n\n    /**\n     * Creates a new 'PromptSectionBase' instance.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n`.\n     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n     */\n    public constructor(tokens: number = -1, required: boolean = true, separator: string = '\\n', textPrefix: string = '') {\n        this.required = required;\n        this.tokens = tokens;\n        this.separator = separator;\n        this.textPrefix = textPrefix;\n    }\n\n    public async renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>> {\n        // Render as messages\n        const asMessages = await this.renderAsMessages(memory, functions, tokenizer, maxTokens);\n\n        // Convert to text\n        let text = asMessages.output.map((message) => PromptSectionBase.getMessageText(message)).join(this.separator);\n\n        // Calculate length\n        const prefixLength = tokenizer.encode(this.textPrefix).length;\n        const separatorLength = tokenizer.encode(this.separator).length;\n        let length = prefixLength + asMessages.length + ((asMessages.output.length - 1) * separatorLength);\n\n        // Truncate if fixed length\n        text = this.textPrefix + text;", "        if (this.tokens > 1.0 && length > this.tokens) {\n            const encoded = tokenizer.encode(text);\n            text = tokenizer.decode(encoded.slice(0, this.tokens));\n            length = this.tokens;\n        }\n\n        return { output: text, length: length, tooLong: length > maxTokens };\n    }\n\n    public abstract renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>>;\n\n    protected returnMessages(output: Message[], length: number, tokenizer: Tokenizer, maxTokens: number): RenderedPromptSection<Message[]> {\n        // Truncate if fixed length", "        if (this.tokens > 1.0) {\n            while (length > this.tokens) {\n                const msg = output.pop();\n                const encoded = tokenizer.encode(PromptSectionBase.getMessageText(msg!));\n                length -= encoded.length;\n                if (length < this.tokens) {\n                    const delta = this.tokens - length;\n                    const truncated = tokenizer.decode(encoded.slice(0, delta));\n                    output.push({ role: msg!.role, content: truncated });\n                    length += delta;\n                }\n            }\n        }\n\n        return { output: output, length: length, tooLong: length > maxTokens };\n    }\n\n    public static getMessageText(message: Message): string {\n        let text = message.content ?? '';", "        if (message.function_call) {\n            text = JSON.stringify(message.function_call);\n        } else if (message.name) {\n            text = `${message.name} returned ${text}`;\n        }\n\n        return text;\n    }\n\n}"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./AssistantMessage\";\nexport * from \"./ConversationHistory\";\nexport * from \"./FunctionCallMessage\";\nexport * from \"./FunctionRegistry\";\nexport * from \"./FunctionResponseMessage\";\nexport * from \"./GPT3Tokenizer\";\nexport * from \"./GroupSection\";\nexport * from \"./LayoutEngine\";\nexport * from \"./Prompt\";\nexport * from \"./PromptSectionBase\";", "export * from \"./Prompt\";\nexport * from \"./PromptSectionBase\";\nexport * from \"./SystemMessage\";\nexport * from \"./TemplateSection\";\nexport * from \"./TextSection\";\nexport * from \"./types\";\nexport * from \"./UserMessage\";\nexport * from \"./Utilities\";\nexport * from \"./VolatileMemory\";\n", "export * from \"./VolatileMemory\";\n"]}
{"filename": "src/GPT3Tokenizer.ts", "chunked_list": ["import { Tokenizer } from \"./types\";\nimport { encode, decode } from \"gpt-3-encoder\";\n\n/**\n * Tokenizer that uses GPT-3's encoder.\n */\nexport class GPT3Tokenizer implements Tokenizer {\n    public decode(tokens: number[]): string {\n        return decode(tokens);\n    }\n\n    public encode(text: string): number[] {\n        return encode(text);\n    }\n}\n"]}
{"filename": "src/Utilities.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { Utilities } from \"./Utilities\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"Utilities\", () => {\n    const tokenizer = new GPT3Tokenizer();\n    describe(\"toString\", () => {\n        it(\"should convert a number to a string\", () => {\n            const result = Utilities.toString(tokenizer, 1);\n            assert.equal(result, \"1\");", "            const result = Utilities.toString(tokenizer, 1);\n            assert.equal(result, \"1\");\n        });\n\n        it(\"should convert a string to a string\", () => {\n            const result = Utilities.toString(tokenizer, \"1\");\n            assert.equal(result, \"1\");\n        });\n\n        it(\"should convert a boolean to a string\", () => {", "\n        it(\"should convert a boolean to a string\", () => {\n            const result = Utilities.toString(tokenizer, true);\n            assert.equal(result, \"true\");\n        });\n\n        it(\"should convert a simple object to yaml\", () => {\n            const result = Utilities.toString(tokenizer, { a: 1 });\n            assert.equal(result, \"a: 1\\n\");\n        });", "            assert.equal(result, \"a: 1\\n\");\n        });\n\n        it(\"should convert a deep object to JSON\", () => {\n            const result = Utilities.toString(tokenizer, { a: { b: { c: { d: 1 } } } });\n            assert.equal(result, `{\"a\":{\"b\":{\"c\":{\"d\":1}}}}`);\n        });\n\n        it(\"should convert a date to a string\", () => {\n            const result = Utilities.toString(tokenizer, new Date(\"2021-01-01\"));", "        it(\"should convert a date to a string\", () => {\n            const result = Utilities.toString(tokenizer, new Date(\"2021-01-01\"));\n            assert.equal(result, \"2021-01-01T00:00:00.000Z\");\n        });\n\n        it(\"should return an empty string for undefined\", () => {\n            const result = Utilities.toString(tokenizer, undefined);\n            assert.equal(result, \"\");\n        });\n", "        });\n\n        it(\"should return an empty string for null\", () => {\n            const result = Utilities.toString(tokenizer, null);\n            assert.equal(result, \"\");\n        });\n    });\n});\n", ""]}
{"filename": "src/FunctionCallMessage.ts", "chunked_list": ["import { FunctionCall, Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\nimport { Utilities } from \"./Utilities\";\n\n/**\n * An `assistant` message containing a function to call.\n * @remarks\n * The function call information is returned by the model so we use an \"assistant\" message to\n * represent it in conversation history.\n */\nexport class FunctionCallMessage extends PromptSectionBase {\n    private _length: number = -1;\n\n    public readonly function_call: FunctionCall;\n\n    /**\n     * Creates a new 'FunctionCallMessage' instance.", "export class FunctionCallMessage extends PromptSectionBase {\n    private _length: number = -1;\n\n    public readonly function_call: FunctionCall;\n\n    /**\n     * Creates a new 'FunctionCallMessage' instance.\n     * @param function_call name and arguments of the function to call.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param assistantPrefix Optional. Prefix to use for assistant messages when rendering as text. Defaults to `assistant: `.\n     */\n    public constructor(function_call: FunctionCall, tokens: number = -1, assistantPrefix: string = 'assistant: ') {\n        super(tokens, true, '\\n', assistantPrefix);\n        this.function_call = function_call;\n    }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Calculate and cache response text and length", "        if (this._length < 0) {\n            this._length = tokenizer.encode(JSON.stringify(this.function_call)).length;\n        }\n\n        // Return output\n        return this.returnMessages([{ role: 'assistant', content: null, function_call: this.function_call }], this._length, tokenizer, maxTokens);\n    }\n}"]}
{"filename": "src/Utilities.ts", "chunked_list": ["import { Tokenizer } from \"./types\";\nimport { stringify } from \"yaml\";\n\n/**\n * Utility functions.\n */\nexport class Utilities {\n    /**\n     * Converts a value to a string.\n     * @remarks\n     * Dates are converted to ISO strings and Objects are converted to JSON or YAML, whichever is shorter.\n     * @param tokenizer Tokenizer to use for encoding.\n     * @param value Value to convert.\n     * @param asJSON Optional. If true objects will always be converted to JSON instead of YAML. Defaults to false.\n     * @returns Converted value.\n     */\n    public static toString(tokenizer: Tokenizer, value: any, asJSON: boolean = false): string {", "        if (value === undefined || value === null) {\n            return '';\n        } else if (typeof value === \"object\") {\n            if (typeof value.toISOString == \"function\") {\n                return value.toISOString();\n            } else if (asJSON) {\n                return JSON.stringify(value);\n            } else {\n                // Return shorter version of object\n                const asYaml = stringify(value);\n                const asJSON = JSON.stringify(value);", "                if (tokenizer.encode(asYaml).length < tokenizer.encode(asJSON).length) {\n                    return asYaml;\n                } else {\n                    return asJSON;\n                }\n            }\n        } else {\n            return value.toString();\n        }\n    }\n}"]}
{"filename": "src/UserMessage.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\nimport { UserMessage } from \"./UserMessage\";\nimport { VolatileMemory } from \"./VolatileMemory\";\nimport { FunctionRegistry } from \"./FunctionRegistry\";\nimport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\ndescribe(\"UserMessage\", () => {\n    const memory = new VolatileMemory();\n    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();", "    const functions = new FunctionRegistry();\n    const tokenizer = new GPT3Tokenizer();\n\n    describe(\"constructor\", () => {\n        it(\"should create a UserMessage\", () => {\n            const section = new UserMessage(\"Hello World\");\n            assert.equal(section.template, \"Hello World\");\n            assert.equal(section.role, \"user\");\n            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);", "            assert.equal(section.tokens, -1);\n            assert.equal(section.required, true);\n            assert.equal(section.separator, \"\\n\");\n            assert.equal(section.textPrefix, \"user: \");\n        });\n    });\n\n    describe(\"renderAsMessages\", () => {\n        it(\"should render a UserMessage to an array of messages\", async () => {\n            const section = new UserMessage(\"Hello World\");", "        it(\"should render a UserMessage to an array of messages\", async () => {\n            const section = new UserMessage(\"Hello World\");\n            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n            assert.equal(rendered.length, 2);\n            assert.equal(rendered.tooLong, false);\n        });\n    });\n\n    describe(\"renderAsText\", () => {", "\n    describe(\"renderAsText\", () => {\n        it(\"should render a TemplateSection to a string\", async () => {\n            const section = new UserMessage(\"Hello World\");\n            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n            assert.equal(rendered.output, \"user: Hello World\");\n            assert.equal(rendered.length, 5);\n            assert.equal(rendered.tooLong, false);\n        });\n    });", "        });\n    });\n});\n"]}
{"filename": "src/FunctionResponseMessage.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\nimport { PromptSectionBase } from \"./PromptSectionBase\";\nimport { Utilities } from \"./Utilities\";\n\n/**\n * Message containing the response to a function call.\n */\nexport class FunctionResponseMessage extends PromptSectionBase {\n    private _text: string = '';\n    private _length: number = -1;\n\n    public readonly name: string;\n    public readonly response: any;\n\n    /**\n     * Creates a new 'FunctionResponseMessage' instance.", "     * @param name Name of the function that was called.\n     * @param response The response returned by the called function.\n     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n     * @param functionPrefix Optional. Prefix to use for function messages when rendering as text. Defaults to `user: ` to simulate the response coming from the user.\n     */\n    public constructor(name: string, response: any, tokens: number = -1, functionPrefix: string = 'user: ') {\n        super(tokens, true, '\\n', functionPrefix);\n        this.name = name;\n        this.response = response;\n    }\n\n    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n        // Calculate and cache response text and length", "        if (this._length < 0) {\n            this._text = Utilities.toString(tokenizer, this.response);\n            this._length = tokenizer.encode(this.name).length + tokenizer.encode(this._text).length;\n        }\n\n        // Return output\n        return this.returnMessages([{ role: 'function', name: this.name, content: this._text }], this._length, tokenizer, maxTokens);\n    }\n}"]}
