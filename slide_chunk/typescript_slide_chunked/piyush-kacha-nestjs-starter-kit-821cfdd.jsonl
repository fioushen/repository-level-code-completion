{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import * as request from 'supertest';\n\nimport { AppModule } from '../src/app.module';\nimport { INestApplication } from '@nestjs/common';\nimport { Test, TestingModule } from '@nestjs/testing';\n\ndescribe('AppController (e2e)', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {", "\n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n", "  });\n\n  it('/ (GET)', () => {\n    return request(app.getHttpServer()).get('/').expect(200).expect('Hello World!');\n  });\n});\n"]}
{"filename": "src/main.ts", "chunked_list": ["// Import external modules\nimport * as cluster from 'cluster';\nimport * as os from 'os';\nimport { ConfigService } from '@nestjs/config';\nimport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\nimport { Logger } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { Logger as Pino } from 'nestjs-pino';\n\n// Import internal modules", "\n// Import internal modules\nimport { AppModule } from './app.module';\n\n// Create a logger for the bootstrap process\nconst logger = new Logger('bootstrap');\n\n// Define the main function\nasync function bootstrap() {\n  // Create the NestJS application instance\n  const app = await NestFactory.create(AppModule, {\n    bufferLogs: true,\n  });\n\n  // Use the Pino logger for the application\n  app.useLogger(app.get(Pino));\n\n  // Allow all origins\n  app.enableCors();\n\n  // Define the Swagger options and document\n  const options = new DocumentBuilder()\n    .setTitle('NestJS Starter API')\n    .setDescription('The API for the NestJS Starter project')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, options);\n\n  // Set up the Swagger UI endpoint\n  SwaggerModule.setup('docs', app, document, {\n    swaggerOptions: {\n      tagsSorter: 'alpha',\n      operationsSorter: 'alpha',\n    },\n  });\n\n  // Get the configuration service from the application\n  const configService = app.get(ConfigService);\n\n  // Get the port number from the configuration\n  const PORT = configService.get<number>('port');\n\n  // Start the application\n  await app.listen(PORT);\n\n  // Log a message to indicate that the application is running\n  logger.log(`Application listening on port ${PORT}`);\n}\n\n// Check if clustering is enabled", "async function bootstrap() {\n  // Create the NestJS application instance\n  const app = await NestFactory.create(AppModule, {\n    bufferLogs: true,\n  });\n\n  // Use the Pino logger for the application\n  app.useLogger(app.get(Pino));\n\n  // Allow all origins\n  app.enableCors();\n\n  // Define the Swagger options and document\n  const options = new DocumentBuilder()\n    .setTitle('NestJS Starter API')\n    .setDescription('The API for the NestJS Starter project')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .build();\n  const document = SwaggerModule.createDocument(app, options);\n\n  // Set up the Swagger UI endpoint\n  SwaggerModule.setup('docs', app, document, {\n    swaggerOptions: {\n      tagsSorter: 'alpha',\n      operationsSorter: 'alpha',\n    },\n  });\n\n  // Get the configuration service from the application\n  const configService = app.get(ConfigService);\n\n  // Get the port number from the configuration\n  const PORT = configService.get<number>('port');\n\n  // Start the application\n  await app.listen(PORT);\n\n  // Log a message to indicate that the application is running\n  logger.log(`Application listening on port ${PORT}`);\n}\n\n// Check if clustering is enabled", "if (process.env.CLUSTERING === 'true') {\n  // Get the number of CPUs on the machine\n  const numCPUs = os.cpus().length;\n\n  // If the current process is the master process\n  if ((cluster as any).isMaster) {\n    logger.log(`Master process is running with PID ${process.pid}`);\n\n    // Fork workers for each available CPU\n    for (let i = 0; i < numCPUs; i += 1) {\n      (cluster as any).fork();\n    }\n\n    // Log when a worker process exits\n    (cluster as any).on('exit', (worker, code, signal) => {\n      logger.debug(`Worker process ${worker.process.pid} exited with code ${code} and signal ${signal}`);\n    });\n  } else {", "    for (let i = 0; i < numCPUs; i += 1) {\n      (cluster as any).fork();\n    }\n\n    // Log when a worker process exits\n    (cluster as any).on('exit', (worker, code, signal) => {\n      logger.debug(`Worker process ${worker.process.pid} exited with code ${code} and signal ${signal}`);\n    });\n  } else {\n    // If the current process is a worker process, call the bootstrap function to start the application\n    bootstrap();\n  }\n} else {", "    // If the current process is a worker process, call the bootstrap function to start the application\n    bootstrap();\n  }\n} else {\n  // Call the bootstrap function to start the application\n  bootstrap();\n}\n"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(): string {\n    return 'Yeah yeah! we are okay!';\n  }\n}\n"]}
{"filename": "src/app.controller.spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\n\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\ndescribe('AppController', () => {\n  let appController: AppController;\n\n  beforeEach(async () => {\n    const app: TestingModule = await Test.createTestingModule({", "  beforeEach(async () => {\n    const app: TestingModule = await Test.createTestingModule({\n      controllers: [AppController],\n      providers: [AppService],\n    }).compile();\n\n    appController = app.get<AppController>(AppController);\n  });\n\n  describe('root', () => {", "\n  describe('root', () => {\n    it('should return \"Hello World!\"', () => {\n      expect(appController.getHello()).toBe('Hello World!');\n    });\n  });\n});\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["// Import required modules\nimport { APP_FILTER, APP_PIPE } from '@nestjs/core';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { LoggerModule } from 'nestjs-pino';\nimport { Module, ValidationError, ValidationPipe } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\n\n// Import application files\n\nimport { AppConfig } from './app.config';", "\nimport { AppConfig } from './app.config';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { configuration } from './config/index';\n\n// Import filters\nimport {\n  AllExceptionsFilter,\n  BadRequestExceptionFilter,", "  AllExceptionsFilter,\n  BadRequestExceptionFilter,\n  ForbiddenExceptionFilter,\n  NotFoundExceptionFilter,\n  UnauthorizedExceptionFilter,\n  ValidationExceptionFilter,\n} from './filters';\n\n// Import other modules\n", "// Import other modules\n\n@Module({\n  imports: [\n    // Configure environment variables\n    ConfigModule.forRoot({\n      isGlobal: true, // Make the configuration global\n      load: [configuration], // Load the environment variables from the configuration file\n    }),\n", "    }),\n\n    // Configure logging\n    LoggerModule.forRoot(AppConfig.getLoggerConfig()), // ! forRootAsync is not working with ConfigService in nestjs-pino\n\n    // Configure mongoose\n    MongooseModule.forRootAsync({\n      imports: [ConfigModule], // Import the ConfigModule so that it can be injected into the factory function\n      inject: [ConfigService], // Inject the ConfigService into the factory function\n      useFactory: async (configService: ConfigService) => ({", "      inject: [ConfigService], // Inject the ConfigService into the factory function\n      useFactory: async (configService: ConfigService) => ({\n        // Get the required configuration settings from the ConfigService\n        uri: configService.get('database.uri'),\n      }),\n    }),\n    // Import other modules\n  ],\n  controllers: [AppController], // Define the application's controller\n  providers: [", "  controllers: [AppController], // Define the application's controller\n  providers: [\n    AppService,\n    { provide: APP_FILTER, useClass: AllExceptionsFilter },\n    { provide: APP_FILTER, useClass: ValidationExceptionFilter },\n    { provide: APP_FILTER, useClass: BadRequestExceptionFilter },\n    { provide: APP_FILTER, useClass: UnauthorizedExceptionFilter },\n    { provide: APP_FILTER, useClass: ForbiddenExceptionFilter },\n    { provide: APP_FILTER, useClass: NotFoundExceptionFilter },\n    {", "    { provide: APP_FILTER, useClass: NotFoundExceptionFilter },\n    {\n      // Allowing to do validation through DTO\n      // Since class-validator library default throw BadRequestException, here we use exceptionFactory to throw\n      // their internal exception so that filter can recognize it\n      provide: APP_PIPE,\n      useFactory: () =>\n        new ValidationPipe({\n          exceptionFactory: (errors: ValidationError[]) => {\n            return errors[0];", "          exceptionFactory: (errors: ValidationError[]) => {\n            return errors[0];\n          },\n        }),\n    },\n  ], // Define the application's service\n})\nexport class AppModule {}\n"]}
{"filename": "src/app.config.ts", "chunked_list": ["// Import external modules\nimport * as crypto from 'crypto'; // Used to generate random UUIDs\nimport { IncomingMessage, ServerResponse } from 'http'; // Used to handle incoming and outgoing HTTP messages\nimport { Params } from 'nestjs-pino'; // Used to define parameters for the Pino logger\n\n// Import internal modules\nimport { LogLevel, NodeEnv } from './shared/enums'; // Import application enums\n\nexport class AppConfig {\n  public static getLoggerConfig(): Params {\n    // Define the configuration for the Pino logger\n    const { NODE_ENV, LOG_LEVEL, CLUSTERING } = process.env;\n\n    return {\n      exclude: [], // Exclude specific path from the logs and may not work for e2e testing\n      pinoHttp: {\n        genReqId: () => crypto.randomUUID(), // Generate a random UUID for each incoming request\n        autoLogging: true, // Automatically log HTTP requests and responses\n        base: CLUSTERING === 'true' ? { pid: process.pid } : {}, // Include the process ID in the logs if clustering is enabled\n        customAttributeKeys: {\n          responseTime: 'timeSpent', // Rename the responseTime attribute to timeSpent\n        },\n        level: LOG_LEVEL || (NODE_ENV === NodeEnv.PRODUCTION ? LogLevel.INFO : LogLevel.TRACE), // Set the log level based on the environment and configuration\n        serializers: {\n          req(request: IncomingMessage) {\n            return {\n              method: request.method,\n              url: request.url,\n              id: request.id,\n              // Including the headers in the log could be in violation of privacy laws, e.g. GDPR.\n              // headers: request.headers,\n            };\n          },\n          res(reply: ServerResponse) {\n            return {\n              statusCode: reply.statusCode,\n            };\n          },\n        },\n        transport:\n          NODE_ENV !== NodeEnv.PRODUCTION // Only use Pino-pretty in non-production environments\n            ? {\n                target: 'pino-pretty',\n                options: {\n                  translateTime: 'SYS:yyyy-mm-dd HH:MM:ss',\n                },\n              }\n            : null,\n      },\n    };\n  }\n}\n", "export class AppConfig {\n  public static getLoggerConfig(): Params {\n    // Define the configuration for the Pino logger\n    const { NODE_ENV, LOG_LEVEL, CLUSTERING } = process.env;\n\n    return {\n      exclude: [], // Exclude specific path from the logs and may not work for e2e testing\n      pinoHttp: {\n        genReqId: () => crypto.randomUUID(), // Generate a random UUID for each incoming request\n        autoLogging: true, // Automatically log HTTP requests and responses\n        base: CLUSTERING === 'true' ? { pid: process.pid } : {}, // Include the process ID in the logs if clustering is enabled\n        customAttributeKeys: {\n          responseTime: 'timeSpent', // Rename the responseTime attribute to timeSpent\n        },\n        level: LOG_LEVEL || (NODE_ENV === NodeEnv.PRODUCTION ? LogLevel.INFO : LogLevel.TRACE), // Set the log level based on the environment and configuration\n        serializers: {\n          req(request: IncomingMessage) {\n            return {\n              method: request.method,\n              url: request.url,\n              id: request.id,\n              // Including the headers in the log could be in violation of privacy laws, e.g. GDPR.\n              // headers: request.headers,\n            };\n          },\n          res(reply: ServerResponse) {\n            return {\n              statusCode: reply.statusCode,\n            };\n          },\n        },\n        transport:\n          NODE_ENV !== NodeEnv.PRODUCTION // Only use Pino-pretty in non-production environments\n            ? {\n                target: 'pino-pretty',\n                options: {\n                  translateTime: 'SYS:yyyy-mm-dd HH:MM:ss',\n                },\n              }\n            : null,\n      },\n    };\n  }\n}\n"]}
{"filename": "src/app.controller.ts", "chunked_list": ["import { ApiTags } from '@nestjs/swagger';\nimport { Controller, Get } from '@nestjs/common';\n\nimport { AppService } from './app.service';\n\n@ApiTags('Health-check')\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n"]}
{"filename": "src/filters/forbidden-exception.filter.ts", "chunked_list": ["import { ArgumentsHost, Catch, ExceptionFilter, Logger } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\nimport { ForbiddenException } from '../exceptions';\n\n/**\n * Exception filter to handle unauthorized exceptions\n */\n@Catch(ForbiddenException)\nexport class ForbiddenExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(ForbiddenExceptionFilter.name);\n\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Method to handle unauthorized exceptions\n   * @param exception - The thrown unauthorized exception\n   * @param host - The arguments host\n   */", "@Catch(ForbiddenException)\nexport class ForbiddenExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(ForbiddenExceptionFilter.name);\n\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Method to handle unauthorized exceptions\n   * @param exception - The thrown unauthorized exception\n   * @param host - The arguments host\n   */", "  catch(exception: ForbiddenException, host: ArgumentsHost): void {\n    this.logger.warn(exception);\n\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n    const httpStatus = exception.getStatus();\n\n    // Example of fetching path to attach path inside response object\n    const request = ctx.getRequest();\n    // const path = httpAdapter.getRequestUrl(request);\n\n    // Sets the trace ID from the request object to the exception.\n    exception.setTraceId(request.id);\n\n    // Constructs the response body object.\n    const responseBody = exception.generateHttpResponseBody();\n\n    // Uses the HTTP adapter to send the response with the constructed response body\n    // and the HTTP status code.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/filters/not-found-exception.filter.ts", "chunked_list": ["import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus, Logger, NotFoundException } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\n/**\n * Catches all exceptions thrown by the application and sends an appropriate HTTP response.\n */\n@Catch(NotFoundException)\nexport class NotFoundExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(NotFoundExceptionFilter.name);\n\n  /**\n   * Creates an instance of `NotFoundExceptionFilter`.\n   *\n   * @param {HttpAdapterHost} httpAdapterHost - the HTTP adapter host\n   */\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Catches an exception and sends an appropriate HTTP response.\n   *\n   * @param {*} exception - the exception to catch\n   * @param {ArgumentsHost} host - the arguments host\n   * @returns {void}\n   */", "  catch(exception: any, host: ArgumentsHost): void {\n    // Log the exception.\n\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n\n    const httpStatus = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    const request = ctx.getRequest();\n\n    // Construct the response body.\n    const responseBody = {\n      error: exception.code,\n      message: exception.message,\n      description: exception.description,\n      traceId: request.id,\n    };\n\n    // Send the HTTP response.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/filters/all-exception.filter.ts", "chunked_list": ["import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus, Logger } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\n/**\n * Catches all exceptions thrown by the application and sends an appropriate HTTP response.\n */\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  private readonly logger = new Logger(AllExceptionsFilter.name);\n\n  /**\n   * Creates an instance of `AllExceptionsFilter`.\n   *\n   * @param {HttpAdapterHost} httpAdapterHost - the HTTP adapter host\n   */\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Catches an exception and sends an appropriate HTTP response.\n   *\n   * @param {*} exception - the exception to catch\n   * @param {ArgumentsHost} host - the arguments host\n   * @returns {void}\n   */", "  catch(exception: any, host: ArgumentsHost): void {\n    // Log the exception.\n    this.logger.error(exception);\n\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n\n    const httpStatus = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    const request = ctx.getRequest();\n\n    // Construct the response body.\n    const responseBody = {\n      error: exception.code,\n      message: exception.message,\n      description: exception.description,\n      timestamp: new Date().toISOString(),\n      traceId: request.id,\n    };\n\n    // Send the HTTP response.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/filters/bad-request-exception.filter.ts", "chunked_list": ["import { ArgumentsHost, Catch, ExceptionFilter, Logger } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\nimport { BadRequestException } from '../exceptions/bad-request.exception';\n\n/**\n * A filter to handle `BadRequestException`.\n */\n@Catch(BadRequestException)\nexport class BadRequestExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(BadRequestException.name);\n\n  /**\n   * Constructs a new instance of `BadRequestExceptionFilter`.\n   * @param httpAdapterHost - The HttpAdapterHost instance to be used.\n   */\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Handles the `BadRequestException` and transforms it into a JSON response.\n   * @param exception - The `BadRequestException` instance that was thrown.\n   * @param host - The `ArgumentsHost` instance that represents the current execution context.\n   */", "@Catch(BadRequestException)\nexport class BadRequestExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(BadRequestException.name);\n\n  /**\n   * Constructs a new instance of `BadRequestExceptionFilter`.\n   * @param httpAdapterHost - The HttpAdapterHost instance to be used.\n   */\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Handles the `BadRequestException` and transforms it into a JSON response.\n   * @param exception - The `BadRequestException` instance that was thrown.\n   * @param host - The `ArgumentsHost` instance that represents the current execution context.\n   */", "  catch(exception: BadRequestException, host: ArgumentsHost): void {\n    // Logs the exception details at the verbose level.\n    this.logger.verbose(exception);\n\n    // In certain situations `httpAdapter` might not be available in the constructor method,\n    // thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    // Retrieves the current HTTP context from the `ArgumentsHost`.\n    const ctx = host.switchToHttp();\n\n    // Retrieves the HTTP status code from the `BadRequestException`.\n    const httpStatus = exception.getStatus();\n\n    // Retrieves the request object from the HTTP context.\n    const request = ctx.getRequest();\n\n    // Sets the trace ID from the request object to the exception.\n    exception.setTraceId(request.id);\n\n    // Constructs the response body object.\n    const responseBody = exception.generateHttpResponseBody();\n\n    // Uses the HTTP adapter to send the response with the constructed response body\n    // and the HTTP status code.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/filters/validator-exception.filter.ts", "chunked_list": ["import { ArgumentsHost, Catch, ExceptionFilter, HttpStatus, Logger } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\nimport { ValidationError } from 'class-validator';\n\nimport { BadRequestException } from '../exceptions/bad-request.exception';\n\n/**\n * An exception filter to handle validation errors thrown by class-validator.\n */\n@Catch(ValidationError)\nexport class ValidationExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(ValidationExceptionFilter.name);\n\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Handle a validation error.\n   * @param exception The validation error object.\n   * @param host The arguments host object.\n   */", " */\n@Catch(ValidationError)\nexport class ValidationExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(ValidationExceptionFilter.name);\n\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Handle a validation error.\n   * @param exception The validation error object.\n   * @param host The arguments host object.\n   */", "  catch(exception: ValidationError, host: ArgumentsHost): void {\n    this.logger.verbose(exception);\n\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n    const httpStatus = HttpStatus.UNPROCESSABLE_ENTITY;\n\n    const request = ctx.getRequest();\n    // Example of fetching path to attach path inside response object\n    // const path = httpAdapter.getRequestUrl(request);\n\n    const errorMsg = exception.constraints || exception.children[0].constraints;\n\n    // Create a new BadRequestException with the validation error message.\n    const err = BadRequestException.VALIDATION_ERROR(Object.values(errorMsg)[0]);\n\n    const responseBody = {\n      error: err.code,\n      message: err.message,\n      timestamp: new Date().toISOString(),\n      traceId: request.id,\n    };\n\n    // Uses the HTTP adapter to send the response with the constructed response body\n    // and the HTTP status code.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/filters/index.ts", "chunked_list": ["export * from './not-found-exception.filter';\nexport * from './all-exception.filter';\nexport * from './bad-request-exception.filter';\nexport * from './unauthorized-exception.filter';\nexport * from './forbidden-exception.filter';\nexport * from './validator-exception.filter';\n"]}
{"filename": "src/filters/internal-server-error-exception.filter.ts", "chunked_list": ["// Importing required modules and classes from NestJS\nimport { ArgumentsHost, Catch, ExceptionFilter, Logger } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\nimport { InternalServerErrorException } from '../exceptions/internal-server-error.exception';\n\n/**\n * A filter to handle `InternalServerErrorException`.\n */\n@Catch(InternalServerErrorException)\nexport class InternalServerErrorExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(InternalServerErrorException.name);\n\n  /**\n   * Constructs a new instance of `InternalServerErrorExceptionFilter`.\n   * @param httpAdapterHost - The HttpAdapterHost instance to be used.\n   */\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Handles the `InternalServerErrorException` and transforms it into a JSON response.\n   * @param exception - The `InternalServerErrorException` instance that was thrown.\n   * @param host - The `ArgumentsHost` instance that represents the current execution context.\n   */", " */\n@Catch(InternalServerErrorException)\nexport class InternalServerErrorExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(InternalServerErrorException.name);\n\n  /**\n   * Constructs a new instance of `InternalServerErrorExceptionFilter`.\n   * @param httpAdapterHost - The HttpAdapterHost instance to be used.\n   */\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Handles the `InternalServerErrorException` and transforms it into a JSON response.\n   * @param exception - The `InternalServerErrorException` instance that was thrown.\n   * @param host - The `ArgumentsHost` instance that represents the current execution context.\n   */", "  catch(exception: InternalServerErrorException, host: ArgumentsHost): void {\n    // Logs the exception details at the error level.\n    this.logger.error(exception);\n\n    // In certain situations `httpAdapter` might not be available in the constructor method,\n    // thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    // Retrieves the current HTTP context from the `ArgumentsHost`.\n    const ctx = host.switchToHttp();\n\n    // Retrieves the HTTP status code from the `InternalServerErrorException`.\n    const httpStatus = exception.getStatus();\n\n    // Retrieves the request object from the HTTP context.\n    const request = ctx.getRequest();\n\n    // Sets the trace ID from the request object to the exception.\n    exception.setTraceId(request.id);\n\n    // Constructs the response body object.\n    const responseBody = exception.generateHttpResponseBody();\n\n    // Uses the HTTP adapter to send the response with the constructed response body\n    // and the HTTP status code.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/filters/unauthorized-exception.filter.ts", "chunked_list": ["import { ArgumentsHost, Catch, ExceptionFilter, Logger } from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\nimport { UnauthorizedException } from '../exceptions/unauthorized.exception';\n\n/**\n * Exception filter to handle unauthorized exceptions\n */\n@Catch(UnauthorizedException)\nexport class UnauthorizedExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(UnauthorizedExceptionFilter.name);\n\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Method to handle unauthorized exceptions\n   * @param exception - The thrown unauthorized exception\n   * @param host - The arguments host\n   */", "@Catch(UnauthorizedException)\nexport class UnauthorizedExceptionFilter implements ExceptionFilter {\n  private readonly logger = new Logger(UnauthorizedExceptionFilter.name);\n\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  /**\n   * Method to handle unauthorized exceptions\n   * @param exception - The thrown unauthorized exception\n   * @param host - The arguments host\n   */", "  catch(exception: UnauthorizedException, host: ArgumentsHost): void {\n    this.logger.warn(exception);\n\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n    const httpStatus = exception.getStatus();\n\n    // Example of fetching path to attach path inside response object\n    const request = ctx.getRequest();\n    // const path = httpAdapter.getRequestUrl(request);\n\n    // Sets the trace ID from the request object to the exception.\n    exception.setTraceId(request.id);\n\n    // Constructs the response body object.\n    const responseBody = exception.generateHttpResponseBody();\n\n    // Uses the HTTP adapter to send the response with the constructed response body\n    // and the HTTP status code.\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n"]}
{"filename": "src/config/transmitter.config.ts", "chunked_list": ["export interface ITransmitterConfig {\n  connectXToken: string;\n  cronServiceUrl: string;\n  messageStormServiceUrl: string;\n}\n\nexport const transmitterConfig = (): ITransmitterConfig => ({\n  connectXToken: process.env.CONNECT_X_TOKEN,\n  cronServiceUrl: process.env.CRON_SERVICE_URL,\n  messageStormServiceUrl: process.env.MESSAGE_STORM_SERVICE_URL,\n});\n"]}
{"filename": "src/config/database.config.ts", "chunked_list": ["export interface IDatabaseConfig {\n  uri: string;\n}\n\nexport const databaseConfig = (): IDatabaseConfig => ({\n  uri: process.env.MONGODB_URI,\n});\n"]}
{"filename": "src/config/app.config.ts", "chunked_list": ["export interface IAppConfig {\n  logo: string;\n  name: string;\n  panelUrl: string;\n}\n\nexport const appConfig = (): IAppConfig => ({\n  logo: process.env.APP_LOGO,\n  name: process.env.APP_NAME,\n  panelUrl: process.env.APP_PANEL_URL,\n});\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import { IAppConfig, appConfig } from './app.config';\nimport { IDatabaseConfig, databaseConfig } from './database.config';\nimport { ITransmitterConfig, transmitterConfig } from './transmitter.config';\nimport { NodeEnv } from '../shared/enums/node-env.enum';\n\nexport interface IConfig {\n  env: string;\n  port: number;\n  host: string;\n  logLevel: string;\n  clustering: string;\n  database: IDatabaseConfig;\n  logo: string;\n  app: IAppConfig;\n  transmitter: ITransmitterConfig;\n}\n\nexport const configuration = (): Partial<IConfig> => ({\n  env: process.env.NODE_ENV || NodeEnv.DEVELOPMENT,\n  port: parseInt(process.env.PORT, 10) || 3009,\n  host: process.env.HOST || '127.0.0.1',\n  logLevel: process.env.LOG_LEVEL,\n  clustering: process.env.CLUSTERING,\n  database: databaseConfig(),\n  app: appConfig(),\n  transmitter: transmitterConfig(),\n});\n"]}
{"filename": "src/exceptions/unauthorized.exception.ts", "chunked_list": ["/**\n * A custom exception that represents a Unauthorized error.\n */\n\n// Import required modules\nimport { ApiHideProperty, ApiProperty } from '@nestjs/swagger';\nimport { HttpException, HttpStatus } from '@nestjs/common';\n\n// Import internal modules\nimport { ExceptionConstants } from './exceptions.constants';", "// Import internal modules\nimport { ExceptionConstants } from './exceptions.constants';\nimport { IException, IHttpUnauthorizedExceptionResponse } from './exceptions.interface';\n\n/**\n * A custom exception for unauthorized access errors.\n */\nexport class UnauthorizedException extends HttpException {\n  /** The error code. */\n  @ApiProperty({\n    enum: ExceptionConstants.UnauthorizedCodes,\n    description: 'A unique code identifying the error.',\n    example: ExceptionConstants.UnauthorizedCodes.TOKEN_EXPIRED_ERROR,\n  })\n  code: number;\n\n  /** The error that caused this exception. */\n  @ApiHideProperty()\n  cause: Error;\n\n  /** The error message. */\n  @ApiProperty({\n    description: 'Message for the exception',\n    example: 'The authentication token provided has expired.',\n  })\n  message: string;\n\n  /** The detailed description of the error. */\n  @ApiProperty({\n    description: 'A description of the error message.',\n    example: 'This error message indicates that the authentication token provided with the request has expired, and therefore the server cannot verify the users identity.',\n  })\n  description: string;\n\n  /** Timestamp of the exception */\n  @ApiProperty({\n    description: 'Timestamp of the exception',\n    format: 'date-time',\n    example: '2022-12-31T23:59:59.999Z',\n  })\n  timestamp: string;\n\n  /** Trace ID of the request */\n  @ApiProperty({\n    description: 'Trace ID of the request',\n    example: '65b5f773-df95-4ce5-a917-62ee832fcdd0',\n  })\n  traceId: string; // Trace ID of the request\n\n  /**\n   * Constructs a new UnauthorizedException object.\n   * @param exception An object containing the exception details.\n   *  - message: A string representing the error message.\n   *  - cause: An object representing the cause of the error.\n   *  - description: A string describing the error in detail.\n   *  - code: A number representing internal status code which helpful in future for frontend\n   */\n  constructor(exception: IException) {\n    super(exception.message, HttpStatus.UNAUTHORIZED, {\n      cause: exception.cause,\n      description: exception.description,\n    });\n\n    this.message = exception.message;\n    this.cause = exception.cause;\n    this.description = exception.description;\n    this.code = exception.code;\n    this.timestamp = new Date().toISOString();\n  }\n\n  /**\n   * Set the Trace ID of the BadRequestException instance.\n   * @param traceId A string representing the Trace ID.\n   */\n  setTraceId = (traceId: string) => {\n    this.traceId = traceId;\n  };\n\n  /**\n   * Generate an HTTP response body representing the BadRequestException instance.\n   * @param message A string representing the message to include in the response body.\n   * @returns An object representing the HTTP response body.\n   */\n  generateHttpResponseBody = (message?: string): IHttpUnauthorizedExceptionResponse => {\n    return {\n      code: this.code,\n      message: message || this.message,\n      description: this.description,\n      timestamp: this.timestamp,\n      traceId: this.traceId,\n    };\n  };\n\n  /**\n   * A static method to generate an exception for token expiration error.\n   * @param msg - An optional error message.\n   * @returns An instance of the UnauthorizedException class.\n   */\n  static TOKEN_EXPIRED_ERROR = (msg?: string) => {\n    return new UnauthorizedException({\n      message: msg || 'The authentication token provided has expired.',\n      code: ExceptionConstants.UnauthorizedCodes.TOKEN_EXPIRED_ERROR,\n    });\n  };\n\n  /**\n   * A static method to generate an exception for invalid JSON web token.\n   * @param msg - An optional error message.\n   * @returns An instance of the UnauthorizedException class.\n   */\n  static JSON_WEB_TOKEN_ERROR = (msg?: string) => {\n    return new UnauthorizedException({\n      message: msg || 'Invalid token specified.',\n      code: ExceptionConstants.UnauthorizedCodes.JSON_WEB_TOKEN_ERROR,\n    });\n  };\n\n  /**\n   * A static method to generate an exception for unauthorized access to a resource.\n   * @param description - An optional detailed description of the error.\n   * @returns An instance of the UnauthorizedException class.\n   */\n  static UNAUTHORIZED_ACCESS = (description?: string) => {\n    return new UnauthorizedException({\n      message: 'Access to the requested resource is unauthorized.',\n      code: ExceptionConstants.UnauthorizedCodes.UNAUTHORIZED_ACCESS,\n      description,\n    });\n  };\n\n  /**\n   * Create a UnauthorizedException for when a resource is not found.\n   * @param {string} [msg] - Optional message for the exception.\n   * @returns {BadRequestException} - A UnauthorizedException with the appropriate error code and message.\n   */\n  static RESOURCE_NOT_FOUND = (msg?: string) => {\n    return new UnauthorizedException({\n      message: msg || 'Resource Not Found',\n      code: ExceptionConstants.UnauthorizedCodes.RESOURCE_NOT_FOUND,\n    });\n  };\n\n  /**\n   * Create a UnauthorizedException for when a resource is not found.\n   * @param {string} [msg] - Optional message for the exception.\n   * @returns {BadRequestException} - A UnauthorizedException with the appropriate error code and message.\n   */\n  static USER_NOT_VERIFIED = (msg?: string) => {\n    return new UnauthorizedException({\n      message: msg || 'User not verified. Please complete verification process before attempting this action.',\n      code: ExceptionConstants.UnauthorizedCodes.USER_NOT_VERIFIED,\n    });\n  };\n\n  /**\n   * A static method to generate an exception for unexpected errors.\n   * @param error - The error that caused this exception.\n   * @returns An instance of the UnauthorizedException class.\n   */\n  static UNEXPECTED_ERROR = (error: any) => {\n    return new UnauthorizedException({\n      message: 'An unexpected error occurred while processing the request. Please try again later.',\n      code: ExceptionConstants.UnauthorizedCodes.UNEXPECTED_ERROR,\n      cause: error,\n    });\n  };\n\n  /**\n   * A static method to generate an exception for when a forgot or change password time previous login token needs to be re-issued.\n   * @param msg - An optional error message.\n   * @returns - An instance of the UnauthorizedException class.\n   */\n  static REQUIRED_RE_AUTHENTICATION = (msg?: string) => {\n    return new UnauthorizedException({\n      message: msg || 'Your previous login session has been terminated due to a password change or reset. Please log in again with your new password.',\n      code: ExceptionConstants.UnauthorizedCodes.REQUIRED_RE_AUTHENTICATION,\n    });\n  };\n\n  /**\n   * A static method to generate an exception for reset password token is invalid.\n   * @param msg - An optional error message.\n   * @returns - An instance of the UnauthorizedException class.\n   */\n  static INVALID_RESET_PASSWORD_TOKEN = (msg?: string) => {\n    return new UnauthorizedException({\n      message: msg || 'The reset password token provided is invalid. Please request a new reset password token.',\n      code: ExceptionConstants.UnauthorizedCodes.INVALID_RESET_PASSWORD_TOKEN,\n    });\n  };\n}\n"]}
{"filename": "src/exceptions/exceptions.interface.ts", "chunked_list": ["export interface IException {\n  message: string;\n  code?: number;\n  cause?: Error;\n  description?: string;\n}\n\nexport interface IHttpBadRequestExceptionResponse {\n  code: number;\n  message: string;\n  description: string;\n  timestamp: string;\n  traceId: string;\n}\n", "export interface IHttpInternalServerErrorExceptionResponse {\n  code: number;\n  message: string;\n  description: string;\n  timestamp: string;\n  traceId: string;\n}\n\nexport interface IHttpUnauthorizedExceptionResponse {\n  code: number;\n  message: string;\n  description: string;\n  timestamp: string;\n  traceId: string;\n}\n", "export interface IHttpUnauthorizedExceptionResponse {\n  code: number;\n  message: string;\n  description: string;\n  timestamp: string;\n  traceId: string;\n}\n\nexport interface IHttpForbiddenExceptionResponse {\n  code: number;\n  message: string;\n  description: string;\n  timestamp: string;\n  traceId: string;\n}\n", "export interface IHttpForbiddenExceptionResponse {\n  code: number;\n  message: string;\n  description: string;\n  timestamp: string;\n  traceId: string;\n}\n"]}
{"filename": "src/exceptions/exceptions.constants.ts", "chunked_list": ["/**\n * This class defines constants for HTTP error codes.\n */\nexport class ExceptionConstants {\n  /**\n   * Constants for bad request HTTP error codes.\n   */\n  public static readonly BadRequestCodes = {\n    MISSING_REQUIRED_PARAMETER: 10001, // Required parameter is missing from request\n    INVALID_PARAMETER_VALUE: 10002, // Parameter value is invalid\n    UNSUPPORTED_PARAMETER: 10003, // Request contains unsupported parameter", "    INVALID_CONTENT_TYPE: 10004, // Content type of request is invalid\n    INVALID_REQUEST_BODY: 10005, // Request body is invalid\n    RESOURCE_ALREADY_EXISTS: 10006, // Resource already exists\n    RESOURCE_NOT_FOUND: 10007, // Resource not found\n    REQUEST_TOO_LARGE: 10008, // Request is too large\n    REQUEST_ENTITY_TOO_LARGE: 10009, // Request entity is too large\n    REQUEST_URI_TOO_LONG: 10010, // Request URI is too long\n    UNSUPPORTED_MEDIA_TYPE: 10011, // Request contains unsupported media type\n    METHOD_NOT_ALLOWED: 10012, // Request method is not allowed\n    HTTP_REQUEST_TIMEOUT: 10013, // Request has timed out\n    VALIDATION_ERROR: 10014, // Request validation error\n    UNEXPECTED_ERROR: 10015, // Unexpected error occurred\n    INVALID_INPUT: 10016, // Invalid input\n  };\n\n  /**\n   * Constants for unauthorized HTTP error codes.\n   */\n  public static readonly UnauthorizedCodes = {\n    UNAUTHORIZED_ACCESS: 20001, // Unauthorized access to resource\n    INVALID_CREDENTIALS: 20002, // Invalid credentials provided\n    JSON_WEB_TOKEN_ERROR: 20003, // JSON web token error\n    AUTHENTICATION_FAILED: 20004, // Authentication failed\n    ACCESS_TOKEN_EXPIRED: 20005, // Access token has expired\n    TOKEN_EXPIRED_ERROR: 20006, // Token has expired error\n    UNEXPECTED_ERROR: 20007, // Unexpected error occurred\n    RESOURCE_NOT_FOUND: 20008, // Resource not found\n    USER_NOT_VERIFIED: 20009, // User not verified\n    REQUIRED_RE_AUTHENTICATION: 20010, // Required re-authentication\n    INVALID_RESET_PASSWORD_TOKEN: 20011, // Invalid reset password token\n  };\n\n  /**\n   * Constants for internal server error HTTP error codes.\n   */\n  public static readonly InternalServerErrorCodes = {\n    INTERNAL_SERVER_ERROR: 30001, // Internal server error\n    DATABASE_ERROR: 30002, // Database error\n    NETWORK_ERROR: 30003, // Network error\n    THIRD_PARTY_SERVICE_ERROR: 30004, // Third party service error\n    SERVER_OVERLOAD: 30005, // Server is overloaded\n    UNEXPECTED_ERROR: 30006, // Unexpected error occurred\n  };\n\n  /**\n   * Constants for forbidden HTTP error codes.\n   */\n  public static readonly ForbiddenCodes = {\n    FORBIDDEN: 40001, // Access to resource is forbidden\n    MISSING_PERMISSIONS: 40002, // User does not have the required permissions to access the resource\n    EXCEEDED_RATE_LIMIT: 40003, // User has exceeded the rate limit for accessing the resource\n    RESOURCE_NOT_FOUND: 40004, // The requested resource could not be found\n    TEMPORARILY_UNAVAILABLE: 40005, // The requested resource is temporarily unavailable\n  };\n}\n"]}
{"filename": "src/exceptions/internal-server-error.exception.ts", "chunked_list": ["import { ApiHideProperty, ApiProperty } from '@nestjs/swagger';\nimport { HttpException, HttpStatus } from '@nestjs/common';\n\n// Import internal files & modules\nimport { ExceptionConstants } from './exceptions.constants';\nimport { IException, IHttpInternalServerErrorExceptionResponse } from './exceptions.interface';\n\n// Exception class for Internal Server Error\nexport class InternalServerErrorException extends HttpException {\n  @ApiProperty({\n    enum: ExceptionConstants.InternalServerErrorCodes,\n    description: 'A unique code identifying the error.',\n    example: ExceptionConstants.InternalServerErrorCodes.INTERNAL_SERVER_ERROR,\n  })\n  code: number; // Internal status code\n\n  @ApiHideProperty()\n  cause: Error; // Error object causing the exception\n\n  @ApiProperty({\n    description: 'Message for the exception',\n    example: 'An unexpected error occurred while processing your request.',\n  })\n  message: string; // Message for the exception\n\n  @ApiProperty({\n    description: 'A description of the error message.',\n    example:\n      'The server encountered an unexpected condition that prevented it from fulfilling the request. This could be due to an error in the application code, a misconfiguration in the server, or an issue with the underlying infrastructure. Please try again later or contact the server administrator if the problem persists.',\n  })\n  description: string; // Description of the exception\n\n  @ApiProperty({\n    description: 'Timestamp of the exception',\n    format: 'date-time',\n    example: '2022-12-31T23:59:59.999Z',\n  })\n  timestamp: string; // Timestamp of the exception\n\n  @ApiProperty({\n    description: 'Trace ID of the request',\n    example: '65b5f773-df95-4ce5-a917-62ee832fcdd0',\n  })\n  traceId: string; // Trace ID of the request\n\n  /**\n   * Constructs a new InternalServerErrorException object.\n   * @param exception An object containing the exception details.\n   *  - message: A string representing the error message.\n   *  - cause: An object representing the cause of the error.\n   *  - description: A string describing the error in detail.\n   *  - code: A number representing internal status code which helpful in future for frontend\n   */\n  constructor(exception: IException) {\n    super(exception.message, HttpStatus.INTERNAL_SERVER_ERROR, {\n      cause: exception.cause,\n      description: exception.description,\n    });\n    this.message = exception.message;\n    this.cause = exception.cause;\n    this.description = exception.description;\n    this.code = exception.code;\n    this.timestamp = new Date().toISOString();\n  }\n\n  /**\n   * Set the Trace ID of the BadRequestException instance.\n   * @param traceId A string representing the Trace ID.\n   */\n  setTraceId = (traceId: string) => {\n    this.traceId = traceId;\n  };\n\n  /**\n   * Generate an HTTP response body representing the BadRequestException instance.\n   * @param message A string representing the message to include in the response body.\n   * @returns An object representing the HTTP response body.\n   */\n  generateHttpResponseBody = (message?: string): IHttpInternalServerErrorExceptionResponse => {\n    return {\n      code: this.code,\n      message: message || this.message,\n      description: this.description,\n      timestamp: this.timestamp,\n      traceId: this.traceId,\n    };\n  };\n\n  /**\n   * Returns a new instance of InternalServerErrorException with a standard error message and code\n   * @param error Error object causing the exception\n   * @returns A new instance of InternalServerErrorException\n   */\n  static INTERNAL_SERVER_ERROR = (error: any) => {\n    return new InternalServerErrorException({\n      message: 'We are sorry, something went wrong on our end. Please try again later or contact our support team for assistance.',\n      code: ExceptionConstants.InternalServerErrorCodes.INTERNAL_SERVER_ERROR,\n      cause: error,\n    });\n  };\n\n  /**\n   * Returns a new instance of InternalServerErrorException with a custom error message and code\n   * @param error Error object causing the exception\n   * @returns A new instance of InternalServerErrorException\n   */\n  static UNEXPECTED_ERROR = (error: any) => {\n    return new InternalServerErrorException({\n      message: 'An unexpected error occurred while processing the request.',\n      code: ExceptionConstants.InternalServerErrorCodes.UNEXPECTED_ERROR,\n      cause: error,\n    });\n  };\n}\n", "export class InternalServerErrorException extends HttpException {\n  @ApiProperty({\n    enum: ExceptionConstants.InternalServerErrorCodes,\n    description: 'A unique code identifying the error.',\n    example: ExceptionConstants.InternalServerErrorCodes.INTERNAL_SERVER_ERROR,\n  })\n  code: number; // Internal status code\n\n  @ApiHideProperty()\n  cause: Error; // Error object causing the exception\n\n  @ApiProperty({\n    description: 'Message for the exception',\n    example: 'An unexpected error occurred while processing your request.',\n  })\n  message: string; // Message for the exception\n\n  @ApiProperty({\n    description: 'A description of the error message.',\n    example:\n      'The server encountered an unexpected condition that prevented it from fulfilling the request. This could be due to an error in the application code, a misconfiguration in the server, or an issue with the underlying infrastructure. Please try again later or contact the server administrator if the problem persists.',\n  })\n  description: string; // Description of the exception\n\n  @ApiProperty({\n    description: 'Timestamp of the exception',\n    format: 'date-time',\n    example: '2022-12-31T23:59:59.999Z',\n  })\n  timestamp: string; // Timestamp of the exception\n\n  @ApiProperty({\n    description: 'Trace ID of the request',\n    example: '65b5f773-df95-4ce5-a917-62ee832fcdd0',\n  })\n  traceId: string; // Trace ID of the request\n\n  /**\n   * Constructs a new InternalServerErrorException object.\n   * @param exception An object containing the exception details.\n   *  - message: A string representing the error message.\n   *  - cause: An object representing the cause of the error.\n   *  - description: A string describing the error in detail.\n   *  - code: A number representing internal status code which helpful in future for frontend\n   */\n  constructor(exception: IException) {\n    super(exception.message, HttpStatus.INTERNAL_SERVER_ERROR, {\n      cause: exception.cause,\n      description: exception.description,\n    });\n    this.message = exception.message;\n    this.cause = exception.cause;\n    this.description = exception.description;\n    this.code = exception.code;\n    this.timestamp = new Date().toISOString();\n  }\n\n  /**\n   * Set the Trace ID of the BadRequestException instance.\n   * @param traceId A string representing the Trace ID.\n   */\n  setTraceId = (traceId: string) => {\n    this.traceId = traceId;\n  };\n\n  /**\n   * Generate an HTTP response body representing the BadRequestException instance.\n   * @param message A string representing the message to include in the response body.\n   * @returns An object representing the HTTP response body.\n   */\n  generateHttpResponseBody = (message?: string): IHttpInternalServerErrorExceptionResponse => {\n    return {\n      code: this.code,\n      message: message || this.message,\n      description: this.description,\n      timestamp: this.timestamp,\n      traceId: this.traceId,\n    };\n  };\n\n  /**\n   * Returns a new instance of InternalServerErrorException with a standard error message and code\n   * @param error Error object causing the exception\n   * @returns A new instance of InternalServerErrorException\n   */\n  static INTERNAL_SERVER_ERROR = (error: any) => {\n    return new InternalServerErrorException({\n      message: 'We are sorry, something went wrong on our end. Please try again later or contact our support team for assistance.',\n      code: ExceptionConstants.InternalServerErrorCodes.INTERNAL_SERVER_ERROR,\n      cause: error,\n    });\n  };\n\n  /**\n   * Returns a new instance of InternalServerErrorException with a custom error message and code\n   * @param error Error object causing the exception\n   * @returns A new instance of InternalServerErrorException\n   */\n  static UNEXPECTED_ERROR = (error: any) => {\n    return new InternalServerErrorException({\n      message: 'An unexpected error occurred while processing the request.',\n      code: ExceptionConstants.InternalServerErrorCodes.UNEXPECTED_ERROR,\n      cause: error,\n    });\n  };\n}\n"]}
{"filename": "src/exceptions/index.ts", "chunked_list": ["export * from './bad-request.exception';\nexport * from './internal-server-error.exception';\nexport * from './unauthorized.exception';\nexport * from './forbidden.exception';\n"]}
{"filename": "src/exceptions/forbidden.exception.ts", "chunked_list": ["/**\n * A custom exception that represents a Forbidden error.\n */\n\n// Import required modules\nimport { ApiHideProperty, ApiProperty } from '@nestjs/swagger';\nimport { HttpException, HttpStatus } from '@nestjs/common';\n\n// Import internal modules\nimport { ExceptionConstants } from './exceptions.constants';", "// Import internal modules\nimport { ExceptionConstants } from './exceptions.constants';\nimport { IException, IHttpForbiddenExceptionResponse } from './exceptions.interface';\n\n/**\n * A custom exception for forbidden errors.\n */\nexport class ForbiddenException extends HttpException {\n  /** The error code. */\n  @ApiProperty({\n    enum: ExceptionConstants.ForbiddenCodes,\n    description: 'You do not have permission to perform this action.',\n    example: ExceptionConstants.ForbiddenCodes.MISSING_PERMISSIONS,\n  })\n  code: number;\n\n  /** The error that caused this exception. */\n  @ApiHideProperty()\n  cause: Error;\n\n  /** The error message. */\n  @ApiProperty({\n    description: 'Message for the exception',\n    example: 'You do not have permission to perform this action.',\n  })\n  message: string;\n\n  /** The detailed description of the error. */\n  @ApiProperty({\n    description: 'A description of the error message.',\n  })\n  description: string;\n\n  /** Timestamp of the exception */\n  @ApiProperty({\n    description: 'Timestamp of the exception',\n    format: 'date-time',\n    example: '2022-12-31T23:59:59.999Z',\n  })\n  timestamp: string;\n\n  /** Trace ID of the request */\n  @ApiProperty({\n    description: 'Trace ID of the request',\n    example: '65b5f773-df95-4ce5-a917-62ee832fcdd0',\n  })\n  traceId: string; // Trace ID of the request\n\n  /**\n   * Constructs a new ForbiddenException object.\n   * @param exception An object containing the exception details.\n   *  - message: A string representing the error message.\n   *  - cause: An object representing the cause of the error.\n   *  - description: A string describing the error in detail.\n   *  - code: A number representing internal status code which helpful in future for frontend\n   */\n  constructor(exception: IException) {\n    super(exception.message, HttpStatus.FORBIDDEN, {\n      cause: exception.cause,\n      description: exception.description,\n    });\n\n    this.message = exception.message;\n    this.cause = exception.cause;\n    this.description = exception.description;\n    this.code = exception.code;\n    this.timestamp = new Date().toISOString();\n  }\n\n  /**\n   * Set the Trace ID of the ForbiddenException instance.\n   * @param traceId A string representing the Trace ID.\n   */\n  setTraceId = (traceId: string) => {\n    this.traceId = traceId;\n  };\n\n  /**\n   * Generate an HTTP response body representing the ForbiddenException instance.\n   * @param message A string representing the message to include in the response body.\n   * @returns An object representing the HTTP response body.\n   */\n  generateHttpResponseBody = (message?: string): IHttpForbiddenExceptionResponse => {\n    return {\n      code: this.code,\n      message: message || this.message,\n      description: this.description,\n      timestamp: this.timestamp,\n      traceId: this.traceId,\n    };\n  };\n\n  /**\n   * A static method to generate an exception forbidden error.\n   * @param msg - An optional error message.\n   * @returns An instance of the ForbiddenException class.\n   */\n  static FORBIDDEN = (msg?: string) => {\n    return new ForbiddenException({\n      message: msg || 'Access to this resource is forbidden.',\n      code: ExceptionConstants.ForbiddenCodes.FORBIDDEN,\n    });\n  };\n\n  /**\n   * A static method to generate an exception missing permissions error.\n   * @param msg - An optional error message.\n   * @returns An instance of the ForbiddenException class.\n   */\n  static MISSING_PERMISSIONS = (msg?: string) => {\n    return new ForbiddenException({\n      message: msg || 'You do not have permission to perform this action.',\n      code: ExceptionConstants.ForbiddenCodes.MISSING_PERMISSIONS,\n    });\n  };\n}\n"]}
{"filename": "src/exceptions/bad-request.exception.ts", "chunked_list": ["/**\n * A custom exception that represents a BadRequest error.\n */\n\n// Import required modules\nimport { ApiHideProperty, ApiProperty } from '@nestjs/swagger';\nimport { HttpException, HttpStatus } from '@nestjs/common';\n\n// Import internal modules\nimport { ExceptionConstants } from './exceptions.constants';", "// Import internal modules\nimport { ExceptionConstants } from './exceptions.constants';\nimport { IException, IHttpBadRequestExceptionResponse } from './exceptions.interface';\n\nexport class BadRequestException extends HttpException {\n  @ApiProperty({\n    enum: ExceptionConstants.BadRequestCodes,\n    description: 'A unique code identifying the error.',\n    example: ExceptionConstants.BadRequestCodes.VALIDATION_ERROR,\n  })\n  code: number; // Internal status code\n\n  @ApiHideProperty()\n  cause: Error; // Error object causing the exception\n\n  @ApiProperty({\n    description: 'Message for the exception',\n    example: 'Bad Request',\n  })\n  message: string; // Message for the exception\n\n  @ApiProperty({\n    description: 'A description of the error message.',\n    example: 'The input provided was invalid',\n  })\n  description: string; // Description of the exception\n\n  @ApiProperty({\n    description: 'Timestamp of the exception',\n    format: 'date-time',\n    example: '2022-12-31T23:59:59.999Z',\n  })\n  timestamp: string; // Timestamp of the exception\n\n  @ApiProperty({\n    description: 'Trace ID of the request',\n    example: '65b5f773-df95-4ce5-a917-62ee832fcdd0',\n  })\n  traceId: string; // Trace ID of the request\n\n  /**\n   * Constructs a new BadRequestException object.\n   * @param exception An object containing the exception details.\n   *  - message: A string representing the error message.\n   *  - cause: An object representing the cause of the error.\n   *  - description: A string describing the error in detail.\n   *  - code: A number representing internal status code which helpful in future for frontend\n   */\n  constructor(exception: IException) {\n    super(exception.message, HttpStatus.BAD_REQUEST, {\n      cause: exception.cause,\n      description: exception.description,\n    });\n    this.message = exception.message;\n    this.cause = exception.cause;\n    this.description = exception.description;\n    this.code = exception.code;\n    this.timestamp = new Date().toISOString();\n  }\n\n  /**\n   * Set the Trace ID of the BadRequestException instance.\n   * @param traceId A string representing the Trace ID.\n   */\n  setTraceId = (traceId: string) => {\n    this.traceId = traceId;\n  };\n\n  /**\n   * Generate an HTTP response body representing the BadRequestException instance.\n   * @param message A string representing the message to include in the response body.\n   * @returns An object representing the HTTP response body.\n   */\n  generateHttpResponseBody = (message?: string): IHttpBadRequestExceptionResponse => {\n    return {\n      code: this.code,\n      message: message || this.message,\n      description: this.description,\n      timestamp: this.timestamp,\n      traceId: this.traceId,\n    };\n  };\n\n  /**\n   * Returns a new instance of BadRequestException representing an HTTP Request Timeout error.\n   * @returns An instance of BadRequestException representing the error.\n   */\n  static HTTP_REQUEST_TIMEOUT = () => {\n    return new BadRequestException({\n      message: 'HTTP Request Timeout',\n      code: ExceptionConstants.BadRequestCodes.HTTP_REQUEST_TIMEOUT,\n    });\n  };\n\n  /**\n   * Create a BadRequestException for when a resource already exists.\n   * @param {string} [msg] - Optional message for the exception.\n   * @returns {BadRequestException} - A BadRequestException with the appropriate error code and message.\n   */\n  static RESOURCE_ALREADY_EXISTS = (msg?: string) => {\n    return new BadRequestException({\n      message: msg || 'Resource Already Exists',\n      code: ExceptionConstants.BadRequestCodes.RESOURCE_ALREADY_EXISTS,\n    });\n  };\n\n  /**\n   * Create a BadRequestException for when a resource is not found.\n   * @param {string} [msg] - Optional message for the exception.\n   * @returns {BadRequestException} - A BadRequestException with the appropriate error code and message.\n   */\n  static RESOURCE_NOT_FOUND = (msg?: string) => {\n    return new BadRequestException({\n      message: msg || 'Resource Not Found',\n      code: ExceptionConstants.BadRequestCodes.RESOURCE_NOT_FOUND,\n    });\n  };\n\n  /**\n   * Returns a new instance of BadRequestException representing a Validation Error.\n   * @param msg A string representing the error message.\n   * @returns An instance of BadRequestException representing the error.\n   */\n  static VALIDATION_ERROR = (msg?: string) => {\n    return new BadRequestException({\n      message: msg || 'Validation Error',\n      code: ExceptionConstants.BadRequestCodes.VALIDATION_ERROR,\n    });\n  };\n\n  /**\n   * Returns a new instance of BadRequestException representing an Unexpected Error.\n   * @param msg A string representing the error message.\n   * @returns An instance of BadRequestException representing the error.\n   */\n  static UNEXPECTED = (msg?: string) => {\n    return new BadRequestException({\n      message: msg || 'Unexpected Error',\n      code: ExceptionConstants.BadRequestCodes.UNEXPECTED_ERROR,\n    });\n  };\n\n  /**\n   * Returns a new instance of BadRequestException representing an Invalid Input.\n   * @param msg A string representing the error message.\n   * @returns An instance of BadRequestException representing the error.\n   */\n  static INVALID_INPUT = (msg?: string) => {\n    return new BadRequestException({\n      message: msg || 'Invalid Input',\n      code: ExceptionConstants.BadRequestCodes.INVALID_INPUT,\n    });\n  };\n}\n"]}
{"filename": "src/shared/enums/index.ts", "chunked_list": ["export * from './log-level.enum';\nexport * from './node-env.enum';\n"]}
{"filename": "src/shared/enums/log-level.enum.ts", "chunked_list": ["export enum LogLevel {\n  SILENT = 'silent',\n  TRACE = 'trace',\n  DEBUG = 'debug',\n  INFO = 'info',\n  WARN = 'warn',\n  ERROR = 'error',\n  FATAL = 'fatal',\n}\n"]}
{"filename": "src/shared/enums/node-env.enum.ts", "chunked_list": ["export enum NodeEnv {\n  DEVELOPMENT = 'development',\n  TEST = 'test',\n  PRODUCTION = 'production',\n}\n"]}
