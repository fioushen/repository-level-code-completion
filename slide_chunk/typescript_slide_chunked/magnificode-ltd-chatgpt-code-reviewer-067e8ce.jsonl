{"filename": "src/index.ts", "chunked_list": ["import CommentOnPullRequestService from './services/commentOnPullRequestService';\n\nconst commentOnPrService = new CommentOnPullRequestService();\n\ncommentOnPrService.addCommentToPr();\n"]}
{"filename": "src/config/promptsConfig.ts", "chunked_list": ["enum Prompt {\n  SYSTEM_PROMPT,\n}\n\nconst promptsConfig: { [key in Prompt]: string } = {\n  [Prompt.SYSTEM_PROMPT]:\n    'You now assume the role of a code reviewer. Based on the patch provide a list of suggestions how to improve the code with examples according to coding standards and best practices.\\nStart every suggestion with path to the file. Path to the file should start with @@ and end with @@',\n};\n\nexport default promptsConfig;\nexport { Prompt };\n"]}
{"filename": "src/config/errorsConfig.ts", "chunked_list": ["enum ErrorMessage {\n  MISSING_GITHUB_TOKEN,\n  MISSING_OPENAI_TOKEN,\n  NO_PULLREQUEST_IN_CONTEXT,\n  MISSING_PATCH_FOR_OPENAI_SUGGESTION,\n  NO_CHANGED_FILES_IN_PULL_REQUEST,\n}\n\nconst errorsConfig: { [key in ErrorMessage]: string } = {\n  [ErrorMessage.MISSING_GITHUB_TOKEN]:\n    'A GitHub token must be provided to use the Octokit API.',\n  [ErrorMessage.MISSING_OPENAI_TOKEN]:\n    'An OpenAI API token must be provided to use the OpenAI API. Make sure you have add a token with a name OPENAI_API_KEY in https://github.com/{user}/{repository}/settings/secrets/actions',\n  [ErrorMessage.NO_PULLREQUEST_IN_CONTEXT]:\n    'Pull request data must be provided, check payload and try again.',\n  [ErrorMessage.MISSING_PATCH_FOR_OPENAI_SUGGESTION]:\n    'The patch must be exist to provide a suggestions with Open AI',\n  [ErrorMessage.NO_CHANGED_FILES_IN_PULL_REQUEST]:\n    'There are not any changed files in provided pull request',\n};\n\nexport default errorsConfig;\nexport { ErrorMessage };\n"]}
{"filename": "src/services/types.ts", "chunked_list": ["import { getOctokit } from '@actions/github';\n\ntype Octokit = ReturnType<typeof getOctokit>;\n\ntype FilenameWithPatch = {\n  filename: string;\n  patch: string;\n  tokensUsed: number;\n};\n\ntype PullRequestInfo = {\n  owner: string;\n  repo: string;\n  pullHeadRef: string;\n  pullBaseRef: string;\n  pullNumber: number;\n};\n\nexport type { Octokit, FilenameWithPatch, PullRequestInfo };\n", "type PullRequestInfo = {\n  owner: string;\n  repo: string;\n  pullHeadRef: string;\n  pullBaseRef: string;\n  pullNumber: number;\n};\n\nexport type { Octokit, FilenameWithPatch, PullRequestInfo };\n"]}
{"filename": "src/services/commentOnPullRequestService.ts", "chunked_list": ["import { getInput } from '@actions/core';\nimport { context, getOctokit } from '@actions/github';\nimport { encode } from 'gpt-3-encoder';\n\nimport errorsConfig, { ErrorMessage } from '../config/errorsConfig';\nimport { FilenameWithPatch, Octokit, PullRequestInfo } from './types';\nimport concatenatePatchesToString from './utils/concatenatePatchesToString';\nimport divideFilesByTokenRange from './utils/divideFilesByTokenRange';\nimport extractFirstChangedLineFromPatch from './utils/extractFirstChangedLineFromPatch';\nimport getOpenAiSuggestions from './utils/getOpenAiSuggestions';", "import extractFirstChangedLineFromPatch from './utils/extractFirstChangedLineFromPatch';\nimport getOpenAiSuggestions from './utils/getOpenAiSuggestions';\nimport parseOpenAISuggestions from './utils/parseOpenAISuggestions';\n\nconst MAX_TOKENS = parseInt(getInput('max_tokens'), 10) || 4096;\nconst OPENAI_TIMEOUT = 20000;\n\nclass CommentOnPullRequestService {\n  private readonly octokitApi: Octokit;\n  private readonly pullRequest: PullRequestInfo;\n\n  constructor() {", "    if (!process.env.GITHUB_TOKEN) {\n      throw new Error(errorsConfig[ErrorMessage.MISSING_GITHUB_TOKEN]);\n    }\n\n    if (!process.env.OPENAI_API_KEY) {\n      throw new Error(errorsConfig[ErrorMessage.MISSING_OPENAI_TOKEN]);\n    }\n\n    if (!context.payload.pull_request) {\n      throw new Error(errorsConfig[ErrorMessage.NO_PULLREQUEST_IN_CONTEXT]);\n    }\n\n    this.octokitApi = getOctokit(process.env.GITHUB_TOKEN);\n\n    this.pullRequest = {\n      owner: context.repo.owner,\n      repo: context.repo.repo,\n      pullHeadRef: context.payload?.pull_request.head.ref,\n      pullBaseRef: context.payload?.pull_request.base.ref,\n      pullNumber: context.payload?.pull_request.number,\n    };\n  }\n\n  private async getBranchDiff() {\n    const { owner, repo, pullBaseRef, pullHeadRef } = this.pullRequest;\n\n    const { data: branchDiff } =\n      await this.octokitApi.rest.repos.compareCommits({\n        owner,\n        repo,\n        base: pullBaseRef,\n        head: pullHeadRef,\n      });\n\n    return branchDiff;\n  }\n\n  private async getLastCommit() {\n    const { owner, repo, pullNumber } = this.pullRequest;\n\n    const { data: commitsList } = await this.octokitApi.rest.pulls.listCommits({\n      owner,\n      repo,\n      per_page: 50,\n      pull_number: pullNumber,\n    });\n\n    return commitsList[commitsList.length - 1].sha;\n  }\n\n  private async createReviewComments(files: FilenameWithPatch[]) {\n    const suggestionsListText = await getOpenAiSuggestions(\n      concatenatePatchesToString(files),\n    );\n    const suggestionsByFile = parseOpenAISuggestions(suggestionsListText);\n    const { owner, repo, pullNumber } = this.pullRequest;\n    const lastCommitId = await this.getLastCommit();\n", "    if (!context.payload.pull_request) {\n      throw new Error(errorsConfig[ErrorMessage.NO_PULLREQUEST_IN_CONTEXT]);\n    }\n\n    this.octokitApi = getOctokit(process.env.GITHUB_TOKEN);\n\n    this.pullRequest = {\n      owner: context.repo.owner,\n      repo: context.repo.repo,\n      pullHeadRef: context.payload?.pull_request.head.ref,\n      pullBaseRef: context.payload?.pull_request.base.ref,\n      pullNumber: context.payload?.pull_request.number,\n    };\n  }\n\n  private async getBranchDiff() {\n    const { owner, repo, pullBaseRef, pullHeadRef } = this.pullRequest;\n\n    const { data: branchDiff } =\n      await this.octokitApi.rest.repos.compareCommits({\n        owner,\n        repo,\n        base: pullBaseRef,\n        head: pullHeadRef,\n      });\n\n    return branchDiff;\n  }\n\n  private async getLastCommit() {\n    const { owner, repo, pullNumber } = this.pullRequest;\n\n    const { data: commitsList } = await this.octokitApi.rest.pulls.listCommits({\n      owner,\n      repo,\n      per_page: 50,\n      pull_number: pullNumber,\n    });\n\n    return commitsList[commitsList.length - 1].sha;\n  }\n\n  private async createReviewComments(files: FilenameWithPatch[]) {\n    const suggestionsListText = await getOpenAiSuggestions(\n      concatenatePatchesToString(files),\n    );\n    const suggestionsByFile = parseOpenAISuggestions(suggestionsListText);\n    const { owner, repo, pullNumber } = this.pullRequest;\n    const lastCommitId = await this.getLastCommit();\n", "    for (const file of files) {\n      const firstChangedLine = extractFirstChangedLineFromPatch(file.patch);\n      const suggestionForFile = suggestionsByFile.find(\n        (suggestion) => suggestion.filename === file.filename,\n      );\n\n      if (suggestionForFile) {\n        try {\n          const consoleTimeLabel = `Comment was created successfully for file: ${file.filename}`;\n          console.time(consoleTimeLabel);\n\n          await this.octokitApi.rest.pulls.createReviewComment({\n            owner,\n            repo,\n            pull_number: pullNumber,\n            line: firstChangedLine,\n            path: suggestionForFile.filename,\n            body: `[ChatGPTReviewer]\\n${suggestionForFile.suggestionText}`,\n            commit_id: lastCommitId,\n          });\n\n          console.timeEnd(consoleTimeLabel);", "        } catch (error) {\n          console.error(\n            'An error occurred while trying to add a comment',\n            error,\n          );\n          throw error;\n        }\n      }\n    }\n  }\n\n  public async addCommentToPr() {\n    const { files } = await this.getBranchDiff();\n", "    if (!files) {\n      throw new Error(\n        errorsConfig[ErrorMessage.NO_CHANGED_FILES_IN_PULL_REQUEST],\n      );\n    }\n\n    const patchesList: FilenameWithPatch[] = [];\n    const filesTooLongToBeChecked: string[] = [];\n\n    for (const file of files) {\n      if (file.patch && encode(file.patch).length <= MAX_TOKENS / 2) {\n        patchesList.push({\n          filename: file.filename,\n          patch: file.patch,\n          tokensUsed: encode(file.patch).length,\n        });\n      } else {\n        filesTooLongToBeChecked.push(file.filename);\n      }\n    }\n", "    for (const file of files) {\n      if (file.patch && encode(file.patch).length <= MAX_TOKENS / 2) {\n        patchesList.push({\n          filename: file.filename,\n          patch: file.patch,\n          tokensUsed: encode(file.patch).length,\n        });\n      } else {\n        filesTooLongToBeChecked.push(file.filename);\n      }\n    }\n", "    if (filesTooLongToBeChecked.length > 0) {\n      console.log(\n        `The changes for ${filesTooLongToBeChecked.join(\n          ', ',\n        )} is too long to be checked.`,\n      );\n    }\n\n    const listOfFilesByTokenRange = divideFilesByTokenRange(\n      MAX_TOKENS / 2,\n      patchesList,\n    );\n\n    await this.createReviewComments(listOfFilesByTokenRange[0]);\n", "    if (listOfFilesByTokenRange.length > 1) {\n      let requestCount = 1;\n\n      const intervalId = setInterval(async () => {\n        if (requestCount >= listOfFilesByTokenRange.length) {\n          clearInterval(intervalId);\n          return;\n        }\n\n        await this.createReviewComments(listOfFilesByTokenRange[requestCount]);\n        requestCount += 1;\n      }, OPENAI_TIMEOUT);\n    }\n  }\n}\n\nexport default CommentOnPullRequestService;\n"]}
{"filename": "src/services/utils/getOpenAiSuggestions.ts", "chunked_list": ["import { getInput } from '@actions/core';\nimport fetch from 'node-fetch';\n\nimport errorsConfig, { ErrorMessage } from '../../config/errorsConfig';\nimport promptsConfig, { Prompt } from '../../config/promptsConfig';\n\nconst OPENAI_MODEL = getInput('model') || 'gpt-3.5-turbo';\n\nconst getOpenAiSuggestions = async (patch: string): Promise<any> => {\n  if (!patch) {\n    throw new Error(\n      errorsConfig[ErrorMessage.MISSING_PATCH_FOR_OPENAI_SUGGESTION],\n    );\n  }\n", "const getOpenAiSuggestions = async (patch: string): Promise<any> => {\n  if (!patch) {\n    throw new Error(\n      errorsConfig[ErrorMessage.MISSING_PATCH_FOR_OPENAI_SUGGESTION],\n    );\n  }\n\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer  ${process.env.OPENAI_API_KEY}`,\n      },\n      body: JSON.stringify({\n        model: OPENAI_MODEL,\n        messages: [\n          { role: 'system', content: promptsConfig[Prompt.SYSTEM_PROMPT] },\n          { role: 'user', content: patch },\n        ],\n      }),\n    });\n", "    if (!response.ok) throw new Error('Failed to post data.');\n\n    const responseJson = (await response.json()) as any;\n\n    const openAiSuggestion =\n      responseJson.choices.shift()?.message?.content || '';\n\n    return openAiSuggestion;\n  } catch (error) {\n    console.error('Error posting data:', error);\n    throw error;\n  }\n};\n\nexport default getOpenAiSuggestions;\n", "  } catch (error) {\n    console.error('Error posting data:', error);\n    throw error;\n  }\n};\n\nexport default getOpenAiSuggestions;\n"]}
{"filename": "src/services/utils/parseOpenAISuggestions.ts", "chunked_list": ["const parseOpenAISuggestions = (suggestionsText: string) => {\n  const regex = /@@(.+?)@@\\n([\\s\\S]*?)(?=\\n@@|$)/g;\n  const suggestionMatches = suggestionsText.matchAll(regex);\n  const suggestions = [];\n\n  for (const match of suggestionMatches) {\n    const filename = match[1].trim();\n    const suggestionText = match[2].trim();\n    suggestions.push({ filename, suggestionText });\n  }\n\n  return suggestions;\n};\n\nexport default parseOpenAISuggestions;\n"]}
{"filename": "src/services/utils/divideFilesByTokenRange.ts", "chunked_list": ["import { FilenameWithPatch } from '../types';\n\nconst divideFilesByTokenRange = (\n  tokensRange: number,\n  files: FilenameWithPatch[],\n) => {\n  const result: FilenameWithPatch[][] = [];\n\n  let currentArray: FilenameWithPatch[] = [];\n  let currentTokensUsed = 0;", "  let currentArray: FilenameWithPatch[] = [];\n  let currentTokensUsed = 0;\n\n  for (const file of files) {\n    if (currentTokensUsed + file.tokensUsed <= tokensRange) {\n      currentArray.push(file);\n      currentTokensUsed += file.tokensUsed;\n    } else {\n      result.push(currentArray);\n      currentArray = [file];\n      currentTokensUsed = file.tokensUsed;\n    }\n  }\n", "  if (currentArray.length > 0) {\n    result.push(currentArray);\n  }\n\n  return result;\n};\n\nexport default divideFilesByTokenRange;\n"]}
{"filename": "src/services/utils/extractFirstChangedLineFromPatch.ts", "chunked_list": ["const extractFirstChangedLineFromPatch = (patch: string) => {\n  const lineHeaderRegExp = /^@@ -\\d+,\\d+ \\+(\\d+),(\\d+) @@/;\n  const lines = patch.split('\\n');\n  const lineHeaderMatch = lines[0].match(lineHeaderRegExp);\n\n  let firstChangedLine = 1;\n\n  if (lineHeaderMatch) {\n    firstChangedLine = parseInt(lineHeaderMatch[1], 10);\n  }\n\n  return firstChangedLine;\n};\n\nexport default extractFirstChangedLineFromPatch;\n"]}
{"filename": "src/services/utils/concatenatePatchesToString.ts", "chunked_list": ["import { FilenameWithPatch } from '../types';\n\nconst concatenatePatchesToString = (files: FilenameWithPatch[]) =>\n  files.map(({ filename, patch }) => `${filename}\\n${patch}\\n`).join('');\n\nexport default concatenatePatchesToString;\n"]}
