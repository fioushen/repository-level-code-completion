{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      include: ['src/**/*.ts'],\n      reporter: ['text', 'json', 'html'],\n    },\n  },\n})", "  },\n})\n"]}
{"filename": "test/proxy.test.ts", "chunked_list": ["import { describe, beforeEach, expect, it } from 'vitest'\nimport supertest from 'supertest'\nimport type { SuperTest, Test } from 'supertest'\nimport type { App } from 'h3'\nimport { createApp, toNodeListener, eventHandler } from 'h3'\nimport { createProxyEventHandler } from '../src'\n\ndescribe('Validate proxy event handler', () => {\n  let app: App\n  let request: SuperTest<Test>", "  let app: App\n  let request: SuperTest<Test>\n\n  beforeEach(() => {\n    app = createApp({ debug: false })\n    app.use(\n      '/test',\n      eventHandler(() => 'Hello World!')\n    )\n    request = supertest(toNodeListener(app))", "    )\n    request = supertest(toNodeListener(app))\n  })\n\n  const proxyEventHandler = createProxyEventHandler({\n    target: 'http://127.0.0.1:3000',\n    pathRewrite: {\n      '/api': '',\n    },\n    pathFilter: ['/api/**'],", "    },\n    pathFilter: ['/api/**'],\n  })\n\n  it('returns 200 OK if proxy request is success', async () => {\n    app.use(eventHandler(proxyEventHandler))\n\n    const res = await request.get('/api/test')\n\n    expect(res.statusCode).toEqual(200)", "\n    expect(res.statusCode).toEqual(200)\n  })\n})\n"]}
{"filename": "lib/index.d.ts", "chunked_list": ["import { H3Event, ProxyOptions, EventHandler } from 'h3';\nimport { IncomingMessage } from 'http';\nimport { ConsolaOptions } from 'consola';\n\ntype CustomPathFilter = (\n  pathname: string,\n  req: IncomingMessage\n) => boolean\n\ntype PathFilterParams = string | string[] | CustomPathFilter\n", "type PathFilterParams = string | string[] | CustomPathFilter\n\ntype CustomPathRewriter = (\n  pathname: string,\n  req: IncomingMessage\n) => string | Promise<string>\n\ntype RewriteRecord = Record<string, string>\n\ntype PathRewriterParams = RewriteRecord | CustomPathRewriter\n", "type PathRewriterParams = RewriteRecord | CustomPathRewriter\n\ntype ProxyRequestOptions = ProxyOptions\n\ntype ConfigureProxyRequest = (event: H3Event) => ProxyRequestOptions\n\ninterface CreateProxyEventHandlerOptions {\n  target: string\n  pathFilter?: PathFilterParams\n  pathRewrite?: PathRewriterParams\n  // Configure options of proxyRequest which is h3's built-in util\n  configureProxyRequest?: ConfigureProxyRequest\n  // Whether to enable logger\n  enableLogger?: boolean\n  // Configure the options of consola\n  loggerOptions?: ConsolaOptions\n  // true/false, Default: false - changes the origin of the host header to the target URL\n  changeOrigin?: boolean\n}\n", "type CreateProxyEventHandler = (\n  options: CreateProxyEventHandlerOptions\n) => EventHandler\n\ndeclare const createProxyEventHandler: CreateProxyEventHandler\n\nexport { ConfigureProxyRequest, CreateProxyEventHandlerOptions, PathFilterParams, PathRewriterParams, createProxyEventHandler };\n"]}
{"filename": "types/index.d.ts", "chunked_list": ["import type {\n  CreateProxyEventHandler,\n  CreateProxyEventHandlerOptions,\n  ConfigureProxyRequest,\n} from '../src/interfaces/core'\nimport type { PathFilterParams } from '../src/interfaces/pathFilter'\nimport type { PathRewriterParams } from '../src/interfaces/pathRewriter'\n\ndeclare const createProxyEventHandler: CreateProxyEventHandler\n", "declare const createProxyEventHandler: CreateProxyEventHandler\n\nexport {\n  createProxyEventHandler,\n  CreateProxyEventHandlerOptions,\n  ConfigureProxyRequest,\n  PathFilterParams,\n  PathRewriterParams,\n}\n", "}\n"]}
{"filename": "src/proxyRequestStrategy.ts", "chunked_list": ["import type {\n  CreateProxyEventHandlerOptions,\n  ProxyRequestOptions,\n} from './interfaces/core'\nimport type { H3Event } from 'h3'\nimport { parseUrlToObject } from './urlParser'\n\nconst generateOutgoingHost = (target: string) => {\n  const { hostname, port } = parseUrlToObject(target)\n\n  if (port) {\n    return `${hostname}:${port}`\n  }\n\n  return `${hostname}`\n}\n\nconst createProxyRequestOptions = (\n  event: H3Event,\n  options: CreateProxyEventHandlerOptions\n): ProxyRequestOptions | undefined => {\n  const { configureProxyRequest, changeOrigin, target } = options\n\n  const defaultOptions: ProxyRequestOptions = {\n    headers: {},\n  }\n", "  const { hostname, port } = parseUrlToObject(target)\n\n  if (port) {\n    return `${hostname}:${port}`\n  }\n\n  return `${hostname}`\n}\n\nconst createProxyRequestOptions = (\n  event: H3Event,\n  options: CreateProxyEventHandlerOptions\n): ProxyRequestOptions | undefined => {\n  const { configureProxyRequest, changeOrigin, target } = options\n\n  const defaultOptions: ProxyRequestOptions = {\n    headers: {},\n  }\n", "  if (changeOrigin) {\n    defaultOptions.headers.host = generateOutgoingHost(target)\n  }\n\n  const incomingOptions =\n    typeof configureProxyRequest === 'function'\n      ? configureProxyRequest(event)\n      : {}\n\n  const finalOptions: ProxyRequestOptions = Object.assign(\n    defaultOptions,\n    incomingOptions\n  )\n\n  finalOptions.headers = Object.assign(\n    defaultOptions.headers,\n    incomingOptions.headers\n  )\n\n  return finalOptions\n}\n\nexport { createProxyRequestOptions }\n"]}
{"filename": "src/pathRewriter.ts", "chunked_list": ["import type {\n  CreatePathRewriter,\n  PathRewriterParams,\n  RewriteRule,\n  RewriteRecord,\n} from './interfaces/pathRewriter'\nimport isPlainObj from 'lodash/isPlainObject'\nimport { ERRORS } from './errors'\nimport type { Logger } from './interfaces/logger'\n\nfunction isValidRewriteConfig(rewriteConfig?: PathRewriterParams) {", "import type { Logger } from './interfaces/logger'\n\nfunction isValidRewriteConfig(rewriteConfig?: PathRewriterParams) {\n  if (typeof rewriteConfig === 'function') {\n    return true\n  } else if (isPlainObj(rewriteConfig)) {\n    return Object.keys(rewriteConfig as object).length !== 0\n  } else if (rewriteConfig === undefined || rewriteConfig === null) {\n    return false\n  } else {\n    throw new Error(ERRORS.ERR_PATH_REWRITER_CONFIG)\n  }\n}\n", "function parsePathRewriteRules(rewriteRecord: RewriteRecord, logger?: Logger) {\n  const rules: RewriteRule[] = []\n\n  if (isPlainObj(rewriteRecord)) {\n    for (const [key, value] of Object.entries(rewriteRecord)) {\n      rules.push({\n        regex: new RegExp(key),\n        value: value,\n      })\n      logger && logger.info('rewrite rule created: \"%s\" ~> \"%s\"', key, value)\n    }\n  }\n\n  return rules\n}\n\n/**\n * Create a path rewriter function\n */\nconst createPathRewriter: CreatePathRewriter = (rewriteConfig, logger) => {", "  if (!isValidRewriteConfig(rewriteConfig)) {\n    return\n  }\n\n  let rulesCache: RewriteRule[]\n\n  function rewritePath(path: string) {\n    let result = path\n\n    for (const rule of rulesCache) {\n      if (rule.regex.test(path)) {\n        result = result.replace(rule.regex, rule.value)\n        logger && logger.info('rewriting path from \"%s\" to \"%s\"', path, result)\n        break\n      }\n    }\n\n    return result\n  }\n", "    for (const rule of rulesCache) {\n      if (rule.regex.test(path)) {\n        result = result.replace(rule.regex, rule.value)\n        logger && logger.info('rewriting path from \"%s\" to \"%s\"', path, result)\n        break\n      }\n    }\n\n    return result\n  }\n", "  if (typeof rewriteConfig === 'function') {\n    const customRewriteFn = rewriteConfig\n    return customRewriteFn\n  } else {\n    rulesCache = parsePathRewriteRules(rewriteConfig as RewriteRecord, logger)\n    return rewritePath\n  }\n}\n\nexport { createPathRewriter }\n"]}
{"filename": "src/pathFilter.ts", "chunked_list": ["import isGlob from 'is-glob'\nimport micromatch from 'micromatch'\nimport type { IsTargetFilterPath } from './interfaces/pathFilter'\nimport { ERRORS } from './errors'\n\nconst isStringPath = (pathFilter?: string | string[]): pathFilter is string => {\n  return typeof pathFilter === 'string' && !isGlob(pathFilter)\n}\n\nconst isGlobPath = (pattern?: string | string[]): pattern is string => {", "\nconst isGlobPath = (pattern?: string | string[]): pattern is string => {\n  return typeof pattern === 'string' && isGlob(pattern)\n}\n\nconst isMultiPath = (\n  pathFilter?: string | string[]\n): pathFilter is string[] => {\n  return Array.isArray(pathFilter)\n}", "  return Array.isArray(pathFilter)\n}\n\nconst matchSingleStringPath = (\n  pathname: string,\n  pathFilter?: string\n): boolean => {\n  if (!pathFilter) return false\n  return pathname.indexOf(pathFilter) >= 0\n}\n\nconst matchMultiPath = (pathname: string, pathFilterList: string[]) => {\n  return pathFilterList.some((pattern) =>\n    matchSingleStringPath(pathname, pattern)\n  )\n}\n\nconst matchSingleGlobPath = (\n  pathname: string,\n  pattern?: string | string[]\n): boolean => {", "  if (!pattern) return false\n  const matches = micromatch([pathname], pattern)\n  return matches && matches.length > 0\n}\n\nconst matchMultiGlobPath = (pathname: string, patterns?: string | string[]) => {\n  return matchSingleGlobPath(pathname, patterns)\n}\n\n/**\n * checkout weather the path is target filter path\n */\nconst isTargetFilterPath: IsTargetFilterPath = (\n  pathname = '',\n  { pathFilter, req }\n) => {\n  // custom path filter", "  if (typeof pathFilter === 'function') {\n    return pathFilter(pathname, req)\n  }\n\n  // single glob\n  if (isGlobPath(pathFilter)) {\n    return matchSingleGlobPath(pathname, pathFilter)\n  }\n\n  // single string\n  if (isStringPath(pathFilter)) {\n    return matchSingleStringPath(pathname, pathFilter)\n  }\n\n  // multi path", "  if (isStringPath(pathFilter)) {\n    return matchSingleStringPath(pathname, pathFilter)\n  }\n\n  // multi path\n  if (isMultiPath(pathFilter)) {\n    if (pathFilter.every(isStringPath)) {\n      return matchMultiPath(pathname, pathFilter)\n    }\n\n    if ((pathFilter as string[]).every(isGlobPath)) {\n      return matchMultiGlobPath(pathname, pathFilter)\n    }\n\n    throw new Error(ERRORS.ERR_CONTEXT_MATCHER_INVALID_ARRAY)\n  }\n\n  return true\n}\n\nexport { isTargetFilterPath }\n", "    if ((pathFilter as string[]).every(isGlobPath)) {\n      return matchMultiGlobPath(pathname, pathFilter)\n    }\n\n    throw new Error(ERRORS.ERR_CONTEXT_MATCHER_INVALID_ARRAY)\n  }\n\n  return true\n}\n\nexport { isTargetFilterPath }\n"]}
{"filename": "src/logger.ts", "chunked_list": ["import consola from 'consola'\nimport type { CreateLogger } from './interfaces/logger'\n\nexport const createLogger: CreateLogger = ({ enableLogger, loggerOptions }) => {\n  const finalLoggerOptions = Object.assign({}, loggerOptions)\n\n  if (enableLogger) {\n    return consola.create(finalLoggerOptions)\n  }\n}\n"]}
{"filename": "src/errors.ts", "chunked_list": ["export enum ERRORS {\n  ERR_CONFIG_FACTORY_TARGET_MISSING = '[h3-proxy] Missing \"target\" option. Example: {target: \"http://www.example.org\"}',\n  ERR_CONTEXT_MATCHER_INVALID_ARRAY = '[h3-proxy] Invalid pathFilter. Expecting something like: [\"/api\", \"/ajax\"] or [\"/api/**\", \"!**.html\"]',\n  ERR_PATH_REWRITER_CONFIG = '[h3-proxy] Invalid pathRewrite config. Expecting object with pathRewrite config or a rewrite function',\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { isTargetFilterPath } from './pathFilter'\nimport type { CreateProxyEventHandler } from './interfaces/core'\nimport { createPathRewriter } from './pathRewriter'\nimport { proxyRequest } from 'h3'\nimport { ERRORS } from './errors'\nimport { createLogger } from './logger'\nimport { createProxyRequestOptions } from './proxyRequestStrategy'\nimport { getUrlPath } from './urlParser'\n\nconst createProxyEventHandler: CreateProxyEventHandler = (options) => {", "\nconst createProxyEventHandler: CreateProxyEventHandler = (options) => {\n  const finalOptions = Object.assign({ enableLogger: true }, options)\n  const { target, pathFilter, pathRewrite, enableLogger, loggerOptions } =\n    finalOptions\n\n  if (!target) {\n    throw new Error(ERRORS.ERR_CONFIG_FACTORY_TARGET_MISSING)\n  }\n\n  const logger = createLogger({\n    enableLogger,\n    loggerOptions,\n  })\n\n  return async (event) => {\n    const { req } = event.node\n\n    const path = getUrlPath(req.url, target)\n\n    // generate proxy request options via default strategy\n    const proxyRequestOptions = createProxyRequestOptions(event, finalOptions)\n", "    if (isTargetFilterPath(path, { pathFilter, req })) {\n      const pathRewriter = createPathRewriter(pathRewrite, logger)\n\n      let rewritedPath = path\n\n      if (pathRewriter) {\n        rewritedPath = await pathRewriter(path, req)\n      }\n\n      const targetUrl = `${target}${rewritedPath}`\n\n      logger && logger.success('proxy to target url:', targetUrl)\n\n      return proxyRequest(event, targetUrl, proxyRequestOptions)\n    }\n  }\n}\n\nexport { createProxyEventHandler }\n"]}
{"filename": "src/urlParser.ts", "chunked_list": ["import { URL } from 'node:url'\n\nconst parseUrlToObject = (url: string) => {\n  return new URL(url)\n}\n\nconst getUrlPath = (url?: string, base?: string) => {\n  if (!url) return ''\n\n  const { pathname, search } = new URL(url, base)\n\n  return `${pathname}${search}`\n}\n\nexport { parseUrlToObject, getUrlPath }\n"]}
{"filename": "src/interfaces/pathRewriter.ts", "chunked_list": ["import type { IncomingMessage } from 'http'\nimport type { Logger } from './logger'\n\nexport type CustomPathRewriter = (\n  pathname: string,\n  req: IncomingMessage\n) => string | Promise<string>\n\nexport type RewriteRecord = Record<string, string>\n\nexport type PathRewriterParams = RewriteRecord | CustomPathRewriter\n", "export type RewriteRecord = Record<string, string>\n\nexport type PathRewriterParams = RewriteRecord | CustomPathRewriter\n\nexport type CreatePathRewriter = (\n  pathRewrite?: PathRewriterParams,\n  logger?: Logger\n) => CustomPathRewriter | undefined\n\nexport type RewriteRule = { regex: RegExp; value: string }\n", "export type RewriteRule = { regex: RegExp; value: string }\n"]}
{"filename": "src/interfaces/core.ts", "chunked_list": ["import type { EventHandler, ProxyOptions, H3Event } from 'h3'\nimport type { PathFilterParams } from './pathFilter'\nimport type { PathRewriterParams } from './pathRewriter'\nimport type { ConsolaOptions } from 'consola'\n\nexport type ProxyRequestOptions = ProxyOptions\n\nexport type ConfigureProxyRequest = (event: H3Event) => ProxyRequestOptions\n\nexport interface CreateProxyEventHandlerOptions {\n  target: string\n  pathFilter?: PathFilterParams\n  pathRewrite?: PathRewriterParams\n  // Configure options of proxyRequest which is h3's built-in util\n  configureProxyRequest?: ConfigureProxyRequest\n  // Whether to enable logger\n  enableLogger?: boolean\n  // Configure the options of consola\n  loggerOptions?: ConsolaOptions\n  // true/false, Default: false - changes the origin of the host header to the target URL\n  changeOrigin?: boolean\n}\n", "export interface CreateProxyEventHandlerOptions {\n  target: string\n  pathFilter?: PathFilterParams\n  pathRewrite?: PathRewriterParams\n  // Configure options of proxyRequest which is h3's built-in util\n  configureProxyRequest?: ConfigureProxyRequest\n  // Whether to enable logger\n  enableLogger?: boolean\n  // Configure the options of consola\n  loggerOptions?: ConsolaOptions\n  // true/false, Default: false - changes the origin of the host header to the target URL\n  changeOrigin?: boolean\n}\n", "export type CreateProxyEventHandler = (\n  options: CreateProxyEventHandlerOptions\n) => EventHandler\n"]}
{"filename": "src/interfaces/pathFilter.ts", "chunked_list": ["import type { IncomingMessage } from 'http'\n\nexport type CustomPathFilter = (\n  pathname: string,\n  req: IncomingMessage\n) => boolean\n\nexport type PathFilterParams = string | string[] | CustomPathFilter\n\nexport type IsTargetFilterPath = (\n  pathname: string | undefined,\n  opts: {\n    pathFilter?: PathFilterParams\n    req: IncomingMessage\n  }\n) => boolean\n", "export type IsTargetFilterPath = (\n  pathname: string | undefined,\n  opts: {\n    pathFilter?: PathFilterParams\n    req: IncomingMessage\n  }\n) => boolean\n"]}
{"filename": "src/interfaces/logger.ts", "chunked_list": ["import type { ConsolaOptions, Consola } from 'consola'\n\nexport interface CreateLoggerOptions {\n  // Whether to enable logger\n  enableLogger?: boolean\n  // Configure the options of consola\n  loggerOptions?: ConsolaOptions\n}\n\nexport type Logger = Consola\n", "export type Logger = Consola\n\nexport type CreateLogger = (options: CreateLoggerOptions) => Logger | undefined\n"]}
