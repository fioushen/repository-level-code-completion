{"filename": "tests/ManualField.test.ts", "chunked_list": ["import Field, { type FieldParams } from '../src/Field';\nimport ManualField from '../src/ManualField';\nimport { invalid, valid } from '../src/validators';\nimport { itCallsTheOnChangeCallback } from './support/callbacks';\n\ndescribe( 'ManualField', () => {\n\tconst after2021 = ( value: Date ) => (\n\t\tvalue.getFullYear() > 2021 ? valid() : invalid( 'Date is invalid' )\n\t);\n\tconst createField = ( params?: Partial<FieldParams<Date>> ) => new ManualField<Date>( {\n\t\tdefaultValue: new Date(),\n\t\tvalue: new Date( 2022, 10, 10 ),\n\t\tvalidators: [ after2021 ],\n\t\t...params\n\t} );\n\n\tconst itChangesTheFieldValue = (\n\t\tchangingAction: ( field: ManualField<Date>, value: Date ) => void\n\t) => {\n\t\tit( 'updates the value of the field with the given one', () => {\n\t\t\tconst field = createField();\n\t\t\tconst newValue = new Date( 2022, 12, 3 );\n\n\t\t\tchangingAction( field, newValue );\n\n\t\t\texpect( field.value ).toEqual( newValue );\n\t\t} );\n\n\t\tit( 'shows the error if the new value is not valid', () => {\n\t\t\tconst field = createField();\n\n\t\t\tchangingAction( field, new Date( 2021, 11, 31 ) );\n\n\t\t\texpect( field.error ).toEqual( 'Date is invalid' );\n\t\t} );\n\n\t\tit( 'hides the error if the old value was invalid and the new one is not', () => {\n\t\t\tconst field = createField();\n\n\t\t\tchangingAction( field, new Date( 2021, 11, 31 ) );\n\t\t\tchangingAction( field, new Date( 2022, 0, 1 ) );\n\n\t\t\texpect( field.error ).toEqual( '' );\n\t\t} );\n\n\t\titCallsTheOnChangeCallback<ManualField<Date>>( {\n\t\t\tfieldBuilder: onChange => createField( { onChange } ),\n\t\t\tchangingAction,\n\t\t\tsampleValue: new Date()\n\t\t} );\n\t};\n\n\tit( 'is a Field', () => {\n\t\tconst field = createField();\n\n\t\texpect( field ).toBeInstanceOf( Field );\n\t} );\n\n\tdescribe( '@change', () => {\n\t\titChangesTheFieldValue( ( field, value ) => field.change( value ) );\n\t} );\n\n\tdescribe( '@set', () => {\n\t\titChangesTheFieldValue( ( field, value ) => field.set( value ) );\n\t} );\n\n\tdescribe( '@select', () => {\n\t\titChangesTheFieldValue( ( field, value ) => field.select( value ) );\n\t} );\n} );\n"]}
{"filename": "tests/Field.test.ts", "chunked_list": ["import TestField from './support/TestField';\nimport type { FieldParams } from '../src/Field';\nimport Form from '../src/Form';\nimport { invalid, valid } from '../src/validators';\n\ndescribe( 'Field', () => {\n\tconst label = 'A field';\n\tconst hint = 'Some hint';\n\tconst initialValue = 'Content';\n\tconst defaultValue = 'Defval';", "\tconst initialValue = 'Content';\n\tconst defaultValue = 'Defval';\n\tconst presenceValidator = ( value: string ) => (\n\t\tvalue ? valid() : invalid( 'This is required.' )\n\t);\n\tconst lengthValidator = ( value: string ) => (\n\t\tvalue.length <= 7 ? valid() : invalid( 'Too long!' )\n\t);\n\n\tconst createField = ( params?: Partial<FieldParams<string>> ) => new TestField( {", "\n\tconst createField = ( params?: Partial<FieldParams<string>> ) => new TestField( {\n\t\tlabel,\n\t\thint,\n\t\tdefaultValue,\n\t\tvalue: initialValue,\n\t\tvalidators: [ presenceValidator, lengthValidator ],\n\t\tdisabled: false,\n\t\t...params\n\t} );", "\t\t...params\n\t} );\n\n\tdescribe( 'constructor', () => {\n\t\tit( 'assigns the given attributes to the field', () => {\n\t\t\tconst field = createField();\n\n\t\t\texpect( field.label ).toEqual( label );\n\t\t\texpect( field.hint ).toEqual( hint );\n\t\t\texpect( field.value ).toEqual( initialValue );", "\t\t\texpect( field.hint ).toEqual( hint );\n\t\t\texpect( field.value ).toEqual( initialValue );\n\t\t\texpect( field.isDisabled ).toEqual( false );\n\n\t\t\tconst disabledField = createField( { disabled: true } );\n\n\t\t\texpect( disabledField.isDisabled ).toEqual( true );\n\t\t} );\n\n\t\tdescribe( 'without label, hint and disabled attributes', () => {", "\n\t\tdescribe( 'without label, hint and disabled attributes', () => {\n\t\t\tit( 'assigns default values for them', () => {\n\t\t\t\tconst field = createField( { label: undefined, hint: undefined, disabled: undefined } );\n\n\t\t\t\texpect( field.label ).toEqual( '' );\n\t\t\t\texpect( field.hint ).toEqual( '' );\n\t\t\t\texpect( field.isDisabled ).toBe( false );\n\t\t\t} );\n\t\t} );", "\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'without value', () => {\n\t\t\tit( 'assigns the given defaultValue as the initial value', () => {\n\t\t\t\tconst field = createField( { value: undefined, hint: undefined, disabled: undefined } );\n\n\t\t\t\texpect( field.value ).toBe( defaultValue );\n\t\t\t} );\n\t\t} );", "\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@isValid', () => {\n\t\tdescribe( 'when the field is constructed with a value not accepted by a validator', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst field = createField( { value: 'Too long' } );\n\n\t\t\t\texpect( field.isValid ).toBe( false );", "\n\t\t\t\texpect( field.isValid ).toBe( false );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the field is constructed with a value accepted by all validators', () => {\n\t\t\tit( 'returns true', () => {\n\t\t\t\tconst field = createField( { value: 'Ok' } );\n\n\t\t\t\texpect( field.isValid ).toBe( true );", "\n\t\t\t\texpect( field.isValid ).toBe( true );\n\t\t\t} );\n\n\t\t\tdescribe( 'but is then updated with a value not accepted by a validator', () => {\n\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\tconst field = createField( { value: 'Ok' } );\n\n\t\t\t\t\tfield.change( '' );\n", "\t\t\t\t\tfield.change( '' );\n\n\t\t\t\t\texpect( field.isValid ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@isDirty', () => {\n\t\tdescribe( 'when the field\\'s value has not changed', () => {", "\tdescribe( '@isDirty', () => {\n\t\tdescribe( 'when the field\\'s value has not changed', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst field = createField();\n\n\t\t\t\texpect( field.isDirty ).toBe( false );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the field\\'s value has changed', () => {", "\n\t\tdescribe( 'when the field\\'s value has changed', () => {\n\t\t\tit( 'returns true', () => {\n\t\t\t\tconst field = createField();\n\n\t\t\t\tfield.change( 'Other content' );\n\n\t\t\t\texpect( field.isDirty ).toBe( true );\n\t\t\t} );\n", "\t\t\t} );\n\n\t\t\tdescribe( 'but is then changed to the initial value given in constructor', () => {\n\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\tconst field = createField();\n\n\t\t\t\t\tfield.change( 'Other content' );\n\t\t\t\t\tfield.change( initialValue );\n\n\t\t\t\t\texpect( field.isDirty ).toBe( false );", "\n\t\t\t\t\texpect( field.isDirty ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@setIsDisabled', () => {\n\t\tdescribe( 'when called with false', () => {\n\t\t\tit( 'sets the field as enabled', () => {", "\t\tdescribe( 'when called with false', () => {\n\t\t\tit( 'sets the field as enabled', () => {\n\t\t\t\tconst field = createField( { disabled: true } );\n\n\t\t\t\tfield.setIsDisabled( false );\n\n\t\t\t\texpect( field.isDisabled ).toBe( false );\n\t\t\t} );\n\t\t} );\n", "\t\t} );\n\n\t\tdescribe( 'when called with true', () => {\n\t\t\tit( 'sets the field as disabled', () => {\n\t\t\t\tconst field = createField( { disabled: false } );\n\n\t\t\t\tfield.setIsDisabled( true );\n\n\t\t\t\texpect( field.isDisabled ).toBe( true );\n\t\t\t} );", "\t\t\t\texpect( field.isDisabled ).toBe( true );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@clear', () => {\n\t\tit( 'sets the defaultValue given in constructor as the new value', () => {\n\t\t\tconst field = createField();\n\n\t\t\tfield.clear();", "\n\t\t\tfield.clear();\n\n\t\t\texpect( field.value ).toEqual( defaultValue );\n\t\t} );\n\n\t\tit( 'stops showing the error message', () => {\n\t\t\tconst field = createField();\n\n\t\t\tfield.change( '' );", "\n\t\t\tfield.change( '' );\n\t\t\tfield.syncError();\n\t\t\tfield.clear();\n\n\t\t\texpect( field.error ).toEqual( '' );\n\t\t} );\n\t} );\n\n\tdescribe( '@reset', () => {", "\n\tdescribe( '@reset', () => {\n\t\tit( 'resets the value of the field with the value given in constructor', () => {\n\t\t\tconst field = createField();\n\n\t\t\tfield.change( 'New content' );\n\t\t\tfield.reset();\n\n\t\t\texpect( field.value ).toEqual( initialValue );\n\t\t} );", "\t\t\texpect( field.value ).toEqual( initialValue );\n\t\t} );\n\n\t\tit( 'stops showing the error message', () => {\n\t\t\tconst field = createField();\n\n\t\t\tfield.change( '' );\n\t\t\tfield.syncError();\n\t\t\tfield.reset();\n", "\t\t\tfield.reset();\n\n\t\t\texpect( field.error ).toEqual( '' );\n\t\t} );\n\t} );\n\n\tdescribe( '@syncError', () => {\n\t\tdescribe( 'when the field is valid', () => {\n\t\t\tdescribe( 'and no error is being shown', () => {\n\t\t\t\tit( 'does not show any error message on the field', () => {", "\t\t\tdescribe( 'and no error is being shown', () => {\n\t\t\t\tit( 'does not show any error message on the field', () => {\n\t\t\t\t\tconst field = createField();\n\n\t\t\t\t\tfield.syncError();\n\n\t\t\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t\t} );\n\t\t\t} );\n", "\t\t\t} );\n\n\t\t\tdescribe( 'and an error is being shown', () => {\n\t\t\t\tit( 'hides the shown error message', () => {\n\t\t\t\t\tconst field = createField();\n\n\t\t\t\t\tfield.change( '' );\n\t\t\t\t\tfield.syncError();\n\t\t\t\t\tfield.change( 'good' );\n\t\t\t\t\tfield.syncError();", "\t\t\t\t\tfield.change( 'good' );\n\t\t\t\t\tfield.syncError();\n\n\t\t\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the field is invalid', () => {\n\t\t\tdescribe( 'and no error is being shown', () => {", "\t\tdescribe( 'when the field is invalid', () => {\n\t\t\tdescribe( 'and no error is being shown', () => {\n\t\t\t\tit( 'shows the error message of the first failing validator', () => {\n\t\t\t\t\tconst field = createField();\n\n\t\t\t\t\tfield.change( 'quite long' );\n\t\t\t\t\tfield.syncError();\n\n\t\t\t\t\texpect( field.error ).toEqual( 'Too long!' );\n\t\t\t\t} );", "\t\t\t\t\texpect( field.error ).toEqual( 'Too long!' );\n\t\t\t\t} );\n\t\t\t} );\n\n\t\t\tdescribe( 'and an error is being shown', () => {\n\t\t\t\tit( 'shows the error message of the first failing validator', () => {\n\t\t\t\t\tconst field = createField();\n\n\t\t\t\t\tfield.change( 'quite long' );\n\t\t\t\t\tfield.syncError();", "\t\t\t\t\tfield.change( 'quite long' );\n\t\t\t\t\tfield.syncError();\n\t\t\t\t\tfield.change( '' );\n\t\t\t\t\tfield.syncError();\n\n\t\t\t\t\texpect( field.error ).toEqual( 'This is required.' );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );", "\t\t} );\n\t} );\n\n\tdescribe( '@showError', () => {\n\t\tit( 'displays the given error on the field', () => {\n\t\t\tconst field = createField();\n\t\t\tconst error = 'That value is already being used';\n\n\t\t\tfield.showError( error );\n", "\t\t\tfield.showError( error );\n\n\t\t\texpect( field.error ).toEqual( error );\n\t\t} );\n\t} );\n\n\tdescribe( '@attachToForm', () => {\n\t\tconst createAndAttachField = () => {\n\t\t\tconst validator = jest.fn(\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars", "\t\t\tconst validator = jest.fn(\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t( _value: string, _form?: Form, _label?: string ) => valid()\n\t\t\t);\n\n\t\t\tconst form = new Form( {\n\t\t\t\tfields: {},\n\t\t\t\tonSubmit: () => Promise.resolve()\n\t\t\t} );\n", "\t\t\t} );\n\n\t\t\tconst field = createField( { validators: [ validator ] } );\n\n\t\t\tfield.attachToForm( form );\n\n\t\t\treturn { field, form, validator };\n\t\t};\n\n\t\tdescribe( 'when the field is not attached to any form', () => {", "\n\t\tdescribe( 'when the field is not attached to any form', () => {\n\t\t\tit( 'starts passing the given form and field key to the validators', () => {\n\t\t\t\tconst { field, form, validator } = createAndAttachField();\n\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\tfield.isValid;\n\n\t\t\t\texpect( validator ).toHaveBeenCalledWith( field.value, form, field.label );\n\t\t\t} );", "\t\t\t\texpect( validator ).toHaveBeenCalledWith( field.value, form, field.label );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the field is already attached to a form', () => {\n\t\t\tit( 'throws a runtime error', () => {\n\t\t\t\tconst { field, form } = createAndAttachField();\n\n\t\t\t\texpect( () => field.attachToForm( form ) ).toThrow( Error );\n\t\t\t} );", "\t\t\t\texpect( () => field.attachToForm( form ) ).toThrow( Error );\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n"]}
{"filename": "tests/Form.test.ts", "chunked_list": ["import ManualField from '../src/ManualField';\nimport TestField from './support/TestField';\nimport Form, { FormParams } from '../src/Form';\nimport { invalid, valid } from '../src/validators';\n\ndescribe( 'Form', () => {\n\tconst required = ( value: string ) => (\n\t\tvalue ? valid() : invalid( 'This field is required.' )\n\t);\n\tconst atLeastEightChars = ( value: string ) => (", "\t);\n\tconst atLeastEightChars = ( value: string ) => (\n\t\tvalue.length >= 8 ? valid() : invalid( 'At least eight chars.' )\n\t);\n\tconst matchPassword = ( value: string, form?: Form ) => (\n\t\tvalue === form?.field( 'password' ).value ? valid() : invalid( 'Password does not match' )\n\t);\n\n\tconst fields = {\n\t\temail: {", "\tconst fields = {\n\t\temail: {\n\t\t\tlabel: 'Email',\n\t\t\thint: 'Write it with a known domain',\n\t\t\tdefaultValue: 'no email',\n\t\t\tvalue: 'autofilled@test.com',\n\t\t\tvalidators: [ required ],\n\t\t\tdisabled: false\n\t\t},\n\t\tpassword: {", "\t\t},\n\t\tpassword: {\n\t\t\tlabel: 'Password',\n\t\t\thint: 'At least 8 characters',\n\t\t\tdefaultValue: 'no password',\n\t\t\tvalue: '',\n\t\t\tvalidators: [ required, atLeastEightChars ],\n\t\t\tdisabled: false\n\t\t},\n\t\tpasswordConfirmation: {", "\t\t},\n\t\tpasswordConfirmation: {\n\t\t\tlabel: 'Password confirmation',\n\t\t\tdefaultValue: 'no password confirmation',\n\t\t\tvalue: '',\n\t\t\tvalidators: [ required, matchPassword ]\n\t\t},\n\t\tdocument: {\n\t\t\tlabel: 'Document',\n\t\t\tdefaultValue: 'no document',", "\t\t\tlabel: 'Document',\n\t\t\tdefaultValue: 'no document',\n\t\t\tvalue: 'unused',\n\t\t\tvalidators: [ atLeastEightChars ],\n\t\t\tdisabled: true\n\t\t},\n\t\tadmin: {\n\t\t\tlabel: 'Admin?',\n\t\t\tdefaultValue: true,\n\t\t\tvalue: true", "\t\t\tdefaultValue: true,\n\t\t\tvalue: true\n\t\t}\n\t};\n\n\tconst onSubmit = jest.fn( () => Promise.resolve() );\n\n\tconst createForm = ( params?: Partial<FormParams> ) => new Form( {\n\t\tfields: {\n\t\t\temail: new TestField( fields.email ),", "\t\tfields: {\n\t\t\temail: new TestField( fields.email ),\n\t\t\tpassword: new TestField( fields.password ),\n\t\t\tpasswordConfirmation: new TestField( fields.passwordConfirmation ),\n\t\t\tdocument: new TestField( fields.document ),\n\t\t\tadmin: new ManualField( fields.admin )\n\t\t},\n\t\tonSubmit,\n\t\t...params\n\t} );", "\t\t...params\n\t} );\n\n\tconst createFormAndMakeItValid = ( params?: Partial<FormParams> ) => {\n\t\tconst form = createForm( params );\n\n\t\tform.field<TestField>( 'password' ).change( 'validpass' );\n\t\tform.field<TestField>( 'passwordConfirmation' ).change( 'validpass' );\n\n\t\treturn form;", "\n\t\treturn form;\n\t};\n\n\tconst itClearsTheErrorMessageOfEachField = ( action: ( form: Form ) => void ) => {\n\t\tit( 'clears the error message of each field', () => {\n\t\t\tconst form = createForm();\n\n\t\t\tform.field<TestField>( 'email' ).change( '' );\n\t\t\tform.field<TestField>( 'password' ).change( '' );", "\t\t\tform.field<TestField>( 'email' ).change( '' );\n\t\t\tform.field<TestField>( 'password' ).change( '' );\n\t\t\tform.submit();\n\n\t\t\taction( form );\n\n\t\t\t[ 'email', 'password', 'passwordConfirmation', 'document', 'admin' ].forEach( ( key ) => {\n\t\t\t\texpect( form.field( key ).error ).toEqual( '' );\n\t\t\t} );\n\t\t} );", "\t\t\t} );\n\t\t} );\n\t};\n\n\tafterEach( () => jest.clearAllMocks() );\n\n\tdescribe( '@fields', () => {\n\t\tit( 'returns an object with all the fields indexed by their keys', () => {\n\t\t\tconst form = createForm();\n", "\t\t\tconst form = createForm();\n\n\t\t\texpect( form.fields ).toEqual( {\n\t\t\t\temail: form.field( 'email' ),\n\t\t\t\tpassword: form.field( 'password' ),\n\t\t\t\tpasswordConfirmation: form.field( 'passwordConfirmation' ),\n\t\t\t\tdocument: form.field( 'document' ),\n\t\t\t\tadmin: form.field( 'admin' )\n\t\t\t} );\n\t\t} );", "\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@values', () => {\n\t\tit( 'returns an object with values per field key', () => {\n\t\t\tconst form = createForm();\n\n\t\t\texpect( form.values ).toEqual( {\n\t\t\t\temail: fields.email.value,", "\t\t\texpect( form.values ).toEqual( {\n\t\t\t\temail: fields.email.value,\n\t\t\t\tpassword: fields.password.value,\n\t\t\t\tpasswordConfirmation: fields.passwordConfirmation.value,\n\t\t\t\tdocument: fields.document.value,\n\t\t\t\tadmin: fields.admin.value\n\t\t\t} );\n\t\t} );\n\t} );\n", "\t} );\n\n\tdescribe( '@dirtyValues', () => {\n\t\tdescribe( 'when no field is dirty', () => {\n\t\t\tit( 'returns an empty object', () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\texpect( form.dirtyValues ).toEqual( {} );\n\t\t\t} );\n\t\t} );", "\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when one or more fields are dirty', () => {\n\t\t\tit( 'returns the values of the dirty fields', () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\tform.field<TestField>( 'email' ).change( 'new@test.com' );\n\t\t\t\tform.field<ManualField<boolean>>( 'admin' ).change( false );\n", "\t\t\t\tform.field<ManualField<boolean>>( 'admin' ).change( false );\n\n\t\t\t\texpect( form.dirtyValues ).toEqual( {\n\t\t\t\t\temail: 'new@test.com',\n\t\t\t\t\tadmin: false\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n", "\t} );\n\n\tdescribe( '@isValid', () => {\n\t\tdescribe( 'when all fields are valid', () => {\n\t\t\tit( 'returns true', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\tform.field<TestField>( 'document' ).change( 'validdoc' );\n\n\t\t\t\texpect( form.isValid ).toBe( true );\n\t\t\t} );", "\t\t\t\texpect( form.isValid ).toBe( true );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when only disabled fields are invalid', () => {\n\t\t\tit( 'returns true', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\texpect( form.isValid ).toBe( true );\n\t\t\t} );", "\t\t\t\texpect( form.isValid ).toBe( true );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when at least one enabled field is invalid', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\tform.field<TestField>( 'passwordConfirmation' ).change( 'is not the password' );\n", "\t\t\t\tform.field<TestField>( 'passwordConfirmation' ).change( 'is not the password' );\n\n\t\t\t\texpect( form.isValid ).toBe( false );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@isDirty', () => {\n\t\tdescribe( 'when no field is dirty', () => {\n\t\t\tit( 'returns false', () => {", "\t\tdescribe( 'when no field is dirty', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\texpect( form.isDirty ).toBe( false );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when one or more fields are dirty', () => {\n\t\t\tit( 'returns true', () => {", "\t\tdescribe( 'when one or more fields are dirty', () => {\n\t\t\tit( 'returns true', () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\tform.field<TestField>( 'password' ).change( 'sekret' );\n\n\t\t\t\texpect( form.isDirty ).toBe( true );\n\t\t\t} );\n\t\t} );\n\t} );", "\t\t} );\n\t} );\n\n\tdescribe( '@isReadyToSubmit', () => {\n\t\tdescribe( 'when one or more fields are invalid', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t} );", "\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the form is not dirty', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst form = createForm( {\n\t\t\t\t\tfields: {\n\t\t\t\t\t\temail: new TestField( fields.email )\n\t\t\t\t\t}", "\t\t\t\t\t\temail: new TestField( fields.email )\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the form is being submitted', () => {\n\t\t\tit( 'returns false', () => {", "\t\tdescribe( 'when the form is being submitted', () => {\n\t\t\tit( 'returns false', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\tform.submit();\n\n\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t} );\n\t\t} );\n", "\t\t} );\n\n\t\tdescribe( 'when the form is valid, dirty and is not being submitted', () => {\n\t\t\tit( 'returns true', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\texpect( form.isReadyToSubmit ).toBe( true );\n\t\t\t} );\n\t\t} );\n\t} );", "\t\t} );\n\t} );\n\n\tdescribe( '@field', () => {\n\t\tit( 'returns the field that has the given key', () => {\n\t\t\tconst form = createForm();\n\n\t\t\tconst documentField = form.field<TestField>( 'document' );\n\n\t\t\texpect( documentField.label ).toEqual( 'Document' );", "\n\t\t\texpect( documentField.label ).toEqual( 'Document' );\n\t\t\texpect( documentField.value ).toEqual( 'unused' );\n\t\t\texpect( documentField.isDisabled ).toBe( true );\n\t\t} );\n\t} );\n\n\tdescribe( '@select', () => {\n\t\tit( 'returns the field that has the given key', () => {\n\t\t\tconst form = createForm();", "\t\tit( 'returns the field that has the given key', () => {\n\t\t\tconst form = createForm();\n\n\t\t\tconst documentField = form.select<TestField>( 'document' );\n\n\t\t\texpect( documentField.label ).toEqual( 'Document' );\n\t\t\texpect( documentField.value ).toEqual( 'unused' );\n\t\t\texpect( documentField.isDisabled ).toBe( true );\n\t\t} );\n\t} );", "\t\t} );\n\t} );\n\n\tdescribe( '@eachField', () => {\n\t\tit( 'executes the given callback for each field', () => {\n\t\t\tconst form = createForm();\n\t\t\tconst fieldLabels: string[] = [];\n\n\t\t\tform.eachField( ( field ) => {\n\t\t\t\tfieldLabels.push( field.label );", "\t\t\tform.eachField( ( field ) => {\n\t\t\t\tfieldLabels.push( field.label );\n\t\t\t} );\n\n\t\t\texpect( fieldLabels ).toEqual(\n\t\t\t\tObject.values( fields ).map( ( { label } ) => label )\n\t\t\t);\n\t\t} );\n\t} );\n", "\t} );\n\n\tdescribe( '@submit', () => {\n\t\tit( 'syncronizes the errors of all fields', () => {\n\t\t\tconst form = createFormAndMakeItValid();\n\t\t\tconst email = form.field<TestField>( 'email' );\n\t\t\tconst password = form.field<TestField>( 'password' );\n\t\t\temail.change( '' );\n\t\t\temail.syncError();\n\t\t\temail.change( 'valid@again.com' );", "\t\t\temail.syncError();\n\t\t\temail.change( 'valid@again.com' );\n\t\t\tpassword.change( 'short' );\n\n\t\t\tform.submit();\n\n\t\t\texpect( email.error ).toEqual( '' );\n\t\t\texpect( password.error ).toEqual( 'At least eight chars.' );\n\t\t} );\n", "\t\t} );\n\n\t\tdescribe( 'when the form is valid and is not being submitted', () => {\n\t\t\tit( 'calls the onSubmit callback with itself as parameter', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\tform.submit();\n\n\t\t\t\texpect( onSubmit ).toHaveBeenCalledWith( form );\n\t\t\t} );", "\t\t\t\texpect( onSubmit ).toHaveBeenCalledWith( form );\n\t\t\t} );\n\n\t\t\tit( 'sets isSubmitting to true', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\tform.submit();\n\n\t\t\t\texpect( form.isSubmitting ).toBe( true );\n\t\t\t} );", "\t\t\t\texpect( form.isSubmitting ).toBe( true );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the onSubmit promise is resolved', () => {\n\t\t\t\tit( 'sets isSubmitting to false again', async () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\t\tawait form.submit();\n\n\t\t\t\t\texpect( form.isSubmitting ).toBe( false );", "\n\t\t\t\t\texpect( form.isSubmitting ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the onSubmit promise is rejected', () => {\n\t\t\t\tbeforeEach( () => onSubmit.mockRejectedValueOnce( 'error' ) );\n\n\t\t\t\tit( 'sets isSubmitting to false again and the returned promise is rejected', async () => {\n\t\t\t\t\texpect.assertions( 1 );", "\t\t\t\tit( 'sets isSubmitting to false again and the returned promise is rejected', async () => {\n\t\t\t\t\texpect.assertions( 1 );\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait form.submit();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\texpect( form.isSubmitting ).toBe( false );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the onSubmit callback does not return anything', () => {\n\t\t\t\tit( 'returns a resolved promise', async () => {\n\t\t\t\t\tconst form = createForm( { onSubmit: () => undefined } );\n\n\t\t\t\t\tawait expect( form.submit() ).resolves.not.toThrow();\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the form is invalid', () => {\n\t\t\tit( 'does not call the onSubmit callback', () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\tform.submit();\n\n\t\t\t\texpect( onSubmit ).not.toHaveBeenCalled();\n\t\t\t} );\n\n\t\t\tit( 'returns a resolved promise', async () => {\n\t\t\t\tconst form = createForm();\n\n\t\t\t\tform.submit();\n\n\t\t\t\tawait expect( form.submit() ).resolves.not.toThrow();\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the form is being submitted', () => {\n\t\t\tit( 'does not call the onSubmit callback', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\tform.submit();\n\t\t\t\tform.submit();\n\n\t\t\t\texpect( onSubmit ).toHaveBeenCalledTimes( 1 );\n\t\t\t} );\n\n\t\t\tit( 'returns a resolved promise', async () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\n\t\t\t\tform.submit();\n\n\t\t\t\tawait expect( form.submit() ).resolves.not.toThrow();\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@clear', () => {\n\t\tit( 'sets the value of each field to its default value', () => {\n\t\t\tconst form = createForm();\n\n\t\t\tform.clear();\n\n\t\t\texpect( form.values ).toEqual( {\n\t\t\t\temail: 'no email',\n\t\t\t\tpassword: 'no password',\n\t\t\t\tpasswordConfirmation: 'no password confirmation',\n\t\t\t\tdocument: 'no document',\n\t\t\t\tadmin: true\n\t\t\t} );\n\t\t} );\n\n\t\titClearsTheErrorMessageOfEachField( form => form.clear() );\n\t} );\n\n\tdescribe( '@reset', () => {\n\t\tit( 'resets the value of each field', () => {\n\t\t\tconst form = createForm();\n\n\t\t\tform.field<TestField>( 'email' ).change( 'dirty@test.com' );\n\t\t\tform.field<TestField>( 'password' ).change( 'dirty' );\n\t\t\tform.reset();\n\n\t\t\texpect( form.values ).toEqual( {\n\t\t\t\temail: fields.email.value,\n\t\t\t\tpassword: fields.password.value,\n\t\t\t\tpasswordConfirmation: fields.passwordConfirmation.value,\n\t\t\t\tdocument: fields.document.value,\n\t\t\t\tadmin: fields.admin.value\n\t\t\t} );\n\t\t} );\n\n\t\titClearsTheErrorMessageOfEachField( form => form.reset() );\n\t} );\n\n\tdescribe( '@showErrors', () => {\n\t\tit( 'shows the given errors on the fields', () => {\n\t\t\tconst form = createForm();\n\t\t\tconst errors = {\n\t\t\t\temail: 'This email is being used',\n\t\t\t\tdocument: 'This document failed the external validation'\n\t\t\t};\n\n\t\t\tform.showErrors( errors );\n\n\t\t\texpect( form.field( 'email' ).error ).toEqual( errors.email );\n\t\t\texpect( form.field( 'document' ).error ).toEqual( errors.document );\n\t\t} );\n\n\t\tit( 'ignores errors for fields that do not exist', () => {\n\t\t\tconst form = createForm();\n\n\t\t\texpect( () => form.showErrors( { age: 'Invalid' } ) ).not.toThrow();\n\t\t} );\n\t} );\n} );\n"]}
{"filename": "tests/multiSelect.test.ts", "chunked_list": ["import ManualField from '../src/ManualField';\nimport multiSelect, { type MultiSelectParams } from '../src/multiSelect';\n\ndescribe( 'multiSelect', () => {\n\tconst createMultiSelect = (\n\t\tparams?: Partial<MultiSelectParams<number>>\n\t) => multiSelect<number>( {\n\t\tlabel: 'Numbers of interest',\n\t\t...params\n\t} );\n\n\tit( 'returns a ManualField', () => {\n\t\tconst field = createMultiSelect();\n\n\t\texpect( field ).toBeInstanceOf( ManualField );\n\t} );\n\n\tdescribe( 'when no default value is given', () => {\n\t\tit( 'uses an empty array as the field\\'s default value', () => {\n\t\t\tconst field = createMultiSelect();\n\n\t\t\texpect( field.value ).toEqual( [] );\n\t\t} );\n\t} );\n\n\tdescribe( 'when a default value is given', () => {\n\t\tit( 'uses that value as the field\\'s default value', () => {\n\t\t\tconst field = createMultiSelect( { defaultValue: [ 5, 6 ] } );\n\n\t\t\texpect( field.value ).toEqual( [ 5, 6 ] );\n\t\t} );\n\t} );\n} );\n"]}
{"filename": "tests/config.test.ts", "chunked_list": ["import { cloneDeep } from 'lodash';\nimport config, { configure } from '../src/config';\n\ndescribe( 'configure', () => {\n\tit( 'replaces the given entries in the config object with the values provided', () => {\n\t\tconst oldConfig = cloneDeep( config );\n\t\tconst newConfigOptions = {\n\t\t\tvalidators: {\n\t\t\t\trequired: { message: 'Cannot be blank' },\n\t\t\t\tminLength: { message: 'Too short' }", "\t\t\t\trequired: { message: 'Cannot be blank' },\n\t\t\t\tminLength: { message: 'Too short' }\n\t\t\t}\n\t\t};\n\n\t\tconfigure( newConfigOptions );\n\n\t\texpect( config ).toEqual( {\n\t\t\t...oldConfig,\n\t\t\tvalidators: {", "\t\t\t...oldConfig,\n\t\t\tvalidators: {\n\t\t\t\t...oldConfig.validators,\n\t\t\t\t...newConfigOptions.validators\n\t\t\t}\n\t\t} );\n\t} );\n} );\n", ""]}
{"filename": "tests/select.test.ts", "chunked_list": ["import ManualField from '../src/ManualField';\nimport select, { type SelectParams } from '../src/select';\n\ndescribe( 'select', () => {\n\tconst createSelect = (\n\t\tparams?: Partial<SelectParams<string>>\n\t) => select<string>( {\n\t\tlabel: 'Favorite language',\n\t\t...params\n\t} );\n\n\tit( 'returns a ManualField', () => {\n\t\tconst field = createSelect();\n\n\t\texpect( field ).toBeInstanceOf( ManualField );\n\t} );\n\n\tdescribe( 'when no default value is given', () => {\n\t\tit( 'uses null as the field\\'s default value', () => {\n\t\t\tconst field = createSelect();\n\n\t\t\texpect( field.value ).toBeNull();\n\t\t} );\n\t} );\n\n\tdescribe( 'when a default value is given', () => {\n\t\tit( 'uses that value as the field\\'s default value', () => {\n\t\t\tconst field = createSelect( { defaultValue: 'Ruby' } );\n\n\t\t\texpect( field.value ).toEqual( 'Ruby' );\n\t\t} );\n\t} );\n} );\n"]}
{"filename": "tests/Input.test.ts", "chunked_list": ["import Field from '../src/Field';\nimport Form from '../src/Form';\nimport Input, { type InputParams } from '../src/Input';\nimport { invalid, valid } from '../src/validators';\nimport { itCallsTheOnChangeCallback } from './support/callbacks';\n\ndescribe( 'Input', () => {\n\tconst lengthValidator = ( value: string ) => (\n\t\tvalue.length >= 8 ? valid() : invalid( 'Too short' )\n\t);\n\n\tconst createInput = ( params?: Partial<InputParams<string>> ) => new Input<string>( {\n\t\tlabel: 'Username',\n\t\tplaceholder: 'AwesomeUser',\n\t\thint: 'Type 5 or more characters',\n\t\tdefaultValue: 'default value',\n\t\tvalue: 'initial value',\n\t\tvalidators: [ lengthValidator ],\n\t\tdisabled: false,\n\t\tshowErrors: 'onWrite',\n\t\t...params\n\t} );\n\n\tconst createInputWithForm = ( params?: Partial<InputParams<string>> ) => {\n\t\tconst input = createInput( params );\n\t\tconst form = new Form( { fields: { input } } );\n\n\t\treturn { input, form };\n\t};\n\n\tit( 'is a Field', () => {\n\t\tconst input = createInput();\n\n\t\texpect( input ).toBeInstanceOf( Field );\n\t} );\n\n\tdescribe( 'constructor', () => {\n\t\tit( 'creates the input with the given parameters', () => {\n\t\t\tconst input = createInput();\n\n\t\t\texpect( input.label ).toEqual( 'Username' );\n\t\t\texpect( input.placeholder ).toEqual( 'AwesomeUser' );\n\t\t\texpect( input.hint ).toEqual( 'Type 5 or more characters' );\n\t\t\texpect( input.value ).toEqual( 'initial value' );\n\t\t\texpect( input.isDisabled ).toBe( false );\n\t\t} );\n\n\t\tdescribe( 'without the optional attributes', () => {\n\t\t\tit( 'assigns default values for them', () => {\n\t\t\t\tconst input = new Input<string>( { defaultValue: 'default value' } );\n\n\t\t\t\texpect( input.label ).toEqual( '' );\n\t\t\t\texpect( input.placeholder ).toEqual( '' );\n\t\t\t\texpect( input.hint ).toEqual( '' );\n\t\t\t\texpect( input.value ).toBe( 'default value' );\n\t\t\t\texpect( input.isDisabled ).toBe( false );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@focus', () => {\n\t\tdescribe( 'when the input is not focused', () => {\n\t\t\tit( 'sets the isFocused prop to true', () => {\n\t\t\t\tconst input = createInput();\n\n\t\t\t\tinput.focus();\n\n\t\t\t\texpect( input.isFocused ).toBe( true );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the input has an onFocus callback', () => {\n\t\t\t\tconst onFocus = jest.fn();\n\n\t\t\t\tit( 'calls it passing the parent form as parameter', () => {\n\t\t\t\t\tconst { input, form } = createInputWithForm( { onFocus } );\n\n\t\t\t\t\tinput.focus();\n\n\t\t\t\t\texpect( onFocus ).toHaveBeenCalledWith( form );\n\t\t\t\t\texpect( onFocus ).toHaveBeenCalledTimes( 1 );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the input is focused', () => {\n\t\t\tit( 'does not change the isFocused prop', () => {\n\t\t\t\tconst input = createInput();\n\n\t\t\t\tinput.focus();\n\t\t\t\tinput.focus();\n\n\t\t\t\texpect( input.isFocused ).toBe( true );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the input has an onFocus callback', () => {\n\t\t\t\tconst onFocus = jest.fn();\n\n\t\t\t\tit( 'doesn\\'t execute it', () => {\n\t\t\t\t\tconst { input } = createInputWithForm( { onFocus } );\n\n\t\t\t\t\tinput.focus();\n\t\t\t\t\tinput.focus();\n\n\t\t\t\t\texpect( onFocus ).toHaveBeenCalledTimes( 1 );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( '@write', () => {\n\t\tit( 'changes the value of the input with the given one', () => {\n\t\t\tconst input = createInput();\n\n\t\t\tinput.write( 'new value' );\n\n\t\t\texpect( input.value ).toEqual( 'new value' );\n\t\t} );\n\n\t\tit( 'focuses the input', () => {\n\t\t\tconst input = createInput();\n\n\t\t\tinput.write( 'new value' );\n\n\t\t\texpect( input.isFocused ).toBe( true );\n\t\t} );\n\n\t\titCallsTheOnChangeCallback<Input<string>>( {\n\t\t\tfieldBuilder: onChange => createInput( { onChange } ),\n\t\t\tchangingAction: ( field, value ) => field.write( value ),\n\t\t\tsampleValue: 'sample'\n\t\t} );\n\t} );\n\n\tdescribe( '@blur', () => {\n\t\tdescribe( 'when the input is not focused', () => {\n\t\t\tit( 'does not change the isFocused prop', () => {\n\t\t\t\tconst input = createInput();\n\n\t\t\t\tinput.blur();\n\n\t\t\t\texpect( input.isFocused ).toBe( false );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the input has an onBlur callback', () => {\n\t\t\t\tconst onBlur = jest.fn();\n\n\t\t\t\tit( 'doesn\\'t execute it', () => {\n\t\t\t\t\tconst { input } = createInputWithForm( { onBlur } );\n\n\t\t\t\t\tinput.blur();\n\n\t\t\t\t\texpect( onBlur ).not.toHaveBeenCalled();\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'when the input is focused', () => {\n\t\t\tit( 'sets the isFocused prop to false', () => {\n\t\t\t\tconst input = createInput();\n\n\t\t\t\tinput.focus();\n\t\t\t\tinput.blur();\n\n\t\t\t\texpect( input.isFocused ).toBe( false );\n\t\t\t} );\n\n\t\t\tdescribe( 'when the input has an onBlur callback', () => {\n\t\t\t\tconst onBlur = jest.fn();\n\n\t\t\t\tit( 'calls it passing the parent form as parameter', () => {\n\t\t\t\t\tconst { input, form } = createInputWithForm( { onBlur } );\n\n\t\t\t\t\tinput.focus();\n\t\t\t\t\tinput.blur();\n\n\t\t\t\t\texpect( onBlur ).toHaveBeenCalledWith( form );\n\t\t\t\t\texpect( onBlur ).toHaveBeenCalledTimes( 1 );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n\n\tdescribe( 'error display configs', () => {\n\t\tdescribe( 'onWrite config', () => {\n\t\t\tdescribe( 'when a value is written', () => {\n\t\t\t\tdescribe( 'and it is invalid', () => {\n\t\t\t\t\ttest( 'the input shows the error', () => {\n\t\t\t\t\t\tconst input = createInput( { showErrors: 'onWrite' } );\n\n\t\t\t\t\t\tinput.write( 'short' );\n\n\t\t\t\t\t\texpect( input.error ).toEqual( 'Too short' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\n\t\t\t\tdescribe( 'and it is valid', () => {\n\t\t\t\t\ttest( 'the input hides any error being shown', () => {\n\t\t\t\t\t\tconst input = createInput( { showErrors: 'onWrite' } );\n\n\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\tinput.write( 'valid again' );\n\n\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'onBlur config', () => {\n\t\t\tdescribe( 'when a value is written', () => {\n\t\t\t\tdescribe( 'and it is invalid', () => {\n\t\t\t\t\ttest( 'the input shows the error only when blurred', () => {\n\t\t\t\t\t\tconst input = createInput( { showErrors: 'onBlur' } );\n\n\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\n\t\t\t\t\t\tinput.blur();\n\t\t\t\t\t\texpect( input.error ).toEqual( 'Too short' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\n\t\t\t\tdescribe( 'and it is valid', () => {\n\t\t\t\t\ttest( 'the input hides any error being shown', () => {\n\t\t\t\t\t\tconst input = createInput( { showErrors: 'onBlur' } );\n\n\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\tinput.blur();\n\n\t\t\t\t\t\tinput.write( 'valid again' );\n\n\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'onSubmit config', () => {\n\t\t\tdescribe( 'when a value is written', () => {\n\t\t\t\tdescribe( 'and it is invalid', () => {\n\t\t\t\t\ttest( 'the input does not show the error', () => {\n\t\t\t\t\t\tconst input = createInput( { showErrors: 'onSubmit' } );\n\n\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\n\t\t\t\t\t\tinput.blur();\n\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\n\t\t\t\tdescribe( 'and it is valid', () => {\n\t\t\t\t\ttest( 'the input hides any error being shown', () => {\n\t\t\t\t\t\tconst input = createInput( { showErrors: 'onSubmit' } );\n\n\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\tinput.syncError();\n\n\t\t\t\t\t\tinput.write( 'valid again' );\n\n\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n"]}
{"filename": "tests/validators/maxLength.test.ts", "chunked_list": ["import { maxLength } from '../../src/validators';\nimport {\n\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n} from '../support/validators';\n\ndescribe( 'maxLength validator', () => {\n\tconst config = { message: 'At most :length chars' };\n\tconst expectedError = 'At most 5 chars';\n\tconst validator = maxLength( 5, config );\n", "\tconst validator = maxLength( 5, config );\n\n\tdescribe( 'when the string\\'s length equals the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( '12345' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {", "\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( 'A' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\tit( 'fails the validation with a message containing the expected min length', () => {\n\t\t\texpectFailedValidation( validator( 'xyz123' ), expectedError );\n\t\t} );", "\t\t\texpectFailedValidation( validator( 'xyz123' ), expectedError );\n\t\t} );\n\t} );\n\n\titIncludesTheLabelInTheErrorMessage( {\n\t\tvalidatorBuilder: message => maxLength( 4, { message } ),\n\t\tsampleInvalidValue: '5char'\n\t} );\n} );\n", "} );\n"]}
{"filename": "tests/validators/email.test.ts", "chunked_list": ["import { email } from '../../src/validators';\nimport {\n\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n} from '../support/validators';\n\ndescribe( 'email validator', () => {\n\tconst config = { message: 'The email is not valid!' };\n\tconst validator = email( config );\n\n\tdescribe( 'when the string has a valid email format', () => {", "\n\tdescribe( 'when the string has a valid email format', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( 'valid@test.co' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string has an invalid email format', () => {\n\t\tit( 'fails the validation', () => {\n\t\t\texpectFailedValidation( validator( 'invalid@test,co' ), config.message );", "\t\tit( 'fails the validation', () => {\n\t\t\texpectFailedValidation( validator( 'invalid@test,co' ), config.message );\n\t\t\texpectFailedValidation( validator( 'invalidtest.co' ), config.message );\n\t\t} );\n\t} );\n\n\titIncludesTheLabelInTheErrorMessage( {\n\t\tvalidatorBuilder: message => email( { message } ),\n\t\tsampleInvalidValue: 'not.valid.com'\n\t} );", "\t\tsampleInvalidValue: 'not.valid.com'\n\t} );\n} );\n"]}
{"filename": "tests/validators/length.test.ts", "chunked_list": ["import { length } from '../../src/validators';\nimport {\n\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n} from '../support/validators';\n\ndescribe( 'length validator', () => {\n\tconst config = { message: 'Must have :length chars' };\n\tconst expectedError = 'Must have 9 chars';\n\tconst validator = length( 9, config );\n", "\tconst validator = length( 9, config );\n\n\tdescribe( 'when the string\\'s length equals the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( 'ninechars' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\tit( 'fails the validation with a message containing the expected length', () => {", "\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\tit( 'fails the validation with a message containing the expected length', () => {\n\t\t\texpectFailedValidation( validator( 'tooshort' ), expectedError );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\tit( 'fails the validation with a message containing the expected length', () => {\n\t\t\texpectFailedValidation( validator( 'toolongggg' ), expectedError );\n\t\t} );", "\t\t\texpectFailedValidation( validator( 'toolongggg' ), expectedError );\n\t\t} );\n\t} );\n\n\titIncludesTheLabelInTheErrorMessage( {\n\t\tvalidatorBuilder: message => length( 3, { message } ),\n\t\tsampleInvalidValue: 'four'\n\t} );\n} );\n", "} );\n"]}
{"filename": "tests/validators/required.test.ts", "chunked_list": ["import { required } from '../../src/validators';\nimport {\n\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n} from '../support/validators';\n\ndescribe( 'required validator', () => {\n\tconst config = { message: 'Cannot be blank' };\n\tconst validator = required( config );\n\n\tdescribe( 'when the value is not falsy', () => {", "\n\tdescribe( 'when the value is not falsy', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( 'something' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the value is falsy', () => {\n\t\tit( 'fails the validation', () => {\n\t\t\texpectFailedValidation( validator( '' ), config.message );", "\t\tit( 'fails the validation', () => {\n\t\t\texpectFailedValidation( validator( '' ), config.message );\n\t\t} );\n\t} );\n\n\titIncludesTheLabelInTheErrorMessage( {\n\t\tvalidatorBuilder: message => required( { message } ),\n\t\tsampleInvalidValue: ''\n\t} );\n} );", "\t} );\n} );\n"]}
{"filename": "tests/validators/minLength.test.ts", "chunked_list": ["import { minLength } from '../../src/validators';\nimport {\n\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n} from '../support/validators';\n\ndescribe( 'minLength validator', () => {\n\tconst config = { message: 'At least :length chars' };\n\tconst expectedError = 'At least 8 chars';\n\tconst validator = minLength( 8, config );\n", "\tconst validator = minLength( 8, config );\n\n\tdescribe( 'when the string\\'s length equals the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( '8--chars' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {", "\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\tit( 'succeeds the validation', () => {\n\t\t\texpectSuccessfulValidation( validator( 'very long string' ) );\n\t\t} );\n\t} );\n\n\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\tit( 'fails the validation with a message containing the expected min length', () => {\n\t\t\texpectFailedValidation( validator( '=short=' ), expectedError );\n\t\t} );", "\t\t\texpectFailedValidation( validator( '=short=' ), expectedError );\n\t\t} );\n\t} );\n\n\titIncludesTheLabelInTheErrorMessage( {\n\t\tvalidatorBuilder: message => minLength( 3, { message } ),\n\t\tsampleInvalidValue: 'XY'\n\t} );\n} );\n", "} );\n"]}
{"filename": "tests/support/TestField.ts", "chunked_list": ["import { action, makeObservable } from 'mobx';\nimport Field, { type FieldParams } from '../../src/Field';\n\nexport default class TestField extends Field<string> {\n\tconstructor( params: FieldParams<string> ) {\n\t\tsuper( params );\n\n\t\tmakeObservable( this, {\n\t\t\tchange: action\n\t\t} );\n\t}\n\n\tchange( newValue: string ) {\n\t\tthis.setValue( newValue );\n\t}\n}\n"]}
{"filename": "tests/support/validators.ts", "chunked_list": ["import { FieldValidator, ValidationResult } from '../../src/validators';\n\nexport function expectSuccessfulValidation( result: ValidationResult ) {\n\texpect( result.isValid ).toBe( true );\n}\n\nexport function expectFailedValidation( result: ValidationResult, expectedError: string ) {\n\texpect( result.isValid ).toBe( false );\n\texpect( result.error ).toBe( expectedError );\n}\n", "export function itIncludesTheLabelInTheErrorMessage<T>( {\n\tvalidatorBuilder,\n\tsampleInvalidValue\n}: {\n\tvalidatorBuilder: ( message: string ) => FieldValidator<T>,\n\tsampleInvalidValue: T\n} ) {\n\tdescribe( 'when the validator is configured with a message containing the :label keyword', () => {\n\t\tdescribe( 'and it is invoked with a label', () => {\n\t\t\tit( 'replaces the :label keyword with the label when returning an error', () => {\n\t\t\t\tconst validator = validatorBuilder( 'The field :label is invalid' );\n\t\t\t\tconst result = validator( sampleInvalidValue, undefined, 'Role' );\n\n\t\t\t\texpect( result.error ).toEqual( 'The field Role is invalid' );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'and it is invoked without a label', () => {\n\t\t\tit( 'replaces the :label keyword with the word \"Field\" when returning an error', () => {\n\t\t\t\tconst validator = validatorBuilder( ':label is invalid' );\n\t\t\t\tconst result = validator( sampleInvalidValue, undefined );\n\n\t\t\t\texpect( result.error ).toEqual( 'Field is invalid' );\n\t\t\t} );\n\t\t} );\n\t} );\n}\n"]}
{"filename": "tests/support/callbacks.ts", "chunked_list": ["import Field from '../../src/Field';\nimport Form from '../../src/Form';\nimport { type ValueType } from '../../src/utils/types';\nimport { FieldOnChangeCallback } from '../../src/utils/FieldState/types';\n\ninterface OnChangeTestParams<F> {\n\tfieldBuilder: ( onChange: FieldOnChangeCallback<ValueType<F>> ) => F,\n\tchangingAction: ( field: F, value: ValueType<F> ) => void,\n\tsampleValue: ValueType<F>\n}\n", "export function itCallsTheOnChangeCallback<F extends Field<ValueType<F>>>( {\n\tfieldBuilder,\n\tchangingAction,\n\tsampleValue\n}: OnChangeTestParams<F> ) {\n\tdescribe( 'when the field has an onChange callback', () => {\n\t\tconst setUp = () => {\n\t\t\tconst onChange = jest.fn();\n\t\t\tconst field = fieldBuilder( onChange );\n\t\t\tconst form = new Form( { fields: { field } } );\n\n\t\t\treturn { onChange, field, form };\n\t\t};\n\n\t\tdescribe( 'and a new value is given', () => {\n\t\t\tit( 'calls the callback with the new value and the parent form', () => {\n\t\t\t\tconst { onChange, field, form } = setUp();\n\n\t\t\t\tchangingAction( field, sampleValue );\n\n\t\t\t\texpect( onChange ).toHaveBeenCalledWith( sampleValue, form );\n\t\t\t\texpect( onChange ).toHaveBeenCalledTimes( 1 );\n\t\t\t} );\n\t\t} );\n\n\t\tdescribe( 'and the same value is given', () => {\n\t\t\tit( 'does not call the callback', () => {\n\t\t\t\tconst { onChange, field } = setUp();\n\n\t\t\t\tchangingAction( field, field.value );\n\n\t\t\t\texpect( onChange ).not.toHaveBeenCalled();\n\t\t\t} );\n\t\t} );\n\t} );\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export {\n\tdefault as config, configure, type Config, type ConfigOptions\n} from './config';\nexport { default as Field, type FieldParams, type FieldOnChangeCallback } from './Field';\nexport {\n\tdefault as Input,\n\ttype InputParams,\n\ttype InputErrorDisplayConfig,\n\ttype InputCallback\n} from './Input';\nexport { default as TextInput, textInput, type TextInputParams } from './TextInput';\nexport { default as ManualField, manualField } from './ManualField';", "\ttype InputCallback\n} from './Input';\nexport { default as TextInput, textInput, type TextInputParams } from './TextInput';\nexport { default as ManualField, manualField } from './ManualField';\nexport { default as select, type Select, type SelectParams } from './select';\nexport { default as multiSelect, type MultiSelect, type MultiSelectParams } from './multiSelect';\nexport { default as Form, type FormParams, type FormValues } from './Form';\nexport {\n\temail,\n\tlength,\n\tmaxLength,\n\tminLength,\n\trequired,\n\tinvalid,\n\tvalid,", "\ttype FieldValidator,\n\ttype ValidationResult\n} from './validators';\n"]}
{"filename": "src/multiSelect/index.ts", "chunked_list": ["import ManualField from '../ManualField';\nimport type { FieldParams } from '../Field';\nimport type { WithOptionalDefaultValue } from '../utils/types';\n\nexport type MultiSelect<ValueType> = ManualField<ValueType[]>;\n\nexport type MultiSelectParams<ValueType> = WithOptionalDefaultValue<FieldParams<ValueType[]>>;\n\nexport default function multiSelect<ValueType = string>( params: MultiSelectParams<ValueType> ) {\n\treturn new ManualField<ValueType[]>( { defaultValue: [], ...params } );\n}\n", "export default function multiSelect<ValueType = string>( params: MultiSelectParams<ValueType> ) {\n\treturn new ManualField<ValueType[]>( { defaultValue: [], ...params } );\n}\n"]}
{"filename": "src/Form/types.ts", "chunked_list": ["import Field from '../Field';\nimport type Form from '.';\n\nexport type FormSubmitCallback = ( form: Form ) => void | Promise<void>;\nexport type FormSubmitAction = ( form: Form ) => Promise<void>;\n\nexport interface FormParams {\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tfields: Record<string, Field<any>>,\n\tonSubmit?: FormSubmitCallback\n}\n", "export type FormFields = Record<string, Field<unknown>>;\n\nexport type FormValues = Record<string, unknown>;\n"]}
{"filename": "src/Form/utils.ts", "chunked_list": ["import { mapValues } from 'lodash';\nimport type Form from '.';\nimport { FormFields, FormSubmitAction, FormSubmitCallback } from './types';\n\nexport function wrapInAsyncAction( onSubmit: FormSubmitCallback ) {\n\treturn (\n\t\t( form: Form ) => Promise.resolve( onSubmit( form ) )\n\t) as FormSubmitAction;\n}\n\nexport function valuesOf( fields: FormFields ) {\n\treturn mapValues( fields, field => field.value );\n}\n", "export function valuesOf( fields: FormFields ) {\n\treturn mapValues( fields, field => field.value );\n}\n"]}
{"filename": "src/Form/index.ts", "chunked_list": ["import {\n\taction, computed, makeObservable, observable\n} from 'mobx';\nimport {\n\tclone, every, forEach, pickBy, some\n} from 'lodash';\nimport Field from '../Field';\nimport type {\n\tFormFields, FormParams, FormSubmitAction, FormValues\n} from './types';", "\tFormFields, FormParams, FormSubmitAction, FormValues\n} from './types';\nimport { valuesOf, wrapInAsyncAction } from './utils';\nimport type { ValueType } from '../utils/types';\nimport deprecatedMethod from '../utils/deprecatedMethod';\n\nexport default class Form {\n\tprivate _fields: FormFields;\n\tprivate submitAction: FormSubmitAction;\n\tprivate _isSubmitting: boolean;\n\n\tconstructor( { fields, onSubmit = () => undefined }: FormParams ) {\n\t\tthis._fields = fields;\n\t\tthis.submitAction = wrapInAsyncAction( onSubmit );\n\t\tthis._isSubmitting = false;\n\n\t\tthis.attachFields();\n\n\t\tmakeObservable<Form, '_fields' | 'submitAction' | '_isSubmitting' >( this, {\n\t\t\t_fields: observable,\n\t\t\tsubmitAction: observable,\n\t\t\t_isSubmitting: observable,\n\t\t\tfields: computed,\n\t\t\tvalues: computed,\n\t\t\tdirtyValues: computed,\n\t\t\tisValid: computed,\n\t\t\tisDirty: computed,\n\t\t\tisReadyToSubmit: computed,\n\t\t\tisSubmitting: computed,\n\t\t\tsubmit: action,\n\t\t\tclear: action,\n\t\t\treset: action,\n\t\t\tshowErrors: action\n\t\t} );\n\t}\n\n\tget fields(): FormFields {\n\t\treturn clone( this._fields );\n\t}\n\n\tget values(): FormValues {\n\t\treturn valuesOf( this._fields );\n\t}\n\n\tget dirtyValues(): FormValues {\n\t\treturn valuesOf( this.dirtyFields );\n\t}\n\n\tget isValid() {\n\t\treturn every( this.enabledFields, field => field.isValid );\n\t}\n\n\tget isDirty() {\n\t\treturn some( this._fields, field => field.isDirty );\n\t}\n\n\tget isReadyToSubmit() {\n\t\treturn this.isValid && this.isDirty && !this.isSubmitting;\n\t}\n\n\tget isSubmitting() {\n\t\treturn this._isSubmitting;\n\t}\n\n\tfield<FieldType extends Field<ValueType<FieldType>> = Field<unknown>>( fieldKey: string ) {\n\t\treturn this._fields[ fieldKey ] as FieldType;\n\t}\n\n\tselect<FieldType extends Field<ValueType<FieldType>> = Field<unknown>>( fieldKey: string ) {\n\t\tdeprecatedMethod(\n\t\t\t'Form', 'select', { alternative: 'field', docsPath: '/reference/Form.md#field' }\n\t\t);\n\n\t\treturn this.field<FieldType>( fieldKey );\n\t}\n\n\teachField( actionOnField: ( field: Field<unknown> ) => void ) {\n\t\tforEach( this._fields, actionOnField );\n\t}\n\n\tsubmit(): Promise<void> {\n\t\tthis.syncFieldErrors();", "\t\tif ( !this.isValid || this.isSubmitting ) return Promise.resolve();\n\n\t\treturn this.executeSubmitAction();\n\t}\n\n\tclear() {\n\t\tthis.eachField( field => field.clear() );\n\t}\n\n\treset() {\n\t\tthis.eachField( field => field.reset() );\n\t}\n\n\tshowErrors( errors: Record<string, string> ) {\n\t\tforEach( errors, ( error, fieldKey ) => this.showErrorOnField( fieldKey, error ) );\n\t}\n\n\tprivate attachFields() {\n\t\tforEach( this._fields, field => field.attachToForm( this ) );\n\t}\n\n\tprivate get dirtyFields() {\n\t\treturn this.pickFieldsBy( field => field.isDirty );\n\t}\n\n\tprivate get enabledFields() {\n\t\treturn this.pickFieldsBy( field => !field.isDisabled );\n\t}\n\n\tprivate pickFieldsBy( predicate: ( field: Field<unknown> ) => boolean ): FormFields {\n\t\treturn pickBy( this._fields, predicate );\n\t}\n\n\tprivate syncFieldErrors() {\n\t\tforEach( this._fields, field => field.syncError() );\n\t}\n\n\tprivate executeSubmitAction() {\n\t\tthis._isSubmitting = true;\n\n\t\treturn this.submitAction( this )\n\t\t\t.finally( action( () => { this._isSubmitting = false; } ) );\n\t}\n\n\tprivate showErrorOnField( fieldKey: string, error: string ) {\n\t\tthis._fields[ fieldKey ]?.showError( error );\n\t}\n}\n\nexport type { FormParams, FormValues };\n"]}
{"filename": "src/Field/types.ts", "chunked_list": ["import type { FieldStateParams } from '../utils/FieldState';\n\nexport type FieldParams<ValueType> = FieldStateParams<ValueType> & { hint?: string };\n\nexport type AnnotatedPrivateFieldProps = '_state' | '_presentedError';\n"]}
{"filename": "src/Field/index.ts", "chunked_list": ["import {\n\taction, computed, makeObservable, observable\n} from 'mobx';\nimport FieldState from '../utils/FieldState';\nimport type { AnnotatedPrivateFieldProps, FieldParams } from './types';\nimport type Form from '../Form';\n\nexport default abstract class Field<ValueType> {\n\treadonly hint: string;\n\n\tprotected _state: FieldState<ValueType>;\n\tprotected _presentedError: string;\n\n\tconstructor( {\n\t\thint = '',\n\t\t...fieldStateParams\n\t}: FieldParams<ValueType> ) {\n\t\tthis.hint = hint;\n\n\t\tthis._state = new FieldState( fieldStateParams );\n\t\tthis._presentedError = '';\n\n\t\tmakeObservable<Field<ValueType>, AnnotatedPrivateFieldProps>( this, {\n\t\t\t_state: observable,\n\t\t\t_presentedError: observable,\n\t\t\tlabel: computed,\n\t\t\tvalue: computed,\n\t\t\tisValid: computed,\n\t\t\tisDirty: computed,\n\t\t\terror: computed,\n\t\t\tisDisabled: computed,\n\t\t\tsetIsDisabled: action,\n\t\t\tclear: action,\n\t\t\treset: action,\n\t\t\tsyncError: action,\n\t\t\tshowError: action,\n\t\t\tattachToForm: action\n\t\t} );\n\t}\n\n\tget label() {\n\t\treturn this._state.label;\n\t}\n\n\tget value() {\n\t\treturn this._state.value;\n\t}\n\n\tget isValid() {\n\t\treturn this._state.isValid;\n\t}\n\n\tget isDirty() {\n\t\treturn this._state.isDirty;\n\t}\n\n\tget error() {\n\t\treturn this._presentedError;\n\t}\n\n\tget isDisabled() {\n\t\treturn this._state.isDisabled;\n\t}\n\n\tsetIsDisabled( isDisabled: boolean ) {\n\t\tthis._state.setIsDisabled( isDisabled );\n\t}\n\n\tclear() {\n\t\tthis._state.clear();\n\t\tthis.hideError();\n\t}\n\n\treset() {\n\t\tthis._state.reset();\n\t\tthis.hideError();\n\t}\n\n\tsyncError() {\n\t\tthis._presentedError = this._state.error || '';\n\t}\n\n\tshowError( errorMessage: string ) {\n\t\tthis._presentedError = errorMessage;\n\t}\n\n\tattachToForm( form: Form ) {\n\t\tthis._state.attachToForm( form );\n\t}\n\n\tprotected hideError() {\n\t\tthis._presentedError = '';\n\t}\n\n\tprotected setValue( newValue: ValueType ) {\n\t\tthis._state.setValue( newValue );\n\t}\n}\n\nexport type { FieldParams };\nexport type { FieldOnChangeCallback } from '../utils/FieldState';\n"]}
{"filename": "src/Input/types.ts", "chunked_list": ["import type { FieldParams } from '../Field';\nimport type Form from '../Form';\n\nexport type InputErrorDisplayConfig = 'onWrite' | 'onBlur' | 'onSubmit';\n\nexport type InputCallback = ( form?: Form ) => void;\n\nexport interface InputParams<ValueType> extends FieldParams<ValueType> {\n\tplaceholder?: string,\n\tshowErrors?: InputErrorDisplayConfig,\n\tonFocus?: InputCallback,\n\tonBlur?: InputCallback\n}\n"]}
{"filename": "src/Input/index.ts", "chunked_list": ["import {\n\taction, computed, makeObservable, observable, reaction\n} from 'mobx';\nimport config from '../config';\nimport Field from '../Field';\nimport type { InputCallback, InputErrorDisplayConfig, InputParams } from './types';\n\nexport default class Input<ValueType> extends Field<ValueType> {\n\treadonly placeholder: string;\n\n\tprotected readonly showErrors: InputErrorDisplayConfig;\n\tprotected readonly onFocus?: InputCallback;\n\tprotected readonly onBlur?: InputCallback;\n\n\tprotected _isFocused: boolean;\n\n\tconstructor( {\n\t\tplaceholder = '',\n\t\tshowErrors = config.inputs.showErrors,\n\t\tonFocus = undefined,\n\t\tonBlur = undefined,\n\t\t...fieldParams\n\t}: InputParams<ValueType> ) {\n\t\tsuper( fieldParams );\n\n\t\tthis.placeholder = placeholder;\n\n\t\tthis.showErrors = showErrors;\n\t\tthis.onFocus = onFocus;\n\t\tthis.onBlur = onBlur;\n\n\t\tthis._isFocused = false;\n\n\t\tmakeObservable<Input<ValueType>, '_isFocused'>( this, {\n\t\t\t_isFocused: observable,\n\t\t\tisFocused: computed,\n\t\t\tfocus: action,\n\t\t\twrite: action,\n\t\t\tblur: action\n\t\t} );\n\n\t\tthis.setUpFocusReaction();\n\t}\n\n\tget isFocused() {\n\t\treturn this._isFocused;\n\t}\n\n\tfocus() {\n\t\tthis._isFocused = true;\n\t}\n\n\twrite( newValue: ValueType ) {\n\t\tthis.focus();\n\t\tthis.setValue( newValue );", "\t\tif ( this.isValid || this.showErrors === 'onWrite' ) this.syncError();\n\t}\n\n\tblur() {\n\t\tthis._isFocused = false;\n\t\tif ( this.showErrors === 'onBlur' ) this.syncError();\n\t}\n\n\tprotected setUpFocusReaction() {\n\t\treaction(\n\t\t\t() => this.isFocused,\n\t\t\t( isFocused ) => {\n\t\t\t\tconst callback = isFocused ? this.onFocus : this.onBlur;\n\t\t\t\tcallback?.( this.parentForm );\n\t\t\t}\n\t\t);\n\t}\n\n\tprotected get parentForm() {\n\t\treturn this._state.parentForm;\n\t}\n}\n\nexport type { InputCallback, InputErrorDisplayConfig, InputParams };\n"]}
{"filename": "src/utils/types.ts", "chunked_list": ["import type Field from '../Field';\nimport type { FieldParams } from '../Field';\n\nexport type ValueType<F> =\n\tF extends Field<infer V> ? V :\n\tF extends FieldParams<infer V> ? V :\n\tnever;\n\nexport type WithOptionalDefaultValue<FieldParamsType> = Omit<FieldParamsType, 'defaultValue'> & {\n\tdefaultValue?: ValueType<FieldParamsType>\n};\n", "export type WithOptionalDefaultValue<FieldParamsType> = Omit<FieldParamsType, 'defaultValue'> & {\n\tdefaultValue?: ValueType<FieldParamsType>\n};\n\nexport type DeepPartial<T> = {\n\t[ K in keyof T ]?:\n\t\tT[ K ] extends object ? DeepPartial<T[ K ]> :\n\t\tT[ K ] extends ( infer U )[] ? DeepPartial<U>[] :\n\t\tT[ K ];\n};\n"]}
{"filename": "src/utils/deprecatedMethod.ts", "chunked_list": ["/* eslint-disable no-console */\nconst DOCS_BASE_URL = 'https://github.com/amalgamaco/mobx-form/blob/main/docs';\n\nfunction docsUrl( path: string ) {\n\treturn DOCS_BASE_URL + path;\n}\n\nfunction joinSentences( ...sentences: Array<string | undefined> ) {\n\treturn sentences.filter( Boolean ).join( '. ' );\n}\n", "interface DeprecatedMethodOptions {\n\talternative?: string,\n\tdocsPath?: string\n}\n\nexport default function deprecatedMethod(\n\tklass: string,\n\tmethod: string,\n\t{ alternative, docsPath }: DeprecatedMethodOptions = {}\n) {\n\tconst deprecationMessage = joinSentences(\n\t\t`DEPRECATED method '${method}' from class '${klass}'`,\n\t\talternative && `Use '${alternative}' instead`,\n\t\tdocsPath && `For more information about usage see ${docsUrl( docsPath )}`\n\t);\n\n\tconsole.warn( `mobx-form: ${deprecationMessage}` );\n}\n"]}
{"filename": "src/utils/FieldState/types.ts", "chunked_list": ["import type { FieldValidator } from '../../validators';\nimport type Form from '../../Form';\n\nexport type FieldOnChangeCallback<ValueType> = (\n\tnewValue: ValueType, parentForm?: Form\n) => void;\n\nexport interface FieldStateParams<ValueType> {\n\tlabel?: string,\n\tdefaultValue: ValueType,\n\tvalue?: ValueType,\n\tvalidators?: FieldValidator<ValueType>[],\n\tdisabled?: boolean,\n\tonChange?: FieldOnChangeCallback<ValueType>\n}\n"]}
{"filename": "src/utils/FieldState/index.ts", "chunked_list": ["import { makeAutoObservable, reaction } from 'mobx';\nimport type { FieldStateParams, FieldOnChangeCallback } from './types';\nimport type Form from '../../Form';\nimport type { FieldValidator } from '../../validators';\n\nconst fieldAlreadyAttachedError = ( label: string ) => new Error(\n\t`Tried to re-attach a field with label \"${label}\". Fields can only be attached to a Form instance once.`\n);\n\nexport default class FieldState<ValueType> {\n\treadonly label: string;\n\n\tprivate readonly _defaultValue: ValueType;\n\tprivate readonly _initialValue: ValueType;\n\tprivate readonly _validators: FieldValidator<ValueType>[];\n\tprivate readonly _onChange?: FieldOnChangeCallback<ValueType>;\n\n\tprivate _value: ValueType;\n\tprivate _isDisabled: boolean;\n\tprivate _parentForm?: Form;\n\n\tconstructor( {\n\t\tlabel = '',\n\t\tdefaultValue,\n\t\tvalue = defaultValue,\n\t\tvalidators = [],\n\t\tdisabled = false,\n\t\tonChange = undefined\n\t}: FieldStateParams<ValueType> ) {\n\t\tthis.label = label;\n\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._initialValue = value;\n\t\tthis._validators = validators;\n\t\tthis._onChange = onChange;\n\n\t\tthis._value = value;\n\t\tthis._isDisabled = disabled;\n\n\t\tmakeAutoObservable( this );\n\n\t\tthis.setUpOnChangeReaction();\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tget isValid() {\n\t\treturn !this.failedValidationResult;\n\t}\n\n\tget isDirty() {\n\t\treturn this._value !== this._initialValue;\n\t}\n\n\tget isDisabled() {\n\t\treturn this._isDisabled;\n\t}\n\n\tget error() {\n\t\treturn this.failedValidationResult?.error;\n\t}\n\n\tget parentForm() {\n\t\treturn this._parentForm;\n\t}\n\n\tsetValue( newValue: ValueType ) {\n\t\tthis._value = newValue;\n\t}\n\n\tsetIsDisabled( isDisabled: boolean ) {\n\t\tthis._isDisabled = isDisabled;\n\t}\n\n\tclear() {\n\t\tthis._value = this._defaultValue;\n\t}\n\n\treset() {\n\t\tthis._value = this._initialValue;\n\t}\n\n\tattachToForm( form: Form ) {", "export default class FieldState<ValueType> {\n\treadonly label: string;\n\n\tprivate readonly _defaultValue: ValueType;\n\tprivate readonly _initialValue: ValueType;\n\tprivate readonly _validators: FieldValidator<ValueType>[];\n\tprivate readonly _onChange?: FieldOnChangeCallback<ValueType>;\n\n\tprivate _value: ValueType;\n\tprivate _isDisabled: boolean;\n\tprivate _parentForm?: Form;\n\n\tconstructor( {\n\t\tlabel = '',\n\t\tdefaultValue,\n\t\tvalue = defaultValue,\n\t\tvalidators = [],\n\t\tdisabled = false,\n\t\tonChange = undefined\n\t}: FieldStateParams<ValueType> ) {\n\t\tthis.label = label;\n\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._initialValue = value;\n\t\tthis._validators = validators;\n\t\tthis._onChange = onChange;\n\n\t\tthis._value = value;\n\t\tthis._isDisabled = disabled;\n\n\t\tmakeAutoObservable( this );\n\n\t\tthis.setUpOnChangeReaction();\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tget isValid() {\n\t\treturn !this.failedValidationResult;\n\t}\n\n\tget isDirty() {\n\t\treturn this._value !== this._initialValue;\n\t}\n\n\tget isDisabled() {\n\t\treturn this._isDisabled;\n\t}\n\n\tget error() {\n\t\treturn this.failedValidationResult?.error;\n\t}\n\n\tget parentForm() {\n\t\treturn this._parentForm;\n\t}\n\n\tsetValue( newValue: ValueType ) {\n\t\tthis._value = newValue;\n\t}\n\n\tsetIsDisabled( isDisabled: boolean ) {\n\t\tthis._isDisabled = isDisabled;\n\t}\n\n\tclear() {\n\t\tthis._value = this._defaultValue;\n\t}\n\n\treset() {\n\t\tthis._value = this._initialValue;\n\t}\n\n\tattachToForm( form: Form ) {", "\t\tif ( this._parentForm ) throw fieldAlreadyAttachedError( this.label );\n\n\t\tthis._parentForm = form;\n\t}\n\n\tprivate setUpOnChangeReaction() {\n\t\treaction(\n\t\t\t() => this._value,\n\t\t\t( newValue: ValueType ) => this._onChange?.( newValue, this._parentForm )\n\t\t);\n\t}\n\n\tprivate get failedValidationResult() {\n\t\treturn this.validationResults.find( result => !result.isValid );\n\t}\n\n\tprivate get validationResults() {\n\t\treturn this._validators.map(\n\t\t\tvalidator => validator( this._value, this._parentForm, this.label )\n\t\t);\n\t}\n}\n\nexport type { FieldStateParams, FieldOnChangeCallback };\n"]}
{"filename": "src/config/types.ts", "chunked_list": ["import type { InputErrorDisplayConfig } from '../Input';\nimport type { DeepPartial } from '../utils/types';\nimport type { EmailValidatorConfig } from '../validators/email';\nimport type { LengthValidatorConfig } from '../validators/length';\nimport type { MaxLengthValidatorConfig } from '../validators/maxLength';\nimport type { MinLengthValidatorConfig } from '../validators/minLength';\nimport type { RequiredValidatorConfig } from '../validators/required';\n\nexport interface Config {\n\tinputs: {\n\t\tshowErrors: InputErrorDisplayConfig\n\t},\n\tvalidators: {\n\t\temail: EmailValidatorConfig,\n\t\tlength: LengthValidatorConfig,\n\t\tmaxLength: MaxLengthValidatorConfig,\n\t\tminLength: MinLengthValidatorConfig,\n\t\trequired: RequiredValidatorConfig\n\t}\n}\n", "export interface Config {\n\tinputs: {\n\t\tshowErrors: InputErrorDisplayConfig\n\t},\n\tvalidators: {\n\t\temail: EmailValidatorConfig,\n\t\tlength: LengthValidatorConfig,\n\t\tmaxLength: MaxLengthValidatorConfig,\n\t\tminLength: MinLengthValidatorConfig,\n\t\trequired: RequiredValidatorConfig\n\t}\n}\n", "export type ConfigOptions = DeepPartial<Config>;\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import { merge } from 'lodash';\nimport type { Config, ConfigOptions } from './types';\n\nconst config: Config = {\n\tinputs: {\n\t\tshowErrors: 'onBlur'\n\t},\n\tvalidators: {\n\t\temail: { message: 'This email does not have a valid format' },\n\t\tlength: { message: 'Must have exactly :length characters' },", "\t\temail: { message: 'This email does not have a valid format' },\n\t\tlength: { message: 'Must have exactly :length characters' },\n\t\tmaxLength: { message: 'Must have at most :length characters' },\n\t\tminLength: { message: 'Must have at least :length characters' },\n\t\trequired: { message: 'This field is mandatory' }\n\t}\n};\n\nfunction configure( options: ConfigOptions ) {\n\tmerge( config, options );\n}\n\nexport default config;", "function configure( options: ConfigOptions ) {\n\tmerge( config, options );\n}\n\nexport default config;\nexport { configure, type Config, type ConfigOptions };\n"]}
{"filename": "src/validators/results.ts", "chunked_list": ["import type { ValidationResult } from './types';\n\nexport const valid = (): ValidationResult => ( {\n\tisValid: true, error: ''\n} );\n\nexport const invalid = ( error: string ): ValidationResult => ( {\n\tisValid: false, error\n} );\n", "} );\n"]}
{"filename": "src/validators/required.ts", "chunked_list": ["import config from '../config';\nimport type { FieldValidator, ValidatorConfigWithMessage } from './types';\nimport { makeValidator } from './utils';\n\nexport type RequiredValidatorConfig = ValidatorConfigWithMessage;\n\nexport function required<ValueType>(\n\t{ message }: RequiredValidatorConfig = config.validators.required\n): FieldValidator<ValueType> {\n\treturn makeValidator( {\n\t\tpredicate: value => !!value,\n\t\tmessage\n\t} );\n}\n"]}
{"filename": "src/validators/email.ts", "chunked_list": ["import isEmail from 'validator/lib/isEmail';\nimport config from '../config';\nimport type { FieldValidator, ValidatorConfigWithMessage } from './types';\nimport { makeValidator } from './utils';\n\nexport type EmailValidatorConfig = ValidatorConfigWithMessage;\n\nexport function email(\n\t{ message }: EmailValidatorConfig = config.validators.email\n): FieldValidator<string> {\n\treturn makeValidator( {\n\t\tpredicate: value => isEmail( value ),\n\t\tmessage\n\t} );\n}\n"]}
{"filename": "src/validators/types.ts", "chunked_list": ["import type Form from '../Form';\n\nexport interface ValidationResult {\n\tisValid: boolean,\n\terror: string\n}\n\nexport type FieldValidator<ValueType> = (\n\tvalue: ValueType, form?: Form, label?: string\n) => ValidationResult;\n", "export interface MakeValidatorParams<ValueType> {\n\tpredicate: ( value: ValueType, form?: Form ) => boolean,\n\tmessage: string\n}\n\nexport interface ValidatorConfigWithMessage {\n\tmessage: string\n}\n"]}
{"filename": "src/validators/minLength.ts", "chunked_list": ["import config from '../config';\nimport type { FieldValidator, ValidatorConfigWithMessage } from './types';\nimport { makeValidator } from './utils';\n\nexport type MinLengthValidatorConfig = ValidatorConfigWithMessage;\n\nexport function minLength(\n\tminLengthValue: number,\n\t{ message }: MinLengthValidatorConfig = config.validators.minLength\n): FieldValidator<string> {\n\treturn makeValidator( {\n\t\tpredicate: value => value.length >= minLengthValue,\n\t\tmessage: message.replace( ':length', minLengthValue.toString() )\n\t} );\n}\n"]}
{"filename": "src/validators/utils.ts", "chunked_list": ["import { invalid, valid } from './results';\nimport type { FieldValidator, MakeValidatorParams } from './types';\n\nexport function makeValidator<ValueType>( {\n\tpredicate, message\n}: MakeValidatorParams<ValueType> ): FieldValidator<ValueType> {\n\treturn ( value, form, label ) => (\n\t\tpredicate( value, form )\n\t\t\t? valid()\n\t\t\t: invalid( message.replace( ':label', label || 'Field' ) )\n\t);\n}\n"]}
{"filename": "src/validators/index.ts", "chunked_list": ["export { email } from './email';\nexport { length } from './length';\nexport { maxLength } from './maxLength';\nexport { minLength } from './minLength';\nexport { required } from './required';\nexport { invalid, valid } from './results';\n\nexport type { FieldValidator, ValidationResult } from './types';\n", ""]}
{"filename": "src/validators/length.ts", "chunked_list": ["import config from '../config';\nimport type { FieldValidator, ValidatorConfigWithMessage } from './types';\nimport { makeValidator } from './utils';\n\nexport type LengthValidatorConfig = ValidatorConfigWithMessage;\n\nexport function length(\n\tlengthValue: number,\n\t{ message }: LengthValidatorConfig = config.validators.length\n): FieldValidator<string> {\n\treturn makeValidator( {\n\t\tpredicate: value => value.length === lengthValue,\n\t\tmessage: message.replace( ':length', lengthValue.toString() )\n\t} );\n}\n"]}
{"filename": "src/validators/maxLength.ts", "chunked_list": ["import config from '../config';\nimport type { FieldValidator, ValidatorConfigWithMessage } from './types';\nimport { makeValidator } from './utils';\n\nexport type MaxLengthValidatorConfig = ValidatorConfigWithMessage;\n\nexport function maxLength(\n\tmaxLengthValue: number,\n\t{ message }: MaxLengthValidatorConfig = config.validators.maxLength\n): FieldValidator<string> {\n\treturn makeValidator( {\n\t\tpredicate: value => value.length <= maxLengthValue,\n\t\tmessage: message.replace( ':length', maxLengthValue.toString() )\n\t} );\n}\n"]}
{"filename": "src/TextInput/types.ts", "chunked_list": ["import type { InputParams } from '../Input';\n\nexport interface TextInputParams extends Omit<InputParams<string>, 'defaultValue'> {\n\tdefaultValue?: string\n}\n"]}
{"filename": "src/TextInput/index.ts", "chunked_list": ["import Input from '../Input';\nimport type { TextInputParams } from './types';\n\nexport default class TextInput extends Input<string> {\n\tconstructor( {\n\t\tdefaultValue = '',\n\t\t...inputParams\n\t}: TextInputParams ) {\n\t\tsuper( { defaultValue, ...inputParams } );\n\t}\n}\n", "export function textInput( params: TextInputParams ) {\n\treturn new TextInput( params );\n}\n\nexport type { TextInputParams };\n"]}
{"filename": "src/ManualField/index.ts", "chunked_list": ["import { action, makeObservable } from 'mobx';\nimport Field, { FieldParams } from '../Field';\n\nexport default class ManualField<ValueType> extends Field<ValueType> {\n\tconstructor( params: FieldParams<ValueType> ) {\n\t\tsuper( params );\n\n\t\tmakeObservable( this, {\n\t\t\tchange: action\n\t\t} );\n\t}\n\n\tchange( newValue: ValueType ) {\n\t\tthis.setValue( newValue );\n\t\tthis.syncError();\n\t}\n\n\tset( newValue: ValueType ) {\n\t\tthis.change( newValue );\n\t}\n\n\tselect( newValue: ValueType ) {\n\t\tthis.change( newValue );\n\t}\n}\n", "export function manualField<ValueType>( params: FieldParams<ValueType> ) {\n\treturn new ManualField<ValueType>( params );\n}\n"]}
{"filename": "src/select/index.ts", "chunked_list": ["import ManualField from '../ManualField';\nimport type { FieldParams } from '../Field';\nimport type { WithOptionalDefaultValue } from '../utils/types';\n\nexport type Select<ValueType> = ManualField<ValueType | null>;\n\nexport type SelectParams<ValueType> = WithOptionalDefaultValue<FieldParams<ValueType | null>>;\n\nexport default function select<ValueType = string>( params: SelectParams<ValueType> ) {\n\treturn new ManualField<ValueType | null>( { defaultValue: null, ...params } );\n}\n", "export default function select<ValueType = string>( params: SelectParams<ValueType> ) {\n\treturn new ManualField<ValueType | null>( { defaultValue: null, ...params } );\n}\n"]}
