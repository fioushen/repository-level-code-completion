{"filename": "src/deye-sun-g3/NodeOutput.d.ts", "chunked_list": ["interface PV {\n    voltage: number;\n    current: number;\n    power: number;\n}\n\ninterface Output {\n    power: number;\n    voltage: number;\n    current: number;\n    frequency: number;\n}\n", "interface Counters {\n    totalEnergy: number;\n    totalEnergyToday: number;\n    pv1TotalEnergy: number;\n    pv1TotalEnergyToday: number;\n    pv2TotalEnergy: number;\n    pv2TotalEnergyToday: number;\n    pv3TotalEnergy: number;\n    pv3TotalEnergyToday: number;\n    pv4TotalEnergy: number;\n    pv4TotalEnergyToday: number;\n}\n", "export interface NodeOutput {\n    pv1: PV;\n    pv2: PV;\n    pv3: PV;\n    pv4: PV;\n    output: Output;\n    counters: Counters;\n    temperature: number | null;\n    isAvailable: boolean;\n}\n"]}
{"filename": "src/deye-sun-g3/ActionFactory.ts", "chunked_list": ["import { Action, ActionFactory as ActionFactoryInterface, Message } from '@binsoul/node-red-bundle-processing';\nimport type { Node, NodeAPI } from '@node-red/registry';\nimport { NodeMessageInFlow, NodeStatus } from 'node-red';\nimport { clearTimeout, setTimeout } from 'timers';\nimport { DailyResetAction } from './Action/DailyResetAction';\nimport { OutputAction } from './Action/OutputAction';\nimport { UnavailableAction } from './Action/UnavailableAction';\nimport { UpdateAction } from './Action/UpdateAction';\nimport type { Configuration } from './Configuration';\nimport { Storage } from './Storage';", "import type { Configuration } from './Configuration';\nimport { Storage } from './Storage';\n\ninterface MessageData extends NodeMessageInFlow {\n    command?: string;\n    timestamp?: number;\n}\n\nfunction formatTime(timestamp: number) {\n    const date = new Date(timestamp);\n\n    return date.getHours().toString().padStart(2, '0') + ':' + date.getMinutes().toString().padStart(2, '0');\n}\n\n/**\n * Generates actions.\n */", "function formatTime(timestamp: number) {\n    const date = new Date(timestamp);\n\n    return date.getHours().toString().padStart(2, '0') + ':' + date.getMinutes().toString().padStart(2, '0');\n}\n\n/**\n * Generates actions.\n */\nexport class ActionFactory implements ActionFactoryInterface {\n    private readonly configuration: Configuration;\n    private readonly RED: NodeAPI;\n    private readonly node: Node;\n    private readonly storage: Storage;\n    private firstMessage = true;\n    private updateTimer: NodeJS.Timeout | null = null;\n    private dailyResetTimer: NodeJS.Timeout | null = null;\n    private unavailableTimer: NodeJS.Timeout | null = null;\n\n    constructor(RED: NodeAPI, node: Node, configuration: Configuration) {\n        this.RED = RED;\n        this.node = node;\n        this.configuration = configuration;\n        this.storage = new Storage(configuration);\n    }\n\n    build(message: Message): Action | Array<Action> | null {\n        const data: MessageData = message.data;\n        const command = data.command;\n", "export class ActionFactory implements ActionFactoryInterface {\n    private readonly configuration: Configuration;\n    private readonly RED: NodeAPI;\n    private readonly node: Node;\n    private readonly storage: Storage;\n    private firstMessage = true;\n    private updateTimer: NodeJS.Timeout | null = null;\n    private dailyResetTimer: NodeJS.Timeout | null = null;\n    private unavailableTimer: NodeJS.Timeout | null = null;\n\n    constructor(RED: NodeAPI, node: Node, configuration: Configuration) {\n        this.RED = RED;\n        this.node = node;\n        this.configuration = configuration;\n        this.storage = new Storage(configuration);\n    }\n\n    build(message: Message): Action | Array<Action> | null {\n        const data: MessageData = message.data;\n        const command = data.command;\n", "        if (this.firstMessage) {\n            this.firstMessage = false;\n            this.scheduleUnavailableCheck();\n        }\n\n        if (typeof command !== 'undefined' && ('' + command).trim() !== '') {\n            switch (command.toLowerCase()) {\n                case 'update':\n                    this.storage.setUpdating(true);\n\n                    return new UpdateAction(\n                        this.configuration,\n                        this.storage,\n                        () => this.outputCallback(),\n                        (status: NodeStatus) => this.nodeStatusCallback(status),\n                    );\n                case 'output':\n                    this.storage.setUpdating(false);\n                    this.scheduleUnavailableCheck();\n\n                    return new OutputAction(this.configuration, this.storage);\n\n                case 'dailyreset':\n                    return new DailyResetAction(this.configuration, this.storage);\n                case 'unavailable':\n                    return new UnavailableAction(this.configuration, this.storage);\n            }\n        }\n", "        if (!this.storage.isUpdating()) {\n            if (this.updateTimer !== null) {\n                clearTimeout(this.updateTimer);\n                this.updateTimer = null;\n            }\n\n            this.scheduleUpdate();\n\n            this.storage.setUpdating(true);\n\n            return new UpdateAction(\n                this.configuration,\n                this.storage,\n                () => this.outputCallback(),\n                (status: NodeStatus) => this.nodeStatusCallback(status),\n            );\n        }\n\n        return null;\n    }\n\n    setup(): void {", "        if (this.configuration.updateMode === 'never') {\n            this.node.status({\n                fill: 'yellow',\n                shape: 'dot',\n                text: 'waiting for message',\n            });\n\n            return;\n        }\n\n        const now = Date.now();\n        const firstUpdateAt = Math.ceil(now / (this.configuration.updateFrequency * 60000)) * this.configuration.updateFrequency * 60000;\n        this.updateTimer = setTimeout(() => this.executeUpdate(), firstUpdateAt - now + 1000);\n\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        tomorrow.setHours(0, 0, 0);\n\n        this.dailyResetTimer = setTimeout(() => this.executeDailyReset(), tomorrow.getTime() - now);\n\n        this.node.status({\n            fill: 'yellow',\n            shape: 'dot',\n            text: `waiting until ${formatTime(firstUpdateAt)}`,\n        });\n    }\n\n    teardown(): void {", "        if (this.updateTimer !== null) {\n            clearTimeout(this.updateTimer);\n            this.updateTimer = null;\n        }\n\n        if (this.dailyResetTimer !== null) {\n            clearTimeout(this.dailyResetTimer);\n            this.dailyResetTimer = null;\n        }\n\n        if (this.unavailableTimer !== null) {\n            clearTimeout(this.unavailableTimer);\n            this.unavailableTimer = null;\n        }\n    }\n\n    /**\n     * Starts a timer if automatic updates are enabled and no timer exists.\n     */\n    private scheduleUpdate(): void {", "        if (this.unavailableTimer !== null) {\n            clearTimeout(this.unavailableTimer);\n            this.unavailableTimer = null;\n        }\n    }\n\n    /**\n     * Starts a timer if automatic updates are enabled and no timer exists.\n     */\n    private scheduleUpdate(): void {\n        if (this.updateTimer !== null || this.configuration.updateMode === 'never') {\n            return;\n        }\n\n        const now = Date.now();\n        this.updateTimer = setTimeout(() => this.executeUpdate(), this.getStartOfSlot(now) - now + this.configuration.updateFrequency * 60000 + 1000);\n    }\n\n    /**\n     * Handles automatic updates.\n     */\n    executeUpdate(): void {\n        const now = new Date().getTime();\n        const nextUpdateAt = this.getStartOfSlot(now) + this.configuration.updateFrequency * 60000 + 1000;\n        this.updateTimer = setTimeout(() => this.executeUpdate(), nextUpdateAt - now);\n\n        // trigger node.on('input', () => {})\n        this.node.receive(<MessageData>{\n            command: 'update',\n            timestamp: now,\n        });\n    }\n\n    /**\n     * Handles daily resets of counters.\n     */\n    executeDailyReset(): void {\n        const now = Date.now();\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        tomorrow.setHours(0, 0, 0);\n\n        this.dailyResetTimer = setTimeout(() => this.executeDailyReset(), tomorrow.getTime() - now);\n\n        // trigger node.on('input', () => {})\n        this.node.receive(<MessageData>{\n            command: 'dailyReset',\n            timestamp: now,\n        });\n    }\n\n    /**\n     * Starts a timer which changes the device status to unavailable.\n     */\n    private scheduleUnavailableCheck(): void {", "        if (this.updateTimer !== null || this.configuration.updateMode === 'never') {\n            return;\n        }\n\n        const now = Date.now();\n        this.updateTimer = setTimeout(() => this.executeUpdate(), this.getStartOfSlot(now) - now + this.configuration.updateFrequency * 60000 + 1000);\n    }\n\n    /**\n     * Handles automatic updates.\n     */\n    executeUpdate(): void {\n        const now = new Date().getTime();\n        const nextUpdateAt = this.getStartOfSlot(now) + this.configuration.updateFrequency * 60000 + 1000;\n        this.updateTimer = setTimeout(() => this.executeUpdate(), nextUpdateAt - now);\n\n        // trigger node.on('input', () => {})\n        this.node.receive(<MessageData>{\n            command: 'update',\n            timestamp: now,\n        });\n    }\n\n    /**\n     * Handles daily resets of counters.\n     */\n    executeDailyReset(): void {\n        const now = Date.now();\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        tomorrow.setHours(0, 0, 0);\n\n        this.dailyResetTimer = setTimeout(() => this.executeDailyReset(), tomorrow.getTime() - now);\n\n        // trigger node.on('input', () => {})\n        this.node.receive(<MessageData>{\n            command: 'dailyReset',\n            timestamp: now,\n        });\n    }\n\n    /**\n     * Starts a timer which changes the device status to unavailable.\n     */\n    private scheduleUnavailableCheck(): void {", "        if (this.unavailableTimer !== null) {\n            clearTimeout(this.unavailableTimer);\n            this.unavailableTimer = null;\n        }\n\n        const now = Date.now();\n        this.unavailableTimer = setTimeout(() => this.executeUnavailableCheck(), this.getStartOfSlot(now) - now + this.configuration.deviceTimeout * 60000);\n    }\n\n    private executeUnavailableCheck(): void {\n        this.unavailableTimer = null;\n\n        this.node.receive(<MessageData>{\n            command: 'unavailable',\n        });\n    }\n\n    outputCallback(): void {\n        this.node.receive(<MessageData>{\n            command: 'output',\n        });\n    }\n\n    nodeStatusCallback(status: NodeStatus): void {\n        this.node.status(status);\n    }\n\n    private getStartOfSlot(timestamp: number) {\n        return Math.floor(timestamp / 60000) * 60000;\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/ConfigurationBuilder.ts", "chunked_list": ["import { Configuration } from './Configuration';\nimport type { UserConfiguration } from './UserConfiguration';\n\nconst getString = function (value: unknown, defaultValue: string): string {\n    const result = value || defaultValue;\n\n    const stringValue = '' + result;\n    if (stringValue.trim() === '') {\n        return defaultValue;\n    }\n\n    return stringValue;\n};\n\n/**\n * Creates a sanitized configuration from user input.\n */", "export function buildConfiguration(config: UserConfiguration): Configuration {\n    const outputTarget = getString(config.outputTarget, 'msg');\n    const outputProperty = getString(config.outputProperty, 'payload');\n    const deviceIp = getString(config.deviceIp, '');\n    const deviceSerialNumber = getString(config.deviceSerialNumber, '');\n    const deviceTimeout = Number(config.deviceTimeout || 30);\n    const updateMode = getString(config.updateMode, 'never');\n    const updateFrequency = Number(config.updateFrequency || 5);\n\n    return new Configuration(outputTarget, outputProperty, deviceIp, deviceSerialNumber, deviceTimeout, updateMode, updateFrequency);\n}\n"]}
{"filename": "src/deye-sun-g3/Node.ts", "chunked_list": ["import { MessageHandler } from '@binsoul/node-red-bundle-processing';\nimport type { Node, NodeInitializer } from 'node-red';\nimport { ActionFactory } from './ActionFactory';\nimport { buildConfiguration } from './ConfigurationBuilder';\nimport type { UserConfiguration } from './UserConfiguration';\n\nconst nodeInitializer: NodeInitializer = (RED): void => {\n    function NodeConstructor(this: Node, userConfiguration: UserConfiguration): void {\n        RED.nodes.createNode(this, userConfiguration);\n\n        const configuration = buildConfiguration(userConfiguration);\n        const actionFactory = new ActionFactory(RED, this, configuration);\n        const messageHandler = new MessageHandler(RED, this, actionFactory);\n\n        actionFactory.setup();\n\n        this.on('input', (msg, send, done) => messageHandler.handle(msg, send, done));\n        this.on('close', () => actionFactory.teardown());\n    }\n\n    RED.nodes.registerType('binsoul-deye-sun-g3', NodeConstructor);\n};\n\nexport = nodeInitializer;\n"]}
{"filename": "src/deye-sun-g3/UserConfiguration.d.ts", "chunked_list": ["import type { NodeDef } from 'node-red';\n\n/**\n * Configuration options available to users.\n */\nexport interface UserConfigurationOptions {\n    outputTarget?: string;\n    outputProperty?: string;\n    deviceIp?: string;\n    deviceSerialNumber?: string;\n    deviceTimeout?: number;\n    updateMode?: string;\n    updateFrequency?: number;\n}\n\n/**\n * Configuration generated by the user in the editor.\n */", "export interface UserConfiguration extends NodeDef, UserConfigurationOptions {}\n"]}
{"filename": "src/deye-sun-g3/Configuration.ts", "chunked_list": ["/**\n * Sanitized configuration generated from user input.\n */\nexport class Configuration {\n    outputProperty: string;\n    outputTarget: string;\n    deviceIp: string;\n    deviceSerialNumber: string;\n    deviceTimeout: number;\n    updateMode: string;\n    updateFrequency: number;\n\n    constructor(outputTarget = 'msg', outputProperty = 'payload', deviceIp: string, deviceSerialNumber: string, deviceTimeout = 30, updateMode = 'never', updateFrequency = 5) {\n        this.outputTarget = outputTarget;\n        this.outputProperty = outputProperty;\n        this.deviceIp = deviceIp;\n        this.deviceSerialNumber = deviceSerialNumber;\n        this.deviceTimeout = deviceTimeout;\n        this.updateMode = updateMode;\n        this.updateFrequency = updateFrequency;\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/Storage.ts", "chunked_list": ["import { Configuration } from './Configuration';\nimport { RegisterValues } from './DeyeRegisters';\nimport { NodeOutput } from './NodeOutput';\n\n/**\n * Stores events and a history of past events.\n */\nexport class Storage {\n    private configuration: Configuration;\n\n    private updating = false;\n    private connected = false;\n\n    private lastConnectionAt: number | null = null;\n    private lastDataAt: number | null = null;\n    private available = true;\n    private data: RegisterValues | null = null;\n\n    constructor(configuration: Configuration) {\n        this.configuration = configuration;\n    }\n\n    public isUpdating(): boolean {\n        return this.updating;\n    }\n\n    public setUpdating(value: boolean) {\n        this.updating = value;", "        if (value) {\n            this.connected = false;\n        }\n    }\n\n    public setConnected() {\n        this.connected = true;\n        this.lastConnectionAt = Date.now();\n        this.available = true;\n    }\n\n    public getData(): NodeOutput | null {", "        if (this.data === null || !this.available) {\n            return null;\n        }\n\n        const pv1 = {\n            voltage: this.data.pv1Voltage,\n            current: this.data.pv1Current,\n            power: this.round(this.data.pv1Voltage * this.data.pv1Current, '4'),\n        };\n\n        const pv2 = {\n            voltage: this.data.pv2Voltage,\n            current: this.data.pv2Current,\n            power: this.round(this.data.pv2Voltage * this.data.pv2Current, '4'),\n        };\n\n        const pv3 = {\n            voltage: this.data.pv3Voltage,\n            current: this.data.pv3Current,\n            power: this.round(this.data.pv3Voltage * this.data.pv3Current, '4'),\n        };\n\n        const pv4 = {\n            voltage: this.data.pv4Voltage,\n            current: this.data.pv4Current,\n            power: this.round(this.data.pv4Voltage * this.data.pv4Current, '4'),\n        };\n\n        const output = {\n            power: this.data.acPower,\n            voltage: this.data.acVoltage,\n            current: this.data.acCurrent,\n            frequency: this.data.acFrequency,\n        };\n\n        const counters = {\n            totalEnergy: this.data.totalEnergy,\n            pv1TotalEnergy: this.data.pv1TotalEnergy,\n            pv2TotalEnergy: this.data.pv2TotalEnergy,\n            pv3TotalEnergy: this.data.pv3TotalEnergy,\n            pv4TotalEnergy: this.data.pv4TotalEnergy,\n            totalEnergyToday: this.data.totalEnergyToday,\n            pv1TotalEnergyToday: this.data.pv1TotalEnergyToday,\n            pv2TotalEnergyToday: this.data.pv2TotalEnergyToday,\n            pv3TotalEnergyToday: this.data.pv3TotalEnergyToday,\n            pv4TotalEnergyToday: this.data.pv4TotalEnergyToday,\n        };\n\n        return {\n            pv1: pv1,\n            pv2: pv2,\n            pv3: pv3,\n            pv4: pv4,\n            output: output,\n            counters: counters,\n            temperature: this.data.temperature,\n            isAvailable: this.available,\n        };\n    }\n\n    public setData(data: RegisterValues) {", "        if (this.data !== null && this.data.totalEnergy > data.totalEnergy) {\n            // totalEnergy should always increase while the node is running\n            return;\n        }\n\n        this.data = data;\n        this.lastDataAt = Date.now();\n        this.available = true;\n    }\n\n    public resetCounters(): void {", "        if (this.data !== null) {\n            this.data.pv1TotalEnergyToday = 0;\n            this.data.pv2TotalEnergyToday = 0;\n            this.data.pv3TotalEnergyToday = 0;\n            this.data.pv4TotalEnergyToday = 0;\n            this.data.totalEnergyToday = 0;\n        }\n    }\n\n    public resetRuntime(): void {\n        if (this.data !== null) {\n            this.data.pv1Voltage = 0;\n            this.data.pv1Current = 0;\n            this.data.pv2Voltage = 0;\n            this.data.pv2Current = 0;\n            this.data.pv3Voltage = 0;\n            this.data.pv3Current = 0;\n            this.data.pv4Voltage = 0;\n            this.data.pv4Current = 0;\n            this.data.acFrequency = 0;\n            this.data.acPower = 0;\n            this.data.acVoltage = 0;\n            this.data.acCurrent = 0;\n            this.data.uptime = 0;\n            this.data.operatingPower = 0;\n            this.data.temperature = null;\n        }\n    }\n\n    public isAvailable(): boolean {\n        return this.available;\n    }\n\n    public setAvailable(value: boolean): void {\n        this.available = value;\n    }\n\n    private round(value: number, decimals: string): number {\n        return Number(Math.round(<number>(<unknown>(value + 'e' + decimals))) + 'e-' + decimals);\n    }\n}\n", "        if (this.data !== null) {\n            this.data.pv1Voltage = 0;\n            this.data.pv1Current = 0;\n            this.data.pv2Voltage = 0;\n            this.data.pv2Current = 0;\n            this.data.pv3Voltage = 0;\n            this.data.pv3Current = 0;\n            this.data.pv4Voltage = 0;\n            this.data.pv4Current = 0;\n            this.data.acFrequency = 0;\n            this.data.acPower = 0;\n            this.data.acVoltage = 0;\n            this.data.acCurrent = 0;\n            this.data.uptime = 0;\n            this.data.operatingPower = 0;\n            this.data.temperature = null;\n        }\n    }\n\n    public isAvailable(): boolean {\n        return this.available;\n    }\n\n    public setAvailable(value: boolean): void {\n        this.available = value;\n    }\n\n    private round(value: number, decimals: string): number {\n        return Number(Math.round(<number>(<unknown>(value + 'e' + decimals))) + 'e-' + decimals);\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/DeyeRegisters.ts", "chunked_list": ["interface Definition {\n    name: string;\n    type: 'unsigned' | 'signed' | 'string';\n    scale?: number;\n    offset?: number;\n    registers: Array<number>;\n    unit: string;\n}\n\nexport interface RegisterValues {\n    [key: string]: number | string | null;\n    id: string;\n    statusCode: number;\n    totalEnergy: number;\n    totalEnergyToday: number;\n    acPower: number;\n    acVoltage: number;\n    acCurrent: number;\n    acFrequency: number;\n    pv1Voltage: number;\n    pv1Current: number;\n    pv1TotalEnergy: number;\n    pv1TotalEnergyToday: number;\n    pv2Voltage: number;\n    pv2Current: number;\n    pv2TotalEnergy: number;\n    pv2TotalEnergyToday: number;\n    pv3Voltage: number;\n    pv3Current: number;\n    pv3TotalEnergy: number;\n    pv3TotalEnergyToday: number;\n    pv4Voltage: number;\n    pv4Current: number;\n    pv4TotalEnergy: number;\n    pv4TotalEnergyToday: number;\n    temperature: number | null;\n    uptime: number;\n    operatingPower: number;\n}\n", "export interface RegisterValues {\n    [key: string]: number | string | null;\n    id: string;\n    statusCode: number;\n    totalEnergy: number;\n    totalEnergyToday: number;\n    acPower: number;\n    acVoltage: number;\n    acCurrent: number;\n    acFrequency: number;\n    pv1Voltage: number;\n    pv1Current: number;\n    pv1TotalEnergy: number;\n    pv1TotalEnergyToday: number;\n    pv2Voltage: number;\n    pv2Current: number;\n    pv2TotalEnergy: number;\n    pv2TotalEnergyToday: number;\n    pv3Voltage: number;\n    pv3Current: number;\n    pv3TotalEnergy: number;\n    pv3TotalEnergyToday: number;\n    pv4Voltage: number;\n    pv4Current: number;\n    pv4TotalEnergy: number;\n    pv4TotalEnergyToday: number;\n    temperature: number | null;\n    uptime: number;\n    operatingPower: number;\n}\n", "export class DeyeRegisters {\n    private dataDefinition: Array<Definition> = [\n        { name: 'id', type: 'string', registers: [0, 1, 2, 3, 4], unit: '' },\n        { name: 'statusCode', scale: 1, type: 'unsigned', registers: [56], unit: '' },\n        { name: 'totalEnergy', scale: 0.1, type: 'unsigned', registers: [60, 61], unit: 'kWh' },\n        { name: 'totalEnergyToday', scale: 0.1, type: 'unsigned', registers: [57], unit: 'kWh' },\n        { name: 'acPower', scale: 0.1, type: 'unsigned', registers: [83, 84], unit: 'W' },\n        { name: 'acVoltage', scale: 0.1, type: 'unsigned', registers: [70], unit: 'V' },\n        { name: 'acCurrent', scale: 0.1, type: 'signed', registers: [73], unit: 'A' },\n        { name: 'acFrequency', scale: 0.01, type: 'unsigned', registers: [76], unit: 'Hz' },\n        { name: 'pv1Voltage', scale: 0.1, type: 'unsigned', registers: [106], unit: 'V' },\n        { name: 'pv1Current', scale: 0.1, type: 'unsigned', registers: [107], unit: 'A' },\n        { name: 'pv1TotalEnergy', scale: 0.1, type: 'unsigned', registers: [66, 67], unit: 'kWh' },\n        { name: 'pv1TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [62], unit: 'kWh' },\n        { name: 'pv2Voltage', scale: 0.1, type: 'unsigned', registers: [108], unit: 'V' },\n        { name: 'pv2Current', scale: 0.1, type: 'unsigned', registers: [109], unit: 'A' },\n        { name: 'pv2TotalEnergy', scale: 0.1, type: 'unsigned', registers: [68, 69], unit: 'kWh' },\n        { name: 'pv2TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [63], unit: 'kWh' },\n        { name: 'pv3Voltage', scale: 0.1, type: 'unsigned', registers: [110], unit: 'V' },\n        { name: 'pv3Current', scale: 0.1, type: 'unsigned', registers: [111], unit: 'A' },\n        { name: 'pv3TotalEnergy', scale: 0.1, type: 'unsigned', registers: [71, 72], unit: 'kWh' },\n        { name: 'pv3TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [64], unit: 'kWh' },\n        { name: 'pv4Voltage', scale: 0.1, type: 'unsigned', registers: [112], unit: 'V' },\n        { name: 'pv4Current', scale: 0.1, type: 'unsigned', registers: [113], unit: 'A' },\n        { name: 'pv4TotalEnergy', scale: 0.1, type: 'unsigned', registers: [74, 75], unit: 'kWh' },\n        { name: 'pv4TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [65], unit: 'kWh' },\n        { name: 'temperature', scale: 0.01, offset: 1000, type: 'unsigned', registers: [87], unit: '\u00b0C' },\n        { name: 'uptime', scale: 1, type: 'unsigned', registers: [59], unit: 'm' },\n        { name: 'operatingPower', scale: 0.1, type: 'unsigned', registers: [77], unit: 'W' },\n    ];\n\n    public parse(modbusRegisters: Array<number>): RegisterValues {\n        const result: RegisterValues = {\n            id: '',\n            statusCode: 0,\n            totalEnergy: 0,\n            totalEnergyToday: 0,\n            acPower: 0,\n            acVoltage: 0,\n            acCurrent: 0,\n            acFrequency: 0,\n            pv1Voltage: 0,\n            pv1Current: 0,\n            pv1TotalEnergy: 0,\n            pv1TotalEnergyToday: 0,\n            pv2Voltage: 0,\n            pv2Current: 0,\n            pv2TotalEnergy: 0,\n            pv2TotalEnergyToday: 0,\n            pv3Voltage: 0,\n            pv3Current: 0,\n            pv3TotalEnergy: 0,\n            pv3TotalEnergyToday: 0,\n            pv4Voltage: 0,\n            pv4Current: 0,\n            pv4TotalEnergy: 0,\n            pv4TotalEnergyToday: 0,\n            temperature: 0,\n            uptime: 0,\n            operatingPower: 0,\n        };\n", "        for (const definition of this.dataDefinition) {\n            let value;\n            const type = definition.type;\n            if (type === 'unsigned') {\n                value = this.parseUnsigned(modbusRegisters, definition.registers, definition.scale || 1, definition.offset || 0);\n            } else if (type === 'signed') {\n                value = this.parseSigned(modbusRegisters, definition.registers, definition.scale || 1, definition.offset || 0);\n            } else if (type === 'string') {\n                value = this.parseString(modbusRegisters, definition.registers);\n            } else {\n                value = 'unknown';\n            }\n\n            result[definition.name] = value;\n        }\n\n        return result;\n    }\n\n    private parseUnsigned(modbusRegisters: Array<number>, registers: Array<number>, scale: number, offset: number): number {\n        let value = 0;\n        let shift = 0;", "        for (const index of registers) {\n            const temp = modbusRegisters[index];\n            value += (temp & 0xffff) << shift;\n            shift += 16;\n        }\n\n        value = value - offset;\n        value = value * scale;\n\n        return this.round(value, '4');\n    }\n\n    private parseSigned(modbusRegisters: Array<number>, registers: Array<number>, scale: number, offset: number): number {\n        let value = 0;\n        let shift = 0;\n        let maxint = 0;", "        for (const index of registers) {\n            maxint <<= 16;\n            maxint |= 0xffff;\n            const temp = modbusRegisters[index];\n            value += (temp & 0xffff) << shift;\n            shift += 16;\n        }\n\n        value = value - offset;\n\n        if (value > maxint / 2) {\n            value = (value - maxint) * scale;\n        } else {\n            value = value * scale;\n        }\n\n        return this.round(value, '4');\n    }\n\n    private parseString(modbusRegisters: Array<number>, registers: Array<number>): string {\n        let value = '';", "        if (value > maxint / 2) {\n            value = (value - maxint) * scale;\n        } else {\n            value = value * scale;\n        }\n\n        return this.round(value, '4');\n    }\n\n    private parseString(modbusRegisters: Array<number>, registers: Array<number>): string {\n        let value = '';", "        for (const index of registers) {\n            const temp = modbusRegisters[index];\n            value = value + String.fromCharCode(temp >> 8) + String.fromCharCode(temp & 0xff);\n        }\n\n        return value;\n    }\n\n    private round(value: number, decimals: string): number {\n        return Number(Math.round(<number>(<unknown>(value + 'e' + decimals))) + 'e-' + decimals);\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/Action/DailyResetAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\nimport type { Configuration } from '../Configuration';\nimport { Storage } from '../Storage';\n\nexport class DailyResetAction implements Action {\n    private readonly configuration: Configuration;\n    private storage: Storage;\n\n    constructor(configuration: Configuration, storage: Storage) {\n        this.configuration = configuration;\n        this.storage = storage;\n    }\n\n    defineInput(): InputDefinition {\n        return new InputDefinition();\n    }\n\n    defineOutput(): OutputDefinition {\n        const result = new OutputDefinition();\n\n        result.set('output', {\n            target: this.configuration.outputTarget,\n            property: this.configuration.outputProperty,\n            type: 'object',\n            channel: 0,\n        });\n\n        return result;\n    }\n\n    execute(): Output {\n        const result = new Output();\n        const isAvailable = this.storage.isAvailable();\n\n        this.storage.setAvailable(true);\n        this.storage.resetCounters();\n        const data = this.storage.getData();\n        this.storage.setAvailable(isAvailable);\n", "        if (data !== null) {\n            data.isAvailable = isAvailable;\n\n            result.setValue('output', data);\n\n            result.setNodeStatus({\n                fill: 'green',\n                shape: 'dot',\n                text: `daily reset`,\n            });\n        }\n\n        return result;\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/Action/UnavailableAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\nimport type { Configuration } from '../Configuration';\nimport { Storage } from '../Storage';\n\nexport class UnavailableAction implements Action {\n    private readonly configuration: Configuration;\n    private storage: Storage;\n\n    constructor(configuration: Configuration, storage: Storage) {\n        this.configuration = configuration;\n        this.storage = storage;\n    }\n\n    defineInput(): InputDefinition {\n        return new InputDefinition();\n    }\n\n    defineOutput(): OutputDefinition {\n        const result = new OutputDefinition();\n\n        result.set('output', {\n            target: this.configuration.outputTarget,\n            property: this.configuration.outputProperty,\n            type: 'object',\n            channel: 0,\n        });\n\n        return result;\n    }\n\n    execute(): Output {\n        const result = new Output();\n\n        this.storage.setAvailable(true);\n        this.storage.resetRuntime();\n        const data = this.storage.getData();\n        this.storage.setAvailable(false);\n", "        if (data !== null) {\n            data.isAvailable = false;\n\n            result.setValue('output', data);\n        }\n\n        result.setNodeStatus({\n            fill: 'yellow',\n            shape: 'dot',\n            text: 'unavailable',\n        });\n\n        return result;\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/Action/OutputAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\nimport type { Configuration } from '../Configuration';\nimport { Storage } from '../Storage';\n\nexport class OutputAction implements Action {\n    private readonly configuration: Configuration;\n    private storage: Storage;\n\n    constructor(configuration: Configuration, storage: Storage) {\n        this.configuration = configuration;\n        this.storage = storage;\n    }\n\n    defineInput(): InputDefinition {\n        return new InputDefinition();\n    }\n\n    defineOutput(): OutputDefinition {\n        const result = new OutputDefinition();\n\n        result.set('output', {\n            target: this.configuration.outputTarget,\n            property: this.configuration.outputProperty,\n            type: 'object',\n            channel: 0,\n        });\n\n        return result;\n    }\n\n    execute(): Output {\n        const result = new Output();\n\n        const data = this.storage.getData();", "        if (data !== null) {\n            result.setValue('output', data);\n\n            result.setNodeStatus({\n                fill: 'green',\n                shape: 'dot',\n                text: `${data.output.power} W`,\n            });\n        }\n\n        return result;\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/Action/UpdateAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\nimport { ModbusRtu } from '@binsoul/nodejs-modbus';\nimport { SolarmanV5 } from '@binsoul/nodejs-solarman';\nimport * as net from 'net';\nimport { NodeStatus } from 'node-red';\nimport type { Configuration } from '../Configuration';\nimport { DeyeRegisters } from '../DeyeRegisters';\nimport { Storage } from '../Storage';\n\nexport class UpdateAction implements Action {\n    private readonly configuration: Configuration;\n    private readonly storage: Storage;\n    private readonly outputCallback: () => void;\n    private readonly nodeStatusCallback: (status: NodeStatus) => void;\n\n    constructor(configuration: Configuration, storage: Storage, outputCallback: () => void, nodeStatusCallback: (status: NodeStatus) => void) {\n        this.configuration = configuration;\n        this.storage = storage;\n        this.outputCallback = outputCallback;\n        this.nodeStatusCallback = nodeStatusCallback;\n    }\n\n    defineInput(): InputDefinition {\n        return new InputDefinition();\n    }\n\n    defineOutput(): OutputDefinition {\n        return new OutputDefinition();\n    }\n\n    execute(): Output {\n        const client = new net.Socket();\n        client.setTimeout(5000);\n\n        let hasConnected = false;\n        let errorMessage = '';\n        let retryCount = 0;\n\n        const unitAddress = 1;\n        const firstRegister = 0x0003;\n        const lastRegister = 0x0080;\n\n        const modbus = new ModbusRtu(unitAddress);\n        const modbusFrame = modbus.requestHoldingRegisters(firstRegister, lastRegister);\n\n        const solarman = new SolarmanV5(this.configuration.deviceSerialNumber, true);\n        const request = solarman.wrapModbusFrame(modbusFrame);\n\n        // Functions to handle socket events\n        const makeConnection = () => {\n            client.connect({ host: this.configuration.deviceIp, port: 8899 });\n        };\n\n        const connectEventHandler = () => {\n            hasConnected = true;\n            this.storage.setConnected();\n            client.write(request);\n        };\n\n        const dataEventHandler = (data: Buffer) => {", "\nexport class UpdateAction implements Action {\n    private readonly configuration: Configuration;\n    private readonly storage: Storage;\n    private readonly outputCallback: () => void;\n    private readonly nodeStatusCallback: (status: NodeStatus) => void;\n\n    constructor(configuration: Configuration, storage: Storage, outputCallback: () => void, nodeStatusCallback: (status: NodeStatus) => void) {\n        this.configuration = configuration;\n        this.storage = storage;\n        this.outputCallback = outputCallback;\n        this.nodeStatusCallback = nodeStatusCallback;\n    }\n\n    defineInput(): InputDefinition {\n        return new InputDefinition();\n    }\n\n    defineOutput(): OutputDefinition {\n        return new OutputDefinition();\n    }\n\n    execute(): Output {\n        const client = new net.Socket();\n        client.setTimeout(5000);\n\n        let hasConnected = false;\n        let errorMessage = '';\n        let retryCount = 0;\n\n        const unitAddress = 1;\n        const firstRegister = 0x0003;\n        const lastRegister = 0x0080;\n\n        const modbus = new ModbusRtu(unitAddress);\n        const modbusFrame = modbus.requestHoldingRegisters(firstRegister, lastRegister);\n\n        const solarman = new SolarmanV5(this.configuration.deviceSerialNumber, true);\n        const request = solarman.wrapModbusFrame(modbusFrame);\n\n        // Functions to handle socket events\n        const makeConnection = () => {\n            client.connect({ host: this.configuration.deviceIp, port: 8899 });\n        };\n\n        const connectEventHandler = () => {\n            hasConnected = true;\n            this.storage.setConnected();\n            client.write(request);\n        };\n\n        const dataEventHandler = (data: Buffer) => {", "            try {\n                const modbusFrame = solarman.unwrapModbusFrame(data);\n                const values = modbus.fetchHoldingRegisters(modbusFrame);\n\n                const parser = new DeyeRegisters();\n                this.storage.setData(parser.parse(values));\n\n                this.outputCallback();\n            } catch (error) {\n                if (error instanceof Error) {\n                    this.nodeStatusCallback({\n                        fill: 'red',\n                        shape: 'dot',\n                        text: error.message,\n                    });\n                }\n            }\n\n            client.end();\n        };\n\n        const timeoutEventHandler = () => {\n            errorMessage = 'Connection timed out';\n            client.end();\n        };\n\n        const errorEventHandler = (error: Error) => {\n            errorMessage = error.message;\n            client.end();\n        };\n\n        const closeEventHandler = () => {", "            } catch (error) {\n                if (error instanceof Error) {\n                    this.nodeStatusCallback({\n                        fill: 'red',\n                        shape: 'dot',\n                        text: error.message,\n                    });\n                }\n            }\n\n            client.end();\n        };\n\n        const timeoutEventHandler = () => {\n            errorMessage = 'Connection timed out';\n            client.end();\n        };\n\n        const errorEventHandler = (error: Error) => {\n            errorMessage = error.message;\n            client.end();\n        };\n\n        const closeEventHandler = () => {", "            if (hasConnected) {\n                return;\n            }\n\n            if (!this.storage.isAvailable()) {\n                this.nodeStatusCallback({\n                    fill: 'yellow',\n                    shape: 'dot',\n                    text: 'unavailable',\n                });\n            } else if (retryCount < 5) {\n                retryCount++;\n                this.nodeStatusCallback({\n                    fill: 'yellow',\n                    shape: 'dot',\n                    text: 'retry ' + retryCount,\n                });\n\n                setTimeout(makeConnection, 5000);\n            } else {\n                this.nodeStatusCallback({\n                    fill: 'red',\n                    shape: 'dot',\n                    text: errorMessage,\n                });\n            }\n        };\n\n        client.on('connect', connectEventHandler);\n        client.on('data', dataEventHandler);\n        client.on('timeout', timeoutEventHandler);\n        client.on('error', errorEventHandler);\n        client.on('close', closeEventHandler);\n\n        this.nodeStatusCallback({\n            fill: 'yellow',\n            shape: 'dot',\n            text: 'updating',\n        });\n\n        makeConnection();\n\n        return new Output();\n    }\n}\n", "            } else if (retryCount < 5) {\n                retryCount++;\n                this.nodeStatusCallback({\n                    fill: 'yellow',\n                    shape: 'dot',\n                    text: 'retry ' + retryCount,\n                });\n\n                setTimeout(makeConnection, 5000);\n            } else {\n                this.nodeStatusCallback({\n                    fill: 'red',\n                    shape: 'dot',\n                    text: errorMessage,\n                });\n            }\n        };\n\n        client.on('connect', connectEventHandler);\n        client.on('data', dataEventHandler);\n        client.on('timeout', timeoutEventHandler);\n        client.on('error', errorEventHandler);\n        client.on('close', closeEventHandler);\n\n        this.nodeStatusCallback({\n            fill: 'yellow',\n            shape: 'dot',\n            text: 'updating',\n        });\n\n        makeConnection();\n\n        return new Output();\n    }\n}\n"]}
{"filename": "src/deye-sun-g3/Node.html/editor.ts", "chunked_list": ["import type { EditorNodeProperties, EditorRED } from 'node-red';\nimport type { UserConfigurationOptions } from '../UserConfiguration';\n\ndeclare const RED: EditorRED;\n\ninterface NodeEditorProperties extends EditorNodeProperties, UserConfigurationOptions {}\n\nRED.nodes.registerType<NodeEditorProperties>('binsoul-deye-sun-g3', {\n    category: 'device',\n    color: '#4594d1',\n    defaults: {\n        outputProperty: {\n            value: 'payload',\n            required: true,\n        },\n        outputTarget: {\n            value: 'msg',\n            required: true,\n        },\n        deviceIp: {\n            value: '192.168.33.1',\n            required: true,\n        },\n        deviceSerialNumber: {\n            value: '',\n            required: true,\n        },\n        deviceTimeout: {\n            value: 30,\n            required: true,\n            validate: RED.validators.number(),\n        },\n        updateMode: {\n            value: 'never',\n            required: true,\n        },\n        updateFrequency: {\n            value: 5,\n            required: true,\n            validate: RED.validators.number(),\n        },\n        name: { value: '' },\n    },\n    inputs: 1,\n    outputs: 1,\n    icon: 'font-awesome/fa-share-square-o',\n    label: function () {\n        return this.name || 'Deye SUN G3';\n    },\n    labelStyle: function () {\n        return this.name ? 'node_label_italic' : '';\n    },\n    paletteLabel: 'Deye SUN G3',\n    inputLabels: 'Incoming message',\n    outputLabels: ['Outgoing message'],\n    oneditprepare: function () {\n        setTimeout(() => {\n            $('.binsoul-deye-sun-g3-wrapper').css('width', '100%');\n            $('.binsoul-deye-sun-g3-wrapper .red-ui-typedInput-container').css({\n                width: 'auto',\n                display: 'flex',\n            });\n        });\n\n        $('#node-input-outputProperty').typedInput({\n            typeField: '#node-input-outputTarget',\n            types: ['msg', 'flow', 'global'],\n            default: 'msg',\n        });\n    },\n});\n"]}
