{"filename": "tools/generateXmltvFile.ts", "chunked_list": ["#!/usr/bin/env -S ts-node --esm\n\nimport { writeXmltv } from \"../src/main.js\";\nimport { ArgumentParser } from \"argparse\";\nimport type { Xmltv } from \"../src/types.js\";\n\n/**\n * Generate a xmltv file with the given number of channels and programmes\n *\n * Usage:", " *\n * Usage:\n *   ./generateXml.ts -c 100 -p 250000 > tests/fixtures/c100-p250_000.xml\n *   ./generateXml.ts --channels 100 --programmes 250000 > tests/fixtures/c100-p250_000.xml\n */\nconst parser = new ArgumentParser({\n  description: \"Generate xmltv xml file\",\n});\n\nparser.add_argument(\"-c\", \"--channels\", {", "\nparser.add_argument(\"-c\", \"--channels\", {\n  help: \"Number of channels to generate\",\n  required: true,\n});\nparser.add_argument(\"-p\", \"--programmes\", {\n  help: \"Number of programmes to generate\",\n  required: true,\n});\nconst { channels: numberOfChannels, programmes: numberOfProgrammes } =", "});\nconst { channels: numberOfChannels, programmes: numberOfProgrammes } =\n  parser.parse_args();\n\nconst channelFactory = (count: number) => {\n  const channels: any = [];\n  for (let i = 0; i < count; i++) {\n    channels.push({\n      id: `${i + 1}`,\n      displayName: [{ _value: `Channel ${i + 1}` }],\n    });\n  }\n  return channels;\n};\n\nconst programmeFactory = (count: number) => {\n  const programmes: any = [];\n  let currentStartTime = new Date(Date.now() - 4 * 60 * 60 * 1000);\n", "  for (let i = 0; i < count; i++) {\n    const duration = Math.floor(Math.random() * 180) + 30;\n    const end = new Date(currentStartTime.getTime() + duration * 60 * 1000);\n\n    programmes.push({\n      title: `Programme ${i + 1}`,\n      desc: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed euismod, nisl nec ultricies lacinia, nisl nisl aliquam nisl\",\n      start: currentStartTime,\n      stop: end,\n      channel: `${Math.floor(Math.random() * numberOfChannels) + 1}`,\n    });\n\n    currentStartTime = end;\n  }\n\n  return programmes;\n};\n\nconst channels = channelFactory(numberOfChannels);\nconst programmes = programmeFactory(numberOfProgrammes);\n\nconst xmltv: Xmltv = {\n  channels,\n  programmes: programmes,\n};\n\nconst xml = writeXmltv(xmltv);\n\nprocess.stdout.write(xml + \"\\n\");\n"]}
{"filename": "tests/main.bench.ts", "chunked_list": ["import fs from \"node:fs\";\nimport { describe, bench } from \"vitest\";\nimport { parser, writeXmltv, parseXmltv } from \"../src/main.js\";\nimport { XMLBuilder, XMLParser } from \"fast-xml-parser\";\nimport epgParser from \"epg-parser\";\nimport {\n  xmltvTagTranslations,\n  xmltvAttributeTranslations,\n} from \"../src/xmltvTranslations.js\";\nimport type { XmltvTags, XmltvAttributes } from \"../src/xmltvTagsAttributes.js\";", "} from \"../src/xmltvTranslations.js\";\nimport type { XmltvTags, XmltvAttributes } from \"../src/xmltvTagsAttributes.js\";\nimport xmltv from \"xmltv\";\nimport path from \"node:path\";\n\nconst files = [\"example.xml\"];\nconst file = files[0];\nconst xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {\n  encoding: \"utf-8\",\n});", "  encoding: \"utf-8\",\n});\n\nconst preParsed = parser(xmltvString);\n\n// these options bring it to feature parity with @iptv/xmltv\nconst fxpParser = new XMLParser({\n  ignoreAttributes: false,\n  alwaysCreateTextNode: true,\n  parseTagValue: true,", "  alwaysCreateTextNode: true,\n  parseTagValue: true,\n  preserveOrder: true,\n  trimValues: true,\n  transformTagName: (tag) => xmltvTagTranslations.get(tag as XmltvTags) || tag,\n  transformAttributeName: (tag) =>\n    xmltvAttributeTranslations.get(tag as XmltvAttributes) || tag,\n});\n\n// unable to transform tags and attributes with XMLBuilder", "\n// unable to transform tags and attributes with XMLBuilder\nconst fxpBuilder = new XMLBuilder({\n  ignoreAttributes: false,\n  preserveOrder: true,\n});\nconst fxpParsed = fxpParser.parse(xmltvString);\n\ndescribe(\"Writing XML Files\", () => {\n  bench(\"@iptv/xmltv\", () => {", "describe(\"Writing XML Files\", () => {\n  bench(\"@iptv/xmltv\", () => {\n    writeXmltv(preParsed, { fromDom: true });\n  });\n\n  bench(\"fast-xml-parser\", () => {\n    fxpBuilder.build(fxpParsed);\n  });\n});\n", "});\n\ndescribe(\"Parsing XML Files\", () => {\n  bench(\"@iptv/xmltv parseXmltv\", () => {\n    parseXmltv(xmltvString);\n  });\n\n  bench(\"@iptv/xmltv parser\", () => {\n    parser(xmltvString);\n  });", "    parser(xmltvString);\n  });\n\n  bench(\"fast-xml-parser\", () => {\n    fxpParser.parse(xmltvString);\n  });\n\n  bench(\"epg-parser\", () => {\n    epgParser.parse(xmltvString);\n  });", "    epgParser.parse(xmltvString);\n  });\n\n  bench(\"xmltv\", async () => {\n    await new Promise<void>((resolve) => {\n      const xmltvparser = new xmltv.Parser() as any;\n      const readable = fs.createReadStream(\n        path.resolve(path.resolve(`./tests/fixtures/${file}`))\n      );\n", "      );\n\n      readable.pipe(xmltvparser);\n\n      const obj: { programmes: any[] } = {\n        programmes: [],\n      };\n\n      xmltvparser.on(\"programme\", function (programme: any) {\n        obj.programmes.push(programme);", "      xmltvparser.on(\"programme\", function (programme: any) {\n        obj.programmes.push(programme);\n      });\n\n      xmltvparser.on(\"end\", () => {\n        resolve();\n      });\n    });\n  });\n});", "  });\n});\n"]}
{"filename": "tests/main.test.ts", "chunked_list": ["import { describe, expect, test } from \"vitest\";\nimport { objectToDom, parseXmltv, writeXmltv } from \"../src/main\";\nimport fs from \"node:fs\";\n\nconst fileAsString = fs.readFileSync(`./tests/fixtures/example.xml`, {\n  encoding: \"utf-8\",\n});\n\nconst fileWithOnlyChannelData = fs.readFileSync(\n  `./tests/fixtures/channel-only.xml`,", "const fileWithOnlyChannelData = fs.readFileSync(\n  `./tests/fixtures/channel-only.xml`,\n  {\n    encoding: \"utf-8\",\n  }\n);\n\ndescribe(\"Parses a XMLTV file\", () => {\n  test(\"Fully parses to a JS object\", async () => {\n    const parsed = parseXmltv(fileAsString);", "  test(\"Fully parses to a JS object\", async () => {\n    const parsed = parseXmltv(fileAsString);\n    expect(parsed).toMatchSnapshot();\n  });\n\n  test(\"it can convert back to xml\", () => {\n    const parsed = parseXmltv(fileAsString);\n    const xml = writeXmltv(parsed);\n    expect(xml).toMatchSnapshot();\n  });", "    expect(xml).toMatchSnapshot();\n  });\n\n  test(\"it can convert an object into the dom structure\", () => {\n    const obj = parseXmltv(fileAsString);\n    const dom = objectToDom(obj);\n\n    expect(dom).toMatchSnapshot();\n  });\n", "  });\n\n  test(\"convertToDom produces the same DOM as an xml file parse\", () => {\n    const [, , exampleOutput] = parseXmltv(fileAsString, { asDom: true });\n    const xml = parseXmltv(fileAsString);\n    const [dom] = objectToDom(xml);\n\n    expect(exampleOutput).toEqual(dom);\n  });\n", "  });\n\n  test(\"Handles empty input string gracefully\", () => {\n    const parsed = parseXmltv(\"\");\n    expect(parsed).toEqual({});\n  });\n\n  test(\"Throws error on malformed XML input string\", () => {\n    const malformedXml = \"<tv><channel></tv>\";\n    expect(() => parseXmltv(malformedXml)).toThrowError(`Unexpected close tag", "    const malformedXml = \"<tv><channel></tv>\";\n    expect(() => parseXmltv(malformedXml)).toThrowError(`Unexpected close tag\nLine: 0\nColumn: 18\nChar: >`);\n  });\n\n  test(\"Parses a XMLTV file with only channel data\", () => {\n    const parsed = parseXmltv(fileWithOnlyChannelData);\n", "    const parsed = parseXmltv(fileWithOnlyChannelData);\n\n    expect(parsed).toEqual({\n      channels: [{ displayName: [{ _value: \"Channel 1\" }], id: \"1\" }],\n    });\n  });\n});\n"]}
{"filename": "tests/utils.test.ts", "chunked_list": ["import { describe, expect, test } from 'vitest';\nimport { dateToXmltvUtcTimestamp, xmltvTimestampToUtcDate } from '../src/utils';\n\ndescribe('dateToXmltvUtcTimestamp', () => {\n  test('should return a valid xmltv UTC timestamp', () => {\n    const date = new Date('2022-01-01T00:00:00Z');\n    const expected = '20220101000000 +0000';\n    const result = dateToXmltvUtcTimestamp(date);\n    expect(result).toEqual(expected);\n  });", "    expect(result).toEqual(expected);\n  });\n});\n\ndescribe('xmltvTimestampToUtcDate', () => {\n  test('should return a valid UTC date', () => {\n    const timestamp = '20220101000000 +0000';\n    const expected = new Date('2022-01-01T00:00:00Z');\n    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);", "    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);\n  });\n\n  test('should handle positive timezones', () => {\n    const timestamp = '20220101000000 +0100';\n    const expected = new Date('2021-12-31T23:00:00Z');\n    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);\n  });", "    expect(result).toEqual(expected);\n  });\n\n  test('should handle negative timezones ', () => {\n    const timestamp = '20220101000000 -0400';\n    const expected = new Date('2022-01-01T04:00:00Z');\n    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);\n  });\n", "  });\n\n  test('should handle misformatted timestamps ', () => {\n    const timestamp = '2022 01 01 000000    -0400';\n    const expected = new Date('2022-01-01T04:00:00Z');\n    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);\n  });\n\n  test('should handle iso formatted timestamps without spaces ', () => {", "\n  test('should handle iso formatted timestamps without spaces ', () => {\n    const timestamp = '2022-01-01T00:00:00.000-0400';\n    const expected = new Date('2022-01-01T04:00:00Z');\n    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);\n  });\n\n  test('should handle iso formatted timestamps with Z timezone', () => {\n    const timestamp = '2022-01-01T00:00:00.000Z';", "  test('should handle iso formatted timestamps with Z timezone', () => {\n    const timestamp = '2022-01-01T00:00:00.000Z';\n    const expected = new Date('2022-01-01T00:00:00Z');\n    const result = xmltvTimestampToUtcDate(timestamp);\n    expect(result).toEqual(expected);\n  });\n});\n"]}
{"filename": "tests/fixtures/files.ts", "chunked_list": ["const files = [\"c0-p0.xml\",\"c0-p1.xml\",\"c1-p0.xml\",\"c1-p1.xml\",\"c100-p100.xml\",\"c100-p1000.xml\",\"c100-p10000.xml\",\"c100-p100000.xml\",\"c100-p250000.xml\",\"c100-p500000.xml\",\"c100-p1000000.xml\",]; export { files }\n"]}
{"filename": "benchmark/nanobench.ts", "chunked_list": ["import bench from \"nanobench\";\nimport fs from \"node:fs\";\nimport { parseXmltv } from \"../src/main.js\";\nimport epgParser from \"epg-parser\";\nimport { files } from \"../tests/fixtures/files.js\";\n// import xmltv from \"xmltv\";\n\n// const xmltvParser = new xmltv.Parser() as any;\n\nfiles.forEach((file) => {", "\nfiles.forEach((file) => {\n  bench(`@iptv/xmltv parsing: ${file}`, function (b: any) {\n    let xmltvString: string | null = fs.readFileSync(\n      `./tests/fixtures/${file}`,\n      {\n        encoding: \"utf-8\",\n      }\n    );\n    b.start();", "    );\n    b.start();\n\n    parseXmltv(xmltvString);\n\n    b.end();\n    xmltvString = null;\n  });\n\n  bench(`epg-parser parsing: ${file}`, function (b: any) {", "\n  bench(`epg-parser parsing: ${file}`, function (b: any) {\n    let xmltvString: string | null = fs.readFileSync(\n      `./tests/fixtures/${file}`,\n      {\n        encoding: \"utf-8\",\n      }\n    );\n    b.start();\n", "    b.start();\n\n    epgParser.parse(xmltvString);\n\n    b.end();\n    xmltvString = null;\n  });\n\n  // bench(`xmltv parsing: ${file}`, function (b: any) {\n  //   const readable = fs.createReadStream(", "  // bench(`xmltv parsing: ${file}`, function (b: any) {\n  //   const readable = fs.createReadStream(\n  //     path.resolve(path.resolve(`./tests/fixtures/${file}`))\n  //   );\n\n  //   b.start();\n  //   console.log(\"started parsing\");\n  //   readable.pipe(xmltvParser);\n\n  //   const obj: { programmes: any[] } = {", "\n  //   const obj: { programmes: any[] } = {\n  //     programmes: [],\n  //   };\n  //   xmltvParser.on(\"programme\", function (programme: any) {\n  //     console.log(\"programme\");\n  //     obj.programmes.push(programme);\n  //   });\n\n  //   console.log(\"setting end\");", "\n  //   console.log(\"setting end\");\n  //   xmltvParser.on(\"end\", () => {\n  //     console.log(\"ended parsing\");\n  //     b.end();\n  //   });\n  // });\n});\n", ""]}
{"filename": "benchmark/self-bench.ts", "chunked_list": ["#!/usr/bin/env -S ts-node --esm\n\nimport fs from \"node:fs\";\nimport { suite, add, cycle, complete } from \"benny\";\nimport { parseXmltv } from \"../src/main.js\";\nimport { files } from \"../tests/fixtures/files.js\";\n\nfiles.unshift(\"example.xml\");\n\nconst file = files[0];", "\nconst file = files[0];\nconst xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {\n  encoding: \"utf-8\",\n});\n\nsuite(\n  \"XMLTV Parsing\",\n  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });", "  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });\n  }),\n  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });\n  }),\n  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });\n  }),\n  add(\"@iptv/xmltv DOM parse\", () => {", "  }),\n  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });\n  }),\n  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });\n  }),\n  cycle(),\n  complete()\n);", "  complete()\n);\n"]}
{"filename": "benchmark/benchmark.ts", "chunked_list": ["#!/usr/bin/env -S ts-node --esm\n\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { suite, add, cycle, complete, save } from \"benny\";\nimport { parseXmltv, writeXmltv } from \"../src/main.js\";\nimport xmltv from \"xmltv\";\nimport epgParser from \"epg-parser\";\nimport { XMLBuilder, XMLParser } from \"fast-xml-parser\";\nimport {", "import { XMLBuilder, XMLParser } from \"fast-xml-parser\";\nimport {\n  xmltvTagTranslations,\n  xmltvAttributeTranslations,\n} from \"../src/xmltvTranslations.js\";\nimport type { XmltvTags, XmltvAttributes } from \"../src/xmltvTagsAttributes.js\";\nimport { files } from \"../tests/fixtures/files.js\";\n// These options bring fast-xml-parser to feature parity with @iptv/xmltv\nconst fxpParser = new XMLParser({\n  ignoreAttributes: false,", "const fxpParser = new XMLParser({\n  ignoreAttributes: false,\n  alwaysCreateTextNode: true,\n  parseTagValue: true,\n  preserveOrder: true,\n  trimValues: true,\n  transformTagName: (tag) => {\n    return xmltvTagTranslations.get(tag as XmltvTags) || tag;\n  },\n  transformAttributeName: (tag) => {", "  },\n  transformAttributeName: (tag) => {\n    return xmltvAttributeTranslations.get(tag as XmltvAttributes) || tag;\n  },\n});\n\nfiles.unshift(\"example.xml\");\n\nconst file = files[0];\nconst xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {", "const file = files[0];\nconst xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {\n  encoding: \"utf-8\",\n});\n\nconst parsed = parseXmltv(xmltvString, { asDom: true });\n\nconst fxpParsed = fxpParser.parse(xmltvString);\n\nsuite(", "\nsuite(\n  \"XMLTV Parsing\",\n  add(\"@iptv/xmltv full parse\", () => {\n    parseXmltv(xmltvString);\n  }),\n  add(\"@iptv/xmltv DOM parse\", () => {\n    parseXmltv(xmltvString, { asDom: true });\n  }),\n  // add(\"txml\", () => {", "  }),\n  // add(\"txml\", () => {\n  //   txml.parse(xmltvString);\n  // }),\n  add(\"epg-parser\", () => {\n    epgParser.parse(xmltvString);\n  }),\n  add(\"fast-xml-parser\", () => {\n    fxpParser.parse(xmltvString);\n  }),", "    fxpParser.parse(xmltvString);\n  }),\n  add(\"xmltv\", async () => {\n    await new Promise<void>((resolve) => {\n      const xmltvparser = new xmltv.Parser() as any;\n      const readable = fs.createReadStream(\n        path.resolve(path.resolve(`./tests/fixtures/${file}`))\n      );\n\n      readable.pipe(xmltvparser);", "\n      readable.pipe(xmltvparser);\n\n      const obj: { programmes: any[] } = {\n        programmes: [],\n      };\n\n      xmltvparser.on(\"programme\", function (programme: any) {\n        obj.programmes.push(programme);\n      });", "        obj.programmes.push(programme);\n      });\n\n      xmltvparser.on(\"end\", () => {\n        resolve();\n      });\n    });\n  }),\n  cycle(),\n  complete(),", "  cycle(),\n  complete(),\n  save({ file: \"xmltv-parse-benchmark\", version: \"1.0.0\" }),\n  save({ file: \"xmltv-parse-benchmark\", format: \"chart.html\" })\n);\n\nsuite(\n  \"Creating XML\",\n  add(\"@iptv/xmltv creating xml\", () => {\n    writeXmltv(parsed, { fromDom: true });", "  add(\"@iptv/xmltv creating xml\", () => {\n    writeXmltv(parsed, { fromDom: true });\n  }),\n  add(\"fast-xml-parser XMLBuilder\", () => {\n    const builder = new XMLBuilder({\n      ignoreAttributes: false,\n      preserveOrder: true,\n    });\n    builder.build(fxpParsed);\n  }),", "    builder.build(fxpParsed);\n  }),\n  cycle(),\n  complete(),\n  save({ file: \"xmltv-creation-benchmark\", version: \"1.0.0\" }),\n  save({ file: \"xmltv-creation-benchmark\", format: \"chart.html\" })\n);\n"]}
{"filename": "benchmark/index.d.ts", "chunked_list": ["declare module \"epg-parser\";\ndeclare module \"xmltv\";\ndeclare module \"nanobench\";\n"]}
{"filename": "src/toObject.ts", "chunked_list": ["import type { Xmltv, XmltvDomNode } from \"./types\";\nimport { xmltvTimestampToUtcDate } from \"./utils.js\";\nimport {\n  xmltvAttributeTranslations,\n  xmltvTagTranslations,\n} from \"./xmltvTranslations.js\";\nimport type { XmltvTags, XmltvAttributes } from \"./xmltvTagsAttributes.js\";\n\nconst questionMarkCC = \"?\".charCodeAt(0);\n", "const questionMarkCC = \"?\".charCodeAt(0);\n\n/**\n * Elements that can only be used once wherever they appear.\n * eg <credits> can only be used once in a <programme> element\n * but <actor> can be used multiple times in a <credits> element\n */\nconst singleUseElements: XmltvTags[] = [\n  \"credits\",\n  \"date\",", "  \"credits\",\n  \"date\",\n  \"language\",\n  \"orig-language\",\n  \"length\",\n  \"country\",\n  \"previously-shown\",\n  \"premiere\",\n  \"last-chance\",\n  \"new\",", "  \"last-chance\",\n  \"new\",\n  \"video\",\n  \"audio\",\n  // Sub-elements of 'video'\n  \"present\",\n  \"colour\",\n  \"aspect\",\n  \"quality\",\n  // Sub-elements of 'audio'", "  \"quality\",\n  // Sub-elements of 'audio'\n  \"present\",\n  \"stereo\",\n\n  //sub-elements of rating and star rating\n  \"value\",\n];\n\n/**", "\n/**\n * Elements that do not have children or attributes so can be rendered as a scalar\n *\n * eg <date>2020-01-01</date> should render as\n * { date: \"2020-01-01\" }\n *    instead of\n * { date: { _value: \"2020-01-01\" } }\n */\nconst elementsAsScalar: XmltvTags[] = [", " */\nconst elementsAsScalar: XmltvTags[] = [\n  \"date\",\n  \"value\",\n  \"aspect\",\n  \"present\",\n  \"colour\",\n  \"quality\",\n  \"stereo\",\n];", "  \"stereo\",\n];\n\n/**\n * Convert an XmltvDom tree to a plain object\n *\n * @param children The XmltvDom tree to convert\n */\ntype Out = Record<string, any>;\nexport function toObject(\n  children: any[],\n  parent: XmltvDomNode = { tagName: \"tv\", attributes: {}, children: [] }\n): Out | boolean | string | Xmltv {\n  let out: Out = {};", "type Out = Record<string, any>;\nexport function toObject(\n  children: any[],\n  parent: XmltvDomNode = { tagName: \"tv\", attributes: {}, children: [] }\n): Out | boolean | string | Xmltv {\n  let out: Out = {};\n  if (!children.length) {\n    return out;\n  }\n\n  if (\n    children.length === 1 &&\n    typeof children[0] === \"string\" &&\n    (children[0] === \"yes\" || children[0] === \"no\")\n  ) {\n    return children[0] === \"yes\";\n  }\n", "  if (\n    children.length === 1 &&\n    typeof children[0] === \"string\" &&\n    (children[0] === \"yes\" || children[0] === \"no\")\n  ) {\n    return children[0] === \"yes\";\n  }\n\n  if (\n    children.length === 1 &&\n    typeof children[0] === \"string\" &&\n    typeof parent !== \"string\"\n  ) {", "  if (\n    children.length === 1 &&\n    typeof children[0] === \"string\" &&\n    typeof parent !== \"string\"\n  ) {\n    if (Object.keys(parent.attributes).length) {\n      return {\n        _value: children[0],\n      };\n    }\n    return children[0];\n  }\n\n  // map each object\n", "  for (let i = 0, n = children.length; i < n; i++) {\n    let child = children[i];\n\n    if (\n      typeof parent !== \"string\" &&\n      parent.tagName === \"actor\" &&\n      typeof child === \"string\"\n    ) {\n      out._value = child;\n    }\n", "    if (typeof child !== \"object\") {\n      continue;\n    }\n\n    if (child.tagName.charCodeAt(0) === questionMarkCC) continue;\n\n    if (child.tagName === \"new\") {\n      out[child.tagName] = true;\n      continue;\n    }\n", "    if (child.tagName === \"tv\") {\n      out = {};\n    }\n\n    const translatedName =\n      xmltvTagTranslations.get(child.tagName) || child.tagName;\n\n    if (\n      !out[translatedName] &&\n      singleUseElements.indexOf(child.tagName) === -1\n    ) {\n      out[translatedName] = [];\n    }\n\n    let kids: any = toObject(child.children || [], child);\n", "    if (Object.keys(child.attributes).length) {\n      if (!Array.isArray(kids)) {\n        if (child.attributes.size) {\n          child.attributes.size = Number(child.attributes.size);\n        }\n\n        if (translatedName === \"programmes\") {\n          if (child.attributes.stop) {\n            child.attributes.stop = xmltvTimestampToUtcDate(\n              child.attributes.stop\n            );\n          }\n", "          if (child.attributes[\"pdc-start\"]) {\n            child.attributes[\"pdc-start\"] = xmltvTimestampToUtcDate(\n              child.attributes[\"pdc-start\"]\n            );\n          }\n\n          if (child.attributes[\"vps-start\"]) {\n            child.attributes[\"vps-start\"] = xmltvTimestampToUtcDate(\n              child.attributes[\"vps-start\"]\n            );\n          }", "        } else if (translatedName === \"icon\") {\n          if (child.attributes.width) {\n            child.attributes.width = Number(child.attributes.width);\n          }\n\n          if (child.attributes.height) {\n            child.attributes.height = Number(child.attributes.height);\n          }\n        } else if (child.attributes.units) {\n          kids._value = Number(kids._value);\n        } else if (child.attributes.guest) {\n          child.attributes.guest = child.attributes.guest === \"yes\";\n        }\n", "        } else if (child.attributes.units) {\n          kids._value = Number(kids._value);\n        } else if (child.attributes.guest) {\n          child.attributes.guest = child.attributes.guest === \"yes\";\n        }\n\n        if (child.attributes.date) {\n          child.attributes.date = xmltvTimestampToUtcDate(\n            child.attributes.date\n          );\n        }\n", "        if (child.attributes.start) {\n          child.attributes.start = xmltvTimestampToUtcDate(\n            child.attributes.start\n          );\n        }\n\n        const translatedAttributes = Object.keys(child.attributes).reduce(\n          (acc: Record<string, string>, key: string) => {\n            acc[xmltvAttributeTranslations.get(key as XmltvAttributes) || key] =\n              child.attributes[key];\n            return acc;\n          },\n          {}\n        );\n\n        Object.assign(kids, translatedAttributes);\n      }\n    }\n", "    if (translatedName === \"subtitles\") {\n      if (typeof kids.language === \"string\") {\n        kids.language = { _value: kids.language };\n      }\n      out[translatedName].push(kids);\n      continue;\n    }\n\n    if (translatedName === \"tv\") {\n      out = kids;\n      continue;\n    }\n", "    if (translatedName === \"tv\") {\n      out = kids;\n      continue;\n    }\n\n    if (translatedName === \"date\") {\n      out[translatedName] = xmltvTimestampToUtcDate(kids);\n      continue;\n    }\n\n    if (\n      typeof kids === \"string\" &&\n      elementsAsScalar.indexOf(child.tagName) === -1\n    ) {\n      kids = {\n        _value: kids,\n      };\n    }\n", "    if (\n      typeof kids === \"string\" &&\n      elementsAsScalar.indexOf(child.tagName) === -1\n    ) {\n      kids = {\n        _value: kids,\n      };\n    }\n\n    if (Array.isArray(out[translatedName])) {\n      out[translatedName].push(kids);\n      continue;\n    }\n\n    out[translatedName] = kids;\n  }\n\n  return out as Xmltv;\n}\n", "    if (Array.isArray(out[translatedName])) {\n      out[translatedName].push(kids);\n      continue;\n    }\n\n    out[translatedName] = kids;\n  }\n\n  return out as Xmltv;\n}\n"]}
{"filename": "src/parser.ts", "chunked_list": ["import { XmltvDom } from \"./types\";\n\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Tobias Nickel\n *\n * Copyright (c) 2023 Liam Potter\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software", " *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *", " * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**", "\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xml parser that can be used in a worker.\n *\n * @author: Liam Potter\n * @created: 03.04.2023\n * Based on the original work of Tobias Nickel (txml)\n * I removed the more generic parts of the parser to focus on working with the XMLTV format", " * Based on the original work of Tobias Nickel (txml)\n * I removed the more generic parts of the parser to focus on working with the XMLTV format\n * Outputs a more fluent object structure matching the Xmltv types\n */\n\nexport function parser(xmltvString: string): XmltvDom {\n  let pos = 0;\n\n  const openBracket = \"<\";\n  const closeBracket = \">\";\n  const openBracketCC = openBracket.charCodeAt(0);\n  const closeBracketCC = closeBracket.charCodeAt(0);\n  const minusCC = \"-\".charCodeAt(0);\n  const slashCC = \"/\".charCodeAt(0);\n  const exclamationCC = \"!\".charCodeAt(0);\n  const singleQuoteCC = \"'\".charCodeAt(0);\n  const doubleQuoteCC = '\"'.charCodeAt(0);\n  const openCornerBracketCC = \"[\".charCodeAt(0);\n  const closeCornerBracketCC = \"]\".charCodeAt(0);\n  const questionMarkCC = \"?\".charCodeAt(0);\n  const nameSpacer = \"\\r\\n\\t>/= \";\n  const noChildNodes = [\"new\", \"icon\", \"previously-shown\"];\n\n  /**\n   * parsing a list of entries\n   */", "  function parseChildren(tagName: string): XmltvDom {\n    const children: XmltvDom = [];\n    while (xmltvString[pos]) {\n      if (xmltvString.charCodeAt(pos) == openBracketCC) {\n        if (xmltvString.charCodeAt(pos + 1) === slashCC) {\n          const closeStart = pos + 2;\n          pos = xmltvString.indexOf(closeBracket, pos);\n\n          const closeTag = xmltvString.substring(closeStart, pos);\n          if (closeTag.indexOf(tagName) == -1) {\n            const parsedText = xmltvString.substring(0, pos).split(\"\\n\");\n            throw new Error(\n              \"Unexpected close tag\\nLine: \" +\n                (parsedText.length - 1) +\n                \"\\nColumn: \" +\n                (parsedText[parsedText.length - 1].length + 1) +\n                \"\\nChar: \" +\n                xmltvString[pos]\n            );\n          }\n", "          if (closeTag.indexOf(tagName) == -1) {\n            const parsedText = xmltvString.substring(0, pos).split(\"\\n\");\n            throw new Error(\n              \"Unexpected close tag\\nLine: \" +\n                (parsedText.length - 1) +\n                \"\\nColumn: \" +\n                (parsedText[parsedText.length - 1].length + 1) +\n                \"\\nChar: \" +\n                xmltvString[pos]\n            );\n          }\n", "          if (pos + 1) pos += 1;\n\n          return children;\n        } else if (xmltvString.charCodeAt(pos + 1) === exclamationCC) {\n          if (xmltvString.charCodeAt(pos + 2) == minusCC) {\n            //comment support\n            while (\n              pos !== -1 &&\n              !(\n                xmltvString.charCodeAt(pos) === closeBracketCC &&\n                xmltvString.charCodeAt(pos - 1) == minusCC &&\n                xmltvString.charCodeAt(pos - 2) == minusCC &&\n                pos != -1\n              )\n            ) {\n              pos = xmltvString.indexOf(closeBracket, pos + 1);\n            }", "            if (pos === -1) {\n              pos = xmltvString.length;\n            }\n          } else {\n            // doctype support\n            const startDoctype = pos + 1;\n            pos += 2;\n            let encapsulated = false;\n            while (\n              (xmltvString.charCodeAt(pos) !== closeBracketCC ||\n                encapsulated === true) &&\n              xmltvString[pos]\n            ) {", "            while (\n              (xmltvString.charCodeAt(pos) !== closeBracketCC ||\n                encapsulated === true) &&\n              xmltvString[pos]\n            ) {\n              if (xmltvString.charCodeAt(pos) === openCornerBracketCC) {\n                encapsulated = true;\n              } else if (\n                encapsulated === true &&\n                xmltvString.charCodeAt(pos) === closeCornerBracketCC\n              ) {\n                encapsulated = false;\n              }\n              pos++;\n            }\n            children.push(xmltvString.substring(startDoctype, pos));\n          }\n          pos++;\n          continue;\n        }\n        const node = parseNode();\n        children.push(node);", "        if (node.tagName.charCodeAt(0) === questionMarkCC) {\n          for (let i = 0, x = node.children.length; i < x; i++) {\n            children.push(node.children[i]);\n          }\n          node.children = [];\n        }\n      } else {\n        const text = parseText().trim();\n\n        if (text.length > 0) {\n          children.push(text);\n        }\n        pos++;\n      }\n    }\n    return children;\n  }\n\n  /**\n   *    returns the text outside of texts until the first '<'\n   */", "        if (text.length > 0) {\n          children.push(text);\n        }\n        pos++;\n      }\n    }\n    return children;\n  }\n\n  /**\n   *    returns the text outside of texts until the first '<'\n   */", "  function parseText() {\n    const start = pos;\n    pos = xmltvString.indexOf(openBracket, pos) - 1;\n    if (pos === -2) pos = xmltvString.length;\n    return xmltvString.slice(start, pos + 1);\n  }\n  /**\n   *    returns text until the first nonAlphabetic letter\n   */\n\n  function parseName() {\n    const start = pos;", "  function parseName() {\n    const start = pos;\n    while (nameSpacer.indexOf(xmltvString[pos]) === -1 && xmltvString[pos]) {\n      pos++;\n    }\n    return xmltvString.slice(start, pos);\n  }\n\n  function parseNode() {\n    pos++;\n    const tagName = parseName();\n    const attributes: Record<string, any> = {};\n    let children: XmltvDom = [];\n\n    // parsing attributes", "  function parseNode() {\n    pos++;\n    const tagName = parseName();\n    const attributes: Record<string, any> = {};\n    let children: XmltvDom = [];\n\n    // parsing attributes\n    while (xmltvString.charCodeAt(pos) !== closeBracketCC && xmltvString[pos]) {\n      const c = xmltvString.charCodeAt(pos);\n      if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n        const name = parseName();\n        // search beginning of the string\n        let code = xmltvString.charCodeAt(pos);\n        let value;", "      if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n        const name = parseName();\n        // search beginning of the string\n        let code = xmltvString.charCodeAt(pos);\n        let value;\n        while (\n          code &&\n          code !== singleQuoteCC &&\n          code !== doubleQuoteCC &&\n          !((code > 64 && code < 91) || (code > 96 && code < 123)) &&\n          code !== closeBracketCC\n        ) {\n          pos++;\n          code = xmltvString.charCodeAt(pos);\n        }", "        if (code === singleQuoteCC || code === doubleQuoteCC) {\n          value = parseString();\n          if (pos === -1) {\n            return {\n              tagName,\n              attributes,\n              children,\n            };\n          }\n        } else {\n          value = null;\n          pos--;\n        }\n        attributes[name] = value;\n      }\n      pos++;\n    }\n    // optional parsing of children", "    if (xmltvString.charCodeAt(pos - 1) !== slashCC) {\n      if (noChildNodes.indexOf(tagName) === -1) {\n        pos++;\n        children = parseChildren(tagName);\n      } else {\n        pos++;\n      }\n    } else {\n      pos++;\n    }\n    return {\n      tagName,\n      attributes,\n      children,\n    };\n  }\n", "  function parseString(): string {\n    const startChar = xmltvString[pos];\n    const start = pos + 1;\n    pos = xmltvString.indexOf(startChar, start);\n    return xmltvString.slice(start, pos);\n  }\n\n  return parseChildren(\"\");\n}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { parser } from \"./parser.js\";\nimport { writer } from \"./writer.js\";\nimport { objectToDom } from \"./objectToDom.js\";\nimport { toObject } from \"./toObject.js\";\nimport type {\n  Xmltv,\n  XmltvAudio,\n  XmltvChannel,\n  XmltvCreditImage,\n  XmltvCredits,", "  XmltvCreditImage,\n  XmltvCredits,\n  XmltvDom,\n  XmltvDisplayName,\n  XmltvEpisodeNumber,\n  XmltvIcon,\n  XmltvImage,\n  XmltvLength,\n  XmltvPerson,\n  XmltvPreviouslyShown,", "  XmltvPerson,\n  XmltvPreviouslyShown,\n  XmltvProgramme,\n  XmltvRating,\n  XmltvReview,\n  XmltvStarRating,\n  XmltvSubtitle,\n  XmltvUrl,\n  XmltvVideo,\n} from \"./types\";", "  XmltvVideo,\n} from \"./types\";\nimport {\n  addAttributeTranslation,\n  addTagTranslation,\n} from \"./xmltvTranslations.js\";\n\ntype ParseXmltvOptions = {\n  asDom: boolean;\n};\n", "type WriteXmltvOptions = {\n  fromDom: boolean;\n};\n\n/**\n * parseXmltv\n *\n * Parses an xmltv file and returns an `Xmltv` object or a DOM tree\n *\n * @param xmltvString The xmltv file content as a string\n * @param options Options to parse the xmltv file\n * @param options.asDom If true, the xmltv file will be returned as a DOM tree\n */", "function parseXmltv(\n  xmltvString: string,\n  options: ParseXmltvOptions & { asDom: true }\n): XmltvDom;\nfunction parseXmltv(\n  xmltvString: string,\n  options: ParseXmltvOptions & { asDom: false }\n): XmltvDom;\nfunction parseXmltv(xmltvString: string): Xmltv;\n\nfunction parseXmltv(\n  xmltvString: string,\n  options: ParseXmltvOptions = { asDom: false }\n): Xmltv | XmltvDom {\n  const parsed = parser(xmltvString);", "function parseXmltv(xmltvString: string): Xmltv;\n\nfunction parseXmltv(\n  xmltvString: string,\n  options: ParseXmltvOptions = { asDom: false }\n): Xmltv | XmltvDom {\n  const parsed = parser(xmltvString);\n  if (options.asDom) {\n    return parsed;\n  }\n\n  return <Xmltv>toObject(parsed);\n}\n\n/**\n * writeXmltv\n *\n * Writes an `Xmltv` object or a DOM tree to an xmltv string\n *\n * @param xmltv The `Xmltv` object or a DOM tree\n * @param options Options to write the xmltv file\n * @param options.fromDom If true, the xmltv file will be written from a DOM tree\n * @returns The xmltv file content as a string\n * @throws If `options.fromDom` is true and `xmltv` is an `Xmltv` object\n */", "function writeXmltv(\n  xmltv: XmltvDom,\n  options: WriteXmltvOptions & { fromDom: true }\n): string;\nfunction writeXmltv(\n  xmltv: Xmltv,\n  options: WriteXmltvOptions & { fromDom: false }\n): string;\nfunction writeXmltv(xmltv: Xmltv): string;\n\nfunction writeXmltv(\n  xmltv: Xmltv | XmltvDom,\n  options: WriteXmltvOptions = { fromDom: false }\n): string {", "function writeXmltv(xmltv: Xmltv): string;\n\nfunction writeXmltv(\n  xmltv: Xmltv | XmltvDom,\n  options: WriteXmltvOptions = { fromDom: false }\n): string {\n  if (options.fromDom) {\n    if (typeof xmltv === \"object\" && !Array.isArray(xmltv)) {\n      throw new Error(\n        \"Cannot write XMLTV from a DOM object that has been converted to an object\"\n      );\n    }\n    return writer(xmltv);\n  }\n  const dom = objectToDom(xmltv);\n  return writer(dom);\n}\n\nexport {\n  parseXmltv,\n  writeXmltv,\n  writer,\n  parser,\n  objectToDom,\n  addTagTranslation,\n  addAttributeTranslation,\n};\n\nexport type {\n  Xmltv,\n  XmltvChannel,\n  XmltvDisplayName,\n  XmltvProgramme,\n  XmltvAudio,\n  XmltvCreditImage,\n  XmltvCredits,\n  XmltvEpisodeNumber,\n  XmltvIcon,\n  XmltvImage,\n  XmltvLength,\n  XmltvPerson,\n  XmltvPreviouslyShown,\n  XmltvRating,\n  XmltvReview,\n  XmltvStarRating,\n  XmltvSubtitle,\n  XmltvUrl,\n  XmltvVideo,\n};\n"]}
{"filename": "src/types.ts", "chunked_list": ["/**\n * A representation of XMLTV data in TypeScript.\n *\n * @see http://wiki.xmltv.org/index.php/XmltvFormat\n */\n\n/**\n * A URL to an image about the programme.\n *\n * The type of the image may be identified by the 'type' attribute. For programmes\n * this could be 'poster' or 'backdrop' (marketing promo photos)  or 'still' (screenshot from the\n * programme itself).\n *", " *\n * The type of the image may be identified by the 'type' attribute. For programmes\n * this could be 'poster' or 'backdrop' (marketing promo photos)  or 'still' (screenshot from the\n * programme itself).\n *\n * If multiple image elements of a particular type are given, the most authoritative or official\n * images should be listed first.\n *\n * The `system` attribute may be used to identify the source of the image, or some useful feature\n * of the target (e.g. 'imdb','tmdb',etc.).\n *\n * The `orient` attribute defines the orientation of the image \"P\" portrait or \"L\" landscape\n *\n * The `size` attribute may be used to indicate the relative size of the image.\n * Possible values are:\n * \"1\" is < 200px in its largest dimension\n * \"2\" is 200-400px in its largest dimension\n * \"3\" is > 400px in its largest dimension\n * Multiple images of different sizes is permitted (e.g. small poster and large poster).\n */", "export type XmltvImage = {\n  /**\n   * Type of image\n   */\n  type?: \"poster\" | \"backdrop\" | \"still\";\n\n  /**\n   * URL of the image\n   */\n  _value: string;\n\n  /**\n   * Size of the image\n   *\n   * Possible values are:\n   * \"1\" is < 200px in its largest dimension\n   * \"2\" is 200-400px in its largest dimension\n   * \"3\" is > 400px in its largest dimension\n   */\n  size?: 1 | 2 | 3;\n\n  /**\n   * Orientation of the image\n   *\n   * Possible values are:\n   * - \"L\" = landscape\n   * - \"P\" = portrait\n   */\n  orient?: \"L\" | \"P\" | \"l\" | \"p\";\n\n  /**\n   * A string to describe where the image came from, eg IMDB\n   */\n  system?: string;\n};\n\n/**\n * Similar to XmltvImage but with a types for the credit images.\n *\n * It could be 'person' (general portfolio picture of the person) or 'character'\n * (photo taken from the programme showing the actor in character).\n */", "export type XmltvCreditImage = XmltvImage & {\n  /**\n   * Type of image\n   */\n  type?: \"person\" | \"character\";\n};\n\n/**\n * A representation of a person in an XMLTV programme object.\n */\nexport type XmltvPerson = {\n  /**\n   * The name of the person.\n   */\n  _value: string;\n\n  /**\n   * The role of the actor in the programme eg Bryan Cranston's role in Breaking Bad is \"Walter White\".\n   */\n  role?: string;\n\n  /**\n   * Whether the person is a guest star or a regular cast member.\n   */\n  guest?: boolean;\n\n  /**\n   * An image of the person.\n   */\n  image?: XmltvCreditImage[];\n\n  /**\n   * The URL of the person.\n   */\n  url?: XmltvUrl[];\n};\n\n/**\n * A representation of the credits for an XMLTV programme object.\n *\n * People are listed in decreasing order of importance; so for example the starring actors appear\n * first followed by the smaller parts.  As with other parts of this file format, not mentioning\n * a particular actor (for example) does not imply that he _didn't_ star in the film - so normally\n * you'd list only the few most important people.\n *\n * Adapter can be either somebody who adapted a work for television, or somebody who did the translation\n * from another lang. The distinction is not always clear.\n *\n * URL can be, for example, a link to a webpage with more information about the actor, director, etc..\n */", "export type XmltvPerson = {\n  /**\n   * The name of the person.\n   */\n  _value: string;\n\n  /**\n   * The role of the actor in the programme eg Bryan Cranston's role in Breaking Bad is \"Walter White\".\n   */\n  role?: string;\n\n  /**\n   * Whether the person is a guest star or a regular cast member.\n   */\n  guest?: boolean;\n\n  /**\n   * An image of the person.\n   */\n  image?: XmltvCreditImage[];\n\n  /**\n   * The URL of the person.\n   */\n  url?: XmltvUrl[];\n};\n\n/**\n * A representation of the credits for an XMLTV programme object.\n *\n * People are listed in decreasing order of importance; so for example the starring actors appear\n * first followed by the smaller parts.  As with other parts of this file format, not mentioning\n * a particular actor (for example) does not imply that he _didn't_ star in the film - so normally\n * you'd list only the few most important people.\n *\n * Adapter can be either somebody who adapted a work for television, or somebody who did the translation\n * from another lang. The distinction is not always clear.\n *\n * URL can be, for example, a link to a webpage with more information about the actor, director, etc..\n */", "export type XmltvCredits = {\n  /**\n   * The director(s) of the programme.\n   */\n  director?: XmltvPerson[];\n\n  /**\n   * The actor(s) in the programme.\n   */\n  actor?: XmltvPerson[];\n\n  /**\n   * The writer(s) of the programme.\n   */\n  writer?: XmltvPerson[];\n\n  /**\n   * The adapter(s) of the programme.\n   */\n  adapter?: XmltvPerson[];\n\n  /**\n   * The producer(s) of the programme.\n   */\n  producer?: XmltvPerson[];\n\n  /**\n   * The composer(s) of the programme.\n   */\n  composer?: XmltvPerson[];\n\n  /**\n   * The editor(s) of the programme.\n   */\n  editor?: XmltvPerson[];\n\n  /**\n   * The presenter(s) of the programme.\n   */\n  presenter?: XmltvPerson[];\n\n  /**\n   * The commentator(s) of the programme.\n   */\n  commentator?: XmltvPerson[];\n\n  /**\n   * The guest(s) of the programme.\n   */\n  guest?: XmltvPerson[];\n};\n\n/**\n * A way to define multiple strings with different langs for the same value.\n */", "type XmltvStringWithLang = {\n  /**\n   * The value of the string\n   */\n  _value: string;\n\n  /**\n   * The lang code of the string eg. \"en\" for English, \"es\" for Spanish, etc.\n   */\n  lang?: string;\n};\n\n/**\n * The channel display name with an optional language attribute.\n */", "export type XmltvDisplayName = XmltvStringWithLang;\n\n/**\n * The title of a programme with an optional language attribute.\n */\nexport type XmltvTitle = XmltvStringWithLang;\n\n/**\n * The subtitle of a programme with an optional language attribute.\n */\nexport type XmltvSubTitle = XmltvStringWithLang;\n\n/**\n * The description of a programme with an optional language attribute.\n */", "export type XmltvSubTitle = XmltvStringWithLang;\n\n/**\n * The description of a programme with an optional language attribute.\n */\nexport type XmltvDesc = XmltvStringWithLang;\n\n/**\n * The category of a programme with an optional language attribute.\n */\nexport type XmltvCategory = XmltvStringWithLang;\n\n/**\n * The keyword related to a programme with an optional language attribute.\n */", "export type XmltvCategory = XmltvStringWithLang;\n\n/**\n * The keyword related to a programme with an optional language attribute.\n */\nexport type XmltvKeyword = XmltvStringWithLang;\n\n/**\n * The language of a programme with an optional language attribute.\n */\nexport type XmltvLanguage = XmltvStringWithLang;\n\n/**\n * The original language of a programme with an optional language attribute.\n */", "export type XmltvLanguage = XmltvStringWithLang;\n\n/**\n * The original language of a programme with an optional language attribute.\n */\nexport type XmltvOrigLanguage = XmltvStringWithLang;\n\n/**\n * The country where a programme was produced with an optional language attribute.\n */\nexport type XmltvCountry = XmltvStringWithLang;\n\n/**\n * The premiere information for a programme with an optional language attribute.\n */", "export type XmltvCountry = XmltvStringWithLang;\n\n/**\n * The premiere information for a programme with an optional language attribute.\n */\nexport type XmltvPremiere = XmltvStringWithLang;\n\n/**\n * The last chance information for a programme with an optional language attribute.\n */\nexport type XmltvLastChance = XmltvStringWithLang;\n\n/**\n * Object describing an icon\n *\n * The icon element is used to specify an image that represents the programme or channel,\n * typically a logo or thumbnail image. The src attribute of the icon element is required\n * and specifies the URL of the image file. The width and height attributes are optional\n * and specify the dimensions of the image in pixels. The icon element is optional and\n * can be used within the channel and programme elements to provide visual information\n * about the channel or programme being described.\n */", "export type XmltvLastChance = XmltvStringWithLang;\n\n/**\n * Object describing an icon\n *\n * The icon element is used to specify an image that represents the programme or channel,\n * typically a logo or thumbnail image. The src attribute of the icon element is required\n * and specifies the URL of the image file. The width and height attributes are optional\n * and specify the dimensions of the image in pixels. The icon element is optional and\n * can be used within the channel and programme elements to provide visual information\n * about the channel or programme being described.\n */", "export type XmltvIcon = {\n  /**\n   * URL of the icon\n   */\n  src: string;\n\n  /**\n   * Width of the icon\n   */\n  width?: number;\n\n  /**\n   * Height of the icon\n   */\n  height?: number;\n};\n\n/**\n * Object describing a URL, used in the programme and channel objects.\n */", "export type XmltvUrl = {\n  /**\n   * Value of the URL\n   */\n  _value: string;\n\n  /**\n   * System of the URL, eg \"imdb\", \"thetvdb\", etc.\n   */\n  system?: string;\n};\n\n/**\n * Episode number\n */", "export type XmltvEpisodeNumber = {\n  /**\n   * The episode number as a standard SxxExx string.\n   * This is the preferred way to specify the episode number.\n   */\n  system?: \"onscreen\" | \"xmltv_ns\";\n\n  /**\n   * The episode number as a XMLTV episode number string eg. \"2.3.2\".\n   */\n  _value?: string;\n};\n\n/**\n * Object describing details of the programme's video\n */", "export type XmltvVideo = {\n  /**\n   * Whether this programme has a picture (no, in the case of radio stations broadcast\n   * on TV or 'Blue'). If this attribute is missing, it is assumed to be `true`.\n   */\n  present?: boolean;\n\n  /**\n   * `true` for colour, `false` for black-and-white.\n   */\n  colour?: boolean;\n\n  /**\n   * The horizontal:vertical aspect ratio, eg `4:3` or `16:9`.\n   */\n  aspect?: string;\n\n  /**\n   * Information on the quality, eg `HDTV`, `800x600`.\n   */\n  quality?: string;\n};\n\n/**\n * The programme rating eg TV-MA, PG, etc.\n */", "export type XmltvRating = {\n  /**\n   * Value of the rating\n   */\n  value: string;\n\n  /**\n   * System of the rating eg. MPAA, VCHIP, etc.\n   */\n  system?: string;\n\n  /**\n   * Icon of the rating\n   */\n  icon?: XmltvIcon[];\n};\n\n/**\n * Audio details, similar to video details.\n *\n * `present`: Whether this programme has any sound at all.\n * `stereo`: Description of the stereo-ness of the sound.  Legal values\n * are currently `mono`,`stereo`,`dolby`,`dolby digital`,`bilingual` and `surround`.\n */", "export type XmltvAudio = {\n  /**\n   * Whether this programme has any sound at all.\n   */\n  present?: boolean;\n\n  /**\n   * Description of the stereo-ness of the sound.\n   *\n   * `bilingual` in this case refers to a single audio stream where the left and right\n   * channels contain monophonic audio  in different langs.  Other values may be added later.\n   */\n  stereo?:\n    | \"mono\"\n    | \"stereo\"\n    | \"dolby\"\n    | \"dolby digital\"\n    | \"bilingual\"\n    | \"surround\";\n};\n\n/**\n * The true length of the programme, not counting advertisements or trailers.\n * But this does take account of any bits which were cut out of the broadcast version\n * - eg if a two hour film is cut to 110 minutes and then padded with 20 minutes of advertising,\n * length will be 110 minutes even though end time minus start time is 130 minutes.\n */", "export type XmltvLength = {\n  /**\n   * The length of the programme\n   */\n  _value: number;\n\n  /**\n   * The units of the length\n   *\n   */\n  units: \"seconds\" | \"minutes\" | \"hours\";\n};\n\n/**\n * These can be either `teletext` (sent digitally, and displayed at the viewer's request),\n * `onscreen` (superimposed on the picture and impossible to get rid of),\n * or 'deaf-signed' (in-vision signing for users of sign lang).\n *\n * You can have multiple subtitle streams to handle different langs.\n * lang for subtitles is specified in the same way as for programmes.\n */", "export type XmltvSubtitle = {\n  type?: \"teletext\" | \"onscreen\" | \"deaf-signed\";\n  language?: XmltvStringWithLang;\n};\n\n/**\n * When and where the programme was last shown, if known.  Normally in TV listings 'repeat'\n * means 'previously shown on this channel', but if you don't know what channel the old\n * screening was on (but do know that it happened) then you can omit the 'channel' attribute.\n * Similarly you can omit the 'start' attribute if you don't know when the previous transmission\n * was (though you can of course give just the year, etc.).\n */", "export type XmltvPreviouslyShown = {\n  start?: Date;\n  channel?: string;\n};\n\n/**\n * A review of the programme.\n * Either the text of the review, or a URL that links to it.\n */\nexport type XmltvReview = {\n  /**\n   * The value of this element must be either the text of the review, or a URL that links to it.\n   */\n  _value: string;\n\n  /**", "export type XmltvReview = {\n  /**\n   * The value of this element must be either the text of the review, or a URL that links to it.\n   */\n  _value: string;\n\n  /**\n   * The type of review\n   */\n  type: \"text\" | \"url\";\n\n  /**\n   * The source of the review\n   */\n  source?: string;\n\n  /**\n   * The author of the review\n   */\n  reviewer?: string;\n\n  /**\n   * The lang of the review\n   */\n  lang?: string;\n};\n", "export type XmltvStarRating = {\n  /**\n   * The value of this element should be 'N / M', for example one star out of a possible five stars would be '1 / 5'.\n   */\n  value: string;\n\n  /**\n   * The system used to provide the star rating\n   */\n  system?: string;\n\n  /**\n   * Icon for the star rating\n   */\n  icon?: XmltvIcon[];\n};\n\n/**\n * Object describing a programme\n */", "export type XmltvProgramme = {\n  /**\n   * The channel id for the program (see `XmltvChannel`)\n   * This is a string that uniquely identifies the channel on which the programme is broadcast.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   channel: 'bbc1.uk'\n   * }\n   * ```\n   */\n  channel: string;\n\n  /**\n   * Title of the program in different langs\n   *\n   * @example\n   * ```typescript\n   * {\n   *   title: [\n   *     { _value: 'The Simpsons', lang: 'en' },\n   *     { _value: 'Los Simpson', lang: 'es' },\n   *     { _value: 'Les Simpson', lang: 'fr' },\n   *   ]\n   * }\n   * ```\n   */\n  title: XmltvTitle[];\n\n  /**\n   * Start time of the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   start: new Date('2019-01-01T00:00:00Z');\n   * }\n   * ```\n   */\n  start: Date;\n\n  /**\n   * Stop time of the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   stop: new Date('2019-01-01T00:00:00Z');\n   * }\n   * ```\n   */\n  stop?: Date;\n\n  /**\n   * The PDC (Program Delivery Control) start time of the programme.\n   * This is used to mark the actual start time of a broadcast in a tape-based recording system.\n   *\n   * PDC stands for Programme Delivery Control. PDC start time is a signal that is transmitted\n   * along with the television signal to synchronize the VCR's timer with the beginning of a program.\n   * The PDC start time is the precise start time of a television program, accurate to the second,\n   * and is useful for programming VCRs to record a particular program.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   pdcStart: new Date('2019-01-01T00:00:00Z');\n   * }\n   * ```\n   */\n  pdcStart?: Date;\n\n  /**\n   * VPS start time of the program\n   *\n   * VPS stands for Video Programming System, a system used in some countries to synchronize the\n   * start and end times of television programs. The VPS start time is an optional field in the\n   * XMLTV DTD that specifies the start time of the programme according to the VPS system.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   vpsStart: new Date('2019-01-01T00:00:00Z');\n   * }\n   * ```\n   */\n  vpsStart?: Date;\n\n  /**\n   * Showview code for the program\n   *\n   * Showview is a system used in some countries to identify TV programs. It is a six-digit code\n   * assigned to each program that provides a unique identifier, which can be used to look up\n   * program information in a database. In the XMLTV DTD, the showView attribute is an optional\n   * field that specifies the Showview code for the programme.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   showView: '123456'\n   * }\n   * ```\n   */\n  showview?: string;\n\n  /**\n   * Video Plus+ code for the program\n   *\n   * Video Plus+ (VPS+) is a system used in some countries to set the timer of a VCR (Video Cassette Recorder)\n   * to record a specific TV program. It works by assigning a code to each program in the TV listings that\n   * can be entered into the VCR timer. The VCR then starts recording at the specified time, without the\n   * need for the user to set the timer manually. In the XMLTV DTD, the videoplus attribute is an optional\n   * field that specifies the Video Plus+ code for the programme.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   videoPlus: 'V123456'\n   * }\n   * ```\n   */\n  videoplus?: string;\n\n  /**\n   * Clump index for the program\n   *\n   * TV listings sometimes have the problem of listing two or more programmes in the same timeslot,\n   * such as 'News; Weather'. We call this a 'clump' of programmes, and the `clumpIndex` attribute\n   * differentiates between two programmes sharing the same timeslot and channel.\n   * In this case News would have clumpIndex=\"0/2\" and Weather would have clumpidx: \"1/2\".\n   *\n   * If you don't have this problem, be thankful!\n   *\n   * @example\n   * ```typescript\n   * {\n   *   clumpidx: '0/2'\n   * }\n   * ```\n   *\n   */\n  clumpidx?: string;\n\n  /**\n   * Subtitle of the program in different langs\n   *\n   * @example\n   * ```typescript\n   * {\n   *   subTitle: [\n   *     { _value: 'Treehouse of Horror XXVII', lang: 'en' },\n   *     { _value: 'El \u00e1rbol de los horrores XXVII', lang: 'es' },\n   *     { _value: \"Le manoir de l'horreur XXVII\", lang: 'fr' },\n   *   ]\n   * }\n   * ```\n   */\n  subTitle?: XmltvSubTitle[];\n\n  /**\n   * Description of the program in different langs\n   *\n   * @example\n   * ```typescript\n   * {\n   *   desc: [\n   *     { _value: 'The Simpsons go to a haunted house.', lang: 'en' },\n   *     { _value: 'Los Simpson van a una casa embrujada.', lang: 'es' },\n   *     { _value: 'Les Simpson vont dans une maison hant\u00e9e.', lang: 'fr' },\n   *   ]\n   * }\n   * ```\n   */\n  desc?: XmltvDesc[];\n\n  /**\n   * Credits for the program, including director, actors, writers, etc.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   credits: {\n   *     directors: [{ _value: 'David Silverman' }],\n   *     actors: [\n   *       { _value: 'Dan Castellaneta', role: 'Homer Simpson' },\n   *       { _value: 'Julie Kavner', role: 'Marge Simpson' },\n   *       { _value: 'Nancy Cartwright', role: 'Bart Simpson' },\n   *       { _value: 'Yeardley Smith', role: 'Lisa Simpson' },\n   *     ],\n   *   }\n   * }\n   */\n  credits?: XmltvCredits;\n\n  /**\n   * Date of the program in YYYYMMDD format\n   *\n   * The date the programme or film was finished.  This will probably be the same as the copyright date.\n   *\n   * @example\n   * ```typescript\n   * {\n   *  date: '20190101'\n   * }\n   * ```\n   */\n  date?: Date;\n\n  /**\n   * Category of the program in different langs\n   *\n   * @example\n   * ```typescript\n   * {\n   *   categories: [\n   *     { : 'Comedy', lang: 'en' },\n   *     { : 'Comedia', lang: 'es' },\n   *     { : 'Com\u00e9die', lang: 'fr' },\n   *   ]\n   * }\n   * ```\n   */\n  category?: XmltvCategory[];\n\n  /**\n   * Keyword for the program in different langs\n   *\n   * @example\n   * ```typescript\n   * {\n   *   keywords: [\n   *     { _value: 'Halloween', lang: 'en' },\n   *     { _value: 'Halloween', lang: 'es' },\n   *     { _value: 'Halloween', lang: 'fr' },\n   *   ]\n   * }\n   * ```\n   */\n  keyword?: XmltvKeyword[];\n\n  /**\n   * language used in the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *  language: 'en'\n   * }\n   * ```\n   */\n  language?: XmltvLanguage;\n\n  /**\n   * Original lang of the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   origLanguage: 'en'\n   * }\n   * ```\n   */\n  origLanguage?: XmltvOrigLanguage;\n\n  /**\n   * Length of the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   length: {\n   *     units: 'minutes',\n   *     _value: 30\n   *   }\n   * }\n   * ```\n   */\n  length?: XmltvLength;\n\n  /**\n   * Icon for the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   icon: {\n   *     src: 'https://example.com/icon.png',\n   *     width: 32,\n   *     height: 32\n   *   }\n   * }\n   * ```\n   */\n  icon?: XmltvIcon[];\n\n  /**\n   * URL for the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   url: {\n   *    _value: 'https://example.com/program',\n   *    system: 'imdb'\n   *   }\n   * }\n   * ```\n   */\n  url?: XmltvUrl[];\n\n  /**\n   * Country of the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   country: 'US'\n   * }\n   * ```\n   */\n  country?: XmltvCountry;\n\n  /**\n   * Episode number for the program in either \"onscreen\" or \"xmltv_ns\" format\n   *\n   * @example\n   * ```typescript\n   * {\n   *   episodeNum: [{\n   *     _value: 'S27E07',\n   *     type: '27.7'\n   *   }]\n   * }\n   * ```\n   */\n  episodeNum?: XmltvEpisodeNumber[];\n\n  /**\n   * Video details, including aspect ratio, whether it is in colour or black and white, etc.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   video: {\n   *     present: true,\n   *     colour: true,\n   *     aspect: '16:9',\n   *     quality: 'HDTV'\n   *   }\n   * }\n   * ```\n   */\n  video?: XmltvVideo;\n\n  /**\n   * Audio details, similar to video details.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   audio: {\n   *     present: true,\n   *     stereo: 'stereo'\n   *   }\n   * }\n   * ```\n   */\n  audio?: XmltvAudio;\n\n  /**\n   * When and where the programme was last shown, if known.  Normally in TV listings 'repeat'\n   * means 'previously shown on this channel', but if you don't know what channel the old\n   * screening was on (but do know that it happened) then you can omit the 'channel' attribute.\n   *\n   * Similarly you can omit the 'start' attribute if you don't know when the previous transmission\n   * was (though you can of course give just the year, etc.).\n   *\n   * The absence of this element does not say for certain that the programme is brand new and\n   * has never been screened anywhere before.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   previouslyShown: {\n   *     start: '2019-01-01T00:00:00Z',\n   *     channel: 'example.com'\n   *   }\n   * }\n   * ```\n   *\n   */\n  previouslyShown?: XmltvPreviouslyShown;\n\n  /**\n   * Premiere details for the program in different langs\n   *\n   * Different channels have different meanings for this word - sometimes it means a film\n   * has never before been seen on TV in that country, but other channels use it to mean\n   * 'the first showing of this film on our channel in the current run'.  It might have been\n   * shown before, but now they have paid for another set of showings, which makes the first\n   * in that set count as a premiere!\n   *\n   * So this element doesn't have a clear meaning, just use it to represent where 'premiere'\n   * would appear in a printed TV listing. You can use the content of the element to explain\n   * exactly what is meant.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   premiere:'First showing on this channel'\n   * }\n   * ```\n   *\n   * If you don't want to give an explanation, just set it to true:\n   *\n   * @example\n   * ```typescript\n   * {\n   *   premiere: true\n   * }\n   * ```\n   */\n  premiere?: XmltvStringWithLang | boolean;\n\n  /**\n   * Last chance details for the program in different langs\n   *\n   * In a way this is the opposite of premiere.  Some channels buy the rights to show a\n   * movie a certain number of times, and the first may be flagged 'premiere',\n   * the last as 'last showing'.\n   *\n   * For symmetry with premiere, you may use the element content to give a 'paragraph'\n   * describing exactly what is meant - it's unlikely to be the last showing ever!\n   * Otherwise, explicitly put empty content.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   lastChance: 'Last showing on this channel'\n   * }\n   * ```\n   */\n  lastChance?: XmltvStringWithLang | boolean;\n\n  /**\n   * This is the first screened programme from a new show that has never been shown on television\n   * before (if not worldwide then at least never before in this country).\n   *\n   * After the first episode or programme has been shown, subsequent ones are no longer 'new'.\n   * Similarly the second series of an established programme is not 'new'.\n   *\n   * Note that this does not mean 'new season' or 'new episode' of an existing show.\n   * You can express part of that using the episode-num stuff.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   new: true\n   * }\n   * ```\n   */\n  new?: boolean;\n\n  /**\n   * Subtitles details for the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   subtitles: [\n   *     { type: 'teletext', language: {_value: 'English'} },\n   *     { type: 'onscreen', language: {_value: 'French', lang: 'fr'} }\n   *   ]\n   * }\n   * ```\n   */\n  subtitles?: XmltvSubtitle[];\n\n  /**\n   * Various bodies decide on classifications for films - usually a minimum age you must be to see it.\n   * In principle the same could be done for ordinary TV programmes. Because there are many systems for\n   * doing this, you can also specify the rating system used eg MPAA, VCHIP, etc.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   system: 'MPAA',\n   *   _value: 'PG',\n   *   icon: [{\n   *     src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n   *     width: 32,\n   *     height: 32\n   *   }]\n   * }\n   * ```\n   *\n   */\n  rating?: XmltvRating[];\n\n  /**\n   * Star rating for the program, including value and system\n   *\n   * Star rating' - many listings guides award a programme a score as a quick guide to how good it is.\n   * The value of this element should be 'N / M', for example one star out of a possible five stars would be '1 / 5'.\n   *\n   * Zero stars is also a possible score (and not the same as 'unrated').  You should try to map whatever wacky system\n   * your listings source uses to a number of stars: so for example if they have thumbs up, thumbs sideways and thumbs down,\n   * you could map that to two, one or zero stars out of two.\n   *\n   * If a programme is marked as recommended in a listings guide you could map this to '1 / 1'.\n   *\n   * Because there could be many ways to provide star-ratings or recommendations for a programme, you can specify\n   * multiple star-ratings. You can specify the star-rating system used, or the provider of the recommendation,\n   * with the system attribute. Whitespace between the numbers and slash is ignored.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   starRating: [{\n   *     value: '1 / 5',\n   *     system: 'IMDB',\n   *     icon: {\n   *       src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n   *       width: 32,\n   *       height: 32\n   *     }\n   *   }]\n   * }\n   * ```\n   */\n  starRating?: XmltvStarRating[];\n\n  /**\n   * Review details for the program\n   *\n   * Listings guides may provide reviews of programmes in addition to, or in place of, standard\n   * programme descriptions. They are usually written by in-house reviewers, but reviews can also\n   * be made available by third-party organisations/individuals. The value of this element must\n   * be either the text of the review, or a URL that links to it. Optional attributes giving the\n   * review source and the individual reviewer can also be specified.\n   *\n   * @example\n   * ```typescript\n   * {\n   *  review: {\n   *   _value: 'https://www.imdb.com/title/tt0111161/reviews',\n   *  type: 'url',\n   * source: 'IMDB',\n   * reviewer: 'John Doe',\n   * lang: 'en'\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * {\n   *   review: [{\n   *     _value: 'A great movie',\n   *     type: 'text',\n   *     source: 'IMDB',\n   *     reviewer: 'John Doe',\n   *     lang: 'en'\n   *   }]\n   * }\n   * ```\n   */\n  review?: XmltvReview[];\n\n  /**\n   * Images associated with the program\n   *\n   * @example\n   * ```typescript\n   * {\n   *   images: [{\n   *     src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n   *     type: 'poster\n   *     orient: 'L',\n   *     size: 3\n   *   }]\n   * }\n   * ```\n   */\n  image?: XmltvImage[];\n};\n\n/**\n * The channel details\n */", "export type XmltvChannel = {\n  /**\n   * The channel id\n   *\n   * @example\n   * ```typescript\n   * {\n   *   id: 'channel-1'\n   * }\n   * ```\n   */\n  id: string;\n\n  /**\n   * The channel display name\n   *\n   * @example\n   * ```typescript\n   * {\n   *   displayName: [{\n   *     _value: 'Channel 1',\n   *     lang: 'en'\n   *   },{\n   *     _value: 'Kanal 1',\n   *     lang: 'de'\n   *   }]\n   * }\n   * ```\n   */\n  displayName: XmltvDisplayName[];\n\n  /**\n   * The channel icon\n   *\n   * @example\n   * ```typescript\n   * {\n   *   icon: [{\n   *     src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n   *     width: 32,\n   *     height: 32\n   *   }]\n   * }\n   * ```\n   */\n  icon?: XmltvIcon[];\n\n  /**\n   * The channel url\n   *\n   * @example\n   * ```typescript\n   * {\n   *   url: [{_value: 'https://www.channel1.com'}]\n   * ]\n   * ```\n   */\n  url?: XmltvUrl[];\n};\n", "export type Xmltv = {\n  channels?: XmltvChannel[];\n  programmes?: XmltvProgramme[];\n  date?: Date;\n  sourceInfoName?: string;\n  generatorInfoName?: string;\n  sourceInfoUrl?: string;\n  sourceDataUrl?: string;\n  generatorInfoUrl?: string;\n};\n\n/**\n * A single XMLTV DOM node\n *\n * @example\n * ```typescript\n * {\n *   tagName: 'programme',\n *   attributes: {\n *     start: '20210101000000 +0100',\n *     stop: '20210101010000 +0100',\n *     channel: 'channel-1'\n *   },\n *   children: [{\n *     tagName: 'title',\n *     attributes: {\n *       lang: 'en'\n *     },\n *     children: ['Programme title']\n *   }]\n * }\n * ```\n */", "export type XmltvDomNode =\n  | {\n      tagName: string;\n      attributes: Record<string, any>;\n      children: Array<XmltvDomNode | string>;\n    }\n  | string;\n\n/**\n * A collection of XMLTV DOM nodes to form a valid XMLTV document\n *\n */", "export type XmltvDom = XmltvDomNode[];\n"]}
{"filename": "src/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n/// <reference types=\"vitest\" />\n"]}
{"filename": "src/objectToDom.ts", "chunked_list": ["import type { XmltvDomNode } from \"./types\";\nimport { dateToXmltvUtcTimestamp } from \"./utils.js\";\nimport {\n  xmltvAttributeTranslationsReversed,\n  xmltvTagTranslationsReversed,\n} from \"./xmltvTranslations.js\";\nimport { XmltvAttributes, xmltvAttributes } from \"./xmltvTagsAttributes.js\";\n\n/**\n * Converts an XMLTV object to a DOM tree", "/**\n * Converts an XMLTV object to a DOM tree\n *\n * @param obj The XMLTV object to convert to a DOM tree\n * @param key The current key to loop over\n * @param isArrayChild Controls if the return is an array or not\n * @returns The DOM tree\n */\nexport function objectToDom(obj: any, key = \"tv\", isArrayChild = false): any {\n  if (Array.isArray(obj)) {\n    return obj.map((item) => objectToDom(item, key, true));\n  }\n", "export function objectToDom(obj: any, key = \"tv\", isArrayChild = false): any {\n  if (Array.isArray(obj)) {\n    return obj.map((item) => objectToDom(item, key, true));\n  }\n\n  if (typeof obj === \"number\") {\n    return obj.toString();\n  }\n\n  if (typeof obj === \"string\") {\n    return obj;\n  }\n", "  if (typeof obj === \"string\") {\n    return obj;\n  }\n\n  if (obj instanceof Date && key !== \"date\") {\n    return dateToXmltvUtcTimestamp(obj);\n  }\n\n  if (typeof obj === \"boolean\" && key !== \"new\") {\n    return obj ? \"yes\" : \"no\";\n  }\n\n  const translatedTagName = xmltvTagTranslationsReversed.get(key) || key;\n\n  const DomNode: XmltvDomNode = {\n    tagName: translatedTagName,\n    attributes: {},\n    children: [],\n  };\n", "  if (typeof obj === \"boolean\" && key !== \"new\") {\n    return obj ? \"yes\" : \"no\";\n  }\n\n  const translatedTagName = xmltvTagTranslationsReversed.get(key) || key;\n\n  const DomNode: XmltvDomNode = {\n    tagName: translatedTagName,\n    attributes: {},\n    children: [],\n  };\n", "  for (let childKey in obj) {\n    const translatedAttributeName =\n      xmltvAttributeTranslationsReversed.get(childKey) || childKey;\n\n    if (obj[childKey].tagName === \"new\") {\n      obj[translatedTagName].children = [];\n      continue;\n    }\n\n    if (\n      (xmltvAttributes.indexOf(translatedAttributeName as XmltvAttributes) >=\n        0 &&\n        typeof obj[childKey] !== \"object\") ||\n      obj[childKey] instanceof Date\n    ) {", "    if (\n      (xmltvAttributes.indexOf(translatedAttributeName as XmltvAttributes) >=\n        0 &&\n        typeof obj[childKey] !== \"object\") ||\n      obj[childKey] instanceof Date\n    ) {\n      if (DomNode.tagName === \"credits\" && childKey === \"guest\") {\n        continue;\n      }\n      if (DomNode.tagName === \"programme\" && childKey === \"channel\") {\n        DomNode.attributes[translatedAttributeName] = obj[childKey];\n        continue;\n      }\n", "      if (DomNode.tagName === \"programme\" && childKey === \"channel\") {\n        DomNode.attributes[translatedAttributeName] = obj[childKey];\n        continue;\n      }\n\n      if (DomNode.tagName === \"tv\" && childKey === \"date\") {\n        DomNode.attributes[translatedAttributeName] = dateToXmltvUtcTimestamp(\n          obj[childKey]\n        );\n        continue;\n      }\n", "      if (DomNode.tagName === \"programme\" && childKey === \"date\") {\n        DomNode.children.push({\n          tagName: translatedAttributeName,\n          attributes: {},\n          children: [dateToXmltvUtcTimestamp(obj[childKey])],\n        });\n        continue;\n      }\n\n      const childJsType = typeof obj[childKey];\n", "      if (childJsType === \"number\") {\n        DomNode.attributes[translatedAttributeName] = obj[childKey].toString();\n        continue;\n      }\n\n      if (childJsType === \"boolean\") {\n        DomNode.attributes[translatedAttributeName] = obj[childKey]\n          ? \"yes\"\n          : \"no\";\n        continue;\n      }\n", "      if (childJsType === \"object\" && !Array.isArray(obj[childKey])) {\n        if (obj[childKey] instanceof Date) {\n          obj[childKey] = dateToXmltvUtcTimestamp(obj[childKey]);\n          DomNode.attributes[translatedAttributeName] = obj[childKey];\n          continue;\n        }\n\n        const normalizedAttrs = Object.keys(obj[childKey]).map((key) => {\n          obj[childKey][key] = obj[childKey][key].toString();\n        });\n\n        DomNode.attributes[translatedAttributeName] = normalizedAttrs;\n        continue;\n      }\n      DomNode.attributes[translatedAttributeName] = obj[childKey];\n    } else {\n      const childNode = objectToDom(obj[childKey], childKey);", "      if (Array.isArray(childNode)) {\n        for (let i = 0, x = childNode.length; i < x; i++) {\n          DomNode.children.push(childNode[i]);\n        }\n      } else {\n        if (childKey !== \"_value\") {\n          DomNode.children.push({\n            tagName: translatedAttributeName,\n            attributes: {},\n            children: [childNode],\n          });\n          continue;\n        }\n        DomNode.children.push(childNode);\n      }\n    }\n  }\n\n  return isArrayChild ? DomNode : [DomNode];\n}\n"]}
{"filename": "src/xmltvTranslations.ts", "chunked_list": ["import { reverseMap } from \"./utils.js\";\nimport { xmltvAttributes, xmltvTags } from \"./xmltvTagsAttributes.js\";\nimport type { XmltvTags, XmltvAttributes } from \"./xmltvTagsAttributes.js\";\n\n/**\n * The map of XMLTV strings to preferred JS strings\n *\n * Why use a map?\n *\n * Instead of using a function to convert to camelCase, we use a map.\n * This is because performance is important in this library, and picking\n * from a map is faster than running a function. It also allows us to\n * translate by any rule we want, pluralisation, internationalisation, etc.\n *\n * Here are the results of running a benchmark comparing picking from a\n * map vs running a transform function:\n *       map: 6 470 122 ops/s, \u00b10.21%   | fastest\n *   convert: 232 614 ops/s, \u00b10.27%     | slowest, 96.4% slower\n *\n */\n", " *\n * Instead of using a function to convert to camelCase, we use a map.\n * This is because performance is important in this library, and picking\n * from a map is faster than running a function. It also allows us to\n * translate by any rule we want, pluralisation, internationalisation, etc.\n *\n * Here are the results of running a benchmark comparing picking from a\n * map vs running a transform function:\n *       map: 6 470 122 ops/s, \u00b10.21%   | fastest\n *   convert: 232 614 ops/s, \u00b10.27%     | slowest, 96.4% slower\n *\n */\n", "type XmltvTagTranslations = Map<XmltvTags, string>;\ntype XmltvAttributeTranslations = Map<XmltvAttributes, string>;\ntype XmltvTagTranslationsReversed = Map<string, XmltvTags>;\ntype XmltvAttributeTranslationsReversed = Map<string, XmltvAttributes>;\n\nconst xmltvTagTranslations: XmltvTagTranslations = new Map([\n  ...xmltvTags.map((x) => [x, x] as [XmltvTags, string]),\n]);\n\nconst xmltvAttributeTranslations: XmltvAttributeTranslations = new Map([\n  ...xmltvAttributes.map((x) => [x, x] as [XmltvAttributes, string]),\n]);\n\nconst xmltvTagTranslationsReversed =\n  reverseMap<XmltvTagTranslationsReversed>(xmltvTagTranslations);\nconst xmltvAttributeTranslationsReversed =\n  reverseMap<XmltvAttributeTranslationsReversed>(xmltvAttributeTranslations);\n\n/**\n * Adds or modifies a translation for a XMLTV tag\n *\n * @param key A valid Xmltv tag string\n * @param value Your translation\n */", "function addTagTranslation(key: XmltvTags, value: string) {\n  if (!xmltvTags.includes(key)) {\n    throw new Error(`Invalid tag: ${key}`);\n  }\n\n  const map: XmltvTagTranslations = xmltvTagTranslations;\n  const reverse: XmltvTagTranslationsReversed = xmltvTagTranslationsReversed;\n\n  if (map && reverse) {\n    map.set(key, value);\n    reverse.set(value, key);\n  }\n}\n\n/**\n * Adds or modifies a translation for a XMLTV attribute\n *\n * @param key A valid Xmltv attribute string\n * @param value Your translation\n */", "  if (map && reverse) {\n    map.set(key, value);\n    reverse.set(value, key);\n  }\n}\n\n/**\n * Adds or modifies a translation for a XMLTV attribute\n *\n * @param key A valid Xmltv attribute string\n * @param value Your translation\n */", "function addAttributeTranslation(key: XmltvAttributes, value: string) {\n  if (!xmltvAttributes.includes(key)) {\n    throw new Error(`Invalid attribute: ${key}`);\n  }\n\n  const map: XmltvAttributeTranslations = xmltvAttributeTranslations;\n  const reverse: XmltvAttributeTranslationsReversed =\n    xmltvAttributeTranslationsReversed;\n\n  if (map && reverse) {\n    map.set(key, value);\n    reverse.set(value, key);\n  }\n}\n\naddTagTranslation(\"display-name\", \"displayName\");\naddTagTranslation(\"episode-num\", \"episodeNum\");\naddTagTranslation(\"last-chance\", \"lastChance\");\naddTagTranslation(\"orig-language\", \"origLanguage\");\naddTagTranslation(\"previously-shown\", \"previouslyShown\");\naddTagTranslation(\"star-rating\", \"starRating\");\naddTagTranslation(\"sub-title\", \"subTitle\");\naddTagTranslation(\"channel\", \"channels\");\naddTagTranslation(\"programme\", \"programmes\");\n\naddAttributeTranslation(\"generator-info-name\", \"generatorInfoName\");\naddAttributeTranslation(\"generator-info-url\", \"generatorInfoUrl\");\naddAttributeTranslation(\"pdc-start\", \"pdcStart\");\naddAttributeTranslation(\"vps-start\", \"vpsStart\");\naddAttributeTranslation(\"source-data-url\", \"sourceDataUrl\");\naddAttributeTranslation(\"source-info-name\", \"sourceInfoName\");\naddAttributeTranslation(\"source-info-url\", \"sourceInfoUrl\");\n\nexport {\n  xmltvTagTranslations,\n  xmltvTagTranslationsReversed,\n  xmltvAttributeTranslations,\n  xmltvAttributeTranslationsReversed,\n  addTagTranslation,\n  addAttributeTranslation,\n};\n\nexport type { XmltvTagTranslations, XmltvAttributeTranslations };\n", "  if (map && reverse) {\n    map.set(key, value);\n    reverse.set(value, key);\n  }\n}\n\naddTagTranslation(\"display-name\", \"displayName\");\naddTagTranslation(\"episode-num\", \"episodeNum\");\naddTagTranslation(\"last-chance\", \"lastChance\");\naddTagTranslation(\"orig-language\", \"origLanguage\");\naddTagTranslation(\"previously-shown\", \"previouslyShown\");\naddTagTranslation(\"star-rating\", \"starRating\");\naddTagTranslation(\"sub-title\", \"subTitle\");\naddTagTranslation(\"channel\", \"channels\");\naddTagTranslation(\"programme\", \"programmes\");\n\naddAttributeTranslation(\"generator-info-name\", \"generatorInfoName\");\naddAttributeTranslation(\"generator-info-url\", \"generatorInfoUrl\");\naddAttributeTranslation(\"pdc-start\", \"pdcStart\");\naddAttributeTranslation(\"vps-start\", \"vpsStart\");\naddAttributeTranslation(\"source-data-url\", \"sourceDataUrl\");\naddAttributeTranslation(\"source-info-name\", \"sourceInfoName\");\naddAttributeTranslation(\"source-info-url\", \"sourceInfoUrl\");\n\nexport {\n  xmltvTagTranslations,\n  xmltvTagTranslationsReversed,\n  xmltvAttributeTranslations,\n  xmltvAttributeTranslationsReversed,\n  addTagTranslation,\n  addAttributeTranslation,\n};\n\nexport type { XmltvTagTranslations, XmltvAttributeTranslations };\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export function xmltvTimestampToUtcDate(timestamp: string) {\n  timestamp = timestamp.trim().replace(/[\\s]/g, '');\n  let mainPart, timeZone;\n\n  if (timestamp.endsWith('Z')) {\n    mainPart = timestamp.slice(0, -1);\n    timeZone = null; // No adjustment needed for UTC\n  } else {\n    mainPart = timestamp.slice(0, -5);\n    timeZone = timestamp.slice(-5);\n  }\n\n  const cleanTimestamp = mainPart.replace(/[-:Zz]/g, '');\n\n  const year = parseInt(cleanTimestamp.slice(0, 4), 10);\n  const month = parseInt(cleanTimestamp.slice(4, 6), 10) - 1 || 0;\n  const day = parseInt(cleanTimestamp.slice(6, 8), 10) || 1;\n  const hours = parseInt(cleanTimestamp.slice(8, 10), 10) || 0;\n  const minutes = parseInt(cleanTimestamp.slice(10, 12), 10) || 0;\n  const seconds = parseInt(cleanTimestamp.slice(12, 14), 10) || 0;\n\n  const date = new Date(Date.UTC(year, month, day, hours, minutes, seconds));\n", "  if (timeZone) {\n    const offsetSign = timeZone.slice(0, 1);\n    const offsetHours = parseInt(timeZone.slice(1, 3), 10);\n    const offsetMinutes = parseInt(timeZone.slice(3, 5), 10);\n    const totalOffsetMinutes = offsetHours * 60 + offsetMinutes;\n\n    if (offsetSign === '+') {\n      date.setUTCMinutes(date.getUTCMinutes() - totalOffsetMinutes);\n    } else if (offsetSign === '-') {\n      date.setUTCMinutes(date.getUTCMinutes() + totalOffsetMinutes);\n    }\n  }\n\n  return date;\n}\n", "    } else if (offsetSign === '-') {\n      date.setUTCMinutes(date.getUTCMinutes() + totalOffsetMinutes);\n    }\n  }\n\n  return date;\n}\n\nexport function dateToXmltvUtcTimestamp(date: Date) {\n  const padZeroes = (num: number) => (num < 10 ? `0${num}` : num.toString());\n\n  const year = padZeroes(date.getUTCFullYear());\n  const month = padZeroes(date.getUTCMonth() + 1);\n  const day = padZeroes(date.getUTCDate());\n  const hours = padZeroes(date.getUTCHours());\n  const minutes = padZeroes(date.getUTCMinutes());\n  const seconds = padZeroes(date.getUTCSeconds());\n\n  return `${year}${month}${day}${hours}${minutes}${seconds} +0000`;\n}\n\n/**\n * Reverses the xmltvTranslations . So that we can convert from\n * camelCase to the xmltv format.\n */", "export function dateToXmltvUtcTimestamp(date: Date) {\n  const padZeroes = (num: number) => (num < 10 ? `0${num}` : num.toString());\n\n  const year = padZeroes(date.getUTCFullYear());\n  const month = padZeroes(date.getUTCMonth() + 1);\n  const day = padZeroes(date.getUTCDate());\n  const hours = padZeroes(date.getUTCHours());\n  const minutes = padZeroes(date.getUTCMinutes());\n  const seconds = padZeroes(date.getUTCSeconds());\n\n  return `${year}${month}${day}${hours}${minutes}${seconds} +0000`;\n}\n\n/**\n * Reverses the xmltvTranslations . So that we can convert from\n * camelCase to the xmltv format.\n */", "export function reverseMap<T extends Map<any, any>>(map: Map<any, any>) {\n  const reversedMap = new Map<any, any>();\n\n  for (const [key, value] of map.entries()) {\n    reversedMap.set(value, key);\n  }\n\n  return reversedMap as T;\n}\n"]}
{"filename": "src/writer.ts", "chunked_list": ["import type { XmltvDom, XmltvDomNode } from \"./types\";\n\nexport function writer(xmltvDom: XmltvDom): string {\n  let out = \"\";\n  function writeChildren(node: XmltvDom) {\n    if (node)\n      for (var i = 0; i < node.length; i++) {\n        if (typeof node[i] === \"string\") {\n          if ((node[i] as string).includes(\"!DOCTYPE\")) {\n            out += \"<\" + (node[i] as string).trim() + \">\";\n            continue;\n          }\n          out += (node[i] as string).trim();\n        } else {\n          writeNode(node[i]);\n        }\n      }\n  }", "          if ((node[i] as string).includes(\"!DOCTYPE\")) {\n            out += \"<\" + (node[i] as string).trim() + \">\";\n            continue;\n          }\n          out += (node[i] as string).trim();\n        } else {\n          writeNode(node[i]);\n        }\n      }\n  }\n  function writeNode(node: XmltvDomNode) {", "  function writeNode(node: XmltvDomNode) {\n    if (typeof node === \"string\") return;\n    out += \"<\" + node.tagName;\n    for (const attr in node.attributes) {\n      if (\n        typeof node.attributes[attr] === \"string\" &&\n        node.attributes[attr].indexOf('\"') === -1\n      ) {\n        out += \" \" + attr + '=\"' + node.attributes[attr].trim() + '\"';\n      } else if (typeof node.attributes[attr] === \"boolean\") {\n        out += \" \" + attr + '=\"' + (node.attributes[attr] ? \"yes\" : \"no\") + '\"';\n      } else {\n        out += \" \" + attr + \"='\" + node.attributes[attr] + \"'\";\n      }\n    }\n", "      } else if (typeof node.attributes[attr] === \"boolean\") {\n        out += \" \" + attr + '=\"' + (node.attributes[attr] ? \"yes\" : \"no\") + '\"';\n      } else {\n        out += \" \" + attr + \"='\" + node.attributes[attr] + \"'\";\n      }\n    }\n\n    if ([\"new\", \"icon\", \"previously-shown\"].indexOf(node.tagName) >= 0) {\n      out += \"/>\";\n      return;\n    }\n", "    if (node.tagName === \"?xml\") {\n      out += \"?>\";\n      return;\n    }\n    out += \">\";\n    if (typeof node.children === \"boolean\") {\n      out += node.children ? \"yes\" : \"no\";\n      return;\n    }\n    writeChildren(node.children);\n    out += \"</\" + node.tagName + \">\";\n  }\n\n  writeChildren(xmltvDom);\n\n  let header = \"\";\n", "  if (out.indexOf(\"?xml\") === -1) {\n    header += '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n  }\n  if (out.indexOf(\"!DOCTYPE\") === -1) {\n    header += '<!DOCTYPE tv SYSTEM \"xmltv.dtd\">';\n  }\n\n  return header + out;\n}\n"]}
{"filename": "src/xmltvTagsAttributes.ts", "chunked_list": ["const xmltvTags = [\n  \"actor\",\n  \"adapter\",\n  \"aspect\",\n  \"audio\",\n  \"category\",\n  \"channel\",\n  \"colour\",\n  \"commentator\",\n  \"composer\",", "  \"commentator\",\n  \"composer\",\n  \"country\",\n  \"credits\",\n  \"date\",\n  \"desc\",\n  \"director\",\n  \"display-name\",\n  \"editor\",\n  \"episode-num\",", "  \"editor\",\n  \"episode-num\",\n  \"guest\",\n  \"icon\",\n  \"image\",\n  \"keyword\",\n  \"language\",\n  \"last-chance\",\n  \"length\",\n  \"new\",", "  \"length\",\n  \"new\",\n  \"orig-language\",\n  \"premiere\",\n  \"present\",\n  \"presenter\",\n  \"previously-shown\",\n  \"producer\",\n  \"programme\",\n  \"quality\",", "  \"programme\",\n  \"quality\",\n  \"rating\",\n  \"review\",\n  \"star-rating\",\n  \"stereo\",\n  \"sub-title\",\n  \"subtitles\",\n  \"title\",\n  \"tv\",", "  \"title\",\n  \"tv\",\n  \"url\",\n  \"value\",\n  \"video\",\n  \"writer\",\n] as const;\n\nconst xmltvAttributes = [\n  \"channel\",", "const xmltvAttributes = [\n  \"channel\",\n  \"clumpidx\",\n  \"date\",\n  \"generator-info-name\",\n  \"generator-info-url\",\n  \"guest\",\n  \"height\",\n  \"id\",\n  \"lang\",", "  \"id\",\n  \"lang\",\n  \"orient\",\n  \"pdc-start\",\n  \"reviewer\",\n  \"role\",\n  \"showview\",\n  \"size\",\n  \"source-data-url\",\n  \"source-info-name\",", "  \"source-data-url\",\n  \"source-info-name\",\n  \"source-info-url\",\n  \"source\",\n  \"src\",\n  \"start\",\n  \"stop\",\n  \"system\",\n  \"type\",\n  \"units\",", "  \"type\",\n  \"units\",\n  \"videoplus\",\n  \"vps-start\",\n  \"width\",\n] as const;\n\ntype XmltvTags = (typeof xmltvTags)[number];\ntype XmltvAttributes = (typeof xmltvAttributes)[number];\n\nexport { xmltvTags, xmltvAttributes, XmltvTags, XmltvAttributes };\n", "type XmltvAttributes = (typeof xmltvAttributes)[number];\n\nexport { xmltvTags, xmltvAttributes, XmltvTags, XmltvAttributes };\n"]}
