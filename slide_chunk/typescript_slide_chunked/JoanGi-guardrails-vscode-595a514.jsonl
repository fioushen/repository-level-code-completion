{"filename": "src/extension.ts", "chunked_list": ["import * as vscode from 'vscode';\nimport * as path from 'path';\nimport {\n    LanguageClient, LanguageClientOptions, ServerOptions, TransportKind\n} from 'vscode-languageclient/node';\nimport { HintsService } from './hints-service/hints-service';\n\nlet client: LanguageClient;\n\n// This function is called when the extension is activated.\nexport function activate(context: vscode.ExtensionContext): void {\n    client = startLanguageClient(context);\n\n    context.subscriptions.push(\n        vscode.languages.registerHoverProvider(\n            'rails', {\n                provideHover(document, position, token) {\n                    let hints = new HintsService();\n                    let content = hints.populateHints(document, position);\n     ", "\n// This function is called when the extension is activated.\nexport function activate(context: vscode.ExtensionContext): void {\n    client = startLanguageClient(context);\n\n    context.subscriptions.push(\n        vscode.languages.registerHoverProvider(\n            'rails', {\n                provideHover(document, position, token) {\n                    let hints = new HintsService();\n                    let content = hints.populateHints(document, position);\n     ", "                    if (content != undefined) return new vscode.Hover(content);\n                    return null;\n            }\n      }));\n}\n\n// This function is called when the extension is deactivated.\nexport function deactivate(): Thenable<void> | undefined {\n    if (client) {\n        return client.stop();\n    }\n    return undefined;\n}\n", "    if (client) {\n        return client.stop();\n    }\n    return undefined;\n}\n\nfunction startLanguageClient(context: vscode.ExtensionContext): LanguageClient {\n    const serverModule = context.asAbsolutePath(path.join('out', 'language-server', 'main'));\n    // The debug options for the server\n    // --inspect=6009: runs the server in Node's Inspector mode so VS Code can attach to the server for debugging.\n    // By setting `process.env.DEBUG_BREAK` to a truthy value, the language server will wait until a debugger is attached.\n    const debugOptions = { execArgv: ['--nolazy', `--inspect${process.env.DEBUG_BREAK ? '-brk' : ''}=${process.env.DEBUG_SOCKET || '6009'}`] };\n\n    // If the extension is launched in debug mode then the debug server options are used\n    // Otherwise the run options are used\n    const serverOptions: ServerOptions = {\n        run: { module: serverModule, transport: TransportKind.ipc },\n        debug: { module: serverModule, transport: TransportKind.ipc, options: debugOptions }\n    };\n\n    const fileSystemWatcher = vscode.workspace.createFileSystemWatcher('**/*.rails');\n    context.subscriptions.push(fileSystemWatcher);\n\n    // Options to control the language client\n    const clientOptions: LanguageClientOptions = {\n        documentSelector: [{ scheme: 'file', language: 'rails' }],\n        synchronize: {\n            // Notify the server about file changes to files contained in the workspace\n            fileEvents: fileSystemWatcher\n        }\n    };\n\n    // Create the language client and start the client.\n    const client = new LanguageClient(\n        'rails',\n        'rails',\n        serverOptions,\n        clientOptions\n    );\n\n    // Start the client. This will also launch the server\n    client.start();\n    return client;\n}\n"]}
{"filename": "src/cli/generator.ts", "chunked_list": ["import fs from 'fs';\nimport { CompositeGeneratorNode, NL, toString } from 'langium';\nimport path from 'path';\nimport { Model } from '../language-server/generated/ast';\nimport { extractDestinationAndName } from './cli-util';\n\nexport function generateJavaScript(model: Model, filePath: string, destination: string | undefined): string {\n    const data = extractDestinationAndName(filePath, destination);\n    const generatedFilePath = `${path.join(data.destination, data.name)}.js`;\n\n    const fileNode = new CompositeGeneratorNode();\n    fileNode.append('\"use strict\";', NL, NL);\n    //model.greetings.forEach(greeting => fileNode.append(`console.log('Hello, ${greeting.person.ref?.name}!');`, NL));\n", "    if (!fs.existsSync(data.destination)) {\n        fs.mkdirSync(data.destination, { recursive: true });\n    }\n    fs.writeFileSync(generatedFilePath, toString(fileNode));\n    return generatedFilePath;\n}\n"]}
{"filename": "src/cli/cli-util.ts", "chunked_list": ["import chalk from 'chalk';\nimport path from 'path';\nimport fs from 'fs';\nimport { AstNode, LangiumDocument, LangiumServices } from 'langium';\nimport { URI } from 'vscode-uri';\n\nexport async function extractDocument(fileName: string, services: LangiumServices): Promise<LangiumDocument> {\n    const extensions = services.LanguageMetaData.fileExtensions;\n    if (!extensions.includes(path.extname(fileName))) {\n        console.error(chalk.yellow(`Please choose a file with one of these extensions: ${extensions}.`));\n        process.exit(1);\n    }\n", "    if (!extensions.includes(path.extname(fileName))) {\n        console.error(chalk.yellow(`Please choose a file with one of these extensions: ${extensions}.`));\n        process.exit(1);\n    }\n\n    if (!fs.existsSync(fileName)) {\n        console.error(chalk.red(`File ${fileName} does not exist.`));\n        process.exit(1);\n    }\n\n    const document = services.shared.workspace.LangiumDocuments.getOrCreateDocument(URI.file(path.resolve(fileName)));\n    await services.shared.workspace.DocumentBuilder.build([document], { validationChecks: 'all' });\n\n    const validationErrors = (document.diagnostics ?? []).filter(e => e.severity === 1);", "    if (validationErrors.length > 0) {\n        console.error(chalk.red('There are validation errors:'));\n        for (const validationError of validationErrors) {\n            console.error(chalk.red(\n                `line ${validationError.range.start.line + 1}: ${validationError.message} [${document.textDocument.getText(validationError.range)}]`\n            ));\n        }\n        process.exit(1);\n    }\n\n    return document;\n}\n", "export async function extractAstNode<T extends AstNode>(fileName: string, services: LangiumServices): Promise<T> {\n    return (await extractDocument(fileName, services)).parseResult?.value as T;\n}\n\ninterface FilePathData {\n    destination: string,\n    name: string\n}\n\nexport function extractDestinationAndName(filePath: string, destination: string | undefined): FilePathData {\n    filePath = path.basename(filePath, path.extname(filePath)).replace(/[.-]/g, '');\n    return {\n        destination: destination ?? path.join(path.dirname(filePath), 'generated'),\n        name: path.basename(filePath)\n    };\n}\n", "export function extractDestinationAndName(filePath: string, destination: string | undefined): FilePathData {\n    filePath = path.basename(filePath, path.extname(filePath)).replace(/[.-]/g, '');\n    return {\n        destination: destination ?? path.join(path.dirname(filePath), 'generated'),\n        name: path.basename(filePath)\n    };\n}\n"]}
{"filename": "src/cli/index.ts", "chunked_list": ["import chalk from 'chalk';\nimport { Command } from 'commander';\nimport { Model } from '../language-server/generated/ast';\nimport { RailsLanguageMetaData } from '../language-server/generated/module';\nimport { createRailsServices } from '../language-server/rails-module';\nimport { extractAstNode } from './cli-util';\nimport { generateJavaScript } from './generator';\nimport { NodeFileSystem } from 'langium/node';\n\nexport const generateAction = async (fileName: string, opts: GenerateOptions): Promise<void> => {", "\nexport const generateAction = async (fileName: string, opts: GenerateOptions): Promise<void> => {\n    const services = createRailsServices(NodeFileSystem).Rails;\n    const model = await extractAstNode<Model>(fileName, services);\n    const generatedFilePath = generateJavaScript(model, fileName, opts.destination);\n    console.log(chalk.green(`JavaScript code generated successfully: ${generatedFilePath}`));\n};\n\nexport type GenerateOptions = {\n    destination?: string;\n}\n\nexport default function(): void {\n    const program = new Command();\n\n    program\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        .version(require('../../package.json').version);\n\n    const fileExtensions = RailsLanguageMetaData.fileExtensions.join(', ');\n    program\n        .command('generate')\n        .argument('<file>', `source file (possible file extensions: ${fileExtensions})`)\n        .option('-d, --destination <dir>', 'destination directory of generating')\n        .description('generates JavaScript code that prints \"Hello, {name}!\" for each greeting in a source file')\n        .action(generateAction);\n\n    program.parse(process.argv);\n}\n", "export type GenerateOptions = {\n    destination?: string;\n}\n\nexport default function(): void {\n    const program = new Command();\n\n    program\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        .version(require('../../package.json').version);\n\n    const fileExtensions = RailsLanguageMetaData.fileExtensions.join(', ');\n    program\n        .command('generate')\n        .argument('<file>', `source file (possible file extensions: ${fileExtensions})`)\n        .option('-d, --destination <dir>', 'destination directory of generating')\n        .description('generates JavaScript code that prints \"Hello, {name}!\" for each greeting in a source file')\n        .action(generateAction);\n\n    program.parse(process.argv);\n}\n"]}
{"filename": "src/hints-service/hints-service.ts", "chunked_list": ["/******************************************************************************\n * Copyright 2022 SOM Research\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n import { TextDocument, MarkdownString} from 'vscode';\n\n\n \n \n export interface Hints {\n     // Load the Abstract Syntax Tree of the .descML active file\n     populateHints(Declaration : string | TextDocument, position: any) : MarkdownString | undefined;\n }\n \n /**\n  */", " \n \n export interface Hints {\n     // Load the Abstract Syntax Tree of the .descML active file\n     populateHints(Declaration : string | TextDocument, position: any) : MarkdownString | undefined;\n }\n \n /**\n  */\n export class HintsService implements Hints {\n \n \n     constructor() {\n       \n    }\n \n     populateHints(document : TextDocument, position: any) : MarkdownString | undefined {\n        const wordRange = document.getWordRangeAtPosition(position);\n        const word = document.getText(wordRange);\n        switch (word) {\n            case \"output\":\n                const markdown = new MarkdownString();", " export class HintsService implements Hints {\n \n \n     constructor() {\n       \n    }\n \n     populateHints(document : TextDocument, position: any) : MarkdownString | undefined {\n        const wordRange = document.getWordRangeAtPosition(position);\n        const word = document.getText(wordRange);\n        switch (word) {\n            case \"output\":\n                const markdown = new MarkdownString();", "                markdown.appendMarkdown(`## Output \\n The output element contains the structure of the expected output of the LLM. It contains the spec for the overall structure of the LLM output, type info for each field, and the quality criteria for each field and the corrective action to be taken in case quality criteria is not met. \\n`)\n                markdown.appendCodeblock(`\n<rail version=\"0.1\">\n    <output>\n        <string name=\"text\" description=\"The generated text\" \n            format=\"two-words\" on-fail-two-words=\"reask\"/>\n        <float name=\"score\" description=\"The score of th.e..\"\n            format=\"min-val: 0\" on-fail-min-val=\"fix\"/>\n        <object name=\"metadata\" description=\"The metadata...\">\n            <string name=\"key_1\" description=\"description of key_1\" />\n            ...\n        </object>\n    </output>\n</rail>`,\"rails\")\n\n                return  markdown\n  //          case \"prompt\":\n             //   return \"## Prompt \\n The prompt `declare = x` element contains the high level instructions that are sent to the LLM. Check out the RAIL Prompt page for more details.\";\n  //          case \"rails\":\n  //              return `<rail version=\"0.1\">\n  //              <output>\n  //                  <string name=\"text\" description=\"The generated text\" format=\"two-words\" on-fail-two-words=\"reask\"/>\n  //                  <float name=\"score\" description=\"The score of the generated text\" format=\"min-val: 0\" on-fail-min-val=\"fix\"/>\n  //                  <object name=\"metadata\" description=\"The metadata associated with the generated text\">\n  //                      <string name=\"key_1\" description=\"description of key_1\" />\n  //                      ...\n   //                 </object>\n   //             </output>\n   //         </rail>`;\n           default:\n            return undefined\n        }\n     }\n }"]}
{"filename": "src/language-server/rails-module.ts", "chunked_list": ["import {\n    createDefaultModule, createDefaultSharedModule, DefaultSharedModuleContext, inject,\n    LangiumServices, LangiumSharedServices, Module, PartialLangiumServices\n} from 'langium';\nimport { RailsGeneratedModule, RailsGeneratedSharedModule } from './generated/module';\nimport { RailsValidator, registerValidationChecks } from './rails-validator';\n\n/**\n * Declaration of custom services - add your own service classes here.\n */\nexport type RailsAddedServices = {\n    validation: {\n        RailsValidator: RailsValidator\n    }\n}\n\n/**\n * Union of Langium default services and your custom services - use this as constructor parameter\n * of custom service classes.\n */", " * Declaration of custom services - add your own service classes here.\n */\nexport type RailsAddedServices = {\n    validation: {\n        RailsValidator: RailsValidator\n    }\n}\n\n/**\n * Union of Langium default services and your custom services - use this as constructor parameter\n * of custom service classes.\n */", "export type RailsServices = LangiumServices & RailsAddedServices\n\n/**\n * Dependency injection module that overrides Langium default services and contributes the\n * declared custom services. The Langium defaults can be partially specified to override only\n * selected services, while the custom services must be fully specified.\n */\nexport const RailsModule: Module<RailsServices, PartialLangiumServices & RailsAddedServices> = {\n    validation: {\n        RailsValidator: () => new RailsValidator()\n    }\n};\n\n/**\n * Create the full set of services required by Langium.\n *\n * First inject the shared services by merging two modules:\n *  - Langium default shared services\n *  - Services generated by langium-cli\n *\n * Then inject the language-specific services by merging three modules:\n *  - Langium default language-specific services\n *  - Services generated by langium-cli\n *  - Services specified in this file\n *", " * @param context Optional module context with the LSP connection\n * @returns An object wrapping the shared services and the language-specific services\n */\nexport function createRailsServices(context: DefaultSharedModuleContext): {\n    shared: LangiumSharedServices,\n    Rails: RailsServices\n} {\n    const shared = inject(\n        createDefaultSharedModule(context),\n        RailsGeneratedSharedModule\n    );\n    const Rails = inject(\n        createDefaultModule({ shared }),\n        RailsGeneratedModule,\n        RailsModule\n    );\n    shared.ServiceRegistry.register(Rails);\n    registerValidationChecks(Rails);\n    return { shared, Rails };\n}\n"]}
{"filename": "src/language-server/main.ts", "chunked_list": ["import { startLanguageServer } from 'langium';\nimport { NodeFileSystem } from 'langium/node';\nimport { createConnection, ProposedFeatures } from 'vscode-languageserver/node';\nimport { createRailsServices } from './rails-module';\n\n// Create a connection to the client\nconst connection = createConnection(ProposedFeatures.all);\n\n// Inject the shared services and language-specific services\nconst { shared } = createRailsServices({ connection, ...NodeFileSystem });", "// Inject the shared services and language-specific services\nconst { shared } = createRailsServices({ connection, ...NodeFileSystem });\n\n// Start the language server with the shared services\nstartLanguageServer(shared);\n"]}
{"filename": "src/language-server/rails-validator.ts", "chunked_list": ["import { ValidationAcceptor, ValidationChecks } from 'langium';\nimport { RailsAstType, Output } from './generated/ast';\nimport type { RailsServices } from './rails-module';\n\n/**\n * Register custom validation checks.\n */\nexport function registerValidationChecks(services: RailsServices) {\n    const registry = services.validation.ValidationRegistry;\n    const validator = services.validation.RailsValidator;\n    const checks: ValidationChecks<RailsAstType> = {\n       \n    };\n    registry.register(checks, validator);\n}\n\n/**\n * Implementation of custom validations.\n */", "export class RailsValidator {\n\n    checkPersonStartsWithCapital(person: Output, accept: ValidationAcceptor): void {\n    //    if (person.name) {\n    //        const firstChar = person.name.substring(0, 1);\n    //        if (firstChar.toUpperCase() !== firstChar) {\n    //            accept('warning', 'Person name should start with a capital.', { node: person, property: 'name' });\n    //        }\n    //    }\n    }\n\n}\n"]}
{"filename": "src/language-server/generated/module.ts", "chunked_list": ["/******************************************************************************\n * This file was generated by langium-cli 1.1.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\nimport { LangiumGeneratedServices, LangiumGeneratedSharedServices, LangiumSharedServices, LangiumServices, LanguageMetaData, Module } from 'langium';\nimport { RailsAstReflection } from './ast';\nimport { RailsGrammar } from './grammar';\n\nexport const RailsLanguageMetaData: LanguageMetaData = {", "\nexport const RailsLanguageMetaData: LanguageMetaData = {\n    languageId: 'rails',\n    fileExtensions: ['.rails'],\n    caseInsensitive: false\n};\n\nexport const RailsGeneratedSharedModule: Module<LangiumSharedServices, LangiumGeneratedSharedServices> = {\n    AstReflection: () => new RailsAstReflection()\n};", "    AstReflection: () => new RailsAstReflection()\n};\n\nexport const RailsGeneratedModule: Module<LangiumServices, LangiumGeneratedServices> = {\n    Grammar: () => RailsGrammar(),\n    LanguageMetaData: () => RailsLanguageMetaData,\n    parser: {}\n};\n", ""]}
{"filename": "src/language-server/generated/grammar.ts", "chunked_list": ["/******************************************************************************\n * This file was generated by langium-cli 1.1.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\nimport { loadGrammarFromJson, Grammar } from 'langium';\n\nlet loadedRailsGrammar: Grammar | undefined;\nexport const RailsGrammar = (): Grammar => loadedRailsGrammar ?? (loadedRailsGrammar = loadGrammarFromJson(`{\n  \"$type\": \"Grammar\",", "export const RailsGrammar = (): Grammar => loadedRailsGrammar ?? (loadedRailsGrammar = loadGrammarFromJson(`{\n  \"$type\": \"Grammar\",\n  \"isDeclared\": true,\n  \"name\": \"Rails\",\n  \"rules\": [\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Model\",\n      \"entry\": true,\n      \"definition\": {", "      \"entry\": true,\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"<\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"rails\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"version=\"\n          },\n          {\n            \"$type\": \"Assignment\",", "          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"version\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@16\"\n              },\n              \"arguments\": []", "              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          },\n          {\n            \"$type\": \"Assignment\",", "          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"rails\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@1\"\n              },\n              \"arguments\": []", "              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"</\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"rails\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",", "    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Rails\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"output\",\n            \"operator\": \"=\",", "            \"feature\": \"output\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@2\"\n              },\n              \"arguments\": []\n            }\n          },", "            }\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"prompt\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@13\"", "              \"rule\": {\n                \"$ref\": \"#/rules@13\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"script\",\n            \"operator\": \"=\",", "            \"feature\": \"script\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@14\"\n              },\n              \"arguments\": []\n            }\n          }", "            }\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false", "      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Output\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {", "        \"elements\": [\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"Keyword\",\n              \"value\": \"<output>\"\n            }\n          },", "            }\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"element\",\n            \"operator\": \"+=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@3\"", "              \"rule\": {\n                \"$ref\": \"#/rules@3\"\n              },\n              \"arguments\": []\n            },\n            \"cardinality\": \"*\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"</output>\"", "            \"$type\": \"Keyword\",\n            \"value\": \"</output>\"\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],", "      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"NonScalarType\",\n      \"definition\": {\n        \"$type\": \"Alternatives\",\n        \"elements\": [", "        \"$type\": \"Alternatives\",\n        \"elements\": [\n          {\n            \"$type\": \"RuleCall\",\n            \"rule\": {\n              \"$ref\": \"#/rules@4\"\n            },\n            \"arguments\": []\n          },\n          {", "          },\n          {\n            \"$type\": \"RuleCall\",\n            \"rule\": {\n              \"$ref\": \"#/rules@5\"\n            },\n            \"arguments\": []\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"ObjectType\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"<object\"", "            \"$type\": \"Keyword\",\n            \"value\": \"<object\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"name=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@20\"\n              },\n              \"arguments\": []\n            }", "              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"format=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"format\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"format\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@7\"\n              },\n              \"arguments\": []\n            }", "              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"elements\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"elements\",\n            \"operator\": \"+=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@8\"\n              },\n              \"arguments\": []\n            },", "              \"arguments\": []\n            },\n            \"cardinality\": \"*\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"</object>\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"ListType\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"<list\"", "            \"$type\": \"Keyword\",\n            \"value\": \"<list\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"name=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@20\"\n              },\n              \"arguments\": []\n            }", "              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"format=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"format\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"format\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@7\"\n              },\n              \"arguments\": []\n            }", "              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"elements\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"elements\",\n            \"operator\": \"+=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@8\"\n              },\n              \"arguments\": []\n            },", "              \"arguments\": []\n            },\n            \"cardinality\": \"*\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"</list>\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Format\",\n      \"definition\": {\n        \"$type\": \"Assignment\",\n        \"feature\": \"name\",\n        \"operator\": \"=\",\n        \"terminal\": {\n          \"$type\": \"RuleCall\",", "        \"terminal\": {\n          \"$type\": \"RuleCall\",\n          \"rule\": {\n            \"$ref\": \"#/rules@15\"\n          },\n          \"arguments\": []\n        }\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,", "      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Formats\",", "      \"$type\": \"ParserRule\",\n      \"name\": \"Formats\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"format\",\n            \"operator\": \"+=\",\n            \"terminal\": {", "            \"operator\": \"+=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@6\"\n              },\n              \"arguments\": []\n            }\n          },\n          {", "          },\n          {\n            \"$type\": \"Group\",\n            \"elements\": [\n              {\n                \"$type\": \"Keyword\",\n                \"value\": \";\"\n              },\n              {\n                \"$type\": \"Assignment\",", "              {\n                \"$type\": \"Assignment\",\n                \"feature\": \"format\",\n                \"operator\": \"+=\",\n                \"terminal\": {\n                  \"$type\": \"RuleCall\",\n                  \"rule\": {\n                    \"$ref\": \"#/rules@6\"\n                  },\n                  \"arguments\": []", "                  },\n                  \"arguments\": []\n                }\n              }\n            ],\n            \"cardinality\": \"?\"\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,", "      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",", "    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"ScalarType\",\n      \"definition\": {\n        \"$type\": \"Assignment\",\n        \"feature\": \"element\",\n        \"operator\": \"+=\",\n        \"terminal\": {\n          \"$type\": \"Alternatives\",\n          \"elements\": [", "          \"$type\": \"Alternatives\",\n          \"elements\": [\n            {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@9\"\n              },\n              \"arguments\": []\n            },\n            {", "            },\n            {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@11\"\n              },\n              \"arguments\": []\n            }\n          ]\n        },", "          ]\n        },\n        \"cardinality\": \"*\"\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false", "      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"StringType\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {", "        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"<string\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"name=\"\n          },\n          {", "          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@20\"\n              },", "                \"$ref\": \"#/rules@20\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"description=\"\n          },\n          {", "          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"desc\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@22\"\n              },", "                \"$ref\": \"#/rules@22\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"format=\"\n          },\n          {", "          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"format\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@7\"\n              },", "                \"$ref\": \"#/rules@7\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Group\",\n            \"elements\": [\n              {\n                \"$type\": \"Keyword\",", "              {\n                \"$type\": \"Keyword\",\n                \"value\": \"on-fail-\"\n              },\n              {\n                \"$type\": \"Assignment\",\n                \"feature\": \"fail\",\n                \"operator\": \"=\",\n                \"terminal\": {\n                  \"$type\": \"RuleCall\",", "                \"terminal\": {\n                  \"$type\": \"RuleCall\",\n                  \"rule\": {\n                    \"$ref\": \"#/rules@10\"\n                  },\n                  \"arguments\": []\n                }\n              },\n              {\n                \"$type\": \"Keyword\",", "              {\n                \"$type\": \"Keyword\",\n                \"value\": \"=\"\n              },\n              {\n                \"$type\": \"Assignment\",\n                \"feature\": \"corrective\",\n                \"operator\": \"=\",\n                \"terminal\": {\n                  \"$type\": \"RuleCall\",", "                \"terminal\": {\n                  \"$type\": \"RuleCall\",\n                  \"rule\": {\n                    \"$ref\": \"#/rules@18\"\n                  },\n                  \"arguments\": []\n                }\n              }\n            ],\n            \"cardinality\": \"?\"", "            ],\n            \"cardinality\": \"?\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,", "      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",", "    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"OnFail\",\n      \"definition\": {\n        \"$type\": \"Assignment\",\n        \"feature\": \"fail\",\n        \"operator\": \"=\",\n        \"terminal\": {\n          \"$type\": \"RuleCall\",\n          \"rule\": {", "          \"$type\": \"RuleCall\",\n          \"rule\": {\n            \"$ref\": \"#/rules@15\"\n          },\n          \"arguments\": []\n        }\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,", "      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"IntegerType\",\n      \"definition\": {", "      \"name\": \"IntegerType\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"<integer\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"name=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",", "            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@20\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"description=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"desc\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",", "            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@22\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"format=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"format\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",", "            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@7\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Group\",", "          {\n            \"$type\": \"Group\",\n            \"elements\": [\n              {\n                \"$type\": \"Keyword\",\n                \"value\": \"on-fail-\"\n              },\n              {\n                \"$type\": \"Assignment\",\n                \"feature\": \"fail\",", "                \"$type\": \"Assignment\",\n                \"feature\": \"fail\",\n                \"operator\": \"=\",\n                \"terminal\": {\n                  \"$type\": \"RuleCall\",\n                  \"rule\": {\n                    \"$ref\": \"#/rules@10\"\n                  },\n                  \"arguments\": []\n                }", "                  \"arguments\": []\n                }\n              },\n              {\n                \"$type\": \"Keyword\",\n                \"value\": \"=\"\n              },\n              {\n                \"$type\": \"Assignment\",\n                \"feature\": \"corrective\",", "                \"$type\": \"Assignment\",\n                \"feature\": \"corrective\",\n                \"operator\": \"=\",\n                \"terminal\": {\n                  \"$type\": \"RuleCall\",\n                  \"rule\": {\n                    \"$ref\": \"#/rules@12\"\n                  },\n                  \"arguments\": []\n                }", "                  \"arguments\": []\n                }\n              }\n            ],\n            \"cardinality\": \"?\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          }", "            \"value\": \">\"\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false", "      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Corrective\",\n      \"definition\": {\n        \"$type\": \"Assignment\",\n        \"feature\": \"name\",\n        \"operator\": \"=\",", "        \"feature\": \"name\",\n        \"operator\": \"=\",\n        \"terminal\": {\n          \"$type\": \"RuleCall\",\n          \"rule\": {\n            \"$ref\": \"#/rules@18\"\n          },\n          \"arguments\": []\n        }\n      },", "        }\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Prompt\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"Keyword\",\n              \"value\": \"<prompt>\"\n            }\n          },\n          {\n            \"$type\": \"Assignment\",", "          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"prompt\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@22\"\n              },\n              \"arguments\": []", "              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"</prompt>\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Script\",\n      \"definition\": {\n        \"$type\": \"Group\",\n        \"elements\": [\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"name\",", "            \"$type\": \"Assignment\",\n            \"feature\": \"name\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"Keyword\",\n              \"value\": \"<script\"\n            }\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"language=\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"language\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",", "            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@17\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \">\"\n          },\n          {\n            \"$type\": \"Assignment\",\n            \"feature\": \"script\",\n            \"operator\": \"=\",\n            \"terminal\": {\n              \"$type\": \"RuleCall\",", "            \"terminal\": {\n              \"$type\": \"RuleCall\",\n              \"rule\": {\n                \"$ref\": \"#/rules@22\"\n              },\n              \"arguments\": []\n            }\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"</script>\"\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],", "      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"QualityCriteria\",\n      \"dataType\": \"string\",\n      \"definition\": {", "      \"dataType\": \"string\",\n      \"definition\": {\n        \"$type\": \"Alternatives\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"bug-free-python\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"bug-free-sql\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"choice\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"ends-with\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"exclude-sql-predicates\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"is-high-quality-translation\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"alt-profinity-check\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"lowe-case\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"one-line\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"similar-to-document\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"sql-column-presence\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"two-words\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"upper-case\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"valid-choices\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"lenght\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"valid-range\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"valid-url\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Version\",\n      \"dataType\": \"string\",\n      \"definition\": {\n        \"$type\": \"Alternatives\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"1.0\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"1.1\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"Languages\",\n      \"dataType\": \"string\",\n      \"definition\": {\n        \"$type\": \"Alternatives\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"python\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"typescript\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"c++\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"go\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"others\"\n          }\n        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],", "      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {\n      \"$type\": \"ParserRule\",\n      \"name\": \"CorrectiveAction\",\n      \"dataType\": \"string\",\n      \"definition\": {", "      \"dataType\": \"string\",\n      \"definition\": {\n        \"$type\": \"Alternatives\",\n        \"elements\": [\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"reask\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"fix\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"filter\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"refrain\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"noop\"\n          },\n          {\n            \"$type\": \"Keyword\",", "          {\n            \"$type\": \"Keyword\",\n            \"value\": \"exception\"\n          },\n          {\n            \"$type\": \"Keyword\",\n            \"value\": \"fix_reask\"\n          }\n        ]\n      },", "        ]\n      },\n      \"definesHiddenTokens\": false,\n      \"entry\": false,\n      \"fragment\": false,\n      \"hiddenTokens\": [],\n      \"parameters\": [],\n      \"wildcard\": false\n    },\n    {", "    },\n    {\n      \"$type\": \"TerminalRule\",\n      \"hidden\": true,\n      \"name\": \"WS\",\n      \"definition\": {\n        \"$type\": \"RegexToken\",\n        \"regex\": \"\\\\\\\\s+\"\n      },\n      \"fragment\": false", "      },\n      \"fragment\": false\n    },\n    {\n      \"$type\": \"TerminalRule\",\n      \"name\": \"ID\",\n      \"definition\": {\n        \"$type\": \"RegexToken\",\n        \"regex\": \"[_a-zA-Z][\\\\\\\\w_]*\"\n      },", "        \"regex\": \"[_a-zA-Z][\\\\\\\\w_]*\"\n      },\n      \"fragment\": false,\n      \"hidden\": false\n    },\n    {\n      \"$type\": \"TerminalRule\",\n      \"name\": \"INT\",\n      \"type\": {\n        \"$type\": \"ReturnType\",", "      \"type\": {\n        \"$type\": \"ReturnType\",\n        \"name\": \"number\"\n      },\n      \"definition\": {\n        \"$type\": \"RegexToken\",\n        \"regex\": \"[0-9]+\"\n      },\n      \"fragment\": false,\n      \"hidden\": false", "      \"fragment\": false,\n      \"hidden\": false\n    },\n    {\n      \"$type\": \"TerminalRule\",\n      \"name\": \"STRING\",\n      \"definition\": {\n        \"$type\": \"RegexToken\",\n        \"regex\": \"\\\\\"(\\\\\\\\\\\\\\\\.|[^\\\\\"\\\\\\\\\\\\\\\\])*\\\\\"|'(\\\\\\\\\\\\\\\\.|[^'\\\\\\\\\\\\\\\\])*'\"\n      },", "        \"regex\": \"\\\\\"(\\\\\\\\\\\\\\\\.|[^\\\\\"\\\\\\\\\\\\\\\\])*\\\\\"|'(\\\\\\\\\\\\\\\\.|[^'\\\\\\\\\\\\\\\\])*'\"\n      },\n      \"fragment\": false,\n      \"hidden\": false\n    },\n    {\n      \"$type\": \"TerminalRule\",\n      \"hidden\": true,\n      \"name\": \"ML_COMMENT\",\n      \"definition\": {", "      \"name\": \"ML_COMMENT\",\n      \"definition\": {\n        \"$type\": \"RegexToken\",\n        \"regex\": \"\\\\\\\\/\\\\\\\\*[\\\\\\\\s\\\\\\\\S]*?\\\\\\\\*\\\\\\\\/\"\n      },\n      \"fragment\": false\n    },\n    {\n      \"$type\": \"TerminalRule\",\n      \"hidden\": true,", "      \"$type\": \"TerminalRule\",\n      \"hidden\": true,\n      \"name\": \"SL_COMMENT\",\n      \"definition\": {\n        \"$type\": \"RegexToken\",\n        \"regex\": \"\\\\\\\\/\\\\\\\\/[^\\\\\\\\n\\\\\\\\r]*\"\n      },\n      \"fragment\": false\n    }\n  ],", "    }\n  ],\n  \"definesHiddenTokens\": false,\n  \"hiddenTokens\": [],\n  \"imports\": [],\n  \"interfaces\": [],\n  \"types\": [],\n  \"usedGrammars\": []\n}`));\n", "}`));\n"]}
{"filename": "src/language-server/generated/ast.ts", "chunked_list": ["/******************************************************************************\n * This file was generated by langium-cli 1.1.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\n/* eslint-disable */\nimport { AstNode, AbstractAstReflection, ReferenceInfo, TypeMetaData } from 'langium';\n\nexport type CorrectiveAction = 'exception' | 'filter' | 'fix' | 'fix_reask' | 'noop' | 'reask' | 'refrain';\n\nexport type Languages = 'c++' | 'go' | 'others' | 'python' | 'typescript';\n", "export type CorrectiveAction = 'exception' | 'filter' | 'fix' | 'fix_reask' | 'noop' | 'reask' | 'refrain';\n\nexport type Languages = 'c++' | 'go' | 'others' | 'python' | 'typescript';\n\nexport type NonScalarType = ListType | ObjectType;\n\nexport const NonScalarType = 'NonScalarType';\n\nexport function isNonScalarType(item: unknown): item is NonScalarType {\n    return reflection.isInstance(item, NonScalarType);\n}\n", "export function isNonScalarType(item: unknown): item is NonScalarType {\n    return reflection.isInstance(item, NonScalarType);\n}\n\nexport type QualityCriteria = 'alt-profinity-check' | 'bug-free-python' | 'bug-free-sql' | 'choice' | 'ends-with' | 'exclude-sql-predicates' | 'is-high-quality-translation' | 'lenght' | 'lowe-case' | 'one-line' | 'similar-to-document' | 'sql-column-presence' | 'two-words' | 'upper-case' | 'valid-choices' | 'valid-range' | 'valid-url';\n\nexport type Version = '1.0' | '1.1';\n\nexport interface Corrective extends AstNode {\n    readonly $container: IntegerType;\n    readonly $type: 'Corrective';\n    name: CorrectiveAction\n}\n\nexport const Corrective = 'Corrective';\n", "export interface Corrective extends AstNode {\n    readonly $container: IntegerType;\n    readonly $type: 'Corrective';\n    name: CorrectiveAction\n}\n\nexport const Corrective = 'Corrective';\n\nexport function isCorrective(item: unknown): item is Corrective {\n    return reflection.isInstance(item, Corrective);\n}\n", "export function isCorrective(item: unknown): item is Corrective {\n    return reflection.isInstance(item, Corrective);\n}\n\nexport interface Format extends AstNode {\n    readonly $container: Formats;\n    readonly $type: 'Format';\n    name: QualityCriteria\n}\n\nexport const Format = 'Format';\n", "export function isFormat(item: unknown): item is Format {\n    return reflection.isInstance(item, Format);\n}\n\nexport interface Formats extends AstNode {\n    readonly $container: IntegerType | ListType | ObjectType | StringType;\n    readonly $type: 'Formats';\n    format: Array<Format>\n}\n\nexport const Formats = 'Formats';\n", "export function isFormats(item: unknown): item is Formats {\n    return reflection.isInstance(item, Formats);\n}\n\nexport interface IntegerType extends AstNode {\n    readonly $container: ScalarType;\n    readonly $type: 'IntegerType';\n    corrective?: Corrective\n    desc: string\n    fail?: OnFail\n    format: Formats\n    name: string\n}\n\nexport const IntegerType = 'IntegerType';\n", "export function isIntegerType(item: unknown): item is IntegerType {\n    return reflection.isInstance(item, IntegerType);\n}\n\nexport interface ListType extends AstNode {\n    readonly $container: Output;\n    readonly $type: 'ListType';\n    elements: Array<ScalarType>\n    format: Formats\n    name: string\n}\n\nexport const ListType = 'ListType';\n", "export function isListType(item: unknown): item is ListType {\n    return reflection.isInstance(item, ListType);\n}\n\nexport interface Model extends AstNode {\n    readonly $type: 'Model';\n    rails: Rails\n    version: Version\n}\n\nexport const Model = 'Model';\n", "export function isModel(item: unknown): item is Model {\n    return reflection.isInstance(item, Model);\n}\n\nexport interface ObjectType extends AstNode {\n    readonly $container: Output;\n    readonly $type: 'ObjectType';\n    elements: Array<ScalarType>\n    format: Formats\n    name: string\n}\n\nexport const ObjectType = 'ObjectType';\n", "export function isObjectType(item: unknown): item is ObjectType {\n    return reflection.isInstance(item, ObjectType);\n}\n\nexport interface OnFail extends AstNode {\n    readonly $container: IntegerType | StringType;\n    readonly $type: 'OnFail';\n    fail: QualityCriteria\n}\n\nexport const OnFail = 'OnFail';\n", "export function isOnFail(item: unknown): item is OnFail {\n    return reflection.isInstance(item, OnFail);\n}\n\nexport interface Output extends AstNode {\n    readonly $container: Rails;\n    readonly $type: 'Output';\n    element: Array<NonScalarType>\n    name: '<output>'\n}\n\nexport const Output = 'Output';\n", "export function isOutput(item: unknown): item is Output {\n    return reflection.isInstance(item, Output);\n}\n\nexport interface Prompt extends AstNode {\n    readonly $container: Rails;\n    readonly $type: 'Prompt';\n    name: '<prompt>'\n    prompt: string\n}\n\nexport const Prompt = 'Prompt';\n", "export function isPrompt(item: unknown): item is Prompt {\n    return reflection.isInstance(item, Prompt);\n}\n\nexport interface Rails extends AstNode {\n    readonly $container: Model;\n    readonly $type: 'Rails';\n    output: Output\n    prompt: Prompt\n    script: Script\n}\n\nexport const Rails = 'Rails';\n", "export function isRails(item: unknown): item is Rails {\n    return reflection.isInstance(item, Rails);\n}\n\nexport interface ScalarType extends AstNode {\n    readonly $container: ListType | ObjectType;\n    readonly $type: 'ScalarType';\n    element: Array<IntegerType | StringType>\n}\n\nexport const ScalarType = 'ScalarType';\n", "export function isScalarType(item: unknown): item is ScalarType {\n    return reflection.isInstance(item, ScalarType);\n}\n\nexport interface Script extends AstNode {\n    readonly $container: Rails;\n    readonly $type: 'Script';\n    language: Languages\n    name: '<script'\n    script: string\n}\n\nexport const Script = 'Script';\n", "export function isScript(item: unknown): item is Script {\n    return reflection.isInstance(item, Script);\n}\n\nexport interface StringType extends AstNode {\n    readonly $container: ScalarType;\n    readonly $type: 'StringType';\n    corrective?: CorrectiveAction\n    desc: string\n    fail?: OnFail\n    format: Formats\n    name: string\n}\n\nexport const StringType = 'StringType';\n", "export function isStringType(item: unknown): item is StringType {\n    return reflection.isInstance(item, StringType);\n}\n\nexport interface RailsAstType {\n    Corrective: Corrective\n    Format: Format\n    Formats: Formats\n    IntegerType: IntegerType\n    ListType: ListType\n    Model: Model\n    NonScalarType: NonScalarType\n    ObjectType: ObjectType\n    OnFail: OnFail\n    Output: Output\n    Prompt: Prompt\n    Rails: Rails\n    ScalarType: ScalarType\n    Script: Script\n    StringType: StringType\n}\n", "export class RailsAstReflection extends AbstractAstReflection {\n\n    getAllTypes(): string[] {\n        return ['Corrective', 'Format', 'Formats', 'IntegerType', 'ListType', 'Model', 'NonScalarType', 'ObjectType', 'OnFail', 'Output', 'Prompt', 'Rails', 'ScalarType', 'Script', 'StringType'];\n    }\n\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\n        switch (subtype) {\n            case ListType:\n            case ObjectType: {\n                return this.isSubtype(NonScalarType, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n\n    getReferenceType(refInfo: ReferenceInfo): string {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n\n    getTypeMetaData(type: string): TypeMetaData {\n        switch (type) {\n            case 'Formats': {\n                return {\n                    name: 'Formats',\n                    mandatory: [\n                        { name: 'format', type: 'array' }\n                    ]\n                };\n            }\n            case 'ListType': {\n                return {\n                    name: 'ListType',\n                    mandatory: [\n                        { name: 'elements', type: 'array' }\n                    ]\n                };\n            }\n            case 'ObjectType': {\n                return {\n                    name: 'ObjectType',\n                    mandatory: [\n                        { name: 'elements', type: 'array' }\n                    ]\n                };\n            }\n            case 'Output': {\n                return {\n                    name: 'Output',\n                    mandatory: [\n                        { name: 'element', type: 'array' }\n                    ]\n                };\n            }\n            case 'ScalarType': {\n                return {\n                    name: 'ScalarType',\n                    mandatory: [\n                        { name: 'element', type: 'array' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    mandatory: []\n                };\n            }\n        }\n    }\n}\n\nexport const reflection = new RailsAstReflection();\n"]}
