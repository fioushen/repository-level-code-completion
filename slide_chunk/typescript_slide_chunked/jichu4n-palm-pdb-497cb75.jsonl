{"filename": "src/memo-database.ts", "chunked_list": ["import pick from 'lodash/pick';\nimport {\n  field,\n  SerializeOptions,\n  SObject,\n  SStringNT,\n  SUInt16BE,\n  SUInt8,\n} from 'serio';\nimport {AppInfoType, DatabaseHdrType, PdbDatabase, PdbRecord} from '.';", "} from 'serio';\nimport {AppInfoType, DatabaseHdrType, PdbDatabase, PdbRecord} from '.';\n\n/** MemoDB sort order. */\nexport enum MemoSortOrder {\n  MANUAL = 0,\n  ALPHABETICAL = 1,\n}\n\n/** MemoDB AppInfo block. */\nexport class MemoAppInfo extends AppInfoType {\n  @field(SUInt16BE)\n  private padding2 = 0;\n\n  /** Memo sort order.\n   *\n   * New for 2.0 memo application.\n   */\n  @field(SUInt8.enum(MemoSortOrder))\n  sortOrder = MemoSortOrder.MANUAL;\n\n  @field(SUInt8)\n  private padding3 = 0;\n\n  serialize(opts?: SerializeOptions) {", "export class MemoAppInfo extends AppInfoType {\n  @field(SUInt16BE)\n  private padding2 = 0;\n\n  /** Memo sort order.\n   *\n   * New for 2.0 memo application.\n   */\n  @field(SUInt8.enum(MemoSortOrder))\n  sortOrder = MemoSortOrder.MANUAL;\n\n  @field(SUInt8)\n  private padding3 = 0;\n\n  serialize(opts?: SerializeOptions) {", "    if (this.sortOrder < 0 || this.sortOrder > 1) {\n      throw new Error(`Invalid sort order: ${this.sortOrder}`);\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** A MemoDB record. */\nexport class MemoRecord extends PdbRecord {\n  /** Memo content. */\n  @field(SStringNT)\n  value = '';\n}\n\n/** MemoDB database.\n *\n * References:\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/memo.c\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Memo.pm\n */", "export class MemoRecord extends PdbRecord {\n  /** Memo content. */\n  @field(SStringNT)\n  value = '';\n}\n\n/** MemoDB database.\n *\n * References:\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/memo.c\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Memo.pm\n */", "export class MemoDatabase extends PdbDatabase.of(MemoRecord, MemoAppInfo) {\n  header = DatabaseHdrType.with({\n    name: 'MemoDB',\n    type: 'DATA',\n    creator: 'memo',\n  });\n}\n"]}
{"filename": "src/date-time.ts", "chunked_list": ["import {\n  DeserializeOptions,\n  SUInt16BE,\n  SerializableWrapper,\n  SerializeOptions,\n} from 'serio';\n\n/** Standard epoch on Palm OS -- 1904/1/1. */\nexport const PDB_EPOCH = new Date('1904-01-01T00:00:00.000Z');\n/** Standard UNIX epoch. */", "export const PDB_EPOCH = new Date('1904-01-01T00:00:00.000Z');\n/** Standard UNIX epoch. */\nexport const UNIX_EPOCH = new Date(0);\n\n/** Epoch that a DatabaseTimestamp value is based on. */\nexport enum EpochType {\n  /** Standard epoch on Palm OS -- 1904/1/1. */\n  PDB = 'pdb',\n  /** UNIX epoch -- 1970/1/1. */\n  UNIX = 'unix',\n}\n\n/** A timestamp value.\n *\n * References:\n *   - https://wiki.mobileread.com/wiki/PDB#PDB_Times\n */", "export class DatabaseTimestamp extends SerializableWrapper<Date> {\n  /** JavaScript Date value corresponding to the time. */\n  value: Date = new Date();\n  /** The epoch to use when serializing this date. */\n  epochType = EpochType.PDB;\n\n  /** Parses a PDB timestamp.\n   *\n   * If the time has the top bit set, it's an unsigned 32-bit number counting\n   * from 1st Jan 1904.\n   *\n   * If the time has the top bit clear, it's a signed 32-bit number counting\n   * from 1st Jan 1970.\n   */\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    let ts = buffer.readUInt32BE();", "    if (ts === 0 || ts & (1 << 31)) {\n      this.epochType = EpochType.PDB;\n      this.value.setTime(PDB_EPOCH.getTime() + ts * 1000);\n    } else {\n      this.epochType = EpochType.UNIX;\n      ts = buffer.readInt32BE();\n      this.value.setTime(ts * 1000);\n    }\n\n    return 4;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    const buffer = Buffer.alloc(4);\n    switch (this.epochType) {\n      case EpochType.PDB:\n        buffer.writeUInt32BE(\n          (this.value.getTime() - PDB_EPOCH.getTime()) / 1000\n        );\n        break;\n      case EpochType.UNIX:\n        buffer.writeInt32BE(this.value.getTime() / 1000);\n        break;\n      default:\n        throw new Error(`Unknown epoch type: ${this.epochType}`);\n    }\n    return buffer;\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return 4;\n  }\n}\n\n/** DatabaseTimestamp corresponding to epochDate. */\nexport const EPOCH_TIMESTAMP = DatabaseTimestamp.of(PDB_EPOCH);\n\n/** A date (year, month, DOM) encoded as a 16-bit integer.\n *\n * There is no timezone information in the serialized form, so we assume UTC\n * when converting to / from JavaScript Date objects.\n */", "export class DatabaseDate extends SerializableWrapper<Date> {\n  /** Year. */\n  year = PDB_EPOCH.getUTCFullYear();\n  /** Month (Jan = 0, Dec = 11). */\n  month = 0;\n  /** Day of the month (1st = 1). */\n  dayOfMonth = 1;\n\n  get value() {\n    return new Date(Date.UTC(this.year, this.month, this.dayOfMonth));\n  }\n  set value(newValue: Date) {\n    this.year = newValue.getUTCFullYear();\n    this.month = newValue.getUTCMonth();\n    this.dayOfMonth = newValue.getUTCDate();\n  }\n\n  serialize(opts?: SerializeOptions) {", "    if (this.year < PDB_EPOCH.getUTCFullYear()) {\n      throw new Error(`Invalid year: ${this.year}`);\n    }\n    if (this.month < 0 || this.month > 11) {\n      throw new Error(`Invalid month: ${this.month}`);\n    }\n    if (this.dayOfMonth < 1 || this.dayOfMonth > 31) {\n      throw new Error(`Invalid day of month: ${this.dayOfMonth}`);\n    }\n    return SUInt16BE.of(\n      ((this.year - PDB_EPOCH.getUTCFullYear()) << 9) |\n        ((this.month + 1) << 5) |\n        this.dayOfMonth\n    ).serialize();\n  }\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const {value: v} = SUInt16BE.from(buffer, opts);\n\n    // upper 7 bits => year since 1904\n    this.year = ((v >> 9) & 0x7f) + PDB_EPOCH.getUTCFullYear();\n    // 4 bits => month\n    this.month = ((v >> 5) & 0x0f) - 1;\n    // 5 bits => date\n    this.dayOfMonth = v & 0x1f;\n\n    return this.getSerializedLength(opts);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return 2;\n  }\n\n  toJSON() {\n    return this.value.toISOString();\n  }\n}\n\n/** DatabaseDate wrapper where the value may be unspecified (indicated by 0xff). */", "export class OptionalDatabaseDate extends SerializableWrapper<DatabaseDate | null> {\n  /** DatabaseDate value, or null if unspecified.*/\n  value: DatabaseDate | null = null;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const dateValue = buffer.readUInt16BE();\n    this.value = dateValue === 0xffff ? null : DatabaseDate.from(buffer, opts);\n    return this.getSerializedLength(opts);\n  }\n\n  serialize(opts?: SerializeOptions) {\n    return this.value ? this.value.serialize(opts) : Buffer.of(0xff, 0xff);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return 2;\n  }\n}\n"]}
{"filename": "src/record.ts", "chunked_list": ["import {field, SBuffer, Serializable, SObject} from 'serio';\nimport {EntryType, RecordEntryType, RsrcEntryType} from './database-header';\n\n/** Base class of records in a PDB or PRC database. */\nexport abstract class Record<EntryT extends EntryType> extends Serializable {\n  /** Record entry stored in the database header. */\n  abstract entry: EntryT;\n}\n\n/** Base class of records in a PDB database. */\nexport abstract class PdbRecord\n  extends SObject\n  implements Record<RecordEntryType>\n{\n  entry = new RecordEntryType();\n\n  toJSON() {\n    return {\n      entry: this.entry,\n      ...super.toJSON(),\n    };\n  }\n}\n", "/** Base class of records in a PDB database. */\nexport abstract class PdbRecord\n  extends SObject\n  implements Record<RecordEntryType>\n{\n  entry = new RecordEntryType();\n\n  toJSON() {\n    return {\n      entry: this.entry,\n      ...super.toJSON(),\n    };\n  }\n}\n", "/** Base class of records in a PRC database. */\nexport abstract class PrcRecord\n  extends SObject\n  implements Record<RsrcEntryType>\n{\n  entry = new RsrcEntryType();\n\n  toJSON() {\n    return {\n      entry: this.entry,\n      ...super.toJSON(),\n    };\n  }\n}\n\n/** PDB database record that simply stores record data in a Buffer. */", "export class RawPdbRecord extends PdbRecord {\n  @field(SBuffer)\n  data = Buffer.of();\n}\n\n/** PRC database record that simply stores record data in a Buffer. */\nexport class RawPrcRecord extends PrcRecord {\n  @field(SBuffer)\n  data = Buffer.of();\n}\n"]}
{"filename": "src/palmdoc-database.ts", "chunked_list": ["import {\n  decodeString,\n  DeserializeOptions,\n  encodeString,\n  Serializable,\n  SerializeOptions,\n  SObject,\n} from 'serio';\nimport {SmartBuffer} from 'smart-buffer';\nimport {DatabaseHdrType, DEFAULT_ENCODING, PdbDatabase, RawPdbRecord} from '.';", "import {SmartBuffer} from 'smart-buffer';\nimport {DatabaseHdrType, DEFAULT_ENCODING, PdbDatabase, RawPdbRecord} from '.';\n\n/** PalmDOC document. */\nexport class PalmDoc extends SObject {\n  /** Document name (typically the file name). */\n  name = 'doc.txt';\n  /** Text content. */\n  text = '';\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    opts = {encoding: DEFAULT_ENCODING, ...opts};\n    const numBytes = this.db.deserialize(buffer, opts);\n    this.name = this.db.header.name;", "    if (this.db.records.length === 0) {\n      throw new Error(`PalmDOC metadata record missing`);\n    }\n    this.metadata.deserialize(this.db.records[0].data, opts);\n    this.textInDb = this.db.records\n      .slice(1, this.metadata.numRecords + 1)\n      .map(({data: data}) =>\n        decodeString(\n          this.metadata.isCompressed ? PalmDoc.decompress(data) : data,\n          opts\n        )\n      )\n      .join('');\n    this.text = this.textInDb;\n    return numBytes;\n  }\n\n  serialize(opts?: PalmDocSerializeOptions) {\n    opts = {encoding: DEFAULT_ENCODING, ...opts};\n    this.db.header.name = this.name;", "    if (this.text !== this.textInDb) {\n      this.db.records = [];\n\n      // Split text into 4096-byte chunks, compress, and add to DB.\n      const encodedText = encodeString(this.text, opts);\n      for (let i = 0; i < encodedText.length; i += PALM_DOC_RECORD_SIZE) {\n        const encodedTextChunk = encodedText.subarray(\n          i,\n          i + PALM_DOC_RECORD_SIZE\n        );\n        const record = RawPdbRecord.with({\n          data: opts?.enableCompression\n            ? PalmDoc.compress(encodedTextChunk)\n            : encodedTextChunk,\n        });\n        this.db.records.push(record);\n      }\n\n      // Add metadata record.\n      this.metadata.isCompressed = !!opts?.enableCompression;\n      this.metadata.textLength = this.text.length;\n      this.metadata.numRecords = this.db.records.length;", "        const record = RawPdbRecord.with({\n          data: opts?.enableCompression\n            ? PalmDoc.compress(encodedTextChunk)\n            : encodedTextChunk,\n        });\n        this.db.records.push(record);\n      }\n\n      // Add metadata record.\n      this.metadata.isCompressed = !!opts?.enableCompression;\n      this.metadata.textLength = this.text.length;\n      this.metadata.numRecords = this.db.records.length;", "      if (\n        this.metadata.position < 0 ||\n        this.metadata.position >= this.text.length\n      ) {\n        this.metadata.position = 0;\n      }\n      const metadataRecord = RawPdbRecord.with({\n        data: this.metadata.serialize(opts),\n      });\n      this.db.records.unshift(metadataRecord);\n\n      this.textInDb = this.text;\n    }\n    return this.db.serialize(opts);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return this.serialize(opts).length;\n  }\n\n  /** Database corresponding to this document.\n   *\n   * Updated during serialize().\n   */\n  private readonly db = new PalmDocDatabase();\n  /** Text corresponding to db. */\n  private textInDb = '';\n  /** Metadata stored in the first record of a PalmDOC database. */\n  private metadata: PalmDocMetadata = new PalmDocMetadata();\n\n  /** PalmDOC LZ77 decompression algorithm.\n   *\n   * References:\n   *   - https://metacpan.org/release/EBook-Tools/source/lib/EBook/Tools/PalmDoc.pm\n   */\n  static decompress(buffer: Buffer): Buffer {\n    const reader = SmartBuffer.fromBuffer(buffer);\n    const writer = new SmartBuffer();", "    while (reader.remaining() > 0) {\n      const byte1 = reader.readUInt8();\n      if (byte1 === 0x00) {\n        // 0x00: \"1 literal\" copy that byte unmodified to the decompressed stream.\n        writer.writeUInt8(byte1);\n      } else if (byte1 <= 0x08) {\n        // 0x01 to 0x08: \"literals\": the byte is interpreted as a count from 1 to\n        // 8, and that many literals are copied unmodified from the compressed\n        // stream to the decompressed stream.\n        writer.writeBuffer(reader.readBuffer(byte1));\n      } else if (byte1 <= 0x7f) {\n        // 0x09 to 0x7f: \"1 literal\" copy that byte unmodified to the decompressed\n        // stream.\n        writer.writeUInt8(byte1);", "      } else if (byte1 <= 0x7f) {\n        // 0x09 to 0x7f: \"1 literal\" copy that byte unmodified to the decompressed\n        // stream.\n        writer.writeUInt8(byte1);\n      } else if (byte1 <= 0xbf) {\n        // 0x80 to 0xbf: \"length, distance\" pair: the 2 leftmost bits of this byte\n        // ('10') are discarded, and the following 6 bits are combined with the 8\n        // bits of the next byte to make a 14 bit \"distance, length\" item. Those\n        // 14 bits are broken into 11 bits of distance backwards from the current\n        // location in the uncompressed text, and 3 bits of length to copy from\n        // that point (copying n+3 bytes, 3 to 10 bytes).\n        const byte2 = reader.readUInt8();\n        const distance =\n          ((byte1 & 0x3f) << 5) | // lower 6 bits\n          ((byte2 & 0xf8) >> 3); // upper 5 bits\n        const length =\n          (byte2 & 0x7) + // lower 3 bits\n          3;", "        if (writer.writeOffset - distance < 0) {\n          throw new Error(\n            'Invalid encoding: ' +\n              `distance = ${distance}, length = ${length}, decoded text length = ${writer.writeOffset}`\n          );\n        }\n        writer.readOffset = writer.writeOffset - distance;\n        if (writer.readOffset + length < writer.writeOffset) {\n          writer.writeBuffer(writer.readBuffer(length));\n        } else {\n          // It's possible that the \"length, distance\" pair references bytes that\n          // have not been decoded yet.", "          for (let i = 0; i < length; ++i) {\n            writer.writeUInt8(writer.readUInt8());\n          }\n        }\n      } else if (byte1 <= 0xff) {\n        // 0xc0 to 0xff: \"byte pair\": this byte is decoded into 2 characters: a\n        // space character, and a letter formed from this byte XORed with 0x80.\n        writer.writeUInt8(' '.charCodeAt(0));\n        writer.writeUInt8(byte1 ^ 0x80);\n      }\n    }\n\n    return writer.toBuffer();\n  }\n\n  /** PalmDOC LZ77 compression algorithm.\n   *\n   * References:\n   *   - https://metacpan.org/release/EBook-Tools/source/lib/EBook/Tools/PalmDoc.pm\n   */\n  static compress(buffer: Buffer): Buffer {\n    const reader = SmartBuffer.fromBuffer(buffer);\n    const writer = new SmartBuffer();\n", "    while (reader.remaining() > 0) {\n      const {readOffset} = reader;\n\n      // 1. Try 2-byte \"length, distance pair\" encoding.\n      if (readOffset >= 3 && reader.remaining() >= 3) {\n        let chunk = reader.readBuffer(Math.min(10, reader.remaining()));\n        // Prev occurrence must be within 2047 byte window.\n        const windowStartPos = Math.max(0, readOffset - 2047);\n        const window = buffer.subarray(windowStartPos, readOffset);\n        let prevOccurrencePos = -1;\n        do {\n          prevOccurrencePos = window.lastIndexOf(chunk);", "          if (prevOccurrencePos >= 0) {\n            prevOccurrencePos += windowStartPos;\n            break;\n          } else {\n            chunk = chunk.subarray(0, chunk.length - 1);\n          }\n        } while (chunk.length >= 3);\n\n        if (prevOccurrencePos >= 0) {\n          const distance = readOffset - prevOccurrencePos;\n          if (distance < 0 || distance > 2047) {\n            throw new Error(\n              `Distance out of range: ${distance}\\n` +\n                `readOffset = ${readOffset}, ` +\n                `prevOccurrencePos = ${prevOccurrencePos}, ` +\n                `chunk = \"${chunk.toString('latin1')}\"\\n` +\n                'This is a programming error. Please file an issue!'\n            );\n          }\n          const {length} = chunk;", "        if (prevOccurrencePos >= 0) {\n          const distance = readOffset - prevOccurrencePos;\n          if (distance < 0 || distance > 2047) {\n            throw new Error(\n              `Distance out of range: ${distance}\\n` +\n                `readOffset = ${readOffset}, ` +\n                `prevOccurrencePos = ${prevOccurrencePos}, ` +\n                `chunk = \"${chunk.toString('latin1')}\"\\n` +\n                'This is a programming error. Please file an issue!'\n            );\n          }\n          const {length} = chunk;", "          if (length < 3 || length > 10) {\n            throw new Error(\n              `Length out of range: ${length}\\n` +\n                'This is a programming error. Please file an issue!'\n            );\n          }\n          const byte1 =\n            0x80 | // upper two bits = '10'\n            ((distance >> 5) & 0x3f); // upper 6 bits of distance as 11-bit integer\n          writer.writeUInt8(byte1);\n          const byte2 =\n            ((distance & 0x1f) << 3) | // lower 5 bits of distance\n            ((length - 3) & 0x7); // length as 3-bit integer\n          writer.writeUInt8(byte2);\n          reader.readOffset = readOffset + length;\n          continue;\n        } else {\n          reader.readOffset = readOffset;\n          // fall through\n        }\n      }\n\n      // Consume next byte.\n      let byte1 = reader.readUInt8();\n\n      // 2. Try 2-byte \"space, char XOR 0x80\" encoding.", "      if (byte1 === ' '.charCodeAt(0) && reader.remaining() >= 1) {\n        const byte2 = reader.readUInt8();\n        if (byte2 >= 0x40 && byte2 <= 0x7f) {\n          writer.writeUInt8(byte2 ^ 0x80);\n          continue;\n        } else {\n          --reader.readOffset;\n          // fall through\n        }\n      }\n\n      // 3. Try 1-byte literal encoding.", "      if (byte1 === 0 || (byte1 >= 0x9 && byte1 <= 0x7f)) {\n        writer.writeUInt8(byte1);\n        continue;\n      }\n\n      // 4. Fall through to multi-byte literal encoding.\n      {\n        const chunk = reader.readBuffer(Math.min(7, reader.remaining()));\n        writer.writeUInt8(chunk.length + 1); // length including byte1\n        writer.writeUInt8(byte1);\n        writer.writeBuffer(chunk);\n        continue;\n      }\n    }\n\n    return writer.toBuffer();\n  }\n}\n\n/** Serialization options for PalmDoc. */", "export interface PalmDocSerializeOptions extends SerializeOptions {\n  /** Whether to compress the text. */\n  enableCompression?: boolean;\n}\n\n/** Maximum size of each record containing text. */\nconst PALM_DOC_RECORD_SIZE = 4096;\n\n/** Metadata stored in the first record of a PalmDOC database. */\nexport class PalmDocMetadata extends Serializable {\n  /** Whether the text is compressed. */\n  isCompressed = true;\n  /** Uncompressed length of the text. */\n  textLength = 0;\n  /** Number of records used for storing text. */\n  numRecords = 0;\n  /** Current reading position, as an offset into the uncompressed text. */\n  position = 0;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const reader = SmartBuffer.fromBuffer(buffer);\n\n    const compressionLevel = reader.readUInt16BE();\n    switch (compressionLevel) {\n      case 1:\n        this.isCompressed = false;\n        break;\n      case 2:\n        this.isCompressed = true;\n        break;\n      default:\n        throw new Error(`Unknown compression level: ${compressionLevel}`);\n    }\n    reader.readUInt16BE(); // Padding bytes\n\n    this.textLength = reader.readUInt32BE();\n\n    this.numRecords = reader.readUInt16BE();\n\n    const recordSize = reader.readUInt16BE();", "export class PalmDocMetadata extends Serializable {\n  /** Whether the text is compressed. */\n  isCompressed = true;\n  /** Uncompressed length of the text. */\n  textLength = 0;\n  /** Number of records used for storing text. */\n  numRecords = 0;\n  /** Current reading position, as an offset into the uncompressed text. */\n  position = 0;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const reader = SmartBuffer.fromBuffer(buffer);\n\n    const compressionLevel = reader.readUInt16BE();\n    switch (compressionLevel) {\n      case 1:\n        this.isCompressed = false;\n        break;\n      case 2:\n        this.isCompressed = true;\n        break;\n      default:\n        throw new Error(`Unknown compression level: ${compressionLevel}`);\n    }\n    reader.readUInt16BE(); // Padding bytes\n\n    this.textLength = reader.readUInt32BE();\n\n    this.numRecords = reader.readUInt16BE();\n\n    const recordSize = reader.readUInt16BE();", "    if (recordSize !== PALM_DOC_RECORD_SIZE) {\n      throw new Error(`Unexpected record size: ${recordSize}`);\n    }\n    this.position = reader.readUInt32BE();\n\n    return reader.readOffset;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    const writer = SmartBuffer.fromSize(this.getSerializedLength(opts));\n    writer.writeUInt16BE(this.isCompressed ? 2 : 1);\n    writer.writeUInt16BE(0); // Padding bytes\n    writer.writeUInt32BE(this.textLength);\n    writer.writeUInt16BE(this.numRecords);\n    writer.writeUInt16BE(PALM_DOC_RECORD_SIZE);\n    writer.writeUInt32BE(this.position);\n    return writer.toBuffer();\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return 16;\n  }\n}\n\n/** PalmDOC database.*/", "export class PalmDocDatabase extends PdbDatabase.of(RawPdbRecord) {\n  header = DatabaseHdrType.with({\n    name: 'Document',\n    type: 'TEXt',\n    creator: 'REAd',\n  });\n}\n"]}
{"filename": "src/database-header.ts", "chunked_list": ["import {\n  bitfield,\n  field,\n  SBitmask,\n  Serializable,\n  SObject,\n  SStringNT,\n  SUInt16BE,\n  SUInt32BE,\n  SUInt8,", "  SUInt32BE,\n  SUInt8,\n} from 'serio';\nimport {DatabaseTimestamp, EPOCH_TIMESTAMP} from './date-time';\nimport {LocalId, RecordId, SDynamicArray, TypeId} from './util';\nimport pick from 'lodash/pick';\n\n/** Maximum length of database names - 31 chars + 1 NUL byte.\n *\n * References:", " *\n * References:\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataMgr.h#L72\n */\nexport const DB_NAME_LENGTH = 32;\n\n/** Database header.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf", " * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L67\n */\nexport class DatabaseHdrType extends SObject {\n  /** Database name. */\n  @field(SStringNT.ofLength(DB_NAME_LENGTH))\n  name = '';\n\n  /** Database attribute flags. */\n  @field()\n  attributes: DatabaseAttrs = new DatabaseAttrs();\n\n  /** Database version (integer). */\n  @field(SUInt16BE)\n  version = 0;\n\n  /** Database creation timestamp. */\n  @field()\n  creationDate = new DatabaseTimestamp();\n\n  /** Database modification timestamp. */\n  @field()\n  modificationDate = new DatabaseTimestamp();\n\n  /** Last backup timestamp. */\n  @field()\n  lastBackupDate: DatabaseTimestamp = EPOCH_TIMESTAMP;\n\n  /** Modification number (integer). */\n  @field(SUInt32BE)\n  modificationNumber = 0;\n\n  /** Offset to AppInfo block. */\n  @field(LocalId)\n  appInfoId = 0;\n\n  /** Offset to SortInfo block. */\n  @field(LocalId)\n  sortInfoId = 0;\n", "  /** Database type identifier (max 4 bytes). */\n  @field(TypeId)\n  type = '';\n\n  /** Database creator identifier (max 4 bytes). */\n  @field(TypeId)\n  creator = '';\n\n  /** Seed for generating record IDs. */\n  @field(SUInt32BE)\n  uniqueIdSeed = 0;\n}\n\n/** Record entry in PDB files.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L23\n */", "export class RecordEntryType extends SObject {\n  /** Offset to raw record data. */\n  @field(LocalId)\n  localChunkId = 0;\n\n  /** Record attributes. */\n  @field()\n  attributes = new RecordAttrs();\n\n  /** Unique ID of the record.\n   *\n   * Valid records should have a non-zero unique ID.\n   */\n  @field(RecordId)\n  uniqueId = 0;\n}\n\n/** Resource entry in PRC files.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L36\n */", "export class RsrcEntryType extends SObject {\n  /** Resource type identifier (max 4 bytes). */\n  @field(TypeId)\n  type = '';\n\n  /** Resource ID. */\n  @field(SUInt16BE)\n  resourceId = 0;\n\n  /** Offset to raw record data. */\n  @field(LocalId)\n  localChunkId = 0;\n}\n", "/** Union type representing any record entry type. */\nexport type EntryType = RecordEntryType | RsrcEntryType;\n\n/** Record or resource entry list. */\nexport interface RecordListType<EntryT extends EntryType> extends Serializable {\n  /** Array of record or resource entries. */\n  values: Array<EntryT>;\n}\n\n/** Record entry list in PDB databases.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L51\n */", "export class PdbRecordListType\n  extends SObject\n  implements RecordListType<RecordEntryType>\n{\n  /** Offset of next PdbRecordListType structure.\n   *\n   * We don't support multiple RecordListTypes, so this must always be 0. See\n   * page 17 of the Palm File Format Specification for more details.\n   */\n  @field(SUInt32BE)\n  private readonly nextListId = 0;\n\n  /** Array of record entries. */\n  @field(SDynamicArray.of(SUInt16BE, RecordEntryType))\n  values: Array<RecordEntryType> = [];\n\n  @field(SUInt16BE)\n  private readonly padding1 = 0;\n}\n\n/** Resource entry list in PRC databases.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L51\n */", "export class PrcRecordListType\n  extends SObject\n  implements RecordListType<RsrcEntryType>\n{\n  /** Offset of next PrcRecordListType structure.\n   *\n   * We don't support multiple RecordListTypes, so this must always be 0. See\n   * page 17 of the Palm File Format Specification for more details.\n   */\n  @field(SUInt32BE)\n  private readonly nextListId = 0;\n\n  /** Array of resource entries. */\n  @field(SDynamicArray.of(SUInt16BE, RsrcEntryType))\n  values: Array<RsrcEntryType> = [];\n\n  @field(SUInt16BE)\n  private readonly padding1 = 0;\n}\n\n/** Database attribute flags.\n *\n * References:\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r4/include/Core/System/DataMgr.h\n *   - https://github.com/madsen/Palm-PDB/blob/master/lib/Palm/PDB.pm\n */", "export class DatabaseAttrs extends SBitmask.of(SUInt16BE) {\n  /** Database not closed properly. */\n  @bitfield(1)\n  open = false;\n  @bitfield(3)\n  private unused1 = 0;\n  /** This database (resource or record) is associated with the application\n   * with the same creator. It will be beamed and copied along with the\n   * application. */\n  @bitfield(1)\n  bundle = false;\n  /** This database (resource or record) is recyclable: it will be deleted Real\n   * Soon Now, generally the next time the database is closed. */\n  @bitfield(1)\n  recyclable = false;\n  /** This data database (not applicable for executables) can be \"launched\" by\n   * passing its name to it's owner app ('appl' database with same creator)\n   * using the sysAppLaunchCmdOpenNamedDB action code. */\n  @bitfield(1)\n  launchableData = false;\n  /** This database should generally be hidden from view.\n   *\n   * Used to hide some apps from the main view of the launcher for example. For\n   * data (non-resource) databases, this hides the record count within the\n   * launcher info screen. */\n  @bitfield(1)\n  hidden = false;\n  /** This database is used for file stream implementation. */\n  @bitfield(1)\n  stream = false;\n  /** This database should not be copied to */\n  @bitfield(1)\n  copyPrevention = false;\n  /** Device requires a reset after this database is installed. */\n  @bitfield(1)\n  resetAfterInstall = false;\n  /** This tells the backup conduit that it's OK for it to install a newer version\n   * of this database with a different name if the current database is open. This\n   * mechanism is used to update the Graffiti Shortcuts database, for example.\n   */\n  @bitfield(1)\n  okToInstallNewer = false;\n  /** Set if database should be backed up to PC if no app-specific synchronization\n   * conduit has been supplied. */\n  @bitfield(1)\n  backup = false;\n  /** Set if Application Info block is dirty.\n   *\n   * Optionally supported by an App's conduit. */\n  @bitfield(1)\n  appInfoDirty = false;\n  /** Read Only database. */\n  @bitfield(1)\n  readOnly = false;\n  /** Whether this is a resource database (i.e. PRC). */\n  @bitfield(1)\n  resDB = false;\n}\n\n/** Record attribute flags in PDB files.\n *\n * In the DLP protocol, we use one byte to store record attribute flags and\n * another byte to store the record category. However, in PDB files, we use a\n * single byte is used to store both attribute flags and the record category.\n *\n * This presents a problem: there are 5 record attributes (namely delete, dirty,\n * busy, secret, and archive), leaving 3 bits unused, but we need 4 bits to\n * store the record category. So the lowest 4 bits are overloaded, but the\n * exactly how differs among existing open source implementations:\n *\n * In pilot-link:\n *   - Upper 4 bits store the first 4 record attributes (delete, dirty, busy, secret)\n *   - Lower 4 bits store the record category; there's no archive bit\n *\n * In ColdSync:\n *   - If the record is busy, bit 5 stores the archive flag and the lowest 3\n *     bits are unused.\n *   - If the record is not busy, the lowest 4 bits store the category.\n *\n * In the Palm::PDB Perl module:\n *   - If the record is deleted or busy, bit 5 stores the archive flag and the\n *     lowest 3 bits are unused.\n *   - If the record is neither deleted or busy, the lowest 4 bits store the\n *     category.\n *\n * Here we've chosen to follow the Palm::PDB Perl module's implementation, as it\n * is the most flexible.\n *\n * References:\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r4/include/Core/System/DataMgr.h#L44\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r4/include/Core/System/DLCommon.h#L44\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L670\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L479\n *   - https://github.com/dwery/coldsync/blob/master/libpdb/pdb.c#L96\n *   - https://metacpan.org/dist/Palm-PDB/source/lib/Palm/PDB.pm#L428\n */", "export class RecordAttrs extends SBitmask.of(SUInt8) {\n  /** Record has been deleted. */\n  @bitfield(1)\n  delete = false;\n  /** Record has been modified. */\n  @bitfield(1)\n  dirty = false;\n  /** Record currently in use.\n   *\n   * This bit may also indicate the record has been deleted -- see comments in\n   * https://github.com/dwery/coldsync/blob/master/include/pdb.h .\n   */\n  @bitfield(1)\n  busy = false;\n  /** \"Secret\" record - password protected. */\n  @bitfield(1)\n  secret = false;\n\n  @bitfield(4)\n  private lowest4bits = 0;\n\n  /** Record is archived.\n   *\n   * Only available if deleted or busy.\n   */\n  get archive() {", "    if (this.delete || this.busy) {\n      return Boolean(this.lowest4bits & 0b1000);\n    } else {\n      return false;\n    }\n  }\n  set archive(newValue: boolean) {\n    if (!(this.delete || this.busy)) {\n      throw new Error(\n        `Attempting to set archive = ${newValue} ` +\n          `on record that is neither deleted nor busy`\n      );\n    }\n    this.lowest4bits = newValue\n      ? this.lowest4bits | 0b1000\n      : this.lowest4bits & 0b0111;\n  }\n\n  /** Record category.\n   *\n   * Only available if NOT deleted or busy.\n   */\n  get category() {", "    if (this.delete || this.busy) {\n      return 0;\n    } else {\n      return this.lowest4bits;\n    }\n  }\n  set category(newValue: number) {\n    if (this.delete || this.busy) {\n      const recordState =\n        this.delete && this.busy\n          ? 'deleted and busy'\n          : this.delete\n          ? 'deleted'\n          : 'busy';\n      throw new Error(\n        `Attempting to set category ${newValue} on record ` +\n          `that is currently ${recordState}`\n      );\n    }\n    this.lowest4bits = newValue & 0b1111;\n  }\n}\n"]}
{"filename": "src/todo-database.ts", "chunked_list": ["import pick from 'lodash/pick';\nimport {\n  DeserializeOptions,\n  field,\n  SerializeOptions,\n  SStringNT,\n  SUInt16BE,\n  SUInt8,\n} from 'serio';\nimport {", "} from 'serio';\nimport {\n  AppInfoType,\n  DatabaseDate,\n  DatabaseHdrType,\n  OptionalDatabaseDate,\n  PdbDatabase,\n  PdbRecord,\n} from '.';\n", "} from '.';\n\n/** ToDoDB item sort order. */\nexport enum ToDoSortOrder {\n  MANUAL = 0,\n  PRIORITY = 1,\n}\n\n/** ToDoDB AppInfo block. */\nexport class ToDoAppInfo extends AppInfoType {\n  /** Not sure what this is \u00af\\_(\u30c4)_/\u00af */\n  @field(SUInt16BE)\n  private dirty = 0;\n\n  /** Item sort order. */\n  @field(SUInt8.enum(ToDoSortOrder))\n  sortOrder = ToDoSortOrder.MANUAL;\n\n  @field(SUInt8)\n  private padding2 = 0;\n\n  serialize(opts?: SerializeOptions) {", "export class ToDoAppInfo extends AppInfoType {\n  /** Not sure what this is \u00af\\_(\u30c4)_/\u00af */\n  @field(SUInt16BE)\n  private dirty = 0;\n\n  /** Item sort order. */\n  @field(SUInt8.enum(ToDoSortOrder))\n  sortOrder = ToDoSortOrder.MANUAL;\n\n  @field(SUInt8)\n  private padding2 = 0;\n\n  serialize(opts?: SerializeOptions) {", "    if (this.sortOrder < 0 || this.sortOrder > 1) {\n      throw new Error(`Invalid sort order: ${this.sortOrder}`);\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** A ToDoDB record. */\nexport class ToDoRecord extends PdbRecord {\n  /** Due date of the item (may be empty if there is no due date). */\n  @field(OptionalDatabaseDate)\n  dueDate: DatabaseDate | null = null;\n\n  /** Attributes byte. */\n  @field(SUInt8)\n  private attrs = 0;\n\n  /** Whether the item is completed. Stored inside attrs. */\n  isCompleted = false;\n\n  /** Priority of the item (max 127). Stored inside attrs. */\n  priority = 0;\n\n  /** Main description. */\n  @field(SStringNT)\n  description = '';\n\n  /** Additional note. */\n  @field(SStringNT)\n  note = '';\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const readOffset = super.deserialize(buffer, opts);\n    this.isCompleted = !!(this.attrs & 0x80);\n    this.priority = this.attrs & 0x7f;\n    return readOffset;\n  }\n\n  serialize(opts?: SerializeOptions) {", "export class ToDoRecord extends PdbRecord {\n  /** Due date of the item (may be empty if there is no due date). */\n  @field(OptionalDatabaseDate)\n  dueDate: DatabaseDate | null = null;\n\n  /** Attributes byte. */\n  @field(SUInt8)\n  private attrs = 0;\n\n  /** Whether the item is completed. Stored inside attrs. */\n  isCompleted = false;\n\n  /** Priority of the item (max 127). Stored inside attrs. */\n  priority = 0;\n\n  /** Main description. */\n  @field(SStringNT)\n  description = '';\n\n  /** Additional note. */\n  @field(SStringNT)\n  note = '';\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const readOffset = super.deserialize(buffer, opts);\n    this.isCompleted = !!(this.attrs & 0x80);\n    this.priority = this.attrs & 0x7f;\n    return readOffset;\n  }\n\n  serialize(opts?: SerializeOptions) {", "    if (this.priority < 0 || this.priority > 0x7f) {\n      throw new Error(`Invalid priority: ${this.priority}`);\n    }\n    this.attrs = this.priority;\n    if (this.isCompleted) {\n      this.attrs |= 0x80;\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** ToDoDB database.\n *\n * References:\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/todo.c\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/ToDo.pm\n */", "export class ToDoDatabase extends PdbDatabase.of(ToDoRecord, ToDoAppInfo) {\n  header = DatabaseHdrType.with({\n    name: 'ToDoDB',\n    type: 'DATA',\n    creator: 'todo',\n  });\n}\n"]}
{"filename": "src/address-database.ts", "chunked_list": ["import groupBy from 'lodash/groupBy';\nimport pick from 'lodash/pick';\nimport {\n  bitfield,\n  DeserializeOptions,\n  field,\n  SArray,\n  SBitmask,\n  SerializeOptions,\n  SStringNT,", "  SerializeOptions,\n  SStringNT,\n  SUInt16BE,\n  SUInt32BE,\n  SUInt8,\n} from 'serio';\nimport {AppInfoType, DatabaseHdrType, PdbDatabase, PdbRecord} from '.';\n\n/** Maximum length of address field labels - 15 + 1 NUL byte. */\nexport const ADDRESS_FIELD_LABEL_LENGTH = 16;", "/** Maximum length of address field labels - 15 + 1 NUL byte. */\nexport const ADDRESS_FIELD_LABEL_LENGTH = 16;\n\n/** Countries and regions in AddressDB.\n *\n * References:\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L170\n */\nexport enum AddressCountry {\n  AUSTRALIA = 0,\n  AUSTRIA = 1,\n  BELGIUM = 2,\n  BRAZIL = 3,\n  CANADA = 4,\n  DENMARK = 5,\n  FINLAND = 6,\n  FRANCE = 7,\n  GERMANY = 8,\n  HONG_KONG = 9,\n  ICELAND = 10,\n  IRELAND = 11,\n  ITALY = 12,\n  JAPAN = 13,\n  LUXEMBOURG = 14,\n  MEXICO = 15,\n  NETHERLANDS = 16,\n  NEW_ZEALAND = 17,\n  NORWAY = 18,\n  SPAIN = 19,\n  SWEDEN = 20,\n  SWITZERLAND = 21,\n  UNITED_KINGDOM = 22,\n  UNITED_STATES = 23,\n}\n\n/** Field types in AddressDB.\n *\n * References:\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L424\n */", "export enum AddressCountry {\n  AUSTRALIA = 0,\n  AUSTRIA = 1,\n  BELGIUM = 2,\n  BRAZIL = 3,\n  CANADA = 4,\n  DENMARK = 5,\n  FINLAND = 6,\n  FRANCE = 7,\n  GERMANY = 8,\n  HONG_KONG = 9,\n  ICELAND = 10,\n  IRELAND = 11,\n  ITALY = 12,\n  JAPAN = 13,\n  LUXEMBOURG = 14,\n  MEXICO = 15,\n  NETHERLANDS = 16,\n  NEW_ZEALAND = 17,\n  NORWAY = 18,\n  SPAIN = 19,\n  SWEDEN = 20,\n  SWITZERLAND = 21,\n  UNITED_KINGDOM = 22,\n  UNITED_STATES = 23,\n}\n\n/** Field types in AddressDB.\n *\n * References:\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L424\n */", "export enum AddressFieldType {\n  LAST_NAME = 0,\n  FIRST_NAME = 1,\n  COMPANY = 2,\n  PHONE_1 = 3,\n  PHONE_2 = 4,\n  PHONE_3 = 5,\n  PHONE_4 = 6,\n  PHONE_5 = 7,\n  ADDRESS = 8,\n  CITY = 9,\n  STATE = 10,\n  ZIP_CODE = 11,\n  COUNTRY = 12,\n  TITLE = 13,\n  CUSTOM_1 = 14,\n  CUSTOM_2 = 15,\n  CUSTOM_3 = 16,\n  CUSTOM_4 = 17,\n  NOTE = 18,\n  PHONE_6 = 19,\n  PHONE_7 = 20,\n  PHONE_8 = 21,\n}\n/** Number of address fields (and field types). */\nexport const NUM_ADDRESS_FIELDS = 22;\n\n/** Standard phone number field types in AddressDB.\n *\n * References:\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L159\n */", "export enum PhoneNumberType {\n  WORK = 0,\n  HOME = 1,\n  FAX = 2,\n  OTHER = 3,\n  EMAIL = 4,\n  MAIN = 5,\n  PAGER = 6,\n  MOBILE = 7,\n}\n/** Standard phone number fields. */\nexport const PHONE_NUMBER_FIELD_TYPES: Array<PhoneNumberFieldType> = [\n  AddressFieldType.PHONE_1,\n  AddressFieldType.PHONE_2,\n  AddressFieldType.PHONE_3,\n  AddressFieldType.PHONE_4,\n  AddressFieldType.PHONE_5,\n];", "export type PhoneNumberFieldType =\n  | AddressFieldType.PHONE_1\n  | AddressFieldType.PHONE_2\n  | AddressFieldType.PHONE_3\n  | AddressFieldType.PHONE_4\n  | AddressFieldType.PHONE_5;\n\nexport function isPhoneNumberFieldType(\n  fieldType: AddressFieldType\n): fieldType is PhoneNumberFieldType {\n  return PHONE_NUMBER_FIELD_TYPES.includes(fieldType as any);\n}\n\n/** Information about a field in AddressDB. */", "export interface AddressField {\n  /** Field type. */\n  type: AddressFieldType;\n  /** Label displayed to the user.\n   *\n   * Max length is ADDRESS_FIELD_LABEL_LENGTH - 1.\n   */\n  label: string;\n  /** Dirty bit indicating whether this field has been renamed.  */\n  isRenamed: boolean;\n}\n\n/** AddressDB AppInfo block. */", "export class AddressAppInfo extends AppInfoType {\n  @field(SUInt16BE)\n  private padding2 = 0;\n\n  /** Field information.\n   *\n   * Always has exactly NUM_ADDRESS_FIELDS elements.\n   */\n  fields: Array<AddressField> = [];\n  @field(SUInt32BE)\n  private renamedFields = 0;\n  @field(\n    SArray.of(SStringNT.ofLength(ADDRESS_FIELD_LABEL_LENGTH)).ofLength(\n      NUM_ADDRESS_FIELDS\n    )\n  )\n  private addressLabels: Array<string> = [];\n\n  @field(SUInt8.enum(AddressCountry))\n  country = AddressCountry.UNITED_STATES;\n\n  @field(SUInt8)\n  private padding3 = 0;\n\n  /** Whether to sort the database by company - must be 0 or 1. */\n  @field(SUInt8)\n  sortByCompany = 0;\n\n  @field(SUInt8)\n  private padding4 = 0;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const offset = super.deserialize(buffer, opts);\n    this.fields = this.addressLabels.map((label, i) => ({\n      type: i,\n      label,\n      isRenamed: !!(this.renamedFields & (1 << i)),\n    }));\n    return offset;\n  }\n\n  serialize(opts?: SerializeOptions) {", "    if (this.fields.length !== NUM_ADDRESS_FIELDS) {\n      throw new Error(\n        `Fields array must have exactly ${NUM_ADDRESS_FIELDS} elements, ` +\n          `found ${this.fields.length}`\n      );\n    }\n    this.renamedFields = 0;\n    this.addressLabels = [];\n    for (let i = 0; i < this.fields.length; ++i) {\n      const {type, label, isRenamed} = this.fields[i];\n      if (type !== i) {\n        throw new Error(\n          `Expected field[${i}] to have type ${AddressFieldType[i]}, ` +\n            `found ${type}`\n        );\n      }\n      this.addressLabels.push(label);", "    for (let i = 0; i < this.fields.length; ++i) {\n      const {type, label, isRenamed} = this.fields[i];\n      if (type !== i) {\n        throw new Error(\n          `Expected field[${i}] to have type ${AddressFieldType[i]}, ` +\n            `found ${type}`\n        );\n      }\n      this.addressLabels.push(label);\n      if (isRenamed) {\n        this.renamedFields |= 1 << i;\n      }\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** A cell in an AddressDB record. */", "      if (isRenamed) {\n        this.renamedFields |= 1 << i;\n      }\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** A cell in an AddressDB record. */\nexport interface AddressRecordCell {\n  /** The corresponding field type. */\n  fieldType: AddressFieldType;\n  /** The phone number field, if this is a phone number field. */\n  phoneNumberType?: PhoneNumberType;\n  /** The actual data. */\n  value: string;\n}\n\n/** An AddressDB record. */", "export interface AddressRecordCell {\n  /** The corresponding field type. */\n  fieldType: AddressFieldType;\n  /** The phone number field, if this is a phone number field. */\n  phoneNumberType?: PhoneNumberType;\n  /** The actual data. */\n  value: string;\n}\n\n/** An AddressDB record. */\nexport class AddressRecord extends PdbRecord {", "export class AddressRecord extends PdbRecord {\n  /** The \"main\" phone number type for this record. */\n  get mainPhoneNumberType() {\n    return this.phoneNumberTypeMappingBitmask.mainPhoneNumberType;\n  }\n  set mainPhoneNumberType(newValue: PhoneNumberType) {\n    this.phoneNumberTypeMappingBitmask.mainPhoneNumberType = newValue;\n  }\n  /** Phone number type mapping for this record. */\n  get phoneNumberTypeMapping() {\n    return this.phoneNumberTypeMappingBitmask.phoneNumberTypeMapping;\n  }\n  set phoneNumberTypeMapping(newValue: PhoneNumberTypeMapping) {\n    this.phoneNumberTypeMappingBitmask.phoneNumberTypeMapping = newValue;\n  }\n  @field()\n  private phoneNumberTypeMappingBitmask = new PhoneNumberTypeMappingBitmask();\n\n  /** Cells in this record.\n   *\n   * A record can contain up to NUM_ADDRESS_FIELDS cells, one for each\n   * AddressFieldType.\n   *\n   * This array can be manipulated directly or via the get() and set() methods.\n   */\n  cells: Array<AddressRecordCell> = [];\n  @field(SUInt32BE)\n  private fieldsBitmask = 0;\n  @field(SUInt8)\n  private companyCellValueOffset = 0;\n  @field(SArray.of(SStringNT))\n  private values: Array<string> = [];\n", "  /** Phone number type mapping for this record. */\n  get phoneNumberTypeMapping() {\n    return this.phoneNumberTypeMappingBitmask.phoneNumberTypeMapping;\n  }\n  set phoneNumberTypeMapping(newValue: PhoneNumberTypeMapping) {\n    this.phoneNumberTypeMappingBitmask.phoneNumberTypeMapping = newValue;\n  }\n  @field()\n  private phoneNumberTypeMappingBitmask = new PhoneNumberTypeMappingBitmask();\n\n  /** Cells in this record.\n   *\n   * A record can contain up to NUM_ADDRESS_FIELDS cells, one for each\n   * AddressFieldType.\n   *\n   * This array can be manipulated directly or via the get() and set() methods.\n   */\n  cells: Array<AddressRecordCell> = [];\n  @field(SUInt32BE)\n  private fieldsBitmask = 0;\n  @field(SUInt8)\n  private companyCellValueOffset = 0;\n  @field(SArray.of(SStringNT))\n  private values: Array<string> = [];\n", "  /** Returns the cell value for a field type in this record, or undefined if\n   * not present.\n   */\n  get(fieldType: AddressFieldType) {\n    return this.cells.find((cell) => cell.fieldType === fieldType)?.value;\n  }\n  /** Sets the cell value for a field type.\n   *\n   * If field type was already present on this record, the previous cell value\n   * is overwritten. Otherwise, a new cell is appended.\n   */\n  set(fieldType: AddressFieldType, value: string) {\n    const cell = this.makeCell(fieldType, value);\n    const existingCellIdx = this.cells.findIndex(\n      (cell) => cell.fieldType === fieldType\n    );", "   * If field type was already present on this record, the previous cell value\n   * is overwritten. Otherwise, a new cell is appended.\n   */\n  set(fieldType: AddressFieldType, value: string) {\n    const cell = this.makeCell(fieldType, value);\n    const existingCellIdx = this.cells.findIndex(\n      (cell) => cell.fieldType === fieldType\n    );\n    if (existingCellIdx >= 0) {\n      this.cells[existingCellIdx] = cell;\n    } else {\n      this.cells.push(cell);\n    }\n  }\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    this.cells = [];\n    this.values = [];\n    let offset = super.deserialize(buffer, opts);\n    const s = new SStringNT();", "    if (existingCellIdx >= 0) {\n      this.cells[existingCellIdx] = cell;\n    } else {\n      this.cells.push(cell);\n    }\n  }\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    this.cells = [];\n    this.values = [];\n    let offset = super.deserialize(buffer, opts);\n    const s = new SStringNT();", "    for (let i = 0; i < NUM_ADDRESS_FIELDS; ++i) {\n      if (this.fieldsBitmask & (1 << i)) {\n        offset += s.deserialize(buffer.subarray(offset), opts);\n        const fieldType = i;\n        this.cells.push(this.makeCell(fieldType, s.value));\n      }\n    }\n    return offset;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    this.fieldsBitmask = 0;\n    this.values = [];\n    this.companyCellValueOffset = 0;\n    const cellsByFieldType = groupBy(this.cells, ({fieldType}) => fieldType);", "    for (let i = 0, companyCellValueOffset = 0; i < NUM_ADDRESS_FIELDS; ++i) {\n      const fieldType = i;\n      const cells = cellsByFieldType[fieldType];\n      if (!cells) {\n        continue;\n      }\n      if (cells.length !== 1) {\n        throw new Error(\n          `Found ${cells.length} cells with field type ${fieldType}: ` +\n            cells.map(({value}) => `\"${value}\"`).join(', ')\n        );\n      }\n      const {value, phoneNumberType} = cells[0];", "      if (isPhoneNumberFieldType(fieldType)) {\n        if (\n          phoneNumberType &&\n          phoneNumberType !== this.phoneNumberTypeMapping[fieldType]\n        ) {\n          throw new Error(\n            `Incorrect phone number type in cell ${fieldType}: ` +\n              `phoneNumberTypeMapping[${fieldType}] is ${this.phoneNumberTypeMapping[fieldType]}, ` +\n              `but cell has phone number type ${phoneNumberType}`\n          );\n        }\n      } else {", "        if (phoneNumberType) {\n          throw new Error(\n            `${fieldType} is not a phone number field and should not have phoneNumberType set ` +\n              `(found ${phoneNumberType})`\n          );\n        }\n      }\n      this.fieldsBitmask |= 1 << i;\n      this.values.push(value);\n      if (fieldType === AddressFieldType.COMPANY) {\n        this.companyCellValueOffset = companyCellValueOffset + 1;", "      if (fieldType === AddressFieldType.COMPANY) {\n        this.companyCellValueOffset = companyCellValueOffset + 1;\n      } else if (this.companyCellValueOffset === 0) {\n        companyCellValueOffset += value.length + 1;\n      }\n    }\n    return super.serialize(opts);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    this.values = this.cells.map(({value}) => value);\n    return super.getSerializedLength(opts);\n  }\n\n  private makeCell(fieldType: AddressFieldType, value: string) {\n    return {\n      fieldType,\n      ...(isPhoneNumberFieldType(fieldType)\n        ? {\n            phoneNumberType: this.phoneNumberTypeMapping[fieldType],\n          }\n        : {}),\n      value,\n    };\n  }\n}\n", "/** Mapping from address field type to phone number type. */\nexport type PhoneNumberTypeMapping = {\n  [key in PhoneNumberFieldType]: PhoneNumberType;\n};\n\nclass PhoneNumberTypeMappingBitmask extends SBitmask.of(SUInt32BE) {\n  @bitfield(8)\n  private padding1 = 0;\n\n  @bitfield(4)\n  mainPhoneNumberType = PhoneNumberType.WORK;\n\n  get phoneNumberTypeMapping(): PhoneNumberTypeMapping {\n    return {\n      [AddressFieldType.PHONE_1]: this.phone1,\n      [AddressFieldType.PHONE_2]: this.phone2,\n      [AddressFieldType.PHONE_3]: this.phone3,\n      [AddressFieldType.PHONE_4]: this.phone4,\n      [AddressFieldType.PHONE_5]: this.phone5,\n    };\n  }\n  set phoneNumberTypeMapping(newValue: PhoneNumberTypeMapping) {\n    this.phone1 = newValue[AddressFieldType.PHONE_1];\n    this.phone2 = newValue[AddressFieldType.PHONE_2];\n    this.phone3 = newValue[AddressFieldType.PHONE_3];\n    this.phone4 = newValue[AddressFieldType.PHONE_4];\n    this.phone5 = newValue[AddressFieldType.PHONE_5];\n  }\n  @bitfield(4)\n  private phone5 = 4;\n  @bitfield(4)\n  private phone4 = 3;\n  @bitfield(4)\n  private phone3 = 2;\n  @bitfield(4)\n  private phone2 = 1;\n  @bitfield(4)\n  private phone1 = 0;\n}\n\n/** AddressDB database.\n *\n * References:\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/address.c\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm\n */", "export class AddressDatabase extends PdbDatabase.of(\n  AddressRecord,\n  AddressAppInfo\n) {\n  header = DatabaseHdrType.with({\n    name: 'AddressDB',\n    type: 'DATA',\n    creator: 'addr',\n  });\n}\n"]}
{"filename": "src/app-info.ts", "chunked_list": ["import {pick} from 'lodash';\nimport {\n  DeserializeOptions,\n  SArray,\n  SObject,\n  SStringNT,\n  SUInt16BE,\n  SUInt8,\n  SerializeOptions,\n  field,", "  SerializeOptions,\n  field,\n} from 'serio';\n\n/** Maximum number of categories.\n *\n * References:\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataMgr.h#L34\n */\nexport const NUM_CATEGORIES = 16;", " */\nexport const NUM_CATEGORIES = 16;\n/** Maximum length of category labels - 15 chars + 1 NUL byte.\n *\n * References:\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataMgr.h#L35\n */\nexport const CATEGORY_LABEL_LENGTH = 16;\n\n/** Information about a category.", "\n/** Information about a category.\n *\n * The member fields inside a Category object aren't actually stored together as\n * a single unit; instead, they are split across the `categoryLabels`,\n * `categoryUniqIds` and `renamedCategories` fields inside {@link AppInfoType}.\n * However, we still make Category extend `SObject` in order to present a\n * consistent API for interacting with database objects.\n */\nexport class Category extends SObject {\n  /** Name of the category.\n   *\n   * Max length is CATEGORY_LABEL_LENGTH - 1.\n   */\n  label = '';\n  /** ID of the category.\n   *\n   * Unique IDs generated by the device are between 0 and 127. Unique IDs\n   * generated by the desktop computer are between 128 and 255.\n   */\n  uniqId = 0;\n  /** Dirty bit indicating whether this category has been renamed. */\n  isRenamed = false;\n\n  toJSON() {\n    return pick(this, ['label', 'uniqId', 'isRenamed']);\n  }\n}\n\n/** AppInfo block for standard category data.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r3/include/Core/UI/Category.h\n */", " */\nexport class Category extends SObject {\n  /** Name of the category.\n   *\n   * Max length is CATEGORY_LABEL_LENGTH - 1.\n   */\n  label = '';\n  /** ID of the category.\n   *\n   * Unique IDs generated by the device are between 0 and 127. Unique IDs\n   * generated by the desktop computer are between 128 and 255.\n   */\n  uniqId = 0;\n  /** Dirty bit indicating whether this category has been renamed. */\n  isRenamed = false;\n\n  toJSON() {\n    return pick(this, ['label', 'uniqId', 'isRenamed']);\n  }\n}\n\n/** AppInfo block for standard category data.\n *\n * References:\n *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r3/include/Core/UI/Category.h\n */", "export class AppInfoType extends SObject {\n  /** Array of category information (dmRecNumCategories = 16 elements). */\n  categories: Array<Category> = [];\n  @field(SUInt16BE)\n  private renamedCategories = 0;\n  @field(\n    SArray.of(SStringNT.ofLength(CATEGORY_LABEL_LENGTH)).ofLength(\n      NUM_CATEGORIES\n    )\n  )\n  private categoryLabels: Array<string> = [];\n  @field(SArray.of(SUInt8).ofLength(NUM_CATEGORIES))\n  private categoryUniqIds: Array<number> = [];\n\n  /** The last unique category ID assigned. */\n  @field(SUInt8)\n  lastUniqId = 0;\n\n  @field(SUInt8)\n  private readonly padding1 = 0;\n\n  /** Finds the category with the given unique ID or label.\n   *\n   * If the argument is a number, this method will look for a category with a\n   * matching uniqId. If the argument is a string, this method will look for a\n   * category with a matching label.\n   */\n  getCategory(arg: number | string): Category | null {\n    let matchFn: (category: Category) => boolean;\n    switch (typeof arg) {\n      case 'number':\n        matchFn = (category) => category.uniqId === arg;\n        break;\n      case 'string':\n        matchFn = (category) => category.label === arg;\n        break;\n      default:\n        throw new Error(`Expected a number or string, found ${typeof arg}`);\n    }\n    return this.categories.find(matchFn) ?? null;\n  }\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const offset = super.deserialize(buffer, opts);\n    this.categories = [];", "    for (let i = 0; i < NUM_CATEGORIES; ++i) {\n      if (!this.categoryLabels[i]) {\n        break;\n      }\n      this.categories.push(\n        Category.with({\n          label: this.categoryLabels[i],\n          uniqId: this.categoryUniqIds[i],\n          isRenamed: !!(this.renamedCategories & (1 << i)),\n        })\n      );\n    }\n    return offset;\n  }\n\n  serialize(opts?: SerializeOptions): Buffer {\n    this.categoryLabels = [];\n    this.categoryUniqIds = [];\n    this.renamedCategories = 0;", "    for (let i = 0; i < this.categories.length; ++i) {\n      const {label, uniqId, isRenamed} = this.categories[i];\n      this.categoryLabels.push(label);\n      this.categoryUniqIds.push(uniqId);\n      if (isRenamed) {\n        this.renamedCategories |= 1 << i;\n      }\n    }\n    return super.serialize(opts);\n  }\n}\n"]}
{"filename": "src/database.ts", "chunked_list": ["import sum from 'lodash/sum';\nimport {\n  DeserializeOptions,\n  SBuffer,\n  SObject,\n  Serializable,\n  SerializeOptions,\n} from 'serio';\nimport {SmartBuffer} from 'smart-buffer';\nimport {", "import {SmartBuffer} from 'smart-buffer';\nimport {\n  DatabaseHdrType,\n  EntryType,\n  PdbRecordListType,\n  PrcRecordListType,\n  RecordEntryType,\n  RecordListType,\n  RsrcEntryType,\n} from './database-header';", "  RsrcEntryType,\n} from './database-header';\nimport {RawPdbRecord, RawPrcRecord, Record} from './record';\nimport {DEFAULT_ENCODING} from './util';\n\n/** Representation of a Palm OS database file. */\nexport abstract class Database<\n  /** Record or resource entry type. */\n  EntryT extends EntryType,\n  /** Record type. */\n  RecordT extends Record<EntryT>,\n  /** AppInfo type. */\n  AppInfoT extends Serializable = SBuffer,\n  /** SortInfo type. */\n  SortInfoT extends Serializable = SBuffer\n> extends SObject {\n  /** Record list constructor, to be provided by child classes. */\n  protected abstract readonly recordListType: new () => RecordListType<EntryT>;", "  /** Record type constructor, to be provided by child classes. */\n  protected abstract readonly recordType: new () => RecordT;\n  /** AppInfo type constructor, to be provided by child classes. */\n  protected readonly appInfoType: (new () => AppInfoT) | null = null;\n  /** SortInfo type constructor, to be provided by child classes. */\n  protected readonly sortInfoType: (new () => SortInfoT) | null = null;\n\n  /** Database header.\n   *\n   * Note that `appInfoId` and `sortInfoId` fields in the header are overwritten\n   * during serialization.\n   */\n  header = new DatabaseHdrType();\n  /** AppInfo value. */\n  appInfo: AppInfoT | null = null;\n  /** SortInfo value. */\n  sortInfo: SortInfoT | null = null;\n  /** Record values.\n   *\n   * Note that `entry.localChunkId` is overwritten during serialization.\n   */\n  records: Array<RecordT> = [];\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    opts = {encoding: DEFAULT_ENCODING, ...opts};\n\n    this.header.deserialize(buffer, opts);\n\n    const recordList = new this.recordListType();\n    recordList.deserialize(\n      buffer.subarray(this.header.getSerializedLength(opts)),\n      opts\n    );\n", "    if (this.appInfoType && this.header.appInfoId) {\n      const appInfoEnd =\n        this.header.sortInfoId ||\n        (recordList.values.length > 0\n          ? recordList.values[0].localChunkId\n          : buffer.length);\n      if (!this.appInfo) {\n        this.appInfo = new this.appInfoType();\n      }\n      this.appInfo.deserialize(\n        buffer.subarray(this.header.appInfoId, appInfoEnd),\n        opts\n      );\n    } else {\n      this.appInfo = null;\n    }\n", "    if (this.sortInfoType && this.header.sortInfoId) {\n      const sortInfoEnd =\n        recordList.values.length > 0\n          ? recordList.values[0].localChunkId\n          : buffer.length;\n      if (!this.sortInfo) {\n        this.sortInfo = new this.sortInfoType();\n      }\n      this.sortInfo.deserialize(\n        buffer.subarray(this.header.sortInfoId, sortInfoEnd),\n        opts\n      );\n    } else {\n      this.sortInfo = null;\n    }\n\n    this.records = [];\n    let lastRecordEnd = 0;", "    for (let i = 0; i < recordList.values.length; ++i) {\n      const recordStart = recordList.values[i].localChunkId;\n      const recordEnd =\n        i < recordList.values.length - 1\n          ? recordList.values[i + 1].localChunkId\n          : buffer.length;\n      const record = new this.recordType();\n      record.entry = recordList.values[i];\n      record.deserialize(buffer.subarray(recordStart, recordEnd), opts);\n      this.records.push(record);\n      lastRecordEnd = recordEnd;\n    }\n\n    return lastRecordEnd;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    opts = {encoding: DEFAULT_ENCODING, ...opts};\n    this.recomputeOffsets(opts);\n    const writer = new SmartBuffer();\n\n    writer.writeBuffer(this.header.serialize(opts));\n\n    const recordList = new this.recordListType();\n    recordList.values = this.records.map(({entry}) => entry);\n    writer.writeBuffer(recordList.serialize(opts));\n", "    if (this.appInfo) {\n      writer.writeBuffer(this.appInfo.serialize(opts));\n    }\n\n    if (this.sortInfo) {\n      writer.writeBuffer(this.sortInfo.serialize(opts));\n    }\n\n    for (const record of this.records) {\n      writer.writeBuffer(record.serialize(opts));\n    }\n\n    return writer.toBuffer();\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return (\n      this.header.getSerializedLength(opts) +\n      sum(this.records.map(({entry}) => entry.getSerializedLength(opts))) +\n      (this.appInfo ? this.appInfo.getSerializedLength(opts) : 0) +\n      (this.sortInfo ? this.sortInfo.getSerializedLength(opts) : 0) +\n      sum(this.records.map((record) => record.getSerializedLength(opts)))\n    );\n  }\n\n  /** Recompute offsets in the database and record headers.\n   *\n   * This will update the following based on the current field values:\n   *  - `header.appInfoId`\n   *  - `header.sortInfoId`\n   *  - `entry.localChunkId` for each record\n   */\n  recomputeOffsets(opts?: SerializeOptions) {\n    opts = {encoding: DEFAULT_ENCODING, ...opts};\n    const recordList = new this.recordListType();\n    recordList.values = this.records.map(({entry}) => entry);\n\n    let offset =\n      this.header.getSerializedLength(opts) +\n      recordList.getSerializedLength(opts);", "    for (const record of this.records) {\n      writer.writeBuffer(record.serialize(opts));\n    }\n\n    return writer.toBuffer();\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return (\n      this.header.getSerializedLength(opts) +\n      sum(this.records.map(({entry}) => entry.getSerializedLength(opts))) +\n      (this.appInfo ? this.appInfo.getSerializedLength(opts) : 0) +\n      (this.sortInfo ? this.sortInfo.getSerializedLength(opts) : 0) +\n      sum(this.records.map((record) => record.getSerializedLength(opts)))\n    );\n  }\n\n  /** Recompute offsets in the database and record headers.\n   *\n   * This will update the following based on the current field values:\n   *  - `header.appInfoId`\n   *  - `header.sortInfoId`\n   *  - `entry.localChunkId` for each record\n   */\n  recomputeOffsets(opts?: SerializeOptions) {\n    opts = {encoding: DEFAULT_ENCODING, ...opts};\n    const recordList = new this.recordListType();\n    recordList.values = this.records.map(({entry}) => entry);\n\n    let offset =\n      this.header.getSerializedLength(opts) +\n      recordList.getSerializedLength(opts);", "    if (this.appInfo) {\n      this.header.appInfoId = offset;\n      offset += this.appInfo.getSerializedLength(opts);\n    } else {\n      this.header.appInfoId = 0;\n    }\n    if (this.sortInfo) {\n      this.header.sortInfoId = offset;\n      offset += this.sortInfo.getSerializedLength(opts);\n    } else {\n      this.header.sortInfoId = 0;\n    }\n", "    for (let i = 0; i < this.records.length; ++i) {\n      recordList.values[i].localChunkId = offset;\n      offset += this.records[i].getSerializedLength(opts);\n    }\n  }\n}\n\n/** PDB databases. */\nexport abstract class PdbDatabase<\n  /** Record type. */\n  RecordT extends Record<RecordEntryType>,\n  /** AppInfo type. */\n  AppInfoT extends Serializable = SBuffer,\n  /** SortInfo type. */\n  SortInfoT extends Serializable = SBuffer\n> extends Database<RecordEntryType, RecordT, AppInfoT, SortInfoT> {\n  constructor() {\n    super();\n    this.header.attributes.resDB = false;\n  }\n\n  recordListType = PdbRecordListType;\n", "export abstract class PdbDatabase<\n  /** Record type. */\n  RecordT extends Record<RecordEntryType>,\n  /** AppInfo type. */\n  AppInfoT extends Serializable = SBuffer,\n  /** SortInfo type. */\n  SortInfoT extends Serializable = SBuffer\n> extends Database<RecordEntryType, RecordT, AppInfoT, SortInfoT> {\n  constructor() {\n    super();\n    this.header.attributes.resDB = false;\n  }\n\n  recordListType = PdbRecordListType;\n", "  /** Constructs a PdbDatabase class with the given parameters. */\n  static of<\n    RecordT extends Record<RecordEntryType>,\n    AppInfoT extends Serializable = SBuffer,\n    SortInfoT extends Serializable = SBuffer\n  >(\n    recordType: new () => RecordT,\n    appInfoType?: new () => AppInfoT,\n    sortInfoType?: new () => SortInfoT\n  ) {\n    return class extends PdbDatabase<RecordT, AppInfoT, SortInfoT> {\n      recordType = recordType;\n      appInfoType = appInfoType ?? null;\n      sortInfoType = sortInfoType ?? null;\n      appInfo = appInfoType ? new appInfoType() : null;\n      sortInfo = sortInfoType ? new sortInfoType() : null;\n    };\n  }\n}\n\n/** PRC databases. */", "    return class extends PdbDatabase<RecordT, AppInfoT, SortInfoT> {\n      recordType = recordType;\n      appInfoType = appInfoType ?? null;\n      sortInfoType = sortInfoType ?? null;\n      appInfo = appInfoType ? new appInfoType() : null;\n      sortInfo = sortInfoType ? new sortInfoType() : null;\n    };\n  }\n}\n\n/** PRC databases. */", "export abstract class PrcDatabase<\n  /** Record type. */\n  RecordT extends Record<RsrcEntryType>,\n  /** AppInfo type. */\n  AppInfoT extends Serializable = SBuffer,\n  /** SortInfo type. */\n  SortInfoT extends Serializable = SBuffer\n> extends Database<RsrcEntryType, RecordT, AppInfoT, SortInfoT> {\n  constructor() {\n    super();\n    this.header.attributes.resDB = true;\n  }\n  recordListType = PrcRecordListType;\n", "  /** Constructs a PrcDatabase class with the given parameters. */\n  static of<\n    RecordT extends Record<RsrcEntryType>,\n    AppInfoT extends Serializable = SBuffer,\n    SortInfoT extends Serializable = SBuffer\n  >(\n    recordType: new () => RecordT,\n    appInfoType?: new () => AppInfoT,\n    sortInfoType?: new () => SortInfoT\n  ) {\n    return class extends PrcDatabase<RecordT, AppInfoT, SortInfoT> {\n      recordType = recordType;\n      appInfoType = appInfoType ?? null;\n      sortInfoType = sortInfoType ?? null;\n      appInfo = appInfoType ? new appInfoType() : null;\n      sortInfo = sortInfoType ? new sortInfoType() : null;\n    };\n  }\n}\n\n/** PDB database providing records, AppInfo and SortInfo as raw buffers. */", "    return class extends PrcDatabase<RecordT, AppInfoT, SortInfoT> {\n      recordType = recordType;\n      appInfoType = appInfoType ?? null;\n      sortInfoType = sortInfoType ?? null;\n      appInfo = appInfoType ? new appInfoType() : null;\n      sortInfo = sortInfoType ? new sortInfoType() : null;\n    };\n  }\n}\n\n/** PDB database providing records, AppInfo and SortInfo as raw buffers. */", "export class RawPdbDatabase extends PdbDatabase.of(\n  RawPdbRecord,\n  SBuffer,\n  SBuffer\n) {}\n\n/** PRC database providing records, AppInfo and SortInfo as raw buffers. */\nexport class RawPrcDatabase extends PrcDatabase.of(\n  RawPrcRecord,\n  SBuffer,\n  SBuffer\n) {}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './util';\n\nexport * from './date-time';\nexport * from './database-header';\nexport * from './app-info';\nexport * from './database';\nexport * from './record';\n\nexport * from './datebook-database';\nexport * from './memo-database';", "export * from './datebook-database';\nexport * from './memo-database';\nexport * from './todo-database';\nexport * from './address-database';\nexport * from './palmdoc-database';\n"]}
{"filename": "src/util.ts", "chunked_list": ["import sum from 'lodash/sum';\nimport {\n  DeserializeOptions,\n  SArray,\n  SString,\n  SUInt32BE,\n  Serializable,\n  SerializableWrapper,\n  SerializeOptions,\n} from 'serio';", "  SerializeOptions,\n} from 'serio';\n\n/** An array encoded as a number N followed by N elements. */\nexport abstract class SDynamicArray<\n  LengthT extends SerializableWrapper<number>,\n  ValueT extends Serializable\n> extends SerializableWrapper<Array<ValueT>> {\n  /** Array of Serializables. */\n  value: Array<ValueT> = [];\n  /** Length type, to be provided by child classes. */\n  protected abstract readonly lengthType: new () => LengthT;\n  /** Element type, to be provided by child classes. */\n  protected abstract readonly valueType: new () => ValueT;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const length = new this.lengthType();\n    let readOffset = length.deserialize(buffer, opts);\n    const sArray = new (SArray.ofLength(length.value, this.valueType))();\n    readOffset += sArray.deserialize(buffer.subarray(readOffset), opts);\n    this.value.splice(0, this.value.length, ...sArray.value);\n    return readOffset;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    const length = new this.lengthType();\n    length.value = this.value.length;\n    return Buffer.concat([\n      length.serialize(opts),\n      SArray.ofLength(this.value.length, this.valueType)\n        .of(this.value)\n        .serialize(opts),\n    ]);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    const length = new this.lengthType();\n    length.value = this.value.length;\n    return (\n      length.getSerializedLength(opts) +\n      sum(this.value.map((value) => value.getSerializedLength(opts)))\n    );\n  }\n", "  /** Create a new instance of this wrapper class from a raw value. */\n  static of<ValueT extends Serializable, SDynamicArrayT extends SArray<ValueT>>(\n    this: new () => SDynamicArrayT,\n    value: Array<ValueT>\n  ): SDynamicArrayT;\n  /** Returns an SDynamicArray class with the given length and value types. */\n  static of<\n    LengthT extends SerializableWrapper<number>,\n    ValueT extends Serializable\n  >(\n    lengthType: new () => LengthT,\n    valueType: new () => ValueT\n  ): ReturnType<typeof createSDynamicArray<LengthT, ValueT>>;\n  static of<\n    LengthT extends SerializableWrapper<number>,\n    ValueT extends Serializable\n  >(arg1: Array<ValueT> | (new () => LengthT), arg2?: new () => ValueT) {", "    if (Array.isArray(arg1)) {\n      return super.of(arg1);\n    }\n    if (\n      typeof arg1 === 'function' &&\n      arg1.prototype instanceof SerializableWrapper &&\n      typeof arg2 === 'function' &&\n      arg2.prototype instanceof Serializable\n    ) {\n      return createSDynamicArray(arg1, arg2);\n    }\n    throw new Error(\n      'SDynamicArray.of() should be invoked either with an array of Serializable ' +", "        'values, or a length type constructor and a value type constructor'\n    );\n  }\n}\n\nfunction createSDynamicArray<\n  LengthT extends SerializableWrapper<number>,\n  ValueT extends Serializable\n>(lengthType: new () => LengthT, valueType: new () => ValueT) {\n  return class extends SDynamicArray<LengthT, ValueT> {\n    lengthType = lengthType;\n    valueType = valueType;\n  };\n}\n", "  return class extends SDynamicArray<LengthT, ValueT> {\n    lengthType = lengthType;\n    valueType = valueType;\n  };\n}\n\n/** Serializable wrapper for a 32-bit type ID mapped to a 4-character string. */\nexport class TypeId extends SString.ofLength(4) {\n  value = 'AAAA';\n}\n\n/** Memory offset, i.e. \"local (card relative) chunk ID\" according to the SDK. */\nexport const LocalId = SUInt32BE;\n\n/** Unique ID of records in PDB databases.\n *\n * Each unique ID is encoded as a 24-bit big endian unsigned integer. Valid\n * records should have a non-zero unique ID.\n */", "export class RecordId extends SerializableWrapper<number> {\n  value = 0;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    // Reference: https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L258\n    this.value =\n      (buffer.readUInt8(0) << 16) |\n      (buffer.readUInt8(1) << 8) |\n      buffer.readUInt8(2);\n    return 3;\n  }\n  serialize(opts?: SerializeOptions) {\n    // Reference: https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L1246\n    return Buffer.of(\n      (this.value >> 16) & 0xff,\n      (this.value >> 8) & 0xff,\n      this.value & 0xff\n    );\n  }\n  getSerializedLength(opts?: SerializeOptions) {\n    return 3;\n  }\n}\n\n/** Default text encoding for Palm OS PDB files. */\nexport const DEFAULT_ENCODING = 'cp1252';\n"]}
{"filename": "src/datebook-database.ts", "chunked_list": ["import pick from 'lodash/pick';\nimport times from 'lodash/times';\nimport {\n  bitfield,\n  DeserializeOptions,\n  field,\n  SBitmask,\n  SerializableWrapper,\n  SerializeOptions,\n  SObject,", "  SerializeOptions,\n  SObject,\n  SStringNT,\n  SUInt16BE,\n  SUInt8,\n} from 'serio';\nimport {\n  AppInfoType,\n  DatabaseDate,\n  DatabaseHdrType,", "  DatabaseDate,\n  DatabaseHdrType,\n  OptionalDatabaseDate,\n  PdbDatabase,\n  PdbRecord,\n  SDynamicArray,\n} from '.';\n\n/** Event start / end time. */\nexport class EventTime extends SObject {\n  /** Hour of day (0 to 23). */\n  @field(SUInt8)\n  hour = 0;\n  /** Minute (0-59). */\n  @field(SUInt8)\n  minute = 0;\n\n  serialize(opts?: SerializeOptions) {", "/** Event start / end time. */\nexport class EventTime extends SObject {\n  /** Hour of day (0 to 23). */\n  @field(SUInt8)\n  hour = 0;\n  /** Minute (0-59). */\n  @field(SUInt8)\n  minute = 0;\n\n  serialize(opts?: SerializeOptions) {\n    if (this.hour < 0 || this.hour > 23) {\n      throw new Error(`Invalid hour value: ${this.hour}`);\n    }", "    if (this.hour < 0 || this.hour > 23) {\n      throw new Error(`Invalid hour value: ${this.hour}`);\n    }\n    if (this.minute < 0 || this.minute > 59) {\n      throw new Error(`Invalid minute value: ${this.minute}`);\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** Event start / end time. */", "export class OptionalEventTime extends SerializableWrapper<EventTime | null> {\n  /** Time value, or null if not specified. */\n  value: EventTime | null = null;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    this.value =\n      buffer.readUInt16BE() === 0xffff ? null : EventTime.from(buffer, opts);\n    return this.getSerializedLength(opts);\n  }\n\n  serialize(opts?: SerializeOptions) {\n    return this.value ? this.value.serialize(opts) : Buffer.of(0xff, 0xff);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return 2;\n  }\n}\n\n/** DatebookDB AppInfo block. */", "export class DatebookAppInfo extends AppInfoType {\n  /** Day of the week to start the week on. Not sure what the format is\n   * \u00af\\_(\u30c4)_/\u00af */\n  @field(SUInt8)\n  firstDayOfWeek = 0;\n\n  @field(SUInt8)\n  private padding2 = 0;\n}\n\n/** A DatebookDB record. */", "export class DatebookRecord extends PdbRecord {\n  /** Start time of event. */\n  @field(OptionalEventTime)\n  startTime: EventTime | null = null;\n  /** End time of event. */\n  @field(OptionalEventTime)\n  endTime: EventTime | null = null;\n  /** Date of the event. */\n  @field()\n  date = new DatabaseDate();\n  /** Attributes field. */\n  @field()\n  private attrs = new DatebookRecordAttrs();\n  @field(SUInt8)\n  private padding1 = 0;\n\n  /** Alarm settings, or null if no alarm configured. */\n  alarmSettings: AlarmSettings | null = null;\n  /** Recurrence settings, or null if the event is not recurring. */\n  recurrenceSettings: RecurrenceSettings | null = null;\n  /** Dates on which to skip repetitions. */\n  exceptionDates: Array<DatabaseDate> = [];\n  /** Main description. */\n  description = '';\n  /** Additional note. */\n  note = '';\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    let offset = super.deserialize(buffer, opts);\n", "    if (this.attrs.hasAlarmSettings) {\n      this.alarmSettings = new AlarmSettings();\n      offset += this.alarmSettings.deserialize(buffer.subarray(offset), opts);\n    } else {\n      this.alarmSettings = null;\n    }\n\n    if (this.attrs.hasRecurrenceSettings) {\n      this.recurrenceSettings = new RecurrenceSettings();\n      offset += this.recurrenceSettings.deserialize(\n        buffer.subarray(offset),\n        opts\n      );\n    } else {\n      this.recurrenceSettings = null;\n    }\n", "    if (this.attrs.hasExceptionDates) {\n      const wrapper = new (SDynamicArray.of(SUInt16BE, DatabaseDate))();\n      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n      this.exceptionDates = wrapper.value;\n    } else {\n      this.exceptionDates = [];\n    }\n\n    if (this.attrs.hasDescription) {\n      const wrapper = new SStringNT();\n      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n      this.description = wrapper.value;\n    } else {\n      this.description = '';\n    }\n", "    if (this.attrs.hasDescription) {\n      const wrapper = new SStringNT();\n      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n      this.description = wrapper.value;\n    } else {\n      this.description = '';\n    }\n\n    if (this.attrs.hasNote) {\n      const wrapper = new SStringNT();\n      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n      this.note = wrapper.value;\n    } else {\n      this.note = '';\n    }\n\n    return buffer.length;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    const pieces: Array<Buffer> = [];\n\n    this.attrs.hasAlarmSettings = !!this.alarmSettings;\n    this.attrs.hasRecurrenceSettings = !!this.recurrenceSettings;\n    this.attrs.hasExceptionDates = this.exceptionDates.length > 0;\n    this.attrs.hasDescription = !!this.description;\n    this.attrs.hasNote = !!this.note;\n    pieces.push(super.serialize(opts));\n", "    if (this.attrs.hasNote) {\n      const wrapper = new SStringNT();\n      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n      this.note = wrapper.value;\n    } else {\n      this.note = '';\n    }\n\n    return buffer.length;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    const pieces: Array<Buffer> = [];\n\n    this.attrs.hasAlarmSettings = !!this.alarmSettings;\n    this.attrs.hasRecurrenceSettings = !!this.recurrenceSettings;\n    this.attrs.hasExceptionDates = this.exceptionDates.length > 0;\n    this.attrs.hasDescription = !!this.description;\n    this.attrs.hasNote = !!this.note;\n    pieces.push(super.serialize(opts));\n", "    if (this.alarmSettings) {\n      pieces.push(this.alarmSettings.serialize(opts));\n    }\n    if (this.recurrenceSettings) {\n      pieces.push(this.recurrenceSettings.serialize(opts));\n    }\n    if (this.exceptionDates.length > 0) {\n      pieces.push(\n        SDynamicArray.of(SUInt16BE, DatabaseDate)\n          .of(this.exceptionDates)\n          .serialize(opts)\n      );\n    }", "    if (this.description) {\n      pieces.push(SStringNT.of(this.description).serialize(opts));\n    }\n    if (this.note) {\n      pieces.push(SStringNT.of(this.note).serialize(opts));\n    }\n\n    return Buffer.concat(pieces);\n  }\n\n  getSerializedLength(opts?: SerializeOptions) {\n    return (\n      8 +\n      (this.alarmSettings ? this.alarmSettings.getSerializedLength(opts) : 0) +\n      (this.recurrenceSettings\n        ? this.recurrenceSettings.getSerializedLength(opts)\n        : 0) +\n      (this.exceptionDates.length > 0\n        ? SDynamicArray.of(SUInt16BE, DatabaseDate)\n            .of(this.exceptionDates)\n            .getSerializedLength(opts)\n        : 0) +\n      (this.note ? this.note.length + 1 : 0) +\n      (this.description ? this.description.length + 1 : 0)\n    );\n  }\n}\n\n/** Datebook record attribute flags. */", "export class DatebookRecordAttrs extends SBitmask.of(SUInt8) {\n  @bitfield(1)\n  private unused1 = 0;\n  /** Whether this event should sound an alarm before the start time. */\n  @bitfield(1)\n  hasAlarmSettings = false;\n  /** Whether this event is recurring. */\n  @bitfield(1)\n  hasRecurrenceSettings = false;\n  /** Whether this event has an additional note. */\n  @bitfield(1)\n  hasNote = false;\n  /** Whether this event has repetition exceptions. */\n  @bitfield(1)\n  hasExceptionDates = false;\n  /** Whether this event has a description. */\n  @bitfield(1)\n  hasDescription = false;\n  @bitfield(2)\n  private unused2 = 0;\n}\n\n/** Time unit for describing when the alarm should fire. */", "export enum AlarmTimeUnit {\n  MINUTES = 0,\n  HOURS = 1,\n  DAYS = 2,\n}\n\n/** Event alarm settings.\n *\n * The time when the alarm will fire is specified by the combination of `unit`\n * and `value`. For example, `{unit: 'minutes', value: 10}` means the alarm will\n * fire 10 minutes before the event.\n */", "export class AlarmSettings extends SObject {\n  /** Number of time units before the event start time to fire the alarm. */\n  @field(SUInt8)\n  value = 0;\n\n  /** Time unit for expressing when the alarm should fire. */\n  @field(SUInt8.enum(AlarmTimeUnit))\n  unit = AlarmTimeUnit.MINUTES;\n}\n\n/** Frequency of a recurring event. */", "export enum RecurrenceFrequency {\n  /** Don't repeat. */\n  NONE = 0,\n  /** Repeat every N days */\n  DAILY = 1,\n  /** Repeat every N weeks on the same days of the week. */\n  WEEKLY = 2,\n  /** Repeat on same week of the month every N months. */\n  MONTHLY_BY_DAY = 3,\n  /** Repeat on same day of the month every N months. */\n  MONTHLY_BY_DATE = 4,\n  /** Repeat on same day of the year every N years. */\n  YEARLY = 5,\n}\n\n/** Additional settings for events with weekly recurrence. */", "export interface WeeklyRecurrenceSettings {\n  /** Array of 7 booleans specifying which days of the week the event recurs on.\n   *\n   * Index 0 = Sunday, 1 = Monday, etc. For example, the following indicates an\n   * event that recurs on Monday, Wednesday and Friday:\n   *\n   *   [false, true, false, true, false, true, false]\n   */\n  days: [boolean, boolean, boolean, boolean, boolean, boolean, boolean];\n  /** Day of the week that weeks start on - 0 for Sunday, 1 for Monday.\n   *\n   * This affects events that repeat every 2nd Sunday (or higher interval).\n   */\n  firstDayOfWeek: number;\n}\n\n/** Additional settings for events with monthly-by-day recurrence frequency. */", "export interface MonthlyByDayRecurrenceSettings {\n  /** Week number within the month.\n   *\n   * 0 = 1st week of the month\n   * 1 = 2nd week of the month\n   * ...\n   * 5 = last week of the month\n   */\n  weekOfMonth: number;\n  /** Day of week.\n   *\n   * 0 = Sunday, 1 = Monday, etc.\n   */\n  day: number;\n}\n/** Event recurrence settings. */", "export class RecurrenceSettings extends SObject {\n  /** Frequency of this recurring event. */\n  @field(SUInt8.enum(RecurrenceFrequency))\n  frequency = RecurrenceFrequency.DAILY;\n\n  @field(SUInt8)\n  private padding1 = 0;\n\n  /** Recurrence end date. If null, the event repeats forever. */\n  @field(OptionalDatabaseDate)\n  endDate: DatabaseDate | null = null;\n\n  /** The interval at which the event repeats (every N days / weeks / months /\n   * years). */\n  @field(SUInt8)\n  interval = 1;\n\n  /** Additional settings for WEEKLY frequency.\n   *\n   * Required if frequency is WEEKLY.\n   */\n  weekly: WeeklyRecurrenceSettings | null = null;\n\n  /** Additional settings for MONTHLY_BY_DAY frequency.\n   *\n   * Required if frequency is MONTHLY_BY_DAY.\n   */\n  monthlyByDay: MonthlyByDayRecurrenceSettings | null = null;\n\n  @field(SUInt8)\n  private arg1 = 0;\n  @field(SUInt8)\n  private arg2 = 0;\n\n  @field(SUInt8)\n  private padding2 = 0;\n\n  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n    const offset = super.deserialize(buffer, opts);\n    this.weekly = null;\n    this.monthlyByDay = null;\n    switch (this.frequency) {\n      case RecurrenceFrequency.DAILY:\n      case RecurrenceFrequency.MONTHLY_BY_DATE:\n      case RecurrenceFrequency.YEARLY:\n        break;\n      case RecurrenceFrequency.WEEKLY:\n        const days = times(\n          7,\n          (i) => !!(this.arg1 & (1 << i))\n        ) as WeeklyRecurrenceSettings['days'];\n        const firstDayOfWeek = this.arg2;\n        this.weekly = {days, firstDayOfWeek};\n        break;\n      case RecurrenceFrequency.MONTHLY_BY_DAY:\n        const weekOfMonth = Math.floor(this.arg1 / 7);\n        const day = this.arg1 % 7;\n        this.monthlyByDay = {weekOfMonth, day};\n        break;\n      default:\n        throw new Error(`Invalid frequency type: ${this.frequency}`);\n    }\n\n    return offset;\n  }\n\n  serialize(opts?: SerializeOptions) {\n    switch (this.frequency) {\n      case RecurrenceFrequency.DAILY:\n      case RecurrenceFrequency.MONTHLY_BY_DATE:\n      case RecurrenceFrequency.YEARLY:\n        this.arg1 = 0;\n        this.arg2 = 0;\n        break;\n      case RecurrenceFrequency.WEEKLY:", "        if (!this.weekly) {\n          throw new Error('`weekly` must be set when frequency is WEEKLY');\n        }\n        const {days, firstDayOfWeek} = this.weekly;\n        if (days.length !== 7) {\n          throw new Error(\n            `Days array must have exactly 7 elements, found ${days.length}`\n          );\n        }\n        this.arg1 = 0;\n        for (let i = 0; i < 7; ++i) {", "        for (let i = 0; i < 7; ++i) {\n          if (days[i]) {\n            this.arg1 |= 1 << i;\n          }\n        }\n        if (firstDayOfWeek < 0 || firstDayOfWeek > 1) {\n          throw new Error(`Invalid first day of week: ${firstDayOfWeek}`);\n        }\n        this.arg2 = firstDayOfWeek;\n        break;\n      case RecurrenceFrequency.MONTHLY_BY_DAY:", "        if (!this.monthlyByDay) {\n          throw new Error(\n            '`monthlyByDay` must be set when frequency is MONTHLY_BY_DAY'\n          );\n        }\n        const {weekOfMonth, day} = this.monthlyByDay;\n        if (weekOfMonth < 0 || weekOfMonth > 5) {\n          throw new Error(`Invalid week of month: ${weekOfMonth}`);\n        }\n        if (day < 0 || day > 7) {\n          throw new Error(`Invalid day of week: ${day}`);\n        }\n        this.arg1 = weekOfMonth * 7 + day;\n        this.arg2 = 0;\n        break;\n      default:\n        throw new Error(`Invalid frequency type: ${this.frequency}`);\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** DatebookDB database.\n *\n * References:\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/datebook.c\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Datebook.pm\n */", "        if (day < 0 || day > 7) {\n          throw new Error(`Invalid day of week: ${day}`);\n        }\n        this.arg1 = weekOfMonth * 7 + day;\n        this.arg2 = 0;\n        break;\n      default:\n        throw new Error(`Invalid frequency type: ${this.frequency}`);\n    }\n    return super.serialize(opts);\n  }\n}\n\n/** DatebookDB database.\n *\n * References:\n *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/datebook.c\n *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Datebook.pm\n */", "export class DatebookDatabase extends PdbDatabase.of(\n  DatebookRecord,\n  DatebookAppInfo\n) {\n  header = DatabaseHdrType.with({\n    name: 'DatebookDB',\n    type: 'DATA',\n    creator: 'date',\n  });\n}\n"]}
{"filename": "src/bin/palmdoc.ts", "chunked_list": ["#!/usr/bin/env node\n\nimport {program} from 'commander';\nimport fs from 'fs-extra';\nimport iconv from 'iconv-lite';\nimport path from 'path';\nimport {DEFAULT_ENCODING, PalmDoc} from '..';\n// Not using resolveJsonModule because it causes the output to be generated\n// relative to the root directory instead of src/.\nconst packageJson = require('../../package.json');", "// relative to the root directory instead of src/.\nconst packageJson = require('../../package.json');\n\nif (require.main === module) {\n  (async () => {\n    program.name('palmdoc').version(packageJson.version);\n\n    program\n      .command('decode <document.pdb>')\n      .description('Decode a PalmDOC PDB file to text.')\n      .option(\n        '--input-encoding <encoding>',\n        'text encoding of input PalmDOC PDB file',\n        DEFAULT_ENCODING\n      )\n      .option(\n        '--output-encoding <encoding>',\n        'text encoding for output text file',\n        'utf-8'\n      )\n      .option('-o, --output <document.txt>', 'path to output text file')\n      .action(async (inputFilePath: string, opts: any) => {\n        const doc = new PalmDoc();", "        try {\n          const buffer = await fs.readFile(inputFilePath);\n          doc.deserialize(buffer, {encoding: opts.inputEncoding});\n        } catch (e: any) {\n          console.error(`Could not open '${inputFilePath}': ${e.message}`);\n          process.exit(1);\n        }\n        const outputFilePath =\n          opts.output || replaceOrAddFileExt(inputFilePath, 'pdb', 'txt');\n        await fs.writeFile(outputFilePath, doc.text, opts.outputEncoding);\n      });\n\n    program\n      .command('encode <document.txt>')\n      .description('Encode a text file to PalmDOC PDB format.')\n      .option(\n        '--input-encoding <encoding>',\n        'text encoding of input text file',\n        'utf-8'\n      )\n      .option(\n        '--output-encoding <encoding>',\n        'text encoding for output PalmDOC PDB file',\n        DEFAULT_ENCODING\n      )\n      .option(\n        '-n, --name <document name>',\n        'document name (default: file name)'\n      )\n      .option('--compress', 'enable compression', true)\n      .option('--no-compress', 'disable compression')\n      .option('-o, --output <document.pdb>', 'path to output PalmDOC PDB file')\n      .action(async (inputFilePath: string, opts: any) => {\n        const doc = new PalmDoc();", "        try {\n          doc.text = iconv.decode(\n            await fs.readFile(inputFilePath),\n            opts.inputEncoding\n          );\n        } catch (e: any) {\n          console.error(`Could not open '${inputFilePath}': ${e.message}`);\n          process.exit(1);\n        }\n        doc.name = opts.name || path.basename(inputFilePath);\n        const outputFilePath =\n          opts.output || replaceOrAddFileExt(inputFilePath, 'txt', 'pdb');\n        await fs.writeFile(\n          outputFilePath,\n          doc.serialize({\n            encoding: opts.outputEncoding,\n            enableCompression: !!opts.compress,\n          })\n        );\n      });\n\n    await program.parseAsync();\n  })();\n}\n\n/** Replace file extension in a path (case insenstive). */", "function replaceOrAddFileExt(filePath: string, oldExt: string, newExt: string) {\n  if (filePath.toLowerCase().endsWith(`.${oldExt.toLowerCase()}`)) {\n    return filePath.substr(0, filePath.length - oldExt.length) + newExt;\n  } else {\n    return `${filePath}.${newExt}`;\n  }\n}\n"]}
{"filename": "src/bin/pdb2json.ts", "chunked_list": ["#!/usr/bin/env node\n\nimport {program} from 'commander';\nimport fs from 'fs-extra';\nimport {\n  AddressDatabase,\n  DatebookDatabase,\n  DEFAULT_ENCODING,\n  MemoDatabase,\n  PalmDocDatabase,", "  MemoDatabase,\n  PalmDocDatabase,\n  PdbDatabase,\n  RawPdbDatabase,\n  ToDoDatabase,\n} from '..';\n// Not using resolveJsonModule because it causes the output to be generated\n// relative to the root directory instead of src/.\nconst packageJson = require('../../package.json');\n\ninterface DatabaseRegistryEntry {\n  creator: string;\n  type: string;\n  databaseType: new () => PdbDatabase<any, any, any>;\n  label: string;\n}\n\nconst DATABASE_REGISTRY: Array<DatabaseRegistryEntry> = [\n  {creator: 'memo', type: 'DATA', databaseType: MemoDatabase, label: 'Memo'},\n  {creator: 'todo', type: 'DATA', databaseType: ToDoDatabase, label: 'ToDo'},\n  {\n    creator: 'date',\n    type: 'DATA',\n    databaseType: DatebookDatabase,\n    label: 'Datebook',\n  },\n  {\n    creator: 'addr',\n    type: 'DATA',\n    databaseType: AddressDatabase,\n    label: 'Address',\n  },\n  {\n    creator: 'REAd',\n    type: 'TEXt',\n    databaseType: PalmDocDatabase,\n    label: 'PalmDOC',\n  },\n];\n", "const packageJson = require('../../package.json');\n\ninterface DatabaseRegistryEntry {\n  creator: string;\n  type: string;\n  databaseType: new () => PdbDatabase<any, any, any>;\n  label: string;\n}\n\nconst DATABASE_REGISTRY: Array<DatabaseRegistryEntry> = [\n  {creator: 'memo', type: 'DATA', databaseType: MemoDatabase, label: 'Memo'},\n  {creator: 'todo', type: 'DATA', databaseType: ToDoDatabase, label: 'ToDo'},\n  {\n    creator: 'date',\n    type: 'DATA',\n    databaseType: DatebookDatabase,\n    label: 'Datebook',\n  },\n  {\n    creator: 'addr',\n    type: 'DATA',\n    databaseType: AddressDatabase,\n    label: 'Address',\n  },\n  {\n    creator: 'REAd',\n    type: 'TEXt',\n    databaseType: PalmDocDatabase,\n    label: 'PalmDOC',\n  },\n];\n", "if (require.main === module) {\n  (async () => {\n    program.name('pdb2json').version(packageJson.version);\n\n    program\n      .description(\n        [\n          'Decode a PDB file and print it to JSON.',\n          'Supported formats: ' +\n            DATABASE_REGISTRY.map(({label}) => label).join(', '),\n        ].join('\\n')\n      )\n      .argument('<pdb-file>', 'Path to PDB file')\n      .option(\n        '--input-encoding <encoding>',\n        'text encoding of input PalmDOC PDB file',\n        DEFAULT_ENCODING\n      )\n      .action(async (inputFilePath, options) => {\n        // Read input file into buffer.\n        let pdbBuffer: Buffer;\n        let rawDb: RawPdbDatabase;", "        try {\n          pdbBuffer = await fs.readFile(inputFilePath);\n          rawDb = RawPdbDatabase.from(pdbBuffer);\n        } catch (e: any) {\n          console.error(`Could not open '${inputFilePath}': ${e.message}`);\n          process.exit(1);\n        }\n\n        // Find corresponding database type.\n        const {creator, type} = rawDb.header;\n        const dbRegistryEntry = DATABASE_REGISTRY.find(\n          (entry) => entry.creator === creator && entry.type === type\n        );", "        if (!dbRegistryEntry) {\n          console.error(\n            `Unknown database type: creator \"${creator}\", type \"${type}\"`\n          );\n          process.exit(1);\n        }\n\n        // Re-parse the file using the correct database.\n        const db = new dbRegistryEntry.databaseType();\n        try {\n          db.deserialize(pdbBuffer, {encoding: options.inputEncoding});", "        try {\n          db.deserialize(pdbBuffer, {encoding: options.inputEncoding});\n        } catch (e: any) {\n          console.error(`Could not parse '${inputFilePath}': ${e.message}`);\n          process.exit(1);\n        }\n\n        // Print out result.\n        console.log(JSON.stringify(db, null, 4));\n      });\n\n    await program.parseAsync();\n  })();\n}\n"]}
{"filename": "src/tests/todo-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\nimport pick from 'lodash/pick';\nimport path from 'path';\nimport {Category, DatabaseDate, ToDoDatabase, ToDoRecord} from '..';\n\ndescribe('ToDoDatabase', function () {\n  test('load test database', async function () {\n    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'ToDoDB.pdb')\n    );", "      path.join(__dirname, 'testdata', 'ToDoDB.pdb')\n    );\n    const db = ToDoDatabase.from(buffer);\n\n    expect(db.header).toMatchObject(\n      pick(new ToDoDatabase().header, ['name', 'type', 'creator'])\n    );\n    expect(db.appInfo?.categories.length).toStrictEqual(3);\n    expect(db.records.length).toStrictEqual(3);\n    for (const record of db.records) {\n      expect(record.description.length).toBeGreaterThan(1);\n      expect(record.priority).toStrictEqual(1);\n      expect(record.isCompleted).toStrictEqual(false);\n    }\n\n    let dueDate0 = db.records[0].dueDate;\n    expect(dueDate0?.year).toStrictEqual(2021);\n    expect(dueDate0?.month).toStrictEqual(1);\n    expect(dueDate0?.dayOfMonth).toStrictEqual(21);\n\n    expect(db.records[2].dueDate).toBeNull();\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new ToDoDatabase();\n    db1.appInfo!.categories = [", "    expect(db.records.length).toStrictEqual(3);\n    for (const record of db.records) {\n      expect(record.description.length).toBeGreaterThan(1);\n      expect(record.priority).toStrictEqual(1);\n      expect(record.isCompleted).toStrictEqual(false);\n    }\n\n    let dueDate0 = db.records[0].dueDate;\n    expect(dueDate0?.year).toStrictEqual(2021);\n    expect(dueDate0?.month).toStrictEqual(1);\n    expect(dueDate0?.dayOfMonth).toStrictEqual(21);\n\n    expect(db.records[2].dueDate).toBeNull();\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new ToDoDatabase();\n    db1.appInfo!.categories = [", "      Category.with({label: 'Unfiled', uniqId: 0, isRenamed: false}),\n      Category.with({label: 'Personal', uniqId: 1, isRenamed: false}),\n    ];\n    for (let i = 0; i < 10; ++i) {\n      const record = new ToDoRecord();\n      record.description = `Task #${i}`;\n      record.note = `Note #${i}`;\n      record.priority = i + 1;\n      record.isCompleted = !!(i % 2);\n      if (i % 3) {\n        record.dueDate = DatabaseDate.of(new Date(2000 + i, 0, 1));\n      }\n      db1.records.push(record);\n    }\n\n    // Serialize to buffer and deserialize back into db2.\n    const buffer = db1.serialize();\n    const db2 = ToDoDatabase.from(buffer);\n\n    // Check db2 contents.\n    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n    expect(db2.records.length).toStrictEqual(db1.records.length);", "      if (i % 3) {\n        record.dueDate = DatabaseDate.of(new Date(2000 + i, 0, 1));\n      }\n      db1.records.push(record);\n    }\n\n    // Serialize to buffer and deserialize back into db2.\n    const buffer = db1.serialize();\n    const db2 = ToDoDatabase.from(buffer);\n\n    // Check db2 contents.\n    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n    expect(db2.records.length).toStrictEqual(db1.records.length);", "    for (let i = 0; i < db1.records.length; ++i) {\n      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n    }\n  });\n});\n"]}
{"filename": "src/tests/palmdoc-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\nimport _ from 'lodash';\nimport path from 'path';\nimport {DeserializeOptions} from 'serio';\nimport {PalmDoc, PalmDocSerializeOptions} from '..';\n\ndescribe('PalmDoc', function () {\n  test('load test database', async function () {\n    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'OnBoardHeaderV40.pdb')", "    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'OnBoardHeaderV40.pdb')\n    );\n    const doc = PalmDoc.from(buffer);\n\n    expect(doc.text).toContain('#define NULL 0');\n  });\n\n  for (const {label, text, serializeOpts, parseOpts} of [\n    {label: '\"Hello, world!\"', text: 'Hello, world!'},\n    {\n      label: '\"Hello, world!\" repeated 10K times',\n      text: 'Hello, world!'.repeat(10000),\n    },\n    {\n      label: '0x00 repeated 10K times',\n      text: '\\x00'.repeat(10000),\n    },\n    ..._.times(3, (n) => ({\n      label: `10K random base64 letters and spaces (pass #${n})`,\n      text: _.times(10000, () =>\n        generateRandomBuffer(Math.floor(1 + Math.random() * 10)).toString(\n          'base64'\n        )\n      ).join(' '),\n    })),\n    ..._.times(3, () => ({\n      label: 'base64 encoded random buffer of size 100K (pass #${n})',\n      text: generateRandomBuffer(100000).toString('base64'),\n    })),\n    {\n      label: '\u6c49\u8bed',\n      text: '\u6c49\u8bed\uff0c\u53c8\u79f0\u4e2d\u6587\u3001\u5510\u8bdd\u3001\u534e\u8bed\uff0c\u6307\u6574\u4e2a\u6c49\u8bed\u65cf\u6216\u8005\u5176\u8bed\u65cf\u91cc\u7684\u4e00\u79cd\u8bed\u8a00\u3002',\n      serializeOpts: {\n        encoding: 'gb2312',\n        enableCompression: true,\n      },\n      parseOpts: {\n        encoding: 'gb2312',\n      },\n    },\n    {\n      label: '\u6f22\u8a9e',\n      text: '\u6f22\u8a9e\uff0c\u53c8\u7a31\u4e2d\u6587\u3001\u5510\u8a71\u3001\u83ef\u8a9e\uff0c\u6307\u6574\u500b\u6f22\u8a9e\u65cf\u6216\u8005\u5176\u8a9e\u65cf\u91cc\u7684\u4e00\u7a2e\u8a9e\u8a00\u3002',\n      serializeOpts: {\n        encoding: 'big5',\n        enableCompression: true,\n      },\n      parseOpts: {\n        encoding: 'big5',\n      },\n    },\n    {\n      label: '\u65e5\u672c\u8a9e',\n      text: '\u65e5\u672c\u8a9e\uff08\u306b\u307b\u3093\u3054\u3001\u306b\u3063\u307d\u3093\u3054\u3001\u82f1: Japanese\uff09\u306f\u3001\u4e3b\u306b\u65e5\u672c\u56fd\u5185\u3084\u65e5\u672c\u4eba\u540c\u58eb\u306e\u9593\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b\u8a00\u8a9e\u3002',\n      serializeOpts: {\n        encoding: 'shiftjis',\n        enableCompression: true,\n      },\n      parseOpts: {\n        encoding: 'shiftjis',\n      },\n    },\n  ] as Array<{\n    label: string;\n    text: string;\n    serializeOpts?: PalmDocSerializeOptions;\n    parseOpts?: DeserializeOptions;\n  }>) {\n    test(`serialize ${label}`, async function () {\n      // Create doc1.\n      const doc1 = new PalmDoc();\n      doc1.name = label.substring(0, 31);\n      doc1.text = text;\n\n      // Serialize to buffer and deserialize back into doc2.\n      const buffer = doc1.serialize(serializeOpts);\n      const doc2 = PalmDoc.from(buffer, parseOpts);\n\n      // Check doc2 contents.\n      expect(doc2.name).toStrictEqual(doc1.name);\n      expect(doc2.text).toStrictEqual(doc1.text);\n    });\n  }\n});\n\n/** Fill a Buffer of length n with random numbers. */", "  for (const {label, text, serializeOpts, parseOpts} of [\n    {label: '\"Hello, world!\"', text: 'Hello, world!'},\n    {\n      label: '\"Hello, world!\" repeated 10K times',\n      text: 'Hello, world!'.repeat(10000),\n    },\n    {\n      label: '0x00 repeated 10K times',\n      text: '\\x00'.repeat(10000),\n    },\n    ..._.times(3, (n) => ({\n      label: `10K random base64 letters and spaces (pass #${n})`,\n      text: _.times(10000, () =>\n        generateRandomBuffer(Math.floor(1 + Math.random() * 10)).toString(\n          'base64'\n        )\n      ).join(' '),\n    })),\n    ..._.times(3, () => ({\n      label: 'base64 encoded random buffer of size 100K (pass #${n})',\n      text: generateRandomBuffer(100000).toString('base64'),\n    })),\n    {\n      label: '\u6c49\u8bed',\n      text: '\u6c49\u8bed\uff0c\u53c8\u79f0\u4e2d\u6587\u3001\u5510\u8bdd\u3001\u534e\u8bed\uff0c\u6307\u6574\u4e2a\u6c49\u8bed\u65cf\u6216\u8005\u5176\u8bed\u65cf\u91cc\u7684\u4e00\u79cd\u8bed\u8a00\u3002',\n      serializeOpts: {\n        encoding: 'gb2312',\n        enableCompression: true,\n      },\n      parseOpts: {\n        encoding: 'gb2312',\n      },\n    },\n    {\n      label: '\u6f22\u8a9e',\n      text: '\u6f22\u8a9e\uff0c\u53c8\u7a31\u4e2d\u6587\u3001\u5510\u8a71\u3001\u83ef\u8a9e\uff0c\u6307\u6574\u500b\u6f22\u8a9e\u65cf\u6216\u8005\u5176\u8a9e\u65cf\u91cc\u7684\u4e00\u7a2e\u8a9e\u8a00\u3002',\n      serializeOpts: {\n        encoding: 'big5',\n        enableCompression: true,\n      },\n      parseOpts: {\n        encoding: 'big5',\n      },\n    },\n    {\n      label: '\u65e5\u672c\u8a9e',\n      text: '\u65e5\u672c\u8a9e\uff08\u306b\u307b\u3093\u3054\u3001\u306b\u3063\u307d\u3093\u3054\u3001\u82f1: Japanese\uff09\u306f\u3001\u4e3b\u306b\u65e5\u672c\u56fd\u5185\u3084\u65e5\u672c\u4eba\u540c\u58eb\u306e\u9593\u3067\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b\u8a00\u8a9e\u3002',\n      serializeOpts: {\n        encoding: 'shiftjis',\n        enableCompression: true,\n      },\n      parseOpts: {\n        encoding: 'shiftjis',\n      },\n    },\n  ] as Array<{\n    label: string;\n    text: string;\n    serializeOpts?: PalmDocSerializeOptions;\n    parseOpts?: DeserializeOptions;\n  }>) {\n    test(`serialize ${label}`, async function () {\n      // Create doc1.\n      const doc1 = new PalmDoc();\n      doc1.name = label.substring(0, 31);\n      doc1.text = text;\n\n      // Serialize to buffer and deserialize back into doc2.\n      const buffer = doc1.serialize(serializeOpts);\n      const doc2 = PalmDoc.from(buffer, parseOpts);\n\n      // Check doc2 contents.\n      expect(doc2.name).toStrictEqual(doc1.name);\n      expect(doc2.text).toStrictEqual(doc1.text);\n    });\n  }\n});\n\n/** Fill a Buffer of length n with random numbers. */", "function generateRandomBuffer(n: number) {\n  const buffer = Buffer.alloc(n);\n  let i = 0;\n  while (i + 4 <= n) {\n    buffer.writeUInt32BE(Math.floor(Math.random() * 0x100000000), i);\n    i += 4;\n  }\n  while (i < n) {\n    buffer.writeUInt8(Math.floor(Math.random() * 0x100), i);\n    ++i;\n  }\n  return buffer;\n}\n"]}
{"filename": "src/tests/prc-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\nimport _ from 'lodash';\nimport path from 'path';\nimport {SmartBuffer} from 'smart-buffer';\nimport {RawPrcRecord, RawPrcDatabase} from '..';\n\ndescribe('PrcDatabase', function () {\n  test('load test database', async function () {\n    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'OnBoard.prc')", "    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'OnBoard.prc')\n    );\n    const db = RawPrcDatabase.from(buffer);\n\n    const recordsByType = _.groupBy(db.records, 'entry.type') as _.Dictionary<\n      Array<RawPrcRecord>\n    >;\n    for (const [type, resourceIds] of [\n      // Obtained from Simulator > View > Databases.\n      ['code', [0, 1, 2]],\n      ['data', [0]],\n      ['MBAR', [1000]],\n      ['pref', [0]],\n      ['tAIN', [1000]],\n      ['Tbmp', [1000, 1001, 1002, 1003, 1510, 1703, 2000, 2100, 2200, 2300]],\n      ['tFRM', [1100, 3400]],\n      ['tSTR', [1000]],\n      ['tver', [1000]],\n    ] as const) {\n      expect(recordsByType).toHaveProperty(type);\n      expect(\n        _.map(recordsByType[type], 'entry.resourceId').sort()\n      ).toStrictEqual(resourceIds);\n    }\n    expect(\n      SmartBuffer.fromBuffer(recordsByType['tAIN'][0].data).readStringNT()\n    ).toStrictEqual('OnBoard Asm');\n    expect(\n      SmartBuffer.fromBuffer(recordsByType['tver'][0].data).readStringNT()\n    ).toStrictEqual('2.5.1');\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new RawPrcDatabase();\n    db1.header.name = 'Foo';\n    expect(db1.header.attributes.resDB).toStrictEqual(true);\n    db1.header.type = 'appl';\n    db1.header.creator = 'TSt1';", "    for (const [type, resourceIds] of [\n      // Obtained from Simulator > View > Databases.\n      ['code', [0, 1, 2]],\n      ['data', [0]],\n      ['MBAR', [1000]],\n      ['pref', [0]],\n      ['tAIN', [1000]],\n      ['Tbmp', [1000, 1001, 1002, 1003, 1510, 1703, 2000, 2100, 2200, 2300]],\n      ['tFRM', [1100, 3400]],\n      ['tSTR', [1000]],\n      ['tver', [1000]],\n    ] as const) {\n      expect(recordsByType).toHaveProperty(type);\n      expect(\n        _.map(recordsByType[type], 'entry.resourceId').sort()\n      ).toStrictEqual(resourceIds);\n    }\n    expect(\n      SmartBuffer.fromBuffer(recordsByType['tAIN'][0].data).readStringNT()\n    ).toStrictEqual('OnBoard Asm');\n    expect(\n      SmartBuffer.fromBuffer(recordsByType['tver'][0].data).readStringNT()\n    ).toStrictEqual('2.5.1');\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new RawPrcDatabase();\n    db1.header.name = 'Foo';\n    expect(db1.header.attributes.resDB).toStrictEqual(true);\n    db1.header.type = 'appl';\n    db1.header.creator = 'TSt1';", "    for (let i = 0; i < 10; ++i) {\n      const record = new RawPrcRecord();\n      record.entry.type = 'code';\n      record.entry.resourceId = i;\n      record.data = new SmartBuffer().writeUInt32BE(i).toBuffer();\n      db1.records.push(record);\n    }\n\n    // Serialize to buffer and deserialize back into db2.\n    const buffer = db1.serialize();\n    const db2 = RawPrcDatabase.from(buffer);\n\n    // Check db2 contents.\n    expect(db2.records.length).toStrictEqual(db1.records.length);", "    for (let i = 0; i < db1.records.length; ++i) {\n      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n    }\n  });\n});\n"]}
{"filename": "src/tests/memo-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\nimport pick from 'lodash/pick';\nimport path from 'path';\nimport {Category, MemoDatabase, MemoRecord, MemoSortOrder} from '..';\n\ndescribe('MemoDatabase', function () {\n  test('load test database', async function () {\n    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'MemoDB.pdb')\n    );", "      path.join(__dirname, 'testdata', 'MemoDB.pdb')\n    );\n    const db = MemoDatabase.from(buffer);\n\n    expect(db.header).toMatchObject(\n      pick(new MemoDatabase().header, ['name', 'type', 'creator'])\n    );\n    expect(db.appInfo?.categories.length).toStrictEqual(3);\n    expect(db.records.length).toStrictEqual(5);\n    for (const record of db.records) {\n      expect(record.value.length).toBeGreaterThan(1);\n    }\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new MemoDatabase();\n    db1.appInfo!.categories = [", "    expect(db.records.length).toStrictEqual(5);\n    for (const record of db.records) {\n      expect(record.value.length).toBeGreaterThan(1);\n    }\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new MemoDatabase();\n    db1.appInfo!.categories = [\n      Category.with({label: 'Unfiled', uniqId: 0, isRenamed: false}),", "      Category.with({label: 'Unfiled', uniqId: 0, isRenamed: false}),\n      Category.with({label: 'Personal', uniqId: 1, isRenamed: false}),\n    ];\n    db1.appInfo!.sortOrder = MemoSortOrder.ALPHABETICAL;\n    for (let i = 0; i < 10; ++i) {\n      const record = new MemoRecord();\n      record.value = `Memo #${i}`;\n      db1.records.push(record);\n    }\n\n    // Serialize to buffer and deserialize back into db2.\n    const buffer = db1.serialize();\n    const db2 = MemoDatabase.from(buffer);\n\n    // Check db2 contents.\n    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n    expect(db2.appInfo?.sortOrder).toStrictEqual(db1.appInfo?.sortOrder);\n    expect(db2.records.length).toStrictEqual(db1.records.length);", "    for (let i = 0; i < db1.records.length; ++i) {\n      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n    }\n  });\n});\n"]}
{"filename": "src/tests/address-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\nimport pick from 'lodash/pick';\nimport path from 'path';\nimport {SObject, SStringNT} from 'serio';\nimport {\n  AddressCountry,\n  AddressDatabase,\n  AddressFieldType,\n  PHONE_NUMBER_FIELD_TYPES,\n  PhoneNumberType,", "  PHONE_NUMBER_FIELD_TYPES,\n  PhoneNumberType,\n} from '..';\n\nasync function loadTestDbAndDoBasicChecks(dbFile: string, encoding?: string) {\n  const buffer = await fs.readFile(path.join(__dirname, 'testdata', dbFile));\n  const db = AddressDatabase.from(buffer, {encoding});\n\n  expect(db.header).toMatchObject(\n    pick(new AddressDatabase().header, ['name', 'type', 'creator'])\n  );\n  expect((db.appInfo?.categories ?? []).length).toBeGreaterThan(0);\n  expect(db.records.length).toBeGreaterThan(0);", "  for (const record of db.records) {\n    expect(record.cells.length).toBeGreaterThan(0);\n    expect(Object.keys(record.phoneNumberTypeMapping)).toStrictEqual(\n      PHONE_NUMBER_FIELD_TYPES.map((t) => t.toString())\n    );\n  }\n  return db;\n}\n\nfunction mapToJson(array: Array<SObject>) {\n  return array.map((e) => e.toJSON());\n}\n\ndescribe('AddressDatabase', function () {\n  describe('load test databases', function () {\n    test(`load test database AddressDB-LifeDrive.pdb`, async function () {\n      const db = await loadTestDbAndDoBasicChecks('AddressDB-LifeDrive.pdb');\n      expect(mapToJson(db.appInfo!.categories)).toStrictEqual([\n        {\n          label: 'Unfiled',\n          uniqId: 0,\n          isRenamed: true,\n        },\n        {\n          label: 'Business',\n          uniqId: 1,\n          isRenamed: true,\n        },\n        {\n          label: 'Personal',\n          uniqId: 2,\n          isRenamed: true,\n        },\n        {\n          label: 'QuickList',\n          uniqId: 3,\n          isRenamed: true,\n        },\n      ]);\n      expect(db.appInfo?.fields).toStrictEqual([\n        {\n          type: AddressFieldType.LAST_NAME,\n          label: 'Last name',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.FIRST_NAME,\n          label: 'First name',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.COMPANY,\n          label: 'Company',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_1,\n          label: 'Work',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_2,\n          label: 'Home',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_3,\n          label: 'Fax',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_4,\n          label: 'Other',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_5,\n          label: 'E-mail',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.ADDRESS,\n          label: 'Addr(W)',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CITY,\n          label: 'City',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.STATE,\n          label: 'State',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.ZIP_CODE,\n          label: 'Zip Code',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.COUNTRY,\n          label: 'Country',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.TITLE,\n          label: 'Title',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.CUSTOM_1,\n          label: 'Custom 1',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_2,\n          label: 'Custom 2',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.CUSTOM_3,\n          label: 'Custom 3',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.CUSTOM_4,\n          label: 'Custom 4',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.NOTE,\n          label: 'Note',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_6,\n          label: 'Main',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_7,\n          label: 'Pager',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_8,\n          label: 'Mobile',\n          isRenamed: false,\n        },\n      ]);\n      expect(db.appInfo?.country).toStrictEqual(AddressCountry.UNITED_STATES);\n      expect(db.records).toHaveLength(2);\n      expect(db.records[1].phoneNumberTypeMapping).toStrictEqual({\n        [AddressFieldType.PHONE_1]: PhoneNumberType.MAIN,\n        [AddressFieldType.PHONE_2]: PhoneNumberType.OTHER,\n        [AddressFieldType.PHONE_3]: PhoneNumberType.MOBILE,\n        [AddressFieldType.PHONE_4]: PhoneNumberType.EMAIL,\n        [AddressFieldType.PHONE_5]: PhoneNumberType.MAIN,\n      });\n      expect(db.records[1].cells).toStrictEqual([\n        {\n          fieldType: AddressFieldType.LAST_NAME,\n          value: 'Technical Support',\n        },\n        {\n          fieldType: AddressFieldType.COMPANY,\n          value: 'palmOne, Inc.',\n        },\n        {\n          fieldType: AddressFieldType.PHONE_1,\n          phoneNumberType: PhoneNumberType.MAIN,\n          value: 'www.palmOne.com/support',\n        },\n        {\n          fieldType: AddressFieldType.PHONE_2,\n          phoneNumberType: PhoneNumberType.OTHER,\n          value: \"Int'l: www.palmOne.com/support/intl\",\n        },\n        {\n          fieldType: AddressFieldType.NOTE,\n          value:\n            'For the latest information on products and upgrades, check our web site regularly.',\n        },\n      ]);\n    });\n    test(`load test database AddressDB-Palm V-JP.pdb`, async function () {\n      const db = await loadTestDbAndDoBasicChecks(\n        'AddressDB-Palm V-JP.pdb',\n        'shiftjis'\n      );\n      expect(mapToJson(db.appInfo!.categories)).toStrictEqual([\n        {\n          label: '\u672a\u5206\u985e',\n          uniqId: 0,\n          isRenamed: true,\n        },\n        {\n          label: '\u30d3\u30b8\u30cd\u30b9',\n          uniqId: 1,\n          isRenamed: true,\n        },\n        {\n          label: '\u30d1\u30fc\u30bd\u30ca\u30eb',\n          uniqId: 2,\n          isRenamed: true,\n        },\n        {\n          label: '\u30af\u30a4\u30c3\u30af\u30ea\u30b9\u30c8',\n          uniqId: 3,\n          isRenamed: true,\n        },\n      ]);\n      expect(db.appInfo?.fields).toStrictEqual([\n        {\n          type: AddressFieldType.LAST_NAME,\n          label: '\u59d3',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.FIRST_NAME,\n          label: '\u540d',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.COMPANY,\n          label: '\u4f1a\u793e\u540d',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_1,\n          label: '\u4f1a\u793e',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_2,\n          label: '\u81ea\u5b85',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_3,\n          label: 'Fax',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_4,\n          label: '\u305d\u306e\u4ed6',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_5,\n          label: 'E-mail',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.ADDRESS,\n          label: '\u4f4f\u6240',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CITY,\n          label: '\u5e02\u753a\u6751',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.STATE,\n          label: '\u90fd\u9053\u5e9c\u770c',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.ZIP_CODE,\n          label: '\u90f5\u4fbf\u756a\u53f7',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.COUNTRY,\n          label: '\u56fd',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.TITLE,\n          label: '\u5f79\u8077',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_1,\n          label: '\u30ab\u30b9\u30bf\u30e0 1',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_2,\n          label: '\u30ab\u30b9\u30bf\u30e0 2',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_3,\n          label: '\u30ab\u30b9\u30bf\u30e0 3',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_4,\n          label: '\u30ab\u30b9\u30bf\u30e0 4',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.NOTE,\n          label: '\uff7a\uff92\uff9d\uff84',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_6,\n          label: '\u4ee3\u8868',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_7,\n          label: '\u30dd\u30b1\u30d9\u30eb',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_8,\n          label: '\u643a\u5e2f',\n          isRenamed: true,\n        },\n      ]);\n      expect(db.appInfo?.country).toStrictEqual(AddressCountry.JAPAN);\n      expect(db.records).toHaveLength(1);\n      expect(db.records[0].phoneNumberTypeMapping).toStrictEqual({\n        [AddressFieldType.PHONE_1]: PhoneNumberType.WORK,\n        [AddressFieldType.PHONE_2]: PhoneNumberType.HOME,\n        [AddressFieldType.PHONE_3]: PhoneNumberType.FAX,\n        [AddressFieldType.PHONE_4]: PhoneNumberType.OTHER,\n        [AddressFieldType.PHONE_5]: PhoneNumberType.EMAIL,\n      });\n      expect(db.records[0].cells).toStrictEqual([\n        {\n          fieldType: AddressFieldType.LAST_NAME,\n          value: '\u7530\u4e2d\\u0001\u305f\u306a\u304b',\n        },\n        {\n          fieldType: AddressFieldType.FIRST_NAME,\n          value: '\u592a\u90ce\\u0001\u305f\u308d\u3046',\n        },\n        {\n          fieldType: AddressFieldType.ADDRESS,\n          value: '\u6e2f\u533a\u516d\u672c\u67286\u4e01\u76ee10\u30fc1',\n        },\n        {\n          fieldType: AddressFieldType.STATE,\n          value: '\u6771\u4eac\u90fd',\n        },\n        {\n          fieldType: AddressFieldType.ZIP_CODE,\n          value: '106-6126',\n        },\n        {\n          fieldType: AddressFieldType.COUNTRY,\n          value: '\u65e5\u672c',\n        },\n      ]);\n    });\n    test(`load test database AddressDB-Palm V-FR.pdb`, async function () {\n      const db = await loadTestDbAndDoBasicChecks('AddressDB-Palm V-FR.pdb');\n      expect(db.appInfo?.country).toStrictEqual(AddressCountry.FRANCE);\n      expect(db.records).toHaveLength(2);\n    });\n  });\n\n  describe('serialize', function () {\n    test(`using test database AddressDB-LifeDrive.pdb`, async function () {\n      const db1 = await loadTestDbAndDoBasicChecks('AddressDB-LifeDrive.pdb');\n      const db2 = AddressDatabase.from(db1.serialize());\n      expect(db2.records).toHaveLength(db1.records.length);", "function mapToJson(array: Array<SObject>) {\n  return array.map((e) => e.toJSON());\n}\n\ndescribe('AddressDatabase', function () {\n  describe('load test databases', function () {\n    test(`load test database AddressDB-LifeDrive.pdb`, async function () {\n      const db = await loadTestDbAndDoBasicChecks('AddressDB-LifeDrive.pdb');\n      expect(mapToJson(db.appInfo!.categories)).toStrictEqual([\n        {\n          label: 'Unfiled',\n          uniqId: 0,\n          isRenamed: true,\n        },\n        {\n          label: 'Business',\n          uniqId: 1,\n          isRenamed: true,\n        },\n        {\n          label: 'Personal',\n          uniqId: 2,\n          isRenamed: true,\n        },\n        {\n          label: 'QuickList',\n          uniqId: 3,\n          isRenamed: true,\n        },\n      ]);\n      expect(db.appInfo?.fields).toStrictEqual([\n        {\n          type: AddressFieldType.LAST_NAME,\n          label: 'Last name',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.FIRST_NAME,\n          label: 'First name',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.COMPANY,\n          label: 'Company',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_1,\n          label: 'Work',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_2,\n          label: 'Home',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_3,\n          label: 'Fax',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_4,\n          label: 'Other',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_5,\n          label: 'E-mail',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.ADDRESS,\n          label: 'Addr(W)',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CITY,\n          label: 'City',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.STATE,\n          label: 'State',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.ZIP_CODE,\n          label: 'Zip Code',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.COUNTRY,\n          label: 'Country',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.TITLE,\n          label: 'Title',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.CUSTOM_1,\n          label: 'Custom 1',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_2,\n          label: 'Custom 2',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.CUSTOM_3,\n          label: 'Custom 3',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.CUSTOM_4,\n          label: 'Custom 4',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.NOTE,\n          label: 'Note',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_6,\n          label: 'Main',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_7,\n          label: 'Pager',\n          isRenamed: false,\n        },\n        {\n          type: AddressFieldType.PHONE_8,\n          label: 'Mobile',\n          isRenamed: false,\n        },\n      ]);\n      expect(db.appInfo?.country).toStrictEqual(AddressCountry.UNITED_STATES);\n      expect(db.records).toHaveLength(2);\n      expect(db.records[1].phoneNumberTypeMapping).toStrictEqual({\n        [AddressFieldType.PHONE_1]: PhoneNumberType.MAIN,\n        [AddressFieldType.PHONE_2]: PhoneNumberType.OTHER,\n        [AddressFieldType.PHONE_3]: PhoneNumberType.MOBILE,\n        [AddressFieldType.PHONE_4]: PhoneNumberType.EMAIL,\n        [AddressFieldType.PHONE_5]: PhoneNumberType.MAIN,\n      });\n      expect(db.records[1].cells).toStrictEqual([\n        {\n          fieldType: AddressFieldType.LAST_NAME,\n          value: 'Technical Support',\n        },\n        {\n          fieldType: AddressFieldType.COMPANY,\n          value: 'palmOne, Inc.',\n        },\n        {\n          fieldType: AddressFieldType.PHONE_1,\n          phoneNumberType: PhoneNumberType.MAIN,\n          value: 'www.palmOne.com/support',\n        },\n        {\n          fieldType: AddressFieldType.PHONE_2,\n          phoneNumberType: PhoneNumberType.OTHER,\n          value: \"Int'l: www.palmOne.com/support/intl\",\n        },\n        {\n          fieldType: AddressFieldType.NOTE,\n          value:\n            'For the latest information on products and upgrades, check our web site regularly.',\n        },\n      ]);\n    });\n    test(`load test database AddressDB-Palm V-JP.pdb`, async function () {\n      const db = await loadTestDbAndDoBasicChecks(\n        'AddressDB-Palm V-JP.pdb',\n        'shiftjis'\n      );\n      expect(mapToJson(db.appInfo!.categories)).toStrictEqual([\n        {\n          label: '\u672a\u5206\u985e',\n          uniqId: 0,\n          isRenamed: true,\n        },\n        {\n          label: '\u30d3\u30b8\u30cd\u30b9',\n          uniqId: 1,\n          isRenamed: true,\n        },\n        {\n          label: '\u30d1\u30fc\u30bd\u30ca\u30eb',\n          uniqId: 2,\n          isRenamed: true,\n        },\n        {\n          label: '\u30af\u30a4\u30c3\u30af\u30ea\u30b9\u30c8',\n          uniqId: 3,\n          isRenamed: true,\n        },\n      ]);\n      expect(db.appInfo?.fields).toStrictEqual([\n        {\n          type: AddressFieldType.LAST_NAME,\n          label: '\u59d3',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.FIRST_NAME,\n          label: '\u540d',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.COMPANY,\n          label: '\u4f1a\u793e\u540d',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_1,\n          label: '\u4f1a\u793e',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_2,\n          label: '\u81ea\u5b85',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_3,\n          label: 'Fax',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_4,\n          label: '\u305d\u306e\u4ed6',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_5,\n          label: 'E-mail',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.ADDRESS,\n          label: '\u4f4f\u6240',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CITY,\n          label: '\u5e02\u753a\u6751',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.STATE,\n          label: '\u90fd\u9053\u5e9c\u770c',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.ZIP_CODE,\n          label: '\u90f5\u4fbf\u756a\u53f7',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.COUNTRY,\n          label: '\u56fd',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.TITLE,\n          label: '\u5f79\u8077',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_1,\n          label: '\u30ab\u30b9\u30bf\u30e0 1',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_2,\n          label: '\u30ab\u30b9\u30bf\u30e0 2',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_3,\n          label: '\u30ab\u30b9\u30bf\u30e0 3',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.CUSTOM_4,\n          label: '\u30ab\u30b9\u30bf\u30e0 4',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.NOTE,\n          label: '\uff7a\uff92\uff9d\uff84',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_6,\n          label: '\u4ee3\u8868',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_7,\n          label: '\u30dd\u30b1\u30d9\u30eb',\n          isRenamed: true,\n        },\n        {\n          type: AddressFieldType.PHONE_8,\n          label: '\u643a\u5e2f',\n          isRenamed: true,\n        },\n      ]);\n      expect(db.appInfo?.country).toStrictEqual(AddressCountry.JAPAN);\n      expect(db.records).toHaveLength(1);\n      expect(db.records[0].phoneNumberTypeMapping).toStrictEqual({\n        [AddressFieldType.PHONE_1]: PhoneNumberType.WORK,\n        [AddressFieldType.PHONE_2]: PhoneNumberType.HOME,\n        [AddressFieldType.PHONE_3]: PhoneNumberType.FAX,\n        [AddressFieldType.PHONE_4]: PhoneNumberType.OTHER,\n        [AddressFieldType.PHONE_5]: PhoneNumberType.EMAIL,\n      });\n      expect(db.records[0].cells).toStrictEqual([\n        {\n          fieldType: AddressFieldType.LAST_NAME,\n          value: '\u7530\u4e2d\\u0001\u305f\u306a\u304b',\n        },\n        {\n          fieldType: AddressFieldType.FIRST_NAME,\n          value: '\u592a\u90ce\\u0001\u305f\u308d\u3046',\n        },\n        {\n          fieldType: AddressFieldType.ADDRESS,\n          value: '\u6e2f\u533a\u516d\u672c\u67286\u4e01\u76ee10\u30fc1',\n        },\n        {\n          fieldType: AddressFieldType.STATE,\n          value: '\u6771\u4eac\u90fd',\n        },\n        {\n          fieldType: AddressFieldType.ZIP_CODE,\n          value: '106-6126',\n        },\n        {\n          fieldType: AddressFieldType.COUNTRY,\n          value: '\u65e5\u672c',\n        },\n      ]);\n    });\n    test(`load test database AddressDB-Palm V-FR.pdb`, async function () {\n      const db = await loadTestDbAndDoBasicChecks('AddressDB-Palm V-FR.pdb');\n      expect(db.appInfo?.country).toStrictEqual(AddressCountry.FRANCE);\n      expect(db.records).toHaveLength(2);\n    });\n  });\n\n  describe('serialize', function () {\n    test(`using test database AddressDB-LifeDrive.pdb`, async function () {\n      const db1 = await loadTestDbAndDoBasicChecks('AddressDB-LifeDrive.pdb');\n      const db2 = AddressDatabase.from(db1.serialize());\n      expect(db2.records).toHaveLength(db1.records.length);", "      for (let i = 0; i < db1.records.length; ++i) {\n        const rec1 = db1.records[i];\n        const rec2 = db2.records[i];\n        expect(rec2.mainPhoneNumberType).toStrictEqual(\n          rec1.mainPhoneNumberType\n        );\n        expect(rec2.phoneNumberTypeMapping).toStrictEqual(\n          rec1.phoneNumberTypeMapping\n        );\n        expect((rec2 as any)['companyCellValueOffset']).toBeGreaterThan(0);\n        expect((rec2 as any)['companyCellValueOffset']).toStrictEqual(\n          (rec1 as any)['companyCellValueOffset']\n        );\n        expect(\n          SStringNT.from(\n            rec2\n              .serialize()\n              .subarray(9 + (rec2 as any)['companyCellValueOffset'] - 1)\n          ).value\n        ).toStrictEqual(rec1.get(AddressFieldType.COMPANY));\n        expect(rec2.cells).toStrictEqual(rec1.cells);\n      }\n    });\n  });\n});\n"]}
{"filename": "src/tests/datebook-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\nimport pick from 'lodash/pick';\nimport path from 'path';\nimport {\n  AlarmSettings,\n  AlarmTimeUnit,\n  DatabaseDate,\n  DatebookDatabase,\n  DatebookRecord,\n  EventTime,", "  DatebookRecord,\n  EventTime,\n  RecurrenceFrequency,\n  RecurrenceSettings,\n} from '..';\n\ndescribe('DatebookDatabase', function () {\n  test('load test database', async function () {\n    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'DatebookDB.pdb')", "    const buffer = await fs.readFile(\n      path.join(__dirname, 'testdata', 'DatebookDB.pdb')\n    );\n    const db = DatebookDatabase.from(buffer);\n\n    expect(db.header).toMatchObject(\n      pick(new DatebookDatabase().header, ['name', 'type', 'creator'])\n    );\n    expect(db.records.length).toStrictEqual(3);\n    for (const record of db.records) {\n      expect(record.date.year).toStrictEqual(2021);\n      expect(record.date.month).toStrictEqual(1);\n      expect(record.startTime?.hour).toBeGreaterThan(0);\n      expect(record.startTime?.minute).toStrictEqual(0);\n      expect(record.endTime?.hour).toBeGreaterThan(0);\n      expect(record.endTime?.minute).toStrictEqual(0);\n      expect(record.description.length).toBeGreaterThan(1);\n    }\n    expect(db.records[0].recurrenceSettings).toMatchObject({\n      frequency: RecurrenceFrequency.WEEKLY,\n      weekly: {\n        days: [false, false, false, false, false, false, true],\n        firstDayOfWeek: 0,\n      },\n      interval: 1,\n      endDate: null,\n    });\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new DatebookDatabase();", "    expect(db.records.length).toStrictEqual(3);\n    for (const record of db.records) {\n      expect(record.date.year).toStrictEqual(2021);\n      expect(record.date.month).toStrictEqual(1);\n      expect(record.startTime?.hour).toBeGreaterThan(0);\n      expect(record.startTime?.minute).toStrictEqual(0);\n      expect(record.endTime?.hour).toBeGreaterThan(0);\n      expect(record.endTime?.minute).toStrictEqual(0);\n      expect(record.description.length).toBeGreaterThan(1);\n    }\n    expect(db.records[0].recurrenceSettings).toMatchObject({\n      frequency: RecurrenceFrequency.WEEKLY,\n      weekly: {\n        days: [false, false, false, false, false, false, true],\n        firstDayOfWeek: 0,\n      },\n      interval: 1,\n      endDate: null,\n    });\n  });\n\n  test('serialize', async function () {\n    // Create db1.\n    const db1 = new DatebookDatabase();", "    for (let i = 0; i < 30; ++i) {\n      const record = new DatebookRecord();\n      record.description = `Event #${i}`;\n      record.note = `Note #${i}`;\n      record.date.year = 2000 + i;\n      if (i % 2) {\n        record.startTime = EventTime.with({hour: i % 24, minute: 0});\n        record.endTime = EventTime.with({hour: i % 24, minute: 30});\n      }\n      if (i % 3) {\n        record.alarmSettings = AlarmSettings.with({\n          unit: AlarmTimeUnit.MINUTES,\n          value: i,\n        });\n      }", "      if (i % 3) {\n        record.alarmSettings = AlarmSettings.with({\n          unit: AlarmTimeUnit.MINUTES,\n          value: i,\n        });\n      }\n      if (i % 10 === 0) {\n        record.recurrenceSettings = null;\n      } else {\n        if (i < 7) {\n          record.recurrenceSettings = RecurrenceSettings.with({\n            frequency: RecurrenceFrequency.WEEKLY,\n            weekly: {\n              days: [false, false, false, false, false, false, false],\n              firstDayOfWeek: 0,\n            },\n            interval: 1,\n            endDate: null,\n          });", "        if (i < 7) {\n          record.recurrenceSettings = RecurrenceSettings.with({\n            frequency: RecurrenceFrequency.WEEKLY,\n            weekly: {\n              days: [false, false, false, false, false, false, false],\n              firstDayOfWeek: 0,\n            },\n            interval: 1,\n            endDate: null,\n          });\n          for (let j = 0; j < i; j += 2) {\n            record.recurrenceSettings.weekly!.days[j] = true;\n          }", "          for (let j = 0; j < i; j += 2) {\n            record.recurrenceSettings.weekly!.days[j] = true;\n          }\n        } else if (i < 15) {\n          record.recurrenceSettings = RecurrenceSettings.with({\n            frequency: RecurrenceFrequency.MONTHLY_BY_DAY,\n            monthlyByDay: {\n              weekOfMonth: i % 6,\n              day: i % 7,\n            },\n            interval: 1,\n            endDate: null,\n          });\n        } else {\n          const frequencies = [\n            RecurrenceFrequency.DAILY,\n            RecurrenceFrequency.MONTHLY_BY_DATE,\n            RecurrenceFrequency.YEARLY,\n          ] as const;\n          const frequency = frequencies[i % frequencies.length];", "          record.recurrenceSettings = RecurrenceSettings.with({\n            frequency,\n            interval: i,\n            endDate: null,\n          });\n        }\n        if (i % 4 && record.recurrenceSettings) {\n          record.recurrenceSettings.endDate = DatabaseDate.of(\n            new Date(2001 + i, 0, 1)\n          );\n        }\n      }\n      db1.records.push(record);\n    }\n\n    // Serialize to buffer and deserialize back into db2.\n    const buffer = db1.serialize();\n    const db2 = DatebookDatabase.from(buffer);\n\n    // Check db2 contents.\n    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n    expect(db2.records.length).toStrictEqual(db1.records.length);", "    for (let i = 0; i < db1.records.length; ++i) {\n      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n    }\n  });\n});\n"]}
