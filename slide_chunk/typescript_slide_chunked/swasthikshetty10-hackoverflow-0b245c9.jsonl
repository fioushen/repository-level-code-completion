{"filename": "src/pages/api/pusher.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from \"next\";\nimport { pusher } from \"../../utils/pusher\";\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const { message, sender } = req.body;\n  console.log(\"here\", message, sender);\n  const response = await pusher.trigger(\"chat\", \"chat-event\", {\n    message,\n    sender,\n  });\n\n  res.json({ message: \"completed\" });\n}\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\nimport { env } from \"~/env.mjs\";\nimport { createTRPCContext } from \"~/server/api/trpc\";\nimport { appRouter } from \"~/server/api/root\";\n\n// export API handler\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext: createTRPCContext,", "  router: appRouter,\n  createContext: createTRPCContext,\n  onError:\n    env.NODE_ENV === \"development\"\n      ? ({ path, error }) => {\n          console.error(\n            `\u274c tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n          );\n        }\n      : undefined,", "        }\n      : undefined,\n});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\nimport { authOptions } from \"~/server/auth\";\n\nexport default NextAuth(authOptions);\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n *\n * We also create a few inference helpers for input and output types.\n */\nimport { httpBatchLink, loggerLink } from \"@trpc/client\";\nimport { createTRPCNext } from \"@trpc/next\";\nimport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n", "import { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n\nimport { type AppRouter } from \"~/server/api/root\";\n\nconst getBaseUrl = () => {\n  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n};\n\n/** A set of type-safe react-query hooks for your tRPC API. */\nexport const api = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      /**\n       * Transformer used for data de-serialization from the server.\n       *\n       * @see https://trpc.io/docs/data-transformers\n       */\n      transformer: superjson,\n\n      /**\n       * Links used to determine request flow from client to server.\n       *\n       * @see https://trpc.io/docs/links\n       */\n      links: [\n        loggerLink({\n          enabled: (opts) =>\n            process.env.NODE_ENV === \"development\" ||\n            (opts.direction === \"down\" && opts.result instanceof Error),\n        }),\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n    };\n  },\n  /**\n   * Whether tRPC should await queries when server rendering pages.\n   *\n   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n   */\n  ssr: false,\n});\n\n/**\n * Inference helper for inputs.\n *", " * @example type HelloInput = RouterInputs['example']['hello']\n */\nexport type RouterInputs = inferRouterInputs<AppRouter>;\n\n/**\n * Inference helper for outputs.\n *\n * @example type HelloOutput = RouterOutputs['example']['hello']\n */\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n", "export type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/utils/pusher.ts", "chunked_list": ["import Pusher from \"pusher\";\n\nexport const pusher = new Pusher({\n  appId: process.env.PUSHER_APP_ID as string,\n  key: process.env.PUSHER_KEY as string,\n  secret: process.env.PUSHER_SECRET as string,\n  cluster: process.env.PUSHER_CLUSTER as string,\n  useTLS: true,\n});\n", "});\n"]}
{"filename": "src/utils/speak.ts", "chunked_list": ["import { transliterate } from \"transliteration\";\n\nlet lastSpokenText = \"\";\n\nconst speakOut = async (text: string, isEmpty: boolean, lang?: string) => {\n  if (text === lastSpokenText) {\n    console.log(\"Skipping speaking text again:\", text);\n    return;\n  }\n\n  if (isEmpty) lastSpokenText = \"\";\n", "  if (isEmpty) lastSpokenText = \"\";\n\n  console.log(\"speakOut function called with text:\", text);\n\n  let speech = new SpeechSynthesisUtterance();\n  speech.lang = lang || \"en-US\";\n\n  let englishText = transliterate(text);\n  speech.text = englishText;\n\n  console.log(\"SpeechSynthesisUtterance:\", speech);\n  speechSynthesis.speak(speech);\n\n  lastSpokenText = text;\n};\n\nexport default speakOut;\n"]}
{"filename": "src/lib/serverUtils.ts", "chunked_list": ["import { RoomServiceClient } from \"livekit-server-sdk\";\n\nexport function getRoomClient(): RoomServiceClient {\n  checkKeys();\n  return new RoomServiceClient(getLiveKitURL());\n}\n\nexport function getLiveKitURL(region?: string | string[]): string {\n  let targetKey = \"LIVEKIT_URL\";\n  if (region && !Array.isArray(region)) {\n    targetKey = `LIVEKIT_URL_${region}`.toUpperCase();\n  }\n  const url = process.env[targetKey];", "  if (region && !Array.isArray(region)) {\n    targetKey = `LIVEKIT_URL_${region}`.toUpperCase();\n  }\n  const url = process.env[targetKey];\n  if (!url) {\n    throw new Error(`${targetKey} is not defined`);\n  }\n  return url;\n}\n\nfunction checkKeys() {", "function checkKeys() {\n  if (typeof process.env.LIVEKIT_API_KEY === \"undefined\") {\n    throw new Error(\"LIVEKIT_API_KEY is not defined\");\n  }\n  if (typeof process.env.LIVEKIT_API_SECRET === \"undefined\") {\n    throw new Error(\"LIVEKIT_API_SECRET is not defined\");\n  }\n}\n"]}
{"filename": "src/lib/type.ts", "chunked_list": ["import { LocalAudioTrack, LocalVideoTrack } from \"livekit-client\";\n\nexport interface SessionProps {\n  roomName: string;\n  identity: string;\n  audioTrack?: LocalAudioTrack;\n  videoTrack?: LocalVideoTrack;\n  region?: string;\n  turnServer?: RTCIceServer;\n  forceRelay?: boolean;\n}\n", "export interface TokenResult {\n  identity: string;\n  accessToken: string;\n}\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\nimport {\n  getServerSession,\n  type NextAuthOptions,\n  type DefaultSession,\n} from \"next-auth\";\nimport GoogleProvider from \"next-auth/providers/google\";\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\nimport { env } from \"~/env.mjs\";\nimport { prisma } from \"~/server/db\";\n\n/**\n * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`", " * object and keep type safety.\n *\n * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n */\ndeclare module \"next-auth\" {\n  interface Session extends DefaultSession {\n    user: {\n      id: string;\n      // ...other properties\n      // role: UserRole;\n    } & DefaultSession[\"user\"];\n  }\n", "  // interface User {\n  //   // ...other properties\n  //   // role: UserRole;\n  // }\n}\n\n/**\n * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n *\n * @see https://next-auth.js.org/configuration/options\n */\nexport const authOptions: NextAuthOptions = {\n  callbacks: {\n    session({ session, user }) {", "      if (session.user) {\n        session.user.id = user.id;\n        // session.user.role = user.role; <-- put other properties on the session here\n      }\n      return session;\n    },\n  },\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    GoogleProvider({\n      clientId: env.GOOGLE_CLIENT_ID,\n      clientSecret: env.GOOGLE_CLIENT_SECRET,\n    }),\n  ],\n};\n\n/**\n * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n *\n * @see https://next-auth.js.org/configuration/nextjs\n */\nexport const getServerAuthSession = (ctx: {\n  req: GetServerSidePropsContext[\"req\"];\n  res: GetServerSidePropsContext[\"res\"];\n}) => {\n  return getServerSession(ctx.req, ctx.res, authOptions);\n};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"~/env.mjs\";\n\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log:", "  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n */", "import { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\nimport { type Session } from \"next-auth\";\n\nimport { getServerAuthSession } from \"~/server/auth\";\nimport { prisma } from \"~/server/db\";\n\ntype CreateContextOptions = {\n  session: Session | null;\n};\n\n/**\n * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n * it from here.\n *\n * Examples of things you may need it for:\n * - testing, so we don't have to mock Next.js' req/res\n * - tRPC's `createSSGHelpers`, where we don't have req/res\n *\n * @see https://create.t3.gg/en/usage/trpc#-servertrpccontextts\n */\nconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n  return {\n    session: opts.session,\n    prisma,\n  };\n};\n\n/**\n * This is the actual context you will use in your router. It will be used to process every request\n * that goes through your tRPC endpoint.\n *\n * @see https://trpc.io/docs/context\n */\nexport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n  const { req, res } = opts;\n\n  // Get the session from the server using the getServerSession wrapper function\n  const session = await getServerAuthSession({ req, res });\n\n  return createInnerTRPCContext({\n    session,\n  });\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer.\n */\nimport { initTRPC, TRPCError } from \"@trpc/server\";\nimport superjson from \"superjson\";\n\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape }) {\n    return shape;\n  },\n});\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure;\n\n/** Reusable middleware that enforces users are logged in before running the procedure. */\nconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {", "  if (!ctx.session || !ctx.session.user) {\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n  }\n  return next({\n    ctx: {\n      // infers the `session` as non-nullable\n      session: { ...ctx.session, user: ctx.session.user },\n    },\n  });\n});\n\n/**\n * Protected (authenticated) procedure\n *\n * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n * the session is valid and guarantees `ctx.session.user` is not null.\n *\n * @see https://trpc.io/docs/procedures\n */\nexport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { createTRPCRouter } from \"~/server/api/trpc\";\nimport { roomsRouter } from \"./routers/rooms\";\nimport { pusherRouter } from \"./routers/pusher\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({", " */\nexport const appRouter = createTRPCRouter({\n  rooms: roomsRouter,\n  pusher: pusherRouter,\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/pusher.ts", "chunked_list": ["import { string, z } from \"zod\";\nimport { pusher } from \"~/utils/pusher\";\n\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  protectedProcedure,\n} from \"~/server/api/trpc\";\nimport { translate } from \"@vitalets/google-translate-api\";\nexport const pusherRouter = createTRPCRouter({", "import { translate } from \"@vitalets/google-translate-api\";\nexport const pusherRouter = createTRPCRouter({\n  send: protectedProcedure\n    .input(\n      z.object({\n        message: string(),\n        roomName: string(),\n        isFinal: z.boolean(),\n      })\n    )", "      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const { message } = input;\n      const { user } = ctx.session;\n      const response = await pusher.trigger(\n        input.roomName,\n        \"transcribe-event\",\n        {\n          message,", "        {\n          message,\n          sender: user.name,\n          isFinal: input.isFinal,\n          senderId: user.id,\n        }\n      );\n      const { text } = await translate(message, {\n        to: \"en\",\n      });", "        to: \"en\",\n      });\n      await ctx.prisma.transcript.create({\n        data: {\n          text: text,\n          Room: {\n            connect: {\n              name: input.roomName,\n            },\n          },", "            },\n          },\n          User: {\n            connect: {\n              id: user.id,\n            },\n          },\n        },\n      });\n      return response;", "      });\n      return response;\n    }),\n});\n"]}
{"filename": "src/server/api/routers/rooms.ts", "chunked_list": ["import { nullable, string, z } from \"zod\";\nimport { AccessToken, RoomServiceClient } from \"livekit-server-sdk\";\nimport type {\n  AccessTokenOptions,\n  VideoGrant,\n  CreateOptions,\n} from \"livekit-server-sdk\";\nimport { translate } from \"@vitalets/google-translate-api\";\n\nconst createToken = (userInfo: AccessTokenOptions, grant: VideoGrant) => {", "\nconst createToken = (userInfo: AccessTokenOptions, grant: VideoGrant) => {\n  const at = new AccessToken(apiKey, apiSecret, userInfo);\n  at.ttl = \"5m\";\n  at.addGrant(grant);\n  return at.toJwt();\n};\nimport axios from \"axios\";\n\nconst apiKey = process.env.LIVEKIT_API_KEY;", "\nconst apiKey = process.env.LIVEKIT_API_KEY;\nconst apiSecret = process.env.LIVEKIT_API_SECRET;\nconst apiHost = process.env.NEXT_PUBLIC_LIVEKIT_API_HOST as string;\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  protectedProcedure,\n} from \"~/server/api/trpc\";\nimport { TokenResult } from \"~/lib/type\";", "} from \"~/server/api/trpc\";\nimport { TokenResult } from \"~/lib/type\";\nimport { CreateRoomRequest } from \"livekit-server-sdk/dist/proto/livekit_room\";\nconst roomClient = new RoomServiceClient(apiHost, apiKey, apiSecret);\nconst configuration = new Configuration({\n  apiKey: process.env.OPEN_API_SECRET,\n});\nimport { Configuration, OpenAIApi } from \"openai\";\nconst openai = new OpenAIApi(configuration);\nexport const roomsRouter = createTRPCRouter({", "const openai = new OpenAIApi(configuration);\nexport const roomsRouter = createTRPCRouter({\n  joinRoom: protectedProcedure\n    .input(\n      z.object({\n        roomName: z.string(),\n      })\n    )\n    .query(async ({ input, ctx }) => {\n      const identity = ctx.session.user.id;", "    .query(async ({ input, ctx }) => {\n      const identity = ctx.session.user.id;\n      const name = ctx.session.user.name;\n\n      const grant: VideoGrant = {\n        room: input.roomName,\n        roomJoin: true,\n        canPublish: true,\n        canPublishData: true,\n        canSubscribe: true,", "        canPublishData: true,\n        canSubscribe: true,\n      };\n      const { roomName } = input;\n\n      const token = createToken({ identity, name: name as string }, grant);\n      const result: TokenResult = {\n        identity,\n        accessToken: token,\n      };\n      try {\n        // check if user is already in room\n        console.log(\"here\");\n        const participant = await ctx.prisma.participant.findUnique({\n          where: {\n            UserId_RoomName: {\n              UserId: ctx.session.user.id,\n              RoomName: roomName,\n            },\n          },\n        });", "        accessToken: token,\n      };\n      try {\n        // check if user is already in room\n        console.log(\"here\");\n        const participant = await ctx.prisma.participant.findUnique({\n          where: {\n            UserId_RoomName: {\n              UserId: ctx.session.user.id,\n              RoomName: roomName,\n            },\n          },\n        });", "        if (participant === null)\n          await ctx.prisma.participant.create({\n            data: {\n              User: {\n                connect: {\n                  id: ctx.session.user.id,\n                },\n              },\n              Room: {\n                connect: {\n                  name: roomName,\n                },\n              },\n            },\n          });", "      } catch (error) {\n        console.log(error);\n      }\n\n      return result;\n    }),\n  createRoom: protectedProcedure.mutation(async ({ ctx }) => {\n    const identity = ctx.session.user.id;\n    const name = ctx.session.user.name;\n    const room = await ctx.prisma.room.create({\n      data: {\n        Owner: {\n          connect: {\n            id: ctx.session.user.id,\n          },\n        },\n      },\n    });\n    await roomClient.createRoom({\n      name: room.name,\n    });\n\n    const grant: VideoGrant = {\n      room: room.name,\n      roomJoin: true,\n      canPublish: true,\n      canPublishData: true,\n      canSubscribe: true,\n    };\n    const token = createToken({ identity, name: name as string }, grant);\n    const result = {\n      roomName: room.name,\n    };\n\n    return result;\n  }),\n  getRoomsByUser: protectedProcedure.query(async ({ ctx }) => {\n    const rooms = await ctx.prisma.room.findMany({\n      where: {\n        OR: [\n          {\n            Owner: {\n              id: ctx.session.user.id,\n            },\n          },\n          {\n            Participant: {\n              some: {\n                UserId: ctx.session.user.id,\n              },\n            },\n          },\n        ],\n      },\n    });\n\n    return rooms;\n  }),\n  getRoomSummary: protectedProcedure\n    .input(\n      z.object({\n        roomName: z.string(),\n      })\n    )\n    .query(async ({ input, ctx }) => {\n      // order all transcripts by createdAt in ascending order\n      const transcripts = await ctx.prisma.transcript.findMany({\n        where: {\n          Room: {\n            name: input.roomName,\n          },\n        },\n        include: {\n          User: true,\n        },\n        orderBy: {\n          createdAt: \"asc\",\n        },\n      });\n      const chatLog = transcripts.map((transcript) => ({\n        speaker: transcript.User.name,\n        utterance: transcript.text,\n        timestamp: transcript.createdAt.toISOString(),\n      }));", "      if (chatLog.length === 0) {\n        return null;\n      }\n\n      const apiKey = process.env.ONEAI_API_KEY;\n      console.log(chatLog);\n      try {\n        const config = {\n          method: \"POST\",\n          url: \"https://api.oneai.com/api/v0/pipeline\",\n          headers: {\n            \"api-key\": apiKey,\n            \"Content-Type\": \"application/json\",\n          },\n          data: {\n            input: chatLog,\n            input_type: \"conversation\",\n            content_type: \"application/json\",\n            output_type: \"json\",\n            multilingual: {\n              enabled: true,\n            },\n            steps: [\n              {\n                skill: \"article-topics\",\n              },\n              {\n                skill: \"numbers\",\n              },\n              {\n                skill: \"names\",\n              },\n              {\n                skill: \"emotions\",\n              },\n              {\n                skill: \"summarize\",\n              },\n            ],\n          },\n        };\n\n        const res = await axios.request(config);\n        console.log(res.status);\n        return res.data;", "      } catch (error) {\n        console.log(error);\n      }\n    }),\n});\n"]}
{"filename": "src/hooks/useTranscribe.ts", "chunked_list": ["import { useEffect } from \"react\";\nimport SpeechRecognition, {\n  useSpeechRecognition,\n} from \"react-speech-recognition\";\nimport { api } from \"~/utils/api\";\n\ntype UseTranscribeProps = {\n  roomName: string;\n  audioEnabled: boolean;\n  languageCode?: string;\n};\n\nconst useTranscribe = ({\n  roomName,\n  audioEnabled,\n  languageCode,\n}: UseTranscribeProps) => {\n  const {\n    transcript,\n    resetTranscript,\n    finalTranscript,\n    browserSupportsSpeechRecognition,\n  } = useSpeechRecognition();\n\n  const pusherMutation = api.pusher.send.useMutation();\n\n  useEffect(() => {", "    if (finalTranscript !== \"\") {\n      pusherMutation.mutate({\n        message: transcript,\n        roomName: roomName,\n        isFinal: true,\n      });\n      resetTranscript();\n    }\n  }, [finalTranscript]);\n\n  useEffect(() => {", "    if (audioEnabled) {\n      SpeechRecognition.startListening({\n        continuous: true,\n        language: languageCode,\n      });\n    }\n  }, [audioEnabled]);\n\n  return null;\n};\n\nexport default useTranscribe;\n"]}
