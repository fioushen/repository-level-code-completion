{"filename": "app/v3/index.ts", "chunked_list": ["import * as app from '@azure/functions';\n\napp.setup();"]}
{"filename": "app/v3/storageBlobTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst blobTrigger: AzureFunction = async function (_context: Context, myBlob: any): Promise<any> {\n    console.log(`storageBlobTrigger1 was triggered by \"${myBlob.toString()}\"`);\n    return myBlob;\n};\n", "};\n\nexport default blobTrigger;\n"]}
{"filename": "app/v3/serviceBusQueueTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst serviceBusQueueTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<string> {\n    console.log(`serviceBusQueueTrigger1 was triggered by \"${mySbMsg}\"`);\n    return mySbMsg;\n};\n", "};\n\nexport default serviceBusQueueTrigger;\n"]}
{"filename": "app/v3/cosmosDBTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst cosmosDBTrigger: AzureFunction = async function (_context: Context, documents: any[]): Promise<any[]> {\n    console.log(`cosmosDBTrigger1 processed ${documents.length} documents`);\n    for (const document of documents) {\n        console.log(`cosmosDBTrigger1 was triggered by \"${document.message}\"`);\n    }\n    return documents;\n};\n\nexport default cosmosDBTrigger;\n"]}
{"filename": "app/v3/eventHubTriggerMany/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst eventHubTrigger: AzureFunction = async function (_context: Context, messages: unknown[]): Promise<void> {\n    console.log(`eventHubTriggerMany processed ${messages.length} messages`);\n    for (const message of messages) {\n        console.log(`eventHubTriggerMany was triggered by \"${message}\"`);\n    }\n};\n\nexport default eventHubTrigger;\n"]}
{"filename": "app/v3/storageQueueTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst queueTrigger: AzureFunction = async function (_context: Context, myQueueItem: string): Promise<void> {\n    console.log(`storageQueueTrigger2 was triggered by \"${myQueueItem}\"`);\n};\n\nexport default queueTrigger;", "\nexport default queueTrigger;\n"]}
{"filename": "app/v3/helloWorld1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n    console.log(`Http function processed request for url \"${req.url}\"`);\n\n    const name = req.query.name || req.body || 'world';\n\n    context.res = {\n        body: `Hello, ${name}!`,\n    };\n};\n\nexport default httpTrigger;\n"]}
{"filename": "app/v3/timerTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst timerTrigger: AzureFunction = async function (_context: Context, _myTimer: any): Promise<void> {\n    console.log('timerTrigger1 was triggered');\n};\n\nexport default timerTrigger;", "\nexport default timerTrigger;\n"]}
{"filename": "app/v3/httpRawBody/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context, HttpRequest } from '@azure/functions';\nimport * as util from 'util';\n\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n    console.log(`Http function processed request for url \"${req.url}\"`);\n\n    context.res = {\n        body: {\n            body: formatIfBuffer(req.body),\n            rawBody: formatIfBuffer(req.rawBody),\n            bufferBody: formatIfBuffer(req.bufferBody),\n        },\n    };\n};\n\nexport default httpTrigger;\n", "function formatIfBuffer(data: any): any {\n    return Buffer.isBuffer(data) ? util.format(data) : data;\n}\n"]}
{"filename": "app/v3/eventHubTriggerOne/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst eventHubTrigger: AzureFunction = async function (_context: Context, message: unknown): Promise<void> {\n    console.log(`eventHubTriggerOne was triggered by \"${message}\"`);\n};\n\nexport default eventHubTrigger;", "\nexport default eventHubTrigger;\n"]}
{"filename": "app/v3/storageQueueTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst queueTrigger: AzureFunction = async function (_context: Context, myQueueItem: string): Promise<string> {\n    console.log(`storageQueueTrigger1 was triggered by \"${myQueueItem}\"`);\n    return myQueueItem;\n};\n", "};\n\nexport default queueTrigger;\n"]}
{"filename": "app/v3/httpCookies/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\nconst httpCookies: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n    console.log(`Http function processed request for url \"${req.url}\"`);\n\n    context.res = {\n        cookies: [\n            {\n                name: 'mycookie',\n                value: 'myvalue',\n                maxAge: 200000,\n            },\n            {\n                name: 'mycookie2',\n                value: 'myvalue',\n                path: '/',\n                maxAge: '200000',\n            },\n            {\n                name: 'mycookie3-expires',\n                value: 'myvalue3-expires',\n                maxAge: 0,\n            },\n            {\n                name: 'mycookie4-samesite-lax',\n                value: 'myvalue',\n                sameSite: 'Lax',\n            },\n            {\n                name: 'mycookie5-samesite-strict',\n                value: 'myvalue',\n                sameSite: 'Strict',\n            },\n        ],\n    };\n};\n\nexport default httpCookies;\n"]}
{"filename": "app/v3/serviceBusTopicTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst serviceBusTopicTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<string> {\n    console.log(`serviceBusTopicTrigger1 was triggered by \"${mySbMsg}\"`);\n    return mySbMsg;\n};\n", "};\n\nexport default serviceBusTopicTrigger;\n"]}
{"filename": "app/v3/storageBlobTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst blobTrigger: AzureFunction = async function (_context: Context, myBlob: any): Promise<void> {\n    console.log(`storageBlobTrigger2 was triggered by \"${myBlob.toString()}\"`);\n};\n\nexport default blobTrigger;", "\nexport default blobTrigger;\n"]}
{"filename": "app/v3/serviceBusTopicTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst serviceBusTopicTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<void> {\n    console.log(`serviceBusTopicTrigger2 was triggered by \"${mySbMsg}\"`);\n};\n\nexport default serviceBusTopicTrigger;", "\nexport default serviceBusTopicTrigger;\n"]}
{"filename": "app/v3/cosmosDBTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst cosmosDBTrigger: AzureFunction = async function (_context: Context, documents: any[]): Promise<void> {\n    console.log(`cosmosDBTrigger2 processed ${documents.length} documents`);\n    for (const document of documents) {\n        console.log(`cosmosDBTrigger2 was triggered by \"${document.message}\"`);\n    }\n};\n\nexport default cosmosDBTrigger;\n"]}
{"filename": "app/v3/serviceBusQueueTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AzureFunction, Context } from '@azure/functions';\n\nconst serviceBusQueueTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<void> {\n    console.log(`serviceBusQueueTrigger2 was triggered by \"${mySbMsg}\"`);\n};\n\nexport default serviceBusQueueTrigger;", "\nexport default serviceBusQueueTrigger;\n"]}
{"filename": "app/v4/src/functions/storageBlobTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function storageBlobTrigger2(blob: Buffer, _context: InvocationContext): Promise<void> {\n    console.log(`storageBlobTrigger2 was triggered by \"${blob.toString()}\"`);\n}\n\napp.storageBlob('storageBlobTrigger2', {\n    path: 'e2etestcontainer/e2etestblob2',\n    connection: 'e2eTest_storage',\n    handler: storageBlobTrigger2,\n});\n"]}
{"filename": "app/v4/src/functions/serviceBusQueueTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function serviceBusQueueTrigger2(message: unknown, _context: InvocationContext): Promise<void> {\n    console.log(`serviceBusQueueTrigger2 was triggered by \"${message}\"`);\n}\n\napp.serviceBusQueue('serviceBusQueueTrigger2', {\n    connection: 'e2eTest_serviceBus',\n    queueName: 'e2etestqueue2',\n    handler: serviceBusQueueTrigger2,\n});\n"]}
{"filename": "app/v4/src/functions/storageQueueTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, output } from '@azure/functions';\n\nexport async function storageQueueTrigger1(queueItem: string, _context: InvocationContext): Promise<string> {\n    console.log(`storageQueueTrigger1 was triggered by \"${queueItem}\"`);\n    return queueItem;\n}\n\napp.storageQueue('storageQueueTrigger1', {\n    queueName: 'e2etestqueue1',\n    connection: 'e2eTest_storage',\n    return: output.storageQueue({\n        queueName: 'e2etestqueue2',\n        connection: 'e2eTest_storage',\n    }),\n    handler: storageQueueTrigger1,\n});\n"]}
{"filename": "app/v4/src/functions/storageQueueTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function storageQueueTrigger2(queueItem: string, _context: InvocationContext): Promise<void> {\n    console.log(`storageQueueTrigger2 was triggered by \"${queueItem}\"`);\n}\n\napp.storageQueue('storageQueueTrigger2', {\n    queueName: 'e2etestqueue2',\n    connection: 'e2eTest_storage',\n    handler: storageQueueTrigger2,\n});\n"]}
{"filename": "app/v4/src/functions/cosmosDBTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, output } from '@azure/functions';\n\nexport async function cosmosDBTrigger1(documents: unknown[], _context: InvocationContext): Promise<unknown[]> {\n    console.log(`cosmosDBTrigger1 processed ${documents.length} documents`);\n    for (const document of documents) {\n        console.log(`cosmosDBTrigger1 was triggered by \"${(<any>document).message}\"`);\n    }\n    return documents;\n}\n\napp.cosmosDB('cosmosDBTrigger1', {\n    connection: 'e2eTest_cosmosDB',\n    databaseName: 'e2eTestDB',\n    containerName: 'e2eTestContainer1',\n    createLeaseContainerIfNotExists: true,\n    leaseContainerPrefix: '1',\n    return: output.cosmosDB({\n        connection: 'e2eTest_cosmosDB',\n        databaseName: 'e2eTestDB',\n        containerName: 'e2eTestContainer2',\n    }),\n    handler: cosmosDBTrigger1,\n});\n"]}
{"filename": "app/v4/src/functions/serviceBusTopicTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function serviceBusTopicTrigger2(message: unknown, _context: InvocationContext): Promise<void> {\n    console.log(`serviceBusTopicTrigger2 was triggered by \"${message}\"`);\n}\n\napp.serviceBusTopic('serviceBusTopicTrigger2', {\n    connection: 'e2eTest_serviceBus',\n    topicName: 'e2etesttopic2',\n    subscriptionName: 'e2etestsub',\n    handler: serviceBusTopicTrigger2,\n});\n"]}
{"filename": "app/v4/src/functions/timerTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, Timer } from '@azure/functions';\n\nexport async function timerTrigger1(_myTimer: Timer, _context: InvocationContext): Promise<void> {\n    console.log('timerTrigger1 was triggered');\n}\n\napp.timer('timerTrigger1', {\n    schedule: '*/30 * * * * *',\n    handler: timerTrigger1,\n});\n"]}
{"filename": "app/v4/src/functions/helloWorld1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';\n\nexport async function helloWorld1(request: HttpRequest, _context: InvocationContext): Promise<HttpResponseInit> {\n    console.log(`Http function processed request for url \"${request.url}\"`);\n\n    const name = request.query.get('name') || (await request.text()) || 'world';\n\n    return { body: `Hello, ${name}!` };\n}\n\napp.http('helloWorld1', {\n    methods: ['GET', 'POST'],\n    authLevel: 'anonymous',\n    handler: helloWorld1,\n});\n"]}
{"filename": "app/v4/src/functions/serviceBusTopicTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, output } from '@azure/functions';\n\nexport async function serviceBusTopicTrigger1(message: unknown, _context: InvocationContext): Promise<unknown> {\n    console.log(`serviceBusTopicTrigger1 was triggered by \"${message}\"`);\n    return message;\n}\n\napp.serviceBusTopic('serviceBusTopicTrigger1', {\n    connection: 'e2eTest_serviceBus',\n    topicName: 'e2etesttopic1',\n    subscriptionName: 'e2etestsub',\n    return: output.serviceBusTopic({\n        connection: 'e2eTest_serviceBus',\n        topicName: 'e2etesttopic2',\n    }),\n    handler: serviceBusTopicTrigger1,\n});\n"]}
{"filename": "app/v4/src/functions/eventHubTriggerMany.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function eventHubTriggerMany(messages: unknown[], _context: InvocationContext): Promise<void> {\n    console.log(`eventHubTriggerMany processed ${messages.length} messages`);\n    for (const message of messages) {\n        console.log(`eventHubTriggerMany was triggered by \"${message}\"`);\n    }\n}\n\napp.eventHub('eventHubTriggerMany', {\n    connection: 'e2eTest_eventHub',\n    eventHubName: 'e2etesteventhubmany',\n    cardinality: 'many',\n    handler: eventHubTriggerMany,\n});\n"]}
{"filename": "app/v4/src/functions/cosmosDBTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function cosmosDBTrigger2(documents: unknown[], _context: InvocationContext): Promise<void> {\n    console.log(`cosmosDBTrigger2 processed ${documents.length} documents`);\n    for (const document of documents) {\n        console.log(`cosmosDBTrigger2 was triggered by \"${(<any>document).message}\"`);\n    }\n}\n\napp.cosmosDB('cosmosDBTrigger2', {\n    connection: 'e2eTest_cosmosDB',\n    databaseName: 'e2eTestDB',\n    containerName: 'e2eTestContainer2',\n    createLeaseContainerIfNotExists: true,\n    leaseContainerPrefix: '2',\n    handler: cosmosDBTrigger2,\n});\n"]}
{"filename": "app/v4/src/functions/eventHubTriggerOne.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function eventHubTriggerOne(message: unknown, _context: InvocationContext): Promise<void> {\n    console.log(`eventHubTriggerOne was triggered by \"${message}\"`);\n}\n\napp.eventHub('eventHubTriggerOne', {\n    connection: 'e2eTest_eventHub',\n    eventHubName: 'e2etesteventhubone',\n    cardinality: 'one',\n    handler: eventHubTriggerOne,\n});\n"]}
{"filename": "app/v4/src/functions/serviceBusQueueTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, output } from '@azure/functions';\n\nexport async function serviceBusQueueTrigger1(message: unknown, _context: InvocationContext): Promise<unknown> {\n    console.log(`serviceBusQueueTrigger1 was triggered by \"${message}\"`);\n    return message;\n}\n\napp.serviceBusQueue('serviceBusQueueTrigger1', {\n    connection: 'e2eTest_serviceBus',\n    queueName: 'e2etestqueue1',\n    return: output.serviceBusQueue({\n        connection: 'e2eTest_serviceBus',\n        queueName: 'e2etestqueue2',\n    }),\n    handler: serviceBusQueueTrigger1,\n});\n"]}
{"filename": "app/v4/src/functions/storageBlobTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, output } from '@azure/functions';\n\nexport async function storageBlobTrigger1(blob: Buffer, _context: InvocationContext): Promise<Buffer> {\n    console.log(`storageBlobTrigger1 was triggered by \"${blob.toString()}\"`);\n    return blob;\n}\n\napp.storageBlob('storageBlobTrigger1', {\n    path: 'e2etestcontainer/e2etestblob1',\n    connection: 'e2eTest_storage',\n    return: output.storageBlob({\n        path: 'e2etestcontainer/e2etestblob2',\n        connection: 'e2eTest_storage',\n    }),\n    handler: storageBlobTrigger1,\n});\n"]}
{"filename": "app/v4/src/functions/httpCookies.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';\n\nexport async function httpCookies(request: HttpRequest, _context: InvocationContext): Promise<HttpResponseInit> {\n    console.log(`Http function processed request for url \"${request.url}\"`);\n\n    return {\n        cookies: [\n            {\n                name: 'mycookie',\n                value: 'myvalue',\n                maxAge: 200000,\n            },\n            {\n                name: 'mycookie2',\n                value: 'myvalue',\n                path: '/',\n                maxAge: <any>'200000',\n            },\n            {\n                name: 'mycookie3-expires',\n                value: 'myvalue3-expires',\n                maxAge: 0,\n            },\n            {\n                name: 'mycookie4-samesite-lax',\n                value: 'myvalue',\n                sameSite: 'Lax',\n            },\n            {\n                name: 'mycookie5-samesite-strict',\n                value: 'myvalue',\n                sameSite: 'Strict',\n            },\n        ],\n    };\n}\n\napp.http('httpCookies', {\n    methods: ['GET', 'POST'],\n    authLevel: 'anonymous',\n    handler: httpCookies,\n});\n"]}
{"filename": "app/v4-oldBundle/src/functions/cosmosDBTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext, output } from '@azure/functions';\n\nexport async function cosmosDBTrigger1(documents: unknown[], _context: InvocationContext): Promise<unknown[]> {\n    console.log(`cosmosDBTrigger1 processed ${documents.length} documents`);\n    for (const document of documents) {\n        console.log(`cosmosDBTrigger1 was triggered by \"${(<any>document).message}\"`);\n    }\n    return documents;\n}\n\napp.cosmosDB('cosmosDBTrigger1', {\n    connectionStringSetting: 'e2eTest_cosmosDB',\n    databaseName: 'e2eTestDB',\n    collectionName: 'e2eTestContainer1',\n    createLeaseCollectionIfNotExists: true,\n    leaseCollectionPrefix: '1',\n    return: output.cosmosDB({\n        connectionStringSetting: 'e2eTest_cosmosDB',\n        databaseName: 'e2eTestDB',\n        collectionName: 'e2eTestContainer2',\n    }),\n    handler: cosmosDBTrigger1,\n});\n"]}
{"filename": "app/v4-oldBundle/src/functions/cosmosDBTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { app, InvocationContext } from '@azure/functions';\n\nexport async function cosmosDBTrigger2(documents: unknown[], _context: InvocationContext): Promise<void> {\n    console.log(`cosmosDBTrigger2 processed ${documents.length} documents`);\n    for (const document of documents) {\n        console.log(`cosmosDBTrigger2 was triggered by \"${(<any>document).message}\"`);\n    }\n}\n\napp.cosmosDB('cosmosDBTrigger2', {\n    connectionStringSetting: 'e2eTest_cosmosDB',\n    databaseName: 'e2eTestDB',\n    collectionName: 'e2eTestContainer2',\n    createLeaseCollectionIfNotExists: true,\n    leaseCollectionPrefix: '2',\n    handler: cosmosDBTrigger2,\n});\n"]}
{"filename": "src/eventHub.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubProducerClient } from '@azure/event-hubs';\nimport { waitForOutput } from './global.test';\nimport { eventHubConnectionString } from './resources/connectionStrings';\nimport { eventHubMany, eventHubOne } from './resources/eventHub';\nimport { getRandomTestData } from './utils/getRandomTestData';\n\ndescribe('eventHub', () => {", "\ndescribe('eventHub', () => {\n    let clientOne: EventHubProducerClient;\n    let clientMany: EventHubProducerClient;\n\n    before(() => {\n        clientOne = new EventHubProducerClient(eventHubConnectionString, eventHubOne);\n        clientMany = new EventHubProducerClient(eventHubConnectionString, eventHubMany);\n    });\n", "    });\n\n    after(async () => {\n        await Promise.all([clientOne.close(), clientMany.close()]);\n    });\n\n    it('event hub cardinality one', async () => {\n        const message = getRandomTestData();\n        await clientOne.sendBatch([{ body: message }]);\n", "        await clientOne.sendBatch([{ body: message }]);\n\n        await waitForOutput(`eventHubTriggerOne was triggered by \"${message}\"`);\n    });\n\n    it('event hub cardinality many', async () => {\n        const message = getRandomTestData();\n        const message2 = getRandomTestData();\n        await clientMany.sendBatch([{ body: message }, { body: message2 }]);\n", "        await clientMany.sendBatch([{ body: message }, { body: message2 }]);\n\n        await waitForOutput(`eventHubTriggerMany processed 2 messages`);\n        await waitForOutput(`eventHubTriggerMany was triggered by \"${message}\"`);\n        await waitForOutput(`eventHubTriggerMany was triggered by \"${message2}\"`);\n    });\n});\n"]}
{"filename": "src/timer.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { waitForOutput } from './global.test';\n\ndescribe('timer', () => {\n    it('hello world', async () => {\n        await waitForOutput('timerTrigger1 was triggered', true);\n    });\n});", "    });\n});\n"]}
{"filename": "src/cosmosDB.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { CosmosClient } from '@azure/cosmos';\nimport { waitForOutput } from './global.test';\nimport { cosmosDBConnectionString } from './resources/connectionStrings';\nimport { container1Name, dbName } from './resources/cosmosDB';\nimport { getRandomTestData } from './utils/getRandomTestData';\n\ndescribe('cosmosDB', () => {", "\ndescribe('cosmosDB', () => {\n    it('trigger and output', async () => {\n        const client = new CosmosClient(cosmosDBConnectionString);\n        const container = client.database(dbName).container(container1Name);\n        const message = getRandomTestData();\n        await container.items.create({ message });\n\n        await waitForOutput(`cosmosDBTrigger1 processed 1 documents`);\n        await waitForOutput(`cosmosDBTrigger1 was triggered by \"${message}\"`);", "        await waitForOutput(`cosmosDBTrigger1 processed 1 documents`);\n        await waitForOutput(`cosmosDBTrigger1 was triggered by \"${message}\"`);\n        await waitForOutput(`cosmosDBTrigger2 processed 1 documents`);\n        await waitForOutput(`cosmosDBTrigger2 was triggered by \"${message}\"`);\n    });\n});\n"]}
{"filename": "src/serviceBus.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ServiceBusClient } from '@azure/service-bus';\nimport { waitForOutput } from './global.test';\nimport { serviceBusConnectionString } from './resources/connectionStrings';\nimport { serviceBusQueue1, serviceBusTopic1 } from './resources/serviceBus';\nimport { getRandomTestData } from './utils/getRandomTestData';\n\ndescribe('serviceBus', () => {", "\ndescribe('serviceBus', () => {\n    let client: ServiceBusClient;\n\n    before(() => {\n        client = new ServiceBusClient(serviceBusConnectionString);\n    });\n\n    after(async () => {\n        await client.close();", "    after(async () => {\n        await client.close();\n    });\n\n    it('queue', async () => {\n        const message = getRandomTestData();\n        const sender = client.createSender(serviceBusQueue1);\n        const batch = await sender.createMessageBatch();\n        batch.tryAddMessage({ body: message });\n        await sender.sendMessages(batch);", "        batch.tryAddMessage({ body: message });\n        await sender.sendMessages(batch);\n\n        await waitForOutput(`serviceBusQueueTrigger1 was triggered by \"${message}\"`);\n        await waitForOutput(`serviceBusQueueTrigger2 was triggered by \"${message}\"`);\n    });\n\n    it('topic', async () => {\n        const message = getRandomTestData();\n        const sender = client.createSender(serviceBusTopic1);", "        const message = getRandomTestData();\n        const sender = client.createSender(serviceBusTopic1);\n        const batch = await sender.createMessageBatch();\n        batch.tryAddMessage({ body: message });\n        await sender.sendMessages(batch);\n\n        await waitForOutput(`serviceBusTopicTrigger1 was triggered by \"${message}\"`);\n        await waitForOutput(`serviceBusTopicTrigger2 was triggered by \"${message}\"`);\n    });\n});", "    });\n});\n"]}
{"filename": "src/http.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { expect } from 'chai';\nimport { encode } from 'iconv-lite';\n// Node.js core added support for fetch in v18, but while we're testing versions <18 we'll use \"node-fetch\"\nimport { HeadersInit, default as fetch } from 'node-fetch';\nimport util from 'util';\nimport { model } from './global.test';\n\nfunction getFuncUrl(functionName: string): string {\n    return `http://127.0.0.1:7071/api/${functionName}`;\n}\n\nconst helloWorld1Url = getFuncUrl('helloWorld1');\nconst httpRawBodyUrl = getFuncUrl('httpRawBody');\n", "import { model } from './global.test';\n\nfunction getFuncUrl(functionName: string): string {\n    return `http://127.0.0.1:7071/api/${functionName}`;\n}\n\nconst helloWorld1Url = getFuncUrl('helloWorld1');\nconst httpRawBodyUrl = getFuncUrl('httpRawBody');\n\nfunction getContentTypeHeaders(contentType: string): HeadersInit {\n    return {\n        'content-type': contentType,\n    };\n}\nconst applicationJsonHeaders = getContentTypeHeaders('application/json');\nconst octetStreamHeaders = getContentTypeHeaders('application/octet-stream');\nconst multipartFormHeaders = getContentTypeHeaders('multipart/form');\nconst textPlainHeaders = getContentTypeHeaders('text/plain');\n\ndescribe('http', () => {\n    it('hello world', async () => {\n        const response = await fetch(helloWorld1Url);\n        const body = await response.text();\n        expect(body).to.equal('Hello, world!');\n        expect(response.status).to.equal(200);\n    });\n\n    it('hello world name in body', async () => {\n        const response = await fetch(helloWorld1Url, { method: 'POST', body: 'testName' });\n        const body = await response.text();\n        expect(body).to.equal('Hello, testName!');\n        expect(response.status).to.equal(200);\n    });\n\n    it('hello world name in query', async () => {\n        const response = await fetch(`${helloWorld1Url}?name=testName`);\n        const body = await response.text();\n        expect(body).to.equal('Hello, testName!');\n        expect(response.status).to.equal(200);\n    });\n\n    it('No function', async () => {\n        const response = await fetch(getFuncUrl('doesntExist'));\n        const body = await response.text();\n        expect(body).to.equal('');\n        expect(response.status).to.equal(404);\n    });\n\n    it('Cookies', async () => {\n        const response = await fetch(getFuncUrl('httpCookies'));\n        const body = await response.text();\n        expect(body).to.equal('');\n        expect(response.status).to.equal(200);\n        const cookies = response.headers.get('Set-Cookie');\n        expect(cookies).to.equal(\n            'mycookie=myvalue; max-age=200000; path=/, mycookie2=myvalue; max-age=200000; path=/, mycookie3-expires=myvalue3-expires; max-age=0; path=/, mycookie4-samesite-lax=myvalue; path=/; samesite=lax, mycookie5-samesite-strict=myvalue; path=/; samesite=strict'\n        );\n    });\n\n    describe('v3 only', () => {\n        before(function (this: Mocha.Context) {", "function getContentTypeHeaders(contentType: string): HeadersInit {\n    return {\n        'content-type': contentType,\n    };\n}\nconst applicationJsonHeaders = getContentTypeHeaders('application/json');\nconst octetStreamHeaders = getContentTypeHeaders('application/octet-stream');\nconst multipartFormHeaders = getContentTypeHeaders('multipart/form');\nconst textPlainHeaders = getContentTypeHeaders('text/plain');\n\ndescribe('http', () => {\n    it('hello world', async () => {\n        const response = await fetch(helloWorld1Url);\n        const body = await response.text();\n        expect(body).to.equal('Hello, world!');\n        expect(response.status).to.equal(200);\n    });\n\n    it('hello world name in body', async () => {\n        const response = await fetch(helloWorld1Url, { method: 'POST', body: 'testName' });\n        const body = await response.text();\n        expect(body).to.equal('Hello, testName!');\n        expect(response.status).to.equal(200);\n    });\n\n    it('hello world name in query', async () => {\n        const response = await fetch(`${helloWorld1Url}?name=testName`);\n        const body = await response.text();\n        expect(body).to.equal('Hello, testName!');\n        expect(response.status).to.equal(200);\n    });\n\n    it('No function', async () => {\n        const response = await fetch(getFuncUrl('doesntExist'));\n        const body = await response.text();\n        expect(body).to.equal('');\n        expect(response.status).to.equal(404);\n    });\n\n    it('Cookies', async () => {\n        const response = await fetch(getFuncUrl('httpCookies'));\n        const body = await response.text();\n        expect(body).to.equal('');\n        expect(response.status).to.equal(200);\n        const cookies = response.headers.get('Set-Cookie');\n        expect(cookies).to.equal(\n            'mycookie=myvalue; max-age=200000; path=/, mycookie2=myvalue; max-age=200000; path=/, mycookie3-expires=myvalue3-expires; max-age=0; path=/, mycookie4-samesite-lax=myvalue; path=/; samesite=lax, mycookie5-samesite-strict=myvalue; path=/; samesite=strict'\n        );\n    });\n\n    describe('v3 only', () => {\n        before(function (this: Mocha.Context) {", "            if (model !== 'v3') {\n                this.skip();\n            }\n        });\n\n        it('Json body', async () => {\n            for (const headers of [applicationJsonHeaders, textPlainHeaders]) {\n                const content = '{ \"a\": 1 }';\n                const response = await fetch(httpRawBodyUrl, {\n                    method: 'POST',\n                    body: content,\n                    headers,\n                });\n                const body = await response.json();\n                expect(body.body, 'body').to.deep.equal(JSON.parse(content));\n                expect(body.rawBody, 'rawBody').to.equal(content);\n                expect(body.bufferBody, 'bufferBody').to.equal(util.format(Buffer.from(content)));\n                expect(response.status).to.equal(200);\n            }\n        });\n\n        it('Json body invalid', async () => {\n            const content = '{ \"a\": 1, \"b\": }';\n            const response = await fetch(httpRawBodyUrl, {\n                method: 'POST',\n                body: content,\n                headers: applicationJsonHeaders,\n            });\n            const body = await response.json();\n            expect(body.body, 'body').to.equal(content);\n            expect(body.rawBody, 'rawBody').to.equal(content);\n            expect(body.bufferBody, 'bufferBody').to.equal(util.format(Buffer.from(content)));\n            expect(response.status).to.equal(200);\n        });\n\n        it('Json body stream/multipart type', async () => {", "            for (const headers of [\n                octetStreamHeaders,\n                multipartFormHeaders,\n                getContentTypeHeaders('multipart/whatever'),\n            ]) {\n                const content = '{ \"a\": 1 }';\n                const response = await fetch(httpRawBodyUrl, {\n                    method: 'POST',\n                    body: content,\n                    headers,\n                });\n                const body = await response.json();\n                const expectedBuffer = util.format(Buffer.from(content));\n                expect(body.body, 'body').to.equal(expectedBuffer);\n                expect(body.rawBody, 'rawBody').to.deep.equal(content);\n                expect(body.bufferBody, 'bufferBody').to.equal(expectedBuffer);\n                expect(response.status).to.equal(200);\n            }\n        });\n\n        it('Plain text', async () => {", "            for (const encoding of ['utf16be', 'utf16le', 'utf32le', 'utf8', 'utf32be']) {\n                const buffer = encode('abc', encoding);\n                const response = await fetch(httpRawBodyUrl, {\n                    method: 'POST',\n                    body: buffer,\n                    headers: textPlainHeaders,\n                });\n                const body = await response.json();\n                expect(body.body, 'body').to.equal(buffer.toString());\n                expect(body.rawBody, 'rawBody').to.equal(buffer.toString());\n                expect(body.bufferBody, 'bufferBody').to.equal(util.format(buffer));\n                expect(response.status).to.equal(200);\n            }\n        });\n    });\n});\n"]}
{"filename": "src/constants.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nexport namespace EnvVarNames {\n    export const storage = 'e2eTest_storage';\n    export const cosmosDB = 'e2eTest_cosmosDB';\n    export const eventHub = 'e2eTest_eventHub';\n    export const serviceBus = 'e2eTest_serviceBus';\n}\n", "}\n\nexport const defaultTimeout = 3 * 60 * 1000;\n\nexport const combinedFolder = 'combined';\nexport const oldBundleSuffix = '-oldBundle';\n"]}
{"filename": "src/getModelArg.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport parseArgs from 'minimist';\n\nexport type Model = 'v3' | 'v4';\n\nexport function getModelArg(): Model {\n    const args = parseArgs(process.argv.slice(2));\n    const modelArg: string = args.model || args.m;\n    if (modelArg === 'v3' || modelArg === 'v4') {\n        return modelArg;\n    } else {\n        throw new Error('You must pass in the model argument with \"--model\" or \"-m\". Valid values are \"v3\" or \"v4\".');\n    }\n}\n", "    if (modelArg === 'v3' || modelArg === 'v4') {\n        return modelArg;\n    } else {\n        throw new Error('You must pass in the model argument with \"--model\" or \"-m\". Valid values are \"v3\" or \"v4\".');\n    }\n}\n\nexport function getOldBundleArg(): boolean {\n    const flag = 'oldBundle';\n    const args = parseArgs(process.argv.slice(2), { boolean: flag });\n    return args[flag];\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport globby from 'globby';\nimport Mocha from 'mocha';\nimport path from 'path';\nimport { defaultTimeout } from './constants';\nimport { getModelArg, getOldBundleArg } from './getModelArg';\n\nexport async function run(): Promise<void> {\n    try {\n        const bundleSuffix = getOldBundleArg() ? '_oldBundle' : '';\n        const fileName = `${process.platform}_model-${getModelArg()}_Node-${process.version}${bundleSuffix}.xml`;\n        const options: Mocha.MochaOptions = {\n            color: true,\n            timeout: defaultTimeout,\n            reporter: 'mocha-multi-reporters',\n            reporterOptions: {\n                reporterEnabled: 'spec, mocha-junit-reporter',\n                mochaJunitReporterReporterOptions: {\n                    mochaFile: path.resolve(__dirname, '..', 'e2e-test-results', fileName),\n                },\n            },\n        };\n\n        addEnvVarsToMochaOptions(options);\n\n        const mocha = new Mocha(options);\n\n        const files: string[] = await globby('**/**.test.js', { cwd: __dirname });\n\n        files.forEach((f) => mocha.addFile(path.resolve(__dirname, f)));\n\n        const failures = await new Promise<number>((resolve) => mocha.run(resolve));", "\nexport async function run(): Promise<void> {\n    try {\n        const bundleSuffix = getOldBundleArg() ? '_oldBundle' : '';\n        const fileName = `${process.platform}_model-${getModelArg()}_Node-${process.version}${bundleSuffix}.xml`;\n        const options: Mocha.MochaOptions = {\n            color: true,\n            timeout: defaultTimeout,\n            reporter: 'mocha-multi-reporters',\n            reporterOptions: {\n                reporterEnabled: 'spec, mocha-junit-reporter',\n                mochaJunitReporterReporterOptions: {\n                    mochaFile: path.resolve(__dirname, '..', 'e2e-test-results', fileName),\n                },\n            },\n        };\n\n        addEnvVarsToMochaOptions(options);\n\n        const mocha = new Mocha(options);\n\n        const files: string[] = await globby('**/**.test.js', { cwd: __dirname });\n\n        files.forEach((f) => mocha.addFile(path.resolve(__dirname, f)));\n\n        const failures = await new Promise<number>((resolve) => mocha.run(resolve));", "        if (failures > 0) {\n            throw new Error(`${failures} tests failed.`);\n        }\n    } catch (err) {\n        console.error(err);\n        console.error('Test run failed');\n        process.exit(1);\n    }\n}\n\nfunction addEnvVarsToMochaOptions(options: Mocha.MochaOptions): void {", "function addEnvVarsToMochaOptions(options: Mocha.MochaOptions): void {\n    for (const envVar of Object.keys(process.env)) {\n        const match: RegExpMatchArray | null = envVar.match(/^mocha_(.+)/i);\n        if (match) {\n            const [, option] = match;\n            let value: string | number = process.env[envVar] || '';\n            if (typeof value === 'string' && !isNaN(parseInt(value))) {\n                value = parseInt(value);\n            }\n            (<any>options)[option] = value;\n        }\n    }\n}\n\nvoid run();\n"]}
{"filename": "src/global.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport cp from 'child_process';\nimport path from 'path';\nimport semver from 'semver';\nimport { EnvVarNames, combinedFolder, defaultTimeout, oldBundleSuffix } from './constants';\nimport { Model, getModelArg, getOldBundleArg } from './getModelArg';\nimport {\n    cosmosDBConnectionString,", "import {\n    cosmosDBConnectionString,\n    eventHubConnectionString,\n    initializeConnectionStrings,\n    serviceBusConnectionString,\n    storageConnectionString,\n} from './resources/connectionStrings';\nimport { delay } from './utils/delay';\nimport findProcess = require('find-process');\n", "import findProcess = require('find-process');\n\nlet perTestFuncOutput = '';\nlet fullFuncOutput = '';\nexport let model: Model | undefined;\nlet childProc: cp.ChildProcess | undefined;\nlet testsDone = false;\n\nbefore(async function (this: Mocha.Context): Promise<void> {\n    model = getModelArg();\n    if (model === 'v4' && semver.lt(process.versions.node, '18.0.0')) {\n        this.skip();\n    }\n\n    await killFuncProc();\n\n    await initializeConnectionStrings();\n\n    const appPath = getOldBundleArg()\n        ? path.join(__dirname, '..', 'app', combinedFolder, model + oldBundleSuffix)\n        : path.join(__dirname, '..', 'app', model);\n\n    startFuncProcess(appPath);\n    await waitForOutput('Host lock lease acquired by instance ID');\n\n    // Add slight delay after starting func to hopefully increase reliability of tests\n    await delay(30 * 1000);\n});\n\nafter(async () => {\n    testsDone = true;\n    await killFuncProc();\n});\n\nafterEach(async () => {\n    perTestFuncOutput = '';\n});\n", "before(async function (this: Mocha.Context): Promise<void> {\n    model = getModelArg();\n    if (model === 'v4' && semver.lt(process.versions.node, '18.0.0')) {\n        this.skip();\n    }\n\n    await killFuncProc();\n\n    await initializeConnectionStrings();\n\n    const appPath = getOldBundleArg()\n        ? path.join(__dirname, '..', 'app', combinedFolder, model + oldBundleSuffix)\n        : path.join(__dirname, '..', 'app', model);\n\n    startFuncProcess(appPath);\n    await waitForOutput('Host lock lease acquired by instance ID');\n\n    // Add slight delay after starting func to hopefully increase reliability of tests\n    await delay(30 * 1000);\n});\n\nafter(async () => {\n    testsDone = true;\n    await killFuncProc();\n});\n\nafterEach(async () => {\n    perTestFuncOutput = '';\n});\n", "async function killFuncProc(): Promise<void> {\n    const results = await findProcess('port', 7071);\n    for (const result of results) {\n        console.log(`Killing process ${result.name} with id ${result.pid}`);\n        process.kill(result.pid, 'SIGINT');\n    }\n}\n\nexport async function waitForOutput(data: string, checkFullOutput = false): Promise<void> {\n    const start = Date.now();\n    while (true) {", "export async function waitForOutput(data: string, checkFullOutput = false): Promise<void> {\n    const start = Date.now();\n    while (true) {\n        if (checkFullOutput && fullFuncOutput.includes(data)) {\n            return;\n        } else if (perTestFuncOutput.includes(data)) {\n            return;\n        } else if (Date.now() > start + defaultTimeout * 0.9) {\n            throw new Error(`Timed out while waiting for \"${data}\"`);\n        } else {\n            await delay(200);\n        }\n    }\n}\n", "function startFuncProcess(appPath: string): void {\n    const options: cp.SpawnOptions = {\n        cwd: appPath,\n        shell: true,\n        env: {\n            ...process.env,\n            AzureWebJobsStorage: storageConnectionString,\n            FUNCTIONS_WORKER_RUNTIME: 'node',\n            AzureWebJobsFeatureFlags: 'EnableWorkerIndexing',\n            logging__logLevel__Worker: 'debug',\n            [EnvVarNames.storage]: storageConnectionString,\n            [EnvVarNames.eventHub]: eventHubConnectionString,\n            [EnvVarNames.cosmosDB]: cosmosDBConnectionString,\n            [EnvVarNames.serviceBus]: serviceBusConnectionString,\n        },\n    };\n\n    const funcPath = path.join(__dirname, '..', 'func-cli', 'func');\n    childProc = cp.spawn(funcPath, ['start'], options);\n\n    childProc.stdout?.on('data', (data: string | Buffer) => {\n        data = data.toString();\n        process.stdout.write(data);\n        perTestFuncOutput += data;\n        fullFuncOutput += data;\n    });\n\n    childProc.stderr?.on('data', (data: string | Buffer) => {\n        data = data.toString();\n        process.stderr.write(data);\n        perTestFuncOutput += data;\n        fullFuncOutput += data;\n    });\n\n    childProc.on('error', (err) => {", "        if (!testsDone) {\n            console.error(err.message);\n            process.exit(1);\n        }\n    });\n    childProc.on('close', (code: number) => {\n        if (!testsDone) {\n            console.error(`func exited with code ${code}`);\n            process.exit(1);\n        }\n    });\n}\n"]}
{"filename": "src/createCombinedApps.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { combinedFolder, oldBundleSuffix } from './constants';\n\nasync function createCombinedApps(): Promise<void> {\n    const appRoot = path.join(__dirname, '..', 'app');\n    for (const model of ['v3', 'v4']) {\n        const modelRoot = path.join(appRoot, model);\n        const oldBundleRoot = path.join(appRoot, model + oldBundleSuffix);\n        const combinedRoot = path.join(appRoot, combinedFolder, model + oldBundleSuffix);\n        await fs.cp(modelRoot, combinedRoot, {\n            recursive: true,\n            filter: (source) => {\n                const foldersToExclude = ['dist', 'node_modules'];\n                return !foldersToExclude.find((f) => source.includes(f));\n            },\n        });\n        await fs.cp(oldBundleRoot, combinedRoot, { recursive: true });\n    }\n}\n\nvoid createCombinedApps();\n", "    for (const model of ['v3', 'v4']) {\n        const modelRoot = path.join(appRoot, model);\n        const oldBundleRoot = path.join(appRoot, model + oldBundleSuffix);\n        const combinedRoot = path.join(appRoot, combinedFolder, model + oldBundleSuffix);\n        await fs.cp(modelRoot, combinedRoot, {\n            recursive: true,\n            filter: (source) => {\n                const foldersToExclude = ['dist', 'node_modules'];\n                return !foldersToExclude.find((f) => source.includes(f));\n            },\n        });\n        await fs.cp(oldBundleRoot, combinedRoot, { recursive: true });\n    }\n}\n\nvoid createCombinedApps();\n"]}
{"filename": "src/storage.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ContainerClient } from '@azure/storage-blob';\nimport { QueueClient } from '@azure/storage-queue';\nimport { waitForOutput } from './global.test';\nimport { storageConnectionString } from './resources/connectionStrings';\nimport { getRandomTestData } from './utils/getRandomTestData';\n\ndescribe('storage', () => {", "\ndescribe('storage', () => {\n    it('queue trigger and output', async () => {\n        const client = new QueueClient(storageConnectionString, 'e2etestqueue1');\n        await client.createIfNotExists();\n\n        const message = getRandomTestData();\n        await client.sendMessage(Buffer.from(message).toString('base64'));\n\n        await waitForOutput(`storageQueueTrigger1 was triggered by \"${message}\"`);", "\n        await waitForOutput(`storageQueueTrigger1 was triggered by \"${message}\"`);\n        await waitForOutput(`storageQueueTrigger2 was triggered by \"${message}\"`);\n    });\n\n    it('blob trigger and output', async () => {\n        const client = new ContainerClient(storageConnectionString, 'e2etestcontainer');\n        await client.createIfNotExists();\n\n        const message = getRandomTestData();", "\n        const message = getRandomTestData();\n        const messageBuffer = Buffer.from(message);\n        await client.uploadBlockBlob('e2etestblob1', messageBuffer, messageBuffer.byteLength);\n\n        await waitForOutput(`storageBlobTrigger1 was triggered by \"${message}\"`);\n        await waitForOutput(`storageBlobTrigger2 was triggered by \"${message}\"`);\n    });\n});\n", "});\n"]}
{"filename": "src/utils/nonNull.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Retrieves a property by name from an object and checks that it's not null and not undefined.  It is strongly typed\n * for the property and will give a compile error if the given name is not a property of the source.\n */\nexport function nonNullProp<TSource, TKey extends keyof TSource>(\n    source: TSource,\n    name: TKey\n): NonNullable<TSource[TKey]> {\n    const value: NonNullable<TSource[TKey]> = <NonNullable<TSource[TKey]>>source[name];\n    return nonNullValue(value, <string>name);\n}\n\n/**\n * Validates that a given value is not null and not undefined.\n */", "export function nonNullValue<T>(value: T | undefined | null, propertyNameOrMessage?: string): T {\n    if (value === null || value === undefined) {\n        throw new Error(\n            'Internal error: Expected value to be neither null nor undefined' +\n                (propertyNameOrMessage ? `: ${propertyNameOrMessage}` : '')\n        );\n    }\n\n    return value;\n}\n", "export function copyPropIfDefined<TData, TKey extends keyof TData>(source: TData, destination: TData, key: TKey): void {\n    if (source[key] !== null && source[key] !== undefined) {\n        destination[key] = source[key];\n    }\n}\n\nexport function isDefined<T>(data: T | undefined | null): data is T {\n    return data !== null && data !== undefined;\n}\n"]}
{"filename": "src/utils/delay.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nexport async function delay(ms: number): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, ms));\n}\n"]}
{"filename": "src/utils/getRandomTestData.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport crypto from 'crypto';\n\nexport function getRandomTestData(): string {\n    // This should start with non-numeric data to prevent this bug from causing a test failure\n    // https://github.com/Azure/azure-functions-nodejs-library/issues/90\n    return `testData${getRandomHexString()}`;\n}\n", "export function getRandomHexString(length = 10): string {\n    const buffer: Buffer = crypto.randomBytes(Math.ceil(length / 2));\n    return buffer.toString('hex').slice(0, length);\n}\n"]}
{"filename": "src/utils/validateEnvVar.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { isDefined } from './nonNull';\n\nexport function validateEnvVar(name: string): string {\n    const value = process.env[name];\n    if (!isDefined(value)) {\n        throw new Error(`You must set the environment variable \"${name}\".`);\n    }\n    return value;\n}\n"]}
{"filename": "src/resources/deleteResources.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ResourceManagementClient } from '@azure/arm-resources';\nimport { getResourceInfo } from './ResourceInfo';\n\nasync function deleteResources(): Promise<void> {\n    try {\n        const info = getResourceInfo();\n\n        const resourceClient = new ResourceManagementClient(info.creds, info.subscriptionId);\n        await resourceClient.resourceGroups.beginDelete(info.resourceGroupName);", "    } catch (err) {\n        console.error(err);\n        console.error('Delete resources failed');\n        process.exit(1);\n    }\n}\n\nvoid deleteResources();\n"]}
{"filename": "src/resources/cosmosDB.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { CosmosDBManagementClient } from '@azure/arm-cosmosdb';\nimport { CosmosClient } from '@azure/cosmos';\nimport { nonNullProp } from '../utils/nonNull';\nimport { ResourceInfo } from './ResourceInfo';\n\nfunction getCosmosDBAccountName(info: ResourceInfo): string {\n    return info.resourcePrefix + 'comsosdb';\n}\n\nexport const dbName = 'e2eTestDB';\nexport const container1Name = 'e2eTestContainer1';\nexport const container2Name = 'e2eTestContainer2';\n", "function getCosmosDBAccountName(info: ResourceInfo): string {\n    return info.resourcePrefix + 'comsosdb';\n}\n\nexport const dbName = 'e2eTestDB';\nexport const container1Name = 'e2eTestContainer1';\nexport const container2Name = 'e2eTestContainer2';\n\nexport async function createCosmosDB(info: ResourceInfo): Promise<void> {\n    const accountName = getCosmosDBAccountName(info);\n    const armClient = new CosmosDBManagementClient(info.creds, info.subscriptionId);\n    await armClient.databaseAccounts.beginCreateOrUpdateAndWait(info.resourceGroupName, accountName, {\n        location: info.location,\n        databaseAccountOfferType: 'Standard',\n        locations: [{ locationName: info.location }],\n    });\n    const connectionString = await getCosmosDBConnectionString(info);\n    const client = new CosmosClient(connectionString);\n    const res = await client.databases.create({\n        id: dbName,\n        throughput: 400,\n    });", "export async function createCosmosDB(info: ResourceInfo): Promise<void> {\n    const accountName = getCosmosDBAccountName(info);\n    const armClient = new CosmosDBManagementClient(info.creds, info.subscriptionId);\n    await armClient.databaseAccounts.beginCreateOrUpdateAndWait(info.resourceGroupName, accountName, {\n        location: info.location,\n        databaseAccountOfferType: 'Standard',\n        locations: [{ locationName: info.location }],\n    });\n    const connectionString = await getCosmosDBConnectionString(info);\n    const client = new CosmosClient(connectionString);\n    const res = await client.databases.create({\n        id: dbName,\n        throughput: 400,\n    });", "    for (const containerName of [container1Name, container2Name]) {\n        await res.database.containers.create({\n            id: containerName,\n        });\n    }\n}\n\nexport async function getCosmosDBConnectionString(info: ResourceInfo): Promise<string> {\n    const accountName = getCosmosDBAccountName(info);\n    const client = new CosmosDBManagementClient(info.creds, info.subscriptionId);\n    const keys = await client.databaseAccounts.listKeys(info.resourceGroupName, accountName);\n    const key = nonNullProp(keys, 'primaryMasterKey');\n    return `AccountEndpoint=https://${accountName}.documents.azure.com:443/;AccountKey=${key};`;\n}\n"]}
{"filename": "src/resources/connectionStrings.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getResourceInfo } from './ResourceInfo';\nimport { getCosmosDBConnectionString } from './cosmosDB';\nimport { getEventHubConnectionString } from './eventHub';\nimport { getServiceBusConnectionString } from './serviceBus';\nimport { getStorageConnectionString } from './storage';\n\nexport let storageConnectionString: string;", "\nexport let storageConnectionString: string;\nexport let eventHubConnectionString: string;\nexport let cosmosDBConnectionString: string;\nexport let serviceBusConnectionString: string;\n\nexport async function initializeConnectionStrings(): Promise<void> {\n    const info = getResourceInfo();\n    [storageConnectionString, eventHubConnectionString, cosmosDBConnectionString, serviceBusConnectionString] =\n        await Promise.all([\n            getStorageConnectionString(info),\n            getEventHubConnectionString(info),\n            getCosmosDBConnectionString(info),\n            getServiceBusConnectionString(info),\n        ]);\n}\n"]}
{"filename": "src/resources/createResources.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ResourceManagementClient } from '@azure/arm-resources';\nimport { getResourceInfo } from './ResourceInfo';\nimport { createCosmosDB } from './cosmosDB';\nimport { createEventHub } from './eventHub';\nimport { createServiceBus } from './serviceBus';\nimport { createStorageAccount } from './storage';\n\nasync function createResources(): Promise<void> {", "import { createStorageAccount } from './storage';\n\nasync function createResources(): Promise<void> {\n    try {\n        const info = getResourceInfo();\n\n        const resourceClient = new ResourceManagementClient(info.creds, info.subscriptionId);\n        await resourceClient.resourceGroups.createOrUpdate(info.resourceGroupName, { location: info.location });\n\n        await Promise.all([\n            createStorageAccount(info),\n            createEventHub(info),\n            createCosmosDB(info),\n            createServiceBus(info),\n        ]);", "    } catch (err) {\n        console.error(err);\n        console.error('Create resources failed');\n        process.exit(1);\n    }\n}\n\nvoid createResources();\n"]}
{"filename": "src/resources/storage.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { KnownKind, KnownSkuName, StorageManagementClient } from '@azure/arm-storage';\nimport { nonNullProp, nonNullValue } from '../utils/nonNull';\nimport { ResourceInfo } from './ResourceInfo';\n\nfunction getAccountName(info: ResourceInfo): string {\n    return info.resourcePrefix + 'sto';\n}\n", "export async function createStorageAccount(info: ResourceInfo): Promise<void> {\n    const client = new StorageManagementClient(info.creds, info.subscriptionId);\n    await client.storageAccounts.beginCreateAndWait(info.resourceGroupName, getAccountName(info), {\n        kind: KnownKind.StorageV2,\n        location: info.location,\n        sku: {\n            name: KnownSkuName.StandardLRS,\n        },\n    });\n}\n", "export async function getStorageConnectionString(info: ResourceInfo): Promise<string> {\n    const client = new StorageManagementClient(info.creds, info.subscriptionId);\n    const accountName = getAccountName(info);\n    const keys = await client.storageAccounts.listKeys(info.resourceGroupName, accountName);\n    const key = nonNullValue(nonNullProp(keys, 'keys')[0]?.value, 'storageKey');\n    return `DefaultEndpointsProtocol=https;AccountName=${accountName};AccountKey=${key};EndpointSuffix=core.windows.net`;\n}\n"]}
{"filename": "src/resources/eventHub.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventHubManagementClient, KnownSkuName } from '@azure/arm-eventhub';\nimport { nonNullProp } from '../utils/nonNull';\nimport { ResourceInfo } from './ResourceInfo';\n\nfunction getNamespaceName(info: ResourceInfo): string {\n    return info.resourcePrefix + 'eventhub';\n}\n\nexport const eventHubOne = 'e2etesteventhubone';\nexport const eventHubMany = 'e2etesteventhubmany';\n", "export async function createEventHub(info: ResourceInfo): Promise<void> {\n    const client = new EventHubManagementClient(info.creds, info.subscriptionId);\n    const namespaceName = getNamespaceName(info);\n    await client.namespaces.beginCreateOrUpdateAndWait(info.resourceGroupName, namespaceName, {\n        location: info.location,\n        sku: {\n            name: KnownSkuName.Standard,\n        },\n    });\n    for (const eventHubName of [eventHubOne, eventHubMany]) {\n        await client.eventHubs.createOrUpdate(info.resourceGroupName, namespaceName, eventHubName, {\n            messageRetentionInDays: 1,\n        });\n    }\n}\n", "    for (const eventHubName of [eventHubOne, eventHubMany]) {\n        await client.eventHubs.createOrUpdate(info.resourceGroupName, namespaceName, eventHubName, {\n            messageRetentionInDays: 1,\n        });\n    }\n}\n\nexport async function getEventHubConnectionString(info: ResourceInfo): Promise<string> {\n    const client = new EventHubManagementClient(info.creds, info.subscriptionId);\n    const keys = await client.namespaces.listKeys(\n        info.resourceGroupName,\n        getNamespaceName(info),\n        'RootManageSharedAccessKey'\n    );\n    return nonNullProp(keys, 'primaryConnectionString');\n}\n"]}
{"filename": "src/resources/serviceBus.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ServiceBusManagementClient } from '@azure/arm-servicebus';\nimport { nonNullProp } from '../utils/nonNull';\nimport { ResourceInfo } from './ResourceInfo';\n\nfunction getNamespaceName(info: ResourceInfo): string {\n    return info.resourcePrefix + 'servicebus';\n}\n\nexport const serviceBusQueue1 = 'e2etestqueue1';\nexport const serviceBusQueue2 = 'e2etestqueue2';\n\nexport const serviceBusTopic1 = 'e2etesttopic1';\nexport const serviceBusTopic2 = 'e2etesttopic2';\n\nexport const serviceBusSub = 'e2etestsub';\n", "export async function createServiceBus(info: ResourceInfo): Promise<void> {\n    const client = new ServiceBusManagementClient(info.creds, info.subscriptionId);\n    const namespaceName = getNamespaceName(info);\n    await client.namespaces.beginCreateOrUpdateAndWait(info.resourceGroupName, namespaceName, {\n        location: info.location,\n        sku: {\n            name: 'Standard',\n        },\n    });\n\n    for (const queueName of [serviceBusQueue1, serviceBusQueue2]) {\n        await client.queues.createOrUpdate(info.resourceGroupName, namespaceName, queueName, {});\n    }\n", "    for (const queueName of [serviceBusQueue1, serviceBusQueue2]) {\n        await client.queues.createOrUpdate(info.resourceGroupName, namespaceName, queueName, {});\n    }\n\n    for (const topicName of [serviceBusTopic1, serviceBusTopic2]) {\n        await client.topics.createOrUpdate(info.resourceGroupName, namespaceName, topicName, {});\n        await client.subscriptions.createOrUpdate(info.resourceGroupName, namespaceName, topicName, serviceBusSub, {});\n    }\n}\n\nexport async function getServiceBusConnectionString(info: ResourceInfo): Promise<string> {\n    const client = new ServiceBusManagementClient(info.creds, info.subscriptionId);\n    const keys = await client.namespaces.listKeys(\n        info.resourceGroupName,\n        getNamespaceName(info),\n        'RootManageSharedAccessKey'\n    );\n    return nonNullProp(keys, 'primaryConnectionString');\n}\n", "export async function getServiceBusConnectionString(info: ResourceInfo): Promise<string> {\n    const client = new ServiceBusManagementClient(info.creds, info.subscriptionId);\n    const keys = await client.namespaces.listKeys(\n        info.resourceGroupName,\n        getNamespaceName(info),\n        'RootManageSharedAccessKey'\n    );\n    return nonNullProp(keys, 'primaryConnectionString');\n}\n"]}
{"filename": "src/resources/ResourceInfo.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EnvironmentCredential } from '@azure/identity';\nimport { validateEnvVar } from '../utils/validateEnvVar';\n\nexport interface ResourceInfo {\n    creds: EnvironmentCredential;\n    subscriptionId: string;\n    resourceGroupName: string;\n    resourcePrefix: string;\n    location: string;\n}\n", "function getResourcePrefix(): string {\n    const buildNumber = validateEnvVar('BUILD_BUILDNUMBER');\n    const jobAttempt = process.env['SYSTEM_JOBATTEMPT'] || '';\n    const result = 'e2e' + process.platform + buildNumber + jobAttempt;\n    return result.replace(/[^0-9a-zA-Z]/g, '');\n}\n\nexport function getResourceInfo(): ResourceInfo {\n    validateEnvVar('AZURE_TENANT_ID');\n    validateEnvVar('AZURE_CLIENT_ID');\n    validateEnvVar('AZURE_CLIENT_SECRET');\n    const subscriptionId: string = validateEnvVar('AZURE_SUBSCRIPTION_ID');\n    const resourcePrefix = getResourcePrefix();\n\n    const creds = new EnvironmentCredential();\n\n    return {\n        creds,\n        subscriptionId,\n        resourcePrefix,\n        resourceGroupName: resourcePrefix + 'group',\n        location: 'eastus',\n    };\n}\n"]}
