{"filename": "jest.config.ts", "chunked_list": ["import { JestConfigWithTsJest } from 'ts-jest';\n\nconst config: JestConfigWithTsJest = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n\n  moduleNameMapper: {\n    '^@/(.*)': '<rootDir>/src/$1',\n  },\n", "  },\n\n  testMatch: [`<rootDir>/src/**/__tests__/index.ts`],\n};\n\nexport default config;\n"]}
{"filename": "tsup.config.ts", "chunked_list": ["import type { Options } from 'tsup';\n\nconst tsupConfig: Options = {\n  entryPoints: ['src/*.ts'],\n  clean: true,\n  format: ['cjs', 'esm'],\n  dts: true,\n  onSuccess: 'npm run build:grammar',\n};\n", "};\n\nexport default tsupConfig;\n"]}
{"filename": "scripts/build-grammar.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\n\nasync function run() {\n  const source = path.resolve(process.cwd(), 'src/parser/grammar/liquidx.ohm');\n  const target = path.resolve(process.cwd(), 'dist/liquidx.ohm');\n\n  fs.copyFileSync(source, target);\n}\n\nrun();\n"]}
{"filename": "src/index.ts", "chunked_list": ["import render from './renderer';\n\nexport { render };\n"]}
{"filename": "src/utils/tests/get-suite-name.ts", "chunked_list": ["import getRelativeDirnameFromAbsoluteDirname from './get-relative-dirname-from-absolute-dirname';\n\nexport default function getSuiteName(dirname: string, { isDir = false } = {}) {\n  const relativeDirname = getRelativeDirnameFromAbsoluteDirname(dirname);\n\n  if (isDir) {\n    return relativeDirname.split('__tests__/')[1];\n  }\n\n  const filename = dirname.split('/').at(-1);\n  const filenameWithoutExtension = filename!.split('.')[0];\n\n  return filenameWithoutExtension;\n}\n"]}
{"filename": "src/utils/tests/require-all.ts", "chunked_list": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport getSuiteName from './get-suite-name';\n\nconst TEST_ONLY: string | undefined = process.env.TEST_ONLY;\n\nexport default function requireAll(directory: string) {\n  const files = fs.readdirSync(directory);\n\n  files.forEach((file) => {\n    const filePath = path.join(directory, file);\n", "    if (filePath.endsWith('__snapshots__')) return;\n\n    const filePathWithoutTestsPrefix = filePath.replace('__tests__/', '');\n\n    if (TEST_ONLY && !filePathWithoutTestsPrefix.match(new RegExp(TEST_ONLY, 'i'))) {\n      test.skip('', () => {\n        expect(true).toBe(true);\n      });\n\n      return;\n    }\n", "    if (fs.statSync(filePath).isDirectory()) {\n      describe(getSuiteName(filePath, { isDir: true }), () => {\n        require(path.join(filePath, 'index.ts'));\n      });\n    } else if (filePath.match(/.+\\.test\\.ts/)) {\n      describe(getSuiteName(filePath), () => {\n        require(filePath);\n      });\n    }\n  });\n}\n"]}
{"filename": "src/utils/tests/get-root-suite-name.ts", "chunked_list": ["import * as path from 'path';\nimport getRelativeDirnameFromAbsoluteDirname from './get-relative-dirname-from-absolute-dirname';\n\nexport default function getRootSuiteName(dirname: string) {\n  const relativeDirname = getRelativeDirnameFromAbsoluteDirname(dirname);\n\n  // Get rid of trailing slash, 'src', and '__tests__'\n  const dirnameParts = relativeDirname.split(path.sep).slice(2, -1);\n\n  return path.join(...dirnameParts);\n}\n"]}
{"filename": "src/utils/tests/get-relative-dirname-from-absolute-dirname.ts", "chunked_list": ["export default function getRelativeDirnameFromAbsoluteDirname(dirname: string) {\n  return dirname.replace(process.cwd(), '');\n}\n"]}
{"filename": "src/utils/tests/index.ts", "chunked_list": ["export { default as getRelativeDirnameFromAbsoluteDirname } from './get-relative-dirname-from-absolute-dirname';\nexport { default as getRootSuiteName } from './get-root-suite-name';\nexport { default as getSuiteName } from './get-suite-name';\nexport { default as requireAll } from './require-all';\n"]}
{"filename": "src/renderer/index.ts", "chunked_list": ["import sourceToAST, {\n  AttributeNode,\n  ElementNode,\n  LiquidDropNode,\n  LiquidXNode,\n  NodeTypes,\n  TextNode,\n} from '../parser/2-cst-to-ast';\n\nfunction renderStartMarker() {\n  return '{% # LIQUIDX:START - EDITS MADE TO THE CODE BETWEEN \"LIQUIDX:START\" and \"LIQUIDX:END\" WILL BE OVERWRITTEN %}';\n}\n", "\nfunction renderStartMarker() {\n  return '{% # LIQUIDX:START - EDITS MADE TO THE CODE BETWEEN \"LIQUIDX:START\" and \"LIQUIDX:END\" WILL BE OVERWRITTEN %}';\n}\n\nfunction renderEndMarker(node: ElementNode) {\n  return `{% # LIQUIDX:END - SOURCE ${JSON.stringify(\n    node.source.slice(node.locStart, node.locEnd),\n  )} %}`;\n}\n", "function renderElement(\n  node: ElementNode,\n  { withSource = false, isChildOfElementNode = false } = {},\n) {\n  let output = '';\n\n  const attributes = node.attributes;\n\n  if (withSource && !isChildOfElementNode) {\n    output += renderStartMarker();\n  }\n", "  if (withSource && !isChildOfElementNode) {\n    output += renderStartMarker();\n  }\n\n  if (node.children.length > 0) {\n    const captureName = `${node.name}Children`;\n\n    output += `{% capture ${captureName} %}`;\n    output += renderAST(node.children, { withSource, isChildOfElementNode: true });\n    output += '{% endcapture %}';\n\n    const childrenAttribute: AttributeNode = {\n      type: NodeTypes.AttributeDoubleQuoted,\n      locStart: 0,\n      locEnd: 0,\n      source: '',\n      name: {\n        type: NodeTypes.TextNode,\n        locStart: 0,\n        locEnd: 0,\n        source: '',\n        value: 'children',\n      },\n      value: {\n        type: NodeTypes.LiquidDropNode,\n        locStart: 0,\n        locEnd: 0,\n        source: '',\n        value: captureName,\n      },\n    };\n\n    attributes.push(childrenAttribute);\n  }\n\n  const renderedAttributes = node.attributes.map((attribute) => renderAST([attribute]));\n  const separator = ', ';\n\n  const attributesString =\n    renderedAttributes.length > 0 ? `${separator}${renderedAttributes.join(separator)}` : '';\n\n  output += `{% render '${node.name}'${attributesString} %}`;\n", "  if (withSource && !isChildOfElementNode) {\n    output += renderEndMarker(node);\n  }\n\n  return output;\n}\n\nfunction renderText(node: TextNode) {\n  return node.value;\n}\n", "function renderLiquidDrop(node: LiquidDropNode) {\n  return node.value;\n}\n\nfunction renderAST(\n  ast: LiquidXNode[],\n  { withSource = false, isChildOfElementNode = false } = {},\n): string {\n  let output = '';\n\n  for (let i = 0; i < ast.length; i += 1) {\n    const node = ast[i];\n\n    switch (node.type) {\n      case NodeTypes.TextNode: {\n        output += renderText(node);\n\n        break;\n      }\n\n      case NodeTypes.ElementNode: {\n        output += renderElement(node, { withSource, isChildOfElementNode });\n\n        break;\n      }\n\n      case NodeTypes.AttributeDoubleQuoted:\n      case NodeTypes.AttributeSingleQuoted:\n      case NodeTypes.AttributeUnquoted: {\n        const name = renderText(node.name);\n        let value = null;\n", "  for (let i = 0; i < ast.length; i += 1) {\n    const node = ast[i];\n\n    switch (node.type) {\n      case NodeTypes.TextNode: {\n        output += renderText(node);\n\n        break;\n      }\n\n      case NodeTypes.ElementNode: {\n        output += renderElement(node, { withSource, isChildOfElementNode });\n\n        break;\n      }\n\n      case NodeTypes.AttributeDoubleQuoted:\n      case NodeTypes.AttributeSingleQuoted:\n      case NodeTypes.AttributeUnquoted: {\n        const name = renderText(node.name);\n        let value = null;\n", "        if (node.value.type === NodeTypes.TextNode) {\n          value = JSON.stringify(renderText(node.value));\n        } else {\n          value = renderLiquidDrop(node.value);\n        }\n\n        output += `${name}: ${value}`;\n\n        break;\n      }\n\n      case NodeTypes.AttributeEmpty: {\n        const name = renderText(node.name);\n        const value = true;\n\n        output += `${name}: ${value}`;\n\n        break;\n      }\n\n      default: {\n        console.log(node);\n\n        // TODO\n        throw new Error('');\n      }\n    }\n  }\n\n  return output;\n}\n", "export default function render(source: string, { withSource = false } = {}) {\n  const ast = sourceToAST(source);\n\n  const ouput = renderAST(ast, { withSource });\n\n  return ouput;\n}\n"]}
{"filename": "src/renderer/__tests__/self-closing.test.ts", "chunked_list": ["import dedent from 'dedent-js';\nimport { testRender } from './utils';\n\nit('should render', () => {\n  const input = dedent`\n  <Icon/>\n  <Icon />\n  `;\n\n  const expected = dedent`", "\n  const expected = dedent`\n  {% render 'Icon' %}\n  {% render 'Icon' %}\n  `;\n\n  testRender(input, expected);\n});\n", ""]}
{"filename": "src/renderer/__tests__/formatting.test.ts", "chunked_list": ["import dedent from 'dedent-js';\nimport { testRender } from './utils';\n\nit('should preserve formatting (single-line)', () => {\n  const input = '<Button>Hello, World!</Button>';\n\n  const expected = dedent`\n  {% capture ButtonChildren %}Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}\n  `;\n", "  `;\n\n  testRender(input, expected);\n});\n\nit('should preserve formatting (multi-line #1)', () => {\n  const input = dedent`\n  <Button>Hello, World!\n  </Button>\n  `;", "  </Button>\n  `;\n\n  const expected = dedent`\n  {% capture ButtonChildren %}Hello, World!\n  {% endcapture %}{% render 'Button', children: ButtonChildren %}\n  `;\n\n  testRender(input, expected);\n});", "  testRender(input, expected);\n});\n\nit('should preserve formatting (multi-line #2)', () => {\n  const input = dedent`\n  <Button>\n    Hello, World!</Button>\n  `;\n\n  const expected = dedent`", "\n  const expected = dedent`\n  {% capture ButtonChildren %}\n    Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should preserve formatting (multi-line #3)', () => {", "\nit('should preserve formatting (multi-line #3)', () => {\n  const input = dedent`\n  <Button>\n    Hello, World!\n  </Button>\n  `;\n\n  const expected = dedent`\n  {% capture ButtonChildren %}", "  const expected = dedent`\n  {% capture ButtonChildren %}\n    Hello, World!\n  {% endcapture %}{% render 'Button', children: ButtonChildren %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should preserve formatting (deeply nested)', () => {", "\nit('should preserve formatting (deeply nested)', () => {\n  const input = dedent`\n  <div>\n    <div>\n      <Button>\n        <Text>\n          <span>Hello, World!</span>\n        </Text>\n      </Button>", "        </Text>\n      </Button>\n    </div>\n  </div>\n  `;\n\n  const expected = dedent`\n  <div>\n    <div>\n      {% capture ButtonChildren %}", "    <div>\n      {% capture ButtonChildren %}\n        {% capture TextChildren %}\n          <span>Hello, World!</span>\n        {% endcapture %}{% render 'Text', children: TextChildren %}\n      {% endcapture %}{% render 'Button', children: ButtonChildren %}\n    </div>\n  </div>\n  `;\n", "  `;\n\n  testRender(input, expected);\n});\n"]}
{"filename": "src/renderer/__tests__/simple.test.ts", "chunked_list": ["import { testRender } from './utils';\n\nit('should render text', () => {\n  const input = '<button>Hello, World</button>';\n\n  const expected = '<button>Hello, World</button>';\n\n  testRender(input, expected);\n});\n", "});\n\nit('should render element without children', () => {\n  const input = '<Button></Button>';\n\n  const expected = \"{% render 'Button' %}\";\n\n  testRender(input, expected);\n});\n", "});\n"]}
{"filename": "src/renderer/__tests__/source.test.ts", "chunked_list": ["import dedent from 'dedent-js';\nimport { testRender } from './utils';\n\nit('should render source', () => {\n  const input = dedent`<Icon />`;\n\n  const expected = dedent`\n  {% # LIQUIDX:START - EDITS MADE TO THE CODE BETWEEN \\\"LIQUIDX:START\\\" and \\\"LIQUIDX:END\\\" WILL BE OVERWRITTEN %}{% render 'Icon' %}{% # LIQUIDX:END - SOURCE \\\"<Icon />\\\" %}\n  `;\n", "  `;\n\n  testRender(input, expected, { withSource: true });\n});\n"]}
{"filename": "src/renderer/__tests__/nested.test.ts", "chunked_list": ["import dedent from 'dedent-js';\nimport { testRender } from './utils';\n\nit('should render text in element', () => {\n  const input = dedent`\n  <Button>Hello, World!</Button>\n  `;\n\n  const expected = dedent`\n  {% capture ButtonChildren %}Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}", "  const expected = dedent`\n  {% capture ButtonChildren %}Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should render element in element', () => {\n  const input = dedent`\n  <Button>", "  const input = dedent`\n  <Button>\n    <Text>Hello, World!</Text>\n  </Button>\n  `;\n\n  const expected = dedent`\n  {% capture ButtonChildren %}\n    {% capture TextChildren %}Hello, World!{% endcapture %}{% render 'Text', children: TextChildren %}\n  {% endcapture %}{% render 'Button', children: ButtonChildren %}", "    {% capture TextChildren %}Hello, World!{% endcapture %}{% render 'Text', children: TextChildren %}\n  {% endcapture %}{% render 'Button', children: ButtonChildren %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should render element in text', () => {\n  const input = dedent`\n  <button>", "  const input = dedent`\n  <button>\n    <Text>Hello, World!</Text>\n  </button>\n  `;\n\n  const expected = dedent`\n  <button>\n    {% capture TextChildren %}Hello, World!{% endcapture %}{% render 'Text', children: TextChildren %}\n  </button>", "    {% capture TextChildren %}Hello, World!{% endcapture %}{% render 'Text', children: TextChildren %}\n  </button>\n  `;\n\n  testRender(input, expected);\n});\n"]}
{"filename": "src/renderer/__tests__/utils.ts", "chunked_list": ["import render from '..';\n\nexport function testRender(input: string, expected: string, { withSource = false } = {}) {\n  const output = render(input, { withSource });\n\n  expect(output).toBe(expected);\n}\n"]}
{"filename": "src/renderer/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\ndescribe(getRootSuiteName(__dirname), () => {\n  requireAll(__dirname);\n});\n"]}
{"filename": "src/renderer/__tests__/attributes.test.ts", "chunked_list": ["import dedent from 'dedent-js';\nimport { testRender } from './utils';\n\nit('should render string', () => {\n  const input = dedent`\n  <Icon str=\"STRING\" />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', str: \"STRING\" %}", "  const expected = dedent`\n  {% render 'Icon', str: \"STRING\" %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should render number', () => {\n  const input = dedent`\n  <Icon num=\"{{ 0 }}\" />", "  const input = dedent`\n  <Icon num=\"{{ 0 }}\" />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', num: 0 %}\n  `;\n\n  testRender(input, expected);\n});", "  testRender(input, expected);\n});\n\nit('should render float', () => {\n  const input = dedent`\n  <Icon num=\"{{ 1.1 }}\" />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', num: 1.1 %}", "  const expected = dedent`\n  {% render 'Icon', num: 1.1 %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should render boolean (explicit)', () => {\n  const input = dedent`\n  <Icon bool1=\"{{ true }}\" bool2=\"{{ false }}\" />", "  const input = dedent`\n  <Icon bool1=\"{{ true }}\" bool2=\"{{ false }}\" />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', bool1: true, bool2: false %}\n  `;\n\n  testRender(input, expected);\n});", "  testRender(input, expected);\n});\n\nit('should render boolean (implicit)', () => {\n  const input = dedent`\n  <Icon bool />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', bool: true %}", "  const expected = dedent`\n  {% render 'Icon', bool: true %}\n  `;\n\n  testRender(input, expected);\n});\n\nit('should render null', () => {\n  const input = dedent`\n  <Icon a=\"{{ null }}\" />", "  const input = dedent`\n  <Icon a=\"{{ null }}\" />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', a: null %}\n  `;\n\n  testRender(input, expected);\n});", "  testRender(input, expected);\n});\n\nit('should render computed', () => {\n  const input = dedent`\n  <Icon attr=\"{{ foo }}\" />\n  `;\n\n  const expected = dedent`\n  {% render 'Icon', attr: foo %}", "  const expected = dedent`\n  {% render 'Icon', attr: foo %}\n  `;\n\n  testRender(input, expected);\n});\n"]}
{"filename": "src/parser/errors.ts", "chunked_list": ["import { SourceLocation, codeFrameColumns } from '@babel/code-frame';\nimport lineColumn from 'line-column';\nimport * as ohm from 'ohm-js';\n\ntype ErrorResult = {\n  result: string;\n};\n\ntype ErrorSource = {\n  result: undefined;\n  message: string;\n  source: string;\n  locStart: number;\n  locEnd: number;\n};\n", "type ErrorSource = {\n  result: undefined;\n  message: string;\n  source: string;\n  locStart: number;\n  locEnd: number;\n};\n\nclass LoggableError extends Error {\n  constructor(info: ErrorResult | ErrorSource) {\n    let result = '';\n", "class LoggableError extends Error {\n  constructor(info: ErrorResult | ErrorSource) {\n    let result = '';\n\n    if (typeof info.result === 'undefined') {\n      const { message, source, locStart, locEnd } = info;\n\n      const lc = lineColumn(source);\n      const start = lc.fromIndex(locStart);\n      const end = lc.fromIndex(Math.min(locEnd, source.length - 1));\n\n      const location: SourceLocation = {\n        start: {\n          line: start?.line ?? source.length - 1,\n          column: start?.col,\n        },\n        end: {\n          line: end?.line ?? source.length,\n          column: end?.col,\n        },\n      };\n\n      result = codeFrameColumns(source, location, {\n        message: message,\n      });\n    } else {\n      result = info.result;\n    }\n\n    super(result);\n\n    this.name = 'BaseError';\n  }\n}\n", "export class CSTParsingError extends LoggableError {\n  constructor(matchResult: ohm.MatchResult) {\n    super({ result: matchResult.message ?? '' });\n\n    this.name = 'CSTParsingError';\n  }\n}\n\nexport class UnknownConcreteNodeTypeError extends LoggableError {\n  constructor(message: string, source: string, locStart: number, locEnd: number) {\n    super({ result: undefined, message, source, locStart, locEnd });\n\n    this.name = 'UnknownConcreteNodeTypeError';\n  }\n}\n", "export class UnknownConcreteNodeTypeError extends LoggableError {\n  constructor(message: string, source: string, locStart: number, locEnd: number) {\n    super({ result: undefined, message, source, locStart, locEnd });\n\n    this.name = 'UnknownConcreteNodeTypeError';\n  }\n}\n\nexport class ASTParsingError extends LoggableError {\n  constructor(message: string, source: string, locStart: number, locEnd: number) {\n    super({ result: undefined, message, source, locStart, locEnd });\n\n    this.name = 'ASTParsingError';\n  }\n}\n", "export class ASTParsingError extends LoggableError {\n  constructor(message: string, source: string, locStart: number, locEnd: number) {\n    super({ result: undefined, message, source, locStart, locEnd });\n\n    this.name = 'ASTParsingError';\n  }\n}\n"]}
{"filename": "src/parser/1-source-to-cst/index.ts", "chunked_list": ["import { Node } from 'ohm-js';\nimport { toAST } from 'ohm-js/extras';\nimport { CSTParsingError } from '../errors';\nimport grammar from '../grammar';\n\nexport enum ConcreteNodeTypes {\n  TextNode = 'TextNode',\n\n  LiquidDropNode = 'LiquidDropNode',\n\n  ElementOpeningTag = 'ElementOpeningTag',\n  ElementClosingTag = 'ElementClosingTag',\n  ElementSelfClosingTag = 'ElementSelfClosingTag',\n\n  AttributeDoubleQuoted = 'AttributeDoubleQuoted',\n  AttributeSingleQuoted = 'AttributeSingleQuoted',\n  AttributeUnquoted = 'AttributeUnquoted',\n  AttributeEmpty = 'AttributeEmpty',\n}\n", "export type ConcreteNode =\n  | ConcreteTextNode\n  | ConcreteLiquidDropNode\n  | ConcreteElementOpeningTagNode\n  | ConcreteElementClosingTagNode\n  | ConcreteElementSelfClosingTagNode;\n\nexport type ConcreteBasicNode<T> = {\n  type: T;\n  locStart: number;\n  locEnd: number;\n  source: string;\n};\n", "export type ConcreteTextNode = {\n  value: string;\n} & ConcreteBasicNode<ConcreteNodeTypes.TextNode>;\n\nexport type ConcreteLiquidDropNode = {\n  value: string;\n} & ConcreteBasicNode<ConcreteNodeTypes.LiquidDropNode>;\n\nexport type ConcreteElementOpeningTagNode = {\n  name: string;\n  attributes: ConcreteAttributeNode[];\n} & ConcreteBasicNode<ConcreteNodeTypes.ElementOpeningTag>;\n", "export type ConcreteElementOpeningTagNode = {\n  name: string;\n  attributes: ConcreteAttributeNode[];\n} & ConcreteBasicNode<ConcreteNodeTypes.ElementOpeningTag>;\n\nexport type ConcreteElementClosingTagNode = {\n  name: string;\n} & ConcreteBasicNode<ConcreteNodeTypes.ElementClosingTag>;\n\nexport type ConcreteElementSelfClosingTagNode = {\n  name: string;\n  attributes: ConcreteAttributeNode[];\n} & ConcreteBasicNode<ConcreteNodeTypes.ElementSelfClosingTag>;\n", "export type ConcreteElementSelfClosingTagNode = {\n  name: string;\n  attributes: ConcreteAttributeNode[];\n} & ConcreteBasicNode<ConcreteNodeTypes.ElementSelfClosingTag>;\n\nexport type ConcreteAttributeNodeBase<T> = {\n  name: ConcreteTextNode;\n  value: ConcreteTextNode;\n} & ConcreteBasicNode<T>;\n\nexport type ConcreteAttributeNode =\n  | ConcreteAttributeDoubleQuoted\n  | ConcreteAttributeSingleQuoted\n  | ConcreteAttributeUnquoted\n  | ConcreteAttributeEmpty;\n", "export type ConcreteAttributeNode =\n  | ConcreteAttributeDoubleQuoted\n  | ConcreteAttributeSingleQuoted\n  | ConcreteAttributeUnquoted\n  | ConcreteAttributeEmpty;\n\nexport type ConcreteAttributeDoubleQuoted =\n  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeDoubleQuoted>;\n\nexport type ConcreteAttributeSingleQuoted =\n  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeSingleQuoted>;\n", "export type ConcreteAttributeSingleQuoted =\n  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeSingleQuoted>;\n\nexport type ConcreteAttributeUnquoted =\n  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeUnquoted>;\n\nexport type ConcreteAttributeEmpty = {\n  name: ConcreteTextNode;\n} & ConcreteBasicNode<ConcreteNodeTypes.AttributeEmpty>;\n\nexport type CST = ConcreteNode[];\n", "export type CST = ConcreteNode[];\n\nexport type TemplateMapping = {\n  type: ConcreteNodeTypes;\n  locStart: (node: Node[]) => number;\n  locEnd: (node: Node[]) => number;\n  source: string;\n  [k: string]: string | number | boolean | object | null;\n};\n\nexport type TopLevelFunctionMapping = (...nodes: Node[]) => any;\n", "export type TopLevelFunctionMapping = (...nodes: Node[]) => any;\n\nexport type Mapping = {\n  [k: string]: number | TemplateMapping | TopLevelFunctionMapping;\n};\n\nfunction locStart(nodes: Node[]) {\n  return nodes[0].source.startIdx;\n}\n\nfunction locEnd(nodes: Node[]) {\n  return nodes[nodes.length - 1].source.endIdx;\n}\n", "function locEnd(nodes: Node[]) {\n  return nodes[nodes.length - 1].source.endIdx;\n}\n\nexport default function sourceToCST(source: string): ConcreteNode[] {\n  const matchResult = grammar.match(source);\n\n  if (matchResult.failed()) {\n    throw new CSTParsingError(matchResult);\n  }\n\n  const textNode = {\n    type: ConcreteNodeTypes.TextNode,\n    locStart,\n    locEnd,\n    value: function (this: Node) {\n      return this.sourceString;\n    },\n    source,\n  };\n\n  const mapping: Mapping = {\n    Node: 0,\n\n    TextNode: textNode,\n\n    liquidDropNode: {\n      type: ConcreteNodeTypes.LiquidDropNode,\n      locStart,\n      locEnd,\n      source,\n      value: 2,\n    },\n    liquidDropValue: (node: Node) => node.sourceString.trimEnd(),\n\n    ElementNode: 0,\n\n    ElementOpeningTag: {\n      type: ConcreteNodeTypes.ElementOpeningTag,\n      locStart,\n      locEnd,\n      name: 1,\n      attributes: 2,\n      source,\n    },\n    ElementClosingTag: {\n      type: ConcreteNodeTypes.ElementClosingTag,\n      locStart,\n      locEnd,\n      name: 1,\n      source,\n    },\n    ElementSelfClosingTag: {\n      type: ConcreteNodeTypes.ElementSelfClosingTag,\n      locStart,\n      locEnd,\n      name: 1,\n      attributes: 2,\n      source,\n    },\n\n    AttributeDoubleQuoted: {\n      type: ConcreteNodeTypes.AttributeDoubleQuoted,\n      locStart,\n      locEnd,\n      source,\n      name: 0,\n      value: 3,\n    },\n    AttributeSingleQuoted: {\n      type: ConcreteNodeTypes.AttributeSingleQuoted,\n      locStart,\n      locEnd,\n      source,\n      name: 0,\n      value: 3,\n    },\n    AttributeUnquoted: {\n      type: ConcreteNodeTypes.AttributeUnquoted,\n      locStart,\n      locEnd,\n      source,\n      name: 0,\n      value: 2,\n    },\n    AttributeEmpty: {\n      type: ConcreteNodeTypes.AttributeEmpty,\n      locStart,\n      locEnd,\n      source,\n      name: 0,\n    },\n\n    attributeName: textNode,\n\n    attributeDoubleQuotedValue: 0,\n    attributeSingleQuotedValue: 0,\n    attributeUnquotedValue: 0,\n\n    attributeDoubleQuotedTextNode: textNode,\n    attributeSingleQuotedTextNode: textNode,\n    attributeUnquotedTextNode: textNode,\n  };\n\n  const cst = toAST(matchResult, mapping) as ConcreteNode[];\n\n  return cst;\n}\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/text-node.test.ts", "chunked_list": ["import { expectOutput } from './utils';\n\nit('should parse plain text', () => {\n  const input = 'Plain text';\n\n  expectOutput(input).toHaveProperty('0.type', 'TextNode');\n  expectOutput(input).toHaveProperty('0.value', 'Plain text');\n});\n\nit('should parse native HTML elements', () => {", "\nit('should parse native HTML elements', () => {\n  const input = '<button></button>';\n\n  expectOutput(input).toHaveProperty('0.type', 'TextNode');\n  expectOutput(input).toHaveProperty('0.value', '<button></button>');\n});\n\nit('should parse custom HTML elements', () => {\n  const input = '<custom-button></custom-button>';", "it('should parse custom HTML elements', () => {\n  const input = '<custom-button></custom-button>';\n\n  expectOutput(input).toHaveProperty('0.type', 'TextNode');\n  expectOutput(input).toHaveProperty('0.value', '<custom-button></custom-button>');\n});\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/utils.ts", "chunked_list": ["import sourceToCST from '../';\n\nexport function expectOutput(input: string) {\n  const output = sourceToCST(input);\n\n  return expect(output);\n}\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\ndescribe(getRootSuiteName(__dirname), () => {\n  requireAll(__dirname);\n});\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/element-node.test.ts", "chunked_list": ["import { expectOutput } from './utils';\n\ndescribe('opening tag', () => {\n  it('should parse without attributes', () => {\n    const input = '<Button>';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementOpeningTag');\n    expectOutput(input).toHaveProperty('0.name', 'Button');\n    expectOutput(input).toHaveProperty('0.attributes.length', 0);\n  });", "    expectOutput(input).toHaveProperty('0.attributes.length', 0);\n  });\n\n  it('should parse with single attribute', () => {\n    const input = '<Button secondary>';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementOpeningTag');\n    expectOutput(input).toHaveProperty('0.name', 'Button');\n    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'secondary');\n    expectOutput(input).toHaveProperty('0.attributes.length', 1);", "    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'secondary');\n    expectOutput(input).toHaveProperty('0.attributes.length', 1);\n  });\n\n  it('should parse with multiple attributes', () => {\n    const input = '<Button secondary icon=\"IconShoppingBag\">';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementOpeningTag');\n    expectOutput(input).toHaveProperty('0.name', 'Button');\n    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'secondary');", "    expectOutput(input).toHaveProperty('0.name', 'Button');\n    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'secondary');\n    expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'icon');\n    expectOutput(input).toHaveProperty('0.attributes.length', 2);\n  });\n});\n\ndescribe('closing tag', () => {\n  it('should parse', () => {\n    const input = '</Button>';", "  it('should parse', () => {\n    const input = '</Button>';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementClosingTag');\n    expectOutput(input).toHaveProperty('0.name', 'Button');\n  });\n});\n\ndescribe('self-closing tag', () => {\n  it('should parse without attributes', () => {", "describe('self-closing tag', () => {\n  it('should parse without attributes', () => {\n    const input = '<Icon/>';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementSelfClosingTag');\n    expectOutput(input).toHaveProperty('0.name', 'Icon');\n    expectOutput(input).toHaveProperty('0.attributes.length', 0);\n  });\n\n  it('should parse with single attribute', () => {", "\n  it('should parse with single attribute', () => {\n    const input = '<Icon icon=\"IconShoppingBag\" />';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementSelfClosingTag');\n    expectOutput(input).toHaveProperty('0.name', 'Icon');\n    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'icon');\n    expectOutput(input).toHaveProperty('0.attributes.length', 1);\n  });\n", "  });\n\n  it('should parse with multiple attributes', () => {\n    const input = '<Icon icon=\"IconShoppingBag\" size=\"sm\" />';\n\n    expectOutput(input).toHaveProperty('0.type', 'ElementSelfClosingTag');\n    expectOutput(input).toHaveProperty('0.name', 'Icon');\n    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'icon');\n    expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'size');\n    expectOutput(input).toHaveProperty('0.attributes.length', 2);", "    expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'size');\n    expectOutput(input).toHaveProperty('0.attributes.length', 2);\n  });\n});\n\ndescribe('attributes', () => {\n  it('should parse double quoted attribute', () => {\n    const input = '<Button attr=\"test\">';\n\n    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeDoubleQuoted');", "\n    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeDoubleQuoted');\n  });\n\n  it('should parse single quoted attribute', () => {\n    const input = \"<Button attr='test'>\";\n\n    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeSingleQuoted');\n  });\n", "  });\n\n  it('should parse unquoted attribute', () => {\n    const input = '<Button attr=test>';\n\n    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeUnquoted');\n  });\n\n  it('should parse empty attribute', () => {\n    const input = '<Button attr>';", "  it('should parse empty attribute', () => {\n    const input = '<Button attr>';\n\n    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeEmpty');\n  });\n\n  describe('values', () => {\n    it('should parse text attribute value', () => {\n      const input = '<Button attr1=\"test\" attr2=\"0\" attr3=\"true\">';\n", "      const input = '<Button attr1=\"test\" attr2=\"0\" attr3=\"true\">';\n\n      expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'attr1');\n      expectOutput(input).toHaveProperty('0.attributes.0.value.type', 'TextNode');\n      expectOutput(input).toHaveProperty('0.attributes.0.value.value', 'test');\n\n      expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'attr2');\n      expectOutput(input).toHaveProperty('0.attributes.1.value.type', 'TextNode');\n      expectOutput(input).toHaveProperty('0.attributes.1.value.value', '0');\n", "      expectOutput(input).toHaveProperty('0.attributes.1.value.value', '0');\n\n      expectOutput(input).toHaveProperty('0.attributes.2.name.value', 'attr3');\n      expectOutput(input).toHaveProperty('0.attributes.2.value.type', 'TextNode');\n      expectOutput(input).toHaveProperty('0.attributes.2.value.value', 'true');\n    });\n\n    it('should parse liquid drop attribute value', () => {\n      const input = '<Button attr1=\"{{ \\'test\\' }}\" attr2=\"{{ 0 }}\" attr3=\"{{ true }}\">';\n", "      const input = '<Button attr1=\"{{ \\'test\\' }}\" attr2=\"{{ 0 }}\" attr3=\"{{ true }}\">';\n\n      expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'attr1');\n      expectOutput(input).toHaveProperty('0.attributes.0.value.type', 'LiquidDropNode');\n      expectOutput(input).toHaveProperty('0.attributes.0.value.value', \"'test'\");\n\n      expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'attr2');\n      expectOutput(input).toHaveProperty('0.attributes.1.value.type', 'LiquidDropNode');\n      expectOutput(input).toHaveProperty('0.attributes.1.value.value', '0');\n", "      expectOutput(input).toHaveProperty('0.attributes.1.value.value', '0');\n\n      expectOutput(input).toHaveProperty('0.attributes.2.name.value', 'attr3');\n      expectOutput(input).toHaveProperty('0.attributes.2.value.type', 'LiquidDropNode');\n      expectOutput(input).toHaveProperty('0.attributes.2.value.value', 'true');\n    });\n  });\n});\n", ""]}
{"filename": "src/parser/2-cst-to-ast/ast-builder.ts", "chunked_list": ["import { ElementNode, LiquidXNode, NodeTypes } from '.';\nimport {\n  ConcreteElementClosingTagNode,\n  ConcreteElementSelfClosingTagNode,\n} from '../1-source-to-cst';\nimport { ASTParsingError } from '../errors';\nimport { deepGet, dropLast } from './utils';\n\nexport default class ASTBuilder {\n  ast: LiquidXNode[];\n  cursor: (string | number)[];\n  source: string;\n\n  constructor(source: string) {\n    this.ast = [];\n    this.cursor = [];\n    this.source = source;\n  }\n\n  get current(): LiquidXNode[] {\n    return deepGet<LiquidXNode[]>(this.cursor, this.ast);\n  }\n\n  get currentPosition(): number {\n    return (this.current || []).length - 1;\n  }\n\n  get parent(): ElementNode | undefined {", "export default class ASTBuilder {\n  ast: LiquidXNode[];\n  cursor: (string | number)[];\n  source: string;\n\n  constructor(source: string) {\n    this.ast = [];\n    this.cursor = [];\n    this.source = source;\n  }\n\n  get current(): LiquidXNode[] {\n    return deepGet<LiquidXNode[]>(this.cursor, this.ast);\n  }\n\n  get currentPosition(): number {\n    return (this.current || []).length - 1;\n  }\n\n  get parent(): ElementNode | undefined {", "    if (this.cursor.length == 0) return undefined;\n\n    return deepGet<ElementNode>(dropLast(1, this.cursor), this.ast);\n  }\n\n  open(node: ElementNode) {\n    this.push(node);\n    this.cursor.push(this.currentPosition);\n    this.cursor.push('children');\n  }\n\n  close(\n    node: ConcreteElementClosingTagNode | ConcreteElementSelfClosingTagNode,\n    nodeType: NodeTypes.ElementNode,\n  ) {", "    if (!this.parent || this.parent.name !== node.name || this.parent.type !== nodeType) {\n      throw new ASTParsingError(\n        `LiquidX element '${node.name}' has no corresponding opening tag`,\n        this.source,\n        node.locStart,\n        node.locEnd,\n      );\n    }\n\n    this.parent.locEnd = node.locEnd;\n\n    this.cursor.pop();\n    this.cursor.pop();\n  }\n\n  push(node: LiquidXNode) {\n    this.current.push(node);\n  }\n\n  finish() {", "    if (this.cursor.length > 0) {\n      throw new ASTParsingError(\n        `LiquidX element '${this.parent?.name}' has no corresponding closing tag.`,\n        this.source,\n        this.parent?.locStart ?? this.source.length - 1,\n        this.parent?.locEnd ?? this.source.length,\n      );\n    }\n\n    return this.ast;\n  }\n}\n"]}
{"filename": "src/parser/2-cst-to-ast/utils.ts", "chunked_list": ["export function deepGet<T = any>(path: (string | number)[], obj: any): T {\n  return path.reduce((curr: any, k: string | number) => {\n    if (curr && curr[k] !== undefined) return curr[k];\n\n    return undefined;\n  }, obj);\n}\n\nexport function dropLast<T>(num: number, xs: readonly T[]) {\n  const result = [...xs];\n", "export function dropLast<T>(num: number, xs: readonly T[]) {\n  const result = [...xs];\n\n  for (let i = 0; i < num; i += 1) {\n    result.pop();\n  }\n\n  return result;\n}\n"]}
{"filename": "src/parser/2-cst-to-ast/index.ts", "chunked_list": ["import sourceToCST, {\n  ConcreteAttributeNode,\n  ConcreteElementOpeningTagNode,\n  ConcreteElementSelfClosingTagNode,\n  ConcreteLiquidDropNode,\n  ConcreteNode,\n  ConcreteNodeTypes,\n  ConcreteTextNode,\n} from '../1-source-to-cst';\nimport { UnknownConcreteNodeTypeError } from '../errors';", "} from '../1-source-to-cst';\nimport { UnknownConcreteNodeTypeError } from '../errors';\nimport ASTBuilder from './ast-builder';\n\nexport type BasicNode<T> = {\n  type: T;\n  locStart: number;\n  locEnd: number;\n  source: string;\n};\n", "export enum NodeTypes {\n  TextNode = 'TextNode',\n\n  LiquidDropNode = 'LiquidDropNode',\n\n  ElementNode = 'ElementNode',\n\n  AttributeDoubleQuoted = 'AttributeDoubleQuoted',\n  AttributeSingleQuoted = 'AttributeSingleQuoted',\n  AttributeUnquoted = 'AttributeUnquoted',\n  AttributeEmpty = 'AttributeEmpty',\n}\n", "export type TextNode = {\n  value: string;\n} & BasicNode<NodeTypes.TextNode>;\n\nexport type LiquidDropNode = {\n  value: string;\n} & BasicNode<NodeTypes.LiquidDropNode>;\n\nexport type LiquidXNode = TextNode | LiquidDropNode | ElementNode | AttributeNode;\n\nexport type ElementNode = {\n  name: string;\n  source: string;\n  attributes: AttributeNode[];\n  children: LiquidXNode[];\n} & BasicNode<NodeTypes.ElementNode>;\n", "export type LiquidXNode = TextNode | LiquidDropNode | ElementNode | AttributeNode;\n\nexport type ElementNode = {\n  name: string;\n  source: string;\n  attributes: AttributeNode[];\n  children: LiquidXNode[];\n} & BasicNode<NodeTypes.ElementNode>;\n\nexport type AttributeNode =\n  | AttributeDoubleQuoted\n  | AttributeSingleQuoted\n  | AttributeUnquoted\n  | AttributeEmpty;\n", "export type AttributeNode =\n  | AttributeDoubleQuoted\n  | AttributeSingleQuoted\n  | AttributeUnquoted\n  | AttributeEmpty;\n\nexport type AttributeNodeBase<T> = {\n  name: TextNode;\n  value: TextNode | LiquidDropNode;\n} & BasicNode<T>;\n", "export type AttributeDoubleQuoted = {} & AttributeNodeBase<NodeTypes.AttributeDoubleQuoted>;\nexport type AttributeSingleQuoted = {} & AttributeNodeBase<NodeTypes.AttributeSingleQuoted>;\nexport type AttributeUnquoted = {} & AttributeNodeBase<NodeTypes.AttributeUnquoted>;\nexport type AttributeEmpty = { name: TextNode } & BasicNode<NodeTypes.AttributeEmpty>;\n\nfunction toTextNode(node: ConcreteTextNode): TextNode {\n  return {\n    type: NodeTypes.TextNode,\n    locStart: node.locStart,\n    locEnd: node.locEnd,\n    source: node.source,\n    value: node.value,\n  };\n}\n", "function toLiquidDropNode(node: ConcreteLiquidDropNode): LiquidDropNode {\n  return {\n    type: NodeTypes.LiquidDropNode,\n    locStart: node.locStart,\n    locEnd: node.locEnd,\n    source: node.source,\n    value: node.value,\n  };\n}\n\nfunction toElementNode(\n  node: ConcreteElementOpeningTagNode | ConcreteElementSelfClosingTagNode,\n): ElementNode {\n  return {\n    type: NodeTypes.ElementNode,\n    locStart: node.locStart,\n    locEnd: node.locEnd,\n    name: node.name,\n    source: node.source,\n    attributes: toAttributes(node.attributes),\n    children: [],\n  };\n}\n", "function toElementNode(\n  node: ConcreteElementOpeningTagNode | ConcreteElementSelfClosingTagNode,\n): ElementNode {\n  return {\n    type: NodeTypes.ElementNode,\n    locStart: node.locStart,\n    locEnd: node.locEnd,\n    name: node.name,\n    source: node.source,\n    attributes: toAttributes(node.attributes),\n    children: [],\n  };\n}\n", "function toAttributes(attributes: ConcreteAttributeNode[]) {\n  return cstToAST(attributes) as AttributeNode[];\n}\n\nfunction toAttributeValue(value: ConcreteTextNode | ConcreteLiquidDropNode) {\n  return cstToAST([value])[0] as TextNode | LiquidDropNode;\n}\n\nfunction isAttributeNode(node: any): boolean {\n  return (\n    node.type === ConcreteNodeTypes.AttributeDoubleQuoted ||\n    node.type === ConcreteNodeTypes.AttributeSingleQuoted ||\n    node.type === ConcreteNodeTypes.AttributeUnquoted ||\n    node.type === ConcreteNodeTypes.AttributeEmpty\n  );\n}\n", "function isAttributeNode(node: any): boolean {\n  return (\n    node.type === ConcreteNodeTypes.AttributeDoubleQuoted ||\n    node.type === ConcreteNodeTypes.AttributeSingleQuoted ||\n    node.type === ConcreteNodeTypes.AttributeUnquoted ||\n    node.type === ConcreteNodeTypes.AttributeEmpty\n  );\n}\n\nfunction cstToAST(cst: ConcreteNode[] | ConcreteAttributeNode[]) {\n  if (cst.length === 0) return [];\n\n  const astBuilder = new ASTBuilder(cst[0].source);\n", "function cstToAST(cst: ConcreteNode[] | ConcreteAttributeNode[]) {\n  if (cst.length === 0) return [];\n\n  const astBuilder = new ASTBuilder(cst[0].source);\n\n  for (let i = 0; i < cst.length; i += 1) {\n    const node = cst[i];\n    const prevNode = cst[i - 1];\n\n    // Add whitespaces and linebreaks that went missing after parsing. We don't need to do this\n    // if the node is an attribute since whitespaces between attributes is not important to preserve.\n    // In fact it would probably break the rendered output due to unexpected text nodes.\n    // TODO: This should be handled in the grammar/source-to-cst part instead (if possible).", "    if (prevNode?.source && !isAttributeNode(node)) {\n      const diff = node.locStart - prevNode.locEnd;\n\n      if (diff > 0) {\n        astBuilder.push(\n          toTextNode({\n            type: ConcreteNodeTypes.TextNode,\n            locStart: prevNode.locEnd,\n            locEnd: node.locStart,\n            source: node.source,\n            value: prevNode.source.slice(prevNode.locEnd, node.locStart),\n          }),\n        );\n      }\n    }\n\n    switch (node.type) {\n      case ConcreteNodeTypes.TextNode: {\n        astBuilder.push(toTextNode(node));\n\n        break;\n      }\n\n      case ConcreteNodeTypes.LiquidDropNode: {\n        astBuilder.push(toLiquidDropNode(node));\n        break;\n      }\n\n      case ConcreteNodeTypes.ElementOpeningTag: {\n        astBuilder.open(toElementNode(node));\n\n        break;\n      }\n\n      case ConcreteNodeTypes.ElementClosingTag: {\n        astBuilder.close(node, NodeTypes.ElementNode);\n\n        break;\n      }\n\n      case ConcreteNodeTypes.ElementSelfClosingTag: {\n        astBuilder.open(toElementNode(node));\n        astBuilder.close(node, NodeTypes.ElementNode);\n\n        break;\n      }\n\n      case ConcreteNodeTypes.AttributeDoubleQuoted:\n      case ConcreteNodeTypes.AttributeSingleQuoted:\n      case ConcreteNodeTypes.AttributeUnquoted: {\n        const attributeNode: AttributeDoubleQuoted | AttributeSingleQuoted | AttributeUnquoted = {", "          type: node.type as unknown as\n            | NodeTypes.AttributeDoubleQuoted\n            | NodeTypes.AttributeSingleQuoted\n            | NodeTypes.AttributeUnquoted,\n          locStart: node.locStart,\n          locEnd: node.locEnd,\n          source: node.source,\n          name: cstToAST([node.name])[0] as TextNode,\n          value: toAttributeValue(node.value),\n        };\n\n        astBuilder.push(attributeNode);\n\n        break;\n      }\n\n      case ConcreteNodeTypes.AttributeEmpty: {\n        const attributeNode: AttributeEmpty = {\n          type: NodeTypes.AttributeEmpty,\n          locStart: node.locStart,\n          locEnd: node.locEnd,\n          source: node.source,\n          name: cstToAST([node.name])[0] as TextNode,\n        };\n\n        astBuilder.push(attributeNode);\n\n        break;\n      }\n\n      default: {\n        throw new UnknownConcreteNodeTypeError(\n          '',\n          (node as any)?.source,\n          (node as any)?.locStart,\n          (node as any)?.locEnd,\n        );\n      }\n    }\n  }\n\n  return astBuilder.finish();\n}\n", "export default function sourceToAST(source: string): LiquidXNode[] {\n  const cst = sourceToCST(source);\n  const ast = cstToAST(cst);\n\n  return ast;\n}\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/text-node.test.ts", "chunked_list": ["import { NodeTypes } from '..';\nimport { expectOutput } from './utils';\n\nit('should parse plain text', () => {\n  const input = 'Plain text';\n\n  expectOutput(input).toHaveProperty('0.type', NodeTypes.TextNode);\n  expectOutput(input).toHaveProperty('0.value', 'Plain text');\n});\n", "});\n\nit('should parse native HTML elements', () => {\n  const input = '<button></button>';\n\n  expectOutput(input).toHaveProperty('0.type', NodeTypes.TextNode);\n  expectOutput(input).toHaveProperty('0.value', '<button></button>');\n});\n\nit('should parse custom HTML elements', () => {", "\nit('should parse custom HTML elements', () => {\n  const input = '<custom-button></custom-button>';\n\n  expectOutput(input).toHaveProperty('0.type', NodeTypes.TextNode);\n  expectOutput(input).toHaveProperty('0.value', '<custom-button></custom-button>');\n});\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/utils.ts", "chunked_list": ["import sourceToAST from '../';\n\nexport function expectOutput(input: string) {\n  const output = sourceToAST(input);\n\n  return expect(output);\n}\n\nexport function expectErrorMessage(input: string) {\n  let errorMessage = '';\n", "export function expectErrorMessage(input: string) {\n  let errorMessage = '';\n\n  try {\n    sourceToAST(input);\n  } catch (error: any) {\n    errorMessage = error.message;\n  }\n\n  return expect(errorMessage);\n}\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\ndescribe(getRootSuiteName(__dirname), () => {\n  requireAll(__dirname);\n});\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/element-node.test.ts", "chunked_list": ["import { NodeTypes } from '..';\nimport { expectErrorMessage, expectOutput } from './utils';\n\nit('should parse without children', () => {\n  const input = '<Button></Button>';\n\n  expectOutput(input).toHaveProperty('0.type', NodeTypes.ElementNode);\n  expectOutput(input).toHaveProperty('0.name', 'Button');\n  expectOutput(input).toHaveProperty('0.children', []);\n});", "  expectOutput(input).toHaveProperty('0.children', []);\n});\n\nit('should parse with text children', () => {\n  const input = '<Button>Plain text</Button>';\n\n  expectOutput(input).toHaveProperty('0.type', NodeTypes.ElementNode);\n  expectOutput(input).toHaveProperty('0.name', 'Button');\n  expectOutput(input).toHaveProperty('0.children.0.type', NodeTypes.TextNode);\n});", "  expectOutput(input).toHaveProperty('0.children.0.type', NodeTypes.TextNode);\n});\n\nit('should parse with element children', () => {\n  const input = '<Box><Button>Plain text</Button></Box>';\n\n  expectOutput(input).toHaveProperty('0.type', NodeTypes.ElementNode);\n  expectOutput(input).toHaveProperty('0.name', 'Box');\n  expectOutput(input).toHaveProperty('0.children.0.type', NodeTypes.ElementNode);\n  expectOutput(input).toHaveProperty('0.children.0.name', 'Button');", "  expectOutput(input).toHaveProperty('0.children.0.type', NodeTypes.ElementNode);\n  expectOutput(input).toHaveProperty('0.children.0.name', 'Button');\n  expectOutput(input).toHaveProperty('0.children.0.children.0.type', NodeTypes.TextNode);\n});\n\nit('should throw an error if corresponding closing tag is missing', () => {\n  const input = '<Box>';\n\n  expectErrorMessage(input).toMatchSnapshot();\n});", "  expectErrorMessage(input).toMatchSnapshot();\n});\n\nit('should throw an error if corresponding opening tag is missing', () => {\n  const input = '</Box>';\n\n  expectErrorMessage(input).toMatchSnapshot();\n});\n", ""]}
{"filename": "src/parser/grammar/index.ts", "chunked_list": ["import * as fs from 'fs';\nimport * as ohm from 'ohm-js';\nimport * as path from 'path';\n\nexport const grammars = ohm.grammars(fs.readFileSync(path.join(__dirname, 'liquidx.ohm'), 'utf8'));\n\nexport default grammars['LiquidX'];\n"]}
{"filename": "src/parser/grammar/__tests__/grammar.test.ts", "chunked_list": ["import grammar from '..';\n\nit('should parse plain text', () => {\n  expectMatchSucceeded('Hello, World!').toBe(true);\n  expectMatchSucceeded('<a').toBe(true);\n  expectMatchSucceeded('<1').toBe(true);\n  expectMatchSucceeded('2 < 3').toBe(true);\n});\n\nit('should parse valid HTML tags', () => {", "\nit('should parse valid HTML tags', () => {\n  expectMatchSucceeded('<button></button>').toBe(true);\n  expectMatchSucceeded('<button type=\"submit\"></button>').toBe(true);\n  expectMatchSucceeded('<button>').toBe(true);\n  expectMatchSucceeded('</button>').toBe(true);\n  expectMatchSucceeded('<a>').toBe(true);\n  expectMatchSucceeded('<img />').toBe(true);\n});\n", "});\n\nit('should parse invalid HTML tags', () => {\n  expectMatchSucceeded('< button>').toBe(true);\n  expectMatchSucceeded('<button').toBe(true);\n  expectMatchSucceeded('<button attr').toBe(true);\n  expectMatchSucceeded('button>').toBe(true);\n  expectMatchSucceeded('button attr>').toBe(true);\n  expectMatchSucceeded('</button').toBe(true);\n  expectMatchSucceeded('img />').toBe(true);", "  expectMatchSucceeded('</button').toBe(true);\n  expectMatchSucceeded('img />').toBe(true);\n  expectMatchSucceeded('img attr />').toBe(true);\n});\n\nit('should parse valid LiquidX tags', () => {\n  expectMatchSucceeded('<Button></Button>').toBe(true);\n  expectMatchSucceeded('<Button type=\"submit\"></Button>').toBe(true);\n  expectMatchSucceeded('<Button>').toBe(true);\n  expectMatchSucceeded('</Button>').toBe(true);", "  expectMatchSucceeded('<Button>').toBe(true);\n  expectMatchSucceeded('</Button>').toBe(true);\n  expectMatchSucceeded('<A>').toBe(true);\n  expectMatchSucceeded('<Image />').toBe(true);\n});\n\nit('should not parse invalid LiquidX tags', () => {\n  expectMatchSucceeded('< Button>').toBe(false);\n  expectMatchSucceeded('<Button').toBe(false);\n  expectMatchSucceeded('<Button attr').toBe(false);", "  expectMatchSucceeded('<Button').toBe(false);\n  expectMatchSucceeded('<Button attr').toBe(false);\n  expectMatchSucceeded('Button>').toBe(false);\n  expectMatchSucceeded('Button attr>').toBe(false);\n  expectMatchSucceeded('</Button').toBe(false);\n  expectMatchSucceeded('Image />').toBe(false);\n  expectMatchSucceeded('Image attr />').toBe(false);\n});\n\nfunction expectMatchSucceeded(source: string) {\n  const match = grammar.match(source);\n\n  return expect(match.succeeded());\n}\n", "\nfunction expectMatchSucceeded(source: string) {\n  const match = grammar.match(source);\n\n  return expect(match.succeeded());\n}\n"]}
{"filename": "src/parser/grammar/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\ndescribe(getRootSuiteName(__dirname), () => {\n  requireAll(__dirname);\n});\n"]}
