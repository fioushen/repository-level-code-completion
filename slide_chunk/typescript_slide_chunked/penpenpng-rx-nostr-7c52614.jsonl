{"filename": "vite.config.ts", "chunked_list": ["import path from \"path\";\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  define: {\n    \"import.meta.vitest\": \"undefined\",\n  },\n  build: {\n    lib: {\n      name: \"rx-nostr\",", "    lib: {\n      name: \"rx-nostr\",\n      fileName: (format) => `index.${format}.js`,\n      entry: path.resolve(__dirname, \"src/index.ts\"),\n      formats: [\"es\", \"cjs\", \"umd\"],\n    },\n    sourcemap: true,\n  },\n});\n", "});\n"]}
{"filename": "docs/.vuepress/config.ts", "chunked_list": ["import { defineUserConfig, defaultTheme } from \"vuepress\";\nimport attrs from \"markdown-it-attrs\";\n\nexport default defineUserConfig({\n  // To host on GitHub Pages.\n  base: \"/rx-nostr/\",\n  lang: \"ja_JP\",\n  title: \"rx-nostr\",\n  description:\n    \"A library based on RxJS, which allows Nostr applications to easily communicate with relays.\",", "  description:\n    \"A library based on RxJS, which allows Nostr applications to easily communicate with relays.\",\n  // Ban README.md. Use index.md instead.\n  pagePatterns: [\"**/*.md\", \"!**/README.md\", \"!.vuepress\", \"!node_modules\"],\n  markdown: {\n    code: {\n      lineNumbers: false,\n    },\n  },\n  extendsMarkdown: (md) => {", "  },\n  extendsMarkdown: (md) => {\n    // Allow `# Header Text [#custom-id-attr]` syntax.\n    // Default delimiters `{}` conflict with [line highlighting](https://v2.vuepress.vuejs.org/guide/markdown.html#code-blocks) feature.\n    md.use(attrs, {\n      leftDelimiter: \"[\",\n      rightDelimiter: \"]\",\n    });\n  },\n  theme: defaultTheme({", "  },\n  theme: defaultTheme({\n    navbar: [\n      {\n        text: \"Docs\",\n        link: \"/docs/\",\n      },\n      {\n        text: \"GitHub\",\n        link: \"https://github.com/penpenpng/rx-nostr\",", "        text: \"GitHub\",\n        link: \"https://github.com/penpenpng/rx-nostr\",\n      },\n    ],\n    sidebar: {\n      \"/docs/\": [\n        {\n          text: \"Introduction\",\n          children: [\n            \"/docs/index.md\",", "          children: [\n            \"/docs/index.md\",\n            \"/docs/getting-started.md\",\n            \"/docs/first-step.md\",\n          ],\n        },\n        {\n          text: \"Guide\",\n          children: [\n            \"/docs/req-strategy.md\",", "          children: [\n            \"/docs/req-strategy.md\",\n            \"/docs/relay-configuration.md\",\n            \"/docs/lazy-since-until.md\",\n            \"/docs/sending-event.md\",\n            \"/docs/monitoring-connections.md\",\n            \"/docs/error-handling.md\",\n            \"/docs/operators.md\",\n          ],\n        },", "          ],\n        },\n        {\n          text: \"Examples\",\n          link: \"/docs/examples.md\",\n        },\n      ],\n    },\n    editLinkText: \"\u3053\u306e\u30da\u30fc\u30b8\u3092\u7de8\u96c6\",\n    docsRepo: \"https://github.com/penpenpng/rx-nostr\",", "    editLinkText: \"\u3053\u306e\u30da\u30fc\u30b8\u3092\u7de8\u96c6\",\n    docsRepo: \"https://github.com/penpenpng/rx-nostr\",\n    docsBranch: \"main\",\n    docsDir: \"docs\",\n  }),\n});\n"]}
{"filename": "app/main.ts", "chunked_list": ["// # Playground\n// Edit here and try `yarn dev`\n\nimport {\n  createRxBackwardReq,\n  createRxForwardReq,\n  createRxNostr,\n} from \"../src/index.js\";\n\ndocument.getElementById(\"send\")?.addEventListener(\"click\", async () => {", "\ndocument.getElementById(\"send\")?.addEventListener(\"click\", async () => {\n  const input = document.getElementById(\"input\") as HTMLInputElement;\n  rxNostr\n    .send({\n      kind: 1,\n      content: input.value,\n      pubkey: (await window.nostr?.getPublicKey()) ?? \"\",\n    })\n    .subscribe({", "    })\n    .subscribe({\n      next: ({ from }) => {\n        console.log(\"OK\", from);\n      },\n      complete: () => {\n        console.log(\"Send completed\");\n      },\n    });\n  input.value = \"\";", "    });\n  input.value = \"\";\n});\n\nconst rxNostr = createRxNostr();\nrxNostr.createConnectionStateObservable().subscribe((ev) => {\n  console.log(ev.state, ev.from);\n});\nrxNostr.switchRelays([\n  \"wss://relay-jp.nostr.wirednet.jp\",", "rxNostr.switchRelays([\n  \"wss://relay-jp.nostr.wirednet.jp\",\n  \"wss://nostr-relay.nokotaro.com\",\n]);\n\nconst req0 = createRxBackwardReq();\nrxNostr\n  .use(req0)\n  .subscribe((e) => console.log(0, e.event.id.slice(0, 5), e.subId, e.from));\n", "  .subscribe((e) => console.log(0, e.event.id.slice(0, 5), e.subId, e.from));\n\nconst req1 = createRxForwardReq();\nrxNostr\n  .use(req1)\n  .subscribe((e) => console.log(1, e.event.id.slice(0, 5), e.subId, e.from));\n\nreq0.emit([{ kinds: [0], limit: 3 }]);\nreq1.emit([{ kinds: [1], limit: 3 }]);\n", "req1.emit([{ kinds: [1], limit: 3 }]);\n\nsetTimeout(() => {\n  console.log(\"---\");\n  rxNostr.switchRelays([\n    \"wss://relay-jp.nostr.wirednet.jp\",\n    \"wss://nostr.h3z.jp\",\n  ]);\n}, 3000);\n", "}, 3000);\n"]}
{"filename": "app/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n"]}
{"filename": "src/req.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\nimport { BehaviorSubject, Observable, type OperatorFunction } from \"rxjs\";\n\nimport { LazyFilter, ReqPacket } from \"./packet.js\";\nimport type { Override } from \"./util.js\";\n\n/**\n * The RxReq interface that is provided for RxNostr (**not for users**).\n */\nexport interface RxReq<S extends RxReqStrategy = RxReqStrategy> {\n  /** @internal User should not use this directly.The RxReq strategy. It is read-only and must not change. */\n  get strategy(): S;\n  /** @internal User should not use this directly. Used to construct subId. */\n  get rxReqId(): string;\n  /** @internal User should not use this directly. Get an Observable of ReqPacket. */\n  getReqObservable(): Observable<ReqPacket>;\n}\n\n/**\n * REQ strategy.\n *\n * See comments on `createRxForwardReq()`, `createRxBackwardReq()` and `createRxOneshotReq()\n */", "export interface RxReq<S extends RxReqStrategy = RxReqStrategy> {\n  /** @internal User should not use this directly.The RxReq strategy. It is read-only and must not change. */\n  get strategy(): S;\n  /** @internal User should not use this directly. Used to construct subId. */\n  get rxReqId(): string;\n  /** @internal User should not use this directly. Get an Observable of ReqPacket. */\n  getReqObservable(): Observable<ReqPacket>;\n}\n\n/**\n * REQ strategy.\n *\n * See comments on `createRxForwardReq()`, `createRxBackwardReq()` and `createRxOneshotReq()\n */", "export type RxReqStrategy = \"forward\" | \"backward\" | \"oneshot\";\n\n/**\n * The RxReq interface that is provided for users (not for RxNostr).\n */\nexport interface RxReqController {\n  /** Start new REQ or stop REQ on the RxNostr with witch the RxReq is associated. */\n  emit(filters: LazyFilter | LazyFilter[] | null): void;\n\n  /**\n   * Returns itself overriding only `getReqObservable()`.\n   * It is useful for throttling and other control purposes.\n   */\n  pipe(): RxReq;\n  pipe(op1: OperatorFunction<ReqPacket, ReqPacket>): RxReq;\n  pipe<A>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, ReqPacket>\n  ): RxReq;\n  pipe<A, B>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, ReqPacket>\n  ): RxReq;\n  pipe<A, B, C>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, ReqPacket>\n  ): RxReq;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, ReqPacket>\n  ): RxReq;\n}\n", "abstract class RxReqBase implements RxReq {\n  protected filters$ = new BehaviorSubject<ReqPacket>(null);\n  private _rxReqId: string;\n\n  abstract get strategy(): RxReqStrategy;\n  get rxReqId() {\n    return this._rxReqId;\n  }\n\n  constructor(rxReqId?: string) {\n    this._rxReqId = rxReqId ?? getRandomDigitsString();\n  }\n\n  getReqObservable(): Observable<ReqPacket> {\n    return this.filters$.asObservable();\n  }\n\n  emit(filters: LazyFilter | LazyFilter[] | null) {\n    const normalized = normalizeFilters(filters);\n", "    if (normalized) {\n      this.filters$.next(normalized);\n    } else {\n      this.filters$.next(null);\n    }\n  }\n\n  pipe(): RxReq;\n  pipe(op1: OperatorFunction<ReqPacket, ReqPacket>): RxReq;\n  pipe<A>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, ReqPacket>\n  ): RxReq;\n  pipe<A, B>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, ReqPacket>\n  ): RxReq;\n  pipe<A, B, C>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, ReqPacket>\n  ): RxReq;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<ReqPacket, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, ReqPacket>\n  ): RxReq;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pipe(...operators: OperatorFunction<any, any>[]): RxReq {\n    const rxReqId = this.rxReqId;\n    const strategy = this.strategy;\n    return {\n      ...this,\n      get rxReqId() {\n        return rxReqId;\n      },\n      get strategy() {\n        return strategy;\n      },\n      getReqObservable: () =>\n        this.getReqObservable().pipe(...(operators as [])),\n    };\n  }\n}\n\n/**\n * Create a RxReq instance based on the backward strategy.\n * It is useful if you want to retrieve past events that have already been published.\n *\n * In backward strategy:\n * - All REQs have different subIds.\n * - All REQ-subscriptions keep alive until timeout or getting EOSE.\n * - In most cases, you should specify `until` or `limit` for filters.\n *\n * For more information, see [document](https://penpenpng.github.io/rx-nostr/docs/req-strategy.html#backward-strategy).\n */", "export function createRxBackwardReq(\n  subIdBase?: string\n): RxReq<\"backward\"> & RxReqController {\n  return new RxBackwardReq(subIdBase);\n}\n\nclass RxBackwardReq extends RxReqBase implements RxReqController {\n  constructor(rxReqId?: string) {\n    super(rxReqId);\n  }\n\n  override get strategy(): \"backward\" {\n    return \"backward\";\n  }\n}\n\n/**\n * Create a RxReq instance based on the forward strategy.\n * It is useful if you want to listen future events.\n *\n * In forward strategy:\n * - All REQs have the same subId.\n * - When a new REQ is issued, the old REQ is overwritten and terminated immediately.\n *   The latest REQ keeps alive until it is overwritten or explicitly terminated.\n * - In most cases, you should not specify `limit` for filters.\n *\n * For more information, see [document](https://penpenpng.github.io/rx-nostr/docs/req-strategy.html#forward-strategy).\n */", "export function createRxForwardReq(\n  subId?: string\n): RxReq<\"forward\"> & RxReqController {\n  return new RxForwardReq(subId);\n}\n\nclass RxForwardReq extends RxReqBase implements RxReqController {\n  constructor(rxReqId?: string) {\n    super(rxReqId);\n  }\n\n  override get strategy(): \"forward\" {\n    return \"forward\";\n  }\n}\n\n/**\n * Create a RxReq instance based on the oneshot strategy.\n * It is almost the same as backward strategy, however can publish only one REQ\n * and the Observable completes on EOSE.\n *\n * For more information, see [document](https://penpenpng.github.io/rx-nostr/docs/req-strategy.html#oneshot-strategy).\n */", "export function createRxOneshotReq(req: {\n  filters: LazyFilter | LazyFilter[];\n  subId?: string;\n}): RxReq<\"oneshot\"> {\n  return new RxOneshotReq(req);\n}\n\nclass RxOneshotReq extends RxReqBase {\n  constructor(req: { filters: LazyFilter | LazyFilter[]; subId?: string }) {\n    super(req?.subId);\n    this.emit(req.filters);\n  }\n\n  override get strategy(): \"oneshot\" {\n    return \"oneshot\";\n  }\n}\n", "export interface Mixin<R, T> {\n  (): ThisType<R> & T;\n}\n\n/** NOTE: unstable feature */\nexport function mixin<R extends object, T extends object>(\n  def: () => ThisType<R> & T\n): Mixin<R, T> {\n  return def;\n}\n\n/** NOTE: unstable feature */", "export function extend<B extends R, R extends object, T extends object>(\n  base: B,\n  mixin: Mixin<R, T>\n): Override<B, T> {\n  return Object.assign(base, mixin()) as Override<B, T>;\n}\n\nfunction getRandomDigitsString() {\n  return `${Math.floor(Math.random() * 1000000)}`;\n}\n", "function normalizeFilter(filter: LazyFilter): LazyFilter | null {\n  const res: LazyFilter = {};\n  const isTagName = (s: string): s is Nostr.TagName => /^#[a-zA-Z]$/.test(s);\n\n  for (const key of Object.keys(filter)) {\n    if (key === \"limit\" && (filter[key] ?? -1) >= 0) {\n      res[key] = filter[key];\n      continue;\n    }\n    if (key === \"since\" || key === \"until\") {\n      const f = filter[key];", "    if (key === \"since\" || key === \"until\") {\n      const f = filter[key];\n      if (typeof f !== \"number\" || (f ?? -1) >= 0) {\n        res[key] = f;\n        continue;\n      }\n    }\n    if (\n      (isTagName(key) || key === \"ids\" || key === \"authors\") &&\n      filter[key] !== undefined &&\n      (filter[key]?.length ?? -1) > 0\n    ) {\n      res[key] = filter[key];\n      continue;\n    }", "    if (\n      key === \"kinds\" &&\n      filter[key] !== undefined &&\n      (filter[key]?.length ?? -1) > 0\n    ) {\n      res[key] = filter[key];\n      continue;\n    }\n    if (key === \"search\" && filter[key] !== undefined) {\n      res[key] = filter[key];\n      continue;\n    }\n  }\n\n  const timeRangeIsValid =\n    typeof res.since !== \"number\" ||\n    typeof res.until !== \"number\" ||\n    res.since <= res.until;", "    if (key === \"search\" && filter[key] !== undefined) {\n      res[key] = filter[key];\n      continue;\n    }\n  }\n\n  const timeRangeIsValid =\n    typeof res.since !== \"number\" ||\n    typeof res.until !== \"number\" ||\n    res.since <= res.until;\n  if (!timeRangeIsValid) {\n    return null;\n  }\n", "  if (!timeRangeIsValid) {\n    return null;\n  }\n\n  if (Object.keys(res).length <= 0) {\n    return null;\n  }\n\n  return res;\n}\n", "function normalizeFilters(\n  filters: LazyFilter | LazyFilter[] | null\n): LazyFilter[] | null {\n  if (!filters) {\n    return null;\n  }\n  const normalized = (Array.isArray(filters) ? filters : [filters]).flatMap(\n    (e) => normalizeFilter(e) ?? []\n  );\n  return normalized.length > 0 ? normalized : null;\n}\n"]}
{"filename": "src/helper.ts", "chunked_list": ["/** Return a function that is lazily evaluated for since/until parameters of `LazyFilter`. */\nimport Nostr from \"nostr-typedef\";\n\nimport { LazyFilter } from \"./packet.js\";\n\nexport function now(): number {\n  return Math.floor(new Date().getTime() / 1000);\n}\n\nexport function evalFilters(\n  filters: LazyFilter | LazyFilter[]\n): Nostr.Filter[] {", "export function evalFilters(\n  filters: LazyFilter | LazyFilter[]\n): Nostr.Filter[] {\n  if (\"length\" in filters) {\n    return filters.map(evalFilter);\n  } else {\n    return [evalFilter(filters)];\n  }\n}\n\nfunction evalFilter(filter: LazyFilter): Nostr.Filter {\n  return {\n    ...filter,\n    since: filter.since ? evalLazyNumber(filter.since) : undefined,\n    until: filter.until ? evalLazyNumber(filter.until) : undefined,\n  };\n}\n", "function evalFilter(filter: LazyFilter): Nostr.Filter {\n  return {\n    ...filter,\n    since: filter.since ? evalLazyNumber(filter.since) : undefined,\n    until: filter.until ? evalLazyNumber(filter.until) : undefined,\n  };\n}\n\nfunction evalLazyNumber(lazyNumber: number | (() => number)): number {\n  return typeof lazyNumber === \"number\" ? lazyNumber : lazyNumber();\n}\n", "function evalLazyNumber(lazyNumber: number | (() => number)): number {\n  return typeof lazyNumber === \"number\" ? lazyNumber : lazyNumber();\n}\n"]}
{"filename": "src/connection.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\nimport {\n  EMPTY,\n  filter,\n  identity,\n  mergeMap,\n  type MonoTypeOperatorFunction,\n  Observable,\n  type ObservableInput,\n  of,\n  retry,\n  Subject,\n  tap,\n  timer,\n} from \"rxjs\";\n\nimport { evalFilters } from \"./helper.js\";\nimport { fetchRelayInfo } from \"./index.js\";\nimport { isFiltered } from \"./nostr/filter.js\";\nimport { ConnectionState, LazyREQ, MessagePacket } from \"./packet.js\";\n", "  type ObservableInput,\n  of,\n  retry,\n  Subject,\n  tap,\n  timer,\n} from \"rxjs\";\n\nimport { evalFilters } from \"./helper.js\";\nimport { fetchRelayInfo } from \"./index.js\";\nimport { isFiltered } from \"./nostr/filter.js\";\nimport { ConnectionState, LazyREQ, MessagePacket } from \"./packet.js\";\n", "export class Connection {\n  private socket: WebSocket | null = null;\n  private message$ = new Subject<MessagePacket | WebSocketError>();\n  private error$ = new Subject<unknown>();\n  private connectionState$ = new Subject<ConnectionState>();\n  private connectionState: ConnectionState = \"not-started\";\n  private queuedEvents: Nostr.ToRelayMessage.EVENT[] = [];\n  private reqs: Map<string /* subId */, ReqState> = new Map();\n  private serverLimitations: Nostr.Nip11.ServerLimitations | null = null;\n  private canRetry = false;\n\n  get read() {\n    return this.config.read;\n  }\n  set read(v) {\n    this.config.read = v;\n  }\n  get write() {\n    return this.config.write;\n  }\n  set write(v) {\n    this.config.write = v;\n  }\n  get maxConcurrentReqs(): number | null {\n    return (\n      this.serverLimitations?.max_subscriptions ??\n      this.config.maxConcurrentReqsFallback ??\n      null\n    );\n  }\n\n  constructor(public url: string, private config: ConnectionConfig) {\n    this.connectionState$.next(\"not-started\");\n  }\n\n  private setConnectionState(state: ConnectionState) {", "    if (this.connectionState === \"terminated\") {\n      return;\n    }\n\n    this.connectionState = state;\n    this.connectionState$.next(state);\n  }\n\n  private async fetchServerLimitationsIfNeeded() {\n    if (\n      this.config.disableAutoFetchNip11Limitations ||\n      this.serverLimitations\n    ) {\n      return;\n    }", "    if (\n      this.config.disableAutoFetchNip11Limitations ||\n      this.serverLimitations\n    ) {\n      return;\n    }\n    try {\n      const info = await fetchRelayInfo(this.url);\n      this.serverLimitations = info.limitation ?? null;\n    } catch {\n      // do nothing\n    }\n  }\n\n  async start() {", "    if (\n      !this.canRetry &&\n      (this.connectionState === \"reconnecting\" ||\n        this.connectionState === \"starting\" ||\n        this.connectionState === \"ongoing\")\n    ) {\n      return Promise.resolve();\n    }\n    this.canRetry = false;\n\n    if (this.connectionState === \"not-started\") {\n      this.setConnectionState(\"starting\");\n    } else {\n      this.setConnectionState(\"reconnecting\");\n    }\n\n    await this.fetchServerLimitationsIfNeeded();\n\n    let completeStartingProcess: () => void;\n    const succeededOrFailed = new Promise<void>((_resolve) => {\n      completeStartingProcess = _resolve;\n    });\n\n    const onopen = () => {\n      this.setConnectionState(\"ongoing\");\n      completeStartingProcess();", "    if (this.connectionState === \"not-started\") {\n      this.setConnectionState(\"starting\");\n    } else {\n      this.setConnectionState(\"reconnecting\");\n    }\n\n    await this.fetchServerLimitationsIfNeeded();\n\n    let completeStartingProcess: () => void;\n    const succeededOrFailed = new Promise<void>((_resolve) => {\n      completeStartingProcess = _resolve;\n    });\n\n    const onopen = () => {\n      this.setConnectionState(\"ongoing\");\n      completeStartingProcess();", "      for (const event of this.queuedEvents) {\n        this.sendEVENT(event);\n      }\n      this.queuedEvents = [];\n\n      this.ensureReqs();\n    };\n    const onmessage = ({ data }: MessageEvent) => {\n      if (this.connectionState === \"terminated\") {\n        return;\n      }", "      if (this.connectionState === \"terminated\") {\n        return;\n      }\n      try {\n        this.message$.next({ from: this.url, message: JSON.parse(data) });\n      } catch (err) {\n        this.error$.next(err);\n      }\n    };\n    const onerror = () => {\n      completeStartingProcess();\n    };\n    const onclose = ({ code }: CloseEvent) => {", "      if (\n        code === WebSocketCloseCode.DISPOSED_BY_RX_NOSTR ||\n        this.connectionState === \"terminated\"\n      ) {\n        return;\n      }\n\n      websocket.removeEventListener(\"open\", onopen);\n      websocket.removeEventListener(\"message\", onmessage);\n      websocket.removeEventListener(\"error\", onerror);\n      websocket.removeEventListener(\"close\", onclose);\n      websocket.close();\n      this.socket = null;\n", "      for (const req of this.reqs.values()) {\n        req.isOngoing = false;\n      }\n\n      if (code === WebSocketCloseCode.DESIRED_BY_RX_NOSTR) {\n        this.setConnectionState(\"not-started\");\n      } else if (code === WebSocketCloseCode.DONT_RETRY) {\n        this.setConnectionState(\"rejected\");\n        this.message$.next(new WebSocketError(code));\n        completeStartingProcess();\n      } else {\n        this.canRetry = true;\n        this.message$.next(new WebSocketError(code));\n        completeStartingProcess();\n      }\n    };\n", "    if (this.connectionState === \"terminated\") {\n      return Promise.resolve();\n    }\n    const websocket = new WebSocket(this.url);\n\n    websocket.addEventListener(\"open\", onopen);\n    websocket.addEventListener(\"message\", onmessage);\n    websocket.addEventListener(\"error\", onerror);\n    websocket.addEventListener(\"close\", onclose);\n\n    this.socket = websocket;\n\n    return succeededOrFailed;\n  }\n\n  stop() {\n    this.finalizeAllReqs();\n    this.socket?.close(WebSocketCloseCode.DESIRED_BY_RX_NOSTR);\n  }\n\n  getConnectionState() {\n    return this.connectionState;\n  }\n\n  getMessageObservable(): Observable<MessagePacket> {\n    const reqs = this.reqs;\n\n    return this.message$.asObservable().pipe(\n      mergeMap((data) => {", "        if (data instanceof WebSocketError) {\n          if (data.code === WebSocketCloseCode.DONT_RETRY) {\n            return EMPTY;\n          } else {\n            throw data;\n          }\n        } else {\n          return of(data);\n        }\n      }),\n      tap({\n        subscribe: () => {\n          this.start();\n        },\n      }),\n      this.config.backoff.strategy === \"off\"\n        ? identity\n        : retry({\n            delay: (_, retryCount) =>\n              backoffSignal(this.config.backoff, retryCount),\n            count: this.config.backoff.maxCount,\n          }),\n      tap({\n        error: () => {\n          this.setConnectionState(\"error\");\n        },\n      }),\n      rejectFilterUnmatchEvents()\n    );\n", "    function rejectFilterUnmatchEvents(): MonoTypeOperatorFunction<MessagePacket> {\n      return filter((packet) => {\n        const [type, subId, event] = packet.message;\n\n        if (type !== \"EVENT\") {\n          return true;\n        }\n\n        const req = reqs.get(subId);\n        if (!req) {\n          return true;\n        }\n\n        const [, , ...filters] = req.actual;\n\n        return isFiltered(event, filters);\n      });\n    }\n  }\n\n  getConnectionStateObservable() {\n    return this.connectionState$.asObservable();\n  }\n\n  getErrorObservable() {\n    return this.error$.asObservable();\n  }\n\n  ensureReq(req: LazyREQ, options?: { overwrite?: boolean }) {\n    const subId = req[1];\n", "        if (!req) {\n          return true;\n        }\n\n        const [, , ...filters] = req.actual;\n\n        return isFiltered(event, filters);\n      });\n    }\n  }\n\n  getConnectionStateObservable() {\n    return this.connectionState$.asObservable();\n  }\n\n  getErrorObservable() {\n    return this.error$.asObservable();\n  }\n\n  ensureReq(req: LazyREQ, options?: { overwrite?: boolean }) {\n    const subId = req[1];\n", "    if (this.connectionState === \"terminated\") {\n      return;\n    }\n    if (!this.read) {\n      // REQ is not allowed.\n      return;\n    }\n    if (!options?.overwrite) {\n      if (this.reqs.get(subId)?.isOngoing) {\n        // REQ is already ongoing\n        return;\n      }", "      if (this.reqs.get(subId)?.isOngoing) {\n        // REQ is already ongoing\n        return;\n      }\n      if (\n        this.reqs.has(subId) &&\n        !isConcurrentAllowed(subId, this.reqs, this.maxConcurrentReqs)\n      ) {\n        // REQ is already queued\n        return;\n      }\n    }\n\n    const message = evalREQ(req);\n\n    // enqueue or overwrite\n    this.reqs.set(subId, {\n      original: req,\n      actual: message,\n      isOngoing: false,\n    });\n", "    if (isConcurrentAllowed(subId, this.reqs, this.maxConcurrentReqs)) {\n      const req = this.reqs.get(subId);\n      if (req && this.socket?.readyState === WebSocket.OPEN) {\n        req.isOngoing = true;\n        this.socket.send(JSON.stringify(message));\n      }\n    }\n  }\n\n  private ensureReqs() {\n    const reqs = Array.from(this.reqs.values()).slice(\n      0,\n      this.maxConcurrentReqs ?? undefined\n    );", "    for (const req of reqs) {\n      this.ensureReq(req.original);\n    }\n  }\n\n  finalizeReq(subId: string) {\n    if (this.connectionState === \"terminated\") {\n      return;\n    }\n\n    const req = this.reqs.get(subId);", "    if (!req) {\n      return;\n    }\n\n    this.reqs.delete(subId);\n\n    if (req.isOngoing) {\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        const message: Nostr.ToRelayMessage.CLOSE = [\"CLOSE\", subId];\n        this.socket.send(JSON.stringify(message));\n      }\n\n      this.ensureReqs();\n    }\n  }\n\n  private finalizeAllReqs() {", "    if (this.connectionState === \"terminated\") {\n      return;\n    }\n\n    for (const subId of this.reqs.keys()) {\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        const message: Nostr.ToRelayMessage.CLOSE = [\"CLOSE\", subId];\n        this.socket.send(JSON.stringify(message));\n      }\n    }\n\n    this.reqs.clear();\n  }\n\n  sendEVENT(message: Nostr.ToRelayMessage.EVENT) {", "    if (this.connectionState === \"terminated\") {\n      return;\n    }\n    if (!this.write) {\n      return;\n    }\n\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(message));\n    } else {\n      if (this.socket?.readyState === WebSocket.CONNECTING) {\n        // Enqueue\n        this.queuedEvents.push(message);\n      } else {\n        // Create a temporary socket to send message.\n        const socket = new WebSocket(this.url);\n        socket.addEventListener(\"open\", () => {\n          socket.send(JSON.stringify(message));\n        });\n\n        // Close the temporary socket after receiveing OK or timed out.\n        socket.addEventListener(\"message\", ({ data }) => {", "      if (this.socket?.readyState === WebSocket.CONNECTING) {\n        // Enqueue\n        this.queuedEvents.push(message);\n      } else {\n        // Create a temporary socket to send message.\n        const socket = new WebSocket(this.url);\n        socket.addEventListener(\"open\", () => {\n          socket.send(JSON.stringify(message));\n        });\n\n        // Close the temporary socket after receiveing OK or timed out.\n        socket.addEventListener(\"message\", ({ data }) => {", "          try {\n            const response: Nostr.ToClientMessage.Any = JSON.parse(data);\n            if (response[0] === \"OK\") {\n              socket.close();\n            }\n            this.message$.next({ from: this.url, message: response });\n          } catch (err) {\n            this.message$.error(err);\n          }\n        });\n        setTimeout(() => {", "          if (\n            socket.readyState === WebSocket.OPEN ||\n            socket.readyState === WebSocket.CONNECTING\n          ) {\n            socket.close();\n          }\n        }, 10 * 1000);\n      }\n    }\n  }\n\n  dispose() {\n    this.finalizeAllReqs();\n    this.setConnectionState(\"terminated\");\n\n    this.socket?.close(WebSocketCloseCode.DISPOSED_BY_RX_NOSTR);\n    this.socket = null;\n\n    this.reqs.clear();\n\n    this.message$.complete();\n    this.message$.unsubscribe();\n    this.connectionState$.complete();\n    this.connectionState$.unsubscribe();\n    this.error$.complete();\n    this.error$.unsubscribe();\n  }\n}\n\nexport const WebSocketCloseCode = {\n  /**\n   * 1006 is a reserved value and MUST NOT be set as a status code in a\n   * Close control frame by an endpoint.  It is designated for use in\n   * applications expecting a status code to indicate that the\n   * connection was closed abnormally, e.g., without sending or\n   * receiving a Close control frame.\n   *\n   * See also: https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n   */\n  ABNORMAL_CLOSURE: 1006,\n  /**\n   * When a websocket is closed by the relay with a status code 4000\n   * that means the client shouldn't try to connect again.\n   *\n   * See also: https://github.com/nostr-protocol/nips/blob/fab6a21a779460f696f11169ddf343b437327592/01.md?plain=1#L113\n   */\n  DONT_RETRY: 4000,\n  /** @internal rx-nostr uses it internally. */\n  DESIRED_BY_RX_NOSTR: 4537,\n  /** @internal rx-nostr uses it internally. */\n  DISPOSED_BY_RX_NOSTR: 4538,\n} as const;\n", "export interface ConnectionConfig {\n  backoff: BackoffConfig;\n  read: boolean;\n  write: boolean;\n  disableAutoFetchNip11Limitations?: boolean;\n  maxConcurrentReqsFallback?: number;\n}\n\nexport type BackoffConfig =\n  | {\n      // Exponential backoff and jitter strategy\n      strategy: \"exponential\";\n      maxCount: number;\n      initialDelay: number;\n    }\n  | {\n      // Retry at regular intervals\n      strategy: \"linear\";\n      maxCount: number;\n      interval: number;\n    }\n  | {\n      // Retry immediately\n      strategy: \"immediately\";\n      maxCount: number;\n    }\n  | {\n      // Won't retry\n      strategy: \"off\";\n    };\n", "export type BackoffConfig =\n  | {\n      // Exponential backoff and jitter strategy\n      strategy: \"exponential\";\n      maxCount: number;\n      initialDelay: number;\n    }\n  | {\n      // Retry at regular intervals\n      strategy: \"linear\";\n      maxCount: number;\n      interval: number;\n    }\n  | {\n      // Retry immediately\n      strategy: \"immediately\";\n      maxCount: number;\n    }\n  | {\n      // Won't retry\n      strategy: \"off\";\n    };\n", "interface ReqState {\n  original: LazyREQ;\n  actual: Nostr.ToRelayMessage.REQ;\n  isOngoing: boolean;\n}\n\nfunction backoffSignal(\n  config: BackoffConfig,\n  count: number\n): ObservableInput<unknown> {\n  if (config.strategy === \"exponential\") {\n    const time = Math.max(\n      config.initialDelay * 2 ** (count - 1) + (Math.random() - 0.5) * 1000,\n      1000\n    );\n    return timer(time);", "  if (config.strategy === \"exponential\") {\n    const time = Math.max(\n      config.initialDelay * 2 ** (count - 1) + (Math.random() - 0.5) * 1000,\n      1000\n    );\n    return timer(time);\n  } else if (config.strategy === \"linear\") {\n    return timer(config.interval);\n  } else if (config.strategy === \"immediately\") {\n    return of(0);\n  } else {\n    return EMPTY;\n  }\n}\n", "  } else if (config.strategy === \"immediately\") {\n    return of(0);\n  } else {\n    return EMPTY;\n  }\n}\n\nfunction evalREQ([type, subId, ...filters]: LazyREQ): Nostr.ToRelayMessage.REQ {\n  return [type, subId, ...evalFilters(filters)];\n}\n", "function isConcurrentAllowed(\n  subId: string,\n  reqs: Map<string, ReqState>,\n  concurrent: number | null\n): boolean {\n  if (concurrent === null) {\n    return true;\n  }\n\n  const reqOrdinal = Array.from(reqs.keys()).findIndex((e) => e === subId);\n", "  if (reqOrdinal === undefined) {\n    return false;\n  }\n\n  return reqOrdinal < concurrent;\n}\n\nclass WebSocketError extends Error {\n  constructor(public code?: number) {\n    super(`WebSocket Error: Socket was closed with code ${code}`);\n  }\n}\n"]}
{"filename": "src/packet.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\n// Packet is data treated by rx-nostr Observables.\n\n/**\n * Packets flowing through the Observable stream sent from RxReq towards RxNostr.\n * When null is sent, the subscription is suspended.\n */\nexport type ReqPacket = LazyFilter[] | null;\n\n/**\n * Filter object, but allows parameters since/until to be function.\n * If so, values will be evaluated just before submission.\n */", "export type ReqPacket = LazyFilter[] | null;\n\n/**\n * Filter object, but allows parameters since/until to be function.\n * If so, values will be evaluated just before submission.\n */\nexport type LazyFilter = Omit<Nostr.Filter, \"since\" | \"until\"> & {\n  since?: number | (() => number);\n  until?: number | (() => number);\n};\n", "export type LazyREQ = [\"REQ\", string, ...LazyFilter[]];\n\n/**\n * Packets from websocket that represents an EVENT.\n */\nexport interface EventPacket {\n  from: string;\n  subId: string;\n  event: Nostr.Event;\n}\n\n/**\n * Packets from websocket that represents an error.\n */", "export interface ErrorPacket {\n  from: string;\n  reason: unknown;\n}\n\n/**\n * Packets from websocket that represents all raw incoming messages.\n */\nexport interface MessagePacket<\n  M extends Nostr.ToClientMessage.Any = Nostr.ToClientMessage.Any\n> {\n  from: string;\n  message: M;\n}\n\n/**\n * Packets emitted when WebSocket connection state is changed.\n */", "export interface MessagePacket<\n  M extends Nostr.ToClientMessage.Any = Nostr.ToClientMessage.Any\n> {\n  from: string;\n  message: M;\n}\n\n/**\n * Packets emitted when WebSocket connection state is changed.\n */\nexport interface ConnectionStatePacket {\n  from: string;\n  state: ConnectionState;\n}\n\n/**\n * WebSocket connection state.\n *\n * - `not-started`: Not started yet, or closed by expected ways.\n * - `starting`: Attempting to connect (for reasons other than error recovery).\n * - `ongoing`: Active, but may be temporarily closed as idling.\n * - `reconnecting`: Trying to reconnect for error recovery.\n * - `error`: Inactive because of an unexpected error. You can try to recover by reconnect()\n * - `rejected`: Inactive because of closing code 4000. You can try to reconnect, but should not do.\n * - `terminated`: No longer available because of dispose()\n */", "export interface ConnectionStatePacket {\n  from: string;\n  state: ConnectionState;\n}\n\n/**\n * WebSocket connection state.\n *\n * - `not-started`: Not started yet, or closed by expected ways.\n * - `starting`: Attempting to connect (for reasons other than error recovery).\n * - `ongoing`: Active, but may be temporarily closed as idling.\n * - `reconnecting`: Trying to reconnect for error recovery.\n * - `error`: Inactive because of an unexpected error. You can try to recover by reconnect()\n * - `rejected`: Inactive because of closing code 4000. You can try to reconnect, but should not do.\n * - `terminated`: No longer available because of dispose()\n */", "export type ConnectionState =\n  | \"not-started\"\n  | \"starting\"\n  | \"ongoing\"\n  | \"reconnecting\"\n  | \"error\"\n  | \"rejected\"\n  | \"terminated\";\n\n/**\n * Packets represents OK messages associated with an EVENT submission.\n */", "export interface OkPacket {\n  from: string;\n  id: string;\n  ok: boolean;\n}\n"]}
{"filename": "src/rx-nostr.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\nimport {\n  catchError,\n  EMPTY,\n  filter,\n  finalize,\n  first,\n  identity,\n  map,\n  merge,", "  map,\n  merge,\n  mergeAll,\n  mergeMap,\n  type MonoTypeOperatorFunction,\n  Observable,\n  of,\n  type OperatorFunction,\n  ReplaySubject,\n  Subject,\n  Subscription,\n  take,\n  takeUntil,\n  tap,\n  timeout,", "  type Unsubscribable,\n} from \"rxjs\";\n\nimport { BackoffConfig, Connection } from \"./connection.js\";\nimport { getSignedEvent } from \"./nostr/event.js\";\nimport { fetchRelayInfo } from \"./nostr/nip11.js\";\nimport { completeOnTimeout } from \"./operator.js\";\nimport type {\n  ConnectionState,\n  ConnectionStatePacket,\n  ErrorPacket,\n  EventPacket,\n  LazyFilter,\n  LazyREQ,\n  MessagePacket,\n  OkPacket,\n} from \"./packet.js\";\nimport type { RxReq } from \"./req.js\";\nimport { defineDefaultOptions, normalizeRelayUrl } from \"./util.js\";\n\n/**\n * The core object of rx-nostr, which holds a connection to relays\n * and manages subscriptions as directed by the RxReq object connected by `use()`.\n * Use `createRxNostr()` to get the object.\n */", "export interface RxNostr {\n  /**\n   * Return a list of relays used by this object.\n   * The relay URLs are normalised so may not match the URLs set.\n   */\n  getRelays(): RelayConfig[];\n\n  /**\n   * Set the list of relays.\n   * If a REQ subscription already exists, the same REQ is issued for the newly added relay\n   * and CLOSE is sent for the removed relay.\n   */\n  switchRelays(config: AcceptableRelaysConfig): Promise<void>;\n  /** Utility wrapper for `switchRelays()`. */\n  addRelay(relay: string | RelayConfig): Promise<void>;\n  /** Utility wrapper for `switchRelays()`. */\n  removeRelay(url: string): Promise<void>;\n\n  /** Return true if the given relay is set to rxNostr. */\n  hasRelay(url: string): boolean;\n  /** Return true if the given relay allows to be written. */\n  canWriteRelay(url: string): boolean;\n  /** Return true if the given relay allows to be read. */\n  canReadRelay(url: string): boolean;\n\n  /** Fetch all relays' info based on [NIP-11](https://github.com/nostr-protocol/nips/blob/master/11.md) */\n  fetchAllRelaysInfo(): Promise<Record<string, Nostr.Nip11.RelayInfo | null>>;\n\n  /**\n   * Return a dictionary in which you can look up connection state.\n   *\n   * **NOTE**: Keys are **normalized** URL, so may be different from one you set.\n   */\n  getAllRelayState(): Record<string, ConnectionState>;\n  /**\n   * Return connection state of the given relay.\n   * Throw if unknown URL is given.\n   */\n  getRelayState(url: string): ConnectionState;\n  /**\n   * Attempt to reconnect the WebSocket if its state is `error` or `rejected`.\n   * If not, do nothing.\n   */\n  reconnect(url: string): void;\n\n  // TODO: document\n  /**\n   * Set or unset a pipe to be applied to all EventPackets.\n   */\n  setGlobalEventPacketPipe(\n    pipe: MonoTypeOperatorFunction<EventPacket> | null\n  ): void;\n\n  /**\n   * Associate RxReq with RxNostr.\n   * When the associated RxReq is manipulated,\n   * the RxNostr issues a new REQ to all relays allowed to be read.\n   * The method returns an Observable that issues EventPackets\n   * when an EVENT is received that is subscribed by RxReq.\n   * You can unsubscribe the Observable to CLOSE.\n   */\n  use(\n    rxReq: RxReq,\n    options?: Partial<RxNostrUseOptions>\n  ): Observable<EventPacket>;\n  /**\n   * Create an Observable that receives all events (EVENT) from all websocket connections.\n   *\n   * Nothing happens when this Observable is unsubscribed.\n   * */\n  createAllEventObservable(): Observable<EventPacket>;\n  /**\n   * Create an Observable that receives all errors from all websocket connections.\n   * Note that an Observable is terminated when it receives any error,\n   * so this method is the only way to receive errors arising from multiplexed websocket connections\n   * (It means that Observables returned by `use()` never throw error).\n   *\n   * Nothing happens when this Observable is unsubscribed.\n   * */\n  createAllErrorObservable(): Observable<ErrorPacket>;\n  /**\n   * Create an Observable that receives all messages from all websocket connections.\n   *\n   * Nothing happens when this Observable is unsubscribed.\n   * */\n  createAllMessageObservable(): Observable<MessagePacket>;\n  /**\n   * Create an Observable that receives changing of WebSocket connection state.\n   *\n   * Nothing happens when this Observable is unsubscribed.\n   */\n  createConnectionStateObservable(): Observable<ConnectionStatePacket>;\n\n  /**\n   * Attempt to send events to all relays that are allowed to write.\n   * The `seckey` option accepts both nsec format and hex format,\n   * and if omitted NIP-07 will be automatically used.\n   */\n  send(\n    params: Nostr.EventParameters,\n    options?: RxNostrSendOptions\n  ): Observable<OkPacket>;\n\n  /**\n   * Release all resources held by the RxNostr object.\n   * Any Observable resulting from this RxNostr will be in the completed state\n   * and will never receive messages again.\n   * RxReq used by this object is not affected; in other words, if the RxReq is used\n   * by another RxNostr, its use is not prevented.\n   */\n  dispose(): void;\n}\n\n/** Create a RxNostr object. This is the only way to create that. */", "export function createRxNostr(options?: Partial<RxNostrOptions>): RxNostr {\n  return new RxNostrImpl(options);\n}\n\nexport interface RxNostrOptions {\n  /** Auto reconnection strategy. */\n  retry: BackoffConfig;\n  /**\n   * The time in milliseconds to timeout when following the backward strategy.\n   * The observable is terminated when the specified amount of time has elapsed\n   * during which no new events are available.\n   */\n  timeout: number;\n  globalRelayConfig?: {\n    disableAutoFetchNip11Limitations?: boolean;\n    maxConcurrentReqsFallback?: number;\n  };\n}\nconst makeRxNostrOptions = defineDefaultOptions<RxNostrOptions>({\n  retry: {\n    strategy: \"exponential\",\n    maxCount: 5,\n    initialDelay: 1000,\n  },\n  timeout: 10000,\n  globalRelayConfig: undefined,\n});\n", "export interface RxNostrUseOptions {\n  scope?: string[];\n}\nconst makeRxNostrUseOptions = defineDefaultOptions<RxNostrUseOptions>({\n  scope: undefined,\n});\n\nexport interface RxNostrSendOptions {\n  scope?: string[];\n  seckey?: string;\n}\nconst makeRxNostrSendOptions = defineDefaultOptions<RxNostrSendOptions>({\n  scope: undefined,\n  seckey: undefined,\n});\n\n/** Config object specifying WebSocket behavior. */", "export interface RelayConfig {\n  /** WebSocket endpoint URL. */\n  url: string;\n  /** If true, rxNostr can publish REQ and subscribe EVENTs. */\n  read: boolean;\n  /** If true, rxNostr can send EVENTs. */\n  write: boolean;\n  disableAutoFetchNip11Limitations?: boolean;\n}\n\n/** Parameter of `rxNostr.switchRelays()` */", "export type AcceptableRelaysConfig =\n  | (string | RelayConfig)[]\n  | Nostr.Nip07.GetRelayResult;\n\nclass RxNostrImpl implements RxNostr {\n  private options: RxNostrOptions;\n  private connections: Map<string, Connection> = new Map();\n  private ongoings: Map<string, OngoingReq> = new Map();\n  private messageIn$: Subject<MessagePacket> = new Subject();\n  private error$: Subject<ErrorPacket> = new Subject();\n  private status$: Subject<ConnectionStatePacket> = new Subject();\n  private globalEventPacketPipe: MonoTypeOperatorFunction<EventPacket> | null =\n    null;\n  private disposed = false;\n\n  private get messageOut$() {\n    return this.messageIn$.pipe(\n      mergeMap((packet) => {\n        const pipe = this.globalEventPacketPipe;\n", "        if (!pipe) {\n          return of(packet);\n        }\n\n        const message = packet.message;\n        if (message[0] !== \"EVENT\") {\n          return of(packet);\n        }\n\n        return of({\n          from: packet.from,\n          subId: message[1],\n          event: message[2],\n        }).pipe(\n          pipe,\n          map(\n            ({ from, subId, event }): MessagePacket => ({\n              from,\n              message: [\"EVENT\", subId, event],\n            })\n          )\n        );\n      })\n    );\n  }\n\n  constructor(options?: Partial<RxNostrOptions>) {\n    const opt = makeRxNostrOptions(options);\n    this.options = {\n      ...opt,\n    };\n  }\n\n  getRelays(): RelayConfig[] {\n    return Array.from(this.connections.values()).map(\n      ({ url, read, write }) => ({\n        url,\n        read,\n        write,\n      })\n    );\n  }\n\n  private createConnection({\n    url,\n    read,\n    write,\n    disableAutoFetchNip11Limitations,\n  }: RelayConfig): Connection {\n    const connection = new Connection(url, {\n      backoff: this.options.retry,\n      read,\n      write,\n      disableAutoFetchNip11Limitations:\n        disableAutoFetchNip11Limitations ??\n        this.options.globalRelayConfig?.disableAutoFetchNip11Limitations,\n      maxConcurrentReqsFallback:\n        this.options.globalRelayConfig?.maxConcurrentReqsFallback,\n    });\n\n    connection.getConnectionStateObservable().subscribe((state) => {\n      this.status$.next({\n        from: url,\n        state,\n      });\n    });\n    connection.getErrorObservable().subscribe((reason) => {\n      this.error$.next({ from: url, reason });\n    });\n    connection\n      .getMessageObservable()\n      .pipe(\n        catchError((reason: unknown) => {\n          this.error$.next({ from: url, reason });\n          return EMPTY;\n        })\n      )\n      .subscribe((v) => {\n        this.messageIn$.next(v);\n      });\n\n    return connection;\n  }\n\n  async switchRelays(config: AcceptableRelaysConfig): Promise<void> {\n    const nextConns: Map<string, Connection> = new Map();", "    for (const { url, read, write } of normalizeRelaysConfig(config)) {\n      // pop a connection if exists\n      const prevConn = this.connections.get(url);\n      this.connections.delete(url);\n\n      if (prevConn) {\n        prevConn.read = read;\n        prevConn.write = write;\n        nextConns.set(url, prevConn);\n      } else {\n        nextConns.set(url, this.createConnection({ url, read, write }));\n      }\n    }\n\n    // connections that are no longer used", "    for (const conn of this.connections.values()) {\n      conn.dispose();\n    }\n\n    const ensureConns: Promise<unknown>[] = [];\n    for (const conn of nextConns.values()) {\n      if (conn.read) {\n        ensureConns.push(conn.start());\n      } else {\n        conn.stop();\n      }\n    }\n\n    await Promise.all(ensureConns);\n\n    this.connections = nextConns;\n    // If disposed during switchRelay processing", "    if (this.disposed) {\n      for (const conn of this.connections.values()) {\n        conn.dispose();\n      }\n      return;\n    }\n\n    for (const { req, scope } of this.ongoings.values()) {\n      this.ensureReq(req, { scope });\n    }\n\n    // --- scoped untility pure functions ---", "    function normalizeRelaysConfig(\n      config: AcceptableRelaysConfig\n    ): RelayConfig[] {\n      if (Array.isArray(config)) {\n        return config.map((urlOrConfig) => {\n          const relay: RelayConfig =\n            typeof urlOrConfig === \"string\"\n              ? {\n                  url: urlOrConfig,\n                  read: true,\n                  write: true,\n                }\n              : urlOrConfig;\n          relay.url = normalizeRelayUrl(relay.url);\n\n          return relay;\n        });\n      } else {\n        return Object.entries(config).map(([url, flags]) => ({\n          url: normalizeRelayUrl(url),\n          ...flags,\n        }));\n      }\n    }\n  }\n  async addRelay(relay: string | RelayConfig): Promise<void> {\n    await this.switchRelays([...this.getRelays(), relay]);\n  }\n  async removeRelay(url: string): Promise<void> {\n    const u = normalizeRelayUrl(url);\n    const currentRelays = this.getRelays();\n    const nextRelays = currentRelays.filter((relay) => relay.url !== u);", "    if (currentRelays.length !== nextRelays.length) {\n      await this.switchRelays(nextRelays);\n    }\n  }\n  hasRelay(url: string): boolean {\n    const u = normalizeRelayUrl(url);\n    return this.getRelays().some((relay) => relay.url === u);\n  }\n  canWriteRelay(url: string): boolean {\n    const u = normalizeRelayUrl(url);\n    return this.getRelays().some((relay) => relay.url === u && relay.write);\n  }\n  canReadRelay(url: string): boolean {\n    const u = normalizeRelayUrl(url);\n    return this.getRelays().some((relay) => relay.url === u && relay.read);\n  }\n\n  async fetchAllRelaysInfo(): Promise<\n    Record<string, Nostr.Nip11.RelayInfo | null>\n  > {\n    const entries = await Promise.all(\n      Array.from(this.connections.keys()).map(\n        async (url): Promise<[string, Nostr.Nip11.RelayInfo | null]> => [\n          url,", "          await fetchRelayInfo(url).catch(() => null),\n        ]\n      )\n    );\n    return Object.fromEntries(entries);\n  }\n\n  getAllRelayState(): Record<string, ConnectionState> {\n    return Object.fromEntries(\n      Array.from(this.connections.values()).map((e) => [\n        e.url,\n        this.getRelayState(e.url),\n      ])\n    );\n  }\n  getRelayState(url: string): ConnectionState {\n    const conn = this.connections.get(normalizeRelayUrl(url));", "    if (!conn) {\n      throw new Error(\"RelayConfig not found\");\n    }\n    // this.relays[url] may be set before this.relays[url].websocket is initialized\n    return conn?.getConnectionState() ?? \"not-started\";\n  }\n  reconnect(url: string): void {\n    if (this.canReadRelay(url)) {\n      this.connections.get(normalizeRelayUrl(url))?.start();\n    }\n  }\n\n  setGlobalEventPacketPipe(pipe: MonoTypeOperatorFunction<EventPacket> | null) {\n    this.globalEventPacketPipe = pipe;\n  }\n\n  use(\n    rxReq: RxReq,\n    options?: Partial<RxNostrUseOptions>\n  ): Observable<EventPacket> {\n    const { scope: _scope } = makeRxNostrUseOptions(options);\n    const scope = _scope?.map(normalizeRelayUrl);\n\n    const TIMEOUT = this.options.timeout;\n    const strategy = rxReq.strategy;\n    const rxReqId = rxReq.rxReqId;\n    const message$ = this.messageOut$;\n    const ongoings = this.ongoings;\n\n    const getAllRelayState = this.getAllRelayState.bind(this);\n    const createConnectionStateObservable =\n      this.createConnectionStateObservable.bind(this);\n    const ensureReq = this.ensureReq.bind(this);\n    const finalizeReq = this.finalizeReq.bind(this);\n\n    const subId$ = rxReq.getReqObservable().pipe(\n      filter((filters): filters is LazyFilter[] => filters !== null),\n      strategy === \"oneshot\" ? first() : identity,\n      attachSubId(),\n      strategy === \"forward\" ? manageActiveForwardReq() : identity,\n      tap((req) => {\n        ensureReq(req, { overwrite: strategy === \"forward\", scope });\n      }),\n      map(([, subId]) => subId)\n    );\n", "    if (strategy === \"forward\") {\n      const subId = makeSubId({\n        rxReqId,\n      });\n\n      const resource: Unsubscribable[] = [];\n      const subject = new Subject<EventPacket>();\n      resource.push(subject);\n\n      return subject.pipe(\n        tap({\n          subscribe: () => {\n            resource.push(subId$.subscribe());\n            resource.push(\n              message$\n                .pipe(filterBySubId(subId), pickEvents())\n                .subscribe((v) => {\n                  subject.next(v);\n                })\n            );\n          },\n          finalize: () => {", "            for (const r of resource) {\n              r.unsubscribe();\n            }\n            finalizeReq({ subId });\n          },\n        })\n      );\n    } else {\n      return subId$.pipe(map(createEoseManagedEventObservable), mergeAll());\n    }\n", "    function attachSubId(): OperatorFunction<LazyFilter[], LazyREQ> {\n      const makeId = (index?: number) => makeSubId({ rxReqId, index });\n\n      switch (strategy) {\n        case \"backward\":\n          return map((filters, index) => [\"REQ\", makeId(index), ...filters]);\n        case \"forward\":\n        case \"oneshot\":\n          return map((filters) => [\"REQ\", makeId(), ...filters]);\n      }\n    }", "    function manageActiveForwardReq(): MonoTypeOperatorFunction<LazyREQ> {\n      const recordActiveReq = (req: LazyREQ) => {\n        const subId = req[1];\n        ongoings.set(subId, {\n          req,\n          scope,\n        });\n      };\n      const forgetActiveReq = (subId: string) => {\n        ongoings.delete(subId);\n      };\n\n      return tap({\n        next: (req: LazyREQ) => {\n          recordActiveReq(req);\n        },\n        finalize: () => {\n          forgetActiveReq(\n            makeSubId({\n              rxReqId,\n            })\n          );\n        },\n      });\n    }", "    function createEoseManagedEventObservable(\n      subId: string\n    ): Observable<EventPacket> {\n      const eose$ = new Subject<void>();\n      const complete$ = new Subject<void>();\n      const eoseRelays = new Set<string>();\n      const manageCompletion = merge(\n        eose$,\n        createConnectionStateObservable()\n      ).subscribe(() => {\n        const status = getAllRelayState();\n        const shouldComplete = Object.entries(status).every(\n          ([url, state]) =>\n            (scope && !scope.includes(url)) ||\n            state === \"error\" ||\n            state === \"terminated\" ||\n            (state === \"ongoing\" && eoseRelays.has(url))\n        );", "        if (shouldComplete) {\n          complete$.next();\n        }\n      });\n\n      return message$.pipe(\n        takeUntil(complete$),\n        completeOnTimeout(TIMEOUT),\n        filterBySubId(subId),\n        filter((e) => !eoseRelays.has(e.from)),\n        tap((e) => {", "          if (e.message[0] === \"EOSE\") {\n            eoseRelays.add(e.from);\n            finalizeReq({ subId, url: e.from });\n            eose$.next();\n          }\n        }),\n        pickEvents(),\n        finalize(() => {\n          finalizeReq({ subId });\n          complete$.unsubscribe();\n          eose$.unsubscribe();\n          manageCompletion.unsubscribe();\n        })\n      );\n    }", "    function filterBySubId(\n      subId: string\n    ): MonoTypeOperatorFunction<MessagePacket> {\n      return filter(\n        (packet) =>\n          (packet.message[0] === \"EVENT\" || packet.message[0] === \"EOSE\") &&\n          packet.message[1] === subId\n      );\n    }\n    function pickEvents(): OperatorFunction<MessagePacket, EventPacket> {\n      return mergeMap(({ from, message }) =>\n        message[0] === \"EVENT\"\n          ? of({ from, subId: message[1], event: message[2] })\n          : EMPTY\n      );\n    }\n  }\n  createAllEventObservable(): Observable<EventPacket> {\n    return this.messageOut$.pipe(\n      mergeMap(({ from, message }) =>\n        message[0] === \"EVENT\"\n          ? of({ from, subId: message[1], event: message[2] })\n          : EMPTY\n      )\n    );\n  }\n  createAllErrorObservable(): Observable<ErrorPacket> {\n    return this.error$.asObservable();\n  }\n  createAllMessageObservable(): Observable<MessagePacket> {\n    return this.messageOut$;\n  }\n  createConnectionStateObservable(): Observable<ConnectionStatePacket> {\n    return this.status$.asObservable();\n  }\n\n  send(\n    params: Nostr.EventParameters,\n    options?: RxNostrSendOptions\n  ): Observable<OkPacket> {\n    const { seckey, scope: _scope } = makeRxNostrSendOptions(options);\n    const scope = _scope?.map(normalizeRelayUrl);\n\n    const writableConns = Array.from(this.connections.values()).filter(\n      (conn) => (!scope || scope.includes(conn.url)) && conn.write\n    );\n    const subject = new ReplaySubject<OkPacket>(writableConns.length);\n    let subscription: Subscription | null = null;\n\n    getSignedEvent(params, seckey).then((event) => {", "    function pickEvents(): OperatorFunction<MessagePacket, EventPacket> {\n      return mergeMap(({ from, message }) =>\n        message[0] === \"EVENT\"\n          ? of({ from, subId: message[1], event: message[2] })\n          : EMPTY\n      );\n    }\n  }\n  createAllEventObservable(): Observable<EventPacket> {\n    return this.messageOut$.pipe(\n      mergeMap(({ from, message }) =>\n        message[0] === \"EVENT\"\n          ? of({ from, subId: message[1], event: message[2] })\n          : EMPTY\n      )\n    );\n  }\n  createAllErrorObservable(): Observable<ErrorPacket> {\n    return this.error$.asObservable();\n  }\n  createAllMessageObservable(): Observable<MessagePacket> {\n    return this.messageOut$;\n  }\n  createConnectionStateObservable(): Observable<ConnectionStatePacket> {\n    return this.status$.asObservable();\n  }\n\n  send(\n    params: Nostr.EventParameters,\n    options?: RxNostrSendOptions\n  ): Observable<OkPacket> {\n    const { seckey, scope: _scope } = makeRxNostrSendOptions(options);\n    const scope = _scope?.map(normalizeRelayUrl);\n\n    const writableConns = Array.from(this.connections.values()).filter(\n      (conn) => (!scope || scope.includes(conn.url)) && conn.write\n    );\n    const subject = new ReplaySubject<OkPacket>(writableConns.length);\n    let subscription: Subscription | null = null;\n\n    getSignedEvent(params, seckey).then((event) => {", "      if (!subject.closed) {\n        subscription = this.createAllMessageObservable().subscribe(\n          ({ from, message }) => {\n            if (message[0] !== \"OK\") {\n              return;\n            }\n            subject.next({\n              from,\n              id: event.id,\n              ok: message[2],\n            });\n          }\n        );\n      }\n", "      for (const conn of writableConns) {\n        conn.sendEVENT([\"EVENT\", event]);\n      }\n    });\n\n    return subject.pipe(\n      take(writableConns.length),\n      timeout(30 * 1000),\n      finalize(() => {\n        subject.complete();\n        subject.unsubscribe();\n        subscription?.unsubscribe();\n      })\n    );\n  }\n\n  dispose(): void {\n    this.disposed = true;\n    this.messageIn$.complete();\n    this.error$.complete();", "    for (const conn of this.connections.values()) {\n      conn.dispose();\n    }\n  }\n\n  private ensureReq(\n    req: LazyREQ,\n    options?: { scope?: string[] | null; overwrite?: boolean }\n  ) {\n    const scope = options?.scope;\n    for (const url of this.connections.keys()) {\n      const conn = this.connections.get(url);", "    for (const url of this.connections.keys()) {\n      const conn = this.connections.get(url);\n      if (!conn || !conn.read || (scope && !scope.includes(url))) {\n        continue;\n      }\n\n      conn.ensureReq(req, { overwrite: options?.overwrite });\n    }\n  }\n\n  private finalizeReq(params: { subId: string; url?: string }) {\n    const { subId, url } = params;", "    if (subId === undefined && url === undefined) {\n      throw new Error();\n    }\n\n    if (url) {\n      const conn = this.connections.get(url);\n      conn?.finalizeReq(subId);\n    } else {\n      for (const conn of this.connections.values()) {\n        conn?.finalizeReq(subId);\n      }\n    }\n  }\n}\n", "      for (const conn of this.connections.values()) {\n        conn?.finalizeReq(subId);\n      }\n    }\n  }\n}\n\ninterface OngoingReq {\n  req: LazyREQ;\n  scope?: string[];\n}\n", "function makeSubId(params: { rxReqId: string; index?: number }): string {\n  return `${params.rxReqId}:${params.index ?? 0}`;\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./helper.js\";\nexport { toHex } from \"./nostr/bech32.js\";\nexport {\n  compareEvents,\n  earlierEvent,\n  getEventHash,\n  getPublicKey,\n  getSignature,\n  getSignedEvent,\n  laterEvent,", "  getSignedEvent,\n  laterEvent,\n} from \"./nostr/event.js\";\nexport { isFiltered } from \"./nostr/filter.js\";\nexport { fetchRelayInfo } from \"./nostr/nip11.js\";\nexport * from \"./operator.js\";\nexport * from \"./packet.js\";\nexport * from \"./req.js\";\nexport * from \"./rx-nostr.js\";\n", "export * from \"./rx-nostr.js\";\n"]}
{"filename": "src/operator.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\nimport {\n  catchError,\n  delay,\n  distinct,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  groupBy,\n  map,", "  groupBy,\n  map,\n  mergeAll,\n  mergeMap,\n  type MonoTypeOperatorFunction,\n  type ObservableInput,\n  of,\n  type OperatorFunction,\n  pipe,\n  scan,\n  tap,\n  timeout,\n  TimeoutError,\n} from \"rxjs\";\n\nimport { evalFilters } from \"./helper.js\";\nimport { compareEvents, verify as _verify } from \"./nostr/event.js\";\nimport { isFiltered, MatchFilterOptions } from \"./nostr/filter.js\";\nimport { EventPacket, LazyFilter, MessagePacket, ReqPacket } from \"./packet.js\";\nimport { defineDefaultOptions } from \"./util.js\";\n\n// --------------------- //\n// EventPacket operators //\n// --------------------- //\n\n/**\n * Remove the events once seen.\n */", "export function uniq(\n  flushes?: ObservableInput<unknown>\n): MonoTypeOperatorFunction<EventPacket> {\n  return distinct<EventPacket, string>(({ event }) => event.id, flushes);\n}\n\n/**\n * Create a customizable uniq operator.\n *\n * If `keyFn()` returns a non-null key, the key is stored in `Set`.\n * The operator filters packets with keys already stored.\n *\n * The `Set` returned in the second value of the tuple\n * can be manipulated externally or in optional event handlers.\n * For example, you can call `Set#clear()` to forget all keys.\n */", "export function createUniq<T>(\n  keyFn: (packet: EventPacket) => T | null,\n  options?: CreateUniqOptions<T>\n): [MonoTypeOperatorFunction<EventPacket>, Set<T>] {\n  const cache = new Set<T>();\n\n  return [\n    filter((packet) => {\n      const key = keyFn(packet);\n      if (key === null) {\n        return true;\n      }\n", "      if (key === null) {\n        return true;\n      }\n\n      if (cache.has(key)) {\n        options?.onHit?.(packet, cache);\n        return false;\n      } else {\n        cache.add(key);\n        options?.onCache?.(packet, cache);\n        return true;\n      }\n    }),\n    cache,\n  ];\n}\n\n/**\n * Only the latest events are allowed to pass.\n */", "export function latest(): MonoTypeOperatorFunction<EventPacket> {\n  return pipe(\n    scan<EventPacket>((acc, packet) =>\n      compareEvents(acc.event, packet.event) < 0 ? packet : acc\n    ),\n    distinctUntilChanged(\n      (a, b) => a === b,\n      ({ event }) => event.id\n    )\n  );\n}\n\n/**\n * For each key, only the latest events are allowed to pass.\n */", "export function latestEach<K>(\n  key: (packet: EventPacket) => K\n): MonoTypeOperatorFunction<EventPacket> {\n  return pipe(groupBy(key), map(pipe(latest())), mergeAll());\n}\n\n/**\n * Only events with a valid signature are allowed to pass.\n */\nexport function verify(): MonoTypeOperatorFunction<EventPacket> {\n  return filter<EventPacket>(({ event }) => _verify(event));\n}\n\n/**\n * Only events with given kind are allowed to pass.\n */", "export function verify(): MonoTypeOperatorFunction<EventPacket> {\n  return filter<EventPacket>(({ event }) => _verify(event));\n}\n\n/**\n * Only events with given kind are allowed to pass.\n */\nexport function filterKind<K extends number>(\n  kind: K\n): MonoTypeOperatorFunction<EventPacket> {\n  return filter<EventPacket>(({ event }) => event.kind === kind);\n}\n\n/**\n * Filter events based on a REQ filter object.\n */", "export function filterBy(\n  filters: LazyFilter | LazyFilter[],\n  options?: MatchFilterOptions & FilterByOptions\n): MonoTypeOperatorFunction<EventPacket> {\n  const { not } = makeFilterByOptions(options);\n  const evaledFilter = evalFilters(filters);\n  return filter(({ event }) => {\n    const match = isFiltered(event, evaledFilter, options);\n    return not ? !match : match;\n  });\n}\n\n/**\n * Accumulate latest events in order of new arrival (based on `created_at`).\n */", "export function timeline(\n  limit?: number\n): OperatorFunction<EventPacket, EventPacket[]> {\n  return scan<EventPacket, EventPacket[]>((acc, packet) => {\n    const next = [...acc, packet].sort(\n      (a, b) => -1 * compareEvents(a.event, b.event)\n    );\n    if (limit !== undefined) {\n      next.splice(limit);\n    }\n    return next;\n  }, []);\n}\n", "export function sortEvents(\n  bufferTime: number,\n  compareFn?: (a: EventPacket, b: EventPacket) => number\n): MonoTypeOperatorFunction<EventPacket> {\n  return sort(\n    bufferTime,\n    compareFn ?? ((a, b) => compareEvents(a.event, b.event))\n  );\n}\n\n// ----------------------- //\n// MessagePacket operators //\n// ----------------------- //\n", "export function filterType<T extends Nostr.ToClientMessage.Type>(\n  type: T\n): OperatorFunction<\n  MessagePacket,\n  MessagePacket<Nostr.ToClientMessage.Message<T>>\n> {\n  return filter(\n    (packet): packet is MessagePacket<Nostr.ToClientMessage.Message<T>> =>\n      packet.message[0] === type\n  );\n}\n\n// ------------------- //\n// ReqPacket operators //\n// ------------------- //\n\n/**\n * Map REQ packets into a single REQ packet.\n *\n * It is useful to reduce REQ requests in a time interval.\n */", "export function batch(\n  /** Function used for merge REQ filters. Default behavior is simple concatenation. */\n  mergeFilter?: MergeFilter\n): OperatorFunction<ReqPacket[], ReqPacket> {\n  return map((f) =>\n    f.reduce((acc, v) => {\n      if (acc === null) {\n        return v;\n      }\n      if (v === null) {\n        return acc;\n      }\n      return (mergeFilter ?? defaultMergeFilter)(acc, v);\n    }, null)\n  );\n}\n\n/**\n * Chunk a REQ packet into multiple REQ packets.\n *\n * It is useful to avoid to send large REQ filter.\n */", "      if (v === null) {\n        return acc;\n      }\n      return (mergeFilter ?? defaultMergeFilter)(acc, v);\n    }, null)\n  );\n}\n\n/**\n * Chunk a REQ packet into multiple REQ packets.\n *\n * It is useful to avoid to send large REQ filter.\n */", "export function chunk(\n  predicate: (f: LazyFilter[]) => boolean,\n  toChunk: (f: LazyFilter[]) => LazyFilter[][]\n): MonoTypeOperatorFunction<ReqPacket> {\n  return mergeMap((f) =>\n    f !== null && predicate(f) ? of(...toChunk(f)) : of(f)\n  );\n}\n\n// ----------------- //\n// General operators //\n// ----------------- //\n\n/**\n * Almost RxJS's `timeout`, but won't throw.\n */", "export function completeOnTimeout<T>(\n  time: number\n): MonoTypeOperatorFunction<T> {\n  return pipe(\n    timeout(time),\n    catchError((error: unknown) => {\n      if (error instanceof TimeoutError) {\n        return EMPTY;\n      } else {\n        throw error;\n      }\n    })\n  );\n}\n\n/**\n * Buffer the received values for a specified time\n * and return the values in sorted order as possible.\n */", "export function sort<T>(\n  bufferTime: number,\n  compareFn: (a: T, b: T) => number\n): MonoTypeOperatorFunction<T> {\n  const buffer: T[] = [];\n\n  return pipe(\n    tap((v) => {\n      buffer.push(v);\n      buffer.sort(compareFn);\n    }),\n    delay(bufferTime),\n    map(() => {", "      if (buffer.length <= 0) {\n        throw new Error(\"Logic Error: This is rx-nostr's internal bug.\");\n      }\n      // Non-null is valid because the lenght has been checked.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return buffer.shift()!;\n    })\n  );\n}\n\n// ----------- //\n// Other stuff //\n// ----------- //\n", "export type MergeFilter = (a: LazyFilter[], b: LazyFilter[]) => LazyFilter[];\n\nfunction defaultMergeFilter(a: LazyFilter[], b: LazyFilter[]): LazyFilter[] {\n  return [...a, ...b];\n}\n\nexport interface CreateUniqOptions<T> {\n  onCache?: (packet: EventPacket, cache: Set<T>) => void;\n  onHit?: (packet: EventPacket, cache: Set<T>) => void;\n}\n", "export interface FilterByOptions {\n  not: boolean;\n}\nconst makeFilterByOptions = defineDefaultOptions<FilterByOptions>({\n  not: false,\n});\n"]}
{"filename": "src/util.ts", "chunked_list": ["import normalizeUrl from \"normalize-url\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function defineDefaultOptions<T extends Record<string, any>>(\n  defaultParams: T\n): (givenParams?: Partial<T>) => T {\n  return (givenParams) =>\n    Object.fromEntries(\n      Object.keys(defaultParams).map((key) => [\n        key,\n        givenParams?.[key] ?? defaultParams[key],\n      ])\n    ) as T;\n}\n", "export type Override<T extends object, U extends object> = {\n  [K in keyof T | keyof U]: K extends keyof U\n    ? U[K]\n    : K extends keyof T\n    ? T[K]\n    : never;\n};\n\nexport function normalizeRelayUrl(url: string) {\n  return normalizeUrl(url, {\n    normalizeProtocol: false,\n    removeTrailingSlash: true,\n  });\n}\n", "export function normalizeRelayUrl(url: string) {\n  return normalizeUrl(url, {\n    normalizeProtocol: false,\n    removeTrailingSlash: true,\n  });\n}\n"]}
{"filename": "src/__test__/operator.test.ts", "chunked_list": ["import { map, of } from \"rxjs\";\nimport { test } from \"vitest\";\n\nimport { filterType, latestEach } from \"../operator.js\";\nimport { EventPacket, MessagePacket } from \"../packet.js\";\nimport { faker, testScheduler } from \"./helper.js\";\n\ntest(\"latestEach()\", async () => {\n  testScheduler().run((helpers) => {\n    const { expectObservable } = helpers;", "  testScheduler().run((helpers) => {\n    const { expectObservable } = helpers;\n\n    const packet$ = of<EventPacket[]>(\n      faker.eventPacket({ id: \"1\", pubkey: \"a\", created_at: 3 }),\n      faker.eventPacket({ id: \"2\", pubkey: \"b\", created_at: 1 }),\n      faker.eventPacket({ id: \"3\", pubkey: \"a\", created_at: 2 }),\n      faker.eventPacket({ id: \"4\", pubkey: \"a\", created_at: 1 }),\n      faker.eventPacket({ id: \"5\", pubkey: \"b\", created_at: 3 }),\n      faker.eventPacket({ id: \"6\", pubkey: \"b\", created_at: 2 })", "      faker.eventPacket({ id: \"5\", pubkey: \"b\", created_at: 3 }),\n      faker.eventPacket({ id: \"6\", pubkey: \"b\", created_at: 2 })\n    ).pipe(latestEach((packet) => packet.event.pubkey));\n\n    expectObservable(packet$.pipe(map((e) => e.event.id))).toEqual(\n      of(\"1\", \"2\", \"5\")\n    );\n  });\n});\n", "});\n\ntest(\"filterType()\", async () => {\n  testScheduler().run((helpers) => {\n    const { expectObservable } = helpers;\n\n    const packets: MessagePacket[] = [\n      faker.messagePacket(faker.toClientMessage.NOTICE(\"Hello\")),\n      faker.messagePacket(faker.toClientMessage.EVENT(\"*\")),\n      faker.messagePacket(faker.toClientMessage.AUTH()),", "      faker.messagePacket(faker.toClientMessage.EVENT(\"*\")),\n      faker.messagePacket(faker.toClientMessage.AUTH()),\n      faker.messagePacket(faker.toClientMessage.NOTICE(\"Nostr\")),\n      faker.messagePacket(faker.toClientMessage.COUNT(\"*\")),\n      faker.messagePacket(faker.toClientMessage.EVENT(\"*\")),\n    ];\n\n    const packet$ = of(...packets).pipe(filterType(\"NOTICE\"));\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any", "\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    expectObservable(packet$).toEqual(of<any[]>(packets[0], packets[3]));\n  });\n});\n"]}
{"filename": "src/__test__/subscription.test.ts", "chunked_list": ["import { afterEach, assert, beforeEach, describe, expect, test } from \"vitest\";\nimport { createMockRelay, type MockRelay } from \"vitest-nostr\";\n\nimport { WebSocketCloseCode } from \"../connection.js\";\nimport {\n  createRxBackwardReq,\n  createRxForwardReq,\n  createRxNostr,\n  createRxOneshotReq,\n  RxNostr,\n} from \"../index.js\";\nimport { faker, spyEvent, spySub } from \"./helper.js\";\n\ndescribe(\"Basic subscription behavior (single relay)\", () => {\n  const RELAY_URL = \"ws://localhost:1234\";\n  let rxNostr: RxNostr;\n  let relay: MockRelay;\n\n  beforeEach(async () => {\n    relay = createMockRelay(RELAY_URL);\n\n    rxNostr = createRxNostr({\n      retry: { strategy: \"immediately\", maxCount: 1 },\n      globalRelayConfig: {\n        disableAutoFetchNip11Limitations: true,\n      },\n    });\n    await rxNostr.switchRelays([RELAY_URL]);\n\n    await relay.connected;\n  });\n\n  afterEach(() => {\n    rxNostr.dispose();\n    relay.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n  });\n\n  test(\"[forward] Each REQ is published with the same subId.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n    rxNostr.use(req).subscribe();\n\n    req.emit(faker.filter());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n  });\n\n  test(\"[forward] If connection is abnormally closed, REQ will be retried.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    // Emulate an abnormal disconnection of a relay.\n    const socket = await relay.getSocket(0);\n    socket.close({\n      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n      reason: \"Relay's internal error\",\n      wasClean: true,\n    });\n\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    relay.emitEVENT(\"sub:0\");\n    await expect(spy).toSeeEVENT();\n  });\n\n  test(\"[forward] Backoff option `maxCount` works.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    (await relay.getSocket(0)).close({\n      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n      reason: \"Relay's internal error\",\n      wasClean: true,\n    });\n\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    (await relay.getSocket(1)).close({\n      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n      reason: \"Relay's internal error\",\n      wasClean: true,\n    });\n\n    // FIXME: dirty\n    return new Promise((resolve) => {\n      setTimeout(resolve, 100);\n    }).then(async () => {\n      await expect(rxNostr.getRelayState(RELAY_URL)).toBe(\"error\");\n    });\n  });\n\n  test(\"[forward] If connection is closed with 4000, REQ will not be retried.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    // Emulate an abnormal disconnection of a relay.\n    const socket = await relay.getSocket(0);\n    socket.close({\n      code: WebSocketCloseCode.DONT_RETRY,\n      reason: \"Relay's internal error, but should not retry.\",\n      wasClean: true,\n    });\n\n    rxNostr.send(faker.event());\n    // REQ will not be retried, so next message is EVENT\n    await expect(relay).toReceiveEVENT();\n  });\n\n  test(\"[forward] since/until is reevaluated when a lazy REQ is resubmitted.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n    rxNostr.use(req).subscribe();\n\n    let since = 0;\n\n    req.emit({ ...faker.filter(), since: () => since++ });\n    await expect(relay).toReceiveREQ([\n      \"sub:0\",\n      { ...faker.filter(), since: 0 },\n    ]);\n\n    // Emulate an abnormal disconnection of a relay.\n    const socket = await relay.getSocket(0);\n    socket.close({\n      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n      reason: \"Relay's internal error\",\n      wasClean: true,\n    });\n\n    await expect(relay).toReceiveREQ([\n      \"sub:0\",\n      { ...faker.filter(), since: 1 },\n    ]);\n  });\n\n  test(\"[forward] Reject EVENTs that do not match the given filters.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit({ kinds: [1] });\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    relay.emitEVENT(\"sub:0\", faker.event({ kind: 1, content: \"pass\" }));\n    await expect(spy).toSeeEVENT([\n      \"sub:0\",\n      faker.event({ kind: 1, content: \"pass\" }),\n    ]);\n\n    relay.emitEVENT(\"sub:0\", faker.event({ kind: 0, content: \"rejected\" }));\n\n    relay.emitEVENT(\"sub:0\", faker.event({ kind: 1, content: \"pass\" }));\n    await expect(spy).toSeeEVENT([\n      \"sub:0\",\n      faker.event({ kind: 1, content: \"pass\" }),\n    ]);\n  });\n\n  test(\"[backward] After receiving EOSE, CLOSE is sent out.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    rxNostr.use(req).pipe().subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    relay.emitEOSE(\"sub:0\");\n    await expect(relay).toReceiveCLOSE(\"sub:0\");\n  });\n\n  test(\"[backward] Receipt of EOSE does not terminate the Observable.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    const spy = spySub();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ();\n\n    relay.emitEOSE(\"sub:0\");\n    assert(!spy.completed());\n  });\n\n  test(\"[backward] Each EOSE CLOSEs the REQ in the order of arrival.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    rxNostr.use(req).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:1\");\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:2\");\n\n    relay.emitEOSE(\"sub:2\");\n    await expect(relay).toReceiveCLOSE(\"sub:2\");\n\n    relay.emitEOSE(\"sub:1\");\n    await expect(relay).toReceiveCLOSE(\"sub:1\");\n\n    relay.emitEOSE(\"sub:0\");\n    await expect(relay).toReceiveCLOSE(\"sub:0\");\n  });\n\n  test(\"[backward] Even if a newer REQ emits EOSE, EVENTs from older but still active REQ can be received.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:1\");\n\n    relay.emitEOSE(\"sub:1\");\n    await expect(relay).toReceiveCLOSE(\"sub:1\");\n\n    relay.emitEVENT(\"sub:0\");\n    await expect(spy).toSeeEVENT(\"sub:0\");\n\n    relay.emitEOSE(\"sub:0\");\n    await expect(relay).toReceiveCLOSE(\"sub:0\");\n  });\n\n  test(\"[backward] If connection is abnormally closed before receiving EOSE, REQ will be retried.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    // Emulate an abnormal disconnection of a relay.\n    const socket = await relay.getSocket(0);\n    socket.close({\n      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n      reason: \"Relay's internal error\",\n      wasClean: true,\n    });\n\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    relay.emitEVENT(\"sub:0\");\n    await expect(spy).toSeeEVENT();\n\n    relay.emitEOSE(\"sub:0\");\n    await expect(relay).toReceiveCLOSE(\"sub:0\");\n  });\n\n  test(\"[backward] If connection is abnormally closed after receiving EOSE, REQ will not be retried.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    rxNostr.use(req).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    relay.emitEOSE(\"sub:0\");\n    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\n    // Emulate an abnormal disconnection of a relay.\n    const socket = await relay.getSocket(0);\n    socket.close({\n      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n      reason: \"Relay's internal error\",\n      wasClean: true,\n    });\n\n    rxNostr.send(faker.event());\n    await expect(relay).toReceiveEVENT();\n  });\n\n  test(\"[oneshot] Receipt of EOSE terminates the Observable.\", async () => {\n    const req = createRxOneshotReq({\n      subId: \"sub\",\n      filters: faker.filter(),\n    });\n    const spy = spySub();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    assert(!spy.completed());\n\n    relay.emitEOSE(\"sub:0\");\n    assert(spy.completed());\n  });\n});\n\ndescribe(\"Basic subscription behavior (multiple relays)\", () => {\n  const RELAY_URL1 = \"ws://localhost:1234\";\n  const RELAY_URL2 = \"ws://localhost:1235\";\n  const RELAY_URL3 = \"ws://localhost:1236\";\n  let rxNostr: RxNostr;\n  let relay1: MockRelay;\n  let relay2: MockRelay;\n  let relay3: MockRelay;\n\n  beforeEach(async () => {\n    relay1 = createMockRelay(RELAY_URL1);\n    relay2 = createMockRelay(RELAY_URL2);\n    relay3 = createMockRelay(RELAY_URL3);\n\n    rxNostr = createRxNostr({\n      globalRelayConfig: {\n        disableAutoFetchNip11Limitations: true,\n      },\n    });\n    await rxNostr.switchRelays([RELAY_URL1, RELAY_URL2]);\n\n    await relay1.connected;\n    await relay2.connected;\n  });\n\n  afterEach(() => {\n    rxNostr.dispose();\n    relay1.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n    relay2.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n    relay3.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n  });\n\n  test(\"[forward] Adding new relay affects existing REQ.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n\n    rxNostr.use(req).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n    await expect(relay2).toReceiveREQ(\"sub:0\");\n\n    await rxNostr.addRelay(RELAY_URL3);\n    await expect(relay3).toReceiveREQ(\"sub:0\");\n  });\n\n  test(\"[forward] Removing a relay affects existing REQ.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n\n    rxNostr.use(req).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n    await expect(relay2).toReceiveREQ(\"sub:0\");\n\n    await rxNostr.removeRelay(RELAY_URL2);\n    await expect(relay2).toReceiveCLOSE(\"sub:0\");\n  });\n\n  test(\"[forward] Adding new relay doesn't affect existing subset-REQ when the relay is not in subset.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n\n    rxNostr.use(req, { scope: [RELAY_URL1] }).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n\n    await rxNostr.addRelay(RELAY_URL3);\n\n    rxNostr.send(faker.event());\n    await expect(relay1).toReceiveEVENT();\n    await expect(relay2).toReceiveEVENT();\n    await expect(relay3).toReceiveEVENT();\n\n    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n    expect(relay3.messagesToConsume.pendingItems.length).toBe(0);\n  });\n\n  test(\"[forward] Adding new relay affects existing subset-REQ when the relay is in subset.\", async () => {\n    const req = createRxForwardReq(\"sub\");\n\n    rxNostr.use(req, { scope: [RELAY_URL1, RELAY_URL3] }).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n\n    await rxNostr.addRelay(RELAY_URL3);\n    await expect(relay3).toReceiveREQ(\"sub:0\");\n\n    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n  });\n\n  test(\"[backward] EOSE on all subset relays triggers CLOSE.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n\n    rxNostr.use(req, { scope: [RELAY_URL1] }).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n\n    relay1.emitEOSE(\"sub:0\");\n    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\n    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n    expect(relay3.messagesToConsume.pendingItems.length).toBe(0);\n  });\n\n  test(\"[backward] EOSE on all subset and active relays triggers CLOSE.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n\n    rxNostr.use(req, { scope: [RELAY_URL1, RELAY_URL3] }).subscribe();\n\n    req.emit(faker.filters());\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n\n    relay1.emitEOSE(\"sub:0\");\n    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\n    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n  });\n\n  test(\"[oneshot] EOSE on all subset and active relays triggers completion.\", async () => {\n    const req = createRxOneshotReq({\n      subId: \"sub\",\n      filters: faker.filters(),\n    });\n    const spy = spySub();\n\n    rxNostr\n      .use(req, { scope: [RELAY_URL1, RELAY_URL3] })\n      .pipe(spy.tap())\n      .subscribe();\n\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n\n    relay1.emitEOSE(\"sub:0\");\n    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\n    assert(spy.completed());\n  });\n\n  test(\"[oneshot] Collect all events under different timing EOSE.\", async () => {\n    const req = createRxOneshotReq({\n      subId: \"sub\",\n      filters: faker.filters(),\n    });\n    const spy = spyEvent();\n    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\n    await expect(relay1).toReceiveREQ(\"sub:0\");\n    await expect(relay2).toReceiveREQ(\"sub:0\");\n\n    relay1.emitEVENT(\"sub:0\");\n    await expect(spy).toSeeEVENT(\"sub:0\");\n\n    relay2.emitEVENT(\"sub:0\");\n    await expect(spy).toSeeEVENT(\"sub:0\");\n\n    relay1.emitEOSE(\"sub:0\");\n    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\n    relay2.emitEVENT(\"sub:0\");\n    await expect(spy).toSeeEVENT(\"sub:0\");\n\n    relay2.emitEOSE(\"sub:0\");\n    await expect(relay2).toReceiveCLOSE(\"sub:0\");\n  });\n});\n\ndescribe(\"Under limited REQ concurency (single relay)\", () => {\n  const RELAY_URL = \"ws://localhost:1234\";\n  let rxNostr: RxNostr;\n  let relay: MockRelay;\n\n  beforeEach(async () => {\n    relay = createMockRelay(RELAY_URL);\n\n    rxNostr = createRxNostr({\n      retry: { strategy: \"immediately\", maxCount: 1 },\n      globalRelayConfig: {\n        disableAutoFetchNip11Limitations: true,\n        maxConcurrentReqsFallback: 1,\n      },\n    });\n    await rxNostr.switchRelays([RELAY_URL]);\n\n    await relay.connected;\n  });\n\n  afterEach(() => {\n    rxNostr.dispose();\n    relay.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n  });\n\n  test(\"[backward] Overflowed REQs will be enqueued.\", async () => {\n    const req = createRxBackwardReq(\"sub\");\n    rxNostr.use(req).pipe().subscribe();\n\n    req.emit(faker.filters());\n    req.emit(faker.filters());\n    req.emit(faker.filters());\n\n    await expect(relay).toReceiveREQ(\"sub:0\");\n\n    relay.emitEOSE(\"sub:0\");\n    await expect(relay).toReceiveCLOSE(\"sub:0\");\n    await expect(relay).toReceiveREQ(\"sub:1\");\n\n    relay.emitEOSE(\"sub:1\");\n    await expect(relay).toReceiveCLOSE(\"sub:1\");\n    await expect(relay).toReceiveREQ(\"sub:2\");\n\n    relay.emitEOSE(\"sub:2\");\n    await expect(relay).toReceiveCLOSE(\"sub:2\");\n  });\n});\n"]}
{"filename": "src/__test__/extend.test.ts", "chunked_list": ["import { expect, test } from \"vitest\";\n\nimport { createRxBackwardReq, extend, mixin } from \"../index.js\";\n\ntest(\"Extend req.\", async () => {\n  const addFoo = mixin<{ strategy: \"backward\" }, { foo: () => string }>(() => ({\n    foo() {\n      return this.strategy;\n    },\n  }));", "    },\n  }));\n  const req = extend(createRxBackwardReq(), addFoo);\n\n  expect(req.strategy).toBe(\"backward\");\n  expect(req.foo()).toBe(\"backward\");\n});\n\ntest(\"Override req.\", async () => {\n  const original = extend(", "test(\"Override req.\", async () => {\n  const original = extend(\n    createRxBackwardReq(),\n    mixin<object, { foo: () => string }>(() => ({\n      foo() {\n        return \"foo\";\n      },\n    }))\n  );\n  const override = mixin<{ foo: () => string }, { foo: () => number }>(() => ({", "  );\n  const override = mixin<{ foo: () => string }, { foo: () => number }>(() => ({\n    foo() {\n      return 100;\n    },\n  }));\n  const req = extend(original, override);\n\n  expect(req.foo()).toBe(100);\n});", "  expect(req.foo()).toBe(100);\n});\n"]}
{"filename": "src/__test__/helper.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\nimport { type MonoTypeOperatorFunction, tap } from \"rxjs\";\nimport { TestScheduler } from \"rxjs/testing\";\nimport { expect } from \"vitest\";\nimport { createClientSpy, faker as _faker } from \"vitest-nostr\";\n\nimport { EventPacket, MessagePacket } from \"../packet.js\";\n\nexport function testScheduler() {\n  return new TestScheduler((a, b) => expect(a).toEqual(b));\n}\n\nexport const faker = {\n  ..._faker,\n  eventPacket(\n    packetOrEvent?: Partial<\n      EventPacket[\"event\"] &\n        Omit<EventPacket, \"event\"> & {\n          event?: Partial<EventPacket[\"event\"]>;\n        }\n    >\n  ): EventPacket {\n    return {\n      from: packetOrEvent?.from ?? \"*\",\n      subId: packetOrEvent?.subId ?? \"*\",\n      event: faker.event(packetOrEvent?.event ?? packetOrEvent),\n    };\n  },\n  messagePacket(message: Nostr.ToClientMessage.Any): MessagePacket {\n    return {\n      from: \"*\",\n      message,\n    };\n  },\n};\n", "export function testScheduler() {\n  return new TestScheduler((a, b) => expect(a).toEqual(b));\n}\n\nexport const faker = {\n  ..._faker,\n  eventPacket(\n    packetOrEvent?: Partial<\n      EventPacket[\"event\"] &\n        Omit<EventPacket, \"event\"> & {\n          event?: Partial<EventPacket[\"event\"]>;\n        }\n    >\n  ): EventPacket {\n    return {\n      from: packetOrEvent?.from ?? \"*\",\n      subId: packetOrEvent?.subId ?? \"*\",\n      event: faker.event(packetOrEvent?.event ?? packetOrEvent),\n    };\n  },\n  messagePacket(message: Nostr.ToClientMessage.Any): MessagePacket {\n    return {\n      from: \"*\",\n      message,\n    };\n  },\n};\n", "export function spySub(): {\n  completed: () => boolean;\n  error: () => boolean;\n  count: () => number;\n  subscribed: () => boolean;\n  unsubscribed: () => boolean;\n  tap: <T>() => MonoTypeOperatorFunction<T>;\n} {\n  let completed = false;\n  let error = false;\n  let count = 0;\n  let subscribed = false;\n  let unsubscribed = false;\n\n  return {\n    completed: () => completed,\n    error: () => error,\n    count: () => count,\n    subscribed: () => subscribed,\n    unsubscribed: () => unsubscribed,\n    tap: () =>\n      tap({\n        complete: () => void (completed = true),\n        error: () => void (error = true),\n        next: () => void count++,\n        subscribe: () => void (subscribed = true),\n        unsubscribe: () => void (unsubscribed = true),\n      }),\n  };\n}\n", "export function spyMessage(): {\n  tap: () => MonoTypeOperatorFunction<MessagePacket>;\n} {\n  let tapNext: (message: Nostr.ToClientMessage.Any) => void;\n  const spy = createClientSpy((listener) => {\n    tapNext = listener;\n  });\n\n  return {\n    tap: () =>\n      tap((packet) => {\n        tapNext(packet.message);\n      }),\n    ...spy,\n  };\n}\n", "export function spyEvent(): {\n  tap: () => MonoTypeOperatorFunction<EventPacket>;\n} {\n  let tapNext: (message: Nostr.ToClientMessage.Any) => void;\n  const spy = createClientSpy((listener) => {\n    tapNext = listener;\n  });\n\n  return {\n    tap: () =>\n      tap((packet) => {\n        tapNext([\"EVENT\", packet.subId, packet.event]);\n      }),\n    ...spy,\n  };\n}\n"]}
{"filename": "src/__test__/sending.test.ts", "chunked_list": ["import { afterEach, beforeEach, describe, expect, test } from \"vitest\";\nimport { createMockRelay, type MockRelay } from \"vitest-nostr\";\n\nimport { WebSocketCloseCode } from \"../connection.js\";\nimport { createRxNostr, RxNostr } from \"../index.js\";\nimport { faker, spySub } from \"./helper.js\";\n\ndescribe(\"Basic sending behavior\", () => {\n  const RELAY_URL1 = \"ws://localhost:1234\";\n  const RELAY_URL2 = \"ws://localhost:1235\";\n  const RELAY_URL3 = \"ws://localhost:1236\";\n  let rxNostr: RxNostr;\n  let relay1: MockRelay;\n  let relay2: MockRelay;\n  let relay3: MockRelay;\n\n  beforeEach(async () => {\n    relay1 = createMockRelay(RELAY_URL1);\n    relay2 = createMockRelay(RELAY_URL2);\n    relay3 = createMockRelay(RELAY_URL3);\n\n    rxNostr = createRxNostr();\n    await rxNostr.switchRelays([\n      { url: RELAY_URL1, write: true, read: false },\n      { url: RELAY_URL2, write: false, read: true },\n    ]);\n\n    await relay1.connected;\n    await relay2.connected;\n  });\n\n  afterEach(() => {\n    rxNostr.dispose();\n    relay1.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n    relay2.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n    relay3.close({\n      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n      reason: \"Clean up on afterEach()\",\n      wasClean: true,\n    });\n  });\n\n  test(\"send() sends only to writable relays.\", async () => {\n    rxNostr.send(faker.event());\n\n    await expect(relay1).toReceiveEVENT();\n    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n  });\n\n  test(\"send() doesn't wait for OK from relays added later.\", async () => {\n    const spy = spySub();\n\n    rxNostr.send(faker.event()).pipe(spy.tap()).subscribe();\n    rxNostr.addRelay(RELAY_URL3);\n\n    await expect(relay1).toReceiveEVENT();\n    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n    expect(relay3.messagesToConsume.pendingItems.length).toBe(0);\n\n    relay1.emitOK(\"*\", true);\n    expect(spy.completed()).toBe(true);\n  });\n\n  test(\"send() doesn't wait for OK from out of scope.\", async () => {\n    const spy = spySub();\n\n    await rxNostr.switchRelays([RELAY_URL1, RELAY_URL2]);\n    rxNostr\n      .send(faker.event(), { scope: [RELAY_URL2] })\n      .pipe(spy.tap())\n      .subscribe();\n\n    await expect(relay2).toReceiveEVENT();\n    expect(relay1.messagesToConsume.pendingItems.length).toBe(0);\n\n    relay2.emitOK(\"*\", true);\n    expect(spy.completed()).toBe(true);\n  });\n});\n"]}
{"filename": "src/nostr/filter.ts", "chunked_list": ["import * as Nostr from \"nostr-typedef\";\n\nimport { defineDefaultOptions } from \"../util.js\";\n\nexport interface MatchFilterOptions {\n  sinceInclusive: boolean;\n  untilInclusive: boolean;\n}\n\nconst makeMatchFilterOptions = defineDefaultOptions<MatchFilterOptions>({\n  sinceInclusive: true,\n  untilInclusive: true,\n});\n\n/**\n * Return true if the given filter matches the given filters.\n */", "export function isFiltered(\n  event: Nostr.Event,\n  filters: Nostr.Filter | Nostr.Filter[],\n  options?: Partial<MatchFilterOptions>\n): boolean {\n  if (Array.isArray(filters)) {\n    return filters.some((filter) => _isFiltered(event, filter, options));\n  } else {\n    return _isFiltered(event, filters, options);\n  }\n}\n", "function _isFiltered(\n  event: Nostr.Event,\n  filter: Nostr.Filter,\n  options?: Partial<MatchFilterOptions>\n): boolean {\n  const { sinceInclusive, untilInclusive } = makeMatchFilterOptions(options);\n\n  if (\n    filter.ids &&\n    filter.ids.every((prefix) => !event.id.startsWith(prefix))\n  ) {\n    return false;\n  }", "  if (filter.kinds && !filter.kinds.includes(event.kind)) {\n    return false;\n  }\n  if (\n    filter.authors &&\n    filter.authors.every((prefix) => !event.pubkey.startsWith(prefix))\n  ) {\n    return false;\n  }\n  if (\n    filter.since &&\n    ((sinceInclusive && !(filter.since <= event.created_at)) ||\n      (!sinceInclusive && !(filter.since < event.created_at)))\n  ) {\n    return false;\n  }", "  if (\n    filter.since &&\n    ((sinceInclusive && !(filter.since <= event.created_at)) ||\n      (!sinceInclusive && !(filter.since < event.created_at)))\n  ) {\n    return false;\n  }\n  if (\n    filter.until &&\n    ((untilInclusive && !(event.created_at <= filter.until)) ||\n      (!untilInclusive && !(event.created_at < filter.until)))\n  ) {\n    return false;\n  }\n", "  for (const [key, needleValues] of Object.entries(filter)) {\n    if (!key.startsWith(\"#\") || !Array.isArray(needleValues)) {\n      continue;\n    }\n    const needleTagName = key.slice(1);\n\n    if (\n      !event.tags.find(\n        ([tagName, tagValue]) =>\n          needleTagName === tagName &&\n          (needleValues as string[]).includes(tagValue)\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"]}
{"filename": "src/nostr/nip11.ts", "chunked_list": ["import * as Nostr from \"nostr-typedef\";\n\n/**\n * Fetch relay's information based on [NIP-11](https://github.com/nostr-protocol/nips/blob/master/11.md).\n */\nexport async function fetchRelayInfo(\n  url: string\n): Promise<Nostr.Nip11.RelayInfo> {\n  const u = new URL(url);\n  u.protocol = u.protocol.replace(/^ws(s?):/, \"http$1:\");\n\n  const res = await fetch(u.toString(), {\n    headers: { Accept: \"application/nostr+json\" },\n  });\n  return res.json();\n}\n"]}
{"filename": "src/nostr/bech32.ts", "chunked_list": ["import { bytesToHex } from \"@noble/hashes/utils\";\nimport { bech32 } from \"@scure/base\";\n\n/** Convert bech32 format string to HEX format string. */\nexport function toHex(str: string): string {\n  const { words } = bech32.decode(str);\n  const data = new Uint8Array(bech32.fromWords(words));\n  return bytesToHex(data);\n}\n"]}
{"filename": "src/nostr/nip07.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\ndeclare global {\n  interface Window {\n    nostr?: Nostr.Nip07.Nostr;\n  }\n}\n"]}
{"filename": "src/nostr/event.ts", "chunked_list": ["import { schnorr } from \"@noble/curves/secp256k1\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport Nostr from \"nostr-typedef\";\n\nimport { toHex } from \"./bech32.js\";\n\nconst utf8Encoder = new TextEncoder();\n\n/**", "\n/**\n * Return a signed event that is ready for sending.\n */\nexport async function getSignedEvent(\n  params: Nostr.EventParameters,\n  /** Private key in bech32 format of HEX format. If omitted, attempt to use NIP-07 interface. */\n  seckey?: string\n): Promise<Nostr.Event> {\n  const event = {\n    ...params,\n    pubkey: params.pubkey ?? (await getPubkey()),\n    tags: params.tags ?? [],\n    created_at: params.created_at ?? Math.floor(new Date().getTime() / 1000),\n  };\n", "  if (ensureRequiredFields(params)) {\n    return params;\n  } else if (seckey) {\n    const id = event.id ?? getEventHash(event);\n    const sechex = seckey.startsWith(\"nsec1\") ? toHex(seckey) : seckey;\n    return {\n      ...event,\n      id,\n      sig: event.sig ?? getSignature(id, sechex),\n    };\n  } else {\n    const nostr = (window ?? {})?.nostr;", "    if (!nostr) {\n      throw new Error(\n        \"Couldn't get sig. To automatically calculate signature, a seckey argument or NIP-07 environment is required.\"\n      );\n    }\n\n    return nostr.signEvent({\n      kind: event.kind,\n      tags: event.tags,\n      content: event.content,\n      created_at: event.created_at,\n    });\n  }\n", "  async function getPubkey() {\n    if (params.pubkey) {\n      if (params.pubkey.startsWith(\"npub1\")) {\n        return toHex(params.pubkey);\n      } else {\n        return params.pubkey;\n      }\n    } else {\n      if (seckey) {\n        if (seckey.startsWith(\"nsec1\")) {\n          return getPublicKey(toHex(seckey));\n        } else {\n          return getPublicKey(seckey);\n        }\n      } else {\n        const pubkey = await window?.nostr?.getPublicKey();", "      if (seckey) {\n        if (seckey.startsWith(\"nsec1\")) {\n          return getPublicKey(toHex(seckey));\n        } else {\n          return getPublicKey(seckey);\n        }\n      } else {\n        const pubkey = await window?.nostr?.getPublicKey();\n        if (!pubkey) {\n          throw new Error(\n            \"Couldn't get pubkey. To automatically calculate pubkey, a seckey argument or NIP-07 environment is required.\"\n          );\n        }\n        return pubkey;\n      }\n    }\n  }\n}\n\n/** Calculate and return public key in HEX format. */", "        if (!pubkey) {\n          throw new Error(\n            \"Couldn't get pubkey. To automatically calculate pubkey, a seckey argument or NIP-07 environment is required.\"\n          );\n        }\n        return pubkey;\n      }\n    }\n  }\n}\n\n/** Calculate and return public key in HEX format. */", "export function getPublicKey(seckey: string): string {\n  return bytesToHex(schnorr.getPublicKey(seckey));\n}\n\n/** Calculate and return event's hash (ID). */\nexport function getEventHash(event: Nostr.UnsignedEvent): string {\n  const serialized = JSON.stringify([\n    0,\n    event.pubkey,\n    event.created_at,\n    event.kind,\n    event.tags,\n    event.content,\n  ]);\n  return bytesToHex(sha256(utf8Encoder.encode(serialized)));\n}\n\n/** Calculate and return schnorr signature. */", "export function getSignature(eventHash: string, seckey: string): string {\n  return bytesToHex(schnorr.sign(eventHash, seckey));\n}\n\n/** Verify the given event and return true if it is valid. */\nexport function verify(event: Nostr.Event): boolean {\n  try {\n    return schnorr.verify(event.sig, getEventHash(event), event.pubkey);\n  } catch (err) {\n    console.warn(\"The following error occurred during verify():\", err);\n    return false;\n  }\n}\n", "  } catch (err) {\n    console.warn(\"The following error occurred during verify():\", err);\n    return false;\n  }\n}\n\nfunction ensureRequiredFields(\n  event: Partial<Nostr.Event>\n): event is Nostr.Event {\n  if (typeof event.id !== \"string\") return false;\n  if (typeof event.sig !== \"string\") return false;", "  if (typeof event.id !== \"string\") return false;\n  if (typeof event.sig !== \"string\") return false;\n  if (typeof event.kind !== \"number\") return false;\n  if (typeof event.pubkey !== \"string\") return false;\n  if (typeof event.content !== \"string\") return false;\n  if (typeof event.created_at !== \"number\") return false;\n\n  if (!Array.isArray(event.tags)) return false;\n  for (let i = 0; i < event.tags.length; i++) {\n    const tag = event.tags[i];\n    if (!Array.isArray(tag)) return false;", "  for (let i = 0; i < event.tags.length; i++) {\n    const tag = event.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n\n  return true;\n}\n\n/** Return an event that has earlier `created_at`. */", "export function earlierEvent(a: Nostr.Event, b: Nostr.Event): Nostr.Event {\n  return compareEvents(a, b) < 0 ? a : b;\n}\n\n/** Return an event that has later `created_at`. */\nexport function laterEvent(a: Nostr.Event, b: Nostr.Event): Nostr.Event {\n  return compareEvents(a, b) < 0 ? b : a;\n}\n\n/** Sort key function to sort events based on `created_at`. */\nexport function compareEvents(a: Nostr.Event, b: Nostr.Event): number {", "/** Sort key function to sort events based on `created_at`. */\nexport function compareEvents(a: Nostr.Event, b: Nostr.Event): number {\n  if (a.id === b.id) {\n    return 0;\n  }\n\n  return a.created_at < b.created_at ||\n    // https://github.com/nostr-protocol/nips/blob/master/16.md#replaceable-events\n    (a.created_at === b.created_at && a.id < b.id)\n    ? -1\n    : 1;\n}\n"]}
