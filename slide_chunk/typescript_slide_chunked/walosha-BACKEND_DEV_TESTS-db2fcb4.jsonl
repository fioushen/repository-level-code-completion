{"filename": "@types/helmet.d.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/ban-types */\ndeclare module 'xss-clean' {\n  const value: Function;\n\n  export default value;\n}\n"]}
{"filename": "@types/xss-clean.d.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/ban-types */\ndeclare module 'helmet' {\n  const value: Function;\n\n  export default value;\n}\n"]}
{"filename": "@types/express.d.ts", "chunked_list": ["export interface UserPayload {\n  id?: string;\n  name: string;\n  email: string;\n  role: string;\n  token?: string;\n}\n\ndeclare module 'express-serve-static-core' {\n  interface Request {\n    user?: UserPayload;\n  }\n}\n", "  interface Request {\n    user?: UserPayload;\n  }\n}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import express from 'express';\nimport morgan from 'morgan';\nimport mongoSanitize from 'express-mongo-sanitize';\nimport cookieParser from 'cookie-parser';\nimport cors from 'cors';\nimport authRouter from './modules/auth/controller';\nimport userRouter from './modules/auth/controller/users';\nimport accountRouter from './modules/account/controller/index';\nimport errorHandler from './middleware/error';\nimport swaggerJsdoc from 'swagger-jsdoc';", "import errorHandler from './middleware/error';\nimport swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\nimport * as dotenv from 'dotenv';\nimport { options } from './constant/swaggerOptions';\nimport { customRedisRateLimiter } from './middleware/ratelimiter';\ndotenv.config();\n\n// Start express app\nconst app = express();", "// Start express app\nconst app = express();\nconst specs = swaggerJsdoc(options);\napp.use('/api/v1/api-docs', swaggerUi.serve, swaggerUi.setup(specs));\n\napp.enable('trust proxy');\n\n// Implement CORS\napp.use(cors());\n// Set security HTTP headers", "app.use(cors());\n// Set security HTTP headers\n\n// Implemened 10 requests in 24 hrs limit!\napp.use(customRedisRateLimiter);\n\n// Development logging\nif (process.env.NODE_ENV === 'development') {\n  app.use(morgan('dev'));\n}\n\n// Body parser, reading data from body into req.body\napp.use(express.json({ limit: '10kb' }));\napp.use(express.urlencoded({ extended: true, limit: '10kb' }));\napp.use(cookieParser());\n\napp.use(mongoSanitize());\n\n// 3) ROUTES\napp.use('/api/v1/auth', authRouter);\napp.use('/api/v1/users', userRouter);\napp.use('/api/v1/account', accountRouter);\napp.use(errorHandler);\n\nexport default app;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import dotenv from 'dotenv';\nimport { initializeDB } from './database';\n\nprocess.on('uncaughtException', (err) => {\n  console.log('UNCAUGHT EXCEPTION! \ud83d\udca5 Shutting down...');\n  console.log(err.name, err.message);\n  process.exit(1);\n});\n\ndotenv.config({ path: './config.env' });", "\ndotenv.config({ path: './config.env' });\nimport app from './app';\n\ninitializeDB();\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`App running on port ${port}...`);\n});", "  console.log(`App running on port ${port}...`);\n});\n\nprocess.on('unhandledRejection', (err: any) => {\n  console.log('UNHANDLED REJECTION! \ud83d\udca5 Shutting down...');\n  console.log(err.name, err.message);\n  server.close(() => {\n    process.exit(1);\n  });\n});", "  });\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('\ud83d\udc4b SIGTERM RECEIVED. Shutting down gracefully');\n  server.close(() => {\n    console.log('\ud83d\udca5 Process terminated!');\n  });\n});\n", "});\n"]}
{"filename": "src/utils/appError.ts", "chunked_list": ["export class AppError extends Error {\n  status;\n  statusCode;\n  isOperational;\n  constructor(message: string, statusCode: number) {\n    super(message);\n\n    this.statusCode = statusCode;\n    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\n    this.isOperational = true;\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n"]}
{"filename": "src/utils/catchAsync.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\ntype AsyncFunction = (req: Request, res: Response, next: NextFunction) => Promise<any>;\n\nexport const catchAsync = (fn: AsyncFunction) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    fn(req, res, next).catch(next);\n  };\n};\n"]}
{"filename": "src/utils/redis.ts", "chunked_list": ["import { createClient } from 'redis';\n\nclass RedisService {\n  client;\n  constructor() {\n    this.client = createClient({ url: process.env.REDIS_URL });\n  }\n\n  async set({ key, value, timeType, time }: any) {\n    await this.client.connect();\n    await this.client.set(key, value, timeType, time);\n    await this.client.disconnect();\n  }\n\n  async get(key: string) {\n    await this.client.connect();\n    const result = await this.client.get(key);\n    await this.client.disconnect();\n    return result;\n  }\n\n  async exists(key: string) {\n    await this.client.connect();\n    const result = await this.client.exists(key);\n    await this.client.disconnect();\n    return result;\n  }\n}\n\nexport default new RedisService();\n"]}
{"filename": "src/constant/swaggerOptions.ts", "chunked_list": ["// https://blog.logrocket.com/documenting-express-js-api-swagger/\nexport const options = {\n  swaggerDefinition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'BACKEND_DEV_TEST',\n      version: '1.0.0',\n      description: 'API documentation',\n      contact: {\n        name: 'bacnk-api',", "      contact: {\n        name: 'bacnk-api',\n        url: 'localhost:3000',\n        email: 'walosha@yahoo.com',\n      },\n    },\n    components: {\n      securitySchemes: {\n        bearerAuth: {\n          type: 'http',", "        bearerAuth: {\n          type: 'http',\n          scheme: 'bearer',\n          bearerFormat: 'JWT',\n        },\n      },\n    },\n    security: [{ bearerAuth: [] }],\n    servers: [\n      {", "    servers: [\n      {\n        url: 'http://localhost:3000',\n        description: 'Development server',\n      },\n    ],\n  },\n\n  apis: ['./src/modules/**/*.ts'],\n};", "  apis: ['./src/modules/**/*.ts'],\n};\n"]}
{"filename": "src/database/index.ts", "chunked_list": ["import mongoose from 'mongoose';\n\nexport const initializeDB = () => {\n  console.log(process.env.DATABASE_URL);\n  mongoose\n    .connect(process.env.DATABASE_URL as string, {})\n    .then(() => console.log('DB connection successful!'))\n    .catch(console.log);\n};\n"]}
{"filename": "src/modules/auth/model/index.ts", "chunked_list": ["import { Document, Model, Schema, model } from 'mongoose';\nimport * as EmailValidator from 'email-validator';\nimport { hash, compare } from 'bcryptjs';\n// import { IUser } from '../types';\n\ninterface UserAttrs {\n  id: string;\n  name: string;\n  email: string;\n  role: 'user' | 'admin';\n  password: string;\n}\n", "export interface UserModel extends Model<IUser> {\n  build(attrs: UserAttrs): IUser;\n  correctPassword(candidatePassword: string, userPassword: string): Promise<boolean>;\n}\n\ninterface IUser extends Document {\n  id: string;\n  name: string;\n  email: string;\n  role: 'user' | 'admin';\n  password: string;\n}\n\nconst userSchema = new Schema<IUser>({\n  name: {\n    type: String,\n    required: [true, 'Please tell us your name!'],\n  },\n  email: {\n    type: String,\n    required: [true, 'Please provide your email'],\n    unique: true,\n    lowercase: true,\n    validate: {\n      validator: function (value: string) {\n        // Custom email validation logic\n        return /^([\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4})?$/.test(value);\n      },\n      message: 'Invalid email format',\n    },\n  },\n\n  role: {\n    type: String,\n    enum: ['user', 'admin'],\n    default: 'user',\n  },\n  password: {\n    type: String,\n    required: [true, 'Please provide a password'],\n    minlength: 8,\n    select: false,\n  },\n});\n\nuserSchema.pre('save', async function (next) {", "  // Only run this function if password was actually modified\n  if (!this.isModified('password')) return next();\n\n  // Hash the password with cost of 12\n  this.password = await hash(this.password, 12);\n\n  // Delete passwordConfirm field\n  next();\n});\n\nuserSchema.methods.correctPassword = async function (\n  candidatePassword: string,\n  userPassword: string,\n): Promise<boolean> {\n  return await compare(candidatePassword, userPassword);\n};\n\n// const User = model<IUser>('User', userSchema);\n\nuserSchema.statics.build = (attrs: UserAttrs) => {\n  return new User(attrs);\n};\n\nconst User = model<IUser, UserModel>('User', userSchema);\n\nexport default User;\n"]}
{"filename": "src/modules/auth/controller/users.ts", "chunked_list": ["/**\n * @swagger\n * components:\n *   schemas:\n *     User:\n *       type: object\n *       required:\n *         - name\n *         - email\n *       properties:", " *         - email\n *       properties:\n *         name:\n *           type: string\n *           description: The user name\n *         email:\n *           type: string\n *           format: email\n *           description: The user email address\n *         password:", " *           description: The user email address\n *         password:\n *           type: string\n *           description: The user password (hashed)\n *         role:\n *           type: string\n *           enum: [user, admin]\n *           description: The user role\n *           default: user\n *       example:", " *           default: user\n *       example:\n *         name: John Doe\n *         email: johndoe@example.com\n *         password: $2a$10$gR06R4K1NM4p4b4ELq.LlOTzq3Dcxj2iPwE5U/O2MDE70o9noemhO\n *         role: user\n */\n\nimport express from 'express';\nimport { deleteUser, fetchUsers } from '../service';", "import express from 'express';\nimport { deleteUser, fetchUsers } from '../service';\nimport { protect, restrictTo } from '../../../middleware';\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/v1/users:\n *   get:\n *     summary: Retrieve all users", " *   get:\n *     summary: Retrieve all users\n *     tags: [User]\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       \"200\":\n *         description: A list of users\n *         content:\n *           application/json:", " *         content:\n *           application/json:\n *             schema:\n *               type: array\n *               items:\n *                 $ref: '#/components/schemas/User'\n *       \"401\":\n *         description: Unauthorized\n */\n", " */\n\nrouter.get('/', protect, restrictTo('admin'), fetchUsers);\n\n/**\n * @swagger\n * /api/v1/users/{id}:\n *   delete:\n *     summary: Delete a user by ID\n *     tags: [User]", " *     summary: Delete a user by ID\n *     tags: [User]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         schema:\n *           type: string\n *         required: true", " *           type: string\n *         required: true\n *         description: The ID of the user to delete\n *     responses:\n *       \"204\":\n *         description: User deleted successfully\n *       \"401\":\n *         description: Unauthorized\n *       \"404\":\n *         description: User not found", " *       \"404\":\n *         description: User not found\n */\n// A simple case where users can only delete themselves not the admin\n\nrouter.delete('/:id', restrictTo('user'), deleteUser);\n\nexport default router;\n", ""]}
{"filename": "src/modules/auth/controller/index.ts", "chunked_list": ["/**\n * @swagger\n * components:\n *   schemas:\n *     SignupRequest:\n *       type: object\n *       required:\n *         - email\n *         - password\n *         - name", " *         - password\n *         - name\n *       properties:\n *         name:\n *           type: string\n *           description: The user name\n *         email:\n *           type: string\n *           description: The user email address\n *         password:", " *           description: The user email address\n *         password:\n *           type: string\n *           description: The user password\n *       example:\n *         name: John Doe\n *         email: johndoe@example.com\n *         password: password123\n *     LoginRequest:\n *       type: object", " *     LoginRequest:\n *       type: object\n *       required:\n *         - email\n *         - password\n *       properties:\n *         email:\n *           type: string\n *           description: The user email address\n *         password:", " *           description: The user email address\n *         password:\n *           type: string\n *           description: The user password\n *       example:\n *         email: johndoe@example.com\n *         password: password123\n */\n\nimport express from 'express';", "\nimport express from 'express';\nimport { getMe, login, refresh, signup } from '../service';\nimport { refreshMiddleware } from '../../../middleware/refresh';\nimport { protect } from '../../../middleware';\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/v1/auth/signup:", " * @swagger\n * /api/v1/auth/signup:\n *   post:\n *     summary: Creates an account\n *     tags: [Auth]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:", " *         application/json:\n *           schema:\n *             $ref: '#/components/schemas/SignupRequest'\n *     responses:\n *       \"200\":\n *         description: The created user.\n *         content:\n *           application/json:\n *             schema:\n *               $ref: '#/components/schemas/User'", " *             schema:\n *               $ref: '#/components/schemas/User'\n */\n\nrouter.post('/signup', signup);\n\n/**\n * @swagger\n * /api/v1/auth/login:\n *   post:", " * /api/v1/auth/login:\n *   post:\n *     summary: Login User\n *     tags: [Auth]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             $ref: '#/components/schemas/LoginRequest'", " *           schema:\n *             $ref: '#/components/schemas/LoginRequest'\n *     responses:\n *       \"200\":\n *         description: The authenticated user.\n *         content:\n *           application/json:\n *             schema:\n *               $ref: '#/components/schemas/User'\n */", " *               $ref: '#/components/schemas/User'\n */\nrouter.post('/login', login);\n\n/**\n * @swagger\n * /api/v1/auth/refresh:\n *   post:\n *     summary: Refreshes the access token\n *     tags: [Auth]", " *     summary: Refreshes the access token\n *     tags: [Auth]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - refresh", " *             required:\n *               - refresh\n *             properties:\n *               refresh:\n *                 type: string\n *                 description: Refresh token\n *                 example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0NGYwMjg0MWRmNGJlYzliOWI3ZjlhYSIsImlhdCI6MTY4Mjg5OTU4OCwiZXhwIjoxNjgzMDcyMzg4fQ.Bt2kzyxyUEtUy9pLvr0zSzpI8_xTaM6KulO2mwYztbQ\n *     responses:\n *       \"200\":\n *         description: The new access token", " *       \"200\":\n *         description: The new access token\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 accessToken:\n *                   type: string\n *                   description: Access token", " *                   type: string\n *                   description: Access token\n *                   example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJKb2huIERvZSIsImlhdCI6MTUxNjIzOTAyMn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n *       \"400\":\n *         description: Invalid request or refresh token is not present\n *       \"401\":\n *         description: Invalid or expired token or refresh token was already used\n */\n\nrouter.post('/refresh', refreshMiddleware, refresh);", "\nrouter.post('/refresh', refreshMiddleware, refresh);\n\n/**\n * @swagger\n * /api/v1/auth/me:\n *   post:\n *     summary: Get user profile\n *     tags: [Auth]\n *     security:", " *     tags: [Auth]\n *     security:\n *       - bearerAuth: []\n *     responses:\n *       \"200\":\n *         description: The user profile\n *       \"401\":\n *         description: Unauthorized\n */\nrouter.post('/me', protect, getMe);", " */\nrouter.post('/me', protect, getMe);\n\nexport default router;\n"]}
{"filename": "src/modules/auth/types/index.ts", "chunked_list": ["export interface IUser {\n  _id: string;\n  name: string;\n  email: string;\n  role: 'user' | 'admin';\n  password: string;\n}\n"]}
{"filename": "src/modules/auth/service/index.ts", "chunked_list": ["import { sign } from 'jsonwebtoken';\nimport { IUser } from '../types';\nimport { Request, Response } from 'express';\nimport User from '../model';\nimport { AppError } from '../../../utils/appError';\nimport { catchAsync } from '../../../utils/catchAsync';\nimport redisService from '../../../utils/redis';\n\nconst accessToken = (user: { _id: string; name: string; email: string; role: string }) => {\n  return sign(", "const accessToken = (user: { _id: string; name: string; email: string; role: string }) => {\n  return sign(\n    { id: user._id, name: user.name, email: user.email, type: process.env.JWT_ACCESS, role: user.role },\n    process.env.JWT_KEY_SECRET as string,\n    {\n      subject: user.email,\n      expiresIn: process.env.JWT_EXPIRES_IN,\n      audience: process.env.JWT_AUDIENCE,\n      issuer: process.env.JWT_ISSUER,\n    },", "      issuer: process.env.JWT_ISSUER,\n    },\n  );\n};\n\nconst refreshToken = (user: { _id: string; name: string; email: string; role: string }) => {\n  return sign(\n    { id: user._id, name: user.name, email: user.email, type: process.env.JWT_REFRESH, role: user.role },\n    process.env.JWT_KEY_REFRESH as string,\n    {", "    process.env.JWT_KEY_REFRESH as string,\n    {\n      subject: user.email,\n      expiresIn: process.env.JWT_EXPIRES_IN,\n      audience: process.env.JWT_AUDIENCE,\n      issuer: process.env.JWT_ISSUER,\n    },\n  );\n};\n", "};\n\nconst createSendToken = (user: IUser, statusCode: number, req: Request, res: Response) => {\n  const acess = accessToken(user);\n  const refresh = refreshToken(user);\n\n  // Remove password from output\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { name, email, role, ...otherUserData } = user;\n", "  const { name, email, role, ...otherUserData } = user;\n\n  res.status(statusCode).json({\n    status: 'success',\n    acess,\n    refresh,\n    data: {\n      name,\n      email,\n      role,", "      email,\n      role,\n    },\n  });\n};\n\nexport const signup = catchAsync(async (req, res) => {\n  const newUser = await User.create({\n    name: req.body.name,\n    email: req.body.email,", "    name: req.body.name,\n    email: req.body.email,\n    password: req.body.password,\n  });\n\n  createSendToken(newUser, 201, req, res);\n});\n\nexport const login = catchAsync(async (req, res, next) => {\n  const { email, password } = req.body;", "export const login = catchAsync(async (req, res, next) => {\n  const { email, password } = req.body;\n\n  // 1) Check if email and password exist\n  if (!email || !password) {\n    return next(new AppError('Please provide email and password!', 400));\n  }\n  // 2) Check if user exists && password is correct\n  const user: any = await User.findOne({ email }).select('+password');\n\n  if (!user || !(await user.correctPassword(password, user.password))) {\n    return next(new AppError('Incorrect email or password', 401));\n  }\n\n  // 3) If everything ok, send token to client\n  createSendToken(user, 200, req, res);\n});\n\nexport const getMe = catchAsync(async (req, res) => {\n  const user = req.user;\n\n  // 3) If everything ok, send token to client\n  res.status(200).json({ message: 'user sucessfully fetched!', user });\n});\n", "  if (!user || !(await user.correctPassword(password, user.password))) {\n    return next(new AppError('Incorrect email or password', 401));\n  }\n\n  // 3) If everything ok, send token to client\n  createSendToken(user, 200, req, res);\n});\n\nexport const getMe = catchAsync(async (req, res) => {\n  const user = req.user;\n\n  // 3) If everything ok, send token to client\n  res.status(200).json({ message: 'user sucessfully fetched!', user });\n});\n", "export function logout(req: Request, res: Response) {\n  res.cookie('jwt', 'loggedout', {\n    expires: new Date(Date.now() + 10 * 1000),\n    httpOnly: true,\n  });\n  res.status(200).json({ status: 'success' });\n}\n\nexport async function refresh(req: Request, res: Response) {\n  const user: any = req.user;\n  await redisService.set({\n    key: user?.token,\n    value: '1',\n    timeType: 'EX',\n    time: parseInt(process.env.JWT_REFRESH_TIME || '', 10),\n  });\n  const refresh = refreshToken(user);\n  return res.status(200).json({ status: 'sucess', refresh });\n}\n", "export async function refresh(req: Request, res: Response) {\n  const user: any = req.user;\n  await redisService.set({\n    key: user?.token,\n    value: '1',\n    timeType: 'EX',\n    time: parseInt(process.env.JWT_REFRESH_TIME || '', 10),\n  });\n  const refresh = refreshToken(user);\n  return res.status(200).json({ status: 'sucess', refresh });\n}\n", "export async function fetchUsers(req: Request, res: Response) {\n  const body = req.body;\n  console.log({ body });\n  try {\n    const users = await User.find();\n    return res.status(200).json({ message: 'sucessfully fetch users', data: users });\n  } catch (error: any) {\n    new AppError(error.message, 201);\n  }\n}\n", "export async function deleteUser(req: Request, res: Response) {\n  const id = req.params.id;\n\n  try {\n    await User.deleteOne({ _id: id });\n    return res.status(200).json({ message: 'sucessfully deleted users' });\n  } catch (error: any) {\n    new AppError(error.message, 201);\n  }\n}\n"]}
{"filename": "src/modules/account/model/index.ts", "chunked_list": ["import mongoose, { Document, Model, Schema, model } from 'mongoose';\n\ninterface AccountAttrs {\n  id: string;\n  user: string;\n  accountType: any;\n  balance: number;\n}\n\ninterface IAccount extends Document {\n  id: string;\n  user: string;\n  accountType: any;\n  balance: number;\n}\n", "interface IAccount extends Document {\n  id: string;\n  user: string;\n  accountType: any;\n  balance: number;\n}\n\nexport interface AccountModel extends Model<IAccount> {\n  build(attrs: AccountAttrs): IAccount;\n}\n\nconst AccountSchema = new Schema({\n  accountType: {\n    type: String,\n    enum: ['Savings', 'Current', 'BasicSavings'],\n  },\n  user: {\n    type: mongoose.Types.ObjectId,\n    ref: 'User',\n  },\n  balance: {\n    type: Number,\n    default: 0,\n  },\n});\n\nAccountSchema.methods.verifyBalance = function (amountToAdd: any) {", "  if (this.accountType === 'BasicSavings' && this.balance + amountToAdd > 50000) {\n    return false;\n  }\n  return true;\n};\n\nAccountSchema.statics.build = (attrs: AccountAttrs) => {\n  return new Account(attrs);\n};\n\nconst Account = model<IAccount, AccountModel>('Account', AccountSchema);\nexport default Account;\n"]}
{"filename": "src/modules/account/controller/index.ts", "chunked_list": ["/**\n * @swagger\n * components:\n *   schemas:\n *     SignupRequest:\n *       type: object\n *       required:\n *         - email\n *         - password\n *         - name", " *         - password\n *         - name\n *       properties:\n *         name:\n *           type: string\n *           description: The user name\n *         email:\n *           type: string\n *           description: The user email address\n *         password:", " *           description: The user email address\n *         password:\n *           type: string\n *           description: The user password\n *       example:\n *         name: John Doe\n *         email: johndoe@example.com\n *         password: password123\n *     LoginRequest:\n *       type: object", " *     LoginRequest:\n *       type: object\n *       required:\n *         - email\n *         - password\n *       properties:\n *         email:\n *           type: string\n *           description: The user email address\n *         password:", " *           description: The user email address\n *         password:\n *           type: string\n *           description: The user password\n *       example:\n *         email: johndoe@example.com\n *         password: password123\n */\n\nimport express from 'express';", "\nimport express from 'express';\nimport { transferFund } from '../service';\nimport { protect } from '../../../middleware';\nconst router = express.Router();\n\n/**\n * @swagger\n * /api/v1/account/transfer:\n *   post:", " * /api/v1/account/transfer:\n *   post:\n *     tags:\n *       - Transfer\n *     summary: Transfer funds between accounts\n *     security:\n *       - BearerAuth: []\n *     requestBody:\n *       required: true\n *       content:", " *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               fromAccountId:\n *                 type: string\n *                 description: The ID of the account to transfer funds from.\n *                 example: \"123456\"", " *                 description: The ID of the account to transfer funds from.\n *                 example: \"123456\"\n *               toAccountId:\n *                 type: string\n *                 description: The ID of the account to transfer funds to.\n *                 example: \"789012\"\n *               amount:\n *                 type: number\n *                 description: The amount of funds to transfer.\n *                 example: 1000.00", " *                 description: The amount of funds to transfer.\n *                 example: 1000.00\n *               tag:\n *                 type: string\n *                 description: The tag associated with the transfer.\n *                 example: \"Rent payment\"\n *     responses:\n *       '200':\n *         description: Successful transfer of funds\n *       '400':", " *         description: Successful transfer of funds\n *       '400':\n *         description: Invalid request parameters\n *       '401':\n *         description: Unauthorized request\n */\n\nrouter.post('/transfer', protect, transferFund);\n\nexport default router;", "\nexport default router;\n"]}
{"filename": "src/modules/account/types/index.ts", "chunked_list": ["export interface IUser {\n  _id: string;\n  name: string;\n  email: string;\n  role: 'user' | 'admin';\n  password: string;\n}\n"]}
{"filename": "src/modules/account/service/index.ts", "chunked_list": ["import { Request, Response } from 'express';\nimport Account from '../model';\n\nexport const transferFund = async (req: Request, res: Response) => {\n  const { fromAccountId, toAccountId, amount } = req.body;\n  try {\n    let srcAccount: any = await Account.findById(fromAccountId);\n    let destAccount: any = await Account.findById(toAccountId);\n\n    if (String(srcAccount.user) == String(destAccount.user)) {\n      return res.status(400).json({\n        error: 'Cannot transfer to own acccount',\n        errorCode: 400,\n      });\n    }", "    if (String(srcAccount.user) == String(destAccount.user)) {\n      return res.status(400).json({\n        error: 'Cannot transfer to own acccount',\n        errorCode: 400,\n      });\n    }\n    if (srcAccount.balance >= amount) {\n      srcAccount = await Account.findByIdAndUpdate(\n        srcAccount,\n        {\n          $inc: {\n            balance: -amount,\n          },\n        },\n        { returnOriginal: false },\n      );\n\n      destAccount = await Account.findByIdAndUpdate(destAccount, {\n        $inc: {\n          balance: amount,\n        },\n      });\n      console.log('srcAcc', srcAccount);\n\n      const destUserId = destAccount.user;\n      const destUserData = await Account.aggregate([\n        {\n          $match: {\n            user: destUserId,\n          },\n        },\n        {\n          $group: {\n            _id: null,\n            total: {\n              $sum: '$balance',\n            },\n          },\n        },\n      ]);\n      console.log(destUserData[0].total);\n\n      return res.json({\n        newSrcBalance: srcAccount.balance,\n        totalDestBalance: destUserData[0].total,\n        transferedAt: new Date(),\n      });\n    } else {\n      return res.status(400).json({\n        error: 'Not enough balance',\n        errorCode: 400,\n      });\n    }", "  } catch (err) {\n    console.log(err);\n    return res.status(400).json({\n      error: 'Transcation failed',\n    });\n  }\n};\n"]}
{"filename": "src/middleware/isLoggedIn.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { NextFunction, Request, Response } from 'express';\nimport jwt from 'jsonwebtoken';\nimport User from '../modules/auth/model';\n\n// Only for rendered pages, no errors!\nexport async function isLoggedIn(req: Request, res: Response, next: NextFunction) {\n  if (req.cookies.jwt) {\n    try {\n      // 1) verify token\n      const decoded: any = await jwt.verify(req.cookies.jwt, process.env.JWT_KEY_SECRET as string);\n\n      // 2) Check if user still exists\n      const currentUser = await User.findById(decoded?.id);", "    try {\n      // 1) verify token\n      const decoded: any = await jwt.verify(req.cookies.jwt, process.env.JWT_KEY_SECRET as string);\n\n      // 2) Check if user still exists\n      const currentUser = await User.findById(decoded?.id);\n      if (!currentUser) {\n        return next();\n      }\n\n      return next();", "    } catch (err) {\n      return next();\n    }\n  }\n  next();\n}\n"]}
{"filename": "src/middleware/protect.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\nimport { JwtPayload, verify } from 'jsonwebtoken';\nimport { AppError } from '../utils/appError';\nimport { catchAsync } from '../utils/catchAsync';\nimport User from '../modules/auth/model';\n\nexport const protect = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n  // 1) Getting token and check of it's there\n  let token;\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    token = req.headers.authorization.split(' ')[1];", "  let token;\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    token = req.headers.authorization.split(' ')[1];\n  } else if (req.cookies.jwt) {\n    token = req.cookies.jwt;\n  }\n  console.log({ token });\n  if (!token) {\n    return next(new AppError('You are not logged in! Please log in to get access.', 401));\n  }\n\n  // 2) Verification token\n  const decoded = (await verify(token, process.env.JWT_KEY_SECRET as string)) as JwtPayload;\n  console.log({ decoded });\n\n  // 3) Check if user still exists\n  const currentUser = await User.findById(decoded.id);", "  if (!currentUser) {\n    return next(new AppError('The user belonging to this token does no longer exist.', 401));\n  }\n\n  // GRANT ACCESS TO PROTECTED ROUTE\n  req.user = currentUser;\n  next();\n});\n"]}
{"filename": "src/middleware/roles.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\nimport { AppError } from '../utils/appError';\nimport { UserPayload } from '../../@types/express';\n\nexport function restrictTo(...roles: string[]) {\n  return (req: Request & { user?: UserPayload }, res: Response, next: NextFunction) => {\n    // roles ['admin', 'user']. role='user'\n\n    if (req?.user) {\n      if (!roles.includes(req.user.role)) {\n        return next(new AppError('You do not have permission to perform this action', 403));\n      }\n    }\n    next();\n  };\n}\n", "    if (req?.user) {\n      if (!roles.includes(req.user.role)) {\n        return next(new AppError('You do not have permission to perform this action', 403));\n      }\n    }\n    next();\n  };\n}\n"]}
{"filename": "src/middleware/ratelimiter.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\nimport moment from 'moment';\nimport { AppError } from '../utils/appError';\nimport redisService from '../utils/redis';\n\nconst WINDOW_SIZE_IN_HOURS = 24;\nconst MAX_WINDOW_REQUEST_COUNT = 20;\nconst WINDOW_LOG_INTERVAL_IN_HOURS = 1;\n\nexport const customRedisRateLimiter = async (req: Request, res: Response, next: NextFunction) => {\n  try {", "\nexport const customRedisRateLimiter = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    if (!redisService) {\n      throw new AppError('Redis client does not exist!', 500);\n    }\n    console.log({ IPAddress: req.ip });\n    const record = await redisService.get(req.ip);\n    const currentRequestTime = moment();\n\n    if (!record) {\n      const newRecord = [{ requestTimeStamp: currentRequestTime.unix(), requestCount: 1 }];\n      await redisService.set({ key: req.ip, value: JSON.stringify(newRecord) });\n      return next();\n    }\n\n    const data = JSON.parse(record);\n    const windowStartTimestamp = moment().subtract(WINDOW_SIZE_IN_HOURS, 'hours').unix();\n    const requestsWithinWindow = data.filter(\n      (entry: { requestTimeStamp: number }) => entry.requestTimeStamp > windowStartTimestamp,\n    );\n    const totalWindowRequestsCount = requestsWithinWindow.reduce(\n      (accumulator: any, entry: { requestCount: any }) => accumulator + entry.requestCount,\n      0,\n    );\n", "    if (!record) {\n      const newRecord = [{ requestTimeStamp: currentRequestTime.unix(), requestCount: 1 }];\n      await redisService.set({ key: req.ip, value: JSON.stringify(newRecord) });\n      return next();\n    }\n\n    const data = JSON.parse(record);\n    const windowStartTimestamp = moment().subtract(WINDOW_SIZE_IN_HOURS, 'hours').unix();\n    const requestsWithinWindow = data.filter(\n      (entry: { requestTimeStamp: number }) => entry.requestTimeStamp > windowStartTimestamp,\n    );\n    const totalWindowRequestsCount = requestsWithinWindow.reduce(\n      (accumulator: any, entry: { requestCount: any }) => accumulator + entry.requestCount,\n      0,\n    );\n", "    if (totalWindowRequestsCount >= MAX_WINDOW_REQUEST_COUNT) {\n      return res.status(429).send({\n        message: `You have exceeded the ${MAX_WINDOW_REQUEST_COUNT} requests in ${WINDOW_SIZE_IN_HOURS} hrs limit!`,\n      });\n    }\n\n    const lastRequestLog = data[data.length - 1];\n    const potentialCurrentWindowIntervalStartTimeStamp = currentRequestTime\n      .subtract(WINDOW_LOG_INTERVAL_IN_HOURS, 'hours')\n      .unix();\n", "    if (lastRequestLog.requestTimeStamp > potentialCurrentWindowIntervalStartTimeStamp) {\n      lastRequestLog.requestCount++;\n      data[data.length - 1] = lastRequestLog;\n    } else {\n      data.push({ requestTimeStamp: currentRequestTime.unix(), requestCount: 1 });\n    }\n\n    await redisService.set({ key: req.ip, value: JSON.stringify(data) });\n    next();\n  } catch (error) {\n    next(error);\n  }\n};\n", "  } catch (error) {\n    next(error);\n  }\n};\n"]}
{"filename": "src/middleware/refresh.ts", "chunked_list": ["import jwt, { JwtPayload } from 'jsonwebtoken';\nimport redisService from '../utils/redis';\nimport { AppError } from '../utils/appError';\nimport { NextFunction, Request, Response } from 'express';\n\nexport const refreshMiddleware: any = async (req: Request, res: Response, next: NextFunction) => {\n  if (req.body?.refresh) {\n    const token = req.body.refresh;\n\n    try {\n      const decoded: any = jwt.verify(token, process.env.JWT_KEY_REFRESH as string) as JwtPayload;\n", "    try {\n      const decoded: any = jwt.verify(token, process.env.JWT_KEY_REFRESH as string) as JwtPayload;\n\n      if (\n        decoded.type !== process.env.JWT_REFRESH ||\n        decoded.aud !== process.env.JWT_AUDIENCE ||\n        decoded.iss !== process.env.JWT_ISSUER\n      ) {\n        next(new AppError('Invalid token type', 401));\n      }\n\n      const value = await redisService.get(token);", "      if (value) {\n        next(new AppError('Refresh token was already used', 401));\n      }\n\n      req.user = {\n        email: decoded.email,\n        name: decoded.name,\n        role: decoded.role,\n        token,\n      };\n      next();\n      return;", "    } catch (err) {\n      console.log({ err });\n      next(new AppError('Invalid token', 401));\n    }\n  }\n  next(new AppError('Refresh token is not present', 400));\n};\n"]}
{"filename": "src/middleware/error.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\nimport { AppError } from '../utils/appError';\n\nconst handleCastErrorDB = (err: any) => {\n  const message = `Invalid ${err.path}: ${err.value}.`;\n  return new AppError(message, 400);\n};\n\nconst handleDuplicateFieldsDB = (err: any) => {\n  const value = err.errmsg.match(/([\"'])(\\\\?.)*?\\1/)[0];", "const handleDuplicateFieldsDB = (err: any) => {\n  const value = err.errmsg.match(/([\"'])(\\\\?.)*?\\1/)[0];\n\n  const message = `Duplicate field value: ${value}. Please use another value!`;\n  return new AppError(message, 400);\n};\n\nconst handleValidationErrorDB = (err: any) => {\n  const errors = Object.values(err.errors).map((el: any) => el.message);\n", "  const errors = Object.values(err.errors).map((el: any) => el.message);\n\n  const message = `Invalid input data. ${errors.join('. ')}`;\n  return new AppError(message, 400);\n};\n\nconst handleJWTError = () => new AppError('Invalid token. Please log in again!', 401);\n\nconst handleJWTExpiredError = () => new AppError('Your token has expired! Please log in again.', 401);\n", "const handleJWTExpiredError = () => new AppError('Your token has expired! Please log in again.', 401);\n\nconst sendErrorDev = (err: any, req: Request, res: Response) => {\n  // A) API\n  return res.status(err.statusCode).json({\n    status: err.status,\n    error: err,\n    message: err.message,\n    stack: err.stack,\n  });", "    stack: err.stack,\n  });\n};\n\nconst sendErrorProd = (err: any, req: Request, res: Response) => {\n  // A) API\n  if (req.originalUrl.startsWith('/api')) {\n    // A) Operational, trusted error: send message to client\n    if (err.isOperational) {\n      return res.status(err.statusCode).json({\n        status: err.status,\n        message: err.message,\n      });\n    }\n    // B) Programming or other unknown error: don't leak error details\n    // 1) Log error\n    console.error('ERROR \ud83d\udca5', err);\n    // 2) Send generic message\n    return res.status(500).json({\n      status: 'error',\n      message: 'Something went very wrong!',\n    });\n  }\n\n  // B) Programming or other unknown error: don't leak error details\n  // 1) Log error\n  console.error('ERROR \ud83d\udca5', err);\n  // 2) Send generic message\n  return res.status(err.statusCode).render('error', {\n    title: 'Something went wrong!',\n    msg: 'Please try again later.',\n  });\n};\n", "    if (err.isOperational) {\n      return res.status(err.statusCode).json({\n        status: err.status,\n        message: err.message,\n      });\n    }\n    // B) Programming or other unknown error: don't leak error details\n    // 1) Log error\n    console.error('ERROR \ud83d\udca5', err);\n    // 2) Send generic message\n    return res.status(500).json({\n      status: 'error',\n      message: 'Something went very wrong!',\n    });\n  }\n\n  // B) Programming or other unknown error: don't leak error details\n  // 1) Log error\n  console.error('ERROR \ud83d\udca5', err);\n  // 2) Send generic message\n  return res.status(err.statusCode).render('error', {\n    title: 'Something went wrong!',\n    msg: 'Please try again later.',\n  });\n};\n", "function globalErrorHandler(err: any, req: Request, res: Response, next: NextFunction) {\n  // console.log(err.stack);\n  err.statusCode = err.statusCode || 500;\n  err.status = err.status || 'error';\n\n  if (process.env.NODE_ENV === undefined) {\n    sendErrorDev(err, req, res);\n  } else if (process.env.NODE_ENV === 'production') {\n    let error = { ...err };\n    error.message = err.message;\n", "    if (error.name === 'CastError') error = handleCastErrorDB(error);\n    if (error.code === 11000) error = handleDuplicateFieldsDB(error);\n    if (error.name === 'ValidationError') error = handleValidationErrorDB(error);\n    if (error.name === 'JsonWebTokenError') error = handleJWTError();\n    if (error.name === 'TokenExpiredError') error = handleJWTExpiredError();\n\n    sendErrorProd(error, req, res);\n  }\n}\n\nexport default globalErrorHandler;\n"]}
{"filename": "src/middleware/index.ts", "chunked_list": ["export { restrictTo } from './roles';\nexport { isLoggedIn } from './isLoggedIn';\nexport { protect } from './protect';\n"]}
