{"filename": "src/main.ts", "chunked_list": ["import { CommandFactory } from 'nest-commander';\nimport { Logger } from 'nestjs-pino';\n\nimport { AppModule } from './app.module';\nimport { AppService } from './app.service';\n\nasync function bootstrap() {\n  const app = await CommandFactory.createWithoutRunning(AppModule, { cliName: 'ssc', logger: false });\n  app.enableShutdownHooks();\n\n  const logger = app.get(Logger);\n  app.useLogger(logger);\n\n  const appService = app.get(AppService);\n  appService.subscribeToShutdown(() => app.close());\n", "  try {\n    await CommandFactory.runApplication(app);\n  } catch (error) {\n    logger.error(error.message);\n    appService.shutdown();\n  }\n}\n\nbootstrap();\n"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { Subject } from 'rxjs';\n\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class AppService implements OnModuleInit {\n  private readonly logger = new Logger(AppService.name);\n  private readonly shutdownListener$: Subject<void> = new Subject();\n\n  private isShuttingDown = false;\n\n  constructor(private readonly configService: ConfigService) {}\n\n  public onModuleInit() {\n    this.initialize();\n  }\n\n  private initialize() {\n    this.catchExceptions();\n    this.setProcessTitle(this.configService.getOrThrow('app.title'));\n  }\n\n  public shutdown() {", "    if (this.isShuttingDown) return;\n    this.isShuttingDown = true;\n    this.shutdownListener$.next();\n  }\n\n  private setProcessTitle(title: string) {\n    if (process.title === title) return;\n    if (process.platform === 'win32') process.title = title;\n    else process.stdout.write(`\\x1b]2;${title}\\x1b\\x5c`);\n  }\n\n  public subscribeToShutdown(shutdownFn: () => void): void {\n    this.shutdownListener$.subscribe(() => shutdownFn());\n  }\n\n  private catchExceptions() {\n    process.on('uncaughtException', (error) => {\n      this.logger.error(new Error('Uncaught exception', { cause: error }));\n      this.shutdown();\n    });\n    process.on('unhandledRejection', (reason) => {\n      this.logger.error(new Error('Unhandled rejection', { cause: reason }));\n      this.shutdown();\n    });\n  }\n}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { CacheModule } from '@nestjs/cache-manager';\nimport { Global, Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\nimport { AppService } from './app.service';\nimport { CommandsModule } from './commands/commands.module';\nimport configuration from './config/configuration';\nimport { LoggerModule } from './modules/logger/logger.module';\n\n@Global()", "\n@Global()\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true, load: [configuration] }),\n    LoggerModule,\n    CacheModule.register(),\n    CommandsModule,\n  ],\n  providers: [AppService],", "  ],\n  providers: [AppService],\n  exports: [AppService],\n})\nexport class AppModule {}\n"]}
{"filename": "src/commands/commands.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { CreateModule } from './create/create-sessions.module';\nimport { ValidateSessionsModule } from './validate/validate-sessions.module';\n\n@Module({\n  imports: [CreateModule, ValidateSessionsModule],\n})\nexport class CommandsModule {}\n", "export class CommandsModule {}\n"]}
{"filename": "src/commands/create/create-sessions.service.ts", "chunked_list": ["import pRetry from 'p-retry';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, OnModuleInit } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\nimport { Account } from '../../interfaces/account.interface';\nimport { Session as ISession } from '../../interfaces/session.interface';\nimport { SteamTokensService } from '../../modules/steam-tokens/steam-tokens.service';\n", "import { SteamTokensService } from '../../modules/steam-tokens/steam-tokens.service';\n\n@Injectable()\nexport class CreateSessionsService implements OnModuleInit {\n  private schemaVersion: number;\n\n  constructor(private readonly steamTokensService: SteamTokensService, private readonly configService: ConfigService) {}\n\n  public onModuleInit() {\n    this.schemaVersion = this.configService.getOrThrow<number>('session.schemaVersion');\n  }\n\n  public async createSession(account: Account) {", "    try {\n      // we need to wait at least 30 seconds between each refresh token creation\n      // because steam has a limit of logins for one account once per 30 seconds\n      // probably it's fair only for accounts with 2FA enabled\n      const delayMs = 1000 * 31;\n\n      const desktopRefreshToken = await this.createRefreshToken(account, 'desktop');\n      await delay(delayMs);\n\n      const webRefreshToken = await this.createRefreshToken(account, 'web');\n      await delay(delayMs);\n\n      const mobileRefreshToken = await this.createRefreshToken(account, 'mobile');\n      await delay(delayMs);\n\n      const steamId = this.getSteamIdFromRefreshToken(webRefreshToken);\n\n      const schemaVersion = this.schemaVersion;\n\n      const session: ISession = {\n        username: account.username,\n        password: account.password,\n        sharedSecret: account.sharedSecret || null,\n        identitySecret: account.identitySecret || null,\n        steamId,\n        webRefreshToken,\n        mobileRefreshToken,\n        desktopRefreshToken,\n        schemaVersion,\n      };\n\n      return session;", "    } catch (error) {\n      throw new Error('Failed to create session', { cause: error });\n    }\n  }\n\n  private async createRefreshToken(account: Account, platform: 'web' | 'mobile' | 'desktop') {\n    try {\n      return await pRetry(() => this.steamTokensService.createRefreshToken(account, platform), {\n        retries: 3,\n        minTimeout: 31000,\n        maxTimeout: 31000,\n      });", "    } catch (error) {\n      throw new Error('Failed to create refresh token', { cause: error });\n    }\n  }\n\n  private getSteamIdFromRefreshToken(token: string) {\n    try {\n      const { sub: steamId } = this.steamTokensService.decodeRefreshToken(token);\n      if (!steamId) throw new Error('SteamId is missing from refresh token');\n      return steamId;\n    } catch (error) {\n      throw new Error('Failed to get steamId from refresh token', { cause: error });\n    }\n  }\n}\n", "      if (!steamId) throw new Error('SteamId is missing from refresh token');\n      return steamId;\n    } catch (error) {\n      throw new Error('Failed to get steamId from refresh token', { cause: error });\n    }\n  }\n}\n"]}
{"filename": "src/commands/create/create-sessions.command.ts", "chunked_list": ["import glob from 'fast-glob';\nimport { CliUtilityService, Command, CommandRunner, Help, Option } from 'nest-commander';\nimport pQueue from 'p-queue';\nimport path from 'path';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Logger } from '@nestjs/common';\n\nimport { AccountsImportService } from '../../modules/accounts-import/accounts-import.service';\nimport { ExportSessionsService } from '../../modules/export-sessions/export-sessions.service';", "import { AccountsImportService } from '../../modules/accounts-import/accounts-import.service';\nimport { ExportSessionsService } from '../../modules/export-sessions/export-sessions.service';\nimport { ProxiesImportService } from '../../modules/proxies-import/proxies-import.service';\nimport { ProxiesService } from '../../modules/proxies/proxies.service';\nimport { SecretsImportService } from '../../modules/secrets-import/secrets-import.service';\nimport { CreateSessionsService } from './create-sessions.service';\n\ninterface CreateCommandOptions {\n  accounts: string | string[];\n  secrets: string | string[];\n  proxies: string | string[];\n  concurrency: number;\n  output: string;\n  overwrite: boolean;\n}\n\n@Command({\n  name: 'create',\n  description: 'Creates new sessions',\n})", "export class CreateSessionsCommand extends CommandRunner {\n  private readonly logger = new Logger(CreateSessionsCommand.name);\n\n  constructor(\n    private readonly createSessionsService: CreateSessionsService,\n    private readonly exportSessionsService: ExportSessionsService,\n    private readonly accountsImportService: AccountsImportService,\n    private readonly secretsImportService: SecretsImportService,\n    private readonly proxiesImportService: ProxiesImportService,\n    private readonly proxiesService: ProxiesService,\n  ) {\n    super();\n  }\n\n  public async run(args: string[], options: CreateCommandOptions) {", "    try {\n      const accountsOptionInput = await this.normalizeInput(options.accounts);\n      let accounts = await this.accountsImportService.loadAccounts(accountsOptionInput);\n      if (accounts.length === 0) throw new Error('No accounts found');\n      this.logger.log(`Accounts: ${accounts.length}`);\n\n      const secretsOptionInput = await this.normalizeInput(options.secrets);\n      const secrets = await this.secretsImportService.loadSecrets(secretsOptionInput);\n      this.logger.log(`Secrets: ${secrets.length}`);\n\n      const outputOptionInput = options.output;", "      if (!outputOptionInput) throw new Error('Output path is required');\n      const output = path.resolve(outputOptionInput);\n      await this.exportSessionsService.setOutputPath(output);\n      this.logger.log(`Output: ${output}`);\n\n      const overwriteExistingSessions = options.overwrite;\n      if (!overwriteExistingSessions) {\n        const sessionsPaths = await this.normalizeInput(`${output}/*`);\n        const existingSessions = await this.accountsImportService.loadAccounts(sessionsPaths);\n        this.logger.log(`Ignoring existing sessions: ${existingSessions.length}`);\n        accounts = accounts.filter((account) => !existingSessions.some((a) => a.username === account.username));\n      }\n", "      if (accounts.length === 0) {\n        this.logger.log('No accounts to create');\n        return;\n      }\n\n      const proxiesOptionInput = await this.normalizeInput(options.proxies);\n      const proxies = await this.proxiesImportService.loadProxies(proxiesOptionInput);\n      this.proxiesService.setProxies(proxies);\n      this.logger.log(`Proxies: ${proxies.length}`);\n\n      const concurrencyOptionInput = options.concurrency;\n      const concurrency = proxies.length > 0 ? concurrencyOptionInput || Math.min(proxies.length * 3, 100) : 1;\n      this.logger.log(`Concurrency: ${concurrency}`);\n\n      this.logger.log(`Starting to create sessions for ${accounts.length} accounts`);\n\n      this.accountsImportService.assignSecretsToAccounts(accounts, secrets);\n\n      let success = 0;\n      let fails = 0;\n      let left = accounts.length;\n\n      const queue = new pQueue({ concurrency, interval: 10, intervalCap: 1 });", "      for (const account of accounts) {\n        queue.add(async () => {\n          try {\n            const session = await this.createSessionsService.createSession(account);\n            await this.exportSessionsService.exportSession(session);\n            success++;\n            this.logger.log(`Success: ${account.username}, left: ${--left}`);\n          } catch (error) {\n            fails++;\n            this.logger.warn(`Fail: ${account.username}, left: ${--left}`);\n          }\n        });\n      }\n\n      await queue.onIdle();\n\n      this.logger.log(`Session creation complete`);\n      this.logger.log(`Success: ${success}`);\n      this.logger.log(`Fails: ${fails}`);\n\n      await delay(1000);", "    } catch (error) {\n      this.logger.error(error.message);\n    }\n  }\n\n  private async normalizeInput(input: string | string[]) {\n    if (!input) return [];\n\n    if (!Array.isArray(input)) input = [input];\n\n    const filteredInput = input.filter((el) => typeof el === 'string' && el.trim() !== '');", "    if (!Array.isArray(input)) input = [input];\n\n    const filteredInput = input.filter((el) => typeof el === 'string' && el.trim() !== '');\n    if (filteredInput.length === 0) return [];\n\n    const nestedData = await Promise.all(\n      filteredInput.map(async (el) => {\n        el = el.trim();\n\n        // Possible glob pattern\n        const files = await glob(el);", "        if (files.length > 0) return files;\n\n        // Possible string\n        return el.split(/\\s+|\\r?\\n/).map((line) => line.trim());\n      }),\n    );\n\n    return nestedData.flat();\n  }\n\n  @Option({\n    required: true,\n    flags: '-a, --accounts <accounts...>',\n    description: `Specify one or more accounts.\nAccount can be specified as:\n- A simple string.\n- A file path to load accounts from (one account per line).\n- A glob pattern to load accounts from multiple files.\nSupported formats:\n- username:password\n- username:password:sharedSecret\n- username:password:sharedSecret:identitySecret\n- ASF json`,\n  })\n  private parseAccountsOption(val: string, accumulator: string[] = []) {\n    accumulator.push(val);\n    return accumulator;\n  }\n\n  @Option({\n    flags: '-s, --secrets <secrets...>',\n    description: `Specify one or more secrets.\nSecret can be specified as:\n- A file path to load secrets from file.\n- A glob pattern to load secrets from multiple files.\nSupported formats:\n- maFile\n- ASF db`,\n  })\n  private parseSecretsOption(val: string, accumulator: string[] = []) {\n    accumulator.push(val);\n    return accumulator;\n  }\n\n  @Option({\n    flags: '-p, --proxies <proxies...>',\n    description: `Specify one or more proxies.\nProxy can be specified as:\n- A string in the format <protocol>://<username>:<password>@<host>:<port>.\n- A file path to load proxies from a text file.\nSupported protocols:\n- http\n- https`,\n  })\n  private parseProxiesOption(val: string, accumulator: string[] = []) {\n    accumulator.push(val);\n    return accumulator;\n  }\n\n  @Option({\n    flags: '-c, --concurrency <concurrency>',\n    description: `Specify the number of concurrent runs.\nDefault: 1, or the number of proxies.`,\n  })\n  private parseConcurrencyOption(val: string) {\n    const parsed = parseInt(val, 10);", "    if (Number.isNaN(parsed)) throw new Error('Concurrency must be a number');\n    if (parsed < 1) throw new Error('Concurrency must be greater than 0');\n    return parsed;\n  }\n\n  @Option({\n    flags: '-o, --output <output>',\n    description: 'Specify the output directory.',\n    defaultValue: './sessions',\n  })\n  private parseOutputOption(val: string) {\n    return val;\n  }\n\n  @Option({\n    flags: '--overwrite (-w)',\n    description: 'Overwrite existing sessions.',\n    defaultValue: false,\n  })\n  private parseOverwriteOption(val: string) {\n    return new CliUtilityService().parseBoolean(val);\n  }\n\n  @Help('afterAll')\n  private displayExamples() {\n    return `\nExamples:\n  create -a accounts.txt -s ./secrets -p proxies.txt\n  create -a username:password -p proxies.txt`;\n  }\n}\n"]}
{"filename": "src/commands/create/create-sessions.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { AccountsImportModule } from '../../modules/accounts-import/accounts-import.module';\nimport { ExportSessionsModule } from '../../modules/export-sessions/export-sessions.module';\nimport { ProxiesImportModule } from '../../modules/proxies-import/proxies-import.module';\nimport { ProxiesModule } from '../../modules/proxies/proxies.module';\nimport { SecretsImportModule } from '../../modules/secrets-import/secrets-import.module';\nimport { SteamTokensModule } from '../../modules/steam-tokens/steam-tokens.module';\nimport { CreateSessionsCommand } from './create-sessions.command';\nimport { CreateSessionsService } from './create-sessions.service';", "import { CreateSessionsCommand } from './create-sessions.command';\nimport { CreateSessionsService } from './create-sessions.service';\n\n@Module({\n  imports: [\n    AccountsImportModule,\n    SecretsImportModule,\n    ProxiesImportModule,\n    ExportSessionsModule,\n    ProxiesModule,", "    ExportSessionsModule,\n    ProxiesModule,\n    SteamTokensModule,\n  ],\n  providers: [CreateSessionsCommand, CreateSessionsService],\n})\nexport class CreateModule {}\n"]}
{"filename": "src/commands/validate/validate-sessions.command.ts", "chunked_list": ["import glob from 'fast-glob';\nimport { Command, CommandRunner, Help, Option } from 'nest-commander';\n\nimport { Logger } from '@nestjs/common';\n\nimport { SessionsImportService } from '../../modules/sessions-import/sessions-import.service';\nimport { ValidateSessionsService } from './validate-sessions.service';\n\ninterface ValidateCommandOptions {\n  sessions: string | string[];\n}\n\n@Command({\n  name: 'validate',\n  description: 'Validates sessions',\n})", "interface ValidateCommandOptions {\n  sessions: string | string[];\n}\n\n@Command({\n  name: 'validate',\n  description: 'Validates sessions',\n})\nexport class ValidateSessionsCommand extends CommandRunner {\n  private readonly logger = new Logger(ValidateSessionsCommand.name);\n\n  constructor(\n    private readonly sessionsImportService: SessionsImportService,\n    private readonly validateSessionsService: ValidateSessionsService,\n  ) {\n    super();\n  }\n\n  public async run(args: string[], options: ValidateCommandOptions) {", "export class ValidateSessionsCommand extends CommandRunner {\n  private readonly logger = new Logger(ValidateSessionsCommand.name);\n\n  constructor(\n    private readonly sessionsImportService: SessionsImportService,\n    private readonly validateSessionsService: ValidateSessionsService,\n  ) {\n    super();\n  }\n\n  public async run(args: string[], options: ValidateCommandOptions) {", "    try {\n      const sessionsOptionInput = await this.normalizeInput(options.sessions);\n      const sessions = await this.sessionsImportService.loadSessions(sessionsOptionInput);\n      if (sessions.length === 0) throw new Error('No sessions found');\n      this.logger.log(`Sessions: ${sessions.length}`);\n\n      await this.validateSessionsService.validateSessions(sessions);\n    } catch (error) {\n      this.logger.error(error.message);\n    }\n  }\n\n  private async normalizeInput(input: string | string[]) {", "    if (!input) return [];\n\n    if (!Array.isArray(input)) input = [input];\n\n    const filteredInput = input.filter((el) => typeof el === 'string' && el.trim() !== '');\n    if (filteredInput.length === 0) return [];\n\n    const nestedData = await Promise.all(\n      filteredInput.map(async (el) => {\n        el = el.trim();\n\n        // Possible glob pattern\n        const files = await glob(el);", "        if (files.length > 0) return files;\n\n        // Possible string\n        return el.split(/\\s+|\\r?\\n/).map((line) => line.trim());\n      }),\n    );\n\n    return nestedData.flat();\n  }\n\n  @Option({\n    flags: '-s, --sessions <sessions...>',\n    description: `Specify one or more sessions.\nSession can be specified as:\n- A file path to load session from.\n- A glob pattern to load sessions from multiple files.`,\n  })\n  private parseSessionsOption(val: string, accumulator: string[] = []) {\n    accumulator.push(val);\n    return accumulator;\n  }\n\n  @Help('afterAll')\n  private displayHelp() {\n    return `\nExamples:\n  validate -s example.steamsession\n  validate -s sessions/*.steamsession`;\n  }\n}\n"]}
{"filename": "src/commands/validate/validate-sessions.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { SessionsImportModule } from '../../modules/sessions-import/sessions-import.module';\nimport { SteamTokensModule } from '../../modules/steam-tokens/steam-tokens.module';\nimport { ValidateSessionsCommand } from './validate-sessions.command';\nimport { ValidateSessionsService } from './validate-sessions.service';\n\n@Module({\n  imports: [SessionsImportModule, SteamTokensModule],\n  providers: [ValidateSessionsCommand, ValidateSessionsService],", "  imports: [SessionsImportModule, SteamTokensModule],\n  providers: [ValidateSessionsCommand, ValidateSessionsService],\n})\nexport class ValidateSessionsModule {}\n"]}
{"filename": "src/commands/validate/validate-sessions.service.ts", "chunked_list": ["import { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\nimport { Session } from '../../interfaces/session.interface';\nimport { SteamTokensService } from '../../modules/steam-tokens/steam-tokens.service';\n\n@Injectable()\nexport class ValidateSessionsService {\n  private readonly logger = new Logger(ValidateSessionsService.name);\n\n  constructor(private readonly steamTokensService: SteamTokensService, private readonly configService: ConfigService) {}\n\n  public async validateSessions(sessions: Session[]) {\n    const valid: Session[] = [];\n    const invalid: Session[] = [];\n", "@Injectable()\nexport class ValidateSessionsService {\n  private readonly logger = new Logger(ValidateSessionsService.name);\n\n  constructor(private readonly steamTokensService: SteamTokensService, private readonly configService: ConfigService) {}\n\n  public async validateSessions(sessions: Session[]) {\n    const valid: Session[] = [];\n    const invalid: Session[] = [];\n\n    for (const session of sessions) {\n      const { valid: isValid, errors, expires } = await this.validateSession(session);", "    for (const session of sessions) {\n      const { valid: isValid, errors, expires } = await this.validateSession(session);\n      if (isValid) {\n        valid.push(session);\n        this.logger.log(\n          `Valid: ${session.username}, days: ${Math.floor((expires - Date.now()) / (24 * 60 * 60 * 1000))}`,\n        );\n      } else {\n        invalid.push(session);\n        this.logger.warn(`Invalid: ${session.username}, errors: ${errors.join(', ')}`);\n      }\n    }\n", "    if (invalid.length > 0) {\n      this.logger.warn(`Invalid sessions:\\n${invalid.map((session) => session.username).join('\\n')}`);\n    }\n\n    await delay(1000);\n  }\n\n  private async validateSession(session: Session) {\n    const errors: string[] = [];\n    let expires = Date.now();\n", "    if (!session) errors.push('Invalid session');\n\n    if (session.schemaVersion !== this.configService.getOrThrow<number>('session.schemaVersion')) {\n      errors.push('Outdated schema version');\n    }\n\n    if (!session.username) errors.push('Invalid username');\n    if (!session.password) errors.push('Invalid password');\n    if (!session.steamId) errors.push('Invalid steamId');\n\n    if (!session.hasOwnProperty('sharedSecret')) errors.push('Invalid shared Secret');", "    if (!session.steamId) errors.push('Invalid steamId');\n\n    if (!session.hasOwnProperty('sharedSecret')) errors.push('Invalid shared Secret');\n    if (!session.hasOwnProperty('identitySecret')) errors.push('Invalid identity Secret');\n\n    if (session.desktopRefreshToken) {\n      if (!this.steamTokensService.validateRefreshToken(session.desktopRefreshToken)) {\n        errors.push('Invalid desktop refresh token');\n      }\n      const tokenExpiration = this.steamTokensService.getRefreshTokenExpiration(session.desktopRefreshToken);\n      if (tokenExpiration > expires) expires = tokenExpiration;\n    }\n", "      if (tokenExpiration > expires) expires = tokenExpiration;\n    }\n\n    if (session.mobileRefreshToken) {\n      if (!this.steamTokensService.validateRefreshToken(session.mobileRefreshToken)) {\n        errors.push('Invalid mobile refresh token');\n      }\n      const tokenExpiration = this.steamTokensService.getRefreshTokenExpiration(session.mobileRefreshToken);\n      if (tokenExpiration > expires) expires = tokenExpiration;\n    }\n", "      if (tokenExpiration > expires) expires = tokenExpiration;\n    }\n\n    if (session.webRefreshToken) {\n      if (!this.steamTokensService.validateRefreshToken(session.webRefreshToken)) {\n        errors.push('Invalid web refresh token');\n      }\n      const tokenExpiration = this.steamTokensService.getRefreshTokenExpiration(session.webRefreshToken);\n      if (tokenExpiration > expires) expires = tokenExpiration;\n    }\n", "      if (tokenExpiration > expires) expires = tokenExpiration;\n    }\n\n    if (expires < Date.now()) errors.push('Expired session');\n\n    return { valid: errors.length === 0, errors, expires };\n  }\n}\n"]}
{"filename": "src/config/configuration.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\n\nexport interface Config {\n  app: {\n    name: string;\n    version: string;\n    title: string;\n    directory: string;\n    environment: 'development' | 'production';\n  };\n  session: {\n    schemaVersion: number;\n  };\n}\n\nconst getPackageJson = (): any => {", "  try {\n    let filePath = path.resolve(__dirname, '../package.json');\n    if (fs.existsSync(filePath)) return JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\n    filePath = path.resolve(__dirname, '../../package.json');\n    if (fs.existsSync(filePath)) return JSON.parse(fs.readFileSync(filePath, 'utf8'));\n  } catch (error) {\n    throw new Error('Failed to read package.json');\n  }\n};\n\nexport default (): Config => {\n  const packageJson = getPackageJson();\n\n  const appName = packageJson.name;\n  const appVersion = packageJson.version;\n\n  const env = process.env.NODE_ENV || (<any>process).pkg ? 'production' : 'development';\n  const appDirectory = env === 'production' && (<any>process).pkg ? path.dirname(process.execPath) : process.cwd();\n\n  return {\n    app: {\n      name: appName,\n      title: appName,\n      version: appVersion,\n      directory: appDirectory,\n      environment: env,\n    },\n    session: {\n      schemaVersion: 2,\n    },\n  };\n};\n"]}
{"filename": "src/interfaces/proxy.interface.ts", "chunked_list": ["export interface Proxy {\n  host: string;\n  port: number;\n  protocol: string;\n  auth?: {\n    username: string;\n    password: string;\n  };\n  toString(): string;\n}\n"]}
{"filename": "src/interfaces/account.interface.ts", "chunked_list": ["export interface Account {\n  username: string;\n  password: string;\n  sharedSecret: string | null;\n  identitySecret: string | null;\n}\n"]}
{"filename": "src/interfaces/session.interface.ts", "chunked_list": ["export interface Session {\n  username: string;\n  password: string;\n  steamId: string;\n  webRefreshToken: string;\n  mobileRefreshToken: string;\n  desktopRefreshToken: string;\n  sharedSecret: string | null;\n  identitySecret: string | null;\n  schemaVersion: number;\n}\n"]}
{"filename": "src/interfaces/secrets.interface.ts", "chunked_list": ["export interface Secrets {\n  username: string;\n  sharedSecret: string;\n  identitySecret: string;\n}\n"]}
{"filename": "src/modules/proxies-import/proxies-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { ProxiesImportService } from './proxies-import.service';\n\n@Module({\n  providers: [ProxiesImportService],\n  exports: [ProxiesImportService],\n})\nexport class ProxiesImportModule {}\n", "export class ProxiesImportModule {}\n"]}
{"filename": "src/modules/proxies-import/proxies-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\nimport inquirer from 'inquirer';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, Logger } from '@nestjs/common';\n\nimport { Proxy as IProxy } from '../../interfaces/proxy.interface';\n\nclass Proxy implements IProxy {\n  public readonly host: string;\n  public readonly port: number;\n  public readonly protocol: string;\n  public readonly auth?: { username: string; password: string };\n\n  constructor(proxy: string) {", "class Proxy implements IProxy {\n  public readonly host: string;\n  public readonly port: number;\n  public readonly protocol: string;\n  public readonly auth?: { username: string; password: string };\n\n  constructor(proxy: string) {\n    if (!/^(https?|socks5?):\\/\\/([-\\w:@.^&]+)$/.test(proxy)) throw new Error('Invalid proxy');\n\n    const url = new URL(proxy);\n\n    this.host = url.hostname;\n    this.port = Number(url.port);\n    this.protocol = url.protocol.replace(/:$/, '');\n", "    if (url.username.length > 0 && url.password.length > 0) {\n      this.auth = { username: url.username, password: url.password };\n    }\n  }\n\n  public toString() {\n    return this.auth\n      ? `${this.protocol}://${this.auth.username}:${this.auth.password}@${this.host}:${this.port}`\n      : `${this.protocol}://${this.host}:${this.port}`;\n  }\n}\n\n@Injectable()", "export class ProxiesImportService {\n  private readonly logger = new Logger(ProxiesImportService.name);\n\n  public async loadProxies(input: string[] | string) {\n    if (!input) return [];\n    if (!Array.isArray(input)) input = [input];\n    if (input.length === 0) return [];\n    let proxies: Proxy[] = [];\n    const errors: string[] = [];\n\n    const readResults = await Promise.all(input.map((input) => this.readProxyFromInput(input)));", "    for (const result of readResults) {\n      proxies.push(...result.values);\n      errors.push(...result.errors);\n    }\n\n    proxies = this.removeDuplicates(proxies);\n\n    if (errors.length > 0) {\n      this.logger.warn(`The following proxy sources are invalid:\\n${errors.join('\\n')}`);\n      await delay(1000);\n\n      const { confirm } = await inquirer.prompt({\n        type: 'confirm',\n        name: 'confirm',\n        message: proxies.length > 0 ? `Continue with ${proxies.length} valid proxies ?` : 'Continue without proxies ?',\n        default: false,\n      });\n", "      if (!confirm) throw new Error('Aborted by user');\n    }\n\n    return proxies;\n  }\n\n  private removeDuplicates(proxies: Proxy[]) {\n    const map = new Map<string, Proxy>();\n    for (const proxy of proxies) map.set(proxy.toString(), proxy);\n    return [...map.values()];\n  }\n\n  private async readProxyFromInput(input: string) {\n    const inputType = await this.inferInputType(input);", "    for (const proxy of proxies) map.set(proxy.toString(), proxy);\n    return [...map.values()];\n  }\n\n  private async readProxyFromInput(input: string) {\n    const inputType = await this.inferInputType(input);\n    if (inputType === 'file') return await this.readProxyFromFile(input);\n    if (inputType === 'string') return this.readProxyFromString(input);\n    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private readProxyFromString(str: string) {\n    const result: { values: Proxy[]; errors: string[] } = { values: [], errors: [] };\n", "    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private readProxyFromString(str: string) {\n    const result: { values: Proxy[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      const proxy = new Proxy(str);\n      result.values.push(proxy);\n    } catch (error) {\n      result.errors.push(str);\n    }\n\n    return result;\n  }\n\n  private async readProxyFromFile(path: string) {\n    const result: { values: Proxy[]; errors: string[] } = { values: [], errors: [] };\n", "    } catch (error) {\n      result.errors.push(str);\n    }\n\n    return result;\n  }\n\n  private async readProxyFromFile(path: string) {\n    const result: { values: Proxy[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      const file = await fs.readFile(path, 'utf8');\n\n      const lines = file\n        .split(/\\s+|\\r?\\n/)\n        .map((line) => line.trim())\n        .filter((line) => line.length > 0);\n", "    try {\n      const file = await fs.readFile(path, 'utf8');\n\n      const lines = file\n        .split(/\\s+|\\r?\\n/)\n        .map((line) => line.trim())\n        .filter((line) => line.length > 0);\n\n      if (lines.length === 0) throw new Error(`File '${path}' is empty`);\n\n      for (const line of lines) {\n        const { values, errors } = this.readProxyFromString(line);\n        result.values.push(...values);\n        result.errors.push(...errors);\n      }", "      if (lines.length === 0) throw new Error(`File '${path}' is empty`);\n\n      for (const line of lines) {\n        const { values, errors } = this.readProxyFromString(line);\n        result.values.push(...values);\n        result.errors.push(...errors);\n      }\n    } catch (error) {\n      result.errors.push(path);\n    }\n\n    return result;\n  }\n\n  private async inferInputType(input: string) {", "    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\n    try {\n      const stats = await fs.stat(input);\n      if (stats.isFile()) return 'file';\n      if (stats.isDirectory()) return 'directory';\n    } catch (error) {\n      return 'string';\n    }\n  }\n}\n"]}
{"filename": "src/modules/export-sessions/export-sessions.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { ExportSessionsService } from './export-sessions.service';\n\n@Module({\n  providers: [ExportSessionsService],\n  exports: [ExportSessionsService],\n})\nexport class ExportSessionsModule {}\n", "export class ExportSessionsModule {}\n"]}
{"filename": "src/modules/export-sessions/export-sessions.service.ts", "chunked_list": ["import fs from 'fs/promises';\nimport path from 'path';\n\nimport { Injectable } from '@nestjs/common';\n\nimport { Session } from '../../interfaces/session.interface';\n\n@Injectable()\nexport class ExportSessionsService {\n  private readonly fileExtension = 'steamsession';\n  private outputPath = './output';\n\n  public async setOutputPath(directory: string) {", "export class ExportSessionsService {\n  private readonly fileExtension = 'steamsession';\n  private outputPath = './output';\n\n  public async setOutputPath(directory: string) {\n    if (directory === this.outputPath) return;\n    if (!directory || typeof directory !== 'string') throw new Error('Invalid output path');\n    if (!path.isAbsolute(directory)) throw new Error('Output path must be absolute');\n\n    try {\n      await fs.mkdir(directory, { recursive: true });", "    try {\n      await fs.mkdir(directory, { recursive: true });\n    } catch (error) {\n      throw new Error('Failed to create output directory', { cause: error });\n    }\n\n    this.outputPath = directory;\n  }\n\n  public async exportSession(session: Session) {\n    const serializedSession = this.serializeSession(session);\n    const sessionPath = path.resolve(this.outputPath, `${session.username}.${this.fileExtension}`);\n", "    try {\n      await fs.writeFile(sessionPath, serializedSession);\n    } catch (error) {\n      throw new Error('Failed to write session to file', { cause: error });\n    }\n  }\n\n  private serializeSession(session: Session) {\n    const serializedObject = Object.fromEntries(\n      Object.entries(session).map(([key, value]) => {\n        key = key[0].toUpperCase() + key.slice(1);\n        value = value || null;\n        return [key, value];\n      }),\n    );\n\n    const serializedString = JSON.stringify(serializedObject, null, 2);\n\n    return serializedString;\n  }\n}\n"]}
{"filename": "src/modules/steam-tokens/steam-tokens.service.ts", "chunked_list": ["import { Cache } from 'cache-manager';\nimport pEvent from 'p-event';\nimport { EAuthTokenPlatformType, EResult, LoginSession } from 'steam-session';\nimport SteamTotp from 'steam-totp';\n\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Inject, Injectable } from '@nestjs/common';\n\nimport { Account } from '../../interfaces/account.interface';\nimport { ProxiesService } from '../proxies/proxies.service';", "import { Account } from '../../interfaces/account.interface';\nimport { ProxiesService } from '../proxies/proxies.service';\n\n@Injectable()\nexport class SteamTokensService {\n  private readonly connectionThrottlingTimeout = 31 * 1000;\n\n  constructor(\n    @Inject(CACHE_MANAGER) private throttledConnections: Cache,\n    private readonly proxiesService: ProxiesService,\n  ) {}\n\n  public async createRefreshToken(account: Account, platform: 'web' | 'mobile' | 'desktop') {\n    const loginSessionPlatform = this.inferLoginSessionPlatform(platform);\n\n    const proxy = await this.proxiesService.getProxy();\n\n    const connectionId = this.inferConnectionId((proxy || '').toString());\n    await this.waitConnectionLimitReset(connectionId);\n    this.throttleConnection(connectionId, this.connectionThrottlingTimeout);\n\n    const loginSessionOptions = {};", "    if (proxy) loginSessionOptions[proxy.protocol.includes('socks') ? 'socksProxy' : 'httpProxy'] = proxy.toString();\n\n    const loginSession = new LoginSession(loginSessionPlatform, loginSessionOptions);\n    loginSession.on('error', () => {}); // fallback errors handling\n\n    try {\n      const credentials = { accountName: account.username, password: account.password } as any;\n      if (account.sharedSecret) credentials.steamGuardCode = SteamTotp.getAuthCode(account.sharedSecret);\n\n      loginSession\n        .startWithCredentials(credentials)\n        .then((result) => result.actionRequired && loginSession.emit('error', new Error('Guard action required')))", "        .catch((error) => loginSession.emit('error', error));\n\n      await pEvent(loginSession, 'authenticated', { rejectionEvents: ['error', 'timeout'], timeout: 35000 });\n\n      const refreshToken = loginSession.refreshToken;\n      if (!refreshToken) throw new Error('Refresh token is empty');\n\n      return refreshToken;\n    } catch (error) {\n      if (error.eresult === EResult.RateLimitExceeded) this.throttleConnection(connectionId, 31 * 60 * 1000);\n      throw new Error('Failed to create refresh token', { cause: error });", "    } catch (error) {\n      if (error.eresult === EResult.RateLimitExceeded) this.throttleConnection(connectionId, 31 * 60 * 1000);\n      throw new Error('Failed to create refresh token', { cause: error });\n    } finally {\n      if (loginSession) loginSession.cancelLoginAttempt();\n    }\n  }\n\n  public decodeRefreshToken(token: string) {\n    try {\n      const parts = token.split('.');", "    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) throw new Error('Invalid token');\n\n      const headerBase64Url = parts[1];\n      const headerBase64 = headerBase64Url.replace(/-/g, '+').replace(/_/g, '/');\n      const headerJson = Buffer.from(headerBase64, 'base64').toString('utf-8');\n      return JSON.parse(headerJson);\n    } catch (error) {\n      throw new Error('An error occurred while decoding refresh token', { cause: error });\n    }\n  }\n\n  public validateRefreshToken(token: string) {", "    } catch (error) {\n      throw new Error('An error occurred while decoding refresh token', { cause: error });\n    }\n  }\n\n  public validateRefreshToken(token: string) {\n    try {\n      const { iss, sub, exp, aud } = this.decodeRefreshToken(token);\n      if (!iss || !sub || !exp || !aud) return false;\n\n      if (iss !== 'steam') return false;", "      if (!iss || !sub || !exp || !aud) return false;\n\n      if (iss !== 'steam') return false;\n      if (exp < Math.floor(Date.now() / 1000)) return false;\n      if (!aud.includes('renew')) return false;\n\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  public getRefreshTokenExpiration(token: string) {", "    try {\n      const { exp } = this.decodeRefreshToken(token);\n      return exp * 1000;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  private inferLoginSessionPlatform(platform: 'web' | 'mobile' | 'desktop'): EAuthTokenPlatformType {\n    if (platform === 'web') return EAuthTokenPlatformType.WebBrowser;\n    else if (platform === 'mobile') return EAuthTokenPlatformType.MobileApp;", "    if (platform === 'web') return EAuthTokenPlatformType.WebBrowser;\n    else if (platform === 'mobile') return EAuthTokenPlatformType.MobileApp;\n    else if (platform === 'desktop') return EAuthTokenPlatformType.SteamClient;\n    else throw new Error('Invalid platform');\n  }\n\n  private inferConnectionId(id?: string) {\n    return `${SteamTokensService.name}:${id || 'localhost'}`;\n  }\n\n  private throttleConnection(connectionId: string, timeoutMs: number) {\n    connectionId = this.inferConnectionId(connectionId);\n\n    this.throttledConnections.set(connectionId, true, timeoutMs);", "    if (this.inferConnectionId() !== connectionId) this.proxiesService.throttleProxy(connectionId, timeoutMs);\n  }\n\n  private async waitConnectionLimitReset(connectionId: string) {\n    connectionId = this.inferConnectionId(connectionId);\n\n    const execute = () => {\n      if (this.throttledConnections.get(connectionId)) return false;\n      this.throttleConnection(connectionId, 1000);\n      return true;\n    };\n", "    if (execute()) return;\n\n    return new Promise<void>((resolve) => {\n      const interval = setInterval(() => {\n        if (!execute()) return;\n        clearInterval(interval);\n        resolve();\n      }, 1000);\n    });\n  }\n}\n"]}
{"filename": "src/modules/steam-tokens/steam-tokens.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { ProxiesModule } from '../proxies/proxies.module';\nimport { SteamTokensService } from './steam-tokens.service';\n\n@Module({\n  imports: [ProxiesModule],\n  providers: [SteamTokensService],\n  exports: [SteamTokensService],\n})\nexport class SteamTokensModule {}\n", "  exports: [SteamTokensService],\n})\nexport class SteamTokensModule {}\n"]}
{"filename": "src/modules/proxies/proxies.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { ProxiesService } from './proxies.service';\n\n@Module({\n  providers: [ProxiesService],\n  exports: [ProxiesService],\n})\nexport class ProxiesModule {}\n", "export class ProxiesModule {}\n"]}
{"filename": "src/modules/proxies/proxies.service.ts", "chunked_list": ["import { Cache } from 'cache-manager';\nimport pQueue from 'p-queue';\n\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Inject, Injectable } from '@nestjs/common';\n\nimport { Proxy } from '../../interfaces/proxy.interface';\n\n@Injectable()\nexport class ProxiesService {\n  private readonly proxies: Map<string, Proxy> = new Map();\n  private readonly proxiesUsageQueue = new pQueue({ concurrency: 1 });\n\n  constructor(@Inject(CACHE_MANAGER) private throttledProxies: Cache) {}\n\n  public setProxies(proxies: Proxy[]) {", "@Injectable()\nexport class ProxiesService {\n  private readonly proxies: Map<string, Proxy> = new Map();\n  private readonly proxiesUsageQueue = new pQueue({ concurrency: 1 });\n\n  constructor(@Inject(CACHE_MANAGER) private throttledProxies: Cache) {}\n\n  public setProxies(proxies: Proxy[]) {\n    if (proxies.length === 0) return;\n\n    for (const proxy of proxies) {\n      this.proxies.set(proxy.toString(), proxy);\n    }\n  }\n\n  public async getProxy(): Promise<Proxy | null> {", "    if (proxies.length === 0) return;\n\n    for (const proxy of proxies) {\n      this.proxies.set(proxy.toString(), proxy);\n    }\n  }\n\n  public async getProxy(): Promise<Proxy | null> {\n    if (this.proxies.size === 0) return null;\n    const proxy = await this.proxiesUsageQueue.add(() => this.fetchProxy());\n    this.throttleProxy(proxy);\n    return proxy;\n  }\n\n  public getProxiesCount() {\n    return this.proxies.size;\n  }\n\n  public throttleProxy(proxy: Proxy | string, timeoutMs?: number) {\n    const proxyId = this.getProxyId(proxy);\n    this.throttledProxies.set(proxyId, true, timeoutMs);\n  }\n\n  private async fetchProxy() {\n    const proxy = await new Promise<Proxy>((resolve) => {\n      let proxy = this.findAvailableProxy();", "    if (this.proxies.size === 0) return null;\n    const proxy = await this.proxiesUsageQueue.add(() => this.fetchProxy());\n    this.throttleProxy(proxy);\n    return proxy;\n  }\n\n  public getProxiesCount() {\n    return this.proxies.size;\n  }\n\n  public throttleProxy(proxy: Proxy | string, timeoutMs?: number) {\n    const proxyId = this.getProxyId(proxy);\n    this.throttledProxies.set(proxyId, true, timeoutMs);\n  }\n\n  private async fetchProxy() {\n    const proxy = await new Promise<Proxy>((resolve) => {\n      let proxy = this.findAvailableProxy();", "      if (proxy) return resolve(proxy);\n\n      const interval = setInterval(() => {\n        proxy = this.findAvailableProxy();\n        if (!proxy) return;\n\n        clearInterval(interval);\n        resolve(proxy);\n      }, 1000);\n    });\n\n    return proxy;\n  }\n\n  private findAvailableProxy(): Proxy | null {", "    for (const proxy of this.proxies.values()) {\n      const proxyId = this.getProxyId(proxy);\n      if (this.throttledProxies.get(proxyId)) continue;\n      return proxy;\n    }\n\n    return null;\n  }\n\n  private getProxyId(proxy: Proxy | string) {\n    return `${ProxiesService.name}:${proxy.toString()}`;\n  }\n}\n"]}
{"filename": "src/modules/accounts-import/accounts-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\nimport inquirer from 'inquirer';\nimport pQueue from 'p-queue';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, Logger } from '@nestjs/common';\n\nimport { Account as IAccount } from '../../interfaces/account.interface';\nimport { Secrets } from '../../interfaces/secrets.interface';\n\nclass Account implements IAccount {\n  public readonly username: string;\n  public readonly password: string;\n  public sharedSecret: string | null = null;\n  public identitySecret: string | null = null;\n\n  constructor(account: string) {\n    account = account.trim();", "import { Secrets } from '../../interfaces/secrets.interface';\n\nclass Account implements IAccount {\n  public readonly username: string;\n  public readonly password: string;\n  public sharedSecret: string | null = null;\n  public identitySecret: string | null = null;\n\n  constructor(account: string) {\n    account = account.trim();\n    if (account.length === 0) throw new Error('Invalid account');\n\n    const parts = account.split(':').map((part) => part.trim());", "    if (account.length === 0) throw new Error('Invalid account');\n\n    const parts = account.split(':').map((part) => part.trim());\n    if (parts.length < 2) throw new Error('Invalid account');\n\n    const [username, password, sharedSecret, identitySecret] = parts;\n\n    this.username = username;\n    this.password = password;\n    if (sharedSecret) this.sharedSecret = sharedSecret;\n    if (identitySecret) this.identitySecret = identitySecret;\n  }\n}\n\n@Injectable()", "    if (sharedSecret) this.sharedSecret = sharedSecret;\n    if (identitySecret) this.identitySecret = identitySecret;\n  }\n}\n\n@Injectable()\nexport class AccountsImportService {\n  private readonly logger = new Logger(AccountsImportService.name);\n  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n\n  public async loadAccounts(input: string[] | string) {", "    if (!input) return [];\n    if (!Array.isArray(input)) input = [input];\n    if (input.length === 0) return [];\n\n    let accounts: Account[] = [];\n    const errors: string[] = [];\n\n    const readResults = await Promise.all(input.map((input) => this.readAccountsFromInput(input)));\n    for (const result of readResults) {\n      accounts.push(...result.values);\n      errors.push(...result.errors);\n    }\n\n    accounts = this.removeDuplicates(accounts);\n", "    for (const result of readResults) {\n      accounts.push(...result.values);\n      errors.push(...result.errors);\n    }\n\n    accounts = this.removeDuplicates(accounts);\n\n    if (errors.length > 0 && accounts.length > 0) {\n      this.logger.warn(`The following account sources are invalid:\\n${errors.join('\\n')}`);\n      await delay(1000);\n\n      const { confirm } = await inquirer.prompt({\n        type: 'confirm',\n        name: 'confirm',\n        message: 'Continue with the valid accounts?',\n        default: false,\n      });\n", "      if (!confirm) throw new Error('Aborted by user');\n    }\n\n    return accounts;\n  }\n\n  public assignSecretsToAccounts(accounts: Account[], secrets: Secrets[]) {\n    const secretsMap = new Map<string, Secrets>();\n    for (const secret of secrets) {\n      secretsMap.set(secret.username, secret);\n      // some existing steam-oriented apps are case-insensitive to usernames in secrets\n      secretsMap.set(secret.username.toLowerCase(), secret);\n    }\n", "    for (const secret of secrets) {\n      secretsMap.set(secret.username, secret);\n      // some existing steam-oriented apps are case-insensitive to usernames in secrets\n      secretsMap.set(secret.username.toLowerCase(), secret);\n    }\n\n    for (const account of accounts) {\n      let secret = secretsMap.get(account.username);\n      if (!secret) secret = secretsMap.get(account.username.toLowerCase());\n      if (!secret) continue;\n\n      account.sharedSecret = secret.sharedSecret;\n      account.identitySecret = secret.identitySecret;\n    }\n  }\n\n  private removeDuplicates(accounts: Account[]) {\n    const map = new Map<string, Account>();", "      if (!secret) secret = secretsMap.get(account.username.toLowerCase());\n      if (!secret) continue;\n\n      account.sharedSecret = secret.sharedSecret;\n      account.identitySecret = secret.identitySecret;\n    }\n  }\n\n  private removeDuplicates(accounts: Account[]) {\n    const map = new Map<string, Account>();\n    for (const account of accounts) map.set(account.username, account);\n    return [...map.values()];\n  }\n\n  private async readAccountsFromInput(input: string) {\n    const inputType = await this.inferInputType(input);", "    for (const account of accounts) map.set(account.username, account);\n    return [...map.values()];\n  }\n\n  private async readAccountsFromInput(input: string) {\n    const inputType = await this.inferInputType(input);\n    if (inputType === 'file') return this.readAccountsFromFile(input);\n    if (inputType === 'string') return this.readAccountFromString(input);\n    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private async readAccountsFromFile(filePath: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n", "    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private async readAccountsFromFile(filePath: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n      content = content.trim();\n\n      if (content.length === 0) throw new Error('Empty file');\n\n      // session file", "      if (content.length === 0) throw new Error('Empty file');\n\n      // session file\n      if (filePath.endsWith('.steamsession')) {\n        const readResults = this.readAccountFromSessionFile(content);\n        result.values.push(...readResults.values);\n        if (readResults.errors.length > 0) result.errors.push(filePath);\n\n        return result;\n      }\n\n      // asf json", "      if (filePath.endsWith('.json') && content.includes('\"SteamLogin\"')) {\n        const readResults = this.readAccountFromAsfJson(content);\n        result.values.push(...readResults.values);\n        if (readResults.errors.length > 0) result.errors.push(filePath);\n\n        return result;\n      }\n\n      // plain text\n      if (content.includes(':')) {\n        const lines = content\n          .split(/\\s+|\\r?\\n/)\n          .map((l) => l.trim())\n          .filter((l) => l.length > 0);\n", "      if (content.includes(':')) {\n        const lines = content\n          .split(/\\s+|\\r?\\n/)\n          .map((l) => l.trim())\n          .filter((l) => l.length > 0);\n\n        if (lines.length === 0) throw new Error('Empty file');\n\n        for (const line of lines) {\n          const readResults = this.readAccountFromString(line);\n          result.values.push(...readResults.values);", "        for (const line of lines) {\n          const readResults = this.readAccountFromString(line);\n          result.values.push(...readResults.values);\n          if (readResults.errors.length > 0) result.errors.push(line);\n        }\n\n        return result;\n      }\n\n      throw new Error('Unsupported file format');\n    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private readAccountFromString(str: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n", "    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private readAccountFromString(str: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      const account = new Account(str);\n      result.values.push(account);", "    try {\n      const account = new Account(str);\n      result.values.push(account);\n    } catch (error) {\n      result.errors.push(str);\n    }\n\n    return result;\n  }\n\n  private readAccountFromAsfJson(fileContent: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n", "    try {\n      const { SteamLogin: username, SteamPassword: password } = JSON.parse(fileContent);\n\n      if (!username) throw new Error('Invalid username');\n      if (!password) throw new Error('Invalid password');\n\n      const account = new Account(`${username}:${password}`);\n      result.values.push(account);\n    } catch (error) {\n      result.errors.push(fileContent);\n    }\n\n    return result;\n  }\n\n  private readAccountFromSessionFile(fileContent: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n", "    } catch (error) {\n      result.errors.push(fileContent);\n    }\n\n    return result;\n  }\n\n  private readAccountFromSessionFile(fileContent: string) {\n    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      const { Username, Password, SharedSecret, IdentitySecret } = JSON.parse(fileContent);", "    try {\n      const { Username, Password, SharedSecret, IdentitySecret } = JSON.parse(fileContent);\n      if (!Username) throw new Error('Invalid username');\n      if (!Password) throw new Error('Invalid password');\n\n      const account = new Account(`${Username}:${Password}:${SharedSecret || ''}:${IdentitySecret || ''}`);\n      result.values.push(account);\n    } catch (error) {\n      result.errors.push(fileContent);\n    }\n\n    return result;\n  }\n\n  private async inferInputType(input: string) {", "    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\n    try {\n      const stats = await fs.stat(input);\n      if (stats.isFile()) return 'file';\n      if (stats.isDirectory()) return 'directory';\n    } catch (error) {\n      return 'string';\n    }\n  }\n}\n"]}
{"filename": "src/modules/accounts-import/accounts-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { AccountsImportService } from './accounts-import.service';\n\n@Module({\n  providers: [AccountsImportService],\n  exports: [AccountsImportService],\n})\nexport class AccountsImportModule {}\n", "export class AccountsImportModule {}\n"]}
{"filename": "src/modules/sessions-import/sessions-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\nimport inquirer from 'inquirer';\nimport pQueue from 'p-queue';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, Logger } from '@nestjs/common';\n\nimport { Session } from '../../interfaces/session.interface';\n\n@Injectable()\nexport class SessionsImportService {\n  private readonly logger = new Logger(SessionsImportService.name);\n  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n\n  public async loadSessions(input: string[] | string) {", "\n@Injectable()\nexport class SessionsImportService {\n  private readonly logger = new Logger(SessionsImportService.name);\n  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n\n  public async loadSessions(input: string[] | string) {\n    if (!input) return [];\n    if (!Array.isArray(input)) input = [input];\n    if (input.length === 0) return [];\n\n    let sessions: Session[] = [];\n    const errors: string[] = [];\n\n    const readResults = await Promise.all(input.map((input) => this.readSessionsFromInput(input)));", "    if (!Array.isArray(input)) input = [input];\n    if (input.length === 0) return [];\n\n    let sessions: Session[] = [];\n    const errors: string[] = [];\n\n    const readResults = await Promise.all(input.map((input) => this.readSessionsFromInput(input)));\n    for (const result of readResults) {\n      sessions.push(...result.values);\n      errors.push(...result.errors);\n    }\n\n    sessions = this.removeDuplicates(sessions);\n", "    if (errors.length > 0 && sessions.length > 0) {\n      this.logger.warn(`The following session sources are invalid:\\n${errors.join('\\n')}`);\n      await delay(1000);\n\n      const { confirm } = await inquirer.prompt({\n        type: 'confirm',\n        name: 'confirm',\n        message: 'Continue with the valid sessions?',\n        default: false,\n      });\n", "      if (!confirm) throw new Error('Aborted by user');\n    }\n\n    return sessions;\n  }\n\n  private removeDuplicates(sessions: Session[]) {\n    const map = new Map<string, Session>();\n    for (const session of sessions) map.set(session.username, session);\n    return [...map.values()];\n  }\n\n  private async readSessionsFromInput(input: string) {\n    const inputType = await this.inferInputType(input);", "    for (const session of sessions) map.set(session.username, session);\n    return [...map.values()];\n  }\n\n  private async readSessionsFromInput(input: string) {\n    const inputType = await this.inferInputType(input);\n    if (inputType === 'file') return this.readSessionFromFile(input);\n    if (inputType === 'string') return { values: [], errors: [input] };\n    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private async readSessionFromFile(filePath: string) {\n    const result: { values: Session[]; errors: string[] } = { values: [], errors: [] };\n", "    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private async readSessionFromFile(filePath: string) {\n    const result: { values: Session[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n\n      content = JSON.parse(content);\n      if (content == null || typeof content !== 'object' || Array.isArray(content)) {\n        throw new Error('Invalid session file');\n      }\n\n      const session = Object.fromEntries(\n        Object.entries(content).map(([key, value]) => [key[0].toLowerCase() + key.slice(1), value]),\n      ) as unknown as Session;\n\n      result.values.push(session);", "      if (content == null || typeof content !== 'object' || Array.isArray(content)) {\n        throw new Error('Invalid session file');\n      }\n\n      const session = Object.fromEntries(\n        Object.entries(content).map(([key, value]) => [key[0].toLowerCase() + key.slice(1), value]),\n      ) as unknown as Session;\n\n      result.values.push(session);\n    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async inferInputType(input: string) {", "    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async inferInputType(input: string) {\n    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\n    try {\n      const stats = await fs.stat(input);", "    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\n    try {\n      const stats = await fs.stat(input);\n      if (stats.isFile()) return 'file';\n      if (stats.isDirectory()) return 'directory';\n    } catch (error) {\n      return 'string';\n    }\n  }\n}\n"]}
{"filename": "src/modules/sessions-import/sessions-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { SessionsImportService } from './sessions-import.service';\n\n@Module({\n  providers: [SessionsImportService],\n  exports: [SessionsImportService],\n})\nexport class SessionsImportModule {}\n", "export class SessionsImportModule {}\n"]}
{"filename": "src/modules/logger/logger.module.ts", "chunked_list": ["import { LoggerModule as PinoLoggerModule } from 'nestjs-pino';\n\nimport { Global, Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\nimport { LoggerService } from './logger.service';\n\n@Global()\n@Module({\n  imports: [", "@Module({\n  imports: [\n    PinoLoggerModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: async (configService) => ({\n        pinoHttp: {\n          level: configService.getOrThrow('app.environment') === 'production' ? 'info' : 'trace',\n          base: null,\n          transport: {\n            targets: [{ target: 'pino-pretty', level: 'trace', options: { sync: true } }],", "          transport: {\n            targets: [{ target: 'pino-pretty', level: 'trace', options: { sync: true } }],\n          },\n        },\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n  providers: [LoggerService],\n})\nexport class LoggerModule {}\n", "  providers: [LoggerService],\n})\nexport class LoggerModule {}\n"]}
{"filename": "src/modules/logger/logger.service.ts", "chunked_list": ["import { PinoLogger } from 'nestjs-pino';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, OnModuleDestroy } from '@nestjs/common';\n\n@Injectable()\nexport class LoggerService implements OnModuleDestroy {\n  constructor(private readonly logger: PinoLogger) {}\n\n  public async onModuleDestroy() {\n    this.logger.logger.flush();\n    await delay(1000);\n  }\n}\n"]}
{"filename": "src/modules/secrets-import/secrets-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\nimport { SecretsImportService } from './secrets-import.service';\n\n@Module({\n  providers: [SecretsImportService],\n  exports: [SecretsImportService],\n})\nexport class SecretsImportModule {}\n", "export class SecretsImportModule {}\n"]}
{"filename": "src/modules/secrets-import/secrets-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\nimport inquirer from 'inquirer';\nimport pQueue from 'p-queue';\nimport path from 'path';\nimport { setTimeout as delay } from 'timers/promises';\n\nimport { Injectable, Logger } from '@nestjs/common';\n\nimport { Secrets as ISecrets } from '../../interfaces/secrets.interface';\n\nclass Secrets implements ISecrets {\n  public readonly username: string;\n  public readonly sharedSecret: string;\n  public readonly identitySecret: string;\n\n  constructor(secrets: string) {\n    let parsedSecrets: any;\n", "import { Secrets as ISecrets } from '../../interfaces/secrets.interface';\n\nclass Secrets implements ISecrets {\n  public readonly username: string;\n  public readonly sharedSecret: string;\n  public readonly identitySecret: string;\n\n  constructor(secrets: string) {\n    let parsedSecrets: any;\n\n    try {\n      parsedSecrets = JSON.parse(secrets);", "    try {\n      parsedSecrets = JSON.parse(secrets);\n    } catch (error) {}\n\n    if (typeof parsedSecrets !== 'object' || parsedSecrets === null) throw new Error('Secrets string is invalid');\n\n    const { shared_secret, identity_secret, account_name } = parsedSecrets;\n\n    if (!shared_secret) throw new Error('Shared secret is missing');\n    this.sharedSecret = shared_secret;\n", "    if (!shared_secret) throw new Error('Shared secret is missing');\n    this.sharedSecret = shared_secret;\n\n    if (!identity_secret) throw new Error('Identity secret is missing');\n    this.identitySecret = identity_secret;\n\n    if (!account_name) throw new Error('Account name is missing');\n    this.username = account_name;\n  }\n}\n\n@Injectable()", "export class SecretsImportService {\n  private readonly logger = new Logger(SecretsImportService.name);\n  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n\n  public async loadSecrets(input: string[] | string) {\n    if (!input) return [];\n    if (!Array.isArray(input)) input = [input];\n    if (input.length === 0) return [];\n\n    let secrets: Secrets[] = [];\n    const errors: string[] = [];\n\n    const readResults = await Promise.all(input.map((input) => this.readSecretsFromInput(input)));", "    for (const result of readResults) {\n      secrets.push(...result.values);\n      errors.push(...result.errors);\n    }\n\n    secrets = this.removeDuplicates(secrets);\n\n    if (errors.length > 0) {\n      this.logger.warn(`The following secret sources are invalid:\\n${errors.join('\\n')}`);\n      await delay(1000);\n\n      const { confirm } = await inquirer.prompt({\n        type: 'confirm',\n        name: 'confirm',\n        message:\n          secrets.length > 0 ? `Continue with ${secrets.length} valid secrets?` : 'Continue without any secrets?',\n        default: false,\n      });\n", "      if (!confirm) throw new Error('Aborted by user');\n    }\n\n    return secrets;\n  }\n\n  private removeDuplicates(secrets: Secrets[]) {\n    const map = new Map<string, Secrets>();\n    for (const secret of secrets) map.set(secret.username, secret);\n    return [...map.values()];\n  }\n\n  private async readSecretsFromInput(input: string) {\n    const inputType = await this.inferInputType(input);", "    for (const secret of secrets) map.set(secret.username, secret);\n    return [...map.values()];\n  }\n\n  private async readSecretsFromInput(input: string) {\n    const inputType = await this.inferInputType(input);\n    if (inputType === 'file') return this.readSecretsFromFile(input);\n    if (inputType === 'string') return { values: [], errors: [input] };\n    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private async readSecretsFromFile(filePath: string) {\n    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n", "    if (inputType === 'directory') return { values: [], errors: [input] };\n  }\n\n  private async readSecretsFromFile(filePath: string) {\n    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      const fileExtension = path.extname(filePath);\n\n      // mafile\n      if (fileExtension.toLowerCase() === '.mafile') {\n        const readResult = await this.readSecretsFromMaFile(filePath);\n        result.values.push(...readResult.values);", "      if (fileExtension.toLowerCase() === '.mafile') {\n        const readResult = await this.readSecretsFromMaFile(filePath);\n        result.values.push(...readResult.values);\n        if (readResult.errors.length > 0) result.errors.push(filePath);\n        return result;\n      }\n\n      // asf db\n      if (fileExtension === '.db') {\n        const readResult = await this.readSecretsFromAsfDbFile(filePath);\n        result.values.push(...readResult.values);", "      if (fileExtension === '.db') {\n        const readResult = await this.readSecretsFromAsfDbFile(filePath);\n        result.values.push(...readResult.values);\n        if (readResult.errors.length > 0) result.errors.push(filePath);\n        return result;\n      }\n\n      throw new Error('Unsupported file format');\n    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async readSecretsFromMaFile(filePath: string) {\n    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n", "    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async readSecretsFromMaFile(filePath: string) {\n    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n\n    try {\n      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n      content = content.trim().replace(/},\\s*}/g, '}}');\n\n      const secrets = new Secrets(content);\n      result.values.push(secrets);", "    try {\n      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n      content = content.trim().replace(/},\\s*}/g, '}}');\n\n      const secrets = new Secrets(content);\n      result.values.push(secrets);\n    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async readSecretsFromAsfDbFile(filePath: string) {\n    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n", "    try {\n      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n\n      const parsedContent = JSON.parse(content)['_MobileAuthenticator'];\n      parsedContent['account_name'] = path.basename(filePath, path.extname(filePath));\n\n      content = JSON.stringify(parsedContent);\n\n      const secrets = new Secrets(content);\n      result.values.push(secrets);\n    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async inferInputType(input: string) {", "    } catch (error) {\n      result.errors.push(filePath);\n    }\n\n    return result;\n  }\n\n  private async inferInputType(input: string) {\n    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\n    try {\n      const stats = await fs.stat(input);", "    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\n    try {\n      const stats = await fs.stat(input);\n      if (stats.isFile()) return 'file';\n      if (stats.isDirectory()) return 'directory';\n    } catch (error) {\n      return 'string';\n    }\n  }\n}\n"]}
