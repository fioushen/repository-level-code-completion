{"filename": "vite.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\n\n// Configure Vitest (https://vitest.dev/config/)\n\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    /* for example, use global to avoid globals imports (describe, test, expect): */\n    // globals: true,", "    /* for example, use global to avoid globals imports (describe, test, expect): */\n    // globals: true,\n  },\n});\n"]}
{"filename": "test/test-app-bun-oauth.ts", "chunked_list": ["import { SlackAPIClient } from \"slack-web-api-client\";\nimport {\n  Authorize,\n  SlackOAuthApp,\n  SlackOAuthEnv,\n  AuthorizeError,\n  Installation,\n  InstallationStore,\n  InstallationStoreQuery,\n} from \"../src/index\";", "  InstallationStoreQuery,\n} from \"../src/index\";\n\nclass FileInstallationStore implements InstallationStore<SlackOAuthEnv> {\n  async save(\n    installation: Installation,\n    _request: Request | undefined\n  ): Promise<void> {\n    await Bun.write(\n      `./tmp/${installation.team_id}.json`,\n      JSON.stringify(installation)\n    );\n    await Bun.write(\n      `./tmp/${installation.team_id}-${installation.user_id}.json`,\n      JSON.stringify(installation)\n    );\n  }\n  async findBotInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    return await Bun.file(`./tmp/${query.teamId}.json`).json();\n  }\n  async findUserInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    return await Bun.file(`./tmp/${query.teamId}-${query.userId}.json`).json();\n  }\n  toAuthorize(): Authorize<SlackOAuthEnv> {\n    return async (req) => {\n      // Note that this implementation supports only bot token resolution\n      const installation = await this.findBotInstallation(req.context);", "      if (installation) {\n        const client = new SlackAPIClient();\n        const authTest = await client.auth.test({\n          token: installation.bot_token,\n        });\n        return {\n          enterpriseId: installation?.enterprise_id,\n          teamId: installation?.team_id,\n          botId: authTest.bot_id,\n          botUserId: installation.bot_user_id,\n          botToken: installation.bot_token,\n          botScopes: installation.bot_scopes,\n        };\n      }\n      throw new AuthorizeError(\n        `Failed to resolve the associated installation: ${req.context.teamId}`\n      );\n    };\n  }\n}\n\nconst app = new SlackOAuthApp({\n  env: {\n    SLACK_SIGNING_SECRET: process.env.SLACK_SIGNING_SECRET!,\n    SLACK_CLIENT_ID: process.env.SLACK_CLIENT_ID!,\n    SLACK_CLIENT_SECRET: process.env.SLACK_CLIENT_SECRET!,\n    SLACK_BOT_SCOPES: \"app_mentions:read,chat:write,channels:history,commands\",\n    SLACK_LOGGING_LEVEL: \"DEBUG\",\n  },\n  installationStore: new FileInstallationStore(),\n});\n\napp.event(\"app_mention\", async ({ context, payload }) => {\n  console.log(payload);\n  await context.say({ text: \"Hey!\" });\n});\n\napp.message(\"hey\", async ({ context }) => {\n  await context.say({ text: \"Hey!\" });\n});\napp.event(\"message\", async () => {});\n\napp.shortcut(\n  \"hello\",\n  async () => {},\n  async ({ context, payload }) => {\n    await context.client.views.open({\n      trigger_id: payload.trigger_id,\n      view: {\n        type: \"modal\",\n        callback_id: \"foo\",\n        title: { type: \"plain_text\", text: \"My App\" },\n        close: { type: \"plain_text\", text: \"Cancel\" },\n        blocks: [\n          {\n            type: \"section\",\n            text: {\n              type: \"plain_text\",\n              text: \"This is a plain text section block.\",\n            },\n          },\n        ],\n      },\n    });\n  }\n);\n\n// bun run --watch test/test-app-bun-oauth.ts\n// ngrok http 3000 --subdomain your-domain\nexport default {\n  port: 3000,\n  async fetch(request) {\n    return await app.run(request);\n  },\n};\n"]}
{"filename": "test/oauth-app.test.ts", "chunked_list": ["import { assert, test, describe } from \"vitest\";\nimport {\n  SlackOAuthApp,\n  InstallationStore,\n  SlackOAuthEnv,\n  Installation,\n  InstallationStoreQuery,\n  Authorize,\n} from \"../src/index\";\n\nclass MemoryInstallationStore implements InstallationStore<SlackOAuthEnv> {\n  async save(\n    installation: Installation,\n    request: Request | undefined\n  ): Promise<void> {\n    throw new Error();\n  }\n\n  async findBotInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    throw new Error();\n  }\n\n  async findUserInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    throw new Error();\n  }\n\n  toAuthorize(): Authorize<SlackOAuthEnv> {\n    return async (req) => {\n      throw new Error();\n    };\n  }\n}\n\ndescribe(\"SlackOAuthApp\", () => {\n  test(\"Initialization\", () => {\n    const app = new SlackOAuthApp({\n      env: {\n        SLACK_CLIENT_ID: \"111.222\",\n        SLACK_CLIENT_SECRET: \"xxx\",\n        SLACK_BOT_SCOPES: \"commands,chat:write\",\n        SLACK_SIGNING_SECRET: \"test\",\n      },\n      installationStore: new MemoryInstallationStore(),\n    });\n    assert.exists(app.client);\n  });\n});\n", "} from \"../src/index\";\n\nclass MemoryInstallationStore implements InstallationStore<SlackOAuthEnv> {\n  async save(\n    installation: Installation,\n    request: Request | undefined\n  ): Promise<void> {\n    throw new Error();\n  }\n\n  async findBotInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    throw new Error();\n  }\n\n  async findUserInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    throw new Error();\n  }\n\n  toAuthorize(): Authorize<SlackOAuthEnv> {\n    return async (req) => {\n      throw new Error();\n    };\n  }\n}\n\ndescribe(\"SlackOAuthApp\", () => {\n  test(\"Initialization\", () => {\n    const app = new SlackOAuthApp({\n      env: {\n        SLACK_CLIENT_ID: \"111.222\",\n        SLACK_CLIENT_SECRET: \"xxx\",\n        SLACK_BOT_SCOPES: \"commands,chat:write\",\n        SLACK_SIGNING_SECRET: \"test\",\n      },\n      installationStore: new MemoryInstallationStore(),\n    });\n    assert.exists(app.client);\n  });\n});\n"]}
{"filename": "test/test-app-deno.ts", "chunked_list": ["import { SlackApp } from \"../src_deno/app.ts\";\n\nconst app = new SlackApp({\n  env: {\n    SLACK_SIGNING_SECRET: Deno.env.get(\"SLACK_SIGNING_SECRET\"),\n    SLACK_BOT_TOKEN: Deno.env.get(\"SLACK_BOT_TOKEN\"),\n    SLACK_LOGGING_LEVEL: \"DEBUG\",\n  },\n});\n", "});\n\napp.event(\"app_mention\", async ({ context, payload }) => {\n  console.log(payload);\n  await context.say({ text: \"Hey!\" });\n});\n\napp.message(\"hey\", async ({ context }) => {\n  await context.say({ text: \"Hey!\" });\n});", "  await context.say({ text: \"Hey!\" });\n});\napp.event(\"message\", async () => {});\n\napp.shortcut(\n  \"hello\",\n  async () => {},\n  async ({ context, payload }) => {\n    await context.client.views.open({\n      trigger_id: payload.trigger_id,", "    await context.client.views.open({\n      trigger_id: payload.trigger_id,\n      view: {\n        type: \"modal\",\n        title: { type: \"plain_text\", text: \"My App\" },\n        close: { type: \"plain_text\", text: \"Cancel\" },\n        blocks: [\n          {\n            type: \"section\",\n            text: {", "            type: \"section\",\n            text: {\n              type: \"plain_text\",\n              text: \"This is a plain text section block.\",\n            },\n          },\n        ],\n      },\n    });\n  }", "    });\n  }\n);\n\n// deno run --watch --allow-net --allow-env test/test-app-deno.ts\n// ngrok http 3000 --subdomain your-domain\nimport { serve } from \"https://deno.land/std@0.192.0/http/server.ts\";\nawait serve(\n  async (request) => {\n    return await app.run(request);", "  async (request) => {\n    return await app.run(request);\n  },\n  { port: 3000 }\n);\n"]}
{"filename": "test/errors.test.ts", "chunked_list": ["import { assert, test, describe } from \"vitest\";\nimport { ConfigError, AuthorizeError } from \"../src/index\";\n\ndescribe(\"Errors\", () => {\n  test(\"ConfigError\", () => {\n    const error = new ConfigError(\"test\");\n    assert.equal(error.toString(), \"ConfigError: test\");\n  });\n  test(\"AuthorizeError\", () => {\n    const error = new AuthorizeError(\"test\");", "  test(\"AuthorizeError\", () => {\n    const error = new AuthorizeError(\"test\");\n    assert.equal(error.toString(), \"AuthorizeError: test\");\n  });\n});\n"]}
{"filename": "test/app.test.ts", "chunked_list": ["import { assert, test, describe } from \"vitest\";\nimport { SlackApp } from \"../src/index\";\n\ndescribe(\"SlackApp\", () => {\n  test(\"initialization\", () => {\n    const app = new SlackApp({\n      env: { SLACK_SIGNING_SECRET: \"test\", SLACK_BOT_TOKEN: \"xoxb-\" },\n    });\n    assert.exists(app.client);\n  });", "    assert.exists(app.client);\n  });\n});\n"]}
{"filename": "test/test-app-bun.ts", "chunked_list": ["import { SlackApp } from \"../src/app\";\n\nconst app = new SlackApp({\n  env: {\n    SLACK_SIGNING_SECRET: process.env.SLACK_SIGNING_SECRET!,\n    SLACK_BOT_TOKEN: process.env.SLACK_BOT_TOKEN,\n    SLACK_LOGGING_LEVEL: \"DEBUG\",\n  },\n});\n", "});\n\napp.event(\"app_mention\", async ({ context, payload }) => {\n  console.log(payload);\n  await context.say({ text: \"Hey!\" });\n});\n\napp.message(\"hey\", async ({ context }) => {\n  await context.say({ text: \"Hey!\" });\n});", "  await context.say({ text: \"Hey!\" });\n});\napp.event(\"message\", async () => {});\n\napp.shortcut(\n  \"hello\",\n  async () => {},\n  async ({ context, payload }) => {\n    await context.client.views.open({\n      trigger_id: payload.trigger_id,", "    await context.client.views.open({\n      trigger_id: payload.trigger_id,\n      view: {\n        type: \"modal\",\n        callback_id: \"foo\",\n        title: { type: \"plain_text\", text: \"My App\" },\n        close: { type: \"plain_text\", text: \"Cancel\" },\n        blocks: [\n          {\n            type: \"section\",", "          {\n            type: \"section\",\n            text: {\n              type: \"plain_text\",\n              text: \"This is a plain text section block.\",\n            },\n          },\n        ],\n      },\n    });", "      },\n    });\n  }\n);\n\n// bun run --watch test/test-app-bun.ts\n// ngrok http 3000 --subdomain your-domain\nexport default {\n  port: 3000,\n  async fetch(request) {", "  port: 3000,\n  async fetch(request) {\n    return await app.run(request);\n  },\n};\n"]}
{"filename": "test/test-socket-mode-app-deno.ts", "chunked_list": ["import { SlackApp } from \"../src_deno/mod.ts\";\n\nconst app = new SlackApp({\n  env: {\n    SLACK_BOT_TOKEN: Deno.env.get(\"SLACK_BOT_TOKEN\"),\n    SLACK_APP_TOKEN: Deno.env.get(\"SLACK_APP_TOKEN\"),\n    SLACK_LOGGING_LEVEL: \"DEBUG\",\n  },\n});\n", "});\n\napp.event(\"app_mention\", async ({ context, payload }) => {\n  console.log(payload);\n  await context.say({ text: \"Hey!\" });\n});\n\napp.message(\"hey\", async ({ context }) => {\n  await context.say({ text: \"Hey!\" });\n});", "  await context.say({ text: \"Hey!\" });\n});\napp.event(\"message\", async () => {});\n\napp.shortcut(\n  \"hello\",\n  async () => {},\n  async ({ context, payload }) => {\n    await context.client.views.open({\n      trigger_id: payload.trigger_id,", "    await context.client.views.open({\n      trigger_id: payload.trigger_id,\n      view: {\n        type: \"modal\",\n        title: { type: \"plain_text\", text: \"My App\" },\n        close: { type: \"plain_text\", text: \"Cancel\" },\n        blocks: [\n          {\n            type: \"section\",\n            text: {", "            type: \"section\",\n            text: {\n              type: \"plain_text\",\n              text: \"This is a plain text section block.\",\n            },\n          },\n        ],\n      },\n    });\n  }", "    });\n  }\n);\n\napp.command(\"/hello\", async () => \"Hello!\");\n\n// deno run --watch --allow-net --allow-env test/test-socket-mode-app-deno.ts\nawait app.connect();\nsetTimeout(() => {}, Number.MAX_SAFE_INTEGER);\n", "setTimeout(() => {}, Number.MAX_SAFE_INTEGER);\n"]}
{"filename": "test/test-app-deno-oauth.ts", "chunked_list": ["import { SlackAPIClient } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport {\n  Authorize,\n  SlackOAuthApp,\n  SlackOAuthEnv,\n  AuthorizeError,\n  Installation,\n  InstallationStore,\n  InstallationStoreQuery,\n} from \"../src_deno/mod.ts\";", "  InstallationStoreQuery,\n} from \"../src_deno/mod.ts\";\n\nclass FileInstallationStore implements InstallationStore<SlackOAuthEnv> {\n  async save(\n    installation: Installation,\n    _request: Request | undefined\n  ): Promise<void> {\n    const encoder = new TextEncoder();\n    await Deno.writeFile(\n      `./tmp/${installation.team_id}.json`,\n      encoder.encode(JSON.stringify(installation))\n    );\n    await Deno.writeFile(\n      `./tmp/${installation.team_id}-${installation.user_id}.json`,\n      encoder.encode(JSON.stringify(installation))\n    );\n  }\n  async findBotInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    return JSON.parse(await Deno.readTextFile(`./tmp/${query.teamId}.json`));\n  }\n  async findUserInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined> {\n    return JSON.parse(\n      await Deno.readTextFile(`./tmp/${query.teamId}-${query.userId}.json`)\n    );\n  }\n  toAuthorize(): Authorize<SlackOAuthEnv> {\n    return async (req) => {\n      // Note that this implementation supports only bot token resolution\n      const installation = await this.findBotInstallation(req.context);", "      if (installation) {\n        const client = new SlackAPIClient();\n        const authTest = await client.auth.test({\n          token: installation.bot_token,\n        });\n        return {\n          enterpriseId: installation?.enterprise_id,\n          teamId: installation?.team_id,\n          botId: authTest.bot_id,\n          botUserId: installation.bot_user_id,\n          botToken: installation.bot_token,\n          botScopes: installation.bot_scopes,\n        };\n      }\n      throw new AuthorizeError(\n        `Failed to resolve the associated installation: ${req.context.teamId}`\n      );\n    };\n  }\n}\n\nconst app = new SlackOAuthApp({\n  env: {\n    SLACK_SIGNING_SECRET: Deno.env.get(\"SLACK_SIGNING_SECRET\"),\n    SLACK_CLIENT_ID: Deno.env.get(\"SLACK_CLIENT_ID\"),\n    SLACK_CLIENT_SECRET: Deno.env.get(\"SLACK_CLIENT_SECRET\"),\n    SLACK_BOT_SCOPES: \"app_mentions:read,chat:write,channels:history,commands\",\n    SLACK_LOGGING_LEVEL: \"DEBUG\",\n  },\n  installationStore: new FileInstallationStore(),\n});\n\napp.event(\"app_mention\", async ({ context, payload }) => {\n  console.log(payload);\n  await context.say({ text: \"Hey!\" });\n});\n\napp.message(\"hey\", async ({ context }) => {\n  await context.say({ text: \"Hey!\" });\n});\napp.event(\"message\", async () => {});\n\napp.shortcut(\n  \"hello\",\n  async () => {},\n  async ({ context, payload }) => {\n    await context.client.views.open({\n      trigger_id: payload.trigger_id,\n      view: {\n        type: \"modal\",\n        callback_id: \"foo\",\n        title: { type: \"plain_text\", text: \"My App\" },\n        close: { type: \"plain_text\", text: \"Cancel\" },\n        blocks: [\n          {\n            type: \"section\",\n            text: {\n              type: \"plain_text\",\n              text: \"This is a plain text section block.\",\n            },\n          },\n        ],\n      },\n    });\n  }\n);\n\n// deno run --watch --allow-net --allow-env --allow-read --allow-write test/test-app-deno-oauth.ts\n// ngrok http 3000 --subdomain your-domain\nimport { serve } from \"https://deno.land/std@0.192.0/http/server.ts\";\nawait serve(\n  async (request) => {\n    return await app.run(request);\n  },\n  { port: 3000 }\n);\n"]}
{"filename": "src_deno/oauth-app.ts", "chunked_list": ["import { ExecutionContext, NoopExecutionContext } from \"./execution-context.ts\";\nimport { SlackApp } from \"./app.ts\";\nimport { SlackOAuthEnv } from \"./app-env.ts\";\nimport { InstallationStore } from \"./oauth/installation-store.ts\";\nimport { NoStorageStateStore, StateStore } from \"./oauth/state-store.ts\";\nimport {\n  renderCompletionPage,\n  renderStartPage,\n} from \"./oauth/oauth-page-renderer.ts\";\nimport { generateAuthorizeUrl } from \"./oauth/authorize-url-generator.ts\";", "} from \"./oauth/oauth-page-renderer.ts\";\nimport { generateAuthorizeUrl } from \"./oauth/authorize-url-generator.ts\";\nimport { parse as parseCookie } from \"./cookie.ts\";\nimport {\n  OAuthV2AccessResponse,\n  OpenIDConnectTokenResponse,\n  SlackAPIClient,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { toInstallation } from \"./oauth/installation.ts\";\nimport {", "import { toInstallation } from \"./oauth/installation.ts\";\nimport {\n  AfterInstallation,\n  BeforeInstallation,\n  defaultOnFailure,\n  defaultOnStateValidationError,\n  OnFailure,\n  OnStateValidationError,\n} from \"./oauth/callback.ts\";\nimport {", "} from \"./oauth/callback.ts\";\nimport {\n  defaultOpenIDConnectCallback,\n  OpenIDConnectCallback,\n} from \"./oidc/callback.ts\";\nimport { generateOIDCAuthorizeUrl } from \"./oidc/authorize-url-generator.ts\";\nimport {\n  CompletionPageError,\n  InstallationError,\n  InstallationStoreError,", "  InstallationError,\n  InstallationStoreError,\n  MissingCode,\n  OpenIDConnectError,\n} from \"./oauth/error-codes.ts\";\n\nexport interface SlackOAuthAppOptions<E extends SlackOAuthEnv> {\n  env: E;\n  installationStore: InstallationStore<E>;\n  stateStore?: StateStore;\n  oauth?: {\n    stateCookieName?: string;\n    beforeInstallation?: BeforeInstallation;\n    afterInstallation?: AfterInstallation;\n    onFailure?: OnFailure;\n    onStateValidationError?: OnStateValidationError;\n    redirectUri?: string;\n  };\n  oidc?: {\n    stateCookieName?: string;\n    callback: OpenIDConnectCallback;\n    onFailure?: OnFailure;\n    onStateValidationError?: OnStateValidationError;\n    redirectUri?: string;\n  };\n  routes?: {\n    events: string;\n    oauth: { start: string; callback: string };\n    oidc?: { start: string; callback: string };\n  };\n}\n", "export class SlackOAuthApp<E extends SlackOAuthEnv> extends SlackApp<E> {\n  public env: E;\n  public installationStore: InstallationStore<E>;\n  public stateStore: StateStore;\n  public oauth: {\n    stateCookieName?: string;\n    beforeInstallation?: BeforeInstallation;\n    afterInstallation?: AfterInstallation;\n    onFailure: OnFailure;\n    onStateValidationError: OnStateValidationError;\n    redirectUri?: string;\n  };\n  public oidc?: {\n    stateCookieName?: string;\n    callback: OpenIDConnectCallback;\n    onFailure: OnFailure;\n    onStateValidationError: OnStateValidationError;\n    redirectUri?: string;\n  };\n  public routes: {\n    events: string;\n    oauth: { start: string; callback: string };\n    oidc?: { start: string; callback: string };\n  };\n\n  constructor(options: SlackOAuthAppOptions<E>) {\n    super({\n      env: options.env,\n      authorize: options.installationStore.toAuthorize(),\n      routes: { events: options.routes?.events ?? \"/slack/events\" },\n    });\n    this.env = options.env;\n    this.installationStore = options.installationStore;\n    this.stateStore = options.stateStore ?? new NoStorageStateStore();\n    this.oauth = {\n      stateCookieName: options.oauth?.stateCookieName ??\n        \"slack-app-oauth-state\",\n      onFailure: options.oauth?.onFailure ?? defaultOnFailure,\n      onStateValidationError: options.oauth?.onStateValidationError ??\n        defaultOnStateValidationError,\n      redirectUri: options.oauth?.redirectUri ?? this.env.SLACK_REDIRECT_URI,\n    };", "    if (options.oidc) {\n      this.oidc = {\n        stateCookieName: options.oidc.stateCookieName ?? \"slack-app-oidc-state\",\n        onFailure: options.oidc.onFailure ?? defaultOnFailure,\n        onStateValidationError: options.oidc.onStateValidationError ??\n          defaultOnStateValidationError,\n        callback: defaultOpenIDConnectCallback(this.env),\n        redirectUri: options.oidc.redirectUri ??\n          this.env.SLACK_OIDC_REDIRECT_URI,\n      };\n    } else {\n      this.oidc = undefined;\n    }\n    this.routes = options.routes ? options.routes : {\n      events: \"/slack/events\",\n      oauth: {\n        start: \"/slack/install\",\n        callback: \"/slack/oauth_redirect\",\n      },\n      oidc: {\n        start: \"/slack/login\",\n        callback: \"/slack/login/callback\",\n      },\n    };\n  }\n\n  async run(\n    request: Request,\n    ctx: ExecutionContext = new NoopExecutionContext(),\n  ): Promise<Response> {\n    const url = new URL(request.url);", "    if (request.method === \"GET\") {\n      if (url.pathname === this.routes.oauth.start) {\n        return await this.handleOAuthStartRequest(request);\n      } else if (url.pathname === this.routes.oauth.callback) {\n        return await this.handleOAuthCallbackRequest(request);\n      }\n      if (this.routes.oidc) {\n        if (url.pathname === this.routes.oidc.start) {\n          return await this.handleOIDCStartRequest(request);\n        } else if (url.pathname === this.routes.oidc.callback) {\n          return await this.handleOIDCCallbackRequest(request);\n        }\n      }", "        } else if (url.pathname === this.routes.oidc.callback) {\n          return await this.handleOIDCCallbackRequest(request);\n        }\n      }\n    } else if (request.method === \"POST\") {\n      if (url.pathname === this.routes.events) {\n        return await this.handleEventRequest(request, ctx);\n      }\n    }\n    return new Response(\"Not found\", { status: 404 });\n  }\n\n  async handleEventRequest(\n    request: Request,\n    ctx: ExecutionContext,\n  ): Promise<Response> {\n    return await super.handleEventRequest(request, ctx);\n  }\n\n  // deno-lint-ignore no-unused-vars\n  async handleOAuthStartRequest(request: Request): Promise<Response> {\n    const stateValue = await this.stateStore.issueNewState();\n    const authorizeUrl = generateAuthorizeUrl(stateValue, this.env);\n    return new Response(renderStartPage(authorizeUrl), {\n      status: 302,\n      headers: {\n        Location: authorizeUrl,\n        \"Set-Cookie\":\n          `${this.oauth.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n        \"Content-Type\": \"text/html; charset=utf-8\",\n      },\n    });\n  }\n\n  async handleOAuthCallbackRequest(request: Request): Promise<Response> {\n    // State parameter validation\n    await this.#validateStateParameter(\n      request,\n      this.routes.oauth.start,\n      this.oauth.stateCookieName!,\n    );\n\n    const { searchParams } = new URL(request.url);\n    const code = searchParams.get(\"code\");", "    if (!code) {\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        MissingCode,\n        request,\n      );\n    }\n\n    const client = new SlackAPIClient(undefined, {\n      logLevel: this.env.SLACK_LOGGING_LEVEL,\n    });\n    let oauthAccess: OAuthV2AccessResponse | undefined;", "    try {\n      // Execute the installation process\n      oauthAccess = await client.oauth.v2.access({\n        client_id: this.env.SLACK_CLIENT_ID,\n        client_secret: this.env.SLACK_CLIENT_SECRET,\n        redirect_uri: this.oauth.redirectUri,\n        code,\n      });\n    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        InstallationError,\n        request,\n      );\n    }\n", "    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        InstallationError,\n        request,\n      );\n    }\n\n    try {\n      // Store the installation data on this app side\n      await this.installationStore.save(toInstallation(oauthAccess), request);", "    try {\n      // Store the installation data on this app side\n      await this.installationStore.save(toInstallation(oauthAccess), request);\n    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        InstallationStoreError,\n        request,\n      );\n    }\n", "    try {\n      // Build the completion page\n      const authTest = await client.auth.test({\n        token: oauthAccess.access_token,\n      });\n      const enterpriseUrl = authTest.url;\n      return new Response(\n        renderCompletionPage(\n          oauthAccess.app_id!,\n          oauthAccess.team?.id!,\n          oauthAccess.is_enterprise_install,\n          enterpriseUrl,\n        ),\n        {\n          status: 200,\n          headers: {\n            \"Set-Cookie\":\n              `${this.oauth.stateCookieName}=deleted; Secure; HttpOnly; Path=/; Max-Age=0`,\n            \"Content-Type\": \"text/html; charset=utf-8\",\n          },\n        },\n      );", "    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        CompletionPageError,\n        request,\n      );\n    }\n  }\n\n  // deno-lint-ignore no-unused-vars\n  async handleOIDCStartRequest(request: Request): Promise<Response> {", "    if (!this.oidc) {\n      return new Response(\"Not found\", { status: 404 });\n    }\n    const stateValue = await this.stateStore.issueNewState();\n    const authorizeUrl = generateOIDCAuthorizeUrl(stateValue, this.env);\n    return new Response(renderStartPage(authorizeUrl), {\n      status: 302,\n      headers: {\n        Location: authorizeUrl,\n        \"Set-Cookie\":\n          `${this.oidc.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n        \"Content-Type\": \"text/html; charset=utf-8\",\n      },\n    });\n  }\n\n  async handleOIDCCallbackRequest(request: Request): Promise<Response> {", "    if (!this.oidc || !this.routes.oidc) {\n      return new Response(\"Not found\", { status: 404 });\n    }\n    // State parameter validation\n    await this.#validateStateParameter(\n      request,\n      this.routes.oidc.start,\n      this.oidc.stateCookieName!,\n    );\n\n    const { searchParams } = new URL(request.url);\n    const code = searchParams.get(\"code\");", "    if (!code) {\n      return await this.oidc.onFailure(\n        this.routes.oidc.start,\n        MissingCode,\n        request,\n      );\n    }\n\n    try {\n      const client = new SlackAPIClient(undefined, {\n        logLevel: this.env.SLACK_LOGGING_LEVEL,\n      });\n      const apiResponse: OpenIDConnectTokenResponse = await client.openid\n        .connect.token({\n          client_id: this.env.SLACK_CLIENT_ID,\n          client_secret: this.env.SLACK_CLIENT_SECRET,\n          redirect_uri: this.oidc.redirectUri,\n          code,\n        });\n      return await this.oidc.callback(apiResponse, request);", "    try {\n      const client = new SlackAPIClient(undefined, {\n        logLevel: this.env.SLACK_LOGGING_LEVEL,\n      });\n      const apiResponse: OpenIDConnectTokenResponse = await client.openid\n        .connect.token({\n          client_id: this.env.SLACK_CLIENT_ID,\n          client_secret: this.env.SLACK_CLIENT_SECRET,\n          redirect_uri: this.oidc.redirectUri,\n          code,\n        });\n      return await this.oidc.callback(apiResponse, request);", "    } catch (e) {\n      console.log(e);\n      return await this.oidc.onFailure(\n        this.routes.oidc.start,\n        OpenIDConnectError,\n        request,\n      );\n    }\n  }\n\n  async #validateStateParameter(\n    request: Request,\n    startPath: string,\n    cookieName: string,\n  ) {\n    const { searchParams } = new URL(request.url);\n    const queryState = searchParams.get(\"state\");\n    const cookie = parseCookie(request.headers.get(\"Cookie\") || \"\");\n    const cookieState = cookie[cookieName];", "    if (\n      queryState !== cookieState ||\n      !(await this.stateStore.consume(queryState))\n    ) {\n      if (startPath === this.routes.oauth.start) {\n        return await this.oauth.onStateValidationError(startPath, request);\n      } else if (\n        this.oidc &&\n        this.routes.oidc &&\n        startPath === this.routes.oidc.start\n      ) {\n        return await this.oidc.onStateValidationError(startPath, request);\n      }\n    }\n  }\n}\n"]}
{"filename": "src_deno/mod.ts", "chunked_list": ["export * from \"./index.ts\";\n"]}
{"filename": "src_deno/app.ts", "chunked_list": ["import {\n  SlackAppEnv,\n  SlackEdgeAppEnv,\n  SlackSocketModeAppEnv,\n} from \"./app-env.ts\";\nimport { parseRequestBody } from \"./request/request-parser.ts\";\nimport { verifySlackRequest } from \"./request/request-verification.ts\";\nimport { AckResponse, SlackHandler } from \"./handler/handler.ts\";\nimport { SlackRequestBody } from \"./request/request-body.ts\";\nimport {", "import { SlackRequestBody } from \"./request/request-body.ts\";\nimport {\n  PreAuthorizeSlackMiddlwareRequest,\n  SlackMiddlwareRequest,\n  SlackRequest,\n  SlackRequestWithChannelId,\n  SlackRequestWithOptionalRespond,\n  SlackRequestWithRespond,\n} from \"./request/request.ts\";\nimport { SlashCommand } from \"./request/payload/slash-command.ts\";", "} from \"./request/request.ts\";\nimport { SlashCommand } from \"./request/payload/slash-command.ts\";\nimport { toCompleteResponse } from \"./response/response.ts\";\nimport {\n  AnySlackEvent,\n  AnySlackEventWithChannelId,\n  SlackEvent,\n} from \"./request/payload/event.ts\";\nimport {\n  ResponseUrlSender,", "import {\n  ResponseUrlSender,\n  SlackAPIClient,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport {\n  builtBaseContext,\n  SlackAppContext,\n  SlackAppContextWithChannelId,\n  SlackAppContextWithRespond,\n} from \"./context/context.ts\";", "  SlackAppContextWithRespond,\n} from \"./context/context.ts\";\nimport { Middleware, PreAuthorizeMiddleware } from \"./middleware/middleware.ts\";\nimport {\n  isDebugLogEnabled,\n  prettyPrint,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { Authorize } from \"./authorization/authorize.ts\";\nimport { AuthorizeResult } from \"./authorization/authorize-result.ts\";\nimport {", "import { AuthorizeResult } from \"./authorization/authorize-result.ts\";\nimport {\n  ignoringSelfEvents,\n  urlVerification,\n} from \"./middleware/built-in-middleware.ts\";\nimport { ConfigError } from \"./errors.ts\";\nimport { GlobalShortcut } from \"./request/payload/global-shortcut.ts\";\nimport { MessageShortcut } from \"./request/payload/message-shortcut.ts\";\nimport {\n  BlockAction,", "import {\n  BlockAction,\n  BlockElementAction,\n  BlockElementTypes,\n} from \"./request/payload/block-action.ts\";\nimport { ViewSubmission } from \"./request/payload/view-submission.ts\";\nimport { ViewClosed } from \"./request/payload/view-closed.ts\";\nimport { BlockSuggestion } from \"./request/payload/block-suggestion.ts\";\nimport {\n  OptionsAckResponse,", "import {\n  OptionsAckResponse,\n  SlackOptionsHandler,\n} from \"./handler/options-handler.ts\";\nimport { SlackViewHandler, ViewAckResponse } from \"./handler/view-handler.ts\";\nimport {\n  MessageAckResponse,\n  SlackMessageHandler,\n} from \"./handler/message-handler.ts\";\nimport { singleTeamAuthorize } from \"./authorization/single-team-authorize.ts\";", "} from \"./handler/message-handler.ts\";\nimport { singleTeamAuthorize } from \"./authorization/single-team-authorize.ts\";\nimport { ExecutionContext, NoopExecutionContext } from \"./execution-context.ts\";\nimport { PayloadType } from \"./request/payload-types.ts\";\nimport { isPostedMessageEvent } from \"./utility/message-events.ts\";\nimport { SocketModeClient } from \"./socket-mode/socket-mode-client.ts\";\n\nexport interface SlackAppOptions<\n  E extends SlackEdgeAppEnv | SlackSocketModeAppEnv,\n> {\n  env: E;\n  authorize?: Authorize<E>;\n  routes?: {\n    events: string;\n  };\n  socketMode?: boolean;\n}\n", "export class SlackApp<E extends SlackEdgeAppEnv | SlackSocketModeAppEnv> {\n  public env: E;\n  public client: SlackAPIClient;\n  public authorize: Authorize<E>;\n  public routes: { events: string | undefined };\n  public signingSecret: string;\n\n  public appLevelToken: string | undefined;\n  public socketMode: boolean;\n  public socketModeClient: SocketModeClient | undefined;\n\n  // deno-lint-ignore no-explicit-any\n  public preAuthorizeMiddleware: PreAuthorizeMiddleware<any>[] = [\n    urlVerification,\n  ];\n\n  // deno-lint-ignore no-explicit-any\n  public postAuthorizeMiddleware: Middleware<any>[] = [ignoringSelfEvents];\n\n  #slashCommands: ((\n    body: SlackRequestBody,\n  ) => SlackMessageHandler<E, SlashCommand> | null)[] = [];\n  #events: ((\n    body: SlackRequestBody,\n  ) => SlackHandler<E, SlackEvent<string>> | null)[] = [];\n  #globalShorcuts: ((\n    body: SlackRequestBody,\n  ) => SlackHandler<E, GlobalShortcut> | null)[] = [];\n  #messageShorcuts: ((\n    body: SlackRequestBody,\n  ) => SlackHandler<E, MessageShortcut> | null)[] = [];\n  #blockActions: ((body: SlackRequestBody) =>\n    | SlackHandler<\n      E,\n      // deno-lint-ignore no-explicit-any\n      BlockAction<any>\n    >\n    | null)[] = [];\n  #blockSuggestions: ((\n    body: SlackRequestBody,\n  ) => SlackOptionsHandler<E, BlockSuggestion> | null)[] = [];\n  #viewSubmissions: ((\n    body: SlackRequestBody,\n  ) => SlackViewHandler<E, ViewSubmission> | null)[] = [];\n  #viewClosed: ((\n    body: SlackRequestBody,\n  ) => SlackViewHandler<E, ViewClosed> | null)[] = [];\n\n  constructor(options: SlackAppOptions<E>) {", "    if (\n      options.env.SLACK_BOT_TOKEN === undefined &&\n      (options.authorize === undefined ||\n        options.authorize === singleTeamAuthorize)\n    ) {\n      throw new ConfigError(\n        \"When you don't pass env.SLACK_BOT_TOKEN, your own authorize function, which supplies a valid token to use, needs to be passed instead.\",\n      );\n    }\n    this.env = options.env;\n    this.client = new SlackAPIClient(options.env.SLACK_BOT_TOKEN, {\n      logLevel: this.env.SLACK_LOGGING_LEVEL,\n    });\n    this.appLevelToken = options.env.SLACK_APP_TOKEN;\n    this.socketMode = options.socketMode ?? this.appLevelToken !== undefined;", "    if (this.socketMode) {\n      this.signingSecret = \"\";\n    } else {\n      if (!this.env.SLACK_SIGNING_SECRET) {\n        throw new ConfigError(\n          \"env.SLACK_SIGNING_SECRET is required to run your app on edge functions!\",\n        );\n      }\n      this.signingSecret = this.env.SLACK_SIGNING_SECRET;\n    }\n    this.authorize = options.authorize ?? singleTeamAuthorize;\n    this.routes = { events: options.routes?.events };\n  }\n\n  beforeAuthorize(middleware: PreAuthorizeMiddleware<E>): SlackApp<E> {\n    this.preAuthorizeMiddleware.push(middleware);\n    return this;\n  }\n\n  middleware(middleware: Middleware<E>): SlackApp<E> {\n    return this.afterAuthorize(middleware);\n  }\n\n  use(middleware: Middleware<E>): SlackApp<E> {\n    return this.afterAuthorize(middleware);\n  }\n\n  afterAuthorize(middleware: Middleware<E>): SlackApp<E> {\n    this.postAuthorizeMiddleware.push(middleware);\n    return this;\n  }\n\n  command(\n    pattern: StringOrRegExp,\n    ack: (\n      req: SlackRequestWithRespond<E, SlashCommand>,\n    ) => Promise<MessageAckResponse>,\n    lazy: (\n      req: SlackRequestWithRespond<E, SlashCommand>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackMessageHandler<E, SlashCommand> = { ack, lazy };\n    this.#slashCommands.push((body) => {", "      if (body.type || !body.command) {\n        return null;\n      }\n      if (typeof pattern === \"string\" && body.command === pattern) {\n        return handler;\n      } else if (\n        typeof pattern === \"object\" &&\n        pattern instanceof RegExp &&\n        body.command.match(pattern)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  event<Type extends string>(\n    event: Type,\n    lazy: (req: EventRequest<E, Type>) => Promise<void>,\n  ): SlackApp<E> {\n    this.#events.push((body) => {", "      if (body.type !== PayloadType.EventsAPI || !body.event) {\n        return null;\n      }\n      if (body.event.type === event) {\n        // deno-lint-ignore require-await\n        return { ack: async () => \"\", lazy };\n      }\n      return null;\n    });\n    return this;\n  }\n\n  anyMessage(lazy: MessageEventHandler<E>): SlackApp<E> {\n    return this.message(undefined, lazy);\n  }\n\n  message(\n    pattern: MessageEventPattern,\n    lazy: MessageEventHandler<E>,\n  ): SlackApp<E> {\n    this.#events.push((body) => {", "      if (\n        body.type !== PayloadType.EventsAPI ||\n        !body.event ||\n        body.event.type !== \"message\"\n      ) {\n        return null;\n      }\n      if (isPostedMessageEvent(body.event)) {\n        let matched = true;\n        if (pattern !== undefined) {\n          if (typeof pattern === \"string\") {\n            matched = body.event.text!.includes(pattern);\n          }", "        if (pattern !== undefined) {\n          if (typeof pattern === \"string\") {\n            matched = body.event.text!.includes(pattern);\n          }\n          if (typeof pattern === \"object\") {\n            matched = body.event.text!.match(pattern) !== null;\n          }\n        }\n        if (matched) {\n          // deno-lint-ignore require-await\n          return { ack: async (_: EventRequest<E, \"message\">) => \"\", lazy };\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  shortcut(\n    callbackId: StringOrRegExp,\n    ack: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>,\n    ) => Promise<AckResponse>,\n    lazy: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    return this.globalShortcut(callbackId, ack, lazy).messageShortcut(\n      callbackId,\n      ack,\n      lazy,\n    );\n  }\n\n  globalShortcut(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, GlobalShortcut>) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequest<E, GlobalShortcut>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, GlobalShortcut> = { ack, lazy };\n    this.#globalShorcuts.push((body) => {", "        if (matched) {\n          // deno-lint-ignore require-await\n          return { ack: async (_: EventRequest<E, \"message\">) => \"\", lazy };\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  shortcut(\n    callbackId: StringOrRegExp,\n    ack: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>,\n    ) => Promise<AckResponse>,\n    lazy: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    return this.globalShortcut(callbackId, ack, lazy).messageShortcut(\n      callbackId,\n      ack,\n      lazy,\n    );\n  }\n\n  globalShortcut(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, GlobalShortcut>) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequest<E, GlobalShortcut>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, GlobalShortcut> = { ack, lazy };\n    this.#globalShorcuts.push((body) => {", "      if (body.type !== PayloadType.GlobalShortcut || !body.callback_id) {\n        return null;\n      }\n      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  messageShortcut(\n    callbackId: StringOrRegExp,\n    ack: (\n      req: SlackRequestWithRespond<E, MessageShortcut>,\n    ) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequestWithRespond<E, MessageShortcut>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, MessageShortcut> = { ack, lazy };\n    this.#messageShorcuts.push((body) => {", "      if (body.type !== PayloadType.MessageShortcut || !body.callback_id) {\n        return null;\n      }\n      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  action<\n    T extends BlockElementTypes,\n    A extends BlockAction<BlockElementAction<T>> = BlockAction<\n      BlockElementAction<T>\n    >,\n  >(\n    constraints:\n      | StringOrRegExp\n      | { type: T; block_id?: string; action_id: string },\n    ack: (req: SlackRequestWithOptionalRespond<E, A>) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequestWithOptionalRespond<E, A>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, A> = { ack, lazy };\n    this.#blockActions.push((body) => {", "      if (\n        body.type !== PayloadType.BlockAction ||\n        !body.actions ||\n        !body.actions[0]\n      ) {\n        return null;\n      }\n      const action = body.actions[0];\n      if (typeof constraints === \"string\" && action.action_id === constraints) {\n        return handler;\n      } else if (typeof constraints === \"object\") {", "      if (typeof constraints === \"string\" && action.action_id === constraints) {\n        return handler;\n      } else if (typeof constraints === \"object\") {\n        if (constraints instanceof RegExp) {\n          if (action.action_id.match(constraints)) {\n            return handler;\n          }\n        } else if (constraints.type) {\n          if (action.type === constraints.type) {\n            if (action.action_id === constraints.action_id) {\n              if (\n                constraints.block_id &&\n                action.block_id !== constraints.block_id\n              ) {\n                return null;\n              }\n              return handler;\n            }\n          }\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  options(\n    constraints: StringOrRegExp | { block_id?: string; action_id: string },\n    ack: (req: SlackRequest<E, BlockSuggestion>) => Promise<OptionsAckResponse>,\n  ): SlackApp<E> {\n    // Note that block_suggestion response must be done within 3 seconds.\n    // So, we don't support the lazy handler for it.\n    const handler: SlackOptionsHandler<E, BlockSuggestion> = { ack };\n    this.#blockSuggestions.push((body) => {", "          if (action.type === constraints.type) {\n            if (action.action_id === constraints.action_id) {\n              if (\n                constraints.block_id &&\n                action.block_id !== constraints.block_id\n              ) {\n                return null;\n              }\n              return handler;\n            }\n          }\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  options(\n    constraints: StringOrRegExp | { block_id?: string; action_id: string },\n    ack: (req: SlackRequest<E, BlockSuggestion>) => Promise<OptionsAckResponse>,\n  ): SlackApp<E> {\n    // Note that block_suggestion response must be done within 3 seconds.\n    // So, we don't support the lazy handler for it.\n    const handler: SlackOptionsHandler<E, BlockSuggestion> = { ack };\n    this.#blockSuggestions.push((body) => {", "      if (body.type !== PayloadType.BlockSuggestion || !body.action_id) {\n        return null;\n      }\n      if (typeof constraints === \"string\" && body.action_id === constraints) {\n        return handler;\n      } else if (typeof constraints === \"object\") {\n        if (constraints instanceof RegExp) {\n          if (body.action_id.match(constraints)) {\n            return handler;\n          }\n        } else {", "          if (body.action_id === constraints.action_id) {\n            if (body.block_id && body.block_id !== constraints.block_id) {\n              return null;\n            }\n            return handler;\n          }\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  view(\n    callbackId: StringOrRegExp,\n    ack: (\n      req:\n        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n        | SlackRequest<E, ViewClosed>,\n    ) => Promise<ViewAckResponse>,\n    lazy: (\n      req:\n        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n        | SlackRequest<E, ViewClosed>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    return this.viewSubmission(callbackId, ack, lazy).viewClosed(\n      callbackId,\n      ack,\n      lazy,\n    );\n  }\n\n  viewSubmission(\n    callbackId: StringOrRegExp,\n    ack: (\n      req: SlackRequestWithOptionalRespond<E, ViewSubmission>,\n    ) => Promise<ViewAckResponse>,\n    lazy: (\n      req: SlackRequestWithOptionalRespond<E, ViewSubmission>,\n    ) => Promise<void> = noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackViewHandler<E, ViewSubmission> = { ack, lazy };\n    this.#viewSubmissions.push((body) => {", "      if (body.type !== PayloadType.ViewSubmission || !body.view) {\n        return null;\n      }\n      if (\n        typeof callbackId === \"string\" &&\n        body.view.callback_id === callbackId\n      ) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  viewClosed(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, ViewClosed>) => Promise<ViewAckResponse>,\n    lazy: (req: SlackRequest<E, ViewClosed>) => Promise<void> =\n      noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackViewHandler<E, ViewClosed> = { ack, lazy };\n    this.#viewClosed.push((body) => {", "      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  viewClosed(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, ViewClosed>) => Promise<ViewAckResponse>,\n    lazy: (req: SlackRequest<E, ViewClosed>) => Promise<void> =\n      noopLazyListener,\n  ): SlackApp<E> {\n    const handler: SlackViewHandler<E, ViewClosed> = { ack, lazy };\n    this.#viewClosed.push((body) => {", "      if (body.type !== PayloadType.ViewClosed || !body.view) {\n        return null;\n      }\n      if (\n        typeof callbackId === \"string\" &&\n        body.view.callback_id === callbackId\n      ) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  async run(\n    request: Request,\n    ctx: ExecutionContext = new NoopExecutionContext(),\n  ): Promise<Response> {\n    return await this.handleEventRequest(request, ctx);\n  }\n\n  async connect(): Promise<void> {", "      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  async run(\n    request: Request,\n    ctx: ExecutionContext = new NoopExecutionContext(),\n  ): Promise<Response> {\n    return await this.handleEventRequest(request, ctx);\n  }\n\n  async connect(): Promise<void> {", "    if (!this.socketMode) {\n      throw new ConfigError(\n        \"Both env.SLACK_APP_TOKEN and socketMode: true are required to start a Socket Mode connection!\",\n      );\n    }\n    this.socketModeClient = new SocketModeClient(this);\n    await this.socketModeClient.connect();\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.socketModeClient) {\n      await this.socketModeClient.disconnect();\n    }\n  }\n\n  async handleEventRequest(\n    request: Request,\n    ctx: ExecutionContext,\n  ): Promise<Response> {\n    // If the routes.events is missing, any URLs can work for handing requests from Slack", "    if (this.socketModeClient) {\n      await this.socketModeClient.disconnect();\n    }\n  }\n\n  async handleEventRequest(\n    request: Request,\n    ctx: ExecutionContext,\n  ): Promise<Response> {\n    // If the routes.events is missing, any URLs can work for handing requests from Slack\n    if (this.routes.events) {\n      const { pathname } = new URL(request.url);", "    if (this.routes.events) {\n      const { pathname } = new URL(request.url);\n      if (pathname !== this.routes.events) {\n        return new Response(\"Not found\", { status: 404 });\n      }\n    }\n\n    // To avoid the following warning by Cloudflware, parse the body as Blob first\n    // Called .text() on an HTTP body which does not appear to be text ..\n    const blobRequestBody = await request.blob();\n    // We can safely assume the incoming request body is always text data\n    const rawBody: string = await blobRequestBody.text();\n\n    // For Request URL verification", "    if (rawBody.includes(\"ssl_check=\")) {\n      // Slack does not send the x-slack-signature header for this pattern.\n      // Thus, we need to check the pattern before verifying a request.\n      const bodyParams = new URLSearchParams(rawBody);\n      if (bodyParams.get(\"ssl_check\") === \"1\" && bodyParams.get(\"token\")) {\n        return new Response(\"\", { status: 200 });\n      }\n    }\n\n    // Verify the request headers and body\n    const isRequestSignatureVerified = this.socketMode ||\n      (await verifySlackRequest(this.signingSecret, request.headers, rawBody));", "    if (isRequestSignatureVerified) {\n      // deno-lint-ignore no-explicit-any\n      const body: Record<string, any> = await parseRequestBody(\n        request.headers,\n        rawBody,\n      );\n      let retryNum: number | undefined = undefined;\n      try {\n        const retryNumHeader = request.headers.get(\"x-slack-retry-num\");\n        if (retryNumHeader) {\n          retryNum = Number.parseInt(retryNumHeader);", "        if (retryNumHeader) {\n          retryNum = Number.parseInt(retryNumHeader);\n        } else if (this.socketMode && body.retry_attempt) {\n          retryNum = Number.parseInt(body.retry_attempt);\n        }\n        // deno-lint-ignore no-unused-vars\n      } catch (e) {\n        // Ignore an exception here\n      }\n      const retryReason = request.headers.get(\"x-slack-retry-reason\") ??\n        body.retry_reason;\n      const preAuthorizeRequest: PreAuthorizeSlackMiddlwareRequest<E> = {\n        body,\n        rawBody,\n        retryNum,\n        retryReason,\n        context: builtBaseContext(body),\n        env: this.env,\n        headers: request.headers,\n      };", "      if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n        console.log(`*** Received request body ***\\n ${prettyPrint(body)}`);\n      }\n      for (const middlware of this.preAuthorizeMiddleware) {\n        const response = await middlware(preAuthorizeRequest);\n        if (response) {\n          return toCompleteResponse(response);\n        }\n      }\n      const authorizeResult: AuthorizeResult = await this.authorize(\n        preAuthorizeRequest,\n      );\n      const authorizedContext: SlackAppContext = {\n        ...preAuthorizeRequest.context,\n        authorizeResult,\n        client: new SlackAPIClient(authorizeResult.botToken, {\n          logLevel: this.env.SLACK_LOGGING_LEVEL,\n        }),\n        botToken: authorizeResult.botToken,\n        botId: authorizeResult.botId,\n        botUserId: authorizeResult.botUserId,\n        userToken: authorizeResult.userToken,\n      };", "      if (authorizedContext.channelId) {\n        const context = authorizedContext as SlackAppContextWithChannelId;\n        const client = new SlackAPIClient(context.botToken);\n        context.say = async (params) =>\n          await client.chat.postMessage({\n            channel: context.channelId,\n            ...params,\n          });\n      }\n      if (authorizedContext.responseUrl) {\n        const responseUrl = authorizedContext.responseUrl;\n        // deno-lint-ignore require-await\n        (authorizedContext as SlackAppContextWithRespond).respond = async (\n          params,\n        ) => {\n          return new ResponseUrlSender(responseUrl).call(params);\n        };\n      }\n\n      const baseRequest: SlackMiddlwareRequest<E> = {\n        ...preAuthorizeRequest,\n        context: authorizedContext,\n      };", "      if (authorizedContext.responseUrl) {\n        const responseUrl = authorizedContext.responseUrl;\n        // deno-lint-ignore require-await\n        (authorizedContext as SlackAppContextWithRespond).respond = async (\n          params,\n        ) => {\n          return new ResponseUrlSender(responseUrl).call(params);\n        };\n      }\n\n      const baseRequest: SlackMiddlwareRequest<E> = {\n        ...preAuthorizeRequest,\n        context: authorizedContext,\n      };", "      for (const middlware of this.postAuthorizeMiddleware) {\n        const response = await middlware(baseRequest);\n        if (response) {\n          return toCompleteResponse(response);\n        }\n      }\n\n      const payload = body as SlackRequestBody;\n\n      if (body.type === PayloadType.EventsAPI) {\n        // Events API\n        const slackRequest: SlackRequest<E, SlackEvent<string>> = {\n          payload: body.event,\n          ...baseRequest,\n        };", "      if (body.type === PayloadType.EventsAPI) {\n        // Events API\n        const slackRequest: SlackRequest<E, SlackEvent<string>> = {\n          payload: body.event,\n          ...baseRequest,\n        };\n        for (const matcher of this.#events) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (!body.type && body.command) {\n        // Slash commands\n        const slackRequest: SlackRequest<E, SlashCommand> = {\n          payload: body as SlashCommand,\n          ...baseRequest,\n        };\n        for (const matcher of this.#slashCommands) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.GlobalShortcut) {\n        // Global shortcuts\n        const slackRequest: SlackRequest<E, GlobalShortcut> = {\n          payload: body as GlobalShortcut,\n          ...baseRequest,\n        };\n        for (const matcher of this.#globalShorcuts) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.MessageShortcut) {\n        // Message shortcuts\n        const slackRequest: SlackRequest<E, MessageShortcut> = {\n          payload: body as MessageShortcut,\n          ...baseRequest,\n        };\n        for (const matcher of this.#messageShorcuts) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.BlockAction) {\n        // Block actions\n        // deno-lint-ignore no-explicit-any\n        const slackRequest: SlackRequest<E, BlockAction<any>> = {\n          // deno-lint-ignore no-explicit-any\n          payload: body as BlockAction<any>,\n          ...baseRequest,\n        };\n        for (const matcher of this.#blockActions) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "        for (const matcher of this.#blockActions) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.BlockSuggestion) {\n        // Block suggestions\n        const slackRequest: SlackRequest<E, BlockSuggestion> = {\n          payload: body as BlockSuggestion,\n          ...baseRequest,\n        };\n        for (const matcher of this.#blockSuggestions) {\n          const handler = matcher(payload);\n          if (handler) {\n            // Note that the only way to respond to a block_suggestion request\n            // is to send an HTTP response with options/option_groups.\n            // Thus, we don't support lazy handlers for this pattern.\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            // Note that the only way to respond to a block_suggestion request\n            // is to send an HTTP response with options/option_groups.\n            // Thus, we don't support lazy handlers for this pattern.\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.ViewSubmission) {\n        // View submissions\n        const slackRequest: SlackRequest<E, ViewSubmission> = {\n          payload: body as ViewSubmission,\n          ...baseRequest,\n        };\n        for (const matcher of this.#viewSubmissions) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.ViewClosed) {\n        // View closed\n        const slackRequest: SlackRequest<E, ViewClosed> = {\n          payload: body as ViewClosed,\n          ...baseRequest,\n        };\n        for (const matcher of this.#viewClosed) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }\n      }\n      // TODO: Add code suggestion here\n      console.log(\n        `*** No listener found ***\\n${JSON.stringify(baseRequest.body)}`,\n      );\n      return new Response(\"No listener found\", { status: 404 });\n    }\n    return new Response(\"Invalid signature\", { status: 401 });\n  }\n}\n", "export type StringOrRegExp = string | RegExp;\n\nexport type EventRequest<E extends SlackAppEnv, T> = Extract<\n  AnySlackEventWithChannelId,\n  { type: T }\n> extends never ? SlackRequest<E, Extract<AnySlackEvent, { type: T }>>\n  : SlackRequestWithChannelId<\n    E,\n    Extract<AnySlackEventWithChannelId, { type: T }>\n  >;\n", "export type MessageEventPattern = string | RegExp | undefined;\n\nexport type MessageEventRequest<\n  E extends SlackAppEnv,\n  ST extends string | undefined,\n> = SlackRequestWithChannelId<\n  E,\n  Extract<AnySlackEventWithChannelId, { subtype: ST }>\n>;\n\nexport type MessageEventSubtypes =\n  | undefined\n  | \"bot_message\"\n  | \"thread_broadcast\"\n  | \"file_share\";\n", "export type MessageEventSubtypes =\n  | undefined\n  | \"bot_message\"\n  | \"thread_broadcast\"\n  | \"file_share\";\n\nexport type MessageEventHandler<E extends SlackAppEnv> = (\n  req: MessageEventRequest<E, MessageEventSubtypes>,\n) => Promise<void>;\n\nexport const noopLazyListener = async () => {};\n"]}
{"filename": "src_deno/execution-context.ts", "chunked_list": ["/**\n * An interface representing context parameter in Cloudflare Workers and Vercel Edge Functions.\n * Refer to the following resources:\n * - https://developers.cloudflare.com/workers/runtime-apis/fetch-event/\n * - https://vercel.com/docs/concepts/functions/edge-functions/edge-functions-api#waituntil\n */\nexport interface ExecutionContext {\n  // deno-lint-ignore no-explicit-any\n  waitUntil(promise: Promise<any>): void;\n}\n", "export class NoopExecutionContext implements ExecutionContext {\n  // deno-lint-ignore no-explicit-any\n  waitUntil(promise: Promise<any>): void {\n    promise.catch((reason) => {\n      console.error(`Failed to run a lazy listener: ${reason}`);\n    });\n  }\n}\n"]}
{"filename": "src_deno/cookie.ts", "chunked_list": ["/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Parse a cookie header.\n *", " * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function parse(\n  str: string,\n  // deno-lint-ignore no-explicit-any\n  options: any | undefined = undefined,\n): Record<string, string> {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n\n  // deno-lint-ignore no-explicit-any\n  const obj: any = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n\n  let index = 0;", "  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n\n  // deno-lint-ignore no-explicit-any\n  const obj: any = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    // no more cookie pairs", "  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n\n    // only assign once", "    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n\n    // only assign once\n    if (undefined === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      // quoted values", "    if (undefined === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  }\n  return obj;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */", "function decode(str: string): string {\n  return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n */\nfunction tryDecode(str: string, decode: (val: string) => string) {\n  try {\n    return decode(str);\n    // deno-lint-ignore no-unused-vars", "  try {\n    return decode(str);\n    // deno-lint-ignore no-unused-vars\n  } catch (e) {\n    return str;\n  }\n}\n"]}
{"filename": "src_deno/errors.ts", "chunked_list": ["export class ConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ConfigError\";\n  }\n}\n\nexport class AuthorizeError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AuthorizeError\";\n  }\n}\n", "export class SocketModeError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SocketModeError\";\n  }\n}\n"]}
{"filename": "src_deno/index.ts", "chunked_list": ["export * from \"./app.ts\";\nexport * from \"./app-env.ts\";\nexport * from \"./execution-context.ts\";\n\nexport * from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport * from \"./errors.ts\";\nexport * from \"./oauth/error-codes.ts\";\n\nexport * from \"./handler/handler.ts\";", "\nexport * from \"./handler/handler.ts\";\nexport * from \"./handler/message-handler.ts\";\nexport * from \"./handler/options-handler.ts\";\nexport * from \"./handler/view-handler.ts\";\n\nexport * from \"./authorization/authorize.ts\";\nexport * from \"./authorization/authorize-result.ts\";\nexport * from \"./authorization/single-team-authorize.ts\";\n", "export * from \"./authorization/single-team-authorize.ts\";\n\nexport * from \"./middleware/middleware.ts\";\nexport * from \"./middleware/built-in-middleware.ts\";\n\nexport * from \"./context/context.ts\";\n\nexport * from \"./oauth-app.ts\";\nexport * from \"./oauth/authorize-url-generator.ts\";\nexport * from \"./oauth/callback.ts\";", "export * from \"./oauth/authorize-url-generator.ts\";\nexport * from \"./oauth/callback.ts\";\nexport * from \"./oauth/escape-html.ts\";\nexport * from \"./oauth/installation.ts\";\nexport * from \"./oauth/installation-store.ts\";\nexport * from \"./oauth/oauth-page-renderer.ts\";\nexport * from \"./oauth/state-store.ts\";\n\nexport * from \"./oidc/authorize-url-generator.ts\";\nexport * from \"./oidc/callback.ts\";", "export * from \"./oidc/authorize-url-generator.ts\";\nexport * from \"./oidc/callback.ts\";\nexport * from \"./oidc/login.ts\";\n\nexport * from \"./request/request-body.ts\";\nexport * from \"./request/request-verification.ts\";\nexport * from \"./request/request.ts\";\nexport * from \"./request/payload-types.ts\";\n\nexport * from \"./request/payload/block-action.ts\";", "\nexport * from \"./request/payload/block-action.ts\";\nexport * from \"./request/payload/block-suggestion.ts\";\nexport * from \"./request/payload/event.ts\";\nexport * from \"./request/payload/global-shortcut.ts\";\nexport * from \"./request/payload/message-shortcut.ts\";\nexport * from \"./request/payload/slash-command.ts\";\nexport * from \"./request/payload/view-submission.ts\";\nexport * from \"./request/payload/view-closed.ts\";\nexport * from \"./request/payload/view-objects.ts\";", "export * from \"./request/payload/view-closed.ts\";\nexport * from \"./request/payload/view-objects.ts\";\n\nexport * from \"./response/response.ts\";\nexport * from \"./socket-mode/socket-mode-client.ts\";\n\nexport * from \"./utility/message-events.ts\";\n"]}
{"filename": "src_deno/app-env.ts", "chunked_list": ["export interface SlackLoggingLevel {\n  SLACK_LOGGING_LEVEL?: \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\n}\n\nexport type SlackAppEnv = SlackLoggingLevel & {\n  SLACK_SIGNING_SECRET?: string;\n  SLACK_BOT_TOKEN?: string;\n  SLACK_APP_TOKEN?: string;\n};\n\nexport type SlackEdgeAppEnv = SlackAppEnv & {\n  SLACK_SIGNING_SECRET: string;\n  SLACK_BOT_TOKEN?: string;\n};\n", "export type SlackEdgeAppEnv = SlackAppEnv & {\n  SLACK_SIGNING_SECRET: string;\n  SLACK_BOT_TOKEN?: string;\n};\n\nexport type SlackSocketModeAppEnv = SlackAppEnv & {\n  SLACK_SIGNING_SECRET?: string;\n  SLACK_BOT_TOKEN?: string;\n  SLACK_APP_TOKEN: string;\n};\n", "export type SlackOAuthEnv = (SlackEdgeAppEnv | SlackSocketModeAppEnv) & {\n  SLACK_CLIENT_ID: string;\n  SLACK_CLIENT_SECRET: string;\n  SLACK_BOT_SCOPES: string;\n  SLACK_USER_SCOPES?: string;\n  SLACK_REDIRECT_URI?: string;\n  SLACK_OIDC_SCOPES?: string;\n  SLACK_OIDC_REDIRECT_URI?: string;\n  SLACK_USER_TOKEN_RESOLUTION?: \"installer\" | \"actor\";\n};\n", "export type SlackOIDCEnv = SlackAppEnv & {\n  SLACK_CLIENT_ID: string;\n  SLACK_CLIENT_SECRET: string;\n  SLACK_OIDC_SCOPES?: string;\n  SLACK_OIDC_REDIRECT_URI: string;\n};\n\nexport type SlackOAuthAndOIDCEnv = SlackOAuthEnv & SlackOIDCEnv;\n"]}
{"filename": "src_deno/oidc/callback.ts", "chunked_list": ["import { SlackLoggingLevel } from \"../app-env.ts\";\nimport {\n  OpenIDConnectTokenResponse,\n  SlackAPIClient,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { prettyPrint } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport type OpenIDConnectCallback = (\n  apiResponse: OpenIDConnectTokenResponse,\n  req: Request,\n) => Promise<Response>;\n", "export function defaultOpenIDConnectCallback(\n  env: SlackLoggingLevel,\n): OpenIDConnectCallback {\n  // deno-lint-ignore no-unused-vars\n  return async (token, req) => {\n    const client = new SlackAPIClient(token.access_token, {\n      logLevel: env.SLACK_LOGGING_LEVEL,\n    });\n    const userInfo = await client.openid.connect.userInfo();\n    const body =\n      `<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h1>It works!</h1><p>This is the default handler. To change this, pass \\`oidc: { callback: async (token, req) => new Response(\"TODO\") }\\` to your SlackOAuthApp constructor.</p><pre>${\n        prettyPrint(\n          userInfo,\n        )\n      }</pre></body></html>`;\n\n    return new Response(body, {\n      status: 200,\n      headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n    });\n  };\n}\n"]}
{"filename": "src_deno/oidc/login.ts", "chunked_list": ["import {\n  OpenIDConnectTokenResponse,\n  OpenIDConnectUserInfoResponse,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport interface Login {\n  enterprise_id?: string;\n  team_id: string;\n  user_id: string;\n  name?: string;\n  email?: string;\n  picture?: string;\n\n  access_token: string;\n  refresh_token?: string; // token rotation\n  token_expires_at?: number; // token rotation (epoch time seconds)\n}\n", "export function toLogin(\n  token: OpenIDConnectTokenResponse,\n  userInfo: OpenIDConnectUserInfoResponse,\n): Login {\n  return {\n    enterprise_id: userInfo[\"https://slack.com/enterprise_id\"],\n    team_id: userInfo[\"https://slack.com/team_id\"]!,\n    user_id: userInfo[\"https://slack.com/user_id\"]!,\n    email: userInfo.email,\n    picture: userInfo.picture,\n    access_token: token.access_token!,\n    refresh_token: token.refresh_token,\n    token_expires_at: token.expires_in\n      ? new Date().getTime() / 1000 + token.expires_in\n      : undefined,\n  };\n}\n"]}
{"filename": "src_deno/oidc/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env.ts\";\nimport { ConfigError } from \"../errors.ts\";\n\nexport function generateOIDCAuthorizeUrl<E extends SlackOAuthEnv>(\n  state: string,\n  env: E,\n): string {\n  if (!env.SLACK_OIDC_SCOPES) {\n    throw new ConfigError(\n      \"env.SLACK_OIDC_SCOPES must be present when enabling Sign in with Slack (OpenID Connect)\",\n    );\n  }", "  if (!env.SLACK_OIDC_REDIRECT_URI) {\n    throw new ConfigError(\n      \"env.SLACK_OIDC_REDIRECT_URI must be present when enabling Sign in with Slack (OpenID Connect)\",\n    );\n  }\n  let url =\n    `https://slack.com/openid/connect/authorize?response_type=code&state=${state}`;\n  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n  url += `&scope=${env.SLACK_OIDC_SCOPES}`;\n  url += `&redirect_uri=${env.SLACK_OIDC_REDIRECT_URI}`;\n  return url;\n}\n"]}
{"filename": "src_deno/context/context.ts", "chunked_list": ["import { AuthorizeResult } from \"../authorization/authorize-result.ts\";\nimport {\n  ChatPostMessageRequest,\n  ChatPostMessageResponse,\n  SlackAPIClient,\n  WebhookParams,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport interface PreAuthorizeSlackAppContext {\n  isEnterpriseinstall?: boolean;\n  enterpriseId?: string;\n  teamId?: string;\n  userId?: string;\n  actorEnterpriseId?: string;\n  actorTeamId?: string;\n  actorUserId?: string;\n  botId?: string;\n  botUserId?: string;\n  responseUrl?: string;\n  channelId?: string;\n  custom: {\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any; // custom properties\n  };\n}\n", "export interface PreAuthorizeSlackAppContext {\n  isEnterpriseinstall?: boolean;\n  enterpriseId?: string;\n  teamId?: string;\n  userId?: string;\n  actorEnterpriseId?: string;\n  actorTeamId?: string;\n  actorUserId?: string;\n  botId?: string;\n  botUserId?: string;\n  responseUrl?: string;\n  channelId?: string;\n  custom: {\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any; // custom properties\n  };\n}\n", "export type SlackAppContext = {\n  client: SlackAPIClient;\n  botToken: string;\n  userToken?: string;\n  authorizeResult: AuthorizeResult;\n} & PreAuthorizeSlackAppContext;\n\nexport type SlackAppContextWithChannelId = {\n  channelId: string;\n  say: (\n    params: Omit<ChatPostMessageRequest, \"channel\">,\n  ) => Promise<ChatPostMessageResponse>;\n} & SlackAppContext;\n", "export type SlackAppContextWithRespond = {\n  channelId: string;\n  respond: (params: WebhookParams) => Promise<Response>;\n} & SlackAppContext;\n\nexport type SlackAppContextWithOptionalRespond = {\n  respond?: (params: WebhookParams) => Promise<Response>;\n} & SlackAppContext;\n\nexport function builtBaseContext(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): PreAuthorizeSlackAppContext {\n  return {\n    isEnterpriseinstall: extractIsEnterpriseInstall(body),\n    enterpriseId: extractEnterpriseId(body),\n    teamId: extractTeamId(body),\n    userId: extractUserId(body),\n    actorEnterpriseId: extractActorEnterpriseId(body),\n    actorTeamId: extractActorTeamId(body),\n    actorUserId: extractActorUserId(body),\n    botId: undefined, // will be set later\n    botUserId: undefined, // will be set later\n    responseUrl: extractResponseUrl(body),\n    channelId: extractChannelId(body),\n    custom: {},\n  };\n}\n", "export function builtBaseContext(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): PreAuthorizeSlackAppContext {\n  return {\n    isEnterpriseinstall: extractIsEnterpriseInstall(body),\n    enterpriseId: extractEnterpriseId(body),\n    teamId: extractTeamId(body),\n    userId: extractUserId(body),\n    actorEnterpriseId: extractActorEnterpriseId(body),\n    actorTeamId: extractActorTeamId(body),\n    actorUserId: extractActorUserId(body),\n    botId: undefined, // will be set later\n    botUserId: undefined, // will be set later\n    responseUrl: extractResponseUrl(body),\n    channelId: extractChannelId(body),\n    custom: {},\n  };\n}\n", "export function extractIsEnterpriseInstall(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): boolean | undefined {\n  if (body.authorizations && body.authorizations.length > 0) {\n    return body.authorizations[0].is_enterprise_install;\n  } else if (body.is_enterprise_install) {\n    if (typeof body.is_enterprise_install === \"string\") {\n      // slash command payloads\n      return body.is_enterprise_install === \"true\";\n    }\n    return body.is_enterprise_install == true;\n  }\n  return undefined;\n}\n", "export function extractEnterpriseId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {\n  if (body.enterprise) {\n    if (typeof body.enterprise === \"string\") {\n      return body.enterprise;\n    } else if (typeof body.enterprise === \"object\" && body.enterprise.id) {\n      return body.enterprise.id;\n    }\n  } else if (body.authorizations && body.authorizations.length > 0) {\n    return extractEnterpriseId(body.authorizations[0]);", "  } else if (body.authorizations && body.authorizations.length > 0) {\n    return extractEnterpriseId(body.authorizations[0]);\n  } else if (body.enterprise_id) {\n    return body.enterprise_id;\n  } else if (\n    body.team &&\n    typeof body.team === \"object\" &&\n    body.team.enterprise_id\n  ) {\n    return body.team.enterprise_id;\n  } else if (body.event) {\n    return extractEnterpriseId(body.event);\n  }\n  return undefined;\n}\n\n// deno-lint-ignore no-explicit-any", "  } else if (body.event) {\n    return extractEnterpriseId(body.event);\n  }\n  return undefined;\n}\n\n// deno-lint-ignore no-explicit-any\nexport function extractTeamId(body: Record<string, any>): string | undefined {\n  if (body.view && body.view.app_installed_team_id) {\n    // view_submission payloads can have `view.app_installed_team_id`\n    // when a modal view that was opened in a different workspace via some operations inside a Slack Connect channel.\n    // Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,\n    // you have to run some query toward your InstallationStore to know the org where the team_id belongs to.\n    return body.view.app_installed_team_id;", "  if (body.view && body.view.app_installed_team_id) {\n    // view_submission payloads can have `view.app_installed_team_id`\n    // when a modal view that was opened in a different workspace via some operations inside a Slack Connect channel.\n    // Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,\n    // you have to run some query toward your InstallationStore to know the org where the team_id belongs to.\n    return body.view.app_installed_team_id;\n  } else if (body.team) {\n    // With org-wide installations, payload.team in interactivity payloads can be None\n    // You need to extract either payload.user.team_id or payload.view.team_id as below\n    if (typeof body.team === \"string\") {\n      return body.team;", "    if (typeof body.team === \"string\") {\n      return body.team;\n    } else if (body.team.id) {\n      return body.team.id;\n    }\n  } else if (body.authorizations && body.authorizations.length > 0) {\n    // To make Events API handling functioning also for shared channels,\n    // we should use .authorizations[0].team_id over .team_id\n    return extractTeamId(body.authorizations[0]);\n  } else if (body.team_id) {\n    return body.team_id;", "  } else if (body.team_id) {\n    return body.team_id;\n  } else if (body.user && typeof body.user === \"object\") {\n    return body.user.team_id;\n  } else if (body.view && typeof body.view === \"object\") {\n    return body.view.team_id;\n  }\n  return undefined;\n}\n\n// deno-lint-ignore no-explicit-any", "export function extractUserId(body: Record<string, any>): string | undefined {\n  if (body.user) {\n    if (typeof body.user === \"string\") {\n      return body.user;\n    }\n    if (typeof body.user === \"object\" && body.user.id) {\n      return body.user.id;\n    }\n  } else if (body.user_id) {\n    return body.user_id;\n  } else if (body.event) {\n    return extractUserId(body.event);", "  } else if (body.user_id) {\n    return body.user_id;\n  } else if (body.event) {\n    return extractUserId(body.event);\n  } else if (body.message) {\n    return extractUserId(body.message);\n  } else if (body.previous_message) {\n    return extractUserId(body.previous_message);\n  }\n  return undefined;\n}\n", "export function extractActorEnterpriseId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {\n  if (body.is_ext_shared_channel) {\n    if (body.type === \"event_callback\") {\n      const eventTeamId = body.event?.user_team || body.event?.team;\n      if (eventTeamId && eventTeamId.startsWith(\"E\")) {\n        return eventTeamId;\n      } else if (eventTeamId === body.team_id) {\n        return body.enterprise_id;\n      }\n    }\n  }\n  return extractEnterpriseId(body);\n}\n", "      } else if (eventTeamId === body.team_id) {\n        return body.enterprise_id;\n      }\n    }\n  }\n  return extractEnterpriseId(body);\n}\n\nexport function extractActorTeamId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {", "export function extractActorTeamId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {\n  if (body.is_ext_shared_channel) {\n    if (body.type === \"event_callback\") {\n      const eventType = body.event.type;\n      if (eventType === \"app_mention\") {\n        // The $.event.user_team can be an enterprise_id in app_mention events.\n        // In the scenario, there is no way to retrieve actor_team_id as of March 2023\n        const userTeam = body.event.user_team;", "        if (!userTeam) {\n          // working with an app installed in this user's org/workspace side\n          return body.event.team;\n        } else if (userTeam.startsWith(\"T\")) {\n          // interacting from a connected non-grid workspace\n          return userTeam;\n        }\n        // Interacting from a connected grid workspace; in this case, team_id cannot be resolved as of March 2023\n        return undefined;\n      }\n      const eventUserTeam = body.event.user_team;", "      if (eventUserTeam) {\n        if (eventUserTeam.startsWith(\"T\")) {\n          return eventUserTeam;\n        } else if (eventUserTeam.startsWith(\"E\")) {\n          if (eventUserTeam === body.enterprise_id) {\n            return body.team_id;\n          } else if (eventUserTeam === body.context_enterprise_id) {\n            return body.context_team_id;\n          }\n        }\n      }\n      const eventTeam = body.event.team;", "      if (eventTeam) {\n        if (eventTeam.startsWith(\"T\")) {\n          return eventTeam;\n        } else if (eventTeam.startsWith(\"E\")) {\n          if (eventTeam === body.enterprise_id) {\n            return body.team_id;\n          } else if (eventTeam === body.context_enterprise_id) {\n            return body.context_team_id;\n          }\n        }\n      }\n    }\n  }\n  return extractTeamId(body);\n}\n", "export function extractActorUserId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {\n  if (body.is_ext_shared_channel) {\n    if (body.type === \"event_callback\") {\n      if (body.event) {\n        if (extractActorEnterpriseId(body) && extractActorTeamId(body)) {\n          // When both enterprise_id and team_id are not identified, we skip returning user_id too for safety\n          return undefined;\n        }\n        return body.event.user || body.event.user_id;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  return extractUserId(body);\n}\n", "export function extractResponseUrl(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {\n  if (body.response_url) {\n    return body.response_url;\n  } else if (body.response_urls && body.response_urls.length > 0) {\n    return body.response_urls[0].response_url;\n  }\n  return undefined;\n}\n", "export function extractChannelId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>,\n): string | undefined {\n  if (body.channel) {\n    if (typeof body.channel === \"string\") {\n      return body.channel;\n    } else if (typeof body.channel === \"object\" && body.channel.id) {\n      return body.channel.id;\n    }\n  } else if (body.channel_id) {\n    return body.channel_id;", "  } else if (body.channel_id) {\n    return body.channel_id;\n  } else if (body.event) {\n    return extractChannelId(body.event);\n  } else if (body.item) {\n    // reaction_added: body[\"event\"][\"item\"]\n    return extractChannelId(body.item);\n  }\n  return undefined;\n}\n"]}
{"filename": "src_deno/authorization/single-team-authorize.ts", "chunked_list": ["import { AuthorizeError } from \"../errors.ts\";\nimport {\n  AuthTestResponse,\n  SlackAPIClient,\n  SlackAPIError,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { Authorize } from \"./authorize.ts\";\n\nexport const singleTeamAuthorize: Authorize = async (req) => {\n  // This authorize function supports only the bot token for a workspace\n  const botToken = req.env.SLACK_BOT_TOKEN!;\n  const client = new SlackAPIClient(botToken);", "export const singleTeamAuthorize: Authorize = async (req) => {\n  // This authorize function supports only the bot token for a workspace\n  const botToken = req.env.SLACK_BOT_TOKEN!;\n  const client = new SlackAPIClient(botToken);\n  try {\n    const response: AuthTestResponse = await client.auth.test();\n    const scopes = response.headers.get(\"x-oauth-scopes\") ?? \"\";\n    return {\n      botToken,\n      enterpriseId: response.enterprise_id,\n      teamId: response.team_id,\n      team: response.team,\n      url: response.url,\n      botId: response.bot_id!,\n      botUserId: response.user_id!,\n      userId: response.user_id,\n      user: response.user,\n      botScopes: scopes.split(\",\"),\n      userToken: undefined, // As mentioned above, user tokens are not supported in this module\n      userScopes: undefined, // As mentioned above, user tokens are not supported in this module\n    };", "  } catch (e) {\n    throw new AuthorizeError(\n      `Failed to call auth.test API due to ${(e as SlackAPIError).message}`,\n    );\n  }\n};\n"]}
{"filename": "src_deno/authorization/authorize.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\nimport { PreAuthorizeSlackMiddlwareRequest } from \"../request/request.ts\";\nimport { AuthorizeResult } from \"./authorize-result.ts\";\n\nexport type Authorize<E extends SlackAppEnv = SlackAppEnv> = (\n  req: PreAuthorizeSlackMiddlwareRequest<E>,\n) => Promise<AuthorizeResult>;\n"]}
{"filename": "src_deno/authorization/authorize-result.ts", "chunked_list": ["export interface AuthorizeResult {\n  enterpriseId?: string;\n  teamId?: string;\n  team?: string;\n  url?: string;\n  botId: string;\n  botUserId: string;\n  botToken: string;\n  botScopes: string[];\n  userId?: string;\n  user?: string;\n  userToken?: string;\n  userScopes?: string[];\n}\n"]}
{"filename": "src_deno/socket-mode/socket-mode-client.ts", "chunked_list": ["import {\n  isDebugLogEnabled,\n  SlackAPIClient,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { SlackApp } from \"../app.ts\";\nimport { ConfigError, SocketModeError } from \"../errors.ts\";\nimport { ExecutionContext } from \"../execution-context.ts\";\nimport { SlackSocketModeAppEnv } from \"../app-env.ts\";\n\n// TODO: Implement proper reconnection logic", "\n// TODO: Implement proper reconnection logic\n// TODO: Add connection monitor like 1st party SDKs do\n// TODO: Add Bun support (the runtime does not work well with Socket Mode)\nexport class SocketModeClient {\n  public app: SlackApp<SlackSocketModeAppEnv>;\n  public appLevelToken: string;\n  public ws: WebSocket | undefined;\n\n  constructor(\n    // deno-lint-ignore no-explicit-any\n    app: SlackApp<any>,\n  ) {", "    if (!app.socketMode) {\n      throw new ConfigError(\n        \"socketMode: true must be set for running with Socket Mode\",\n      );\n    }\n    if (!app.appLevelToken) {\n      throw new ConfigError(\n        \"appLevelToken must be set for running with Socket Mode\",\n      );\n    }\n    this.app = app as SlackApp<SlackSocketModeAppEnv>;\n    this.appLevelToken = app.appLevelToken;\n\n    console.warn(\n      \"WARNING: The Socket Mode support provided by slack-edge is still experimental and is not designed to handle reconnections for production-grade applications. It is recommended to use this mode only for local development and testing purposes.\",\n    );\n  }\n\n  async connect() {\n    const client = new SlackAPIClient(this.appLevelToken);", "    try {\n      const newConnection = await client.apps.connections.open();\n      this.ws = new WebSocket(newConnection.url!);\n    } catch (e) {\n      throw new SocketModeError(\n        `Failed to establish a new WSS connection: ${e}`,\n      );\n    }\n    if (this.ws) {\n      const ws = this.ws;\n      // deno-lint-ignore require-await\n      ws.onopen = async (ev) => {\n        // TODO: make this customizable", "    if (this.ws) {\n      const ws = this.ws;\n      // deno-lint-ignore require-await\n      ws.onopen = async (ev) => {\n        // TODO: make this customizable\n        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n          console.log(\n            `Now the Socket Mode client is connected to Slack: ${\n              JSON.stringify(\n                ev,\n              )\n            }`,\n          );\n        }\n      };\n      // deno-lint-ignore require-await\n      ws.onclose = async (ev) => {\n        // TODO: make this customizable", "        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n          console.log(\n            `The Socket Mode client is disconnected from Slack: ${\n              JSON.stringify(\n                ev,\n              )\n            }`,\n          );\n        }\n      };\n      // deno-lint-ignore require-await\n      ws.onerror = async (e) => {\n        // TODO: make this customizable\n        console.error(\n          `An error was thrown by the Socket Mode connection: ${e}`,\n        );\n      };\n\n      const app = this.app;\n      ws.onmessage = async (ev) => {", "        try {\n          if (\n            ev.data &&\n            typeof ev.data === \"string\" &&\n            ev.data.startsWith(\"{\")\n          ) {\n            const data = JSON.parse(ev.data);\n            if (data.type === \"hello\") {\n              if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n                console.log(`*** Received hello data ***\\n ${ev.data}`);\n              }\n              return;\n            }\n            const payload = JSON.stringify(data.payload);\n            console.log(payload);\n            const request: Request = new Request(ws.url, {\n              method: \"POST\",\n              headers: new Headers({ \"content-type\": \"application/json\" }),\n              body: new Blob([payload]).stream(),\n            });\n            const context: ExecutionContext = {\n              // deno-lint-ignore require-await\n              waitUntil: async (promise) => {\n                promise\n                  .then((res) => {\n                    console.info(`Completed a lazy listener execution: ${res}`);\n                  })", "              if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n                console.log(`*** Received hello data ***\\n ${ev.data}`);\n              }\n              return;\n            }\n            const payload = JSON.stringify(data.payload);\n            console.log(payload);\n            const request: Request = new Request(ws.url, {\n              method: \"POST\",\n              headers: new Headers({ \"content-type\": \"application/json\" }),\n              body: new Blob([payload]).stream(),\n            });\n            const context: ExecutionContext = {\n              // deno-lint-ignore require-await\n              waitUntil: async (promise) => {\n                promise\n                  .then((res) => {\n                    console.info(`Completed a lazy listener execution: ${res}`);\n                  })", "                  .catch((err) => {\n                    console.error(`Failed to run a lazy listener: ${err}`);\n                  });\n              },\n            };\n            const response = await app.run(request, context);\n            // deno-lint-ignore no-explicit-any\n            let ack: any = { envelope_id: data.envelope_id };\n            if (response.body) {\n              const contentType = response.headers.get(\"Content-Type\");\n              if (contentType && contentType.startsWith(\"text/plain\")) {\n                const text = await response.text();\n                ack = { envelope_id: data.envelope_id, payload: { text } };\n              } else {\n                const json = await response.json();\n                ack = { envelope_id: data.envelope_id, payload: { ...json } };\n              }\n            }\n            ws.send(JSON.stringify(ack));\n          } else {", "            if (response.body) {\n              const contentType = response.headers.get(\"Content-Type\");\n              if (contentType && contentType.startsWith(\"text/plain\")) {\n                const text = await response.text();\n                ack = { envelope_id: data.envelope_id, payload: { text } };\n              } else {\n                const json = await response.json();\n                ack = { envelope_id: data.envelope_id, payload: { ...json } };\n              }\n            }\n            ws.send(JSON.stringify(ack));\n          } else {", "            if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n              console.log(`*** Received non-JSON data ***\\n ${ev.data}`);\n            }\n          }\n        } catch (e) {\n          console.error(`Failed to handle a WebSocke message: ${e}`);\n        }\n      };\n    }\n  }\n\n  // deno-lint-ignore require-await\n  async disconnect(): Promise<void> {", "    if (this.ws) {\n      this.ws.close();\n      this.ws = undefined;\n    }\n  }\n}\n"]}
{"filename": "src_deno/handler/view-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\nimport { SlackRequest } from \"../request/request.ts\";\nimport { SlackViewResponse } from \"../response/response.ts\";\n\nexport type ViewAckResponse = SlackViewResponse | void;\n\nexport type SlackViewHandler<E extends SlackAppEnv, Payload> = {\n  ack(request: SlackRequest<E, Payload>): Promise<ViewAckResponse>;\n  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n};\n"]}
{"filename": "src_deno/handler/message-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\nimport { SlackRequest } from \"../request/request.ts\";\nimport { MessageResponse } from \"../response/response-body.ts\";\nimport { AckResponse } from \"./handler.ts\";\n\nexport type MessageAckResponse = AckResponse | MessageResponse;\n\nexport interface SlackMessageHandler<E extends SlackAppEnv, Payload> {\n  ack(request: SlackRequest<E, Payload>): Promise<MessageAckResponse>;\n  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n}\n"]}
{"filename": "src_deno/handler/handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\nimport { SlackRequest } from \"../request/request.ts\";\nimport { SlackResponse } from \"../response/response.ts\";\n\nexport type AckResponse = SlackResponse | string | void;\n\nexport interface SlackHandler<E extends SlackAppEnv, Payload> {\n  ack(request: SlackRequest<E, Payload>): Promise<AckResponse>;\n  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n}\n"]}
{"filename": "src_deno/handler/options-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\nimport { SlackRequest } from \"../request/request.ts\";\nimport { SlackOptionsResponse } from \"../response/response.ts\";\n\nexport type OptionsAckResponse = SlackOptionsResponse;\n\nexport interface SlackOptionsHandler<E extends SlackAppEnv, Payload> {\n  ack(request: SlackRequest<E, Payload>): Promise<OptionsAckResponse>;\n  // Note that a block_suggestion response must be done synchronously.\n  // That's why we don't support lazy functions for the pattern.\n}\n"]}
{"filename": "src_deno/response/response-body.ts", "chunked_list": ["import {\n  AnyMessageBlock,\n  AnyTextField,\n  MessageAttachment,\n  MessageMetadata,\n  ModalView,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport interface MessageResponse {\n  response_type?: \"ephemeral\" | \"in_channel\";\n  text: string;\n  blocks?: AnyMessageBlock[];\n  attachments?: MessageAttachment[];\n  metadata?: MessageMetadata;\n  thread_ts?: string;\n}\n", "export interface MessageResponse {\n  response_type?: \"ephemeral\" | \"in_channel\";\n  text: string;\n  blocks?: AnyMessageBlock[];\n  attachments?: MessageAttachment[];\n  metadata?: MessageMetadata;\n  thread_ts?: string;\n}\n\nexport interface ViewUpdateResponse {\n  response_action: \"update\";\n  view: ModalView;\n}\n", "export interface ViewUpdateResponse {\n  response_action: \"update\";\n  view: ModalView;\n}\n\nexport interface ViewPushResponse {\n  response_action: \"push\";\n  view: ModalView;\n}\n\nexport interface ViewClearResponse {\n  response_action: \"clear\";\n}\n", "export interface ViewClearResponse {\n  response_action: \"clear\";\n}\n\nexport interface ViewErrorsResponse {\n  response_action: \"errors\";\n  errors: { [blockId: string]: string };\n}\n\nexport type AnyViewResponse =\n  | ViewUpdateResponse\n  | ViewPushResponse\n  | ViewClearResponse\n  | ViewErrorsResponse;\n", "export type AnyViewResponse =\n  | ViewUpdateResponse\n  | ViewPushResponse\n  | ViewClearResponse\n  | ViewErrorsResponse;\n\nexport interface Option {\n  value: string;\n  text: AnyTextField;\n}\n", "export interface OptionGroup {\n  label: AnyTextField;\n  options: Option[];\n}\n\nexport interface OptionsResponse {\n  options: Option[];\n}\nexport interface OptionGroupsResponse {\n  option_groups: OptionGroup[];\n}\n", "export interface OptionGroupsResponse {\n  option_groups: OptionGroup[];\n}\n\nexport type AnyOptionsResponse = OptionsResponse | OptionGroupsResponse;\n"]}
{"filename": "src_deno/response/response.ts", "chunked_list": ["import {\n  AnyOptionsResponse,\n  AnyViewResponse,\n  MessageResponse,\n} from \"./response-body.ts\";\n\nexport interface SlackResponse {\n  status?: number;\n  contentType?: string;\n  // deno-lint-ignore no-explicit-any\n  body?: string | MessageResponse | Record<string, any>;\n}\n", "export type SlackViewResponse =\n  | (SlackResponse & {\n    body: \"\" | AnyViewResponse;\n  })\n  | \"\"\n  | AnyViewResponse\n  | undefined\n  | void;\n\nexport type SlackOptionsResponse =\n  | (SlackResponse & {\n    body: AnyOptionsResponse;\n  })\n  | AnyOptionsResponse;\n", "export type SlackOptionsResponse =\n  | (SlackResponse & {\n    body: AnyOptionsResponse;\n  })\n  | AnyOptionsResponse;\n\nexport function toCompleteResponse(\n  slackResponse:\n    | SlackResponse\n    | MessageResponse\n    | SlackViewResponse\n    | SlackOptionsResponse\n    | string\n    | void,\n): Response {", "  if (!slackResponse) {\n    return new Response(\"\", {\n      status: 200,\n      headers: { \"Content-Type\": \"text/plain\" },\n    });\n  }\n  if (typeof slackResponse === \"string\") {\n    return new Response(slackResponse, {\n      status: 200,\n      headers: { \"Content-Type\": \"text/plain;charset=utf-8\" },\n    });\n  }\n  let completeResponse: SlackResponse = {};", "  if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"text\") ||\n    Object.prototype.hasOwnProperty.call(slackResponse, \"blocks\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse as MessageResponse };\n  } else if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"response_action\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse };\n  } else if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"options\") ||\n    Object.prototype.hasOwnProperty.call(slackResponse, \"option_groups\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse };\n  } else {\n    completeResponse = slackResponse as SlackResponse;\n  }\n  const status = completeResponse.status ? completeResponse.status : 200;\n  let contentType = completeResponse.contentType\n    ? completeResponse.contentType\n    : \"text/plain;charset=utf-8\";\n  let bodyString = \"\";", "  } else if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"options\") ||\n    Object.prototype.hasOwnProperty.call(slackResponse, \"option_groups\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse };\n  } else {\n    completeResponse = slackResponse as SlackResponse;\n  }\n  const status = completeResponse.status ? completeResponse.status : 200;\n  let contentType = completeResponse.contentType\n    ? completeResponse.contentType\n    : \"text/plain;charset=utf-8\";\n  let bodyString = \"\";", "  if (typeof completeResponse.body === \"object\") {\n    contentType = \"application/json;charset=utf-8\";\n    bodyString = JSON.stringify(completeResponse.body);\n  } else {\n    bodyString = completeResponse.body || \"\";\n  }\n  return new Response(bodyString, {\n    status,\n    headers: { \"Content-Type\": contentType },\n  });\n}\n"]}
{"filename": "src_deno/utility/message-events.ts", "chunked_list": ["import {\n  BotMessageEvent,\n  FileShareMessageEvent,\n  GenericMessageEvent,\n  ThreadBroadcastMessageEvent,\n} from \"../request/payload/event.ts\";\n\nexport const isPostedMessageEvent = (event: {\n  type: string;\n  subtype?: string;", "  type: string;\n  subtype?: string;\n}): event is\n  | GenericMessageEvent\n  | BotMessageEvent\n  | FileShareMessageEvent\n  | ThreadBroadcastMessageEvent => {\n  return (\n    event.subtype === undefined ||\n    event.subtype === \"bot_message\" ||", "    event.subtype === undefined ||\n    event.subtype === \"bot_message\" ||\n    event.subtype === \"file_share\" ||\n    event.subtype === \"thread_broadcast\"\n  );\n};\n"]}
{"filename": "src_deno/request/payload-types.ts", "chunked_list": ["export enum PayloadType {\n  BlockAction = \"block_actions\",\n  BlockSuggestion = \"block_suggestion\",\n  MessageShortcut = \"message_action\",\n  GlobalShortcut = \"shortcut\",\n  EventsAPI = \"event_callback\",\n  ViewSubmission = \"view_submission\",\n  ViewClosed = \"view_closed\",\n  // Note that Slash command payloads do not have \"type\" property\n}\n"]}
{"filename": "src_deno/request/request-parser.ts", "chunked_list": ["// deno-lint-ignore require-await\nexport async function parseRequestBody(\n  requestHeaders: Headers,\n  requestBody: string,\n): // deno-lint-ignore no-explicit-any\nPromise<Record<string, any>> {\n  const contentType = requestHeaders.get(\"content-type\");\n  if (\n    contentType?.startsWith(\"application/json\") ||\n    requestBody.startsWith(\"{\")\n  ) {\n    return JSON.parse(requestBody);\n  }\n  const params = new URLSearchParams(requestBody);", "  if (params.has(\"payload\")) {\n    const payload = params.get(\"payload\")!;\n    return JSON.parse(payload);\n  }\n  // deno-lint-ignore no-explicit-any\n  const formBody: any = {};\n  for (const k of params.keys()) {\n    formBody[k] = params.get(k);\n  }\n  return formBody;\n}\n"]}
{"filename": "src_deno/request/request-verification.ts", "chunked_list": ["export async function verifySlackRequest(\n  signingSecret: string,\n  requsetHeaders: Headers,\n  requestBody: string,\n) {\n  const timestampHeader = requsetHeaders.get(\"x-slack-request-timestamp\");\n  if (!timestampHeader) {\n    console.log(\"x-slack-request-timestamp header is missing!\");\n    return false;\n  }\n  const fiveMinutesAgoSeconds = Math.floor(Date.now() / 1000) - 60 * 5;", "  if (Number.parseInt(timestampHeader) < fiveMinutesAgoSeconds) {\n    return false;\n  }\n\n  const signatureHeader = requsetHeaders.get(\"x-slack-signature\");\n  if (!timestampHeader || !signatureHeader) {\n    console.log(\"x-slack-signature header is missing!\");\n    return false;\n  }\n\n  const textEncoder = new TextEncoder();\n  return await crypto.subtle.verify(\n    \"HMAC\",\n    await crypto.subtle.importKey(\n      \"raw\",\n      textEncoder.encode(signingSecret),\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"verify\"],\n    ),\n    fromHexStringToBytes(signatureHeader.substring(3)),\n    textEncoder.encode(`v0:${timestampHeader}:${requestBody}`),\n  );\n}\n", "function fromHexStringToBytes(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n  for (let idx = 0; idx < hexString.length; idx += 2) {\n    bytes[idx / 2] = parseInt(hexString.substring(idx, idx + 2), 16);\n  }\n  return bytes.buffer;\n}\n"]}
{"filename": "src_deno/request/request.ts", "chunked_list": ["import {\n  PreAuthorizeSlackAppContext,\n  SlackAppContext,\n  SlackAppContextWithChannelId,\n  SlackAppContextWithOptionalRespond,\n  SlackAppContextWithRespond,\n} from \"../context/context.ts\";\nimport { SlackAppEnv } from \"../app-env.ts\";\n\nexport interface SlackMiddlewareRequestBase<E extends SlackAppEnv> {\n  env: E;\n  context: PreAuthorizeSlackAppContext;\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>;\n  retryNum?: number;\n  retryReason?: string;\n  rawBody: string;\n  headers: Headers;\n}\n", "\nexport interface SlackMiddlewareRequestBase<E extends SlackAppEnv> {\n  env: E;\n  context: PreAuthorizeSlackAppContext;\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>;\n  retryNum?: number;\n  retryReason?: string;\n  rawBody: string;\n  headers: Headers;\n}\n", "export type PreAuthorizeSlackMiddlwareRequest<E extends SlackAppEnv> =\n  & SlackMiddlewareRequestBase<E>\n  & {\n    context: PreAuthorizeSlackAppContext;\n  };\n\nexport type SlackMiddlwareRequest<E extends SlackAppEnv> =\n  & SlackMiddlewareRequestBase<E>\n  & {\n    context: SlackAppContext;\n  };\n", "export type SlackRequest<\n  E extends SlackAppEnv,\n  Payload,\n> = SlackMiddlwareRequest<E> & {\n  payload: Payload;\n};\n\nexport type SlackRequestWithChannelId<\n  E extends SlackAppEnv,\n  Payload,\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithChannelId;\n  payload: Payload;\n};\n", "export type SlackRequestWithRespond<\n  E extends SlackAppEnv,\n  Payload,\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithRespond;\n  payload: Payload;\n};\n\nexport type SlackRequestWithOptionalRespond<\n  E extends SlackAppEnv,\n  Payload,\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithOptionalRespond;\n  payload: Payload;\n};\n", "export type SlackRequestWithOptionalRespond<\n  E extends SlackAppEnv,\n  Payload,\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithOptionalRespond;\n  payload: Payload;\n};\n"]}
{"filename": "src_deno/request/request-body.ts", "chunked_list": ["export interface SlackRequestBody {\n  type?: string;\n\n  // slash commands\n  command?: string;\n\n  // event_callback\n  event?: {\n    type: string;\n    subtype?: string;\n    text?: string;\n  };\n\n  // shortcut, message_action\n  callback_id?: string;\n\n  // block_actions\n  actions: {\n    type: string;\n    block_id: string;\n    action_id: string;\n  }[];\n\n  // block_suggestion\n  block_id?: string;\n  action_id?: string;\n\n  // view_submission / view_closed\n  view?: {\n    callback_id: string;\n  };\n}\n"]}
{"filename": "src_deno/request/payload/global-shortcut.ts", "chunked_list": ["export interface GlobalShortcut {\n  type: \"shortcut\";\n  callback_id: string;\n  trigger_id: string;\n  user: {\n    id: string;\n    username: string;\n    team_id: string;\n  };\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  token: string;\n  action_ts: string;\n  is_enterprise_install?: boolean;\n  enterprise?: { id: string; name: string };\n}\n"]}
{"filename": "src_deno/request/payload/block-suggestion.ts", "chunked_list": ["import { AnyOption } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { DataSubmissionView } from \"./view-objects.ts\";\n\nexport interface BlockSuggestion {\n  type: \"block_suggestion\";\n  block_id: string;\n  action_id: string;\n  value: string;\n  api_app_id: string;\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  channel?: {\n    id: string;\n    name: string;\n  };\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  token: string;\n  // deno-lint-ignore no-explicit-any\n  container: any;\n  view?: DataSubmissionView;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n}\n", "export interface BlockOptions {\n  options: AnyOption[];\n}\n\nexport interface OptionGroups<Options> {\n  option_groups: ({ label: string } & Options)[];\n}\n"]}
{"filename": "src_deno/request/payload/slash-command.ts", "chunked_list": ["export interface SlashCommand {\n  token: string;\n  command: string;\n  text: string;\n  response_url: string;\n  trigger_id: string;\n  user_id: string;\n  user_name: string;\n  team_id: string;\n  team_domain: string;\n  channel_id: string;\n  channel_name: string;\n  api_app_id: string;\n  enterprise_id?: string;\n  enterprise_name?: string;\n  is_enterprise_install?: string;\n}\n"]}
{"filename": "src_deno/request/payload/view-submission.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects.ts\";\n\nexport interface ViewSubmission {\n  type: \"view_submission\";\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  view: DataSubmissionView;\n  api_app_id: string;\n  token: string;\n  trigger_id: string;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n  response_urls?: {\n    block_id: string;\n    action_id: string;\n    channel_id: string;\n    response_url: string;\n  }[];\n}\n"]}
{"filename": "src_deno/request/payload/view-closed.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects.ts\";\n\nexport interface ViewClosed {\n  type: \"view_closed\";\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  view: DataSubmissionView;\n  api_app_id: string;\n  token: string;\n  is_cleared: boolean;\n  is_enterprise_install?: boolean;\n  enterprise?: { id: string; name: string };\n}\n"]}
{"filename": "src_deno/request/payload/view-objects.ts", "chunked_list": ["import {\n  AnyActionBlockElementType,\n  AnyModalBlock,\n  PlainTextField,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport interface ViewStateSelectedOption {\n  text: PlainTextField;\n  value: string;\n}\n", "export interface ViewStateValue {\n  type: AnyActionBlockElementType;\n  value?: string | null;\n  selected_date?: string | null;\n  selected_time?: string | null;\n  selected_date_time?: number | null;\n  selected_conversation?: string | null;\n  selected_channel?: string | null;\n  selected_user?: string | null;\n  selected_option?: ViewStateSelectedOption | null;\n  selected_conversations?: string[];\n  selected_channels?: string[];\n  selected_users?: string[];\n  selected_options?: ViewStateSelectedOption[];\n}\n", "export interface DataSubmissionView {\n  id: string;\n  callback_id: string;\n  team_id: string;\n  app_installed_team_id?: string;\n  app_id: string | null;\n  bot_id: string;\n  title: PlainTextField;\n  type: string;\n  blocks: AnyModalBlock[];\n  close: PlainTextField | null;\n  submit: PlainTextField | null;\n  state: {\n    values: {\n      [blockId: string]: {\n        [actionId: string]: ViewStateValue;\n      };\n    };\n  };\n  hash: string;\n  private_metadata: string;\n  root_view_id: string | null;\n  previous_view_id: string | null;\n  clear_on_close: boolean;\n  notify_on_close: boolean;\n  external_id?: string;\n}\n"]}
{"filename": "src_deno/request/payload/event.ts", "chunked_list": ["import {\n  AnyMessageBlock,\n  HomeTabView,\n  MessageAttachment,\n  MessageMetadata,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport type AnySlackEvent =\n  | AppRequestedEvent\n  | AppHomeOpenedEvent\n  | AppMentionEvent\n  | AppRateLimitedEvent\n  | AppUninstalledEvent\n  | ChannelArchiveEvent\n  | ChannelCreatedEvent\n  | ChannelDeletedEvent\n  | ChannelHistoryChangedEvent\n  | ChannelIDChangedEvent\n  | ChannelLeftEvent\n  | ChannelRenameEvent\n  | ChannelSharedEvent\n  | ChannelUnarchiveEvent\n  | ChannelUnsharedEvent\n  | DNDUpdatedEvent\n  | DNDUpdatedUserEvent\n  | EmailDomainChangedEvent\n  | EmojiChangedEvent\n  | FileChangeEvent\n  | FileCreatedEvent\n  | FileDeletedEvent\n  | FilePublicEvent\n  | FileSharedEvent\n  | FileUnsharedEvent\n  | GridMigrationFinishedEvent\n  | GridMigrationStartedEvent\n  | GroupArchiveEvent\n  | GroupCloseEvent\n  | GroupDeletedEvent\n  | GroupHistoryChangedEvent\n  | GroupLeftEvent\n  | GroupOpenEvent\n  | GroupRenameEvent\n  | GroupUnarchiveEvent\n  | IMCloseEvent\n  | IMCreatedEvent\n  | IMHistoryChangedEvent\n  | IMOpenEvent\n  | InviteRequestedEvent\n  | LinkSharedEvent\n  | MemberJoinedChannelEvent\n  | MemberLeftChannelEvent\n  | AnyMessageEvent\n  | AnyMessageMetadataEvent\n  | PinAddedEvent\n  | PinRemovedEvent\n  | ReactionAddedEvent\n  | ReactionRemovedEvent\n  | SharedChannelInviteReceivedEvent\n  | SharedChannelInviteAcceptedEvent\n  | SharedChannelInviteApprovedEvent\n  | SharedChannelInviteDeclinedEvent\n  | StarAddedEvent\n  | StarRemovedEvent\n  | SubteamCreatedEvent\n  | SubteamMembersChangedEvent\n  | SubteamSelfAddedEvent\n  | SubteamSelfRemovedEvent\n  | SubteamUpdatedEvent\n  | TeamAccessGrantedEvent\n  | TeamAccessRevokedEvent\n  | TeamDomainChangedEvent\n  | TeamJoinEvent\n  | TeamRenameEvent\n  | TokensRevokedEvent\n  | UserChangeEvent\n  | UserHuddleChangedEvent\n  | UserProfileChangedEvent\n  | UserStatusChangedEvent\n  | WorkflowDeletedEvent\n  | WorkflowPublishedEvent\n  | WorkflowUnpublishedEvent\n  | WorkflowStepDeletedEvent\n  | WorkflowStepExecuteEvent;\n\n// These union types may not be a complete set of events", "export type AnySlackEventWithChannelId =\n  | AppHomeOpenedEvent\n  | AppMentionEvent\n  | AppUninstalledEvent\n  | ChannelArchiveEvent\n  | ChannelCreatedEvent\n  | ChannelDeletedEvent\n  | ChannelIDChangedEvent\n  | ChannelLeftEvent\n  | ChannelRenameEvent\n  | ChannelSharedEvent\n  | ChannelUnarchiveEvent\n  | ChannelUnsharedEvent\n  | FileSharedEvent\n  | FileUnsharedEvent\n  | GroupArchiveEvent\n  | GroupCloseEvent\n  | GroupDeletedEvent\n  | GroupLeftEvent\n  | GroupOpenEvent\n  | GroupRenameEvent\n  | GroupUnarchiveEvent\n  | IMCloseEvent\n  | IMCreatedEvent\n  | IMOpenEvent\n  | InviteRequestedEvent\n  | LinkSharedEvent\n  | MemberJoinedChannelEvent\n  | MemberLeftChannelEvent\n  | AnyMessageEvent\n  | AnyMessageMetadataEvent\n  | PinAddedEvent\n  | PinRemovedEvent\n  | ReactionAddedEvent\n  | ReactionRemovedEvent\n  | SharedChannelInviteReceivedEvent\n  | SharedChannelInviteAcceptedEvent\n  | SharedChannelInviteApprovedEvent\n  | SharedChannelInviteDeclinedEvent\n  | StarAddedEvent\n  | StarRemovedEvent;\n", "export interface SlackEvent<Type extends string> {\n  type: Type;\n  subtype?: string;\n}\n\nexport interface AppRequestedEvent extends SlackEvent<\"app_requested\"> {\n  type: \"app_requested\";\n  app_request: {\n    id: string;\n    app: {\n      id: string;\n      name: string;\n      description: string;\n      help_url: string;\n      privacy_policy_url: string;\n      app_homepage_url: string;\n      app_directory_url: string;\n      is_app_directory_approved: boolean;\n      is_internal: boolean;\n      additional_info: string;\n      icons?: {\n        image_32?: string;\n        image_36?: string;\n        image_48?: string;\n        image_64?: string;\n        image_72?: string;\n        image_96?: string;\n        image_128?: string;\n        image_192?: string;\n        image_512?: string;\n        image_1024?: string;\n        image_original?: string;\n      };\n    };\n  };\n  previous_resolution: {\n    status: \"approved\" | \"restricted\";\n    scopes: {\n      name: string;\n      description: string;\n      is_dangerous: boolean;\n      token_type: \"bot\" | \"user\" | \"app\" | null;\n    };\n  } | null;\n  is_user_app_collaborator: boolean;\n  user: {\n    id: string;\n    name: string;\n    email: string;\n  };\n  team: {\n    id: string;\n    name: string;\n    domain: string;\n  };\n  scopes: {\n    name: string;\n    description: string;\n    is_dangerous: boolean;\n    token_type: \"bot\" | \"user\" | \"app\" | null;\n  };\n  message: string;\n  date_created: number;\n}\n", "export interface AppHomeOpenedEvent extends SlackEvent<\"app_home_opened\"> {\n  type: \"app_home_opened\";\n  user: string;\n  channel: string;\n  tab: \"home\" | \"messages\";\n  view?: HomeTabView;\n  event_ts: string;\n}\n\nexport interface AppMentionEvent extends SlackEvent<\"app_mention\"> {\n  type: \"app_mention\";\n  subtype?: string;\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  username: string;\n  team?: string;\n  user?: string;\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  ts: string;\n  channel: string;\n  event_ts: string;\n  thread_ts?: string;\n}\n", "export interface AppMentionEvent extends SlackEvent<\"app_mention\"> {\n  type: \"app_mention\";\n  subtype?: string;\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  username: string;\n  team?: string;\n  user?: string;\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  ts: string;\n  channel: string;\n  event_ts: string;\n  thread_ts?: string;\n}\n", "export interface AppRateLimitedEvent extends SlackEvent<\"app_rate_limited\"> {\n  type: \"app_rate_limited\";\n  token: string;\n  team_id: string;\n  minute_rate_limited: number;\n  api_app_id: string;\n}\n\nexport interface AppUninstalledEvent extends SlackEvent<\"app_uninstalled\"> {\n  type: \"app_uninstalled\";\n}\n", "export interface AppUninstalledEvent extends SlackEvent<\"app_uninstalled\"> {\n  type: \"app_uninstalled\";\n}\n\nexport interface ChannelArchiveEvent extends SlackEvent<\"channel_archive\"> {\n  type: \"channel_archive\";\n  channel: string;\n  user: string;\n  is_moved?: number;\n  event_ts: string;\n}\n", "export interface ChannelCreatedEvent extends SlackEvent<\"channel_created\"> {\n  type: \"channel_created\";\n  channel: {\n    id: string;\n    is_channel: boolean;\n    name: string;\n    name_normalized: string;\n    created: number;\n    creator: string;\n    is_shared: boolean;\n    is_org_shared: boolean;\n  };\n}\n", "export interface ChannelDeletedEvent extends SlackEvent<\"channel_deleted\"> {\n  type: \"channel_deleted\";\n  channel: string;\n}\n\nexport interface ChannelHistoryChangedEvent\n  extends SlackEvent<\"channel_history_changed\"> {\n  type: \"channel_history_changed\";\n  latest: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelIDChangedEvent\n  extends SlackEvent<\"channel_id_changed\"> {\n  type: \"channel_id_changed\";\n  old_channel_id: string;\n  new_channel_id: string;\n  event_ts: string;\n}\n\nexport interface ChannelLeftEvent extends SlackEvent<\"channel_left\"> {\n  type: \"channel_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n", "export interface ChannelLeftEvent extends SlackEvent<\"channel_left\"> {\n  type: \"channel_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n\nexport interface ChannelRenameEvent extends SlackEvent<\"channel_rename\"> {\n  type: \"channel_rename\";\n  channel: {\n    id: string;\n    name: string;\n    name_normalized: string;\n    created: number;\n    is_channel: boolean;\n    is_mpim: boolean;\n  };\n  event_ts: string;\n}\n", "export interface ChannelSharedEvent extends SlackEvent<\"channel_shared\"> {\n  type: \"channel_shared\";\n  connected_team_id: string;\n  channel: string;\n  event_ts: string;\n}\n\nexport interface ChannelUnarchiveEvent extends SlackEvent<\"channel_unarchive\"> {\n  type: \"channel_unarchive\";\n  channel: string;\n  user: string;\n  event_ts: string;\n}\n", "export interface ChannelUnsharedEvent extends SlackEvent<\"channel_unshared\"> {\n  type: \"channel_unshared\";\n  previously_connected_team_id: string;\n  channel: string;\n  is_ext_shared: boolean;\n  event_ts: string;\n}\n\nexport interface DNDUpdatedEvent extends SlackEvent<\"dnd_updated\"> {\n  type: \"dnd_updated\";\n  user: string;\n  dnd_status: {\n    dnd_enabled: boolean;\n    next_dnd_start_ts: number;\n    next_dnd_end_ts: number;\n    snooze_enabled: boolean;\n    snooze_endtime: number;\n    snooze_remaining: number;\n  };\n  event_ts: string;\n}\n", "export interface DNDUpdatedEvent extends SlackEvent<\"dnd_updated\"> {\n  type: \"dnd_updated\";\n  user: string;\n  dnd_status: {\n    dnd_enabled: boolean;\n    next_dnd_start_ts: number;\n    next_dnd_end_ts: number;\n    snooze_enabled: boolean;\n    snooze_endtime: number;\n    snooze_remaining: number;\n  };\n  event_ts: string;\n}\n", "export interface DNDUpdatedUserEvent extends SlackEvent<\"dnd_updated_user\"> {\n  type: \"dnd_updated_user\";\n  user: string;\n  dnd_status: {\n    dnd_enabled: boolean;\n    next_dnd_start_ts: number;\n    next_dnd_end_ts: number;\n  };\n  event_ts: string;\n}\n", "export interface EmailDomainChangedEvent\n  extends SlackEvent<\"email_domain_changed\"> {\n  type: \"email_domain_changed\";\n  email_domain: string;\n  event_ts: string;\n}\n\n// NOTE: this should probably be broken into its two subtypes\nexport interface EmojiChangedEvent extends SlackEvent<\"emoji_changed\"> {\n  type: \"emoji_changed\";\n  subtype: \"add\" | \"remove\" | \"rename\";\n  names?: string[]; // only for remove\n  name?: string; // only for add\n  value?: string; // only for add\n  old_name?: string;\n  new_name?: string;\n  event_ts: string;\n}\n", "export interface EmojiChangedEvent extends SlackEvent<\"emoji_changed\"> {\n  type: \"emoji_changed\";\n  subtype: \"add\" | \"remove\" | \"rename\";\n  names?: string[]; // only for remove\n  name?: string; // only for add\n  value?: string; // only for add\n  old_name?: string;\n  new_name?: string;\n  event_ts: string;\n}\n", "export interface FileChangeEvent extends SlackEvent<\"file_change\"> {\n  type: \"file_change\";\n  file_id: string;\n  file: { id: string };\n}\n\nexport interface FileCreatedEvent extends SlackEvent<\"file_created\"> {\n  type: \"file_created\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  event_ts: string;\n}\n", "export interface FileDeletedEvent extends SlackEvent<\"file_deleted\"> {\n  type: \"file_deleted\";\n  file_id: string;\n  channel_ids?: string[];\n  event_ts: string;\n}\n\nexport interface FilePublicEvent extends SlackEvent<\"file_public\"> {\n  type: \"file_public\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  event_ts: string;\n}\n", "export interface FileSharedEvent extends SlackEvent<\"file_shared\"> {\n  type: \"file_shared\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  channel_id: string;\n  event_ts: string;\n}\n\nexport interface FileUnsharedEvent extends SlackEvent<\"file_unshared\"> {\n  type: \"file_unshared\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  channel_id: string;\n  event_ts: string;\n}\n", "export interface FileUnsharedEvent extends SlackEvent<\"file_unshared\"> {\n  type: \"file_unshared\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  channel_id: string;\n  event_ts: string;\n}\n\nexport interface GridMigrationFinishedEvent\n  extends SlackEvent<\"grid_migration_finished\"> {\n  type: \"grid_migration_finished\";\n  enterprise_id: string;\n}\n", "export interface GridMigrationFinishedEvent\n  extends SlackEvent<\"grid_migration_finished\"> {\n  type: \"grid_migration_finished\";\n  enterprise_id: string;\n}\n\nexport interface GridMigrationStartedEvent\n  extends SlackEvent<\"grid_migration_started\"> {\n  type: \"grid_migration_started\";\n  enterprise_id: string;\n}\n", "export interface GroupArchiveEvent extends SlackEvent<\"group_archive\"> {\n  type: \"group_archive\";\n  channel: string;\n  user: string;\n  is_moved: number;\n  event_ts: string;\n}\n\nexport interface GroupCloseEvent extends SlackEvent<\"group_close\"> {\n  type: \"group_close\";\n  user: string;\n  channel: string;\n}\n", "export interface GroupCloseEvent extends SlackEvent<\"group_close\"> {\n  type: \"group_close\";\n  user: string;\n  channel: string;\n}\n\nexport interface GroupDeletedEvent extends SlackEvent<\"group_deleted\"> {\n  type: \"group_deleted\";\n  channel: string;\n  date_deleted: number;\n  actor_id: string;\n  event_ts: string;\n}\n", "export interface GroupHistoryChangedEvent\n  extends SlackEvent<\"group_history_changed\"> {\n  type: \"group_history_changed\";\n  latest: string;\n  ts: string;\n  event_ts: string;\n}\n\nexport interface GroupLeftEvent extends SlackEvent<\"group_left\"> {\n  type: \"group_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n", "export interface GroupLeftEvent extends SlackEvent<\"group_left\"> {\n  type: \"group_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n\nexport interface GroupOpenEvent extends SlackEvent<\"group_open\"> {\n  type: \"group_open\";\n  user: string;\n  channel: string;\n}\n", "export interface GroupRenameEvent extends SlackEvent<\"group_rename\"> {\n  type: \"group_rename\";\n  channel: {\n    id: string;\n    name: string;\n    name_normalized: string;\n    created: number;\n    is_channel: boolean;\n    is_mpim: boolean;\n  };\n  event_ts: string;\n}\n", "export interface GroupUnarchiveEvent extends SlackEvent<\"group_unarchive\"> {\n  type: \"group_unarchive\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n\nexport interface IMCloseEvent extends SlackEvent<\"im_close\"> {\n  type: \"im_close\";\n  user: string;\n  channel: string;\n  event_ts: string;\n}\n", "export interface IMCreatedEvent extends SlackEvent<\"im_created\"> {\n  type: \"im_created\";\n  user: string;\n  channel: { id: string };\n}\n\nexport interface IMHistoryChangedEvent\n  extends SlackEvent<\"im_history_changed\"> {\n  type: \"im_history_changed\";\n  latest: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface IMOpenEvent extends SlackEvent<\"im_open\"> {\n  type: \"im_open\";\n  user: string;\n  channel: string;\n  event_ts: string;\n}\n\nexport interface InviteRequestedEvent extends SlackEvent<\"invite_requested\"> {\n  type: \"invite_requested\";\n  invite_request: {\n    id: string;\n    email: string;\n    date_created: number;\n    requester_ids: string[];\n    channel_ids: string[];\n    invite_type: \"restricted\" | \"ultra_restricted\" | \"full_member\";\n    real_name: string;\n    date_expire: number;\n    request_reason: string;\n    team: {\n      id: string;\n      name: string;\n      domain: string;\n    };\n  };\n}\n", "export interface LinkSharedEvent extends SlackEvent<\"link_shared\"> {\n  type: \"link_shared\";\n  channel: string;\n  is_bot_user_member: boolean;\n  user: string;\n  message_ts: string;\n  thread_ts?: string;\n  links: {\n    domain: string;\n    url: string;\n  }[];\n  unfurl_id?: string;\n  source?: string;\n  event_ts: string;\n}\n", "export interface MemberJoinedChannelEvent\n  extends SlackEvent<\"member_joined_channel\"> {\n  type: \"member_joined_channel\";\n  user: string;\n  channel: string;\n  channel_type: string;\n  team: string;\n  inviter?: string;\n  event_ts: string;\n}\n", "export interface MemberLeftChannelEvent\n  extends SlackEvent<\"member_left_channel\"> {\n  type: \"member_left_channel\";\n  user: string;\n  channel: string;\n  channel_type: string;\n  team: string;\n  event_ts: string;\n}\n\nexport interface PinAddedEvent extends SlackEvent<\"pin_added\"> {\n  type: \"pin_added\";\n  user: string;\n  channel_id: string;\n  item: PinnedItem;\n  item_user: string;\n  pin_count: string;\n  pinned_info: {\n    channel: string;\n    pinned_by: string;\n    pinned_ts: number;\n  };\n  event_ts: string;\n}", "export interface PinAddedEvent extends SlackEvent<\"pin_added\"> {\n  type: \"pin_added\";\n  user: string;\n  channel_id: string;\n  item: PinnedItem;\n  item_user: string;\n  pin_count: string;\n  pinned_info: {\n    channel: string;\n    pinned_by: string;\n    pinned_ts: number;\n  };\n  event_ts: string;\n}", "export interface PinRemovedEvent extends SlackEvent<\"pin_removed\"> {\n  type: \"pin_removed\";\n  user: string;\n  channel_id: string;\n  item: PinnedItem;\n  item_user: string;\n  pin_count: string;\n  pinned_info: {\n    channel: string;\n    pinned_by: string;\n    pinned_ts: number;\n  };\n  has_pins: boolean;\n  event_ts: string;\n}\n", "export interface ReactionAddedEvent extends SlackEvent<\"reaction_added\"> {\n  type: \"reaction_added\";\n  user: string;\n  reaction: string;\n  item_user: string;\n  item: ReactionMessageItem;\n  event_ts: string;\n}\n\nexport interface ReactionRemovedEvent extends SlackEvent<\"reaction_removed\"> {\n  type: \"reaction_removed\";\n  user: string;\n  reaction: string;\n  item_user: string;\n  item: ReactionMessageItem;\n  event_ts: string;\n}\n", "export interface ReactionRemovedEvent extends SlackEvent<\"reaction_removed\"> {\n  type: \"reaction_removed\";\n  user: string;\n  reaction: string;\n  item_user: string;\n  item: ReactionMessageItem;\n  event_ts: string;\n}\n\nexport interface SharedChannelInviteAcceptedEvent\n  extends SlackEvent<\"shared_channel_invite_accepted\"> {\n  type: \"shared_channel_invite_accepted\";\n  approval_required: boolean;\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  teams_in_channel: SharedChannelTeamItem[];\n  accepting_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteAcceptedEvent\n  extends SlackEvent<\"shared_channel_invite_accepted\"> {\n  type: \"shared_channel_invite_accepted\";\n  approval_required: boolean;\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  teams_in_channel: SharedChannelTeamItem[];\n  accepting_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteApprovedEvent\n  extends SlackEvent<\"shared_channel_invite_approved\"> {\n  type: \"shared_channel_invite_approved\";\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  approving_team_id: string;\n  teams_in_channel: SharedChannelTeamItem[];\n  approving_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteDeclinedEvent\n  extends SlackEvent<\"shared_channel_invite_declined\"> {\n  type: \"shared_channel_invite_declined\";\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  declining_team_id: string;\n  teams_in_channel: SharedChannelTeamItem[];\n  declining_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteReceivedEvent\n  extends SlackEvent<\"shared_channel_invite_received\"> {\n  type: \"shared_channel_invite_received\";\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  event_ts: string;\n}\n\nexport interface StarAddedEvent extends SlackEvent<\"star_added\"> {\n  type: \"star_added\";\n  user: string;\n  item: StarItem;\n  event_ts: string;\n}\n", "export interface StarAddedEvent extends SlackEvent<\"star_added\"> {\n  type: \"star_added\";\n  user: string;\n  item: StarItem;\n  event_ts: string;\n}\n\nexport interface StarRemovedEvent extends SlackEvent<\"star_removed\"> {\n  type: \"star_removed\";\n  user: string;\n  item: StarItem;\n  event_ts: string;\n}\n", "export interface SubteamCreatedEvent extends SlackEvent<\"subteam_created\"> {\n  type: \"subteam_created\";\n  subteam: Subteam;\n  event_ts: string;\n}\n\nexport interface SubteamMembersChangedEvent\n  extends SlackEvent<\"subteam_members_changed\"> {\n  type: \"subteam_members_changed\";\n  subteam_id: string;\n  team_id: string;\n  date_previous_update: number;\n  date_update: number;\n  added_users?: string[];\n  added_users_count?: number;\n  removed_users?: string[];\n  removed_users_count?: number;\n  event_ts: string;\n}\n", "export interface SubteamSelfAddedEvent\n  extends SlackEvent<\"subteam_self_added\"> {\n  type: \"subteam_self_added\";\n  subteam_id: string;\n  event_ts: string;\n}\n\nexport interface SubteamSelfRemovedEvent\n  extends SlackEvent<\"subteam_self_removed\"> {\n  type: \"subteam_self_removed\";\n  subteam_id: string;\n  event_ts: string;\n}\n", "export interface SubteamUpdatedEvent extends SlackEvent<\"subteam_updated\"> {\n  type: \"subteam_updated\";\n  subteam: Subteam;\n  event_ts: string;\n}\n\nexport interface TeamAccessGrantedEvent\n  extends SlackEvent<\"team_access_granted\"> {\n  type: \"team_access_granted\";\n  team_ids: string[];\n  event_ts: string;\n}\n", "export interface TeamAccessRevokedEvent\n  extends SlackEvent<\"team_access_revoked\"> {\n  type: \"team_access_revoked\";\n  team_ids: string[];\n  event_ts: string;\n}\n\nexport interface TeamDomainChangedEvent\n  extends SlackEvent<\"team_domain_changed\"> {\n  type: \"team_domain_changed\";\n  url: string;\n  domain: string;\n}\n", "export interface TeamJoinEvent extends SlackEvent<\"team_join\"> {\n  type: \"team_join\";\n  user: { id: string };\n}\n\nexport interface TeamRenameEvent extends SlackEvent<\"team_rename\"> {\n  type: \"team_rename\";\n  name: string;\n}\n\nexport interface TokensRevokedEvent extends SlackEvent<\"tokens_revoked\"> {\n  type: \"tokens_revoked\";\n  tokens: {\n    oauth?: string[];\n    bot?: string[];\n  };\n}\n", "export interface TokensRevokedEvent extends SlackEvent<\"tokens_revoked\"> {\n  type: \"tokens_revoked\";\n  tokens: {\n    oauth?: string[];\n    bot?: string[];\n  };\n}\n\nexport interface UserChangeEvent extends SlackEvent<\"user_change\"> {\n  type: \"user_change\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state?: string;\n      huddle_state_expiration_ts?: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserChangeEvent extends SlackEvent<\"user_change\"> {\n  type: \"user_change\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state?: string;\n      huddle_state_expiration_ts?: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserHuddleChangedEvent\n  extends SlackEvent<\"user_huddle_changed\"> {\n  type: \"user_huddle_changed\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state: string;\n      huddle_state_expiration_ts: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserProfileChangedEvent\n  extends SlackEvent<\"user_profile_changed\"> {\n  type: \"user_profile_changed\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state: string;\n      huddle_state_expiration_ts: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserStatusChangedEvent\n  extends SlackEvent<\"user_status_changed\"> {\n  type: \"user_status_changed\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface WorkflowDeletedEvent extends SlackEvent<\"workflow_deleted\"> {\n  type: \"workflow_deleted\";\n  workflow_id: string;\n  workflow_draft_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowPublishedEvent\n  extends SlackEvent<\"workflow_published\"> {\n  type: \"workflow_published\";\n  workflow_id: string;\n  workflow_published_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowUnpublishedEvent\n  extends SlackEvent<\"workflow_unpublished\"> {\n  type: \"workflow_unpublished\";\n  workflow_id: string;\n  workflow_draft_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowStepDeletedEvent\n  extends SlackEvent<\"workflow_step_deleted\"> {\n  type: \"workflow_step_deleted\";\n  workflow_id: string;\n  workflow_draft_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  workflow_published_configuration?: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowStepExecuteEvent\n  extends SlackEvent<\"workflow_step_execute\"> {\n  type: \"workflow_step_execute\";\n  callback_id: string;\n  workflow_step: {\n    workflow_step_execute_id: string;\n    workflow_id: string;\n    workflow_instance_id: string;\n    step_id: string;\n    // deno-lint-ignore no-explicit-any\n    inputs: { [key: string]: { value: any } };\n    outputs: { name: string; type: string; label: string }[];\n  };\n  event_ts: string;\n}\n", "export type AnyMessageEvent =\n  | GenericMessageEvent\n  | BotMessageEvent\n  | ChannelArchiveMessageEvent\n  | ChannelJoinMessageEvent\n  | ChannelLeaveMessageEvent\n  | ChannelNameMessageEvent\n  | ChannelPostingPermissionsMessageEvent\n  | ChannelPurposeMessageEvent\n  | ChannelTopicMessageEvent\n  | ChannelUnarchiveMessageEvent\n  | EKMAccessDeniedMessageEvent\n  | FileShareMessageEvent\n  | MeMessageEvent\n  | MessageChangedEvent\n  | MessageDeletedEvent\n  | MessageRepliedEvent\n  | ThreadBroadcastMessageEvent;\n", "export type AnyMessageItem =\n  | GenericMessageEvent\n  | BotMessageEvent\n  | ChannelArchiveMessageEvent\n  | ChannelJoinMessageEvent\n  | ChannelLeaveMessageEvent\n  | ChannelNameMessageEvent\n  | ChannelPostingPermissionsMessageEvent\n  | ChannelPurposeMessageEvent\n  | ChannelTopicMessageEvent\n  | ChannelUnarchiveMessageEvent\n  | EKMAccessDeniedMessageEvent\n  | FileShareMessageEvent\n  | MeMessageEvent\n  | MessageRepliedEvent\n  | ThreadBroadcastMessageEvent;\n", "export type AnyMessageMetadataEvent =\n  | MessageMetadataPostedEvent\n  | MessageMetadataUpdatedEvent\n  | MessageMetadataDeletedEvent;\n\nexport interface GenericMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: undefined;\n  event_ts: string;\n  team?: string;\n  channel: string;\n  user: string;\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  text: string;\n  ts: string;\n  thread_ts?: string;\n  channel_type: AnyChannelType;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  files?: File[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  client_msg_id?: string;\n  parent_user_id?: string;\n\n  // TODO: optional types that maybe should flow into other subtypes?\n  is_starred?: boolean;\n  pinned_to?: string[];\n  reactions?: {\n    name: string;\n    count: number;\n    users: string[];\n  }[];\n}\n", "export interface BotMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"bot_message\";\n  event_ts: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  text: string;\n  bot_id: string;\n  username?: string;\n  icons?: {\n    [size: string]: string;\n  };\n\n  // copied from MessageEvent\n  // TODO: is a user really optional? likely for things like IncomingWebhook authored messages\n  user?: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  thread_ts?: string;\n}\n", "export interface ChannelArchiveMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_archive\";\n  team: string;\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelJoinMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_join\";\n  team: string;\n  user: string;\n  inviter: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelLeaveMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_leave\";\n  team: string;\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelNameMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_name\";\n  team: string;\n  user: string;\n  name: string;\n  old_name: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelPostingPermissionsMessageEvent\n  extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_posting_permissions\";\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelPurposeMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_purpose\";\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  purpose: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelTopicMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_topic\";\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  topic: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelUnarchiveMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_unarchive\";\n  team: string;\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface EKMAccessDeniedMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"ekm_access_denied\";\n  event_ts: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  text: string; // This will not have any meaningful content within\n  user: \"UREVOKEDU\";\n}\n", "export interface FileShareMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"file_share\";\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  files?: File[];\n  upload?: boolean;\n  display_as_bot?: boolean;\n  x_files?: string[];\n  user: string;\n  parent_user_id?: string;\n  ts: string;\n  thread_ts?: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  event_ts: string;\n}\n", "export interface MeMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"me_message\";\n  event_ts: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  user: string;\n  text: string;\n  ts: string;\n}\n", "export interface MessageChangedEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"message_changed\";\n  event_ts: string;\n  hidden: true;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  message: AnyMessageItem;\n  previous_message: AnyMessageItem;\n}\n", "export interface MessageDeletedEvent {\n  type: \"message\";\n  subtype: \"message_deleted\";\n  event_ts: string;\n  hidden: true;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  deleted_ts: string;\n  previous_message: AnyMessageItem;\n}\n", "export interface MessageRepliedEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"message_replied\";\n  event_ts: string;\n  hidden: true;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  message: AnyMessageItem & {\n    // TODO: should this be the union of all message events with type 'message'?\n    thread_ts: string;\n    reply_count: number;\n    replies: AnyMessageEvent[]; // TODO: should this be the union of all message events with type 'message'?\n  };\n}\n\n// the `reply_broadcast` message subtype is omitted because it is discontinued\n", "export interface ThreadBroadcastMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"thread_broadcast\";\n  event_ts: string;\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  user: string;\n  ts: string;\n  thread_ts?: string;\n  root: (GenericMessageEvent | BotMessageEvent) & {\n    thread_ts: string;\n    reply_count: number;\n    reply_users_count: number;\n    latest_reply: string;\n    reply_users: string[];\n  };\n  client_msg_id: string;\n  channel: string;\n  channel_type: AnyChannelType;\n}\n", "export interface MessageMetadataPostedEvent\n  extends SlackEvent<\"message_metadata_posted\"> {\n  type: \"message_metadata_posted\";\n  app_id: string;\n  bot_id?: string;\n  user_id: string;\n  team_id: string;\n  channel_id: string;\n  metadata: MessageMetadata;\n  message_ts: string;\n  event_ts: string;\n}\n", "export interface MessageMetadataUpdatedEvent\n  extends SlackEvent<\"message_metadata_updated\"> {\n  type: \"message_metadata_updated\";\n  channel_id: string;\n  event_ts: string;\n  previous_metadata: MessageMetadata;\n  app_id: string;\n  bot_id?: string;\n  user_id: string;\n  team_id: string;\n  message_ts: string;\n  metadata: MessageMetadata;\n}\n", "export interface MessageMetadataDeletedEvent\n  extends SlackEvent<\"message_metadata_deleted\"> {\n  type: \"message_metadata_deleted\";\n  channel_id: string;\n  event_ts: string;\n  previous_metadata: MessageMetadata;\n  app_id: string;\n  bot_id?: string;\n  user_id: string;\n  team_id: string;\n  message_ts: string;\n  deleted_ts: string;\n}\n", "export type AnyChannelType = \"channel\" | \"group\" | \"im\" | \"mpim\" | \"app_home\";\n\n// -----------------------------------------------------------\n\nexport interface BotProfile {\n  id: string;\n  name: string;\n  app_id: string;\n  team_id: string;\n  icons: { [size: string]: string };\n  updated: number;\n  deleted: boolean;\n}\n", "export interface PinnedItem {\n  type: string;\n  channel: string;\n  created_by: string;\n  created: number;\n  message?: MessageItem;\n  file?: FileItem;\n}\n\nexport interface SharedChannelTeamItem {\n  id: string;\n  name: string;\n  icon: Record<string, unknown>;\n  is_verified: boolean;\n  domain: string;\n  date_created: number;\n}\n", "export interface SharedChannelTeamItem {\n  id: string;\n  name: string;\n  icon: Record<string, unknown>;\n  is_verified: boolean;\n  domain: string;\n  date_created: number;\n}\n\nexport interface SharedChannelUserItem {\n  id: string;\n  team_id: string;\n  name: string;\n  updated: number;\n  profile: {\n    real_name: string;\n    display_name: string;\n    real_name_normalized: string;\n    display_name_normalized: string;\n    team: string;\n    avatar_hash: string;\n    email: string;\n    image_24: string;\n    image_32: string;\n    image_48: string;\n    image_72: string;\n    image_192: string;\n    image_512: string;\n  };\n}\n", "export interface SharedChannelUserItem {\n  id: string;\n  team_id: string;\n  name: string;\n  updated: number;\n  profile: {\n    real_name: string;\n    display_name: string;\n    real_name_normalized: string;\n    display_name_normalized: string;\n    team: string;\n    avatar_hash: string;\n    email: string;\n    image_24: string;\n    image_32: string;\n    image_48: string;\n    image_72: string;\n    image_192: string;\n    image_512: string;\n  };\n}\n", "export interface SharedChannelInviteItem {\n  id: string;\n  date_created: number;\n  date_invalid: number;\n  inviting_team: SharedChannelTeamItem;\n  inviting_user: SharedChannelUserItem;\n  recipient_email?: string;\n  recipient_user_id?: string;\n}\n\nexport interface SharedChannelItem {\n  id: string;\n  is_private: boolean;\n  is_im: boolean;\n  name: string;\n}\n", "export interface SharedChannelItem {\n  id: string;\n  is_private: boolean;\n  is_im: boolean;\n  name: string;\n}\n\nexport interface Subteam {\n  id: string;\n  team_id?: string;\n  is_usergroup: boolean;\n  is_subteam: boolean;\n  name: string;\n  description?: string;\n  handle: string;\n  is_external: boolean;\n  date_create: number;\n  date_update?: number;\n  date_delete?: number;\n  auto_provision: boolean;\n  enterprise_subteam_id?: string;\n  created_by: string;\n  updated_by?: string;\n  prefs?: {\n    channels?: string[];\n    groups?: string[];\n  };\n  users: string[];\n  user_count: number;\n  channel_count?: number;\n}\n", "export interface StatusEmojiDisplayInfo {\n  emoji_name?: string;\n  display_alias?: string;\n  display_url?: string;\n}\n\nexport interface ReactionMessageItem {\n  type: \"message\";\n  channel: string;\n  ts: string;\n}\n", "export interface FileInitialComment {\n  channel?: string;\n  comment?: string;\n  created?: number;\n  id?: string;\n  is_intro?: boolean;\n  timestamp?: number;\n  user?: string;\n}\n\nexport interface StarItem {\n  date_create: number;\n  type: string;\n  channel?: string;\n  file?: FileItem;\n  message?: MessageItem;\n  comment?: {\n    channel?: string;\n    comment?: string;\n    created?: number;\n    id?: string;\n    is_intro?: boolean;\n    is_starred?: boolean;\n    num_stars?: number;\n    timestamp?: number;\n    user?: string;\n  };\n}\n", "export interface StarItem {\n  date_create: number;\n  type: string;\n  channel?: string;\n  file?: FileItem;\n  message?: MessageItem;\n  comment?: {\n    channel?: string;\n    comment?: string;\n    created?: number;\n    id?: string;\n    is_intro?: boolean;\n    is_starred?: boolean;\n    num_stars?: number;\n    timestamp?: number;\n    user?: string;\n  };\n}\n", "export interface FileItem {\n  alt_txt?: string;\n  app_id?: string;\n  app_name?: string;\n  bot_id?: string;\n  cc?: EmailAddress[];\n  channel_actions_count?: number;\n  channel_actions_ts?: string;\n  channels?: string[];\n  comments_count?: number;\n  converted_pdf?: string;\n  created: number;\n  deanimate?: string;\n  deanimate_gif?: string;\n  display_as_bot?: boolean;\n  duration_ms?: number;\n  edit_link?: string;\n  editable?: boolean;\n  editor?: string;\n  external_id?: string;\n  external_type?: string;\n  external_url?: string;\n  file_access?: string;\n  filetype: string;\n  from?: EmailAddress[];\n  groups?: string[];\n  has_more?: boolean;\n  has_more_shares?: boolean;\n  has_rich_preview?: boolean;\n  headers?: EmailHeaders;\n  hls?: string;\n  hls_embed?: string;\n  id?: string;\n  image_exif_rotation?: number;\n  ims?: string[];\n  initial_comment?: FileInitialComment;\n  is_external?: boolean;\n  is_public?: boolean;\n  is_starred?: boolean;\n  last_editor?: string;\n  lines?: number;\n  lines_more?: number;\n  media_display_type?: string;\n  media_progress?: SlackVideoMediaProgress;\n  mimetype?: string;\n  mode?: string;\n  mp4?: string;\n  name: string;\n  non_owner_editable?: boolean;\n  num_stars?: number;\n  original_attachment_count?: number;\n  original_h?: string;\n  original_w?: string;\n  permalink: string;\n  permalink_public?: string;\n  pinned_to?: string[];\n  pjpeg?: string;\n  plain_text?: string;\n  pretty_type?: string;\n  preview?: string;\n  preview_highlight?: string;\n  preview_is_truncated?: boolean;\n  preview_plain_text?: string;\n  public_url_shared?: boolean;\n  reactions?: Reaction[];\n  sent_to_self?: boolean;\n  shares?: FileShares;\n  simplified_html?: string;\n  size?: number;\n  source_team?: string;\n  subject?: string;\n  subtype?: string;\n  thumb_1024?: string;\n  thumb_1024_gif?: string;\n  thumb_1024_h?: string;\n  thumb_1024_w?: string;\n  thumb_160?: string;\n  thumb_160_gif?: string;\n  thumb_160_h?: string;\n  thumb_160_w?: string;\n  thumb_360?: string;\n  thumb_360_gif?: string;\n  thumb_360_h?: string;\n  thumb_360_w?: string;\n  thumb_480?: string;\n  thumb_480_gif?: string;\n  thumb_480_h?: string;\n  thumb_480_w?: string;\n  thumb_64?: string;\n  thumb_64_gif?: string;\n  thumb_64_h?: string;\n  thumb_64_w?: string;\n  thumb_720?: string;\n  thumb_720_gif?: string;\n  thumb_720_h?: string;\n  thumb_720_w?: string;\n  thumb_80?: string;\n  thumb_800?: string;\n  thumb_800_gif?: string;\n  thumb_800_h?: string;\n  thumb_800_w?: string;\n  thumb_80_gif?: string;\n  thumb_80_h?: string;\n  thumb_80_w?: string;\n  thumb_960?: string;\n  thumb_960_gif?: string;\n  thumb_960_h?: string;\n  thumb_960_w?: string;\n  thumb_gif?: string;\n  thumb_pdf?: string;\n  thumb_pdf_h?: string;\n  thumb_pdf_w?: string;\n  thumb_tiny?: string;\n  thumb_video?: string;\n  thumb_video_h?: number;\n  thumb_video_w?: number;\n  timestamp?: number;\n  title?: string;\n  to?: EmailAddress[];\n  transcription?: FileTranscription;\n  updated?: number;\n  url_private: string;\n  url_private_download: string;\n  user: string;\n  user_team: string;\n  username: string;\n  vtt?: string;\n}\n", "export interface EmailAddress {\n  address: string;\n  name: string;\n  original: string;\n}\n\nexport interface EmailHeaders {\n  date: string;\n  in_reply_to: string;\n  message_id: string;\n  reply_to: string;\n}\n", "export interface SlackVideoMediaProgress {\n  duration_ms: number;\n  max_offset_ms: number;\n  offset_ms: number;\n}\n\nexport interface Reaction {\n  count: number;\n  name: string;\n  url: string;\n  users: string[];\n}\n", "export interface FileShares {\n  private?: { [key: string]: ShareDetails[] };\n  public?: { [key: string]: ShareDetails[] };\n}\n\nexport interface ShareDetails {\n  share_user_id: string;\n  team_id: string;\n  channel_name: string;\n  ts: string;\n  latest_reply?: string;\n  reply_count?: number;\n  reply_users?: string[];\n  reply_users_count?: number;\n  thread_ts?: string;\n}\n", "export interface FileTranscription {\n  locale: string;\n  status: string;\n}\n\nexport interface MessageItem {\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  client_msg_id: string;\n  display_as_bot?: boolean;\n  edited?: MessageEdited;\n  files?: FileElement[];\n  inviter?: string;\n  is_locked?: boolean;\n  is_starred?: boolean;\n  last_read?: string;\n  latest_reply?: string;\n  permalink: string;\n  reactions?: Reaction[];\n  reply_count?: number;\n  reply_users?: string[];\n  reply_users_count?: number;\n  subscribed?: boolean;\n  subtype?: string;\n  team: string;\n  text: string;\n  thread_ts?: string;\n  ts: string;\n  type: string;\n  upload?: boolean;\n  user: string;\n  username: string;\n}\n", "export interface MessageEdited {\n  ts: string;\n  user: string;\n}\n\nexport interface FileElement {\n  alt_txt?: string;\n  app_id?: string;\n  app_name?: string;\n  bot_id?: string;\n  cc?: EmailAddress[];\n  channel_actions_count?: number;\n  channel_actions_ts?: string;\n  channels?: string[];\n  comments_count?: number;\n  converted_pdf?: string;\n  created?: number;\n  deanimate?: string;\n  deanimate_gif?: string;\n  display_as_bot?: boolean;\n  duration_ms?: number;\n  edit_link?: string;\n  editable?: boolean;\n  editor?: string;\n  external_id?: string;\n  external_type?: string;\n  external_url?: string;\n  file_access?: string;\n  filetype?: string;\n  from?: EmailAddress[];\n  groups?: string[];\n  has_more?: boolean;\n  has_more_shares?: boolean;\n  has_rich_preview?: boolean;\n  headers?: Headers;\n  hls?: string;\n  hls_embed?: string;\n  id?: string;\n  image_exif_rotation?: number;\n  ims?: string[];\n  initial_comment?: FileInitialComment;\n  is_external: boolean;\n  is_public: boolean;\n  is_starred?: boolean;\n  last_editor?: string;\n  lines?: number;\n  lines_more?: number;\n  media_display_type?: string;\n  media_progress?: SlackVideoMediaProgress;\n  mimetype: string;\n  mode?: string;\n  mp4?: string;\n  name: string;\n  non_owner_editable?: boolean;\n  num_stars?: number;\n  original_attachment_count?: number;\n  original_h?: string;\n  original_w?: string;\n  permalink: string;\n  permalink_public?: string;\n  pinned_to?: string[];\n  pjpeg?: string;\n  plain_text?: string;\n  pretty_type?: string;\n  preview?: string;\n  preview_highlight?: string;\n  preview_is_truncated?: boolean;\n  preview_plain_text?: string;\n  public_url_shared?: boolean;\n  reactions?: Reaction[];\n  sent_to_self?: boolean;\n  shares?: FileShares;\n  simplified_html?: string;\n  size?: number;\n  source_team?: string;\n  subject?: string;\n  subtype?: string;\n  thumb_1024?: string;\n  thumb_1024_gif?: string;\n  thumb_1024_h?: string;\n  thumb_1024_w?: string;\n  thumb_160?: string;\n  thumb_160_gif?: string;\n  thumb_160_h?: string;\n  thumb_160_w?: string;\n  thumb_360?: string;\n  thumb_360_gif?: string;\n  thumb_360_h?: string;\n  thumb_360_w?: string;\n  thumb_480?: string;\n  thumb_480_gif?: string;\n  thumb_480_h?: string;\n  thumb_480_w?: string;\n  thumb_64?: string;\n  thumb_64_gif?: string;\n  thumb_64_h?: string;\n  thumb_64_w?: string;\n  thumb_720?: string;\n  thumb_720_gif?: string;\n  thumb_720_h?: string;\n  thumb_720_w?: string;\n  thumb_80?: string;\n  thumb_800?: string;\n  thumb_800_gif?: string;\n  thumb_800_h?: string;\n  thumb_800_w?: string;\n  thumb_80_gif?: string;\n  thumb_80_h?: string;\n  thumb_80_w?: string;\n  thumb_960?: string;\n  thumb_960_gif?: string;\n  thumb_960_h?: string;\n  thumb_960_w?: string;\n  thumb_gif?: string;\n  thumb_pdf?: string;\n  thumb_pdf_h?: string;\n  thumb_pdf_w?: string;\n  thumb_tiny?: string;\n  thumb_video?: string;\n  thumb_video_h?: number;\n  thumb_video_w?: number;\n  timestamp: number;\n  title: string;\n  to?: EmailAddress[];\n  transcription?: FileTranscription;\n  updated?: number;\n  url_private: string;\n  url_private_download: string;\n  user: string;\n  user_team: string;\n  username: string;\n  vtt?: string;\n}\n"]}
{"filename": "src_deno/request/payload/block-action.ts", "chunked_list": ["import {\n  AnyOption,\n  Confirm,\n  PlainTextField,\n} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\nimport { DataSubmissionView, ViewStateValue } from \"./view-objects.ts\";\n\nexport interface BlockAction<A extends BlockElementAction> {\n  type: \"block_actions\";\n  actions: A[];\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  channel?: {\n    id: string;\n    name: string;\n  };\n  message?: {\n    type: \"message\";\n    user?: string;\n    ts: string;\n    text?: string;\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any;\n  };\n  view?: DataSubmissionView;\n  state?: {\n    values: {\n      [blockId: string]: {\n        [actionId: string]: ViewStateValue;\n      };\n    };\n  };\n  token: string;\n  response_url: string;\n  trigger_id: string;\n  api_app_id: string;\n  // deno-lint-ignore no-explicit-any\n  container: any;\n  // deno-lint-ignore no-explicit-any\n  app_unfurl?: any;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n}\n", "export interface BlockElementAction<T extends string = string> {\n  type: T;\n  block_id: string;\n  action_id: string;\n  action_ts: string;\n}\n\nexport interface ButtonAction extends BlockElementAction<\"button\"> {\n  value: string;\n  text: PlainTextField;\n  url?: string;\n  confirm?: Confirm;\n  accessibility_label?: string;\n}\n", "export interface StaticSelectAction\n  extends BlockElementAction<\"static_select\"> {\n  selected_option: {\n    text: PlainTextField;\n    value: string;\n  };\n  initial_option?: AnyOption;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface MultiStaticSelectAction\n  extends BlockElementAction<\"multi_static_select\"> {\n  selected_options: {\n    text: PlainTextField;\n    value: string;\n  }[];\n  initial_options?: AnyOption[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface UsersSelectAction extends BlockElementAction<\"users_select\"> {\n  selected_user: string;\n  initial_user?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface MultiUsersSelectAction\n  extends BlockElementAction<\"multi_users_select\"> {\n  selected_users: string[];\n  initial_users?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface ConversationsSelectAction\n  extends BlockElementAction<\"conversations_select\"> {\n  selected_conversation: string;\n  initial_conversation?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface MultiConversationsSelectAction\n  extends BlockElementAction<\"multi_conversations_select\"> {\n  selected_conversations: string[];\n  initial_conversations?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface MultiConversationsSelectAction\n  extends BlockElementAction<\"multi_conversations_select\"> {\n  selected_conversations: string[];\n  initial_conversations?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface ChannelsSelectAction\n  extends BlockElementAction<\"channels_select\"> {\n  selected_channel: string;\n  initial_channel?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface ChannelsSelectAction\n  extends BlockElementAction<\"channels_select\"> {\n  selected_channel: string;\n  initial_channel?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface MultiChannelsSelectAction\n  extends BlockElementAction<\"multi_channels_select\"> {\n  selected_channels: string[];\n  initial_channels?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface MultiChannelsSelectAction\n  extends BlockElementAction<\"multi_channels_select\"> {\n  selected_channels: string[];\n  initial_channels?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface ExternalSelectAction\n  extends BlockElementAction<\"external_select\"> {\n  selected_option?: AnyOption;\n  initial_option?: AnyOption;\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n", "export interface ExternalSelectAction\n  extends BlockElementAction<\"external_select\"> {\n  selected_option?: AnyOption;\n  initial_option?: AnyOption;\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n\nexport interface MultiExternalSelectAction\n  extends BlockElementAction<\"multi_external_select\"> {\n  selected_options?: AnyOption[];\n  initial_options?: AnyOption[];\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n", "export interface MultiExternalSelectAction\n  extends BlockElementAction<\"multi_external_select\"> {\n  selected_options?: AnyOption[];\n  initial_options?: AnyOption[];\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n\nexport interface OverflowAction extends BlockElementAction<\"overflow\"> {\n  selected_option: {\n    text: PlainTextField;\n    value: string;\n  };\n  confirm?: Confirm;\n}\n", "export interface OverflowAction extends BlockElementAction<\"overflow\"> {\n  selected_option: {\n    text: PlainTextField;\n    value: string;\n  };\n  confirm?: Confirm;\n}\n\nexport interface DatepickerAction extends BlockElementAction<\"datepicker\"> {\n  selected_date: string | null;\n  initial_date?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface DatepickerAction extends BlockElementAction<\"datepicker\"> {\n  selected_date: string | null;\n  initial_date?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface RadioButtonsAction\n  extends BlockElementAction<\"radio_buttons\"> {\n  selected_option: AnyOption | null;\n  initial_option?: AnyOption;\n  confirm?: Confirm;\n}\n", "export interface CheckboxesAction extends BlockElementAction<\"checkboxes\"> {\n  selected_options: AnyOption[];\n  initial_options?: AnyOption[];\n  confirm?: Confirm;\n}\n\nexport interface PlainTextInputAction\n  extends BlockElementAction<\"plain_text_input\"> {\n  value: string;\n}\n", "export type Actions =\n  | ButtonAction\n  | StaticSelectAction\n  | MultiStaticSelectAction\n  | UsersSelectAction\n  | MultiUsersSelectAction\n  | ConversationsSelectAction\n  | MultiConversationsSelectAction\n  | ChannelsSelectAction\n  | MultiChannelsSelectAction\n  | ExternalSelectAction\n  | MultiExternalSelectAction\n  | OverflowAction\n  | DatepickerAction\n  | RadioButtonsAction\n  | CheckboxesAction\n  | PlainTextInputAction;\n", "export type BlockElementTypes = Actions[\"type\"];\n"]}
{"filename": "src_deno/request/payload/message-shortcut.ts", "chunked_list": ["export interface MessageShortcut {\n  type: \"message_action\";\n  callback_id: string;\n  trigger_id: string;\n  message_ts: string;\n  response_url: string;\n  message: {\n    type: \"message\";\n    user?: string;\n    ts: string;\n    text?: string;\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any;\n  };\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n    username?: string;\n  };\n  channel: {\n    id: string;\n    name: string;\n  };\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  token: string;\n  action_ts: string;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n}\n"]}
{"filename": "src_deno/middleware/built-in-middleware.ts", "chunked_list": ["import { Middleware, PreAuthorizeMiddleware } from \"./middleware.ts\";\n\n// deno-lint-ignore require-await\nexport const urlVerification: PreAuthorizeMiddleware = async (req) => {\n  if (req.body.type === \"url_verification\") {\n    return { status: 200, body: req.body.challenge };\n  }\n};\n\nconst eventTypesToKeep = [\"member_joined_channel\", \"member_left_channel\"];\n\n// deno-lint-ignore require-await\nexport const ignoringSelfEvents: Middleware = async (req) => {", "  if (req.body.event) {\n    if (eventTypesToKeep.includes(req.body.event.type)) {\n      return;\n    }\n    if (\n      req.context.authorizeResult.botId === req.body.event.bot_id ||\n      req.context.authorizeResult.botUserId === req.context.userId\n    ) {\n      return { status: 200, body: \"\" };\n    }\n  }\n};\n"]}
{"filename": "src_deno/middleware/middleware.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\nimport {\n  PreAuthorizeSlackMiddlwareRequest,\n  SlackMiddlwareRequest,\n} from \"../request/request.ts\";\nimport { SlackResponse } from \"../response/response.ts\";\n\nexport type PreAuthorizeMiddleware<E extends SlackAppEnv = SlackAppEnv> = (\n  req: PreAuthorizeSlackMiddlwareRequest<E>,\n) => Promise<SlackResponse | void>;\n", "export type Middleware<E extends SlackAppEnv = SlackAppEnv> = (\n  req: SlackMiddlwareRequest<E>,\n) => Promise<SlackResponse | void>;\n"]}
{"filename": "src_deno/oauth/callback.ts", "chunked_list": ["import { InvalidStateParameter, OAuthErrorCode } from \"./error-codes.ts\";\nimport { Installation } from \"./installation.ts\";\nimport { renderErrorPage } from \"./oauth-page-renderer.ts\";\n\nexport type BeforeInstallation = (\n  req: Request,\n) => Promise<Response | undefined | void>;\n\nexport type AfterInstallation = (\n  installation: Installation,\n  req: Request,\n) => Promise<Response | undefined | void>;\n", "export type AfterInstallation = (\n  installation: Installation,\n  req: Request,\n) => Promise<Response | undefined | void>;\n\nexport type OnStateValidationError = (\n  startPath: string,\n  req: Request,\n) => Promise<Response>;\n\n// deno-lint-ignore require-await\nexport const defaultOnStateValidationError = async (\n  startPath: string,\n  // deno-lint-ignore no-unused-vars\n  req: Request,\n) => {\n  return new Response(renderErrorPage(startPath, InvalidStateParameter), {\n    status: 400,\n    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n  });\n};\n", "export type OnFailure = (\n  startPath: string,\n  reason: OAuthErrorCode,\n  req: Request,\n) => Promise<Response>;\n\n// deno-lint-ignore require-await\nexport const defaultOnFailure = async (\n  startPath: string,\n  reason: OAuthErrorCode,\n  // deno-lint-ignore no-unused-vars\n  req: Request,\n) => {\n  return new Response(renderErrorPage(startPath, reason), {\n    status: 400,\n    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n  });\n};\n"]}
{"filename": "src_deno/oauth/installation.ts", "chunked_list": ["import { OAuthV2AccessResponse } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\nexport interface Installation {\n  app_id: string;\n  is_enterprise_install?: boolean;\n  enterprise_id?: string; // only for Enterprise Grid installations\n  team_id?: string; // can be absent when is_enterprise_install is true\n  user_id: string;\n\n  // bot token\n  bot_token?: string;\n  bot_user_id?: string;\n  bot_scopes?: string[];\n  bot_refresh_token?: string; // token rotation\n  bot_token_expires_at?: number; // token rotation (epoch time seconds)\n\n  // user token\n  user_token?: string;\n  user_scopes?: string[];\n  user_refresh_token?: string; // token rotation\n  user_token_expires_at?: number; // token rotation (epoch time seconds)\n\n  // Only when having incoming-webhooks\n  incoming_webhook_url?: string;\n  incoming_webhook_channel_id?: string;\n  incoming_webhook_configuration_url?: string;\n}\n", "export function toInstallation(\n  oauthAccess: OAuthV2AccessResponse,\n): Installation {\n  const installation: Installation = {\n    app_id: oauthAccess.app_id!,\n    is_enterprise_install: oauthAccess.is_enterprise_install,\n    enterprise_id: oauthAccess.enterprise?.id,\n    team_id: oauthAccess.team?.id,\n    user_id: oauthAccess.authed_user?.id!,\n    // bot token\n    bot_token: oauthAccess.access_token,\n    bot_user_id: oauthAccess.bot_user_id,\n    bot_scopes: oauthAccess.scope?.split(\",\"),\n    bot_refresh_token: oauthAccess.refresh_token,\n    bot_token_expires_at: oauthAccess.expires_in\n      ? new Date().getTime() / 1000 + oauthAccess.expires_in\n      : undefined,\n\n    // user token\n    user_token: oauthAccess.authed_user?.access_token,\n    user_scopes: oauthAccess.authed_user?.scope?.split(\",\"),\n    user_refresh_token: oauthAccess.authed_user?.refresh_token,\n    user_token_expires_at: oauthAccess.authed_user?.expires_in\n      ? new Date().getTime() / 1000 + oauthAccess.authed_user?.expires_in\n      : undefined,\n\n    // Only when having incoming-webhooks\n    incoming_webhook_url: oauthAccess.incoming_webhook?.url,\n    incoming_webhook_channel_id: oauthAccess.incoming_webhook?.channel_id,\n    incoming_webhook_configuration_url: oauthAccess.incoming_webhook?.url,\n  };\n  return installation;\n}\n"]}
{"filename": "src_deno/oauth/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env.ts\";\n\nexport function generateAuthorizeUrl<E extends SlackOAuthEnv>(\n  state: string,\n  env: E,\n  team: string | undefined = undefined,\n): string {\n  let url = `https://slack.com/oauth/v2/authorize?state=${state}`;\n  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n  url += `&scope=${env.SLACK_BOT_SCOPES}`;\n  if (env.SLACK_USER_SCOPES) {\n    url += `&user_scope=${env.SLACK_USER_SCOPES}`;\n  }", "  if (env.SLACK_USER_SCOPES) {\n    url += `&user_scope=${env.SLACK_USER_SCOPES}`;\n  }\n  if (env.SLACK_REDIRECT_URI) {\n    url += `&redirect_uri=${env.SLACK_REDIRECT_URI}`;\n  }\n  if (team) {\n    url += `&team=${team}`;\n  }\n  return url;\n}\n"]}
{"filename": "src_deno/oauth/error-codes.ts", "chunked_list": ["export interface OAuthErrorCode {\n  code: string;\n  message: string;\n}\n\nexport const InvalidStateParameter: OAuthErrorCode = {\n  code: \"invalid-state\",\n  message: \"The state parameter is missing or invalid\",\n};\n\nexport const MissingCode: OAuthErrorCode = {\n  code: \"missing-code\",\n  message: \"The code parameter is missing\",\n};\n\nexport const InstallationError: OAuthErrorCode = {\n  code: \"installation-error\",\n  message: \"The installation process failed\",\n};\n\nexport const InstallationStoreError: OAuthErrorCode = {\n  code: \"installation-store-error\",\n  message: \"Saving the installation data failed\",\n};\n\nexport const CompletionPageError: OAuthErrorCode = {\n  code: \"completion-page-failure\",\n  message: \"Rendering the completion page failed\",\n};\n\nexport const OpenIDConnectError: OAuthErrorCode = {\n  code: \"oidc-error\",\n  message: \"The OpenID Connect process failed\",\n};\n"]}
{"filename": "src_deno/oauth/oauth-page-renderer.ts", "chunked_list": ["import { OAuthErrorCode } from \"./error-codes.ts\";\nimport { escapeHtml } from \"./escape-html.ts\";\n\nexport function renderStartPage(url: string) {\n  return (\n    '<html><head><meta http-equiv=\"refresh\" content=\"2;url=' +\n    escapeHtml(url) +\n    '\" /><title>Redirecting to Slack ...</title></head><body>Redirecting to the Slack OAuth page ... Click <a href=\"' +\n    escapeHtml(url) +\n    '\">here</a> to continue.</body></html>'\n  );\n}\n", "export function renderErrorPage(installPath: string, reason: OAuthErrorCode) {\n  return (\n    '<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Oops, Something Went Wrong!</h2><p>Please try again from <a href=\"' +\n    escapeHtml(installPath) +\n    '\">here</a> or contact the app owner (reason: ' +\n    escapeHtml(reason.message) +\n    \")</p></body></html>\"\n  );\n}\n\nexport function renderCompletionPage(\n  appId: string,\n  teamId: string,\n  isEnterpriseInstall: boolean | undefined,\n  enterpriseUrl: string | undefined,\n) {\n  let url = `slack://app?team=${teamId}&id=${appId}`;", "export function renderCompletionPage(\n  appId: string,\n  teamId: string,\n  isEnterpriseInstall: boolean | undefined,\n  enterpriseUrl: string | undefined,\n) {\n  let url = `slack://app?team=${teamId}&id=${appId}`;\n  if (isEnterpriseInstall && enterpriseUrl !== undefined) {\n    url =\n      `${enterpriseUrl}manage/organization/apps/profile/${appId}/workspaces/add\"`;\n  }\n  const browserUrl = `https://app.slack.com/client/${teamId}`;\n  return (\n    '<html><head><meta http-equiv=\"refresh\" content=\"0; URL=' +\n    escapeHtml(url) +\n    '\"><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Thank you!</h2><p>Redirecting to the Slack App... click <a href=\"' +\n    escapeHtml(url) +\n    '\">here</a>. If you use the browser version of Slack, click <a href=\"' +\n    escapeHtml(browserUrl) +\n    '\" target=\"_blank\">this link</a> instead.</p></body></html>'\n  );\n}\n"]}
{"filename": "src_deno/oauth/state-store.ts", "chunked_list": ["export interface StateStore {\n  issueNewState(): Promise<string>;\n  consume(state: string): Promise<boolean>;\n}\n\nexport class NoStorageStateStore implements StateStore {\n  // deno-lint-ignore require-await\n  async issueNewState(): Promise<string> {\n    return crypto.randomUUID();\n  }\n\n  // deno-lint-ignore require-await no-unused-vars\n  async consume(state: string): Promise<boolean> {\n    return true;\n  }\n}\n"]}
{"filename": "src_deno/oauth/installation-store.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env.ts\";\nimport { Authorize } from \"../authorization/authorize.ts\";\nimport { Installation } from \"./installation.ts\";\n\nexport interface InstallationStoreQuery {\n  enterpriseId?: string;\n  teamId?: string;\n  userId?: string;\n  isEnterpriseInstall?: boolean;\n}\n", "export interface InstallationStore<E extends SlackOAuthEnv> {\n  save(installation: Installation, request: Request | undefined): Promise<void>;\n\n  findBotInstallation(\n    query: InstallationStoreQuery,\n  ): Promise<Installation | undefined>;\n\n  findUserInstallation(\n    query: InstallationStoreQuery,\n  ): Promise<Installation | undefined>;\n\n  toAuthorize(): Authorize<E>;\n}\n"]}
{"filename": "src_deno/oauth/escape-html.ts", "chunked_list": ["export function escapeHtml(input: string | undefined | null): string {\n  if (input) {\n    return input\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/\"/g, \"&quot;\")\n      .replace(/'/g, \"&#x27;\");\n  }\n  return \"\";\n}\n"]}
{"filename": "src/oauth-app.ts", "chunked_list": ["import { ExecutionContext, NoopExecutionContext } from \"./execution-context\";\nimport { SlackApp } from \"./app\";\nimport { SlackOAuthEnv } from \"./app-env\";\nimport { InstallationStore } from \"./oauth/installation-store\";\nimport { NoStorageStateStore, StateStore } from \"./oauth/state-store\";\nimport {\n  renderCompletionPage,\n  renderStartPage,\n} from \"./oauth/oauth-page-renderer\";\nimport { generateAuthorizeUrl } from \"./oauth/authorize-url-generator\";", "} from \"./oauth/oauth-page-renderer\";\nimport { generateAuthorizeUrl } from \"./oauth/authorize-url-generator\";\nimport { parse as parseCookie } from \"./cookie\";\nimport {\n  SlackAPIClient,\n  OAuthV2AccessResponse,\n  OpenIDConnectTokenResponse,\n} from \"slack-web-api-client\";\nimport { toInstallation } from \"./oauth/installation\";\nimport {", "import { toInstallation } from \"./oauth/installation\";\nimport {\n  AfterInstallation,\n  BeforeInstallation,\n  OnFailure,\n  OnStateValidationError,\n  defaultOnFailure,\n  defaultOnStateValidationError,\n} from \"./oauth/callback\";\nimport {", "} from \"./oauth/callback\";\nimport {\n  OpenIDConnectCallback,\n  defaultOpenIDConnectCallback,\n} from \"./oidc/callback\";\nimport { generateOIDCAuthorizeUrl } from \"./oidc/authorize-url-generator\";\nimport {\n  InstallationError,\n  MissingCode,\n  CompletionPageError,", "  MissingCode,\n  CompletionPageError,\n  InstallationStoreError,\n  OpenIDConnectError,\n} from \"./oauth/error-codes\";\n\nexport interface SlackOAuthAppOptions<E extends SlackOAuthEnv> {\n  env: E;\n  installationStore: InstallationStore<E>;\n  stateStore?: StateStore;\n  oauth?: {\n    stateCookieName?: string;\n    beforeInstallation?: BeforeInstallation;\n    afterInstallation?: AfterInstallation;\n    onFailure?: OnFailure;\n    onStateValidationError?: OnStateValidationError;\n    redirectUri?: string;\n  };\n  oidc?: {\n    stateCookieName?: string;\n    callback: OpenIDConnectCallback;\n    onFailure?: OnFailure;\n    onStateValidationError?: OnStateValidationError;\n    redirectUri?: string;\n  };\n  routes?: {\n    events: string;\n    oauth: { start: string; callback: string };\n    oidc?: { start: string; callback: string };\n  };\n}\n", "export class SlackOAuthApp<E extends SlackOAuthEnv> extends SlackApp<E> {\n  public env: E;\n  public installationStore: InstallationStore<E>;\n  public stateStore: StateStore;\n  public oauth: {\n    stateCookieName?: string;\n    beforeInstallation?: BeforeInstallation;\n    afterInstallation?: AfterInstallation;\n    onFailure: OnFailure;\n    onStateValidationError: OnStateValidationError;\n    redirectUri?: string;\n  };\n  public oidc?: {\n    stateCookieName?: string;\n    callback: OpenIDConnectCallback;\n    onFailure: OnFailure;\n    onStateValidationError: OnStateValidationError;\n    redirectUri?: string;\n  };\n  public routes: {\n    events: string;\n    oauth: { start: string; callback: string };\n    oidc?: { start: string; callback: string };\n  };\n\n  constructor(options: SlackOAuthAppOptions<E>) {\n    super({\n      env: options.env,\n      authorize: options.installationStore.toAuthorize(),\n      routes: { events: options.routes?.events ?? \"/slack/events\" },\n    });\n    this.env = options.env;\n    this.installationStore = options.installationStore;\n    this.stateStore = options.stateStore ?? new NoStorageStateStore();\n    this.oauth = {\n      stateCookieName:\n        options.oauth?.stateCookieName ?? \"slack-app-oauth-state\",\n      onFailure: options.oauth?.onFailure ?? defaultOnFailure,\n      onStateValidationError:\n        options.oauth?.onStateValidationError ?? defaultOnStateValidationError,\n      redirectUri: options.oauth?.redirectUri ?? this.env.SLACK_REDIRECT_URI,\n    };", "    if (options.oidc) {\n      this.oidc = {\n        stateCookieName: options.oidc.stateCookieName ?? \"slack-app-oidc-state\",\n        onFailure: options.oidc.onFailure ?? defaultOnFailure,\n        onStateValidationError:\n          options.oidc.onStateValidationError ?? defaultOnStateValidationError,\n        callback: defaultOpenIDConnectCallback(this.env),\n        redirectUri:\n          options.oidc.redirectUri ?? this.env.SLACK_OIDC_REDIRECT_URI,\n      };\n    } else {\n      this.oidc = undefined;\n    }\n    this.routes = options.routes\n      ? options.routes\n      : {\n          events: \"/slack/events\",\n          oauth: {\n            start: \"/slack/install\",\n            callback: \"/slack/oauth_redirect\",\n          },\n          oidc: {\n            start: \"/slack/login\",\n            callback: \"/slack/login/callback\",\n          },\n        };\n  }\n\n  async run(\n    request: Request,\n    ctx: ExecutionContext = new NoopExecutionContext()\n  ): Promise<Response> {\n    const url = new URL(request.url);", "    if (request.method === \"GET\") {\n      if (url.pathname === this.routes.oauth.start) {\n        return await this.handleOAuthStartRequest(request);\n      } else if (url.pathname === this.routes.oauth.callback) {\n        return await this.handleOAuthCallbackRequest(request);\n      }\n      if (this.routes.oidc) {\n        if (url.pathname === this.routes.oidc.start) {\n          return await this.handleOIDCStartRequest(request);\n        } else if (url.pathname === this.routes.oidc.callback) {\n          return await this.handleOIDCCallbackRequest(request);\n        }\n      }", "        } else if (url.pathname === this.routes.oidc.callback) {\n          return await this.handleOIDCCallbackRequest(request);\n        }\n      }\n    } else if (request.method === \"POST\") {\n      if (url.pathname === this.routes.events) {\n        return await this.handleEventRequest(request, ctx);\n      }\n    }\n    return new Response(\"Not found\", { status: 404 });\n  }\n\n  async handleEventRequest(\n    request: Request,\n    ctx: ExecutionContext\n  ): Promise<Response> {\n    return await super.handleEventRequest(request, ctx);\n  }\n\n  // deno-lint-ignore no-unused-vars\n  async handleOAuthStartRequest(request: Request): Promise<Response> {\n    const stateValue = await this.stateStore.issueNewState();\n    const authorizeUrl = generateAuthorizeUrl(stateValue, this.env);\n    return new Response(renderStartPage(authorizeUrl), {\n      status: 302,\n      headers: {\n        Location: authorizeUrl,\n        \"Set-Cookie\": `${this.oauth.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n        \"Content-Type\": \"text/html; charset=utf-8\",\n      },\n    });\n  }\n\n  async handleOAuthCallbackRequest(request: Request): Promise<Response> {\n    // State parameter validation\n    await this.#validateStateParameter(\n      request,\n      this.routes.oauth.start,\n      this.oauth.stateCookieName!\n    );\n\n    const { searchParams } = new URL(request.url);\n    const code = searchParams.get(\"code\");", "    if (!code) {\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        MissingCode,\n        request\n      );\n    }\n\n    const client = new SlackAPIClient(undefined, {\n      logLevel: this.env.SLACK_LOGGING_LEVEL,\n    });\n    let oauthAccess: OAuthV2AccessResponse | undefined;", "    try {\n      // Execute the installation process\n      oauthAccess = await client.oauth.v2.access({\n        client_id: this.env.SLACK_CLIENT_ID,\n        client_secret: this.env.SLACK_CLIENT_SECRET,\n        redirect_uri: this.oauth.redirectUri,\n        code,\n      });\n    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        InstallationError,\n        request\n      );\n    }\n", "    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        InstallationError,\n        request\n      );\n    }\n\n    try {\n      // Store the installation data on this app side\n      await this.installationStore.save(toInstallation(oauthAccess), request);", "    try {\n      // Store the installation data on this app side\n      await this.installationStore.save(toInstallation(oauthAccess), request);\n    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        InstallationStoreError,\n        request\n      );\n    }\n", "    try {\n      // Build the completion page\n      const authTest = await client.auth.test({\n        token: oauthAccess.access_token,\n      });\n      const enterpriseUrl = authTest.url;\n      return new Response(\n        renderCompletionPage(\n          oauthAccess.app_id!,\n          oauthAccess.team?.id!,\n          oauthAccess.is_enterprise_install,\n          enterpriseUrl\n        ),\n        {\n          status: 200,\n          headers: {\n            \"Set-Cookie\": `${this.oauth.stateCookieName}=deleted; Secure; HttpOnly; Path=/; Max-Age=0`,\n            \"Content-Type\": \"text/html; charset=utf-8\",\n          },\n        }\n      );", "    } catch (e) {\n      console.log(e);\n      return await this.oauth.onFailure(\n        this.routes.oauth.start,\n        CompletionPageError,\n        request\n      );\n    }\n  }\n\n  // deno-lint-ignore no-unused-vars\n  async handleOIDCStartRequest(request: Request): Promise<Response> {", "    if (!this.oidc) {\n      return new Response(\"Not found\", { status: 404 });\n    }\n    const stateValue = await this.stateStore.issueNewState();\n    const authorizeUrl = generateOIDCAuthorizeUrl(stateValue, this.env);\n    return new Response(renderStartPage(authorizeUrl), {\n      status: 302,\n      headers: {\n        Location: authorizeUrl,\n        \"Set-Cookie\": `${this.oidc.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n        \"Content-Type\": \"text/html; charset=utf-8\",\n      },\n    });\n  }\n\n  async handleOIDCCallbackRequest(request: Request): Promise<Response> {", "    if (!this.oidc || !this.routes.oidc) {\n      return new Response(\"Not found\", { status: 404 });\n    }\n    // State parameter validation\n    await this.#validateStateParameter(\n      request,\n      this.routes.oidc.start,\n      this.oidc.stateCookieName!\n    );\n\n    const { searchParams } = new URL(request.url);\n    const code = searchParams.get(\"code\");", "    if (!code) {\n      return await this.oidc.onFailure(\n        this.routes.oidc.start,\n        MissingCode,\n        request\n      );\n    }\n\n    try {\n      const client = new SlackAPIClient(undefined, {\n        logLevel: this.env.SLACK_LOGGING_LEVEL,\n      });\n      const apiResponse: OpenIDConnectTokenResponse =\n        await client.openid.connect.token({\n          client_id: this.env.SLACK_CLIENT_ID,\n          client_secret: this.env.SLACK_CLIENT_SECRET,\n          redirect_uri: this.oidc.redirectUri,\n          code,\n        });\n      return await this.oidc.callback(apiResponse, request);", "    try {\n      const client = new SlackAPIClient(undefined, {\n        logLevel: this.env.SLACK_LOGGING_LEVEL,\n      });\n      const apiResponse: OpenIDConnectTokenResponse =\n        await client.openid.connect.token({\n          client_id: this.env.SLACK_CLIENT_ID,\n          client_secret: this.env.SLACK_CLIENT_SECRET,\n          redirect_uri: this.oidc.redirectUri,\n          code,\n        });\n      return await this.oidc.callback(apiResponse, request);", "    } catch (e) {\n      console.log(e);\n      return await this.oidc.onFailure(\n        this.routes.oidc.start,\n        OpenIDConnectError,\n        request\n      );\n    }\n  }\n\n  async #validateStateParameter(\n    request: Request,\n    startPath: string,\n    cookieName: string\n  ) {\n    const { searchParams } = new URL(request.url);\n    const queryState = searchParams.get(\"state\");\n    const cookie = parseCookie(request.headers.get(\"Cookie\") || \"\");\n    const cookieState = cookie[cookieName];", "    if (\n      queryState !== cookieState ||\n      !(await this.stateStore.consume(queryState))\n    ) {\n      if (startPath === this.routes.oauth.start) {\n        return await this.oauth.onStateValidationError(startPath, request);\n      } else if (\n        this.oidc &&\n        this.routes.oidc &&\n        startPath === this.routes.oidc.start\n      ) {\n        return await this.oidc.onStateValidationError(startPath, request);\n      }\n    }\n  }\n}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import { SlackAppEnv, SlackEdgeAppEnv, SlackSocketModeAppEnv } from \"./app-env\";\nimport { parseRequestBody } from \"./request/request-parser\";\nimport { verifySlackRequest } from \"./request/request-verification\";\nimport { AckResponse, SlackHandler } from \"./handler/handler\";\nimport { SlackRequestBody } from \"./request/request-body\";\nimport {\n  PreAuthorizeSlackMiddlwareRequest,\n  SlackRequestWithRespond,\n  SlackMiddlwareRequest,\n  SlackRequestWithOptionalRespond,", "  SlackMiddlwareRequest,\n  SlackRequestWithOptionalRespond,\n  SlackRequest,\n  SlackRequestWithChannelId,\n} from \"./request/request\";\nimport { SlashCommand } from \"./request/payload/slash-command\";\nimport { toCompleteResponse } from \"./response/response\";\nimport {\n  SlackEvent,\n  AnySlackEvent,", "  SlackEvent,\n  AnySlackEvent,\n  AnySlackEventWithChannelId,\n} from \"./request/payload/event\";\nimport { ResponseUrlSender, SlackAPIClient } from \"slack-web-api-client\";\nimport {\n  builtBaseContext,\n  SlackAppContext,\n  SlackAppContextWithChannelId,\n  SlackAppContextWithRespond,", "  SlackAppContextWithChannelId,\n  SlackAppContextWithRespond,\n} from \"./context/context\";\nimport { PreAuthorizeMiddleware, Middleware } from \"./middleware/middleware\";\nimport { isDebugLogEnabled, prettyPrint } from \"slack-web-api-client\";\nimport { Authorize } from \"./authorization/authorize\";\nimport { AuthorizeResult } from \"./authorization/authorize-result\";\nimport {\n  ignoringSelfEvents,\n  urlVerification,", "  ignoringSelfEvents,\n  urlVerification,\n} from \"./middleware/built-in-middleware\";\nimport { ConfigError } from \"./errors\";\nimport { GlobalShortcut } from \"./request/payload/global-shortcut\";\nimport { MessageShortcut } from \"./request/payload/message-shortcut\";\nimport {\n  BlockAction,\n  BlockElementAction,\n  BlockElementTypes,", "  BlockElementAction,\n  BlockElementTypes,\n} from \"./request/payload/block-action\";\nimport { ViewSubmission } from \"./request/payload/view-submission\";\nimport { ViewClosed } from \"./request/payload/view-closed\";\nimport { BlockSuggestion } from \"./request/payload/block-suggestion\";\nimport {\n  OptionsAckResponse,\n  SlackOptionsHandler,\n} from \"./handler/options-handler\";", "  SlackOptionsHandler,\n} from \"./handler/options-handler\";\nimport { SlackViewHandler, ViewAckResponse } from \"./handler/view-handler\";\nimport {\n  MessageAckResponse,\n  SlackMessageHandler,\n} from \"./handler/message-handler\";\nimport { singleTeamAuthorize } from \"./authorization/single-team-authorize\";\nimport { ExecutionContext, NoopExecutionContext } from \"./execution-context\";\nimport { PayloadType } from \"./request/payload-types\";", "import { ExecutionContext, NoopExecutionContext } from \"./execution-context\";\nimport { PayloadType } from \"./request/payload-types\";\nimport { isPostedMessageEvent } from \"./utility/message-events\";\nimport { SocketModeClient } from \"./socket-mode/socket-mode-client\";\n\nexport interface SlackAppOptions<\n  E extends SlackEdgeAppEnv | SlackSocketModeAppEnv\n> {\n  env: E;\n  authorize?: Authorize<E>;\n  routes?: {\n    events: string;\n  };\n  socketMode?: boolean;\n}\n", "export class SlackApp<E extends SlackEdgeAppEnv | SlackSocketModeAppEnv> {\n  public env: E;\n  public client: SlackAPIClient;\n  public authorize: Authorize<E>;\n  public routes: { events: string | undefined };\n  public signingSecret: string;\n\n  public appLevelToken: string | undefined;\n  public socketMode: boolean;\n  public socketModeClient: SocketModeClient | undefined;\n\n  // deno-lint-ignore no-explicit-any\n  public preAuthorizeMiddleware: PreAuthorizeMiddleware<any>[] = [\n    urlVerification,\n  ];\n\n  // deno-lint-ignore no-explicit-any\n  public postAuthorizeMiddleware: Middleware<any>[] = [ignoringSelfEvents];\n\n  #slashCommands: ((\n    body: SlackRequestBody\n  ) => SlackMessageHandler<E, SlashCommand> | null)[] = [];\n  #events: ((\n    body: SlackRequestBody\n  ) => SlackHandler<E, SlackEvent<string>> | null)[] = [];\n  #globalShorcuts: ((\n    body: SlackRequestBody\n  ) => SlackHandler<E, GlobalShortcut> | null)[] = [];\n  #messageShorcuts: ((\n    body: SlackRequestBody\n  ) => SlackHandler<E, MessageShortcut> | null)[] = [];\n  #blockActions: ((body: SlackRequestBody) => SlackHandler<\n    E,\n    // deno-lint-ignore no-explicit-any\n    BlockAction<any>\n  > | null)[] = [];\n  #blockSuggestions: ((\n    body: SlackRequestBody\n  ) => SlackOptionsHandler<E, BlockSuggestion> | null)[] = [];\n  #viewSubmissions: ((\n    body: SlackRequestBody\n  ) => SlackViewHandler<E, ViewSubmission> | null)[] = [];\n  #viewClosed: ((\n    body: SlackRequestBody\n  ) => SlackViewHandler<E, ViewClosed> | null)[] = [];\n\n  constructor(options: SlackAppOptions<E>) {", "    if (\n      options.env.SLACK_BOT_TOKEN === undefined &&\n      (options.authorize === undefined ||\n        options.authorize === singleTeamAuthorize)\n    ) {\n      throw new ConfigError(\n        \"When you don't pass env.SLACK_BOT_TOKEN, your own authorize function, which supplies a valid token to use, needs to be passed instead.\"\n      );\n    }\n    this.env = options.env;\n    this.client = new SlackAPIClient(options.env.SLACK_BOT_TOKEN, {\n      logLevel: this.env.SLACK_LOGGING_LEVEL,\n    });\n    this.appLevelToken = options.env.SLACK_APP_TOKEN;\n    this.socketMode = options.socketMode ?? this.appLevelToken !== undefined;", "    if (this.socketMode) {\n      this.signingSecret = \"\";\n    } else {\n      if (!this.env.SLACK_SIGNING_SECRET) {\n        throw new ConfigError(\n          \"env.SLACK_SIGNING_SECRET is required to run your app on edge functions!\"\n        );\n      }\n      this.signingSecret = this.env.SLACK_SIGNING_SECRET;\n    }\n    this.authorize = options.authorize ?? singleTeamAuthorize;\n    this.routes = { events: options.routes?.events };\n  }\n\n  beforeAuthorize(middleware: PreAuthorizeMiddleware<E>): SlackApp<E> {\n    this.preAuthorizeMiddleware.push(middleware);\n    return this;\n  }\n\n  middleware(middleware: Middleware<E>): SlackApp<E> {\n    return this.afterAuthorize(middleware);\n  }\n\n  use(middleware: Middleware<E>): SlackApp<E> {\n    return this.afterAuthorize(middleware);\n  }\n\n  afterAuthorize(middleware: Middleware<E>): SlackApp<E> {\n    this.postAuthorizeMiddleware.push(middleware);\n    return this;\n  }\n\n  command(\n    pattern: StringOrRegExp,\n    ack: (\n      req: SlackRequestWithRespond<E, SlashCommand>\n    ) => Promise<MessageAckResponse>,\n    lazy: (\n      req: SlackRequestWithRespond<E, SlashCommand>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackMessageHandler<E, SlashCommand> = { ack, lazy };\n    this.#slashCommands.push((body) => {", "      if (body.type || !body.command) {\n        return null;\n      }\n      if (typeof pattern === \"string\" && body.command === pattern) {\n        return handler;\n      } else if (\n        typeof pattern === \"object\" &&\n        pattern instanceof RegExp &&\n        body.command.match(pattern)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  event<Type extends string>(\n    event: Type,\n    lazy: (req: EventRequest<E, Type>) => Promise<void>\n  ): SlackApp<E> {\n    this.#events.push((body) => {", "      if (body.type !== PayloadType.EventsAPI || !body.event) {\n        return null;\n      }\n      if (body.event.type === event) {\n        // deno-lint-ignore require-await\n        return { ack: async () => \"\", lazy };\n      }\n      return null;\n    });\n    return this;\n  }\n\n  anyMessage(lazy: MessageEventHandler<E>): SlackApp<E> {\n    return this.message(undefined, lazy);\n  }\n\n  message(\n    pattern: MessageEventPattern,\n    lazy: MessageEventHandler<E>\n  ): SlackApp<E> {\n    this.#events.push((body) => {", "      if (\n        body.type !== PayloadType.EventsAPI ||\n        !body.event ||\n        body.event.type !== \"message\"\n      ) {\n        return null;\n      }\n      if (isPostedMessageEvent(body.event)) {\n        let matched = true;\n        if (pattern !== undefined) {\n          if (typeof pattern === \"string\") {\n            matched = body.event.text!.includes(pattern);\n          }", "        if (pattern !== undefined) {\n          if (typeof pattern === \"string\") {\n            matched = body.event.text!.includes(pattern);\n          }\n          if (typeof pattern === \"object\") {\n            matched = body.event.text!.match(pattern) !== null;\n          }\n        }\n        if (matched) {\n          // deno-lint-ignore require-await\n          return { ack: async (_: EventRequest<E, \"message\">) => \"\", lazy };\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  shortcut(\n    callbackId: StringOrRegExp,\n    ack: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>\n    ) => Promise<AckResponse>,\n    lazy: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    return this.globalShortcut(callbackId, ack, lazy).messageShortcut(\n      callbackId,\n      ack,\n      lazy\n    );\n  }\n\n  globalShortcut(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, GlobalShortcut>) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequest<E, GlobalShortcut>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, GlobalShortcut> = { ack, lazy };\n    this.#globalShorcuts.push((body) => {", "        if (matched) {\n          // deno-lint-ignore require-await\n          return { ack: async (_: EventRequest<E, \"message\">) => \"\", lazy };\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  shortcut(\n    callbackId: StringOrRegExp,\n    ack: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>\n    ) => Promise<AckResponse>,\n    lazy: (\n      req:\n        | SlackRequest<E, GlobalShortcut>\n        | SlackRequestWithRespond<E, MessageShortcut>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    return this.globalShortcut(callbackId, ack, lazy).messageShortcut(\n      callbackId,\n      ack,\n      lazy\n    );\n  }\n\n  globalShortcut(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, GlobalShortcut>) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequest<E, GlobalShortcut>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, GlobalShortcut> = { ack, lazy };\n    this.#globalShorcuts.push((body) => {", "      if (body.type !== PayloadType.GlobalShortcut || !body.callback_id) {\n        return null;\n      }\n      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  messageShortcut(\n    callbackId: StringOrRegExp,\n    ack: (\n      req: SlackRequestWithRespond<E, MessageShortcut>\n    ) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequestWithRespond<E, MessageShortcut>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, MessageShortcut> = { ack, lazy };\n    this.#messageShorcuts.push((body) => {", "      if (body.type !== PayloadType.MessageShortcut || !body.callback_id) {\n        return null;\n      }\n      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  action<\n    T extends BlockElementTypes,\n    A extends BlockAction<BlockElementAction<T>> = BlockAction<\n      BlockElementAction<T>\n    >\n  >(\n    constraints:\n      | StringOrRegExp\n      | { type: T; block_id?: string; action_id: string },\n    ack: (req: SlackRequestWithOptionalRespond<E, A>) => Promise<AckResponse>,\n    lazy: (\n      req: SlackRequestWithOptionalRespond<E, A>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackHandler<E, A> = { ack, lazy };\n    this.#blockActions.push((body) => {", "      if (\n        body.type !== PayloadType.BlockAction ||\n        !body.actions ||\n        !body.actions[0]\n      ) {\n        return null;\n      }\n      const action = body.actions[0];\n      if (typeof constraints === \"string\" && action.action_id === constraints) {\n        return handler;\n      } else if (typeof constraints === \"object\") {", "      if (typeof constraints === \"string\" && action.action_id === constraints) {\n        return handler;\n      } else if (typeof constraints === \"object\") {\n        if (constraints instanceof RegExp) {\n          if (action.action_id.match(constraints)) {\n            return handler;\n          }\n        } else if (constraints.type) {\n          if (action.type === constraints.type) {\n            if (action.action_id === constraints.action_id) {\n              if (\n                constraints.block_id &&\n                action.block_id !== constraints.block_id\n              ) {\n                return null;\n              }\n              return handler;\n            }\n          }\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  options(\n    constraints: StringOrRegExp | { block_id?: string; action_id: string },\n    ack: (req: SlackRequest<E, BlockSuggestion>) => Promise<OptionsAckResponse>\n  ): SlackApp<E> {\n    // Note that block_suggestion response must be done within 3 seconds.\n    // So, we don't support the lazy handler for it.\n    const handler: SlackOptionsHandler<E, BlockSuggestion> = { ack };\n    this.#blockSuggestions.push((body) => {", "          if (action.type === constraints.type) {\n            if (action.action_id === constraints.action_id) {\n              if (\n                constraints.block_id &&\n                action.block_id !== constraints.block_id\n              ) {\n                return null;\n              }\n              return handler;\n            }\n          }\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  options(\n    constraints: StringOrRegExp | { block_id?: string; action_id: string },\n    ack: (req: SlackRequest<E, BlockSuggestion>) => Promise<OptionsAckResponse>\n  ): SlackApp<E> {\n    // Note that block_suggestion response must be done within 3 seconds.\n    // So, we don't support the lazy handler for it.\n    const handler: SlackOptionsHandler<E, BlockSuggestion> = { ack };\n    this.#blockSuggestions.push((body) => {", "      if (body.type !== PayloadType.BlockSuggestion || !body.action_id) {\n        return null;\n      }\n      if (typeof constraints === \"string\" && body.action_id === constraints) {\n        return handler;\n      } else if (typeof constraints === \"object\") {\n        if (constraints instanceof RegExp) {\n          if (body.action_id.match(constraints)) {\n            return handler;\n          }\n        } else {", "          if (body.action_id === constraints.action_id) {\n            if (body.block_id && body.block_id !== constraints.block_id) {\n              return null;\n            }\n            return handler;\n          }\n        }\n      }\n      return null;\n    });\n    return this;\n  }\n\n  view(\n    callbackId: StringOrRegExp,\n    ack: (\n      req:\n        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n        | SlackRequest<E, ViewClosed>\n    ) => Promise<ViewAckResponse>,\n    lazy: (\n      req:\n        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n        | SlackRequest<E, ViewClosed>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    return this.viewSubmission(callbackId, ack, lazy).viewClosed(\n      callbackId,\n      ack,\n      lazy\n    );\n  }\n\n  viewSubmission(\n    callbackId: StringOrRegExp,\n    ack: (\n      req: SlackRequestWithOptionalRespond<E, ViewSubmission>\n    ) => Promise<ViewAckResponse>,\n    lazy: (\n      req: SlackRequestWithOptionalRespond<E, ViewSubmission>\n    ) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackViewHandler<E, ViewSubmission> = { ack, lazy };\n    this.#viewSubmissions.push((body) => {", "      if (body.type !== PayloadType.ViewSubmission || !body.view) {\n        return null;\n      }\n      if (\n        typeof callbackId === \"string\" &&\n        body.view.callback_id === callbackId\n      ) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  viewClosed(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, ViewClosed>) => Promise<ViewAckResponse>,\n    lazy: (req: SlackRequest<E, ViewClosed>) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackViewHandler<E, ViewClosed> = { ack, lazy };\n    this.#viewClosed.push((body) => {", "      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  viewClosed(\n    callbackId: StringOrRegExp,\n    ack: (req: SlackRequest<E, ViewClosed>) => Promise<ViewAckResponse>,\n    lazy: (req: SlackRequest<E, ViewClosed>) => Promise<void> = noopLazyListener\n  ): SlackApp<E> {\n    const handler: SlackViewHandler<E, ViewClosed> = { ack, lazy };\n    this.#viewClosed.push((body) => {", "      if (body.type !== PayloadType.ViewClosed || !body.view) {\n        return null;\n      }\n      if (\n        typeof callbackId === \"string\" &&\n        body.view.callback_id === callbackId\n      ) {\n        return handler;\n      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  async run(\n    request: Request,\n    ctx: ExecutionContext = new NoopExecutionContext()\n  ): Promise<Response> {\n    return await this.handleEventRequest(request, ctx);\n  }\n\n  async connect(): Promise<void> {", "      } else if (\n        typeof callbackId === \"object\" &&\n        callbackId instanceof RegExp &&\n        body.view.callback_id.match(callbackId)\n      ) {\n        return handler;\n      }\n      return null;\n    });\n    return this;\n  }\n\n  async run(\n    request: Request,\n    ctx: ExecutionContext = new NoopExecutionContext()\n  ): Promise<Response> {\n    return await this.handleEventRequest(request, ctx);\n  }\n\n  async connect(): Promise<void> {", "    if (!this.socketMode) {\n      throw new ConfigError(\n        \"Both env.SLACK_APP_TOKEN and socketMode: true are required to start a Socket Mode connection!\"\n      );\n    }\n    this.socketModeClient = new SocketModeClient(this);\n    await this.socketModeClient.connect();\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.socketModeClient) {\n      await this.socketModeClient.disconnect();\n    }\n  }\n\n  async handleEventRequest(\n    request: Request,\n    ctx: ExecutionContext\n  ): Promise<Response> {\n    // If the routes.events is missing, any URLs can work for handing requests from Slack", "    if (this.socketModeClient) {\n      await this.socketModeClient.disconnect();\n    }\n  }\n\n  async handleEventRequest(\n    request: Request,\n    ctx: ExecutionContext\n  ): Promise<Response> {\n    // If the routes.events is missing, any URLs can work for handing requests from Slack\n    if (this.routes.events) {\n      const { pathname } = new URL(request.url);", "    if (this.routes.events) {\n      const { pathname } = new URL(request.url);\n      if (pathname !== this.routes.events) {\n        return new Response(\"Not found\", { status: 404 });\n      }\n    }\n\n    // To avoid the following warning by Cloudflware, parse the body as Blob first\n    // Called .text() on an HTTP body which does not appear to be text ..\n    const blobRequestBody = await request.blob();\n    // We can safely assume the incoming request body is always text data\n    const rawBody: string = await blobRequestBody.text();\n\n    // For Request URL verification", "    if (rawBody.includes(\"ssl_check=\")) {\n      // Slack does not send the x-slack-signature header for this pattern.\n      // Thus, we need to check the pattern before verifying a request.\n      const bodyParams = new URLSearchParams(rawBody);\n      if (bodyParams.get(\"ssl_check\") === \"1\" && bodyParams.get(\"token\")) {\n        return new Response(\"\", { status: 200 });\n      }\n    }\n\n    // Verify the request headers and body\n    const isRequestSignatureVerified =\n      this.socketMode ||\n      (await verifySlackRequest(this.signingSecret, request.headers, rawBody));", "    if (isRequestSignatureVerified) {\n      // deno-lint-ignore no-explicit-any\n      const body: Record<string, any> = await parseRequestBody(\n        request.headers,\n        rawBody\n      );\n      let retryNum: number | undefined = undefined;\n      try {\n        const retryNumHeader = request.headers.get(\"x-slack-retry-num\");\n        if (retryNumHeader) {\n          retryNum = Number.parseInt(retryNumHeader);", "        if (retryNumHeader) {\n          retryNum = Number.parseInt(retryNumHeader);\n        } else if (this.socketMode && body.retry_attempt) {\n          retryNum = Number.parseInt(body.retry_attempt);\n        }\n        // deno-lint-ignore no-unused-vars\n      } catch (e) {\n        // Ignore an exception here\n      }\n      const retryReason =\n        request.headers.get(\"x-slack-retry-reason\") ?? body.retry_reason;\n      const preAuthorizeRequest: PreAuthorizeSlackMiddlwareRequest<E> = {\n        body,\n        rawBody,\n        retryNum,\n        retryReason,\n        context: builtBaseContext(body),\n        env: this.env,\n        headers: request.headers,\n      };", "      if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n        console.log(`*** Received request body ***\\n ${prettyPrint(body)}`);\n      }\n      for (const middlware of this.preAuthorizeMiddleware) {\n        const response = await middlware(preAuthorizeRequest);\n        if (response) {\n          return toCompleteResponse(response);\n        }\n      }\n      const authorizeResult: AuthorizeResult = await this.authorize(\n        preAuthorizeRequest\n      );\n      const authorizedContext: SlackAppContext = {\n        ...preAuthorizeRequest.context,\n        authorizeResult,\n        client: new SlackAPIClient(authorizeResult.botToken, {\n          logLevel: this.env.SLACK_LOGGING_LEVEL,\n        }),\n        botToken: authorizeResult.botToken,\n        botId: authorizeResult.botId,\n        botUserId: authorizeResult.botUserId,\n        userToken: authorizeResult.userToken,\n      };", "      if (authorizedContext.channelId) {\n        const context = authorizedContext as SlackAppContextWithChannelId;\n        const client = new SlackAPIClient(context.botToken);\n        context.say = async (params) =>\n          await client.chat.postMessage({\n            channel: context.channelId,\n            ...params,\n          });\n      }\n      if (authorizedContext.responseUrl) {\n        const responseUrl = authorizedContext.responseUrl;\n        // deno-lint-ignore require-await\n        (authorizedContext as SlackAppContextWithRespond).respond = async (\n          params\n        ) => {\n          return new ResponseUrlSender(responseUrl).call(params);\n        };\n      }\n\n      const baseRequest: SlackMiddlwareRequest<E> = {\n        ...preAuthorizeRequest,\n        context: authorizedContext,\n      };", "      if (authorizedContext.responseUrl) {\n        const responseUrl = authorizedContext.responseUrl;\n        // deno-lint-ignore require-await\n        (authorizedContext as SlackAppContextWithRespond).respond = async (\n          params\n        ) => {\n          return new ResponseUrlSender(responseUrl).call(params);\n        };\n      }\n\n      const baseRequest: SlackMiddlwareRequest<E> = {\n        ...preAuthorizeRequest,\n        context: authorizedContext,\n      };", "      for (const middlware of this.postAuthorizeMiddleware) {\n        const response = await middlware(baseRequest);\n        if (response) {\n          return toCompleteResponse(response);\n        }\n      }\n\n      const payload = body as SlackRequestBody;\n\n      if (body.type === PayloadType.EventsAPI) {\n        // Events API\n        const slackRequest: SlackRequest<E, SlackEvent<string>> = {\n          payload: body.event,\n          ...baseRequest,\n        };", "      if (body.type === PayloadType.EventsAPI) {\n        // Events API\n        const slackRequest: SlackRequest<E, SlackEvent<string>> = {\n          payload: body.event,\n          ...baseRequest,\n        };\n        for (const matcher of this.#events) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (!body.type && body.command) {\n        // Slash commands\n        const slackRequest: SlackRequest<E, SlashCommand> = {\n          payload: body as SlashCommand,\n          ...baseRequest,\n        };\n        for (const matcher of this.#slashCommands) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.GlobalShortcut) {\n        // Global shortcuts\n        const slackRequest: SlackRequest<E, GlobalShortcut> = {\n          payload: body as GlobalShortcut,\n          ...baseRequest,\n        };\n        for (const matcher of this.#globalShorcuts) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.MessageShortcut) {\n        // Message shortcuts\n        const slackRequest: SlackRequest<E, MessageShortcut> = {\n          payload: body as MessageShortcut,\n          ...baseRequest,\n        };\n        for (const matcher of this.#messageShorcuts) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.BlockAction) {\n        // Block actions\n        // deno-lint-ignore no-explicit-any\n        const slackRequest: SlackRequest<E, BlockAction<any>> = {\n          // deno-lint-ignore no-explicit-any\n          payload: body as BlockAction<any>,\n          ...baseRequest,\n        };\n        for (const matcher of this.#blockActions) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "        for (const matcher of this.#blockActions) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.BlockSuggestion) {\n        // Block suggestions\n        const slackRequest: SlackRequest<E, BlockSuggestion> = {\n          payload: body as BlockSuggestion,\n          ...baseRequest,\n        };\n        for (const matcher of this.#blockSuggestions) {\n          const handler = matcher(payload);\n          if (handler) {\n            // Note that the only way to respond to a block_suggestion request\n            // is to send an HTTP response with options/option_groups.\n            // Thus, we don't support lazy handlers for this pattern.\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            // Note that the only way to respond to a block_suggestion request\n            // is to send an HTTP response with options/option_groups.\n            // Thus, we don't support lazy handlers for this pattern.\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.ViewSubmission) {\n        // View submissions\n        const slackRequest: SlackRequest<E, ViewSubmission> = {\n          payload: body as ViewSubmission,\n          ...baseRequest,\n        };\n        for (const matcher of this.#viewSubmissions) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }", "      } else if (body.type === PayloadType.ViewClosed) {\n        // View closed\n        const slackRequest: SlackRequest<E, ViewClosed> = {\n          payload: body as ViewClosed,\n          ...baseRequest,\n        };\n        for (const matcher of this.#viewClosed) {\n          const handler = matcher(payload);\n          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);", "          if (handler) {\n            ctx.waitUntil(handler.lazy(slackRequest));\n            const slackResponse = await handler.ack(slackRequest);\n            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n              console.log(\n                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n              );\n            }\n            return toCompleteResponse(slackResponse);\n          }\n        }\n      }\n      // TODO: Add code suggestion here\n      console.log(\n        `*** No listener found ***\\n${JSON.stringify(baseRequest.body)}`\n      );\n      return new Response(\"No listener found\", { status: 404 });\n    }\n    return new Response(\"Invalid signature\", { status: 401 });\n  }\n}\n", "export type StringOrRegExp = string | RegExp;\n\nexport type EventRequest<E extends SlackAppEnv, T> = Extract<\n  AnySlackEventWithChannelId,\n  { type: T }\n> extends never\n  ? SlackRequest<E, Extract<AnySlackEvent, { type: T }>>\n  : SlackRequestWithChannelId<\n      E,\n      Extract<AnySlackEventWithChannelId, { type: T }>\n    >;\n", "export type MessageEventPattern = string | RegExp | undefined;\n\nexport type MessageEventRequest<\n  E extends SlackAppEnv,\n  ST extends string | undefined\n> = SlackRequestWithChannelId<\n  E,\n  Extract<AnySlackEventWithChannelId, { subtype: ST }>\n>;\n\nexport type MessageEventSubtypes =\n  | undefined\n  | \"bot_message\"\n  | \"thread_broadcast\"\n  | \"file_share\";\n", "export type MessageEventSubtypes =\n  | undefined\n  | \"bot_message\"\n  | \"thread_broadcast\"\n  | \"file_share\";\n\nexport type MessageEventHandler<E extends SlackAppEnv> = (\n  req: MessageEventRequest<E, MessageEventSubtypes>\n) => Promise<void>;\n\nexport const noopLazyListener = async () => {};\n"]}
{"filename": "src/execution-context.ts", "chunked_list": ["/**\n * An interface representing context parameter in Cloudflare Workers and Vercel Edge Functions.\n * Refer to the following resources:\n * - https://developers.cloudflare.com/workers/runtime-apis/fetch-event/\n * - https://vercel.com/docs/concepts/functions/edge-functions/edge-functions-api#waituntil\n */\nexport interface ExecutionContext {\n  // deno-lint-ignore no-explicit-any\n  waitUntil(promise: Promise<any>): void;\n}\n", "export class NoopExecutionContext implements ExecutionContext {\n  // deno-lint-ignore no-explicit-any\n  waitUntil(promise: Promise<any>): void {\n    promise.catch((reason) => {\n      console.error(`Failed to run a lazy listener: ${reason}`);\n    });\n  }\n}\n"]}
{"filename": "src/cookie.ts", "chunked_list": ["/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Parse a cookie header.\n *", " * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function parse(\n  str: string,\n  // deno-lint-ignore no-explicit-any\n  options: any | undefined = undefined\n): Record<string, string> {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n\n  // deno-lint-ignore no-explicit-any\n  const obj: any = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n\n  let index = 0;", "  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n\n  // deno-lint-ignore no-explicit-any\n  const obj: any = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    // no more cookie pairs", "  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n\n    // only assign once", "    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n\n    // only assign once\n    if (undefined === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      // quoted values", "    if (undefined === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  }\n  return obj;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */", "function decode(str: string): string {\n  return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n */\nfunction tryDecode(str: string, decode: (val: string) => string) {\n  try {\n    return decode(str);\n    // deno-lint-ignore no-unused-vars", "  try {\n    return decode(str);\n    // deno-lint-ignore no-unused-vars\n  } catch (e) {\n    return str;\n  }\n}\n"]}
{"filename": "src/errors.ts", "chunked_list": ["export class ConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ConfigError\";\n  }\n}\n\nexport class AuthorizeError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AuthorizeError\";\n  }\n}\n", "export class SocketModeError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SocketModeError\";\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./app\";\nexport * from \"./app-env\";\nexport * from \"./execution-context\";\n\nexport * from \"slack-web-api-client\";\n\nexport * from \"./errors\";\nexport * from \"./oauth/error-codes\";\n\nexport * from \"./handler/handler\";", "\nexport * from \"./handler/handler\";\nexport * from \"./handler/message-handler\";\nexport * from \"./handler/options-handler\";\nexport * from \"./handler/view-handler\";\n\nexport * from \"./authorization/authorize\";\nexport * from \"./authorization/authorize-result\";\nexport * from \"./authorization/single-team-authorize\";\n", "export * from \"./authorization/single-team-authorize\";\n\nexport * from \"./middleware/middleware\";\nexport * from \"./middleware/built-in-middleware\";\n\nexport * from \"./context/context\";\n\nexport * from \"./oauth-app\";\nexport * from \"./oauth/authorize-url-generator\";\nexport * from \"./oauth/callback\";", "export * from \"./oauth/authorize-url-generator\";\nexport * from \"./oauth/callback\";\nexport * from \"./oauth/escape-html\";\nexport * from \"./oauth/installation\";\nexport * from \"./oauth/installation-store\";\nexport * from \"./oauth/oauth-page-renderer\";\nexport * from \"./oauth/state-store\";\n\nexport * from \"./oidc/authorize-url-generator\";\nexport * from \"./oidc/callback\";", "export * from \"./oidc/authorize-url-generator\";\nexport * from \"./oidc/callback\";\nexport * from \"./oidc/login\";\n\nexport * from \"./request/request-body\";\nexport * from \"./request/request-verification\";\nexport * from \"./request/request\";\nexport * from \"./request/payload-types\";\n\nexport * from \"./request/payload/block-action\";", "\nexport * from \"./request/payload/block-action\";\nexport * from \"./request/payload/block-suggestion\";\nexport * from \"./request/payload/event\";\nexport * from \"./request/payload/global-shortcut\";\nexport * from \"./request/payload/message-shortcut\";\nexport * from \"./request/payload/slash-command\";\nexport * from \"./request/payload/view-submission\";\nexport * from \"./request/payload/view-closed\";\nexport * from \"./request/payload/view-objects\";", "export * from \"./request/payload/view-closed\";\nexport * from \"./request/payload/view-objects\";\n\nexport * from \"./response/response\";\nexport * from \"./socket-mode/socket-mode-client\";\n\nexport * from \"./utility/message-events\";\n"]}
{"filename": "src/app-env.ts", "chunked_list": ["export interface SlackLoggingLevel {\n  SLACK_LOGGING_LEVEL?: \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\n}\n\nexport type SlackAppEnv = SlackLoggingLevel & {\n  SLACK_SIGNING_SECRET?: string;\n  SLACK_BOT_TOKEN?: string;\n  SLACK_APP_TOKEN?: string;\n};\n\nexport type SlackEdgeAppEnv = SlackAppEnv & {\n  SLACK_SIGNING_SECRET: string;\n  SLACK_BOT_TOKEN?: string;\n};\n", "export type SlackEdgeAppEnv = SlackAppEnv & {\n  SLACK_SIGNING_SECRET: string;\n  SLACK_BOT_TOKEN?: string;\n};\n\nexport type SlackSocketModeAppEnv = SlackAppEnv & {\n  SLACK_SIGNING_SECRET?: string;\n  SLACK_BOT_TOKEN?: string;\n  SLACK_APP_TOKEN: string;\n};\n", "export type SlackOAuthEnv = (SlackEdgeAppEnv | SlackSocketModeAppEnv) & {\n  SLACK_CLIENT_ID: string;\n  SLACK_CLIENT_SECRET: string;\n  SLACK_BOT_SCOPES: string;\n  SLACK_USER_SCOPES?: string;\n  SLACK_REDIRECT_URI?: string;\n  SLACK_OIDC_SCOPES?: string;\n  SLACK_OIDC_REDIRECT_URI?: string;\n  SLACK_USER_TOKEN_RESOLUTION?: \"installer\" | \"actor\";\n};\n", "export type SlackOIDCEnv = SlackAppEnv & {\n  SLACK_CLIENT_ID: string;\n  SLACK_CLIENT_SECRET: string;\n  SLACK_OIDC_SCOPES?: string;\n  SLACK_OIDC_REDIRECT_URI: string;\n};\n\nexport type SlackOAuthAndOIDCEnv = SlackOAuthEnv & SlackOIDCEnv;\n"]}
{"filename": "src/oidc/callback.ts", "chunked_list": ["import { SlackLoggingLevel } from \"../app-env\";\nimport {\n  SlackAPIClient,\n  OpenIDConnectTokenResponse,\n} from \"slack-web-api-client\";\nimport { prettyPrint } from \"slack-web-api-client\";\n\nexport type OpenIDConnectCallback = (\n  apiResponse: OpenIDConnectTokenResponse,\n  req: Request\n) => Promise<Response>;\n", "export function defaultOpenIDConnectCallback(\n  env: SlackLoggingLevel\n): OpenIDConnectCallback {\n  // deno-lint-ignore no-unused-vars\n  return async (token, req) => {\n    const client = new SlackAPIClient(token.access_token, {\n      logLevel: env.SLACK_LOGGING_LEVEL,\n    });\n    const userInfo = await client.openid.connect.userInfo();\n    const body = `<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h1>It works!</h1><p>This is the default handler. To change this, pass \\`oidc: { callback: async (token, req) => new Response(\"TODO\") }\\` to your SlackOAuthApp constructor.</p><pre>${prettyPrint(\n      userInfo\n    )}</pre></body></html>`;\n\n    return new Response(body, {\n      status: 200,\n      headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n    });\n  };\n}\n"]}
{"filename": "src/oidc/login.ts", "chunked_list": ["import {\n  OpenIDConnectTokenResponse,\n  OpenIDConnectUserInfoResponse,\n} from \"slack-web-api-client\";\n\nexport interface Login {\n  enterprise_id?: string;\n  team_id: string;\n  user_id: string;\n  name?: string;\n  email?: string;\n  picture?: string;\n\n  access_token: string;\n  refresh_token?: string; // token rotation\n  token_expires_at?: number; // token rotation (epoch time seconds)\n}\n", "export function toLogin(\n  token: OpenIDConnectTokenResponse,\n  userInfo: OpenIDConnectUserInfoResponse\n): Login {\n  return {\n    enterprise_id: userInfo[\"https://slack.com/enterprise_id\"],\n    team_id: userInfo[\"https://slack.com/team_id\"]!,\n    user_id: userInfo[\"https://slack.com/user_id\"]!,\n    email: userInfo.email,\n    picture: userInfo.picture,\n    access_token: token.access_token!,\n    refresh_token: token.refresh_token,\n    token_expires_at: token.expires_in\n      ? new Date().getTime() / 1000 + token.expires_in\n      : undefined,\n  };\n}\n"]}
{"filename": "src/oidc/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env\";\nimport { ConfigError } from \"../errors\";\n\nexport function generateOIDCAuthorizeUrl<E extends SlackOAuthEnv>(\n  state: string,\n  env: E\n): string {\n  if (!env.SLACK_OIDC_SCOPES) {\n    throw new ConfigError(\n      \"env.SLACK_OIDC_SCOPES must be present when enabling Sign in with Slack (OpenID Connect)\"\n    );\n  }", "  if (!env.SLACK_OIDC_REDIRECT_URI) {\n    throw new ConfigError(\n      \"env.SLACK_OIDC_REDIRECT_URI must be present when enabling Sign in with Slack (OpenID Connect)\"\n    );\n  }\n  let url = `https://slack.com/openid/connect/authorize?response_type=code&state=${state}`;\n  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n  url += `&scope=${env.SLACK_OIDC_SCOPES}`;\n  url += `&redirect_uri=${env.SLACK_OIDC_REDIRECT_URI}`;\n  return url;\n}\n"]}
{"filename": "src/context/context.ts", "chunked_list": ["import { AuthorizeResult } from \"../authorization/authorize-result\";\nimport {\n  SlackAPIClient,\n  ChatPostMessageRequest,\n  ChatPostMessageResponse,\n  WebhookParams,\n} from \"slack-web-api-client\";\n\nexport interface PreAuthorizeSlackAppContext {\n  isEnterpriseinstall?: boolean;\n  enterpriseId?: string;\n  teamId?: string;\n  userId?: string;\n  actorEnterpriseId?: string;\n  actorTeamId?: string;\n  actorUserId?: string;\n  botId?: string;\n  botUserId?: string;\n  responseUrl?: string;\n  channelId?: string;\n  custom: {\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any; // custom properties\n  };\n}\n", "export interface PreAuthorizeSlackAppContext {\n  isEnterpriseinstall?: boolean;\n  enterpriseId?: string;\n  teamId?: string;\n  userId?: string;\n  actorEnterpriseId?: string;\n  actorTeamId?: string;\n  actorUserId?: string;\n  botId?: string;\n  botUserId?: string;\n  responseUrl?: string;\n  channelId?: string;\n  custom: {\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any; // custom properties\n  };\n}\n", "export type SlackAppContext = {\n  client: SlackAPIClient;\n  botToken: string;\n  userToken?: string;\n  authorizeResult: AuthorizeResult;\n} & PreAuthorizeSlackAppContext;\n\nexport type SlackAppContextWithChannelId = {\n  channelId: string;\n  say: (\n    params: Omit<ChatPostMessageRequest, \"channel\">\n  ) => Promise<ChatPostMessageResponse>;\n} & SlackAppContext;\n", "export type SlackAppContextWithRespond = {\n  channelId: string;\n  respond: (params: WebhookParams) => Promise<Response>;\n} & SlackAppContext;\n\nexport type SlackAppContextWithOptionalRespond = {\n  respond?: (params: WebhookParams) => Promise<Response>;\n} & SlackAppContext;\n\nexport function builtBaseContext(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): PreAuthorizeSlackAppContext {\n  return {\n    isEnterpriseinstall: extractIsEnterpriseInstall(body),\n    enterpriseId: extractEnterpriseId(body),\n    teamId: extractTeamId(body),\n    userId: extractUserId(body),\n    actorEnterpriseId: extractActorEnterpriseId(body),\n    actorTeamId: extractActorTeamId(body),\n    actorUserId: extractActorUserId(body),\n    botId: undefined, // will be set later\n    botUserId: undefined, // will be set later\n    responseUrl: extractResponseUrl(body),\n    channelId: extractChannelId(body),\n    custom: {},\n  };\n}\n", "export function builtBaseContext(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): PreAuthorizeSlackAppContext {\n  return {\n    isEnterpriseinstall: extractIsEnterpriseInstall(body),\n    enterpriseId: extractEnterpriseId(body),\n    teamId: extractTeamId(body),\n    userId: extractUserId(body),\n    actorEnterpriseId: extractActorEnterpriseId(body),\n    actorTeamId: extractActorTeamId(body),\n    actorUserId: extractActorUserId(body),\n    botId: undefined, // will be set later\n    botUserId: undefined, // will be set later\n    responseUrl: extractResponseUrl(body),\n    channelId: extractChannelId(body),\n    custom: {},\n  };\n}\n", "export function extractIsEnterpriseInstall(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): boolean | undefined {\n  if (body.authorizations && body.authorizations.length > 0) {\n    return body.authorizations[0].is_enterprise_install;\n  } else if (body.is_enterprise_install) {\n    if (typeof body.is_enterprise_install === \"string\") {\n      // slash command payloads\n      return body.is_enterprise_install === \"true\";\n    }\n    return body.is_enterprise_install == true;\n  }\n  return undefined;\n}\n", "export function extractEnterpriseId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {\n  if (body.enterprise) {\n    if (typeof body.enterprise === \"string\") {\n      return body.enterprise;\n    } else if (typeof body.enterprise === \"object\" && body.enterprise.id) {\n      return body.enterprise.id;\n    }\n  } else if (body.authorizations && body.authorizations.length > 0) {\n    return extractEnterpriseId(body.authorizations[0]);", "  } else if (body.authorizations && body.authorizations.length > 0) {\n    return extractEnterpriseId(body.authorizations[0]);\n  } else if (body.enterprise_id) {\n    return body.enterprise_id;\n  } else if (\n    body.team &&\n    typeof body.team === \"object\" &&\n    body.team.enterprise_id\n  ) {\n    return body.team.enterprise_id;\n  } else if (body.event) {\n    return extractEnterpriseId(body.event);\n  }\n  return undefined;\n}\n\n// deno-lint-ignore no-explicit-any", "  } else if (body.event) {\n    return extractEnterpriseId(body.event);\n  }\n  return undefined;\n}\n\n// deno-lint-ignore no-explicit-any\nexport function extractTeamId(body: Record<string, any>): string | undefined {\n  if (body.view && body.view.app_installed_team_id) {\n    // view_submission payloads can have `view.app_installed_team_id`\n    // when a modal view that was opened in a different workspace via some operations inside a Slack Connect channel.\n    // Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,\n    // you have to run some query toward your InstallationStore to know the org where the team_id belongs to.\n    return body.view.app_installed_team_id;", "  if (body.view && body.view.app_installed_team_id) {\n    // view_submission payloads can have `view.app_installed_team_id`\n    // when a modal view that was opened in a different workspace via some operations inside a Slack Connect channel.\n    // Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,\n    // you have to run some query toward your InstallationStore to know the org where the team_id belongs to.\n    return body.view.app_installed_team_id;\n  } else if (body.team) {\n    // With org-wide installations, payload.team in interactivity payloads can be None\n    // You need to extract either payload.user.team_id or payload.view.team_id as below\n    if (typeof body.team === \"string\") {\n      return body.team;", "    if (typeof body.team === \"string\") {\n      return body.team;\n    } else if (body.team.id) {\n      return body.team.id;\n    }\n  } else if (body.authorizations && body.authorizations.length > 0) {\n    // To make Events API handling functioning also for shared channels,\n    // we should use .authorizations[0].team_id over .team_id\n    return extractTeamId(body.authorizations[0]);\n  } else if (body.team_id) {\n    return body.team_id;", "  } else if (body.team_id) {\n    return body.team_id;\n  } else if (body.user && typeof body.user === \"object\") {\n    return body.user.team_id;\n  } else if (body.view && typeof body.view === \"object\") {\n    return body.view.team_id;\n  }\n  return undefined;\n}\n\n// deno-lint-ignore no-explicit-any", "export function extractUserId(body: Record<string, any>): string | undefined {\n  if (body.user) {\n    if (typeof body.user === \"string\") {\n      return body.user;\n    }\n    if (typeof body.user === \"object\" && body.user.id) {\n      return body.user.id;\n    }\n  } else if (body.user_id) {\n    return body.user_id;\n  } else if (body.event) {\n    return extractUserId(body.event);", "  } else if (body.user_id) {\n    return body.user_id;\n  } else if (body.event) {\n    return extractUserId(body.event);\n  } else if (body.message) {\n    return extractUserId(body.message);\n  } else if (body.previous_message) {\n    return extractUserId(body.previous_message);\n  }\n  return undefined;\n}\n", "export function extractActorEnterpriseId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {\n  if (body.is_ext_shared_channel) {\n    if (body.type === \"event_callback\") {\n      const eventTeamId = body.event?.user_team || body.event?.team;\n      if (eventTeamId && eventTeamId.startsWith(\"E\")) {\n        return eventTeamId;\n      } else if (eventTeamId === body.team_id) {\n        return body.enterprise_id;\n      }\n    }\n  }\n  return extractEnterpriseId(body);\n}\n", "      } else if (eventTeamId === body.team_id) {\n        return body.enterprise_id;\n      }\n    }\n  }\n  return extractEnterpriseId(body);\n}\n\nexport function extractActorTeamId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {", "export function extractActorTeamId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {\n  if (body.is_ext_shared_channel) {\n    if (body.type === \"event_callback\") {\n      const eventType = body.event.type;\n      if (eventType === \"app_mention\") {\n        // The $.event.user_team can be an enterprise_id in app_mention events.\n        // In the scenario, there is no way to retrieve actor_team_id as of March 2023\n        const userTeam = body.event.user_team;", "        if (!userTeam) {\n          // working with an app installed in this user's org/workspace side\n          return body.event.team;\n        } else if (userTeam.startsWith(\"T\")) {\n          // interacting from a connected non-grid workspace\n          return userTeam;\n        }\n        // Interacting from a connected grid workspace; in this case, team_id cannot be resolved as of March 2023\n        return undefined;\n      }\n      const eventUserTeam = body.event.user_team;", "      if (eventUserTeam) {\n        if (eventUserTeam.startsWith(\"T\")) {\n          return eventUserTeam;\n        } else if (eventUserTeam.startsWith(\"E\")) {\n          if (eventUserTeam === body.enterprise_id) {\n            return body.team_id;\n          } else if (eventUserTeam === body.context_enterprise_id) {\n            return body.context_team_id;\n          }\n        }\n      }\n      const eventTeam = body.event.team;", "      if (eventTeam) {\n        if (eventTeam.startsWith(\"T\")) {\n          return eventTeam;\n        } else if (eventTeam.startsWith(\"E\")) {\n          if (eventTeam === body.enterprise_id) {\n            return body.team_id;\n          } else if (eventTeam === body.context_enterprise_id) {\n            return body.context_team_id;\n          }\n        }\n      }\n    }\n  }\n  return extractTeamId(body);\n}\n", "export function extractActorUserId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {\n  if (body.is_ext_shared_channel) {\n    if (body.type === \"event_callback\") {\n      if (body.event) {\n        if (extractActorEnterpriseId(body) && extractActorTeamId(body)) {\n          // When both enterprise_id and team_id are not identified, we skip returning user_id too for safety\n          return undefined;\n        }\n        return body.event.user || body.event.user_id;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  return extractUserId(body);\n}\n", "export function extractResponseUrl(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {\n  if (body.response_url) {\n    return body.response_url;\n  } else if (body.response_urls && body.response_urls.length > 0) {\n    return body.response_urls[0].response_url;\n  }\n  return undefined;\n}\n", "export function extractChannelId(\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>\n): string | undefined {\n  if (body.channel) {\n    if (typeof body.channel === \"string\") {\n      return body.channel;\n    } else if (typeof body.channel === \"object\" && body.channel.id) {\n      return body.channel.id;\n    }\n  } else if (body.channel_id) {\n    return body.channel_id;", "  } else if (body.channel_id) {\n    return body.channel_id;\n  } else if (body.event) {\n    return extractChannelId(body.event);\n  } else if (body.item) {\n    // reaction_added: body[\"event\"][\"item\"]\n    return extractChannelId(body.item);\n  }\n  return undefined;\n}\n"]}
{"filename": "src/authorization/single-team-authorize.ts", "chunked_list": ["import { AuthorizeError } from \"../errors\";\nimport {\n  SlackAPIClient,\n  AuthTestResponse,\n  SlackAPIError,\n} from \"slack-web-api-client\";\nimport { Authorize } from \"./authorize\";\n\nexport const singleTeamAuthorize: Authorize = async (req) => {\n  // This authorize function supports only the bot token for a workspace\n  const botToken = req.env.SLACK_BOT_TOKEN!;\n  const client = new SlackAPIClient(botToken);", "export const singleTeamAuthorize: Authorize = async (req) => {\n  // This authorize function supports only the bot token for a workspace\n  const botToken = req.env.SLACK_BOT_TOKEN!;\n  const client = new SlackAPIClient(botToken);\n  try {\n    const response: AuthTestResponse = await client.auth.test();\n    const scopes = response.headers.get(\"x-oauth-scopes\") ?? \"\";\n    return {\n      botToken,\n      enterpriseId: response.enterprise_id,\n      teamId: response.team_id,\n      team: response.team,\n      url: response.url,\n      botId: response.bot_id!,\n      botUserId: response.user_id!,\n      userId: response.user_id,\n      user: response.user,\n      botScopes: scopes.split(\",\"),\n      userToken: undefined, // As mentioned above, user tokens are not supported in this module\n      userScopes: undefined, // As mentioned above, user tokens are not supported in this module\n    };", "  } catch (e) {\n    throw new AuthorizeError(\n      `Failed to call auth.test API due to ${(e as SlackAPIError).message}`\n    );\n  }\n};\n"]}
{"filename": "src/authorization/authorize.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\nimport { PreAuthorizeSlackMiddlwareRequest } from \"../request/request\";\nimport { AuthorizeResult } from \"./authorize-result\";\n\nexport type Authorize<E extends SlackAppEnv = SlackAppEnv> = (\n  req: PreAuthorizeSlackMiddlwareRequest<E>\n) => Promise<AuthorizeResult>;\n"]}
{"filename": "src/authorization/authorize-result.ts", "chunked_list": ["export interface AuthorizeResult {\n  enterpriseId?: string;\n  teamId?: string;\n  team?: string;\n  url?: string;\n  botId: string;\n  botUserId: string;\n  botToken: string;\n  botScopes: string[];\n  userId?: string;\n  user?: string;\n  userToken?: string;\n  userScopes?: string[];\n}\n"]}
{"filename": "src/socket-mode/socket-mode-client.ts", "chunked_list": ["import { SlackAPIClient, isDebugLogEnabled } from \"slack-web-api-client\";\nimport { SlackApp } from \"../app\";\nimport { ConfigError, SocketModeError } from \"../errors\";\nimport { ExecutionContext } from \"../execution-context\";\nimport { SlackSocketModeAppEnv } from \"../app-env\";\n\n// TODO: Implement proper reconnection logic\n// TODO: Add connection monitor like 1st party SDKs do\n// TODO: Add Bun support (the runtime does not work well with Socket Mode)\nexport class SocketModeClient {\n  public app: SlackApp<SlackSocketModeAppEnv>;\n  public appLevelToken: string;\n  public ws: WebSocket | undefined;\n\n  constructor(\n    // deno-lint-ignore no-explicit-any\n    app: SlackApp<any>\n  ) {", "// TODO: Add Bun support (the runtime does not work well with Socket Mode)\nexport class SocketModeClient {\n  public app: SlackApp<SlackSocketModeAppEnv>;\n  public appLevelToken: string;\n  public ws: WebSocket | undefined;\n\n  constructor(\n    // deno-lint-ignore no-explicit-any\n    app: SlackApp<any>\n  ) {\n    if (!app.socketMode) {\n      throw new ConfigError(\n        \"socketMode: true must be set for running with Socket Mode\"\n      );\n    }", "    if (!app.socketMode) {\n      throw new ConfigError(\n        \"socketMode: true must be set for running with Socket Mode\"\n      );\n    }\n    if (!app.appLevelToken) {\n      throw new ConfigError(\n        \"appLevelToken must be set for running with Socket Mode\"\n      );\n    }\n    this.app = app as SlackApp<SlackSocketModeAppEnv>;\n    this.appLevelToken = app.appLevelToken;\n\n    console.warn(\n      \"WARNING: The Socket Mode support provided by slack-edge is still experimental and is not designed to handle reconnections for production-grade applications. It is recommended to use this mode only for local development and testing purposes.\"\n    );\n  }\n\n  async connect() {\n    const client = new SlackAPIClient(this.appLevelToken);", "    try {\n      const newConnection = await client.apps.connections.open();\n      this.ws = new WebSocket(newConnection.url!);\n    } catch (e) {\n      throw new SocketModeError(\n        `Failed to establish a new WSS connection: ${e}`\n      );\n    }\n    if (this.ws) {\n      const ws = this.ws;\n      // deno-lint-ignore require-await\n      ws.onopen = async (ev) => {\n        // TODO: make this customizable", "    if (this.ws) {\n      const ws = this.ws;\n      // deno-lint-ignore require-await\n      ws.onopen = async (ev) => {\n        // TODO: make this customizable\n        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n          console.log(\n            `Now the Socket Mode client is connected to Slack: ${JSON.stringify(\n              ev\n            )}`\n          );\n        }\n      };\n      // deno-lint-ignore require-await\n      ws.onclose = async (ev) => {\n        // TODO: make this customizable", "        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n          console.log(\n            `The Socket Mode client is disconnected from Slack: ${JSON.stringify(\n              ev\n            )}`\n          );\n        }\n      };\n      // deno-lint-ignore require-await\n      ws.onerror = async (e) => {\n        // TODO: make this customizable\n        console.error(\n          `An error was thrown by the Socket Mode connection: ${e}`\n        );\n      };\n\n      const app = this.app;\n      ws.onmessage = async (ev) => {", "        try {\n          if (\n            ev.data &&\n            typeof ev.data === \"string\" &&\n            ev.data.startsWith(\"{\")\n          ) {\n            const data = JSON.parse(ev.data);\n            if (data.type === \"hello\") {\n              if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n                console.log(`*** Received hello data ***\\n ${ev.data}`);\n              }\n              return;\n            }\n            const payload = JSON.stringify(data.payload);\n            console.log(payload);\n            const request: Request = new Request(ws.url, {\n              method: \"POST\",\n              headers: new Headers({ \"content-type\": \"application/json\" }),\n              body: new Blob([payload]).stream(),\n            });\n            const context: ExecutionContext = {\n              // deno-lint-ignore require-await\n              waitUntil: async (promise) => {\n                promise\n                  .then((res) => {\n                    console.info(`Completed a lazy listener execution: ${res}`);\n                  })", "              if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n                console.log(`*** Received hello data ***\\n ${ev.data}`);\n              }\n              return;\n            }\n            const payload = JSON.stringify(data.payload);\n            console.log(payload);\n            const request: Request = new Request(ws.url, {\n              method: \"POST\",\n              headers: new Headers({ \"content-type\": \"application/json\" }),\n              body: new Blob([payload]).stream(),\n            });\n            const context: ExecutionContext = {\n              // deno-lint-ignore require-await\n              waitUntil: async (promise) => {\n                promise\n                  .then((res) => {\n                    console.info(`Completed a lazy listener execution: ${res}`);\n                  })", "                  .catch((err) => {\n                    console.error(`Failed to run a lazy listener: ${err}`);\n                  });\n              },\n            };\n            const response = await app.run(request, context);\n            // deno-lint-ignore no-explicit-any\n            let ack: any = { envelope_id: data.envelope_id };\n            if (response.body) {\n              const contentType = response.headers.get(\"Content-Type\");\n              if (contentType && contentType.startsWith(\"text/plain\")) {\n                const text = await response.text();\n                ack = { envelope_id: data.envelope_id, payload: { text } };\n              } else {\n                const json = await response.json();\n                ack = { envelope_id: data.envelope_id, payload: { ...json } };\n              }\n            }\n            ws.send(JSON.stringify(ack));\n          } else {", "            if (response.body) {\n              const contentType = response.headers.get(\"Content-Type\");\n              if (contentType && contentType.startsWith(\"text/plain\")) {\n                const text = await response.text();\n                ack = { envelope_id: data.envelope_id, payload: { text } };\n              } else {\n                const json = await response.json();\n                ack = { envelope_id: data.envelope_id, payload: { ...json } };\n              }\n            }\n            ws.send(JSON.stringify(ack));\n          } else {", "            if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n              console.log(`*** Received non-JSON data ***\\n ${ev.data}`);\n            }\n          }\n        } catch (e) {\n          console.error(`Failed to handle a WebSocke message: ${e}`);\n        }\n      };\n    }\n  }\n\n  // deno-lint-ignore require-await\n  async disconnect(): Promise<void> {", "    if (this.ws) {\n      this.ws.close();\n      this.ws = undefined;\n    }\n  }\n}\n"]}
{"filename": "src/handler/view-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\nimport { SlackRequest } from \"../request/request\";\nimport { SlackViewResponse } from \"../response/response\";\n\nexport type ViewAckResponse = SlackViewResponse | void;\n\nexport type SlackViewHandler<E extends SlackAppEnv, Payload> = {\n  ack(request: SlackRequest<E, Payload>): Promise<ViewAckResponse>;\n  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n};\n"]}
{"filename": "src/handler/message-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\nimport { SlackRequest } from \"../request/request\";\nimport { MessageResponse } from \"../response/response-body\";\nimport { AckResponse } from \"./handler\";\n\nexport type MessageAckResponse = AckResponse | MessageResponse;\n\nexport interface SlackMessageHandler<E extends SlackAppEnv, Payload> {\n  ack(request: SlackRequest<E, Payload>): Promise<MessageAckResponse>;\n  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n}\n"]}
{"filename": "src/handler/handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\nimport { SlackRequest } from \"../request/request\";\nimport { SlackResponse } from \"../response/response\";\n\nexport type AckResponse = SlackResponse | string | void;\n\nexport interface SlackHandler<E extends SlackAppEnv, Payload> {\n  ack(request: SlackRequest<E, Payload>): Promise<AckResponse>;\n  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n}\n"]}
{"filename": "src/handler/options-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\nimport { SlackRequest } from \"../request/request\";\nimport { SlackOptionsResponse } from \"../response/response\";\n\nexport type OptionsAckResponse = SlackOptionsResponse;\n\nexport interface SlackOptionsHandler<E extends SlackAppEnv, Payload> {\n  ack(request: SlackRequest<E, Payload>): Promise<OptionsAckResponse>;\n  // Note that a block_suggestion response must be done synchronously.\n  // That's why we don't support lazy functions for the pattern.\n}\n"]}
{"filename": "src/response/response-body.ts", "chunked_list": ["import {\n  AnyMessageBlock,\n  MessageAttachment,\n  MessageMetadata,\n  AnyTextField,\n  ModalView,\n} from \"slack-web-api-client\";\n\nexport interface MessageResponse {\n  response_type?: \"ephemeral\" | \"in_channel\";\n  text: string;\n  blocks?: AnyMessageBlock[];\n  attachments?: MessageAttachment[];\n  metadata?: MessageMetadata;\n  thread_ts?: string;\n}\n", "export interface MessageResponse {\n  response_type?: \"ephemeral\" | \"in_channel\";\n  text: string;\n  blocks?: AnyMessageBlock[];\n  attachments?: MessageAttachment[];\n  metadata?: MessageMetadata;\n  thread_ts?: string;\n}\n\nexport interface ViewUpdateResponse {\n  response_action: \"update\";\n  view: ModalView;\n}\n", "export interface ViewUpdateResponse {\n  response_action: \"update\";\n  view: ModalView;\n}\n\nexport interface ViewPushResponse {\n  response_action: \"push\";\n  view: ModalView;\n}\n\nexport interface ViewClearResponse {\n  response_action: \"clear\";\n}\n", "export interface ViewClearResponse {\n  response_action: \"clear\";\n}\n\nexport interface ViewErrorsResponse {\n  response_action: \"errors\";\n  errors: { [blockId: string]: string };\n}\n\nexport type AnyViewResponse =\n  | ViewUpdateResponse\n  | ViewPushResponse\n  | ViewClearResponse\n  | ViewErrorsResponse;\n", "export type AnyViewResponse =\n  | ViewUpdateResponse\n  | ViewPushResponse\n  | ViewClearResponse\n  | ViewErrorsResponse;\n\nexport interface Option {\n  value: string;\n  text: AnyTextField;\n}\n", "export interface OptionGroup {\n  label: AnyTextField;\n  options: Option[];\n}\n\nexport interface OptionsResponse {\n  options: Option[];\n}\nexport interface OptionGroupsResponse {\n  option_groups: OptionGroup[];\n}\n", "export interface OptionGroupsResponse {\n  option_groups: OptionGroup[];\n}\n\nexport type AnyOptionsResponse = OptionsResponse | OptionGroupsResponse;\n"]}
{"filename": "src/response/response.ts", "chunked_list": ["import {\n  MessageResponse,\n  AnyOptionsResponse,\n  AnyViewResponse,\n} from \"./response-body\";\n\nexport interface SlackResponse {\n  status?: number;\n  contentType?: string;\n  // deno-lint-ignore no-explicit-any\n  body?: string | MessageResponse | Record<string, any>;\n}\n", "export type SlackViewResponse =\n  | (SlackResponse & {\n      body: \"\" | AnyViewResponse;\n    })\n  | \"\"\n  | AnyViewResponse\n  | undefined\n  | void;\n\nexport type SlackOptionsResponse =\n  | (SlackResponse & {\n      body: AnyOptionsResponse;\n    })\n  | AnyOptionsResponse;\n", "export type SlackOptionsResponse =\n  | (SlackResponse & {\n      body: AnyOptionsResponse;\n    })\n  | AnyOptionsResponse;\n\nexport function toCompleteResponse(\n  slackResponse:\n    | SlackResponse\n    | MessageResponse\n    | SlackViewResponse\n    | SlackOptionsResponse\n    | string\n    | void\n): Response {", "  if (!slackResponse) {\n    return new Response(\"\", {\n      status: 200,\n      headers: { \"Content-Type\": \"text/plain\" },\n    });\n  }\n  if (typeof slackResponse === \"string\") {\n    return new Response(slackResponse, {\n      status: 200,\n      headers: { \"Content-Type\": \"text/plain;charset=utf-8\" },\n    });\n  }\n  let completeResponse: SlackResponse = {};", "  if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"text\") ||\n    Object.prototype.hasOwnProperty.call(slackResponse, \"blocks\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse as MessageResponse };\n  } else if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"response_action\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse };\n  } else if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"options\") ||\n    Object.prototype.hasOwnProperty.call(slackResponse, \"option_groups\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse };\n  } else {\n    completeResponse = slackResponse as SlackResponse;\n  }\n  const status = completeResponse.status ? completeResponse.status : 200;\n  let contentType = completeResponse.contentType\n    ? completeResponse.contentType\n    : \"text/plain;charset=utf-8\";\n  let bodyString = \"\";", "  } else if (\n    Object.prototype.hasOwnProperty.call(slackResponse, \"options\") ||\n    Object.prototype.hasOwnProperty.call(slackResponse, \"option_groups\")\n  ) {\n    completeResponse = { status: 200, body: slackResponse };\n  } else {\n    completeResponse = slackResponse as SlackResponse;\n  }\n  const status = completeResponse.status ? completeResponse.status : 200;\n  let contentType = completeResponse.contentType\n    ? completeResponse.contentType\n    : \"text/plain;charset=utf-8\";\n  let bodyString = \"\";", "  if (typeof completeResponse.body === \"object\") {\n    contentType = \"application/json;charset=utf-8\";\n    bodyString = JSON.stringify(completeResponse.body);\n  } else {\n    bodyString = completeResponse.body || \"\";\n  }\n  return new Response(bodyString, {\n    status,\n    headers: { \"Content-Type\": contentType },\n  });\n}\n"]}
{"filename": "src/utility/message-events.ts", "chunked_list": ["import {\n  BotMessageEvent,\n  FileShareMessageEvent,\n  GenericMessageEvent,\n  ThreadBroadcastMessageEvent,\n} from \"../request/payload/event\";\n\nexport const isPostedMessageEvent = (event: {\n  type: string;\n  subtype?: string;", "  type: string;\n  subtype?: string;\n}): event is\n  | GenericMessageEvent\n  | BotMessageEvent\n  | FileShareMessageEvent\n  | ThreadBroadcastMessageEvent => {\n  return (\n    event.subtype === undefined ||\n    event.subtype === \"bot_message\" ||", "    event.subtype === undefined ||\n    event.subtype === \"bot_message\" ||\n    event.subtype === \"file_share\" ||\n    event.subtype === \"thread_broadcast\"\n  );\n};\n"]}
{"filename": "src/request/payload-types.ts", "chunked_list": ["export enum PayloadType {\n  BlockAction = \"block_actions\",\n  BlockSuggestion = \"block_suggestion\",\n  MessageShortcut = \"message_action\",\n  GlobalShortcut = \"shortcut\",\n  EventsAPI = \"event_callback\",\n  ViewSubmission = \"view_submission\",\n  ViewClosed = \"view_closed\",\n  // Note that Slash command payloads do not have \"type\" property\n}\n"]}
{"filename": "src/request/request-parser.ts", "chunked_list": ["// deno-lint-ignore require-await\nexport async function parseRequestBody(\n  requestHeaders: Headers,\n  requestBody: string\n): // deno-lint-ignore no-explicit-any\nPromise<Record<string, any>> {\n  const contentType = requestHeaders.get(\"content-type\");\n  if (\n    contentType?.startsWith(\"application/json\") ||\n    requestBody.startsWith(\"{\")\n  ) {\n    return JSON.parse(requestBody);\n  }\n  const params = new URLSearchParams(requestBody);", "  if (params.has(\"payload\")) {\n    const payload = params.get(\"payload\")!;\n    return JSON.parse(payload);\n  }\n  // deno-lint-ignore no-explicit-any\n  const formBody: any = {};\n  for (const k of params.keys()) {\n    formBody[k] = params.get(k);\n  }\n  return formBody;\n}\n"]}
{"filename": "src/request/request-verification.ts", "chunked_list": ["export async function verifySlackRequest(\n  signingSecret: string,\n  requsetHeaders: Headers,\n  requestBody: string\n) {\n  const timestampHeader = requsetHeaders.get(\"x-slack-request-timestamp\");\n  if (!timestampHeader) {\n    console.log(\"x-slack-request-timestamp header is missing!\");\n    return false;\n  }\n  const fiveMinutesAgoSeconds = Math.floor(Date.now() / 1000) - 60 * 5;", "  if (Number.parseInt(timestampHeader) < fiveMinutesAgoSeconds) {\n    return false;\n  }\n\n  const signatureHeader = requsetHeaders.get(\"x-slack-signature\");\n  if (!timestampHeader || !signatureHeader) {\n    console.log(\"x-slack-signature header is missing!\");\n    return false;\n  }\n\n  const textEncoder = new TextEncoder();\n  return await crypto.subtle.verify(\n    \"HMAC\",\n    await crypto.subtle.importKey(\n      \"raw\",\n      textEncoder.encode(signingSecret),\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"verify\"]\n    ),\n    fromHexStringToBytes(signatureHeader.substring(3)),\n    textEncoder.encode(`v0:${timestampHeader}:${requestBody}`)\n  );\n}\n", "function fromHexStringToBytes(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n  for (let idx = 0; idx < hexString.length; idx += 2) {\n    bytes[idx / 2] = parseInt(hexString.substring(idx, idx + 2), 16);\n  }\n  return bytes.buffer;\n}\n"]}
{"filename": "src/request/request.ts", "chunked_list": ["import {\n  SlackAppContext,\n  PreAuthorizeSlackAppContext,\n  SlackAppContextWithRespond,\n  SlackAppContextWithOptionalRespond,\n  SlackAppContextWithChannelId,\n} from \"../context/context\";\nimport { SlackAppEnv } from \"../app-env\";\n\nexport interface SlackMiddlewareRequestBase<E extends SlackAppEnv> {\n  env: E;\n  context: PreAuthorizeSlackAppContext;\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>;\n  retryNum?: number;\n  retryReason?: string;\n  rawBody: string;\n  headers: Headers;\n}\n", "\nexport interface SlackMiddlewareRequestBase<E extends SlackAppEnv> {\n  env: E;\n  context: PreAuthorizeSlackAppContext;\n  // deno-lint-ignore no-explicit-any\n  body: Record<string, any>;\n  retryNum?: number;\n  retryReason?: string;\n  rawBody: string;\n  headers: Headers;\n}\n", "export type PreAuthorizeSlackMiddlwareRequest<E extends SlackAppEnv> =\n  SlackMiddlewareRequestBase<E> & {\n    context: PreAuthorizeSlackAppContext;\n  };\n\nexport type SlackMiddlwareRequest<E extends SlackAppEnv> =\n  SlackMiddlewareRequestBase<E> & {\n    context: SlackAppContext;\n  };\n\nexport type SlackRequest<\n  E extends SlackAppEnv,\n  Payload\n> = SlackMiddlwareRequest<E> & {\n  payload: Payload;\n};\n", "export type SlackRequest<\n  E extends SlackAppEnv,\n  Payload\n> = SlackMiddlwareRequest<E> & {\n  payload: Payload;\n};\n\nexport type SlackRequestWithChannelId<\n  E extends SlackAppEnv,\n  Payload\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithChannelId;\n  payload: Payload;\n};\n", "export type SlackRequestWithRespond<\n  E extends SlackAppEnv,\n  Payload\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithRespond;\n  payload: Payload;\n};\n\nexport type SlackRequestWithOptionalRespond<\n  E extends SlackAppEnv,\n  Payload\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithOptionalRespond;\n  payload: Payload;\n};\n", "export type SlackRequestWithOptionalRespond<\n  E extends SlackAppEnv,\n  Payload\n> = SlackMiddlwareRequest<E> & {\n  context: SlackAppContextWithOptionalRespond;\n  payload: Payload;\n};\n"]}
{"filename": "src/request/request-body.ts", "chunked_list": ["export interface SlackRequestBody {\n  type?: string;\n\n  // slash commands\n  command?: string;\n\n  // event_callback\n  event?: {\n    type: string;\n    subtype?: string;\n    text?: string;\n  };\n\n  // shortcut, message_action\n  callback_id?: string;\n\n  // block_actions\n  actions: {\n    type: string;\n    block_id: string;\n    action_id: string;\n  }[];\n\n  // block_suggestion\n  block_id?: string;\n  action_id?: string;\n\n  // view_submission / view_closed\n  view?: {\n    callback_id: string;\n  };\n}\n"]}
{"filename": "src/request/payload/global-shortcut.ts", "chunked_list": ["export interface GlobalShortcut {\n  type: \"shortcut\";\n  callback_id: string;\n  trigger_id: string;\n  user: {\n    id: string;\n    username: string;\n    team_id: string;\n  };\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  token: string;\n  action_ts: string;\n  is_enterprise_install?: boolean;\n  enterprise?: { id: string; name: string };\n}\n"]}
{"filename": "src/request/payload/block-suggestion.ts", "chunked_list": ["import { AnyOption } from \"slack-web-api-client\";\nimport { DataSubmissionView } from \"./view-objects\";\n\nexport interface BlockSuggestion {\n  type: \"block_suggestion\";\n  block_id: string;\n  action_id: string;\n  value: string;\n  api_app_id: string;\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  channel?: {\n    id: string;\n    name: string;\n  };\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  token: string;\n  // deno-lint-ignore no-explicit-any\n  container: any;\n  view?: DataSubmissionView;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n}\n", "export interface BlockOptions {\n  options: AnyOption[];\n}\n\nexport interface OptionGroups<Options> {\n  option_groups: ({ label: string } & Options)[];\n}\n"]}
{"filename": "src/request/payload/slash-command.ts", "chunked_list": ["export interface SlashCommand {\n  token: string;\n  command: string;\n  text: string;\n  response_url: string;\n  trigger_id: string;\n  user_id: string;\n  user_name: string;\n  team_id: string;\n  team_domain: string;\n  channel_id: string;\n  channel_name: string;\n  api_app_id: string;\n  enterprise_id?: string;\n  enterprise_name?: string;\n  is_enterprise_install?: string;\n}\n"]}
{"filename": "src/request/payload/view-submission.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects\";\n\nexport interface ViewSubmission {\n  type: \"view_submission\";\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  view: DataSubmissionView;\n  api_app_id: string;\n  token: string;\n  trigger_id: string;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n  response_urls?: {\n    block_id: string;\n    action_id: string;\n    channel_id: string;\n    response_url: string;\n  }[];\n}\n"]}
{"filename": "src/request/payload/view-closed.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects\";\n\nexport interface ViewClosed {\n  type: \"view_closed\";\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  view: DataSubmissionView;\n  api_app_id: string;\n  token: string;\n  is_cleared: boolean;\n  is_enterprise_install?: boolean;\n  enterprise?: { id: string; name: string };\n}\n"]}
{"filename": "src/request/payload/view-objects.ts", "chunked_list": ["import {\n  AnyActionBlockElementType,\n  AnyModalBlock,\n  PlainTextField,\n} from \"slack-web-api-client\";\n\nexport interface ViewStateSelectedOption {\n  text: PlainTextField;\n  value: string;\n}\n", "export interface ViewStateValue {\n  type: AnyActionBlockElementType;\n  value?: string | null;\n  selected_date?: string | null;\n  selected_time?: string | null;\n  selected_date_time?: number | null;\n  selected_conversation?: string | null;\n  selected_channel?: string | null;\n  selected_user?: string | null;\n  selected_option?: ViewStateSelectedOption | null;\n  selected_conversations?: string[];\n  selected_channels?: string[];\n  selected_users?: string[];\n  selected_options?: ViewStateSelectedOption[];\n}\n", "export interface DataSubmissionView {\n  id: string;\n  callback_id: string;\n  team_id: string;\n  app_installed_team_id?: string;\n  app_id: string | null;\n  bot_id: string;\n  title: PlainTextField;\n  type: string;\n  blocks: AnyModalBlock[];\n  close: PlainTextField | null;\n  submit: PlainTextField | null;\n  state: {\n    values: {\n      [blockId: string]: {\n        [actionId: string]: ViewStateValue;\n      };\n    };\n  };\n  hash: string;\n  private_metadata: string;\n  root_view_id: string | null;\n  previous_view_id: string | null;\n  clear_on_close: boolean;\n  notify_on_close: boolean;\n  external_id?: string;\n}\n"]}
{"filename": "src/request/payload/event.ts", "chunked_list": ["import {\n  AnyMessageBlock,\n  MessageAttachment,\n  MessageMetadata,\n  HomeTabView,\n} from \"slack-web-api-client\";\n\nexport type AnySlackEvent =\n  | AppRequestedEvent\n  | AppHomeOpenedEvent\n  | AppMentionEvent\n  | AppRateLimitedEvent\n  | AppUninstalledEvent\n  | ChannelArchiveEvent\n  | ChannelCreatedEvent\n  | ChannelDeletedEvent\n  | ChannelHistoryChangedEvent\n  | ChannelIDChangedEvent\n  | ChannelLeftEvent\n  | ChannelRenameEvent\n  | ChannelSharedEvent\n  | ChannelUnarchiveEvent\n  | ChannelUnsharedEvent\n  | DNDUpdatedEvent\n  | DNDUpdatedUserEvent\n  | EmailDomainChangedEvent\n  | EmojiChangedEvent\n  | FileChangeEvent\n  | FileCreatedEvent\n  | FileDeletedEvent\n  | FilePublicEvent\n  | FileSharedEvent\n  | FileUnsharedEvent\n  | GridMigrationFinishedEvent\n  | GridMigrationStartedEvent\n  | GroupArchiveEvent\n  | GroupCloseEvent\n  | GroupDeletedEvent\n  | GroupHistoryChangedEvent\n  | GroupLeftEvent\n  | GroupOpenEvent\n  | GroupRenameEvent\n  | GroupUnarchiveEvent\n  | IMCloseEvent\n  | IMCreatedEvent\n  | IMHistoryChangedEvent\n  | IMOpenEvent\n  | InviteRequestedEvent\n  | LinkSharedEvent\n  | MemberJoinedChannelEvent\n  | MemberLeftChannelEvent\n  | AnyMessageEvent\n  | AnyMessageMetadataEvent\n  | PinAddedEvent\n  | PinRemovedEvent\n  | ReactionAddedEvent\n  | ReactionRemovedEvent\n  | SharedChannelInviteReceivedEvent\n  | SharedChannelInviteAcceptedEvent\n  | SharedChannelInviteApprovedEvent\n  | SharedChannelInviteDeclinedEvent\n  | StarAddedEvent\n  | StarRemovedEvent\n  | SubteamCreatedEvent\n  | SubteamMembersChangedEvent\n  | SubteamSelfAddedEvent\n  | SubteamSelfRemovedEvent\n  | SubteamUpdatedEvent\n  | TeamAccessGrantedEvent\n  | TeamAccessRevokedEvent\n  | TeamDomainChangedEvent\n  | TeamJoinEvent\n  | TeamRenameEvent\n  | TokensRevokedEvent\n  | UserChangeEvent\n  | UserHuddleChangedEvent\n  | UserProfileChangedEvent\n  | UserStatusChangedEvent\n  | WorkflowDeletedEvent\n  | WorkflowPublishedEvent\n  | WorkflowUnpublishedEvent\n  | WorkflowStepDeletedEvent\n  | WorkflowStepExecuteEvent;\n\n// These union types may not be a complete set of events", "export type AnySlackEventWithChannelId =\n  | AppHomeOpenedEvent\n  | AppMentionEvent\n  | AppUninstalledEvent\n  | ChannelArchiveEvent\n  | ChannelCreatedEvent\n  | ChannelDeletedEvent\n  | ChannelIDChangedEvent\n  | ChannelLeftEvent\n  | ChannelRenameEvent\n  | ChannelSharedEvent\n  | ChannelUnarchiveEvent\n  | ChannelUnsharedEvent\n  | FileSharedEvent\n  | FileUnsharedEvent\n  | GroupArchiveEvent\n  | GroupCloseEvent\n  | GroupDeletedEvent\n  | GroupLeftEvent\n  | GroupOpenEvent\n  | GroupRenameEvent\n  | GroupUnarchiveEvent\n  | IMCloseEvent\n  | IMCreatedEvent\n  | IMOpenEvent\n  | InviteRequestedEvent\n  | LinkSharedEvent\n  | MemberJoinedChannelEvent\n  | MemberLeftChannelEvent\n  | AnyMessageEvent\n  | AnyMessageMetadataEvent\n  | PinAddedEvent\n  | PinRemovedEvent\n  | ReactionAddedEvent\n  | ReactionRemovedEvent\n  | SharedChannelInviteReceivedEvent\n  | SharedChannelInviteAcceptedEvent\n  | SharedChannelInviteApprovedEvent\n  | SharedChannelInviteDeclinedEvent\n  | StarAddedEvent\n  | StarRemovedEvent;\n", "export interface SlackEvent<Type extends string> {\n  type: Type;\n  subtype?: string;\n}\n\nexport interface AppRequestedEvent extends SlackEvent<\"app_requested\"> {\n  type: \"app_requested\";\n  app_request: {\n    id: string;\n    app: {\n      id: string;\n      name: string;\n      description: string;\n      help_url: string;\n      privacy_policy_url: string;\n      app_homepage_url: string;\n      app_directory_url: string;\n      is_app_directory_approved: boolean;\n      is_internal: boolean;\n      additional_info: string;\n      icons?: {\n        image_32?: string;\n        image_36?: string;\n        image_48?: string;\n        image_64?: string;\n        image_72?: string;\n        image_96?: string;\n        image_128?: string;\n        image_192?: string;\n        image_512?: string;\n        image_1024?: string;\n        image_original?: string;\n      };\n    };\n  };\n  previous_resolution: {\n    status: \"approved\" | \"restricted\";\n    scopes: {\n      name: string;\n      description: string;\n      is_dangerous: boolean;\n      token_type: \"bot\" | \"user\" | \"app\" | null;\n    };\n  } | null;\n  is_user_app_collaborator: boolean;\n  user: {\n    id: string;\n    name: string;\n    email: string;\n  };\n  team: {\n    id: string;\n    name: string;\n    domain: string;\n  };\n  scopes: {\n    name: string;\n    description: string;\n    is_dangerous: boolean;\n    token_type: \"bot\" | \"user\" | \"app\" | null;\n  };\n  message: string;\n  date_created: number;\n}\n", "export interface AppHomeOpenedEvent extends SlackEvent<\"app_home_opened\"> {\n  type: \"app_home_opened\";\n  user: string;\n  channel: string;\n  tab: \"home\" | \"messages\";\n  view?: HomeTabView;\n  event_ts: string;\n}\n\nexport interface AppMentionEvent extends SlackEvent<\"app_mention\"> {\n  type: \"app_mention\";\n  subtype?: string;\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  username: string;\n  team?: string;\n  user?: string;\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  ts: string;\n  channel: string;\n  event_ts: string;\n  thread_ts?: string;\n}\n", "export interface AppMentionEvent extends SlackEvent<\"app_mention\"> {\n  type: \"app_mention\";\n  subtype?: string;\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  username: string;\n  team?: string;\n  user?: string;\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  ts: string;\n  channel: string;\n  event_ts: string;\n  thread_ts?: string;\n}\n", "export interface AppRateLimitedEvent extends SlackEvent<\"app_rate_limited\"> {\n  type: \"app_rate_limited\";\n  token: string;\n  team_id: string;\n  minute_rate_limited: number;\n  api_app_id: string;\n}\n\nexport interface AppUninstalledEvent extends SlackEvent<\"app_uninstalled\"> {\n  type: \"app_uninstalled\";\n}\n", "export interface AppUninstalledEvent extends SlackEvent<\"app_uninstalled\"> {\n  type: \"app_uninstalled\";\n}\n\nexport interface ChannelArchiveEvent extends SlackEvent<\"channel_archive\"> {\n  type: \"channel_archive\";\n  channel: string;\n  user: string;\n  is_moved?: number;\n  event_ts: string;\n}\n", "export interface ChannelCreatedEvent extends SlackEvent<\"channel_created\"> {\n  type: \"channel_created\";\n  channel: {\n    id: string;\n    is_channel: boolean;\n    name: string;\n    name_normalized: string;\n    created: number;\n    creator: string;\n    is_shared: boolean;\n    is_org_shared: boolean;\n  };\n}\n", "export interface ChannelDeletedEvent extends SlackEvent<\"channel_deleted\"> {\n  type: \"channel_deleted\";\n  channel: string;\n}\n\nexport interface ChannelHistoryChangedEvent\n  extends SlackEvent<\"channel_history_changed\"> {\n  type: \"channel_history_changed\";\n  latest: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelIDChangedEvent\n  extends SlackEvent<\"channel_id_changed\"> {\n  type: \"channel_id_changed\";\n  old_channel_id: string;\n  new_channel_id: string;\n  event_ts: string;\n}\n\nexport interface ChannelLeftEvent extends SlackEvent<\"channel_left\"> {\n  type: \"channel_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n", "export interface ChannelLeftEvent extends SlackEvent<\"channel_left\"> {\n  type: \"channel_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n\nexport interface ChannelRenameEvent extends SlackEvent<\"channel_rename\"> {\n  type: \"channel_rename\";\n  channel: {\n    id: string;\n    name: string;\n    name_normalized: string;\n    created: number;\n    is_channel: boolean;\n    is_mpim: boolean;\n  };\n  event_ts: string;\n}\n", "export interface ChannelSharedEvent extends SlackEvent<\"channel_shared\"> {\n  type: \"channel_shared\";\n  connected_team_id: string;\n  channel: string;\n  event_ts: string;\n}\n\nexport interface ChannelUnarchiveEvent extends SlackEvent<\"channel_unarchive\"> {\n  type: \"channel_unarchive\";\n  channel: string;\n  user: string;\n  event_ts: string;\n}\n", "export interface ChannelUnsharedEvent extends SlackEvent<\"channel_unshared\"> {\n  type: \"channel_unshared\";\n  previously_connected_team_id: string;\n  channel: string;\n  is_ext_shared: boolean;\n  event_ts: string;\n}\n\nexport interface DNDUpdatedEvent extends SlackEvent<\"dnd_updated\"> {\n  type: \"dnd_updated\";\n  user: string;\n  dnd_status: {\n    dnd_enabled: boolean;\n    next_dnd_start_ts: number;\n    next_dnd_end_ts: number;\n    snooze_enabled: boolean;\n    snooze_endtime: number;\n    snooze_remaining: number;\n  };\n  event_ts: string;\n}\n", "export interface DNDUpdatedEvent extends SlackEvent<\"dnd_updated\"> {\n  type: \"dnd_updated\";\n  user: string;\n  dnd_status: {\n    dnd_enabled: boolean;\n    next_dnd_start_ts: number;\n    next_dnd_end_ts: number;\n    snooze_enabled: boolean;\n    snooze_endtime: number;\n    snooze_remaining: number;\n  };\n  event_ts: string;\n}\n", "export interface DNDUpdatedUserEvent extends SlackEvent<\"dnd_updated_user\"> {\n  type: \"dnd_updated_user\";\n  user: string;\n  dnd_status: {\n    dnd_enabled: boolean;\n    next_dnd_start_ts: number;\n    next_dnd_end_ts: number;\n  };\n  event_ts: string;\n}\n", "export interface EmailDomainChangedEvent\n  extends SlackEvent<\"email_domain_changed\"> {\n  type: \"email_domain_changed\";\n  email_domain: string;\n  event_ts: string;\n}\n\n// NOTE: this should probably be broken into its two subtypes\nexport interface EmojiChangedEvent extends SlackEvent<\"emoji_changed\"> {\n  type: \"emoji_changed\";\n  subtype: \"add\" | \"remove\" | \"rename\";\n  names?: string[]; // only for remove\n  name?: string; // only for add\n  value?: string; // only for add\n  old_name?: string;\n  new_name?: string;\n  event_ts: string;\n}\n", "export interface EmojiChangedEvent extends SlackEvent<\"emoji_changed\"> {\n  type: \"emoji_changed\";\n  subtype: \"add\" | \"remove\" | \"rename\";\n  names?: string[]; // only for remove\n  name?: string; // only for add\n  value?: string; // only for add\n  old_name?: string;\n  new_name?: string;\n  event_ts: string;\n}\n", "export interface FileChangeEvent extends SlackEvent<\"file_change\"> {\n  type: \"file_change\";\n  file_id: string;\n  file: { id: string };\n}\n\nexport interface FileCreatedEvent extends SlackEvent<\"file_created\"> {\n  type: \"file_created\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  event_ts: string;\n}\n", "export interface FileDeletedEvent extends SlackEvent<\"file_deleted\"> {\n  type: \"file_deleted\";\n  file_id: string;\n  channel_ids?: string[];\n  event_ts: string;\n}\n\nexport interface FilePublicEvent extends SlackEvent<\"file_public\"> {\n  type: \"file_public\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  event_ts: string;\n}\n", "export interface FileSharedEvent extends SlackEvent<\"file_shared\"> {\n  type: \"file_shared\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  channel_id: string;\n  event_ts: string;\n}\n\nexport interface FileUnsharedEvent extends SlackEvent<\"file_unshared\"> {\n  type: \"file_unshared\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  channel_id: string;\n  event_ts: string;\n}\n", "export interface FileUnsharedEvent extends SlackEvent<\"file_unshared\"> {\n  type: \"file_unshared\";\n  file_id: string;\n  user_id: string;\n  file: { id: string };\n  channel_id: string;\n  event_ts: string;\n}\n\nexport interface GridMigrationFinishedEvent\n  extends SlackEvent<\"grid_migration_finished\"> {\n  type: \"grid_migration_finished\";\n  enterprise_id: string;\n}\n", "export interface GridMigrationFinishedEvent\n  extends SlackEvent<\"grid_migration_finished\"> {\n  type: \"grid_migration_finished\";\n  enterprise_id: string;\n}\n\nexport interface GridMigrationStartedEvent\n  extends SlackEvent<\"grid_migration_started\"> {\n  type: \"grid_migration_started\";\n  enterprise_id: string;\n}\n", "export interface GroupArchiveEvent extends SlackEvent<\"group_archive\"> {\n  type: \"group_archive\";\n  channel: string;\n  user: string;\n  is_moved: number;\n  event_ts: string;\n}\n\nexport interface GroupCloseEvent extends SlackEvent<\"group_close\"> {\n  type: \"group_close\";\n  user: string;\n  channel: string;\n}\n", "export interface GroupCloseEvent extends SlackEvent<\"group_close\"> {\n  type: \"group_close\";\n  user: string;\n  channel: string;\n}\n\nexport interface GroupDeletedEvent extends SlackEvent<\"group_deleted\"> {\n  type: \"group_deleted\";\n  channel: string;\n  date_deleted: number;\n  actor_id: string;\n  event_ts: string;\n}\n", "export interface GroupHistoryChangedEvent\n  extends SlackEvent<\"group_history_changed\"> {\n  type: \"group_history_changed\";\n  latest: string;\n  ts: string;\n  event_ts: string;\n}\n\nexport interface GroupLeftEvent extends SlackEvent<\"group_left\"> {\n  type: \"group_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n", "export interface GroupLeftEvent extends SlackEvent<\"group_left\"> {\n  type: \"group_left\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n\nexport interface GroupOpenEvent extends SlackEvent<\"group_open\"> {\n  type: \"group_open\";\n  user: string;\n  channel: string;\n}\n", "export interface GroupRenameEvent extends SlackEvent<\"group_rename\"> {\n  type: \"group_rename\";\n  channel: {\n    id: string;\n    name: string;\n    name_normalized: string;\n    created: number;\n    is_channel: boolean;\n    is_mpim: boolean;\n  };\n  event_ts: string;\n}\n", "export interface GroupUnarchiveEvent extends SlackEvent<\"group_unarchive\"> {\n  type: \"group_unarchive\";\n  channel: string;\n  actor_id: string;\n  event_ts: string;\n}\n\nexport interface IMCloseEvent extends SlackEvent<\"im_close\"> {\n  type: \"im_close\";\n  user: string;\n  channel: string;\n  event_ts: string;\n}\n", "export interface IMCreatedEvent extends SlackEvent<\"im_created\"> {\n  type: \"im_created\";\n  user: string;\n  channel: { id: string };\n}\n\nexport interface IMHistoryChangedEvent\n  extends SlackEvent<\"im_history_changed\"> {\n  type: \"im_history_changed\";\n  latest: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface IMOpenEvent extends SlackEvent<\"im_open\"> {\n  type: \"im_open\";\n  user: string;\n  channel: string;\n  event_ts: string;\n}\n\nexport interface InviteRequestedEvent extends SlackEvent<\"invite_requested\"> {\n  type: \"invite_requested\";\n  invite_request: {\n    id: string;\n    email: string;\n    date_created: number;\n    requester_ids: string[];\n    channel_ids: string[];\n    invite_type: \"restricted\" | \"ultra_restricted\" | \"full_member\";\n    real_name: string;\n    date_expire: number;\n    request_reason: string;\n    team: {\n      id: string;\n      name: string;\n      domain: string;\n    };\n  };\n}\n", "export interface LinkSharedEvent extends SlackEvent<\"link_shared\"> {\n  type: \"link_shared\";\n  channel: string;\n  is_bot_user_member: boolean;\n  user: string;\n  message_ts: string;\n  thread_ts?: string;\n  links: {\n    domain: string;\n    url: string;\n  }[];\n  unfurl_id?: string;\n  source?: string;\n  event_ts: string;\n}\n", "export interface MemberJoinedChannelEvent\n  extends SlackEvent<\"member_joined_channel\"> {\n  type: \"member_joined_channel\";\n  user: string;\n  channel: string;\n  channel_type: string;\n  team: string;\n  inviter?: string;\n  event_ts: string;\n}\n", "export interface MemberLeftChannelEvent\n  extends SlackEvent<\"member_left_channel\"> {\n  type: \"member_left_channel\";\n  user: string;\n  channel: string;\n  channel_type: string;\n  team: string;\n  event_ts: string;\n}\n\nexport interface PinAddedEvent extends SlackEvent<\"pin_added\"> {\n  type: \"pin_added\";\n  user: string;\n  channel_id: string;\n  item: PinnedItem;\n  item_user: string;\n  pin_count: string;\n  pinned_info: {\n    channel: string;\n    pinned_by: string;\n    pinned_ts: number;\n  };\n  event_ts: string;\n}", "export interface PinAddedEvent extends SlackEvent<\"pin_added\"> {\n  type: \"pin_added\";\n  user: string;\n  channel_id: string;\n  item: PinnedItem;\n  item_user: string;\n  pin_count: string;\n  pinned_info: {\n    channel: string;\n    pinned_by: string;\n    pinned_ts: number;\n  };\n  event_ts: string;\n}", "export interface PinRemovedEvent extends SlackEvent<\"pin_removed\"> {\n  type: \"pin_removed\";\n  user: string;\n  channel_id: string;\n  item: PinnedItem;\n  item_user: string;\n  pin_count: string;\n  pinned_info: {\n    channel: string;\n    pinned_by: string;\n    pinned_ts: number;\n  };\n  has_pins: boolean;\n  event_ts: string;\n}\n", "export interface ReactionAddedEvent extends SlackEvent<\"reaction_added\"> {\n  type: \"reaction_added\";\n  user: string;\n  reaction: string;\n  item_user: string;\n  item: ReactionMessageItem;\n  event_ts: string;\n}\n\nexport interface ReactionRemovedEvent extends SlackEvent<\"reaction_removed\"> {\n  type: \"reaction_removed\";\n  user: string;\n  reaction: string;\n  item_user: string;\n  item: ReactionMessageItem;\n  event_ts: string;\n}\n", "export interface ReactionRemovedEvent extends SlackEvent<\"reaction_removed\"> {\n  type: \"reaction_removed\";\n  user: string;\n  reaction: string;\n  item_user: string;\n  item: ReactionMessageItem;\n  event_ts: string;\n}\n\nexport interface SharedChannelInviteAcceptedEvent\n  extends SlackEvent<\"shared_channel_invite_accepted\"> {\n  type: \"shared_channel_invite_accepted\";\n  approval_required: boolean;\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  teams_in_channel: SharedChannelTeamItem[];\n  accepting_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteAcceptedEvent\n  extends SlackEvent<\"shared_channel_invite_accepted\"> {\n  type: \"shared_channel_invite_accepted\";\n  approval_required: boolean;\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  teams_in_channel: SharedChannelTeamItem[];\n  accepting_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteApprovedEvent\n  extends SlackEvent<\"shared_channel_invite_approved\"> {\n  type: \"shared_channel_invite_approved\";\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  approving_team_id: string;\n  teams_in_channel: SharedChannelTeamItem[];\n  approving_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteDeclinedEvent\n  extends SlackEvent<\"shared_channel_invite_declined\"> {\n  type: \"shared_channel_invite_declined\";\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  declining_team_id: string;\n  teams_in_channel: SharedChannelTeamItem[];\n  declining_user: SharedChannelUserItem;\n  event_ts: string;\n}\n", "export interface SharedChannelInviteReceivedEvent\n  extends SlackEvent<\"shared_channel_invite_received\"> {\n  type: \"shared_channel_invite_received\";\n  invite: SharedChannelInviteItem;\n  channel: SharedChannelItem;\n  event_ts: string;\n}\n\nexport interface StarAddedEvent extends SlackEvent<\"star_added\"> {\n  type: \"star_added\";\n  user: string;\n  item: StarItem;\n  event_ts: string;\n}\n", "export interface StarAddedEvent extends SlackEvent<\"star_added\"> {\n  type: \"star_added\";\n  user: string;\n  item: StarItem;\n  event_ts: string;\n}\n\nexport interface StarRemovedEvent extends SlackEvent<\"star_removed\"> {\n  type: \"star_removed\";\n  user: string;\n  item: StarItem;\n  event_ts: string;\n}\n", "export interface SubteamCreatedEvent extends SlackEvent<\"subteam_created\"> {\n  type: \"subteam_created\";\n  subteam: Subteam;\n  event_ts: string;\n}\n\nexport interface SubteamMembersChangedEvent\n  extends SlackEvent<\"subteam_members_changed\"> {\n  type: \"subteam_members_changed\";\n  subteam_id: string;\n  team_id: string;\n  date_previous_update: number;\n  date_update: number;\n  added_users?: string[];\n  added_users_count?: number;\n  removed_users?: string[];\n  removed_users_count?: number;\n  event_ts: string;\n}\n", "export interface SubteamSelfAddedEvent\n  extends SlackEvent<\"subteam_self_added\"> {\n  type: \"subteam_self_added\";\n  subteam_id: string;\n  event_ts: string;\n}\n\nexport interface SubteamSelfRemovedEvent\n  extends SlackEvent<\"subteam_self_removed\"> {\n  type: \"subteam_self_removed\";\n  subteam_id: string;\n  event_ts: string;\n}\n", "export interface SubteamUpdatedEvent extends SlackEvent<\"subteam_updated\"> {\n  type: \"subteam_updated\";\n  subteam: Subteam;\n  event_ts: string;\n}\n\nexport interface TeamAccessGrantedEvent\n  extends SlackEvent<\"team_access_granted\"> {\n  type: \"team_access_granted\";\n  team_ids: string[];\n  event_ts: string;\n}\n", "export interface TeamAccessRevokedEvent\n  extends SlackEvent<\"team_access_revoked\"> {\n  type: \"team_access_revoked\";\n  team_ids: string[];\n  event_ts: string;\n}\n\nexport interface TeamDomainChangedEvent\n  extends SlackEvent<\"team_domain_changed\"> {\n  type: \"team_domain_changed\";\n  url: string;\n  domain: string;\n}\n", "export interface TeamJoinEvent extends SlackEvent<\"team_join\"> {\n  type: \"team_join\";\n  user: { id: string };\n}\n\nexport interface TeamRenameEvent extends SlackEvent<\"team_rename\"> {\n  type: \"team_rename\";\n  name: string;\n}\n\nexport interface TokensRevokedEvent extends SlackEvent<\"tokens_revoked\"> {\n  type: \"tokens_revoked\";\n  tokens: {\n    oauth?: string[];\n    bot?: string[];\n  };\n}\n", "export interface TokensRevokedEvent extends SlackEvent<\"tokens_revoked\"> {\n  type: \"tokens_revoked\";\n  tokens: {\n    oauth?: string[];\n    bot?: string[];\n  };\n}\n\nexport interface UserChangeEvent extends SlackEvent<\"user_change\"> {\n  type: \"user_change\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state?: string;\n      huddle_state_expiration_ts?: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserChangeEvent extends SlackEvent<\"user_change\"> {\n  type: \"user_change\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state?: string;\n      huddle_state_expiration_ts?: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserHuddleChangedEvent\n  extends SlackEvent<\"user_huddle_changed\"> {\n  type: \"user_huddle_changed\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state: string;\n      huddle_state_expiration_ts: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserProfileChangedEvent\n  extends SlackEvent<\"user_profile_changed\"> {\n  type: \"user_profile_changed\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      huddle_state: string;\n      huddle_state_expiration_ts: number;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface UserStatusChangedEvent\n  extends SlackEvent<\"user_status_changed\"> {\n  type: \"user_status_changed\";\n  user: {\n    id: string;\n    team_id: string;\n    name: string;\n    deleted: boolean;\n    color: string;\n    real_name: string;\n    tz: string;\n    tz_label: string;\n    tz_offset: number;\n    profile: {\n      title: string;\n      phone: string;\n      skype: string;\n      real_name: string;\n      real_name_normalized: string;\n      display_name: string;\n      display_name_normalized: string;\n      status_text: string;\n      status_text_canonical: string;\n      status_emoji: string;\n      status_emoji_display_info: StatusEmojiDisplayInfo[];\n      status_expiration: number;\n      avatar_hash: string;\n      first_name: string;\n      last_name: string;\n      email?: string;\n      image_original?: string;\n      is_custom_image?: boolean;\n      image_24: string;\n      image_32: string;\n      image_48: string;\n      image_72: string;\n      image_192: string;\n      image_512: string;\n      image_1024?: string;\n      team: string;\n      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n    };\n    is_admin: boolean;\n    is_owner: boolean;\n    is_primary_owner: boolean;\n    is_restricted: boolean;\n    is_ultra_restricted: boolean;\n    is_bot: boolean;\n    is_stranger?: boolean;\n    updated: number;\n    is_email_confirmed: boolean;\n    is_app_user: boolean;\n    is_invited_user?: boolean;\n    has_2fa?: boolean;\n    locale: string;\n    presence?: string;\n    enterprise_user?: {\n      id: string;\n      enterprise_id: string;\n      enterprise_name: string;\n      is_admin: boolean;\n      is_owner: boolean;\n      teams: string[];\n    };\n    two_factor_type?: string;\n    has_files?: boolean;\n    is_workflow_bot?: boolean;\n    who_can_share_contact_card: string;\n  };\n  cache_ts: number;\n  event_ts: string;\n}\n", "export interface WorkflowDeletedEvent extends SlackEvent<\"workflow_deleted\"> {\n  type: \"workflow_deleted\";\n  workflow_id: string;\n  workflow_draft_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowPublishedEvent\n  extends SlackEvent<\"workflow_published\"> {\n  type: \"workflow_published\";\n  workflow_id: string;\n  workflow_published_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowUnpublishedEvent\n  extends SlackEvent<\"workflow_unpublished\"> {\n  type: \"workflow_unpublished\";\n  workflow_id: string;\n  workflow_draft_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowStepDeletedEvent\n  extends SlackEvent<\"workflow_step_deleted\"> {\n  type: \"workflow_step_deleted\";\n  workflow_id: string;\n  workflow_draft_configuration: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  workflow_published_configuration?: {\n    version_id: string;\n    app_steps: {\n      app_id: string;\n      workflow_step_id: string;\n      callback_id: string;\n    }[];\n  };\n  event_ts: string;\n}\n", "export interface WorkflowStepExecuteEvent\n  extends SlackEvent<\"workflow_step_execute\"> {\n  type: \"workflow_step_execute\";\n  callback_id: string;\n  workflow_step: {\n    workflow_step_execute_id: string;\n    workflow_id: string;\n    workflow_instance_id: string;\n    step_id: string;\n    // deno-lint-ignore no-explicit-any\n    inputs: { [key: string]: { value: any } };\n    outputs: { name: string; type: string; label: string }[];\n  };\n  event_ts: string;\n}\n", "export type AnyMessageEvent =\n  | GenericMessageEvent\n  | BotMessageEvent\n  | ChannelArchiveMessageEvent\n  | ChannelJoinMessageEvent\n  | ChannelLeaveMessageEvent\n  | ChannelNameMessageEvent\n  | ChannelPostingPermissionsMessageEvent\n  | ChannelPurposeMessageEvent\n  | ChannelTopicMessageEvent\n  | ChannelUnarchiveMessageEvent\n  | EKMAccessDeniedMessageEvent\n  | FileShareMessageEvent\n  | MeMessageEvent\n  | MessageChangedEvent\n  | MessageDeletedEvent\n  | MessageRepliedEvent\n  | ThreadBroadcastMessageEvent;\n", "export type AnyMessageItem =\n  | GenericMessageEvent\n  | BotMessageEvent\n  | ChannelArchiveMessageEvent\n  | ChannelJoinMessageEvent\n  | ChannelLeaveMessageEvent\n  | ChannelNameMessageEvent\n  | ChannelPostingPermissionsMessageEvent\n  | ChannelPurposeMessageEvent\n  | ChannelTopicMessageEvent\n  | ChannelUnarchiveMessageEvent\n  | EKMAccessDeniedMessageEvent\n  | FileShareMessageEvent\n  | MeMessageEvent\n  | MessageRepliedEvent\n  | ThreadBroadcastMessageEvent;\n", "export type AnyMessageMetadataEvent =\n  | MessageMetadataPostedEvent\n  | MessageMetadataUpdatedEvent\n  | MessageMetadataDeletedEvent;\n\nexport interface GenericMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: undefined;\n  event_ts: string;\n  team?: string;\n  channel: string;\n  user: string;\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  text: string;\n  ts: string;\n  thread_ts?: string;\n  channel_type: AnyChannelType;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  files?: File[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  client_msg_id?: string;\n  parent_user_id?: string;\n\n  // TODO: optional types that maybe should flow into other subtypes?\n  is_starred?: boolean;\n  pinned_to?: string[];\n  reactions?: {\n    name: string;\n    count: number;\n    users: string[];\n  }[];\n}\n", "export interface BotMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"bot_message\";\n  event_ts: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  text: string;\n  bot_id: string;\n  username?: string;\n  icons?: {\n    [size: string]: string;\n  };\n\n  // copied from MessageEvent\n  // TODO: is a user really optional? likely for things like IncomingWebhook authored messages\n  user?: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  edited?: {\n    user: string;\n    ts: string;\n  };\n  thread_ts?: string;\n}\n", "export interface ChannelArchiveMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_archive\";\n  team: string;\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelJoinMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_join\";\n  team: string;\n  user: string;\n  inviter: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelLeaveMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_leave\";\n  team: string;\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelNameMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_name\";\n  team: string;\n  user: string;\n  name: string;\n  old_name: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelPostingPermissionsMessageEvent\n  extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_posting_permissions\";\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelPurposeMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_purpose\";\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  purpose: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelTopicMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_topic\";\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  topic: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface ChannelUnarchiveMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"channel_unarchive\";\n  team: string;\n  user: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  text: string;\n  ts: string;\n  event_ts: string;\n}\n", "export interface EKMAccessDeniedMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"ekm_access_denied\";\n  event_ts: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  text: string; // This will not have any meaningful content within\n  user: \"UREVOKEDU\";\n}\n", "export interface FileShareMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"file_share\";\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  files?: File[];\n  upload?: boolean;\n  display_as_bot?: boolean;\n  x_files?: string[];\n  user: string;\n  parent_user_id?: string;\n  ts: string;\n  thread_ts?: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  event_ts: string;\n}\n", "export interface MeMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"me_message\";\n  event_ts: string;\n  channel: string;\n  channel_type: AnyChannelType;\n  user: string;\n  text: string;\n  ts: string;\n}\n", "export interface MessageChangedEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"message_changed\";\n  event_ts: string;\n  hidden: true;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  message: AnyMessageItem;\n  previous_message: AnyMessageItem;\n}\n", "export interface MessageDeletedEvent {\n  type: \"message\";\n  subtype: \"message_deleted\";\n  event_ts: string;\n  hidden: true;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  deleted_ts: string;\n  previous_message: AnyMessageItem;\n}\n", "export interface MessageRepliedEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"message_replied\";\n  event_ts: string;\n  hidden: true;\n  channel: string;\n  channel_type: AnyChannelType;\n  ts: string;\n  message: AnyMessageItem & {\n    // TODO: should this be the union of all message events with type 'message'?\n    thread_ts: string;\n    reply_count: number;\n    replies: AnyMessageEvent[]; // TODO: should this be the union of all message events with type 'message'?\n  };\n}\n\n// the `reply_broadcast` message subtype is omitted because it is discontinued\n", "export interface ThreadBroadcastMessageEvent extends SlackEvent<\"message\"> {\n  type: \"message\";\n  subtype: \"thread_broadcast\";\n  event_ts: string;\n  text: string;\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  user: string;\n  ts: string;\n  thread_ts?: string;\n  root: (GenericMessageEvent | BotMessageEvent) & {\n    thread_ts: string;\n    reply_count: number;\n    reply_users_count: number;\n    latest_reply: string;\n    reply_users: string[];\n  };\n  client_msg_id: string;\n  channel: string;\n  channel_type: AnyChannelType;\n}\n", "export interface MessageMetadataPostedEvent\n  extends SlackEvent<\"message_metadata_posted\"> {\n  type: \"message_metadata_posted\";\n  app_id: string;\n  bot_id?: string;\n  user_id: string;\n  team_id: string;\n  channel_id: string;\n  metadata: MessageMetadata;\n  message_ts: string;\n  event_ts: string;\n}\n", "export interface MessageMetadataUpdatedEvent\n  extends SlackEvent<\"message_metadata_updated\"> {\n  type: \"message_metadata_updated\";\n  channel_id: string;\n  event_ts: string;\n  previous_metadata: MessageMetadata;\n  app_id: string;\n  bot_id?: string;\n  user_id: string;\n  team_id: string;\n  message_ts: string;\n  metadata: MessageMetadata;\n}\n", "export interface MessageMetadataDeletedEvent\n  extends SlackEvent<\"message_metadata_deleted\"> {\n  type: \"message_metadata_deleted\";\n  channel_id: string;\n  event_ts: string;\n  previous_metadata: MessageMetadata;\n  app_id: string;\n  bot_id?: string;\n  user_id: string;\n  team_id: string;\n  message_ts: string;\n  deleted_ts: string;\n}\n", "export type AnyChannelType = \"channel\" | \"group\" | \"im\" | \"mpim\" | \"app_home\";\n\n// -----------------------------------------------------------\n\nexport interface BotProfile {\n  id: string;\n  name: string;\n  app_id: string;\n  team_id: string;\n  icons: { [size: string]: string };\n  updated: number;\n  deleted: boolean;\n}\n", "export interface PinnedItem {\n  type: string;\n  channel: string;\n  created_by: string;\n  created: number;\n  message?: MessageItem;\n  file?: FileItem;\n}\n\nexport interface SharedChannelTeamItem {\n  id: string;\n  name: string;\n  icon: Record<string, unknown>;\n  is_verified: boolean;\n  domain: string;\n  date_created: number;\n}\n", "export interface SharedChannelTeamItem {\n  id: string;\n  name: string;\n  icon: Record<string, unknown>;\n  is_verified: boolean;\n  domain: string;\n  date_created: number;\n}\n\nexport interface SharedChannelUserItem {\n  id: string;\n  team_id: string;\n  name: string;\n  updated: number;\n  profile: {\n    real_name: string;\n    display_name: string;\n    real_name_normalized: string;\n    display_name_normalized: string;\n    team: string;\n    avatar_hash: string;\n    email: string;\n    image_24: string;\n    image_32: string;\n    image_48: string;\n    image_72: string;\n    image_192: string;\n    image_512: string;\n  };\n}\n", "export interface SharedChannelUserItem {\n  id: string;\n  team_id: string;\n  name: string;\n  updated: number;\n  profile: {\n    real_name: string;\n    display_name: string;\n    real_name_normalized: string;\n    display_name_normalized: string;\n    team: string;\n    avatar_hash: string;\n    email: string;\n    image_24: string;\n    image_32: string;\n    image_48: string;\n    image_72: string;\n    image_192: string;\n    image_512: string;\n  };\n}\n", "export interface SharedChannelInviteItem {\n  id: string;\n  date_created: number;\n  date_invalid: number;\n  inviting_team: SharedChannelTeamItem;\n  inviting_user: SharedChannelUserItem;\n  recipient_email?: string;\n  recipient_user_id?: string;\n}\n\nexport interface SharedChannelItem {\n  id: string;\n  is_private: boolean;\n  is_im: boolean;\n  name: string;\n}\n", "export interface SharedChannelItem {\n  id: string;\n  is_private: boolean;\n  is_im: boolean;\n  name: string;\n}\n\nexport interface Subteam {\n  id: string;\n  team_id?: string;\n  is_usergroup: boolean;\n  is_subteam: boolean;\n  name: string;\n  description?: string;\n  handle: string;\n  is_external: boolean;\n  date_create: number;\n  date_update?: number;\n  date_delete?: number;\n  auto_provision: boolean;\n  enterprise_subteam_id?: string;\n  created_by: string;\n  updated_by?: string;\n  prefs?: {\n    channels?: string[];\n    groups?: string[];\n  };\n  users: string[];\n  user_count: number;\n  channel_count?: number;\n}\n", "export interface StatusEmojiDisplayInfo {\n  emoji_name?: string;\n  display_alias?: string;\n  display_url?: string;\n}\n\nexport interface ReactionMessageItem {\n  type: \"message\";\n  channel: string;\n  ts: string;\n}\n", "export interface FileInitialComment {\n  channel?: string;\n  comment?: string;\n  created?: number;\n  id?: string;\n  is_intro?: boolean;\n  timestamp?: number;\n  user?: string;\n}\n\nexport interface StarItem {\n  date_create: number;\n  type: string;\n  channel?: string;\n  file?: FileItem;\n  message?: MessageItem;\n  comment?: {\n    channel?: string;\n    comment?: string;\n    created?: number;\n    id?: string;\n    is_intro?: boolean;\n    is_starred?: boolean;\n    num_stars?: number;\n    timestamp?: number;\n    user?: string;\n  };\n}\n", "export interface StarItem {\n  date_create: number;\n  type: string;\n  channel?: string;\n  file?: FileItem;\n  message?: MessageItem;\n  comment?: {\n    channel?: string;\n    comment?: string;\n    created?: number;\n    id?: string;\n    is_intro?: boolean;\n    is_starred?: boolean;\n    num_stars?: number;\n    timestamp?: number;\n    user?: string;\n  };\n}\n", "export interface FileItem {\n  alt_txt?: string;\n  app_id?: string;\n  app_name?: string;\n  bot_id?: string;\n  cc?: EmailAddress[];\n  channel_actions_count?: number;\n  channel_actions_ts?: string;\n  channels?: string[];\n  comments_count?: number;\n  converted_pdf?: string;\n  created: number;\n  deanimate?: string;\n  deanimate_gif?: string;\n  display_as_bot?: boolean;\n  duration_ms?: number;\n  edit_link?: string;\n  editable?: boolean;\n  editor?: string;\n  external_id?: string;\n  external_type?: string;\n  external_url?: string;\n  file_access?: string;\n  filetype: string;\n  from?: EmailAddress[];\n  groups?: string[];\n  has_more?: boolean;\n  has_more_shares?: boolean;\n  has_rich_preview?: boolean;\n  headers?: EmailHeaders;\n  hls?: string;\n  hls_embed?: string;\n  id?: string;\n  image_exif_rotation?: number;\n  ims?: string[];\n  initial_comment?: FileInitialComment;\n  is_external?: boolean;\n  is_public?: boolean;\n  is_starred?: boolean;\n  last_editor?: string;\n  lines?: number;\n  lines_more?: number;\n  media_display_type?: string;\n  media_progress?: SlackVideoMediaProgress;\n  mimetype?: string;\n  mode?: string;\n  mp4?: string;\n  name: string;\n  non_owner_editable?: boolean;\n  num_stars?: number;\n  original_attachment_count?: number;\n  original_h?: string;\n  original_w?: string;\n  permalink: string;\n  permalink_public?: string;\n  pinned_to?: string[];\n  pjpeg?: string;\n  plain_text?: string;\n  pretty_type?: string;\n  preview?: string;\n  preview_highlight?: string;\n  preview_is_truncated?: boolean;\n  preview_plain_text?: string;\n  public_url_shared?: boolean;\n  reactions?: Reaction[];\n  sent_to_self?: boolean;\n  shares?: FileShares;\n  simplified_html?: string;\n  size?: number;\n  source_team?: string;\n  subject?: string;\n  subtype?: string;\n  thumb_1024?: string;\n  thumb_1024_gif?: string;\n  thumb_1024_h?: string;\n  thumb_1024_w?: string;\n  thumb_160?: string;\n  thumb_160_gif?: string;\n  thumb_160_h?: string;\n  thumb_160_w?: string;\n  thumb_360?: string;\n  thumb_360_gif?: string;\n  thumb_360_h?: string;\n  thumb_360_w?: string;\n  thumb_480?: string;\n  thumb_480_gif?: string;\n  thumb_480_h?: string;\n  thumb_480_w?: string;\n  thumb_64?: string;\n  thumb_64_gif?: string;\n  thumb_64_h?: string;\n  thumb_64_w?: string;\n  thumb_720?: string;\n  thumb_720_gif?: string;\n  thumb_720_h?: string;\n  thumb_720_w?: string;\n  thumb_80?: string;\n  thumb_800?: string;\n  thumb_800_gif?: string;\n  thumb_800_h?: string;\n  thumb_800_w?: string;\n  thumb_80_gif?: string;\n  thumb_80_h?: string;\n  thumb_80_w?: string;\n  thumb_960?: string;\n  thumb_960_gif?: string;\n  thumb_960_h?: string;\n  thumb_960_w?: string;\n  thumb_gif?: string;\n  thumb_pdf?: string;\n  thumb_pdf_h?: string;\n  thumb_pdf_w?: string;\n  thumb_tiny?: string;\n  thumb_video?: string;\n  thumb_video_h?: number;\n  thumb_video_w?: number;\n  timestamp?: number;\n  title?: string;\n  to?: EmailAddress[];\n  transcription?: FileTranscription;\n  updated?: number;\n  url_private: string;\n  url_private_download: string;\n  user: string;\n  user_team: string;\n  username: string;\n  vtt?: string;\n}\n", "export interface EmailAddress {\n  address: string;\n  name: string;\n  original: string;\n}\n\nexport interface EmailHeaders {\n  date: string;\n  in_reply_to: string;\n  message_id: string;\n  reply_to: string;\n}\n", "export interface SlackVideoMediaProgress {\n  duration_ms: number;\n  max_offset_ms: number;\n  offset_ms: number;\n}\n\nexport interface Reaction {\n  count: number;\n  name: string;\n  url: string;\n  users: string[];\n}\n", "export interface FileShares {\n  private?: { [key: string]: ShareDetails[] };\n  public?: { [key: string]: ShareDetails[] };\n}\n\nexport interface ShareDetails {\n  share_user_id: string;\n  team_id: string;\n  channel_name: string;\n  ts: string;\n  latest_reply?: string;\n  reply_count?: number;\n  reply_users?: string[];\n  reply_users_count?: number;\n  thread_ts?: string;\n}\n", "export interface FileTranscription {\n  locale: string;\n  status: string;\n}\n\nexport interface MessageItem {\n  attachments?: MessageAttachment[];\n  blocks?: AnyMessageBlock[];\n  bot_id?: string;\n  bot_profile?: BotProfile;\n  client_msg_id: string;\n  display_as_bot?: boolean;\n  edited?: MessageEdited;\n  files?: FileElement[];\n  inviter?: string;\n  is_locked?: boolean;\n  is_starred?: boolean;\n  last_read?: string;\n  latest_reply?: string;\n  permalink: string;\n  reactions?: Reaction[];\n  reply_count?: number;\n  reply_users?: string[];\n  reply_users_count?: number;\n  subscribed?: boolean;\n  subtype?: string;\n  team: string;\n  text: string;\n  thread_ts?: string;\n  ts: string;\n  type: string;\n  upload?: boolean;\n  user: string;\n  username: string;\n}\n", "export interface MessageEdited {\n  ts: string;\n  user: string;\n}\n\nexport interface FileElement {\n  alt_txt?: string;\n  app_id?: string;\n  app_name?: string;\n  bot_id?: string;\n  cc?: EmailAddress[];\n  channel_actions_count?: number;\n  channel_actions_ts?: string;\n  channels?: string[];\n  comments_count?: number;\n  converted_pdf?: string;\n  created?: number;\n  deanimate?: string;\n  deanimate_gif?: string;\n  display_as_bot?: boolean;\n  duration_ms?: number;\n  edit_link?: string;\n  editable?: boolean;\n  editor?: string;\n  external_id?: string;\n  external_type?: string;\n  external_url?: string;\n  file_access?: string;\n  filetype?: string;\n  from?: EmailAddress[];\n  groups?: string[];\n  has_more?: boolean;\n  has_more_shares?: boolean;\n  has_rich_preview?: boolean;\n  headers?: Headers;\n  hls?: string;\n  hls_embed?: string;\n  id?: string;\n  image_exif_rotation?: number;\n  ims?: string[];\n  initial_comment?: FileInitialComment;\n  is_external: boolean;\n  is_public: boolean;\n  is_starred?: boolean;\n  last_editor?: string;\n  lines?: number;\n  lines_more?: number;\n  media_display_type?: string;\n  media_progress?: SlackVideoMediaProgress;\n  mimetype: string;\n  mode?: string;\n  mp4?: string;\n  name: string;\n  non_owner_editable?: boolean;\n  num_stars?: number;\n  original_attachment_count?: number;\n  original_h?: string;\n  original_w?: string;\n  permalink: string;\n  permalink_public?: string;\n  pinned_to?: string[];\n  pjpeg?: string;\n  plain_text?: string;\n  pretty_type?: string;\n  preview?: string;\n  preview_highlight?: string;\n  preview_is_truncated?: boolean;\n  preview_plain_text?: string;\n  public_url_shared?: boolean;\n  reactions?: Reaction[];\n  sent_to_self?: boolean;\n  shares?: FileShares;\n  simplified_html?: string;\n  size?: number;\n  source_team?: string;\n  subject?: string;\n  subtype?: string;\n  thumb_1024?: string;\n  thumb_1024_gif?: string;\n  thumb_1024_h?: string;\n  thumb_1024_w?: string;\n  thumb_160?: string;\n  thumb_160_gif?: string;\n  thumb_160_h?: string;\n  thumb_160_w?: string;\n  thumb_360?: string;\n  thumb_360_gif?: string;\n  thumb_360_h?: string;\n  thumb_360_w?: string;\n  thumb_480?: string;\n  thumb_480_gif?: string;\n  thumb_480_h?: string;\n  thumb_480_w?: string;\n  thumb_64?: string;\n  thumb_64_gif?: string;\n  thumb_64_h?: string;\n  thumb_64_w?: string;\n  thumb_720?: string;\n  thumb_720_gif?: string;\n  thumb_720_h?: string;\n  thumb_720_w?: string;\n  thumb_80?: string;\n  thumb_800?: string;\n  thumb_800_gif?: string;\n  thumb_800_h?: string;\n  thumb_800_w?: string;\n  thumb_80_gif?: string;\n  thumb_80_h?: string;\n  thumb_80_w?: string;\n  thumb_960?: string;\n  thumb_960_gif?: string;\n  thumb_960_h?: string;\n  thumb_960_w?: string;\n  thumb_gif?: string;\n  thumb_pdf?: string;\n  thumb_pdf_h?: string;\n  thumb_pdf_w?: string;\n  thumb_tiny?: string;\n  thumb_video?: string;\n  thumb_video_h?: number;\n  thumb_video_w?: number;\n  timestamp: number;\n  title: string;\n  to?: EmailAddress[];\n  transcription?: FileTranscription;\n  updated?: number;\n  url_private: string;\n  url_private_download: string;\n  user: string;\n  user_team: string;\n  username: string;\n  vtt?: string;\n}\n"]}
{"filename": "src/request/payload/block-action.ts", "chunked_list": ["import { Confirm, AnyOption, PlainTextField } from \"slack-web-api-client\";\nimport { DataSubmissionView, ViewStateValue } from \"./view-objects\";\n\nexport interface BlockAction<A extends BlockElementAction> {\n  type: \"block_actions\";\n  actions: A[];\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n  };\n  channel?: {\n    id: string;\n    name: string;\n  };\n  message?: {\n    type: \"message\";\n    user?: string;\n    ts: string;\n    text?: string;\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any;\n  };\n  view?: DataSubmissionView;\n  state?: {\n    values: {\n      [blockId: string]: {\n        [actionId: string]: ViewStateValue;\n      };\n    };\n  };\n  token: string;\n  response_url: string;\n  trigger_id: string;\n  api_app_id: string;\n  // deno-lint-ignore no-explicit-any\n  container: any;\n  // deno-lint-ignore no-explicit-any\n  app_unfurl?: any;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n}\n", "export interface BlockElementAction<T extends string = string> {\n  type: T;\n  block_id: string;\n  action_id: string;\n  action_ts: string;\n}\n\nexport interface ButtonAction extends BlockElementAction<\"button\"> {\n  value: string;\n  text: PlainTextField;\n  url?: string;\n  confirm?: Confirm;\n  accessibility_label?: string;\n}\n", "export interface StaticSelectAction\n  extends BlockElementAction<\"static_select\"> {\n  selected_option: {\n    text: PlainTextField;\n    value: string;\n  };\n  initial_option?: AnyOption;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface MultiStaticSelectAction\n  extends BlockElementAction<\"multi_static_select\"> {\n  selected_options: {\n    text: PlainTextField;\n    value: string;\n  }[];\n  initial_options?: AnyOption[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface UsersSelectAction extends BlockElementAction<\"users_select\"> {\n  selected_user: string;\n  initial_user?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface MultiUsersSelectAction\n  extends BlockElementAction<\"multi_users_select\"> {\n  selected_users: string[];\n  initial_users?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface ConversationsSelectAction\n  extends BlockElementAction<\"conversations_select\"> {\n  selected_conversation: string;\n  initial_conversation?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface MultiConversationsSelectAction\n  extends BlockElementAction<\"multi_conversations_select\"> {\n  selected_conversations: string[];\n  initial_conversations?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface MultiConversationsSelectAction\n  extends BlockElementAction<\"multi_conversations_select\"> {\n  selected_conversations: string[];\n  initial_conversations?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface ChannelsSelectAction\n  extends BlockElementAction<\"channels_select\"> {\n  selected_channel: string;\n  initial_channel?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface ChannelsSelectAction\n  extends BlockElementAction<\"channels_select\"> {\n  selected_channel: string;\n  initial_channel?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface MultiChannelsSelectAction\n  extends BlockElementAction<\"multi_channels_select\"> {\n  selected_channels: string[];\n  initial_channels?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface MultiChannelsSelectAction\n  extends BlockElementAction<\"multi_channels_select\"> {\n  selected_channels: string[];\n  initial_channels?: string[];\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface ExternalSelectAction\n  extends BlockElementAction<\"external_select\"> {\n  selected_option?: AnyOption;\n  initial_option?: AnyOption;\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n", "export interface ExternalSelectAction\n  extends BlockElementAction<\"external_select\"> {\n  selected_option?: AnyOption;\n  initial_option?: AnyOption;\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n\nexport interface MultiExternalSelectAction\n  extends BlockElementAction<\"multi_external_select\"> {\n  selected_options?: AnyOption[];\n  initial_options?: AnyOption[];\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n", "export interface MultiExternalSelectAction\n  extends BlockElementAction<\"multi_external_select\"> {\n  selected_options?: AnyOption[];\n  initial_options?: AnyOption[];\n  placeholder?: PlainTextField;\n  min_query_length?: number;\n  confirm?: Confirm;\n}\n\nexport interface OverflowAction extends BlockElementAction<\"overflow\"> {\n  selected_option: {\n    text: PlainTextField;\n    value: string;\n  };\n  confirm?: Confirm;\n}\n", "export interface OverflowAction extends BlockElementAction<\"overflow\"> {\n  selected_option: {\n    text: PlainTextField;\n    value: string;\n  };\n  confirm?: Confirm;\n}\n\nexport interface DatepickerAction extends BlockElementAction<\"datepicker\"> {\n  selected_date: string | null;\n  initial_date?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n", "export interface DatepickerAction extends BlockElementAction<\"datepicker\"> {\n  selected_date: string | null;\n  initial_date?: string;\n  placeholder?: PlainTextField;\n  confirm?: Confirm;\n}\n\nexport interface RadioButtonsAction\n  extends BlockElementAction<\"radio_buttons\"> {\n  selected_option: AnyOption | null;\n  initial_option?: AnyOption;\n  confirm?: Confirm;\n}\n", "export interface CheckboxesAction extends BlockElementAction<\"checkboxes\"> {\n  selected_options: AnyOption[];\n  initial_options?: AnyOption[];\n  confirm?: Confirm;\n}\n\nexport interface PlainTextInputAction\n  extends BlockElementAction<\"plain_text_input\"> {\n  value: string;\n}\n", "export type Actions =\n  | ButtonAction\n  | StaticSelectAction\n  | MultiStaticSelectAction\n  | UsersSelectAction\n  | MultiUsersSelectAction\n  | ConversationsSelectAction\n  | MultiConversationsSelectAction\n  | ChannelsSelectAction\n  | MultiChannelsSelectAction\n  | ExternalSelectAction\n  | MultiExternalSelectAction\n  | OverflowAction\n  | DatepickerAction\n  | RadioButtonsAction\n  | CheckboxesAction\n  | PlainTextInputAction;\n", "export type BlockElementTypes = Actions[\"type\"];\n"]}
{"filename": "src/request/payload/message-shortcut.ts", "chunked_list": ["export interface MessageShortcut {\n  type: \"message_action\";\n  callback_id: string;\n  trigger_id: string;\n  message_ts: string;\n  response_url: string;\n  message: {\n    type: \"message\";\n    user?: string;\n    ts: string;\n    text?: string;\n    // deno-lint-ignore no-explicit-any\n    [key: string]: any;\n  };\n  user: {\n    id: string;\n    name: string;\n    team_id?: string;\n    username?: string;\n  };\n  channel: {\n    id: string;\n    name: string;\n  };\n  team: {\n    id: string;\n    domain: string;\n    enterprise_id?: string;\n    enterprise_name?: string;\n  } | null;\n  token: string;\n  action_ts: string;\n  is_enterprise_install?: boolean;\n  enterprise?: {\n    id: string;\n    name: string;\n  };\n}\n"]}
{"filename": "src/middleware/built-in-middleware.ts", "chunked_list": ["import { PreAuthorizeMiddleware, Middleware } from \"./middleware\";\n\n// deno-lint-ignore require-await\nexport const urlVerification: PreAuthorizeMiddleware = async (req) => {\n  if (req.body.type === \"url_verification\") {\n    return { status: 200, body: req.body.challenge };\n  }\n};\n\nconst eventTypesToKeep = [\"member_joined_channel\", \"member_left_channel\"];\n\n// deno-lint-ignore require-await\nexport const ignoringSelfEvents: Middleware = async (req) => {", "  if (req.body.event) {\n    if (eventTypesToKeep.includes(req.body.event.type)) {\n      return;\n    }\n    if (\n      req.context.authorizeResult.botId === req.body.event.bot_id ||\n      req.context.authorizeResult.botUserId === req.context.userId\n    ) {\n      return { status: 200, body: \"\" };\n    }\n  }\n};\n"]}
{"filename": "src/middleware/middleware.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\nimport {\n  PreAuthorizeSlackMiddlwareRequest,\n  SlackMiddlwareRequest,\n} from \"../request/request\";\nimport { SlackResponse } from \"../response/response\";\n\nexport type PreAuthorizeMiddleware<E extends SlackAppEnv = SlackAppEnv> = (\n  req: PreAuthorizeSlackMiddlwareRequest<E>\n) => Promise<SlackResponse | void>;\n", "export type Middleware<E extends SlackAppEnv = SlackAppEnv> = (\n  req: SlackMiddlwareRequest<E>\n) => Promise<SlackResponse | void>;\n"]}
{"filename": "src/oauth/callback.ts", "chunked_list": ["import { InvalidStateParameter, OAuthErrorCode } from \"./error-codes\";\nimport { Installation } from \"./installation\";\nimport { renderErrorPage } from \"./oauth-page-renderer\";\n\nexport type BeforeInstallation = (\n  req: Request\n) => Promise<Response | undefined | void>;\n\nexport type AfterInstallation = (\n  installation: Installation,\n  req: Request\n) => Promise<Response | undefined | void>;\n", "export type AfterInstallation = (\n  installation: Installation,\n  req: Request\n) => Promise<Response | undefined | void>;\n\nexport type OnStateValidationError = (\n  startPath: string,\n  req: Request\n) => Promise<Response>;\n\n// deno-lint-ignore require-await\nexport const defaultOnStateValidationError = async (\n  startPath: string,\n  // deno-lint-ignore no-unused-vars\n  req: Request\n) => {\n  return new Response(renderErrorPage(startPath, InvalidStateParameter), {\n    status: 400,\n    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n  });\n};\n", "export type OnFailure = (\n  startPath: string,\n  reason: OAuthErrorCode,\n  req: Request\n) => Promise<Response>;\n\n// deno-lint-ignore require-await\nexport const defaultOnFailure = async (\n  startPath: string,\n  reason: OAuthErrorCode,\n  // deno-lint-ignore no-unused-vars\n  req: Request\n) => {\n  return new Response(renderErrorPage(startPath, reason), {\n    status: 400,\n    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n  });\n};\n"]}
{"filename": "src/oauth/installation.ts", "chunked_list": ["import { OAuthV2AccessResponse } from \"slack-web-api-client\";\n\nexport interface Installation {\n  app_id: string;\n  is_enterprise_install?: boolean;\n  enterprise_id?: string; // only for Enterprise Grid installations\n  team_id?: string; // can be absent when is_enterprise_install is true\n  user_id: string;\n\n  // bot token\n  bot_token?: string;\n  bot_user_id?: string;\n  bot_scopes?: string[];\n  bot_refresh_token?: string; // token rotation\n  bot_token_expires_at?: number; // token rotation (epoch time seconds)\n\n  // user token\n  user_token?: string;\n  user_scopes?: string[];\n  user_refresh_token?: string; // token rotation\n  user_token_expires_at?: number; // token rotation (epoch time seconds)\n\n  // Only when having incoming-webhooks\n  incoming_webhook_url?: string;\n  incoming_webhook_channel_id?: string;\n  incoming_webhook_configuration_url?: string;\n}\n", "export function toInstallation(\n  oauthAccess: OAuthV2AccessResponse\n): Installation {\n  const installation: Installation = {\n    app_id: oauthAccess.app_id!,\n    is_enterprise_install: oauthAccess.is_enterprise_install,\n    enterprise_id: oauthAccess.enterprise?.id,\n    team_id: oauthAccess.team?.id,\n    user_id: oauthAccess.authed_user?.id!,\n    // bot token\n    bot_token: oauthAccess.access_token,\n    bot_user_id: oauthAccess.bot_user_id,\n    bot_scopes: oauthAccess.scope?.split(\",\"),\n    bot_refresh_token: oauthAccess.refresh_token,\n    bot_token_expires_at: oauthAccess.expires_in\n      ? new Date().getTime() / 1000 + oauthAccess.expires_in\n      : undefined,\n\n    // user token\n    user_token: oauthAccess.authed_user?.access_token,\n    user_scopes: oauthAccess.authed_user?.scope?.split(\",\"),\n    user_refresh_token: oauthAccess.authed_user?.refresh_token,\n    user_token_expires_at: oauthAccess.authed_user?.expires_in\n      ? new Date().getTime() / 1000 + oauthAccess.authed_user?.expires_in\n      : undefined,\n\n    // Only when having incoming-webhooks\n    incoming_webhook_url: oauthAccess.incoming_webhook?.url,\n    incoming_webhook_channel_id: oauthAccess.incoming_webhook?.channel_id,\n    incoming_webhook_configuration_url: oauthAccess.incoming_webhook?.url,\n  };\n  return installation;\n}\n"]}
{"filename": "src/oauth/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env\";\n\nexport function generateAuthorizeUrl<E extends SlackOAuthEnv>(\n  state: string,\n  env: E,\n  team: string | undefined = undefined\n): string {\n  let url = `https://slack.com/oauth/v2/authorize?state=${state}`;\n  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n  url += `&scope=${env.SLACK_BOT_SCOPES}`;\n  if (env.SLACK_USER_SCOPES) {\n    url += `&user_scope=${env.SLACK_USER_SCOPES}`;\n  }", "  if (env.SLACK_USER_SCOPES) {\n    url += `&user_scope=${env.SLACK_USER_SCOPES}`;\n  }\n  if (env.SLACK_REDIRECT_URI) {\n    url += `&redirect_uri=${env.SLACK_REDIRECT_URI}`;\n  }\n  if (team) {\n    url += `&team=${team}`;\n  }\n  return url;\n}\n"]}
{"filename": "src/oauth/error-codes.ts", "chunked_list": ["export interface OAuthErrorCode {\n  code: string;\n  message: string;\n}\n\nexport const InvalidStateParameter: OAuthErrorCode = {\n  code: \"invalid-state\",\n  message: \"The state parameter is missing or invalid\",\n};\n\nexport const MissingCode: OAuthErrorCode = {\n  code: \"missing-code\",\n  message: \"The code parameter is missing\",\n};\n\nexport const InstallationError: OAuthErrorCode = {\n  code: \"installation-error\",\n  message: \"The installation process failed\",\n};\n\nexport const InstallationStoreError: OAuthErrorCode = {\n  code: \"installation-store-error\",\n  message: \"Saving the installation data failed\",\n};\n\nexport const CompletionPageError: OAuthErrorCode = {\n  code: \"completion-page-failure\",\n  message: \"Rendering the completion page failed\",\n};\n\nexport const OpenIDConnectError: OAuthErrorCode = {\n  code: \"oidc-error\",\n  message: \"The OpenID Connect process failed\",\n};\n"]}
{"filename": "src/oauth/oauth-page-renderer.ts", "chunked_list": ["import { OAuthErrorCode } from \"./error-codes\";\nimport { escapeHtml } from \"./escape-html\";\n\nexport function renderStartPage(url: string) {\n  return (\n    '<html><head><meta http-equiv=\"refresh\" content=\"2;url=' +\n    escapeHtml(url) +\n    '\" /><title>Redirecting to Slack ...</title></head><body>Redirecting to the Slack OAuth page ... Click <a href=\"' +\n    escapeHtml(url) +\n    '\">here</a> to continue.</body></html>'\n  );\n}\n", "export function renderErrorPage(installPath: string, reason: OAuthErrorCode) {\n  return (\n    '<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Oops, Something Went Wrong!</h2><p>Please try again from <a href=\"' +\n    escapeHtml(installPath) +\n    '\">here</a> or contact the app owner (reason: ' +\n    escapeHtml(reason.message) +\n    \")</p></body></html>\"\n  );\n}\n\nexport function renderCompletionPage(\n  appId: string,\n  teamId: string,\n  isEnterpriseInstall: boolean | undefined,\n  enterpriseUrl: string | undefined\n) {\n  let url = `slack://app?team=${teamId}&id=${appId}`;", "export function renderCompletionPage(\n  appId: string,\n  teamId: string,\n  isEnterpriseInstall: boolean | undefined,\n  enterpriseUrl: string | undefined\n) {\n  let url = `slack://app?team=${teamId}&id=${appId}`;\n  if (isEnterpriseInstall && enterpriseUrl !== undefined) {\n    url = `${enterpriseUrl}manage/organization/apps/profile/${appId}/workspaces/add\"`;\n  }\n  const browserUrl = `https://app.slack.com/client/${teamId}`;\n  return (\n    '<html><head><meta http-equiv=\"refresh\" content=\"0; URL=' +\n    escapeHtml(url) +\n    '\"><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Thank you!</h2><p>Redirecting to the Slack App... click <a href=\"' +\n    escapeHtml(url) +\n    '\">here</a>. If you use the browser version of Slack, click <a href=\"' +\n    escapeHtml(browserUrl) +\n    '\" target=\"_blank\">this link</a> instead.</p></body></html>'\n  );\n}\n"]}
{"filename": "src/oauth/state-store.ts", "chunked_list": ["export interface StateStore {\n  issueNewState(): Promise<string>;\n  consume(state: string): Promise<boolean>;\n}\n\nexport class NoStorageStateStore implements StateStore {\n  // deno-lint-ignore require-await\n  async issueNewState(): Promise<string> {\n    return crypto.randomUUID();\n  }\n\n  // deno-lint-ignore require-await no-unused-vars\n  async consume(state: string): Promise<boolean> {\n    return true;\n  }\n}\n"]}
{"filename": "src/oauth/installation-store.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env\";\nimport { Authorize } from \"../authorization/authorize\";\nimport { Installation } from \"./installation\";\n\nexport interface InstallationStoreQuery {\n  enterpriseId?: string;\n  teamId?: string;\n  userId?: string;\n  isEnterpriseInstall?: boolean;\n}\n", "export interface InstallationStore<E extends SlackOAuthEnv> {\n  save(installation: Installation, request: Request | undefined): Promise<void>;\n\n  findBotInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined>;\n\n  findUserInstallation(\n    query: InstallationStoreQuery\n  ): Promise<Installation | undefined>;\n\n  toAuthorize(): Authorize<E>;\n}\n"]}
{"filename": "src/oauth/escape-html.ts", "chunked_list": ["export function escapeHtml(input: string | undefined | null): string {\n  if (input) {\n    return input\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/\"/g, \"&quot;\")\n      .replace(/'/g, \"&#x27;\");\n  }\n  return \"\";\n}\n"]}
