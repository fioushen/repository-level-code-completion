{"filename": "types.d.ts", "chunked_list": ["declare module \"tailwindcss-animate\";\n"]}
{"filename": "src/pages/api/add-new-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\nimport { verifySignature } from \"@upstash/qstash/nextjs\";\nimport { ulid } from \"ulid\";\n\nimport authenticateRequest from \"@/server/authenticateRequest\";\nimport { fetchNewTitles } from \"@/lib/netflix\";\nimport { prisma } from \"@/server/db\";\nimport { parseTitles } from \"@/lib/parsers\";\n\nasync function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const date = new Date();\n\n    const titles = await fetchNewTitles({\n      date,\n      force: true,\n      fetchAllCountries: true,\n    });", "async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const date = new Date();\n\n    const titles = await fetchNewTitles({\n      date,\n      force: true,\n      fetchAllCountries: true,\n    });\n    if (titles.length < 1) {\n      res.statusCode = 204;\n      res.statusMessage = \"No newly added content.\";\n      return res.end();\n    }\n\n    const data = parseTitles(titles).map((title) => ({ ...title, id: ulid() }));\n    const created = await prisma.title.createMany({\n      data: data,\n      skipDuplicates: true,\n    });\n", "    if (titles.length < 1) {\n      res.statusCode = 204;\n      res.statusMessage = \"No newly added content.\";\n      return res.end();\n    }\n\n    const data = parseTitles(titles).map((title) => ({ ...title, id: ulid() }));\n    const created = await prisma.title.createMany({\n      data: data,\n      skipDuplicates: true,\n    });\n", "    if (created.count < 1) {\n      res.statusCode = 204;\n      res.statusMessage = \"There are no new titles to update in the database.\";\n      return res.end();\n    }\n\n    return res.json({\n      metadata: {\n        nonce: date.getTime(),\n        size: titles.length,\n        added: created.count,\n      },\n      data: titles,\n    });", "  } catch (e: any) {\n    return res.status(500).json({\n      code: res.statusCode,\n      name: e.name,\n      message: e.message,\n    });\n  }\n}\n\nexport default verifySignature(authenticateRequest(handler));\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n"]}
{"filename": "src/pages/api/post-to-twitter.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\nimport { verifySignature } from \"@upstash/qstash/nextjs\";\n\nimport authenticateRequest from \"@/server/authenticateRequest\";\nimport { fetchDailyTitles } from \"@/lib/netflix\";\nimport { buildThread, createTweetThread } from \"@/server/twitter\";\n\nasync function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const date = new Date();\n\n    const titles = await fetchDailyTitles({ date, force: true });", "  try {\n    const date = new Date();\n\n    const titles = await fetchDailyTitles({ date, force: true });\n    if (!titles.size) {\n      res.statusCode = 204;\n      res.statusMessage = \"No newly added or deleted content.\";\n      return res.end();\n    }\n\n    const tweetContent = buildThread({ date, titles });\n    const thread = await createTweetThread(tweetContent);\n\n    return res.json({\n      metadata: {\n        nonce: date.getTime(),\n        size: titles.size,\n      },\n      data: {\n        tweet_id: thread[0]?.data.id,\n        added: titles.added,\n        deleted: titles.deleted,\n      },\n    });", "  } catch (e: any) {\n    return res.status(500).json({\n      code: res.statusCode,\n      name: e.name,\n      message: e.message,\n    });\n  }\n}\n\nexport default verifySignature(authenticateRequest(handler));\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n"]}
{"filename": "src/pages/api/netflix/added-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\nimport { fetchNewTitles } from \"@/lib/netflix\";\nimport { convertDateQueryParam, getFormattedDate } from \"@/lib/date\";\nimport authenticateRequest from \"@/server/authenticateRequest\";\n\nasync function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const date = new Date();\n    const queryDate = convertDateQueryParam(req.query.date, date);\n    if (!queryDate)\n      return res.status(400).json({\n        metadata: {\n          nonce: date.getTime(),\n        },\n        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n          date\n        )})`,\n      });\n\n    const formattedQueryDate = getFormattedDate(queryDate);\n    const titles = await fetchNewTitles({ date: queryDate });", "    if (!queryDate)\n      return res.status(400).json({\n        metadata: {\n          nonce: date.getTime(),\n        },\n        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n          date\n        )})`,\n      });\n\n    const formattedQueryDate = getFormattedDate(queryDate);\n    const titles = await fetchNewTitles({ date: queryDate });", "    if (titles.length < 1) {\n      res.statusCode = 204;\n      res.statusMessage =\n        \"There are no new added titles for the provided date.\";\n      return res.end();\n    }\n\n    return res.json({\n      metadata: {\n        nonce: date.getTime(),\n        query_date: formattedQueryDate,\n        size: titles.length,\n      },\n      data: titles,\n    });", "  } catch (e: any) {\n    return res.status(500).json({\n      code: res.statusCode,\n      name: e.name,\n      message: e.message,\n    });\n  }\n}\n\nexport default authenticateRequest(handler);\n"]}
{"filename": "src/pages/api/netflix/get-daily-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\nimport { fetchDailyTitles } from \"@/lib/netflix\";\nimport { convertDateQueryParam, getFormattedDate } from \"@/lib/date\";\nimport authenticateRequest from \"@/server/authenticateRequest\";\n\nasync function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const date = new Date();\n    const queryDate = convertDateQueryParam(req.query.date, date);\n    if (!queryDate)\n      return res.status(400).json({\n        metadata: {\n          nonce: date.getTime(),\n        },\n        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n          date\n        )})`,\n      });\n\n    const formattedQueryDate = getFormattedDate(queryDate);\n    const titles = await fetchDailyTitles({ date: queryDate });", "    if (!queryDate)\n      return res.status(400).json({\n        metadata: {\n          nonce: date.getTime(),\n        },\n        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n          date\n        )})`,\n      });\n\n    const formattedQueryDate = getFormattedDate(queryDate);\n    const titles = await fetchDailyTitles({ date: queryDate });", "    if (!titles.size) {\n      res.statusCode = 204;\n      res.statusMessage = \"No newly added or deleted content.\";\n      return res.end();\n    }\n\n    return res.json({\n      metadata: {\n        nonce: date.getTime(),\n        query_date: formattedQueryDate,\n        size: titles.size,\n      },\n      data: {\n        added: titles.added,\n        deleted: titles.deleted,\n      },\n    });", "  } catch (e: any) {\n    return res.status(500).json({\n      code: res.statusCode,\n      name: e.name,\n      message: e.message,\n    });\n  }\n}\n\nexport default authenticateRequest(handler);\n"]}
{"filename": "src/pages/api/netflix/deleted-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\nimport { fetchDeletedTitles } from \"@/lib/netflix\";\nimport { convertDateQueryParam, getFormattedDate } from \"@/lib/date\";\nimport authenticateRequest from \"@/server/authenticateRequest\";\n\nasync function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const date = new Date();\n    const queryDate = convertDateQueryParam(req.query.date, date);\n    if (!queryDate)\n      return res.status(400).json({\n        metadata: {\n          nonce: date.getTime(),\n        },\n        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n          date\n        )})`,\n      });\n\n    const formattedQueryDate = getFormattedDate(queryDate);\n    const titles = await fetchDeletedTitles({ date: queryDate });", "    if (!queryDate)\n      return res.status(400).json({\n        metadata: {\n          nonce: date.getTime(),\n        },\n        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n          date\n        )})`,\n      });\n\n    const formattedQueryDate = getFormattedDate(queryDate);\n    const titles = await fetchDeletedTitles({ date: queryDate });", "    if (titles.length < 1) {\n      res.statusCode = 204;\n      res.statusMessage =\n        \"There are no new deleted titles for the provided date.\";\n      return res.end();\n    }\n\n    return res.json({\n      metadata: {\n        nonce: date.getTime(),\n        query_date: formattedQueryDate,\n        size: titles.length,\n      },\n      data: titles,\n    });", "  } catch (e: any) {\n    return res.status(500).json({\n      code: res.statusCode,\n      name: e.name,\n      message: e.message,\n    });\n  }\n}\n\nexport default authenticateRequest(handler);\n"]}
{"filename": "src/config/site.ts", "chunked_list": ["export type SiteConfig = typeof siteConfig;\n\nexport const siteConfig = {\n  name: \"Netflix Refresh\",\n  description:\n    \"Get notified on added/removed content on Netflix in your Twitter feed daily!\",\n  mainNav: [\n    {\n      title: \"Home\",\n      href: \"/\",\n    },\n  ],\n  links: {\n    twitter: \"https://twitter.com/NetflixRefresh\",\n    github: \"https://github.com/acollierr17/netflix-refresh\",\n  },\n};\n"]}
{"filename": "src/lib/api.ts", "chunked_list": ["/**\n * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n *\n * We also create a few inference helpers for input and output types.\n */\nimport { httpBatchLink, loggerLink } from \"@trpc/client\";\nimport { createTRPCNext } from \"@trpc/next\";\nimport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n", "import { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n\nimport { type AppRouter } from \"@/server/api/root\";\n\nconst getBaseUrl = () => {\n  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n};\n\n/** A set of type-safe react-query hooks for your tRPC API. */\nexport const api = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      /**\n       * Transformer used for data de-serialization from the server.\n       *\n       * @see https://trpc.io/docs/data-transformers\n       */\n      transformer: superjson,\n\n      /**\n       * Links used to determine request flow from client to server.\n       *\n       * @see https://trpc.io/docs/links\n       */\n      links: [\n        loggerLink({\n          enabled: (opts) =>\n            process.env.NODE_ENV === \"development\" ||\n            (opts.direction === \"down\" && opts.result instanceof Error),\n        }),\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n    };\n  },\n  /**\n   * Whether tRPC should await queries when server rendering pages.\n   *\n   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n   */\n  ssr: false,\n});\n\n/**\n * Inference helper for inputs.\n *", " * @example type HelloInput = RouterInputs['example']['hello']\n */\nexport type RouterInputs = inferRouterInputs<AppRouter>;\n\n/**\n * Inference helper for outputs.\n *\n * @example type HelloOutput = RouterOutputs['example']['hello']\n */\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n", "export type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/lib/trpc.ts", "chunked_list": ["import { createTRPCReact } from \"@trpc/react-query\";\nimport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\n// import type { AppRouter } from \"@/app/api/trpc/trpc-router\";\nimport type { AppRouter } from \"@/server/api/root\";\n\nexport const api = createTRPCReact<AppRouter>();\n\n/**\n * Inference helper for inputs.\n *", " * @example type HelloInput = RouterInputs['example']['hello']\n */\nexport type RouterInputs = inferRouterInputs<AppRouter>;\n\n/**\n * Inference helper for outputs.\n *\n * @example type HelloOutput = RouterOutputs['example']['hello']\n */\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n", "export type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/lib/fonts.ts", "chunked_list": ["import {\n  JetBrains_Mono as FontMono,\n  Inter as FontSans,\n} from \"next/font/google\";\n\nexport const fontSans = FontSans({\n  subsets: [\"latin\"],\n  variable: \"--font-sans\",\n});\n", "});\n\nexport const fontMono = FontMono({\n  subsets: [\"latin\"],\n  variable: \"--font-mono\",\n});\n"]}
{"filename": "src/lib/parsers.ts", "chunked_list": ["import { z } from \"zod\";\nimport type { NetflixJSONData } from \"./netflix\";\n\nexport const TitleSchema = z.object({\n  imdbId: z.string().max(16),\n  img: z.string().max(1024),\n  netflixId: z.number(),\n  poster: z.string().max(1024),\n  rating: z.string().max(255),\n  runtime: z.string().max(255),", "  rating: z.string().max(255),\n  runtime: z.string().max(255),\n  synopsis: z.string().max(1024),\n  title: z.string().max(255),\n  titleDate: z.string().max(255),\n  titleType: z.string().max(6),\n  top250: z.number(),\n  top250tv: z.number(),\n  year: z.string().max(4),\n});", "  year: z.string().max(4),\n});\n\nexport const TitlesSchema = z.array(TitleSchema);\n\nexport const parseTitles = (data: NetflixJSONData[]) => {\n  const formatted = data.map(formatJSONData);\n  return TitlesSchema.parse(formatted);\n};\n", "};\n\nexport const formatJSONData = (data: NetflixJSONData) => ({\n  imdbId: data[\"imdb_id\"],\n  img: data[\"img\"],\n  netflixId: data[\"netflix_id\"],\n  poster: data[\"poster\"],\n  rating: data[\"rating\"],\n  runtime: data[\"runtime\"],\n  synopsis: data[\"synopsis\"],", "  runtime: data[\"runtime\"],\n  synopsis: data[\"synopsis\"],\n  title: data[\"title\"],\n  titleDate: data[\"title_date\"],\n  titleType: data[\"title_type\"],\n  top250: data[\"top250\"],\n  top250tv: data[\"top250tv\"],\n  year: data[\"year\"],\n});\n", "});\n"]}
{"filename": "src/lib/utils.ts", "chunked_list": ["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n"]}
{"filename": "src/lib/date.ts", "chunked_list": ["/**\n * For dates:\n * - CONTEXT: Date is 2023-05-16\n * - Note: When doing a date range to the current date, it will exclude the current date.\n * To resolve this, +1 the date to add those results.\n * Ex. 2023-05-01-2023-05-16 would be changed to 2023-05-01,2023-05-17\n *\n * - Get all titles on a SPECIFIC date, ex. 2023-05-15,2023-05-16\n * - Get all titles FROM a SPECIFIC date, ex. 2023-05-09\n * - Get all titles between a specific date range, ex. 2023-03-01,2023-03-08", " * - Get all titles FROM a SPECIFIC date, ex. 2023-05-09\n * - Get all titles between a specific date range, ex. 2023-03-01,2023-03-08\n * - Get all titles FROM a SPECIFIC date to the CURRENT date, ex. 2023-05-01,2023-05-17\n * - Get all titles on the CURRENT date, ex. 2023-05-16\n */\nexport const formatDateQueryString = (date: Date): string => {\n  const currentDate = new Date();\n  if (areDatesEqual(date, currentDate)) return getFormattedDate(date);\n\n  const endDate = new Date(date);\n  endDate.setDate(endDate.getDate() + 1);\n  return `${getFormattedDate(date)},${getFormattedDate(endDate)}`;\n};\n\nexport const convertUTCStringToDate = (utc: string): Date => {\n  const parts = utc.split(\"-\");\n  const year = Number(parts[0]);\n  const month = Number(parts[1]) - 1;\n  const day = Number(parts[2]);\n\n  return new Date(year, month, day);\n};\n\nconst areDatesEqual = (date1: Date, date2: Date) => {\n  return (\n    date1.getFullYear() === date2.getFullYear() &&\n    date1.getMonth() === date2.getMonth() &&\n    date1.getDate() === date2.getDate()\n  );\n};\n\nexport const getFriendlyFormattedDate = (date: Date): string => {\n  return new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n  }).format(date);\n};\n\nexport const getFormattedDate = (date: Date): string => {\n  const year = date.getFullYear().toString();\n  const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n  const day = date.getDate().toString().padStart(2, \"0\");\n\n  return [year, month, day].join(\"-\");\n};\n\nexport const convertDateQueryParam = (\n  param: string | string[] | undefined,\n  date: Date\n) => {\n  return param\n    ? convertUTCStringToDate(\n        Array.isArray(param) ? (param[0] as string) : param\n      )\n    : date;\n};\n"]}
{"filename": "src/lib/netflix.ts", "chunked_list": ["import { env } from \"@/env.mjs\";\nimport redis from \"@/server/redis\";\nimport { formatDateQueryString, getFormattedDate } from \"./date\";\n\nconst { RAPIDAPI_KEY, RAPIDAPI_HOST } = env;\n\nexport type NetflixJSONData = {\n  imdb_id: string;\n  img: string;\n  netflix_id: number;\n  poster: string;\n  rating: string;\n  runtime: string;\n  synopsis: string;\n  title: string;\n  title_date: string;\n  title_type: \"series\" | \"movie\";\n  top250: number;\n  top250tv: number;\n  year: string;\n};\n", "export type DailyNetflixJSON = {\n  size: number;\n  added: NetflixJSONData[];\n  deleted: NetflixDeleteJSONData[];\n};\n\nexport type NetflixDeleteJSONData = {\n  netflix_id: number;\n  country_id: number;\n  title: string;\n  delete_date: string;\n  country_code: string;\n};\n", "export type BaseNetflixData<T> = {\n  Object: {\n    total: number;\n    limit: number;\n    offset: number;\n  };\n  results: T[] | null;\n};\n\ntype RequestOptions = {\n  route: string;\n  method?: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\n  body?: BodyInit | null;\n  headers?: HeadersInit | null;\n  queries?: URLSearchParams | null;\n  fetchAllCountries?: boolean | null;\n};\n", "type RequestOptions = {\n  route: string;\n  method?: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\n  body?: BodyInit | null;\n  headers?: HeadersInit | null;\n  queries?: URLSearchParams | null;\n  fetchAllCountries?: boolean | null;\n};\n\ntype FetchTitleOptions = {\n  date: Date;\n  force?: boolean;\n  fetchAllCountries?: boolean;\n};\n\nconst BASE_URL = `https://${RAPIDAPI_HOST}`;\n\nconst makeNetflixRequest = async <T>(\n  options: RequestOptions\n): Promise<BaseNetflixData<T>> => {\n  const url = new URL(`${BASE_URL + options.route}`);", "type FetchTitleOptions = {\n  date: Date;\n  force?: boolean;\n  fetchAllCountries?: boolean;\n};\n\nconst BASE_URL = `https://${RAPIDAPI_HOST}`;\n\nconst makeNetflixRequest = async <T>(\n  options: RequestOptions\n): Promise<BaseNetflixData<T>> => {\n  const url = new URL(`${BASE_URL + options.route}`);", "  if (!options.queries) {\n    const params = new URLSearchParams();\n    if (!options.fetchAllCountries) params.set(\"country_list\", \"78\");\n    options.queries = params;\n  }\n\n  if (!options.fetchAllCountries) options.queries.set(\"country_list\", \"78\");\n\n  url.search = options.queries.toString();\n\n  return fetch(url, {\n    headers: {\n      ...options.headers,\n      \"X-RapidAPI-Key\": RAPIDAPI_KEY,\n      \"X-RapidAPI-Host\": RAPIDAPI_HOST,\n    },\n    body: options.body,\n  }).then((res: Response) => res.json() as Promise<BaseNetflixData<T>>);\n};\n\nexport const fetchDailyTitles = async ({ date }: FetchTitleOptions) => {\n  const queryDate = formatDateQueryString(date);\n  const data: DailyNetflixJSON = {\n    size: 0,\n    added: [],\n    deleted: [],\n  };\n\n  const promises = [fetchNewTitles({ date }), fetchDeletedTitles({ date })];\n  const results = await Promise.allSettled(promises);\n\n  const addedContent =\n    results[0]?.status === \"fulfilled\" ? results[0].value : [];\n  const deletedContent =\n    results[1]?.status === \"fulfilled\" ? results[1].value : [];\n", "  if (addedContent) {\n    data.added = [...data.added, ...addedContent] as NetflixJSONData[];\n    data.size += data.added.length;\n  }\n  if (deletedContent) {\n    data.deleted = [\n      ...data.deleted,\n      ...deletedContent,\n    ] as NetflixDeleteJSONData[];\n    data.size += data.deleted.length;\n  }\n\n  const dateFormatted = getFormattedDate(date);\n  const cachedDateExists = await redis.sismember(\"dates\", queryDate);", "  if (!cachedDateExists) {\n    await redis.sadd(\"dates\", dateFormatted);\n    await redis.hset<DailyNetflixJSON>(\"daily-titles\", {\n      [dateFormatted]: data,\n    });\n  }\n\n  return data;\n};\n\nexport const fetchDeletedTitles = async ({\n  date,\n  force,\n  fetchAllCountries,\n}: FetchTitleOptions) => {\n  const queryDate = formatDateQueryString(date);\n  const queries = new URLSearchParams({\n    delete_date: queryDate,\n  });\n\n  const cached = force\n    ? null\n    : await redis.hget<NetflixDeleteJSONData[]>(\"deleted-titles\", queryDate);", "  if (cached) return cached;\n\n  const { results } = await makeNetflixRequest<NetflixDeleteJSONData>({\n    route: \"/search/deleted\",\n    queries,\n    fetchAllCountries,\n  });\n\n  if (!results) return [] as NetflixJSONData[];\n\n  if (!force)\n    await redis.hset<NetflixDeleteJSONData[]>(\"deleted-titles\", {\n      [getFormattedDate(date)]: results,\n    });\n\n  return results;\n};\n\nexport const fetchNewTitles = async ({\n  date,\n  force,\n  fetchAllCountries,\n}: FetchTitleOptions) => {\n  const queryDate = formatDateQueryString(date);\n  const queries = new URLSearchParams({\n    order_by: \"date\",\n    new_date: queryDate,\n  });\n\n  const cached = force\n    ? null\n    : await redis.hget<NetflixJSONData[]>(\"added-titles\", queryDate);", "  if (!results) return [] as NetflixJSONData[];\n\n  if (!force)\n    await redis.hset<NetflixDeleteJSONData[]>(\"deleted-titles\", {\n      [getFormattedDate(date)]: results,\n    });\n\n  return results;\n};\n\nexport const fetchNewTitles = async ({\n  date,\n  force,\n  fetchAllCountries,\n}: FetchTitleOptions) => {\n  const queryDate = formatDateQueryString(date);\n  const queries = new URLSearchParams({\n    order_by: \"date\",\n    new_date: queryDate,\n  });\n\n  const cached = force\n    ? null\n    : await redis.hget<NetflixJSONData[]>(\"added-titles\", queryDate);", "  if (cached) return cached;\n\n  const { results } = await makeNetflixRequest<NetflixJSONData>({\n    route: \"/search/titles\",\n    queries,\n    fetchAllCountries,\n  });\n\n  if (!results) return [] as NetflixJSONData[];\n\n  if (!force)\n    await redis.hset<NetflixJSONData[]>(\"added-titles\", {\n      [getFormattedDate(date)]: results,\n    });\n\n  return results;\n};\n", "  if (!results) return [] as NetflixJSONData[];\n\n  if (!force)\n    await redis.hset<NetflixJSONData[]>(\"added-titles\", {\n      [getFormattedDate(date)]: results,\n    });\n\n  return results;\n};\n"]}
{"filename": "src/server/authenticateRequest.ts", "chunked_list": ["import type { NextApiHandler, NextApiRequest, NextApiResponse } from \"next\";\nimport { env } from \"@/env.mjs\";\n\nexport default function authenticateRequest(\n  handler: NextApiHandler\n): NextApiHandler {\n  const date = new Date();\n  return (req: NextApiRequest, res: NextApiResponse) => {\n    if (\n      !req.headers[\"x-api-key\"] ||\n      req.headers[\"x-api-key\"] !== env.API_TOKEN\n    ) {\n      return res.status(401).json({\n        metadata: { nonce: date.getTime() },\n        error: \"The API key is invalid or not found.\",\n      });\n    }\n\n    return handler(req, res);\n  };\n}\n", "    if (\n      !req.headers[\"x-api-key\"] ||\n      req.headers[\"x-api-key\"] !== env.API_TOKEN\n    ) {\n      return res.status(401).json({\n        metadata: { nonce: date.getTime() },\n        error: \"The API key is invalid or not found.\",\n      });\n    }\n\n    return handler(req, res);\n  };\n}\n"]}
{"filename": "src/server/redis.ts", "chunked_list": ["import { Redis } from \"@upstash/redis\";\nimport { env } from \"@/env.mjs\";\n\nconst redis = new Redis({\n  url: env.UPSTASH_REDIS_REST_URL,\n  token: env.UPSTASH_REDIS_REST_TOKEN,\n});\n\nexport default redis;\n", "export default redis;\n"]}
{"filename": "src/server/twitter.ts", "chunked_list": ["import { TwitterApi } from \"twitter-api-v2\";\nimport he from \"he\";\nimport { stripIndents } from \"common-tags\";\n\nimport { env } from \"@/env.mjs\";\nimport type {\n  DailyNetflixJSON,\n  NetflixDeleteJSONData,\n  NetflixJSONData,\n} from \"@/lib/netflix\";", "  NetflixJSONData,\n} from \"@/lib/netflix\";\n\nimport { getFriendlyFormattedDate } from \"@/lib/date\";\n\nconst client = new TwitterApi({\n  appKey: env.TWITTER_CONSUMER_KEY,\n  appSecret: env.TWITTER_CONSUMER_SECRET,\n  accessToken: env.TWITTER_ACCESS_TOKEN,\n  accessSecret: env.TWITTER_ACCESS_TOKEN_SECRET,", "  accessToken: env.TWITTER_ACCESS_TOKEN,\n  accessSecret: env.TWITTER_ACCESS_TOKEN_SECRET,\n});\n\nexport const createTweetThread = async (tweets: string[]) => {\n  return client.v2.tweetThread(tweets);\n};\n\nexport const buildThread = ({\n  date,", "export const buildThread = ({\n  date,\n  titles,\n}: {\n  date: Date;\n  titles: DailyNetflixJSON;\n}): string[] => {\n  const displayTitle = (title: NetflixJSONData | NetflixDeleteJSONData) => {\n    const titleType = {\n      series: \"Series\",", "    const titleType = {\n      series: \"Series\",\n      movie: \"Movie\",\n    };\n\n    let str = \"\u2022 \";\n    if (\"year\" in title)\n      str += `${he.decode(title.title)} (${title.year}) [${\n        titleType[title.title_type]\n      }]`;\n    else str += he.decode(title.title);\n\n    return str;\n  };\n\n  const tweetContent: string[] = [\n    stripIndents`\n      Netflix Refresh (US) \u2022 ${getFriendlyFormattedDate(date)}\n\n      Added: ${titles.added.length}\n      Deleted: ${titles.deleted.length}\n    `,\n  ];\n", "  if (titles.added.length > 0)\n    tweetContent.push(stripIndents`\n      Added Content:\n      \n      ${titles.added.map(displayTitle).join(\"\\n\")}\n    `);\n\n  if (titles.deleted.length > 0)\n    tweetContent.push(stripIndents`\n      Deleted Content:\n      \n      ${titles.deleted.map(displayTitle).join(\"\\n\")}\n    `);\n\n  return tweetContent;\n};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\nimport { env } from \"@/env.mjs\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({", "  globalForPrisma.prisma ??\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\nimport { initTRPC } from \"@trpc/server\";\nimport { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\nimport { prisma } from \"@/server/db\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n */\n", "import { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\nimport { prisma } from \"@/server/db\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n */\n", "type CreateContextOptions = Record<string, never>;\n\n/**\n * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n * it from here.\n *\n * Examples of things you may need it for:\n * - testing, so we don't have to mock Next.js' req/res\n * - tRPC's `createSSGHelpers`, where we don't have req/res\n *\n * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts\n */\nconst createInnerTRPCContext = (_opts: CreateContextOptions) => {\n  return {\n    prisma,\n  };\n};\n\n/**\n * This is the actual context you will use in your router. It will be used to process every request\n * that goes through your tRPC endpoint.\n *\n * @see https://trpc.io/docs/context\n */\nexport const createTRPCContext = (_opts: CreateNextContextOptions) => {\n  return createInnerTRPCContext({});\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\n\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure;\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { exampleRouter } from \"@/server/api/router/example\";\nimport { createTRPCRouter } from \"@/server/api/trpc\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  example: exampleRouter,", "export const appRouter = createTRPCRouter({\n  example: exampleRouter,\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/router/example.ts", "chunked_list": ["import { z } from \"zod\";\nimport { createTRPCRouter, publicProcedure } from \"@/server/api/trpc\";\n\nexport const exampleRouter = createTRPCRouter({\n  hello: publicProcedure\n    .input(z.object({ text: z.string() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.text}`,\n      };", "        greeting: `Hello ${input.text}`,\n      };\n    }),\n  getUsers: publicProcedure.query(({ ctx }) => {\n    return userList;\n  }),\n  getNetflixTitle: publicProcedure\n    .input(z.object({ id: z.number() }))\n    .query(async ({ input, ctx }) => {\n      return await ctx.prisma.title.findUnique({", "    .query(async ({ input, ctx }) => {\n      return await ctx.prisma.title.findUnique({\n        where: {\n          netflixId: input.id,\n        },\n      });\n    }),\n});\n\n// The code below is kept here to keep things simple", "\n// The code below is kept here to keep things simple\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nconst userList: User[] = [\n  {\n    id: \"1\",\n    name: \"John Doe\",\n    email: \"johndoe@gmail.com\",\n  },\n  {\n    id: \"2\",\n    name: \"Abraham Smith\",\n    email: \"abrahamsmith@gmail.com\",\n  },\n  {\n    id: \"3\",\n    name: \"Barbie Tracy\",\n    email: \"barbietracy@gmail.com\",\n  },\n  {\n    id: \"4\",\n    name: \"John Payday\",\n    email: \"johnpayday@gmail.com\",\n  },\n  {\n    id: \"5\",\n    name: \"Remember My Name\",\n    email: \"remembermyname@gmail.com\",\n  },\n  {\n    id: \"6\",\n    name: \"Go to School\",\n    email: \"gotoschool@gmail.com\",\n  },\n  {\n    id: \"7\",\n    name: \"Fish Fruit\",\n    email: \"fishfruit@gmail.com\",\n  },\n  {\n    id: \"8\",\n    name: \"Don't try\",\n    email: \"donttry@gmail.com\",\n  },\n  {\n    id: \"9\",\n    name: \"Producer Feed\",\n    email: \"producerfeed@gmail.com\",\n  },\n  {\n    id: \"10\",\n    name: \"Panic So\",\n    email: \"panicso@gmail.com\",\n  },\n];\n"]}
{"filename": "src/types/nav.ts", "chunked_list": ["export interface NavItem {\n  title: string;\n  href?: string;\n  disabled?: boolean;\n  external?: boolean;\n}\n"]}
{"filename": "src/app/api/trpc/[trpc]/route.ts", "chunked_list": ["import {\n  type FetchCreateContextFnOptions,\n  fetchRequestHandler,\n} from \"@trpc/server/adapters/fetch\";\nimport { appRouter } from \"@/server/api/root\";\nimport { env } from \"@/env.mjs\";\nimport { prisma } from \"@/server/db\";\n\ntype CreateContextOptions = {\n  prisma: typeof prisma;\n};\n\nconst handler = (request: Request) => {\n  console.log(`incoming request ${request.url}`);\n  return fetchRequestHandler({\n    endpoint: \"/api/trpc\",\n    req: request,\n    router: appRouter,\n    createContext: function (\n      opts: FetchCreateContextFnOptions\n    ): CreateContextOptions {\n      return {\n        prisma,\n      };\n    },\n    onError:\n      env.NODE_ENV === \"development\"\n        ? ({ path, error }) => {\n            console.error(\n              `\u274c tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n            );\n          }\n        : undefined,\n  });\n};\n\nexport { handler as GET, handler as POST };\n", "type CreateContextOptions = {\n  prisma: typeof prisma;\n};\n\nconst handler = (request: Request) => {\n  console.log(`incoming request ${request.url}`);\n  return fetchRequestHandler({\n    endpoint: \"/api/trpc\",\n    req: request,\n    router: appRouter,\n    createContext: function (\n      opts: FetchCreateContextFnOptions\n    ): CreateContextOptions {\n      return {\n        prisma,\n      };\n    },\n    onError:\n      env.NODE_ENV === \"development\"\n        ? ({ path, error }) => {\n            console.error(\n              `\u274c tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n            );\n          }\n        : undefined,\n  });\n};\n\nexport { handler as GET, handler as POST };\n"]}
