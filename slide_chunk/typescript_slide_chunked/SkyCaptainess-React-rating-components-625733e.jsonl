{"filename": "playwright-ct.config.ts", "chunked_list": ["import { devices, PlaywrightTestConfig } from '@playwright/experimental-ct-react'\nimport react from '@vitejs/plugin-react'\n\nconst reporterOutputDir = process.env.IS_RTL ? 'playwright-rtl-report' : 'playwright-report'\n\nconst config: PlaywrightTestConfig = {\n   testDir: './tests/ct',\n   timeout: 30 * 1000,\n   fullyParallel: false,\n   reporter: [['html', { outputFolder: reporterOutputDir }]],", "   fullyParallel: false,\n   reporter: [['html', { outputFolder: reporterOutputDir }]],\n   use: {\n      trace: 'on-first-retry',\n      ctViteConfig: {\n         define: {\n            __DEV__: true,\n         },\n         // @ts-ignore - \"\"\n         plugins: [react()],", "         // @ts-ignore - \"\"\n         plugins: [react()],\n      },\n   },\n   projects: [\n      {\n         name: 'chromium',\n         use: {\n            ...devices['Desktop Chrome'],\n         },", "            ...devices['Desktop Chrome'],\n         },\n      },\n      {\n         name: 'firefox',\n         use: {\n            ...devices['Desktop Firefox'],\n         },\n      },\n      {", "      },\n      {\n         name: 'webkit',\n         use: {\n            ...devices['Desktop Safari'],\n         },\n      },\n      {\n         name: 'Mobile Chrome',\n         use: {", "         name: 'Mobile Chrome',\n         use: {\n            ...devices['Pixel 4a (5G)'],\n            ...devices['Pixel 4a (5G) landscape'],\n         },\n      },\n      {\n         name: 'Mobile Safari',\n         use: {\n            ...devices['iPhone 11'],", "         use: {\n            ...devices['iPhone 11'],\n            ...devices['iPhone 11 landscape'],\n         },\n      },\n   ],\n}\n\nexport default config\n", "export default config\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport terser from '@rollup/plugin-terser'\n\nimport Package from './package.json'\n\nconst vitestOptions = {\n   test: {\n      globals: true,\n      environment: 'jsdom',", "      globals: true,\n      environment: 'jsdom',\n      setupFiles: './tests/dom/setupTests.ts',\n      exclude: ['**/vite/**', '**/node_modules/**', '**/dist/**', '**/ct/**'],\n   },\n}\n\nexport default defineConfig(({ command }) => ({\n   ...vitestOptions,\n   define: {", "   ...vitestOptions,\n   define: {\n      __DEV__: command !== 'build',\n   },\n   build: {\n      minify: 'terser',\n      lib: {\n         name: Package.name,\n         entry: 'src/index.ts',\n         formats: ['es', 'cjs'],", "         entry: 'src/index.ts',\n         formats: ['es', 'cjs'],\n         fileName: 'index',\n      },\n      rollupOptions: {\n         external: ['react', 'react/jsx-runtime'],\n         output: {\n            globals: {\n               react: 'React',\n               'react/jsx-runtime': 'React',", "               react: 'React',\n               'react/jsx-runtime': 'React',\n            },\n         },\n         plugins: [\n            terser({\n               compress: {\n                  defaults: true,\n                  drop_console: false,\n               },", "                  drop_console: false,\n               },\n            }),\n         ],\n      },\n   },\n   plugins: [react()],\n}))\n", ""]}
{"filename": "vite/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\ndeclare const __DEV__: boolean\n"]}
{"filename": "tests/dom/testUtils.ts", "chunked_list": ["import { ThinStar } from '../../src/Shapes'\nimport { useState } from 'react'\nimport { ItemStyles } from '../../src/exportedTypes'\nexport { render, screen } from '@testing-library/react'\nimport { StickerStar } from '../../src/Shapes'\n\nexport const GROUP_ID = 'rating'\n\nexport const CHILD_RESET_ID = 'rating-reset'\n", "export const CHILD_RESET_ID = 'rating-reset'\n\nexport const CHILD_ID_1 = 'rating-child-1'\nexport const CHILD_ID_2 = 'rating-child-2'\nexport const CHILD_ID_3 = 'rating-child-3'\nexport const CHILD_ID_4 = 'rating-child-4'\nexport const CHILD_ID_5 = 'rating-child-5'\n\nexport const SVGCHILD_ID_1 = 'rating-child-svg-1'\nexport const SVGCHILD_ID_2 = 'rating-child-svg-2'", "export const SVGCHILD_ID_1 = 'rating-child-svg-1'\nexport const SVGCHILD_ID_2 = 'rating-child-svg-2'\nexport const SVGCHILD_ID_3 = 'rating-child-svg-3'\nexport const SVGCHILD_ID_4 = 'rating-child-svg-4'\nexport const SVGCHILD_ID_5 = 'rating-child-svg-5'\n\nexport const childArr = [CHILD_ID_1, CHILD_ID_2, CHILD_ID_3, CHILD_ID_4, CHILD_ID_5]\n\nexport const itemStyles: ItemStyles = {\n   itemShapes: ThinStar,", "export const itemStyles: ItemStyles = {\n   itemShapes: ThinStar,\n}\n\nexport const useOnChange = (initialValue: number) => {\n   const [ratingValue, setRatingValue] = useState(initialValue)\n\n   return { ratingValue, setRatingValue }\n}\n", "}\n\nexport const arrayColorStyles: ItemStyles = {\n   itemShapes: StickerStar,\n   activeFillColor: ['#FEE2E2', '#FFEDD5', '#FEF9C3', '#ECFCCB', '#D1FAE5'],\n   activeBoxColor: ['#DA1600', '#DB711A', '#DCB000', '#61BB00', '#009664'],\n   activeBoxBorderColor: ['#C41400', '#D05E00', '#CCA300', '#498D00', '#00724C'],\n   activeStrokeColor: ['#C41400', '#D05E00', '#CCA300', '#498D00', '#00724C'],\n}\n", "}\n"]}
{"filename": "tests/dom/setupTests.ts", "chunked_list": ["import { vi } from 'vitest'\nimport { cleanup } from '@testing-library/react'\nimport matchers from '@testing-library/jest-dom/matchers'\n\nimport '@testing-library/jest-dom'\n\nexpect.extend(matchers)\n\nbeforeEach(() => {\n   vi.spyOn(console, 'error').mockImplementation(() => undefined)", "beforeEach(() => {\n   vi.spyOn(console, 'error').mockImplementation(() => undefined)\n   // @ts-expect-error - getBBox\n   window.SVGElement.prototype.getBBox = () => ({\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n   })\n})", "   })\n})\n\nafterEach(() => {\n   // @ts-expect-error - getBBox\n   delete window.SVGElement.prototype.getBBox\n   cleanup()\n})\n", ""]}
{"filename": "tests/dom/setupTests.d.ts", "chunked_list": ["import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers'\n\ninterface SVGElement {\n   getBBox?: () => void\n}\n\ndeclare global {\n   // eslint-disable-next-line @typescript-eslint/no-namespace\n   namespace Vi {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      type Assertion<T = any> = TestingLibraryMatchers<T, void>\n   }\n}\n", "      type Assertion<T = any> = TestingLibraryMatchers<T, void>\n   }\n}\n"]}
{"filename": "tests/ct/testUtils.ts", "chunked_list": ["import { expect } from '@playwright/experimental-ct-react'\nimport { Locator, Page } from '@playwright/test'\n\n/** Copy-pasting it as it is not exported by playwright */\nexport interface MountResult extends Locator {\n   unmount: () => Promise<void>\n   rerender?: (component: JSX.Element) => Promise<void>\n}\n\nexport const groupTestId = 'rating'\nexport const firstButtonId = 'id=first_button'\nexport const secondButtonId = 'id=second_button'\nexport const resetTestId = 'data-testid=rating-reset'\n\nexport const nextArrow = process.env.IS_RTL ? 'ArrowLeft' : 'ArrowRight'\n\nexport const childTestIds = [\n   'data-testid=rating-child-1',\n   'data-testid=rating-child-2',\n   'data-testid=rating-child-3',\n   'data-testid=rating-child-4',\n   'data-testid=rating-child-5',\n]\n", "export function getRandomInt(min: number, max: number) {\n   min = Math.ceil(min)\n   max = Math.floor(max)\n   return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport async function setRTL(page: Page) {\n   if (process.env.IS_RTL) {\n      await page.addScriptTag({\n         content: \"document.body.setAttribute('dir', 'rtl')\",\n      })\n   }\n}\n", "export async function pressTab(page: Page, browserName: string) {\n   if (browserName === 'webkit') {\n      await page.keyboard.press('Alt+Tab')\n   } else {\n      await page.keyboard.press('Tab')\n   }\n}\n\nexport async function pressShiftTab(page: Page, browserName: string) {\n   if (browserName === 'webkit') {\n      await page.keyboard.press('Alt+Shift+Tab')\n   } else {\n      await page.keyboard.press('Shift+Tab')\n   }\n}\n", "export async function pressShiftTab(page: Page, browserName: string) {\n   if (browserName === 'webkit') {\n      await page.keyboard.press('Alt+Shift+Tab')\n   } else {\n      await page.keyboard.press('Shift+Tab')\n   }\n}\n\nexport async function expectToBeTheOnlyFocusable(result: MountResult, locatorId: string) {\n   await expect(result.locator(locatorId)).toHaveAttribute('tabindex', '0')\n\n   const notFocusedChild = childTestIds.filter((childName) => childName !== locatorId)\n   for await (const childName of notFocusedChild) {\n      await expect(result.locator(childName)).toHaveAttribute('tabindex', '-1')\n   }\n}\n", "export async function expectToBeTheOnlyFocusable(result: MountResult, locatorId: string) {\n   await expect(result.locator(locatorId)).toHaveAttribute('tabindex', '0')\n\n   const notFocusedChild = childTestIds.filter((childName) => childName !== locatorId)\n   for await (const childName of notFocusedChild) {\n      await expect(result.locator(childName)).toHaveAttribute('tabindex', '-1')\n   }\n}\n\nexport async function expectToBeTheOnlyChecked(result: MountResult, locatorId: string) {\n   await expect(result.locator(locatorId)).toBeChecked()\n\n   const notFocusedChild = childTestIds.filter((childName) => childName !== locatorId)\n   for await (const childName of notFocusedChild) {\n      await expect(result.locator(childName)).not.toBeChecked()\n   }\n}\n", "export async function expectToBeTheOnlyChecked(result: MountResult, locatorId: string) {\n   await expect(result.locator(locatorId)).toBeChecked()\n\n   const notFocusedChild = childTestIds.filter((childName) => childName !== locatorId)\n   for await (const childName of notFocusedChild) {\n      await expect(result.locator(childName)).not.toBeChecked()\n   }\n}\n\nexport async function expectNoneToBeChecked(result: MountResult) {\n   for await (const childName of childTestIds) {\n      await expect(result.locator(childName)).not.toBeChecked()\n   }\n}\n", "export async function expectNoneToBeChecked(result: MountResult) {\n   for await (const childName of childTestIds) {\n      await expect(result.locator(childName)).not.toBeChecked()\n   }\n}\n\nexport async function tabNavigateToRating(page: Page, browserName: string) {\n   await pressTab(page, browserName)\n   await pressTab(page, browserName)\n}\n"]}
{"filename": "tests/unit/getActiveClassNames.test.ts", "chunked_list": ["import { getActiveClassNames } from '../../src/getActiveClassNames'\nimport { CSSClassName } from '../../src/internalTypes'\n\ndescribe('getActiveClassNames returns proper array of active classes', () => {\n   const items = 5\n   const X: CSSClassName = 'rr--on'\n   const _: CSSClassName = 'rr--off'\n\n   const Test1 = `If highlightOnlySelected is true, it should return an array\nwith the length equal to the rating items, containing the active class only\nat the current selected index`\n\n   test(Test1, () => {\n      expect(getActiveClassNames(true, items, 0)).toStrictEqual([X, _, _, _, _])\n      expect(getActiveClassNames(true, items, 1)).toStrictEqual([_, X, _, _, _])\n      expect(getActiveClassNames(true, items, 2)).toStrictEqual([_, _, X, _, _])\n      expect(getActiveClassNames(true, items, 3)).toStrictEqual([_, _, _, X, _])\n      expect(getActiveClassNames(true, items, 4)).toStrictEqual([_, _, _, _, X])\n   })\n\n   const Test2 = `If highlightOnlySelected is false, it should return an array\nwith the length equal to the rating items, containing the active class\nat the current selected index and any previous index`\n\n   test(Test2, () => {\n      expect(getActiveClassNames(false, items, 0)).toStrictEqual([X, _, _, _, _])\n      expect(getActiveClassNames(false, items, 1)).toStrictEqual([X, X, _, _, _])\n      expect(getActiveClassNames(false, items, 2)).toStrictEqual([X, X, X, _, _])\n      expect(getActiveClassNames(false, items, 3)).toStrictEqual([X, X, X, X, _])\n      expect(getActiveClassNames(false, items, 4)).toStrictEqual([X, X, X, X, X])\n   })\n})\n", "   const Test1 = `If highlightOnlySelected is true, it should return an array\nwith the length equal to the rating items, containing the active class only\nat the current selected index`\n\n   test(Test1, () => {\n      expect(getActiveClassNames(true, items, 0)).toStrictEqual([X, _, _, _, _])\n      expect(getActiveClassNames(true, items, 1)).toStrictEqual([_, X, _, _, _])\n      expect(getActiveClassNames(true, items, 2)).toStrictEqual([_, _, X, _, _])\n      expect(getActiveClassNames(true, items, 3)).toStrictEqual([_, _, _, X, _])\n      expect(getActiveClassNames(true, items, 4)).toStrictEqual([_, _, _, _, X])\n   })\n\n   const Test2 = `If highlightOnlySelected is false, it should return an array\nwith the length equal to the rating items, containing the active class\nat the current selected index and any previous index`\n\n   test(Test2, () => {\n      expect(getActiveClassNames(false, items, 0)).toStrictEqual([X, _, _, _, _])\n      expect(getActiveClassNames(false, items, 1)).toStrictEqual([X, X, _, _, _])\n      expect(getActiveClassNames(false, items, 2)).toStrictEqual([X, X, X, _, _])\n      expect(getActiveClassNames(false, items, 3)).toStrictEqual([X, X, X, X, _])\n      expect(getActiveClassNames(false, items, 4)).toStrictEqual([X, X, X, X, X])\n   })\n})\n"]}
{"filename": "tests/unit/getTabIndex.test.ts", "chunked_list": ["import { getTabIndex } from '../../src/getTabIndex'\n\ndescribe('getTabIndex returns the updated tabIndex array based on currentRatingIndex', () => {\n   const items = 5\n\n   test('Should return [0, -1, -1, -1, -1 if currentRatingIndex is 0 or -1', () => {\n      expect(getTabIndex(items, -1)).toStrictEqual([0, -1, -1, -1, -1])\n      expect(getTabIndex(items, 0)).toStrictEqual([0, -1, -1, -1, -1])\n   })\n", "   })\n\n   test('Should return [-1, 0, -1, -1, -1 if currentRatingIndex is 1 and so on...', () => {\n      expect(getTabIndex(items, 1)).toStrictEqual([-1, 0, -1, -1, -1])\n      expect(getTabIndex(items, 2)).toStrictEqual([-1, -1, 0, -1, -1])\n      expect(getTabIndex(items, 3)).toStrictEqual([-1, -1, -1, 0, -1])\n      expect(getTabIndex(items, 4)).toStrictEqual([-1, -1, -1, -1, 0])\n   })\n})\n", "})\n"]}
{"filename": "tests/unit/getIntersectionIndex.test.ts", "chunked_list": ["import { getIntersectionIndex } from '../../src/utils'\n\nconst ratingValues = [1, 2, 3, 4, 5]\n\nconst Test = `We try to round the value to the nearest half-integer.\nIf the result is an integer (not enough for half-fill),\nit should return the index of the (rounded) rating value. If the final\nresult is an half-integer, it should return the next integer index.`\n\ntest(Test, () => {", "\ntest(Test, () => {\n   expect(getIntersectionIndex(ratingValues, 1.23)).toBe(0)\n   expect(getIntersectionIndex(ratingValues, 1.5)).toBe(1)\n   expect(getIntersectionIndex(ratingValues, 2.23)).toBe(1)\n   expect(getIntersectionIndex(ratingValues, 2.55)).toBe(2)\n   expect(getIntersectionIndex(ratingValues, 3)).toBe(2)\n   expect(getIntersectionIndex(ratingValues, 3.5)).toBe(3)\n})\n", "})\n"]}
{"filename": "tests/unit/getHFClassNames.test.ts", "chunked_list": ["import { getHFClassNames } from '../../src/getHFClassNames'\nimport { CSSClassName } from '../../src/internalTypes'\n\ndescribe('getHFClassNames returns classNames for box and svg', () => {\n   const items = 5\n   const Test1 = `It should return an array, whose value at the intersectionIndex\nhas a special className if halfFillMode equals to \"box\"`\n\n   const X: CSSClassName = 'rr--hf-box-int'\n   const I: CSSClassName = 'rr--hf-box-on'", "   const X: CSSClassName = 'rr--hf-box-int'\n   const I: CSSClassName = 'rr--hf-box-on'\n   const O: CSSClassName = 'rr--hf-box-off'\n\n   test(Test1, () => {\n      expect(getHFClassNames(0.4, items, 'box')).toStrictEqual([X, O, O, O, O])\n      expect(getHFClassNames(1.5, items, 'box')).toStrictEqual([I, X, O, O, O])\n      expect(getHFClassNames(2.33, items, 'box')).toStrictEqual([I, I, X, O, O])\n      expect(getHFClassNames(3.33, items, 'box')).toStrictEqual([I, I, I, X, O])\n      expect(getHFClassNames(4.33, items, 'box')).toStrictEqual([I, I, I, I, X])", "      expect(getHFClassNames(3.33, items, 'box')).toStrictEqual([I, I, I, X, O])\n      expect(getHFClassNames(4.33, items, 'box')).toStrictEqual([I, I, I, I, X])\n   })\n\n   const Test2 = `It should return an array, whose value at the intersectionIndex and\nall values before have an active className if halfFillMode equals to \"svg\"`\n\n   const ON: CSSClassName = 'rr--hf-svg-on'\n   const _: CSSClassName = 'rr--hf-svg-off'\n", "   const _: CSSClassName = 'rr--hf-svg-off'\n\n   test(Test2, () => {\n      expect(getHFClassNames(0.41, items, 'svg')).toStrictEqual([ON, _, _, _, _])\n      expect(getHFClassNames(1.51, items, 'svg')).toStrictEqual([ON, ON, _, _, _])\n      expect(getHFClassNames(2.33, items, 'svg')).toStrictEqual([ON, ON, ON, _, _])\n      expect(getHFClassNames(3.33, items, 'svg')).toStrictEqual([ON, ON, ON, ON, _])\n      expect(getHFClassNames(4.33, items, 'svg')).toStrictEqual([ON, ON, ON, ON, ON])\n   })\n})", "   })\n})\n"]}
{"filename": "tests/unit/getColors.test.ts", "chunked_list": ["import { getColors } from '../../src/getColors'\n\ndescribe('getColors returns proper arrayColors and staticColors objects', () => {\n   const Test1 = 'Should return an object including only properties with string values'\n\n   const sourceObject = {\n      activeFillColor: 'transparent',\n      activeStrokeColor: undefined,\n      activeBoxColor: ['x', 'a', 'f', undefined, 0],\n      activeBoxBorderColor: 3,", "      activeBoxColor: ['x', 'a', 'f', undefined, 0],\n      activeBoxBorderColor: 3,\n\n      inactiveFillColor: 'green',\n      inactiveStrokeColor: '#FFFFFF',\n      inactiveBoxColor: 'red',\n      inactiveBoxBorderColor: undefined,\n   }\n\n   const expectedObject = {", "\n   const expectedObject = {\n      arrayColors: {\n         activeBoxColor: ['x', 'a', 'f'],\n      },\n      staticColors: {\n         activeFillColor: 'transparent',\n\n         inactiveBoxColor: 'red',\n         inactiveFillColor: 'green',", "         inactiveBoxColor: 'red',\n         inactiveFillColor: 'green',\n         inactiveStrokeColor: '#FFFFFF',\n      },\n   }\n\n   test(Test1, () => {\n      expect(getColors(sourceObject)).toStrictEqual(expectedObject)\n   })\n", "   })\n\n   const Test2 = 'Should never include non-array properties in arrayColors'\n\n   const sourceObject2 = {\n      activeBoxColor: ['x', 'a', 'f', undefined, 0],\n\n      inactiveFillColor: ['green', 'red', 'blue'],\n      inactiveStrokeColor: '#FFFFFF',\n   }", "      inactiveStrokeColor: '#FFFFFF',\n   }\n\n   const expectedObject2 = {\n      arrayColors: {\n         activeBoxColor: ['x', 'a', 'f'],\n      },\n      staticColors: {\n         inactiveStrokeColor: '#FFFFFF',\n      },", "         inactiveStrokeColor: '#FFFFFF',\n      },\n   }\n\n   test(Test2, () => {\n      expect(getColors(sourceObject2)).toStrictEqual(expectedObject2)\n   })\n\n   const Test3 = 'Should return an empty object for arrayColors if no colors are provided as array'\n", "   const Test3 = 'Should return an empty object for arrayColors if no colors are provided as array'\n\n   const sourceObject3 = {\n      activeFillColor: '#ffb23f',\n      activeBoxColor: 'red',\n      activeBoxBorderColor: 'blue',\n      activeStrokeColor: '#e17b21',\n\n      inactiveFillColor: '#FFF7ED',\n      inactiveStrokeColor: '#eda76a',", "      inactiveFillColor: '#FFF7ED',\n      inactiveStrokeColor: '#eda76a',\n      inactiveBoxColor: 'green',\n      inactiveBoxBorderColor: 'aliceblue',\n   }\n\n   const expectedObject3 = {\n      arrayColors: {},\n      staticColors: {\n         ...sourceObject3,", "      staticColors: {\n         ...sourceObject3,\n      },\n   }\n\n   test(Test3, () => {\n      expect(getColors(sourceObject3)).toStrictEqual(expectedObject3)\n   })\n})\n", "})\n"]}
{"filename": "tests/unit/getDynamicCssVars.test.ts", "chunked_list": ["import { getDynamicCssVars } from '../../src/getDynamicCssVars'\nimport { CSSVariables, RequireAtLeastOne, ValidArrayColors } from '../../src/internalTypes'\n\ndescribe('getDynamicCssVars returns only CSS vars that user actually needs', () => {\n   const Test1 = `If highlightOnlySelected is true and the current rating is 3,\nit should return an array of the same length containing active colors only at\nthe current rating index`\n\n   const activeColors1 = ['#c41400', '#d05e00', '#cca300', '#498d00', '#00724c']\n   const activeColors2 = ['#da1600', '#db711a', '#dcb000', '#61bb00', '#009664']", "   const activeColors1 = ['#c41400', '#d05e00', '#cca300', '#498d00', '#00724c']\n   const activeColors2 = ['#da1600', '#db711a', '#dcb000', '#61bb00', '#009664']\n\n   const sourceObject: RequireAtLeastOne<ValidArrayColors> = {\n      activeFillColor: activeColors1,\n      activeStrokeColor: activeColors2,\n      activeBoxColor: activeColors1,\n      activeBoxBorderColor: activeColors2,\n   }\n", "   }\n\n   const expectedColors: CSSVariables = {\n      '--rr--fill-on-color': '#cca300',\n      '--rr--stroke-on-color': '#dcb000',\n      '--rr--box-on-color': '#cca300',\n      '--rr--border-on-color': '#dcb000',\n   }\n\n   const expectedArray1: CSSVariables[] = [", "\n   const expectedArray1: CSSVariables[] = [\n      {},\n      {},\n      {\n         ...expectedColors,\n      },\n   ]\n\n   test(Test1, () => {", "\n   test(Test1, () => {\n      expect(getDynamicCssVars(sourceObject, 2, true)).toStrictEqual(expectedArray1)\n   })\n\n   const Test2 = `If highlightOnlySelected is false, it should always return an array of\nthe same length filled with the colors of the current selected rating index`\n\n   const expectedArray2: CSSVariables[] = [\n      {", "   const expectedArray2: CSSVariables[] = [\n      {\n         ...expectedColors,\n      },\n      {\n         ...expectedColors,\n      },\n      {\n         ...expectedColors,\n      },", "         ...expectedColors,\n      },\n   ]\n\n   test(Test2, () => {\n      expect(getDynamicCssVars(sourceObject, 2, false)).toStrictEqual(expectedArray2)\n   })\n})\n", ""]}
{"filename": "playwright/index.ts", "chunked_list": ["import '../src/styles/utils.css';\nimport '../src/styles/core.css';\nimport '../src/styles/colors.css';\nimport '../src/styles/transitions.css';\nimport '../src/styles/half-fill.css';\n"]}
{"filename": "src/getStaticClassNames.ts", "chunked_list": ["import { CSSClassName, MaybeEmptyClassName } from './internalTypes'\nimport {\n   Sizes,\n   TransitionProps,\n   TransitionClasses,\n   RadiusClasses,\n   GapClasses,\n   PaddingClasses,\n} from './constants'\n", "} from './constants'\n\nconst colorsWith = (transition: CSSClassName): CSSClassName =>\n   `${transition} ${TransitionClasses.COLORS}`\n\n/* c8 ignore start */\nexport function getTransitionClassNames(transitionProp: unknown): MaybeEmptyClassName {\n   switch (transitionProp) {\n      case TransitionProps.ZOOM:\n         return colorsWith(TransitionClasses.ZOOM)\n      case TransitionProps.POSITION:\n         return colorsWith(TransitionClasses.POSITION)\n      case TransitionProps.OPACITY:\n         return colorsWith(TransitionClasses.OPACITY)\n      case TransitionProps.COLORS:\n         return TransitionClasses.COLORS\n      default:\n         return ''\n   }\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */", "export function getRadiusClassName(radiusProp: unknown): MaybeEmptyClassName {\n   switch (radiusProp) {\n      case Sizes.SMALL:\n         return RadiusClasses.SMALL\n      case Sizes.MEDIUM:\n         return RadiusClasses.MEDIUM\n      case Sizes.LARGE:\n         return RadiusClasses.LARGE\n      case Sizes.FULL:\n         return RadiusClasses.FULL\n      default:\n         return ''\n   }\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */", "export function getGapClassName(gapProp: unknown): MaybeEmptyClassName {\n   switch (gapProp) {\n      case Sizes.SMALL:\n         return GapClasses.SMALL\n      case Sizes.MEDIUM:\n         return GapClasses.MEDIUM\n      case Sizes.LARGE:\n         return GapClasses.LARGE\n      default:\n         return ''\n   }\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */", "export function getPaddingClassName(paddingProp: unknown): MaybeEmptyClassName {\n   switch (paddingProp) {\n      case Sizes.SMALL:\n         return PaddingClasses.SMALL\n      case Sizes.MEDIUM:\n         return PaddingClasses.MEDIUM\n      case Sizes.LARGE:\n         return PaddingClasses.LARGE\n      default:\n         return ''\n   }\n}\n/* c8 ignore stop */\n"]}
{"filename": "src/exportedTypes.ts", "chunked_list": ["import {\n   CSSProperties,\n   ForwardRefExoticComponent,\n   RefAttributes,\n   Dispatch,\n   SetStateAction,\n} from 'react'\n\nexport type MaybeArrayColors = {\n   /** Active fill color of the SVG, it can be an array of colors in ascending order. */\n   activeFillColor?: string | string[]\n   /** Active stroke color of the SVG, it can be an array of colors in ascending order. */\n   activeStrokeColor?: string | string[]\n   /** Active background color of the SVG bounding box, it can be an array of colors in ascending order. */\n   activeBoxColor?: string | string[]\n   /** Active border color of the SVG bounding box, it can be an array of colors in ascending order. */\n   activeBoxBorderColor?: string | string[]\n}\n", "export type MaybeArrayColors = {\n   /** Active fill color of the SVG, it can be an array of colors in ascending order. */\n   activeFillColor?: string | string[]\n   /** Active stroke color of the SVG, it can be an array of colors in ascending order. */\n   activeStrokeColor?: string | string[]\n   /** Active background color of the SVG bounding box, it can be an array of colors in ascending order. */\n   activeBoxColor?: string | string[]\n   /** Active border color of the SVG bounding box, it can be an array of colors in ascending order. */\n   activeBoxBorderColor?: string | string[]\n}\n", "export type NonArrayColors = {\n   /** Inactive fill color of the SVG. */\n   inactiveFillColor?: string\n   /** Inactive stroke color of the SVG. */\n   inactiveStrokeColor?: string\n   /** Inactive background color of the SVG bounding box. */\n   inactiveBoxColor?: string\n   /** Inactive border color of the SVG bounding box. */\n   inactiveBoxBorderColor?: string\n}\n", "export type Colors = MaybeArrayColors & NonArrayColors\n\n/** Custom shapes and colors, visit https://github.com/smastrom/react-rating for more info. */\nexport type ItemStyles = Colors & {\n   /** JSX element to render the inner shapes of the SVG.\n    * Visit https://github.com/smastrom/react-rating#how-to-create-itemshapes-elements for more info. */\n   itemShapes: JSX.Element | JSX.Element[]\n   /** Stroke width of the SVG, expressed in viewBox user coordinate's unit size. */\n   itemStrokeWidth?: number\n   /** Border width of the SVG bounding box, expressed with an integer representing the pixels. */\n   boxBorderWidth?: number\n}\n", "export type Orientation = 'horizontal' | 'vertical'\nexport type Sizes = 'none' | 'small' | 'medium' | 'large' | 'full'\nexport type Spacings = Omit<Sizes, 'full'>\nexport type HF = 'svg' | 'box'\nexport type Transitions = 'none' | 'zoom' | 'position' | 'opacity' | 'colors'\n\nexport type SharedProps = {\n   /** An integer from 0 to items. It can be a float if readOnly is true. */\n   value: number\n   /** Number of rating items to display. */\n   items?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n   /** Whether or not to render an accessible image element. */\n   readOnly?: boolean\n   /** Whether or not to highlight only the selected rating item. */\n   highlightOnlySelected?: boolean\n   /** Orientation of the rating items. */\n   orientation?: Orientation\n   /** Responsive padding of each rating item. */\n   spaceInside?: Spacings\n   /** Responsive gap between rating items. */\n   spaceBetween?: Spacings\n   /** Radius of each rating item */\n   radius?: Sizes\n   /** Custom shapes and colors, visit https://github.com/smastrom/react-rating for more info. */\n   itemStyles?: ItemStyles\n   id?: string\n   className?: string\n   style?: CSSProperties\n}\n", "export type ReadOnlyProps = {\n   /** Whether to half-fill the SVG or the box. */\n   halfFillMode?: HF\n}\n\nexport type RatingChange =\n   | Dispatch<SetStateAction<number>>\n   | ((selectedValue: number) => void | Promise<void>)\n\nexport type HoverChange = (hoveredValue: number) => void | (() => void)\ntype FocusEvent = (event?: FocusEvent) => void\n", "export type HoverChange = (hoveredValue: number) => void | (() => void)\ntype FocusEvent = (event?: FocusEvent) => void\n\nexport type InputProps = {\n   /** Setter or custom callback to update the rating. */\n   onChange?: RatingChange\n   /** Callback to execute when entering/leaving the rating items. */\n   onHoverChange?: HoverChange\n   onBlur?: FocusEvent\n   onFocus?: FocusEvent\n   /** Whether or not to disable the radio group. */\n   isDisabled?: boolean\n   /**\n    * @deprecated Since version 1.2.0. Please use isRequired prop instead.\n    */\n   resetOnSecondClick?: boolean\n   /** Transition to apply when hovering/selecting. */\n   transition?: Transitions\n   /** Whether or not to tell assistive technologies that rating is required. */\n   isRequired?: boolean\n   /** Accessible label of the rating group / image. */\n   invisibleLabel?: string\n   /** Accessible labels of each each rating item. */\n   invisibleItemLabels?: string[]\n   /** Id of the element used as rating group label. Takes precedence over invisibleLabel. */\n   visibleLabelId?: string\n   /** Ids of the elements used as labels for each rating item. Takes precedence over invisibleItemLabels. */\n   visibleItemLabelIds?: string[]\n   /** Accessible label for the invisible reset radio. Effective if `isRequired` is set to **false**. */\n   resetLabel?: string\n}\n", "export type RatingProps = SharedProps & ReadOnlyProps & InputProps\n\nexport declare const Rating: ForwardRefExoticComponent<RatingProps & RefAttributes<HTMLDivElement>>\n\nexport declare const Star: JSX.Element\nexport declare const ThinStar: JSX.Element\nexport declare const RoundedStar: JSX.Element\nexport declare const ThinRoundedStar: JSX.Element\nexport declare const StickerStar: JSX.Element\nexport declare const Heart: JSX.Element\n"]}
{"filename": "src/setColorCssVars.ts", "chunked_list": ["import { CSSVariables } from './internalTypes'\nimport { ActiveColorProps, InactiveColorProps, ActiveVars, InactiveVars } from './constants'\n\n/* c8 ignore next */\nexport function setDyamicCssVars(targetObj: CSSVariables, key: string, value: string) {\n   switch (key) {\n      case ActiveColorProps.FILL:\n         targetObj[ActiveVars.FILL] = value\n         return true\n      case ActiveColorProps.BOX:\n         targetObj[ActiveVars.BOX] = value\n         return true\n      case ActiveColorProps.BORDER:\n         targetObj[ActiveVars.BORDER] = value\n         return true\n      case ActiveColorProps.STROKE:\n         targetObj[ActiveVars.STROKE] = value\n         return true\n   }\n   return false\n}\n\n/* c8 ignore next */", "export function setColorCssVars(targetObj: CSSVariables, key: string, value: string) {\n   const isActive = setDyamicCssVars(targetObj, key, value)\n   if (!isActive) {\n      switch (key) {\n         case InactiveColorProps.FILL:\n            targetObj[InactiveVars.FILL] = value\n            break\n         case InactiveColorProps.BOX:\n            targetObj[InactiveVars.BOX] = value\n            break\n         case InactiveColorProps.BORDER:\n            targetObj[InactiveVars.BORDER] = value\n            break\n         case InactiveColorProps.STROKE:\n            targetObj[InactiveVars.STROKE] = value\n            break\n      }\n   }\n}\n"]}
{"filename": "src/getStaticCssVars.ts", "chunked_list": ["import { setColorCssVars } from './setColorCssVars'\nimport { ItemStyles } from './exportedTypes'\nimport { CSSVariables, StaticColors } from './internalTypes'\nimport { ItemVars } from './constants'\nimport { isPositiveNum } from './utils'\n\nexport function getStaticCssVars(\n   staticColors: StaticColors,\n   boxBorderWidth: NonNullable<ItemStyles['boxBorderWidth']>\n): CSSVariables {\n   const cssVars: CSSVariables = {}\n", "   if (isPositiveNum(boxBorderWidth)) {\n      cssVars[ItemVars.BORDER_WIDTH] = `${boxBorderWidth}px`\n   }\n\n   const colorsEntries = Object.entries(staticColors)\n\n   if (colorsEntries.length > 0) {\n      for (const [key, value] of colorsEntries) {\n         setColorCssVars(cssVars, key, value)\n      }\n   }\n\n   return cssVars\n}\n"]}
{"filename": "src/getDynamicCssVars.ts", "chunked_list": ["import { setDyamicCssVars } from './setColorCssVars'\nimport { NonNullProp, CSSVariables, RequireAtLeastOne, ValidArrayColors } from './internalTypes'\n\nexport function getDynamicCssVars(\n   arrayColors: RequireAtLeastOne<ValidArrayColors>,\n   starIndex: number,\n   highlightOnlySelected: NonNullProp<'highlightOnlySelected'>\n): CSSVariables[] {\n   const arrayStylesVars: CSSVariables = {}\n   let cssVars: CSSVariables[]\n", "   for (const [key, color] of Object.entries(arrayColors)) {\n      setDyamicCssVars(arrayStylesVars, key, color[starIndex])\n   }\n\n   if (highlightOnlySelected) {\n      cssVars = Array(starIndex).fill({})\n      cssVars.push(arrayStylesVars)\n   } else {\n      cssVars = Array(starIndex + 1).fill(arrayStylesVars)\n   }\n\n   return cssVars\n}\n"]}
{"filename": "src/getColors.ts", "chunked_list": ["import { Colors } from './exportedTypes'\nimport { StaticColors, ValidArrayColors } from './internalTypes'\nimport { ActiveColorProps } from './constants'\n\nconst validArrayColorKeys: (keyof ValidArrayColors)[] = [\n   ActiveColorProps.FILL,\n   ActiveColorProps.BOX,\n   ActiveColorProps.STROKE,\n   ActiveColorProps.BORDER,\n]", "   ActiveColorProps.BORDER,\n]\n\nexport function getColors(colorsObj: Colors | object) {\n   const allColors = { ...colorsObj }\n   const arrayColors: ValidArrayColors = {}\n\n   const colorsEntries = Object.entries(allColors)\n\n   if (colorsEntries.length > 0) {\n      for (const [key, value] of colorsEntries) {", "   if (colorsEntries.length > 0) {\n      for (const [key, value] of colorsEntries) {\n         if (!Array.isArray(value) && typeof value !== 'string') {\n            delete allColors[key as keyof typeof allColors]\n         } else if (Array.isArray(value)) {\n            for (const validKey of validArrayColorKeys) {\n               if (validKey === key) {\n                  const cleanedArrayColors = value.filter((color) => typeof color === 'string')\n                  if (cleanedArrayColors.length > 0) {\n                     arrayColors[key] = cleanedArrayColors\n                     delete allColors[key]\n                  }\n               } else {\n                  delete allColors[key as keyof typeof allColors]\n               }\n            }\n         }\n      }\n   }\n\n   return { arrayColors, staticColors: allColors as StaticColors }\n}\n", "                  if (cleanedArrayColors.length > 0) {\n                     arrayColors[key] = cleanedArrayColors\n                     delete allColors[key]\n                  }\n               } else {\n                  delete allColors[key as keyof typeof allColors]\n               }\n            }\n         }\n      }\n   }\n\n   return { arrayColors, staticColors: allColors as StaticColors }\n}\n"]}
{"filename": "src/internalTypes.ts", "chunked_list": ["import { ItemStyles, MaybeArrayColors, NonArrayColors, RatingProps } from './exportedTypes'\n\ntype CSSPrefix = 'rr'\n\nexport type CSSVariable = `--${CSSPrefix}--${string}`\n\nexport type CSSVariables = {\n   [key: CSSVariable]: string\n}\n\nexport type CSSClassName = `${CSSPrefix}--${string}`\n", "export type CSSClassName = `${CSSPrefix}--${string}`\n\nexport type TagID = `${CSSPrefix}_${string}`\n\nexport type MaybeEmptyClassName = CSSClassName | ''\n\ntype Colors<T> = {\n   [key in keyof MaybeArrayColors]: T\n}\n\nexport type ActiveColorsStrings = Colors<string>\n", "export type ActiveColorsStrings = Colors<string>\n\nexport type ValidArrayColors = Colors<string[]>\n\nexport type StaticColors = NonArrayColors & ActiveColorsStrings\n\nexport type RequireAtLeastOne<T> = {\n   [K in keyof T]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<keyof T, K>>>\n}[keyof T]\n\nexport type TabIndex = -1 | 0\n", "export type TabIndex = -1 | 0\n\nexport type RatingItemProps = NonNullable<Pick<ItemStyles, 'itemShapes'>> & {\n   itemStrokeWidth: NonNullable<ItemStyles['itemStrokeWidth']>\n   orientation: NonNullProp<'orientation'>\n   hasHF: boolean\n   testId?: object\n}\n\nexport type StylesState = {\n   staticCssVars: CSSVariables\n   dynamicCssVars: CSSVariables[]\n   dynamicClassNames: CSSClassName[]\n}\n", "export type StylesState = {\n   staticCssVars: CSSVariables\n   dynamicCssVars: CSSVariables[]\n   dynamicClassNames: CSSClassName[]\n}\n\nexport type SvgData = {\n   viewBox: string\n   translateData: string\n}\n", "export type NonNullProp<K extends keyof RatingProps> = NonNullable<RatingProps[`${K}`]>\n\nexport type HTMLProps = React.HTMLProps<HTMLDivElement>\nexport type MouseEvent = React.MouseEvent<HTMLDivElement>\nexport type FocusEvent = React.FocusEvent<HTMLDivElement>\nexport type MutableRef = React.MutableRefObject<HTMLDivElement | null>\n"]}
{"filename": "src/defaultItemStyles.ts", "chunked_list": ["import { Star } from './Shapes'\nimport { ItemStyles } from './exportedTypes'\n\nexport const defaultItemStyles: ItemStyles = {\n   itemShapes: Star,\n   itemStrokeWidth: 2,\n   activeFillColor: '#ffb23f',\n   inactiveFillColor: '#fff7ed',\n   activeStrokeColor: '#e17b21',\n   inactiveStrokeColor: '#eda76a',", "   activeStrokeColor: '#e17b21',\n   inactiveStrokeColor: '#eda76a',\n}\n"]}
{"filename": "src/getErrors.ts", "chunked_list": ["import { isValidElement } from 'react'\nimport { ItemStyles, RatingProps } from './exportedTypes'\nimport Package from '../package.json'\n\ntype ErrorObj = {\n   shouldRender: boolean\n   reason: string\n}\n\nconst getErrorReason = (reason: string) =>\n   `[${Package.name}] - Nothing's returned from rendering. Reason: ${reason}.`\n", "function setErrors(targetObj: ErrorObj, reason: string) {\n   targetObj.shouldRender = false\n   targetObj.reason = getErrorReason(reason)\n\n   return targetObj\n}\n\nconst invalidJSXMsg = 'itemShapes is not a valid JSX element'\n\ntype Props = Pick<RatingProps, 'items'> & Pick<ItemStyles, 'itemShapes'>\n", "type Props = Pick<RatingProps, 'items'> & Pick<ItemStyles, 'itemShapes'>\n\ntype ParamObj = Required<{\n   [Prop in keyof Props]: unknown\n}>\n\nexport function getErrors({ items, itemShapes }: ParamObj) {\n   const errorsObj: ErrorObj = { shouldRender: true, reason: '' }\n\n   if (typeof items !== 'number' || items < 1 || items > 10) {\n      return setErrors(errorsObj, 'items is invalid')\n   }\n", "   if (typeof items !== 'number' || items < 1 || items > 10) {\n      return setErrors(errorsObj, 'items is invalid')\n   }\n\n   if (!itemShapes) {\n      return setErrors(errorsObj, 'itemStyles needs at least the property itemShapes set')\n   }\n   if (!Array.isArray(itemShapes) && !isValidElement(itemShapes as object | null | undefined)) {\n      return setErrors(errorsObj, invalidJSXMsg)\n   }\n", "   if (Array.isArray(itemShapes)) {\n      if (itemShapes.length !== items) {\n         return setErrors(errorsObj, 'itemShapes length mismatch')\n      }\n      const areValid = (itemShapes as (object | null | undefined)[]).every((svgChildNode) =>\n         isValidElement(svgChildNode)\n      )\n      if (!areValid) {\n         return setErrors(errorsObj, invalidJSXMsg)\n      }\n   }\n\n   return errorsObj\n}\n"]}
{"filename": "src/constants.ts", "chunked_list": ["import { CSSClassName, CSSVariable } from './internalTypes'\nimport {\n   Orientation,\n   HF,\n   Sizes as SizesT,\n   Transitions,\n   MaybeArrayColors,\n   NonArrayColors,\n} from './exportedTypes'\n", "} from './exportedTypes'\n\n/* ClassNames */\n\ntype Classes = {\n   [key: string]: CSSClassName\n}\n\nexport const RatingClasses: Classes = {\n   GROUP: 'rr--group',\n   BOX: 'rr--box',\n   SVG: 'rr--svg',\n   RESET: 'rr--reset',\n   GROUP_RESET: 'rr--focus-reset',\n   DEF_50: 'rr--svg-stop-1',\n   DEF_100: 'rr--svg-stop-2',\n}\n\nexport const ActiveClassNames: Classes = {\n   ON: 'rr--on',\n   OFF: 'rr--off',\n}\n\nexport const TransitionClasses: Classes = {\n   ZOOM: 'rr--fx-zoom',\n   POSITION: 'rr--fx-position',\n   OPACITY: 'rr--fx-opacity',\n   COLORS: 'rr--fx-colors',\n}\n\nexport const RadiusClasses: Classes = {\n   SMALL: 'rr--rx-sm',\n   MEDIUM: 'rr--rx-md',\n   LARGE: 'rr--rx-lg',\n   FULL: 'rr--rx-full',\n}\n\nexport const GapClasses: Classes = {\n   SMALL: 'rr--gap-sm',\n   MEDIUM: 'rr--gap-md',\n   LARGE: 'rr--gap-lg',\n}\n\nexport const PaddingClasses: Classes = {\n   SMALL: 'rr--space-sm',\n   MEDIUM: 'rr--space-md',\n   LARGE: 'rr--space-lg',\n}\n\nexport const CursorClasses: Classes = {\n   POINTER: 'rr--pointer',\n   DISABLED: 'rr--disabled',\n}\n\nexport const OrientationClasses: Classes = {\n   VERTICAL: 'rr--dir-y',\n   HORIZONTAL: 'rr--dir-x',\n}\n\nexport const HasClasses: Classes = {\n   STROKE: 'rr--has-stroke',\n   BORDER: 'rr--has-border',\n}\n\nexport const HFClasses: Classes = {\n   BOX_ON: 'rr--hf-box-on',\n   BOX_INT: 'rr--hf-box-int',\n   BOX_OFF: 'rr--hf-box-off',\n   SVG_ON: 'rr--hf-svg-on',\n   SVG_OFF: 'rr--hf-svg-off',\n}\n\n/* Variables */\n", "type Variables = {\n   [key: string]: CSSVariable\n}\n\nexport const ActiveVars: Variables = {\n   FILL: '--rr--fill-on-color',\n   BOX: '--rr--box-on-color',\n   BORDER: '--rr--border-on-color',\n   STROKE: '--rr--stroke-on-color',\n}\n\nexport const InactiveVars: Variables = {\n   FILL: '--rr--fill-off-color',\n   BOX: '--rr--box-off-color',\n   BORDER: '--rr--border-off-color',\n   STROKE: '--rr--stroke-off-color',\n}\n\nexport const ItemVars: Variables = {\n   BORDER_WIDTH: '--rr--border-width',\n}\n\n/* Props */\n", "type ValuesFromUnion<T> = {\n   [key: string]: T\n}\n\nexport const OrientationProps: ValuesFromUnion<Orientation> = {\n   HORIZONTAL: 'horizontal',\n   VERTICAL: 'vertical',\n}\n\nexport const HFProps: ValuesFromUnion<HF> = {\n   SVG: 'svg',\n   BOX: 'box',\n}\n\nexport const Sizes: ValuesFromUnion<SizesT> = {\n   NONE: 'none',\n   SMALL: 'small',\n   MEDIUM: 'medium',\n   LARGE: 'large',\n   FULL: 'full',\n}\n\nexport const TransitionProps: ValuesFromUnion<Transitions> = {\n   NONE: 'none',\n   ZOOM: 'zoom',\n   POSITION: 'position',\n   OPACITY: 'opacity',\n   COLORS: 'colors',\n}\n\n/* Color Props */\n", "type ValuesFromKeys<T> = {\n   [key: string]: keyof T\n}\n\nexport const ActiveColorProps: ValuesFromKeys<MaybeArrayColors> = {\n   FILL: 'activeFillColor',\n   BOX: 'activeBoxColor',\n   BORDER: 'activeBoxBorderColor',\n   STROKE: 'activeStrokeColor',\n}\n\nexport const InactiveColorProps: ValuesFromKeys<NonArrayColors> = {\n   FILL: 'inactiveFillColor',\n   BOX: 'inactiveBoxColor',\n   BORDER: 'inactiveBoxBorderColor',\n   STROKE: 'inactiveStrokeColor',\n}\n"]}
{"filename": "src/getTabIndex.ts", "chunked_list": ["import { TabIndex } from './internalTypes'\n\nexport function getTabIndex(items: number, selectedIndex: number, hasReset = false): TabIndex[] {\n   return Array.from({ length: items }, (_, index) => {\n      if (hasReset && selectedIndex < 0) {\n         if (index === items - 1) {\n            return 0\n         }\n         return -1\n      }\n      if (selectedIndex <= 0) {", "      if (selectedIndex <= 0) {\n         if (index === 0) {\n            return 0\n         }\n         return -1\n      }\n      if (selectedIndex > 0) {\n         if (index === selectedIndex) {\n            return 0\n         }\n         return -1\n      }\n   }) as TabIndex[]\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { useEffect, useLayoutEffect } from 'react'\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\nexport const noop = (number?: number) => {}\n\nexport const isSSR = typeof window === 'undefined'\n\n/* c8 ignore next */\nexport const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect\n", "export const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect\n\nexport const isPositiveNum = (value: unknown) => typeof value === 'number' && value > 0\n\nexport const getNumber = (value: unknown) => (isPositiveNum(value) ? (value as number) : 0)\n\nexport const toSecondDecimal = (number: number) => Math.round(number * 100) / 100\n\nexport const roundToHalf = (number: number) => Math.round(number * 2) / 2\n", "export const roundToHalf = (number: number) => Math.round(number * 2) / 2\n\nexport const getUniqueId = () => (Math.random() + 1).toString(36).substring(7)\n\nexport const areNum = (...values: unknown[]) => values.every((value) => typeof value === 'number')\n\nexport const getNewPosition = (originalPos: number) =>\n   originalPos === 0 ? 0 : toSecondDecimal(originalPos) * -1\n\nexport const isGraphicalValueInteger = (ratingValue: number) =>", "\nexport const isGraphicalValueInteger = (ratingValue: number) =>\n   Number.isInteger(roundToHalf(ratingValue))\n\nexport function getIntersectionIndex(ratingValues: number[], ratingValue: number) {\n   const roundedHalf = roundToHalf(ratingValue)\n\n   if (Number.isInteger(roundedHalf)) {\n      return ratingValues.indexOf(roundedHalf)\n   }\n   return Math.floor(roundedHalf)\n}\n", "export function isRTLDir(rootElem: HTMLElement) {\n   if (rootElem) {\n      const userDir = getComputedStyle(rootElem).getPropertyValue('direction')\n      return userDir === 'rtl'\n   }\n   return false\n}\n\n/* c8 ignore next */\nexport const devTestId = __DEV__ ? { 'data-testid': 'rating' } : {}\n\n/* c8 ignore next */", "export function getResetTestId() {\n   if (__DEV__) {\n      return { 'data-testid': `rating-reset` }\n   } /* c8 ignore next */\n   return {}\n}\n\n/* c8 ignore next */\nexport function getRadioTestIds(childIndex: number) {\n   if (__DEV__) {\n      return { 'data-testid': `rating-child-${childIndex + 1}` }\n   } /* c8 ignore next */\n   return {}\n}\n\n/* c8 ignore next */", "export function getRadioTestIds(childIndex: number) {\n   if (__DEV__) {\n      return { 'data-testid': `rating-child-${childIndex + 1}` }\n   } /* c8 ignore next */\n   return {}\n}\n\n/* c8 ignore next */\nexport function getSvgTestIds(childIndex: number) {\n   if (__DEV__) {\n      return {\n         'data-testid': `rating-child-svg-${childIndex + 1}`,\n      }\n   } /* c8 ignore next */\n   return {}\n}\n\n/* c8 ignore next */", "export function getSvgTestIds(childIndex: number) {\n   if (__DEV__) {\n      return {\n         'data-testid': `rating-child-svg-${childIndex + 1}`,\n      }\n   } /* c8 ignore next */\n   return {}\n}\n\n/* c8 ignore next */\nexport function getDefsTestId() {", "export function getDefsTestId() {\n   if (__DEV__) {\n      return {\n         'data-testid': 'svg-defs-testid',\n      }\n   } /* c8 ignore next */\n   return {}\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import './styles/core.css'\nimport './styles/utils.css'\nimport './styles/colors.css'\nimport './styles/transitions.css'\nimport './styles/half-fill.css'\n\nexport { Rating } from './Rating'\nexport { Star, ThinStar, RoundedStar, ThinRoundedStar, StickerStar, Heart } from './Shapes'\n", ""]}
{"filename": "src/getGroupClassNames.ts", "chunked_list": ["import { RatingProps } from './exportedTypes'\nimport {\n   getGapClassName,\n   getPaddingClassName,\n   getRadiusClassName,\n   getTransitionClassNames,\n} from './getStaticClassNames'\nimport { CSSClassName, MaybeEmptyClassName } from './internalTypes'\nimport {\n   CursorClasses,", "import {\n   CursorClasses,\n   OrientationClasses,\n   HasClasses,\n   RatingClasses,\n   OrientationProps,\n   TransitionProps,\n} from './constants'\n\ntype ParamObj = Required<\n   Pick<\n      RatingProps,\n      | 'className'\n      | 'radius'\n      | 'readOnly'\n      | 'isDisabled'\n      | 'transition'\n      | 'orientation'\n      | 'spaceBetween'\n      | 'spaceInside'\n   >\n> & {\n   isDynamic: boolean\n   absoluteBoxBorderWidth: number\n   absoluteStrokeWidth: number\n}\n", "\ntype ParamObj = Required<\n   Pick<\n      RatingProps,\n      | 'className'\n      | 'radius'\n      | 'readOnly'\n      | 'isDisabled'\n      | 'transition'\n      | 'orientation'\n      | 'spaceBetween'\n      | 'spaceInside'\n   >\n> & {\n   isDynamic: boolean\n   absoluteBoxBorderWidth: number\n   absoluteStrokeWidth: number\n}\n", "export function getGroupClassNames({\n   className,\n   radius,\n   readOnly,\n   isDisabled,\n   isDynamic,\n   transition,\n   orientation,\n   absoluteBoxBorderWidth,\n   absoluteStrokeWidth,\n   spaceBetween,\n   spaceInside,\n}: ParamObj) {\n   const cursorClassName: MaybeEmptyClassName = isDynamic ? CursorClasses.POINTER : ''\n   const gapClassName = getGapClassName(spaceBetween)\n   const paddingClassName = getPaddingClassName(spaceInside)\n   const disabledClassName: MaybeEmptyClassName =\n      !readOnly && isDisabled ? CursorClasses.DISABLED : ''\n   const transitionClassName =\n      isDynamic && transition !== TransitionProps.NONE ? getTransitionClassNames(transition) : ''\n   const orientationClassName: CSSClassName =\n      orientation === OrientationProps.VERTICAL\n         ? OrientationClasses.VERTICAL\n         : OrientationClasses.HORIZONTAL\n   const radiusClassName = getRadiusClassName(radius)\n   const borderClassName: MaybeEmptyClassName = absoluteBoxBorderWidth > 0 ? HasClasses.BORDER : ''\n   const strokeClassName: MaybeEmptyClassName = absoluteStrokeWidth > 0 ? HasClasses.STROKE : ''\n\n   return `${RatingClasses.GROUP} ${orientationClassName} ${strokeClassName} ${borderClassName}\n${transitionClassName} ${radiusClassName} ${cursorClassName} ${disabledClassName} ${gapClassName}\n${paddingClassName} ${className}`\n      .replace(/  +/g, ' ')\n      .trimEnd()\n}\n"]}
{"filename": "src/getActiveClassNames.ts", "chunked_list": ["import { NonNullProp, CSSClassName } from './internalTypes'\nimport { ActiveClassNames } from './constants'\n\nexport function getActiveClassNames(\n   highlightOnlySelectedProp: NonNullProp<'highlightOnlySelected'>,\n   items: NonNullProp<'items'>,\n   selectedIndex: number\n): CSSClassName[] {\n   return Array.from({ length: items }, (_, index) => {\n      if (!highlightOnlySelectedProp) {\n         if (index <= selectedIndex) {\n            return ActiveClassNames.ON\n         }\n         return ActiveClassNames.OFF\n      }", "      if (!highlightOnlySelectedProp) {\n         if (index <= selectedIndex) {\n            return ActiveClassNames.ON\n         }\n         return ActiveClassNames.OFF\n      }\n      if (index === selectedIndex) {\n         return ActiveClassNames.ON\n      }\n      return ActiveClassNames.OFF\n   })\n}\n"]}
{"filename": "src/getHFClassNames.ts", "chunked_list": ["import { roundToHalf } from './utils'\nimport { NonNullProp, CSSClassName } from './internalTypes'\nimport { HFClasses } from './constants'\n\nexport function getHFClassNames(\n   ratingValue: NonNullProp<'value'>,\n   items: NonNullProp<'items'>,\n   absoluteHFMode: NonNullProp<'halfFillMode'>\n): CSSClassName[] {\n   const intersectionIndex = Math.floor(roundToHalf(ratingValue))\n\n   return Array.from({ length: items }, (_, index) => {", "      if (absoluteHFMode === 'box') {\n         if (index > intersectionIndex) {\n            return HFClasses.BOX_OFF\n         }\n         if (index === intersectionIndex) {\n            return HFClasses.BOX_INT\n         }\n         return HFClasses.BOX_ON\n      }\n      if (index > intersectionIndex) {\n         return HFClasses.SVG_OFF\n      }\n      return HFClasses.SVG_ON\n   })\n}\n", "      if (index > intersectionIndex) {\n         return HFClasses.SVG_OFF\n      }\n      return HFClasses.SVG_ON\n   })\n}\n"]}
