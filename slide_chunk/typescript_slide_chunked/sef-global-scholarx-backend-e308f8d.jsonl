{"filename": "jest.config.ts", "chunked_list": ["export default {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  modulePathIgnorePatterns: ['<rootDir>/dist/']\n}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import express from 'express'\nimport type { Express } from 'express'\nimport bodyParser from 'body-parser'\nimport cors from 'cors'\nimport { dataSource } from './configs/dbConfig'\nimport authRouter from './routes/auth/auth.route'\nimport profileRouter from './routes/profile/profile.route'\nimport passport from 'passport'\nimport './configs/passport'\nimport cookieParser from 'cookie-parser'", "import './configs/passport'\nimport cookieParser from 'cookie-parser'\n\nconst app = express()\n\napp.use(cookieParser())\napp.use(bodyParser.json())\napp.use(cors())\napp.use(passport.initialize())\n", "app.use(passport.initialize())\n\napp.get('/', (req, res) => {\n  res.send('ScholarX Backend')\n})\n\napp.use('/api/auth', authRouter)\napp.use('/api/me', profileRouter)\n\nexport const startServer = async (port: number): Promise<Express> => {\n  try {\n    await dataSource.initialize()\n    console.log('DB connection is successful')\n    app.listen(port, () => {\n      console.log(`Server is running on http://localhost:${port}`)\n    })\n\n    return app", "\nexport const startServer = async (port: number): Promise<Express> => {\n  try {\n    await dataSource.initialize()\n    console.log('DB connection is successful')\n    app.listen(port, () => {\n      console.log(`Server is running on http://localhost:${port}`)\n    })\n\n    return app\n  } catch (err) {\n    console.log('DB connection was not successful', err)\n    throw err\n  }\n}\n\nexport default startServer\n", "  } catch (err) {\n    console.log('DB connection was not successful', err)\n    throw err\n  }\n}\n\nexport default startServer\n"]}
{"filename": "src/types.ts", "chunked_list": ["interface Option {\n  // todo: To be determined (Not final)\n  answer: string\n}\n\ninterface Question {\n  question: string\n  answer: string\n  // todo: Types should be declared here (Not final)\n  type: 'TYPES'\n  options: Option\n}\n", "export interface MenteeApplication {\n  answers: Question[]\n  state: string\n  mentor_id: bigint\n}\n"]}
{"filename": "src/server.ts", "chunked_list": ["import startServer from './app'\nimport { SERVER_PORT } from './configs/envConfig'\n\nconst port = SERVER_PORT as number\n\nasync function start(): Promise<void> {\n  try {\n    await startServer(port)\n    console.log('Server started!')\n  } catch (err) {\n    console.error('Something went wrong!', err)\n  }\n}\n", "  } catch (err) {\n    console.error('Something went wrong!', err)\n  }\n}\n\nstart().catch((err) => {\n  console.error(err)\n})\n"]}
{"filename": "src/configs/envConfig.ts", "chunked_list": ["import dotenv from 'dotenv'\n\ndotenv.config()\n\nexport const DB_USER = process.env.DB_USER\nexport const DB_HOST = process.env.DB_HOST\nexport const DB_NAME = process.env.DB_NAME\nexport const DB_PASSWORD = process.env.DB_PASSWORD\nexport const DB_PORT = process.env.DB_PORT\nexport const SERVER_PORT = process.env.SERVER_PORT ?? 3000", "export const DB_PORT = process.env.DB_PORT\nexport const SERVER_PORT = process.env.SERVER_PORT ?? 3000\nexport const JWT_SECRET = process.env.JWT_SECRET ?? ''\n"]}
{"filename": "src/configs/db.test.ts", "chunked_list": ["import { dataSource } from './dbConfig'\n\nexport const initConnection = async (): Promise<void> => {\n  await dataSource\n    .initialize()\n    .then(() => {\n      console.log('Data Source has been initialized!')\n    })\n    .catch((err) => {\n      console.error('Error during Data Source initialization:', err)\n      throw new Error('Data Source initialization failed')\n    })\n}\n\ndescribe('typeorm connection', () => {\n  it('should test typeorm connection', async () => {\n    await expect(initConnection()).resolves.not.toThrow()\n  })\n})\n", "    .catch((err) => {\n      console.error('Error during Data Source initialization:', err)\n      throw new Error('Data Source initialization failed')\n    })\n}\n\ndescribe('typeorm connection', () => {\n  it('should test typeorm connection', async () => {\n    await expect(initConnection()).resolves.not.toThrow()\n  })\n})\n"]}
{"filename": "src/configs/dbConfig.ts", "chunked_list": ["import { DataSource } from 'typeorm'\nimport { DB_PASSWORD, DB_HOST, DB_PORT, DB_USER, DB_NAME } from './envConfig'\n\nexport const dataSource = new DataSource({\n  type: 'postgres',\n  host: DB_HOST,\n  port: Number(DB_PORT) ?? 5432,\n  username: DB_USER,\n  password: DB_PASSWORD,\n  database: DB_NAME,", "  password: DB_PASSWORD,\n  database: DB_NAME,\n  entities: ['src/entities/*.ts'],\n  logging: false,\n  synchronize: true\n})\n"]}
{"filename": "src/configs/passport.ts", "chunked_list": ["import passport from 'passport'\nimport { Strategy as JwtStrategy } from 'passport-jwt'\nimport { dataSource } from './dbConfig'\nimport Profile from '../entities/profile.entity'\nimport { JWT_SECRET } from './envConfig'\nimport type { Request } from 'express'\n\nconst cookieExtractor = (req: Request): string => {\n  let token = null\n  if (req?.cookies) {\n    token = req.cookies.jwt\n  }\n  return token\n}\n\nconst options = {\n  jwtFromRequest: cookieExtractor,\n  secretOrKey: JWT_SECRET\n}\n\npassport.use(\n  new JwtStrategy(options, async (jwtPayload, done) => {", "  let token = null\n  if (req?.cookies) {\n    token = req.cookies.jwt\n  }\n  return token\n}\n\nconst options = {\n  jwtFromRequest: cookieExtractor,\n  secretOrKey: JWT_SECRET\n}\n\npassport.use(\n  new JwtStrategy(options, async (jwtPayload, done) => {", "    try {\n      const profileRepository = dataSource.getRepository(Profile)\n      const profile = await profileRepository.findOne({\n        where: { uuid: jwtPayload.userId }\n      })\n\n      if (!profile) {\n        done(null, false)\n      } else {\n        done(null, profile)\n      }", "    } catch (error) {\n      done(error, false)\n    }\n  })\n)\n\nexport default passport\n"]}
{"filename": "src/enums/index.ts", "chunked_list": ["export enum ProfileTypes {\n  DEFAULT = 'default',\n  ADMIN = 'admin'\n}\n\nexport enum EmailStatusTypes {\n  SENT = 'sent',\n  DELIVERED = 'delivered',\n  FAILED = 'failed'\n}\n", "export enum ApplicationStatus {\n  PENDING = 'pending',\n  REJECTED = 'rejected',\n  ACCEPTED = 'accepted'\n}\n"]}
{"filename": "src/services/profile.service.ts", "chunked_list": ["import { dataSource } from '../configs/dbConfig'\nimport Profile from '../entities/profile.entity'\n\nexport const updateProfile = async (\n  user: Profile,\n  {\n    primary_email,\n    contact_email,\n    first_name,\n    last_name,", "    first_name,\n    last_name,\n    image_url,\n    linkedin_url\n  }: Partial<Profile>\n): Promise<{\n  statusCode: number\n  profile?: Profile | null\n  message: string\n}> => {\n  try {\n    const profileRepository = dataSource.getRepository(Profile)\n\n    await profileRepository.update(\n      { uuid: user.uuid },\n      {\n        primary_email,\n        contact_email,\n        first_name,\n        last_name,\n        image_url,\n        linkedin_url\n      }\n    )\n\n    const savedProfile = await profileRepository.findOneBy({\n      uuid: user.uuid\n    })\n\n    return {\n      statusCode: 200,\n      profile: savedProfile,\n      message: 'Successfully updated the profile'\n    }", "  message: string\n}> => {\n  try {\n    const profileRepository = dataSource.getRepository(Profile)\n\n    await profileRepository.update(\n      { uuid: user.uuid },\n      {\n        primary_email,\n        contact_email,\n        first_name,\n        last_name,\n        image_url,\n        linkedin_url\n      }\n    )\n\n    const savedProfile = await profileRepository.findOneBy({\n      uuid: user.uuid\n    })\n\n    return {\n      statusCode: 200,\n      profile: savedProfile,\n      message: 'Successfully updated the profile'\n    }", "  } catch (error) {\n    console.error('Error executing login', error)\n    return { statusCode: 500, message: 'Internal server error' }\n  }\n}\n"]}
{"filename": "src/services/auth.service.ts", "chunked_list": ["import { dataSource } from '../configs/dbConfig'\nimport bcrypt from 'bcrypt'\nimport jwt from 'jsonwebtoken'\nimport Profile from '../entities/profile.entity'\nimport { JWT_SECRET } from '../configs/envConfig'\n\nexport const registerUser = async (\n  email: string,\n  password: string\n): Promise<{", "  password: string\n): Promise<{\n  statusCode: number\n  message: string\n  profile?: Profile | null\n}> => {\n  try {\n    const profileRepository = dataSource.getRepository(Profile)\n\n    const existingProfile = await profileRepository.findOne({\n      where: { primary_email: email }\n    })\n", "    if (existingProfile != null) {\n      return { statusCode: 409, message: 'Email already exists' }\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10)\n    const newProfile = profileRepository.create({\n      primary_email: email,\n      password: hashedPassword,\n      contact_email: '',\n      first_name: '',\n      last_name: '',\n      image_url: '',\n      linkedin_url: ''\n    })\n\n    await profileRepository.save(newProfile)\n\n    const savedProfile = await profileRepository.findOne({\n      where: { primary_email: email }\n    })\n\n    return {\n      statusCode: 201,\n      message: 'Registration successful',\n      profile: savedProfile\n    }", "  } catch (error) {\n    console.error('Error executing registration', error)\n    return { statusCode: 500, message: 'Internal server error' }\n  }\n}\n\nexport const loginUser = async (\n  email: string,\n  password: string\n): Promise<{ statusCode: number; message: string; token?: string }> => {\n  try {\n    const profileRepository = dataSource.getRepository(Profile)\n    const profile = await profileRepository\n      .createQueryBuilder('profile')\n      .addSelect('profile.password')\n      .where({ primary_email: email })\n      .getOne()\n", "  try {\n    const profileRepository = dataSource.getRepository(Profile)\n    const profile = await profileRepository\n      .createQueryBuilder('profile')\n      .addSelect('profile.password')\n      .where({ primary_email: email })\n      .getOne()\n\n    if (!profile) {\n      return { statusCode: 401, message: 'Invalid email or password' }\n    }\n\n    const passwordMatch = await bcrypt.compare(password, profile.password)\n", "    if (!profile) {\n      return { statusCode: 401, message: 'Invalid email or password' }\n    }\n\n    const passwordMatch = await bcrypt.compare(password, profile.password)\n\n    if (!passwordMatch) {\n      return { statusCode: 401, message: 'Invalid email or password' }\n    }\n\n    const token = jwt.sign({ userId: profile.uuid }, JWT_SECRET ?? '', {\n      expiresIn: '10h' // To-Do: Change value in production\n    })\n\n    return { statusCode: 200, message: 'Login successful', token }", "  } catch (error) {\n    console.error('Error executing login', error)\n    return { statusCode: 500, message: 'Internal server error' }\n  }\n}\n"]}
{"filename": "src/controllers/auth.controller.ts", "chunked_list": ["import type { Request, Response, NextFunction } from 'express'\nimport { registerUser, loginUser } from '../services/auth.service'\nimport passport from 'passport'\nimport type Profile from '../entities/profile.entity'\nimport jwt from 'jsonwebtoken'\nimport { JWT_SECRET } from '../configs/envConfig'\n\nexport const register = async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { email, password } = req.body\n", "  try {\n    const { email, password } = req.body\n\n    if (!email || !password) {\n      res.status(400).json({ error: 'Email and password are required fields' })\n    }\n\n    const { statusCode, message, profile } = await registerUser(email, password)\n\n    res.status(statusCode).json({ message, profile })\n  } catch (err) {", "  } catch (err) {\n    if (err instanceof Error) {\n      console.error('Error executing query', err)\n      res\n        .status(500)\n        .json({ error: 'Internal server error', message: err.message })\n    }\n  }\n}\n\nexport const login = async (req: Request, res: Response): Promise<void> => {", "  try {\n    const { email, password } = req.body\n\n    if (!email || !password) {\n      res.status(400).json({ error: 'Email and password are required fields' })\n    }\n\n    const { statusCode, message, token } = await loginUser(email, password)\n\n    res.cookie('jwt', token, {\n      httpOnly: true,\n      maxAge: 24 * 60 * 60 * 1000,\n      secure: false // TODO: Set to true when using HTTPS\n    })\n\n    res.status(statusCode).json({ message })", "  } catch (err) {\n    if (err instanceof Error) {\n      console.error('Error executing query', err)\n      res\n        .status(500)\n        .json({ error: 'Internal server error', message: err.message })\n    }\n  }\n}\n\nexport const logout = async (req: Request, res: Response): Promise<void> => {", "  try {\n    res.clearCookie('jwt', { httpOnly: true })\n    res.status(200).json({ message: 'Logged out successfully' })\n  } catch (err) {\n    if (err instanceof Error) {\n      console.error('Something went wrong', err)\n      res\n        .status(500)\n        .json({ error: 'Internal server error', message: err.message })\n    }\n  }\n}\n\nexport const requireAuth = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  passport.authenticate(\n    'jwt',\n    { session: false },\n    (err: Error, user: Profile) => {", "      if (err) {\n        next(err)\n        return\n      }\n\n      const token = req.cookies.jwt\n\n      if (!token) {\n        return res.status(401).json({ error: 'No token provided' })\n      }\n\n      const decoded = jwt.verify(token, JWT_SECRET) as jwt.JwtPayload\n", "      if (decoded.exp && Date.now() > decoded.exp * 1000) {\n        return res\n          .status(401)\n          .json({ error: 'Token expired, please log in again' })\n      }\n\n      if (!user) {\n        return res.status(401).json({ message: 'Unauthorised' })\n      } else {\n        req.user = user\n        next()\n      }\n    }\n  )(req, res, next)\n}\n"]}
{"filename": "src/controllers/profile.controller.ts", "chunked_list": ["import type { Request, Response } from 'express'\nimport { updateProfile } from '../services/profile.service'\nimport type Profile from '../entities/profile.entity'\n\nexport const getProfileHandler = async (\n  req: Request,\n  res: Response\n): Promise<void> => {\n  try {\n    const { user } = req\n    if (!user) {\n      res.status(404).json({ message: 'Profile not found' })\n    }\n\n    res.status(200).json(user)", "  try {\n    const { user } = req\n    if (!user) {\n      res.status(404).json({ message: 'Profile not found' })\n    }\n\n    res.status(200).json(user)\n  } catch (err) {\n    if (err instanceof Error) {\n      console.error('Error executing query', err)\n      res\n        .status(500)\n        .json({ error: 'Internal server error', message: err.message })\n    }\n  }\n}\n\nexport const updateProfileHandler = async (\n  req: Request,\n  res: Response\n): Promise<void> => {", "    if (err instanceof Error) {\n      console.error('Error executing query', err)\n      res\n        .status(500)\n        .json({ error: 'Internal server error', message: err.message })\n    }\n  }\n}\n\nexport const updateProfileHandler = async (\n  req: Request,\n  res: Response\n): Promise<void> => {", "  try {\n    const user = req.user as Profile\n    if (!user) {\n      res.status(404).json({ message: 'Profile not found' })\n    }\n\n    const { statusCode, message, profile } =\n      user && (await updateProfile(user, req.body))\n\n    res.status(statusCode).json({ message, profile })\n  } catch (err) {", "  } catch (err) {\n    if (err instanceof Error) {\n      console.error('Error executing query', err)\n      res\n        .status(500)\n        .json({ error: 'Internal server error', message: err.message })\n    }\n  }\n}\n"]}
{"filename": "src/routes/profile/profile.route.ts", "chunked_list": ["import express from 'express'\nimport {\n  getProfileHandler,\n  updateProfileHandler\n} from '../../controllers/profile.controller'\nimport { requireAuth } from '../../controllers/auth.controller'\n\nconst profileRouter = express.Router()\n\nprofileRouter.get('/profile', requireAuth, getProfileHandler)", "\nprofileRouter.get('/profile', requireAuth, getProfileHandler)\nprofileRouter.put('/profile', requireAuth, updateProfileHandler)\n\nexport default profileRouter\n"]}
{"filename": "src/routes/profile/profile.route.test.ts", "chunked_list": ["import { startServer } from '../../app'\nimport type { Express } from 'express'\nimport supertest from 'supertest'\nimport { dataSource } from '../../configs/dbConfig'\n\nconst randomString = Math.random().toString(36)\nconst port = Math.floor(Math.random() * (9999 - 3000 + 1)) + 3000\n\nlet server: Express\nlet agent: supertest.SuperAgentTest", "let server: Express\nlet agent: supertest.SuperAgentTest\n\ndescribe('profile', () => {\n  beforeAll(async () => {\n    server = await startServer(port)\n    agent = supertest.agent(server)\n\n    const testUser = {\n      email: `test${randomString}@gmail.com`,", "    const testUser = {\n      email: `test${randomString}@gmail.com`,\n      password: '123'\n    }\n\n    await supertest(server)\n      .post('/api/auth/register')\n      .send(testUser)\n      .expect(201)\n", "      .expect(201)\n\n    await agent.post('/api/auth/login').send(testUser).expect(200)\n  }, 5000)\n\n  describe('Get profile route', () => {\n    it('should return a 200 with a user profile object', async () => {\n      const response = await agent.get('/api/me/profile').expect(200)\n\n      expect(response.body).toHaveProperty('created_at')", "\n      expect(response.body).toHaveProperty('created_at')\n      expect(response.body).toHaveProperty('updated_at')\n      expect(response.body).toHaveProperty('primary_email')\n      expect(response.body).toHaveProperty('contact_email')\n      expect(response.body).toHaveProperty('first_name')\n      expect(response.body).toHaveProperty('last_name')\n      expect(response.body).toHaveProperty('image_url')\n      expect(response.body).toHaveProperty('linkedin_url')\n      expect(response.body).toHaveProperty('type')", "      expect(response.body).toHaveProperty('linkedin_url')\n      expect(response.body).toHaveProperty('type')\n      expect(response.body).toHaveProperty('uuid')\n      expect(response.body).not.toHaveProperty('password')\n    })\n  })\n\n  describe('Update profile route', () => {\n    it('should update the user profile and return a 200', async () => {\n      const updatedProfile = {", "    it('should update the user profile and return a 200', async () => {\n      const updatedProfile = {\n        contact_email: 'test_contact@example.com',\n        first_name: 'John',\n        last_name: 'Doe',\n        image_url: 'https://example.com/test_profile_image.jpg',\n        linkedin_url: 'https://www.linkedin.com/in/johndoe'\n      }\n\n      await agent.put('/api/me/profile').send(updatedProfile).expect(200)", "\n      await agent.put('/api/me/profile').send(updatedProfile).expect(200)\n    })\n\n    it('should return a 401 when a valid access token is not provided', async () => {\n      await supertest(server).put('/api/me/profile').send({}).expect(401)\n    })\n\n    afterAll(async () => {\n      await dataSource.destroy()", "    afterAll(async () => {\n      await dataSource.destroy()\n    })\n  })\n})\n"]}
{"filename": "src/routes/auth/auth.route.test.ts", "chunked_list": ["import { startServer } from '../../app'\nimport type { Express } from 'express'\nimport supertest from 'supertest'\nimport { dataSource } from '../../configs/dbConfig'\n\nconst randomString = Math.random().toString(36)\nconst port = Math.floor(Math.random() * (9999 - 3000 + 1)) + 3000\n\nlet server: Express\nlet agent: supertest.SuperAgentTest", "let server: Express\nlet agent: supertest.SuperAgentTest\n\nconst testUser = {\n  email: `test${randomString}@gmail.com`,\n  password: '123'\n}\n\nbeforeAll(async () => {\n  server = await startServer(port)", "beforeAll(async () => {\n  server = await startServer(port)\n  agent = supertest.agent(server)\n}, 5000)\n\ndescribe('auth controllers', () => {\n  describe('register', () => {\n    it('should return a 400 when email or password is missing', async () => {\n      await supertest(server).post('/api/auth/register').send({}).expect(400)\n    })", "      await supertest(server).post('/api/auth/register').send({}).expect(400)\n    })\n\n    it('should return a 201 with a user profile after successful registration', async () => {\n      const response = await supertest(server)\n        .post('/api/auth/register')\n        .send(testUser)\n        .expect(201)\n\n      expect(response.body).toHaveProperty('message')", "\n      expect(response.body).toHaveProperty('message')\n      expect(response.body.profile).toHaveProperty('created_at')\n      expect(response.body.profile).toHaveProperty('updated_at')\n      expect(response.body.profile).toHaveProperty('primary_email')\n      expect(response.body.profile).toHaveProperty('contact_email')\n      expect(response.body.profile).toHaveProperty('first_name')\n      expect(response.body.profile).toHaveProperty('last_name')\n      expect(response.body.profile).toHaveProperty('image_url')\n      expect(response.body.profile).toHaveProperty('linkedin_url')", "      expect(response.body.profile).toHaveProperty('image_url')\n      expect(response.body.profile).toHaveProperty('linkedin_url')\n      expect(response.body.profile).toHaveProperty('type')\n      expect(response.body.profile).toHaveProperty('uuid')\n      expect(response.body.profile).not.toHaveProperty('password')\n    })\n\n    it('should return a 400 when registering with a duplicate email', async () => {\n      await supertest(server)\n        .post('/api/auth/register')", "      await supertest(server)\n        .post('/api/auth/register')\n        .send(testUser)\n        .expect(409)\n    })\n  })\n\n  describe('login', () => {\n    it('should return a 400 when email or password is missing', async () => {\n      await supertest(server).post('/api/auth/login').send({}).expect(400)", "    it('should return a 400 when email or password is missing', async () => {\n      await supertest(server).post('/api/auth/login').send({}).expect(400)\n    })\n\n    it('should return a 200 after successful login', async () => {\n      const response = await supertest(server)\n        .post('/api/auth/login')\n        .send(testUser)\n        .expect(200)\n", "        .expect(200)\n\n      expect(response.body).toHaveProperty('message')\n    })\n\n    it('should return a 401 when logging in with incorrect credentials', async () => {\n      const incorrectUser = {\n        email: `test${randomString}@gmail.com`,\n        password: 'incorrect_password'\n      }", "        password: 'incorrect_password'\n      }\n\n      await supertest(server)\n        .post('/api/auth/login')\n        .send({ email: incorrectUser.email, password: 'wrong_password' })\n        .expect(401)\n    })\n  })\n", "  })\n\n  describe('logout', () => {\n    it('should clear the jwt cookie and return a 200', async () => {\n      const response = await agent.get('/api/auth/logout').expect(200)\n\n      const jwtCookie = response.headers['set-cookie']\n      expect(\n        jwtCookie.some((cookie: string[]) => cookie.includes('jwt='))\n      ).toBe(true)", "        jwtCookie.some((cookie: string[]) => cookie.includes('jwt='))\n      ).toBe(true)\n    })\n  })\n\n  afterAll(async () => {\n    await dataSource.destroy()\n  })\n})\n", "})\n"]}
{"filename": "src/routes/auth/auth.route.ts", "chunked_list": ["import express from 'express'\nimport { register, login, logout } from '../../controllers/auth.controller'\n\nconst authRouter = express.Router()\n\nauthRouter.post('/register', register)\nauthRouter.post('/login', login)\nauthRouter.get('/logout', logout)\n\nexport default authRouter", "\nexport default authRouter\n"]}
{"filename": "src/entities/mentee.entity.ts", "chunked_list": ["import { Column, Entity, JoinColumn, ManyToOne, OneToOne } from 'typeorm'\nimport { MenteeApplication } from '../types'\nimport Mentor from './mentor.entity'\nimport profileEntity from './profile.entity'\nimport { ApplicationStatus } from '../enums'\nimport BaseEntity from './baseEntity'\n\n@Entity('mentee')\nclass Mentee extends BaseEntity {\n  @Column({\n    type: 'enum',\n    enum: ApplicationStatus,\n    default: ApplicationStatus.PENDING\n  })\n  state: ApplicationStatus\n\n  @Column({ type: 'json' })\n  answers: MenteeApplication\n\n  @Column({ type: 'bigint' })\n  certificate_id: bigint\n\n  @Column()\n  journal: string\n\n  @OneToOne(() => profileEntity)\n  @JoinColumn()\n  profile: profileEntity\n\n  @ManyToOne(() => Mentor, (mentor) => mentor.mentees)\n  mentor: Mentor\n\n  constructor(\n    state: ApplicationStatus,\n    answers: MenteeApplication,\n    certificate_id: bigint,\n    journal: string,\n    profile: profileEntity,\n    mentor: Mentor\n  ) {\n    super()\n    this.state = state\n    this.answers = answers\n    this.certificate_id = certificate_id\n    this.journal = journal\n    this.profile = profile\n    this.mentor = mentor\n  }\n}\n\nexport default Mentee\n", "class Mentee extends BaseEntity {\n  @Column({\n    type: 'enum',\n    enum: ApplicationStatus,\n    default: ApplicationStatus.PENDING\n  })\n  state: ApplicationStatus\n\n  @Column({ type: 'json' })\n  answers: MenteeApplication\n\n  @Column({ type: 'bigint' })\n  certificate_id: bigint\n\n  @Column()\n  journal: string\n\n  @OneToOne(() => profileEntity)\n  @JoinColumn()\n  profile: profileEntity\n\n  @ManyToOne(() => Mentor, (mentor) => mentor.mentees)\n  mentor: Mentor\n\n  constructor(\n    state: ApplicationStatus,\n    answers: MenteeApplication,\n    certificate_id: bigint,\n    journal: string,\n    profile: profileEntity,\n    mentor: Mentor\n  ) {\n    super()\n    this.state = state\n    this.answers = answers\n    this.certificate_id = certificate_id\n    this.journal = journal\n    this.profile = profile\n    this.mentor = mentor\n  }\n}\n\nexport default Mentee\n"]}
{"filename": "src/entities/platform.entity.ts", "chunked_list": ["import { Column, Entity } from 'typeorm'\nimport BaseEntity from './baseEntity'\n\n@Entity('platform')\nclass Platform extends BaseEntity {\n  @Column()\n  description: string\n\n  @Column({ type: 'json' })\n  mentor_questions: JSON\n\n  @Column()\n  image_url: string\n\n  @Column()\n  landing_page_url: string\n\n  @Column({ type: 'json' })\n  email_templates: JSON\n\n  @Column({ type: 'varchar', length: 255 })\n  title: string\n\n  constructor(\n    description: string,\n    mentor_questions: JSON,\n    image_url: string,\n    landing_page_url: string,\n    email_templates: JSON,\n    title: string\n  ) {\n    super()\n    this.description = description\n    this.mentor_questions = mentor_questions\n    this.image_url = image_url\n    this.landing_page_url = landing_page_url\n    this.email_templates = email_templates\n    this.title = title\n  }\n}\n\nexport default Platform\n"]}
{"filename": "src/entities/email.entity.ts", "chunked_list": ["import { Column, Entity } from 'typeorm'\nimport { EmailStatusTypes } from '../enums'\nimport BaseEntity from './baseEntity'\n\n@Entity('email')\nclass Email extends BaseEntity {\n  @Column({ type: 'varchar', length: 255 })\n  recipient: string\n\n  @Column({ type: 'varchar', length: 255 })\n  subject: string\n\n  @Column({ type: 'varchar', length: 655 })\n  content: string\n\n  @Column({ type: 'enum', enum: EmailStatusTypes })\n  state: EmailStatusTypes\n\n  constructor(\n    recipient: string,\n    subject: string,\n    content: string,\n    state: EmailStatusTypes\n  ) {\n    super()\n    this.recipient = recipient\n    this.subject = subject\n    this.content = content\n    this.state = state\n  }\n}\n\nexport default Email\n"]}
{"filename": "src/entities/mentor.entity.ts", "chunked_list": ["import { Column, Entity, JoinColumn, OneToMany, OneToOne } from 'typeorm'\nimport profileEntity from './profile.entity'\nimport Mentee from './mentee.entity'\nimport Category from './category.entity'\nimport { ApplicationStatus } from '../enums'\nimport BaseEntity from './baseEntity'\n\n@Entity('mentor')\nclass Mentor extends BaseEntity {\n  @Column({\n    type: 'enum',\n    enum: ApplicationStatus,\n    default: ApplicationStatus.PENDING\n  })\n  state: ApplicationStatus\n\n  @OneToMany(() => Category, (category) => category.category)\n  category: Category\n\n  @Column({ type: 'json', select: false })\n  application: JSON\n\n  @Column({ type: 'boolean' })\n  availability: boolean\n\n  @OneToOne(() => profileEntity)\n  @JoinColumn()\n  profile: profileEntity\n\n  @OneToMany(() => Mentee, (mentee) => mentee.mentor)\n  mentees: Mentee[]\n\n  constructor(\n    state: ApplicationStatus,\n    category: Category,\n    application: JSON,\n    availability: boolean,\n    profile: profileEntity,\n    mentees: Mentee[]\n  ) {\n    super()\n    this.state = state\n    this.category = category\n    this.application = application\n    this.availability = availability\n    this.profile = profile\n    this.mentees = mentees\n  }\n}\n\nexport default Mentor\n", "class Mentor extends BaseEntity {\n  @Column({\n    type: 'enum',\n    enum: ApplicationStatus,\n    default: ApplicationStatus.PENDING\n  })\n  state: ApplicationStatus\n\n  @OneToMany(() => Category, (category) => category.category)\n  category: Category\n\n  @Column({ type: 'json', select: false })\n  application: JSON\n\n  @Column({ type: 'boolean' })\n  availability: boolean\n\n  @OneToOne(() => profileEntity)\n  @JoinColumn()\n  profile: profileEntity\n\n  @OneToMany(() => Mentee, (mentee) => mentee.mentor)\n  mentees: Mentee[]\n\n  constructor(\n    state: ApplicationStatus,\n    category: Category,\n    application: JSON,\n    availability: boolean,\n    profile: profileEntity,\n    mentees: Mentee[]\n  ) {\n    super()\n    this.state = state\n    this.category = category\n    this.application = application\n    this.availability = availability\n    this.profile = profile\n    this.mentees = mentees\n  }\n}\n\nexport default Mentor\n"]}
{"filename": "src/entities/profile.entity.ts", "chunked_list": ["import bcrypt from 'bcrypt'\nimport { Entity, Column } from 'typeorm'\nimport { ProfileTypes } from '../enums'\nimport BaseEntity from './baseEntity'\n\n@Entity({ name: 'profile' })\nclass Profile extends BaseEntity {\n  @Column({ type: 'varchar', length: 255, unique: true })\n  primary_email: string\n\n  @Column({ type: 'varchar', length: 255 })\n  contact_email: string\n\n  @Column({ type: 'varchar', length: 255 })\n  first_name: string\n\n  @Column({ type: 'varchar', length: 255 })\n  last_name: string\n\n  @Column({ type: 'varchar', length: 255 })\n  image_url: string\n\n  @Column({ type: 'varchar', length: 255 })\n  linkedin_url: string\n\n  @Column({ type: 'enum', enum: ProfileTypes, default: ProfileTypes.DEFAULT })\n  type: ProfileTypes\n\n  @Column({ type: 'varchar', length: 255, select: false })\n  password: string\n\n  constructor(\n    primary_email: string,\n    contact_email: string,\n    first_name: string,\n    last_name: string,\n    image_uri: string,\n    linkedin_uri: string,\n    type: ProfileTypes,\n    password: string\n  ) {\n    super()\n    this.primary_email = primary_email\n    this.contact_email = contact_email\n    this.first_name = first_name\n    this.last_name = last_name\n    this.image_url = image_uri\n    this.linkedin_url = linkedin_uri\n    this.type = type || ProfileTypes.DEFAULT\n    this.password = password\n  }\n\n  async comparePassword(candidatePassword: string): Promise<boolean> {\n    return await bcrypt.compare(candidatePassword, this.password)\n  }\n}\n\nexport default Profile\n"]}
{"filename": "src/entities/baseEntity.ts", "chunked_list": ["import {\n  BeforeInsert,\n  BeforeUpdate,\n  Column,\n  PrimaryGeneratedColumn\n} from 'typeorm'\nimport { v4 as uuidv4 } from 'uuid'\n\nclass BaseEntity {\n  @PrimaryGeneratedColumn('uuid')\n  uuid!: string\n\n  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n  created_at: Date | undefined\n\n  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n  updated_at: Date | undefined\n\n  @BeforeInsert()\n  @BeforeUpdate()\n  updateTimestamps(): void {\n    this.updated_at = new Date()", "class BaseEntity {\n  @PrimaryGeneratedColumn('uuid')\n  uuid!: string\n\n  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n  created_at: Date | undefined\n\n  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n  updated_at: Date | undefined\n\n  @BeforeInsert()\n  @BeforeUpdate()\n  updateTimestamps(): void {\n    this.updated_at = new Date()", "    if (!this.uuid) {\n      this.created_at = new Date()\n    }\n  }\n\n  @BeforeInsert()\n  async generateUuid(): Promise<void> {\n    if (!this.uuid) {\n      this.uuid = uuidv4()\n    }\n  }\n}\n\nexport default BaseEntity\n"]}
{"filename": "src/entities/category.entity.ts", "chunked_list": ["import { Column, Entity } from 'typeorm'\nimport BaseEntity from './baseEntity'\n\n@Entity('category')\nclass Category extends BaseEntity {\n  @Column({ type: 'varchar', length: 255 })\n  category: string\n\n  constructor(category: string) {\n    super()\n    this.category = category\n  }\n}\n\nexport default Category\n"]}
