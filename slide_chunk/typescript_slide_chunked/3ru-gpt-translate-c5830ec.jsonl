{"filename": "website/src/middleware.ts", "chunked_list": ["import type { NextRequest } from 'next/server'\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  if (request.nextUrl.pathname === '/') {\n    return NextResponse.redirect(\n      new URL('/docs/overview/getting-started', request.url),\n    )\n  }\n}\n\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],\n}\n"]}
{"filename": "src/gpt.ts", "chunked_list": ["import { error, getInput, info, notice, setFailed } from '@actions/core'\nimport {\n  ChatCompletionRequestMessageRoleEnum,\n  Configuration,\n  OpenAIApi,\n} from 'openai'\nimport { encode } from 'gpt-3-encoder'\n\nconst API_KEY = getInput('apikey')\nconst BASE_PATH = getInput('basePath') || 'https://api.openai.com/v1'", "const API_KEY = getInput('apikey')\nconst BASE_PATH = getInput('basePath') || 'https://api.openai.com/v1'\nconst PROMPT =\n  getInput('prompt') ||\n  'Please translate the given text into naturalistic {targetLanguage}.'\nif (!API_KEY) {\n  setFailed('Error: API_KEY could not be retrieved.')\n}\n\nconst configuration = new Configuration({\n  apiKey: API_KEY,\n  basePath: BASE_PATH,\n})\nconst openAIApi = new OpenAIApi(configuration)\n\nexport const askGPT = async (text: string, prompt: string): Promise<string> => {\n  const {\n    data: {\n      choices: [{ message: { content: content } = { content: '' } }],\n    },\n  } = await openAIApi\n    .createChatCompletion({\n      model: 'gpt-3.5-turbo-16k',\n      messages: [\n        {\n          role: ChatCompletionRequestMessageRoleEnum.System,\n          content: prompt,\n        },\n        { role: ChatCompletionRequestMessageRoleEnum.User, content: text },\n      ],\n      top_p: 0.5,\n    })", "    .catch((err) => {\n      error(err)\n      notice(\n        'If the status code is 400, the file exceeds 16,000 tokens without line breaks. \\nPlease open one line as appropriate.',\n      )\n      process.exit(1)\n    })\n\n  if (content === '') {\n    info('Possible Error: Translation result is empty')\n  }\n\n  return content\n}\n\nexport const gptTranslate = async (\n  text: string,\n  targetLanguage: string,\n  targetFileExt: string, // filename extension. Must be within availableFileExtensions.\n  maxToken = 16000,\n  splitter = `\\n\\n`,\n): Promise<string> => {\n  const prompt = PROMPT.replaceAll(\n    '{targetLanguage}',\n    targetLanguage,\n  ).replaceAll('{targetFileExt}', targetFileExt)\n\n  let translated = ''\n  let chunk = ''\n\n  info('Start translating...')\n  const contentChunks = text.split(splitter)", "  if (content === '') {\n    info('Possible Error: Translation result is empty')\n  }\n\n  return content\n}\n\nexport const gptTranslate = async (\n  text: string,\n  targetLanguage: string,\n  targetFileExt: string, // filename extension. Must be within availableFileExtensions.\n  maxToken = 16000,\n  splitter = `\\n\\n`,\n): Promise<string> => {\n  const prompt = PROMPT.replaceAll(\n    '{targetLanguage}',\n    targetLanguage,\n  ).replaceAll('{targetFileExt}', targetFileExt)\n\n  let translated = ''\n  let chunk = ''\n\n  info('Start translating...')\n  const contentChunks = text.split(splitter)", "  for (let i = 0; i < contentChunks.length; i++) {\n    if (encode(chunk + contentChunks[i]).length > maxToken) {\n      const translatedContent = await askGPT(chunk, prompt)\n      translated += translatedContent + splitter\n      chunk = ''\n    }\n    chunk += contentChunks[i] + (i < contentChunks.length - 1 ? splitter : '')\n  }\n  translated += await askGPT(chunk, prompt)\n  info('Translation completed!')\n\n  return translated\n}\n"]}
{"filename": "src/translate.ts", "chunked_list": ["import fs from 'fs/promises'\nimport path from 'path'\nimport { gptTranslate } from './gpt'\nimport { generatePRBody, isPR } from './utils'\nimport {\n  gitCheckout,\n  gitCommitPush,\n  gitCreateBranch,\n  gitCreatePullRequest,\n  gitPostComment,", "  gitCreatePullRequest,\n  gitPostComment,\n  gitSetConfig,\n} from './git'\nimport { context } from '@actions/github'\nimport {\n  createFile,\n  generateOutputFilePaths,\n  getFilePathsWithExtension,\n  isFileExists,", "  getFilePathsWithExtension,\n  isFileExists,\n} from './file'\nimport { info } from '@actions/core'\n\nexport const translateByCommand = async (\n  inputFilePath: string,\n  outputFilePath: string,\n  targetLang: string,\n) => {", "  targetLang: string,\n) => {\n  await gitSetConfig()\n  const branch = isPR() ? await gitCheckout() : await gitCreateBranch()\n\n  const isMultipleFileSelected = path.basename(inputFilePath).includes('*')\n\n  const inputFilePaths = isMultipleFileSelected\n    ? await getFilePathsWithExtension(\n        path.dirname(inputFilePath),", "    ? await getFilePathsWithExtension(\n        path.dirname(inputFilePath),\n        path.extname(inputFilePath),\n      )\n    : [inputFilePath]\n\n  const outputFilePaths = isMultipleFileSelected\n    ? generateOutputFilePaths(inputFilePaths, outputFilePath)\n    : [outputFilePath]\n", "    : [outputFilePath]\n\n  await createTranslatedFiles(inputFilePaths, outputFilePaths, targetLang)\n\n  await gitCommitPush(branch, outputFilePaths)\n  if (isPR()) {\n    await gitPostComment('\ud83c\udf89Translation completed!')\n    return\n  }\n\n  const issueNumber = context.issue.number\n  const title = '\ud83c\udf10 Add LLM Translations'\n  const body = generatePRBody(\n    inputFilePaths,\n    outputFilePaths,\n    targetLang,\n    issueNumber,\n  )\n\n  await gitCreatePullRequest(branch, title, body)\n  await gitPostComment('\ud83c\udf89Translation PR created!')\n}\n\nexport const translateByManual = async (\n  inputFiles: string[],\n  outputFiles: string[],\n  languages: string[],\n) => {", "  if (!inputFiles.length) {\n    info('No input files specified. Skip translation.')\n    return\n  }\n\n  if (!inputFiles.length || !outputFiles.length || !languages.length) {\n    throw new Error(\n      'Error: For push execution, all three parameters (inputFiles, outputFiles and language ) are required',\n    )\n  }\n  if (outputFiles.length !== languages.length) {\n    throw new Error('Error: outputFiles and language must be same length.')\n  }\n\n  const outputFilePaths: string[][] = outputFiles.map((outputFile) => {\n    return generateOutputFilePaths(inputFiles, outputFile)\n  })\n\n  // TODO: Dealing with request limits (503 error)\n  await Promise.all(\n    languages.map((language, index) =>\n      createTranslatedFiles(inputFiles, outputFilePaths[index], language),\n    ),\n  )\n\n  await gitSetConfig()\n  const branch = await gitCreateBranch()\n  const title = '\ud83c\udf10 Add LLM Translations'\n  await gitCommitPush(branch, outputFilePaths.flat())\n  const body = generatePRBody(inputFiles, outputFilePaths, languages)\n  await gitCreatePullRequest(branch, title, body)\n}\n\n/*\n * Parallel creation of translation files\n * inputFilePaths and outputFilePaths must be same length and same order\n */\nexport const createTranslatedFiles = async (\n  inputFilePaths: string[],\n  outputFilePaths: string[],\n  targetLang: string,\n) => {\n  const processFiles = inputFilePaths.map(async (inputFile, i) => {\n    const content = await fs.readFile(inputFile, 'utf-8')\n    const ext = path.extname(inputFile)\n    const translated = await gptTranslate(content, targetLang, ext)\n\n    // Check if the translation is same as the original", "  if (outputFiles.length !== languages.length) {\n    throw new Error('Error: outputFiles and language must be same length.')\n  }\n\n  const outputFilePaths: string[][] = outputFiles.map((outputFile) => {\n    return generateOutputFilePaths(inputFiles, outputFile)\n  })\n\n  // TODO: Dealing with request limits (503 error)\n  await Promise.all(\n    languages.map((language, index) =>\n      createTranslatedFiles(inputFiles, outputFilePaths[index], language),\n    ),\n  )\n\n  await gitSetConfig()\n  const branch = await gitCreateBranch()\n  const title = '\ud83c\udf10 Add LLM Translations'\n  await gitCommitPush(branch, outputFilePaths.flat())\n  const body = generatePRBody(inputFiles, outputFilePaths, languages)\n  await gitCreatePullRequest(branch, title, body)\n}\n\n/*\n * Parallel creation of translation files\n * inputFilePaths and outputFilePaths must be same length and same order\n */\nexport const createTranslatedFiles = async (\n  inputFilePaths: string[],\n  outputFilePaths: string[],\n  targetLang: string,\n) => {\n  const processFiles = inputFilePaths.map(async (inputFile, i) => {\n    const content = await fs.readFile(inputFile, 'utf-8')\n    const ext = path.extname(inputFile)\n    const translated = await gptTranslate(content, targetLang, ext)\n\n    // Check if the translation is same as the original", "    if (await isFileExists(outputFilePaths[i])) {\n      const fileContent = await fs.readFile(outputFilePaths[i], 'utf-8')\n      if (fileContent === translated) {\n        info(\n          '\u26d4 The result of translation was same as the existed output file.',\n        )\n        return\n      }\n    }\n\n    info(`Create Translated File ${outputFilePaths[i]}`)\n    await createFile(translated, outputFilePaths[i])\n  })\n\n  await Promise.all(processFiles)\n}\n"]}
{"filename": "src/const.ts", "chunked_list": ["// File extensions for translation\nexport const availableFileExtensions = ['.md', '.mdx']\n"]}
{"filename": "src/git.ts", "chunked_list": ["import { exec } from '@actions/exec'\nimport { context, getOctokit } from '@actions/github'\nimport { setFailed, info, getInput } from '@actions/core'\nimport { randomUUID } from 'crypto'\n\nconst GITHUB_TOKEN = getInput('token')\nif (!GITHUB_TOKEN) {\n  setFailed('Error: GITHUB_TOKEN could not be retrieved.')\n}\n\nexport const gitSetConfig = async () => {\n  info('Setting git config...')\n  // TODO: Get command user info from\n  // const { rest } = getOctokit(GITHUB_TOKEN)\n  // const { data: user } = await rest.users.getAuthenticated()\n  const user = {\n    name: 'github-actions[bot]',\n    email: '41898282+github-actions[bot]@users.noreply.github.com',\n  }\n\n  await exec('git', ['config', 'user.name', user.name])\n  await exec('git', ['config', 'user.email', user.email])\n}\n\nexport const gitCheckout = async () => {\n  info('Checking out...')\n\n  const {\n    rest: { pulls },\n  } = getOctokit(GITHUB_TOKEN)\n  const {\n    data: {\n      head: { ref: branch },\n    },\n  } = await pulls.get({\n    ...context.repo,\n    pull_number: context.issue.number,\n  })\n\n  await exec('git', ['fetch', 'origin', branch])\n  await exec('git', ['checkout', branch])\n\n  return branch as string\n}\n\nexport const gitCreateBranch = async () => {\n  info('Creating branch...')\n  const branch = `gt-${randomUUID()}`\n\n  await exec('git', ['checkout', '-b', branch])\n  return branch\n}\n\nexport const gitCommitPush = async (\n  branch: string,\n  filePath: string | string[],\n) => {\n  info('Committing and pushing...')\n", "  if (Array.isArray(filePath)) {\n    await exec('git', ['add', ...filePath])\n  } else {\n    await exec('git', ['add', filePath])\n  }\n\n  await exec('git', ['commit', '-m', `\ud83d\udcacGenerate LLM translations`])\n  await exec('git', ['push', 'origin', branch])\n}\n\nexport const gitCreatePullRequest = async (\n  head: string,\n  title: string,\n  body: string,\n) => {\n  const {\n    rest: { pulls, repos },\n  } = getOctokit(GITHUB_TOKEN)\n  const {\n    data: { default_branch: base },\n  } = await repos.get(context.repo)\n\n  info(`Creating pull request from ${base} to ${head}...`)\n\n  await pulls.create({\n    ...context.repo,\n    head,\n    base,\n    title,\n    body,\n  })\n}\n\nexport const gitPostComment = async (message: string) => {\n  const {\n    rest: { issues },\n  } = getOctokit(GITHUB_TOKEN)\n\n  await issues.createComment({\n    ...context.repo,\n    issue_number: context.issue.number,\n    body: message,\n  })\n}\n\nexport const authorizeUser = async () => {\n  const {\n    rest: { repos },\n  } = getOctokit(GITHUB_TOKEN)\n  const { data: user } = await repos.getCollaboratorPermissionLevel({\n    ...context.repo,\n    username: context.actor,\n  })\n\n  info(`User permission: ${user.permission}`)\n\n  return user.permission === 'admin' || user.permission === 'write'\n}\n"]}
{"filename": "src/validate.ts", "chunked_list": ["import { availableFileExtensions } from './const'\nimport path from 'path'\nimport { postError, removeSymbols } from './utils'\nimport { COMMAND_USAGE, INVALID_FILE_EXTENSION } from './error'\n\nexport const isValidFileExt = (filename: string): boolean => {\n  // Allow input file extension inheritance by asterisk in addition to normal file formats\n  const fileExts = [...availableFileExtensions, '*']\n  return fileExts.some((type) => filename.endsWith(type))\n}", "  return fileExts.some((type) => filename.endsWith(type))\n}\n\nexport const commandValidator = async (\n  userCommand: string | undefined,\n  match: RegExpExecArray | null,\n): Promise<{\n  inputFilePath: string\n  outputFilePath: string\n  targetLang: string", "  outputFilePath: string\n  targetLang: string\n}> => {\n  if (!match || match.length < 4) {\n    await postError(`Invalid command: \\`${userCommand}\\`\\n${COMMAND_USAGE}`)\n  }\n\n  const [, inputFilePath, outputFilePath, targetLang] = match!\n\n  if (!isValidFileExt(inputFilePath) || !isValidFileExt(outputFilePath)) {\n    await postError(INVALID_FILE_EXTENSION)\n  }\n\n  const inputFileName = path.basename(inputFilePath)\n  const outputFileName = path.basename(outputFilePath)\n\n  // If multiple files are specified, input and output must be specified in the same way.", "  if (!isValidFileExt(inputFilePath) || !isValidFileExt(outputFilePath)) {\n    await postError(INVALID_FILE_EXTENSION)\n  }\n\n  const inputFileName = path.basename(inputFilePath)\n  const outputFileName = path.basename(outputFilePath)\n\n  // If multiple files are specified, input and output must be specified in the same way.\n  if (\n    (inputFileName.includes('*') && !outputFileName.includes('*')) ||\n    (!inputFileName.includes('*') && outputFileName.includes('*'))\n  ) {\n    await postError(\n      `Error: Multiple file specification mismatch.\\n${inputFileName} and ${outputFileName}`,\n    )\n  }\n\n  return {\n    inputFilePath,\n    outputFilePath,\n    targetLang: removeSymbols(targetLang),\n  }\n}\n", "  if (\n    (inputFileName.includes('*') && !outputFileName.includes('*')) ||\n    (!inputFileName.includes('*') && outputFileName.includes('*'))\n  ) {\n    await postError(\n      `Error: Multiple file specification mismatch.\\n${inputFileName} and ${outputFileName}`,\n    )\n  }\n\n  return {\n    inputFilePath,\n    outputFilePath,\n    targetLang: removeSymbols(targetLang),\n  }\n}\n"]}
{"filename": "src/error.ts", "chunked_list": ["import { availableFileExtensions } from './const'\n\nexport const COMMAND_USAGE = `usage:\n\\`\\`\\`\n/gpt-translate [input file path] [output file path] [target language]\n\\`\\`\\`\n`\n\nconst availableFileExtsString = availableFileExtensions.join(', ')\n", "const availableFileExtsString = availableFileExtensions.join(', ')\n\nexport const INVALID_FILE_EXTENSION = `Error: File must be a valid file type.\\n${availableFileExtsString}`\n"]}
{"filename": "src/file.ts", "chunked_list": ["import fs from 'fs/promises'\nimport path from 'path'\n\n/**\n * Create files recursively if no directory.\n */\nexport const createFile = async (\n  data: string,\n  filePath: string,\n): Promise<void> => {\n  try {\n    await fs.writeFile(filePath, data)", "  filePath: string,\n): Promise<void> => {\n  try {\n    await fs.writeFile(filePath, data)\n  } catch (err) {\n    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n      await fs.mkdir(path.dirname(filePath), { recursive: true })\n      await createFile(data, filePath)\n    } else {\n      throw err\n    }\n  }\n}\n\nexport const isFileExists = async (inputPath: string) => {", "  try {\n    await fs.stat(inputPath)\n    return true\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return false\n    }\n    throw error\n  }\n}\n\n/**\n * Replace the part with '**' with the rest\n */", "function replaceWildcard(inputArray: string[], outputArray: string[]) {\n  const output = [...outputArray]\n  const indexOfAsteriskAsterisk = outputArray.indexOf('**')\n\n  if (indexOfAsteriskAsterisk !== -1) {\n    output.splice(\n      indexOfAsteriskAsterisk,\n      1,\n      ...inputArray.slice(indexOfAsteriskAsterisk),\n    )\n  }\n\n  return output\n}\n\n/**\n * Extracts the extension from a filename string\n */", "function extractFileExtension(filename: string): string | null {\n  const match = filename.match(/\\.\\w+(\\.\\w+)?$/)\n  return match ? match[0] : null\n}\n\n/*\n * Get all file paths in a directory with a specific extension.\n * @param directoryPath The path to the directory to search.\n * @param extension The extension to filter by.\n */\nexport const getFilePathsWithExtension = async (\n  directoryPath: string,\n  extension: string,\n): Promise<string[]> => {\n  const files = await fs.readdir(directoryPath)\n\n  const filteredFiles: string[] = []", "  for (const file of files) {\n    const filePath = path.join(directoryPath, file)\n    const stat = await fs.stat(filePath)\n\n    if (stat.isFile() && path.extname(file) === extension) {\n      filteredFiles.push(filePath)\n    }\n  }\n\n  return filteredFiles\n}\n\n/**\n * Generates an array of output file paths based on the provided array of input file paths\n *\n * @param {string[]} inputFilePaths - The array of input file paths\n * @param {string} outputFilePath - The format of the output file path. The '*' character in the output file path is replaced by the filename of each input file path\n * @returns {string[]} An array of output file paths.\n * @throws {Error} Throws an error if the outputFilePath does not contain extensions(.md) or wildcards(*)\n *\n */\nexport const generateOutputFilePaths = (\n  inputFilePaths: string[],\n  outputFilePath: string,\n): string[] => {\n  const outputSegments = outputFilePath.replace('./', '').split('/')\n  const outputFilePattern = outputSegments.pop()!\n  const outputFileExt = extractFileExtension(outputFilePattern) || ''\n  const outputFilenameWithoutExt = outputFilePattern.replace(outputFileExt, '')\n\n  return inputFilePaths.map((inputFilePath) => {\n    const inputSegments = inputFilePath.split('/')\n    const inputFile = inputSegments.pop()!\n    const inputFileExt = extractFileExtension(inputFile) || ''\n    const inputFilenameWithoutExt = inputFile.replace(inputFileExt, '')\n\n    const resolvedPathSegments = replaceWildcard(inputSegments, outputSegments) // Resolve path segments\n\n    // If output file pattern contains '*', replace it with the input filename", "    if (outputFilenameWithoutExt.includes('*')) {\n      const finalExt = outputFileExt || inputFileExt // If output extension isn't specified, use input file extension\n      const finalFilename = `${inputFilenameWithoutExt}${finalExt}` // Concatenate filename and extension\n      resolvedPathSegments.push(finalFilename)\n    } else {\n      // Otherwise, use the specified output filename\n      resolvedPathSegments.push(outputFilePattern)\n    }\n\n    return resolvedPathSegments.join('/')\n  })\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { setFailed } from '@actions/core'\nimport { gitPostComment } from './git'\nimport { context } from '@actions/github'\n\nexport const postError = async (message: string) => {\n  await gitPostComment(`\u274c${message}`)\n  setFailed(message)\n  process.exit(1)\n}\n", "}\n\nexport const isPR = () => {\n  const { payload } = context\n  return !!payload.issue?.pull_request\n}\n\nexport const removeSymbols = (input: string): string => {\n  return input.replace(/[^\\w\\s]/gi, '')\n}", "  return input.replace(/[^\\w\\s]/gi, '')\n}\n\nexport const generatePRBody = (\n  inputFilePaths: string[],\n  outputFilePaths: string[] | string[][],\n  targetLang: string | string[],\n  issueNumber?: number,\n) => {\n  const generateRow = (label: string, filePaths: string[] | string[][]) => {", ") => {\n  const generateRow = (label: string, filePaths: string[] | string[][]) => {\n    let result: string[] = []\n\n    if (Array.isArray(filePaths[0])) {\n      // filePaths: string[][]\n      let cnt = -1\n      filePaths.forEach((subArr) => {\n        // subArr: string[]\n        subArr.forEach((filePath: string) => {\n          cnt++\n          return result.push(\n            `${cnt > 0 ? '|' : `|**${label}**`}|\\`${filePath}\\`|`,\n          )\n        })\n      })\n    } else {\n      // filePaths: string[]\n      filePaths.forEach((filePath, i) => {\n        return result.push(`${i > 0 ? '|' : `|**${label}**`}|\\`${filePath}\\`|`)\n      })\n    }\n    return result.join('\\n')\n  }\n\n  return `## \u2705 LLM Translation completed\n  |**Name**|**Value**|\n  |---|---|\n  ${generateRow('Source', inputFilePaths)}\n  ${generateRow('Output', outputFilePaths)}\n  |**Language**|${\n    Array.isArray(targetLang) ? targetLang.join(', ') : targetLang\n  }|\n  ${issueNumber ? `|**Issue**|#${issueNumber}|` : ''}\n  `\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { postError } from './utils'\nimport { translateByCommand, translateByManual } from './translate'\nimport { authorizeUser } from './git'\nimport { extractInput, getCommandParams } from './extract'\nimport { context } from '@actions/github'\nimport { setFailed } from '@actions/core'\n\nasync function main() {\n  switch (context.eventName) {\n    case 'issue_comment':\n      const isAuthorized = await authorizeUser()", "      if (!isAuthorized) {\n        await postError('You have no permission to use this bot.')\n      }\n      const { inputFilePath, outputFilePath, targetLang } =\n        await getCommandParams()\n      await translateByCommand(inputFilePath, outputFilePath, targetLang)\n\n      break\n    case 'push':\n      // \u26a0 Experimental Feature\n      // Translate any file from the parameter specification.\n      // Multiple output and target languages can be selected.\n      // [IMPORTANT]\n      // outputFiles must be specified using wildcards.\n\n      const { inputFiles, outputFiles, languages } = extractInput()\n      await translateByManual(inputFiles, outputFiles, languages)\n\n      break\n    default:\n      await postError('This event is not supported.')\n  }\n}\n", "main().catch((e) => setFailed(e))\n"]}
{"filename": "src/extract.ts", "chunked_list": ["import { getInput, setFailed } from '@actions/core'\nimport { context } from '@actions/github'\nimport { commandValidator, isValidFileExt } from './validate'\n\ntype CommandParams = {\n  inputFilePath: string\n  outputFilePath: string\n  targetLang: string\n}\n\ntype ManualParams = {\n  inputFiles: string[]\n  outputFiles: string[]\n  languages: string[]\n}\n\nexport const getCommandParams = async (): Promise<CommandParams> => {\n  const comment = context.payload.comment?.body", "type ManualParams = {\n  inputFiles: string[]\n  outputFiles: string[]\n  languages: string[]\n}\n\nexport const getCommandParams = async (): Promise<CommandParams> => {\n  const comment = context.payload.comment?.body\n  if (!comment) setFailed('Error: Comment could not be retrieved correctly.')\n\n  const regex = /\\/(?:gpt-translate|gt)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/\n  const match = regex.exec(comment)\n\n  return commandValidator(comment, match)\n}\n\nexport const extractInput = (): ManualParams => {\n  const inputFilesRaw = getInput('inputFiles')\n  const outputFilesRaw = getInput('outputFiles')\n  const languagesRaw = getInput('languages')\n\n  const inputFiles = inputFilesRaw\n    ? inputFilesRaw.split(' ').filter((v) => v)\n    : []\n  const outputFiles = outputFilesRaw\n    ? outputFilesRaw.split(' ').filter((v) => v)\n    : []\n  const languages = languagesRaw ? languagesRaw.split(' ').filter((v) => v) : []\n\n  // validate input\n  const isValidInput =\n    inputFiles.every((v) => isValidFileExt(v)) &&\n    outputFiles.every((v) => isValidFileExt(v))\n", "  if (!comment) setFailed('Error: Comment could not be retrieved correctly.')\n\n  const regex = /\\/(?:gpt-translate|gt)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/\n  const match = regex.exec(comment)\n\n  return commandValidator(comment, match)\n}\n\nexport const extractInput = (): ManualParams => {\n  const inputFilesRaw = getInput('inputFiles')\n  const outputFilesRaw = getInput('outputFiles')\n  const languagesRaw = getInput('languages')\n\n  const inputFiles = inputFilesRaw\n    ? inputFilesRaw.split(' ').filter((v) => v)\n    : []\n  const outputFiles = outputFilesRaw\n    ? outputFilesRaw.split(' ').filter((v) => v)\n    : []\n  const languages = languagesRaw ? languagesRaw.split(' ').filter((v) => v) : []\n\n  // validate input\n  const isValidInput =\n    inputFiles.every((v) => isValidFileExt(v)) &&\n    outputFiles.every((v) => isValidFileExt(v))\n", "  if (!isValidInput) {\n    throw new Error(\n      'Invalid input. Please check the inputFiles and outputFiles parameters',\n    )\n  }\n\n  return {\n    inputFiles,\n    outputFiles,\n    languages,\n  }\n}\n"]}
