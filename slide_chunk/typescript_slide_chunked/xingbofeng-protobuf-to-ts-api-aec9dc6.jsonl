{"filename": "api/example/test.ts", "chunked_list": ["/* eslint-disable */\nimport request from axios;\nimport api from './test.d';\n\nexport function GetExampleData(req: api.test.IGetExampleDataReq): Promise<api.test.IGetExampleDataRsp> {\n  return request.get('/GetExampleData', { params: req });\n};\n\nexport function PostExampleData(req: api.test.IPostExampleDataReq): Promise<api.test.IPostExampleDataRsp> {\n  return request.post('/PostExampleData', req);\n};\n", "export function PostExampleData(req: api.test.IPostExampleDataReq): Promise<api.test.IPostExampleDataRsp> {\n  return request.post('/PostExampleData', req);\n};\n"]}
{"filename": "api/example/test.d.ts", "chunked_list": ["/** Namespace test. */\nexport namespace test {\n\n    /** Status enum. */\n    enum Status {\n        SUCCESS = 0,\n        FAIL = 1,\n        UNKNOWN = 2\n    }\n\n    /** Properties of a GetExampleDataReq. */", "    interface IGetExampleDataReq {\n        /** GetExampleDataReq id */\n        id: number;\n        /** GetExampleDataReq name */\n        name: string;\n    }\n\n    /** Properties of a GetExampleDataRsp. */\n    interface IGetExampleDataRsp {\n        /** GetExampleDataRsp status */\n        status: test.Status[];\n        /** GetExampleDataRsp msg */\n        msg: string;\n        /** GetExampleDataRsp city */\n        city: string;\n        /** GetExampleDataRsp code */\n        code: number;\n    }\n\n    /** Properties of a PostExampleDataReq. */", "    interface IGetExampleDataRsp {\n        /** GetExampleDataRsp status */\n        status: test.Status[];\n        /** GetExampleDataRsp msg */\n        msg: string;\n        /** GetExampleDataRsp city */\n        city: string;\n        /** GetExampleDataRsp code */\n        code: number;\n    }\n\n    /** Properties of a PostExampleDataReq. */", "    interface IPostExampleDataReq {\n        /** PostExampleDataReq id */\n        id: number;\n        /** PostExampleDataReq name */\n        name: string;\n    }\n\n    /** Properties of a PostExampleDataRsp. */\n    interface IPostExampleDataRsp {\n        /** PostExampleDataRsp status */\n        status: test.Status[];\n        /** PostExampleDataRsp msg */\n        msg: string;\n        /** PostExampleDataRsp code */\n        code: number;\n    }\n\n    namespace API {\n    }\n}\n", "    interface IPostExampleDataRsp {\n        /** PostExampleDataRsp status */\n        status: test.Status[];\n        /** PostExampleDataRsp msg */\n        msg: string;\n        /** PostExampleDataRsp code */\n        code: number;\n    }\n\n    namespace API {\n    }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import chalk from 'chalk';\nimport { Express } from 'express';\nimport glob from 'glob';\nimport minimist from 'minimist';\n\nimport { IOptions } from './interfaces/IOptions';\nimport { initServer } from './modules/mockServer';\nimport { transferTSFile } from './modules/transferTSFile';\n\nconst getUsage = () =>", "\nconst getUsage = () =>\n  `Usage: ${chalk.bold.green('pb2TSApi')} [options] ${chalk.bold.red('[file1.proto file2.proto ...]')} or ${chalk.bold.red('[./**/*.proto]')}`;\n\nconst getHelp = () =>\n  `Help:\n${chalk.bold.green('--requestModule -r')}: the request module of you want to set, default is ${chalk.bold.red('\\'axios\\'')}, you can set to your custom request method, for example ${chalk.bold.red('\\'@/request\\'')};\n${chalk.bold.green('--baseUrl -b')}: the base url of you want to set, default is ${chalk.bold.red('\\'/\\'')}, you can set to your api path, for example ${chalk.bold.red('\\'/api\\'')};\n${chalk.bold.green('--folder -f')}: the folder of you want to save the output files, default is ${chalk.bold.red('\\'./api\\'')};\n${chalk.bold.green('--root -r')}: the root path set to protobufjs, default is ${chalk.bold.red('the path of this command run')};\n${chalk.bold.green('--optional -o')}: is transfrom d.ts optional to false, because of protobuf 3.0 set all filed is optional, default is ${chalk.bold.red('true')};\n${chalk.bold.green('--mock -m')}: is open mock server, default is ${chalk.bold.red('false')};\n${chalk.bold.green('--port -p')}: mock server port, default is ${chalk.bold.red('3000')};\n`;\n", "export async function main() {\n  try {\n    const argv = minimist(process.argv.slice(2), {\n      alias: {\n        requestModule: 'r',\n        baseUrl: 'b',\n        folder: 'f',\n        root: 'r',\n        optional: 'o',\n        mock: 'm',\n        port: 'p',\n        help: 'h',\n      },\n      string: ['requestModule', 'baseUrl', 'folder', 'root', 'port'],\n      boolean: ['optional', 'mock'],\n      default: {\n        requestModule: 'axios',\n        baseUrl: '/',\n        folder: './api',\n        root: process.cwd(),\n        optional: true,\n        mock: false,\n        port: '3000',\n        help: '',\n      },\n    });", "    if (argv.help) {\n      process.stderr.write(getHelp());\n      process.exit(1);\n    }\n    const { _: files } = argv;\n    const options: IOptions = {\n      requestModule: argv.requestModule,\n      baseUrl: argv.baseUrl,\n      folder: argv.folder,\n      root: argv.root,\n      optional: argv.optional,\n      mock: argv.mock,\n      port: argv.port,\n      help: argv.help,\n    };", "    if (!files.length) {\n      process.stderr.write(getUsage());\n      process.exit(1);\n    }\n    const protoFiles = await glob(files, { ignore: 'node_modules/**', windowsPathsNoEscape: true });\n    if (!protoFiles.length) {\n      process.stderr.write(chalk.bold.red(`there is not files for the flowing paths: \\n ${files.join('\\n')}`));\n      process.exit(1);\n    }\n    let mockServer: Express;\n    if (options.mock) {\n      mockServer = initServer(options);\n    }\n    await Promise.all(protoFiles.map(filePath => transferTSFile(filePath, mockServer, options)));", "    if (options.mock) {\n      mockServer = initServer(options);\n    }\n    await Promise.all(protoFiles.map(filePath => transferTSFile(filePath, mockServer, options)));\n  } catch (err) {\n    console.error(err);\n    process.exit(1);\n  }\n}\n\nmain();\n"]}
{"filename": "src/utils/getRequestMethod.ts", "chunked_list": ["import { RequestMethods } from '../interfaces/RequestMethods';\n\nexport function getRequestMethod(apiName: string): RequestMethods {\n  return /post/.test(apiName.toLowerCase()) ? RequestMethods.post : RequestMethods.get;\n}\n"]}
{"filename": "src/interfaces/RequestMethods.ts", "chunked_list": ["export enum RequestMethods {\n  post = 'post',\n  get = 'get',\n}\n"]}
{"filename": "src/interfaces/IOptions.ts", "chunked_list": ["export interface IOptions {\n  requestModule: string;\n  baseUrl: string;\n  folder: string;\n  root: string;\n  optional: boolean;\n  mock: boolean;\n  port: string;\n  help: string;\n}\n"]}
{"filename": "src/modules/mockServer.ts", "chunked_list": ["import express, { Express } from 'express';\nimport fs from 'fs';\n\nimport { IOptions } from '../interfaces/IOptions';\nimport { getRequestMethod } from '../utils/getRequestMethod';\n\n/**\n * \u521d\u59cb\u5316 mock server\n * @param {IOptions} options \u7528\u6237\u81ea\u5b9a\u4e49\u914d\u7f6e\n * @returns {Express} mockServer \u901a\u8fc7express\u5b9e\u4f8b\u5316\u7684mock server app", " * @param {IOptions} options \u7528\u6237\u81ea\u5b9a\u4e49\u914d\u7f6e\n * @returns {Express} mockServer \u901a\u8fc7express\u5b9e\u4f8b\u5316\u7684mock server app\n */\nexport function initServer(options: IOptions) {\n  const mockServer = express();\n  const { port = '3000' } = options;\n  mockServer.listen(+port, () => {\n    console.log(`mock server listening on port ${port}`);\n  });\n  return mockServer;\n}\n\n/**\n * \u62ff\u5230mock\u6587\u4ef6\uff0c\u751f\u6210mock server\n * @param {String} mockFilePath mock\u6587\u4ef6\u7684\u8def\u5f84\n * @param {Express} mockServer express server \u5bf9\u8c61\n * @param {IOptions} options \u7528\u6237\u81ea\u5b9a\u4e49\u914d\u7f6e\n */", "export async function generateMockRoute(mockFilePath: string, mockServer: Express, options: IOptions) {\n  const { baseUrl } = options;\n  const mockFile = await fs.promises.readFile(mockFilePath, { encoding: 'utf-8' });\n  const json = JSON.parse(mockFile);\n  for (const apiName in json) {\n    if (Object.hasOwnProperty.call(json, apiName)) {\n      const requestMethod = getRequestMethod(apiName);\n      mockServer[requestMethod](`${baseUrl}${apiName}`, (req, res) => {\n        res.send(json[apiName]);\n      });\n      console.log(`mockServer generate mock route: ${baseUrl}${apiName} success`);\n    }\n  }\n}\n"]}
{"filename": "src/modules/saveJSONSchemaFile.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport { buildGenerator, getProgramFromFiles } from 'typescript-json-schema';\n\n/**\n * \u751f\u6210\u524d\u7aefapi\u8bf7\u6c42JSON Schema \u6587\u4ef6\n * @param {String} pbtsFilePath \u751f\u6210\u7684d.ts\u5b9a\u4e49\u6587\u4ef6\u7684\u8def\u5f84\n * @returns {String} jsonSchemaFilePath \u751f\u6210\u7684json schema \u6587\u4ef6\u8def\u5f84\n */\nexport async function saveJSONSchemaFile(pbtsFilePath: string) {\n  const settings = {\n    required: true,\n  };\n  const compilerOptions = {\n    strictNullChecks: true,\n  };\n\n  const program = getProgramFromFiles([path.resolve(pbtsFilePath)], compilerOptions, process.cwd());\n  const generator = buildGenerator(program, settings);\n  const symbols = (generator?.getUserSymbols() || []).filter(symbol => /I(\\S*)Rsp$/.test(symbol));\n  const schema = generator?.getSchemaForSymbols(symbols);\n  const jsonSchemaFilePath = pbtsFilePath.replace('.d.ts', '.json');\n  await fs.promises.writeFile(jsonSchemaFilePath, JSON.stringify(schema, null, 2), { encoding: 'utf-8' });\n  return jsonSchemaFilePath;\n}\n", " */\nexport async function saveJSONSchemaFile(pbtsFilePath: string) {\n  const settings = {\n    required: true,\n  };\n  const compilerOptions = {\n    strictNullChecks: true,\n  };\n\n  const program = getProgramFromFiles([path.resolve(pbtsFilePath)], compilerOptions, process.cwd());\n  const generator = buildGenerator(program, settings);\n  const symbols = (generator?.getUserSymbols() || []).filter(symbol => /I(\\S*)Rsp$/.test(symbol));\n  const schema = generator?.getSchemaForSymbols(symbols);\n  const jsonSchemaFilePath = pbtsFilePath.replace('.d.ts', '.json');\n  await fs.promises.writeFile(jsonSchemaFilePath, JSON.stringify(schema, null, 2), { encoding: 'utf-8' });\n  return jsonSchemaFilePath;\n}\n"]}
{"filename": "src/modules/transferTSFile.ts", "chunked_list": ["import { Express } from 'express';\nimport fs from 'fs';\nimport path from 'path';\n\nimport { IOptions } from '../interfaces/IOptions';\nimport { getPbjsFile } from './getPbjsFile';\nimport { getPbtsFile } from './getPbtsFile';\nimport { generateMockRoute } from './mockServer';\nimport { saveApiFile } from './saveApiFile';\nimport { saveJSONSchemaFile } from './saveJSONSchemaFile';", "import { saveApiFile } from './saveApiFile';\nimport { saveJSONSchemaFile } from './saveJSONSchemaFile';\nimport { saveMockJSONFile } from './saveMockJSONFile';\nimport { saveTypeScriptDefineFile } from './saveTypeScriptDefineFile';\n\n/**\n * \u8f6c\u6362protobuf\u5b9a\u4e49\u6587\u4ef6\u4e3ats\u5b9a\u4e49\u6587\u4ef6\u548capi\u8bf7\u6c42\u6587\u4ef6\n * @param {String} filePath protobuf\u5b9a\u4e49\u6587\u4ef6\u7684\u8def\u5f84\n * @param {Express} mockServer mockServer\u5bf9\u8c61\uff0c\u662f\u4e00\u4e2aexpress\u5b9e\u4f8b\u5316\u7684\u5bf9\u8c61\n * @param {Object} options \u7528\u6237\u81ea\u5b9a\u4e49\u914d\u7f6e", " * @param {Express} mockServer mockServer\u5bf9\u8c61\uff0c\u662f\u4e00\u4e2aexpress\u5b9e\u4f8b\u5316\u7684\u5bf9\u8c61\n * @param {Object} options \u7528\u6237\u81ea\u5b9a\u4e49\u914d\u7f6e\n */\nexport async function transferTSFile(filePath: string, mockServer: Express, options: IOptions) {\n  const pbjsFilePath = await getPbjsFile(filePath, options);\n  const pbtsFilePath = await getPbtsFile(pbjsFilePath, options);\n  await fs.promises.unlink(pbjsFilePath);\n  await saveTypeScriptDefineFile(pbtsFilePath, options);\n  await saveApiFile(pbtsFilePath, options);\n  const jsonSchemaFilePath = await saveJSONSchemaFile(pbtsFilePath);\n  const mockFilePath = await saveMockJSONFile(jsonSchemaFilePath);\n  console.log(`success generate ${filePath} to ${path.resolve(options.folder, filePath)}.d.ts and ${path.resolve(options.folder, filePath)}.ts`);", "  if (options.mock && mockServer) {\n    console.log('begin open mock server');\n    await generateMockRoute(mockFilePath, mockServer, options);\n  }\n}\n"]}
{"filename": "src/modules/travelAllModule.ts", "chunked_list": ["import { ModuleDeclaration } from 'ts-morph';\n/**\n * \u9012\u5f52\u4e00\u4e2ats\u6587\u4ef6\u4e0b\u6240\u6709\u6a21\u5757\n * @param {ModuleDeclaration[]} modules \u901a\u8fc7ts-morph\u751f\u6210\u6a21\u5757\u58f0\u660e\n * @param {Function} callback \u9012\u5f52\u4e00\u4e2ats\u6587\u4ef6\u6240\u6709\u6a21\u5757\u4e0b\u5bf9\u4e8e\u6bcf\u4e2a\u6a21\u5757\u7684\u56de\u8c03\u51fd\u6570\n * @param {String} parentName \u9012\u5f52\u5230\u5f53\u524d\u6a21\u5757\uff0c\u6240\u6709\u7236\u7ea7namespace\u7684\u540d\u79f0\uff0c\u901a\u8fc7.\u7b26\u53f7\u5206\u5272\n */\nexport function travelAllModule(modules: ModuleDeclaration[], callback: (module: ModuleDeclaration, fullName: string) => void, parentName = '') {\n  for (const module of modules) {\n    const children = module.getModules();\n    const hasModule = children.length > 0;\n    const fullName = `${parentName ? `${parentName}.` : ''}${module.getName()}`;\n    callback(module, fullName);", "  for (const module of modules) {\n    const children = module.getModules();\n    const hasModule = children.length > 0;\n    const fullName = `${parentName ? `${parentName}.` : ''}${module.getName()}`;\n    callback(module, fullName);\n    if (hasModule) {\n      travelAllModule(children, callback, fullName);\n    }\n  }\n}\n"]}
{"filename": "src/modules/saveApiFile.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport { Project } from 'ts-morph';\n\nimport { IOptions } from '../interfaces/IOptions';\nimport { RequestMethods } from '../interfaces/RequestMethods';\nimport { getRequestMethod } from '../utils/getRequestMethod';\nimport { travelAllModule } from './travelAllModule';\n\nconst getLinePerfix = (requestModule: string, tsDefineFilename: string) =>", "\nconst getLinePerfix = (requestModule: string, tsDefineFilename: string) =>\n  `/* eslint-disable */\nimport request from ${requestModule};\nimport api from './${tsDefineFilename.replace('.ts', '')}';\n`;\n\nconst getLine = (apiName: string, reqName: string, rspName: string, requestMethod: RequestMethods, baseUrl: string) => `\nexport function ${apiName}(req: api.${reqName}): Promise<api.${rspName}> {\n  return request.${requestMethod}('${baseUrl}${apiName}', ${requestMethod === 'post' ? 'req' : '{ params: req }'});", "export function ${apiName}(req: api.${reqName}): Promise<api.${rspName}> {\n  return request.${requestMethod}('${baseUrl}${apiName}', ${requestMethod === 'post' ? 'req' : '{ params: req }'});\n};\n`;\n\n/**\n * \u751f\u6210\u524d\u7aefapi\u8bf7\u6c42\u6587\u4ef6\n * @param {String} pbtsFilePath \u751f\u6210\u7684d.ts\u5b9a\u4e49\u6587\u4ef6\u7684\u8def\u5f84\n * @param {Object} options \u7528\u6237\u4f20\u5165\u7684\u81ea\u5b9a\u4e49\u914d\u7f6e\u9009\u9879\n */\nexport async function saveApiFile(pbtsFilePath: string, options: IOptions) {\n  const {\n    requestModule,\n    baseUrl,\n  } = options;\n  // \u83b7\u53d6\u5f53\u524dd.ts\u6587\u4ef6\u7684\u76ee\u5f55\u540d\u79f0\u548c\u6587\u4ef6\u540d\u79f0\n  const tsDefineDirname = path.dirname(pbtsFilePath);\n  const tsDefineFilename = path.basename(pbtsFilePath);\n  let apiline = '';\n  apiline += getLinePerfix(\n    requestModule,\n    tsDefineFilename,\n  );\n  const project = new Project();\n  project.addSourceFileAtPath(pbtsFilePath);\n  const file = project.getSourceFileOrThrow(pbtsFilePath);\n  const modules = file.getModules();\n  travelAllModule(modules, (module, parentName) => {\n    const interfaces = module.getInterfaces();\n    interfaces.length && interfaces.forEach(i => {\n      const reqName = i.getName();\n      // \u627e\u5230\u8bf7\u6c42\u7684interface\u540d\u79f0\n      const reqNameMatchs = reqName.match(/^I(\\S*)Req$/);", " * @param {Object} options \u7528\u6237\u4f20\u5165\u7684\u81ea\u5b9a\u4e49\u914d\u7f6e\u9009\u9879\n */\nexport async function saveApiFile(pbtsFilePath: string, options: IOptions) {\n  const {\n    requestModule,\n    baseUrl,\n  } = options;\n  // \u83b7\u53d6\u5f53\u524dd.ts\u6587\u4ef6\u7684\u76ee\u5f55\u540d\u79f0\u548c\u6587\u4ef6\u540d\u79f0\n  const tsDefineDirname = path.dirname(pbtsFilePath);\n  const tsDefineFilename = path.basename(pbtsFilePath);\n  let apiline = '';\n  apiline += getLinePerfix(\n    requestModule,\n    tsDefineFilename,\n  );\n  const project = new Project();\n  project.addSourceFileAtPath(pbtsFilePath);\n  const file = project.getSourceFileOrThrow(pbtsFilePath);\n  const modules = file.getModules();\n  travelAllModule(modules, (module, parentName) => {\n    const interfaces = module.getInterfaces();\n    interfaces.length && interfaces.forEach(i => {\n      const reqName = i.getName();\n      // \u627e\u5230\u8bf7\u6c42\u7684interface\u540d\u79f0\n      const reqNameMatchs = reqName.match(/^I(\\S*)Req$/);", "      if (reqNameMatchs && reqNameMatchs.length) {\n        const apiName = reqNameMatchs[1];\n        // \u627e\u5230\u8fd4\u56de\u503c\u7684interface\n        const rspName = `I${apiName}Rsp`;\n        const rsp = interfaces.find(item => item.getName() === rspName);\n        if (!rsp) {\n          return;\n        }\n        apiline += getLine(\n          apiName,\n          `${parentName}.${reqName}`,\n          `${parentName}.${rspName}`,\n          getRequestMethod(apiName),\n          baseUrl,\n        );\n      }\n    });\n  });\n\n  await fs.promises.writeFile(path.resolve(tsDefineDirname, tsDefineFilename.replace('.d.ts', '.ts')), apiline);\n}\n"]}
{"filename": "src/modules/saveTypeScriptDefineFile.ts", "chunked_list": ["import { ImportDeclaration, Project } from 'ts-morph';\n\nimport { IOptions } from '../interfaces/IOptions';\nimport { travelAllModule } from './travelAllModule';\n\n/**\n * \u53bb\u9664protobuf-cli\u751f\u6210\u7684d.ts\u6587\u4ef6\u4e2d\u7684\u5197\u4f59\u7684class\u6a21\u5757\n * @param {String} pbtsFilePath \u751f\u6210\u7684d.ts\u5b9a\u4e49\u6587\u4ef6\u7684\u8def\u5f84\n * @param {Object} options \u7528\u6237\u4f20\u5165\u7684\u81ea\u5b9a\u4e49\u914d\u7f6e\u9009\u9879\n */\nexport async function saveTypeScriptDefineFile(pbtsFilePath: string, options: IOptions) {\n  const project = new Project();\n  project.addSourceFileAtPath(pbtsFilePath);\n  const file = project.getSourceFileOrThrow(pbtsFilePath);\n  const modules = file.getModules();\n  // \u53bb\u6389\u751f\u6210\u7684import\n  file.getImportDeclarations().forEach(i => i.remove());\n\n  // \u5bf9\u4e8eimportString\u7684\u5904\u7406\n  file.getImportStringLiterals().forEach(i => {\n    const p = i.getParent()?.getParent() as ImportDeclaration;\n    p.remove();\n  });\n\n  travelAllModule(modules, module => {\n    // \u53bb\u6389\u751f\u6210\u7684class\n    const classes = module.getClasses();\n    classes.forEach(c => c.remove());\n\n    // \u53bb\u6389\u751f\u6210\u7684rpc-type\n    const typeAliases = module.getTypeAliases();\n    typeAliases.forEach(t => t.remove());\n", " * @param {Object} options \u7528\u6237\u4f20\u5165\u7684\u81ea\u5b9a\u4e49\u914d\u7f6e\u9009\u9879\n */\nexport async function saveTypeScriptDefineFile(pbtsFilePath: string, options: IOptions) {\n  const project = new Project();\n  project.addSourceFileAtPath(pbtsFilePath);\n  const file = project.getSourceFileOrThrow(pbtsFilePath);\n  const modules = file.getModules();\n  // \u53bb\u6389\u751f\u6210\u7684import\n  file.getImportDeclarations().forEach(i => i.remove());\n\n  // \u5bf9\u4e8eimportString\u7684\u5904\u7406\n  file.getImportStringLiterals().forEach(i => {\n    const p = i.getParent()?.getParent() as ImportDeclaration;\n    p.remove();\n  });\n\n  travelAllModule(modules, module => {\n    // \u53bb\u6389\u751f\u6210\u7684class\n    const classes = module.getClasses();\n    classes.forEach(c => c.remove());\n\n    // \u53bb\u6389\u751f\u6210\u7684rpc-type\n    const typeAliases = module.getTypeAliases();\n    typeAliases.forEach(t => t.remove());\n", "    if (!options.optional) {\n      module.getInterfaces().forEach(item => {\n        const structure = item.getStructure();\n        structure.properties?.forEach(property => {\n          property.hasQuestionToken = false;\n          if (typeof property.type === 'string') {\n            property.type = property.type.replace(/^\\((\\S*)\\|null\\)$/, '$1');\n          }\n        });\n        item.set(structure);\n      });\n    }\n  });\n  project.saveSync();\n}\n"]}
{"filename": "src/modules/saveMockJSONFile.ts", "chunked_list": ["import fs from 'fs';\nimport { JSONSchemaFaker } from 'json-schema-faker';\nimport { JsonObject, JsonValue } from 'type-fest';\n\n/**\n * \u751f\u6210\u524d\u7aefapi\u8bf7\u6c42 mock \u6587\u4ef6\n * @param {String} jsonSchemaFilePath \u751f\u6210\u7684JSON Schema \u6587\u4ef6\u7684\u8def\u5f84\n */\nexport async function saveMockJSONFile(jsonSchemaFilePath: string) {\n  const schemaFileStr = await fs.promises.readFile(jsonSchemaFilePath, { encoding: 'utf-8' });\n  const schema = JSON.parse(schemaFileStr.replace(/(?<=#\\/)definitions\\//g, ''));\n  const jsfResult = await JSONSchemaFaker.resolve(schema.definitions) as JsonObject;\n  const json: Record<string, JsonValue> = {};", "export async function saveMockJSONFile(jsonSchemaFilePath: string) {\n  const schemaFileStr = await fs.promises.readFile(jsonSchemaFilePath, { encoding: 'utf-8' });\n  const schema = JSON.parse(schemaFileStr.replace(/(?<=#\\/)definitions\\//g, ''));\n  const jsfResult = await JSONSchemaFaker.resolve(schema.definitions) as JsonObject;\n  const json: Record<string, JsonValue> = {};\n  for (const key in jsfResult) {\n    if (Object.hasOwnProperty.call(jsfResult, key)) {\n      const rspNameMatchs = key.match(/I(\\S*)Rsp$/);\n      if (rspNameMatchs && rspNameMatchs.length) {\n        const apiName = rspNameMatchs[1];\n        json[apiName] = jsfResult[key];\n      }\n    }\n  }\n  const fileContent = JSON.stringify(json, null, 2);\n  const mockFilePath = jsonSchemaFilePath.replace('.json', '.mock.json');\n  fs.writeFileSync(mockFilePath, fileContent, { encoding: 'utf-8' });\n  return mockFilePath;\n}\n", "      if (rspNameMatchs && rspNameMatchs.length) {\n        const apiName = rspNameMatchs[1];\n        json[apiName] = jsfResult[key];\n      }\n    }\n  }\n  const fileContent = JSON.stringify(json, null, 2);\n  const mockFilePath = jsonSchemaFilePath.replace('.json', '.mock.json');\n  fs.writeFileSync(mockFilePath, fileContent, { encoding: 'utf-8' });\n  return mockFilePath;\n}\n"]}
{"filename": "src/modules/getPbjsFile.ts", "chunked_list": ["import mkdirp from 'mkdirp';\nimport path from 'path';\nimport pbjs from 'protobufjs-cli/pbjs';\n\nimport { IOptions } from '../interfaces/IOptions';\n\n/**\n * \u901a\u8fc7protobuf-cli\u751f\u6210\u4e34\u65f6\u7684js\u6587\u4ef6\uff0c\u7528\u4e8e\u518d\u751f\u6210ts\u6587\u4ef6\uff0c\u751f\u6210ts\u6587\u4ef6\u540e\uff0c\u5220\u6389\u4e34\u65f6\u7684js\u6587\u4ef6\n * @param {String} filePath proto\u6587\u4ef6\u7684\u8def\u5f84\n * @returns {Promise<string>} \u751f\u6210\u4e34\u65f6\u7684js\u6587\u4ef6\u7684\u8def\u5f84", " * @param {String} filePath proto\u6587\u4ef6\u7684\u8def\u5f84\n * @returns {Promise<string>} \u751f\u6210\u4e34\u65f6\u7684js\u6587\u4ef6\u7684\u8def\u5f84\n */\nexport async function getPbjsFile(filePath: string, options: IOptions): Promise<string> {\n  const { folder = '' } = options;\n  const fileName = filePath.replace('.proto', '.js');\n  const pbjsFilePath = path.resolve(process.cwd(), folder, fileName);\n  const p = path.dirname(pbjsFilePath);\n  await mkdirp(p);\n  return new Promise((resolve, reject) => {\n    pbjs.main(['-p', options.root, '-t', 'static-module', '-w', 'commonjs', '-o', pbjsFilePath, path.resolve(process.cwd(), filePath)], err => {", "      if (err) {\n        reject(err);\n      }\n      resolve(pbjsFilePath);\n    });\n  });\n}\n"]}
{"filename": "src/modules/getPbtsFile.ts", "chunked_list": ["import path from 'path';\nimport pbts from 'protobufjs-cli/pbts';\n\nimport { IOptions } from '../interfaces/IOptions';\n\n/**\n * \u901a\u8fc7protobuf-cli\u751f\u6210d.ts\u6587\u4ef6\n * @param {String} pbjsFilePath \u751f\u6210\u7684js\u6587\u4ef6\u7684\u8def\u5f84\n * @returns {Promise<string>} \u751f\u6210\u4e34\u65f6\u7684js\u6587\u4ef6\u7684\u8def\u5f84\n */\nexport function getPbtsFile(pbjsFilePath: string, options: IOptions): Promise<string> {\n  const { folder = '' } = options;\n  const pbtsFilePath = path.resolve(process.cwd(), folder, pbjsFilePath.replace('.js', '.d.ts'));\n  return new Promise((resolve, reject) => {\n    pbts.main(['-p', options.root, '-o', pbtsFilePath, pbjsFilePath], err => {", " * @returns {Promise<string>} \u751f\u6210\u4e34\u65f6\u7684js\u6587\u4ef6\u7684\u8def\u5f84\n */\nexport function getPbtsFile(pbjsFilePath: string, options: IOptions): Promise<string> {\n  const { folder = '' } = options;\n  const pbtsFilePath = path.resolve(process.cwd(), folder, pbjsFilePath.replace('.js', '.d.ts'));\n  return new Promise((resolve, reject) => {\n    pbts.main(['-p', options.root, '-o', pbtsFilePath, pbjsFilePath], err => {\n      if (err) {\n        reject(err);\n      }\n      resolve(pbtsFilePath);\n    });\n  });\n}\n"]}
