{"filename": "src/server.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport { ClientCapabilities, createConnection, InitializeParams, InitializeResult, ProposedFeatures, TextDocuments } from 'vscode-languageserver/node'\nimport DocumentIndexer from './indexing/DocumentIndexer'\nimport WorkspaceIndexer from './indexing/WorkspaceIndexer'\nimport ConfigurationManager, { ConnectionTiming } from './lifecycle/ConfigurationManager'\nimport MatlabLifecycleManager, { MatlabConnectionStatusParam } from './lifecycle/MatlabLifecycleManager'\nimport Logger from './logging/Logger'\nimport { Actions, reportTelemetryAction } from './logging/TelemetryUtils'", "import Logger from './logging/Logger'\nimport { Actions, reportTelemetryAction } from './logging/TelemetryUtils'\nimport NotificationService, { Notification } from './notifications/NotificationService'\nimport CompletionProvider from './providers/completion/CompletionSupportProvider'\nimport FormatSupportProvider from './providers/formatting/FormatSupportProvider'\nimport LintingSupportProvider from './providers/linting/LintingSupportProvider'\nimport ExecuteCommandProvider, { MatlabLSCommands } from './providers/lspCommands/ExecuteCommandProvider'\nimport NavigationSupportProvider, { RequestType } from './providers/navigation/NavigationSupportProvider'\n\n// Create a connection for the server", "\n// Create a connection for the server\nexport const connection = createConnection(ProposedFeatures.all)\n\n// Initialize Logger\nLogger.initialize(connection.console)\n\n// Create basic text document manager\nconst documentManager: TextDocuments<TextDocument> = new TextDocuments(TextDocument)\n", "const documentManager: TextDocuments<TextDocument> = new TextDocuments(TextDocument)\n\nMatlabLifecycleManager.addMatlabLifecycleListener((error, lifecycleEvent) => {\n    if (error != null) {\n        Logger.error(`MATLAB Lifecycle Error: ${error.message}\\n${error.stack ?? ''}`)\n    }\n\n    if (lifecycleEvent.matlabStatus === 'connected') {\n        // Handle things after MATLAB\u00ae has launched\n\n        // Initiate workspace indexing\n        void WorkspaceIndexer.indexWorkspace()\n\n        documentManager.all().forEach(textDocument => {\n            void LintingSupportProvider.lintDocument(textDocument, connection)\n            void DocumentIndexer.indexDocument(textDocument)\n        })\n    }\n})\n\nlet capabilities: ClientCapabilities\n\n// Handles an initialization request\nconnection.onInitialize((params: InitializeParams) => {\n    capabilities = params.capabilities\n\n    // Defines the capabilities supported by this language server\n    const initResult: InitializeResult = {\n        capabilities: {\n            codeActionProvider: true,\n            completionProvider: {\n                triggerCharacters: [", "                    '.', // Struct/class properties, package names, etc.\n                    '(', // Function call\n                    ' ', // Command-style function call\n                    ',', // Function arguments\n                    '/', // File path\n                    '\\\\' // File path\n                ]\n            },\n            definitionProvider: true,\n            documentFormattingProvider: true,\n            executeCommandProvider: {\n                commands: Object.values(MatlabLSCommands)\n            },\n            referencesProvider: true,\n            signatureHelpProvider: {\n                triggerCharacters: ['(', ',']\n            },\n            documentSymbolProvider: true\n        }\n    }\n\n    return initResult\n})\n\n// Handles the initialized notification\nconnection.onInitialized(() => {\n    ConfigurationManager.setup(capabilities)\n\n    WorkspaceIndexer.setupCallbacks(capabilities)\n\n    void startMatlabIfOnStartLaunch()\n})\n", "async function startMatlabIfOnStartLaunch (): Promise<void> {\n    // Launch MATLAB if it should be launched early\n    const connectionTiming = (await ConfigurationManager.getConfiguration()).matlabConnectionTiming\n    if (connectionTiming === ConnectionTiming.OnStart) {\n        void MatlabLifecycleManager.connectToMatlab(connection)\n    }\n}\n\n// Handles a shutdown request\nconnection.onShutdown(() => {\n    // Shut down MATLAB\n    MatlabLifecycleManager.disconnectFromMatlab()\n})\n\n// Set up connection notification listeners\nNotificationService.registerNotificationListener(\n    Notification.MatlabConnectionClientUpdate,\n    data => MatlabLifecycleManager.handleConnectionStatusChange(data as MatlabConnectionStatusParam)\n)\n\n// Handles files opened\ndocumentManager.onDidOpen(params => {\n    reportFileOpened(params.document)\n    void LintingSupportProvider.lintDocument(params.document, connection)\n    void DocumentIndexer.indexDocument(params.document)\n})\n\ndocumentManager.onDidClose(params => {\n    LintingSupportProvider.clearDiagnosticsForDocument(params.document)\n})\n\n// Handles files saved\ndocumentManager.onDidSave(params => {\n    void LintingSupportProvider.lintDocument(params.document, connection)\n})\n\n// Handles changes to the text document\ndocumentManager.onDidChangeContent(params => {", "    if (MatlabLifecycleManager.isMatlabReady()) {\n        // Only want to lint on content changes when linting is being backed by MATLAB\n        LintingSupportProvider.queueLintingForDocument(params.document, connection)\n        DocumentIndexer.queueIndexingForDocument(params.document)\n    }\n})\n\n// Handle execute command requests\nconnection.onExecuteCommand(params => {\n    void ExecuteCommandProvider.handleExecuteCommand(params, documentManager, connection)\n})\n\n/** -------------------- COMPLETION SUPPORT -------------------- **/\nconnection.onCompletion(async params => {\n    // Gather a list of possible completions to be displayed by the IDE\n    return await CompletionProvider.handleCompletionRequest(params, documentManager)\n})\n\nconnection.onSignatureHelp(async params => {", "    // Gather a list of possible function signatures to be displayed by the IDE\n    return await CompletionProvider.handleSignatureHelpRequest(params, documentManager)\n})\n\n/** -------------------- FORMATTING SUPPORT -------------------- **/\nconnection.onDocumentFormatting(async params => {\n    // Gather a set of document edits required for formatting, which the IDE will execute\n    return await FormatSupportProvider.handleDocumentFormatRequest(params, documentManager)\n})\n\n/** --------------------  LINTING SUPPORT   -------------------- **/\nconnection.onCodeAction(params => {\n    // Retrieve a list of possible code actions to be displayed by the IDE\n    return LintingSupportProvider.handleCodeActionRequest(params)\n})\n\n/** --------------------  NAVIGATION SUPPORT   -------------------- **/\nconnection.onDefinition(async params => {\n    return await NavigationSupportProvider.handleDefOrRefRequest(params, documentManager, RequestType.Definition)\n})\n\nconnection.onReferences(async params => {\n    return await NavigationSupportProvider.handleDefOrRefRequest(params, documentManager, RequestType.References)\n})\n\nconnection.onDocumentSymbol(async params => {\n    return await NavigationSupportProvider.handleDocumentSymbol(params, documentManager, RequestType.DocumentSymbol)\n})\n\n// Start listening to open/change/close text document events\ndocumentManager.listen(connection)\n\n/** -------------------- Helper Functions -------------------- **/", "function reportFileOpened (document: TextDocument): void {\n    const roughSize = Math.ceil(document.getText().length / 1024) // in KB\n    reportTelemetryAction(Actions.OpenFile, roughSize.toString())\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\n// Start up the LSP server\nimport { connection } from './server'\n\n// Listen on the connection\nconnection.listen()\n"]}
{"filename": "src/utils/PositionUtils.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { Position } from 'vscode-languageserver'\n\n/**\n * Determines whether a position is less than another position.\n *\n * @param a The first position\n * @param b The second position\n * @returns true if position A is before position B", " * @param b The second position\n * @returns true if position A is before position B\n */\nexport function isPositionLessThan (a: Position, b: Position): boolean {\n    return checkLessThan(a, b)\n}\n\n/**\n * Determines whether a position is less than or equal to another position.\n *\n * @param a The first position\n * @param b The second position\n * @returns true if position A is before position B, or the same position\n */", "export function isPositionLessThanOrEqualTo (a: Position, b: Position): boolean {\n    return checkLessThan(a, b, true)\n}\n\n/**\n * Determines whether a position is greater than another position.\n *\n * @param a The first position\n * @param b The second position\n * @returns True if position A is after position B\n */", "export function isPositionGreaterThan (a: Position, b: Position): boolean {\n    return checkGreaterThan(a, b)\n}\n\n/**\n * Determines whether a position is greater than or equal to another position.\n *\n * @param a The first position\n * @param b The second position\n * @returns True if position A is after position B, or the same position\n */", "export function isPositionGreaterThanOrEqualTo (a: Position, b: Position): boolean {\n    return checkGreaterThan(a, b, true)\n}\n\n/**\n * Performs a \"less than (or equal to)\" check on two positions.\n *\n * @param a The first position\n * @param b The second position\n * @param orEqual Whether or not an \"or equal to\" check should be performed\n * @returns true if position A is before position B\n */", "function checkLessThan (a: Position, b: Position, orEqual = false): boolean {\n    if (a.line < b.line) {\n        return true\n    }\n\n    if (a.line === b.line) {\n        return orEqual\n            ? a.character <= b.character\n            : a.character < b.character\n    }\n\n    return false\n}\n\n/**\n * Performs a \"greater than (or equal to)\" check on two positions.\n *\n * @param a The first position\n * @param b The second position\n * @param orEqual Whether or not an \"or equal to\" check should be performed\n * @returns true if position A is after position B\n */", "function checkGreaterThan (a: Position, b: Position, orEqual = false): boolean {\n    if (a.line > b.line) {\n        return true\n    }\n\n    if (a.line === b.line) {\n        return orEqual\n            ? a.character >= b.character\n            : a.character > b.character\n    }\n\n    return false\n}\n"]}
{"filename": "src/utils/TextDocumentUtils.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { Range } from 'vscode-languageserver'\nimport { TextDocument } from 'vscode-languageserver-textdocument'\n\n/**\n * Gets a Range within a text document from the given line/column position to\n * the end of the provided line.\n *\n * @param doc The text document", " *\n * @param doc The text document\n * @param line The line number\n * @param char The character number on the line\n * @returns A range\n */\nexport function getRangeUntilLineEnd (doc: TextDocument, line: number, char: number): Range {\n    const lineText = getTextOnLine(doc, line)\n    return Range.create(line, char, line, lineText.length)\n}\n\n/**\n * Gets the text on the given line of the document.\n *\n * @param doc The text document\n * @param line The line number\n * @returns The text on the line\n */", "export function getTextOnLine (doc: TextDocument, line: number): string {\n    return doc.getText().split('\\n')[line]\n}\n"]}
{"filename": "src/utils/CliUtils.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport * as yargs from 'yargs'\nimport { Argument } from '../lifecycle/ConfigurationManager'\n\nexport interface CliArgs {\n    [Argument.MatlabLaunchCommandArguments]?: string\n    [Argument.MatlabInstallationPath]?: string\n    [Argument.MatlabConnectionTiming]?: string\n    [Argument.ShouldIndexWorkspace]?: boolean\n    [Argument.MatlabUrl]?: string\n}\n\n/**\n * Creates a yargs parser to extract command line arguments.\n *\n * @returns The parsed command line arguments\n */", "function makeParser (): yargs.Argv<CliArgs> {\n    const argParser = yargs.option(Argument.MatlabLaunchCommandArguments, {\n        description: 'Arguments passed to MATLAB when launching',\n        type: 'string',\n        requiresArg: true\n    }).option(Argument.MatlabInstallationPath, {\n        description: 'The full path to the top-level directory of the MATLAB installation. If not specified, the environment path will be checked for the location of the `matlab` executable.',\n        type: 'string',\n        default: ''\n    }).option(Argument.MatlabConnectionTiming, {\n        description: 'When the language server should attempt to connect to MATLAB.',\n        type: 'string',\n        default: 'onStart',\n        choices: ['onStart', 'onDemand', 'never']\n    }).option(Argument.ShouldIndexWorkspace, {\n        boolean: true,\n        default: false,\n        description: 'Whether or not the user\\'s workspace should be indexed.',\n        requiresArg: false\n    }).option(Argument.MatlabUrl, {\n        type: 'string',\n        description: 'URL for communicating with an existing MATLAB instance',\n        requiresArg: true\n    }).usage(\n        'Usage: $0 {--node-ipc | --stdio | --socket=socket} options\\n' +\n        '\\n' +\n        '\\tAn LSP server for MATLAB. This is meant to be invoked from an editor or IDE.\\n'\n    ).group(\n        ['node-ipc', 'stdio', 'socket'],\n        'Required IPC flag'\n    ).option('node-ipc', {\n        description: 'Use Node IPC'\n    }).option('stdio', {\n        description: 'Use stdio for IPC'\n    }).option('socket', {\n        description: 'Use specified socket for IPC',\n        requiresArg: true\n    }).help('help').alias('h', 'help')\n\n    return argParser\n}\n\n/**\n * Parse the command line arguments.\n *\n * @param args If provided, these are the arguments to parse. Otherwise, the true\n * command line arguments will be parsed. This is primarily meant for testing.\n * @returns The parsed CLI arguments\n */", "export function getCliArgs (args?: string[]): CliArgs {\n    const cliParser = makeParser()\n    return (args != null) ? cliParser.parseSync(args) : cliParser.parseSync()\n}\n"]}
{"filename": "src/logging/TelemetryUtils.ts", "chunked_list": ["// Copyright 2023 The MathWorks, Inc.\n\nimport NotificationService, { Notification } from '../notifications/NotificationService'\n\nenum EventKeys {\n    Action = 'ACTIONS',\n    SettingChange = 'SETTING_CHANGE'\n}\n\nexport enum Actions {\n    OpenFile = 'openFile',\n    StartMatlab = 'startMATLAB',\n    ShutdownMatlab = 'shutdownMATLAB',\n    FormatDocument = 'formatDocument',\n    GoToReference = 'goToReference',\n    GoToDefinition = 'goToDefinition',\n    DocumentSymbol = 'documentSymbol'\n}\n", "export enum Actions {\n    OpenFile = 'openFile',\n    StartMatlab = 'startMATLAB',\n    ShutdownMatlab = 'shutdownMATLAB',\n    FormatDocument = 'formatDocument',\n    GoToReference = 'goToReference',\n    GoToDefinition = 'goToDefinition',\n    DocumentSymbol = 'documentSymbol'\n}\n\nexport enum ActionErrorConditions {\n    MatlabUnavailable = 'MATLAB unavailable'\n}\n\n/**\n * Reports a telemetry event to the client\n *\n * @param eventKey The event key\n * @param data The event's data\n */", "export enum ActionErrorConditions {\n    MatlabUnavailable = 'MATLAB unavailable'\n}\n\n/**\n * Reports a telemetry event to the client\n *\n * @param eventKey The event key\n * @param data The event's data\n */\nfunction reportTelemetry (eventKey: string, data: unknown): void {\n    NotificationService.sendNotification(Notification.LogTelemetryData, {\n        eventKey,\n        data\n    })\n}\n\n/**\n * Reports telemetry about a simple action\n *\n * @param actionType The action's type\n * @param data The action's data\n */", "function reportTelemetry (eventKey: string, data: unknown): void {\n    NotificationService.sendNotification(Notification.LogTelemetryData, {\n        eventKey,\n        data\n    })\n}\n\n/**\n * Reports telemetry about a simple action\n *\n * @param actionType The action's type\n * @param data The action's data\n */", "export function reportTelemetryAction (actionType: string, data = ''): void {\n    reportTelemetry(EventKeys.Action, {\n        action_type: actionType,\n        result: data\n    })\n}\n\n/**\n * Reports telemetry about a settings change\n *\n * @param settingName The setting's name\n * @param newValue The new value\n * @param oldValue The old value\n */", "export function reportTelemetrySettingsChange (settingName: string, newValue: string, oldValue: string): void {\n    reportTelemetry(EventKeys.SettingChange, {\n        setting_name: settingName,\n        new_value: newValue,\n        old_value: oldValue\n    })\n}\n"]}
{"filename": "src/logging/Logger.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport * as fs from 'fs'\nimport * as os from 'os'\nimport * as path from 'path'\nimport { RemoteConsole } from 'vscode-languageserver'\n\nconst SERVER_LOG = 'languageServerLog.txt'\nconst MATLAB_LOG = 'matlabLog.txt'\n\nclass Logger {\n    private readonly _logDir: string\n    private readonly languageServerLogFile: string\n    private readonly matlabLogFile: string\n    private _console: RemoteConsole | null = null\n\n    constructor () {\n        // Create Log Directory\n        const pid = process.pid\n        this._logDir = path.join(os.tmpdir(), `matlabls_${pid}`)", "const MATLAB_LOG = 'matlabLog.txt'\n\nclass Logger {\n    private readonly _logDir: string\n    private readonly languageServerLogFile: string\n    private readonly matlabLogFile: string\n    private _console: RemoteConsole | null = null\n\n    constructor () {\n        // Create Log Directory\n        const pid = process.pid\n        this._logDir = path.join(os.tmpdir(), `matlabls_${pid}`)", "        if (fs.existsSync(this._logDir)) {\n            let i = 1\n            while (fs.existsSync(`${this._logDir}_${i}`)) { i++ }\n            this._logDir = `${this._logDir}_${i}`\n        }\n        fs.mkdirSync(this._logDir)\n\n        // Get name of log file\n        this.languageServerLogFile = path.join(this._logDir, SERVER_LOG)\n        this.matlabLogFile = path.join(this._logDir, MATLAB_LOG)\n    }\n\n    /**\n     * Initializes the logger with an output console.\n     *\n     * @param console The console which the Logger should output to\n     */\n    initialize (console: RemoteConsole): void {\n        this._console = console\n        this.log(`Log Directory: ${this._logDir}`)\n    }\n\n    /**\n     * Logs an informational message to both the console and the log file.\n     *\n     * @param message The message\n     */\n    log (message: string): void {\n        const msg = `(${getCurrentTimeString()}) matlabls: ${message}`\n        this._console?.log(msg)\n        this._writeToLogFile(msg, this.languageServerLogFile)\n    }\n\n    /**\n     * Logs a warning message to both the console and the log file.\n     *\n     * @param message The warning message\n     */\n    warn (message: string): void {\n        const msg = `(${getCurrentTimeString()}) matlabls - WARNING: ${message}`\n        this._console?.warn(msg)\n        this._writeToLogFile(msg, this.languageServerLogFile)\n    }\n\n    /**\n     * Logs an error message to both the console and the log file.\n     *\n     * @param message The error message\n     */\n    error (message: string): void {\n        const msg = `(${getCurrentTimeString()}) matlabls - ERROR: ${message}`\n        this._console?.error(msg)\n        this._writeToLogFile(msg, this.languageServerLogFile)\n    }\n\n    /**\n     * Log MATLAB application output to a log file on disk, separate from\n     * the language server logs.\n     *\n     * @param message The message\n     */\n    writeMatlabLog (message: string): void {\n        this._writeToLogFile(message, this.matlabLogFile)\n    }\n\n    public get logDir (): string {\n        return this._logDir\n    }\n\n    private _writeToLogFile (message: string, filePath: string): void {\n        // Log to file\n        fs.writeFile(\n            filePath,\n            `${message}\\n`,\n            { flag: 'a+' },\n            err => {", "                if (err !== null) {\n                    this._console?.error('Failed to write to log file')\n                }\n            }\n        )\n    }\n}\n\nfunction getCurrentTimeString (): string {\n    const d = new Date()\n    const strFormatter = (x: number): string => x.toString().padStart(2, '0')\n    return `${strFormatter(d.getHours())}:${strFormatter(d.getMinutes())}:${strFormatter(d.getSeconds())}`\n}\n\nexport default new Logger()\n", "function getCurrentTimeString (): string {\n    const d = new Date()\n    const strFormatter = (x: number): string => x.toString().padStart(2, '0')\n    return `${strFormatter(d.getHours())}:${strFormatter(d.getMinutes())}:${strFormatter(d.getSeconds())}`\n}\n\nexport default new Logger()\n"]}
{"filename": "src/indexing/Indexer.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport { URI } from 'vscode-uri'\nimport { MatlabConnection } from '../lifecycle/MatlabCommunicationManager'\nimport MatlabLifecycleManager from '../lifecycle/MatlabLifecycleManager'\nimport FileInfoIndex, { MatlabCodeData, RawCodeData } from './FileInfoIndex'\nimport * as fs from 'fs/promises'\nimport PathResolver from '../providers/navigation/PathResolver'\n\ninterface WorkspaceFileIndexedResponse {\n    isDone: boolean\n    filePath: string\n    codeData: RawCodeData\n}\n", "import PathResolver from '../providers/navigation/PathResolver'\n\ninterface WorkspaceFileIndexedResponse {\n    isDone: boolean\n    filePath: string\n    codeData: RawCodeData\n}\n\nclass Indexer {\n    private readonly INDEX_DOCUMENT_REQUEST_CHANNEL = '/matlabls/indexDocument/request'\n    private readonly INDEX_DOCUMENT_RESPONSE_CHANNEL = '/matlabls/indexDocument/response/' // Needs to be appended with requestId\n\n    private readonly INDEX_FOLDERS_REQUEST_CHANNEL = '/matlabls/indexFolders/request'\n    private readonly INDEX_FOLDERS_RESPONSE_CHANNEL = '/matlabls/indexFolders/response/' // Needs to be appended with requestId\n\n    private requestCt = 1\n\n    /**\n     * Indexes the given TextDocument and caches the data.\n     *\n     * @param textDocument The document being indexed\n     */\n    async indexDocument (textDocument: TextDocument): Promise<void> {\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "class Indexer {\n    private readonly INDEX_DOCUMENT_REQUEST_CHANNEL = '/matlabls/indexDocument/request'\n    private readonly INDEX_DOCUMENT_RESPONSE_CHANNEL = '/matlabls/indexDocument/response/' // Needs to be appended with requestId\n\n    private readonly INDEX_FOLDERS_REQUEST_CHANNEL = '/matlabls/indexFolders/request'\n    private readonly INDEX_FOLDERS_RESPONSE_CHANNEL = '/matlabls/indexFolders/response/' // Needs to be appended with requestId\n\n    private requestCt = 1\n\n    /**\n     * Indexes the given TextDocument and caches the data.\n     *\n     * @param textDocument The document being indexed\n     */\n    async indexDocument (textDocument: TextDocument): Promise<void> {\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n            return\n        }\n\n        const rawCodeData = await this.getCodeData(textDocument.getText(), textDocument.uri, matlabConnection)\n\n        const parsedCodeData = FileInfoIndex.parseAndStoreCodeData(textDocument.uri, rawCodeData)\n\n        void this.indexAdditionalClassData(parsedCodeData, matlabConnection, textDocument.uri)\n    }\n\n    /**\n     * Indexes all M files within the given list of folders.\n     *\n     * @param folders A list of folder URIs to be indexed\n     */\n    indexFolders (folders: string[]): void {\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n            return\n        }\n\n        const requestId = this.requestCt++\n        const responseSub = matlabConnection.subscribe(`${this.INDEX_FOLDERS_RESPONSE_CHANNEL}${requestId}`, message => {\n            const fileResults = message as WorkspaceFileIndexedResponse\n\n            if (fileResults.isDone) {\n                // No more files being indexed - safe to unsubscribe\n                matlabConnection.unsubscribe(responseSub)\n            }\n\n            // Convert file path to URI, which is used as an index when storing the code data\n            const fileUri = URI.file(fileResults.filePath).toString()\n            FileInfoIndex.parseAndStoreCodeData(fileUri, fileResults.codeData)\n        })\n\n        matlabConnection.publish(this.INDEX_FOLDERS_REQUEST_CHANNEL, {\n            folders,\n            requestId\n        })\n    }\n\n    /**\n     * Indexes the file for the given URI and caches the data.\n     *\n     * @param uri The URI for the file being indexed\n     */\n    async indexFile (uri: string): Promise<void> {\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "            if (fileResults.isDone) {\n                // No more files being indexed - safe to unsubscribe\n                matlabConnection.unsubscribe(responseSub)\n            }\n\n            // Convert file path to URI, which is used as an index when storing the code data\n            const fileUri = URI.file(fileResults.filePath).toString()\n            FileInfoIndex.parseAndStoreCodeData(fileUri, fileResults.codeData)\n        })\n\n        matlabConnection.publish(this.INDEX_FOLDERS_REQUEST_CHANNEL, {\n            folders,\n            requestId\n        })\n    }\n\n    /**\n     * Indexes the file for the given URI and caches the data.\n     *\n     * @param uri The URI for the file being indexed\n     */\n    async indexFile (uri: string): Promise<void> {\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n            return\n        }\n\n        const fileContentBuffer = await fs.readFile(URI.parse(uri).fsPath)\n        const code = fileContentBuffer.toString()\n        const rawCodeData = await this.getCodeData(code, uri, matlabConnection)\n\n        FileInfoIndex.parseAndStoreCodeData(uri, rawCodeData)\n    }\n\n    /**\n     * Retrieves data about classes, functions, and variables from the given document.\n     *\n     * @param code The code being parsed\n     * @param uri The URI associated with the code\n     * @param matlabConnection The connection to MATLAB\u00ae\n     *\n     * @returns The raw data extracted from the document\n     */\n    private async getCodeData (code: string, uri: string, matlabConnection: MatlabConnection): Promise<RawCodeData> {\n        const filePath = URI.parse(uri).fsPath\n\n        return await new Promise(resolve => {\n            const requestId = this.requestCt++\n            const responseSub = matlabConnection.subscribe(`${this.INDEX_DOCUMENT_RESPONSE_CHANNEL}${requestId}`, message => {\n                matlabConnection.unsubscribe(responseSub)\n\n                resolve(message as RawCodeData)\n            })\n\n            matlabConnection.publish(this.INDEX_DOCUMENT_REQUEST_CHANNEL, {\n                code,\n                filePath,\n                requestId\n            })\n        })\n    }\n\n    /**\n     * Indexes any supplemental files if the parsed code data represents a class.\n     * This will index any other files in a @ directory, as well as any direct base classes.\n     *\n     * @param parsedCodeData The parsed code data\n     * @param matlabConnection The connection to MATLAB\n     * @param uri The document's URI\n     */\n    private async indexAdditionalClassData (parsedCodeData: MatlabCodeData, matlabConnection: MatlabConnection, uri: string): Promise<void> {", "        if (parsedCodeData.classInfo == null) {\n            return\n        }\n\n        // Queue indexing for other files in @ class directory\n        const classDefFolder = parsedCodeData.classInfo.classDefFolder\n        if (classDefFolder !== '') {\n            this.indexFolders([classDefFolder])\n        }\n\n        // Find and queue indexing for parent classes\n        const baseClasses = parsedCodeData.classInfo.baseClasses\n\n        const resolvedBaseClasses = await PathResolver.resolvePaths(baseClasses, uri, matlabConnection)\n\n        resolvedBaseClasses.forEach(resolvedBaseClass => {\n            const uri = resolvedBaseClass.uri", "            if (uri !== '') {\n                void this.indexFile(uri)\n            }\n        })\n    }\n}\n\nexport default new Indexer()\n"]}
{"filename": "src/indexing/FileInfoIndex.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { Position, Range } from 'vscode-languageserver'\nimport { isPositionGreaterThan, isPositionLessThanOrEqualTo } from '../utils/PositionUtils'\n\n/**\n * Defines the structure of the raw data retrieved from MATLAB\u00ae.\n */\nexport interface RawCodeData {\n    classInfo: CodeDataClassInfo\n    functionInfo: CodeDataFunctionInfo[]\n    packageName: string\n    references: CodeDataReference[]\n}\n\n/**", "export interface RawCodeData {\n    classInfo: CodeDataClassInfo\n    functionInfo: CodeDataFunctionInfo[]\n    packageName: string\n    references: CodeDataReference[]\n}\n\n/**\n * Contains raw information about the file's class data\n */\ninterface CodeDataClassInfo {", " * Contains raw information about the file's class data\n */\ninterface CodeDataClassInfo {\n    isClassDef: boolean // Whether or not the file represents a class definition\n    hasClassInfo: boolean // Whether or not the file contains data related to a class (could be a class definition, or within a classdef folder)\n    name: string\n    range: CodeDataRange\n    declaration: CodeDataRange\n    properties: CodeDataMemberInfo[]\n    enumerations: CodeDataMemberInfo[]\n    classDefFolder: string\n    baseClasses: string[]\n}\n\n/**\n * Contains raw information about a function\n */", "interface CodeDataFunctionInfo {\n    name: string\n    range: CodeDataRange\n    parentClass: string\n    isPublic: boolean\n    declaration?: CodeDataRange // Will be undefined if function is prototype\n    variableInfo: CodeDataFunctionVariableInfo\n    globals: string[]\n    isPrototype: boolean\n}\n\n/**\n * Contains raw information about variables within a function\n */", "interface CodeDataFunctionVariableInfo {\n    definitions: CodeDataReference[]\n    references: CodeDataReference[]\n}\n\n/**\n * Represents a reference to a variable or function. The first element is the\n * name of the variable. The second element is the range of that reference.\n */\ntype CodeDataReference = [string, CodeDataRange]\n\n/**\n * Represents members of a class (e.g. Properties or Enumerations)\n */", "type CodeDataReference = [string, CodeDataRange]\n\n/**\n * Represents members of a class (e.g. Properties or Enumerations)\n */\ninterface CodeDataMemberInfo {\n    name: string\n    range: CodeDataRange\n    parentClass: string\n    isPublic: boolean\n}\n\n/**\n * Represents a range in the document.\n * Line and column values are 1-based.\n */", "interface CodeDataRange {\n    lineStart: number\n    charStart: number\n    lineEnd: number\n    charEnd: number\n}\n\nexport enum FunctionVisibility {\n    Public,\n    Private\n}\n\n/**\n * Serves as an cache of data extracted from files\n */", "class FileInfoIndex {\n    /**\n     * Maps document URI to the code data\n     */\n    readonly codeDataCache = new Map<string, MatlabCodeData>()\n\n    /**\n     * Maps class name to class info\n     */\n    readonly classInfoCache = new Map<string, MatlabClassInfo>()\n\n    /**\n     * Parses the raw data into a more usable form. Caches the resulting data\n     * in the code data index.\n     *\n     * @param uri The uri of the document from which the data was extracted\n     * @param rawCodeData The raw data\n     * @returns An object containing the parsed data\n     */\n    parseAndStoreCodeData (uri: string, rawCodeData: RawCodeData): MatlabCodeData {\n        let parsedCodeData: MatlabCodeData\n", "        if (rawCodeData.classInfo.hasClassInfo) {\n            let classInfo = this.classInfoCache.get(rawCodeData.classInfo.name)\n            if (classInfo == null) {\n                // Class not discovered yet - need to create info object\n                classInfo = new MatlabClassInfo(rawCodeData.classInfo, uri)\n                this.classInfoCache.set(classInfo.name, classInfo)\n            } else {\n                // Class already known - update data\n                classInfo.appendClassData(rawCodeData.classInfo, uri)\n            }\n            parsedCodeData = new MatlabCodeData(uri, rawCodeData, classInfo)\n        } else {\n            parsedCodeData = new MatlabCodeData(uri, rawCodeData)\n        }\n\n        // Store in cache\n        this.codeDataCache.set(uri, parsedCodeData)\n\n        return parsedCodeData\n    }\n}\n\n/**\n * Class to contain info about a class\n */", "export class MatlabClassInfo {\n    readonly methods: Map<string, MatlabFunctionInfo>\n    readonly properties: Map<string, MatlabClassMemberInfo>\n    readonly enumerations: Map<string, MatlabClassMemberInfo>\n\n    readonly name: string\n\n    baseClasses: string[]\n    readonly classDefFolder: string\n\n    range?: Range\n    declaration?: Range\n\n    constructor (rawClassInfo: CodeDataClassInfo, public uri?: string) {\n        this.methods = new Map<string, MatlabFunctionInfo>()\n        this.properties = new Map<string, MatlabClassMemberInfo>()\n        this.enumerations = new Map<string, MatlabClassMemberInfo>()\n\n        this.name = rawClassInfo.name\n\n        this.baseClasses = rawClassInfo.baseClasses\n        this.classDefFolder = rawClassInfo.classDefFolder\n", "        if (rawClassInfo.isClassDef) {\n            this.range = convertRange(rawClassInfo.range)\n            this.declaration = convertRange(rawClassInfo.declaration)\n        }\n\n        this.parsePropertiesAndEnums(rawClassInfo)\n    }\n\n    /**\n     * Appends the new data to the existing class data.\n     *\n     * Specifically, when the new data represents the classdef file, information about\n     * the URI, base classes, and range/declaration are added to the existing data.\n     *", "     * Appends the new data to the existing class data.\n     *\n     * Specifically, when the new data represents the classdef file, information about\n     * the URI, base classes, and range/declaration are added to the existing data.\n     *\n     * @param rawClassInfo The raw class data being appended\n     * @param uri The document URI corresponding to the class data\n     */\n    appendClassData (rawClassInfo: CodeDataClassInfo, uri?: string): void {\n        if (rawClassInfo.isClassDef) {\n            // Data contains class definition\n            this.uri = uri\n            this.baseClasses = rawClassInfo.baseClasses\n            this.range = convertRange(rawClassInfo.range)\n            this.declaration = convertRange(rawClassInfo.declaration)\n\n            // Since this is the classdef, we'll update all members. Clear them out here.\n            this.enumerations.clear()\n            this.properties.clear()\n            this.methods.clear()\n            this.parsePropertiesAndEnums(rawClassInfo)\n        } else {", "        if (rawClassInfo.isClassDef) {\n            // Data contains class definition\n            this.uri = uri\n            this.baseClasses = rawClassInfo.baseClasses\n            this.range = convertRange(rawClassInfo.range)\n            this.declaration = convertRange(rawClassInfo.declaration)\n\n            // Since this is the classdef, we'll update all members. Clear them out here.\n            this.enumerations.clear()\n            this.properties.clear()\n            this.methods.clear()\n            this.parsePropertiesAndEnums(rawClassInfo)\n        } else {", "            // Data contains supplementary class info - nothing to do in this situation\n        }\n    }\n\n    /**\n     * Appends info about a method to the class's info.\n     *\n     * This will not replace info about a method's implementation with info about a method prototype.\n     *\n     * @param functionInfo The method's information\n     */\n    addMethod (functionInfo: MatlabFunctionInfo): void {\n        // Only store the method if a non-prototype version of it is not\n        // already stored, as that will contain better information.\n        const name = functionInfo.name\n        const shouldStoreMethod = !functionInfo.isPrototype || (this.methods.get(name)?.isPrototype ?? true)\n", "        if (shouldStoreMethod) {\n            this.methods.set(name, functionInfo)\n        }\n    }\n\n    /**\n     * Parses information about the class's properties and enums from the raw data.\n     *\n     * @param rawClassInfo The raw class info\n     */\n    private parsePropertiesAndEnums (rawClassInfo: CodeDataClassInfo): void {\n        rawClassInfo.properties.forEach(propertyInfo => {\n            const name = propertyInfo.name\n            this.properties.set(name, new MatlabClassMemberInfo(propertyInfo))\n        })\n        rawClassInfo.enumerations.forEach(enumerationInfo => {\n            const name = enumerationInfo.name\n            this.enumerations.set(name, new MatlabClassMemberInfo(enumerationInfo))\n        })\n    }\n}\n\n/**\n * Class to contain info about members of a class (e.g. Properties or Enumerations)\n */", "     * @param rawClassInfo The raw class info\n     */\n    private parsePropertiesAndEnums (rawClassInfo: CodeDataClassInfo): void {\n        rawClassInfo.properties.forEach(propertyInfo => {\n            const name = propertyInfo.name\n            this.properties.set(name, new MatlabClassMemberInfo(propertyInfo))\n        })\n        rawClassInfo.enumerations.forEach(enumerationInfo => {\n            const name = enumerationInfo.name\n            this.enumerations.set(name, new MatlabClassMemberInfo(enumerationInfo))\n        })\n    }\n}\n\n/**\n * Class to contain info about members of a class (e.g. Properties or Enumerations)\n */", "export class MatlabClassMemberInfo {\n    readonly name: string\n    readonly range: Range\n    readonly parentClass: string\n\n    constructor (rawPropertyInfo: CodeDataMemberInfo) {\n        this.name = rawPropertyInfo.name\n        this.range = convertRange(rawPropertyInfo.range)\n        this.parentClass = rawPropertyInfo.parentClass\n    }\n}\n\n/**\n * Class to contain info about functions\n */", "export class MatlabFunctionInfo {\n    name: string\n\n    range: Range\n    declaration: Range | null\n\n    isPrototype: boolean\n\n    parentClass: string\n    isClassMethod: boolean\n    visibility: FunctionVisibility\n\n    variableInfo: Map<string, MatlabVariableInfo>\n\n    constructor (rawFunctionInfo: CodeDataFunctionInfo, public uri: string) {\n        this.name = rawFunctionInfo.name\n\n        this.range = convertRange(rawFunctionInfo.range)\n        this.declaration = rawFunctionInfo.declaration != null ? convertRange(rawFunctionInfo.declaration) : null\n\n        this.isPrototype = rawFunctionInfo.isPrototype\n\n        this.parentClass = rawFunctionInfo.parentClass\n        this.isClassMethod = this.parentClass !== ''\n        this.visibility = rawFunctionInfo.isPublic ? FunctionVisibility.Public : FunctionVisibility.Private\n\n        this.variableInfo = new Map<string, MatlabVariableInfo>()\n        this.parseVariableInfo(rawFunctionInfo)\n    }\n\n    /**", "     * Parses information about variables within the function from the raw data.\n     *\n     * @param rawFunctionInfo The raw function info\n     */\n    private parseVariableInfo (rawFunctionInfo: CodeDataFunctionInfo): void {\n        const variableInfo = rawFunctionInfo.variableInfo\n        const globals = rawFunctionInfo.globals\n\n        variableInfo.definitions.forEach(varDefinition => {\n            const name = varDefinition[0]\n            const range = convertRange(varDefinition[1])\n\n            const varInfo = this.getOrCreateVariableInfo(name, globals)\n            varInfo.addDefinition(range)\n        })\n\n        variableInfo.references.forEach(varReference => {\n            const name = varReference[0]\n            const range = convertRange(varReference[1])\n\n            const varInfo = this.getOrCreateVariableInfo(name, globals)\n            varInfo.addReference(range)\n        })\n    }\n\n    /**\n     * Attempts to retrieve an existing MatlabVariableInfo object for the requested variable.\n     * Creates a new instance if one does not already exist.\n     *\n     * @param name The variable's name\n     * @param globals The list of global variables\n     * @returns The MatlabVariableInfo object for the variable\n     */\n    private getOrCreateVariableInfo (name: string, globals: string[]): MatlabVariableInfo {\n        let variableInfo = this.variableInfo.get(name)", "        if (variableInfo == null) {\n            const isGlobal = globals.includes(name)\n            variableInfo = new MatlabVariableInfo(name, isGlobal)\n            this.variableInfo.set(name, variableInfo)\n        }\n        return variableInfo\n    }\n}\n\n/**\n * Class to contain info about variables\n */", "class MatlabVariableInfo {\n    readonly definitions: Range[] = []\n    readonly references: Range[] = []\n\n    constructor (public name: string, public isGlobal: boolean) {}\n\n    /**\n     * Add a definition for the variable\n     *\n     * @param range The range of the definition\n     */\n    addDefinition (range: Range): void {\n        this.definitions.push(range)\n    }\n\n    /**\n     * Add a reference for the variable\n     *\n     * @param range The range of the reference\n     */\n    addReference (range: Range): void {\n        this.references.push(range)\n    }\n}\n\n/**\n * Class to contain info about an entire file\n */", "export class MatlabCodeData {\n    readonly functions: Map<string, MatlabFunctionInfo>\n    readonly references: Map<string, Range[]>\n\n    readonly packageName: string\n\n    constructor (public uri: string, rawCodeData: RawCodeData, public classInfo?: MatlabClassInfo) {\n        this.functions = new Map<string, MatlabFunctionInfo>()\n        this.references = new Map<string, Range[]>()\n\n        this.packageName = rawCodeData.packageName\n\n        this.parseFunctions(rawCodeData.functionInfo)\n        this.parseReferences(rawCodeData.references)\n    }\n\n    /**", "     * Whether or not the code data represents a class definition\n     */\n    get isClassDef (): boolean {\n        return this.classInfo != null\n    }\n\n    /**\n     * Whether or not the code data represents a main classdef file.\n     * For @aclass/aclass.m this returns true\n     * For @aclass/amethod.m this returns false.\n     */\n    get isMainClassDefDocument (): boolean {\n        return this.isClassDef && this.uri === this.classInfo?.uri\n    }\n\n    /**", "     * Finds the info for the function containing the given position.\n     *\n     * @param position A position in the document\n     * @returns The info for the function containing the position, or null if no function contains that position.\n     */\n    findContainingFunction (position: Position): MatlabFunctionInfo | null {\n        let containingFunction: MatlabFunctionInfo | null = null\n\n        for (const functionInfo of this.functions.values()) {\n            const start = functionInfo.range.start\n            const end = functionInfo.range.end\n\n            // Check if position is within range", "        for (const functionInfo of this.functions.values()) {\n            const start = functionInfo.range.start\n            const end = functionInfo.range.end\n\n            // Check if position is within range\n            if (isPositionLessThanOrEqualTo(start, position) && isPositionGreaterThan(end, position)) {\n                if (containingFunction == null) {\n                    containingFunction = functionInfo\n                } else {\n                    // Prefer a narrower function if we already have a match (e.g. nested functions)\n                    if (isPositionGreaterThan(start, containingFunction.range.start)) {\n                        containingFunction = functionInfo\n                    }\n                }\n            }\n        }\n\n        return containingFunction\n    }\n\n    /**\n     * Parses information about the file's functions.\n     *\n     * @param functionInfos The raw information about the functions in the file\n     */\n    private parseFunctions (functionInfos: CodeDataFunctionInfo[]): void {\n        functionInfos.forEach(functionInfo => {\n            const fcnInfo = new MatlabFunctionInfo(functionInfo, this.uri)\n            this.functions.set(fcnInfo.name, fcnInfo)\n", "                    // Prefer a narrower function if we already have a match (e.g. nested functions)\n                    if (isPositionGreaterThan(start, containingFunction.range.start)) {\n                        containingFunction = functionInfo\n                    }\n                }\n            }\n        }\n\n        return containingFunction\n    }\n\n    /**\n     * Parses information about the file's functions.\n     *\n     * @param functionInfos The raw information about the functions in the file\n     */\n    private parseFunctions (functionInfos: CodeDataFunctionInfo[]): void {\n        functionInfos.forEach(functionInfo => {\n            const fcnInfo = new MatlabFunctionInfo(functionInfo, this.uri)\n            this.functions.set(fcnInfo.name, fcnInfo)\n", "            if (fcnInfo.isClassMethod) {\n                // Store the function info with the class as well\n                this.classInfo?.addMethod(fcnInfo)\n            }\n        })\n    }\n\n    /**\n     * Parses information about the file's variable and function references.\n     *\n     * @param references The raw information about the references in the file\n     */\n    private parseReferences (references: CodeDataReference[]): void {\n        references.forEach(reference => {\n            const funcName = reference[0]\n            const range = convertRange(reference[1])\n", "     * Parses information about the file's variable and function references.\n     *\n     * @param references The raw information about the references in the file\n     */\n    private parseReferences (references: CodeDataReference[]): void {\n        references.forEach(reference => {\n            const funcName = reference[0]\n            const range = convertRange(reference[1])\n\n            if (!this.references.has(funcName)) {\n                // First time seeing this reference\n                this.references.set(funcName, [range])\n            } else {\n                this.references.get(funcName)?.push(range)\n            }\n        })\n    }\n}\n\n/**\n * Converts from a CodeDataRange to a Range as expected by the language server APIs.\n *\n * @param codeDataRange The CodeDataRange\n * @returns A Range corresponding to the inputted range\n */", "            if (!this.references.has(funcName)) {\n                // First time seeing this reference\n                this.references.set(funcName, [range])\n            } else {\n                this.references.get(funcName)?.push(range)\n            }\n        })\n    }\n}\n\n/**\n * Converts from a CodeDataRange to a Range as expected by the language server APIs.\n *\n * @param codeDataRange The CodeDataRange\n * @returns A Range corresponding to the inputted range\n */", "function convertRange (codeDataRange: CodeDataRange): Range {\n    // When converting, need to change value from 1-based to 0-based\n    return Range.create(\n        codeDataRange.lineStart - 1,\n        codeDataRange.charStart - 1,\n        codeDataRange.lineEnd - 1,\n        codeDataRange.charEnd - 1\n    )\n}\n\nexport default new FileInfoIndex()\n"]}
{"filename": "src/indexing/WorkspaceIndexer.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { ClientCapabilities, WorkspaceFolder, WorkspaceFoldersChangeEvent } from 'vscode-languageserver'\nimport ConfigurationManager from '../lifecycle/ConfigurationManager'\nimport { connection } from '../server'\nimport Indexer from './Indexer'\n\n/**\n * Handles indexing files in the user's workspace to gather data about classes,\n * functions, and variables.", " * Handles indexing files in the user's workspace to gather data about classes,\n * functions, and variables.\n */\nclass WorkspaceIndexer {\n    private isWorkspaceIndexingSupported = false\n\n    /**\n     * Sets up workspace change listeners, if supported.\n     *\n     * @param capabilities The client capabilities, which contains information about\n     * whether the client supports workspaces.\n     */\n    setupCallbacks (capabilities: ClientCapabilities): void {\n        this.isWorkspaceIndexingSupported = capabilities.workspace?.workspaceFolders ?? false\n", "        if (!this.isWorkspaceIndexingSupported) {\n            // Workspace indexing not supported\n            return\n        }\n\n        connection.workspace.onDidChangeWorkspaceFolders((params: WorkspaceFoldersChangeEvent) => {\n            void this.handleWorkspaceFoldersAdded(params.added)\n        })\n    }\n\n    /**\n     * Attempts to index the files in the user's workspace.\n     */\n    async indexWorkspace (): Promise<void> {", "        if (!(await this.shouldIndexWorkspace())) {\n            return\n        }\n\n        const folders = await connection.workspace.getWorkspaceFolders()\n\n        if (folders == null) {\n            return\n        }\n\n        Indexer.indexFolders(folders.map(folder => folder.uri))\n    }\n\n    /**\n     * Handles when new folders are added to the user's workspace by indexing them.\n     *\n     * @param folders The list of folders added to the workspace\n     */\n    private async handleWorkspaceFoldersAdded (folders: WorkspaceFolder[]): Promise<void> {", "        if (!(await this.shouldIndexWorkspace())) {\n            return\n        }\n\n        Indexer.indexFolders(folders.map(folder => folder.uri))\n    }\n\n    /**\n     * Determines whether or not the workspace should be indexed.\n     * The workspace should be indexed if the client supports workspaces, and if the\n     * workspace indexing setting is true.\n     *\n     * @returns True if workspace indexing should occurr, false otherwise.\n     */\n    private async shouldIndexWorkspace (): Promise<boolean> {\n        const shouldIndexWorkspace = (await ConfigurationManager.getConfiguration()).indexWorkspace\n        return this.isWorkspaceIndexingSupported && shouldIndexWorkspace\n    }\n}\n\nexport default new WorkspaceIndexer()\n"]}
{"filename": "src/indexing/DocumentIndexer.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport Indexer from './Indexer'\nimport FileInfoIndex from './FileInfoIndex'\n\nconst INDEXING_DELAY = 500 // Delay (in ms) after keystroke before attempting to re-index the document\n\n/**\n * Handles indexing a currently open document to gather data about classes,", "/**\n * Handles indexing a currently open document to gather data about classes,\n * functions, and variables.\n */\nclass DocumentIndexer {\n    private readonly pendingFilesToIndex = new Map<string, NodeJS.Timer>()\n\n    /**\n     * Queues a document to be indexed. This handles debouncing so that\n     * indexing is not performed on every keystroke.\n     *\n     * @param textDocument The document to be indexed\n     */\n    queueIndexingForDocument (textDocument: TextDocument): void {\n        const uri = textDocument.uri\n        this.clearTimerForDocumentUri(uri)\n        this.pendingFilesToIndex.set(\n            uri,\n            setTimeout(() => {\n                this.indexDocument(textDocument)\n            }, INDEXING_DELAY) // Specify timeout for debouncing, to avoid re-indexing every keystroke while a user types\n        )\n    }\n\n    /**\n     * Indexes the document and caches the data.\n     *\n     * @param textDocument The document being indexed\n     */\n    indexDocument (textDocument: TextDocument): void {\n        void Indexer.indexDocument(textDocument)\n    }\n\n    /**\n     * Clears any active indexing timers for the provided document URI.\n     *\n     * @param uri The document URI\n     */\n    private clearTimerForDocumentUri (uri: string): void {\n        const timerId = this.pendingFilesToIndex.get(uri)", "        if (timerId != null) {\n            clearTimeout(timerId)\n            this.pendingFilesToIndex.delete(uri)\n        }\n    }\n\n    /**\n     * Ensure that @param textDocument is fully indexed and up to date by flushing any pending indexing tasks\n     * and then forcing an index. This is intended to service requests like documentSymbols where returning\n     * stale info could be confusing.\n     *\n     * @param textDocument The document to index\n     */\n    async ensureDocumentIndexIsUpdated (textDocument: TextDocument): Promise<void> {\n        const uri = textDocument.uri", "        if (this.pendingFilesToIndex.has(uri)) {\n            this.clearTimerForDocumentUri(uri)\n            await Indexer.indexDocument(textDocument)\n        }\n        if (!FileInfoIndex.codeDataCache.has(uri)) {\n            await Indexer.indexDocument(textDocument)\n        }\n    }\n}\n\nexport default new DocumentIndexer()\n"]}
{"filename": "src/providers/formatting/FormatSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { DocumentFormattingParams, FormattingOptions, HandlerResult, Position, Range, TextDocuments, TextEdit } from 'vscode-languageserver'\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport LifecycleNotificationHelper from '../../lifecycle/LifecycleNotificationHelper'\nimport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\nimport { ActionErrorConditions, Actions, reportTelemetryAction } from '../../logging/TelemetryUtils'\nimport { connection } from '../../server'\nimport * as TextDocumentUtils from '../../utils/TextDocumentUtils'\n\ninterface FormatDocumentResponse {\n    data: string // The formatted document contents\n}\n\n/**\n * Handles requests for format-related features.\n * Currently, this handles formatting the entire document. In the future, this may be expanded to\n * include formatting a range witin the documemt.\n */", "import * as TextDocumentUtils from '../../utils/TextDocumentUtils'\n\ninterface FormatDocumentResponse {\n    data: string // The formatted document contents\n}\n\n/**\n * Handles requests for format-related features.\n * Currently, this handles formatting the entire document. In the future, this may be expanded to\n * include formatting a range witin the documemt.\n */", "class FormatSupportProvider {\n    private readonly REQUEST_CHANNEL = '/matlabls/formatDocument/request'\n    private readonly RESPONSE_CHANNEL = '/matlabls/formatDocument/response'\n\n    /**\n     * Handles a request for document formatting.\n     *\n     * @param params Parameters from the onDocumentFormatting request\n     * @param documentManager The text document manager\n     * @param connection The language server connection\n     * @returns An array of text edits required for the formatting operation, or null if the operation cannot be performed\n     */\n    async handleDocumentFormatRequest (params: DocumentFormattingParams, documentManager: TextDocuments<TextDocument>): Promise<HandlerResult<TextEdit[] | null | undefined, void>> {\n        const docToFormat = documentManager.get(params.textDocument.uri)", "        if (docToFormat == null) {\n            return null\n        }\n\n        return await this.formatDocument(docToFormat, params.options)\n    }\n\n    /**\n     * Determines the edits required to format the given document.\n     *\n     * @param doc The document being formatted\n     * @param options The formatting options\n     * @returns An array of text edits required to format the document\n     */\n    private async formatDocument (doc: TextDocument, options: FormattingOptions): Promise<TextEdit[]> {\n        // For format, we try to instantiate MATLAB\u00ae if it is not already running\n        const matlabConnection = await MatlabLifecycleManager.getOrCreateMatlabConnection(connection)\n\n        // If MATLAB is not available, no-op", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n            LifecycleNotificationHelper.notifyMatlabRequirement()\n            reportTelemetryAction(Actions.FormatDocument, ActionErrorConditions.MatlabUnavailable)\n            return []\n        }\n\n        return await new Promise<TextEdit[]>(resolve => {\n            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n                matlabConnection.unsubscribe(responseSub)\n                const newCode = (message as FormatDocumentResponse).data\n                const endRange = TextDocumentUtils.getRangeUntilLineEnd(doc, doc.lineCount - 1, 0)\n                const edit = TextEdit.replace(Range.create(\n                    Position.create(0, 0),\n                    endRange.end\n                ), newCode)\n                reportTelemetryAction(Actions.FormatDocument)\n                resolve([edit])\n            })\n\n            matlabConnection.publish(this.REQUEST_CHANNEL, {\n                data: doc.getText(),\n                insertSpaces: options.insertSpaces,\n                tabSize: options.tabSize\n            })\n        })\n    }\n}\n\nexport default new FormatSupportProvider()\n"]}
{"filename": "src/providers/navigation/NavigationSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { DefinitionParams, DocumentSymbolParams, Location, Position, Range, ReferenceParams, SymbolInformation, SymbolKind, TextDocuments } from 'vscode-languageserver'\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport { URI } from 'vscode-uri'\nimport * as fs from 'fs/promises'\nimport FileInfoIndex, { FunctionVisibility, MatlabClassMemberInfo, MatlabCodeData, MatlabFunctionInfo } from '../../indexing/FileInfoIndex'\nimport Indexer from '../../indexing/Indexer'\nimport { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\nimport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'", "import { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\nimport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\nimport { getTextOnLine } from '../../utils/TextDocumentUtils'\nimport PathResolver from './PathResolver'\nimport { connection } from '../../server'\nimport LifecycleNotificationHelper from '../../lifecycle/LifecycleNotificationHelper'\nimport { ActionErrorConditions, Actions, reportTelemetryAction } from '../../logging/TelemetryUtils'\nimport DocumentIndexer from '../../indexing/DocumentIndexer'\n\n/**", "\n/**\n * Represents a code expression, either a single identifier or a dotted expression.\n * For example, \"plot\" or \"pkg.Class.func\".\n */\nclass Expression {\n    constructor (public components: string[], public selectedComponent: number) {}\n\n    /**\n     * The full, dotted expression\n     */\n    get fullExpression (): string {\n        return this.components.join('.')\n    }\n\n    /**\n     * The dotted expression up to and including the selected component\n     */\n    get targetExpression (): string {\n        return this.components.slice(0, this.selectedComponent + 1).join('.')\n    }\n\n    /**\n     * Only the selected component of the expression\n     */\n    get unqualifiedTarget (): string {\n        return this.components[this.selectedComponent]\n    }\n\n    /**\n     * The first component of the expression\n     */\n    get first (): string {\n        return this.components[0]\n    }\n\n    /**\n     * The last component of the expression\n     */\n    get last (): string {\n        return this.components[this.components.length - 1]\n    }\n}\n", "export enum RequestType {\n    Definition,\n    References,\n    DocumentSymbol\n}\n\nfunction reportTelemetry (type: RequestType, errorCondition = ''): void {\n    let action: Actions\n    switch (type) {\n        case RequestType.Definition:\n            action = Actions.GoToDefinition\n            break\n        case RequestType.References:\n            action = Actions.GoToReference\n            break\n        case RequestType.DocumentSymbol:\n            action = Actions.DocumentSymbol\n            break\n    }\n    reportTelemetryAction(action, errorCondition)\n}\n\n/**\n * Handles requests for navigation-related features.\n * Currently, this handles Go-to-Definition and Go-to-References.\n */", "class NavigationSupportProvider {\n    private readonly DOTTED_IDENTIFIER_REGEX = /[\\w.]+/\n\n    /**\n     * Handles requests for definitions or references.\n     *\n     * @param params Parameters for the definition or references request\n     * @param documentManager The text document manager\n     * @param requestType The type of request (definition or references)\n     * @returns An array of locations\n     */\n    async handleDefOrRefRequest (params: DefinitionParams | ReferenceParams, documentManager: TextDocuments<TextDocument>, requestType: RequestType): Promise<Location[]> {\n        const matlabConnection = await MatlabLifecycleManager.getOrCreateMatlabConnection(connection)", "     * @param requestType The type of request (definition or references)\n     * @returns An array of locations\n     */\n    async handleDefOrRefRequest (params: DefinitionParams | ReferenceParams, documentManager: TextDocuments<TextDocument>, requestType: RequestType): Promise<Location[]> {\n        const matlabConnection = await MatlabLifecycleManager.getOrCreateMatlabConnection(connection)\n        if (matlabConnection == null) {\n            LifecycleNotificationHelper.notifyMatlabRequirement()\n            reportTelemetry(requestType, ActionErrorConditions.MatlabUnavailable)\n            return []\n        }\n\n        const uri = params.textDocument.uri\n        const textDocument = documentManager.get(uri)\n", "        if (textDocument == null) {\n            reportTelemetry(requestType, 'No document')\n            return []\n        }\n\n        // Find ID for which to find the definition or references\n        const expression = this.getTarget(textDocument, params.position)\n\n        if (expression == null) {\n            // No target found\n            reportTelemetry(requestType, 'No navigation target')\n            return []\n        }\n", "        if (expression == null) {\n            // No target found\n            reportTelemetry(requestType, 'No navigation target')\n            return []\n        }\n\n        if (requestType === RequestType.Definition) {\n            return await this.findDefinition(uri, params.position, expression, matlabConnection)\n        } else {\n            return this.findReferences(uri, params.position, expression)\n        }\n    }\n\n    /**\n     * Caches document symbols for URIs to deal with the case when indexing\n     * temporarily fails while the user is in the middle of an edit. We might\n     * consider moving logic like this into the indexer logic later as clearing\n     * out index data in the middle of an edit will have other ill effects.\n     */\n    private readonly _documentSymbolCache = new Map<string, SymbolInformation[]>()\n\n    /**\n     *\n     * @param params Parameters for the document symbol request\n     * @param documentManager The text document manager", "     * @param requestType The type of request\n     * @returns Array of symbols found in the document\n     */\n    async handleDocumentSymbol (params: DocumentSymbolParams, documentManager: TextDocuments<TextDocument>, requestType: RequestType): Promise<SymbolInformation[]> {\n        // Get or wait for MATLAB connection to handle files opened before MATLAB is ready.\n        // Calling getOrCreateMatlabConnection would effectively make the onDemand launch\n        // setting act as onStart.\n        const matlabConnection = await MatlabLifecycleManager.getMatlabConnectionAsync()\n        if (matlabConnection == null) {\n            reportTelemetry(requestType, ActionErrorConditions.MatlabUnavailable)\n            return []\n        }\n\n        const uri = params.textDocument.uri\n        const textDocument = documentManager.get(uri)\n", "        if (matlabConnection == null) {\n            reportTelemetry(requestType, ActionErrorConditions.MatlabUnavailable)\n            return []\n        }\n\n        const uri = params.textDocument.uri\n        const textDocument = documentManager.get(uri)\n\n        if (textDocument == null) {\n            reportTelemetry(requestType, 'No document')\n            return []\n        }\n        // Ensure document index is up to date\n        await DocumentIndexer.ensureDocumentIndexIsUpdated(textDocument)\n        const codeData = FileInfoIndex.codeDataCache.get(uri)", "        if (textDocument == null) {\n            reportTelemetry(requestType, 'No document')\n            return []\n        }\n        // Ensure document index is up to date\n        await DocumentIndexer.ensureDocumentIndexIsUpdated(textDocument)\n        const codeData = FileInfoIndex.codeDataCache.get(uri)\n        if (codeData == null) {\n            reportTelemetry(requestType, 'No code data')\n            return []\n        }\n        // Result symbols in documented\n        const result: SymbolInformation[] = []\n        // Avoid duplicates coming from different data sources\n        const visitedRanges: Set<Range> = new Set()\n        /**\n         * Push symbol info to result set\n         */", "        function pushSymbol (name: string, kind: SymbolKind, symbolRange: Range): void {\n            if (!visitedRanges.has(symbolRange)) {\n                result.push(SymbolInformation.create(name, kind, symbolRange, uri))\n                visitedRanges.add(symbolRange)\n            }\n        }\n        if (codeData.isMainClassDefDocument && codeData.classInfo != null) {\n            const classInfo = codeData.classInfo\n            if (codeData.classInfo.range != null) {\n                pushSymbol(classInfo.name, SymbolKind.Class, codeData.classInfo.range)\n            }\n            classInfo.methods.forEach((info, name) => pushSymbol(name, SymbolKind.Method, info.range))\n            classInfo.enumerations.forEach((info, name) => pushSymbol(name, SymbolKind.EnumMember, info.range))\n            classInfo.properties.forEach((info, name) => pushSymbol(name, SymbolKind.Property, info.range))\n        }\n        codeData.functions.forEach((info, name) => pushSymbol(name, info.isClassMethod ? SymbolKind.Method : SymbolKind.Function, info.range))\n        /**\n         * Handle a case when the indexer fails due to the user being in the middle of an edit.\n         * Here the documentSymbol cache has some symbols but the codeData cache has none. So we\n         * assume that the user will soon fix their code and just fall back to what we knew for now.\n         */", "            if (codeData.classInfo.range != null) {\n                pushSymbol(classInfo.name, SymbolKind.Class, codeData.classInfo.range)\n            }\n            classInfo.methods.forEach((info, name) => pushSymbol(name, SymbolKind.Method, info.range))\n            classInfo.enumerations.forEach((info, name) => pushSymbol(name, SymbolKind.EnumMember, info.range))\n            classInfo.properties.forEach((info, name) => pushSymbol(name, SymbolKind.Property, info.range))\n        }\n        codeData.functions.forEach((info, name) => pushSymbol(name, info.isClassMethod ? SymbolKind.Method : SymbolKind.Function, info.range))\n        /**\n         * Handle a case when the indexer fails due to the user being in the middle of an edit.\n         * Here the documentSymbol cache has some symbols but the codeData cache has none. So we\n         * assume that the user will soon fix their code and just fall back to what we knew for now.\n         */", "        if (result.length === 0) {\n            const cached = this._documentSymbolCache.get(uri) ?? result\n            if (cached.length > 0) {\n                return cached\n            }\n        }\n        this._documentSymbolCache.set(uri, result)\n        return result\n    }\n\n    /**\n     * Gets the definition/references request target expression.\n     *\n     * @param textDocument The text document\n     * @param position The position in the document\n     * @returns The expression at the given position, or null if no expression is found\n     */\n    private getTarget (textDocument: TextDocument, position: Position): Expression | null {\n        const idAtPosition = this.getIdentifierAtPosition(textDocument, position)\n", "        if (idAtPosition.identifier === '') {\n            return null\n        }\n\n        const idComponents = idAtPosition.identifier.split('.')\n\n        // Determine what component was targeted\n        let length = 0\n        let i = 0\n        while (i < idComponents.length && length <= position.character - idAtPosition.start) {\n            length += idComponents[i].length + 1 // +1 for '.'\n            i++\n        }\n\n        return new Expression(idComponents, i - 1) // Compensate for extra increment in loop\n    }\n\n    /**\n     * Determines the identifier (or dotted expression) at the given position in the document.\n     *\n     * @param textDocument The text document\n     * @param position The position in the document\n     * @returns An object containing the string identifier at the position, as well as the column number at which the identifier starts.\n     */\n    private getIdentifierAtPosition (textDocument: TextDocument, position: Position): { identifier: string, start: number } {\n        let lineText = getTextOnLine(textDocument, position.line)\n\n        const result = {\n            identifier: '',\n            start: -1\n        }\n\n        let matchResults = lineText.match(this.DOTTED_IDENTIFIER_REGEX)\n        let offset = 0\n", "        while (i < idComponents.length && length <= position.character - idAtPosition.start) {\n            length += idComponents[i].length + 1 // +1 for '.'\n            i++\n        }\n\n        return new Expression(idComponents, i - 1) // Compensate for extra increment in loop\n    }\n\n    /**\n     * Determines the identifier (or dotted expression) at the given position in the document.\n     *\n     * @param textDocument The text document\n     * @param position The position in the document\n     * @returns An object containing the string identifier at the position, as well as the column number at which the identifier starts.\n     */\n    private getIdentifierAtPosition (textDocument: TextDocument, position: Position): { identifier: string, start: number } {\n        let lineText = getTextOnLine(textDocument, position.line)\n\n        const result = {\n            identifier: '',\n            start: -1\n        }\n\n        let matchResults = lineText.match(this.DOTTED_IDENTIFIER_REGEX)\n        let offset = 0\n", "        while (matchResults != null) {\n            if (matchResults.index == null || matchResults.index > position.character) {\n                // Already passed the cursor - no match found\n                break\n            }\n\n            const startChar = offset + matchResults.index\n            if (startChar + matchResults[0].length >= position.character) {\n                // Found overlapping identifier\n                result.identifier = matchResults[0]\n                result.start = startChar\n                break\n            }\n\n            // Match found too early in line - check for following matches\n            lineText = lineText.substring(matchResults.index + matchResults[0].length)\n            offset = startChar + matchResults[0].length\n\n            matchResults = lineText.match(this.DOTTED_IDENTIFIER_REGEX)\n        }\n\n        return result\n    }\n\n    /**\n     * Finds the definition(s) of an expression.\n     *\n     * @param uri The URI of the document containing the expression\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for the definition\n     * @param matlabConnection The connection to MATLAB\u00ae\n     * @returns The definition location(s)\n     */\n    private async findDefinition (uri: string, position: Position, expression: Expression, matlabConnection: MatlabConnection): Promise<Location[]> {\n        // Get code data for current file\n        const codeData = FileInfoIndex.codeDataCache.get(uri)\n", "        if (codeData == null) {\n            // File not indexed - unable to look for definition\n            reportTelemetry(RequestType.Definition, 'File not indexed')\n            return []\n        }\n\n        // First check within the current file's code data\n        const definitionInCodeData = this.findDefinitionInCodeData(uri, position, expression, codeData)\n\n        if (definitionInCodeData != null) {\n            reportTelemetry(RequestType.Definition)\n            return definitionInCodeData\n        }\n\n        // Check the MATLAB path\n        const definitionOnPath = await this.findDefinitionOnPath(uri, position, expression, matlabConnection)\n", "        if (definitionInCodeData != null) {\n            reportTelemetry(RequestType.Definition)\n            return definitionInCodeData\n        }\n\n        // Check the MATLAB path\n        const definitionOnPath = await this.findDefinitionOnPath(uri, position, expression, matlabConnection)\n\n        if (definitionOnPath != null) {\n            reportTelemetry(RequestType.Definition)\n            return definitionOnPath\n        }\n\n        // If not on path, may be in user's workspace\n        reportTelemetry(RequestType.Definition)\n        return this.findDefinitionInWorkspace(uri, expression)\n    }\n\n    /**\n     * Searches the given code data for the definition(s) of the given expression\n     *\n     * @param uri The URI corresponding to the provided code data\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for the definition\n     * @param codeData The code data which is being searched\n     * @returns The definition location(s), or null if no definition was found\n     */\n    private findDefinitionInCodeData (uri: string, position: Position, expression: Expression, codeData: MatlabCodeData): Location[] | null {\n        // If first part of expression targeted - look for a local variable", "        if (definitionOnPath != null) {\n            reportTelemetry(RequestType.Definition)\n            return definitionOnPath\n        }\n\n        // If not on path, may be in user's workspace\n        reportTelemetry(RequestType.Definition)\n        return this.findDefinitionInWorkspace(uri, expression)\n    }\n\n    /**\n     * Searches the given code data for the definition(s) of the given expression\n     *\n     * @param uri The URI corresponding to the provided code data\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for the definition\n     * @param codeData The code data which is being searched\n     * @returns The definition location(s), or null if no definition was found\n     */\n    private findDefinitionInCodeData (uri: string, position: Position, expression: Expression, codeData: MatlabCodeData): Location[] | null {\n        // If first part of expression targeted - look for a local variable", "        if (expression.selectedComponent === 0) {\n            const containingFunction = codeData.findContainingFunction(position)\n            if (containingFunction != null) {\n                const varDefs = this.getVariableDefsOrRefs(containingFunction, expression.unqualifiedTarget, uri, RequestType.Definition)\n                if (varDefs != null) {\n                    return varDefs\n                }\n            }\n        }\n\n        // Check for functions in file\n        let functionDeclaration = this.getFunctionDeclaration(codeData, expression.fullExpression)", "        if (functionDeclaration != null) {\n            return [this.getLocationForFunctionDeclaration(functionDeclaration)]\n        }\n\n        // Check for definitions within classes\n        if (codeData.isClassDef && codeData.classInfo != null) {\n            // Look for methods/properties within class definitions (e.g. obj.foo)\n            functionDeclaration = this.getFunctionDeclaration(codeData, expression.last)\n            if (functionDeclaration != null) {\n                return [this.getLocationForFunctionDeclaration(functionDeclaration)]\n            }\n\n            // Look for possible properties", "            if (functionDeclaration != null) {\n                return [this.getLocationForFunctionDeclaration(functionDeclaration)]\n            }\n\n            // Look for possible properties\n            if (expression.selectedComponent === 1) {\n                const propertyDeclaration = this.getPropertyDeclaration(codeData, expression.last)\n                if (propertyDeclaration != null) {\n                    const propertyRange = Range.create(propertyDeclaration.range.start, propertyDeclaration.range.end)\n                    const uri = codeData.classInfo.uri\n                    if (uri != null) {\n                        return [Location.create(uri, propertyRange)]\n                    }\n                }\n            }\n        }\n\n        return null\n    }\n\n    /**", "                    if (uri != null) {\n                        return [Location.create(uri, propertyRange)]\n                    }\n                }\n            }\n        }\n\n        return null\n    }\n\n    /**", "     * Gets the location of the given function's declaration. If the function does not have\n     * a definite declaration, provides a location at the beginning of the file. For example,\n     * this may be the case for built-in functions like 'plot'.\n     *\n     * @param functionInfo Info about the function\n     * @returns The location of the function declaration\n     */\n    private getLocationForFunctionDeclaration (functionInfo: MatlabFunctionInfo): Location {\n        const range = functionInfo.declaration ?? Range.create(0, 0, 0, 0)\n        return Location.create(functionInfo.uri, range)\n    }\n\n    /**\n     * Searches the MATLAB path for the definition of the given expression\n     *\n     * @param uri The URI of the file containing the expression\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for the definition\n     * @param matlabConnection The connection to MATLAB\n     * @returns The definition location(s), or null if no definition was found\n     */\n    private async findDefinitionOnPath (uri: string, position: Position, expression: Expression, matlabConnection: MatlabConnection): Promise<Location[] | null> {\n        const resolvedPath = await PathResolver.resolvePaths([expression.targetExpression], uri, matlabConnection)\n        const resolvedUri = resolvedPath[0].uri\n", "        if (resolvedUri === '') {\n            // Not found\n            return null\n        }\n\n        // Ensure URI is not a directory. This can occur with some packages.\n        const fileStats = await fs.stat(URI.parse(resolvedUri).fsPath)\n        if (fileStats.isDirectory()) {\n            return null\n        }\n", "        if (!FileInfoIndex.codeDataCache.has(resolvedUri)) {\n            // Index target file, if necessary\n            await Indexer.indexFile(resolvedUri)\n        }\n\n        const codeData = FileInfoIndex.codeDataCache.get(resolvedUri)\n\n        // Find definition location within determined file\n        if (codeData != null) {\n            const definition = this.findDefinitionInCodeData(resolvedUri, position, expression, codeData)\n", "        if (codeData != null) {\n            const definition = this.findDefinitionInCodeData(resolvedUri, position, expression, codeData)\n\n            if (definition != null) {\n                return definition\n            }\n        }\n\n        // If a definition location cannot be identified, default to the beginning of the file.\n        // This could be the case for builtin functions which don't actually have a definition in a .m file (e.g. plot).\n        return [Location.create(resolvedUri, Range.create(0, 0, 0, 0))]\n    }\n\n    /**\n     * Searches the (indexed) workspace for the definition of the given expression. These files may not be on the MATLAB path.\n     *\n     * @param uri The URI of the file containing the expression\n     * @param expression The expression for which we are looking for the definition\n     * @returns The definition location(s). Returns an empty array if no definitions found.\n     */\n    private findDefinitionInWorkspace (uri: string, expression: Expression): Location[] {\n        const expressionToMatch = expression.fullExpression\n", "        for (const [fileUri, fileCodeData] of FileInfoIndex.codeDataCache) {\n            if (uri === fileUri) continue // Already looked in the current file\n\n            let match = fileCodeData.packageName === '' ? '' : fileCodeData.packageName + '.'\n\n            if (fileCodeData.classInfo != null) {\n                const classUri = fileCodeData.classInfo.uri\n                if (classUri == null) continue\n\n                // Check class name\n                match += fileCodeData.classInfo.name", "                // Check class name\n                match += fileCodeData.classInfo.name\n                if (expressionToMatch === match) {\n                    const range = fileCodeData.classInfo.declaration ?? Range.create(0, 0, 0, 0)\n                    return [Location.create(classUri, range)]\n                }\n\n                // Check properties\n                const matchedProperty = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.properties)\n                if (matchedProperty != null) {\n                    return matchedProperty\n                }\n\n                // Check enums\n                const matchedEnum = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.enumerations)", "                if (matchedProperty != null) {\n                    return matchedProperty\n                }\n\n                // Check enums\n                const matchedEnum = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.enumerations)\n                if (matchedEnum != null) {\n                    return matchedEnum\n                }\n            }\n\n            // Check functions", "            for (const [funcName, funcData] of fileCodeData.functions) {\n                const funcMatch = (match === '') ? funcName : match + '.' + funcName\n\n                // Need to ensure that a function with a matching name should also be visible from the current file.\n                if (expressionToMatch === funcMatch && this.isFunctionVisibleFromUri(uri, funcData)) {\n                    const range = funcData.declaration ?? Range.create(0, 0, 0, 0)\n                    return [Location.create(funcData.uri, range)]\n                }\n            }\n        }\n\n        return []\n    }\n\n    /**", "     * Finds the class member (property or enumeration) in the given map which matches to given expression.\n     *\n     * @param expressionToMatch The expression being compared against\n     * @param matchPrefix The prefix which should be attached to the class members before comparison\n     * @param classUri The URI for the current class\n     * @param classMemberMap The map of class members\n     * @returns An array containing the location of the matched class member, or null if one was not found\n     */\n    private findMatchingClassMember (expressionToMatch: string, matchPrefix: string, classUri: string, classMemberMap: Map<string, MatlabClassMemberInfo>): Location[] | null {\n        for (const [memberName, memberData] of classMemberMap) {\n            const match = matchPrefix + '.' + memberName", "        for (const [memberName, memberData] of classMemberMap) {\n            const match = matchPrefix + '.' + memberName\n            if (expressionToMatch === match) {\n                return [Location.create(classUri, memberData.range)]\n            }\n        }\n\n        return null\n    }\n\n    /**", "     * Determines whether the given function should be visible from the given file URI.\n     * The function is visible if it is contained within the same file, or is public.\n     *\n     * @param uri The file's URI\n     * @param funcData The function data\n     * @returns true if the function should be visible from the given URI; false otherwise\n     */\n    private isFunctionVisibleFromUri (uri: string, funcData: MatlabFunctionInfo): boolean {\n        return uri === funcData.uri || funcData.visibility === FunctionVisibility.Public\n    }\n\n    /**\n     * Finds references of an expression.\n     *\n     * @param uri The URI of the document containing the expression\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for references\n     * @returns The references' locations\n     */\n    private findReferences (uri: string, position: Position, expression: Expression): Location[] {\n        // Get code data for current file\n        const codeData = FileInfoIndex.codeDataCache.get(uri)\n", "        if (codeData == null) {\n            // File not indexed - unable to look for references\n            reportTelemetry(RequestType.References, 'File not indexed')\n            return []\n        }\n\n        const referencesInCodeData = this.findReferencesInCodeData(uri, position, expression, codeData)\n\n        reportTelemetry(RequestType.References)\n\n        if (referencesInCodeData != null) {\n            return referencesInCodeData\n        }\n\n        return []\n    }\n\n    /**\n     * Searches for references, starting within the given code data. If the expression does not correspond to a local variable,\n     *  the search is broadened to other indexed files in the user's workspace.\n     *\n     * @param uri The URI corresponding to the provided code data\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for references\n     * @param codeData The code data which is being searched\n     * @returns The references' locations, or null if no reference was found\n     */\n    private findReferencesInCodeData (uri: string, position: Position, expression: Expression, codeData: MatlabCodeData): Location[] | null {\n        // If first part of expression is targeted - look for a local variable", "        if (referencesInCodeData != null) {\n            return referencesInCodeData\n        }\n\n        return []\n    }\n\n    /**\n     * Searches for references, starting within the given code data. If the expression does not correspond to a local variable,\n     *  the search is broadened to other indexed files in the user's workspace.\n     *\n     * @param uri The URI corresponding to the provided code data\n     * @param position The position of the expression\n     * @param expression The expression for which we are looking for references\n     * @param codeData The code data which is being searched\n     * @returns The references' locations, or null if no reference was found\n     */\n    private findReferencesInCodeData (uri: string, position: Position, expression: Expression, codeData: MatlabCodeData): Location[] | null {\n        // If first part of expression is targeted - look for a local variable", "        if (expression.selectedComponent === 0) {\n            const containingFunction = codeData.findContainingFunction(position)\n            if (containingFunction != null) {\n                const varRefs = this.getVariableDefsOrRefs(containingFunction, expression.unqualifiedTarget, uri, RequestType.References)\n                if (varRefs != null) {\n                    return varRefs\n                }\n            }\n        }\n\n        // Check for functions in file\n        const functionDeclaration = this.getFunctionDeclaration(codeData, expression.fullExpression)", "        if (functionDeclaration != null && functionDeclaration.visibility === FunctionVisibility.Private) {\n            // Found a local function. Look through this file's references\n            return codeData.references.get(functionDeclaration.name)?.map(range => Location.create(uri, range)) ?? []\n        }\n\n        // Check other files\n        const refs: Location[] = []\n        for (const [, fileCodeData] of FileInfoIndex.codeDataCache) {\n            if (fileCodeData.functions.get(expression.fullExpression)?.visibility === FunctionVisibility.Private) {\n                // Skip files with other local functions\n                continue\n            }\n            const varRefs = fileCodeData.references.get(expression.fullExpression)", "            if (fileCodeData.functions.get(expression.fullExpression)?.visibility === FunctionVisibility.Private) {\n                // Skip files with other local functions\n                continue\n            }\n            const varRefs = fileCodeData.references.get(expression.fullExpression)\n            if (varRefs != null) {\n                varRefs.forEach(range => refs.push(Location.create(fileCodeData.uri, range)))\n            }\n        }\n        return refs\n    }\n\n    /**\n     * Gets the definition/references of a variable within a function.\n     *\n     * @param containingFunction Info about a function\n     * @param variableName The variable name for which we are looking for definitions or references\n     * @param uri The URI of the file", "     * @param requestType The type of request (definition or references)\n     * @returns The locations of the definition(s) or references of the given variable name within the given function info, or null if none can be found\n     */\n    private getVariableDefsOrRefs (containingFunction: MatlabFunctionInfo, variableName: string, uri: string, requestType: RequestType): Location[] | null {\n        const variableInfo = containingFunction.variableInfo.get(variableName)\n\n        if (variableInfo == null) {\n            return null\n        }\n\n        const varInfoRanges = requestType === RequestType.Definition ? variableInfo.definitions : variableInfo.references\n\n        return varInfoRanges.map(range => {\n            return Location.create(uri, range)\n        })\n    }\n\n    /**", "     * Searches for info about a function within the given code data.\n     *\n     * @param codeData The code data being searched\n     * @param functionName The name of the function being searched for\n     * @returns The info about the desired function, or null if it cannot be found\n     */\n    private getFunctionDeclaration (codeData: MatlabCodeData, functionName: string): MatlabFunctionInfo | null {\n        let functionDecl = codeData.functions.get(functionName)\n        if (codeData.isClassDef && (functionDecl == null || functionDecl.isPrototype)) {\n            // For classes, look in the methods list to better handle @folders\n            functionDecl = codeData.classInfo?.methods.get(functionName) ?? functionDecl\n        }\n\n        return functionDecl ?? null\n    }\n\n    /**\n     * Searches for info about a property within the given code data.\n     *\n     * @param codeData The code data being searched\n     * @param propertyName The name of the property being searched for\n     * @returns The info about the desired property, or null if it cannot be found\n     */\n    private getPropertyDeclaration (codeData: MatlabCodeData, propertyName: string): MatlabClassMemberInfo | null {", "        if (codeData.isClassDef && (functionDecl == null || functionDecl.isPrototype)) {\n            // For classes, look in the methods list to better handle @folders\n            functionDecl = codeData.classInfo?.methods.get(functionName) ?? functionDecl\n        }\n\n        return functionDecl ?? null\n    }\n\n    /**\n     * Searches for info about a property within the given code data.\n     *\n     * @param codeData The code data being searched\n     * @param propertyName The name of the property being searched for\n     * @returns The info about the desired property, or null if it cannot be found\n     */\n    private getPropertyDeclaration (codeData: MatlabCodeData, propertyName: string): MatlabClassMemberInfo | null {", "        if (codeData.classInfo == null) {\n            return null\n        }\n\n        return codeData.classInfo.properties.get(propertyName) ?? null\n    }\n}\n\nexport default new NavigationSupportProvider()\n"]}
{"filename": "src/providers/navigation/PathResolver.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { URI } from 'vscode-uri'\nimport { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\n\ninterface ResolvePathResponse {\n    data: ResolvedPath[]\n}\n\ninterface ResolvedPath {\n    name: string\n    path: string\n}\n", "interface ResolvedPath {\n    name: string\n    path: string\n}\n\ninterface ResolvedUri {\n    name: string\n    uri: string\n}\n\nclass PathResolver {\n    private readonly REQUEST_CHANNEL = '/matlabls/navigation/resolvePath/request'\n    private readonly RESPONSE_CHANNEL = '/matlabls/navigation/resolvePath/response'\n\n    /**\n     * Attempts to resolve the given names to the files in which the names are defined.\n     * For example, 'MyClass' may be resolved to 'file:///path/to/MyClass.m'.\n     *\n     * @param names The names which should be resolved to paths\n     * @param contextFileUri The file from which the context of the path resolution should be made\n     * @param matlabConnection The connection to MATLAB\u00ae\n     *\n     * @returns The resolved URIs. Any URIs which could not be determiend are denoted by empty strings.\n     */\n    async resolvePaths (names: string[], contextFileUri: string, matlabConnection: MatlabConnection): Promise<ResolvedUri[]> {\n        const contextFile = URI.parse(contextFileUri).fsPath\n\n        return await new Promise(resolve => {\n            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n                matlabConnection.unsubscribe(responseSub)\n\n                const resolvedPaths = (message as ResolvePathResponse).data\n\n                // Convert file system paths from MATLAB to URIs\n                const resolvedUris: ResolvedUri[] = resolvedPaths.map(resolvedPath => {\n                    const filePath = resolvedPath.path\n                    const uri = (filePath === '') ? '' : URI.file(filePath).toString()\n                    return {\n                        name: resolvedPath.name,\n                        uri\n                    }\n                })\n\n                resolve(resolvedUris)\n            })\n\n            matlabConnection.publish(this.REQUEST_CHANNEL, {\n                names,\n                contextFile\n            })\n        })\n    }\n}\n\nexport default new PathResolver()\n", "class PathResolver {\n    private readonly REQUEST_CHANNEL = '/matlabls/navigation/resolvePath/request'\n    private readonly RESPONSE_CHANNEL = '/matlabls/navigation/resolvePath/response'\n\n    /**\n     * Attempts to resolve the given names to the files in which the names are defined.\n     * For example, 'MyClass' may be resolved to 'file:///path/to/MyClass.m'.\n     *\n     * @param names The names which should be resolved to paths\n     * @param contextFileUri The file from which the context of the path resolution should be made\n     * @param matlabConnection The connection to MATLAB\u00ae\n     *\n     * @returns The resolved URIs. Any URIs which could not be determiend are denoted by empty strings.\n     */\n    async resolvePaths (names: string[], contextFileUri: string, matlabConnection: MatlabConnection): Promise<ResolvedUri[]> {\n        const contextFile = URI.parse(contextFileUri).fsPath\n\n        return await new Promise(resolve => {\n            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n                matlabConnection.unsubscribe(responseSub)\n\n                const resolvedPaths = (message as ResolvePathResponse).data\n\n                // Convert file system paths from MATLAB to URIs\n                const resolvedUris: ResolvedUri[] = resolvedPaths.map(resolvedPath => {\n                    const filePath = resolvedPath.path\n                    const uri = (filePath === '') ? '' : URI.file(filePath).toString()\n                    return {\n                        name: resolvedPath.name,\n                        uri\n                    }\n                })\n\n                resolve(resolvedUris)\n            })\n\n            matlabConnection.publish(this.REQUEST_CHANNEL, {\n                names,\n                contextFile\n            })\n        })\n    }\n}\n\nexport default new PathResolver()\n"]}
{"filename": "src/providers/lspCommands/ExecuteCommandProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { ExecuteCommandParams, Range, TextDocuments, _Connection } from 'vscode-languageserver'\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport LintingSupportProvider from '../linting/LintingSupportProvider'\n\ninterface LintSuppressionArgs {\n    id: string\n    range: Range\n    uri: string\n}\n\nexport const MatlabLSCommands = {\n    MLINT_SUPPRESS_ON_LINE: 'matlabls.lint.suppress.line',\n    MLINT_SUPPRESS_IN_FILE: 'matlabls.lint.suppress.file'\n}\n\n/**\n * Handles requests to execute commands\n */", "class ExecuteCommandProvider {\n    /**\n     * Handles command execution requests.\n     *\n     * @param params Parameters from the onExecuteCommand request\n     * @param documentManager The text document manager\n     * @param connection The language server connection\n     */\n    async handleExecuteCommand (params: ExecuteCommandParams, documentManager: TextDocuments<TextDocument>, connection: _Connection): Promise<void> {\n        switch (params.command) {\n            case MatlabLSCommands.MLINT_SUPPRESS_ON_LINE:\n            case MatlabLSCommands.MLINT_SUPPRESS_IN_FILE:\n                void this.handleLintingSuppression(params, documentManager, connection)\n        }\n    }\n\n    /**\n     * Handles command to suppress a linting diagnostic.\n     *\n     * @param params Parameters from the onExecuteCommand request\n     * @param documentManager The text document manager\n     * @param connection The language server connection\n     */\n    private async handleLintingSuppression (params: ExecuteCommandParams, documentManager: TextDocuments<TextDocument>, connection: _Connection): Promise<void> {\n        const args = params.arguments?.[0] as LintSuppressionArgs\n        const range = args.range\n        const uri = args.uri\n        const doc = documentManager.get(uri)\n", "        if (doc == null) {\n            return\n        }\n\n        const shouldSuppressThroughoutFile = params.command === MatlabLSCommands.MLINT_SUPPRESS_IN_FILE\n        LintingSupportProvider.suppressDiagnostic(doc, range, args.id, shouldSuppressThroughoutFile)\n    }\n}\n\nexport default new ExecuteCommandProvider()\n"]}
{"filename": "src/providers/linting/LintingSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { execFile, ExecFileException } from 'child_process'\nimport { CodeAction, CodeActionKind, CodeActionParams, Command, Diagnostic, DiagnosticSeverity, Position, Range, TextDocumentEdit, TextEdit, VersionedTextDocumentIdentifier, WorkspaceEdit, _Connection } from 'vscode-languageserver'\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport { URI } from 'vscode-uri'\nimport ConfigurationManager from '../../lifecycle/ConfigurationManager'\nimport { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\nimport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\nimport Logger from '../../logging/Logger'", "import MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\nimport Logger from '../../logging/Logger'\nimport * as path from 'path'\nimport which = require('which')\nimport { MatlabLSCommands } from '../lspCommands/ExecuteCommandProvider'\nimport { connection } from '../../server'\n\ntype mlintSeverity = '0' | '1' | '2' | '3' | '4'\n\ninterface RawLintResults {\n    lintData: string[]\n}\n", "interface RawLintResults {\n    lintData: string[]\n}\n\ninterface DiagnosticSuppressionResults {\n    suppressionEdits: TextEdit[]\n}\n\nconst LINT_DELAY = 500 // Delay (in ms) after keystroke before attempting to lint the document\n\n// Lint result parsing constants\nconst LINT_MESSAGE_REGEX = /L (\\d+) \\(C (\\d+)-?(\\d*)\\): ([\\dA-Za-z]+): ML(\\d): (.*)/\nconst FIX_FLAG_REGEX = /\\(CAN FIX\\)/\nconst FIX_MESSAGE_REGEX = /----FIX MESSAGE<\\w+>\\s+<([^>]*)>/\nconst FIX_CHANGE_REGEX = /----CHANGE MESSAGE L (\\d+) \\(C (\\d+)\\);\\s+L (\\d+) \\(C (\\d+)\\):\\s+<([^>]*)>/\n\n/**\n * Handles requests for linting-related features.\n * Currently, this handles displaying diagnostics, providing quick-fixes,\n * and suppressing diagnostics.\n *\n * Note: When MATLAB\u00ae is not connected, diagnostics are only updated when\n * the file is saved and suppressing warnings is not available.\n */", "class LintingSupportProvider {\n    private readonly LINTING_REQUEST_CHANNEL = '/matlabls/linting/request'\n    private readonly LINTING_RESPONSE_CHANNEL = '/matlabls/linting/response'\n\n    private readonly SUPPRESS_DIAGNOSTIC_REQUEST_CHANNEL = '/matlabls/linting/suppressdiagnostic/request'\n    private readonly SUPPRESS_DIAGNOSTIC_RESPONSE_CHANNEL = '/matlabls/linting/suppressdiagnostic/response'\n\n    private readonly SEVERITY_MAP = {\n        0: DiagnosticSeverity.Information,\n        1: DiagnosticSeverity.Warning,\n        2: DiagnosticSeverity.Error,\n        3: DiagnosticSeverity.Error,\n        4: DiagnosticSeverity.Error\n    }\n\n    private readonly _pendingFilesToLint = new Map<string, NodeJS.Timer>()\n    private readonly _availableCodeActions = new Map<string, CodeAction[]>()\n\n    /**\n     * Queues a document to be linted. This handles debouncing so\n     * that linting is not performed on every keystroke.\n     *\n     * @param textDocument The document to be linted\n     * @param connection The language server connection\n     */\n    queueLintingForDocument (textDocument: TextDocument, connection: _Connection): void {\n        const uri = textDocument.uri\n        this.clearTimerForDocumentUri(uri)\n        this._pendingFilesToLint.set(\n            uri,\n            setTimeout(() => {\n                void this.lintDocument(textDocument, connection)\n            }, LINT_DELAY) // Specify timeout for debouncing, to avoid re-linting every keystroke while a user types\n        )\n    }\n\n    /**\n     * Lints the document and displays diagnostics.\n     *\n     * @param textDocument The document being linted\n     * @param connection The language server connection\n     */\n    async lintDocument (textDocument: TextDocument, connection: _Connection): Promise<void> {\n        const uri = textDocument.uri\n        this.clearTimerForDocumentUri(uri)\n        this.clearCodeActionsForDocumentUri(uri)\n\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n        const isMatlabAvailable = (matlabConnection != null) && MatlabLifecycleManager.isMatlabReady()\n\n        const fileName = URI.parse(uri).fsPath\n\n        let lintData: string[] = []\n", "        if (isMatlabAvailable) {\n            // Use MATLAB-based linting for better results and fixes\n            const code = textDocument.getText()\n            lintData = await this.getLintResultsFromMatlab(code, fileName, matlabConnection)\n        } else {\n            // Try to use mlint executable for basic linting\n            lintData = await this.getLintResultsFromExecutable(fileName)\n        }\n\n        const lintResults = this.processLintResults(uri, lintData)\n        const diagnostics = lintResults.diagnostics\n\n        // Store code actions\n        this._availableCodeActions.set(uri, lintResults.codeActions)\n\n        // Report diagnostics\n        void connection.sendDiagnostics({\n            uri,\n            diagnostics\n        })\n    }\n\n    clearDiagnosticsForDocument (textDocument: TextDocument): void {\n        void connection.sendDiagnostics({\n            uri: textDocument.uri,\n            diagnostics: []\n        })\n    }\n\n    /**\n     * Handles a request for code actions.\n     *\n     * @param params Parameters from the onCodeAction request\n     */\n    handleCodeActionRequest (params: CodeActionParams): CodeAction[] {\n        const uri = params.textDocument.uri\n        const actions = this._availableCodeActions.get(uri) ?? []\n\n        let codeActions = [...actions]\n\n        // Filter to find unique diagnostics\n        codeActions = codeActions.filter(action => {\n            const diagnostic = action.diagnostics?.[0]", "            if (diagnostic == null) {\n                return false\n            }\n            return params.context.diagnostics.some(diag => this.isSameDiagnostic(diagnostic, diag))\n        })\n\n        if (!MatlabLifecycleManager.isMatlabReady()) {\n            // Cannot suppress warnings without MATLAB\n            return codeActions\n        }\n\n        // Add suppression commands\n        const diagnostics = params.context.diagnostics\n        const commands: Command[] = []\n        diagnostics.forEach(diagnostic => {\n            // Don't allow suppressing errors", "            if (diagnostic.severity === DiagnosticSeverity.Error) {\n                return\n            }\n\n            const diagnosticCode = diagnostic.code as string\n\n            // Add suppress-on-line option\n            commands.push(Command.create(\n                `Suppress message ${diagnosticCode} on this line`,\n                MatlabLSCommands.MLINT_SUPPRESS_ON_LINE,\n                {\n                    id: diagnosticCode,\n                    range: diagnostic.range,\n                    uri\n                }\n            ))\n\n            // Add suppress-in-file option\n            commands.push(Command.create(\n                `Suppress message ${diagnosticCode} in this file`,\n                MatlabLSCommands.MLINT_SUPPRESS_IN_FILE,\n                {\n                    id: diagnosticCode,\n                    range: diagnostic.range,\n                    uri\n                }\n            ))\n        })\n\n        commands.forEach(command => {\n            // Add suppression actions as Commands to be processed later.\n            codeActions.push(CodeAction.create(command.title, command, CodeActionKind.QuickFix))\n        })\n\n        return codeActions\n    }\n\n    /**\n     * Attempt to suppress a diagnostic.\n     *\n     * @param textDocument The document\n     * @param range The range of the diagnostic being suppress\n     * @param id The diagnostic's ID\n     * @param shouldSuppressThroughoutFile Whether or not to suppress the diagnostic throughout the entire file\n     */\n    suppressDiagnostic (textDocument: TextDocument, range: Range, id: string, shouldSuppressThroughoutFile: boolean): void {\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n            return\n        }\n\n        const responseSub = matlabConnection.subscribe(this.SUPPRESS_DIAGNOSTIC_RESPONSE_CHANNEL, message => {\n            matlabConnection.unsubscribe(responseSub)\n\n            const suppressionEdits: TextEdit[] = (message as DiagnosticSuppressionResults).suppressionEdits\n\n            const edit: WorkspaceEdit = {\n                changes: {\n                    [textDocument.uri]: suppressionEdits\n                },\n                documentChanges: [\n                    TextDocumentEdit.create(\n                        VersionedTextDocumentIdentifier.create(textDocument.uri, textDocument.version),\n                        suppressionEdits\n                    )\n                ]\n            }\n\n            void connection.workspace.applyEdit(edit)\n        })\n\n        matlabConnection.publish(this.SUPPRESS_DIAGNOSTIC_REQUEST_CHANNEL, {\n            code: textDocument.getText(),\n            diagnosticId: id,\n            line: range.start.line + 1,\n            suppressInFile: shouldSuppressThroughoutFile\n        })\n    }\n\n    /**\n     * Clears any active linting timers for the provided document URI.\n     *\n     * @param uri The document URI\n     */\n    private clearTimerForDocumentUri (uri: string): void {\n        const timerId = this._pendingFilesToLint.get(uri)", "        if (timerId != null) {\n            clearTimeout(timerId)\n            this._pendingFilesToLint.delete(uri)\n        }\n    }\n\n    /**\n     * Clears any cached code actions for the provided document URI.\n     *\n     * @param uri The document URI\n     */\n    private clearCodeActionsForDocumentUri (uri: string): void {\n        this._availableCodeActions.set(uri, [])\n    }\n\n    /**\n     * Gets raw linting data from MATLAB.\n     *\n     * @param code The code to be linted\n     * @param fileName The file's name\n     * @param matlabConnection The connection to MATLAB\n     * @returns Raw lint data for the code\n     */\n    private async getLintResultsFromMatlab (code: string, fileName: string, matlabConnection: MatlabConnection): Promise<string[]> {\n        return await new Promise<string[]>(resolve => {\n            const responseSub = matlabConnection.subscribe(this.LINTING_RESPONSE_CHANNEL, message => {\n                matlabConnection.unsubscribe(responseSub)\n\n                resolve((message as RawLintResults).lintData)\n            })\n\n            matlabConnection.publish(this.LINTING_REQUEST_CHANNEL, {\n                code,\n                fileName\n            })\n        })\n    }\n\n    /**\n     * Gets raw linting data using the mlint executable.\n     *\n     * @param fileName The file's name\n     * @returns Raw lint data for the file\n     */\n    private async getLintResultsFromExecutable (fileName: string): Promise<string[]> {\n        const mlintExecutable = await this.getMlintExecutable()\n", "        if (mlintExecutable == null) {\n            // Unable to locate executable\n            return []\n        }\n\n        const mlintArgs = [\n            fileName,\n            '-id',\n            '-severity',\n            '-fix'\n        ]\n\n        return await new Promise<string[]>(resolve => {", "            try {\n                execFile(\n                    mlintExecutable,\n                    mlintArgs,\n                    (error: ExecFileException | null, stdout: string, stderr: string) => {\n                        if (error != null) {\n                            Logger.error(`Error from mlint executable: ${error.message}\\n${error.stack ?? ''}`)\n                            resolve([])\n                        }\n                        resolve(stderr.split('\\n')) // For some reason, mlint appears to output on stderr instead of stdout\n                    }\n                )", "            } catch (e) {\n                Logger.error(`Error executing mlint executable at ${mlintExecutable}`)\n            }\n        })\n    }\n\n    /**\n     * Attempts to determine the path to the mlint executable.\n     *\n     * @returns The path to the mlint executable, or null if it cannot be determined\n     */\n    private async getMlintExecutable (): Promise<string | null> {\n        const platformDir = this.getBinDirectoryForPlatform()", "        if (platformDir == null) {\n            // Unable to determine platform\n            return null\n        }\n\n        const matlabInstallPath = (await ConfigurationManager.getConfiguration()).installPath\n        let binPath = ''\n\n        if (matlabInstallPath !== '') {\n            // Find the executable from the root installation directory\n            binPath = path.normalize(path.join(matlabInstallPath, 'bin'))\n        } else {\n            // Try to find the executable based on the location of the `matlab` executable", "        if (matlabInstallPath !== '') {\n            // Find the executable from the root installation directory\n            binPath = path.normalize(path.join(matlabInstallPath, 'bin'))\n        } else {\n            // Try to find the executable based on the location of the `matlab` executable\n            try {\n                const resolvedPath = await which('matlab')\n                if (resolvedPath !== '') {\n                    binPath = path.dirname(resolvedPath)\n                }\n            } catch {\n                // `matlab` not found on path - no action\n            }\n        }\n", "        if (binPath === '') {\n            return null\n        }\n\n        const mlintExecutablePath = path.normalize(path.join(\n            binPath,\n            platformDir,\n            'mlint'\n        ))\n\n        return mlintExecutablePath\n    }\n\n    /**\n     * Gets the name of platform-specific binary directory.\n     *\n     * @returns The binary directory name, or null if the platform is not recognized\n     */\n    private getBinDirectoryForPlatform (): string | null {\n        switch (process.platform) {\n            case 'win32':\n                return 'win64'\n            case 'darwin':\n                return 'maci64'\n            case 'linux':\n                return 'glnxa64'\n            default:\n                return null\n        }\n    }\n\n    /**\n     * Parses diagnostics and code actions from the raw lint data.\n     *\n     * @param uri THe linted document's URI\n     * @param lintData The lint data for the document\n     * @returns Parsed diagnostics and code actions\n     */\n    private processLintResults (uri: string, lintData: string[]): { diagnostics: Diagnostic[], codeActions: CodeAction[] } {\n        const diagnostics: Diagnostic[] = []\n        const codeActions: CodeAction[] = []\n\n        let dataIndex = 0", "        while (dataIndex < lintData.length) {\n            const message = lintData[dataIndex++]\n\n            if (message === '') {\n                continue\n            }\n\n            // Parse lint message\n            // Diagnostics will be reported with a line like the following:\n            //     L {lineNumber} (C {columnNumber}): {diagnosticId}: ML{severity}: {diagnosticMessage} (CAN FIX)\n            // If the diagnostic cannot be fixed, the '(CAN FIX)' will not be present\n            const parsedLine = message.match(LINT_MESSAGE_REGEX)", "            if (parsedLine == null) {\n                continue\n            }\n\n            const line = Math.max(parseInt(parsedLine[1]) - 1, 0)\n            const startColumn = Math.max(parseInt(parsedLine[2]) - 1, 0)\n            const endColumn = (parsedLine[3] !== '') ? parseInt(parsedLine[3]) : startColumn + 1 // +1 for open interval\n            const id = parsedLine[4]\n            const severity = this.SEVERITY_MAP[parsedLine[5] as mlintSeverity]\n            let lintMessage: string = parsedLine[6]\n\n            // Check if there are available fixes for this diagnostic\n            const fixMatch = lintMessage.match(FIX_FLAG_REGEX)", "            if (fixMatch != null) {\n                lintMessage = lintMessage.replace(FIX_FLAG_REGEX, '').trim()\n            }\n\n            const diagnostic = Diagnostic.create(Range.create(line, startColumn, line, endColumn), lintMessage, severity, id, 'MATLAB')\n            diagnostics.push(diagnostic)\n\n            // Parse fix data for this diagnostic, if it exists\n            if (fixMatch == null) {\n                continue\n            }\n\n            const fixInfo = lintData[dataIndex++]\n\n            // Parse fix message\n            // Diagnostic fixes will be reported with lines like the following:\n            //     ----FIX MESSAGE<{diagnosticFixId}> <{message}>\n            //     ----CHANGE MESSAGE L {lineNumber} (C {columnNumber});  L {lineNumber} (C {columnNumber}):  <{text}>\n            const fixMsgMatch = fixInfo.match(FIX_MESSAGE_REGEX)", "            if (fixMatch == null) {\n                continue\n            }\n\n            const fixInfo = lintData[dataIndex++]\n\n            // Parse fix message\n            // Diagnostic fixes will be reported with lines like the following:\n            //     ----FIX MESSAGE<{diagnosticFixId}> <{message}>\n            //     ----CHANGE MESSAGE L {lineNumber} (C {columnNumber});  L {lineNumber} (C {columnNumber}):  <{text}>\n            const fixMsgMatch = fixInfo.match(FIX_MESSAGE_REGEX)", "            if (fixMsgMatch == null) {\n                continue\n            }\n            const fixMsg = fixMsgMatch[1]\n\n            // Gather fixes\n            const changes = {\n                [uri]: [] as TextEdit[]\n            }\n            const wsEdit: WorkspaceEdit = {\n                changes\n            }\n", "            while (dataIndex < lintData.length) {\n                const actionMsg = lintData[dataIndex]\n                const actionMsgMatch = actionMsg.match(FIX_CHANGE_REGEX)\n                if (actionMsgMatch == null) {\n                    break\n                }\n\n                // Consume, since we matched\n                dataIndex++\n\n                const startLine = parseInt(actionMsgMatch[1]) - 1\n                const startColumn = parseInt(actionMsgMatch[2]) - 1\n                const endLine = parseInt(actionMsgMatch[3]) - 1\n                const endColumn = parseInt(actionMsgMatch[4])\n                const replaceText = actionMsgMatch[5]\n\n                // Translate data into edits\n                let edit: TextEdit", "                if (startLine === endLine && startColumn === endColumn) {\n                    // 1. Insert\n                    edit = TextEdit.insert(Position.create(startLine, startColumn + 1), replaceText)\n                } else if (replaceText.length === 0) {\n                    // 2. Delete\n                    edit = TextEdit.del(Range.create(startLine, startColumn, endLine, endColumn))\n                } else {\n                    // 3. Replace\n                    edit = TextEdit.replace(Range.create(startLine, startColumn, endLine, endColumn), replaceText)\n                }\n                changes[uri].push(edit)\n            }\n\n            // If a fix has been processed, create a code action", "            if (changes[uri].length > 0) {\n                const action = CodeAction.create(fixMsg, wsEdit, CodeActionKind.QuickFix)\n                action.diagnostics = [diagnostics[diagnostics.length - 1]]\n                codeActions.push(action)\n            }\n        }\n\n        return {\n            diagnostics,\n            codeActions\n        }\n    }\n\n    /**\n     * Determines whether two diagnostics are equivalent.\n     *\n     * @param a The first diagnostic\n     * @param b The second diagnostic\n     * @returns True if the diagnostics are the same. False otherwise.\n     */\n    private isSameDiagnostic (a: Diagnostic, b: Diagnostic): boolean {\n        return a.code === b.code &&\n            a.message === b.message &&\n            a.range.start.character === b.range.start.character &&\n            a.range.start.line === b.range.start.line &&\n            a.range.end.character === b.range.end.character &&\n            a.range.end.line === b.range.end.line &&\n            a.severity === b.severity &&\n            a.source === b.source\n    }\n}\n\nexport default new LintingSupportProvider()\n"]}
{"filename": "src/providers/completion/CompletionSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { CompletionItem, CompletionItemKind, CompletionList, CompletionParams, ParameterInformation, Position, SignatureHelp, SignatureHelpParams, SignatureInformation, TextDocuments } from 'vscode-languageserver'\nimport { TextDocument } from 'vscode-languageserver-textdocument'\nimport { URI } from 'vscode-uri'\nimport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\n\ninterface MCompletionData {\n    widgetData?: MWidgetData\n    widgetType?: string\n    signatures?: MSignatureData | MSignatureData[] // If there is only one signature, it is not given as an array\n}\n", "interface MWidgetData {\n    choices?: MCompletionChoice | MCompletionChoice[] // If there is only one choice, it is not given as an array\n    truncated?: boolean\n}\n\ninterface MCompletionChoice {\n    completion: string\n    matchType: string\n    purpose: string\n    displayString?: string\n}\n", "interface MSignatureData {\n    functionName: string\n    inputArguments?: MArgumentData | MArgumentData[] // If there is only one argument, it is not given as an array\n    outputArguments?: MArgumentData | MArgumentData[] // If there is only one argument, it is not given as an array\n}\n\ninterface MArgumentData {\n    name: string\n    widgetType: string\n    widgetData?: MWidgetData\n    status?: string\n    purpose?: string\n    valueSummary?: string\n}\n\n// Maps the completion type, as returned by MATLAB\u00ae, to the corresponding CompletionItemKind\nconst MatlabCompletionToKind: { [index: string]: CompletionItemKind } = {\n    literal: CompletionItemKind.Text,\n    unknown: CompletionItemKind.Function,\n    pathItem: CompletionItemKind.File,\n    mFile: CompletionItemKind.Function,\n    pFile: CompletionItemKind.Function,\n    mlxFile: CompletionItemKind.Function,\n    mlappFile: CompletionItemKind.Function,\n    mex: CompletionItemKind.Function,\n    mdlFile: CompletionItemKind.Function,\n    slxFile: CompletionItemKind.Function,\n    slxpFile: CompletionItemKind.Function,\n    sscFile: CompletionItemKind.Function,\n    sscpFile: CompletionItemKind.Function,\n    sfxFile: CompletionItemKind.Class,\n    folder: CompletionItemKind.Folder,\n    logical: CompletionItemKind.Value,\n    function: CompletionItemKind.Function,\n    filename: CompletionItemKind.File,\n    localFunction: CompletionItemKind.Function,\n    fieldname: CompletionItemKind.Field,\n    username: CompletionItemKind.Text,\n    variable: CompletionItemKind.Variable,\n    feature: CompletionItemKind.Text,\n    cellString: CompletionItemKind.Value,\n    class: CompletionItemKind.Class,\n    package: CompletionItemKind.Module,\n    property: CompletionItemKind.Property,\n    method: CompletionItemKind.Method,\n    enumeration: CompletionItemKind.EnumMember,\n    messageId: CompletionItemKind.Text,\n    keyword: CompletionItemKind.Keyword,\n    attribute: CompletionItemKind.Keyword\n}\n\n/**\n * Handles requests for completion-related features.", " * Currently, this handles auto-completion as well as function signature help.\n */\nclass CompletionProvider {\n    private readonly REQUEST_CHANNEL = '/matlabls/completions/request'\n    private readonly RESPONSE_CHANNEL = '/matlabls/completions/response'\n\n    /**\n     * Handles a request for auto-completion choices.\n     *\n     * @param params Parameters from the onCompletion request\n     * @param documentManager The text document manager\n     * @returns An array of possible completions\n     */\n    async handleCompletionRequest (params: CompletionParams, documentManager: TextDocuments<TextDocument>): Promise<CompletionList> {\n        const doc = documentManager.get(params.textDocument.uri)\n", "        if (doc == null) {\n            return CompletionList.create()\n        }\n\n        const completionData = await this.retrieveCompletionData(doc, params.position)\n\n        return this.parseCompletionItems(completionData)\n    }\n\n    /**\n     * Handles a request for function signature help.\n     *\n     * @param params Parameters from the onSignatureHelp request\n     * @param documentManager The text document manager\n     * @returns The signature help, or null if no signature help is available\n     */\n    async handleSignatureHelpRequest (params: SignatureHelpParams, documentManager: TextDocuments<TextDocument>): Promise<SignatureHelp | null> {\n        const doc = documentManager.get(params.textDocument.uri)\n", "     * Handles a request for function signature help.\n     *\n     * @param params Parameters from the onSignatureHelp request\n     * @param documentManager The text document manager\n     * @returns The signature help, or null if no signature help is available\n     */\n    async handleSignatureHelpRequest (params: SignatureHelpParams, documentManager: TextDocuments<TextDocument>): Promise<SignatureHelp | null> {\n        const doc = documentManager.get(params.textDocument.uri)\n\n        if (doc == null) {\n            return null\n        }\n\n        const completionData = await this.retrieveCompletionData(doc, params.position)\n\n        return this.parseSignatureHelp(completionData)\n    }\n\n    /**\n     * Retrieves raw completion data from MATLAB.\n     *\n     * @param doc The text document\n     * @param position The cursor position in the document\n     * @returns The raw completion data\n     */\n    private async retrieveCompletionData (doc: TextDocument, position: Position): Promise<MCompletionData> {\n        const docUri = doc.uri\n\n        const code = doc.getText()\n        const fileName = URI.parse(docUri).fsPath\n        const cursorPosition = doc.offsetAt(position)\n\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (doc == null) {\n            return null\n        }\n\n        const completionData = await this.retrieveCompletionData(doc, params.position)\n\n        return this.parseSignatureHelp(completionData)\n    }\n\n    /**\n     * Retrieves raw completion data from MATLAB.\n     *\n     * @param doc The text document\n     * @param position The cursor position in the document\n     * @returns The raw completion data\n     */\n    private async retrieveCompletionData (doc: TextDocument, position: Position): Promise<MCompletionData> {\n        const docUri = doc.uri\n\n        const code = doc.getText()\n        const fileName = URI.parse(docUri).fsPath\n        const cursorPosition = doc.offsetAt(position)\n\n        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n            return {}\n        }\n\n        return await new Promise(resolve => {\n            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n                matlabConnection.unsubscribe(responseSub)\n\n                resolve(message as MCompletionData)\n            })\n\n            matlabConnection.publish(this.REQUEST_CHANNEL, {\n                code,\n                fileName,\n                cursorPosition\n            })\n        })\n    }\n\n    /**\n     * Parses the raw completion data to extract possible auto-completions.\n     *\n     * @param completionData The raw completion data\n     * @returns A list of completion items\n     */\n    private parseCompletionItems (completionData: MCompletionData): CompletionList {\n        const completionItems: CompletionItem[] = []\n\n        const completionsMap = new Map<string, { kind: CompletionItemKind, doc: string }>()\n", "        // Gather completions from top-level object. This should find function completions.\n        this.gatherCompletions(completionData, completionsMap)\n\n        // Gather completions from each signature. This should find function argument completions.\n        let signatures = completionData.signatures\n        if (signatures != null) {\n            signatures = Array.isArray(signatures) ? signatures : [signatures]\n\n            signatures.forEach(signature => {\n                let inputArguments = signature.inputArguments\n                if (inputArguments == null) {\n                    return\n                }\n\n                inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments]\n\n                inputArguments.forEach(inputArgument => {\n                    this.gatherCompletions(inputArgument, completionsMap)\n                })\n            })\n        }\n\n        let index = 0\n        completionsMap.forEach((completionData, completionName) => {\n            // Preserve the sorting from MATLAB\n            const sortText = String(index).padStart(10, '0')\n\n            const completionItem = CompletionItem.create(completionName)\n            completionItem.kind = completionData.kind\n            completionItem.detail = completionData.doc\n            completionItem.data = index++\n            completionItem.sortText = sortText\n            completionItems.push(completionItem)\n        })\n\n        return CompletionList.create(completionItems, completionData.widgetData?.truncated ?? false)\n    }\n\n    /**\n     * Parses raw completion and argument data and stores info about possible completions in the provided map.\n     *\n     * @param completionDataObj Raw completion or argument data\n     * @param completionMap A map in which to store info about possible completions\n     */\n    private gatherCompletions (completionDataObj: MCompletionData | MArgumentData, completionMap: Map<string, { kind: CompletionItemKind, doc: string }>): void {\n        let choices = completionDataObj.widgetData?.choices", "                if (inputArguments == null) {\n                    return\n                }\n\n                inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments]\n\n                inputArguments.forEach(inputArgument => {\n                    this.gatherCompletions(inputArgument, completionsMap)\n                })\n            })\n        }\n\n        let index = 0\n        completionsMap.forEach((completionData, completionName) => {\n            // Preserve the sorting from MATLAB\n            const sortText = String(index).padStart(10, '0')\n\n            const completionItem = CompletionItem.create(completionName)\n            completionItem.kind = completionData.kind\n            completionItem.detail = completionData.doc\n            completionItem.data = index++\n            completionItem.sortText = sortText\n            completionItems.push(completionItem)\n        })\n\n        return CompletionList.create(completionItems, completionData.widgetData?.truncated ?? false)\n    }\n\n    /**\n     * Parses raw completion and argument data and stores info about possible completions in the provided map.\n     *\n     * @param completionDataObj Raw completion or argument data\n     * @param completionMap A map in which to store info about possible completions\n     */\n    private gatherCompletions (completionDataObj: MCompletionData | MArgumentData, completionMap: Map<string, { kind: CompletionItemKind, doc: string }>): void {\n        let choices = completionDataObj.widgetData?.choices", "        if (choices == null) {\n            return\n        }\n\n        choices = Array.isArray(choices) ? choices : [choices]\n\n        choices.forEach(choice => {\n            let completion: string = choice.completion\n            let isPath = false\n\n            switch (choice.matchType) {\n                case 'folder':\n                case 'filename':\n                    // For files and folders, the completion is the full path whereas the displayString is the path to be added\n                    completion = choice.displayString ?? ''\n                    isPath = true\n                    break\n                case 'messageId':\n                    // Remove quotes from completion\n                    completion = (choice.displayString ?? '').replace(/['\"]/g, '')\n                    break\n            }\n\n            const dotIdx = choice.completion.lastIndexOf('.')", "            if (dotIdx > 0 && !isPath) {\n                completion = completion.slice(dotIdx + 1)\n            }\n\n            completionMap.set(completion, {\n                kind: MatlabCompletionToKind[choice.matchType] ?? CompletionItemKind.Function,\n                doc: choice.purpose\n            })\n        })\n    }\n\n    /**", "     * Parses the raw completion data to extract function signature help.\n     *\n     * @param completionData The raw completion data\n     * @returns The signature help, or null if no signature help is available\n     */\n    private parseSignatureHelp (completionData: MCompletionData): SignatureHelp | null {\n        let signatureData = completionData.signatures\n\n        if (signatureData == null) {\n            return null\n        }\n\n        signatureData = Array.isArray(signatureData) ? signatureData : [signatureData]\n\n        const signatureHelp: SignatureHelp = {\n            activeParameter: 0,\n            activeSignature: 0,\n            signatures: []\n        }\n\n        // Parse each signature\n        signatureData.forEach(sigData => {\n            const params: ParameterInformation[] = []\n", "        if (signatureData == null) {\n            return null\n        }\n\n        signatureData = Array.isArray(signatureData) ? signatureData : [signatureData]\n\n        const signatureHelp: SignatureHelp = {\n            activeParameter: 0,\n            activeSignature: 0,\n            signatures: []\n        }\n\n        // Parse each signature\n        signatureData.forEach(sigData => {\n            const params: ParameterInformation[] = []\n", "            // Handle function inputs\n            const argNames: string[] = []\n            let inputArguments = sigData.inputArguments\n\n            if (inputArguments == null) {\n                return\n            }\n\n            inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments]\n\n            inputArguments.forEach((inputArg, index) => {\n                let paramDoc = ''", "                if (inputArg.purpose != null) {\n                    paramDoc += inputArg.purpose\n                }\n                if (inputArg.valueSummary != null) {\n                    paramDoc += (paramDoc.length > 0 ? '\\n' : '') + inputArg.valueSummary\n                }\n\n                const paramDocArgs = paramDoc.length > 0 ? [paramDoc] : []\n                params.push(ParameterInformation.create(inputArg.name, ...paramDocArgs))\n\n                argNames.push(inputArg.name)", "                if (inputArg.status === 'presenting') {\n                    signatureHelp.activeParameter = index\n                }\n            })\n\n            let argStr = ''\n            if (argNames.length === 1) {\n                argStr = argNames[0]\n            } else if (argNames.length > 1) {\n                argStr = argNames.join(', ')\n            }\n", "            } else if (argNames.length > 1) {\n                argStr = argNames.join(', ')\n            }\n\n            // Handle function outputs\n            let outStr = ''\n            let outputArguments = sigData.outputArguments\n            if (outputArguments != null) {\n                outputArguments = Array.isArray(outputArguments) ? outputArguments : [outputArguments]\n                outStr = outputArguments.length === 1\n                    ? outputArguments[0].name\n                    : `[${outputArguments.map(output => output.name).join(', ')}]`\n                outStr += ' = '\n            }\n\n            const id = `${outStr}${sigData.functionName}(${argStr})`\n            signatureHelp.signatures.push(SignatureInformation.create(\n                id,\n                undefined,\n                ...params\n            ))\n        })\n\n        return signatureHelp\n    }\n}\n\nexport default new CompletionProvider()\n"]}
{"filename": "src/notifications/NotificationService.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { GenericNotificationHandler } from 'vscode-languageserver'\nimport { connection } from '../server'\n\nexport enum Notification {\n    // Connection Status Updates\n    MatlabConnectionClientUpdate = 'matlab/connection/update/client',\n    MatlabConnectionServerUpdate = 'matlab/connection/update/server',\n\n    // Errors\n    MatlabLaunchFailed = 'matlab/launchfailed',\n    MatlabFeatureUnavailable = 'feature/needsmatlab',\n    MatlabFeatureUnavailableNoMatlab = 'feature/needsmatlab/nomatlab',\n\n    // Telemetry\n    LogTelemetryData = 'telemetry/logdata'\n}\n", "class NotificationService {\n    /**\n     * Sends a notification to the language client\n     *\n     * @param name The name of the notification\n     * @param params Any parameters to send with the notification\n     */\n    sendNotification (name: string, params?: unknown): void {\n        void connection.sendNotification(name, params)\n    }\n\n    /**\n     * Sets up a listener for notifications from the language client\n     *\n     * @param name The name of the notification\n     * @param callback The callback\n     */\n    registerNotificationListener (name: string, callback: GenericNotificationHandler): void {\n        connection.onNotification(name, callback)\n    }\n}\n\nexport default new NotificationService()\n"]}
{"filename": "src/lifecycle/MatlabCommunicationManager.d.ts", "chunked_list": ["/// <reference types=\"node\" />\nimport { ChildProcess } from 'child_process';\ndeclare const Faye: any;\ndeclare type Client = typeof Faye.Client;\ndeclare type Subscription = typeof Faye.Client.Subscription;\nexport declare enum LifecycleEventType {\n    CONNECTED = 0,\n    DISCONNECTED = 1\n}\ninterface MatlabProcessInfo {\n    matlabProcess: ChildProcess;\n    matlabConnection: MatlabConnection;\n}\n/**\n * Manages launching and communicating with MATLAB\n */", "interface MatlabProcessInfo {\n    matlabProcess: ChildProcess;\n    matlabConnection: MatlabConnection;\n}\n/**\n * Manages launching and communicating with MATLAB\n */\ndeclare class MatlabCommunicationManager {\n    /**\n     * Launches and connects to MATLAB.\n     *\n     * @param launchCommand The command with which MATLAB is launched\n     * @param launchArguments The arguments with which MATLAB is launched\n     * @param logDirectory The directory in which MATLAB should log data\n     *\n     * @returns Information about the new MATLAB process and the connection to it.\n     * Returns null if the MATLAB process cannot be started.\n     */\n    connectToNewMatlab(launchCommand: string, launchArguments: string[], logDirectory: string): Promise<MatlabProcessInfo | null>;\n    /**\n     * Attempts to connect to an existing instance of MATLAB at the given URL.\n     *\n     * @param url The URL at which to find MATLAB\n     * @returns The connection to MATLAB\n     */\n    connectToExistingMatlab(url: string): Promise<MatlabConnection>;\n    /**\n     * Gets a random available TCP port.\n     *\n     * @returns A random available TCP port, as a string\n     */\n    private _getAvailablePort;\n    /**\n     * Gets a random API key for MATLAB.\n     *\n     * @returns A random API key\n     */\n    private _makeApiKey;\n}", "declare type LifecycleListenerCallback = (eventType: LifecycleEventType) => void;\n/**\n * Abstract class representing a connection with the MATLAB application.\n */\nexport declare abstract class MatlabConnection {\n    protected _client?: Client;\n    protected _url?: string;\n    protected _lifecycleCallback: LifecycleListenerCallback | null;\n    /**\n     * Initializes the connection with MATLAB\n     */\n    abstract initialize(): Promise<void>;\n    /**\n     * Closes the connection with MATLAB.\n     * Does not attempt to close MATLAB.\n     */\n    close(): void;\n    /**\n     * Publishes a message to the given channel.\n     *\n     * @param channel The channel to which the message is being published\n     * @param message The message being published\n     */\n    publish(channel: string, message: unknown): void;\n    /**\n     * Subscribe to messages published on the given channel. The messages will\n     * be passed to hte given calback function.\n     *\n     * @param channel The channel for which to subscribe\n     * @param callback The callback function\n     * @returns The subscription object\n     */\n    subscribe(channel: string, callback: (message: unknown) => void): Subscription;\n    /**\n     * Unsubscribe from the given subscription.\n     *\n     * @param subscription The subscription which is being unsubscribed\n     */\n    unsubscribe(subscription: Subscription): void;\n    /**\n     * Sets a lifecycle listened callback. This will be called when there are\n     * changes to the state of the connection with MATLAB.\n     *\n     * @param callback The callback function\n     */\n    setLifecycleListener(callback: LifecycleListenerCallback): void;\n    protected onConnectionSuccess(): void;\n    protected onConnectionFailure(): void;\n    protected setupConnectionCallbacks(): void;\n    /**\n     * Prepends a channel name with '/matlab' as expected by MATLAB\n     *\n     * @param channel A channel name, in the format '/message/channel'\n     * @returns A channel prepended with '/matlab', such as '/matlab/message/channel'\n     */\n    private _prependChannel;\n}\ndeclare const _default: MatlabCommunicationManager;\nexport default _default;\n"]}
{"filename": "src/lifecycle/LifecycleNotificationHelper.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport NotificationService, { Notification } from '../notifications/NotificationService'\n\nexport enum ConnectionState {\n    CONNECTING = 'connecting',\n    CONNECTED = 'connected',\n    DISCONNECTED = 'disconnected'\n}\n\nclass LifecycleNotificationHelper {\n    didMatlabLaunchFail = false\n\n    /**\n     * Sends notification to the language client of a change in the MATLAB\u00ae connection state.\n     *\n     * @param connectionStatus The connection state\n     */\n    notifyConnectionStatusChange (connectionStatus: ConnectionState): void {\n        NotificationService.sendNotification(Notification.MatlabConnectionServerUpdate, {\n            connectionStatus\n        })\n    }\n\n    /**\n     * Sends notification to the language client to inform user that MATLAB is required for an action.\n     */\n    notifyMatlabRequirement (): void {\n        // Indicate different messages if MATLAB failed to launch (i.e. could not be found)\n        const notification = this.didMatlabLaunchFail ? Notification.MatlabFeatureUnavailableNoMatlab : Notification.MatlabFeatureUnavailable\n        NotificationService.sendNotification(notification)\n    }\n}\n\nexport default new LifecycleNotificationHelper()\n", "class LifecycleNotificationHelper {\n    didMatlabLaunchFail = false\n\n    /**\n     * Sends notification to the language client of a change in the MATLAB\u00ae connection state.\n     *\n     * @param connectionStatus The connection state\n     */\n    notifyConnectionStatusChange (connectionStatus: ConnectionState): void {\n        NotificationService.sendNotification(Notification.MatlabConnectionServerUpdate, {\n            connectionStatus\n        })\n    }\n\n    /**\n     * Sends notification to the language client to inform user that MATLAB is required for an action.\n     */\n    notifyMatlabRequirement (): void {\n        // Indicate different messages if MATLAB failed to launch (i.e. could not be found)\n        const notification = this.didMatlabLaunchFail ? Notification.MatlabFeatureUnavailableNoMatlab : Notification.MatlabFeatureUnavailable\n        NotificationService.sendNotification(notification)\n    }\n}\n\nexport default new LifecycleNotificationHelper()\n"]}
{"filename": "src/lifecycle/MatlabLifecycleManager.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { ChildProcess } from 'child_process'\nimport { _Connection } from 'vscode-languageserver'\n\nimport * as fs from 'fs'\nimport * as os from 'os'\nimport * as path from 'path'\n\nimport MatlabCommunicationManager, { LifecycleEventType, MatlabConnection } from './MatlabCommunicationManager'", "\nimport MatlabCommunicationManager, { LifecycleEventType, MatlabConnection } from './MatlabCommunicationManager'\nimport Logger from '../logging/Logger'\nimport ConfigurationManager, { Argument, ConnectionTiming } from './ConfigurationManager'\nimport { connection } from '../server'\nimport LifecycleNotificationHelper from './LifecycleNotificationHelper'\nimport NotificationService, { Notification } from '../notifications/NotificationService'\nimport { Actions, reportTelemetryAction } from '../logging/TelemetryUtils'\n\nenum ConnectionState {\n    CONNECTING = 'connecting',\n    CONNECTED = 'connected',\n    DISCONNECTED = 'disconnected'\n}\n", "\nenum ConnectionState {\n    CONNECTING = 'connecting',\n    CONNECTED = 'connected',\n    DISCONNECTED = 'disconnected'\n}\n\ninterface MatlabLifecycleEvent {\n    matlabStatus: 'connected' | 'disconnected'\n}\n", "export interface MatlabConnectionStatusParam {\n    connectionAction: 'connect' | 'disconnect'\n}\n\ntype MatlabLifecycleCallback = (error: Error | null, evt: MatlabLifecycleEvent) => void\n\n/**\n * Manages the lifecycle of the connected MATLAB\u00ae application.\n */\nclass MatlabLifecycleManager {\n    private _matlabProcess: MatlabProcess | null = null\n    private readonly _matlabLifecycleCallbacks: MatlabLifecycleCallback[] = []\n\n    /**\n     * Connects to MATLAB.\n     *\n     * @param connection The language server connection\n     * @returns The MATLAB process\n     */\n    async connectToMatlab (connection: _Connection): Promise<MatlabProcess> {", "class MatlabLifecycleManager {\n    private _matlabProcess: MatlabProcess | null = null\n    private readonly _matlabLifecycleCallbacks: MatlabLifecycleCallback[] = []\n\n    /**\n     * Connects to MATLAB.\n     *\n     * @param connection The language server connection\n     * @returns The MATLAB process\n     */\n    async connectToMatlab (connection: _Connection): Promise<MatlabProcess> {", "        if (this._shouldConnectToExistingMatlab()) {\n            return await this._connectToExistingMatlab(connection)\n        } else {\n            return await this._launchAndConnectToMatlab(connection)\n        }\n    }\n\n    /**\n     * Disconnects from MATLAB.\n     */\n    disconnectFromMatlab (): void {", "        if (this._matlabProcess == null || !this._matlabProcess.isValid) {\n            return\n        }\n\n        this._matlabProcess?.shutdown()\n        this._matlabProcess = null\n\n        this._handleMatlabLifecycleUpdate('disconnected')\n    }\n\n    /**\n     * Gets whether or not MATLAB is ready for communication.\n     *\n     * @returns Whether or not MATLAB can be communicated with.\n     */\n    isMatlabReady (): boolean {\n        return Boolean(this._matlabProcess?.isMatlabReady())\n    }\n\n    /**\n     * Gets the active connection to MATLAB. Does not attempt to create a connection if\n     * one does not currently exist.\n     *\n     * @returns The connection to MATLAB, or null if there is no active connection.\n     */\n    getMatlabConnection (): MatlabConnection | null {\n        const isMatlabValid = this._matlabProcess?.isValid ?? false", "        if (isMatlabValid) {\n            return this._matlabProcess?.getConnection() ?? null\n        }\n\n        return null\n    }\n\n    /**\n     * Gets the active connection to MATLAB or waits for one to be established.\n     * Does not attempt to create a connection if one does not currently exist.\n     * Immediately returns null if the user set the MATLAB connection timing to\n     * never.\n     *\n     * @returns The connection to MATLAB, or null if connection timing is never\n     * and MATLAB has not been manually launched.\n     */\n    async getMatlabConnectionAsync (): Promise<MatlabConnection | null> {\n        // If MATLAB is up and running return the connection\n        const isMatlabReady = this._matlabProcess?.isMatlabReady() ?? false", "        if (isMatlabReady) {\n            const conn = this._matlabProcess?.getConnection()\n            if (conn !== null && conn !== undefined) {\n                return conn\n            }\n        }\n        // MATLAB isn't running and the user has said we shouldn't start it\n        if (await this._isMatlabConnectionTimingNever()) {\n            return null\n        }\n        // MATLAB might start later on. Return a promise to wait for it.\n        const result = new Promise<MatlabConnection>((resolve, reject) => {\n            this.addMatlabLifecycleListener((error, evt) => {", "                if (error !== null) {\n                    reject(error)\n                }\n                if (evt.matlabStatus === 'connected') {\n                    const conn = this.getMatlabConnection()\n                    if (conn !== null) {\n                        resolve(conn)\n                    }\n                }\n            })\n        })\n        return await result\n    }\n\n    /**\n     * Gets the active connection to MATLAB. If one does not currently exist, this will\n     * attempt to establish a connection.\n     *\n     * @param connection The language server connection\n     * @returns The connection to MATLAB, or null if one cannot be established.\n     */\n    async getOrCreateMatlabConnection (connection: _Connection): Promise<MatlabConnection | null> {\n        // Check if there is already an active connection\n        const activeConnection = this.getMatlabConnection()", "        if (activeConnection != null) {\n            return activeConnection\n        }\n\n        // No active connection - should create a connection if desired\n        if (!(await this._isMatlabConnectionTimingNever())) {\n            const matlabProcess = await this.connectToMatlab(connection)\n            return matlabProcess.getConnection()\n        }\n\n        // No connection should be created\n        return null\n    }\n\n    /**\n     * Adds a callback for MATLAB lifecycle events, such as when a connection is\n     * established or broken.\n     *\n     * @param callback The callback function\n     */\n    addMatlabLifecycleListener (callback: MatlabLifecycleCallback): void {\n        this._matlabLifecycleCallbacks.push(callback)\n    }\n\n    /**\n     * Handles requests from the language client to either connect to or disconnect from MATLAB\n     *\n     * @param data Data about whether or not MATLAB should be connected or disconnected\n     */\n    handleConnectionStatusChange (data: MatlabConnectionStatusParam): void {", "        if (data.connectionAction === 'connect') {\n            void this.connectToMatlab(connection)\n        } else {\n            this.disconnectFromMatlab()\n        }\n    }\n\n    /**\n     * Whether or not the language server should attempt to connect to an existing\n     * MATLAB instance.\n     *\n     * @returns True if the language server should attempt to connect to an\n     * already-running instance of MATLAB. False otherwise.\n     */\n    private _shouldConnectToExistingMatlab (): boolean {\n        // Assume we should connect to existing MATLAB if the matlabUrl startup flag has been provided\n        return Boolean(ConfigurationManager.getArgument(Argument.MatlabUrl))\n    }\n\n    /**\n     * Attempts to connect to an existing MATLAB process.\n     *\n     * @param connection The language server connection\n     * @returns The connected MATLAB process\n     */\n    private async _connectToExistingMatlab (connection: _Connection): Promise<MatlabProcess> {\n        const url = ConfigurationManager.getArgument(Argument.MatlabUrl)\n", "        if (this._matlabProcess == null || !this._matlabProcess.isValid) {\n            this._matlabProcess = new MatlabProcess(connection)\n        }\n\n        await this._matlabProcess.connectToMatlab(url)\n        return this._matlabProcess\n    }\n\n    /**\n     * Attempts to launch and then connect to MATLAB.\n     *\n     * @param connection The language server connection\n     * @returns The connected MATLAB process\n     */\n    private async _launchAndConnectToMatlab (connection: _Connection): Promise<MatlabProcess> {", "        if (this._matlabProcess == null || !this._matlabProcess.isValid) {\n            this._matlabProcess = new MatlabProcess(connection)\n        }\n\n        if (!this._matlabProcess.isMatlabReady()) {\n            await this._matlabProcess.launchMatlab()\n            this._handleMatlabLifecycleUpdate('connected')\n        }\n\n        return this._matlabProcess\n    }\n\n    /**\n     * Emits a lifecycle update to all listeners.\n     *\n     * @param status The connected status of MATLAB\n     */\n    private _handleMatlabLifecycleUpdate (status: 'connected' | 'disconnected'): void {\n        this._matlabLifecycleCallbacks.forEach(callback => {\n            callback(null, {\n                matlabStatus: status\n            })\n        })\n    }\n\n    /**\n     *\n     * @returns True if the MATLAB connection timing setting is set to never. Returns false otherwise.\n     */\n    private async _isMatlabConnectionTimingNever (): Promise<boolean> {\n        const connectionTiming = (await ConfigurationManager.getConfiguration()).matlabConnectionTiming\n        return connectionTiming === ConnectionTiming.Never\n    }\n}\n\n/**\n * Represents a MATLAB process\n */", "class MatlabProcess {\n    private _matlabProcess?: ChildProcess\n    private _matlabConnection: MatlabConnection | null = null\n    private _matlabPid = 0\n    private _isReady = false // Whether MATLAB is ready for communication\n\n    isValid = true // Gets set to false when the process is terminated\n    isExistingInstance = false\n\n    constructor (private readonly _connection: _Connection) {}\n\n    /**\n     * Gets the connection to MATLAB, if one exists.\n     *\n     * @returns The MATLAB connection, or null if none exists\n     */\n    getConnection (): MatlabConnection | null {\n        return this._matlabConnection\n    }\n\n    /**\n     Gets whether or not MATLAB is ready for communication\n     * @returns True if MATLAB can be communicated with, false otherwise\n     */\n    isMatlabReady (): boolean {\n        return this.isValid && this._isReady\n    }\n\n    /**\n     * Shuts down the MATLAB process\n     */\n    shutdown (): void {", "        if (!this.isValid) {\n            return\n        }\n\n        if (this.isExistingInstance) {\n            // Only want to close the connection\n            this._matlabConnection?.close()\n        } else {\n            // Close connection and kill MATLAB process\n            if (os.platform() === 'win32' && this._matlabPid > 0) {\n                // Need to kill the child process which is launched on Windows\n                process.kill(this._matlabPid)\n            }\n            this._matlabConnection?.close()\n            this._matlabProcess?.kill()\n        }\n\n        this.isValid = false\n        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n        reportTelemetryAction(Actions.ShutdownMatlab)\n    }\n\n    /**\n     * Attempts to launch a new instance of MATLAB\n     */\n    async launchMatlab (): Promise<void> {\n        LifecycleNotificationHelper.didMatlabLaunchFail = false\n        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTING)\n\n        return await new Promise<void>(resolve => {\n            const outFile = path.join(Logger.logDir, 'matlabls_conn.json')", "            if (os.platform() === 'win32' && this._matlabPid > 0) {\n                // Need to kill the child process which is launched on Windows\n                process.kill(this._matlabPid)\n            }\n            this._matlabConnection?.close()\n            this._matlabProcess?.kill()\n        }\n\n        this.isValid = false\n        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n        reportTelemetryAction(Actions.ShutdownMatlab)\n    }\n\n    /**\n     * Attempts to launch a new instance of MATLAB\n     */\n    async launchMatlab (): Promise<void> {\n        LifecycleNotificationHelper.didMatlabLaunchFail = false\n        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTING)\n\n        return await new Promise<void>(resolve => {\n            const outFile = path.join(Logger.logDir, 'matlabls_conn.json')", "            if (!fs.existsSync(outFile)) {\n                fs.writeFileSync(outFile, '', { mode: '600' })\n            }\n\n            fs.watchFile(outFile, () => {\n                Logger.log('Started MATLAB')\n\n                this._isReady = true\n\n                const data = fs.readFileSync(outFile)\n                const info = JSON.parse(data.toString())\n\n                this._matlabPid = info.matlabPid\n                const matlabRelease = info.matlabRelease as string // e.g. R2023a\n\n                this._matlabConnection?.initialize().then(() => {\n                    fs.unwatchFile(outFile)\n                    LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTED)\n                    reportTelemetryAction(Actions.StartMatlab, matlabRelease)\n                    resolve()", "                }).catch(() => {\n                    Logger.error('Failed to connect to MATLAB')\n                    reportTelemetryAction(Actions.StartMatlab, 'Failed to connect to MATLAB')\n                })\n            })\n\n            void this._launchMatlabProcess(outFile)\n        })\n    }\n\n    /**\n     * Attempts to connect to an existing instance of MATLAB at the given URL.\n     *\n     * @param url The URL at which to find MATLAB\n     */\n    async connectToMatlab (url: string): Promise<void> {\n        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTING)\n\n        this._matlabConnection = await MatlabCommunicationManager.connectToExistingMatlab(url)\n\n        this._matlabConnection.setLifecycleListener(lifecycleEvent => {", "            if (lifecycleEvent === LifecycleEventType.CONNECTED) {\n                this._isReady = true\n                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTED)\n            } else if (lifecycleEvent === LifecycleEventType.DISCONNECTED) {\n                // Connection failed - retry after delay\n                this._matlabConnection?.close()\n                this._matlabConnection = null\n                this._isReady = false\n                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n                setTimeout(() => {\n                    void this.connectToMatlab(url)\n                }, 1000)\n            }\n        })\n\n        await this._matlabConnection.initialize()\n    }\n\n    /**\n     * Launches a MATLAB process.\n     *\n     * @param outFile The file in which MATLAB should output connection details\n     */\n    private async _launchMatlabProcess (outFile: string): Promise<void> {\n        const { command, args } = await this._getMatlabLaunchCommand(outFile)\n\n        Logger.log('Launching MATLAB...')\n\n        const matlabProcessInfo = await MatlabCommunicationManager.connectToNewMatlab(command, args, Logger.logDir)\n", "        if (matlabProcessInfo == null) {\n            Logger.error(`Error launching MATLAB with command: ${command}`)\n            this.isValid = false\n            LifecycleNotificationHelper.didMatlabLaunchFail = true\n            LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n            NotificationService.sendNotification(Notification.MatlabLaunchFailed)\n            return\n        }\n\n        const { matlabProcess, matlabConnection } = matlabProcessInfo\n\n        this._matlabProcess = matlabProcess\n        this._matlabConnection = matlabConnection\n\n        // Handle messages from MATLAB's standard err channel. Because MATLAB is launched\n        // with the -log flag, all of MATLAB's output is pushed through stderr. Write this\n        // to a log file.\n        this._matlabProcess.stderr?.on('data', data => {\n            const stderrStr: string = data.toString().trim()\n            Logger.writeMatlabLog(stderrStr)\n        })\n\n        /**\n         * Handles the MATLAB process being terminated unexpectedly.\n         * This could include the user killing the process.\n         */\n        this._matlabProcess.on('close', () => {\n            // Close connection\n            Logger.log('MATLAB process terminated')\n            this._matlabConnection?.close()\n            this.isValid = false\n\n            LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n        })\n\n        // Handles errors with the MATLAB process\n        this._matlabProcess.on('error', error => {\n            Logger.error(`Error launching MATLAB: ${error.message}`)\n            Logger.error(`Error launching MATLAB: ${error.name}`)", "            if (error.stack != null) {\n                Logger.error(`Error launching MATLAB: ${error.stack}`)\n            }\n\n            LifecycleNotificationHelper.didMatlabLaunchFail = true\n            NotificationService.sendNotification(Notification.MatlabLaunchFailed)\n        })\n\n        this._matlabConnection.setLifecycleListener(lifecycleEvent => {\n            if (lifecycleEvent === LifecycleEventType.DISCONNECTED) {\n                Logger.warn('Error while communicating with MATLAB - disconnecting')\n                this._matlabConnection?.close()\n                this.isValid = false\n\n                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n                reportTelemetryAction(Actions.ShutdownMatlab, 'Error while communicating with MATLAB')\n            }\n        })\n    }\n\n    /**\n     * Gets the command with which MATLAB should be launched.\n     *\n     * @param outFile The file in which MATLAB should output connection details\n     * @returns The matlab launch command\n     */\n    private async _getMatlabLaunchCommand (outFile: string): Promise<{ command: string, args: string[] }> {\n        const matlabInstallPath = (await ConfigurationManager.getConfiguration()).installPath\n        let command = 'matlab'", "            if (lifecycleEvent === LifecycleEventType.DISCONNECTED) {\n                Logger.warn('Error while communicating with MATLAB - disconnecting')\n                this._matlabConnection?.close()\n                this.isValid = false\n\n                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n                reportTelemetryAction(Actions.ShutdownMatlab, 'Error while communicating with MATLAB')\n            }\n        })\n    }\n\n    /**\n     * Gets the command with which MATLAB should be launched.\n     *\n     * @param outFile The file in which MATLAB should output connection details\n     * @returns The matlab launch command\n     */\n    private async _getMatlabLaunchCommand (outFile: string): Promise<{ command: string, args: string[] }> {\n        const matlabInstallPath = (await ConfigurationManager.getConfiguration()).installPath\n        let command = 'matlab'", "        if (matlabInstallPath !== '') {\n            command = path.normalize(path.join(\n                matlabInstallPath,\n                'bin',\n                'matlab'\n            ))\n        }\n\n        const args = [\n            '-log',\n            '-memmgr', 'release', // Memory manager\n            '-noAppIcon', // Hide MATLAB application icon in taskbar/dock, if applicable\n            '-nosplash', // Hide splash screen\n            '-r', `addpath(fullfile('${__dirname}', '..', 'matlab')); initmatlabls('${outFile}')`, // Startup command\n            '-useStartupFolderPref' // Startup folder flag\n        ]\n", "        if (os.platform() === 'win32') {\n            args.push('-noDisplayDesktop') // Workaround for '-nodesktop' on Windows until a better solution is implemented\n            args.push('-wait')\n        } else {\n            args.push('-nodesktop')\n        }\n\n        const argsFromSettings = ConfigurationManager.getArgument(Argument.MatlabLaunchCommandArguments) ?? null\n        if (argsFromSettings != null) {\n            args.push(argsFromSettings)\n        }\n\n        return {\n            command,\n            args\n        }\n    }\n}\n\nexport default new MatlabLifecycleManager()\n", "        if (argsFromSettings != null) {\n            args.push(argsFromSettings)\n        }\n\n        return {\n            command,\n            args\n        }\n    }\n}\n\nexport default new MatlabLifecycleManager()\n"]}
{"filename": "src/lifecycle/ConfigurationManager.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\nimport { ClientCapabilities, DidChangeConfigurationNotification, DidChangeConfigurationParams } from 'vscode-languageserver'\nimport { reportTelemetrySettingsChange } from '../logging/TelemetryUtils'\nimport { connection } from '../server'\nimport { getCliArgs } from '../utils/CliUtils'\n\nexport enum Argument {\n    // Basic arguments\n    MatlabLaunchCommandArguments = 'matlabLaunchCommandArgs',\n    MatlabInstallationPath = 'matlabInstallPath',\n    MatlabConnectionTiming = 'matlabConnectionTiming',\n\n    ShouldIndexWorkspace = 'indexWorkspace',\n\n    // Advanced arguments\n    MatlabUrl = 'matlabUrl'\n}\n", "export enum ConnectionTiming {\n    OnStart = 'onStart',\n    OnDemand = 'onDemand',\n    Never = 'never'\n}\n\ninterface CliArguments { \n    [Argument.MatlabLaunchCommandArguments]: string\n    [Argument.MatlabUrl]: string\n}\n", "interface Settings {\n    installPath: string\n    matlabConnectionTiming: ConnectionTiming\n    indexWorkspace: boolean\n    telemetry: boolean\n}\n\ntype SettingName = 'installPath' | 'matlabConnectionTiming' | 'indexWorkspace' | 'telemetry'\n\nconst SETTING_NAMES: SettingName[] = [\n    'installPath',\n    'matlabConnectionTiming',\n    'indexWorkspace',\n    'telemetry'\n]\n", "class ConfigurationManager {\n    private configuration: Settings | null = null\n    private readonly defaultConfiguration: Settings\n    private globalSettings: Settings\n\n    // Holds additional command line arguments that are not part of the configuration\n    private readonly additionalArguments: CliArguments\n\n    private hasConfigurationCapability = false\n\n    constructor () {\n        const cliArgs = getCliArgs()\n\n        this.defaultConfiguration = {\n            installPath: '',\n            matlabConnectionTiming: ConnectionTiming.OnStart,\n            indexWorkspace: false,\n            telemetry: true\n        }\n\n        this.globalSettings = {\n            installPath: cliArgs[Argument.MatlabInstallationPath] ?? this.defaultConfiguration.installPath,\n            matlabConnectionTiming: cliArgs[Argument.MatlabConnectionTiming] as ConnectionTiming ?? this.defaultConfiguration.matlabConnectionTiming,\n            indexWorkspace: cliArgs[Argument.ShouldIndexWorkspace] ?? this.defaultConfiguration.indexWorkspace,\n            telemetry: this.defaultConfiguration.telemetry\n        }\n\n        this.additionalArguments = {\n            [Argument.MatlabLaunchCommandArguments]: cliArgs[Argument.MatlabLaunchCommandArguments] ?? '',\n            [Argument.MatlabUrl]: cliArgs[Argument.MatlabUrl] ?? ''\n        }\n    }\n\n    /**\n     * Sets up the configuration manager\n     *\n     * @param capabilities The client capabilities\n     */\n    setup (capabilities: ClientCapabilities): void {\n        this.hasConfigurationCapability = capabilities.workspace?.configuration != null\n", "        if (this.hasConfigurationCapability) {\n            // Register for configuration changes\n            void connection.client.register(DidChangeConfigurationNotification.type)\n        }\n\n        connection.onDidChangeConfiguration(params => { void this.handleConfigurationChanged(params) })\n    }\n\n    /**\n     * Gets the configuration for the langauge server\n     *\n     * @returns The current configuration\n     */\n    async getConfiguration (): Promise<Settings> {", "        if (this.hasConfigurationCapability) {\n            if (this.configuration == null) {\n                this.configuration = await connection.workspace.getConfiguration('MATLAB') as Settings\n            }\n\n            return this.configuration\n        }\n\n        return this.globalSettings\n    }\n\n    /**\n     * Gets the value of the given argument\n     *\n     * @param argument The argument\n     * @returns The argument's value\n     */\n    getArgument (argument: Argument.MatlabLaunchCommandArguments | Argument.MatlabUrl): string {\n        return this.additionalArguments[argument]\n    }\n\n    /**\n     * Handles a change in the configuration\n     * @param params The configuration changed params\n     */\n    private async handleConfigurationChanged (params: DidChangeConfigurationParams): Promise<void> {\n        let oldConfig: Settings | null\n        let newConfig: Settings\n", "        if (this.hasConfigurationCapability) {\n            oldConfig = this.configuration\n\n            // Clear cached configuration\n            this.configuration = null\n\n            // Force load new configuration\n            newConfig = await this.getConfiguration()\n        } else {\n            oldConfig = this.globalSettings\n            this.globalSettings = params.settings?.matlab ?? this.defaultConfiguration\n\n            newConfig = this.globalSettings\n        }\n\n        this.compareSettingChanges(oldConfig, newConfig)\n    }\n\n    private compareSettingChanges (oldConfiguration: Settings | null, newConfiguration: Settings): void {", "        if (oldConfiguration == null) {\n            // Not yet initialized\n            return\n        }\n\n        for (let i = 0; i < SETTING_NAMES.length; i++) {\n            const settingName = SETTING_NAMES[i]\n            const oldValue = oldConfiguration[settingName]\n            const newValue = newConfiguration[settingName]\n\n            if (oldValue !== newValue) {\n                reportTelemetrySettingsChange(settingName, newValue.toString(), oldValue.toString())\n            }\n        }\n    }\n}\n\nexport default new ConfigurationManager()\n", "            if (oldValue !== newValue) {\n                reportTelemetrySettingsChange(settingName, newValue.toString(), oldValue.toString())\n            }\n        }\n    }\n}\n\nexport default new ConfigurationManager()\n"]}
