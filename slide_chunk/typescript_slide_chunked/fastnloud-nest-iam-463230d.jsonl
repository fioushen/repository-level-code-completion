{"filename": "src/index.ts", "chunked_list": ["export * from './decorators/active-user.decorator';\nexport * from './decorators/auth.decorator';\nexport * from './decorators/roles.decorator';\nexport * from './enums/auth-type.enum';\nexport * from './enums/token-type.enum';\nexport * from './events/logged-in.event';\nexport * from './events/logged-out.event';\nexport * from './hashers/bcrypt.hasher';\nexport * from './iam.module';\nexport * from './interfaces/active-user.interface';", "export * from './iam.module';\nexport * from './interfaces/active-user.interface';\nexport * from './interfaces/auth-service.interface';\nexport * from './interfaces/login.interface';\nexport * from './interfaces/module-options.interface';\nexport * from './interfaces/token.interface';\nexport * from './interfaces/user.interface';\nexport * from './processors/login.processor';\n", ""]}
{"filename": "src/iam.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { APP_GUARD } from '@nestjs/core';\nimport { CqrsModule } from '@nestjs/cqrs';\nimport { JwtModule } from '@nestjs/jwt';\nimport iamConfig from './configs/iam.config';\nimport { AuthController } from './controllers/auth.controller';\nimport { AccessTokenGenerator } from './generators/access-token.generator';\nimport { PasswordlessLoginTokenGenerator } from './generators/passwordless-login-token.generator';\nimport { RefreshTokenGenerator } from './generators/refresh-token.generator';", "import { PasswordlessLoginTokenGenerator } from './generators/passwordless-login-token.generator';\nimport { RefreshTokenGenerator } from './generators/refresh-token.generator';\nimport { AccessTokenGuard } from './guards/access-token.guard';\nimport { AuthGuard } from './guards/auth.guard';\nimport { NoneGuard } from './guards/none.guard';\nimport { RolesGuard } from './guards/roles.guard';\nimport { BcryptHasher } from './hashers/bcrypt.hasher';\nimport { ConfigurableModuleClass } from './iam.module-definition';\nimport { LoginProcessor } from './processors/login.processor';\nimport { LogoutProcessor } from './processors/logout.processor';", "import { LoginProcessor } from './processors/login.processor';\nimport { LogoutProcessor } from './processors/logout.processor';\nimport { PasswordlessLoginRequestProcessor } from './processors/passwordless-login-request.processor';\n\n@Module({\n  imports: [\n    ConfigModule.forFeature(iamConfig),\n    CqrsModule,\n    JwtModule.registerAsync({\n      imports: [ConfigModule],", "    JwtModule.registerAsync({\n      imports: [ConfigModule],\n      useFactory: async (config: ConfigService) => ({\n        secret: config.get('iam.jwt.secret'),\n        signOptions: {\n          audience: config.get('iam.jwt.audience'),\n          issuer: config.get('iam.jwt.issuer'),\n        },\n      }),\n      inject: [ConfigService],", "      }),\n      inject: [ConfigService],\n    }),\n  ],\n  providers: [\n    AccessTokenGenerator,\n    AccessTokenGuard,\n    AuthGuard,\n    BcryptHasher,\n    LoginProcessor,", "    BcryptHasher,\n    LoginProcessor,\n    LogoutProcessor,\n    NoneGuard,\n    PasswordlessLoginRequestProcessor,\n    PasswordlessLoginTokenGenerator,\n    RefreshTokenGenerator,\n    RolesGuard,\n    {\n      provide: APP_GUARD,", "    {\n      provide: APP_GUARD,\n      useClass: AuthGuard,\n    },\n    {\n      provide: APP_GUARD,\n      useClass: RolesGuard,\n    },\n  ],\n  exports: [BcryptHasher, LoginProcessor],", "  ],\n  exports: [BcryptHasher, LoginProcessor],\n  controllers: [AuthController],\n})\nexport class IamModule extends ConfigurableModuleClass {}\n"]}
{"filename": "src/iam.module-definition.ts", "chunked_list": ["import { ConfigurableModuleBuilder } from '@nestjs/common';\nimport { IModuleOptions } from './interfaces/module-options.interface';\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<IModuleOptions>()\n    .setClassMethodName('register')\n    .build();\n"]}
{"filename": "src/processors/login.processor.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { Response } from 'express';\nimport iamConfig from '../configs/iam.config';\nimport { TokenType } from '../enums/token-type.enum';\nimport { AccessTokenGenerator } from '../generators/access-token.generator';\nimport { RefreshTokenGenerator } from '../generators/refresh-token.generator';\nimport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\nimport { ILogin } from '../interfaces/login.interface';\nimport { IModuleOptions } from '../interfaces/module-options.interface';", "import { ILogin } from '../interfaces/login.interface';\nimport { IModuleOptions } from '../interfaces/module-options.interface';\nimport { IUser } from '../interfaces/user.interface';\nimport { TokenModel } from '../models/token.model';\n\n@Injectable()\nexport class LoginProcessor {\n  public constructor(\n    private readonly accessTokenGenerator: AccessTokenGenerator,\n    private readonly refreshTokenGenerator: RefreshTokenGenerator,\n    @Inject(MODULE_OPTIONS_TOKEN)\n    private readonly moduleOptions: IModuleOptions,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  public async process(user: IUser, response: Response): Promise<ILogin> {\n    const accessToken = await this.accessTokenGenerator.generate(user);\n    const refreshToken = await this.refreshTokenGenerator.generate(user);\n\n    const login = {\n      accessToken: accessToken.jwt,\n      refreshToken: refreshToken.jwt,\n    };\n\n    await this.moduleOptions.authService.saveToken(\n      new TokenModel(\n        refreshToken.id,\n        TokenType.RefreshToken,\n        user.getId(),\n        refreshToken.expiresAt,\n      ),\n    );\n\n    response.cookie(TokenType.AccessToken, accessToken.jwt, {\n      secure: this.config.cookie.secure,\n      httpOnly: this.config.cookie.httpOnly,\n      sameSite: this.config.cookie.sameSite,\n      expires: accessToken.expiresAt,\n    });\n\n    response.cookie(TokenType.RefreshToken, refreshToken.jwt, {\n      secure: this.config.cookie.secure,\n      httpOnly: this.config.cookie.httpOnly,\n      sameSite: this.config.cookie.sameSite,\n      expires: refreshToken.expiresAt,\n      path: `${this.config.routePathPrefix}/auth`,\n    });\n\n    return login;\n  }\n}\n"]}
{"filename": "src/processors/passwordless-login-request.processor.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { randomUUID } from 'crypto';\nimport { Response } from 'express';\nimport iamConfig from '../configs/iam.config';\nimport { TokenType } from '../enums/token-type.enum';\nimport { PasswordlessLoginTokenGenerator } from '../generators/passwordless-login-token.generator';\nimport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\nimport { IModuleOptions } from '../interfaces/module-options.interface';\nimport { IUser } from '../interfaces/user.interface';", "import { IModuleOptions } from '../interfaces/module-options.interface';\nimport { IUser } from '../interfaces/user.interface';\n\n@Injectable()\nexport class PasswordlessLoginRequestProcessor {\n  public constructor(\n    private readonly passwordlessLoginTokenGenerator: PasswordlessLoginTokenGenerator,\n    @Inject(MODULE_OPTIONS_TOKEN)\n    private readonly moduleOptions: IModuleOptions,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  public async process(user: IUser, response: Response): Promise<void> {\n    const requestId = randomUUID();\n    const passwordlessLoginToken =\n      await this.passwordlessLoginTokenGenerator.generate(user, requestId);\n\n    await this.moduleOptions.authService.saveToken(passwordlessLoginToken);\n\n    response.cookie(TokenType.PasswordlessLoginToken, requestId, {\n      secure: this.config.cookie.secure,\n      httpOnly: this.config.cookie.httpOnly,\n      sameSite: this.config.cookie.sameSite,\n      expires: passwordlessLoginToken.getExpiresAt(),\n      path: `${this.config.routePathPrefix}/auth`,\n    });\n  }\n}\n"]}
{"filename": "src/processors/logout.processor.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { JwtService } from '@nestjs/jwt';\nimport { Request, Response } from 'express';\nimport { IRefreshTokenJwtPayload } from 'src/interfaces/refresh-token-jwt-payload.interface';\nimport iamConfig from '../configs/iam.config';\nimport { TokenType } from '../enums/token-type.enum';\nimport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\nimport { IModuleOptions } from '../interfaces/module-options.interface';\n", "import { IModuleOptions } from '../interfaces/module-options.interface';\n\n@Injectable()\nexport class LogoutProcessor {\n  public constructor(\n    private readonly jwtService: JwtService,\n    @Inject(MODULE_OPTIONS_TOKEN)\n    private readonly moduleOptions: IModuleOptions,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  public async process(request: Request, response: Response): Promise<void> {", "    try {\n      const refreshTokenJwtPayload: IRefreshTokenJwtPayload =\n        await this.jwtService.verifyAsync(\n          request.cookies[TokenType.RefreshToken],\n        );\n\n      await this.moduleOptions.authService.removeToken(\n        refreshTokenJwtPayload.id,\n      );\n    } catch {}\n\n    response.clearCookie(TokenType.AccessToken);\n    response.clearCookie(TokenType.RefreshToken, {\n      path: `${this.config.routePathPrefix}/auth`,\n    });\n  }\n}\n"]}
{"filename": "src/dtos/login-request.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\nimport { IsString } from 'class-validator';\n\nexport class LoginRequestDto {\n  @IsString()\n  @ApiProperty()\n  username: string;\n\n  @IsString()\n  @ApiProperty()\n  password: string;\n}\n"]}
{"filename": "src/dtos/login-response.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\nexport class LoginResponseDto {\n  @ApiProperty()\n  public readonly accessToken: string;\n\n  @ApiProperty()\n  public readonly refreshToken: string;\n}\n"]}
{"filename": "src/dtos/passwordless-login-request-request.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\nimport { IsString } from 'class-validator';\n\nexport class PasswordlessLoginRequestRequestDto {\n  @IsString()\n  @ApiProperty()\n  username: string;\n}\n"]}
{"filename": "src/configs/iam.config.ts", "chunked_list": ["import { registerAs } from '@nestjs/config';\nimport * as Joi from 'joi';\n\nexport default registerAs('iam', () => {\n  const config = {\n    routePathPrefix: process.env.IAM_ROUTE_PATH_PREFIX || '',\n    auth: {\n      methods: (process.env.IAM_AUTH_METHODS || '').split(','),\n      passwordless: {\n        tokenTtl: process.env.IAM_AUTH_PASSWORDLESS_TOKEN_TTL,", "      passwordless: {\n        tokenTtl: process.env.IAM_AUTH_PASSWORDLESS_TOKEN_TTL,\n      },\n    },\n    cookie: {\n      httpOnly: process.env.IAM_COOKIE_HTTP_ONLY,\n      sameSite: process.env.IAM_COOKIE_SAME_SITE,\n      secure: process.env.IAM_COOKIE_SECURE,\n    },\n    jwt: {", "    },\n    jwt: {\n      accessTokenTtl: process.env.IAM_JWT_ACCESS_TOKEN_TTL,\n      audience: process.env.IAM_JWT_TOKEN_AUDIENCE,\n      issuer: process.env.IAM_JWT_TOKEN_ISSUER,\n      refreshTokenTtl: process.env.IAM_JWT_REFRESH_TOKEN_TTL,\n      secret: process.env.IAM_JWT_SECRET,\n    },\n  };\n", "  };\n\n  const validationResult = Joi.object({\n    auth: Joi.object({\n      methods: Joi.array()\n        .items(Joi.string().valid('basic', 'passwordless'))\n        .min(1)\n        .required()\n        .messages({\n          '*': 'Environment variable IAM_AUTH_METHODS is required (e.g. basic,passwordless (comma separated))',", "        .messages({\n          '*': 'Environment variable IAM_AUTH_METHODS is required (e.g. basic,passwordless (comma separated))',\n        }),\n      passwordless: Joi.any().when('methods', {\n        is: Joi.array().items().has('passwordless'),\n        then: Joi.object({\n          tokenTtl: Joi.number().positive().required().messages({\n            '*': 'Environment variable IAM_AUTH_PASSWORDLESS_TOKEN_TTL is required (e.g. 300 for 5 minutes)',\n          }),\n        }),", "          }),\n        }),\n      }),\n    }),\n    cookie: Joi.object({\n      httpOnly: Joi.valid('1', '0').required().messages({\n        '*': 'Environment variable IAM_COOKIE_HTTP_ONLY is required (1 or 0)',\n      }),\n      sameSite: Joi.valid('lax', 'strict', 'none').required().messages({\n        '*': 'Environment variable IAM_COOKIE_SAME_SITE is required (lax, strict or none)',", "      sameSite: Joi.valid('lax', 'strict', 'none').required().messages({\n        '*': 'Environment variable IAM_COOKIE_SAME_SITE is required (lax, strict or none)',\n      }),\n      secure: Joi.valid('1', '0').required().messages({\n        '*': 'Environment variable IAM_COOKIE_SECURE is required (1 or 0)',\n      }),\n    }),\n    jwt: Joi.object({\n      accessTokenTtl: Joi.number().positive().required().messages({\n        '*': 'Environment variable IAM_JWT_ACCESS_TOKEN_TTL is required (e.g. 3600 for 1 hour)',", "      accessTokenTtl: Joi.number().positive().required().messages({\n        '*': 'Environment variable IAM_JWT_ACCESS_TOKEN_TTL is required (e.g. 3600 for 1 hour)',\n      }),\n      audience: Joi.string().required().messages({\n        '*': 'Environment variable IAM_JWT_TOKEN_AUDIENCE is required (e.g. localhost)',\n      }),\n      issuer: Joi.string().required().messages({\n        '*': 'Environment variable IAM_JWT_TOKEN_ISSUER is required (e.g. localhost)',\n      }),\n      refreshTokenTtl: Joi.number().positive().required().messages({", "      }),\n      refreshTokenTtl: Joi.number().positive().required().messages({\n        '*': 'Environment variable IAM_JWT_REFRESH_TOKEN_TTL is required (e.g. 86400 for 1 day)',\n      }),\n      secret: Joi.string().required().messages({\n        '*': 'Environment variable IAM_JWT_SECRET is required (e.g. superSecretString)',\n      }),\n    }),\n    routePathPrefix: Joi.string().allow('').optional().messages({\n      '*': 'Environment variable IAM_ROUTE_PATH_PREFIX must be a string (e.g. /api)',", "    routePathPrefix: Joi.string().allow('').optional().messages({\n      '*': 'Environment variable IAM_ROUTE_PATH_PREFIX must be a string (e.g. /api)',\n    }),\n  }).validate(config, { abortEarly: false });\n\n  if (validationResult.error) {\n    throw validationResult.error;\n  }\n\n  return {\n    ...config,\n    auth: {\n      ...config.auth,\n      passwordless: {\n        ...config.auth.passwordless,\n        tokenTtl: config.auth.passwordless.tokenTtl\n          ? parseInt(config.auth.passwordless.tokenTtl, 10)\n          : undefined,\n      },\n    },\n    jwt: {\n      ...config.jwt,\n      accessTokenTtl: parseInt(config.jwt.accessTokenTtl, 10),\n      refreshTokenTtl: parseInt(config.jwt.refreshTokenTtl, 10),\n    },\n    cookie: {\n      httpOnly: config.cookie.httpOnly === '1',\n      sameSite: config.cookie.sameSite as 'lax' | 'strict' | 'none',\n      secure: config.cookie.secure === '1',\n    },\n  };\n});\n"]}
{"filename": "src/events/logged-in.event.ts", "chunked_list": ["export class LoggedInEvent {\n  constructor(public readonly userId: string) {}\n}\n"]}
{"filename": "src/events/logged-out.event.ts", "chunked_list": ["export class LoggedOutEvent {\n  constructor(public readonly userId: string) {}\n}\n"]}
{"filename": "src/constants/iam.constants.ts", "chunked_list": ["export const IAM_AUTH_TYPE_KEY = 'iamAuthType';\nexport const IAM_REQUEST_USER_KEY = 'iamUser';\nexport const IAM_ROLES_KEY = 'iamRoles';\n"]}
{"filename": "src/prompts/hash-password.prompt.ts", "chunked_list": ["#!/usr/bin/env node\nimport { PromptObject, prompt } from 'prompts';\nimport { BcryptHasher } from '../hashers/bcrypt.hasher';\n\n(async () => {\n  const questions: PromptObject[] = [\n    {\n      type: 'password',\n      name: 'username',\n      message: 'Type in the password you would like to hash:',", "      name: 'username',\n      message: 'Type in the password you would like to hash:',\n    },\n  ];\n\n  await prompt(questions, {\n    onSubmit: async (_: string, answer: string) =>\n      console.log(await new BcryptHasher().hash(answer)),\n  });\n})();", "  });\n})();\n"]}
{"filename": "src/interfaces/user.interface.ts", "chunked_list": ["export interface IUser {\n  getId(): string;\n  getUsername(): string;\n  getPassword(): string;\n  getRoles(): string[];\n}\n"]}
{"filename": "src/interfaces/module-options.interface.ts", "chunked_list": ["import { IAuthService } from './auth-service.interface';\n\nexport interface IModuleOptions {\n  authService: IAuthService;\n}\n"]}
{"filename": "src/interfaces/cookie.interface.ts", "chunked_list": ["export interface ICookie {\n  name: string;\n  value: string;\n  ttl: number;\n}\n"]}
{"filename": "src/interfaces/auth-service.interface.ts", "chunked_list": ["import { IToken } from './token.interface';\nimport { IUser } from './user.interface';\n\nexport interface IAuthService {\n  checkToken(id: string, type: string, requestId?: string): Promise<IToken>;\n  checkUser(username: string): Promise<IUser>;\n  getUser(id: string): Promise<IUser>;\n  removeToken(id: string): Promise<void>;\n  saveToken(token: IToken): Promise<void>;\n}\n"]}
{"filename": "src/interfaces/login.interface.ts", "chunked_list": ["export interface ILogin {\n  accessToken: string;\n  refreshToken: string;\n}\n"]}
{"filename": "src/interfaces/access-token.interface.ts", "chunked_list": ["export interface IAccessToken {\n  jwt: string;\n  expiresAt: Date;\n}\n"]}
{"filename": "src/interfaces/active-user.interface.ts", "chunked_list": ["export interface IActiveUser {\n  userId: string;\n  roles: string[];\n}\n"]}
{"filename": "src/interfaces/token.interface.ts", "chunked_list": ["export interface IToken {\n  getId(): string;\n  getRequestId(): string | undefined;\n  getUserId(): string;\n  getType(): string;\n  getExpiresAt(): Date;\n}\n"]}
{"filename": "src/interfaces/refresh-token-jwt-payload.interface.ts", "chunked_list": ["export interface IRefreshTokenJwtPayload {\n  id: string;\n  sub: string;\n  username: string;\n  roles: string[];\n}\n"]}
{"filename": "src/interfaces/hasher.interface.ts", "chunked_list": ["export interface IHasher {\n  hash(data: string | Buffer): Promise<string>;\n  compare(data: string | Buffer, encrypted: string): Promise<boolean>;\n}\n"]}
{"filename": "src/interfaces/refresh-token.interface.ts", "chunked_list": ["export interface IRefreshToken {\n  id: string;\n  jwt: string;\n  expiresAt: Date;\n}\n"]}
{"filename": "src/interfaces/access-token-jwt-payload.interface.ts", "chunked_list": ["export interface IAccessTokenJwtPayload {\n  sub: string;\n  username: string;\n  roles: string[];\n}\n"]}
{"filename": "src/generators/access-token.generator.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { JwtService } from '@nestjs/jwt';\nimport iamConfig from '../configs/iam.config';\nimport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';\nimport { IAccessToken } from '../interfaces/access-token.interface';\nimport { IUser } from '../interfaces/user.interface';\n\n@Injectable()\nexport class AccessTokenGenerator {\n  constructor(\n    private readonly jwtService: JwtService,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  async generate(user: IUser): Promise<IAccessToken> {\n    const ttl = this.config.jwt.accessTokenTtl;\n\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\n    return {\n      jwt: await this.jwtService.signAsync(\n        {\n          sub: user.getId(),\n          username: user.getUsername(),\n          roles: user.getRoles(),\n        } as IAccessTokenJwtPayload,\n        {\n          expiresIn: this.config.jwt.accessTokenTtl,\n        },\n      ),\n      expiresAt,\n    };\n  }\n}\n", "@Injectable()\nexport class AccessTokenGenerator {\n  constructor(\n    private readonly jwtService: JwtService,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  async generate(user: IUser): Promise<IAccessToken> {\n    const ttl = this.config.jwt.accessTokenTtl;\n\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\n    return {\n      jwt: await this.jwtService.signAsync(\n        {\n          sub: user.getId(),\n          username: user.getUsername(),\n          roles: user.getRoles(),\n        } as IAccessTokenJwtPayload,\n        {\n          expiresIn: this.config.jwt.accessTokenTtl,\n        },\n      ),\n      expiresAt,\n    };\n  }\n}\n"]}
{"filename": "src/generators/refresh-token.generator.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { JwtService } from '@nestjs/jwt';\nimport { randomUUID } from 'crypto';\nimport iamConfig from '../configs/iam.config';\nimport { IRefreshTokenJwtPayload } from '../interfaces/refresh-token-jwt-payload.interface';\nimport { IRefreshToken } from '../interfaces/refresh-token.interface';\nimport { IUser } from '../interfaces/user.interface';\n\n@Injectable()\nexport class RefreshTokenGenerator {\n  constructor(\n    private readonly jwtService: JwtService,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  async generate(user: IUser): Promise<IRefreshToken> {\n    const id = randomUUID();\n    const ttl = this.config.jwt.refreshTokenTtl;\n\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\n    return {\n      id,\n      jwt: await this.jwtService.signAsync(\n        {\n          id,\n          sub: user.getId(),\n          username: user.getUsername(),\n          roles: user.getRoles(),\n        } as IRefreshTokenJwtPayload,\n        {\n          expiresIn: this.config.jwt.refreshTokenTtl,\n        },\n      ),\n      expiresAt,\n    };\n  }\n}\n", "\n@Injectable()\nexport class RefreshTokenGenerator {\n  constructor(\n    private readonly jwtService: JwtService,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  async generate(user: IUser): Promise<IRefreshToken> {\n    const id = randomUUID();\n    const ttl = this.config.jwt.refreshTokenTtl;\n\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\n    return {\n      id,\n      jwt: await this.jwtService.signAsync(\n        {\n          id,\n          sub: user.getId(),\n          username: user.getUsername(),\n          roles: user.getRoles(),\n        } as IRefreshTokenJwtPayload,\n        {\n          expiresIn: this.config.jwt.refreshTokenTtl,\n        },\n      ),\n      expiresAt,\n    };\n  }\n}\n"]}
{"filename": "src/generators/passwordless-login-token.generator.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { randomUUID } from 'crypto';\nimport iamConfig from '../configs/iam.config';\nimport { TokenType } from '../enums/token-type.enum';\nimport { IToken } from '../interfaces/token.interface';\nimport { IUser } from '../interfaces/user.interface';\nimport { TokenModel } from '../models/token.model';\n\n@Injectable()\nexport class PasswordlessLoginTokenGenerator {\n  constructor(\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  async generate(user: IUser, requestId: string): Promise<IToken> {\n    const id = randomUUID();\n    const ttl = this.config.auth.passwordless.tokenTtl;\n\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\n    return new TokenModel(\n      id,\n      TokenType.PasswordlessLoginToken,\n      user.getId(),\n      expiresAt,\n      requestId,\n    );\n  }\n}\n", "\n@Injectable()\nexport class PasswordlessLoginTokenGenerator {\n  constructor(\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  async generate(user: IUser, requestId: string): Promise<IToken> {\n    const id = randomUUID();\n    const ttl = this.config.auth.passwordless.tokenTtl;\n\n    const expiresAt = new Date();\n    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\n    return new TokenModel(\n      id,\n      TokenType.PasswordlessLoginToken,\n      user.getId(),\n      expiresAt,\n      requestId,\n    );\n  }\n}\n"]}
{"filename": "src/models/token.model.ts", "chunked_list": ["import { IToken } from '../interfaces/token.interface';\n\nexport class TokenModel implements IToken {\n  constructor(\n    public readonly id: string,\n    public readonly type: string,\n    public readonly userId: string,\n    public readonly expiresAt: Date,\n    public readonly requestId?: string,\n  ) {}\n\n  public getId(): string {\n    return this.id;\n  }\n  public getRequestId(): string | undefined {\n    return this.requestId;\n  }\n  public getUserId(): string {\n    return this.userId;\n  }\n  public getType(): string {\n    return this.type;\n  }\n  public getExpiresAt(): Date {\n    return this.expiresAt;\n  }\n}\n"]}
{"filename": "src/enums/auth-type.enum.ts", "chunked_list": ["export enum AuthType {\n  AccessToken,\n  None,\n}\n"]}
{"filename": "src/enums/token-type.enum.ts", "chunked_list": ["export enum TokenType {\n  AccessToken = 'accessToken',\n  PasswordlessLoginToken = 'passwordlessLoginToken',\n  RefreshToken = 'refreshToken',\n}\n"]}
{"filename": "src/controllers/auth.controller.ts", "chunked_list": ["import {\n  Body,\n  Controller,\n  Get,\n  HttpCode,\n  HttpStatus,\n  Inject,\n  NotFoundException,\n  Param,\n  Post,", "  Param,\n  Post,\n  Req,\n  Res,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { ConfigType } from '@nestjs/config';\nimport { EventBus } from '@nestjs/cqrs';\nimport { JwtService } from '@nestjs/jwt';\nimport {", "import { JwtService } from '@nestjs/jwt';\nimport {\n  ApiNoContentResponse,\n  ApiOkResponse,\n  ApiOperation,\n  ApiTags,\n} from '@nestjs/swagger';\nimport { Request, Response } from 'express';\nimport iamConfig from '../configs/iam.config';\nimport { ActiveUser } from '../decorators/active-user.decorator';", "import iamConfig from '../configs/iam.config';\nimport { ActiveUser } from '../decorators/active-user.decorator';\nimport { Auth } from '../decorators/auth.decorator';\nimport { LoginRequestDto } from '../dtos/login-request.dto';\nimport { LoginResponseDto } from '../dtos/login-response.dto';\nimport { PasswordlessLoginRequestRequestDto } from '../dtos/passwordless-login-request-request.dto';\nimport { AuthType } from '../enums/auth-type.enum';\nimport { TokenType } from '../enums/token-type.enum';\nimport { LoggedInEvent } from '../events/logged-in.event';\nimport { LoggedOutEvent } from '../events/logged-out.event';", "import { LoggedInEvent } from '../events/logged-in.event';\nimport { LoggedOutEvent } from '../events/logged-out.event';\nimport { BcryptHasher } from '../hashers/bcrypt.hasher';\nimport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\nimport { IActiveUser } from '../interfaces/active-user.interface';\nimport { IModuleOptions } from '../interfaces/module-options.interface';\nimport { IRefreshTokenJwtPayload } from '../interfaces/refresh-token-jwt-payload.interface';\nimport { LoginProcessor } from '../processors/login.processor';\nimport { LogoutProcessor } from '../processors/logout.processor';\nimport { PasswordlessLoginRequestProcessor } from '../processors/passwordless-login-request.processor';", "import { LogoutProcessor } from '../processors/logout.processor';\nimport { PasswordlessLoginRequestProcessor } from '../processors/passwordless-login-request.processor';\n\n@Controller()\n@ApiTags('Auth')\nexport class AuthController {\n  constructor(\n    private readonly eventBus: EventBus,\n    private readonly hasher: BcryptHasher,\n    private readonly loginProcessor: LoginProcessor,\n    private readonly logoutProcessor: LogoutProcessor,\n    private readonly passwordlessLoginRequestProcessor: PasswordlessLoginRequestProcessor,\n    private readonly jwtService: JwtService,\n    @Inject(MODULE_OPTIONS_TOKEN)\n    private readonly moduleOptions: IModuleOptions,\n    @Inject(iamConfig.KEY)\n    private readonly config: ConfigType<typeof iamConfig>,\n  ) {}\n\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ operationId: 'authLogin' })\n  @ApiOkResponse({ type: LoginResponseDto })\n  @Auth(AuthType.None)\n  @Post('/auth/login')\n  async login(\n    @Body() request: LoginRequestDto,\n    @Res({ passthrough: true }) response: Response,\n  ): Promise<LoginResponseDto> {", "    if (!this.config.auth.methods.includes('basic')) {\n      throw new NotFoundException();\n    }\n\n    try {\n      const user = await this.moduleOptions.authService.checkUser(\n        request.username,\n      );\n\n      if (!(await this.hasher.compare(request.password, user.getPassword()))) {\n        throw new UnauthorizedException();\n      }\n\n      const login = await this.loginProcessor.process(user, response);\n\n      this.eventBus.publish(new LoggedInEvent(user.getId()));\n\n      return {\n        accessToken: login.accessToken,\n        refreshToken: login.refreshToken,\n      };\n    } catch {\n      throw new UnauthorizedException();\n    }\n  }\n\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ operationId: 'authPasswordlessLogin' })\n  @ApiOkResponse({ type: LoginResponseDto })\n  @Auth(AuthType.None)\n  @Get('/auth/passwordless_login/:id')\n  async passwordlessLogin(\n    @Param('id') tokenId: string,\n    @Req() request: Request,\n    @Res({ passthrough: true }) response: Response,\n  ): Promise<LoginResponseDto> {", "      if (!(await this.hasher.compare(request.password, user.getPassword()))) {\n        throw new UnauthorizedException();\n      }\n\n      const login = await this.loginProcessor.process(user, response);\n\n      this.eventBus.publish(new LoggedInEvent(user.getId()));\n\n      return {\n        accessToken: login.accessToken,\n        refreshToken: login.refreshToken,\n      };\n    } catch {\n      throw new UnauthorizedException();\n    }\n  }\n\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ operationId: 'authPasswordlessLogin' })\n  @ApiOkResponse({ type: LoginResponseDto })\n  @Auth(AuthType.None)\n  @Get('/auth/passwordless_login/:id')\n  async passwordlessLogin(\n    @Param('id') tokenId: string,\n    @Req() request: Request,\n    @Res({ passthrough: true }) response: Response,\n  ): Promise<LoginResponseDto> {", "    if (!this.config.auth.methods.includes('passwordless')) {\n      throw new NotFoundException();\n    }\n\n    const requestId = request.cookies[TokenType.PasswordlessLoginToken];\n\n    if (!requestId) {\n      throw new UnauthorizedException();\n    }\n\n    try {\n      const token = await this.moduleOptions.authService.checkToken(\n        tokenId,\n        TokenType.PasswordlessLoginToken,\n        requestId,\n      );\n      const user = await this.moduleOptions.authService.getUser(\n        token.getUserId(),\n      );\n\n      await this.moduleOptions.authService.checkUser(user.getUsername());\n      await this.moduleOptions.authService.removeToken(tokenId);\n\n      const login = await this.loginProcessor.process(user, response);\n\n      return {\n        accessToken: login.accessToken,\n        refreshToken: login.refreshToken,\n      };\n    } catch {\n      throw new UnauthorizedException();\n    }\n  }\n\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ operationId: 'authPasswordlessLoginRequest' })\n  @ApiNoContentResponse()\n  @Auth(AuthType.None)\n  @Post('/auth/passwordless_login')\n  async passwordlessLoginRequest(\n    @Body() request: PasswordlessLoginRequestRequestDto,\n    @Res({ passthrough: true }) response: Response,\n  ): Promise<void> {", "    try {\n      const token = await this.moduleOptions.authService.checkToken(\n        tokenId,\n        TokenType.PasswordlessLoginToken,\n        requestId,\n      );\n      const user = await this.moduleOptions.authService.getUser(\n        token.getUserId(),\n      );\n\n      await this.moduleOptions.authService.checkUser(user.getUsername());\n      await this.moduleOptions.authService.removeToken(tokenId);\n\n      const login = await this.loginProcessor.process(user, response);\n\n      return {\n        accessToken: login.accessToken,\n        refreshToken: login.refreshToken,\n      };\n    } catch {\n      throw new UnauthorizedException();\n    }\n  }\n\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ operationId: 'authPasswordlessLoginRequest' })\n  @ApiNoContentResponse()\n  @Auth(AuthType.None)\n  @Post('/auth/passwordless_login')\n  async passwordlessLoginRequest(\n    @Body() request: PasswordlessLoginRequestRequestDto,\n    @Res({ passthrough: true }) response: Response,\n  ): Promise<void> {", "    if (!this.config.auth.methods.includes('passwordless')) {\n      throw new NotFoundException();\n    }\n\n    try {\n      const user = await this.moduleOptions.authService.checkUser(\n        request.username,\n      );\n\n      await this.passwordlessLoginRequestProcessor.process(user, response);\n    } catch {}\n  }\n\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ operationId: 'authRefreshTokens' })\n  @ApiOkResponse({ type: LoginResponseDto })\n  @Auth(AuthType.None)\n  @Get('/auth/refresh_tokens')\n  async refreshTokens(\n    @Req() request: Request,\n    @Res({ passthrough: true }) response: Response,\n  ): Promise<LoginResponseDto> {", "    try {\n      const refreshTokenJwtPayload: IRefreshTokenJwtPayload =\n        await this.jwtService.verifyAsync(\n          request.cookies[TokenType.RefreshToken],\n        );\n\n      await this.moduleOptions.authService.checkToken(\n        refreshTokenJwtPayload.id,\n        TokenType.RefreshToken,\n      );\n\n      const user = await this.moduleOptions.authService.getUser(\n        refreshTokenJwtPayload.sub,\n      );\n\n      await this.moduleOptions.authService.checkUser(user.getUsername());\n      await this.moduleOptions.authService.removeToken(\n        refreshTokenJwtPayload.id,\n      );\n\n      const login = await this.loginProcessor.process(user, response);\n\n      return {\n        accessToken: login.accessToken,\n        refreshToken: login.refreshToken,\n      };\n    } catch {\n      throw new UnauthorizedException();\n    }\n  }\n\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ operationId: 'authLogout' })\n  @ApiNoContentResponse()\n  @Auth(AuthType.None)\n  @Get('/auth/logout')\n  async logout(\n    @Req() request: Request,\n    @Res({ passthrough: true }) response: Response,\n    @ActiveUser() activeUser: IActiveUser,\n  ) {\n    await this.logoutProcessor.process(request, response);\n", "    if (!activeUser) {\n      return;\n    }\n\n    this.eventBus.publish(new LoggedOutEvent(activeUser.userId));\n  }\n}\n"]}
{"filename": "src/decorators/roles.decorator.ts", "chunked_list": ["import { SetMetadata } from '@nestjs/common';\nimport { IAM_ROLES_KEY } from '../constants/iam.constants';\n\nexport const Roles = (...roles: string[]) => SetMetadata(IAM_ROLES_KEY, roles);\n"]}
{"filename": "src/decorators/auth.decorator.ts", "chunked_list": ["import { SetMetadata } from '@nestjs/common';\nimport { IAM_AUTH_TYPE_KEY } from '../constants/iam.constants';\nimport { AuthType } from '../enums/auth-type.enum';\n\nexport const Auth = (...authTypes: AuthType[]) =>\n  SetMetadata(IAM_AUTH_TYPE_KEY, authTypes);\n"]}
{"filename": "src/decorators/active-user.decorator.ts", "chunked_list": ["import { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { IAM_REQUEST_USER_KEY } from '../constants/iam.constants';\nimport { IActiveUser } from '../interfaces/active-user.interface';\n\nexport const ActiveUser = createParamDecorator(\n  (field: keyof IActiveUser | undefined, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    const user: IActiveUser | undefined = request[IAM_REQUEST_USER_KEY];\n\n    return field ? user?.[field] : user;", "\n    return field ? user?.[field] : user;\n  },\n);\n"]}
{"filename": "src/guards/access-token.guard.ts", "chunked_list": ["import {\n  CanActivate,\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { IAM_REQUEST_USER_KEY } from '../constants/iam.constants';\nimport { TokenType } from '../enums/token-type.enum';\nimport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';", "import { TokenType } from '../enums/token-type.enum';\nimport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';\nimport { IActiveUser } from '../interfaces/active-user.interface';\n\n@Injectable()\nexport class AccessTokenGuard implements CanActivate {\n  constructor(private readonly jwtService: JwtService) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const request = context.switchToHttp().getRequest();\n", "    try {\n      const accessTokenJwtPayload: IAccessTokenJwtPayload =\n        await this.jwtService.verifyAsync(\n          request.cookies[TokenType.AccessToken] ?? '',\n        );\n\n      const activeUser: IActiveUser = {\n        userId: accessTokenJwtPayload.sub,\n        roles: accessTokenJwtPayload.roles,\n      };\n\n      request[IAM_REQUEST_USER_KEY] = activeUser;\n    } catch {\n      throw new UnauthorizedException();\n    }\n\n    return true;\n  }\n}\n"]}
{"filename": "src/guards/roles.guard.ts", "chunked_list": ["import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { Observable } from 'rxjs';\nimport {\n  IAM_REQUEST_USER_KEY,\n  IAM_ROLES_KEY,\n} from '../constants/iam.constants';\nimport { IActiveUser } from '../interfaces/active-user.interface';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private readonly reflector: Reflector) {}\n\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const roles = this.reflector.getAllAndOverride<string[]>(IAM_ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n", "\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private readonly reflector: Reflector) {}\n\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const roles = this.reflector.getAllAndOverride<string[]>(IAM_ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n", "    if (!roles) {\n      return true;\n    }\n\n    const user: IActiveUser | null = context.switchToHttp().getRequest()[\n      IAM_REQUEST_USER_KEY\n    ];\n\n    return roles.some((role) => user && user.roles.includes(role));\n  }\n}\n"]}
{"filename": "src/guards/none.guard.ts", "chunked_list": ["import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { IAM_REQUEST_USER_KEY } from '../constants/iam.constants';\nimport { TokenType } from '../enums/token-type.enum';\nimport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';\nimport { IActiveUser } from '../interfaces/active-user.interface';\n\n@Injectable()\nexport class NoneGuard implements CanActivate {\n  constructor(private readonly jwtService: JwtService) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const request = context.switchToHttp().getRequest();\n    const accessToken: string | undefined =\n      request.cookies[TokenType.AccessToken];\n", "export class NoneGuard implements CanActivate {\n  constructor(private readonly jwtService: JwtService) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const request = context.switchToHttp().getRequest();\n    const accessToken: string | undefined =\n      request.cookies[TokenType.AccessToken];\n\n    try {\n      const accessTokenJwtPayload: IAccessTokenJwtPayload =\n        await this.jwtService.verifyAsync(accessToken);\n\n      const activeUser: IActiveUser = {\n        userId: accessTokenJwtPayload.sub,\n        roles: accessTokenJwtPayload.roles,\n      };\n\n      request[IAM_REQUEST_USER_KEY] = activeUser;\n    } catch {\n      return true;\n    }\n\n    return true;\n  }\n}\n", "    try {\n      const accessTokenJwtPayload: IAccessTokenJwtPayload =\n        await this.jwtService.verifyAsync(accessToken);\n\n      const activeUser: IActiveUser = {\n        userId: accessTokenJwtPayload.sub,\n        roles: accessTokenJwtPayload.roles,\n      };\n\n      request[IAM_REQUEST_USER_KEY] = activeUser;\n    } catch {\n      return true;\n    }\n\n    return true;\n  }\n}\n"]}
{"filename": "src/guards/auth.guard.ts", "chunked_list": ["import {\n  CanActivate,\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { IAM_AUTH_TYPE_KEY } from '../constants/iam.constants';\nimport { AuthType } from '../enums/auth-type.enum';\nimport { AccessTokenGuard } from './access-token.guard';", "import { AuthType } from '../enums/auth-type.enum';\nimport { AccessTokenGuard } from './access-token.guard';\nimport { NoneGuard } from './none.guard';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  private readonly authTypeGuardMap: Record<\n    AuthType,\n    CanActivate | CanActivate[]\n  > = {\n    [AuthType.AccessToken]: this.accessTokenGuard,\n    [AuthType.None]: this.noneGuard,\n  };\n\n  constructor(\n    private readonly reflector: Reflector,\n    private readonly accessTokenGuard: AccessTokenGuard,\n    private readonly noneGuard: NoneGuard,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const authTypes = this.reflector.getAllAndOverride<AuthType[]>(\n      IAM_AUTH_TYPE_KEY,\n      [context.getHandler(), context.getClass()],\n    ) ?? [AuthType.AccessToken];\n\n    const guards = authTypes.map((type) => this.authTypeGuardMap[type]).flat();\n", "    for (const guard of guards) {\n      if (await Promise.resolve(guard.canActivate(context))) {\n        return true;\n      }\n    }\n\n    throw new UnauthorizedException();\n  }\n}\n"]}
{"filename": "src/hashers/bcrypt.hasher.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\nimport { compare, genSalt, hash } from 'bcrypt';\nimport { IHasher } from '../interfaces/hasher.interface';\n\n@Injectable()\nexport class BcryptHasher implements IHasher {\n  async hash(data: string | Buffer): Promise<string> {\n    const salt = await genSalt();\n\n    return hash(data, salt);\n  }\n\n  async compare(data: string | Buffer, encrypted: string): Promise<boolean> {\n    return compare(data, encrypted);\n  }\n}\n"]}
