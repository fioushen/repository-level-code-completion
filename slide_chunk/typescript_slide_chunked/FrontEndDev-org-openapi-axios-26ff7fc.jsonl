{"filename": "vite.config.ts", "chunked_list": ["import { externalizeDeps } from 'vite-plugin-externalize-deps';\nimport dts from 'vite-plugin-dts';\nimport { defineConfig } from 'vitest/config';\nimport pkg from './package.json';\n\n/**\n * vite config\n * @ref https://vitejs.dev/\n * vitest config\n * @ref https://vitest.dev/", " * vitest config\n * @ref https://vitest.dev/\n */\nexport default defineConfig({\n  plugins: [\n    externalizeDeps(),\n    dts({\n      outputDir: 'dist-types',\n    }),\n  ],", "    }),\n  ],\n  define: {\n    'process.env.PKG_NAME': JSON.stringify(pkg.name),\n    'process.env.PKG_VERSION': JSON.stringify(pkg.version),\n  },\n  build: {\n    minify: false,\n    sourcemap: true,\n    copyPublicDir: false,", "    sourcemap: true,\n    copyPublicDir: false,\n    reportCompressedSize: false,\n    lib: {\n      entry: ['src/index.ts', 'src/helpers.ts'],\n    },\n    rollupOptions: {\n      output: [\n        {\n          format: 'esm',", "        {\n          format: 'esm',\n          dir: 'dist-esm',\n          entryFileNames: '[name].mjs',\n          chunkFileNames: '[name].mjs',\n        },\n        {\n          format: 'cjs',\n          dir: 'dist-cjs',\n          entryFileNames: '[name].cjs',", "          dir: 'dist-cjs',\n          entryFileNames: '[name].cjs',\n          chunkFileNames: '[name].cjs',\n        },\n      ],\n    },\n  },\n  test: {\n    globals: true,\n    env: {", "    globals: true,\n    env: {\n      PKG_NAME: 'pkg-name-for-test',\n      PKG_VERSION: 'pkg-version-for-test',\n    },\n    coverage: {\n      all: true,\n      include: ['src/**/*.ts'],\n      reporter: ['lcov', 'text'],\n    },", "      reporter: ['lcov', 'text'],\n    },\n  },\n});\n"]}
{"filename": "test/helpers.test.ts", "chunked_list": ["import { resolveURL } from '../src/helpers';\n\ntest('resolveBaseURL', () => {\n  expect(resolveURL('/', '/a/b')).toEqual('/a/b');\n  expect(resolveURL('/api/v1', '/a/b')).toEqual('/api/v1/a/b');\n  expect(resolveURL('https//example.com/api/v1', '/a/b')).toEqual('https//example.com/api/v1/a/b');\n  expect(resolveURL('https//example.com/api/v1/', '/a/b')).toEqual('https//example.com/api/v1/a/b');\n  expect(resolveURL('https//example.com/api/v1////', '/////a/b')).toEqual('https//example.com/api/v1/a/b');\n});\n", "});\n"]}
{"filename": "test/helpers.ts", "chunked_list": ["import * as crypto from 'crypto';\nimport fs from 'fs';\nimport * as os from 'os';\nimport { pkgName, pkgVersion } from '../src';\nimport { isString } from '../src/utils/type-is';\nimport path from 'path';\n\nexport function writeFile(name: string, data: string | Record<string, any>) {\n  fs.writeFileSync(path.join(__dirname, 'files', name), isString(data) ? data : JSON.stringify(data), 'utf8');\n}\n\n/**\n * \u521b\u5efa\u4e34\u65f6\u76ee\u5f55\u3010\u5fc5\u5b58\u5728\u3011\n * @returns {string}\n */", "export function createTempDirname() {\n  const d = path.join(os.tmpdir(), pkgName, pkgVersion, crypto.randomUUID() + '.d');\n  fs.mkdirSync(d, { recursive: true });\n  return [\n    d,\n    () => {\n      try {\n        fs.rmSync(d, { force: true });\n      } catch (cause) {\n        // ignore\n      }\n    },\n  ] as const;\n}\n", "      } catch (cause) {\n        // ignore\n      }\n    },\n  ] as const;\n}\n"]}
{"filename": "test/printers/DocumentPrinter.test.ts", "chunked_list": ["import type { TypeDocument } from '../../src/parsers/types';\nimport { DocumentPrinter } from '../../src';\n\nimport petStore3 from '../files/petStore3.types.json';\nimport { writeFile } from '../helpers';\n\ntest('DocumentPrinter', () => {\n  const printer = new DocumentPrinter(petStore3 as TypeDocument);\n  const text = printer.print();\n  writeFile('petStore3.types.txt', text);", "  const text = printer.print();\n  writeFile('petStore3.types.txt', text);\n  expect(text).toMatchInlineSnapshot(`\n    \"import type { OneOf } from 'openapi-axios/helpers';\n    import type { AxiosPromise, AxiosRequestConfig } from 'axios';\n    import {\n      DELETE,\n      GET,\n      HEAD,\n      OPTIONS,", "      HEAD,\n      OPTIONS,\n      PATCH,\n      POST,\n      PUT,\n      resolveURL,\n    } from 'openapi-axios/helpers';\n    import axios from 'axios';\n\n    const request = axios.request;", "\n    const request = axios.request;\n    const BASE_URL = '/api/v3';\n\n    export type Address = {\n      /**\n       * @example Palo Alto\n       */\n      city?: string;\n      /**\n       * @example CA\n       */\n      state?: string;\n      /**\n       * @example 437 Lytton\n       */\n      street?: string;\n      /**\n       * @example 94301\n       */\n      zip?: string;\n    };\n", "    export type ApiResponse = {\n      /**\n       * @format int32\n       */\n      code?: number;\n      message?: string;\n      type?: string;\n    };\n\n    export type Category = {\n      /**\n       * @format int64\n       * @example 1\n       */\n      id?: number;\n      /**\n       * @example Dogs\n       */\n      name?: string;\n    };\n", "    export type Category = {\n      /**\n       * @format int64\n       * @example 1\n       */\n      id?: number;\n      /**\n       * @example Dogs\n       */\n      name?: string;\n    };\n", "    export type Customer = {\n      address?: Array<Address>;\n      /**\n       * @format int64\n       * @example 100000\n       */\n      id?: number;\n      /**\n       * @example fehguy\n       */\n      username?: string;\n    };\n", "    export type Order = {\n      complete?: boolean;\n      /**\n       * @format int64\n       * @example 10\n       */\n      id?: number;\n      /**\n       * @format int64\n       * @example 198772\n       */\n      petId?: number;\n      /**\n       * @format int32\n       * @example 7\n       */\n      quantity?: number;\n      /**\n       * @format date-time\n       */\n      shipDate?: string;\n      /**\n       * @description Order Status\n       * @example approved\n       */\n      status?: 'placed' | 'approved' | 'delivered';\n    };\n", "    export type Pet = {\n      category?: Category;\n      /**\n       * @format int64\n       * @example 10\n       */\n      id?: number;\n      /**\n       * @example doggie\n       */\n      name: string;\n      photoUrls: Array<string>;\n      /**\n       * @description pet status in the store\n       */\n      status?: 'available' | 'pending' | 'sold';\n      tags?: Array<Tag>;\n    };\n", "    export type Tag = {\n      /**\n       * @format int64\n       */\n      id?: number;\n      name?: string;\n    };\n\n    export type User = {\n      /**\n       * @example john@email.com\n       */\n      email?: string;\n      /**\n       * @example John\n       */\n      firstName?: string;\n      /**\n       * @format int64\n       * @example 10\n       */\n      id?: number;\n      /**\n       * @example James\n       */\n      lastName?: string;\n      /**\n       * @example 12345\n       */\n      password?: string;\n      /**\n       * @example 12345\n       */\n      phone?: string;\n      /**\n       * @example theUser\n       */\n      username?: string;\n      /**\n       * @description User Status\n       * @format int32\n       * @example 1\n       */\n      userStatus?: number;\n    };\n", "    export type User = {\n      /**\n       * @example john@email.com\n       */\n      email?: string;\n      /**\n       * @example John\n       */\n      firstName?: string;\n      /**\n       * @format int64\n       * @example 10\n       */\n      id?: number;\n      /**\n       * @example James\n       */\n      lastName?: string;\n      /**\n       * @example 12345\n       */\n      password?: string;\n      /**\n       * @example 12345\n       */\n      phone?: string;\n      /**\n       * @example theUser\n       */\n      username?: string;\n      /**\n       * @description User Status\n       * @format int32\n       * @example 1\n       */\n      userStatus?: number;\n    };\n", "    export type AddPetReqData = Pet;\n    export type AddPetResData = Pet;\n    /**\n     * @title Add a new pet to the store\n     * @description Add a new pet to the store\n     */\n    export async function addPet(\n      data: AddPetReqData,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<AddPetResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet\\`),\n        method: POST,\n        data,\n        ...config,\n      });\n    }\n", "    export type UpdatePetReqData = Pet;\n    export type UpdatePetResData = Pet;\n    /**\n     * @title Update an existing pet\n     * @description Update an existing pet by Id\n     */\n    export async function updatePet(\n      data: UpdatePetReqData,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<UpdatePetResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet\\`),\n        method: PUT,\n        data,\n        ...config,\n      });\n    }\n", "    export type DeletePetReqPath = {\n      /**\n       * @description Pet id to delete\n       * @format int64\n       */\n      petId: number;\n    };\n    /**\n     * @title Deletes a pet\n     * @description\n     */", "    export async function deletePet(\n      path: DeletePetReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}\\`),\n        method: DELETE,\n        ...config,\n      });\n    }\n", "    export type GetPetByIdReqPath = {\n      /**\n       * @description ID of pet to return\n       * @format int64\n       */\n      petId: number;\n    };\n    export type GetPetByIdResData = Pet;\n    /**\n     * @title Find pet by ID\n     * @description Returns a single pet\n     */", "    export async function getPetById(\n      path: GetPetByIdReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<GetPetByIdResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}\\`),\n        method: GET,\n        ...config,\n      });\n    }\n", "    export type UpdatePetWithFormReqPath = {\n      /**\n       * @description ID of pet that needs to be updated\n       * @format int64\n       */\n      petId: number;\n    };\n    export type UpdatePetWithFormReqParams = {\n      /**\n       * @description Name of pet that needs to be updated\n       */\n      name?: string;\n      /**\n       * @description Status of pet that needs to be updated\n       */\n      status?: string;\n    };\n    /**\n     * @title Updates a pet in the store with form data\n     * @description\n     */", "    export async function updatePetWithForm(\n      path: UpdatePetWithFormReqPath,\n      params?: UpdatePetWithFormReqParams,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}\\`),\n        method: POST,\n        params,\n        ...config,\n      });\n    }\n", "    export type UploadFileReqPath = {\n      /**\n       * @description ID of pet to update\n       * @format int64\n       */\n      petId: number;\n    };\n    export type UploadFileReqParams = {\n      /**\n       * @description Additional Metadata\n       */\n      additionalMetadata?: string;\n    };", "    export type UploadFileReqData = Blob;\n    export type UploadFileResData = ApiResponse;\n    /**\n     * @title uploads an image\n     * @description\n     */\n    export async function uploadFile(\n      path: UploadFileReqPath,\n      data: UploadFileReqData,\n      params?: UploadFileReqParams,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<UploadFileResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}/uploadImage\\`),\n        method: POST,\n        params,\n        data,\n        ...config,\n      });\n    }\n", "    export type FindPetsByStatusReqParams = {\n      /**\n       * @description Status values that need to be considered for filter\n       * @default available\n       */\n      status?: 'available' | 'pending' | 'sold';\n    };\n    export type FindPetsByStatusResData = Array<Pet>;\n    /**\n     * @title Finds Pets by status\n     * @description Multiple status values can be provided with comma separated strings\n     */", "    export async function findPetsByStatus(\n      params?: FindPetsByStatusReqParams,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<FindPetsByStatusResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet/findByStatus\\`),\n        method: GET,\n        params,\n        ...config,\n      });\n    }\n", "    export type FindPetsByTagsReqParams = {\n      /**\n       * @description Tags to filter by\n       */\n      tags?: Array<string>;\n    };\n    export type FindPetsByTagsResData = Array<Pet>;\n    /**\n     * @title Finds Pets by tags\n     * @description Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n     */", "    export async function findPetsByTags(\n      params?: FindPetsByTagsReqParams,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<FindPetsByTagsResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/pet/findByTags\\`),\n        method: GET,\n        params,\n        ...config,\n      });\n    }\n", "    export type GetInventoryResData = {\n      /**\n       * @format int32\n       */\n      [key: string]: number;\n    };\n    /**\n     * @title Returns pet inventories by status\n     * @description Returns a map of status codes to quantities\n     */\n    export async function getInventory(\n      config?: AxiosRequestConfig\n    ): AxiosPromise<GetInventoryResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/store/inventory\\`),\n        method: GET,\n        ...config,\n      });\n    }\n", "    export async function getInventory(\n      config?: AxiosRequestConfig\n    ): AxiosPromise<GetInventoryResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/store/inventory\\`),\n        method: GET,\n        ...config,\n      });\n    }\n\n    export type PlaceOrderReqData = Order;", "    export type PlaceOrderReqData = Order;\n    export type PlaceOrderResData = Order;\n    /**\n     * @title Place an order for a pet\n     * @description Place a new order in the store\n     */\n    export async function placeOrder(\n      data: PlaceOrderReqData,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<PlaceOrderResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/store/order\\`),\n        method: POST,\n        data,\n        ...config,\n      });\n    }\n", "    export type DeleteOrderReqPath = {\n      /**\n       * @description ID of the order that needs to be deleted\n       * @format int64\n       */\n      orderId: number;\n    };\n    /**\n     * @title Delete purchase order by ID\n     * @description For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\n     */", "    export async function deleteOrder(\n      path: DeleteOrderReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/store/order/\\${path.orderId}\\`),\n        method: DELETE,\n        ...config,\n      });\n    }\n", "    export type GetOrderByIdReqPath = {\n      /**\n       * @description ID of order that needs to be fetched\n       * @format int64\n       */\n      orderId: number;\n    };\n    export type GetOrderByIdResData = Order;\n    /**\n     * @title Find purchase order by ID\n     * @description For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\n     */", "    export async function getOrderById(\n      path: GetOrderByIdReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<GetOrderByIdResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/store/order/\\${path.orderId}\\`),\n        method: GET,\n        ...config,\n      });\n    }\n", "    export type CreateUserReqData = User;\n    /**\n     * @title Create user\n     * @description This can only be done by the logged in user.\n     */\n    export async function createUser(\n      data: CreateUserReqData,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user\\`),\n        method: POST,\n        data,\n        ...config,\n      });\n    }\n", "    export type DeleteUserReqPath = {\n      /**\n       * @description The name that needs to be deleted\n       */\n      username: string;\n    };\n    /**\n     * @title Delete user\n     * @description This can only be done by the logged in user.\n     */\n    export async function deleteUser(\n      path: DeleteUserReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n        method: DELETE,\n        ...config,\n      });\n    }\n", "    export async function deleteUser(\n      path: DeleteUserReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n        method: DELETE,\n        ...config,\n      });\n    }\n", "    export type GetUserByNameReqPath = {\n      /**\n       * @description The name that needs to be fetched. Use user1 for testing.\n       */\n      username: string;\n    };\n    export type GetUserByNameResData = User;\n    /**\n     * @title Get user by user name\n     * @description\n     */", "    export async function getUserByName(\n      path: GetUserByNameReqPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<GetUserByNameResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n        method: GET,\n        ...config,\n      });\n    }\n", "    export type UpdateUserReqPath = {\n      /**\n       * @description name that need to be deleted\n       */\n      username: string;\n    };\n    export type UpdateUserReqData = User;\n    /**\n     * @title Update user\n     * @description This can only be done by the logged in user.\n     */", "    export async function updateUser(\n      path: UpdateUserReqPath,\n      data: UpdateUserReqData,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n        method: PUT,\n        data,\n        ...config,\n      });\n    }\n", "    export type CreateUsersWithListInputReqData = Array<User>;\n    export type CreateUsersWithListInputResData = User;\n    /**\n     * @title Creates list of users with given input array\n     * @description Creates list of users with given input array\n     */\n    export async function createUsersWithListInput(\n      data?: CreateUsersWithListInputReqData,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<CreateUsersWithListInputResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/createWithList\\`),\n        method: POST,\n        data,\n        ...config,\n      });\n    }\n", "    export type LoginUserReqParams = {\n      /**\n       * @description The user name for login\n       */\n      username?: string;\n      /**\n       * @description The password for login in clear text\n       */\n      password?: string;\n    };\n    export type LoginUserResData = string;\n    /**\n     * @title Logs user into the system\n     * @description\n     */", "    export type LoginUserResData = string;\n    /**\n     * @title Logs user into the system\n     * @description\n     */\n    export async function loginUser(\n      params?: LoginUserReqParams,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<LoginUserResData> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/login\\`),\n        method: GET,\n        params,\n        ...config,\n      });\n    }\n\n    /**\n     * @title Logs out current logged in user session\n     * @description\n     */", "    export async function logoutUser(\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: resolveURL(BASE_URL, \\`/user/logout\\`),\n        method: GET,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n"]}
{"filename": "test/printers/CommentsPrinter.test.ts", "chunked_list": ["import { CommentsPrinter } from '../../src/printers/CommentsPrinter';\n\ntest('CommentsPrinter', () => {\n  const printer = new CommentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [],", "    },\n    components: [],\n    paths: [],\n  });\n\n  expect(printer.printComments({})).toMatchInlineSnapshot('\"\"');\n\n  expect(\n    printer.printComments({\n      deprecated: true,", "    printer.printComments({\n      deprecated: true,\n    })\n  ).toMatchInlineSnapshot(`\n    \"/**\n     * @deprecated\n     */\"\n  `);\n\n  expect(", "\n  expect(\n    printer.printComments({\n      deprecated: true,\n      title: '\u4e00\u4e2a\u6ce8\u91ca\u6807\u9898',\n      description: '\u4e00\u4e2a\u6ce8\u91ca\u63cf\u8ff0\\n\u7b2c 2 \u884c\u63cf\u8ff0\\n\u7b2c 3 \u884c\u63cf\u8ff0',\n      format: 'username',\n      example: 'const a = 1;\\nconst b = 2;',\n      default: '\"\u5f20\u4e09\"',\n    })", "      default: '\"\u5f20\u4e09\"',\n    })\n  ).toMatchInlineSnapshot(`\n    \"/**\n     * @deprecated\n     * @title \u4e00\u4e2a\u6ce8\u91ca\u6807\u9898\n     * @description \u4e00\u4e2a\u6ce8\u91ca\u63cf\u8ff0\n     * \u7b2c 2 \u884c\u63cf\u8ff0\n     * \u7b2c 3 \u884c\u63cf\u8ff0\n     * @format username", "     * \u7b2c 3 \u884c\u63cf\u8ff0\n     * @format username\n     * @default \\\\\"\u5f20\u4e09\\\\\"\n     * @example const a = 1;\n     * const b = 2;\n     */\"\n  `);\n});\n", ""]}
{"filename": "test/printers/PathsPrinter.test.ts", "chunked_list": ["import { PathsPrinter } from '../../src/printers/PathsPrinter';\n\ntest('empty paths', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [],", "    components: [],\n    paths: [],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot('\"\"');\n});\n\ntest('empty req && empty res', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',", "    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        url: '/',\n        method: 'get',\n        name: 'getName',", "        method: 'get',\n        name: 'getName',\n        description: 'ddd',\n        request: {},\n        response: {},\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`\n    \"/**", "  expect(printer.printPaths()).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd\n     */\n    export async function getName(\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: \\`/\\`,\n        method: GET,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('req.path', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        url: '/api/name/{name}/age/{age}',\n        method: 'get',\n        name: 'getName',\n        description: 'ddd',\n        request: {\n          path: {\n            kind: 'origin',\n            name: 'T',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                kind: 'origin',\n                type: 'string',\n                name: 'name',\n                required: true,\n              },\n              {\n                kind: 'origin',\n                type: 'number',\n                name: 'age',\n                required: true,\n              },\n            ],\n          },\n        },\n        response: {},\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type T = { name: string; age: number };\n    /**\n     * @description ddd\n     */\n    export async function getName(\n      path: T,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: \\`/api/name/\\${path.name}/age/\\${path.age}\\`,\n        method: GET,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('req.query', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        url: '/',\n        method: 'get',\n        name: 'getName',\n        description: 'ddd',\n        request: {\n          query: {\n            kind: 'origin',\n            name: 'T',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                kind: 'origin',\n                type: 'string',\n                name: 'name',\n                required: true,\n              },\n              {\n                kind: 'origin',\n                type: 'number',\n                name: 'age',\n                required: true,\n              },\n            ],\n          },\n        },\n        response: {},\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type T = { name: string; age: number };\n    /**\n     * @description ddd\n     */\n    export async function getName(\n      params: T,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: \\`/\\`,\n        method: GET,\n        params,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('req.body', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        url: '/',\n        method: 'get',\n        name: 'getName',\n        description: 'ddd',\n        request: {\n          body: {\n            kind: 'origin',\n            name: 'T',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                kind: 'origin',\n                type: 'string',\n                name: 'name',\n                required: true,\n              },\n              {\n                kind: 'origin',\n                type: 'number',\n                name: 'age',\n                required: true,\n              },\n            ],\n          },\n        },\n        response: {},\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type T = { name: string; age: number };\n    /**\n     * @description ddd\n     */\n    export async function getName(\n      data: T,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<never> {\n      return request({\n        url: \\`/\\`,\n        method: GET,\n        data,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('res.body', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        url: '/',\n        method: 'get',\n        name: 'getName',\n        description: 'ddd',\n        response: {\n          body: {\n            kind: 'origin',\n            name: 'T',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                kind: 'origin',\n                type: 'string',\n                name: 'name',\n                required: true,\n              },\n              {\n                kind: 'origin',\n                type: 'number',\n                name: 'age',\n                required: true,\n              },\n            ],\n          },\n        },\n        request: {},\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type T = { name: string; age: number };\n    /**\n     * @description ddd\n     */\n    export async function getName(config?: AxiosRequestConfig): AxiosPromise<T> {\n      return request({\n        url: \\`/\\`,\n        method: GET,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('req.path + res.body', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        name: 'getPetById',\n        method: 'get',\n        url: '/pet/{petId}',\n        title: 'Find pet by ID',\n        description: 'Returns a single pet',\n        request: {\n          path: {\n            kind: 'origin',\n            name: 'GetPetByIdRequestPath',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                format: 'int64',\n                name: 'petId',\n                type: 'number',\n                required: true,\n                kind: 'origin',\n              },\n            ],\n          },\n        },\n        response: {\n          body: {\n            kind: 'alias',\n            refAble: false,\n            required: false,\n            name: 'GetPetByIdResponseBody',\n            ref: '#/components/schemas/Pet',\n            target: 'Pet',\n            origin: 'Pet',\n            props: [],\n          },\n        },\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type GetPetByIdRequestPath = {\n      /**\n       * @format int64\n       */\n      petId: number;\n    };\n    export type GetPetByIdResponseBody = Pet;\n    /**\n     * @title Find pet by ID\n     * @description Returns a single pet\n     */", "    export async function getPetById(\n      path: GetPetByIdRequestPath,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<GetPetByIdResponseBody> {\n      return request({\n        url: \\`/pet/\\${path.petId}\\`,\n        method: GET,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('req.path + req.query + res.body', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        name: 'uploadFile',\n        method: 'post',\n        url: '/pet/{petId}/uploadImage',\n        title: 'uploads an image',\n        description: '',\n        request: {\n          path: {\n            kind: 'origin',\n            name: 'UploadFileRequestPath',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                format: 'int64',\n                name: 'petId',\n                type: 'number',\n                required: true,\n                kind: 'origin',\n              },\n            ],\n          },\n          query: {\n            kind: 'origin',\n            name: 'UploadFileRequestQuery',\n            type: 'object',\n            required: false,\n            children: [\n              {\n                name: 'additionalMetadata',\n                type: 'string',\n                required: false,\n                kind: 'origin',\n              },\n            ],\n          },\n        },\n        response: {\n          body: {\n            kind: 'alias',\n            refAble: false,\n            required: false,\n            name: 'UploadFileResponseBody',\n            ref: '#/components/schemas/ApiResponse',\n            target: 'ApiResponse',\n            origin: 'ApiResponse',\n            props: [],\n          },\n        },\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type UploadFileRequestPath = {\n      /**\n       * @format int64\n       */\n      petId: number;\n    };\n    export type UploadFileRequestQuery = { additionalMetadata?: string };\n    export type UploadFileResponseBody = ApiResponse;\n    /**\n     * @title uploads an image\n     * @description\n     */", "    export async function uploadFile(\n      path: UploadFileRequestPath,\n      params?: UploadFileRequestQuery,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<UploadFileResponseBody> {\n      return request({\n        url: \\`/pet/\\${path.petId}/uploadImage\\`,\n        method: POST,\n        params,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n\ntest('req.path + req.query + req.body + res.body', () => {\n  const printer = new PathsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    components: [],\n    paths: [\n      {\n        name: 'uploadFile',\n        method: 'post',\n        url: '/pet/{petId}/uploadImage',\n        title: 'uploads an image',\n        description: '',\n        request: {\n          path: {\n            kind: 'origin',\n            name: 'UploadFileRequestPath',\n            type: 'object',\n            required: true,\n            children: [\n              {\n                format: 'int64',\n                name: 'petId',\n                type: 'number',\n                required: true,\n                kind: 'origin',\n              },\n            ],\n          },\n          query: {\n            kind: 'origin',\n            name: 'UploadFileRequestQuery',\n            type: 'object',\n            required: false,\n            children: [\n              {\n                name: 'additionalMetadata',\n                type: 'string',\n                required: false,\n                kind: 'origin',\n              },\n            ],\n          },\n          body: {\n            kind: 'origin',\n            name: 'UploadFileRequestBody',\n            type: 'array',\n            required: true,\n            children: [\n              {\n                name: 'additionalMetadata',\n                type: 'string',\n                required: false,\n                kind: 'origin',\n              },\n              {\n                format: 'int32',\n                name: '[key: string]',\n                type: 'number',\n                required: true,\n                kind: 'origin',\n              },\n            ],\n          },\n        },\n        response: {\n          body: {\n            kind: 'alias',\n            refAble: false,\n            required: false,\n            name: 'UploadFileResponseBody',\n            ref: '#/components/schemas/ApiResponse',\n            target: 'ApiResponse',\n            origin: 'ApiResponse',\n            props: [],\n          },\n        },\n      },\n    ],\n  });\n  expect(printer.printPaths()).toMatchInlineSnapshot(`", "    \"export type UploadFileRequestPath = {\n      /**\n       * @format int64\n       */\n      petId: number;\n    };\n    export type UploadFileRequestQuery = { additionalMetadata?: string };\n    export type UploadFileRequestBody = Array<\n      | string\n      /**\n       * @format int32\n       */\n      | number\n    >;", "    export type UploadFileResponseBody = ApiResponse;\n    /**\n     * @title uploads an image\n     * @description\n     */\n    export async function uploadFile(\n      path: UploadFileRequestPath,\n      data: UploadFileRequestBody,\n      params?: UploadFileRequestQuery,\n      config?: AxiosRequestConfig\n    ): AxiosPromise<UploadFileResponseBody> {\n      return request({\n        url: \\`/pet/\\${path.petId}/uploadImage\\`,\n        method: POST,\n        params,\n        data,\n        ...config,\n      });\n    }\n    \"\n  `);\n});\n"]}
{"filename": "test/printers/ComponentsPrinter.test.ts", "chunked_list": ["import { ComponentsPrinter } from '../../src/printers/ComponentsPrinter';\n\ntest('empty components', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [],", "    },\n    components: [],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toEqual('');\n});\n\ntest('alias', () => {\n  const printer = new ComponentsPrinter({", "test('alias', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'alias',", "      {\n        kind: 'alias',\n        name: 'O',\n        target: 'P',\n        origin: 'Q',\n        props: [],\n        refAble: true,\n        required: true,\n        description: 'd1',\n      },", "        description: 'd1',\n      },\n      {\n        kind: 'alias',\n        name: 'O',\n        target: 'P',\n        origin: 'Q',\n        props: ['q1', 'q2'],\n        refAble: true,\n        required: true,", "        refAble: true,\n        required: true,\n        description: 'd2',\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**", "  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description d1\n     */\n    export type O = Q;\n\n    /**\n     * @description d2\n     */\n    export type O = Q['q1']['q2'];\n    \"\n  `);\n});\n\ntest('origin primitive', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'number',\n        name: 'N1',\n        required: true,\n        description: 'ddd1',\n      },\n      {\n        kind: 'origin',\n        type: 'string',\n        name: 'S1',\n        required: true,\n        description: 'ddd2',\n      },\n      {\n        kind: 'origin',\n        type: 'boolean',\n        name: 'B1',\n        required: true,\n      },\n      {\n        kind: 'origin',\n        type: 'never',\n        name: 'N2',\n        required: true,\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type O = Q['q1']['q2'];\n    \"\n  `);\n});\n\ntest('origin primitive', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'number',\n        name: 'N1',\n        required: true,\n        description: 'ddd1',\n      },\n      {\n        kind: 'origin',\n        type: 'string',\n        name: 'S1',\n        required: true,\n        description: 'ddd2',\n      },\n      {\n        kind: 'origin',\n        type: 'boolean',\n        name: 'B1',\n        required: true,\n      },\n      {\n        kind: 'origin',\n        type: 'never',\n        name: 'N2',\n        required: true,\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type N1 = number;\n\n    /**\n     * @description ddd2\n     */\n    export type S1 = string;\n\n    export type B1 = boolean;\n\n    export type N2 = never;\n    \"\n  `);\n});\n\ntest('origin enum', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'string',\n        name: 'N1',\n        required: true,\n        description: 'ddd1',\n        enum: ['aaa', 'bbb', 'ccc'],\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type N2 = never;\n    \"\n  `);\n});\n\ntest('origin enum', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'string',\n        name: 'N1',\n        required: true,\n        description: 'ddd1',\n        enum: ['aaa', 'bbb', 'ccc'],\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type N1 = 'aaa' | 'bbb' | 'ccc';\n    \"\n  `);\n});\n\ntest('origin object', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'object',\n        name: 'O1',\n        required: true,\n        description: 'ddd1',\n        children: [\n          {\n            kind: 'origin',\n            type: 'string',\n            name: 'sss',\n            required: true,\n            description: 'ddd2',\n          },\n          {\n            kind: 'alias',\n            name: 'ooo',\n            target: 'P',\n            origin: 'Q',\n            props: ['q1', 'q2'],\n            refAble: false,\n            required: false,\n            description: 'ddd3',\n          },\n          {\n            kind: 'origin',\n            type: 'object',\n            name: 'ppp',\n            required: true,\n            children: [\n              {\n                kind: 'origin',\n                type: 'number',\n                name: 'nnn',\n                required: true,\n              },\n              {\n                kind: 'alias',\n                name: 'qqq',\n                target: 'X',\n                origin: 'X',\n                props: [],\n                refAble: false,\n                required: false,\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type O1 = {\n      /**\n       * @description ddd2\n       */\n      sss: string;\n      /**\n       * @description ddd3\n       */\n      ooo?: Q['q1']['q2'];\n      ppp: { nnn: number; qqq?: X };\n    };\n    \"\n  `);\n});\n\ntest('origin object additional', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'object',\n        name: 'O1',\n        required: true,\n        description: 'ddd1',\n        children: [\n          {\n            kind: 'origin',\n            type: 'string',\n            name: 'sss',\n            required: true,\n            description: 'ddd2',\n          },\n          {\n            kind: 'alias',\n            name: 'ooo',\n            target: 'P',\n            origin: 'Q',\n            props: ['q1', 'q2'],\n            refAble: false,\n            required: false,\n            description: 'ddd3',\n          },\n          {\n            kind: 'origin',\n            type: 'object',\n            name: 'ppp',\n            required: true,\n            children: [\n              {\n                kind: 'origin',\n                type: 'number',\n                name: 'nnn',\n                required: true,\n              },\n              {\n                kind: 'alias',\n                name: 'qqq',\n                target: 'X',\n                origin: 'X',\n                props: [],\n                refAble: false,\n                required: false,\n              },\n              {\n                format: 'int32',\n                name: '[key: string]',\n                type: 'number',\n                required: true,\n                kind: 'origin',\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type O1 = {\n      /**\n       * @description ddd2\n       */\n      sss: string;\n      /**\n       * @description ddd3\n       */\n      ooo?: Q['q1']['q2'];\n      ppp: {\n        nnn: number;\n        qqq?: X;\n        /**\n         * @format int32\n         */\n        [key: string]: number;\n      };\n    };\n    \"\n  `);\n});\n\ntest('origin array', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'array',\n        name: 'A',\n        required: true,\n        description: 'ddd1',\n        children: [\n          {\n            kind: 'origin',\n            name: 'A[]',\n            type: 'string',\n            required: false,\n            description: 'ddd2',\n          },\n        ],\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type A = Array</**\n     * @description ddd2\n     */\n    string>;\n    \"\n  `);\n});\n\ntest('origin array additional', () => {\n  const printer = new ComponentsPrinter({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n      baseURL: '/',\n    },\n    components: [\n      {\n        kind: 'origin',\n        type: 'array',\n        name: 'A',\n        required: true,\n        description: 'ddd1',\n        children: [\n          {\n            kind: 'origin',\n            name: 'A[]',\n            type: 'string',\n            required: false,\n            description: 'ddd2',\n          },\n          {\n            kind: 'alias',\n            name: '[key: string]',\n            target: 'T',\n            origin: 'T',\n            props: [],\n            refAble: false,\n            required: false,\n            ref: '#/components/schema/T',\n            description: 'ddd3',\n          },\n        ],\n      },\n    ],\n    paths: [],\n  });\n  const text = printer.printComponents();\n  expect(text).toMatchInlineSnapshot(`\n    \"/**\n     * @description ddd1\n     */", "    export type A = Array<\n      /**\n       * @description ddd2\n       */\n      | string\n      /**\n       * @description ddd3\n       */\n      | T\n    >;\n    \"\n  `);\n});\n"]}
{"filename": "test/utils/string.test.ts", "chunked_list": ["import {\n  buildName,\n  findOrigin,\n  joinSlices,\n  nextUniqueName,\n  type RefInfo,\n  refToType,\n  toTypePath,\n  varString,\n} from '../../src/utils/string';\n\ntest('buildName', () => {\n  expect(buildName('!')).toEqual('unnamed');\n  expect(buildName('??')).toEqual('unnamed');\n  expect(buildName('hello-world')).toEqual('helloWorld');\n  expect(buildName('hello-world123')).toEqual('helloWorld123');\n  expect(buildName('123hello-world123')).toEqual('helloWorld123');\n  expect(buildName('123hello-world123')).toEqual('helloWorld123');\n  expect(buildName('[[[123hello-world123]]]')).toEqual('helloWorld123');\n  expect(buildName('[[[123hello-world123]]]', true)).toEqual('HelloWorld123');\n});\n\ntest('refToType', () => {\n  expect(refToType('#/components/schemas/T')).toEqual<RefInfo>({\n    type: 'T',\n    base: '#/components/schemas/T',\n    props: [],\n  });\n  expect(refToType('#/components/schemas/T/oo')).toEqual<RefInfo>({\n    type: 'T',\n    base: '#/components/schemas/T',\n    props: ['oo'],\n  });\n  expect(refToType('#/components/schemas/T/oo/pp/qq')).toEqual<RefInfo>({\n    type: 'T',\n    base: '#/components/schemas/T',\n    props: ['oo', 'pp', 'qq'],\n  });\n});\n\ntest('findOrigin', () => {\n  // a -> b -> c -> d\n  // x -> y\n  const relation = new Map([\n    ['a', 'b'],\n    ['b', 'c'],\n    ['c', 'd'],\n    ['x', 'y'],\n  ]);\n  expect(findOrigin('a', relation)).toBe('d');\n  expect(findOrigin('x', relation)).toBe('y');\n  expect(findOrigin('y', relation)).toBe('y');\n});\n\ntest('varString', () => {\n  expect(varString('/a/b')).toEqual('/a/b');\n  expect(varString('/a/b/{cc}')).toEqual('/a/b/${cc}');\n  expect(varString('/a/b/{cc}/dd/{ee}')).toEqual('/a/b/${cc}/dd/${ee}');\n  expect(varString('/a/b/{cc}/dd/{ee}', 'path')).toEqual('/a/b/${path.cc}/dd/${path.ee}');\n  expect(varString('/a/b/{cc}/dd/{ee}/ff/{-ff-}', 'path')).toEqual('/a/b/${path.cc}/dd/${path.ee}/ff/${path[\"-ff-\"]}');\n});\n\ntest('toTypePath', () => {\n  expect(toTypePath([])).toEqual('');\n  expect(toTypePath(['a'])).toEqual('[\"a\"]');\n  expect(toTypePath(['a', 'b'])).toEqual('[\"a\"][\"b\"]');\n});\n\ntest('joinSlices', () => {\n  expect(joinSlices(['', undefined, ''])).toEqual('');\n  expect(joinSlices(['1', undefined, '2', ''])).toEqual('1\\n2');\n});\n\ntest('nextUniqueName', () => {\n  const map = new Map<string, number>();\n  expect(nextUniqueName('abc', map)).toBe('abc');\n  expect(nextUniqueName('abc', map)).toBe('abc2');\n  expect(nextUniqueName('abc', map)).toBe('abc3');\n  expect(nextUniqueName('abc2', map)).toBe('abc4');\n});\n"]}
{"filename": "test/utils/type-is.test.ts", "chunked_list": ["import { isVarName } from '../../src/utils/type-is';\n\ntest('isVarName', () => {\n  expect(isVarName('')).toBe(false);\n  expect(isVarName('a')).toBe(true);\n  expect(isVarName('$a')).toBe(true);\n  expect(isVarName('_a')).toBe(true);\n  expect(isVarName('1a')).toBe(false);\n});\n", "});\n"]}
{"filename": "test/generators/generator.test.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport { Generator } from '../../src/generators/Generator';\nimport { createTempDirname } from '../helpers';\n\ntest('Generator', async () => {\n  const [tempDir, clean] = createTempDirname();\n  const generator = new Generator({\n    cwd: tempDir,\n    openAPIs: [", "    cwd: tempDir,\n    openAPIs: [\n      {\n        name: 'petStore3',\n        document: path.join(__dirname, '../files/petStore3.openapi.json'),\n      },\n    ],\n  });\n\n  const fn1 = vi.fn();", "\n  const fn1 = vi.fn();\n  generator.on('start', fn1);\n\n  const fn2 = vi.fn();\n  generator.on('end', fn2);\n\n  const fn3 = vi.fn();\n  generator.on('process', fn3);\n", "  generator.on('process', fn3);\n\n  const fn4 = vi.fn();\n  generator.on('error', fn4);\n\n  await generator.generate();\n\n  console.log(tempDir);\n  expect(fs.existsSync(path.join(tempDir, 'src/apis/petStore3.ts'))).toBe(true);\n", "  expect(fs.existsSync(path.join(tempDir, 'src/apis/petStore3.ts'))).toBe(true);\n\n  expect(fn1).toBeCalledTimes(1);\n  expect(fn2).toBeCalledTimes(1);\n  expect(fn3).toBeCalledTimes(1 /*reading*/ + 1 /*parsing*/ + 1 /*printing*/ + 1 /*writing*/ + 1 /*generated*/);\n  expect(fn4).toBeCalledTimes(0);\n\n  clean();\n});\n", "});\n"]}
{"filename": "test/generators/commands.test.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport { configFileNameOrder, resolveConfig, resolveConfigFile, run } from '../../src/generators/command';\nimport type { OpenAPIV3Document } from '../../src/types/openapi';\nimport { createTempDirname } from '../helpers';\n\ntest('resolveConfigFile', async () => {\n  const [cwd, clean] = createTempDirname();\n\n  expect(resolveConfigFile(cwd)).toBeUndefined();", "\n  expect(resolveConfigFile(cwd)).toBeUndefined();\n\n  [...configFileNameOrder].reverse().forEach((name, index) => {\n    const file1 = path.join(cwd, name);\n    const file2 = path.join(cwd, configFileNameOrder[configFileNameOrder.length - 1 - index]);\n    fs.writeFileSync(file1, '', 'utf8');\n    expect(resolveConfigFile(cwd)).toBe(file2);\n  });\n", "  });\n\n  clean();\n});\n\ntest('resolveConfig', async () => {\n  const [cwd, clean] = createTempDirname();\n\n  expect(() => resolveConfig(cwd)).toThrow('\u914d\u7f6e\u6587\u4ef6\u672a\u627e\u5230');\n", "  expect(() => resolveConfig(cwd)).toThrow('\u914d\u7f6e\u6587\u4ef6\u672a\u627e\u5230');\n\n  const file = path.join(cwd, configFileNameOrder[0]);\n  fs.writeFileSync(file, '', 'utf8');\n  expect(() => resolveConfig(cwd)).toThrow('#/openAPIs - Required');\n\n  fs.writeFileSync(\n    file,\n    `module.exports = {\n    openAPIs: []", "    `module.exports = {\n    openAPIs: []\n  };`,\n    'utf8'\n  );\n  expect(() => resolveConfig(cwd)).toThrow('#/openAPIs - Array must contain at least 1 element(s)');\n\n  fs.writeFileSync(\n    file,\n    `module.exports = {", "    file,\n    `module.exports = {\n    openAPIs: [{name: \"test\"}]\n  };`,\n    'utf8'\n  );\n  expect(() => resolveConfig(cwd)).toThrow('#/openAPIs/0/document - Invalid input');\n\n  fs.writeFileSync(\n    file,", "  fs.writeFileSync(\n    file,\n    `module.exports = {\n    openAPIs: [{name: \"test\", \"document\": \"test.openapi.json\"}]\n  };`,\n    'utf8'\n  );\n  expect(() => resolveConfig(cwd)).not.toThrow();\n\n  clean();", "\n  clean();\n});\n\ntest('run', async () => {\n  const [cwd, clean] = createTempDirname();\n  const file = path.join(cwd, configFileNameOrder[0]);\n\n  fs.writeFileSync(\n    path.join(cwd, 'test.openapi.json'),", "  fs.writeFileSync(\n    path.join(cwd, 'test.openapi.json'),\n    JSON.stringify({\n      info: {\n        title: 'test',\n        version: '1.0.0',\n      },\n      openapi: '3.0.0',\n      paths: {},\n    } as OpenAPIV3Document)", "      paths: {},\n    } as OpenAPIV3Document)\n  );\n  fs.writeFileSync(\n    file,\n    `module.exports = {\n    openAPIs: [{name: \"test\", \"document\": \"test.openapi.json\"}]\n  };`,\n    'utf8'\n  );", "    'utf8'\n  );\n\n  await run(cwd);\n  expect(fs.existsSync(path.join(cwd, 'src/apis/test.ts'))).toBe(true);\n\n  clean();\n});\n", ""]}
{"filename": "test/generators/Logger.test.ts", "chunked_list": ["import { Logger } from '../../src/generators/Logger';\n\ntest('Logger', async () => {\n  const logger = new Logger();\n\n  logger.pipeConfigError(new Error('test error'));\n\n  logger.pipeStartEvent({\n    count: 99,\n  });", "    count: 99,\n  });\n\n  logger.pipeProcessEvent({\n    index: 5,\n    count: 99,\n    stage: 'generated',\n    filePath: '/a/b/c/d/e/f',\n    options: {\n      cwd: '/a/b/c',", "    options: {\n      cwd: '/a/b/c',\n      dest: '',\n      name: 'test',\n      document: {\n        info: {\n          title: 'test',\n          version: '1.0.0',\n        },\n        openapi: '3.0.0',", "        },\n        openapi: '3.0.0',\n        paths: {},\n      },\n    },\n  });\n\n  logger.pipeEndEvent({\n    count: 99,\n  });", "    count: 99,\n  });\n\n  logger.pipeErrorEvent(new Error('test error'), {\n    count: 99,\n  });\n\n  expect(logger).toBeInstanceOf(Logger);\n});\n", "});\n"]}
{"filename": "test/generators/Reader.test.ts", "chunked_list": ["import path from 'path';\nimport { Reader } from '../../src/generators/Reader';\n\ntest('read local', async () => {\n  const reader = new Reader();\n  reader.cwd = path.resolve(__dirname, '../files');\n  const document = await reader.read('petStore3.openapi.json');\n  expect(document.openapi).toBeTypeOf('string');\n});\n", "});\n\ntest('read remote', async () => {\n  const reader = new Reader();\n  const document = await reader.read('https://gw.alipayobjects.com/os/antfincdn/LyDMjDyIhK/1611471979478-opa.json');\n  expect(document.openapi).toBeTypeOf('string');\n});\n\ntest('read object', async () => {\n  const reader = new Reader();", "test('read object', async () => {\n  const reader = new Reader();\n  const document = await reader.read({\n    info: {\n      title: 'test',\n      version: '1',\n    },\n    openapi: '3.0.0',\n    paths: {},\n  });", "    paths: {},\n  });\n  expect(document.openapi).toBeTypeOf('string');\n});\n"]}
{"filename": "test/parsers/PathsParser.test.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\nimport { PathsParser } from '../../src/parsers/PathsParser';\nimport type { TypeOperations } from '../../src/parsers/types';\nimport HttpMethods = OpenAPIV3.HttpMethods;\n\ntest('empty paths keys', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',", "      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([]);\n});", "  expect(t).toEqual<TypeOperations>([]);\n});\n\ntest('empty path item keys', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',", "    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {},\n    },\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([]);\n});", "  expect(t).toEqual<TypeOperations>([]);\n});\n\ntest('empty path item method responses keys', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',", "    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {\n        get: {\n          responses: {},\n        },\n      },\n    },\n  });", "    },\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'getPet',\n      method: OpenAPIV3.HttpMethods.GET,\n      url: '/pet',\n      request: {},", "      url: '/pet',\n      request: {},\n      response: {},\n    },\n  ]);\n});\n\ntest('empty path item method responses keys + specify operationId', async () => {\n  const parser = new PathsParser({\n    info: {", "  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {\n        get: {\n          operationId: 'findPet',", "        get: {\n          operationId: 'findPet',\n          responses: {},\n        },\n      },\n    },\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([", "  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'findPet',\n      method: OpenAPIV3.HttpMethods.GET,\n      url: '/pet',\n      request: {},\n      response: {},\n    },\n  ]);", "    },\n  ]);\n});\n\ntest('custom name formatter', async () => {\n  const parser = new PathsParser(\n    {\n      info: {\n        title: 'test',\n        version: '1.0.0',", "        title: 'test',\n        version: '1.0.0',\n      },\n      openapi: '3.0.0',\n      paths: {\n        '/pet': {\n          get: {\n            operationId: 'findPet',\n            responses: {},\n          },", "            responses: {},\n          },\n        },\n        '/cat': {\n          get: {\n            responses: {},\n          },\n        },\n      },\n    },", "      },\n    },\n    {\n      nameFormatter: ({ name /*, method, url, operationId*/ }) => {\n        return `custom_${name}`;\n      },\n    }\n  );\n\n  const t = parser.parsePaths();", "\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: `custom_getCat`,\n      method: OpenAPIV3.HttpMethods.GET,\n      url: '/cat',\n      request: {},\n      response: {},\n    },", "      response: {},\n    },\n    {\n      name: `custom_findPet`,\n      method: OpenAPIV3.HttpMethods.GET,\n      url: '/pet',\n      request: {},\n      response: {},\n    },\n  ]);", "    },\n  ]);\n});\n\ntest('operationId is reserved', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },", "      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {\n        get: {\n          operationId: 'export',\n          responses: {},\n        },\n      },", "        },\n      },\n    },\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'export2',\n      method: OpenAPIV3.HttpMethods.GET,", "      name: 'export2',\n      method: OpenAPIV3.HttpMethods.GET,\n      url: '/pet',\n      request: {},\n      response: {},\n    },\n  ]);\n});\n\ntest('resp ref', async () => {", "\ntest('resp ref', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {", "    paths: {\n      '/pet': {\n        get: {\n          operationId: 'findPet',\n          responses: {\n            200: {\n              description: '',\n              content: {\n                'application/json': {\n                  schema: {", "                'application/json': {\n                  schema: {\n                    $ref: '#/components/schemas/T',\n                  },\n                },\n              },\n            },\n          },\n        },\n      },", "        },\n      },\n    },\n    components: {\n      schemas: {\n        T: {\n          type: 'string',\n        },\n      },\n    },", "      },\n    },\n  });\n\n  parser.parseComponents();\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'findPet',\n      url: '/pet',", "      name: 'findPet',\n      url: '/pet',\n      method: HttpMethods.GET,\n      request: {},\n      response: {\n        body: {\n          kind: 'alias',\n          refAble: false,\n          required: true,\n          name: 'FindPetResData',", "          required: true,\n          name: 'FindPetResData',\n          target: 'T',\n          origin: 'T',\n          props: [],\n          ref: '#/components/schemas/T',\n        },\n      },\n    },\n  ]);", "    },\n  ]);\n});\n\ntest('resp type', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },", "      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {\n        get: {\n          operationId: 'findPet',\n          responses: {\n            200: {\n              description: '',", "            200: {\n              description: '',\n              content: {\n                'application/json': {\n                  schema: {\n                    type: 'string',\n                  },\n                },\n              },\n            },", "              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([", "  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'findPet',\n      method: OpenAPIV3.HttpMethods.GET,\n      url: '/pet',\n      request: {},\n      response: {\n        body: {\n          kind: 'origin',", "        body: {\n          kind: 'origin',\n          name: 'FindPetResData',\n          required: false,\n          type: 'string',\n        },\n      },\n    },\n  ]);\n});", "  ]);\n});\n\ntest('req body', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',", "    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {\n        get: {\n          operationId: 'findPet',\n          requestBody: {\n            content: {\n              'application/json': {\n                schema: {", "              'application/json': {\n                schema: {\n                  type: 'object',\n                  properties: {\n                    p: {\n                      type: 'string',\n                    },\n                  },\n                },\n              },", "                },\n              },\n            },\n          },\n          responses: {},\n        },\n      },\n    },\n  });\n", "  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'findPet',\n      method: HttpMethods.GET,\n      url: '/pet',\n      request: {\n        body: {", "      request: {\n        body: {\n          kind: 'origin',\n          name: 'FindPetReqData',\n          type: 'object',\n          required: false,\n          children: [\n            {\n              kind: 'origin',\n              name: 'p',", "              kind: 'origin',\n              name: 'p',\n              type: 'string',\n              required: false,\n            },\n          ],\n        },\n      },\n      response: {},\n    },", "      response: {},\n    },\n  ]);\n});\n\ntest('req file', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',", "      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet': {\n        get: {\n          operationId: 'findPet',\n          requestBody: {\n            content: {", "          requestBody: {\n            content: {\n              'application/octet-stream': {\n                schema: {\n                  type: 'string',\n                  format: 'binary',\n                },\n              },\n            },\n          },", "            },\n          },\n          responses: {},\n        },\n      },\n    },\n  });\n\n  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([", "  const t = parser.parsePaths();\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'findPet',\n      method: HttpMethods.GET,\n      url: '/pet',\n      request: {\n        body: {\n          kind: 'alias',\n          name: 'FindPetReqData',", "          kind: 'alias',\n          name: 'FindPetReqData',\n          origin: 'Blob',\n          props: [],\n          refAble: false,\n          required: true,\n          target: 'Blob',\n        },\n      },\n      response: {},", "      },\n      response: {},\n    },\n  ]);\n});\n\ntest('req query + path', async () => {\n  const parser = new PathsParser({\n    info: {\n      title: 'test',", "    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {\n      '/pet/{name}': {\n        get: {\n          operationId: 'findPet',\n          parameters: [", "          operationId: 'findPet',\n          parameters: [\n            {\n              name: 'name',\n              in: 'path',\n              required: true,\n              schema: {\n                $ref: '#/components/schemas/O/p',\n              },\n            },", "              },\n            },\n            {\n              name: 'status',\n              in: 'query',\n              description: 'Status values that need to be considered for filter',\n              required: false,\n              explode: true,\n              schema: {\n                type: 'string',", "              schema: {\n                type: 'string',\n                default: 'available',\n                enum: ['available', 'pending', 'sold'],\n              },\n            },\n          ],\n          responses: {},\n        },\n      },", "        },\n      },\n    },\n    components: {\n      schemas: {\n        O: {\n          type: 'object',\n          properties: {\n            P: {\n              type: 'string',", "            P: {\n              type: 'string',\n            },\n          },\n        },\n      },\n    },\n  });\n\n  parser.parseComponents();", "\n  parser.parseComponents();\n  const t = parser.parsePaths();\n  // console.log(JSON.stringify(t));\n  expect(t).toEqual<TypeOperations>([\n    {\n      name: 'findPet',\n      method: 'get',\n      url: '/pet/{name}',\n      request: {", "      url: '/pet/{name}',\n      request: {\n        path: {\n          kind: 'origin',\n          name: 'FindPetReqPath',\n          type: 'object',\n          required: true,\n          children: [\n            {\n              kind: 'alias',", "            {\n              kind: 'alias',\n              refAble: false,\n              required: true,\n              name: 'name',\n              ref: '#/components/schemas/O/p',\n              target: 'O',\n              origin: 'O',\n              props: ['p'],\n            },", "              props: ['p'],\n            },\n          ],\n        },\n        query: {\n          kind: 'origin',\n          name: 'FindPetReqParams',\n          type: 'object',\n          required: false,\n          children: [", "          required: false,\n          children: [\n            {\n              default: 'available',\n              description: 'Status values that need to be considered for filter',\n              enum: ['available', 'pending', 'sold'],\n              name: 'status',\n              type: 'string',\n              required: false,\n              kind: 'origin',", "              required: false,\n              kind: 'origin',\n            },\n          ],\n        },\n      },\n      response: {},\n    },\n  ]);\n});", "  ]);\n});\n"]}
{"filename": "test/parsers/DocumentParser.test.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\nimport { doc } from 'prettier';\nimport { DocumentParser } from '../../src/parsers/DocumentParser';\nimport type { TypeDocument } from '../../src/parsers/types';\nimport document from '../files/petStore3.openapi.json';\nimport { writeFile } from '../helpers';\n\ntest('DocumentParser', () => {\n  const parser = new DocumentParser(document as unknown as OpenAPIV3.Document);\n  const types = parser.parse();", "  const parser = new DocumentParser(document as unknown as OpenAPIV3.Document);\n  const types = parser.parse();\n  writeFile('petStore3.types.json', types);\n  expect(types).toMatchInlineSnapshot(`\n    {\n      \"components\": [\n        {\n          \"children\": [\n            {\n              \"default\": undefined,", "            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"Palo Alto\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"city\",\n              \"required\": false,", "              \"name\": \"city\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,", "              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"CA\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"state\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },", "              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"437 Lytton\",\n              \"format\": undefined,\n              \"kind\": \"origin\",", "              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"street\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,", "              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"94301\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"zip\",\n              \"required\": false,\n              \"title\": undefined,", "              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,", "          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"Address\",\n          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },\n        {", "        },\n        {\n          \"children\": [\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": \"int32\",", "              \"example\": undefined,\n              \"format\": \"int32\",\n              \"kind\": \"origin\",\n              \"name\": \"code\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,", "            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"message\",\n              \"required\": false,", "              \"name\": \"message\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,", "              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"type\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },", "              \"type\": \"string\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",", "          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"ApiResponse\",\n          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },\n        {\n          \"children\": [\n            {", "          \"children\": [\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 1,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"id\",", "              \"kind\": \"origin\",\n              \"name\": \"id\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,", "              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"Dogs\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"name\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",", "              \"title\": undefined,\n              \"type\": \"string\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,", "          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"Category\",\n          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },\n        {\n          \"children\": [", "        {\n          \"children\": [\n            {\n              \"children\": [\n                {\n                  \"kind\": \"alias\",\n                  \"name\": \"address[]\",\n                  \"origin\": \"Address\",\n                  \"props\": [],\n                  \"ref\": \"#/components/schemas/Address\",", "                  \"props\": [],\n                  \"ref\": \"#/components/schemas/Address\",\n                  \"refAble\": false,\n                  \"required\": true,\n                  \"target\": \"Address\",\n                },\n              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,", "              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"address\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"array\",", "              \"title\": undefined,\n              \"type\": \"array\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 100000,\n              \"format\": \"int64\",", "              \"example\": 100000,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"id\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,", "            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"fehguy\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"username\",\n              \"required\": false,", "              \"name\": \"username\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,", "          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"Customer\",\n          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },", "          \"type\": \"object\",\n        },\n        {\n          \"children\": [\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,", "              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"complete\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"boolean\",\n            },\n            {", "            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 10,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"id\",", "              \"kind\": \"origin\",\n              \"name\": \"id\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,", "              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 198772,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"petId\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",", "              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 7,\n              \"format\": \"int32\",", "              \"example\": 7,\n              \"format\": \"int32\",\n              \"kind\": \"origin\",\n              \"name\": \"quantity\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,", "            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": \"date-time\",\n              \"kind\": \"origin\",\n              \"name\": \"shipDate\",\n              \"required\": false,", "              \"name\": \"shipDate\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": \"Order Status\",\n              \"enum\": [", "              \"description\": \"Order Status\",\n              \"enum\": [\n                \"placed\",\n                \"approved\",\n                \"delivered\",\n              ],\n              \"example\": \"approved\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"status\",", "              \"kind\": \"origin\",\n              \"name\": \"status\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,", "          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"Order\",\n          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",", "          \"title\": undefined,\n          \"type\": \"object\",\n        },\n        {\n          \"children\": [\n            {\n              \"kind\": \"alias\",\n              \"name\": \"category\",\n              \"origin\": \"Category\",\n              \"props\": [],", "              \"origin\": \"Category\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Category\",\n              \"refAble\": false,\n              \"required\": false,\n              \"target\": \"Category\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,", "              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 10,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"id\",\n              \"required\": false,\n              \"title\": undefined,", "              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"doggie\",", "              \"enum\": undefined,\n              \"example\": \"doggie\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"name\",\n              \"required\": true,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {", "            },\n            {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": undefined,\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,", "                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"photoUrls[]\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],\n              \"default\": undefined,", "              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"photoUrls\",\n              \"required\": true,", "              \"name\": \"photoUrls\",\n              \"required\": true,\n              \"title\": undefined,\n              \"type\": \"array\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": \"pet status in the store\",\n              \"enum\": [", "              \"description\": \"pet status in the store\",\n              \"enum\": [\n                \"available\",\n                \"pending\",\n                \"sold\",\n              ],\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"status\",", "              \"kind\": \"origin\",\n              \"name\": \"status\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"children\": [\n                {\n                  \"kind\": \"alias\",", "                {\n                  \"kind\": \"alias\",\n                  \"name\": \"tags[]\",\n                  \"origin\": \"Tag\",\n                  \"props\": [],\n                  \"ref\": \"#/components/schemas/Tag\",\n                  \"refAble\": false,\n                  \"required\": true,\n                  \"target\": \"Tag\",\n                },", "                  \"target\": \"Tag\",\n                },\n              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",", "              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"tags\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"array\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,", "          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"Pet\",\n          \"required\": false,\n          \"title\": undefined,", "          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },\n        {\n          \"children\": [\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,", "              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"id\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",", "              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,", "              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"name\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n          ],\n          \"default\": undefined,", "          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"Tag\",\n          \"required\": false,", "          \"name\": \"Tag\",\n          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },\n        {\n          \"children\": [\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,", "              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"john@email.com\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"email\",\n              \"required\": false,\n              \"title\": undefined,", "              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"John\",", "              \"enum\": undefined,\n              \"example\": \"John\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"firstName\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {", "            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": 10,\n              \"format\": \"int64\",\n              \"kind\": \"origin\",\n              \"name\": \"id\",", "              \"kind\": \"origin\",\n              \"name\": \"id\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,", "              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"James\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"lastName\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",", "              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"12345\",\n              \"format\": undefined,", "              \"example\": \"12345\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"password\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,", "            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"12345\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"phone\",\n              \"required\": false,", "              \"name\": \"phone\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,", "              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": \"theUser\",\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"username\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },", "              \"type\": \"string\",\n            },\n            {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": \"User Status\",\n              \"enum\": undefined,\n              \"example\": 1,\n              \"format\": \"int32\",\n              \"kind\": \"origin\",", "              \"format\": \"int32\",\n              \"kind\": \"origin\",\n              \"name\": \"userStatus\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"number\",\n            },\n          ],\n          \"default\": undefined,\n          \"deprecated\": undefined,", "          \"default\": undefined,\n          \"deprecated\": undefined,\n          \"description\": undefined,\n          \"enum\": undefined,\n          \"example\": undefined,\n          \"format\": undefined,\n          \"kind\": \"origin\",\n          \"name\": \"User\",\n          \"required\": false,\n          \"title\": undefined,", "          \"required\": false,\n          \"title\": undefined,\n          \"type\": \"object\",\n        },\n      ],\n      \"info\": {\n        \"baseURL\": \"/api/v3\",\n        \"description\": \"This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\n    Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\n    You can now help us improve the API whether it's by making changes to the definition itself or to the code.", "    Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\n    You can now help us improve the API whether it's by making changes to the definition itself or to the code.\n    That way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\n    Some useful links:\n    - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n    - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\",\n        \"title\": \"Swagger Petstore - OpenAPI 3.0\",\n        \"version\": \"1.0.17\",\n      },", "        \"version\": \"1.0.17\",\n      },\n      \"paths\": [\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Add a new pet to the store\",\n          \"method\": \"post\",\n          \"name\": \"addPet\",\n          \"request\": {\n            \"body\": {", "          \"request\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"AddPetReqData\",\n              \"origin\": \"Pet\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Pet\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Pet\",", "              \"required\": true,\n              \"target\": \"Pet\",\n            },\n            \"path\": undefined,\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"AddPetResData\",", "              \"kind\": \"alias\",\n              \"name\": \"AddPetResData\",\n              \"origin\": \"Pet\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Pet\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Pet\",\n            },\n          },", "            },\n          },\n          \"title\": \"Add a new pet to the store\",\n          \"url\": \"/pet\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Update an existing pet by Id\",\n          \"method\": \"put\",\n          \"name\": \"updatePet\",", "          \"method\": \"put\",\n          \"name\": \"updatePet\",\n          \"request\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"UpdatePetReqData\",\n              \"origin\": \"Pet\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Pet\",\n              \"refAble\": false,", "              \"ref\": \"#/components/schemas/Pet\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Pet\",\n            },\n            \"path\": undefined,\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {", "          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"UpdatePetResData\",\n              \"origin\": \"Pet\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Pet\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Pet\",", "              \"required\": true,\n              \"target\": \"Pet\",\n            },\n          },\n          \"title\": \"Update an existing pet\",\n          \"url\": \"/pet\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"\",", "          \"deprecated\": undefined,\n          \"description\": \"\",\n          \"method\": \"delete\",\n          \"name\": \"deletePet\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,", "                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"Pet id to delete\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int64\",\n                  \"kind\": \"origin\",\n                  \"name\": \"petId\",\n                  \"required\": true,", "                  \"name\": \"petId\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"DeletePetReqPath\",\n              \"required\": true,\n              \"type\": \"object\",", "              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": undefined,\n          },\n          \"title\": \"Deletes a pet\",\n          \"url\": \"/pet/{petId}\",", "          \"title\": \"Deletes a pet\",\n          \"url\": \"/pet/{petId}\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Returns a single pet\",\n          \"method\": \"get\",\n          \"name\": \"getPetById\",\n          \"request\": {\n            \"body\": undefined,", "          \"request\": {\n            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"ID of pet to return\",\n                  \"enum\": undefined,\n                  \"example\": undefined,", "                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int64\",\n                  \"kind\": \"origin\",\n                  \"name\": \"petId\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],", "                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"GetPetByIdReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },\n          \"response\": {", "          },\n          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"GetPetByIdResData\",\n              \"origin\": \"Pet\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Pet\",\n              \"refAble\": false,\n              \"required\": true,", "              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Pet\",\n            },\n          },\n          \"title\": \"Find pet by ID\",\n          \"url\": \"/pet/{petId}\",\n        },\n        {\n          \"deprecated\": undefined,", "        {\n          \"deprecated\": undefined,\n          \"description\": \"\",\n          \"method\": \"post\",\n          \"name\": \"updatePetWithForm\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {", "              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"ID of pet that needs to be updated\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int64\",\n                  \"kind\": \"origin\",\n                  \"name\": \"petId\",", "                  \"kind\": \"origin\",\n                  \"name\": \"petId\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"UpdatePetWithFormReqPath\",\n              \"required\": true,", "              \"name\": \"UpdatePetWithFormReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"Name of pet that needs to be updated\",", "                  \"deprecated\": undefined,\n                  \"description\": \"Name of pet that needs to be updated\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"name\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",", "                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"Status of pet that needs to be updated\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,", "                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"status\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],\n              \"kind\": \"origin\",", "              ],\n              \"kind\": \"origin\",\n              \"name\": \"UpdatePetWithFormReqParams\",\n              \"required\": false,\n              \"type\": \"object\",\n            },\n          },\n          \"response\": {\n            \"body\": undefined,\n          },", "            \"body\": undefined,\n          },\n          \"title\": \"Updates a pet in the store with form data\",\n          \"url\": \"/pet/{petId}\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"\",\n          \"method\": \"post\",\n          \"name\": \"uploadFile\",", "          \"method\": \"post\",\n          \"name\": \"uploadFile\",\n          \"request\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"UploadFileReqData\",\n              \"origin\": \"Blob\",\n              \"props\": [],\n              \"refAble\": false,\n              \"required\": true,", "              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Blob\",\n            },\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"ID of pet to update\",", "                  \"deprecated\": undefined,\n                  \"description\": \"ID of pet to update\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int64\",\n                  \"kind\": \"origin\",\n                  \"name\": \"petId\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",", "                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"UploadFileReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": {", "            },\n            \"query\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"Additional Metadata\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,", "                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"additionalMetadata\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],\n              \"kind\": \"origin\",", "              ],\n              \"kind\": \"origin\",\n              \"name\": \"UploadFileReqParams\",\n              \"required\": false,\n              \"type\": \"object\",\n            },\n          },\n          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",", "            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"UploadFileResData\",\n              \"origin\": \"ApiResponse\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/ApiResponse\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"ApiResponse\",\n            },", "              \"target\": \"ApiResponse\",\n            },\n          },\n          \"title\": \"uploads an image\",\n          \"url\": \"/pet/{petId}/uploadImage\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Multiple status values can be provided with comma separated strings\",\n          \"method\": \"get\",", "          \"description\": \"Multiple status values can be provided with comma separated strings\",\n          \"method\": \"get\",\n          \"name\": \"findPetsByStatus\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": undefined,\n            \"query\": {\n              \"children\": [\n                {\n                  \"default\": \"available\",", "                {\n                  \"default\": \"available\",\n                  \"deprecated\": undefined,\n                  \"description\": \"Status values that need to be considered for filter\",\n                  \"enum\": [\n                    \"available\",\n                    \"pending\",\n                    \"sold\",\n                  ],\n                  \"example\": undefined,", "                  ],\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"status\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],", "                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"FindPetsByStatusReqParams\",\n              \"required\": false,\n              \"type\": \"object\",\n            },\n          },\n          \"response\": {\n            \"body\": {", "          \"response\": {\n            \"body\": {\n              \"children\": [\n                {\n                  \"kind\": \"alias\",\n                  \"name\": \"FindPetsByStatusResData[]\",\n                  \"origin\": \"Pet\",\n                  \"props\": [],\n                  \"ref\": \"#/components/schemas/Pet\",\n                  \"refAble\": false,", "                  \"ref\": \"#/components/schemas/Pet\",\n                  \"refAble\": false,\n                  \"required\": true,\n                  \"target\": \"Pet\",\n                },\n              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,", "              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"FindPetsByStatusResData\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"array\",\n            },", "              \"type\": \"array\",\n            },\n          },\n          \"title\": \"Finds Pets by status\",\n          \"url\": \"/pet/findByStatus\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n          \"method\": \"get\",", "          \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n          \"method\": \"get\",\n          \"name\": \"findPetsByTags\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": undefined,\n            \"query\": {\n              \"children\": [\n                {\n                  \"children\": [", "                {\n                  \"children\": [\n                    {\n                      \"default\": undefined,\n                      \"deprecated\": undefined,\n                      \"description\": undefined,\n                      \"enum\": undefined,\n                      \"example\": undefined,\n                      \"format\": undefined,\n                      \"kind\": \"origin\",", "                      \"format\": undefined,\n                      \"kind\": \"origin\",\n                      \"name\": \"tags[]\",\n                      \"required\": false,\n                      \"title\": undefined,\n                      \"type\": \"string\",\n                    },\n                  ],\n                  \"default\": undefined,\n                  \"deprecated\": undefined,", "                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"Tags to filter by\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"tags\",\n                  \"required\": false,\n                  \"title\": undefined,", "                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"array\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"FindPetsByTagsReqParams\",\n              \"required\": false,\n              \"type\": \"object\",\n            },", "              \"type\": \"object\",\n            },\n          },\n          \"response\": {\n            \"body\": {\n              \"children\": [\n                {\n                  \"kind\": \"alias\",\n                  \"name\": \"FindPetsByTagsResData[]\",\n                  \"origin\": \"Pet\",", "                  \"name\": \"FindPetsByTagsResData[]\",\n                  \"origin\": \"Pet\",\n                  \"props\": [],\n                  \"ref\": \"#/components/schemas/Pet\",\n                  \"refAble\": false,\n                  \"required\": true,\n                  \"target\": \"Pet\",\n                },\n              ],\n              \"default\": undefined,", "              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"FindPetsByTagsResData\",\n              \"required\": false,", "              \"name\": \"FindPetsByTagsResData\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"array\",\n            },\n          },\n          \"title\": \"Finds Pets by tags\",\n          \"url\": \"/pet/findByTags\",\n        },\n        {", "        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Returns a map of status codes to quantities\",\n          \"method\": \"get\",\n          \"name\": \"getInventory\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": undefined,\n            \"query\": undefined,", "            \"path\": undefined,\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": undefined,", "                  \"deprecated\": undefined,\n                  \"description\": undefined,\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int32\",\n                  \"kind\": \"origin\",\n                  \"name\": \"[key: string]\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",", "                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,", "              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"GetInventoryResData\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"object\",\n            },\n          },\n          \"title\": \"Returns pet inventories by status\",", "          },\n          \"title\": \"Returns pet inventories by status\",\n          \"url\": \"/store/inventory\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Place a new order in the store\",\n          \"method\": \"post\",\n          \"name\": \"placeOrder\",\n          \"request\": {", "          \"name\": \"placeOrder\",\n          \"request\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"PlaceOrderReqData\",\n              \"origin\": \"Order\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Order\",\n              \"refAble\": false,\n              \"required\": true,", "              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Order\",\n            },\n            \"path\": undefined,\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",", "            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"PlaceOrderResData\",\n              \"origin\": \"Order\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Order\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Order\",\n            },", "              \"target\": \"Order\",\n            },\n          },\n          \"title\": \"Place an order for a pet\",\n          \"url\": \"/store/order\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\",\n          \"method\": \"delete\",", "          \"description\": \"For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\",\n          \"method\": \"delete\",\n          \"name\": \"deleteOrder\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,", "                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"ID of the order that needs to be deleted\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int64\",\n                  \"kind\": \"origin\",\n                  \"name\": \"orderId\",\n                  \"required\": true,\n                  \"title\": undefined,", "                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"DeleteOrderReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },", "              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": undefined,\n          },\n          \"title\": \"Delete purchase order by ID\",\n          \"url\": \"/store/order/{orderId}\",\n        },", "          \"url\": \"/store/order/{orderId}\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\",\n          \"method\": \"get\",\n          \"name\": \"getOrderById\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": {", "            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"ID of order that needs to be fetched\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": \"int64\",", "                  \"example\": undefined,\n                  \"format\": \"int64\",\n                  \"kind\": \"origin\",\n                  \"name\": \"orderId\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"number\",\n                },\n              ],\n              \"kind\": \"origin\",", "              ],\n              \"kind\": \"origin\",\n              \"name\": \"GetOrderByIdReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {", "          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"GetOrderByIdResData\",\n              \"origin\": \"Order\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/Order\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"Order\",", "              \"required\": true,\n              \"target\": \"Order\",\n            },\n          },\n          \"title\": \"Find purchase order by ID\",\n          \"url\": \"/store/order/{orderId}\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"This can only be done by the logged in user.\",", "          \"deprecated\": undefined,\n          \"description\": \"This can only be done by the logged in user.\",\n          \"method\": \"post\",\n          \"name\": \"createUser\",\n          \"request\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"CreateUserReqData\",\n              \"origin\": \"User\",\n              \"props\": [],", "              \"origin\": \"User\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/User\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"User\",\n            },\n            \"path\": undefined,\n            \"query\": undefined,\n          },", "            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": undefined,\n          },\n          \"title\": \"Create user\",\n          \"url\": \"/user\",\n        },\n        {\n          \"deprecated\": undefined,", "        {\n          \"deprecated\": undefined,\n          \"description\": \"This can only be done by the logged in user.\",\n          \"method\": \"delete\",\n          \"name\": \"deleteUser\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {", "              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"The name that needs to be deleted\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"username\",", "                  \"kind\": \"origin\",\n                  \"name\": \"username\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"DeleteUserReqPath\",\n              \"required\": true,", "              \"name\": \"DeleteUserReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": undefined,\n          },\n          \"title\": \"Delete user\",", "          },\n          \"title\": \"Delete user\",\n          \"url\": \"/user/{username}\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"\",\n          \"method\": \"get\",\n          \"name\": \"getUserByName\",\n          \"request\": {", "          \"name\": \"getUserByName\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"The name that needs to be fetched. Use user1 for testing. \",\n                  \"enum\": undefined,", "                  \"description\": \"The name that needs to be fetched. Use user1 for testing. \",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"username\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },", "                  \"type\": \"string\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"GetUserByNameReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },", "            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"GetUserByNameResData\",\n              \"origin\": \"User\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/User\",\n              \"refAble\": false,", "              \"ref\": \"#/components/schemas/User\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"User\",\n            },\n          },\n          \"title\": \"Get user by user name\",\n          \"url\": \"/user/{username}\",\n        },\n        {", "        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"This can only be done by the logged in user.\",\n          \"method\": \"put\",\n          \"name\": \"updateUser\",\n          \"request\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"UpdateUserReqData\",", "              \"kind\": \"alias\",\n              \"name\": \"UpdateUserReqData\",\n              \"origin\": \"User\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/User\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"User\",\n            },\n            \"path\": {", "            },\n            \"path\": {\n              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"name that need to be deleted\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,", "                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"username\",\n                  \"required\": true,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],\n              \"kind\": \"origin\",", "              ],\n              \"kind\": \"origin\",\n              \"name\": \"UpdateUserReqPath\",\n              \"required\": true,\n              \"type\": \"object\",\n            },\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": undefined,", "          \"response\": {\n            \"body\": undefined,\n          },\n          \"title\": \"Update user\",\n          \"url\": \"/user/{username}\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"Creates list of users with given input array\",\n          \"method\": \"post\",", "          \"description\": \"Creates list of users with given input array\",\n          \"method\": \"post\",\n          \"name\": \"createUsersWithListInput\",\n          \"request\": {\n            \"body\": {\n              \"children\": [\n                {\n                  \"kind\": \"alias\",\n                  \"name\": \"CreateUsersWithListInputReqData[]\",\n                  \"origin\": \"User\",", "                  \"name\": \"CreateUsersWithListInputReqData[]\",\n                  \"origin\": \"User\",\n                  \"props\": [],\n                  \"ref\": \"#/components/schemas/User\",\n                  \"refAble\": false,\n                  \"required\": true,\n                  \"target\": \"User\",\n                },\n              ],\n              \"default\": undefined,", "              ],\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"CreateUsersWithListInputReqData\",\n              \"required\": false,", "              \"name\": \"CreateUsersWithListInputReqData\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"array\",\n            },\n            \"path\": undefined,\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": {", "          \"response\": {\n            \"body\": {\n              \"kind\": \"alias\",\n              \"name\": \"CreateUsersWithListInputResData\",\n              \"origin\": \"User\",\n              \"props\": [],\n              \"ref\": \"#/components/schemas/User\",\n              \"refAble\": false,\n              \"required\": true,\n              \"target\": \"User\",", "              \"required\": true,\n              \"target\": \"User\",\n            },\n          },\n          \"title\": \"Creates list of users with given input array\",\n          \"url\": \"/user/createWithList\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"\",", "          \"deprecated\": undefined,\n          \"description\": \"\",\n          \"method\": \"get\",\n          \"name\": \"loginUser\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": undefined,\n            \"query\": {\n              \"children\": [\n                {", "              \"children\": [\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"The user name for login\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"username\",", "                  \"kind\": \"origin\",\n                  \"name\": \"username\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n                {\n                  \"default\": undefined,\n                  \"deprecated\": undefined,\n                  \"description\": \"The password for login in clear text\",", "                  \"deprecated\": undefined,\n                  \"description\": \"The password for login in clear text\",\n                  \"enum\": undefined,\n                  \"example\": undefined,\n                  \"format\": undefined,\n                  \"kind\": \"origin\",\n                  \"name\": \"password\",\n                  \"required\": false,\n                  \"title\": undefined,\n                  \"type\": \"string\",", "                  \"title\": undefined,\n                  \"type\": \"string\",\n                },\n              ],\n              \"kind\": \"origin\",\n              \"name\": \"LoginUserReqParams\",\n              \"required\": false,\n              \"type\": \"object\",\n            },\n          },", "            },\n          },\n          \"response\": {\n            \"body\": {\n              \"default\": undefined,\n              \"deprecated\": undefined,\n              \"description\": undefined,\n              \"enum\": undefined,\n              \"example\": undefined,\n              \"format\": undefined,", "              \"example\": undefined,\n              \"format\": undefined,\n              \"kind\": \"origin\",\n              \"name\": \"LoginUserResData\",\n              \"required\": false,\n              \"title\": undefined,\n              \"type\": \"string\",\n            },\n          },\n          \"title\": \"Logs user into the system\",", "          },\n          \"title\": \"Logs user into the system\",\n          \"url\": \"/user/login\",\n        },\n        {\n          \"deprecated\": undefined,\n          \"description\": \"\",\n          \"method\": \"get\",\n          \"name\": \"logoutUser\",\n          \"request\": {", "          \"name\": \"logoutUser\",\n          \"request\": {\n            \"body\": undefined,\n            \"path\": undefined,\n            \"query\": undefined,\n          },\n          \"response\": {\n            \"body\": undefined,\n          },\n          \"title\": \"Logs out current logged in user session\",", "          },\n          \"title\": \"Logs out current logged in user session\",\n          \"url\": \"/user/logout\",\n        },\n      ],\n    }\n  `);\n});\n", ""]}
{"filename": "test/parsers/ComponentsPaser.test.ts", "chunked_list": ["import { expect } from 'vitest';\nimport { ComponentsParser } from '../../src/parsers/ComponentsParser';\nimport type { TypeAlias, TypeList } from '../../src/parsers/types';\n\ntest('empty components', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },", "      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([]);\n});\n", "});\n\ntest('empty components keys', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},", "    openapi: '3.0.0',\n    paths: {},\n    components: {},\n  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([]);\n});\n\ntest('empty ref', async () => {", "\ntest('empty ref', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {", "    paths: {},\n    components: {\n      schemas: {\n        T: {\n          $ref: '#/components/schemas/P',\n        },\n      },\n    },\n  });\n", "  });\n\n  const t = parser.parseComponents();\n  expect((t[0] as TypeAlias).target).toEqual('');\n});\n\ntest('ref once', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',", "    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {\n      schemas: {\n        T: {\n          $ref: '#/components/schemas/P',", "        T: {\n          $ref: '#/components/schemas/P',\n        },\n        P: {\n          type: 'string',\n        },\n      },\n    },\n  });\n", "  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([\n    {\n      kind: 'origin',\n      name: 'P',\n      type: 'string',\n      required: false,\n    },", "      required: false,\n    },\n    {\n      kind: 'alias',\n      refAble: true,\n      required: true,\n      name: 'T',\n      target: 'P',\n      origin: 'P',\n      props: [],", "      origin: 'P',\n      props: [],\n      ref: '#/components/schemas/P',\n    },\n  ]);\n});\n\ntest('ref twice', async () => {\n  const parser = new ComponentsParser({\n    info: {", "  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {\n      schemas: {\n        T: {", "      schemas: {\n        T: {\n          $ref: '#/components/schemas/P',\n        },\n        P: {\n          $ref: '#/components/schemas/K',\n        },\n        K: {\n          type: 'string',\n        },", "          type: 'string',\n        },\n      },\n    },\n  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([\n    { kind: 'origin', name: 'K', type: 'string', required: false },\n    {", "    { kind: 'origin', name: 'K', type: 'string', required: false },\n    {\n      kind: 'alias',\n      refAble: true,\n      required: true,\n      name: 'P',\n      target: 'K',\n      origin: 'K',\n      props: [],\n      ref: '#/components/schemas/K',", "      props: [],\n      ref: '#/components/schemas/K',\n    },\n    {\n      kind: 'alias',\n      refAble: true,\n      required: true,\n      name: 'T',\n      target: 'P',\n      origin: 'K',", "      target: 'P',\n      origin: 'K',\n      props: [],\n      ref: '#/components/schemas/P',\n    },\n  ]);\n});\n\ntest('primitive', async () => {\n  const parser = new ComponentsParser({", "test('primitive', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {\n      schemas: {", "    components: {\n      schemas: {\n        B: {\n          type: 'boolean',\n        },\n        S: {\n          type: 'string',\n        },\n        N: {\n          type: 'number',", "        N: {\n          type: 'number',\n        },\n        I: {\n          type: 'integer',\n        },\n      },\n    },\n  });\n", "  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([\n    { name: 'B', type: 'boolean', required: false, kind: 'origin' },\n    { name: 'I', type: 'number', required: false, kind: 'origin' },\n    { name: 'N', type: 'number', required: false, kind: 'origin' },\n    { name: 'S', type: 'string', required: false, kind: 'origin' },\n  ]);\n});", "  ]);\n});\n\ntest('object', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',", "    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {\n      schemas: {\n        O: {\n          type: 'object',\n          nullable: false,\n          properties: {\n            B: {", "          properties: {\n            B: {\n              type: 'boolean',\n            },\n            S: {\n              type: 'string',\n            },\n            N: {\n              type: 'number',\n            },", "              type: 'number',\n            },\n            I: {\n              type: 'integer',\n            },\n            R: {\n              $ref: '#/components/schemas/R',\n            },\n          },\n          required: ['B', 'S', 'N', 'I'],", "          },\n          required: ['B', 'S', 'N', 'I'],\n          additionalProperties: true,\n        },\n        R: {\n          type: 'string',\n        },\n      },\n    },\n  });", "    },\n  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([\n    {\n      kind: 'origin',\n      name: 'O',\n      type: 'object',\n      required: true,", "      type: 'object',\n      required: true,\n      children: [\n        // \u5df2\u91cd\u65b0\u6392\u5e8f\n        { name: 'B', type: 'boolean', required: true, kind: 'origin' },\n        { name: 'I', type: 'number', required: true, kind: 'origin' },\n        { name: 'N', type: 'number', required: true, kind: 'origin' },\n        {\n          kind: 'alias',\n          refAble: false,", "          kind: 'alias',\n          refAble: false,\n          required: false,\n          name: 'R',\n          target: 'R',\n          origin: 'R',\n          props: [],\n          ref: '#/components/schemas/R',\n        },\n        { name: 'S', type: 'string', required: true, kind: 'origin' },", "        },\n        { name: 'S', type: 'string', required: true, kind: 'origin' },\n        { name: '[key: string]', type: 'any', required: true, kind: 'origin' },\n      ],\n    },\n    {\n      kind: 'origin',\n      name: 'R',\n      type: 'string',\n      required: false,", "      type: 'string',\n      required: false,\n    },\n  ]);\n});\n\ntest('array', async () => {\n  const parser = new ComponentsParser({\n    info: {\n      title: 'test',", "    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {\n      schemas: {\n        A: {\n          type: 'array',", "        A: {\n          type: 'array',\n          nullable: false,\n          items: {\n            type: 'string',\n          },\n          additionalProperties: {\n            $ref: '#/components/schema/T',\n          },\n        },", "          },\n        },\n        T: {\n          type: 'string',\n        },\n      },\n    },\n  });\n\n  const t = parser.parseComponents();", "\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([\n    {\n      kind: 'origin',\n      name: 'A',\n      type: 'array',\n      required: true,\n      children: [\n        { kind: 'origin', name: 'A[]', type: 'string', required: false },", "      children: [\n        { kind: 'origin', name: 'A[]', type: 'string', required: false },\n        {\n          kind: 'alias',\n          name: '[key: string]',\n          target: 'T',\n          origin: 'T',\n          props: [],\n          refAble: false,\n          required: true,", "          refAble: false,\n          required: true,\n          ref: '#/components/schema/T',\n        },\n      ],\n    },\n    {\n      kind: 'origin',\n      name: 'T',\n      type: 'string',", "      name: 'T',\n      type: 'string',\n      required: false,\n    },\n  ]);\n});\n\ntest('never', async () => {\n  const parser = new ComponentsParser({\n    info: {", "  const parser = new ComponentsParser({\n    info: {\n      title: 'test',\n      version: '1.0.0',\n    },\n    openapi: '3.0.0',\n    paths: {},\n    components: {\n      schemas: {\n        R: {},", "      schemas: {\n        R: {},\n      },\n    },\n  });\n\n  const t = parser.parseComponents();\n  expect(t).toEqual<TypeList>([\n    {\n      kind: 'origin',", "    {\n      kind: 'origin',\n      name: 'R',\n      type: 'never',\n      required: true,\n    },\n  ]);\n});\n", ""]}
{"filename": "test/parsers/Named.test.ts", "chunked_list": ["import { Named } from '../../src/parsers/Named';\n\ntest('named', () => {\n  const named = new Named();\n\n  named.internalName('Internal');\n  expect(named.nextTypeName('Internal', true)).toEqual('Internal2');\n\n  expect(named.nextTypeName('-', true)).toEqual('Unnamed');\n  expect(named.nextTypeName('!', true)).toEqual('Unnamed2');", "  expect(named.nextTypeName('-', true)).toEqual('Unnamed');\n  expect(named.nextTypeName('!', true)).toEqual('Unnamed2');\n\n  expect(named.nextTypeName('A', true)).toEqual('A');\n  expect(named.nextTypeName('A!', true)).toEqual('A2');\n\n  expect(named.nextTypeName('aa', true)).toEqual('Aa');\n  expect(named.nextTypeName('aa!', true)).toEqual('Aa2');\n  expect(named.nextTypeName('aa!!', true)).toEqual('Aa3');\n", "  expect(named.nextTypeName('aa!!', true)).toEqual('Aa3');\n\n  expect(named.nextOperationId('get', '/path/to/foo')).toEqual('getFoo');\n  expect(named.nextOperationId('get', '/path/to/foo')).toEqual('getFoo2');\n  expect(named.nextOperationId('get', '/path/to/foo', 'foo')).toEqual('foo');\n  expect(named.nextOperationId('get', '/path/to/foo', 'foo')).toEqual('foo2');\n  expect(named.nextOperationId('get', '/path/to/foo')).toEqual('getFoo3');\n\n  expect(named.nextOperationId('', '', 'xx')).toEqual('xx');\n  expect(named.nextOperationId('', '', 'xx')).toEqual('xx2');", "  expect(named.nextOperationId('', '', 'xx')).toEqual('xx');\n  expect(named.nextOperationId('', '', 'xx')).toEqual('xx2');\n\n  named.internalName('export');\n  expect(named.nextOperationId('', '', 'export')).toEqual('export2');\n  expect(named.nextOperationId('', '', 'export')).toEqual('export3');\n\n  // A -> A!(A2) -> aa!!/1/2 == A -> aa!!/1/2(Aa3)\n  const a1 = named.addAlias({\n    kind: 'alias',", "  const a1 = named.addAlias({\n    kind: 'alias',\n    refAble: true,\n    required: true,\n    name: 'A',\n    ref: '#/components/schemas/A!',\n    target: '',\n    origin: '',\n    props: [],\n  });", "    props: [],\n  });\n  // A!(A2) -> aa!!/1/2(Aa3)\n  const a2 = named.addAlias({\n    kind: 'alias',\n    refAble: true,\n    required: true,\n    name: 'A2',\n    ref: '#/components/schemas/aa!!/1/2',\n    target: '',", "    ref: '#/components/schemas/aa!!/1/2',\n    target: '',\n    origin: '',\n    props: [],\n  });\n\n  named.resolveAlias();\n\n  expect(a1.target).toEqual('A2');\n  expect(a2.target).toEqual('Aa3');", "  expect(a1.target).toEqual('A2');\n  expect(a2.target).toEqual('Aa3');\n\n  expect(a1.origin).toEqual('Aa3');\n  expect(a2.origin).toEqual('Aa3');\n\n  expect(a1.props).toEqual([]);\n  expect(a2.props).toEqual(['1', '2']);\n});\n", "});\n"]}
{"filename": "src/const.ts", "chunked_list": ["export const pkgName = process.env.PKG_NAME;\nexport const pkgVersion = process.env.PKG_VERSION;\n"]}
{"filename": "src/helpers.ts", "chunked_list": ["export * from './const';\n\n// @ref https://github.com/drwpow/openapi-typescript/blob/bc52343c44f9dab4006e04c27411e405fb67a739/src/index.ts#L215\nexport type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\nexport type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;\nexport type OneOf<T extends any[]> = T extends [infer Only]\n  ? Only\n  : T extends [infer A, infer B, ...infer Rest]\n  ? OneOf<[XOR<A, B>, ...Rest]>\n  : never;\n\nexport const DELETE = 'DELETE';\nexport const GET = 'GET';\nexport const HEAD = 'HEAD';\nexport const OPTIONS = 'OPTIONS';\nexport const PATCH = 'PATCH';\nexport const POST = 'POST';\nexport const PUT = 'PUT';\nexport const TRACE = 'TRACE';\n", "export function resolveURL(baseURL: string, url: string) {\n  // @ref https://github.com/FrontEndDev-org/openapi-axios/security/code-scanning/1\n  return baseURL.replace(/(?<!\\/)\\/+$/, '') + '/' + url.replace(/^\\/+/, '');\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './const';\nexport { defineConfig, run } from './generators/command';\nexport { DocumentPrinter } from './printers/DocumentPrinter';\nexport { DocumentParser } from './parsers/DocumentParser';\nexport { Generator } from './generators/Generator';\n"]}
{"filename": "src/printers/PathsPrinter.ts", "chunked_list": ["import type { AxiosRequestConfig } from 'axios';\nimport { groupBy } from 'lodash';\nimport type { TypeItem, TypeList, TypeOperation, TypeOperations, TypeOrigin } from '../parsers/types';\nimport { joinSlices, nextUniqueName, varString } from '../utils/string';\nimport { isBoolean, isString } from '../utils/type-is';\nimport { ComponentsPrinter } from './ComponentsPrinter';\n\nconst { stringify } = JSON;\n\nexport class PathsPrinter extends ComponentsPrinter {\n  protected init() {\n    super.init();\n    this.imports.push('import type { AxiosPromise, AxiosRequestConfig } from \"axios\";');\n    this.imports.push(\n      'import { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT, resolveURL } from \"openapi-axios/helpers\";'\n    );\n    this.imports.push(this.options.axiosImport);\n    this.helpers.push(`const request = axios.request;`);", "\nexport class PathsPrinter extends ComponentsPrinter {\n  protected init() {\n    super.init();\n    this.imports.push('import type { AxiosPromise, AxiosRequestConfig } from \"axios\";');\n    this.imports.push(\n      'import { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT, resolveURL } from \"openapi-axios/helpers\";'\n    );\n    this.imports.push(this.options.axiosImport);\n    this.helpers.push(`const request = axios.request;`);\n    if (this.document.info.baseURL) this.helpers.push(`const BASE_URL = ${stringify(this.document.info.baseURL)};`);\n  }\n\n  printPaths() {\n    return this.format(joinSlices(this.document.paths.map(this.printOperation.bind(this)), '\\n\\n'));\n  }\n\n  protected printOperation(type: TypeOperation) {\n    return joinSlices([this.printOperationTypes(type), this.printOperationAxios(type)]);\n  }\n\n  protected printOperationTypes(type: TypeOperation) {\n    const {\n      request: { path, query, body: reqBody },\n      response: { body: resBody },\n    } = type;\n\n    return joinSlices(([path, query, reqBody, resBody].filter(Boolean) as TypeList).map(this.printRootType.bind(this)));\n  }\n\n  protected printOperationAxios(type: TypeOperation) {\n    const {\n      name,\n      request: { path, query, body: reqBody },\n      response: { body: resBody },\n    } = type;\n    const { responseTypeName } = this.options;\n    const argNameCountMap = new Map<string, number>();\n    const requestPathArgName = nextUniqueName(this.options.requestPathArgName, argNameCountMap);\n    const requestQueryArgName = nextUniqueName(this.options.requestQueryArgName, argNameCountMap);\n    const requestBodyArgName = nextUniqueName(this.options.requestBodyArgName, argNameCountMap);\n    const configArgName = nextUniqueName('config', argNameCountMap);\n    const comments = this.printComments(type, true);\n    const argsGroup = groupBy(\n      [\n        this.printArg(requestPathArgName, path),\n        this.printArg(requestQueryArgName, query),\n        this.printArg(requestBodyArgName, reqBody),\n        this.printArg(configArgName, 'AxiosRequestConfig', false),\n      ],\n      (item) => item?.required\n    );\n    const args_ = joinSlices(\n      [\n        // \u53ef\u80fd\u6ca1\u6709\u4efb\u4f55\u5fc5\u586b\u53c2\u6570\n        ...(argsGroup['true'] || []),\n        // \u81f3\u5c11\u6709\u4e00\u4e2a config \u53ef\u9009\u53c2\u6570\n        ...argsGroup['false'],\n      ].map((desc) => desc?.text),\n      ', '\n    );\n    const return_ = `${responseTypeName}<${resBody?.name || 'never'}>`;\n    const url_ = this.printAxiosProp('url', this.toURL(type, requestPathArgName));\n    const method_ = this.printAxiosProp('method', type.method.toUpperCase());\n    const params_ = this.printAxiosProp('params', query ? requestQueryArgName : '');\n    const data_ = this.printAxiosProp('data', reqBody ? requestBodyArgName : '');\n    const props = joinSlices([\n      //\n      url_,\n      method_,\n      params_,\n      data_,\n      `...${configArgName}`,\n    ]);\n\n    return `${comments}export async function ${name}(${args_}): ${return_}  {\n              return request({\n                ${props}\n              });\n            }`;\n  }\n\n  protected printAxiosProp(prop: keyof AxiosRequestConfig, value?: string) {", "    if (this.document.info.baseURL) this.helpers.push(`const BASE_URL = ${stringify(this.document.info.baseURL)};`);\n  }\n\n  printPaths() {\n    return this.format(joinSlices(this.document.paths.map(this.printOperation.bind(this)), '\\n\\n'));\n  }\n\n  protected printOperation(type: TypeOperation) {\n    return joinSlices([this.printOperationTypes(type), this.printOperationAxios(type)]);\n  }\n\n  protected printOperationTypes(type: TypeOperation) {\n    const {\n      request: { path, query, body: reqBody },\n      response: { body: resBody },\n    } = type;\n\n    return joinSlices(([path, query, reqBody, resBody].filter(Boolean) as TypeList).map(this.printRootType.bind(this)));\n  }\n\n  protected printOperationAxios(type: TypeOperation) {\n    const {\n      name,\n      request: { path, query, body: reqBody },\n      response: { body: resBody },\n    } = type;\n    const { responseTypeName } = this.options;\n    const argNameCountMap = new Map<string, number>();\n    const requestPathArgName = nextUniqueName(this.options.requestPathArgName, argNameCountMap);\n    const requestQueryArgName = nextUniqueName(this.options.requestQueryArgName, argNameCountMap);\n    const requestBodyArgName = nextUniqueName(this.options.requestBodyArgName, argNameCountMap);\n    const configArgName = nextUniqueName('config', argNameCountMap);\n    const comments = this.printComments(type, true);\n    const argsGroup = groupBy(\n      [\n        this.printArg(requestPathArgName, path),\n        this.printArg(requestQueryArgName, query),\n        this.printArg(requestBodyArgName, reqBody),\n        this.printArg(configArgName, 'AxiosRequestConfig', false),\n      ],\n      (item) => item?.required\n    );\n    const args_ = joinSlices(\n      [\n        // \u53ef\u80fd\u6ca1\u6709\u4efb\u4f55\u5fc5\u586b\u53c2\u6570\n        ...(argsGroup['true'] || []),\n        // \u81f3\u5c11\u6709\u4e00\u4e2a config \u53ef\u9009\u53c2\u6570\n        ...argsGroup['false'],\n      ].map((desc) => desc?.text),\n      ', '\n    );\n    const return_ = `${responseTypeName}<${resBody?.name || 'never'}>`;\n    const url_ = this.printAxiosProp('url', this.toURL(type, requestPathArgName));\n    const method_ = this.printAxiosProp('method', type.method.toUpperCase());\n    const params_ = this.printAxiosProp('params', query ? requestQueryArgName : '');\n    const data_ = this.printAxiosProp('data', reqBody ? requestBodyArgName : '');\n    const props = joinSlices([\n      //\n      url_,\n      method_,\n      params_,\n      data_,\n      `...${configArgName}`,\n    ]);\n\n    return `${comments}export async function ${name}(${args_}): ${return_}  {\n              return request({\n                ${props}\n              });\n            }`;\n  }\n\n  protected printAxiosProp(prop: keyof AxiosRequestConfig, value?: string) {", "    if (!value) return '';\n    return prop === value ? `${prop},` : `${prop}: ${value},`;\n  }\n\n  protected printArg(name: string, type?: TypeItem | string, required?: boolean) {\n    if (!type) return;\n\n    const typeName = isString(type) ? type : type.name;\n    required = isString(type) ? required : (type as TypeOrigin).required;\n    const equal = required ? ':' : '?:';\n\n    return {\n      required,\n      text: `${name}${equal}${typeName}`,\n    };\n  }\n\n  protected toURL(type: TypeOperation, requestPathArgName: string) {\n    const url = stringify(varString(type.url, requestPathArgName)).replace(/\"/g, '`');\n", "    required = isString(type) ? required : (type as TypeOrigin).required;\n    const equal = required ? ':' : '?:';\n\n    return {\n      required,\n      text: `${name}${equal}${typeName}`,\n    };\n  }\n\n  protected toURL(type: TypeOperation, requestPathArgName: string) {\n    const url = stringify(varString(type.url, requestPathArgName)).replace(/\"/g, '`');\n", "    if (!this.document.info.baseURL) return url;\n\n    return `resolveURL(BASE_URL, ${url})`;\n  }\n}\n"]}
{"filename": "src/printers/CommentsPrinter.ts", "chunked_list": ["import type { TypeComments, TypeItem } from '../parsers/types';\nimport { joinSlices } from '../utils/string';\nimport { isUndefined } from '../utils/type-is';\nimport { BasePrinter } from './BasePrinter';\n\nexport class CommentsPrinter extends BasePrinter {\n  printComments(type: TypeComments, trailingEndOfLine = false) {\n    const orders: (keyof TypeComments)[] = ['title', 'description', 'format', 'default', 'example'];\n    const mainLines = joinSlices([\n      type.deprecated ? ' * @deprecated' : '',\n      ...orders.map((key) => {\n        const val = type[key];\n", "        if (isUndefined(val)) return '';\n\n        const [firstLine, ...restLines] = String(val).split('\\n');\n        return joinSlices([`@${key} ${firstLine}`, ...restLines].map((line) => ` * ${line}`));\n      }),\n    ]);\n\n    if (mainLines.length === 0) return '';\n\n    return (\n      '/**\\n' + //////////////////////////////////////\n      mainLines +\n      '\\n */' +\n      (trailingEndOfLine ? '\\n' : '')\n    );\n  }\n}\n"]}
{"filename": "src/printers/ComponentsPrinter.ts", "chunked_list": ["import type { TypeItem, TypeOrigin } from '../parsers/types';\nimport { joinSlices, toTypePath } from '../utils/string';\nimport { BasePrinter } from './BasePrinter';\nimport { CommentsPrinter } from './CommentsPrinter';\n\nexport class ComponentsPrinter extends CommentsPrinter {\n  protected init() {\n    super.init();\n    this.imports.push('import type { OneOf } from \"openapi-axios/helpers\"');\n  }\n\n  printComponents() {\n    return this.format(joinSlices(this.document.components.map(this.printRootType.bind(this)), '\\n\\n'));\n  }\n\n  protected printRootType(type: TypeItem) {\n    const comments = this.printComments(type, true);\n    return `${comments}export type ${type.name} = ${this.printType(type)};`;\n  }\n\n  private printType(type: TypeItem): string {", "    if (this.isTypeAlias(type)) return `${type.origin}${toTypePath(type.props)}`;\n\n    switch (type.type) {\n      case 'object':\n        return this.printObject(type);\n\n      case 'array':\n        return this.printArray(type);\n\n      default:\n        return this.printPrimitive(type);\n    }\n  }\n\n  private printPrimitive(type: TypeOrigin) {\n    return type.enum ? type.enum.map((el) => JSON.stringify(el)).join('|') : `${type.type}`;\n  }\n\n  private printObject(type: TypeOrigin) {\n    const { children } = type;\n", "    if (!children || !children.length) return '{[key: string]: never}';\n\n    const kvList = children.map((type) => {\n      const comments = this.printComments(type, true);\n      const key = type.name;\n      const equal = type.required ? ':' : '?:';\n      const value = this.printType(type);\n      return comments + key + equal + value + ';';\n    });\n    return '{' + joinSlices(kvList) + '}';\n  }\n\n  private printArray(type: TypeOrigin) {\n    const { children } = type;\n", "    if (!children || !children.length) return 'never';\n\n    const vList = children.map((type) => {\n      const comments = this.printComments(type, true);\n      const value = this.printType(type);\n      return comments + value;\n    });\n\n    return `Array<${joinSlices(vList, '|')}>`;\n  }\n}\n"]}
{"filename": "src/printers/types.ts", "chunked_list": ["import type { Config } from 'prettier';\n\nexport interface PrinterOptions {\n  axiosImport?: string;\n\n  /**\n   * \u683c\u5f0f\u5316\u914d\u7f6e\n   */\n  prettier?: Config;\n\n  requestPathArgName?: string;\n  requestQueryArgName?: string;\n  requestBodyArgName?: string;\n\n  responseTypeName?: 'Promise' | 'AxiosPromise' | string;\n}", "export type StrictPrinterOptions = Required<PrinterOptions>;\n"]}
{"filename": "src/printers/BasePrinter.ts", "chunked_list": ["import type { TypeAlias, TypeDocument, TypeItem } from '../parsers/types';\nimport { joinSlices } from '../utils/string';\nimport type { StrictPrinterOptions, PrinterOptions } from './types';\nimport prettier from 'prettier';\n\nexport class BasePrinter {\n  static defaults: StrictPrinterOptions = {\n    axiosImport: `import axios from 'axios';`,\n    prettier: {\n      singleQuote: true,\n    },\n    requestPathArgName: 'path',\n    requestQueryArgName: 'params',\n    requestBodyArgName: 'data',\n    responseTypeName: 'AxiosPromise',\n  };\n\n  options: StrictPrinterOptions;\n  constructor(readonly document: TypeDocument, options?: PrinterOptions) {\n    this.options = Object.assign({}, BasePrinter.defaults, options) as StrictPrinterOptions;\n    this.init();\n  }\n\n  protected init() {\n    //\n  }\n", "  protected isTypeAlias(type: TypeItem): type is TypeAlias {\n    return type.kind === 'alias';\n  }\n\n  protected format(text: string) {\n    return prettier.format(text, {\n      ...this.options.prettier,\n      parser: 'typescript',\n    });\n  }\n\n  // \u5934\u90e8\u58f0\u660e\n  statements: string[] = [];\n\n  // \u5934\u90e8\u5bfc\u5165\n  imports: string[] = [];\n\n  // \u5e2e\u52a9\u7c7b\u578b\n  helpers: string[] = [];\n\n  protected printStatements() {\n    return joinSlices(this.statements);\n  }\n\n  protected printImports() {\n    return this.format(joinSlices(this.imports));\n  }\n\n  protected printHelpers() {\n    return this.format(joinSlices(this.helpers));\n  }\n}\n"]}
{"filename": "src/printers/DocumentPrinter.ts", "chunked_list": ["import { joinSlices } from '../utils/string';\nimport { PathsPrinter } from './PathsPrinter';\n\nexport class DocumentPrinter extends PathsPrinter {\n  print() {\n    return joinSlices([\n      //\n      this.printStatements(),\n      this.printImports(),\n      this.printHelpers(),\n      this.printComponents(),\n      this.printPaths(),\n    ]);\n  }\n}\n"]}
{"filename": "src/utils/fs2.ts", "chunked_list": ["import fs from 'fs/promises';\n\nexport async function isFile(p: string) {\n  try {\n    const state = await fs.stat(p);\n    return state.isFile();\n  } catch (err) {\n    return false;\n  }\n}\n", "export async function cleanDir(p: string) {\n  await fs.rm(p, { recursive: true, force: true });\n}\n"]}
{"filename": "src/utils/type-is.ts", "chunked_list": ["export function isUndefined(any: unknown): any is undefined {\n  return any === undefined;\n}\n\nexport function isString(any: unknown): any is string {\n  return typeof any === 'string';\n}\n\nexport function isBoolean(any: unknown): any is boolean {\n  return typeof any === 'boolean';\n}\n", "export function isBoolean(any: unknown): any is boolean {\n  return typeof any === 'boolean';\n}\n\nexport function isNumber(any: unknown): any is number {\n  return typeof any === 'number';\n}\n\nexport function isObject(any: unknown): any is object {\n  return typeof any === 'object' && any !== null;\n}\n", "export function isObject(any: unknown): any is object {\n  return typeof any === 'object' && any !== null;\n}\n\nexport function isDate(any: unknown): any is Date {\n  return Boolean(any && any instanceof Date);\n}\n\nexport function isUrl(any: string): boolean {\n  return /^https:\\/\\//i.test(any);\n}\n", "export function isUrl(any: string): boolean {\n  return /^https:\\/\\//i.test(any);\n}\n\nexport function isVarName(varName: string) {\n  return /^[a-z_$]\\w*$/i.test(varName);\n}\n"]}
{"filename": "src/utils/string.ts", "chunked_list": ["import { isVarName } from './type-is';\n\nexport function buildName(origin: string, bigger = false) {\n  const name =\n    origin\n      .replace(/\\W/g, '_')\n      .replace(/(^_+|_+$)/g, '')\n      .replace(/_(.)/g, ($0, $1: string) => $1.toUpperCase())\n      .replace(/^\\d+/, '') || 'unnamed';\n\n  return (bigger ? name[0].toUpperCase() : name[0].toLowerCase()) + name.slice(1);\n}\n", "export interface RefInfo {\n  type: string;\n  base: string;\n  props: string[];\n}\n\nexport function refToType(ref: string): RefInfo {\n  const segs = ref.split('/').slice(3);\n  const type = segs[0]!;\n\n  return {\n    type,\n    base: `#/components/schemas/${type}`,\n    props: segs.slice(1),\n  };\n}\n", "export function findOrigin(source: string, relation: Map<string, string>) {\n  let origin = source;\n  let target: string | undefined;\n\n  while ((target = relation.get(origin))) {\n    origin = target;\n  }\n\n  return origin;\n}\n", "export function varString(string: string, leading = ''): string {\n  return string.replace(/\\{([^}]+)\\}/g, ($0, $1: string) => {\n    const key = leading ? (isVarName($1) ? `${leading}.${$1}` : `${leading}[${JSON.stringify($1)}]`) : $1;\n    return `$\\{${key}}`;\n  });\n}\n\nexport function toTypePath(props: string[]): string {\n  const path = props.map((p) => JSON.stringify(p)).join('][');\n  return path ? '[' + path + ']' : '';\n}\n", "export function joinSlices(slices: Array<string | undefined>, separator = '\\n') {\n  return slices.filter(Boolean).join(separator);\n}\n\nexport function nextUniqueName(refName: string, nameCountMap: Map<string, number>) {\n  // abc123 -> abc\n  const baseName = refName.replace(/\\d+$/, '');\n  const count = nameCountMap.get(baseName) || 0;\n  const nextCount = count + 1;\n  nameCountMap.set(baseName, nextCount);\n  return nextCount === 1 ? baseName : baseName + nextCount;\n}\n"]}
{"filename": "src/generators/Generator.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport process from 'process';\nimport { Emitter } from 'strict-event-emitter';\nimport { normalizeError } from 'try-flatten';\nimport { DocumentParser } from '../parsers/DocumentParser';\nimport { DocumentPrinter } from '../printers/DocumentPrinter';\nimport { Reader } from './Reader';\nimport type {\n  GeneratingOptions,", "import type {\n  GeneratingOptions,\n  GeneratingStage,\n  GeneratorEmits,\n  GeneratorOptions,\n  GeneratingPayload,\n  OpenAPIOptions,\n  StrictGeneratorOptions,\n  GeneratorPayload,\n} from './types';", "  GeneratorPayload,\n} from './types';\n\nexport class Generator extends Emitter<GeneratorEmits> {\n  static defaults: StrictGeneratorOptions = {\n    cwd: process.cwd(),\n    dest: '/src/apis',\n    openAPIs: [],\n  };\n\n  options: StrictGeneratorOptions;\n  constructor(options: GeneratorOptions) {\n    super();\n    this.options = Object.assign({}, Generator.defaults, options) as StrictGeneratorOptions;\n  }\n\n  async generate() {\n    const count = this.options.openAPIs.length;\n    const payload: GeneratorPayload = { count };\n    this.emit('start', payload);\n", "    try {\n      let index = 0;\n      for (const openAPI of this.options.openAPIs) {\n        await this.generateOpenAPI(index, count, openAPI, this.options);\n        index++;\n      }\n    } catch (cause) {\n      const err = normalizeError(cause);\n      this.emit('error', err, payload);\n      throw err;\n    }\n\n    this.emit('end', payload);\n  }\n\n  protected async generateOpenAPI(\n    index: number,\n    count: number,\n    openAPIOptions: OpenAPIOptions,\n    generatorOptions: StrictGeneratorOptions\n  ) {\n    const { cwd, dest, parser: globalParser, printer: globalPrinter } = generatorOptions;\n    const { name, document, parser: scopeParser, printer: scopePrinter } = openAPIOptions;\n    const fileName = `${name}.ts`;\n    const filePath = path.join(cwd, dest, fileName);\n\n    // 1. \u53c2\u6570\u5408\u5e76\n    const parserOptions = Object.assign({}, globalParser, scopeParser);\n    const printerOptions = Object.assign({}, globalPrinter, scopePrinter);\n    const options: GeneratingOptions = {\n      ...openAPIOptions,\n      cwd,\n      dest,\n      parser: parserOptions,\n      printer: printerOptions,\n    };\n    const makePayload = (step: GeneratingStage): GeneratingPayload => ({\n      index,\n      count,\n      stage: step,\n      options,\n      filePath,\n    });\n\n    // 2. \u8bfb\u53d6\n    this.emit('process', makePayload('reading'));\n    const reader = new Reader();\n    reader.cwd = cwd;\n    const openAPIV3Document = await reader.read(document);\n\n    // 3. \u89e3\u6790\n    this.emit('process', makePayload('parsing'));\n    const parser = new DocumentParser(openAPIV3Document, parserOptions);\n    const types = parser.parse();\n\n    // 4. \u8f93\u51fa\n    this.emit('process', makePayload('printing'));\n    const printer = new DocumentPrinter(types, printerOptions);\n    const text = printer.print();\n\n    // 5. \u5199\u5165\n    this.emit('process', makePayload('writing'));\n    fs.mkdirSync(path.dirname(filePath), { recursive: true });\n    fs.writeFileSync(filePath, text, 'utf8');\n\n    this.emit('process', makePayload('generated'));\n  }\n}\n"]}
{"filename": "src/generators/Reader.ts", "chunked_list": ["import axios from 'axios';\nimport fs from 'fs';\nimport path from 'path';\nimport process from 'process';\nimport type { AcceptDocument } from '../parsers/types';\nimport type { OpenAPIV3Document } from '../types/openapi';\nimport { isString } from '../utils/type-is';\n\nexport class Reader {\n  cwd = process.cwd();\n\n  async read(document: AcceptDocument): Promise<OpenAPIV3Document> {", "export class Reader {\n  cwd = process.cwd();\n\n  async read(document: AcceptDocument): Promise<OpenAPIV3Document> {\n    if (isString(document)) {\n      if (/^https?:/i.test(document)) {\n        return await this.readRemote(document);\n      } else {\n        return this.readLocal(document);\n      }\n    } else {\n      return this.readObject(document);\n    }\n  }\n\n  static validate(document: AcceptDocument) {\n    // TODO\n  }\n\n  protected readLocal(file: string) {\n    const data = fs.readFileSync(path.resolve(this.cwd, file), 'utf8');\n    return JSON.parse(data) as OpenAPIV3Document;\n  }\n\n  protected async readRemote(url: string) {\n    const { data } = await axios.request<OpenAPIV3Document>({\n      url,\n      method: 'get',\n    });\n    return data;\n  }\n\n  protected readObject(document: OpenAPIV3Document) {\n    return document;\n  }\n}\n"]}
{"filename": "src/generators/Logger.ts", "chunked_list": ["import chalk from 'chalk';\nimport path from 'path';\nimport type { GeneratorEmits } from './types';\n\nexport class Logger {\n  pipeStartEvent(...[payload]: GeneratorEmits['start']) {\n    console.log(chalk.greenBright('\u25b6'), `\u5373\u5c06\u5904\u7406 ${payload.count} \u4e2a openAPI \u6587\u6863`);\n  }\n\n  pipeProcessEvent(...[payload]: GeneratorEmits['process']) {\n    const width = payload.count.toString().length;\n    const step = (payload.index + 1).toString().padStart(width, '0');\n\n    console.log(\n      chalk.cyanBright('\u25b7'),\n      chalk.yellowBright(`${step}/${payload.count}`),\n      payload.options.name,\n      payload.stage,\n      payload.stage === 'generated' ? path.relative(payload.options.cwd, payload.filePath) : ''\n    );\n  }\n\n  pipeEndEvent(...[payload]: GeneratorEmits['end']) {\n    console.log(chalk.greenBright('\u25a0'), '\u5904\u7406\u5b8c\u6210');\n  }\n\n  pipeErrorEvent(...[err]: GeneratorEmits['error']) {\n    console.log(chalk.redBright('\u25cf'), '\u5904\u7406\u5931\u8d25');\n    console.log(chalk.redBright(err.message));\n  }\n\n  pipeConfigError(err: Error) {\n    console.log(chalk.redBright('\u25cb'), '\u914d\u7f6e\u9519\u8bef');\n    console.log(chalk.redBright(err.message));\n  }\n}\n"]}
{"filename": "src/generators/types.ts", "chunked_list": ["import type { AcceptDocument, ParserOptions } from '../parsers/types';\nimport type { PrinterOptions } from '../printers/types';\nimport type { OpenAPIV3Document } from '../types/openapi';\n\ntype RequiredWith<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\nexport interface OpenAPIOptions {\n  /**\n   * openapi \u7684\u540d\u79f0\uff0c\u5c06\u4f1a\u751f\u6210 ${name}.ts \u6587\u4ef6\n   */\n  name: string;\n\n  /**\n   * openapi \u7684 document\uff0c\u53ef\u4ee5\u662f\u4e00\u4e2a\u94fe\u63a5\u5730\u5740\uff0c\u4e5f\u53ef\u4ee5\u662f\u672c\u5730\u8def\u5f84\uff0c\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u5bf9\u8c61\n   */\n  document: AcceptDocument;\n\n  /**\n   * \u89e3\u6790\u914d\u7f6e\uff0c\u4f18\u5148\u7ea7\u9ad8\u4e8e\u5168\u5c40\u914d\u7f6e\n   */\n  parser?: ParserOptions;\n\n  /**\n   * \u8f93\u51fa\u914d\u7f6e\uff0c\u4f18\u5148\u7ea7\u9ad8\u4e8e\u5168\u5c40\u914d\u7f6e\n   */\n  printer?: PrinterOptions;\n}\n", "export interface GeneratorOptions {\n  /**\n   * \u5de5\u4f5c\u76ee\u5f55\uff0c\u9ed8\u8ba4\u4e3a process.cwd()\n   */\n  cwd?: string;\n\n  /**\n   * \u751f\u6210\u6587\u4ef6\u76ee\u7684\u5730\uff0c\u9ed8\u8ba4\u4e3a src/apis\n   */\n  dest?: string;\n\n  /**\n   * \u89e3\u6790\u914d\u7f6e\n   */\n  parser?: ParserOptions;\n\n  /**\n   * \u8f93\u51fa\u914d\u7f6e\n   */\n  printer?: PrinterOptions;\n\n  /**\n   * openapi \u914d\u7f6e\u5217\u8868\n   */\n  openAPIs: OpenAPIOptions[];\n}", "export type StrictGeneratorOptions = RequiredWith<GeneratorOptions, 'cwd' | 'dest'>;\n\nexport type GeneratingStage = 'reading' | 'parsing' | 'printing' | 'writing' | 'generated';\nexport type GeneratingOptions = OpenAPIOptions & Pick<StrictGeneratorOptions, 'cwd' | 'dest'>;\n\nexport interface GeneratorPayload {\n  count: number;\n}\nexport interface GeneratingPayload {\n  index: number;\n  count: number;\n  stage: GeneratingStage;\n  options: GeneratingOptions;\n  filePath: string;\n}\n", "export interface GeneratingPayload {\n  index: number;\n  count: number;\n  stage: GeneratingStage;\n  options: GeneratingOptions;\n  filePath: string;\n}\n\nexport type GeneratorEmits = {\n  // \u6240\u6709\u5f00\u59cb\n  start: [GeneratorPayload];\n  // \u6240\u6709\u7ed3\u675f\n  end: [GeneratorPayload];\n  // \u5904\u7406\u4e2d\n  process: [GeneratingPayload];\n  error: [Error, GeneratorPayload];\n};\n", "export type GeneratorEmits = {\n  // \u6240\u6709\u5f00\u59cb\n  start: [GeneratorPayload];\n  // \u6240\u6709\u7ed3\u675f\n  end: [GeneratorPayload];\n  // \u5904\u7406\u4e2d\n  process: [GeneratingPayload];\n  error: [Error, GeneratorPayload];\n};\n"]}
{"filename": "src/generators/command.ts", "chunked_list": ["import fs from 'fs';\nimport path from 'path';\nimport process from 'process';\nimport { tryFlatten } from 'try-flatten';\nimport { z } from 'zod';\nimport { Generator } from './Generator';\nimport { Logger } from './Logger';\nimport type { GeneratorOptions } from './types';\n\nexport function defineConfig(options: GeneratorOptions): GeneratorOptions {\n  return options;\n}\n\nexport const configFileNameOrder = [\n  //\n  'openapi.config.cjs',\n  'openapi.config.js',\n];\n", "\nexport function defineConfig(options: GeneratorOptions): GeneratorOptions {\n  return options;\n}\n\nexport const configFileNameOrder = [\n  //\n  'openapi.config.cjs',\n  'openapi.config.js',\n];\n", "export function resolveConfigFile(cwd: string) {\n  for (const fileName of configFileNameOrder.values()) {\n    const filePath = path.join(cwd, fileName);\n\n    if (fs.existsSync(filePath)) {\n      return filePath;\n    }\n  }\n}\n\nexport function resolveConfig(cwd: string): GeneratorOptions {\n  const configFile = resolveConfigFile(cwd);\n", "export function resolveConfig(cwd: string): GeneratorOptions {\n  const configFile = resolveConfigFile(cwd);\n\n  if (!configFile) {\n    throw new Error(`\u914d\u7f6e\u6587\u4ef6\u672a\u627e\u5230\uff0c\u914d\u7f6e\u6587\u4ef6\u53ef\u4ee5\u662f ${configFileNameOrder.join('\u3001')} \u4e4b\u4e00`);\n  }\n\n  const configFileName = path.relative(cwd, configFile);\n\n  const [err, config] = tryFlatten(() => {\n    delete require.cache[require.resolve(configFile)];\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require(configFile) as GeneratorOptions;\n  });\n", "  if (err) {\n    throw err;\n  }\n\n  const schema = z\n    .object({\n      cwd: z.string(),\n      dest: z.string(),\n      openAPIs: z\n        .array(\n          z.object({\n            name: z.string(),\n            document: z.union([z.object({}), z.string()]),\n          })\n        )\n        .min(1),\n    })\n    .partial({\n      cwd: true,\n      dest: true,\n    });\n  const result = schema.safeParse(config);\n", "  if (result.success) return config;\n\n  if (result.error.isEmpty) return config;\n\n  const firstIssue = result.error.issues[0];\n\n  if (!firstIssue) return config;\n\n  throw new Error(`${configFileName}: #/${firstIssue.path.join('/')} - ${firstIssue.message}`);\n}\n", "export async function run(cwd = process.cwd()) {\n  const logger = new Logger();\n  const [err, config] = tryFlatten(() => resolveConfig(cwd));\n\n  if (err) return logger.pipeConfigError(err);\n\n  config.cwd = config.cwd || cwd;\n  const generator = new Generator(config);\n\n  generator.on('start', logger.pipeStartEvent);\n  generator.on('end', logger.pipeEndEvent);\n  generator.on('error', logger.pipeErrorEvent);\n  generator.on('process', logger.pipeProcessEvent);\n\n  await tryFlatten(generator.generate());\n}\n"]}
{"filename": "src/parsers/PathsParser.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\nimport { ComponentsParser } from './ComponentsParser';\nimport { BLOB_MIME, JSON_MIME, HTTP_METHODS } from './const';\nimport type { TypeItem, TypeList, TypeOperation, TypeOperations, TypeOrigin } from './types';\n\nexport class PathsParser extends ComponentsParser {\n  parsingUrl = '';\n  parsingMethod: OpenAPIV3.HttpMethods = OpenAPIV3.HttpMethods.GET;\n\n  parsePaths(): TypeOperations {\n    const { paths } = this.document;\n    const types: TypeOperations = [];\n\n    Object.entries(paths)\n      .sort((a, b) => a[0].localeCompare(b[0]))\n      .forEach(([url, pathItem]) => {", "        if (!pathItem) return;\n\n        this.parsingUrl = url;\n        types.push(...this.parsePathItem(pathItem));\n      });\n\n    this.named.resolveAlias();\n    return types;\n  }\n\n  protected parsePathItem(pathItem: OpenAPIV3.PathItemObject) {\n    const types: TypeOperations = [];\n\n    HTTP_METHODS.forEach((method) => {\n      const operation = pathItem[method];\n", "      if (!operation) return;\n\n      this.parsingMethod = method;\n      types.push(this.parseOperation(operation));\n    });\n\n    return types;\n  }\n\n  parseOperation(operation: OpenAPIV3.OperationObject): TypeOperation {\n    const { parameters, requestBody: requestBodySchema } = operation;\n    const { pathTypes, queryTypes } = this.parseOperationParameters(parameters);\n    const initialName = this.named.nextOperationId(this.parsingMethod, this.parsingUrl, operation.operationId);\n    const name = this.options.nameFormatter({\n      name: initialName,\n      method: this.parsingMethod,\n      url: this.parsingUrl,\n      operationId: operation.operationId,\n    });\n    const requestPathTypeName = this.named.nextTypeName(name + this.options.requestPathTypeName);\n    const requestQueryTypeName = this.named.nextTypeName(name + this.options.requestQueryTypeName);\n    const requestBodyTypeName = this.named.nextTypeName(name + this.options.requestBodyTypeName);\n    const responseBodyTypeName = this.named.nextTypeName(name + this.options.responseBodyTypeName);\n    const requestBody = this.parseOperationRequest(requestBodyTypeName, requestBodySchema);\n\n    return {\n      name,\n      method: this.parsingMethod,\n      url: this.parsingUrl,\n      title: operation.summary,\n      description: operation.description,\n      deprecated: operation.deprecated,\n      request: {\n        path: this.wrapParameters(requestPathTypeName, pathTypes),\n        query: this.wrapParameters(requestQueryTypeName, queryTypes),\n        body: requestBody,\n      },\n      response: {\n        body: this.parseOperationResponse(responseBodyTypeName, operation.responses),\n      },\n    };\n  }\n\n  protected wrapParameters(name: string, types?: TypeList): TypeOrigin | undefined {", "    if (!types) return;\n    if (types.length === 0) return;\n\n    return {\n      kind: 'origin',\n      name,\n      type: 'object',\n      // \u6709\u4e00\u4e2a\u5fc5\u586b\u5c5e\u6027\u65f6\uff0c\u5219\u8be5\u5bf9\u8c61\u5fc5\u586b\n      required: types.some((type) => (this.isTypeAlias(type) ? true : type.required)),\n      children: types,\n    };\n  }\n\n  protected parseOperationParameters(parameters: OpenAPIV3.OperationObject['parameters'] = []) {\n    const pathTypes: TypeList = [];\n    const queryTypes: TypeList = [];\n\n    parameters.forEach((parameter) => {\n      const t = this.parseOperationParameter(parameter);\n", "      if (!t) return;\n      if (!('in' in parameter)) return;\n\n      if (parameter.in === 'path') {\n        pathTypes.push(t);\n      } else if (parameter.in === 'query') {\n        queryTypes.push(t);\n      }\n    });\n\n    return { pathTypes, queryTypes };\n  }\n\n  protected parseOperationParameter(parameter: OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject) {", "    if (this.isReference(parameter)) return;\n\n    const { schema, name, required = false, deprecated, description, example } = parameter;\n    if (!schema) return;\n\n    return this.isReference(schema)\n      ? this.parseReference(name, required, schema)\n      : this.parseSchema(name, required, {\n          deprecated,\n          description,\n          example,\n          ...schema,\n        });\n  }\n\n  parseOperationRequest(name: string, body: OpenAPIV3.OperationObject['requestBody']): TypeItem | undefined {", "    if (!body) return;\n    if (this.isReference(body)) return;\n\n    const { content } = body;\n    const jsonReq = content[JSON_MIME];\n    const blobReq = content[BLOB_MIME];\n\n    if (jsonReq) return this.parseOperationMedia(name, jsonReq);\n    if (blobReq)\n      return {\n        kind: 'alias',\n        name,\n        refAble: false,\n        required: true,\n        target: 'Blob',\n        origin: 'Blob',\n        props: [],\n      };\n  }\n\n  protected parseOperationResponse(name: string, responses: NonNullable<OpenAPIV3.ResponsesObject>) {\n    const okResponse = responses[this.options.okCode];\n", "    if (blobReq)\n      return {\n        kind: 'alias',\n        name,\n        refAble: false,\n        required: true,\n        target: 'Blob',\n        origin: 'Blob',\n        props: [],\n      };\n  }\n\n  protected parseOperationResponse(name: string, responses: NonNullable<OpenAPIV3.ResponsesObject>) {\n    const okResponse = responses[this.options.okCode];\n", "    if (!okResponse) return;\n    if (this.isReference(okResponse)) return;\n\n    const { content } = okResponse;\n    if (!content) return;\n\n    const okMedia = content[this.options.okMediaType];\n    if (!okMedia) return;\n\n    return this.parseOperationMedia(name, okMedia);\n  }\n\n  protected parseOperationMedia(name: string, media: OpenAPIV3.MediaTypeObject) {\n    const { schema } = media;\n", "    if (!schema) return this.parseSchemaNever(name, true, {});\n\n    return this.isReference(schema)\n      ? this.parseReference(name, true, schema)\n      : this.parseSchema(name, schema.nullable === false, schema);\n  }\n}\n"]}
{"filename": "src/parsers/ComponentsParser.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\nimport { isBoolean } from '../utils/type-is';\nimport { BaseParser } from './BaseParser';\nimport type { TypeAlias, TypeItem, TypeList, TypeOrigin, TypeUnit } from './types';\n\nexport class ComponentsParser extends BaseParser {\n  parseComponents(): TypeList {\n    const { components } = this.document;\n\n    if (!components) return [];\n\n    const { schemas } = components;\n", "    if (!components) return [];\n\n    const { schemas } = components;\n\n    if (!schemas) return [];\n\n    const t = Object.entries(schemas)\n      .sort((a, b) => a[0].localeCompare(b[0]))\n      .map(([name, schema]) => {\n        const typeName = this.named.nextTypeName(name, true);\n        return this.isReference(schema)\n          ? this.parseReference(typeName, true, schema, true)\n          : this.parseSchema(typeName, schema.nullable === false, schema);\n      });\n    this.named.resolveAlias();\n    return t;\n  }\n\n  protected parseReference(\n    name: string,\n    required: boolean,\n    reference: OpenAPIV3.ReferenceObject,\n    refAble = false\n  ): TypeAlias {\n    return this.named.addAlias({\n      kind: 'alias',\n      refAble,\n      name,\n      required,\n      ref: reference.$ref,\n      target: '',\n      origin: '',\n      props: [],\n    });\n  }\n\n  protected parseSchema(name: string, required: boolean, schema: OpenAPIV3.SchemaObject) {\n    const { type } = schema;\n\n    switch (type) {\n      case 'boolean':\n      case 'string':\n      case 'number':\n      case 'integer': {\n        const tsType = type === 'integer' ? 'number' : type;\n        return this.parseSchemaPrimitive(name, required, tsType, schema);\n      }\n\n      case 'object':\n        return this.parseSchemaObject(name, required, schema);\n\n      case 'array':\n        return this.parseSchemaArray(name, required, schema);\n\n      default:\n        return this.parseSchemaNever(name, true, schema);\n    }\n  }\n\n  protected parseSchemaPrimitive(\n    name: string,\n    required: boolean,\n    type: TypeUnit,\n    schema: OpenAPIV3.SchemaObject\n  ): TypeOrigin {\n    return {\n      ...this.inheritProps(schema),\n      name,\n      type,\n      required,\n      kind: 'origin',\n    };\n  }\n\n  protected parseSchemaObject(name: string, required: boolean, schema: OpenAPIV3.SchemaObject): TypeOrigin {\n    const properties = Object.entries(schema.properties || {}).sort((a, b) => a[0].localeCompare(b[0]));\n    const children = properties.map(([propName, propSchema]) => {\n      const required = schema.required?.includes(propName) || false;\n      return this.isReference(propSchema)\n        ? this.parseReference(propName, required, propSchema)\n        : this.parseSchema(propName, required, propSchema);\n    });\n\n    const additional = this.parseObjectAdditionalProperties(schema.additionalProperties);", "    if (additional) children.push(additional);\n\n    return {\n      ...this.inheritProps(schema),\n      name,\n      required,\n      kind: 'origin',\n      type: 'object',\n      children,\n    };\n  }\n\n  protected parseSchemaArray(name: string, required: boolean, schema: OpenAPIV3.ArraySchemaObject): TypeOrigin {\n    const children = [schema.items].map((schema) => {\n      return this.isReference(schema)\n        ? this.parseReference(`${name}[]`, true, schema)\n        : this.parseSchema(`${name}[]`, schema.nullable === false, schema);\n    });\n\n    const additional = this.parseObjectAdditionalProperties(schema.additionalProperties);", "    if (additional) children.push(additional);\n\n    return {\n      ...this.inheritProps(schema),\n      name,\n      required,\n      kind: 'origin',\n      type: 'array',\n      children: children,\n    };\n  }\n\n  protected parseObjectAdditionalProperties(\n    additionalProperties: OpenAPIV3.SchemaObject['additionalProperties']\n  ): TypeItem | undefined {", "    if (!additionalProperties) return;\n\n    const name = '[key: string]';\n\n    if (isBoolean(additionalProperties)) {\n      if (additionalProperties) {\n        return {\n          kind: 'origin',\n          type: 'any',\n          name,\n          required: true,\n        };\n      }\n      return;\n    }\n\n    return this.isReference(additionalProperties)\n      ? this.parseReference(name, true, additionalProperties)\n      : this.parseSchema(name, true, additionalProperties);\n  }\n\n  protected parseSchemaNever(name: string, required: boolean, schema: OpenAPIV3.SchemaObject): TypeOrigin {\n    return {\n      ...this.inheritProps(schema),\n      name,\n      required,\n      kind: 'origin',\n      type: 'never',\n    };\n  }\n\n  private inheritProps(schema: OpenAPIV3.BaseSchemaObject) {\n    return {\n      default: schema.default,\n      description: schema.description,\n      example: schema.example,\n      deprecated: schema.deprecated,\n      title: schema.title,\n      format: schema.format,\n      enum: schema.enum,\n    };\n  }\n}\n"]}
{"filename": "src/parsers/Named.ts", "chunked_list": ["import { buildName, findOrigin, nextUniqueName, refToType } from '../utils/string';\nimport type { TypeAlias } from './types';\n\nexport class Named {\n  private aliasRelationMap = new Map<string /*source*/, string /*target*/>();\n  private unresolvedAliasList: TypeAlias[] = [];\n  addAlias(a: TypeAlias): TypeAlias {\n    this.unresolvedAliasList.push(a);\n    return a;\n  }\n  resolveAlias() {\n    this.unresolvedAliasList.forEach((a) => {", "      if (!a.ref) return;\n\n      const info = refToType(a.ref);\n      a.target = this.getName(info.base);\n      a.props = info.props;\n\n      // \u6307\u5411\u53e6\u5916\u4e00\u4e2a\u5730\u5740\n      const { refAble, name, target } = a;\n      if (refAble) {\n        this.aliasRelationMap.set(name, target);\n      }\n    });\n\n    this.unresolvedAliasList.forEach((a) => {\n      a.origin = findOrigin(a.refAble ? a.name : a.target, this.aliasRelationMap);\n    });\n\n    this.unresolvedAliasList.length = 0;\n  }\n\n  nameCountMap = new Map<string /*name*/, number /*count*/>();\n  nameRefMap = new Map<string /*name*/, string /*ref*/>();\n  refNameMap = new Map<string /*ref*/, string /*name*/>();\n\n  /**\n   * \u6ce8\u518c\u5185\u90e8\u540d\u79f0\n   * @param {string} name\n   */\n  internalName(name: string) {\n    this.nameCountMap.set(name, 1);\n  }\n\n  nextTypeName(name: string, refAble = false) {\n    const ref = refAble ? `#/components/schemas/${name}` : '';\n    const refTypeName = buildName(name, true);\n    const uniqueTypeName = nextUniqueName(refTypeName, this.nameCountMap);\n", "      if (refAble) {\n        this.aliasRelationMap.set(name, target);\n      }\n    });\n\n    this.unresolvedAliasList.forEach((a) => {\n      a.origin = findOrigin(a.refAble ? a.name : a.target, this.aliasRelationMap);\n    });\n\n    this.unresolvedAliasList.length = 0;\n  }\n\n  nameCountMap = new Map<string /*name*/, number /*count*/>();\n  nameRefMap = new Map<string /*name*/, string /*ref*/>();\n  refNameMap = new Map<string /*ref*/, string /*name*/>();\n\n  /**\n   * \u6ce8\u518c\u5185\u90e8\u540d\u79f0\n   * @param {string} name\n   */\n  internalName(name: string) {\n    this.nameCountMap.set(name, 1);\n  }\n\n  nextTypeName(name: string, refAble = false) {\n    const ref = refAble ? `#/components/schemas/${name}` : '';\n    const refTypeName = buildName(name, true);\n    const uniqueTypeName = nextUniqueName(refTypeName, this.nameCountMap);\n", "    if (ref) {\n      this.nameRefMap.set(uniqueTypeName, ref);\n      this.refNameMap.set(ref, uniqueTypeName);\n    }\n\n    return uniqueTypeName;\n  }\n\n  getName(ref: string) {\n    return this.refNameMap.get(ref) || '';\n  }\n\n  nextOperationId(method: string, url: string, operationId?: string) {\n    operationId = operationId || buildName([method, url.split('/').pop()!].join('_'));\n    return nextUniqueName(operationId, this.nameCountMap);\n  }\n}\n"]}
{"filename": "src/parsers/types.ts", "chunked_list": ["import type { OpenAPIV3Document } from '../types/openapi';\n\nexport type TypeUnit = 'number' | 'string' | 'boolean' | 'never' | 'object' | 'array' | 'any';\n\nexport interface TypeComments {\n  title?: string;\n  description?: string;\n  default?: any;\n  example?: any;\n  deprecated?: boolean;\n  format?: string;\n}\n", "export interface TypeOrigin extends TypeComments {\n  kind: 'origin';\n  name: string;\n  type: TypeUnit;\n  required: boolean;\n  enum?: string[];\n  children?: TypeList;\n}\n\nexport interface TypeAlias extends TypeComments {\n  kind: 'alias';\n  refAble: boolean;\n  required: boolean;\n  name: string;\n  target: string;\n  origin: string;\n  props: string[];\n  ref?: string;\n}\n", "export interface TypeAlias extends TypeComments {\n  kind: 'alias';\n  refAble: boolean;\n  required: boolean;\n  name: string;\n  target: string;\n  origin: string;\n  props: string[];\n  ref?: string;\n}\n", "export type TypeItem = TypeOrigin | TypeAlias;\nexport type TypeList = TypeItem[];\n\nexport interface NameFormatterProps {\n  name: string;\n  method: string;\n  url: string;\n  operationId?: string;\n}\n\nexport interface ParserOptions {\n  cwd?: string;\n\n  /**\n   * ok \u7684\u54cd\u5e94\u7801\n   * @default 200\n   */\n  okCode?: number;\n\n  /**\n   * ok \u7684\u54cd\u5e94\u7c7b\u578b\n   * @default [\"application/json\"]\n   */\n  okMediaType?: string;\n\n  nameFormatter?: (props: NameFormatterProps) => string;\n  requestPathTypeName?: string;\n  requestQueryTypeName?: string;\n  requestBodyTypeName?: string;\n  responseBodyTypeName?: string;\n}\n", "export interface ParserOptions {\n  cwd?: string;\n\n  /**\n   * ok \u7684\u54cd\u5e94\u7801\n   * @default 200\n   */\n  okCode?: number;\n\n  /**\n   * ok \u7684\u54cd\u5e94\u7c7b\u578b\n   * @default [\"application/json\"]\n   */\n  okMediaType?: string;\n\n  nameFormatter?: (props: NameFormatterProps) => string;\n  requestPathTypeName?: string;\n  requestQueryTypeName?: string;\n  requestBodyTypeName?: string;\n  responseBodyTypeName?: string;\n}\n", "export type StrictParserOptions = Required<ParserOptions>;\n\nexport interface TypeOperation extends TypeComments {\n  method: string;\n  url: string;\n  name: string;\n  request: {\n    path?: TypeItem;\n    query?: TypeItem;\n    body?: TypeItem;\n  };\n  response: {\n    body?: TypeItem;\n  };\n}\n", "export type TypeOperations = TypeOperation[];\n\nexport interface TypeDocument {\n  info: {\n    title: string;\n    description?: string;\n    version: string;\n    baseURL?: string;\n  };\n  components: TypeList;\n  paths: TypeOperations;\n}\n", "export type AcceptDocument = OpenAPIV3Document | string;\n"]}
{"filename": "src/parsers/const.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\nexport const HTTP_METHODS: OpenAPIV3.HttpMethods[] = [\n  OpenAPIV3.HttpMethods.DELETE,\n  OpenAPIV3.HttpMethods.GET,\n  OpenAPIV3.HttpMethods.HEAD,\n  OpenAPIV3.HttpMethods.OPTIONS,\n  OpenAPIV3.HttpMethods.PATCH,\n  OpenAPIV3.HttpMethods.POST,\n  OpenAPIV3.HttpMethods.PUT,", "  OpenAPIV3.HttpMethods.POST,\n  OpenAPIV3.HttpMethods.PUT,\n  OpenAPIV3.HttpMethods.TRACE,\n];\n\nexport const JSON_MIME = 'application/json';\nexport const BLOB_MIME = 'application/octet-stream';\n\n// \u5185\u90e8\u540d\u79f0\uff0c\u6587\u6863\u91cc\u5982\u679c\u91cd\u590d\u4e86\u4f1a\u751f\u6210\u65b0\u7684\u552f\u4e00\u503c\nexport const INTERNAL_NAMES = [", "// \u5185\u90e8\u540d\u79f0\uff0c\u6587\u6863\u91cc\u5982\u679c\u91cd\u590d\u4e86\u4f1a\u751f\u6210\u65b0\u7684\u552f\u4e00\u503c\nexport const INTERNAL_NAMES = [\n  // native\n  'Blob',\n  // @ref ComponentsWriter\n  'OneOf',\n  // @ref PathsWriter\n  'axios',\n  'request',\n  'DELETE',", "  'request',\n  'DELETE',\n  'GET',\n  'HEAD',\n  'OPTIONS',\n  'PATCH',\n  'POST',\n  'PUT',\n  'TRACE',\n  'resolveURL',", "  'TRACE',\n  'resolveURL',\n  'BASE_URL',\n  'AxiosPromise',\n  'AxiosRequestConfig',\n];\n\n// @ref https://www.w3schools.com/js/js_reserved.asp\nexport const JS_RESERVED_NAMES = [\n  'abstract',", "export const JS_RESERVED_NAMES = [\n  'abstract',\n  'arguments',\n  'await',\n  'boolean',\n  'break',\n  'byte',\n  'case',\n  'catch',\n  'char',", "  'catch',\n  'char',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'double',", "  'do',\n  'double',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'final',\n  'finally',", "  'final',\n  'finally',\n  'float',\n  'for',\n  'function',\n  'goto',\n  'if',\n  'implements',\n  'import',\n  'in',", "  'import',\n  'in',\n  'instanceof',\n  'int',\n  'interface',\n  'let',\n  'long',\n  'native',\n  'new',\n  'null',", "  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'short',\n  'static',\n  'super',", "  'static',\n  'super',\n  'switch',\n  'synchronized',\n  'this',\n  'throw',\n  'throws',\n  'transient',\n  'true',\n  'try',", "  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'volatile',\n  'while',\n  'with',\n  'yield',\n  'abstract',", "  'yield',\n  'abstract',\n  'boolean',\n  'byte',\n  'char',\n  'double',\n  'final',\n  'float',\n  'goto',\n  'int',", "  'goto',\n  'int',\n  'long',\n  'native',\n  'short',\n  'synchronized',\n  'throws',\n  'transient',\n  'volatile',\n];", "  'volatile',\n];\n"]}
{"filename": "src/parsers/BaseParser.ts", "chunked_list": ["import process from 'process';\nimport type { OpenAPIV3, OpenAPIV3Document } from '../types/openapi';\nimport { INTERNAL_NAMES, JS_RESERVED_NAMES, JSON_MIME } from './const';\nimport { Named } from './Named';\nimport type { ParserOptions, StrictParserOptions, TypeAlias, TypeItem } from './types';\n\nexport class BaseParser {\n  named = new Named();\n\n  static defaults: StrictParserOptions = {\n    cwd: process.cwd(),\n    okCode: 200,\n    okMediaType: JSON_MIME,\n    nameFormatter: ({ name }) => name,\n    requestPathTypeName: 'ReqPath',\n    requestQueryTypeName: 'ReqParams',\n    requestBodyTypeName: 'ReqData',\n    responseBodyTypeName: 'ResData',\n  };\n\n  options: StrictParserOptions;\n\n  constructor(protected document: OpenAPIV3Document, options?: ParserOptions) {\n    this.options = Object.assign({}, BaseParser.defaults, options) as StrictParserOptions;\n    INTERNAL_NAMES.forEach(this.named.internalName.bind(this.named));\n    JS_RESERVED_NAMES.forEach(this.named.internalName.bind(this.named));\n    this.init();\n  }\n\n  protected init() {\n    //\n  }\n\n  protected isReference(\n    object: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject | OpenAPIV3.ParameterObject | OpenAPIV3.RequestBodyObject\n  ): object is OpenAPIV3.ReferenceObject {\n    return '$ref' in object;\n  }\n", "  protected isTypeAlias(type: TypeItem): type is TypeAlias {\n    return type.kind === 'alias';\n  }\n}\n"]}
{"filename": "src/parsers/DocumentParser.ts", "chunked_list": ["import { PathsParser } from './PathsParser';\nimport type { TypeDocument } from './types';\n\nexport class DocumentParser extends PathsParser {\n  parse(): TypeDocument {\n    const components = this.parseComponents();\n    const paths = this.parsePaths();\n    const { info, servers } = this.document;\n    const firstServer = servers?.[0];\n    const baseURL = firstServer && firstServer.url;\n    const { title, description, version } = info;\n\n    return {\n      info: {\n        title: title,\n        description: description,\n        version: version,\n        baseURL,\n      },\n      components,\n      paths,\n    };\n  }\n}\n"]}
{"filename": "src/types/process.env.d.ts", "chunked_list": ["// @ref https://bobbyhadz.com/blog/typescript-process-env-type\n\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      // package name\n      PKG_NAME: string;\n\n      // package version\n      PKG_VERSION: string;\n    }\n  }\n}\n\nexport {};\n"]}
{"filename": "src/types/openapi.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\nexport { OpenAPIV3 };\nexport type OpenAPIV3Document = OpenAPIV3.Document;\n"]}
