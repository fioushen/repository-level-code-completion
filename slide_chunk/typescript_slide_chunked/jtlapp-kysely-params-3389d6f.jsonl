{"filename": "src/index.ts", "chunked_list": ["export * from './lib/parameterizer.js';\nexport * from './lib/parameterized-query.js';\nexport * from './lib/parameterized-value.js';\n"]}
{"filename": "src/utils/test-setup.ts", "chunked_list": ["import Sqlite3 from 'better-sqlite3';\nimport { Kysely, SqliteDialect } from 'kysely';\n\nimport { Database, createTables, dropTables } from './test-tables.js';\n\nexport async function createDB() {\n  return new Kysely<Database>({\n    dialect: new SqliteDialect({\n      database: new Sqlite3(':memory:'),\n    }),\n  });\n}\n", "export async function resetDB(db: Kysely<Database>) {\n  await dropTables(db);\n  await createTables(db);\n}\n\nexport async function destroyDB<DB>(db: Kysely<DB>) {\n  return db.destroy();\n}\n"]}
{"filename": "src/utils/test-utils.ts", "chunked_list": ["/**\n * Embeds code that will never run within a callback. Useful for\n * testing expected type errors.\n * @param description Description of the code that will never run\n * @param callback Callback that will never run\n */\nexport function ignore(_description: string, _: () => void) {}\n"]}
{"filename": "src/utils/test-tables.ts", "chunked_list": ["import { Kysely, Generated } from 'kysely';\n\n// list tables after those they depend on\nconst TABLE_NAMES = ['users'];\n\nexport interface Database {\n  users: Users;\n}\n\nexport interface Users {\n  id: Generated<number>;\n  handle: string;\n  name: string;\n  nickname: string | null;\n  birthYear: number | null;\n}\n", "export interface Users {\n  id: Generated<number>;\n  handle: string;\n  name: string;\n  nickname: string | null;\n  birthYear: number | null;\n}\n\nexport async function createTables(db: Kysely<Database>) {\n  await db.schema\n    .createTable('users')\n    .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())\n    .addColumn('handle', 'varchar(255)', (col) => col.notNull())\n    .addColumn('name', 'varchar(255)', (col) => col.notNull())\n    .addColumn('nickname', 'varchar(255)')\n    .addColumn('birthYear', 'integer')\n    .execute();\n\n  return db;\n}\n", "export async function createTables(db: Kysely<Database>) {\n  await db.schema\n    .createTable('users')\n    .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())\n    .addColumn('handle', 'varchar(255)', (col) => col.notNull())\n    .addColumn('name', 'varchar(255)', (col) => col.notNull())\n    .addColumn('nickname', 'varchar(255)')\n    .addColumn('birthYear', 'integer')\n    .execute();\n\n  return db;\n}\n", "export async function dropTables(db: Kysely<Database>): Promise<void> {\n  for (const table of TABLE_NAMES) {\n    await db.schema.dropTable(table).ifExists().execute();\n  }\n}\n"]}
{"filename": "src/tests/delete-params.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from '../utils/test-setup';\nimport { Database } from '../utils/test-tables';\nimport { ignore } from '../utils/test-utils';\nimport { parameterizeQuery } from '../lib/parameterizer';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {", "\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\nconst user1 = {\n  name: 'John Smith',\n  nickname: 'Johnny',", "  name: 'John Smith',\n  nickname: 'Johnny',\n  handle: 'jsmith',\n  birthYear: 1980,\n};\nconst user2 = {\n  name: 'John McSmith',\n  nickname: 'Johnny',\n  handle: 'jmsmith',\n  birthYear: 1990,", "  handle: 'jmsmith',\n  birthYear: 1990,\n};\nconst user3 = {\n  name: 'Jane Doe',\n  nickname: 'Jane',\n  handle: 'jdoe',\n  birthYear: 1990,\n};\n", "};\n\nit('instantiates deletions, with multiple executions', async () => {\n  interface Params {\n    targetNickname: string;\n    targetBirthYear: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.deleteFrom('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .where('nickname', '=', param('targetNickname'))\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n\n  // First execution\n\n  const compiledQuery1 = parameterization.instantiate({\n    targetNickname: user2.nickname,\n    targetBirthYear: user2.birthYear,\n  });\n  const result1 = await db.executeQuery(compiledQuery1);\n  expect(Number(result1?.numAffectedRows)).toEqual(1);\n\n  // Second execution\n\n  const compiledQuery2 = parameterization.instantiate({\n    targetNickname: user3.nickname,\n    targetBirthYear: user3.birthYear,\n  });\n  const result2 = await db.executeQuery(compiledQuery2);\n  expect(Number(result2?.numAffectedRows)).toEqual(1);\n\n  // Verify that the correct rows were deleted\n\n  const results = await db.selectFrom('users').selectAll().execute();\n  expect(results).toEqual([{ ...user1, id: 1 }]);\n});\n\nit('parameterizes deletions, with multiple executions', async () => {", "  interface Params {\n    targetNickname: string;\n    targetBirthYear: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  // First execution\n\n  const parameterization = parameterizeQuery(\n    db.deleteFrom('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .where('nickname', '=', param('targetNickname'))\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n  const result1 = await parameterization.execute(db, {\n    targetNickname: user2.nickname,\n    targetBirthYear: user2.birthYear,\n  });\n  expect(Number(result1?.numAffectedRows)).toEqual(1);\n\n  // Second execution\n\n  const result2 = await parameterization.execute(db, {\n    targetNickname: user3.nickname,\n    targetBirthYear: user3.birthYear,\n  });\n  expect(Number(result2?.numAffectedRows)).toEqual(1);\n\n  // Verify that the correct rows were deleted\n\n  const results = await db.selectFrom('users').selectAll().execute();\n  expect(results).toEqual([{ ...user1, id: 1 }]);\n});\n\nit('parameterizes deletions using \"in\" operator', async () => {", "  interface Params {\n    targetNickname: string;\n    targetBirthYear1: number;\n    targetBirthYear2: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.deleteFrom('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .where('nickname', '=', param('targetNickname'))\n      .where('birthYear', 'in', [\n        param('targetBirthYear1'),\n        param('targetBirthYear2'),\n      ])\n  );\n  const results = await parameterization.execute(db, {\n    targetNickname: user2.nickname,\n    targetBirthYear1: 1980,\n    targetBirthYear2: 1990,\n  });\n  expect(Number(results?.numAffectedRows)).toEqual(2);\n\n  const users = await db.selectFrom('users').selectAll().execute();\n  expect(users).toEqual([{ ...user3, id: 3 }]);\n});\n\nit('parameterizes without defined parameters', async () => {\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(db.deleteFrom('users')).asFollows(\n    ({ qb }) => qb.where('birthYear', '=', 1990)\n  );\n  const results = await parameterization.execute(db, {});\n  expect(Number(results?.numAffectedRows)).toEqual(2);\n\n  const users = await db.selectFrom('users').selectAll().execute();\n  expect(users).toEqual([{ ...user1, id: 1 }]);\n});\n\nignore('array parameters are not allowed', () => {", "  interface InvalidParams {\n    targetBirthYears: number[];\n  }\n  // @ts-expect-error - invalid parameter type\n  parameterizeQuery(db.deleteFrom('users')).asFollows<InvalidParams>(\n    ({ qb, param }) => qb.where('birthYear', 'in', param('targetBirthYears'))\n  );\n});\n\nignore('disallows incompatible parameter types', () => {\n  interface InvalidParams {\n    targetHandle: number;\n  }\n  parameterizeQuery(db.deleteFrom('users')).asFollows<InvalidParams>(\n    // @ts-expect-error - invalid parameter type\n    ({ qb, param }) => qb.where('handle', '=', param('targetHandle'))\n  );\n});\n\nignore('restricts provided parameters', async () => {", "  interface InvalidParams {\n    targetHandle: number;\n  }\n  parameterizeQuery(db.deleteFrom('users')).asFollows<InvalidParams>(\n    // @ts-expect-error - invalid parameter type\n    ({ qb, param }) => qb.where('handle', '=', param('targetHandle'))\n  );\n});\n\nignore('restricts provided parameters', async () => {\n  interface ValidParams {\n    targetHandle: string;\n    targetBirthYear: number;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.deleteFrom('users')\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb\n      .where('handle', '=', param('targetHandle'))\n      .where('name', '=', 'John Smith')\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {});\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {});\n});\n", "  interface ValidParams {\n    targetHandle: string;\n    targetBirthYear: number;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.deleteFrom('users')\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb\n      .where('handle', '=', param('targetHandle'))\n      .where('name', '=', 'John Smith')\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {});\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {});\n});\n"]}
{"filename": "src/tests/update-params.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from '../utils/test-setup';\nimport { Database } from '../utils/test-tables';\nimport { ignore } from '../utils/test-utils';\nimport { parameterizeQuery } from '../lib/parameterizer';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {", "\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\nconst user1 = {\n  name: 'John Smith',\n  nickname: 'Johnny',", "  name: 'John Smith',\n  nickname: 'Johnny',\n  handle: 'jsmith',\n  birthYear: 1980,\n};\nconst user2 = {\n  name: 'John McSmith',\n  nickname: 'Johnny',\n  handle: 'jmsmith',\n  birthYear: 1990,", "  handle: 'jmsmith',\n  birthYear: 1990,\n};\nconst user3 = {\n  name: 'Jane Doe',\n  nickname: 'Jane',\n  handle: 'jdoe',\n  birthYear: 1990,\n};\n", "};\n\nit(\"instantiates update values and 'where' selections, with multiple executions\", async () => {\n  interface Params {\n    toBirthYear: number;\n    whereNickname: string;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.updateTable('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .set({\n        birthYear: param('toBirthYear'),\n        handle: 'newHandle',\n      })\n      .where('nickname', '=', param('whereNickname'))\n  );\n\n  // First execution\n\n  const compiledQuery1 = parameterization.instantiate({\n    toBirthYear: 2000,\n    whereNickname: user2.nickname,\n  });\n  const result1 = await db.executeQuery(compiledQuery1);\n  expect(Number(result1?.numAffectedRows)).toEqual(2);\n\n  // Second execution\n\n  const compiledQuery2 = parameterization.instantiate({\n    toBirthYear: 2010,\n    whereNickname: user3.nickname,\n  });\n  const result2 = await db.executeQuery(compiledQuery2);\n  expect(Number(result2?.numAffectedRows)).toEqual(1);\n\n  const users = await db.selectFrom('users').selectAll().execute();\n  expect(users).toEqual([\n    { ...user1, id: 1, handle: 'newHandle', birthYear: 2000 },\n    { ...user2, id: 2, handle: 'newHandle', birthYear: 2000 },\n    { ...user3, id: 3, handle: 'newHandle', birthYear: 2010 },\n  ]);\n});\n\nit(\"parameterizes update values and 'where' selections, with multiple executions\", async () => {", "  interface Params {\n    toBirthYear: number;\n    whereNickname: string;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  // First execution\n\n  const parameterization = parameterizeQuery(\n    db.updateTable('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .set({\n        birthYear: param('toBirthYear'),\n        handle: 'newHandle',\n      })\n      .where('nickname', '=', param('whereNickname'))\n  );\n\n  const result1 = await parameterization.execute(db, {\n    toBirthYear: 2000,\n    whereNickname: user2.nickname,\n  });\n  expect(Number(result1.numAffectedRows)).toEqual(2);\n\n  // Second execution\n\n  const result2 = await parameterization.executeTakeFirst(db, {\n    toBirthYear: 2010,\n    whereNickname: user3.nickname,\n  });\n  expect(result2).toBeUndefined();\n\n  const users = await db.selectFrom('users').selectAll().execute();\n  expect(users).toEqual([\n    { ...user1, id: 1, handle: 'newHandle', birthYear: 2000 },\n    { ...user2, id: 2, handle: 'newHandle', birthYear: 2000 },\n    { ...user3, id: 3, handle: 'newHandle', birthYear: 2010 },\n  ]);\n});\n\nit('parameterizes update values accepting nulls', async () => {", "  interface Params {\n    toBirthYear: number | null;\n    whereNickname: string;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.updateTable('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .set({\n        birthYear: param('toBirthYear'),\n      })\n      .where('nickname', '=', param('whereNickname'))\n  );\n\n  const result1 = await parameterization.execute(db, {\n    toBirthYear: null,\n    whereNickname: user2.nickname,\n  });\n  expect(Number(result1.numAffectedRows)).toEqual(2);\n\n  const result2 = await parameterization.executeTakeFirst(db, {\n    toBirthYear: 2010,\n    whereNickname: user3.nickname,\n  });\n  expect(result2).toBeUndefined();\n\n  const users = await db.selectFrom('users').selectAll().execute();\n  expect(users).toEqual([\n    { ...user1, id: 1, birthYear: null },\n    { ...user2, id: 2, birthYear: null },\n    { ...user3, id: 3, birthYear: 2010 },\n  ]);\n});\n\nit('parameterizes without defined parameters', async () => {\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(db.updateTable('users')).asFollows(\n    ({ qb }) =>\n      qb\n        .set({\n          birthYear: 2000,\n          handle: 'newHandle',\n        })\n        .where('nickname', '=', 'Johnny')\n  );\n\n  const result1 = await parameterization.execute(db, {});\n\n  expect(Number(result1.numAffectedRows)).toEqual(2);\n\n  const users = await db.selectFrom('users').selectAll().execute();\n  expect(users).toEqual([\n    { ...user1, id: 1, handle: 'newHandle', birthYear: 2000 },\n    { ...user2, id: 2, handle: 'newHandle', birthYear: 2000 },\n    { ...user3, id: 3, handle: 'jdoe', birthYear: 1990 },\n  ]);\n});\n\nignore('disallows incompatible set parameter types', () => {", "  interface InvalidParams {\n    sourceHandle: number;\n    sourceName: string | null;\n  }\n\n  parameterizeQuery(db.updateTable('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.set({\n        //@ts-expect-error - invalid parameter type\n        handle: param('sourceHandle'),\n        name: 'John Smith',\n      })\n  );\n\n  parameterizeQuery(db.updateTable('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.set({\n        handle: 'jsmith',\n        //@ts-expect-error - invalid parameter type\n        name: param('sourceName'),\n      })\n  );\n});\n\nignore('restricts a set generated column parameter', async () => {", "  interface InvalidParams {\n    sourceId?: string;\n  }\n\n  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.values({\n        //@ts-expect-error - invalid parameter type\n        id: param('sourceId'),\n        name: 'John Smith',\n        handle: 'jsmith',\n      })\n  );\n});\n\nignore('array parameters are not allowed', () => {", "  interface InvalidParams {\n    targetBirthYears: number[];\n  }\n  parameterizeQuery(db.updateTable('users'))\n    // @ts-expect-error - invalid parameter type\n    .asFollows<InvalidParams>(({ qb, param }) =>\n      qb\n        .set({ nickname: 'newNickname' })\n        .where('birthYear', 'in', param('targetBirthYears'))\n    );\n});\n\nignore('disallows incompatible parameter types', () => {", "  interface InvalidParams {\n    targetHandle: number;\n  }\n  parameterizeQuery(db.updateTable('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb\n        .set({ nickname: 'newNickname' })\n        //@ts-expect-error - invalid parameter type\n        .where('handle', '=', param('targetHandle'))\n  );\n});\n\nignore('restricts provided parameters', async () => {", "  interface ValidParams {\n    targetHandle: string;\n    targetBirthYear: number;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.updateTable('users')\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb\n      .set({ nickname: 'newNickname' })\n      .where('handle', '=', param('targetHandle'))\n      .where('name', '=', 'John Smith')\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {});\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {});\n});\n"]}
{"filename": "src/tests/select-params.test.ts", "chunked_list": ["import { Kysely, sql } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from '../utils/test-setup';\nimport { Database } from '../utils/test-tables';\nimport { ignore } from '../utils/test-utils';\nimport { parameterizeQuery } from '../lib/parameterizer';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {", "\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\nconst user1 = {\n  name: 'John Smith',\n  nickname: 'Johnny',", "  name: 'John Smith',\n  nickname: 'Johnny',\n  handle: 'jsmith',\n  birthYear: 1980,\n};\nconst user2 = {\n  name: 'John McSmith',\n  nickname: 'Johnny',\n  handle: 'jmsmith',\n  birthYear: 1990,", "  handle: 'jmsmith',\n  birthYear: 1990,\n};\nconst user3 = {\n  name: 'Jane Doe',\n  // leave out nickname\n  handle: 'jdoe',\n  birthYear: 1990,\n};\n", "};\n\nit('instantiates \"where\" selections, with multiple executions', async () => {\n  interface Params {\n    targetNickname: string;\n    targetBirthYear: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .where('nickname', '=', param('targetNickname'))\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n\n  // First execution\n\n  const compiledQuery1 = parameterization.instantiate({\n    targetNickname: user2.nickname,\n    targetBirthYear: user2.birthYear,\n  });\n  const result1 = await db.executeQuery(compiledQuery1);\n  expect(result1?.rows).toEqual([{ ...user2, id: 2 }]);\n\n  // Second execution\n\n  const compiledQuery2 = parameterization.instantiate({\n    targetNickname: user2.nickname,\n    targetBirthYear: 1980,\n  });\n  const result2 = await db.executeQuery(compiledQuery2);\n  expect(result2?.rows).toEqual([{ ...user1, id: 1 }]);\n\n  // Allows constant parameters\n\n  const params = {\n    targetNickname: 'Jane' as const,\n    targetBirthYear: 1990 as const,\n  } as const;\n  parameterization.instantiate(params);\n});\n\nit('parameterizes \"where\" selections, with multiple executions', async () => {", "  interface Params {\n    targetNickname: string;\n    targetBirthYear: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  // First execution\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .where('nickname', '=', param('targetNickname'))\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n  const result1 = await parameterization.executeTakeFirst(db, {\n    targetNickname: user2.nickname,\n    targetBirthYear: user2.birthYear,\n  });\n  expect(result1).toEqual({ ...user2, id: 2 });\n  // Make sure we can address properties by name.\n  expect(result1?.name).toEqual(user2.name);\n\n  // Second execution\n\n  const result2 = await parameterization.executeTakeFirst(db, {\n    targetNickname: user2.nickname,\n    targetBirthYear: 1980,\n  });\n  expect(result2).toEqual({ ...user1, id: 1 });\n\n  // Allows constant parameters\n\n  const params = {\n    targetNickname: 'Jane' as const,\n    targetBirthYear: 1990 as const,\n  } as const;\n  parameterization.execute(db, params);\n  parameterization.executeTakeFirst(db, params);\n});\n\nit('parameterizes \"where\" selections for specific columns', async () => {", "  interface Params {\n    targetHandle: string;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').select('name')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.where('handle', '=', param('targetHandle'))\n  );\n  const result1 = await parameterization.executeTakeFirst(db, {\n    targetHandle: user3.handle,\n  });\n  expect(result1).toEqual({ name: user3.name });\n});\n\nit('parameterizes \"where\" selections using \"in\" operator', async () => {", "  interface Params {\n    targetNickname: string;\n    targetBirthYear1: number;\n    targetBirthYear2: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows<Params>(({ qb, param }) =>\n    qb\n      .where('nickname', '=', param('targetNickname'))\n      .where('birthYear', 'in', [\n        param('targetBirthYear1'),\n        param('targetBirthYear2'),\n      ])\n  );\n  const results = await parameterization.execute(db, {\n    targetNickname: user2.nickname,\n    targetBirthYear1: 1980,\n    targetBirthYear2: 1990,\n  });\n  expect(results.rows).toEqual([\n    { ...user1, id: 1 },\n    { ...user2, id: 2 },\n  ]);\n  // Make sure we can address properties by name.\n  expect(results.rows[0].name).toEqual(user1.name);\n});\n\nit('parameterizes values within a where expression', async () => {", "  interface Params {\n    targetNickname: string;\n    targetBirthYear1: number;\n    targetBirthYear2: number;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.where(({ and, cmpr }) =>\n      and([\n        cmpr('nickname', '=', param('targetNickname')),\n        cmpr('birthYear', 'in', [\n          param('targetBirthYear1'),\n          param('targetBirthYear2'),\n        ]),\n      ])\n    )\n  );\n  const results = await parameterization.execute(db, {\n    targetNickname: user2.nickname,\n    targetBirthYear1: 1980,\n    targetBirthYear2: 1990,\n  });\n  expect(results.rows).toEqual([\n    { ...user1, id: 1 },\n    { ...user2, id: 2 },\n  ]);\n});\n\nit('parameterizes values within a SQL expression', async () => {", "  interface Params {\n    targetName: string;\n  }\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.where(sql`name = ${param('targetName')}`)\n  );\n\n  // First execution\n\n  const results1 = await parameterization.execute(db, {\n    targetName: user1.name,\n  });\n  expect(results1.rows).toEqual([{ ...user1, id: 1 }]);\n\n  // Second execution\n\n  const results2 = await parameterization.execute(db, {\n    targetName: user2.name,\n  });\n  expect(results2.rows).toEqual([{ ...user2, id: 2 }]);\n});\n\nit('parameterizes without defined parameters', async () => {\n  await db.insertInto('users').values([user1, user2, user3]).execute();\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows(({ qb }) =>\n    qb\n      .where('nickname', '=', user2.nickname)\n      .where('birthYear', '=', user1.birthYear)\n  );\n  const result2 = await parameterization.executeTakeFirst(db, {});\n  expect(result2).toEqual({ ...user1, id: 1 });\n});\n\nignore('array parameters are not allowed', () => {", "  interface InvalidParams {\n    targetBirthYears: number[];\n  }\n  parameterizeQuery(\n    db.selectFrom('users').selectAll()\n    // @ts-expect-error - invalid parameter type\n  ).asFollows<InvalidParams>(({ qb, param }) =>\n    qb.where('birthYear', 'in', param('targetBirthYears'))\n  );\n});\n\nignore('disallows incompatible parameter types', () => {", "  interface InvalidParams {\n    targetHandle: number;\n  }\n  parameterizeQuery(db.selectFrom('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      //@ts-expect-error - invalid parameter type\n      qb.where('handle', '=', param('targetHandle'))\n  );\n  parameterizeQuery(db.selectFrom('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.where(({ or, cmpr }) =>\n        //@ts-expect-error - invalid parameter type\n        or([cmpr('handle', '=', param('targetHandle'))])\n      )\n  );\n});\n\nignore('disallows parameters in column positions', () => {", "  interface ValidParams {\n    targetHandle: string;\n  }\n\n  parameterizeQuery(db.selectFrom('users')).asFollows<ValidParams>(\n    ({ qb, param }) =>\n      // @ts-expect-error - invalid parameter position\n      qb.where(param('targetHandle'), '=', 'jsmith')\n  );\n\n  parameterizeQuery(db.selectFrom('users')).asFollows<ValidParams>(\n    ({ qb, param }) =>\n      qb.where(({ or, cmpr }) =>\n        or([\n          // @ts-expect-error - invalid parameter position\n          cmpr(param('targetHandle'), '=', 'jsmith'),\n          // @ts-expect-error - invalid parameter position\n          cmpr('birthYear', param('targetHandle'), 1980),\n        ])\n      )\n  );\n});\n\nignore('restricts provided parameters', async () => {", "  interface ValidParams {\n    targetHandle: string;\n    targetBirthYear: number;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users')\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb\n      .where('handle', '=', param('targetHandle'))\n      .where('name', '=', 'John Smith')\n      .where('birthYear', '=', param('targetBirthYear'))\n  );\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetBirthYear: '2020',\n    targetHandle: 'jsmith',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    targetHandle: null,\n  });\n\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {\n    targetBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {});\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {});\n});\n\nignore('restrict selected column names', async () => {", "  interface ValidParams {\n    targetHandle: string;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.selectFrom('users').selectAll()\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb.where('handle', '=', param('targetHandle'))\n  );\n\n  const result1 = await parameterization.executeTakeFirst(db, {\n    targetHandle: 'jsmith',\n  });\n  // @ts-expect-error - invalid returned column\n  expect(result1?.notThere).toEqual('John Smith');\n\n  const result2 = await parameterization.execute(db, {\n    targetHandle: 'jsmith',\n  });\n  const firstRow = result2.rows[0];\n  // @ts-expect-error - invalid returned column\n  expect(firstRow.notThere).toEqual('John Smith');\n});\n"]}
{"filename": "src/tests/insert-params.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\nimport { createDB, resetDB, destroyDB } from '../utils/test-setup';\nimport { Database } from '../utils/test-tables';\nimport { ignore } from '../utils/test-utils';\nimport { parameterizeQuery } from '../lib/parameterizer';\n\nlet db: Kysely<Database>;\n\nbeforeAll(async () => {", "\nbeforeAll(async () => {\n  db = await createDB();\n});\nbeforeEach(() => resetDB(db));\nafterAll(() => destroyDB(db));\n\nit('instantiates inserted strings and numbers', async () => {\n  interface Params {\n    sourceHandle: string;\n    sourceBirthYear: number | null;\n  }\n  const user = {\n    name: 'John Smith',\n    // leave out nickname\n    handle: 'jsmith',\n    birthYear: 1990,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.values({\n      handle: param('sourceHandle'),\n      name: user.name,\n      birthYear: param('sourceBirthYear'),\n    })\n  );\n  const compiledQuery = parameterization.instantiate({\n    sourceHandle: user.handle,\n    sourceBirthYear: user.birthYear,\n  });\n  const result = await db.executeQuery(compiledQuery);\n  expect(result?.rows).toEqual([{ id: 1 }]);\n\n  const readUser = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .executeTakeFirst();\n  expect(readUser).toEqual({ ...user, id: 1, nickname: null });\n});\n\nit('parameterizes inserted strings and numbers with non-null values', async () => {", "  interface Params {\n    sourceHandle: string;\n    sourceBirthYear: number | null;\n  }\n  const user = {\n    name: 'John Smith',\n    // leave out nickname\n    handle: 'jsmith',\n    birthYear: 1990,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.values({\n      handle: param('sourceHandle'),\n      name: user.name,\n      birthYear: param('sourceBirthYear'),\n    })\n  );\n  const compiledQuery = parameterization.instantiate({\n    sourceHandle: user.handle,\n    sourceBirthYear: user.birthYear,\n  });\n  const result = await db.executeQuery(compiledQuery);\n  expect(result?.rows).toEqual([{ id: 1 }]);\n\n  const readUser = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .executeTakeFirst();\n  expect(readUser).toEqual({ ...user, id: 1, nickname: null });\n});\n\nit('parameterizes inserted strings and numbers with non-null values', async () => {", "  interface Params {\n    sourceHandle: string;\n    sourceBirthYear: number | null;\n  }\n  const user = {\n    name: 'John Smith',\n    // leave out nickname\n    handle: 'jsmith',\n    birthYear: 1990,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.values({\n      handle: param('sourceHandle'),\n      name: user.name,\n      birthYear: param('sourceBirthYear'),\n    })\n  );\n  const result = await parameterization.executeTakeFirst(db, {\n    sourceHandle: user.handle,\n    sourceBirthYear: user.birthYear,\n  });\n\n  expect(result).toEqual({ id: 1 });\n  // Make sure we can address properties by name.\n  expect(result?.id).toBe(1);\n\n  const readUser = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .executeTakeFirst();\n  expect(readUser).toEqual({ ...user, id: 1, nickname: null });\n});\n\nit('parameterizes inserted strings and numbers with null values', async () => {", "  interface Params {\n    sourceNickname: string | null;\n    sourceBirthYear: number | null;\n  }\n  const user = {\n    name: 'John Smith',\n    nickname: null,\n    handle: 'jsmith',\n    birthYear: null,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.values({\n      handle: user.handle,\n      name: user.name,\n      nickname: param('sourceNickname'),\n      birthYear: param('sourceBirthYear'),\n    })\n  );\n  const result = await parameterization.executeTakeFirst(db, {\n    sourceNickname: user.nickname,\n    sourceBirthYear: user.birthYear,\n  });\n\n  expect(result).toEqual({ id: 1 });\n\n  const readUser = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .executeTakeFirst();\n  expect(readUser).toEqual({ ...user, id: 1 });\n});\n\nit('parameterizes a generated column, with multiple executions', async () => {", "  interface Params {\n    sourceId?: number;\n  }\n  const user = {\n    handle: 'jsmith',\n    name: 'John Smith',\n    nickname: null,\n    birthYear: null,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.values({\n      id: param('sourceId'),\n      name: user.name,\n      handle: user.handle,\n    })\n  );\n\n  // First execution not assigning generated column.\n\n  const result1 = await parameterization.executeTakeFirst(db, {});\n  expect(result1).toBeUndefined();\n  const readUser = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .executeTakeFirst();\n  expect(readUser).toEqual({ ...user, id: 1 });\n\n  // Second execution assigning generated column.\n\n  const result = await parameterization.executeTakeFirst(db, { sourceId: 100 });\n  expect(result).toBeUndefined();\n  const readUsers = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .execute();\n  expect(readUsers).toEqual([\n    { ...user, id: 1 },\n    { ...user, id: 100 },\n  ]);\n});\n\nit('parameterizes single query performing multiple insertions', async () => {", "  interface Params {\n    sourceName1and2: string;\n    sourceNickname1: string;\n    sourceBirthYear1: number;\n    sourceBirthYear2: number;\n  }\n  const user1 = {\n    name: 'John Smith',\n    nickname: 'Johny',\n    handle: 'jsmith1',\n    birthYear: 1990,\n  };\n  const user2 = {\n    name: 'John Smith',\n    nickname: null,\n    handle: 'jsmith2',\n    birthYear: 2000,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows<Params>(({ qb, param }) =>\n    qb.values([\n      {\n        handle: user1.handle,\n        name: param('sourceName1and2'),\n        nickname: param('sourceNickname1'),\n        birthYear: param('sourceBirthYear1'),\n      },\n      {\n        handle: user2.handle,\n        name: param('sourceName1and2'),\n        nickname: user2.nickname,\n        birthYear: user2.birthYear,\n      },\n    ])\n  );\n\n  const result = await parameterization.execute(db, {\n    sourceName1and2: user1.name,\n    sourceNickname1: user1.nickname,\n    sourceBirthYear1: user1.birthYear,\n    sourceBirthYear2: user2.birthYear,\n  });\n\n  expect(result.rows).toEqual([{ id: 1 }, { id: 2 }]);\n  // Make sure we can address properties by name.\n  expect(result?.rows[0].id).toBe(1);\n\n  const readUsers = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('name', '=', user1.name)\n    .execute();\n  expect(readUsers).toEqual([\n    { ...user1, id: 1 },\n    { ...user2, id: 2 },\n  ]);\n});\n\nit('parameterizes without defined parameters', async () => {\n  const user = {\n    name: 'John Smith',\n    nickname: null,\n    handle: 'jsmith',\n    birthYear: null,\n  };\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows(({ qb }) => qb.values(user));\n\n  const result = await parameterization.executeTakeFirst(db, {});\n  expect(result).toEqual({ id: 1 });\n\n  const readUser = await db\n    .selectFrom('users')\n    .selectAll()\n    .where('handle', '=', user.handle)\n    .executeTakeFirst();\n  expect(readUser).toEqual({ ...user, id: 1 });\n});\n\nignore('disallows incompatible parameter types', () => {", "  interface InvalidParams {\n    sourceHandle: number;\n    sourceName: string | null;\n  }\n\n  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.values({\n        //@ts-expect-error - invalid parameter type\n        handle: param('sourceHandle'),\n        name: 'John Smith',\n      })\n  );\n\n  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.values({\n        handle: 'jsmith',\n        //@ts-expect-error - invalid parameter type\n        name: param('sourceName'),\n      })\n  );\n});\n\nignore('restricts a generated column parameter', async () => {", "  interface InvalidParams {\n    sourceId?: string;\n  }\n\n  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n    ({ qb, param }) =>\n      qb.values({\n        //@ts-expect-error - invalid parameter type\n        id: param('sourceId'),\n        name: 'John Smith',\n        handle: 'jsmith',\n      })\n  );\n});\n\nignore('restricts provided parameters', async () => {", "  interface ValidParams {\n    sourceHandle: string;\n    sourceBirthYear: number | null;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users')\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb.values({\n      handle: param('sourceHandle'),\n      name: 'John Smith',\n      birthYear: param('sourceBirthYear'),\n    })\n  );\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter name\n    invalidParam: 'invalid',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    sourceBirthYear: '2020',\n    sourceHandle: 'jsmith',\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    sourceBirthYear: '2020',\n    sourceHandle: 'jsmith',\n  });\n\n  await parameterization.execute(db, {\n    //@ts-expect-error - invalid parameter type\n    sourceHandle: null,\n    sourceBirthYear: null,\n  });\n  await parameterization.executeTakeFirst(db, {\n    //@ts-expect-error - invalid parameter type\n    sourceHandle: null,\n    sourceBirthYear: null,\n  });\n\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {\n    sourceBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {\n    sourceBirthYear: 2020,\n  });\n  //@ts-expect-error - missing parameter name\n  await parameterization.execute(db, {});\n  //@ts-expect-error - missing parameter name\n  await parameterization.executeTakeFirst(db, {});\n});\n\nignore('restrict returned column names', async () => {", "  interface ValidParams {\n    sourceHandle: string;\n    sourceBirthYear: number | null;\n  }\n\n  const parameterization = parameterizeQuery(\n    db.insertInto('users').returning('id')\n  ).asFollows<ValidParams>(({ qb, param }) =>\n    qb.values({\n      handle: param('sourceHandle'),\n      name: 'John Smith',\n      birthYear: param('sourceBirthYear'),\n    })\n  );\n\n  const result1 = await parameterization.executeTakeFirst(db, {\n    sourceHandle: 'jsmith',\n    sourceBirthYear: 2020,\n  });\n  // @ts-expect-error - invalid column name\n  result1?.notThere;\n\n  const result2 = await parameterization.execute(db, {\n    sourceHandle: 'jsmith',\n    sourceBirthYear: 2020,\n  });\n  // @ts-expect-error - invalid column name\n  result2.rows[0]?.notThere;\n});\n"]}
{"filename": "src/lib/parameterized-value.ts", "chunked_list": ["/**\n * Class representing a parameter-specified value.\n * @paramtype P Record characterizing the parameter names and types.\n */\nexport class ParameterizedValue<P extends Record<string, any>> {\n  /**\n   * Creates a new parameter-specified value.\n   * @param parameterName Name of the parameter.\n   */\n  constructor(readonly parameterName: keyof P & string) {}\n}\n"]}
{"filename": "src/lib/parameterizer.ts", "chunked_list": ["import { Compilable } from 'kysely';\n\nimport { ParameterizedValue } from './parameterized-value.js';\nimport { ParameterizedQuery, ParametersObject } from './parameterized-query.js';\n\ntype QueryBuilderOutput<QB> = QB extends Compilable<infer O> ? O : never;\n\n/**\n * Creates and returns a parameterizer for the given query builder. The\n * provided query builder must designate any selected or returned columns\n * that you wish to be able to reference by name, as TypeScript will not\n * otherwise be aware of the columns being returned.\n * @paramtype O Type of the query result.\n * @paramtype QB Type of the source query builder.\n * @param qb The source query builder, which should establish any selected\n *  or returned columns you wish to be able to reference by name.\n * @returns Parameterizer for the given query builder, which can be used\n *  to create parameterized queries.\n */", "export function parameterizeQuery<\n  QB extends Compilable<O>,\n  O = QueryBuilderOutput<QB>\n>(qb: QB): QueryParameterizer<QB, O> {\n  return new QueryParameterizer(qb);\n}\n\n/**\n * Class for parameterizing queries.\n * @paramtype O Type of the query result.\n * @paramtype QB Type of the source query builder.\n */", "export class QueryParameterizer<\n  QB extends Compilable<O>,\n  O = QueryBuilderOutput<QB>\n> {\n  /**\n   * Creates a new parameterizer for the given query builder.\n   */\n  constructor(readonly qb: QB) {}\n\n  /**\n   * Creates and returns a parameterized query.\n   * @paramtype P Record characterizing the available parameter names and types.\n   * @param factory Function that receives an object of the form { qb, param }\n   *  and returns a query builder that may contain parameterized values.\n   * @returns Parameterized query.\n   */\n  asFollows<P extends ParametersObject<P>>(\n    factory: ParameterizedQueryFactory<P, QB, O>\n  ): ParameterizedQuery<P, O> {\n    const parameterMaker = new QueryParameterMaker<P>();\n    return new ParameterizedQuery(\n      factory({ qb: this.qb, param: parameterMaker.param.bind(parameterMaker) })\n    );\n  }\n}\n\n/**", " * Factory function for creating a parameterized query.\n * @paramtype O Type of the query result.\n * @paramtype P Record characterizing the available parameter names and types.\n * @paramtype QB Type of the source query builder.\n * @param args Object of the form { qb, param }, returning a query builder\n *  that may contain parameterized values.\n */\nexport interface ParameterizedQueryFactory<\n  P extends ParametersObject<P>,\n  QB extends Compilable<O>,\n  O = QueryBuilderOutput<QB>\n> {\n  (args: { qb: QB; param: QueryParameterMaker<P>['param'] }): Compilable<O>;\n}\n\n/**\n * Class for making occurrences of parameters within a query.\n * @paramtype P Record characterizing the available parameter names and types.\n */", "export class QueryParameterMaker<P> {\n  /**\n   * Returns a parameterized value.\n   * @param name Parameter name.\n   * @returns Parameter having the given name and the type assigned to that\n   *  name in P.\n   */\n  param<N extends keyof P & string>(name: N): P[N] {\n    return new ParameterizedValue(name) as unknown as P[N];\n  }\n}\n"]}
{"filename": "src/lib/parameterized-query.ts", "chunked_list": ["import { CompiledQuery, Compilable, Kysely, QueryResult } from 'kysely';\n\nimport { ParameterizedValue } from './parameterized-value.js';\n\n/**\n * Type for an object that defines the query parameters. It disallows the\n * object from having array properties.\n * @typeparam T Type that is to define the query parameters.\n */\nexport type ParametersObject<P> = {\n  [K in keyof P]: P[K] extends Array<any> ? never : P[K];\n};\n\n/**\n * Class representing a parameterized compiled query that can be repeatedly\n * executed or instantiated with different values for its parameters.\n * @paramtype P Record characterizing the parameter names and types.\n */", " */\nexport type ParametersObject<P> = {\n  [K in keyof P]: P[K] extends Array<any> ? never : P[K];\n};\n\n/**\n * Class representing a parameterized compiled query that can be repeatedly\n * executed or instantiated with different values for its parameters.\n * @paramtype P Record characterizing the parameter names and types.\n */\nexport class ParameterizedQuery<P extends ParametersObject<P>, O> {\n  #qb: Compilable<O> | null;\n  #compiledQuery?: CompiledQuery<O>;\n\n  /**\n   * Creates a new parameterized query from a query builder whose query\n   * arguments may contained parameterized values.\n   */\n  constructor(qb: Compilable<O>) {\n    this.#qb = qb;\n  }\n\n  /**\n   * Executes the query with all parameters replaced, returning all results.\n   * Compiles the query on the first call, caching the compiled query and\n   * discarding the underlying query builder to reduce memory used.\n   * @param db The Kysely database instance.\n   * @param params Object providing values for all parameters.\n   * @returns Query result.\n   */\n  execute<DB>(db: Kysely<DB>, params: Readonly<P>): Promise<QueryResult<O>> {\n    return db.executeQuery(this.instantiate(params));\n  }\n\n  /**\n   * Executes the query with all parameters replaced, returning the first\n   * result. Compiles the query on the first call, caching the compiled query\n   * and discarding the underlying query builder to reduce memory used.\n   * @param db The Kysely database instance.\n   * @param params Object providing values for all parameters.\n   * @returns First query result, or undefined if there are no results.\n   */\n  async executeTakeFirst<DB>(\n    db: Kysely<DB>,\n    params: Readonly<P>\n  ): Promise<O | undefined> {\n    const result = await db.executeQuery(this.instantiate(params));\n    return result.rows.length > 0 ? result.rows[0] : undefined;\n  }\n\n  /**\n   * Instantiates the query as a compiled query with all parameters replaced,\n   * returning the compiled query. Compiles the query on the first call,\n   * caching the uninstantiated compiled query and discarding the underlying\n   * query builder to reduce memory used.\n   * @param params Object providing values for all parameters.\n   * @returns Compiled query with values replacing all parameters.\n   */\n  instantiate(params: Readonly<P>): CompiledQuery<O> {", "export class ParameterizedQuery<P extends ParametersObject<P>, O> {\n  #qb: Compilable<O> | null;\n  #compiledQuery?: CompiledQuery<O>;\n\n  /**\n   * Creates a new parameterized query from a query builder whose query\n   * arguments may contained parameterized values.\n   */\n  constructor(qb: Compilable<O>) {\n    this.#qb = qb;\n  }\n\n  /**\n   * Executes the query with all parameters replaced, returning all results.\n   * Compiles the query on the first call, caching the compiled query and\n   * discarding the underlying query builder to reduce memory used.\n   * @param db The Kysely database instance.\n   * @param params Object providing values for all parameters.\n   * @returns Query result.\n   */\n  execute<DB>(db: Kysely<DB>, params: Readonly<P>): Promise<QueryResult<O>> {\n    return db.executeQuery(this.instantiate(params));\n  }\n\n  /**\n   * Executes the query with all parameters replaced, returning the first\n   * result. Compiles the query on the first call, caching the compiled query\n   * and discarding the underlying query builder to reduce memory used.\n   * @param db The Kysely database instance.\n   * @param params Object providing values for all parameters.\n   * @returns First query result, or undefined if there are no results.\n   */\n  async executeTakeFirst<DB>(\n    db: Kysely<DB>,\n    params: Readonly<P>\n  ): Promise<O | undefined> {\n    const result = await db.executeQuery(this.instantiate(params));\n    return result.rows.length > 0 ? result.rows[0] : undefined;\n  }\n\n  /**\n   * Instantiates the query as a compiled query with all parameters replaced,\n   * returning the compiled query. Compiles the query on the first call,\n   * caching the uninstantiated compiled query and discarding the underlying\n   * query builder to reduce memory used.\n   * @param params Object providing values for all parameters.\n   * @returns Compiled query with values replacing all parameters.\n   */\n  instantiate(params: Readonly<P>): CompiledQuery<O> {", "    if (this.#compiledQuery === undefined) {\n      this.#compiledQuery = this.#qb!.compile();\n      // Allow the query builder to be garbage collected.\n      this.#qb = null;\n    }\n    return {\n      query: this.#compiledQuery.query,\n      sql: this.#compiledQuery.sql,\n      parameters: this.#compiledQuery.parameters.map((value) =>\n        value instanceof ParameterizedValue\n          ? params[value.parameterName as keyof P]\n          : value\n      ),\n    };\n  }\n}\n"]}
