{"filename": "tests/didDocument.test.ts", "chunked_list": ["import { describe, it } from 'node:test'\nimport { DID_DOCUMENTS } from './fixtures/didDocuments'\nimport assert from 'node:assert'\nimport { createDidDocumentConstructTest } from './utils/createDidDocumentConstructTest'\nimport {\n  Did,\n  DidDocument,\n  VerificationMethod,\n  DidDocumentError,\n  VerificationMethodTypes,", "  DidDocumentError,\n  VerificationMethodTypes,\n  ServiceTypes,\n} from '../src'\nimport { ZodError } from 'zod'\n\ndescribe('Did Document', () => {\n  DID_DOCUMENTS.map(createDidDocumentConstructTest)\n\n  describe('Create did document with builder', () => {", "\n  describe('Create did document with builder', () => {\n    it('should create basic did document with the builder', () => {\n      const doc = new DidDocument({ id: 'did:example:123' })\n      assert.deepStrictEqual(doc.toJSON(), { id: 'did:example:123' })\n    })\n\n    it('should strip URL parts on `id` field', () => {\n      const doc = new DidDocument({ id: 'did:example:123#key-01' })\n      assert.deepStrictEqual(doc.toJSON(), { id: 'did:example:123' })", "      const doc = new DidDocument({ id: 'did:example:123#key-01' })\n      assert.deepStrictEqual(doc.toJSON(), { id: 'did:example:123' })\n    })\n\n    it('should show undefined properties', () => {\n      const doc = new DidDocument({ id: 'did:example:123', someField: 'a' })\n      assert.deepStrictEqual(doc.toJSON(), {\n        id: 'did:example:123',\n        someField: 'a',\n      })", "        someField: 'a',\n      })\n    })\n\n    it('should not show undefined properties, if specified inside the toJSON method', () => {\n      const doc = new DidDocument({ id: 'did:example:123', someField: 'a' })\n      assert.deepStrictEqual(doc.toJSON(['someField']), {\n        id: 'did:example:123',\n      })\n    })", "      })\n    })\n\n    it('should error when providing a DID URL for the `controller` field', () => {\n      assert.throws(\n        () =>\n          new DidDocument({\n            id: 'did:example:123',\n            controller: 'did:key:abc/path',\n          }),", "            controller: 'did:key:abc/path',\n          }),\n        ZodError\n      )\n    })\n\n    it('should error when providing both a `publicKeyJwk` and `publicKeyMultibase` in a verification method', () => {\n      assert.throws(\n        () =>\n          new DidDocument({", "        () =>\n          new DidDocument({\n            id: 'did:example:123',\n            verificationMethod: [\n              {\n                id: 'did:some:id',\n                type: 'verification',\n                controller: 'did:example:123',\n                publicKeyJwk: { kty: 'keyType' },\n                publicKeyMultibase: 'someMultibase',", "                publicKeyJwk: { kty: 'keyType' },\n                publicKeyMultibase: 'someMultibase',\n              },\n            ],\n          }),\n        ZodError\n      )\n    })\n\n    it('should create a more complex did document with the builder', () => {", "\n    it('should create a more complex did document with the builder', () => {\n      const doc = new DidDocument({ id: 'did:example:123' })\n        .addService({\n          id: 'some:uri',\n          type: ['a', 'b'],\n          serviceEndpoint: ['https://google.com', 'https://github.com'],\n        })\n        .addVerificationMethod({\n          id: new Did('did:example:123'),", "        .addVerificationMethod({\n          id: new Did('did:example:123'),\n          type: 'some-type',\n          controller: 'did:example:123',\n          publicKeyJwk: { kty: 'a' },\n        })\n        .addController(new Did('did:example:123'), true)\n        .addAlsoKnownAs('AKA')\n        .addKeyAgreementUnsafe(new Did('did:foo:bar'))\n        .addAssertionMethod('did:example:123')", "        .addKeyAgreementUnsafe(new Did('did:foo:bar'))\n        .addAssertionMethod('did:example:123')\n        .addAuthentication({\n          controller: 'did:me:123',\n          type: 'again-some-other-type',\n          id: 'did:cheese:bar',\n        })\n        .addCapabilityDelegation(\n          new VerificationMethod({\n            id: 'did:some:id',", "          new VerificationMethod({\n            id: 'did:some:id',\n            type: 'some-type',\n            controller: 'did:me:duh',\n          })\n        )\n        .addCapabilityInvocationUnsafe('did:me:duh')\n        .addAssertionMethod({\n          id: 'did:key:foobar',\n          type: 'a',", "          id: 'did:key:foobar',\n          type: 'a',\n          controller: 'did:example:123',\n        })\n\n      assert.deepStrictEqual(doc.toJSON(), {\n        id: 'did:example:123',\n        alsoKnownAs: ['AKA'],\n        controller: ['did:example:123'],\n        authentication: [", "        controller: ['did:example:123'],\n        authentication: [\n          {\n            controller: 'did:me:123',\n            type: 'again-some-other-type',\n            id: 'did:cheese:bar',\n          },\n        ],\n        verificationMethod: [\n          {", "        verificationMethod: [\n          {\n            id: 'did:example:123',\n            type: 'some-type',\n            controller: 'did:example:123',\n            publicKeyJwk: { kty: 'a' },\n          },\n        ],\n        assertionMethod: [\n          'did:example:123',", "        assertionMethod: [\n          'did:example:123',\n          { id: 'did:key:foobar', type: 'a', controller: 'did:example:123' },\n        ],\n        keyAgreement: ['did:foo:bar'],\n        capabilityInvocation: ['did:me:duh'],\n        capabilityDelegation: [\n          { id: 'did:some:id', type: 'some-type', controller: 'did:me:duh' },\n        ],\n        service: [", "        ],\n        service: [\n          {\n            id: 'some:uri',\n            type: ['a', 'b'],\n            serviceEndpoint: ['https://google.com', 'https://github.com'],\n          },\n        ],\n      })\n    })", "      })\n    })\n\n    it('should error with duplicate ID in service', () => {\n      assert.throws(\n        () =>\n          new DidDocument({ id: 'did:foo:bar' })\n            .addService({\n              id: 'some:id',\n              type: 'some-type',", "              id: 'some:id',\n              type: 'some-type',\n              serviceEndpoint: 'https://github.com',\n            })\n            .addService({\n              id: 'some:id',\n              type: 'some-type',\n              serviceEndpoint: 'https://github.com',\n            }),\n        ZodError", "            }),\n        ZodError\n      )\n    })\n\n    it('should error with duplicate ID in verificationMethod reference', () => {\n      assert.throws(\n        () =>\n          new DidDocument({ id: 'did:foo:bar' })\n            .addAuthentication({", "          new DidDocument({ id: 'did:foo:bar' })\n            .addAuthentication({\n              id: 'did:url:ref#1',\n              type: 'some-type',\n              controller: 'did:foo:bar',\n            })\n            .addAuthentication({\n              id: 'did:url:ref#1',\n              type: 'some-type',\n              controller: 'did:foo:bar',", "              type: 'some-type',\n              controller: 'did:foo:bar',\n            }),\n        ZodError\n      )\n    })\n\n    it('should error when the verification method reference is not inside the verification method', () => {\n      assert.throws(\n        () =>", "      assert.throws(\n        () =>\n          new DidDocument({ id: 'did:foo:bar' }).addAuthentication(\n            'did:example:key#01'\n          ),\n        DidDocumentError\n      )\n    })\n\n    it('should not error when the verification method reference is not inside the verification method, but using unsafe', () => {", "\n    it('should not error when the verification method reference is not inside the verification method, but using unsafe', () => {\n      const doc = new DidDocument({\n        id: 'did:foo:bar',\n      }).addAuthenticationUnsafe('did:example:key#01')\n\n      assert.deepStrictEqual(doc.toJSON(), {\n        id: 'did:foo:bar',\n        authentication: ['did:example:key#01'],\n      })", "        authentication: ['did:example:key#01'],\n      })\n    })\n  })\n\n  describe('Dereferencing to verification method', () => {\n    it('should find correctly to the associated verification method', () => {\n      const doc = new DidDocument({\n        id: 'did:example:bar',\n      }).addVerificationMethod({", "        id: 'did:example:bar',\n      }).addVerificationMethod({\n        id: 'did:example:bar#01',\n        type: 'some-type',\n        controller: 'did:example:bar',\n        publicKeyJwk: { kty: 'some-kty' },\n      })\n\n      assert.deepStrictEqual(\n        doc.findVerificationMethodByDidUrl('did:example:bar#01').toJSON(),", "      assert.deepStrictEqual(\n        doc.findVerificationMethodByDidUrl('did:example:bar#01').toJSON(),\n        {\n          id: 'did:example:bar#01',\n          type: 'some-type',\n          controller: 'did:example:bar',\n          publicKeyJwk: { kty: 'some-kty' },\n        }\n      )\n    })", "      )\n    })\n\n    it('should find safely to the associated verification method', () => {\n      const doc = new DidDocument({\n        id: 'did:example:bar',\n      }).addVerificationMethod({\n        id: 'did:example:bar#01',\n        type: 'some-type',\n        controller: 'did:example:bar',", "        type: 'some-type',\n        controller: 'did:example:bar',\n        publicKeyJwk: { kty: 'some-kty' },\n      })\n\n      assert.deepStrictEqual(\n        doc\n          .safeFindToVerificationMethodByDidUrl('did:example:bar#01')\n          ?.toJSON(),\n        {", "          ?.toJSON(),\n        {\n          id: 'did:example:bar#01',\n          type: 'some-type',\n          controller: 'did:example:bar',\n          publicKeyJwk: { kty: 'some-kty' },\n        }\n      )\n    })\n", "    })\n\n    it('should find safely to undefined if the verification method does not exist', () => {\n      const doc = new DidDocument({\n        id: 'did:example:bar',\n      })\n\n      assert.strictEqual(\n        doc.safeFindToVerificationMethodByDidUrl('did:example:bar#01'),\n        undefined", "        doc.safeFindToVerificationMethodByDidUrl('did:example:bar#01'),\n        undefined\n      )\n    })\n\n    it('should not find if the verification method does not exist', () => {\n      assert.throws(() => {\n        const doc = new DidDocument({\n          id: 'did:example:bar',\n        })", "          id: 'did:example:bar',\n        })\n        doc.findVerificationMethodByDidUrl('did:example:bar#01')\n      }, DidDocumentError)\n    })\n  })\n\n  describe('Finding items in the did Document', () => {\n    it('should find the service by type', () => {\n      const doc = new DidDocument({ id: 'did:example:123' }).addService({", "    it('should find the service by type', () => {\n      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n        id: 'did:example:123#service-1',\n        type: 'some-type',\n        serviceEndpoint: 'https://example.org',\n      })\n\n      assert.deepStrictEqual(doc.findServiceByType('some-type').toJSON(), {\n        id: 'did:example:123#service-1',\n        type: 'some-type',", "        id: 'did:example:123#service-1',\n        type: 'some-type',\n        serviceEndpoint: 'https://example.org',\n      })\n    })\n\n    it('should find the service by id', () => {\n      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n        id: 'did:example:123#service-1',\n        type: 'some-type',", "        id: 'did:example:123#service-1',\n        type: 'some-type',\n        serviceEndpoint: 'https://example.org',\n      })\n\n      assert.deepStrictEqual(\n        doc.findServiceById('did:example:123#service-1').toJSON(),\n        {\n          id: 'did:example:123#service-1',\n          type: 'some-type',", "          id: 'did:example:123#service-1',\n          type: 'some-type',\n          serviceEndpoint: 'https://example.org',\n        }\n      )\n    })\n\n    it('should not find the service if the type does not exist', () => {\n      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n        id: 'did:example:123#service-1',\n        type: 'some-type',\n        serviceEndpoint: 'https://example.org',\n      })\n\n      assert.throws(\n        () => doc.findServiceByType('some-other-type'),\n        DidDocumentError\n      )\n    })\n\n    it('should not find the service if the id does not exist', () => {\n      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n        id: 'did:example:123#service-1',\n        type: 'some-type',\n        serviceEndpoint: 'https://example.org',\n      })\n\n      assert.throws(\n        () => doc.findServiceById('did:example:123#service-2'),\n        DidDocumentError\n      )\n    })\n\n    it('should find the verification method by purpose and type', () => {\n      const doc = new DidDocument({ id: 'did:example:123' }).addKeyAgreement({\n        id: 'did:example:123#key-1',\n        type: 'some-type',\n        controller: 'did:example:123',\n      })\n\n      assert.deepStrictEqual(\n        doc\n          .findVerificationMethodByTypeAndPurpose('some-type', 'keyAgreement')\n          .toJSON(),\n        {\n          id: 'did:example:123#key-1',\n          type: 'some-type',\n          controller: 'did:example:123',\n        }\n      )\n    })\n", "    it('should find the verification method by purpose and type with reference', () => {\n      const doc = new DidDocument({ id: 'did:example:123' })\n        .addVerificationMethod({\n          id: 'did:example:123#key-1',\n          type: 'some-type',\n          controller: 'did:example:123',\n        })\n        .addKeyAgreement('did:example:123#key-1')\n\n      assert.deepStrictEqual(\n        doc\n          .findVerificationMethodByTypeAndPurpose('some-type', 'keyAgreement')\n          .toJSON(),\n        {\n          id: 'did:example:123#key-1',\n          type: 'some-type',\n          controller: 'did:example:123',\n        }\n      )\n    })\n", "    it('should not find the verification method if the type does not exist', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n      }).addVerificationMethod({\n        id: 'did:example:123#key-1',\n        type: 'some-type',\n        controller: 'did:example:123',\n      })\n\n      assert.throws(\n        () =>\n          doc.findVerificationMethodByTypeAndPurpose(\n            'some-other-type',\n            'verificationMethod'\n          ),\n        DidDocumentError\n      )\n    })\n\n    it('should not find the verification method if the purpose does not match', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n      }).addCapabilityDelegation({\n        id: 'did:example:123#key-1',\n        type: 'some-type',\n        controller: 'did:example:123',\n      })\n\n      assert.throws(\n        () =>\n          doc.findVerificationMethodByTypeAndPurpose(\n            'some-type',\n            'keyAgreement'\n          ),\n        DidDocumentError\n      )\n    })\n  })\n\n  describe('validate the registered types for verification methods and services', () => {", "    it('should validate a correct type of a verification method by id', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n        verificationMethod: [\n          {\n            id: 'did:example:123#key-1',\n            type: VerificationMethodTypes.JsonWebKey2020,\n            controller: 'did:example:123',\n          },\n        ],\n      })\n\n      assert(doc.isVerificationMethodTypeRegistered('did:example:123#key-1'))\n    })\n", "    it('should validate an custom added type of a verification method by id', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n        verificationMethod: [\n          {\n            id: 'did:example:123#key-1',\n            type: 'some-added-type',\n            controller: 'did:example:123',\n          },\n        ],\n      })\n\n      assert(\n        doc.isVerificationMethodTypeRegistered(\n          'did:example:123#key-1',\n          'some-added-type'\n        )\n      )\n    })\n", "    it('should not validate an incorrect type of a verification method by id', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n        verificationMethod: [\n          {\n            id: 'did:example:123#key-1',\n            type: 'some-incorrect-type',\n            controller: 'did:example:123',\n          },\n        ],\n      })\n\n      assert(\n        doc.isVerificationMethodTypeRegistered('did:example:123#key-1') ===\n          false\n      )\n    })\n", "    it('should validate a correct type of a service by id', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n        service: [\n          {\n            id: 'did:example:some:id',\n            type: ServiceTypes.LinkedDomains,\n            serviceEndpoint: 'https://example.org',\n          },\n        ],\n      })\n\n      assert(doc.isServiceTypeRegistered('did:example:some:id'))\n    })\n", "    it('should validate a correct type of a service by id', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n        service: [\n          {\n            id: 'did:example:some:id',\n            type: 'some-added-type',\n            serviceEndpoint: 'https://example.org',\n          },\n        ],\n      })\n\n      assert(\n        doc.isServiceTypeRegistered('did:example:some:id', 'some-added-type')\n      )\n    })\n", "    it('should not validate an incorrect type of a service by id', () => {\n      const doc = new DidDocument({\n        id: 'did:example:123',\n        service: [\n          {\n            id: 'did:example:some:id',\n            type: 'some-bad-type',\n            serviceEndpoint: 'https://example.org',\n          },\n        ],\n      })\n\n      assert(doc.isServiceTypeRegistered('did:example:some:id') === false)\n    })\n  })\n})\n"]}
{"filename": "tests/did.test.ts", "chunked_list": ["import { Did } from '../src'\n\nimport assert from 'node:assert'\nimport { describe, it } from 'node:test'\nimport { DIDS } from './fixtures/dids'\nimport {\n  createDidExtractPartsTest,\n  createDidExtractUrlPartsTest,\n  createDidIsDidUrlValidationTest,\n  createDidValidationTest,", "  createDidIsDidUrlValidationTest,\n  createDidValidationTest,\n} from './utils'\n\ndescribe('Did', (_) => {\n  describe('Creation', () => {\n    it('should create a new did', () => {\n      const didUrl = 'did:key:abc'\n      const did = new Did(didUrl)\n", "      const did = new Did(didUrl)\n\n      assert.strictEqual(did.did, didUrl)\n    })\n\n    it('should create a new did from a did-url', () => {\n      const didUrl = 'did:key:abc/some-path?versionId=1#key-1'\n      const did = new Did(didUrl)\n\n      assert.deepStrictEqual(did.toUrl(), didUrl)", "\n      assert.deepStrictEqual(did.toUrl(), didUrl)\n    })\n\n    it('should create a new did via the builder pattern', () => {\n      const did = new Did('did:key:abc')\n        .withPath('some-path')\n        .withQuery({ versionId: '1' })\n        .withFragment('key-1')\n", "        .withFragment('key-1')\n\n      assert.deepStrictEqual(\n        did.toUrl(),\n        'did:key:abc/some-path?versionId=1#key-1'\n      )\n    })\n  })\n\n  describe('Validation', () => {", "\n  describe('Validation', () => {\n    describe('Validate did', () => {\n      Object.keys(DIDS).forEach(createDidValidationTest)\n    })\n\n    describe('Validate whether did is url', () => {\n      Object.entries(DIDS).forEach(([did, expected]) =>\n        createDidIsDidUrlValidationTest(\n          did,", "        createDidIsDidUrlValidationTest(\n          did,\n          Boolean(\n            expected.urlParts.path ||\n              expected.urlParts.query ||\n              expected.urlParts.fragment ||\n              expected.urlParts.parameters\n          )\n        )\n      )", "        )\n      )\n    })\n  })\n\n  describe('Extraction', () => {\n    describe('Extract did parts', () => {\n      Object.entries(DIDS).forEach(([did, expected]) =>\n        createDidExtractPartsTest(did, expected.parts)\n      )", "        createDidExtractPartsTest(did, expected.parts)\n      )\n    })\n\n    describe('Extract did url parts', () => {\n      Object.entries(DIDS).forEach(([did, expected]) =>\n        createDidExtractUrlPartsTest(did, expected.urlParts)\n      )\n    })\n  })", "    })\n  })\n\n  describe('Modify url parts', () => {\n    const baseDid = 'did:key:abc'\n    describe('Path', () => {\n      it('should add a new path (withPath)', () => {\n        const did = new Did(baseDid)\n        did.withPath('test')\n        assert.strictEqual(did.didUrlParts.path, 'test')", "        did.withPath('test')\n        assert.strictEqual(did.didUrlParts.path, 'test')\n      })\n\n      it('should add a new path (addPath)', () => {\n        const did = new Did(baseDid)\n        did.addPath('test')\n        assert.strictEqual(did.didUrlParts.path, 'test')\n      })\n", "      })\n\n      it('should append a new path', () => {\n        const did = new Did(baseDid)\n        did.addPath('test').addPath('testTwo')\n        assert.strictEqual(did.didUrlParts.path, 'test/testTwo')\n      })\n\n      it('should remove the path', () => {\n        const did = new Did(baseDid)", "      it('should remove the path', () => {\n        const did = new Did(baseDid)\n        did.addPath('test').removePath()\n        assert.strictEqual(did.didUrlParts.path, undefined)\n      })\n    })\n\n    describe('Query', () => {\n      it('should add a new query (withQuery)', () => {\n        const did = new Did(baseDid)", "      it('should add a new query (withQuery)', () => {\n        const did = new Did(baseDid)\n        did.withQuery({ a: 'b' })\n        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b' })\n      })\n\n      it('should add a new query (addQuery)', () => {\n        const did = new Did(baseDid)\n        did.addQuery({ a: 'b' })\n        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b' })", "        did.addQuery({ a: 'b' })\n        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b' })\n      })\n\n      it('should append a new query', () => {\n        const did = new Did(baseDid)\n        did.addQuery({ a: 'b' }).addQuery({ c: 'd' })\n        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b', c: 'd' })\n      })\n", "      })\n\n      it('should remove the query', () => {\n        const did = new Did(baseDid)\n        did.addQuery({ a: 'b' }).removeQuery()\n        assert.strictEqual(did.didUrlParts.query, undefined)\n      })\n    })\n\n    describe('Fragment', () => {", "\n    describe('Fragment', () => {\n      it('should add a new fragment', () => {\n        const did = new Did(baseDid)\n        did.withFragment('a')\n        assert.strictEqual(did.didUrlParts.fragment, 'a')\n      })\n\n      it('should remove the fragment', () => {\n        const did = new Did(baseDid)", "      it('should remove the fragment', () => {\n        const did = new Did(baseDid)\n        did.withFragment('a').removeFragment()\n        assert.strictEqual(did.didUrlParts.fragment, undefined)\n      })\n    })\n\n    describe('Parameters', () => {\n      it('should add a new parameter', () => {\n        const did = new Did(baseDid)", "      it('should add a new parameter', () => {\n        const did = new Did(baseDid)\n        did.addParameterKey('a').addQuery({ a: 'b' })\n        assert.deepStrictEqual(did.didUrlParts.parameters, { a: 'b' })\n      })\n    })\n  })\n})\n", ""]}
{"filename": "tests/fixtures/dids.ts", "chunked_list": ["import { DidParts, DidUrlParts } from 'did'\n\nexport const DIDS: Record<string, { parts: DidParts; urlParts: DidUrlParts }> =\n  {\n    'did:key:z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57#z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57':\n      {\n        parts: {\n          scheme: 'did',\n          method: 'key',\n          namespaces: undefined,", "          method: 'key',\n          namespaces: undefined,\n          identifier: 'z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57',\n        },\n        urlParts: {\n          path: undefined,\n          query: undefined,\n          fragment: 'z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57',\n          parameters: undefined,\n        },", "          parameters: undefined,\n        },\n      },\n    'did:key:z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu#z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu':\n      {\n        parts: {\n          scheme: 'did',\n          method: 'key',\n          namespaces: undefined,\n          identifier: 'z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu',", "          namespaces: undefined,\n          identifier: 'z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu',\n        },\n        urlParts: {\n          path: undefined,\n          query: undefined,\n          fragment: 'z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu',\n          parameters: undefined,\n        },\n      },", "        },\n      },\n    'did:sov:2wJPyULfLLnYTEFYzByfUR': {\n      parts: {\n        scheme: 'did',\n        method: 'sov',\n        namespaces: undefined,\n        identifier: '2wJPyULfLLnYTEFYzByfUR',\n      },\n      urlParts: {", "      },\n      urlParts: {\n        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,\n      },\n    },\n    'did:sov:HR6vs6GEZ8rHaVgjg2WodM': {\n      parts: {", "    'did:sov:HR6vs6GEZ8rHaVgjg2WodM': {\n      parts: {\n        scheme: 'did',\n        method: 'sov',\n        namespaces: undefined,\n        identifier: 'HR6vs6GEZ8rHaVgjg2WodM',\n      },\n      urlParts: {\n        path: undefined,\n        query: undefined,", "        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,\n      },\n    },\n    'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w': {\n      parts: {\n        scheme: 'did',\n        method: 'ion',", "        scheme: 'did',\n        method: 'ion',\n        namespaces: undefined,\n        identifier: 'EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n      },\n      urlParts: {\n        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,", "        fragment: undefined,\n        parameters: undefined,\n      },\n    },\n    'did:ala:quor:redT:ec27f358fd0d11d8934ceb51305622ae79b6ad15': {\n      parts: {\n        scheme: 'did',\n        method: 'ala',\n        namespaces: ['quor', 'redT'],\n        identifier: 'ec27f358fd0d11d8934ceb51305622ae79b6ad15',", "        namespaces: ['quor', 'redT'],\n        identifier: 'ec27f358fd0d11d8934ceb51305622ae79b6ad15',\n      },\n      urlParts: {\n        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,\n      },\n    },", "      },\n    },\n    'did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734': {\n      parts: {\n        scheme: 'did',\n        method: 'evan',\n        namespaces: ['testcore'],\n        identifier: '0x126E901F6F408f5E260d95c62E7c73D9B60fd734',\n      },\n      urlParts: {", "      },\n      urlParts: {\n        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,\n      },\n    },\n    'did:cheqd:testnet:55dbc8bf-fba3-4117-855c-1e0dc1d3bb47': {\n      parts: {", "    'did:cheqd:testnet:55dbc8bf-fba3-4117-855c-1e0dc1d3bb47': {\n      parts: {\n        scheme: 'did',\n        method: 'cheqd',\n        namespaces: ['testnet'],\n        identifier: '55dbc8bf-fba3-4117-855c-1e0dc1d3bb47',\n      },\n      urlParts: {\n        path: undefined,\n        query: undefined,", "        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,\n      },\n    },\n    'did:key:abc': {\n      parts: {\n        scheme: 'did',\n        method: 'key',", "        scheme: 'did',\n        method: 'key',\n        namespaces: undefined,\n        identifier: 'abc',\n      },\n      urlParts: {\n        path: undefined,\n        query: undefined,\n        fragment: undefined,\n        parameters: undefined,", "        fragment: undefined,\n        parameters: undefined,\n      },\n    },\n    'did:key:abc/some-path?versionId=1#key-1': {\n      parts: {\n        scheme: 'did',\n        method: 'key',\n        namespaces: undefined,\n        identifier: 'abc',", "        namespaces: undefined,\n        identifier: 'abc',\n      },\n      urlParts: {\n        path: 'some-path',\n        query: { versionId: '1' },\n        fragment: 'key-1',\n        parameters: { versionId: '1' },\n      },\n    },", "      },\n    },\n    'did:example:123456?versionId=1': {\n      parts: {\n        scheme: 'did',\n        method: 'example',\n        namespaces: undefined,\n        identifier: '123456',\n      },\n      urlParts: {", "      },\n      urlParts: {\n        path: undefined,\n        query: { versionId: '1' },\n        fragment: undefined,\n        parameters: { versionId: '1' },\n      },\n    },\n    'did:example:123#public-key-0': {\n      parts: {", "    'did:example:123#public-key-0': {\n      parts: {\n        scheme: 'did',\n        method: 'example',\n        namespaces: undefined,\n        identifier: '123',\n      },\n      urlParts: {\n        path: undefined,\n        query: undefined,", "        path: undefined,\n        query: undefined,\n        fragment: 'public-key-0',\n        parameters: undefined,\n      },\n    },\n    'did:example:123?service=agent&relativeRef=/credentials#degree': {\n      parts: {\n        scheme: 'did',\n        method: 'example',", "        scheme: 'did',\n        method: 'example',\n        namespaces: undefined,\n        identifier: '123',\n      },\n      urlParts: {\n        path: undefined,\n        query: { service: 'agent', relativeRef: '/credentials' },\n        fragment: 'degree',\n        parameters: { service: 'agent', relativeRef: '/credentials' },", "        fragment: 'degree',\n        parameters: { service: 'agent', relativeRef: '/credentials' },\n      },\n    },\n    'did:example:123?service=files&relativeRef=/resume.pdf': {\n      parts: {\n        scheme: 'did',\n        method: 'example',\n        namespaces: undefined,\n        identifier: '123',", "        namespaces: undefined,\n        identifier: '123',\n      },\n      urlParts: {\n        path: undefined,\n        query: { service: 'files', relativeRef: '/resume.pdf' },\n        fragment: undefined,\n        parameters: { service: 'files', relativeRef: '/resume.pdf' },\n      },\n    },", "      },\n    },\n    'did:example:123#_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A': {\n      parts: {\n        scheme: 'did',\n        method: 'example',\n        namespaces: undefined,\n        identifier: '123',\n      },\n      urlParts: {", "      },\n      urlParts: {\n        path: undefined,\n        query: undefined,\n        fragment: '_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A',\n        parameters: undefined,\n      },\n    },\n  }\n", "  }\n"]}
{"filename": "tests/fixtures/didDocuments.ts", "chunked_list": ["import { DidDocumentOptions } from '../../src'\n\nexport const DID_DOCUMENTS: Array<DidDocumentOptions> = [\n  {\n    id: 'did:example:foobar',\n  },\n  {\n    id: 'did:example:123456789abcdefghi',\n    verificationMethod: [\n      {", "    verificationMethod: [\n      {\n        id: 'did:example:123#_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          crv: 'Ed25519',\n          jsldkfalskd: 'asldhfsadj',\n          x: 'VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ',\n          kty: 'OKP',", "          x: 'VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ',\n          kty: 'OKP',\n          kid: '_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A',\n        },\n      },\n      {\n        id: 'did:example:123456789abcdefghi#keys-1',\n        type: 'Ed25519VerificationKey2020',\n        controller: 'did:example:pqrstuvwxyz0987654321',\n        publicKeyMultibase: 'zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV',", "        controller: 'did:example:pqrstuvwxyz0987654321',\n        publicKeyMultibase: 'zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV',\n      },\n    ],\n  },\n  {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      'https://w3id.org/security/suites/ed25519-2020/v1',\n    ],", "      'https://w3id.org/security/suites/ed25519-2020/v1',\n    ],\n    id: 'did:example:123',\n    authentication: [\n      {\n        id: 'did:example:123#z6MkecaLyHuYWkayBDLw5ihndj3T1m6zKTGqau3A51G7RBf3',\n        type: 'Ed25519VerificationKey2020', // external (property value)\n        controller: 'did:example:123',\n        publicKeyMultibase: 'zAKJP3f7BD6W4iWEQ9jwndVTCBq8ua2Utt8EEjJ6Vxsf',\n      },", "        publicKeyMultibase: 'zAKJP3f7BD6W4iWEQ9jwndVTCBq8ua2Utt8EEjJ6Vxsf',\n      },\n    ],\n    capabilityInvocation: [\n      {\n        id: 'did:example:123#z6MkhdmzFu659ZJ4XKj31vtEDmjvsi5yDZG5L7Caz63oP39k',\n        type: 'Ed25519VerificationKey2020', // external (property value)\n        controller: 'did:example:123',\n        publicKeyMultibase: 'z4BWwfeqdp1obQptLLMvPNgBw48p7og1ie6Hf9p5nTpNN',\n      },", "        publicKeyMultibase: 'z4BWwfeqdp1obQptLLMvPNgBw48p7og1ie6Hf9p5nTpNN',\n      },\n    ],\n    capabilityDelegation: [\n      {\n        id: 'did:example:123#z6Mkw94ByR26zMSkNdCUi6FNRsWnc2DFEeDXyBGJ5KTzSWyi',\n        type: 'Ed25519VerificationKey2020', // external (property value)\n        controller: 'did:example:123',\n        publicKeyMultibase: 'zHgo9PAmfeoxHG8Mn2XHXamxnnSwPpkyBHAMNF3VyXJCL',\n      },", "        publicKeyMultibase: 'zHgo9PAmfeoxHG8Mn2XHXamxnnSwPpkyBHAMNF3VyXJCL',\n      },\n    ],\n    assertionMethod: [\n      {\n        id: 'did:example:123#z6MkiukuAuQAE8ozxvmahnQGzApvtW7KT5XXKfojjwbdEomY',\n        type: 'Ed25519VerificationKey2020', // external (property value)\n        controller: 'did:example:123',\n        publicKeyMultibase: 'z5TVraf9itbKXrRvt2DSS95Gw4vqU3CHAdetoufdcKazA',\n      },", "        publicKeyMultibase: 'z5TVraf9itbKXrRvt2DSS95Gw4vqU3CHAdetoufdcKazA',\n      },\n    ],\n  },\n  {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      'https://w3id.org/security/suites/jws-2020/v1',\n    ],\n    id: 'did:example:method-id',", "    ],\n    id: 'did:example:method-id',\n    verificationMethod: [\n      {\n        id: 'did:example:123#key-0',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'OKP', // external (property name)\n          crv: 'Ed25519', // external (property name)", "          kty: 'OKP', // external (property name)\n          crv: 'Ed25519', // external (property name)\n          x: 'VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ', // external (property name)\n        },\n      },\n      {\n        id: 'did:example:123#key-1',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {", "        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'OKP', // external (property name)\n          crv: 'X25519', // external (property name)\n          x: 'pE_mG098rdQjY3MKK2D5SUQ6ZOEW3a6Z6T7Z4SgnzCE', // external (property name)\n        },\n      },\n      {\n        id: 'did:example:123#key-2',\n        type: 'JsonWebKey2020',", "        id: 'did:example:123#key-2',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'EC', // external (property name)\n          crv: 'secp256k1', // external (property name)\n          x: 'Z4Y3NNOxv0J6tCgqOBFnHnaZhJF6LdulT7z8A-2D5_8', // external (property name)\n          y: 'i5a2NtJoUKXkLm6q8nOEu9WOkso1Ag6FTUT6k_LMnGk', // external (property name)\n        },\n      },", "        },\n      },\n      {\n        id: 'did:example:123#key-3',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'EC', // external (property name)\n          crv: 'secp256k1', // external (property name)\n          x: 'U1V4TVZVMUpUa0ZVU1NBcU9CRm5IbmFaaEpGNkxkdWx', // external (property name)", "          crv: 'secp256k1', // external (property name)\n          x: 'U1V4TVZVMUpUa0ZVU1NBcU9CRm5IbmFaaEpGNkxkdWx', // external (property name)\n          y: 'i5a2NtJoUKXkLm6q8nOEu9WOkso1Ag6FTUT6k_LMnGk', // external (property name)\n        },\n      },\n      {\n        id: 'did:example:123#key-4',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {", "        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'EC', // external (property name)\n          crv: 'P-256', // external (property name)\n          x: 'Ums5WVgwRkRTVVFnU3k5c2xvZllMbEcwM3NPRW91ZzN', // external (property name)\n          y: 'nDQW6XZ7b_u2Sy9slofYLlG03sOEoug3I0aAPQ0exs4', // external (property name)\n        },\n      },\n      {\n        id: 'did:example:123#key-5',", "      {\n        id: 'did:example:123#key-5',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'EC', // external (property name)\n          crv: 'P-384', // external (property name)\n          x: 'VUZKSlUwMGdpSXplekRwODhzX2N4U1BYdHVYWUZsaXVDR25kZ1U0UXA4bDkxeHpE', // external (property name)\n          y: 'jq4QoAHKiIzezDp88s_cxSPXtuXYFliuCGndgU4Qp8l91xzD1spCmFIzQgVjqvcP', // external (property name)\n        },", "          y: 'jq4QoAHKiIzezDp88s_cxSPXtuXYFliuCGndgU4Qp8l91xzD1spCmFIzQgVjqvcP', // external (property name)\n        },\n      },\n      {\n        id: 'did:example:123#key-6',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'EC', // external (property name)\n          crv: 'P-521', // external (property name)", "          kty: 'EC', // external (property name)\n          crv: 'P-521', // external (property name)\n          x: 'VTI5c1lYSmZWMmx1WkhNZ0dQTXhaYkhtSnBEU3UtSXZwdUtpZ0VOMnB6Z1d0U28tLVJ3ZC1uNzhuclduWnplRGMx', // external (property name)\n          y: 'UW5WNVgwSnBkR052YVc0Z1VqY1B6LVpoZWNaRnliT3FMSUpqVk9sTEVUSDd1UGx5RzBnRW9NV25JWlhoUVZ5cFB5', // external (property name)\n        },\n      },\n      {\n        id: 'did:example:123#key-7',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',", "        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'RSA', // external (property name)\n          e: 'AQAB', // external (property name)\n          n: 'UkhWaGJGOUZRMTlFVWtKSElBdENGV2hlU1F2djFNRXh1NVJMQ01UNGpWazlraEpLdjhKZU1YV2UzYldIYXRqUHNrZGYyZGxhR2tXNVFqdE9uVUtMNzQybXZyNHRDbGRLUzNVTElhVDFoSkluTUhIeGoyZ2N1Yk82ZUVlZ0FDUTRRU3U5TE8wSC1MTV9MM0RzUkFCQjdRamE4SGVjcHl1c3BXMVR1X0RicXhjU253ZW5kYW13TDUyVjE3ZUtobE80dVh3djJIRmx4dWZGSE0wS21DSnVqSUt5QXhqRF9tM3FfX0lpSFVWSEQxdERJRXZMUGhHOUF6c24zajk1ZC1zYU', // external (property name)\n        },\n      },\n    ],\n  },", "    ],\n  },\n  {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      'https://w3id.org/security/suites/ed25519-2018/v1',\n      'https://w3id.org/security/suites/x25519-2019/v1',\n      'https://w3id.org/security/suites/secp256k1-2019/v1',\n      'https://w3id.org/security/suites/jws-2020/v1',\n    ],", "      'https://w3id.org/security/suites/jws-2020/v1',\n    ],\n    id: 'did:example:method-id',\n    verificationMethod: [\n      {\n        id: 'did:example:123#key-0',\n        type: 'Ed25519VerificationKey2018',\n        controller: 'did:example:123',\n        // publicKeyBase58: '3M5RCDjPTWPkKSN3sxUmmMqHbmRPegYP1tjcKyrDbt9J', // external (property name)\n      },", "        // publicKeyBase58: '3M5RCDjPTWPkKSN3sxUmmMqHbmRPegYP1tjcKyrDbt9J', // external (property name)\n      },\n      {\n        id: 'did:example:123#key-1',\n        type: 'X25519KeyAgreementKey2019',\n        controller: 'did:example:123',\n        publicKeyBase58: 'FbQWLPRhTH95MCkQUeFYdiSoQt8zMwetqfWoxqPgaq7x', // external (property name)\n      },\n      {\n        id: 'did:example:123#key-2',", "      {\n        id: 'did:example:123#key-2',\n        type: 'EcdsaSecp256k1VerificationKey2019',\n        controller: 'did:example:123',\n        publicKeyBase58: 'ns2aFDq25fEV1NUd3wZ65sgj5QjFW8JCAHdUJfLwfodt', // external (property name)\n      },\n      {\n        id: 'did:example:123#key-3',\n        type: 'JsonWebKey2020',\n        controller: 'did:example:123',", "        type: 'JsonWebKey2020',\n        controller: 'did:example:123',\n        publicKeyJwk: {\n          kty: 'EC', // external (property name)\n          crv: 'P-256', // external (property name)\n          x: 'Er6KSSnAjI70ObRWhlaMgqyIOQYrDJTE94ej5hybQ2M', // external (property name)\n          y: 'pPVzCOTJwgikPjuUE6UebfZySqEJ0ZtsWFpj7YSPGEk', // external (property name)\n        },\n      },\n    ],", "      },\n    ],\n  },\n  {\n    '@context': 'https://w3id.org/did/v1',\n    id: 'did:github:OR13',\n    publicKey: [\n      {\n        encoding: 'application/pgp-keys',\n        type: 'OpenPgpVerificationKey2019',", "        encoding: 'application/pgp-keys',\n        type: 'OpenPgpVerificationKey2019',\n        id: 'did:github:OR13#kid=ibHP1ksrJp5FQjP7hhmTXV7YE5o5bB6YFoODu9n_82E',\n        controller: 'did:github:OR13',\n        publicKeyPem:\n          '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v4.4.7\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nxk8EXNhPhBMFK4EEAAoCAwSTAb5KPYRzxaQoplpY8olodfbG3OxFqm6ULA6p\\r\\nvaCxZLKVwd4XCwSL8XcMMrPb78kmDEk0H5/Jl0qpRteRoy8CzRdhbm9uIDxh\\r\\nbm9uQGV4YW1wbGUuY29tPsJ3BBATCAAfBQJc2E+EBgsJBwgDAgQVCAoCAxYC\\r\\nAQIZAQIbAwIeAQAKCRAeL9f86407tSxDAP4/dXtxQKQxAsURQmNxwwlD03YM\\r\\n778dcM753Y4f96jW7QEAkLEDur/hKPLKKdFAi/9TCKNQvr7GVk1wYeYeiHMi\\r\\nJ/fOUwRc2E+EEgUrgQQACgIDBA7fIkmeQmvaG6a5B3X808pdFStePh7+uevf\\r\\njWpXbDYYTsxARpBT/xb34m0wrXGo7DEG6pAknQ6NBWiXSWX7qTkDAQgHwmEE\\r\\nGBMIAAkFAlzYT4QCGwwACgkQHi/X/OuNO7U8gQEAn3/lFx3C7iqzVG2BJgtH\\r\\n08Oc3h0YPwYnZjM9NXDsvEgA/3v5C28Jhx10RFKi9NDxAPjilwBDOZqYPK/s\\r\\nW3qWhGNU\\r\\n=RgYO\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n',\n      },\n      {\n        encoding: 'application/pgp-keys',\n        type: 'OpenPgpVerificationKey2019',", "        encoding: 'application/pgp-keys',\n        type: 'OpenPgpVerificationKey2019',\n        id: 'did:github:OR13#kid=jNeDDagaBn466F-wH26YdQ5_NiabBvOlXTv5xItQakU',\n        controller: 'did:github:OR13',\n        publicKeyPem:\n          '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v4.4.7\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nxk8EXNhPhBMFK4EEAAoCAwRzQtkzDYQJy7xfHE0ld/Yoznx0q5bfVrx51FPG\\r\\nXzjd28wktnePW+3Riq0+3YUa09mZJWEuGPwrrGGXEqobjlVBzRdhbm9uIDxh\\r\\nbm9uQGV4YW1wbGUuY29tPsJ3BBATCAAfBQJc2E+EBgsJBwgDAgQVCAoCAxYC\\r\\nAQIZAQIbAwIeAQAKCRC0BtN9z0XDqWsSAQCso31Utz8xji2B7WUBX+2798ae\\r\\ncqxSxMPWnOQKenBA0gD+N9Qiq6sQ/sDipXuG7xIg4NH4qpf96xvPwC4hX9Jv\\r\\n3FzOUwRc2E+EEgUrgQQACgIDBIPkRAFeFOrFMXa4XoZ8+aZb4iXLhce6N0LE\\r\\nCh3YZNJLwxWVKVCxr8niWq3Fa8RTkLA+F7PvIHjnpgx5UGeqPzgDAQgHwmEE\\r\\nGBMIAAkFAlzYT4QCGwwACgkQtAbTfc9Fw6nomAEAl+1tioF0BlbTNm3c879W\\r\\nadI46tXfqHt8T6TGdIsKbmoA/RjOfCUvMT277p+v3aYjROI3M7ygh24jbjzx\\r\\nKBQj/GIJ\\r\\n=UGd9\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n',\n      },\n    ],\n    authentication: [],\n    service: [],", "    authentication: [],\n    service: [],\n    proof: {\n      type: 'OpenPgpSignature2019',\n      creator:\n        'did:github:OR13#kid=ibHP1ksrJp5FQjP7hhmTXV7YE5o5bB6YFoODu9n_82E',\n      domain: 'GitHubDID',\n      nonce: '9c28424e440806718a5165670f79bbc2',\n      created: '2019-05-12T16:53:25.038Z',\n      signatureValue:", "      created: '2019-05-12T16:53:25.038Z',\n      signatureValue:\n        '-----BEGIN PGP SIGNATURE-----\\r\\nVersion: OpenPGP.js v4.4.7\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nwl0EARMIAAYFAlzYT4UACgkQHi/X/OuNO7WZQAD47BbeS2pgFW/WwPbHvC8I\\r\\nMfsOFhSJEywkED7uz0E4RwD/RRrsmPPb4S4Z+7D2skjiFtnd2nWd+BXcxvhm\\r\\nGzKk1FU=\\r\\n=W/tu\\r\\n-----END PGP SIGNATURE-----\\r\\n',\n    },\n  },\n  {\n    id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      {", "      'https://www.w3.org/ns/did/v1',\n      {\n        '@base': 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n      },\n    ],\n    service: [\n      {\n        id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#linkedin',\n        type: 'linkedin',\n        serviceEndpoint: 'https://linkedin.com/in/henry-tsai-6b884014',", "        type: 'linkedin',\n        serviceEndpoint: 'https://linkedin.com/in/henry-tsai-6b884014',\n      },\n      {\n        id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#github',\n        type: 'github',\n        serviceEndpoint: 'https://github.com/thehenrytsai',\n      },\n    ],\n    verificationMethod: [", "    ],\n    verificationMethod: [\n      {\n        id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#someKeyId',\n        controller: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n        type: 'EcdsaSecp256k1VerificationKey2019',\n        publicKeyJwk: {\n          kty: 'EC',\n          crv: 'secp256k1',\n          x: 'WfY7Px6AgH6x-_dgAoRbg8weYRJA36ON-gQiFnETrqw',", "          crv: 'secp256k1',\n          x: 'WfY7Px6AgH6x-_dgAoRbg8weYRJA36ON-gQiFnETrqw',\n          y: 'IzFx3BUGztK0cyDStiunXbrZYYTtKbOUzx16SUK0sAY',\n        },\n      },\n    ],\n    authentication: [\n      'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#someKeyId',\n    ],\n  },", "    ],\n  },\n  {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      'https://w3c-ccg.github.io/verifiable-conditions/contexts/verifiable-conditions-2021-v1.json',\n    ],\n    id: 'did:eosio:eos:eoscanadacom',\n    verificationMethod: [\n      {", "    verificationMethod: [\n      {\n        id: 'did:eosio:eos:eoscanadacom#active',\n        controller: 'did:eosio:eos:eoscanadacom',\n        type: 'VerifiableCondition',\n        threshold: 1,\n        conditionWeightedThreshold: [\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#active-0',", "            condition: {\n              id: 'did:eosio:eos:eoscanadacom#active-0',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'EcdsaSecp256k1VerificationKey2019',\n              publicKeyJwk: {\n                crv: 'secp256k1',\n                kty: 'EC',\n                x: '0xMG4S6nDAGYjy6un2-l53-s0RC2t619_LqPDxyPcf0',\n                y: 'gRsWsrqWqnlr-jCDVeqatVjFghLADydjOlUPImBwhYs',\n                kid: 'PUB_K1_8SC96RUoYvM1X47isBBrebY1kjqVT4w37Q4tNNHtT8XN35v33D',", "                y: 'gRsWsrqWqnlr-jCDVeqatVjFghLADydjOlUPImBwhYs',\n                kid: 'PUB_K1_8SC96RUoYvM1X47isBBrebY1kjqVT4w37Q4tNNHtT8XN35v33D',\n              },\n            },\n            weight: 1,\n          },\n        ],\n        relationshipParent: ['did:eosio:eos:eoscanadacom#owner'],\n      },\n      {", "      },\n      {\n        id: 'did:eosio:eos:eoscanadacom#blacklistops',\n        controller: 'did:eosio:eos:eoscanadacom',\n        type: 'VerifiableCondition',\n        threshold: 1,\n        conditionWeightedThreshold: [\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#blacklistops-0',", "            condition: {\n              id: 'did:eosio:eos:eoscanadacom#blacklistops-0',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'EcdsaSecp256k1VerificationKey2019',\n              publicKeyJwk: {\n                crv: 'secp256k1',\n                kty: 'EC',\n                x: 'dLOnSPgih47eVwlWAlrcm4wD1cJnjc-Jh_UFdlb29mw',\n                y: 'vwsVDd__tmPumdQ2Yo-TdozxbhGnyDMg3Htd52-SEw0',\n                kid: 'PUB_K1_7idX86zQ6M3mrzkGQ9MGHf4btSECmcTj4i8Le59ga7CpLxRu4s',", "                y: 'vwsVDd__tmPumdQ2Yo-TdozxbhGnyDMg3Htd52-SEw0',\n                kid: 'PUB_K1_7idX86zQ6M3mrzkGQ9MGHf4btSECmcTj4i8Le59ga7CpLxRu4s',\n              },\n            },\n            weight: 1,\n          },\n        ],\n        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n      },\n      {", "      },\n      {\n        id: 'did:eosio:eos:eoscanadacom#claimer',\n        controller: 'did:eosio:eos:eoscanadacom',\n        type: 'VerifiableCondition',\n        threshold: 1,\n        conditionWeightedThreshold: [\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#claimer-0',", "            condition: {\n              id: 'did:eosio:eos:eoscanadacom#claimer-0',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'EcdsaSecp256k1VerificationKey2019',\n              publicKeyJwk: {\n                crv: 'secp256k1',\n                kty: 'EC',\n                x: 'RnFk1oqh28hDY2WHWUhQzAZYXjfvv0oR43h69RCCkIA',\n                y: 'e8aXe3M9xKgYsj6U-KOonbgEtjHGPDtAUavq9nY4lI8',\n                kid: 'PUB_K1_7NFuBesBKK5XHHLtzFxm7S57Eq11gUtndrsvq3Mt3XZNNT5cXo',", "                y: 'e8aXe3M9xKgYsj6U-KOonbgEtjHGPDtAUavq9nY4lI8',\n                kid: 'PUB_K1_7NFuBesBKK5XHHLtzFxm7S57Eq11gUtndrsvq3Mt3XZNNT5cXo',\n              },\n            },\n            weight: 1,\n          },\n        ],\n        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n      },\n      {", "      },\n      {\n        id: 'did:eosio:eos:eoscanadacom#day2day',\n        controller: 'did:eosio:eos:eoscanadacom',\n        type: 'VerifiableCondition',\n        threshold: 1,\n        conditionWeightedThreshold: [\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-0',", "            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-0',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaaa#active',\n            },\n            weight: 1,\n          },\n          {\n            condition: {", "          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-1',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaac#active',\n            },\n            weight: 1,\n          },\n          {", "          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-2',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaaf#active',\n            },\n            weight: 1,\n          },", "            weight: 1,\n          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-3',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaag#active',\n            },\n            weight: 1,", "            },\n            weight: 1,\n          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-4',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaah#active',\n            },", "              conditionDelegated: 'id:eosio:eos::eoscanadaaah#active',\n            },\n            weight: 1,\n          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#day2day-5',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaai#active',", "              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaai#active',\n            },\n            weight: 1,\n          },\n        ],\n        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n      },\n      {\n        id: 'did:eosio:eos:eoscanadacom#eosforumdapp',", "      {\n        id: 'did:eosio:eos:eoscanadacom#eosforumdapp',\n        controller: 'did:eosio:eos:eoscanadacom',\n        type: 'VerifiableCondition',\n        threshold: 1,\n        conditionWeightedThreshold: [\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#eosforumdapp-0',\n              controller: 'did:eosio:eos:eoscanadacom',", "              id: 'did:eosio:eos:eoscanadacom#eosforumdapp-0',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'EcdsaSecp256k1VerificationKey2019',\n              publicKeyJwk: {\n                crv: 'secp256k1',\n                kty: 'EC',\n                x: 'XWelm_LA5OvSwDPBQT_dwxWZ1Li1BiYbP3w2yhkcb6k',\n                y: 'wfydp1B25ylTsaR-W1Wld6TVLnJHXGgC7AgJ50Y0FHM',\n                kid: 'PUB_K1_7YNS1swh6QWANkzGgFrjiX8E3u8WK5CK9GMAb6EzKVNZKnMUfs',\n              },", "                kid: 'PUB_K1_7YNS1swh6QWANkzGgFrjiX8E3u8WK5CK9GMAb6EzKVNZKnMUfs',\n              },\n            },\n            weight: 1,\n          },\n        ],\n        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n      },\n      {\n        id: 'did:eosio:eos:eoscanadacom#owner',", "      {\n        id: 'did:eosio:eos:eoscanadacom#owner',\n        controller: 'did:eosio:eos:eoscanadacom',\n        type: 'VerifiableCondition',\n        threshold: 5,\n        conditionWeightedThreshold: [\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-0',\n              controller: 'did:eosio:eos:eoscanadacom',", "              id: 'did:eosio:eos:eoscanadacom#owner-0',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaaa#active',\n            },\n            weight: 2,\n          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-1',", "            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-1',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaab#active',\n            },\n            weight: 2,\n          },\n          {\n            condition: {", "          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-2',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaac#active',\n            },\n            weight: 2,\n          },\n          {", "          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-3',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaad#active',\n            },\n            weight: 2,\n          },", "            weight: 2,\n          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-4',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaae#active',\n            },\n            weight: 2,", "            },\n            weight: 2,\n          },\n          {\n            condition: {\n              id: 'did:eosio:eos:eoscanadacom#owner-5',\n              controller: 'did:eosio:eos:eoscanadacom',\n              type: 'VerifiableCondition',\n              conditionDelegated: 'id:eosio:eos::eoscanadaaaf#active',\n            },", "              conditionDelegated: 'id:eosio:eos::eoscanadaaaf#active',\n            },\n            weight: 1,\n          },\n        ],\n      },\n    ],\n    service: [\n      {\n        id: 'https://eos.greymass.com',", "      {\n        id: 'https://eos.greymass.com',\n        type: 'LinkedDomains',\n        serviceEndpoint: 'https://eos.greymass.com',\n      },\n      {\n        id: 'https://eos.dfuse.eosnation.io',\n        type: 'LinkedDomains',\n        serviceEndpoint: 'https://eos.dfuse.eosnation.io',\n      },", "        serviceEndpoint: 'https://eos.dfuse.eosnation.io',\n      },\n    ],\n  },\n  {\n    '@context': 'https://w3id.org/did/v0.11',\n    id: 'did:meta:0000000000000000000000000000000000000000000000000000000000005e65',\n    publicKey: [\n      {\n        id: 'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',", "      {\n        id: 'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n        type: 'EcdsaSecp256k1VerificationKey2019',\n        controller:\n          'did:meta:0000000000000000000000000000000000000000000000000000000000005e65',\n        publicKeyHex:\n          '041e5281968ebdd9266b7b841dd6f8ae9088b8399a1eab172ecad2cc5f98a795c98c82e60d58263c4cdfc7ff4ebafea06ab9cfdcdfb5529965b42817db331d66ce',\n      },\n    ],\n    authentication: [", "    ],\n    authentication: [\n      'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n    ],\n    service: [\n      {\n        id: 'did:meta:0000000000000000000000000000000000000000000000000000000000000527',\n        publicKey:\n          'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n        type: 'identityHub',", "          'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n        type: 'identityHub',\n        serviceEndpoint: 'https://datahub.metadium.com',\n      },\n    ],\n  },\n  {\n    authentication: ['did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#verkey'],\n    id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw',\n    service: [", "    id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw',\n    service: [\n      {\n        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#xdi',\n        serviceEndpoint:\n          'https://xdi03-at.danubeclouds.com/cl/+!:did:sov:WRfXPg8dantKVubE3HX8pw',\n        type: 'xdi',\n      },\n      {\n        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#agent',", "      {\n        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#agent',\n        serviceEndpoint:\n          'https://agents.danubeclouds.com/agent/WRfXPg8dantKVubE3HX8pw',\n        type: 'agent',\n      },\n    ],\n    verificationMethod: [\n      {\n        controller: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw',", "      {\n        controller: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw',\n        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#verkey',\n        publicKeyBase58: 'H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV',\n        type: 'Ed25519VerificationKey2018',\n      },\n    ],\n  },\n  {\n    '@context': [", "  {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      {\n        '@vocab': 'https://www.iana.org/assignments/jose#',\n      },\n    ],\n    id: 'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ',\n    verificationMethod: [\n      {", "    verificationMethod: [\n      {\n        id: 'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n        type: 'JsonWebKey2020',\n        controller:\n          'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ',\n        publicKeyJwk: {\n          kid: 'urn:ietf:params:oauth:jwk-thumbprint:sha-256:FfMbzOjMmQ4efT6kvwTIJjelTqjl0xjEIWQ2qobsRMM',\n          kty: 'OKP',\n          crv: 'Ed25519',", "          kty: 'OKP',\n          crv: 'Ed25519',\n          alg: 'EdDSA',\n          x: 'ANRjH_zxcKBxsjRPUtzRbp7FSVLKJXQ9APX9MP1j7k4',\n        },\n      },\n    ],\n    authentication: [\n      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n    ],", "      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n    ],\n    assertionMethod: [\n      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n    ],\n    capabilityInvocation: [\n      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n    ],\n    capabilityDelegation: [\n      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',", "    capabilityDelegation: [\n      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n    ],\n  },\n  {\n    '@context': [\n      'https://www.w3.org/ns/did/v1',\n      {\n        '@base': 'did:web:did.actor:bob',\n      },", "        '@base': 'did:web:did.actor:bob',\n      },\n    ],\n    id: 'did:web:did.actor:bob',\n    publicKey: [\n      {\n        id: '#z6MkkQBvgvqb6zGvS4cydworpUaRDzpszSFixq49ahbDeUTG',\n        type: 'Ed25519VerificationKey2018',\n        controller: '',\n        publicKeyBase58: '6wvt6gb9mSnTKZnGxNr1yP2RQRZ2aZ1NGp9DkRdCjFft',", "        controller: '',\n        publicKeyBase58: '6wvt6gb9mSnTKZnGxNr1yP2RQRZ2aZ1NGp9DkRdCjFft',\n      },\n    ],\n  },\n]\n"]}
{"filename": "tests/utils/createDidExtractPartsTest.ts", "chunked_list": ["import { it } from 'node:test'\nimport assert from 'node:assert'\nimport { Did, DidParts, DidUrlParts } from '../../src'\n\nexport const createDidExtractPartsTest = (\n  did: string,\n  expectedParts: DidParts\n) => {\n  it(`should extract did parts from ${did}`, () => {\n    assert.deepStrictEqual(new Did(did).didParts, expectedParts)", "  it(`should extract did parts from ${did}`, () => {\n    assert.deepStrictEqual(new Did(did).didParts, expectedParts)\n  })\n}\n\nexport const createDidExtractUrlPartsTest = (\n  did: string,\n  expectedUrlParts: DidUrlParts\n) => {\n  it(`should extract did url parts from ${did}`, () => {", ") => {\n  it(`should extract did url parts from ${did}`, () => {\n    assert.deepStrictEqual(new Did(did).didUrlParts, expectedUrlParts)\n  })\n}\n"]}
{"filename": "tests/utils/createDidValidationTest.ts", "chunked_list": ["import { it } from 'node:test'\nimport assert from 'node:assert'\nimport { Did } from '../../src'\n\nexport const createDidValidationTest = (did: string) => {\n  it(`should validate ${did}`, (_) => {\n    assert.strictEqual(Did.validateDidUrl(did), true)\n  })\n}\n", "}\n"]}
{"filename": "tests/utils/index.ts", "chunked_list": ["export * from './createDidExtractPartsTest'\nexport * from './createDidValidationTest'\nexport * from './createDidIsDidUrlTest'\n"]}
{"filename": "tests/utils/createDidIsDidUrlTest.ts", "chunked_list": ["import { Did } from '../../src'\nimport { it } from 'node:test'\nimport assert from 'node:assert'\n\nexport const createDidIsDidUrlValidationTest = (\n  did: string,\n  expected: boolean\n) =>\n  it(`should validate if did is url for ${did}`, () => {\n    const instance = new Did(did)", "  it(`should validate if did is url for ${did}`, () => {\n    const instance = new Did(did)\n    assert.strictEqual(instance.isDidUrl(), expected)\n  })\n"]}
{"filename": "tests/utils/createDidDocumentConstructTest.ts", "chunked_list": ["import { DidDocument, DidDocumentOptions } from '../../src'\nimport assert from 'node:assert'\nimport { it } from 'node:test'\n\nexport const createDidDocumentConstructTest = (\n  didDocument: DidDocumentOptions\n) =>\n  it(`should construct the did document for ${didDocument.id}`, () => {\n    const instance = new DidDocument(didDocument)\n    assert.strictEqual(instance.id.toString(), didDocument.id)", "    const instance = new DidDocument(didDocument)\n    assert.strictEqual(instance.id.toString(), didDocument.id)\n  })\n"]}
{"filename": "src/representations.ts", "chunked_list": ["export enum Representations {\n  /**\n   * @see {@link https://www.w3.org/TR/did-core#json | DID Core}\n   */\n  DidJson = 'application/did+json',\n  /**\n   * JSON-LD has a representation-specific entry, which is the `@context` field inside the DID Document.\n   *\n   * @see {@link https://www.w3.org/TR/did-core#json | DID Core}\n   * @see {@link https://w3c.github.io/did-core/ | DID Core 1.0 Working draft }\n   *\n   * @example\n   * {\n   *  \"@context\": [\n   *    \"https://www.w3.org/ns/did/v1\",\n   *    \"https://example.com/blockchain-identity/v1\"\n   *  ],\n   *  ...\n   * }\n   */\n  DidJsonLd = 'application/did+ld+json',\n  /**\n   * @see {@link https://www.w3.org/TR/did-cbor-representation/#application-did-cbor | The Plain CBOR Representation}\n   */\n  DidCbor = 'application/did+cbor',\n}\n"]}
{"filename": "src/verificationMethodTypes.ts", "chunked_list": ["/**\n * These are values to be used for the type in a verification method object.\n *\n * @see {@link https://www.w3.org/TR/did-spec-registries/#verification-method-types}\n *\n * @note Do not include private or extraneous information in verification methods. The class of private information related to JWKs is defined here. Please review the DID Core specification for additional details on this topic.\n */\nexport enum VerificationMethodTypes {\n  /**\n   * @see {@link https://w3c-ccg.github.io/lds-jws2020/ | Normative definition}\n   * @see {@link https://w3id.org/security/suite/jws-2020/v1 | JSON-LD}\n   *\n   * @example\n   * {\n   *  \"id\": \"did:example:123#_TKzHv2jFIyvdTGF1Dsgwngfdg3SH6TpDv0Ta1aOEkw\",\n   *  \"type\": \"JsonWebKey2020\",\n   *  \"controller\": \"did:example:123\",\n   *  \"publicKeyJwk\": {\n   *    \"crv\": \"P-256\",\n   *    \"x\": \"38M1FDts7Oea7urmseiugGW7tWc3mLpJh6rKe7xINZ8\",\n   *    \"y\": \"nDQW6XZ7b_u2Sy9slofYLlG03sOEoug3I0aAPQ0exs4\",\n   *    \"kty\": \"EC\",\n   *    \"kid\": \"_TKzHv2jFIyvdTGF1Dsgwngfdg3SH6TpDv0Ta1aOEkw\"\n   *  }\n   * }\n   */\n  JsonWebKey2020 = 'JsonWebKey2020',\n  /**\n   * @see {@link https://w3c-ccg.github.io/lds-ecdsa-secp256k1-2019/ | Normative definition}\n   * @see {@link https://w3id.org/security/suites/secp256k1-2019 | JSON-LD}\n   *\n   * @example\n   * {\n   *  \"id\": \"did:example:123#WjKgJV7VRw3hmgU6--4v15c0Aewbcvat1BsRFTIqa5Q\",\n   *  \"type\": \"EcdsaSecp256k1VerificationKey2019\",\n   *  \"controller\": \"did:example:123\",\n   *  \"publicKeyJwk\": {\n   *    \"crv\": \"secp256k1\",\n   *    \"x\": \"NtngWpJUr-rlNNbs0u-Aa8e16OwSJu6UiFf0Rdo1oJ4\",\n   *    \"y\": \"qN1jKupJlFsPFc1UkWinqljv4YE0mq_Ickwnjgasvmo\",\n   *    \"kty\": \"EC\",\n   *    \"kid\": \"WjKgJV7VRw3hmgU6--4v15c0Aewbcvat1BsRFTIqa5Q\"\n   *  }\n   * }\n   */\n  EcdsaSecp256k1VerificationKey2019 = 'EcdsaSecp256k1VerificationKey2019',\n  /**\n   * @see {@link https://w3c-ccg.github.io/lds-ed25519-2018/ | Normative definition}\n   * @see {@link https://w3id.org/security/suites/ed25519-2018/v1 | JSON-LD}\n   *\n   * @example\n   * {\n   *  \"id\": \"did:example:123#ZC2jXTO6t4R501bfCXv3RxarZyUbdP2w_psLwMuY6ec\",\n   *  \"type\": \"Ed25519VerificationKey2018\",\n   *  \"controller\": \"did:example:123\",\n   *  \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\"\n   * }\n   */\n  Ed25519VerificationKey2018 = 'Ed25519VerificationKey2018',\n  /**\n   * @see {@link https://w3c-ccg.github.io/ldp-bbs2020/ | Normative definition}\n   * @see {@link https://w3id.org/security/suites/bls12381-2020/v1 | JSON-LD}\n   *\n   * @example\n   * {\n   *  \"id\": \"did:example:123#z3tEGVtEKzdhJB2rT5hLVjwQPis8k7bTM16t7vDZrQaoddk6wZ7or6xPPs1P8H9U16Xe75\",\n   *  \"type\": \"Bls12381G1Key2020\",\n   *  \"controller\": \"did:example:123\",\n   *  \"publicKeyBase58\": \"7bXhTVonHPizXP72AE92PPmRiaXipC519yU7F6NxUFExWpyQo57LuKKBoTyuZ3uWm9\",\n   * }\n   */\n  Bls12381G1Key2020 = 'Bls12381G1Key2020',\n  /**\n   * @see {@link https://w3c-ccg.github.io/ldp-bbs2020/ | Normative definition}\n   * @see {@link https://w3id.org/security/suites/bls12381-2020/v1 | JSON-LD}\n   *\n   * @example\n   * {\n   *   \"id\": \"did:example:123#zUC7K51WYEsj8y6KPVa1XfwdW5ZJrW5kSbMV619j128T6atCLLXJjjovMZsJ3Ay4STdngRkvM4ygT4qm1mk6HR8FvipSY435nLgYS1TTcaqJAzDWzM1iB9vh3hTL1DEKitwn56i\",\n   *   \"type\": \"Bls12381G2Key2020\",\n   *   \"controller\": \"did:example:123\",\n   *   \"publicKeyBase58\": \"25ETdUZDVnME6yYuAMjFRCnCPcDmYQcoZDcZuXAfeMhXPvjZg35QmZ7uctBcovA69YDM3Jf7s5BHo4u1y89nY6mHiji8yphZ4AMm4iNCRh35edSg76Dkasu3MY2VS9LnuaVQ\",\n   * }\n   */\n  Bls12381G2Key2020 = 'Bls12381G2Key2020',\n  /**\n   * @see {@link https://w3id.org/security/suites/pgp-2021#PgpVerificationKey2021 | Normative definition}\n   * @see {@link https://w3id.org/security/suites/pgp-2021/v1 | JSON-LD}\n   *\n   * @note Use of this verification key should be in line with the OpenPGP Message Format as defined in {@link https://datatracker.ietf.org/doc/html/rfc4880 | RFC 4880}\n   *\n   * @example\n   * {\n   *  \"@context\":[\n   *    \"https://www.w3.org/ns/did/v1\",\n   *    \"https://gpg.jsld.org/contexts/lds-gpg2020-v0.0.jsonld\"\n   *  ],\n   *  \"id\":\"did:example:123\",\n   *  \"verificationMethod\":[{\n   *    \"id\": \"did:example:123#989ed1057a294c8a3665add842e784c4d08de1e2\",\n   *    \"type\": \"PgpVerificationKey2021\",\n   *    \"controller\": \"did:example:123\",\n   *    \"publicKeyPgp\": \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v4.9.0\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nxjMEXkm5LRYJKwYBBAHaRw8BAQdASmfrjYr7vrjwHNiBsdcImK397Vc3t4BL\\r\\nE8rnN......v6\\r\\nDw==\\r\\n=wSoi\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n\"\n   *  }]\n   * }\n   */\n  PgpVerificationKey2021 = 'PgpVerificationKey2021',\n  /**\n   * @see {@link https://w3c-ccg.github.io/lds-rsa2018/ | Normative definition}\n   * @see {@link https://www.w3.org/2018/credentials/v1 | JSON-LD}\n   *\n   * @note {@link https://github.com/w3c/did-spec-registries/issues/370 | DID Specification Registries Issue 370} This property should be moved into a separate suite and linked to here rather than relying on the Verifiable Credentials vocabulary. There are known issues with the first version of the Security vocabulary JSON-LD context and the first version of the Verifiable Credentials JSON-LD context which will prevent these contexts from being listed in the same document. For now it's suggested that implementers rely upon the first version of the Verifiable Credentials JSON-LD context and not rely on the Security vocabulary JSON-LD context in the same document.\n   *\n   * @example\n   * {\n   *  \"id\": \"did:example:123#key-0\",\n   *  \"type\": \"RsaVerificationKey2018\",\n   *  \"controller\": \"did:example:123\",\n   *  \"publicKeyJwk\": {\n   *    \"kty\":\"RSA\",\n   *    \"e\":\"AQAB\",\n   *    \"use\":\"sig\",\n   *    \"kid\":\"tNksV42EUs3Xct9AkgZyFWglItRGMxVZ1A1XM68SNq0\n   *    \"n\":\"kO2d_qQTEBjYFGcoY_da7ziFY4L2QX14K7snCee09n-cY2eP-oJXk8T2_lL20YnpYhf4i\n   *    jhkWHGU8kY8-FWPRrzSeu3JUMVSZoqTgoAiKWdnSLNvPVxvGuD2CiA3T6AkwUC03D2AkOLCcJV\n   *    8h_hxUEPeDawF7ArpuJW5DXzEJjE7gOjN4r6d7VB6sd5y-3la54H2ADz2amHLdBWs30fL4BRBH\n   *    lVdx0YmF37V4u5yvnnb5Iyr3kBXJes8t0MUMPkjqEEXRmukpKUzZYNpWDXY0tVcXeK5sRx0DAn\n   *    lNgNNf14-vsyjGkj2Rz0oGW73jjWa8dw-yVlDEHyIkQU9-UY4dFXbVjdIO8j_5ghh62o1T7Y4w\n   *    5CWMc-FxPE3LHe-_teW97X__NN-ToYgfi42IvV2mYOdQMCbvnvY2oMdK3b9wmeVi0marToauL5\n   *    LMg5xHDKopmIR7E3VyRtNYwDFAZ89kadcbSrZ8zTR5APaB7Tmp2L2ZfXKxqKQuxlFTTCcZtg4e\n   *    5AN8QuYdI18DEDQn2umUU_Twj7k4CXvuIKVL8p4yRHC4CHAGIm9cH_t11dF3wXygaENVOGRXQu\n   *    0g1iKq0mO2rWpOqkGJ5uXMFb5lx54i8uOjCdZ9y2el28xA55Ve95KCxeTHp997Bn3TIgbeQ-B_\n   *    -3PBVTuuAAH8y9fFNKtu5E\"\n   *  }\n   * }\n   */\n  RsaVerificationKey2018 = 'RsaVerificationKey2018',\n  /**\n   * Normative definition pending\n   * @see {@link http://w3id.org/security/suites/x25519-2019/v1 | JSON-LD}\n   *\n   * @note Normative definition in a suite is required for registration, this entry should be updated or removed.\n   */\n  X25519KeyAgreementKey2019 = 'X25519KeyAgreementKey2019',\n  /**\n   * @see {@link https://identity.foundation/EcdsaSecp256k1RecoverySignature2020/#ES256K-R | Normative definition}\n   * @see {@link https://w3id.org/security/suites/secp256k1recovery-2020/v1 | JSON-LD}\n   *\n   * @example\n   * {\n   *  \"@context\": [\n   *    \"https://www.w3.org/ns/did/v1\",\n   *    \"https://identity.foundation/EcdsaSecp256k1RecoverySignature2020#\"\n   *  ],\n   *  \"id\":\"did:example:123\",\n   *  \"verificationMethod\": [\n   *    {\n   *      \"id\": \"did:example:123#vm-1\",\n   *      \"controller\": \"did:example:123\",\n   *      \"type\": \"EcdsaSecp256k1RecoveryMethod2020\",\n   *      \"publicKeyJwk\": {\n   *        \"crv\": \"secp256k1\",\n   *        \"kid\": \"JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw\",\n   *        \"kty\": \"EC\",\n   *        \"x\": \"dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A\",\n   *        \"y\": \"36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA\"\n   *      }\n   *    },\n   *    {\n   *      \"id\": \"did:example:123#vm-2\",\n   *      \"controller\": \"did:example:123\",\n   *      \"type\": \"EcdsaSecp256k1RecoveryMethod2020\",\n   *      \"publicKeyHex\": \"027560af3387d375e3342a6968179ef3c6d04f5d33b2b611cf326d4708badd7770\"\n   *    },\n   *    {\n   *      \"id\": \"did:example:123#vm-3\",\n   *      \"controller\": \"did:example:123\",\n   *      \"type\": \"EcdsaSecp256k1RecoveryMethod2020\",\n   *      \"ethereumAddress\": \"0xF3beAC30C498D9E26865F34fCAa57dBB935b0D74\"\n   *    }\n   *  ]\n   * }\n   */\n  EcdsaSecp256k1RecoveryMethod2020 = 'EcdsaSecp256k1RecoveryMethod2020',\n  /**\n   * @see {@link https://w3c-ccg.github.io/verifiable-conditions | Normative definition}\n   * @see {@link https://w3c-ccg.github.io/verifiable-conditions/contexts/verifiable-conditions-2021-v1.json | JSON-LD}\n   *\n   * @example\n   * {\n   *    \"id\": \"did:example:123#1\",\n   *    \"controller\": \"did:example:123\",\n   *    \"type\": \"VerifiableCondition2021\",\n   *    \"conditionAnd\": [{\n   *        \"id\": \"did:example:123#1-1\",\n   *        \"controller\": \"did:example:123\",\n   *        \"type\": \"VerifiableCondition2021\",\n   *        \"conditionOr\": [{\n   *            \"id\": \"did:example:123#1-1-1\",\n   *            \"controller\": \"did:example:123\",\n   *            \"type\": \"EcdsaSecp256k1VerificationKey2019\",\n   *            \"publicKeyBase58\": \"5JBxKqYKzzoHrzeqwp6zXk8wZU3Ah94ChWAinSj1fYmyJvJS5rT\"\n   *        }, {\n   *            \"id\": \"did:example:123#1-1-2\",\n   *            \"controller\": \"did:example:123\",\n   *            \"type\": \"Ed25519VerificationKey2018\",\n   *            \"publicKeyBase58\": \"PZ8Tyr4Nx8MHsRAGMpZmZ6TWY63dXWSCzamP7YTHkZc78MJgqWsAy\"\n   *        }]\n   *    }, {\n   *        \"id\": \"did:example:123#1-2\",\n   *        \"controller\": \"did:example:123\",\n   *        \"type\": \"Ed25519VerificationKey2018\",\n   *        \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\"\n   *    }]\n   * }\n   */\n  VerifiableCondition2021 = 'VerifiableCondition2021',\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type Modify<T, R> = Omit<T, keyof R> & R\n\nexport type Impossible<T, K extends keyof T> = Omit<T, K> & { [P in K]: never }\n\nexport type OrPromise<T> = T | Promise<T>\n\nexport type MakePropertyRequired<T, K extends keyof T> = T &\n  Required<Pick<T, K>>\n"]}
{"filename": "src/didDocument.ts", "chunked_list": ["import { z } from 'zod'\nimport { Did } from './did'\nimport { Service, ServiceOptions } from './service'\nimport {\n  VerificationMethod,\n  VerificationMethodOptions,\n} from './verificationMethod'\nimport {\n  didDocumentSchema,\n  stringOrDid,", "  didDocumentSchema,\n  stringOrDid,\n  uniqueServicesSchema,\n  uniqueStringOrVerificationMethodsSchema,\n  uniqueVerificationMethodsSchema,\n} from './schemas'\nimport { DidDocumentError } from './error'\nimport { MakePropertyRequired, Modify } from './types'\n\ntype DidOrVerificationMethodArray = Array<VerificationMethodOrDidOrString>\n", "\ntype DidOrVerificationMethodArray = Array<VerificationMethodOrDidOrString>\n\ntype VerificationMethodOrDidOrString =\n  | VerificationMethod\n  | VerificationMethodOptions\n  | Did\n  | string\n\nexport type DidDocumentOptions<T extends Record<string, unknown> = {}> = Modify<\n  z.input<typeof didDocumentSchema>,\n  {\n    verificationMethod?: Array<VerificationMethodOptions>\n    authentication?: DidOrVerificationMethodArray\n    assertionMethod?: DidOrVerificationMethodArray\n    keyAgreement?: DidOrVerificationMethodArray\n    capabilityInvocation?: DidOrVerificationMethodArray\n    capabilityDelegation?: DidOrVerificationMethodArray\n    service?: Array<ServiceOptions | Service>\n  }\n> &\n  Record<string, unknown> &\n  T\n", "export type DidDocumentOptions<T extends Record<string, unknown> = {}> = Modify<\n  z.input<typeof didDocumentSchema>,\n  {\n    verificationMethod?: Array<VerificationMethodOptions>\n    authentication?: DidOrVerificationMethodArray\n    assertionMethod?: DidOrVerificationMethodArray\n    keyAgreement?: DidOrVerificationMethodArray\n    capabilityInvocation?: DidOrVerificationMethodArray\n    capabilityDelegation?: DidOrVerificationMethodArray\n    service?: Array<ServiceOptions | Service>\n  }\n> &\n  Record<string, unknown> &\n  T\n", "type ReturnBuilderWithAlsoKnownAs<T extends DidDocument> = MakePropertyRequired<\n  T,\n  'alsoKnownAs'\n>\ntype ReturnBuilderWithController<T extends DidDocument> = MakePropertyRequired<\n  T,\n  'controller'\n>\ntype ReturnBuilderWithVerificationMethod<T extends DidDocument> =\n  MakePropertyRequired<T, 'verificationMethod'>\ntype ReturnBuilderWithAuthentication<T extends DidDocument> =\n  MakePropertyRequired<T, 'authentication'>", "type ReturnBuilderWithVerificationMethod<T extends DidDocument> =\n  MakePropertyRequired<T, 'verificationMethod'>\ntype ReturnBuilderWithAuthentication<T extends DidDocument> =\n  MakePropertyRequired<T, 'authentication'>\ntype ReturnBuilderWithAssertionMethod<T extends DidDocument> =\n  MakePropertyRequired<T, 'assertionMethod'>\ntype ReturnBuilderWithKeyAgreementMethod<T extends DidDocument> =\n  MakePropertyRequired<T, 'keyAgreement'>\ntype ReturnBuilderWithCapabilityInvocation<T extends DidDocument> =\n  MakePropertyRequired<T, 'capabilityInvocation'>\ntype ReturnBuilderWithCapabilityDelegation<T extends DidDocument> =\n  MakePropertyRequired<T, 'capabilityDelegation'>", "type ReturnBuilderWithCapabilityInvocation<T extends DidDocument> =\n  MakePropertyRequired<T, 'capabilityInvocation'>\ntype ReturnBuilderWithCapabilityDelegation<T extends DidDocument> =\n  MakePropertyRequired<T, 'capabilityDelegation'>\ntype ReturnBuilderWithService<T extends DidDocument> = MakePropertyRequired<\n  T,\n  'service'\n>\n\nexport class DidDocument {\n  public fullDocument: DidDocumentOptions\n\n  public id: Did\n  public alsoKnownAs?: Array<string>\n  public controller?: Did | Array<Did>\n  public verificationMethod?: Array<VerificationMethod>\n  public authentication?: Array<VerificationMethod | Did>\n  public assertionMethod?: Array<VerificationMethod | Did>\n  public keyAgreement?: Array<VerificationMethod | Did>\n  public capabilityInvocation?: Array<VerificationMethod | Did>\n  public capabilityDelegation?: Array<VerificationMethod | Did>\n  public service?: Array<Service>\n\n  public constructor(options: DidDocumentOptions) {\n    this.fullDocument = options\n    const parsed = didDocumentSchema.parse(options)\n\n    this.id = parsed.id\n    this.alsoKnownAs = parsed.alsoKnownAs\n    this.controller = parsed.controller\n    this.verificationMethod = parsed.verificationMethod\n    this.authentication = parsed.authentication\n    this.assertionMethod = parsed.assertionMethod\n    this.keyAgreement = parsed.keyAgreement\n    this.capabilityDelegation = parsed.capabilityDelegation\n    this.capabilityInvocation = parsed.capabilityInvocation\n    this.service = parsed.service\n  }\n\n  public findVerificationMethodByDidUrl(didUrl: z.input<typeof stringOrDid>) {\n    const did = stringOrDid.parse(didUrl)\n\n    const verificationMethod = this.verificationMethod?.find(\n      (verificationMethod) => verificationMethod.id.toUrl() === did.toUrl()\n    )\n", "export class DidDocument {\n  public fullDocument: DidDocumentOptions\n\n  public id: Did\n  public alsoKnownAs?: Array<string>\n  public controller?: Did | Array<Did>\n  public verificationMethod?: Array<VerificationMethod>\n  public authentication?: Array<VerificationMethod | Did>\n  public assertionMethod?: Array<VerificationMethod | Did>\n  public keyAgreement?: Array<VerificationMethod | Did>\n  public capabilityInvocation?: Array<VerificationMethod | Did>\n  public capabilityDelegation?: Array<VerificationMethod | Did>\n  public service?: Array<Service>\n\n  public constructor(options: DidDocumentOptions) {\n    this.fullDocument = options\n    const parsed = didDocumentSchema.parse(options)\n\n    this.id = parsed.id\n    this.alsoKnownAs = parsed.alsoKnownAs\n    this.controller = parsed.controller\n    this.verificationMethod = parsed.verificationMethod\n    this.authentication = parsed.authentication\n    this.assertionMethod = parsed.assertionMethod\n    this.keyAgreement = parsed.keyAgreement\n    this.capabilityDelegation = parsed.capabilityDelegation\n    this.capabilityInvocation = parsed.capabilityInvocation\n    this.service = parsed.service\n  }\n\n  public findVerificationMethodByDidUrl(didUrl: z.input<typeof stringOrDid>) {\n    const did = stringOrDid.parse(didUrl)\n\n    const verificationMethod = this.verificationMethod?.find(\n      (verificationMethod) => verificationMethod.id.toUrl() === did.toUrl()\n    )\n", "    if (!verificationMethod) {\n      throw new DidDocumentError(\n        `Verification method for did '${did.toString()}' not found`\n      )\n    }\n\n    return verificationMethod\n  }\n\n  public safeFindToVerificationMethodByDidUrl(\n    didUrl: z.input<typeof stringOrDid>\n  ) {", "    try {\n      return this.findVerificationMethodByDidUrl(didUrl)\n    } catch {\n      return undefined\n    }\n  }\n\n  public addAlsoKnownAs(\n    alsoKnownAs: string\n  ): ReturnBuilderWithAlsoKnownAs<this> {\n    if (this.alsoKnownAs) {\n      this.alsoKnownAs.push(alsoKnownAs)\n    } else {\n      this.alsoKnownAs = [alsoKnownAs]\n    }\n\n    return this as ReturnBuilderWithAlsoKnownAs<this>\n  }\n\n  public addController(\n    controller: string | Did,\n    asArray = true\n  ): ReturnBuilderWithController<this> {\n    const instancedController =\n      typeof controller === 'string' ? new Did(controller) : controller\n", "    if (this.alsoKnownAs) {\n      this.alsoKnownAs.push(alsoKnownAs)\n    } else {\n      this.alsoKnownAs = [alsoKnownAs]\n    }\n\n    return this as ReturnBuilderWithAlsoKnownAs<this>\n  }\n\n  public addController(\n    controller: string | Did,\n    asArray = true\n  ): ReturnBuilderWithController<this> {\n    const instancedController =\n      typeof controller === 'string' ? new Did(controller) : controller\n", "    if (this.controller) {\n      if (Array.isArray(this.controller)) {\n        this.controller.push(instancedController)\n      } else {\n        this.controller = [this.controller, instancedController]\n      }\n    } else {\n      this.controller = asArray ? [instancedController] : instancedController\n    }\n\n    return this as ReturnBuilderWithController<this>\n  }\n\n  public addVerificationMethod(\n    verificationMethod: VerificationMethodOptions\n  ): ReturnBuilderWithVerificationMethod<this> {", "    if (this.verificationMethod) {\n      this.verificationMethod.push(new VerificationMethod(verificationMethod))\n    } else {\n      this.verificationMethod = [new VerificationMethod(verificationMethod)]\n    }\n\n    uniqueVerificationMethodsSchema.parse(this.verificationMethod)\n\n    return this as ReturnBuilderWithVerificationMethod<this>\n  }\n\n  public addAuthentication(\n    verificationMethodOrDidOrString: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithAuthentication<this> {\n    this.authentication = this.addVerificationMethodOrDidOrString(\n      'authentication',\n      this.authentication,\n      verificationMethodOrDidOrString\n    )\n\n    return this as ReturnBuilderWithAuthentication<this>\n  }\n\n  public addAuthenticationUnsafe(\n    verificationMethodOrDidOrString: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithAuthentication<this> {\n    this.authentication = this.addVerificationMethodOrDidOrString(\n      'authentication',\n      this.authentication,\n      verificationMethodOrDidOrString,\n      true\n    )\n\n    return this as ReturnBuilderWithAuthentication<this>\n  }\n\n  public addKeyAgreement(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithKeyAgreementMethod<this> {\n    this.keyAgreement = this.addVerificationMethodOrDidOrString(\n      'keyAgreement',\n      this.keyAgreement,\n      verificationMethodOrStringOrDid\n    )\n\n    return this as ReturnBuilderWithKeyAgreementMethod<this>\n  }\n\n  public addKeyAgreementUnsafe(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithKeyAgreementMethod<this> {\n    this.keyAgreement = this.addVerificationMethodOrDidOrString(\n      'keyAgreement',\n      this.keyAgreement,\n      verificationMethodOrStringOrDid,\n      true\n    )\n\n    return this as ReturnBuilderWithKeyAgreementMethod<this>\n  }\n\n  public addAssertionMethod(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithAssertionMethod<this> {\n    this.assertionMethod = this.addVerificationMethodOrDidOrString(\n      'assertionMethod',\n      this.assertionMethod,\n      verificationMethodOrStringOrDid\n    )\n\n    return this as ReturnBuilderWithAssertionMethod<this>\n  }\n\n  public addAssertionMethodUnsafe(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithAssertionMethod<this> {\n    this.assertionMethod = this.addVerificationMethodOrDidOrString(\n      'assertionMethod',\n      this.assertionMethod,\n      verificationMethodOrStringOrDid,\n      true\n    )\n\n    return this as ReturnBuilderWithAssertionMethod<this>\n  }\n\n  public addCapabilityDelegation(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithCapabilityDelegation<this> {\n    this.capabilityDelegation = this.addVerificationMethodOrDidOrString(\n      'capabilityDelegation',\n      this.capabilityDelegation,\n      verificationMethodOrStringOrDid\n    )\n\n    return this as ReturnBuilderWithCapabilityDelegation<this>\n  }\n\n  public addCapabilityDelegationUnsafe(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithCapabilityDelegation<this> {\n    this.capabilityDelegation = this.addVerificationMethodOrDidOrString(\n      'capabilityDelegation',\n      this.capabilityDelegation,\n      verificationMethodOrStringOrDid,\n      true\n    )\n\n    return this as ReturnBuilderWithCapabilityDelegation<this>\n  }\n\n  public addCapabilityInvocation(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithCapabilityInvocation<this> {\n    this.capabilityInvocation = this.addVerificationMethodOrDidOrString(\n      'capabilityInvocation',\n      this.capabilityInvocation,\n      verificationMethodOrStringOrDid\n    )\n\n    return this as ReturnBuilderWithCapabilityInvocation<this>\n  }\n\n  public addCapabilityInvocationUnsafe(\n    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n  ): ReturnBuilderWithCapabilityInvocation<this> {\n    this.capabilityInvocation = this.addVerificationMethodOrDidOrString(\n      'capabilityInvocation',\n      this.capabilityInvocation,\n      verificationMethodOrStringOrDid,\n      true\n    )\n\n    return this as ReturnBuilderWithCapabilityInvocation<this>\n  }\n\n  public addService(service: ServiceOptions): ReturnBuilderWithService<this> {\n    const instanceService = new Service(service)", "    if (this.service) {\n      this.service.push(instanceService)\n    } else {\n      this.service = [instanceService]\n    }\n\n    uniqueServicesSchema.parse(this.service)\n\n    return this as ReturnBuilderWithService<this>\n  }\n\n  private addVerificationMethodOrDidOrString(\n    fieldName: string,\n    previousItem: Array<VerificationMethod | Did> | undefined,\n    verificationMethodOrDidOrString: VerificationMethodOrDidOrString,\n    unsafe = false\n  ) {\n    let newItem = previousItem\n\n    const id =\n      verificationMethodOrDidOrString instanceof Did\n        ? verificationMethodOrDidOrString\n        : typeof verificationMethodOrDidOrString === 'string'\n        ? new Did(verificationMethodOrDidOrString)\n        : undefined\n", "    if (id && !unsafe) {\n      const verificationMethodIds = this.verificationMethod?.map((vm) =>\n        vm.id.toUrl()\n      )\n      if (\n        verificationMethodIds === undefined ||\n        !verificationMethodIds.includes(id.toUrl())\n      ) {\n        throw new DidDocumentError(\n          `Tried to add '${id.toUrl()}' to '${fieldName}', but it was not found in the verificationMethod. If you want to add it anyways, try 'this.add${\n            fieldName.charAt(0).toUpperCase() + fieldName.slice(1)\n          }Unsafe(...)'`\n        )\n      }\n    }\n\n    const vm =\n      id === undefined\n        ? verificationMethodOrDidOrString instanceof VerificationMethod\n          ? verificationMethodOrDidOrString\n          : new VerificationMethod(\n              verificationMethodOrDidOrString as VerificationMethodOptions\n            )\n        : undefined\n\n    const item = id ?? vm", "    if (item) {\n      if (newItem) {\n        newItem.push(item)\n      } else {\n        newItem = [item]\n      }\n    } else {\n      throw new DidDocumentError(\n        `Something went wrong while trying to parse verification method for ${fieldName} with item ${verificationMethodOrDidOrString}`\n      )\n    }\n\n    uniqueStringOrVerificationMethodsSchema(fieldName).parse(newItem)\n\n    return newItem\n  }\n\n  public findServiceByType(type: string): Service {\n    const service = this.service?.find((s) =>\n      (typeof s.type === 'string' ? [s.type] : s.type).includes(type)\n    )\n", "    if (!service) {\n      throw new DidDocumentError(`Service not found for type '${type}'`)\n    }\n\n    return service\n  }\n\n  public safeFindServiceByType(type: string): Service | undefined {\n    try {\n      return this.findServiceByType(type)\n    } catch {\n      return undefined\n    }\n  }\n\n  public findServiceById(id: string): Service {\n    const service = this.service?.find((s) => s.id === id)\n", "    try {\n      return this.findServiceByType(type)\n    } catch {\n      return undefined\n    }\n  }\n\n  public findServiceById(id: string): Service {\n    const service = this.service?.find((s) => s.id === id)\n\n    if (!service) {\n      throw new DidDocumentError(`Service not found with id '${id}'`)\n    }\n\n    return service\n  }\n\n  public safeFindServiceById(id: string): Service | undefined {", "    if (!service) {\n      throw new DidDocumentError(`Service not found with id '${id}'`)\n    }\n\n    return service\n  }\n\n  public safeFindServiceById(id: string): Service | undefined {\n    try {\n      return this.findServiceById(id)\n    } catch {\n      return undefined\n    }\n  }\n\n  public findVerificationMethodByTypeAndPurpose(\n    type: string,\n    purpose:\n      | 'authentication'\n      | 'keyAgreement'\n      | 'assertionMethod'\n      | 'capabilityInvocation'\n      | 'capabilityDelegation'\n      | 'verificationMethod' = 'verificationMethod'\n  ): VerificationMethod {\n    const field =\n      purpose === 'authentication'\n        ? this.authentication\n        : purpose === 'keyAgreement'\n        ? this.keyAgreement\n        : purpose === 'assertionMethod'\n        ? this.assertionMethod\n        : purpose === 'capabilityInvocation'\n        ? this.capabilityInvocation\n        : purpose === 'capabilityDelegation'\n        ? this.capabilityInvocation\n        : this.verificationMethod\n", "    try {\n      return this.findServiceById(id)\n    } catch {\n      return undefined\n    }\n  }\n\n  public findVerificationMethodByTypeAndPurpose(\n    type: string,\n    purpose:\n      | 'authentication'\n      | 'keyAgreement'\n      | 'assertionMethod'\n      | 'capabilityInvocation'\n      | 'capabilityDelegation'\n      | 'verificationMethod' = 'verificationMethod'\n  ): VerificationMethod {\n    const field =\n      purpose === 'authentication'\n        ? this.authentication\n        : purpose === 'keyAgreement'\n        ? this.keyAgreement\n        : purpose === 'assertionMethod'\n        ? this.assertionMethod\n        : purpose === 'capabilityInvocation'\n        ? this.capabilityInvocation\n        : purpose === 'capabilityDelegation'\n        ? this.capabilityInvocation\n        : this.verificationMethod\n", "    if (!field) {\n      throw new DidDocumentError(\n        `Purpose '${purpose}' does not exist inside the did document`\n      )\n    }\n\n    const vm = field\n      .map((f) =>\n        f instanceof Did ? this.safeFindToVerificationMethodByDidUrl(f) : f\n      )\n      .find((vm) => vm?.type === type)\n", "    if (!vm) {\n      throw new DidDocumentError(\n        `Purpose '${purpose}' does not have a field with type '${type}'`\n      )\n    }\n\n    return vm\n  }\n\n  public safeFindVerificationMethodByTypeAndPurpose(\n    type: string,\n    purpose:\n      | 'authentication'\n      | 'keyAgreement'\n      | 'assertionMethod'\n      | 'capabilityInvocation'\n      | 'capabilityDelegation'\n      | 'verificationMethod' = 'verificationMethod'\n  ): VerificationMethod | undefined {", "    try {\n      return this.findVerificationMethodByTypeAndPurpose(type, purpose)\n    } catch {\n      return undefined\n    }\n  }\n\n  public isVerificationMethodTypeRegistered(\n    id: Did | string,\n    additionalAcceptedTypes: string | Array<string> = []\n  ): boolean {\n    const vm = this.findVerificationMethodByDidUrl(id)\n\n    return vm.isTypeInDidSpecRegistry(additionalAcceptedTypes)\n  }\n\n  public isServiceTypeRegistered(\n    id: string,\n    additionalAcceptedTypes: string | Array<string> = []\n  ): boolean {\n    const service = this.findServiceById(id)\n\n    return service.isTypeInDidSpecRegistry(additionalAcceptedTypes)\n  }\n\n  public toJSON(omitKeys?: Array<string>): Record<string, unknown> {\n    const mapStringOrVerificationMethod = (i: Did | VerificationMethod) =>\n      i.toJSON()\n\n    const omitBase = ['fullDocument']\n    const omitKeysWithBase = omitKeys ? [...omitBase, ...omitKeys] : omitBase\n\n    const mappedRest = {\n      ...this.fullDocument,\n      id: this.id.did,\n      alsoKnownAs: this.alsoKnownAs,\n      controller:\n        this.controller && this.controller instanceof Did\n          ? this.controller?.did\n          : this.controller?.map((c) => c.did),\n      verificationMethod: this.verificationMethod?.map((v) => v.toJSON()),\n      service: this.service?.map((s) => s.toJSON()),\n      assertionMethod: this.assertionMethod?.map(mapStringOrVerificationMethod),\n      keyAgreement: this.keyAgreement?.map(mapStringOrVerificationMethod),\n      capabilityInvocation: this.capabilityInvocation?.map(\n        mapStringOrVerificationMethod\n      ),\n      capabilityDelegation: this.capabilityDelegation?.map(\n        mapStringOrVerificationMethod\n      ),\n      authentication: this.authentication?.map(mapStringOrVerificationMethod),\n    }\n    const cleanedRest = Object.fromEntries(\n      Object.entries(mappedRest)\n        .filter(([_, value]) => value !== undefined)\n        .filter(([key]) => !omitKeysWithBase.includes(key))\n    )\n\n    return cleanedRest\n  }\n}\n"]}
{"filename": "src/service.ts", "chunked_list": ["import { z } from 'zod'\nimport { serviceSchema } from './schemas'\nimport { ServiceTypes } from './serviceTypes'\n\nexport type ServiceOptions = z.input<typeof serviceSchema> &\n  Record<string, unknown>\n\nexport class Service {\n  public fullService: ServiceOptions\n\n  public id: string\n  public type: ServiceTypes | string | Array<ServiceTypes | string>\n  public serviceEndpoint: string | Array<string> | Record<string, string>\n\n  public constructor(options: ServiceOptions) {\n    this.fullService = options\n\n    const { id, type, serviceEndpoint } = serviceSchema.parse(options)\n    this.id = id\n    this.type = type\n    this.serviceEndpoint = serviceEndpoint\n  }\n\n  /**", "   * Checks whether the service type is registered inside the @{link https://www.w3.org/TR/did-spec-registries/#service-types | service types}\n   *\n   */\n  public isTypeInDidSpecRegistry(\n    additionalAcceptedTypes: string | Array<string> = []\n  ): boolean {\n    const additionalAcceptedTypesArray =\n      typeof additionalAcceptedTypes === 'string'\n        ? [additionalAcceptedTypes]\n        : additionalAcceptedTypes\n\n    const allTypes = (Object.values(ServiceTypes) as Array<string>).concat(\n      additionalAcceptedTypesArray\n    )\n\n    return typeof this.type === 'string'\n      ? allTypes.includes(this.type)\n      : this.type.every(allTypes.includes)\n  }\n\n  public toJSON() {\n    const { fullService, ...rest } = this\n\n    return rest\n  }\n}\n"]}
{"filename": "src/publicKeyJwk.ts", "chunked_list": ["import { publicKeyJwkSchema } from './schemas'\nimport { z } from 'zod'\n\nexport type PublicKeyJwkOptions = z.input<typeof publicKeyJwkSchema> &\n  Record<string, unknown>\n\nexport class PublicKeyJwk {\n  public fullPublicKeyJwk: PublicKeyJwkOptions\n\n  public constructor(options: PublicKeyJwkOptions) {\n    this.fullPublicKeyJwk = options\n    publicKeyJwkSchema.parse(options)\n  }\n\n  public toJSON() {\n    const { fullPublicKeyJwk, ...rest } = this.fullPublicKeyJwk\n    return rest\n  }\n}\n"]}
{"filename": "src/publicKeyMultibase.ts", "chunked_list": ["import { publicKeyMultibaseSchema } from './schemas'\nimport { z } from 'zod'\n\nexport type PublicKeyMultibaseOptions = z.input<typeof publicKeyMultibaseSchema>\n\nexport class PublicKeyMultibase {\n  public publicKeyMultibase: PublicKeyMultibaseOptions\n  public properties: PublicKeyMultibaseOptions\n\n  public constructor(options: PublicKeyMultibaseOptions) {\n    this.publicKeyMultibase = options\n    this.properties = publicKeyMultibaseSchema.parse(options)\n  }\n\n  public toJSON() {\n    this.publicKeyMultibase.toString()\n  }\n}\n"]}
{"filename": "src/didResolution.ts", "chunked_list": ["import { Impossible, OrPromise } from './types'\nimport { DidDocumentOptions } from './didDocument'\n\nexport type ResolutionOptions<T extends Record<string, unknown>> = {\n  accept: string\n} & T\n\nexport type DidResolutionMetadata<T extends Record<string, unknown>> = {\n  contentType: string\n  error?: 'invalidDid' | 'notFound' | 'representationNotSupported' | string\n} & T\n\n// resolveRepresentation(did, resolutionOptions) \u2192\n// \u00ab didResolutionMetadata, didDocumentStream, didDocumentMetadata \u00bb", "export type DidDocumentMetadata<T extends Record<string, unknown>> = {\n  created?: string\n  updated?: string\n  deactivated?: string\n  nextUpdate?: string\n  versionId?: string\n  equivalentId?: Array<string>\n  canonicalId?: string\n} & T\n\nexport interface DidResolution<\n  AdditionalOptions extends Record<string, unknown> = {},\n  AdditionalDidResolutionMetadata extends Record<string, unknown> = {},\n  AdditionalDidDocument extends Record<string, unknown> = {},\n  AdditionalDidDocumentMetadata extends Record<string, unknown> = {}\n> {\n  resolve(\n    did: string,\n    resolutionOptions?: Impossible<\n      ResolutionOptions<AdditionalOptions>,\n      'accept'\n    >\n  ): OrPromise<{\n    didResolutionMetadata: Impossible<\n      DidResolutionMetadata<AdditionalDidResolutionMetadata>,\n      'contentType'\n    >\n    didDocument: DidDocumentOptions<AdditionalDidDocument>\n    didDocumentMetadata: DidDocumentMetadata<AdditionalDidDocumentMetadata>\n  }>\n\n  resolvePresentation(\n    did: string,\n    resolutionOptions?: ResolutionOptions<AdditionalOptions>\n  ): OrPromise<{\n    didResolutionMetadata: DidResolutionMetadata<AdditionalDidResolutionMetadata>\n    didDocumentStream: Uint8Array\n    didDocumentMetadata: DidDocumentMetadata<AdditionalDidDocumentMetadata>\n  }>\n}\n", "export interface DidResolution<\n  AdditionalOptions extends Record<string, unknown> = {},\n  AdditionalDidResolutionMetadata extends Record<string, unknown> = {},\n  AdditionalDidDocument extends Record<string, unknown> = {},\n  AdditionalDidDocumentMetadata extends Record<string, unknown> = {}\n> {\n  resolve(\n    did: string,\n    resolutionOptions?: Impossible<\n      ResolutionOptions<AdditionalOptions>,\n      'accept'\n    >\n  ): OrPromise<{\n    didResolutionMetadata: Impossible<\n      DidResolutionMetadata<AdditionalDidResolutionMetadata>,\n      'contentType'\n    >\n    didDocument: DidDocumentOptions<AdditionalDidDocument>\n    didDocumentMetadata: DidDocumentMetadata<AdditionalDidDocumentMetadata>\n  }>\n\n  resolvePresentation(\n    did: string,\n    resolutionOptions?: ResolutionOptions<AdditionalOptions>\n  ): OrPromise<{\n    didResolutionMetadata: DidResolutionMetadata<AdditionalDidResolutionMetadata>\n    didDocumentStream: Uint8Array\n    didDocumentMetadata: DidDocumentMetadata<AdditionalDidDocumentMetadata>\n  }>\n}\n"]}
{"filename": "src/error.ts", "chunked_list": ["export class DidDocumentError extends Error {}\nexport class DidError extends Error {}\nexport class VerificationMethodError extends Error {}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './did'\nexport * from './didDocument'\nexport * from './verificationMethod'\nexport * from './service'\nexport * from './publicKeyJwk'\nexport * from './publicKeyMultibase'\nexport * from './error'\nexport * from './verificationMethodTypes'\nexport * from './serviceTypes'\nexport * from './representations'", "export * from './serviceTypes'\nexport * from './representations'\n\nexport * from './didResolution'\nexport * from './didUrlDereference'\n\nexport * from './schemas'\n"]}
{"filename": "src/serviceTypes.ts", "chunked_list": ["/**\n * These are values to be used for the type property in a service object.\n *\n * @see {@link https://www.w3.org/TR/did-spec-registries/#service-types}\n */\nexport enum ServiceTypes {\n  /**\n   * LinkedDomains IRI is not stable\n   *\n   * @see {@link https://identity.foundation/.well-known/resources/did-configuration/#LinkedDomains}\n   *\n   * @note If this link changes the term defintion registered in did core will need to change, we should be sure we like this URL as is... forever.\n   */\n  LinkedDomains = 'LinkedDomains',\n  DIDCommMessaging = 'DIDCommMessaging',\n  /**\n   * The CredentialRegistry endpoint allows publication of a dedicated service\n   * endpoint in a DID document, through which verifiable credentials can be\n   * queried. Each registry endpoint is a REST endpoint. When a GET request is\n   * sent to the URI formed by appending the credentialSubject.id as a\n   * URL-encoded string to the given endpoint URI, the registry MUST return an\n   * array of verifiable credentials associated with the subject ID. A sample\n   * registry endpoint can be found {@link https://ssi.eecc.de/api/registry/swagger/#/Credentials/get_api_registry_vcs__id_ | here}.\n   */\n  CredentialRegistry = 'CredentialRegistry',\n}\n"]}
{"filename": "src/did.ts", "chunked_list": ["import { z } from 'zod'\nimport {\n  didUrlSchemaWithouttransformation,\n  stringOrDid,\n  stringOrDidUrl,\n} from './schemas'\n\nexport const PREFIX_PATH = '/'\nexport const PREFIX_QUERY = '?'\nexport const PREFIX_FRAGMENT = '#'", "export const PREFIX_QUERY = '?'\nexport const PREFIX_FRAGMENT = '#'\nconst DEFAULT_PARAMETER_KEYS = [\n  'service',\n  'relativeRef',\n  'versionId',\n  'versionTime',\n  'hl',\n]\n\nexport type DidParts = {\n  scheme: string\n  method: string\n  namespaces?: Array<string>\n  identifier: string\n}\n", "]\n\nexport type DidParts = {\n  scheme: string\n  method: string\n  namespaces?: Array<string>\n  identifier: string\n}\n\nexport type DidUrlParts = {\n  path?: string\n  query?: Record<string, string>\n  fragment?: string\n  parameters?: Record<string, string>\n}\n", "export type DidUrlParts = {\n  path?: string\n  query?: Record<string, string>\n  fragment?: string\n  parameters?: Record<string, string>\n}\n\nexport class Did {\n  public did: string\n  private path?: string\n  private query?: Record<string, string>\n  private fragment?: string\n  private parameters?: Record<string, string>\n  private parameterKeys: Array<string>\n\n  public constructor(did: string, parameterKeys?: Array<string>) {\n    const parsedDid = didUrlSchemaWithouttransformation.parse(did)\n    const url = new URL(parsedDid)\n\n    const prefixPathIndex = url.pathname.indexOf(PREFIX_PATH)\n\n    const stripUntil = Math.min(\n      ...[\n        did.indexOf(PREFIX_PATH),\n        did.indexOf(PREFIX_QUERY),\n        did.indexOf(PREFIX_FRAGMENT),\n      ].filter((i) => i !== -1)\n    )\n\n    const didBase = stripUntil !== -1 ? did.slice(0, stripUntil) : did\n\n    const path = (\n      prefixPathIndex !== -1 ? url.pathname.slice(prefixPathIndex) : ''\n    ).substring(1)\n\n    const query = url.search.substring(1)\n    const queryParams = new URLSearchParams(query)\n\n    const fragment = url.hash.substring(1)\n\n    this.parameterKeys = parameterKeys\n      ? [...DEFAULT_PARAMETER_KEYS, ...parameterKeys]\n      : DEFAULT_PARAMETER_KEYS\n    this.did = didBase\n    this.path = path.length > 0 ? path : undefined\n    this.query =\n      queryParams.size > 0\n        ? [...queryParams.entries()].reduce(\n            (prev, [k, v]) => ({ [k]: v, ...prev } as Record<string, string>),\n            {}\n          )\n        : undefined\n    this.fragment = fragment.length > 0 ? fragment : undefined\n\n    this.parameters = this.query\n      ? Object.entries(this.query).reduce((prev, [k, v]) => {", "          if (this.parameterKeys?.includes(k)) {\n            return { [k]: v, ...prev }\n          }\n          return prev\n        }, {})\n      : undefined\n  }\n\n  public isDidUrl(): boolean {\n    return Boolean(this.path || this.query || this.fragment)\n  }\n\n  public static validateDid(did: z.input<typeof stringOrDid>): boolean {\n    return stringOrDid.safeParse(did).success\n  }\n\n  public static validateDidUrl(did: z.input<typeof stringOrDidUrl>): boolean {\n    return stringOrDidUrl.safeParse(did).success\n  }\n\n  public validate(): boolean {", "    if (this.isDidUrl()) {\n      return Did.validateDidUrl(this.toUrl())\n    } else {\n      return Did.validateDid(this.did)\n    }\n  }\n\n  public toUrl(): string {\n    const path = this.path ? `${PREFIX_PATH}${this.path}` : ''\n    const queryString = new URLSearchParams(this.query).toString()\n    const query = this.query ? `${PREFIX_QUERY}${queryString}` : ''\n    const fragment = this.fragment ? `${PREFIX_FRAGMENT}${this.fragment}` : ''\n\n    return `${this.did}${path}${query}${fragment}`\n  }\n\n  public withPath(path: string): this {\n    this.path = this.stripOptionalPrefix(path, PREFIX_PATH)\n    return this\n  }\n\n  public addPath(path: string): this {", "    if (this.path) {\n      this.path = this.path + this.addPrefixIfNotSupplied(path, PREFIX_PATH)\n    } else {\n      return this.withPath(path)\n    }\n    return this\n  }\n\n  public removePath(): this {\n    this.path = undefined\n    return this\n  }\n\n  public withQuery(query: Record<string, string>): this {\n    this.query = query\n    return this\n  }\n\n  public addQuery(query: Record<string, string>): this {", "    if (this.query) {\n      this.query = { ...this.query, ...query }\n    } else {\n      this.withQuery(query)\n    }\n    return this\n  }\n\n  public removeQuery(): this {\n    this.query = undefined\n    return this\n  }\n\n  public withFragment(fragment: string): this {\n    this.fragment = this.stripOptionalPrefix(fragment, PREFIX_FRAGMENT)\n    return this\n  }\n\n  public removeFragment(): this {\n    this.fragment = undefined\n    return this\n  }\n\n  public get didParts(): DidParts {\n    const parts = this.did.split(':')\n    const scheme = parts[0]\n    const method = parts[1]\n    const identifier = parts[parts.length - 1]\n    const namespaces = parts.slice(2, parts.length - 1)\n\n    return {\n      scheme,\n      method,\n      identifier,\n      namespaces: namespaces.length > 0 ? namespaces : undefined,\n    }\n  }\n\n  public get didUrlParts(): DidUrlParts {\n    // This is done because the params are calculated based on the query and parameterKeys, but is you set additional parameter keys later on the new parameter field is not updated\n    const newDid = new Did(this.toUrl(), this.parameterKeys)\n\n    return {\n      fragment: newDid.fragment,\n      path: newDid.path,\n      query: newDid.query,\n      parameters: newDid.parameters,\n    }\n  }\n\n  private stripOptionalPrefix(s: string, p: string): string {", "    if (s.startsWith(p)) {\n      return s.slice(1)\n    }\n    return s\n  }\n\n  private addPrefixIfNotSupplied(s: string, p: string): string {\n    if (s.startsWith(p)) {\n      return s\n    }\n    return `${p}${s}`\n  }\n\n  public addParameterKey(key: string | Array<string>): this {", "    if (typeof key === 'string') {\n      this.parameterKeys.push(key)\n    } else if (Array.isArray(key)) {\n      this.parameterKeys.push(...key)\n    }\n\n    return this\n  }\n\n  public toString() {\n    return this.toUrl()\n  }\n\n  public toJSON() {\n    return this.toString()\n  }\n}\n"]}
{"filename": "src/didUrlDereference.ts", "chunked_list": ["import { OrPromise } from './types'\n\nexport type DereferenceOptions<T extends Record<string, unknown>> = {\n  accept?: string\n} & T\n\nexport type DereferencingMetadata<T extends Record<string, unknown>> = {\n  contentType?: string\n  error?: 'invalidDidUrl' | 'notFound' | string\n} & T\n", "export interface DidUrlDereference<\n  AdditionalDereferenceOptions extends Record<string, unknown> = {},\n  AdditionalDereferencingMetadata extends Record<string, unknown> = {},\n  ContentStream = unknown,\n  ContentMetadata extends Record<string, unknown> = {}\n> {\n  dereference(\n    didUrl: string,\n    dereferenceOptions: DereferenceOptions<AdditionalDereferenceOptions>\n  ): OrPromise<{\n    dereferencingMetadata: DereferencingMetadata<AdditionalDereferencingMetadata>\n    contentStream?: ContentStream\n    contentMetadata: ContentMetadata\n  }>\n}\n"]}
{"filename": "src/verificationMethod.ts", "chunked_list": ["import type { Modify } from './types'\nimport { verificationMethodSchema } from './schemas'\nimport { Did } from './did'\nimport { z } from 'zod'\nimport { PublicKeyJwk, PublicKeyJwkOptions } from './publicKeyJwk'\nimport {\n  PublicKeyMultibaseOptions,\n  PublicKeyMultibase,\n} from './publicKeyMultibase'\nimport { VerificationMethodTypes } from './verificationMethodTypes'", "} from './publicKeyMultibase'\nimport { VerificationMethodTypes } from './verificationMethodTypes'\n\nexport type VerificationMethodOptions = Modify<\n  z.input<typeof verificationMethodSchema>,\n  {\n    publicKeyJwk?: PublicKeyJwkOptions | PublicKeyJwk\n    publicKeyMultibase?: PublicKeyMultibaseOptions | PublicKeyMultibase\n  }\n> &\n  Record<string, unknown>\n", "export class VerificationMethod {\n  public fullVerificationMethod: VerificationMethodOptions\n\n  id: Did\n  controller: Did\n  type: VerificationMethodTypes | string\n  publicKeyJwk?: PublicKeyJwk\n  publicKeyMultibase?: PublicKeyMultibase\n\n  public constructor(options: VerificationMethodOptions) {\n    this.fullVerificationMethod = options\n\n    const { id, controller, type, publicKeyJwk, publicKeyMultibase } =\n      verificationMethodSchema.parse(options)\n\n    this.id = id\n    this.controller = controller\n    this.type = type\n    this.publicKeyJwk = publicKeyJwk\n    this.publicKeyMultibase = publicKeyMultibase\n  }\n\n  /**", "   * Checks whether the verification method type is registered inside the @{link https://www.w3.org/TR/did-spec-registries/#verification-method-types | verification method types}\n   *\n   */\n  public isTypeInDidSpecRegistry(\n    additionalAcceptedTypes: string | Array<string> = []\n  ): boolean {\n    const additionalAcceptedTypesArray =\n      typeof additionalAcceptedTypes === 'string'\n        ? [additionalAcceptedTypes]\n        : additionalAcceptedTypes\n\n    const allTypes = (\n      Object.values(VerificationMethodTypes) as Array<string>\n    ).concat(additionalAcceptedTypesArray)\n\n    return allTypes.includes(this.type)\n  }\n\n  public toJSON() {\n    const mappedRest = {\n      id: this.id.toJSON(),\n      controller: this.controller.toJSON(),\n      type: this.type,\n      publicKeyJwk: this.publicKeyJwk?.toJSON(),\n      publicKeyMultibase: this.publicKeyMultibase?.toJSON(),\n    }\n    const cleanedRest = Object.fromEntries(\n      Object.entries(mappedRest).filter(([_, value]) => value !== undefined)\n    )\n\n    return cleanedRest\n  }\n}\n"]}
{"filename": "src/schemas/serviceSchema.ts", "chunked_list": ["import { z } from 'zod'\n\nexport const serviceSchema = z.object({\n  id: z.string().url(),\n  type: z.union([z.string(), z.array(z.string())]),\n  serviceEndpoint: z.union([\n    z.string().url(),\n    z.array(z.string().url()),\n    z.object({}),\n  ]),", "    z.object({}),\n  ]),\n})\n\nexport const uniqueServicesSchema = z\n  .array(serviceSchema)\n  .refine((services) => {\n    const idSet = new Set()\n    for (const obj of services) {\n      if (idSet.has(obj.id)) {\n        return false\n      }\n      idSet.add(obj.id)\n    }\n    return true\n  }, 'Duplicate service.id found. They must be unique')\n", "    for (const obj of services) {\n      if (idSet.has(obj.id)) {\n        return false\n      }\n      idSet.add(obj.id)\n    }\n    return true\n  }, 'Duplicate service.id found. They must be unique')\n"]}
{"filename": "src/schemas/publicKeyJwkSchema.ts", "chunked_list": ["import { PublicKeyJwk } from '../publicKeyJwk'\nimport { z } from 'zod'\n\nexport const publicKeyJwkSchema = z.union([\n  z.object({\n    kty: z.string(),\n    use: z.optional(z.string()),\n    crv: z.optional(z.string()),\n    x: z.optional(z.string()),\n    y: z.optional(z.string()),", "    x: z.optional(z.string()),\n    y: z.optional(z.string()),\n    e: z.optional(z.string()),\n    n: z.optional(z.string()),\n    key_ops: z.optional(z.string()),\n    alg: z.optional(z.string()),\n    kid: z.optional(z.string()),\n\n    d: z.optional(\n      z.undefined({", "    d: z.optional(\n      z.undefined({\n        invalid_type_error:\n          \"'d' is not allowed to be supplied as it contains a private key material\",\n      })\n    ),\n  }),\n  z.custom<PublicKeyJwk>(\n    (publicKeyJwk) => publicKeyJwk instanceof PublicKeyJwk\n  ),", "    (publicKeyJwk) => publicKeyJwk instanceof PublicKeyJwk\n  ),\n])\n"]}
{"filename": "src/schemas/verificationMethodSchema.ts", "chunked_list": ["import { z } from 'zod'\nimport { stringOrDid, stringOrDidUrl } from './didSchema'\nimport { publicKeyJwkSchema } from './publicKeyJwkSchema'\nimport { publicKeyMultibaseSchema } from './publicKeyMultibaseSchema'\nimport { PublicKeyJwk } from '../publicKeyJwk'\nimport { PublicKeyMultibase } from '../publicKeyMultibase'\nimport { VerificationMethod } from '../verificationMethod'\nimport { Did } from '../did'\n\nexport const verificationMethodSchema = z", "\nexport const verificationMethodSchema = z\n  .union([\n    z.object({\n      id: stringOrDidUrl,\n      controller: stringOrDid,\n      type: z.string(),\n      publicKeyJwk: z.optional(publicKeyJwkSchema),\n      publicKeyMultibase: z.optional(publicKeyMultibaseSchema),\n    }),", "      publicKeyMultibase: z.optional(publicKeyMultibaseSchema),\n    }),\n    z.custom<VerificationMethod>(\n      (verificationMethod) => verificationMethod instanceof VerificationMethod\n    ),\n  ])\n  .superRefine((data, ctx) => {\n    if (data.publicKeyJwk && data.publicKeyMultibase) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        path: ['publicKeyJwk & publicKeyMultibase'],\n        message:\n          'Supplying both publicKeyJwk and publicKeyMultibase is not permitted',\n      })\n    }\n  })\n  .transform((verificationMethod) => ({\n    id: verificationMethod.id,\n    type: verificationMethod.type,\n    controller: verificationMethod.controller,\n    publicKeyJwk: verificationMethod.publicKeyJwk\n      ? verificationMethod.publicKeyJwk instanceof PublicKeyJwk\n        ? verificationMethod.publicKeyJwk\n        : new PublicKeyJwk(verificationMethod.publicKeyJwk)\n      : undefined,\n    publicKeyMultibase: verificationMethod.publicKeyMultibase\n      ? verificationMethod.publicKeyMultibase instanceof PublicKeyMultibase\n        ? verificationMethod.publicKeyMultibase\n        : new PublicKeyMultibase(verificationMethod.publicKeyMultibase)\n      : undefined,\n  }))\n\nexport const uniqueVerificationMethodsSchema = z\n  .array(verificationMethodSchema)\n  .refine((verificationMethods) => {\n    const idSet = new Set()", "    for (const obj of verificationMethods) {\n      if (idSet.has(obj.id)) {\n        return false\n      }\n      idSet.add(obj.id)\n    }\n    return true\n  }, `Duplicate verificationMethod.id found. They must be unique`)\n\nexport const stringOrVerificationMethod = z\n  .union([stringOrDidUrl, verificationMethodSchema])\n  .transform((verificationMethod) => {", "    if (verificationMethod instanceof Did) {\n      return verificationMethod\n    }\n    return new VerificationMethod(verificationMethod)\n  })\n\nexport const uniqueStringOrVerificationMethodsSchema = (name: string) =>\n  z.array(stringOrVerificationMethod).refine((verificationMethods) => {\n    const idSet = new Set()\n    for (const obj of verificationMethods) {\n      const id = obj instanceof Did ? obj.toUrl() : obj.id.toUrl()", "    for (const obj of verificationMethods) {\n      const id = obj instanceof Did ? obj.toUrl() : obj.id.toUrl()\n      if (idSet.has(id)) {\n        return false\n      }\n      idSet.add(id)\n    }\n    return true\n  }, `Duplicate ${name}.id found. They must be unique`)\n"]}
{"filename": "src/schemas/index.ts", "chunked_list": ["export * from './didSchema'\nexport * from './didDocumentSchema'\nexport * from './verificationMethodSchema'\nexport * from './serviceSchema'\nexport * from './publicKeyJwkSchema'\nexport * from './publicKeyMultibaseSchema'\n"]}
{"filename": "src/schemas/publicKeyMultibaseSchema.ts", "chunked_list": ["import { PublicKeyMultibase } from '../publicKeyMultibase'\nimport { z } from 'zod'\n\nexport const publicKeyMultibaseSchema = z.union([\n  z.string(),\n  z.custom<PublicKeyMultibase>(\n    (publicKeyMultibase) => publicKeyMultibase instanceof PublicKeyMultibase\n  ),\n])\n", "])\n"]}
{"filename": "src/schemas/didSchema.ts", "chunked_list": ["import { DidError } from '../error'\nimport { Did } from '../did'\nimport { z } from 'zod'\n\nconst DID_URL_REGEXP =\n  /^did:[a-z0-9]+(?::[a-z0-9]+(?:[._-][a-z0-9]+)*)*:(?:[a-z0-9]+(?:[._-][a-z0-9]+)*)?(?:\\/[^?\\s]*)?(?:\\?[^#\\s]*)?(?:#[^\\s]*)?$/i\nconst DID_REGEXP =\n  /^did:[a-z0-9]+(?::[a-z0-9]+(?:[._-][a-z0-9]+)*)*(?:#[^s]*)?$/i\n\nexport const didUrlSchemaWithouttransformation = z", "\nexport const didUrlSchemaWithouttransformation = z\n  .string()\n  .regex(DID_URL_REGEXP, { message: 'Invalid did url syntax' })\n\nexport const didSchemaWithouttransformation = z\n  .string()\n  .regex(DID_REGEXP, { message: 'Invalid did syntax' })\n\nexport const stringOrDid = z", "\nexport const stringOrDid = z\n  .union([\n    didSchemaWithouttransformation,\n    z.custom<Did>((did) => did instanceof Did),\n  ])\n  .transform((did: string | Did): Did => {\n    if (typeof did === 'string') {\n      return new Did(did)\n    } else if (did instanceof Did) {\n      return did\n    } else {\n      throw new DidError(`id must be of type 'string' or an instance of 'Did'`)\n    }\n  })\n\nexport const stringOrDidUrl = z\n  .union([\n    didUrlSchemaWithouttransformation,\n    z.custom<Did>((did) => did instanceof Did),\n  ])\n  .transform((did: string | Did): Did => {", "    } else if (did instanceof Did) {\n      return did\n    } else {\n      throw new DidError(`id must be of type 'string' or an instance of 'Did'`)\n    }\n  })\n\nexport const stringOrDidUrl = z\n  .union([\n    didUrlSchemaWithouttransformation,\n    z.custom<Did>((did) => did instanceof Did),\n  ])\n  .transform((did: string | Did): Did => {", "    if (typeof did === 'string') {\n      return new Did(did)\n    } else if (did instanceof Did) {\n      return did\n    } else {\n      throw new DidError(`id must be of type 'string' or an instance of 'Did'`)\n    }\n  })\n"]}
{"filename": "src/schemas/didDocumentSchema.ts", "chunked_list": ["import { z } from 'zod'\nimport { stringOrDid } from './didSchema'\nimport {\n  uniqueStringOrVerificationMethodsSchema,\n  verificationMethodSchema,\n} from './verificationMethodSchema'\nimport { uniqueServicesSchema } from './serviceSchema'\nimport { Service } from '../service'\nimport { VerificationMethod } from '../verificationMethod'\n", "import { VerificationMethod } from '../verificationMethod'\n\nexport const didDocumentSchema = z\n  .object({\n    id: stringOrDid,\n    alsoKnownAs: z.optional(z.array(z.string().url())),\n    controller: z.optional(z.union([stringOrDid, z.array(stringOrDid)])),\n    verificationMethod: z.optional(z.array(verificationMethodSchema)),\n    authentication: z.optional(\n      uniqueStringOrVerificationMethodsSchema('authentication')", "    authentication: z.optional(\n      uniqueStringOrVerificationMethodsSchema('authentication')\n    ),\n    assertionMethod: z.optional(\n      uniqueStringOrVerificationMethodsSchema('assertionMethod')\n    ),\n    keyAgreement: z.optional(\n      uniqueStringOrVerificationMethodsSchema('keyAgreement')\n    ),\n    capabilityInvocation: z.optional(", "    ),\n    capabilityInvocation: z.optional(\n      uniqueStringOrVerificationMethodsSchema('capabilityInvocation')\n    ),\n    capabilityDelegation: z.optional(\n      uniqueStringOrVerificationMethodsSchema('capabilityInvocation')\n    ),\n    service: z.optional(uniqueServicesSchema),\n  })\n  .transform((didDocument) => ({", "  })\n  .transform((didDocument) => ({\n    ...didDocument,\n    service: didDocument.service?.map((s) => new Service(s)),\n    verificationMethod: didDocument.verificationMethod?.map(\n      (v) => new VerificationMethod(v)\n    ),\n  }))\n", ""]}
