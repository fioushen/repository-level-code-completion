{"filename": "vite.config.ts", "chunked_list": ["import { resolve, dirname } from \"path\";\nimport { defineConfig } from \"vite\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport default defineConfig({\n  define: {\n    \"process.env\": { NODE_ENV: \"production\" },", "  define: {\n    \"process.env\": { NODE_ENV: \"production\" },\n  },\n  build: {\n    lib: {\n      entry: resolve(__dirname, \"src/ui/index.tsx\"),\n      name: \"Index\",\n      fileName: \"index\",\n    },\n  },", "    },\n  },\n  server: {\n    proxy: {\n      \"/api\": {\n        rewrite: (path) => path.replace(/^\\/api/, \"\"),\n        target: \"http://localhost:3000\",\n        changeOrigin: true,\n      },\n    },", "      },\n    },\n  },\n});\n"]}
{"filename": "dev/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n"]}
{"filename": "src/api/app-conf.ts", "chunked_list": ["export const AppConf = {\n  meetupApiBaseUrl: process.env.MEETUP_API_BASE_URL,\n  githubApiBaseUrl: process.env.GH_API_BASE_URL,\n  githubAuthKey: process.env.GH_AUTH_KEY,\n  logsVerbose: (process.env.LOGS_VERBOSE || \"\").toUpperCase() === \"TRUE\",\n  settingsBaseUrl: process.env.SETTINGS_BASE_URL,\n  apiKey: process.env.API_KEY,\n  emailAppUrl: process.env.EMAIL_APP_URL as string,\n};\n", "};\n"]}
{"filename": "src/api/routes.ts", "chunked_list": ["import { APIGatewayProxyEventV2 } from \"aws-lambda\";\nimport { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\nimport { chaptersController } from \"./controllers/chapters.controller\";\nimport { chapterIconController } from \"./controllers/chapter-icon.controller\";\nimport { healthController } from \"./controllers/health.controller\";\nimport { notifyController } from \"./controllers/notify.controller\";\n\ntype Route = {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n  path: string;\n  controller: Controller;\n};", "export type Controller = (\n  event: APIGatewayProxyEventV2\n) =>\n  | APIGatewayProxyStructuredResultV2\n  | Promise<APIGatewayProxyStructuredResultV2>;\n\nexport const routes: Array<Route> = [\n  {\n    method: \"GET\",\n    path: \"/info/events\",\n    controller: chaptersController,\n  },\n  {\n    method: \"GET\",\n    path: \"/info/chapter-icons/[A-Za-z-]+\",\n    controller: chapterIconController,\n  },\n  {\n    method: \"GET\",\n    path: \"/info/health\",\n    controller: healthController,\n  },\n  {\n    method: \"GET\",\n    path: \"/api/health\",\n    controller: healthController,\n  },\n  {\n    method: \"POST\",\n    path: \"/api/notify\",\n    controller: notifyController,\n  },\n];\n"]}
{"filename": "src/api/index.ts", "chunked_list": ["import { APIGatewayProxyEventV2 } from \"aws-lambda\";\nimport { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\nimport { MeetupEvent } from \"./dao/meetup.dao\";\nimport { AppConf } from \"./app-conf\";\nimport { Controller, routes } from \"./routes\";\nimport colors from \"colors\";\n\nexport type EventsResponse = Array<MeetupEvent>;\n\nexport async function handler(\n  event: APIGatewayProxyEventV2\n): Promise<APIGatewayProxyStructuredResultV2> {", "export async function handler(\n  event: APIGatewayProxyEventV2\n): Promise<APIGatewayProxyStructuredResultV2> {\n  try {\n    return await handleRequest(event);\n  } catch (e) {\n    console.error(`Internal server error: ${e}`);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        message: \"Internal server error\",\n        requestId: event.requestContext.requestId,\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    };\n  }\n}\n", "async function handleRequest(\n  event: APIGatewayProxyEventV2\n): Promise<APIGatewayProxyStructuredResultV2> {\n  console.log(\"request received\");\n  if (!isApiKeyValid(event)) {\n    return {\n      statusCode: 401,\n      body: JSON.stringify({\n        message: \"Unauthorized\",\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    };\n  }\n  const path = event.requestContext.http.path;\n  const method = event.requestContext.http.method.toUpperCase();\n  let controller = undefined as undefined | Controller;", "  for (const route of routes) {\n    if (method === route.method && new RegExp(`^${route.path}$`).test(path)) {\n      controller = route.controller;\n      break;\n    }\n  }\n  if (controller) {\n    const response = await controller(event);\n    if (!response.headers) {\n      response.headers = {};\n    }\n    response.headers[\"Access-Control-Allow-Origin\"] = \"*\";\n    return response;\n  }\n  console.log(\n    colors.blue(\"No controller found for path \") + colors.yellow(`\"${path}\"`)\n  );\n  return {\n    statusCode: 404,\n    body: JSON.stringify({\n      message: \"Not found\",\n      requestId: event.requestContext.requestId,\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  };\n}\n\nconst API_KEY_PATH = /^\\/api\\/.*/;\n\n/**\n * Checks if an API key is needed, and if so, if it is valid. API Keys are required for all non cached requests.\n * @param request The request to validate.\n */", "    if (!response.headers) {\n      response.headers = {};\n    }\n    response.headers[\"Access-Control-Allow-Origin\"] = \"*\";\n    return response;\n  }\n  console.log(\n    colors.blue(\"No controller found for path \") + colors.yellow(`\"${path}\"`)\n  );\n  return {\n    statusCode: 404,\n    body: JSON.stringify({\n      message: \"Not found\",\n      requestId: event.requestContext.requestId,\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  };\n}\n\nconst API_KEY_PATH = /^\\/api\\/.*/;\n\n/**\n * Checks if an API key is needed, and if so, if it is valid. API Keys are required for all non cached requests.\n * @param request The request to validate.\n */", "function isApiKeyValid(request: APIGatewayProxyEventV2): boolean {\n  if (API_KEY_PATH.test(request.requestContext.http.path)) {\n    return request.headers?.[\"x-api-key\"] === AppConf.apiKey;\n  }\n  return true;\n}\n"]}
{"filename": "src/api/dao/meetup.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\nimport { AppConf } from \"../app-conf\";\nimport { Chapter } from \"./settings.dao\";\n\n//See https://www.meetup.com/api/schema/#p03-objects-section for Meetup API details.\n\n/**\n * Represents all the data that is returned from the Meetup API for an event.\n */\nexport type MeetupEvent = {\n  id: string;\n  eventUrl: string;\n  title: string;\n  going: number;\n  imageUrl: string;\n  venue: {\n    name: string;\n    address: string;\n    city: string;\n    state: string;\n  } | null;\n  dateTime: string;\n  group: {\n    id: string;\n    name: string;\n    city: string;\n    state: string;\n    urlname: string;\n  };\n  description: string;\n};\n\n/**\n * The raw response from the Meetup API events query.\n */", " */\nexport type MeetupEvent = {\n  id: string;\n  eventUrl: string;\n  title: string;\n  going: number;\n  imageUrl: string;\n  venue: {\n    name: string;\n    address: string;\n    city: string;\n    state: string;\n  } | null;\n  dateTime: string;\n  group: {\n    id: string;\n    name: string;\n    city: string;\n    state: string;\n    urlname: string;\n  };\n  description: string;\n};\n\n/**\n * The raw response from the Meetup API events query.\n */", "type QueryResponse = {\n  data: Record<\n    string,\n    {\n      upcomingEvents: {\n        edges: Array<{\n          node: MeetupEvent;\n        }>;\n      };\n    } | null\n  >;\n};\n\n/**\n * Get the events from the Meetup API.\n */", "export async function getMeetupEvents(\n  chapters: Chapter[]\n): Promise<Array<MeetupEvent>> {\n  const finalQuery = formQuery(chapters);\n  const response = await request({\n    name: \"Meetup Event\",\n    url: `${AppConf.meetupApiBaseUrl}/gql`,\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: { query: finalQuery },\n  });\n  return processResponse((await response.json()) as QueryResponse);\n}\n\nconst eventFragment =\n  \"fragment eventFragment on Event { id eventUrl title description going imageUrl venue { name address city state } dateTime group { id name city state urlname}}\";\nconst groupFragment =\n  \"fragment groupFragment on Group { upcomingEvents(input:{first:10}) { edges { node { ...eventFragment } } } }\";\n\n/**\n * Form the query to get the events from the Meetup API.\n *\n * @param chapters The chapters to get events for.\n */", "function formQuery(chapters: Array<Chapter>): string {\n  let newQuery = \"query {\";\n  for (const i in chapters) {\n    newQuery += `result${i}:groupByUrlname(urlname:\"${chapters[i].meetupGroupUrlName}\") { ...groupFragment }`;\n  }\n  newQuery += \"}\" + eventFragment + groupFragment;\n  return newQuery;\n}\n\n/**\n * Process the response from the query and return a list of events.\n *\n * @param response The response from the query.\n */", "function processResponse(response: QueryResponse): Array<MeetupEvent> {\n  const result = [] as Array<MeetupEvent>;\n  for (const group of Object.values(response.data)) {\n    if (group) {\n      for (const event of group.upcomingEvents.edges) {\n        result.push(event.node);\n      }\n    }\n  }\n  return result;\n}\n"]}
{"filename": "src/api/dao/email.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\nimport { AppConf } from \"../app-conf\";\n\nexport type EmailContent = {\n  recipient: string | Array<string>;\n  subject: string;\n  body: string;\n};\n\nexport async function sendEmail(email: EmailContent) {\n  await request({\n    name: \"Send Email\",\n    method: \"POST\",\n    url: AppConf.emailAppUrl,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: email,\n  });\n}\n", "export async function sendEmail(email: EmailContent) {\n  await request({\n    name: \"Send Email\",\n    method: \"POST\",\n    url: AppConf.emailAppUrl,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: email,\n  });\n}\n"]}
{"filename": "src/api/dao/settings.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\nimport { AppConf } from \"../app-conf\";\n\n/**\n * The info for a Code and Coffee Chapter.\n */\nexport type Chapter = {\n  name: string;\n  meetupGroupUrlName: string;\n};\n", "export type NotificationSetting = {\n  name: string;\n  github: string;\n  email: Array<string>;\n  emailTitlePrepend: string;\n};\n\n/**\n * Get a list of all the Code and Coffee Chapters.\n */\nexport async function getChapters(): Promise<Chapter[]> {\n  return (await (\n    await request({\n      name: \"Chapters Setting\",\n      url: `${AppConf.settingsBaseUrl}/chapters.json`,\n      method: \"GET\",\n    })\n  ).json()) as Chapter[];\n}\n\n/**\n * Get the icon for the given chapter.\n *\n * @param chapter The chapter to get the icon for.\n */", "export async function getChapters(): Promise<Chapter[]> {\n  return (await (\n    await request({\n      name: \"Chapters Setting\",\n      url: `${AppConf.settingsBaseUrl}/chapters.json`,\n      method: \"GET\",\n    })\n  ).json()) as Chapter[];\n}\n\n/**\n * Get the icon for the given chapter.\n *\n * @param chapter The chapter to get the icon for.\n */", "export async function getChapterIcon(chapter: string): Promise<ArrayBuffer> {\n  return await (\n    await request({\n      name: \"Chapter Icon\",\n      url: `${AppConf.settingsBaseUrl}/chapter-icons/${chapter}.png`,\n      method: \"GET\",\n    })\n  ).arrayBuffer();\n}\n\n/**\n * Get all the notification settings.\n */", "export async function getNotificationSettings(): Promise<\n  Array<NotificationSetting>\n> {\n  return await (\n    await request({\n      name: \"Notification Settings\",\n      url: `${AppConf.settingsBaseUrl}/notifications.json`,\n      method: \"GET\",\n    })\n  ).json();\n}\n"]}
{"filename": "src/api/dao/github.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\nimport { AppConf } from \"../app-conf\";\n\nexport type GithubIssue = {\n  title: string;\n  body: string;\n};\n\nexport interface GithubIssueResponse {\n  url: string;\n  repository_url: string;\n  labels_url: string;\n  comments_url: string;\n  events_url: string;\n  html_url: string;\n  id: number;\n  node_id: string;\n  number: number;\n  title: string;\n  user: User;\n  labels: any[];\n  state: string;\n  locked: boolean;\n  assignee: null;\n  assignees: any[];\n  milestone: null;\n  comments: number;\n  created_at: Date;\n  updated_at: Date;\n  closed_at: null;\n  author_association: string;\n  active_lock_reason: null;\n  body: string;\n  closed_by: null;\n  reactions: Reactions;\n  timeline_url: string;\n  performed_via_github_app: null;\n  state_reason: null;\n}\n", "export interface GithubIssueResponse {\n  url: string;\n  repository_url: string;\n  labels_url: string;\n  comments_url: string;\n  events_url: string;\n  html_url: string;\n  id: number;\n  node_id: string;\n  number: number;\n  title: string;\n  user: User;\n  labels: any[];\n  state: string;\n  locked: boolean;\n  assignee: null;\n  assignees: any[];\n  milestone: null;\n  comments: number;\n  created_at: Date;\n  updated_at: Date;\n  closed_at: null;\n  author_association: string;\n  active_lock_reason: null;\n  body: string;\n  closed_by: null;\n  reactions: Reactions;\n  timeline_url: string;\n  performed_via_github_app: null;\n  state_reason: null;\n}\n", "export interface Reactions {\n  url: string;\n  total_count: number;\n  \"+1\": number;\n  \"-1\": number;\n  laugh: number;\n  hooray: number;\n  confused: number;\n  heart: number;\n  rocket: number;\n  eyes: number;\n}\n", "export interface User {\n  login: string;\n  id: number;\n  node_id: string;\n  avatar_url: string;\n  gravatar_id: string;\n  url: string;\n  html_url: string;\n  followers_url: string;\n  following_url: string;\n  gists_url: string;\n  starred_url: string;\n  subscriptions_url: string;\n  organizations_url: string;\n  repos_url: string;\n  events_url: string;\n  received_events_url: string;\n  type: string;\n  site_admin: boolean;\n}\n", "export async function createIssue(\n  repo: string,\n  issue: GithubIssue\n): Promise<GithubIssueResponse> {\n  return (\n    await request({\n      name: \"Create Github Issue\",\n      url: `${AppConf.githubApiBaseUrl}/repos/${repo}/issues`,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n        Authorization: `Bearer ${AppConf.githubAuthKey}`,\n        Accept: \"application/vnd.github+json\",\n      },\n      body: issue,\n    })\n  ).json();\n}\n"]}
{"filename": "src/api/util/request.util.ts", "chunked_list": ["import colors from \"colors\";\n\nexport type RequestOptions = {\n  name: string;\n  url: string;\n  body?: any;\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n  headers?: Record<string, string>;\n};\n\nexport async function request(options: RequestOptions): Promise<Response> {\n  console.info(\n    colors.blue.bold(\"REST Request \") +\n      colors.yellow(options.name) +\n      \"\\n\" +\n      colors.yellow(\n        JSON.stringify({\n          name: options.name,\n          url: options.url,\n          method: options.method,\n          headers: options.headers,\n          body: !!options.body,\n        })\n      ) +\n      \"\\n\"\n  );\n  let response;", "export async function request(options: RequestOptions): Promise<Response> {\n  console.info(\n    colors.blue.bold(\"REST Request \") +\n      colors.yellow(options.name) +\n      \"\\n\" +\n      colors.yellow(\n        JSON.stringify({\n          name: options.name,\n          url: options.url,\n          method: options.method,\n          headers: options.headers,\n          body: !!options.body,\n        })\n      ) +\n      \"\\n\"\n  );\n  let response;", "  try {\n    response = await fetch(options.url, {\n      method: options.method,\n      headers: options.headers,\n      body: JSON.stringify(options.body),\n    });\n  } catch (e) {\n    console.error(\n      colors.blue.bold(\"REST Response \") +\n        colors.yellow(options.name) +\n        colors.red.bold(\" FAILURE\") +\n        \"\\n\" +\n        colors.yellow(`ERROR: ${e}`) +\n        \"\\n\"\n    );\n    throw \"Failed to fetch\";\n  }\n", "  if (response.ok) {\n    console.info(\n      colors.blue.bold(\"REST Response \") +\n        colors.yellow(options.name) +\n        colors.green.bold(\" SUCCESS\") +\n        \"\\n\" +\n        colors.yellow(\n          JSON.stringify({\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers,\n            data: !!response.body,\n          })\n        ) +\n        \"\\n\"\n    );\n  } else {\n    console.error(\n      colors.blue.bold(\"REST Response \") +\n        colors.yellow(options.name) +\n        colors.red.bold(\" FAILURE\") +\n        \"\\n\" +\n        colors.yellow(\n          JSON.stringify({\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers,\n          })\n        ) +\n        \"\\n\"\n    );\n    throw response;\n  }\n  return response;\n}\n"]}
{"filename": "src/api/service/events.service.ts", "chunked_list": ["import { getMeetupEvents, MeetupEvent } from \"../dao/meetup.dao\";\nimport { getChapters } from \"../dao/settings.dao\";\n\n/**\n * Get a list of all upcoming events for Code and Coffee.\n */\nexport async function getEvents(): Promise<Array<MeetupEvent>> {\n  const chapters = await getChapters();\n  const events = await getMeetupEvents(chapters);\n  return events.sort((a, b) => {\n    return new Date(a.dateTime).getTime() - new Date(b.dateTime).getTime();\n  });\n}\n"]}
{"filename": "src/api/service/notify.service.ts", "chunked_list": ["import { getNotificationSettings } from \"../dao/settings.dao\";\nimport { sendEmail } from \"../dao/email.dao\";\nimport { createIssue } from \"../dao/github.dao\";\n\ntype Notification = {\n  channel: string;\n  title: string;\n  message: string;\n};\nexport async function notify(notification: Notification): Promise<void> {\n  if (!isNotificationValid(notification)) {\n    throw new Error(\"INVALID_NOTIFICATION\");\n  }\n  const channelSetting = (await getNotificationSettings()).find(\n    (setting) => setting.name === notification.channel\n  );", "export async function notify(notification: Notification): Promise<void> {\n  if (!isNotificationValid(notification)) {\n    throw new Error(\"INVALID_NOTIFICATION\");\n  }\n  const channelSetting = (await getNotificationSettings()).find(\n    (setting) => setting.name === notification.channel\n  );\n  if (!channelSetting) {\n    throw new Error(\"INVALID_NOTIFICATION\");\n  }\n  if (channelSetting.email) {\n    await sendEmail({\n      body: notification.message,\n      recipient: channelSetting.email,\n      subject: channelSetting.emailTitlePrepend\n        ? `${channelSetting.emailTitlePrepend}${notification.title}`\n        : notification.title,\n    });\n  }", "  if (channelSetting.email) {\n    await sendEmail({\n      body: notification.message,\n      recipient: channelSetting.email,\n      subject: channelSetting.emailTitlePrepend\n        ? `${channelSetting.emailTitlePrepend}${notification.title}`\n        : notification.title,\n    });\n  }\n  if (channelSetting.github) {\n    await createIssue(channelSetting.github, {\n      title: notification.title,\n      body: notification.message,\n    });\n  }\n}\n", "  if (channelSetting.github) {\n    await createIssue(channelSetting.github, {\n      title: notification.title,\n      body: notification.message,\n    });\n  }\n}\n\nfunction isNotificationValid(notification: any): boolean {\n  return !(\n    !notification ||\n    !notification.channel ||\n    !notification.title ||\n    !notification.message\n  );\n}\n", "function isNotificationValid(notification: any): boolean {\n  return !(\n    !notification ||\n    !notification.channel ||\n    !notification.title ||\n    !notification.message\n  );\n}\n"]}
{"filename": "src/api/controllers/notify.controller.ts", "chunked_list": ["import { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\nimport { APIGatewayProxyEventV2 } from \"aws-lambda\";\nimport { notify } from \"../service/notify.service\";\n\nexport async function notifyController(\n  event: APIGatewayProxyEventV2\n): Promise<APIGatewayProxyStructuredResultV2> {\n  try {\n    await notify(JSON.parse(event.body || \"\"));\n  } catch (e: any) {\n    if (e.message === \"INVALID_NOTIFICATION\") {\n      return {\n        statusCode: 400,\n        body: JSON.stringify({\n          result: \"INVALID_NOTIFICATION\",\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n    } else {\n      return {\n        statusCode: 500,\n        body: JSON.stringify({\n          result: \"FAILURE\",\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n    }\n  }\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      result: \"SUCCESS\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  };\n}\n", "  } catch (e: any) {\n    if (e.message === \"INVALID_NOTIFICATION\") {\n      return {\n        statusCode: 400,\n        body: JSON.stringify({\n          result: \"INVALID_NOTIFICATION\",\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n    } else {\n      return {\n        statusCode: 500,\n        body: JSON.stringify({\n          result: \"FAILURE\",\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n    }\n  }\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      result: \"SUCCESS\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  };\n}\n"]}
{"filename": "src/api/controllers/chapters.controller.ts", "chunked_list": ["import { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\nimport { getEvents } from \"../service/events.service\";\n\nexport async function chaptersController(): Promise<APIGatewayProxyStructuredResultV2> {\n  return {\n    statusCode: 200,\n    body: JSON.stringify(await getEvents()),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  };\n}\n"]}
{"filename": "src/api/controllers/health.controller.ts", "chunked_list": ["import { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\nexport function healthController(): APIGatewayProxyStructuredResultV2 {\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      status: \"OK\",\n      timestamp: new Date().toUTCString(),\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  };\n}\n"]}
{"filename": "src/api/controllers/chapter-icon.controller.ts", "chunked_list": ["import { APIGatewayProxyEventV2 } from \"aws-lambda\";\nimport { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\nimport { getChapterIcon } from \"../dao/settings.dao\";\n\nexport async function chapterIconController(\n  event: APIGatewayProxyEventV2\n): Promise<APIGatewayProxyStructuredResultV2> {\n  try {\n    return {\n      statusCode: 200,\n      body: new Buffer(\n        await getChapterIcon(extractChapter(event.rawPath))\n      ).toString(\"base64\"),\n      headers: {\n        \"Content-Type\": \"image/png\",\n      },\n      isBase64Encoded: true,\n    };", "  } catch (e: any | Response) {\n    if (e.status === 404) {\n      return {\n        statusCode: 404,\n        body: \"Not Found\",\n        headers: {\n          \"Content-Type\": \"text/plain\",\n        },\n      };\n    } else {\n      throw e;\n    }\n  }\n}\n\nconst chapterRegex = /(?<=\\/info\\/chapter-icons\\/).*$/;", "function extractChapter(path: string): string {\n  const results = path.match(chapterRegex);\n  if (results === null) {\n    throw new Error(`Could not extract chapter from path ${path}`);\n  }\n  return results[0];\n}\n"]}
{"filename": "src/ui/web-conf.ts", "chunked_list": ["export const WebConf = {\n  smBreakpoint: 600,\n  rootHost: import.meta.env.VITE_ROOT_URL,\n};\n"]}
{"filename": "src/ui/calendar/events.util.ts", "chunked_list": ["import { EventsResponse } from \"../../api\";\n\nexport type EventStats = {\n  totalEvents: number;\n  totalActiveChapters: number;\n  totalRSVPs: number;\n};\n\n/**\n * Gets the stats for all the current events.\n *\n * @param events The events to get stats from\n */", "export function getEventStats(events: EventsResponse): EventStats {\n  const result: EventStats = {\n    totalEvents: 0,\n    totalActiveChapters: 0,\n    totalRSVPs: 0,\n  };\n  const chapters = new Set<string>();\n  events.forEach((event) => {\n    result.totalEvents++;\n    result.totalRSVPs += event.going;\n    if (!chapters.has(event.group.urlname)) {\n      result.totalActiveChapters++;\n      chapters.add(event.group.urlname);\n    }\n  });\n  return result;\n}\n", "    if (!chapters.has(event.group.urlname)) {\n      result.totalActiveChapters++;\n      chapters.add(event.group.urlname);\n    }\n  });\n  return result;\n}\n"]}
{"filename": "src/ui/calendar/coffee.dao.ts", "chunked_list": ["import { EventsResponse } from \"../../api\";\nimport { WebConf } from \"../web-conf\";\n\n/**\n * Get the details of all events from the Code and Coffee service.\n */\nexport async function getEvents(): Promise<EventsResponse> {\n  const response = await fetch(`${WebConf.rootHost}/info/events`, {\n    method: \"GET\",\n  });\n  return response.json();\n}\n"]}
