{"filename": "src/interfaces.d.ts", "chunked_list": ["import {TSetting} from './types';\nimport {APP_SETTINGS} from './shared/appSettings';\n\nexport interface IPausable {\n  start(): void;\n  pause(): void;\n}\n\nexport interface ISettingsSubscriber {\n  onSettingChange(name: APP_SETTINGS, value: TSetting): void;\n  get SETTINGS(): APP_SETTINGS[];\n}\n", "export interface ISettingsSubscriber {\n  onSettingChange(name: APP_SETTINGS, value: TSetting): void;\n  get SETTINGS(): APP_SETTINGS[];\n}\n"]}
{"filename": "src/types.d.ts", "chunked_list": ["import '@types/chrome';\nimport '@types/firefox';\nimport {APP_SETTINGS} from './shared/appSettings';\n\nexport type TSetting = boolean | number | string;\nexport type TSettings = { [key in APP_SETTINGS]: TSetting };\n\nexport type TEventKey = keyof HTMLElementEventMap;\nexport type TEventListener<T> = (this: Element, ev: T) => any;\nexport type TEventOptions = boolean | AddEventListenerOptions;\n", "export type TEventListener<T> = (this: Element, ev: T) => any;\nexport type TEventOptions = boolean | AddEventListenerOptions;\n"]}
{"filename": "src/popup/settingsKeeper.ts", "chunked_list": ["import {TSetting} from '../types';\nimport {APP_SETTINGS, DEFAULT_SETTINGS} from '../shared/appSettings';\nimport {setSettings} from '../shared/browserApi';\nimport {SettingsProvider} from '../shared/settingsProvider';\n\nclass SettingsKeeper extends SettingsProvider {\n  async set(settingName: APP_SETTINGS, value: TSetting): Promise<void> {\n    if (!this.isInitialized) throw new Error('SettingsKeeper are not initialized');\n    if (!(settingName in DEFAULT_SETTINGS)) throw new Error(`Unknown setting: ${settingName}`);\n    const oldSettings = this.getAll();\n", "    if (!(settingName in DEFAULT_SETTINGS)) throw new Error(`Unknown setting: ${settingName}`);\n    const oldSettings = this.getAll();\n\n    try {\n      this.settings[settingName] = value;\n      await setSettings(this.settings);\n    } catch (e) {\n      this.settings = oldSettings;\n      throw e;\n    }\n  }\n}\n\nconst settingsKeeper = new SettingsKeeper();\n\nexport const getSettingsKeeper = async (): Promise<SettingsKeeper> => {\n  await settingsKeeper.initialize();\n  return settingsKeeper;\n};\n"]}
{"filename": "src/shared/appSettings.ts", "chunked_list": ["import {TSettings} from '../types';\n\nexport enum APP_SETTINGS {\n  BLUESKY_OVERHAUL_ENABLED = 'bluesky-overhaul-enabled',\n  HANDLE_VIM_KEYBINDINGS = 'vim-keybindings',\n  HIDE_FOLLOWERS_COUNT = 'hide-followers-count',\n  HIDE_FOLLOWING_COUNT = 'hide-following-count',\n  HIDE_POSTS_COUNT = 'hide-posts-count',\n  SHOW_POST_DATETIME = 'show-post-datetime',\n  BSKY_IDENTIFIER = 'bsky-identifier',\n  BSKY_PASSWORD = 'bsky-password'\n}\n\nexport const DEFAULT_SETTINGS: TSettings = {\n  [APP_SETTINGS.BLUESKY_OVERHAUL_ENABLED]: true,\n  [APP_SETTINGS.HANDLE_VIM_KEYBINDINGS]: false,\n  [APP_SETTINGS.HIDE_FOLLOWERS_COUNT]: false,\n  [APP_SETTINGS.HIDE_FOLLOWING_COUNT]: false,\n  [APP_SETTINGS.HIDE_POSTS_COUNT]: false,\n  [APP_SETTINGS.SHOW_POST_DATETIME]: true,\n  [APP_SETTINGS.BSKY_IDENTIFIER]: '',\n  [APP_SETTINGS.BSKY_PASSWORD]: ''\n};\n"]}
{"filename": "src/shared/browserApi.ts", "chunked_list": ["import {TSettings} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst browserAPI = window.browser || chrome;\n\nconst SETTINGS_KEY = 'settings';\n\nexport const clearStorage = async (): Promise<void> => {\n  await browserAPI.storage.local.clear();", "export const clearStorage = async (): Promise<void> => {\n  await browserAPI.storage.local.clear();\n};\n\nexport const getSettings = async (): Promise<TSettings> => {\n  const storage = await browserAPI.storage.local.get();\n  return storage[SETTINGS_KEY] || {};\n};\n\nexport const setSettings = async (newSettings: TSettings): Promise<void> => {", "\nexport const setSettings = async (newSettings: TSettings): Promise<void> => {\n  await browserAPI.storage.local.set({[SETTINGS_KEY]: newSettings});\n};\n\nexport const subscribeToSettings = (listener: (newSettings: TSettings) => void): void => {\n  browserAPI.storage.onChanged.addListener((changes: any, namespace: any) => {\n    if (namespace === 'local' && changes[SETTINGS_KEY]) {\n      listener(changes[SETTINGS_KEY].newValue);\n    }\n  });\n};\n"]}
{"filename": "src/shared/settingsProvider.ts", "chunked_list": ["import {TSetting, TSettings} from '../types';\nimport {APP_SETTINGS, DEFAULT_SETTINGS} from './appSettings';\nimport {getSettings} from './browserApi';\n\nexport class SettingsProvider {\n  protected settings: TSettings = {...DEFAULT_SETTINGS};\n  protected isInitialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    const savedSettings = await getSettings();\n    this.settings = {...DEFAULT_SETTINGS, ...savedSettings};\n    this.isInitialized = true;\n  }\n\n  getAll(): TSettings {", "    if (this.isInitialized) return;\n    const savedSettings = await getSettings();\n    this.settings = {...DEFAULT_SETTINGS, ...savedSettings};\n    this.isInitialized = true;\n  }\n\n  getAll(): TSettings {\n    if (!this.isInitialized) throw new Error('SettingsKeeper are not initialized');\n    return {...this.settings};\n  }\n\n  get(settingName: APP_SETTINGS): TSetting {", "    if (!this.isInitialized) throw new Error('SettingsKeeper are not initialized');\n    if (!(settingName in this.settings)) throw new Error(`Setting ${settingName} is not present`);\n    return this.settings[settingName];\n  }\n}\n"]}
{"filename": "src/shared/misc.ts", "chunked_list": ["// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = (): void => {};\n\nexport const preventDefault = (e: any): void => e.preventDefault();\n\nexport const delay = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n", ""]}
{"filename": "src/content/main.ts", "chunked_list": ["import '@webcomponents/custom-elements';\nimport {APP_SETTINGS} from '../shared/appSettings';\nimport {getSettingsManager} from './browser/settingsManager';\nimport {ultimatelyFind} from './dom/utils';\nimport {ROOT_CONTAINER, FEED_CONTAINER, MODAL_CONTAINER, COMPOSE_MODAL} from './dom/selectors';\nimport {CountersConcealer} from './watchers/countersConcealer';\nimport {KeydownWatcher} from './watchers/keydown';\nimport {PostDatetimeWatcher} from './watchers/postDatetime';\nimport {YoutubeWatcher} from './watchers/youtube';\nimport {PostModalPipeline} from './pipelines/postModal';", "import {YoutubeWatcher} from './watchers/youtube';\nimport {PostModalPipeline} from './pipelines/postModal';\nimport {EmojiPipeline} from './pipelines/emoji';\nimport {QuotePostPipeline} from './pipelines/quotePost';\nimport {log} from './utils/logger';\nimport {PipelineManager} from './utils/pipelineManager';\n\nconst REPO_LINK = 'https://github.com/xenohunter/bluesky-overhaul';\nconst EXTENSION_DISABLED_CODE = 'EXTENSION_DISABLED';\n", "const EXTENSION_DISABLED_CODE = 'EXTENSION_DISABLED';\n\nconst run = async (): Promise<void> => {\n  const settingsManager = await getSettingsManager();\n  if (settingsManager.get(APP_SETTINGS.BLUESKY_OVERHAUL_ENABLED) === false) {\n    return Promise.reject(EXTENSION_DISABLED_CODE);\n  }\n\n  return ultimatelyFind(document.body, ROOT_CONTAINER).then((rootContainer) => Promise.all([\n    Promise.resolve(rootContainer),\n    ultimatelyFind(rootContainer, FEED_CONTAINER),\n    ultimatelyFind(rootContainer, MODAL_CONTAINER)\n  ]).then(([rootContainer, feedContainer, modalContainer]) => {\n    const countersConcealer = new CountersConcealer(document.body);\n    settingsManager.subscribe(countersConcealer);\n    countersConcealer.watch();\n\n    const keydownWatcher = new KeydownWatcher(rootContainer, feedContainer);\n    settingsManager.subscribe(keydownWatcher);\n    keydownWatcher.watch();\n\n    const postDatetimeWatcher = new PostDatetimeWatcher(feedContainer);\n    settingsManager.subscribe(postDatetimeWatcher);\n    postDatetimeWatcher.watch();\n\n    const youtubeWatcher = new YoutubeWatcher(feedContainer);\n    youtubeWatcher.watch();\n\n    const postModalPipeline = new PostModalPipeline(() => keydownWatcher.pause(), () => keydownWatcher.start());\n    const emojiPipeline = new EmojiPipeline(() => postModalPipeline.pause(), () => postModalPipeline.start());\n    const quotePostPipeline = new QuotePostPipeline();\n\n    const pipelineManager = new PipelineManager({\n      compose: [postModalPipeline, emojiPipeline, quotePostPipeline]\n    });\n\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {", "        if (mutation.target === modalContainer) {\n          const composePostModal = modalContainer.querySelector(COMPOSE_MODAL.selector) as HTMLElement | null;\n          if (composePostModal !== null) {\n            pipelineManager.terminateExcept('compose');\n            pipelineManager.deploy('compose', composePostModal);\n          } else {\n            pipelineManager.terminateAll();\n          }\n        }\n      });\n    });\n\n    observer.observe(modalContainer, {childList: true, subtree: true});\n  }));\n};\n\nrun().then(() => {\n  log('Launched');", "}).catch(() => {\n  setTimeout(() => {\n    run().then(() => {\n      log('Launched after the second attempt (1000ms delay)');\n    }).catch((e) => {\n      if (e === EXTENSION_DISABLED_CODE) return;\n      console.error(`Failed to launch Bluesky Overhaul. Please, copy the error and report this issue: ${REPO_LINK}`);\n      console.error(e);\n    });\n  }, 1000);\n});\n"]}
{"filename": "src/content/pipelines/pipeline.ts", "chunked_list": ["export abstract class Pipeline {\n  abstract deploy(modal: HTMLElement): void;\n  abstract terminate(): void;\n}\n"]}
{"filename": "src/content/pipelines/postModal.ts", "chunked_list": ["import {IPausable} from '../../interfaces';\nimport {log} from '../utils/logger';\nimport {Pipeline} from './pipeline';\nimport {EventKeeper} from '../utils/eventKeeper';\nimport {COMPOSE_CANCEL_BUTTON, COMPOSE_CONTENT_EDITABLE} from '../dom/selectors';\nimport {ultimatelyFind} from '../dom/utils';\n\n\nexport class PostModalPipeline extends Pipeline implements IPausable {\n  #modal: HTMLElement | null;\n  #exitButton: HTMLElement | null;\n  #contentEditable: HTMLElement | null;\n  readonly #eventKeeper: EventKeeper;\n  readonly #pauseOuterServices: () => void;\n  readonly #resumeOuterServices: () => void;\n  #paused = false;\n\n  constructor(pauseCallback: () => void, resumeCallback: () => void) {\n    super();\n    this.#modal = null;\n    this.#exitButton = null;\n    this.#contentEditable = null;\n    this.#eventKeeper = new EventKeeper();\n    this.#pauseOuterServices = pauseCallback;\n    this.#resumeOuterServices = resumeCallback;\n  }\n\n  deploy(modal: HTMLElement): void {", "export class PostModalPipeline extends Pipeline implements IPausable {\n  #modal: HTMLElement | null;\n  #exitButton: HTMLElement | null;\n  #contentEditable: HTMLElement | null;\n  readonly #eventKeeper: EventKeeper;\n  readonly #pauseOuterServices: () => void;\n  readonly #resumeOuterServices: () => void;\n  #paused = false;\n\n  constructor(pauseCallback: () => void, resumeCallback: () => void) {\n    super();\n    this.#modal = null;\n    this.#exitButton = null;\n    this.#contentEditable = null;\n    this.#eventKeeper = new EventKeeper();\n    this.#pauseOuterServices = pauseCallback;\n    this.#resumeOuterServices = resumeCallback;\n  }\n\n  deploy(modal: HTMLElement): void {", "    if (this.#modal !== null) {\n      log('PostModalPipeline is already deployed');\n      return;\n    }\n\n    this.#pauseOuterServices();\n    this.#modal = modal;\n\n    Promise.all([\n      ultimatelyFind(modal, COMPOSE_CANCEL_BUTTON),\n      ultimatelyFind(modal, COMPOSE_CONTENT_EDITABLE)\n    ]).then(([exitButton, contentEditable]) => {\n      this.#exitButton = exitButton;\n      this.#contentEditable = contentEditable;\n\n      this.#eventKeeper.add(document, 'click', this.#onClick.bind(this));\n      this.#eventKeeper.add(contentEditable, 'mousedown', this.#onPresumedSelect.bind(this));\n      this.#eventKeeper.add(exitButton, 'click', () => this.#eventKeeper.cancelAll());\n    });\n  }\n\n  terminate(): void {", "    if (this.#modal === null) {\n      log('PostModalPipeline is not deployed');\n      return;\n    }\n\n    this.start();\n    this.#eventKeeper.cancelAll();\n    this.#modal = this.#exitButton = this.#contentEditable = null;\n    this.#resumeOuterServices();\n  }\n\n  start(): void {\n    this.#paused = false;\n  }\n\n  pause(): void {\n    this.#paused = true;\n  }\n\n  #onClick(event: MouseEvent): void {", "    if (this.#paused) return;\n\n    const target = event.target as HTMLElement;\n    if (target?.tagName.toLowerCase() === 'button') return;\n\n    if (!this.#modal?.contains(event.target as Node) && event.target !== this.#exitButton) {\n      this.#eventKeeper.cancelAll();\n      this.#exitButton?.click();\n    }\n  }\n\n  #onPresumedSelect(): void {", "    if (this.#paused) return;\n\n    this.pause();\n    document.addEventListener('mouseup', () => setTimeout(this.start.bind(this), 0), {once: true});\n  }\n}\n"]}
{"filename": "src/content/pipelines/emoji.ts", "chunked_list": ["import {Picker} from 'emoji-mart';\nimport {emojiData} from '../hacks/emojiDataWrapper';\nimport {ultimatelyFind} from '../dom/utils';\nimport {COMPOSE_PHOTO_BUTTON, COMPOSE_CONTENT_EDITABLE} from '../dom/selectors';\nimport {Cursor} from '../utils/cursor';\nimport {EventKeeper} from '../utils/eventKeeper';\nimport {log} from '../utils/logger';\nimport {typeText} from '../utils/text';\nimport {Pipeline} from './pipeline';\nimport {noop} from '../../shared/misc';", "import {Pipeline} from './pipeline';\nimport {noop} from '../../shared/misc';\n\nconst EMOJI_CHARACTER_LENGTH = 2;\n\nconst createEmojiButton = (rightmostButton: HTMLElement): HTMLElement => {\n  const emojiButton = rightmostButton.cloneNode(false) as HTMLElement;\n  emojiButton.innerHTML = '\ud83d\ude00';\n  return emojiButton;\n};", "  return emojiButton;\n};\n\nconst createEmojiPopup = (modal: HTMLElement, emojiButton: HTMLElement): HTMLElement => {\n  const emojiPopup = document.createElement('div');\n  emojiPopup.style.position = 'absolute';\n  emojiPopup.style.display = 'none';\n\n  const modalCoords = modal.getBoundingClientRect();\n  const emojiButtonCoords = emojiButton.getBoundingClientRect();", "  const modalCoords = modal.getBoundingClientRect();\n  const emojiButtonCoords = emojiButton.getBoundingClientRect();\n  emojiPopup.style.left = emojiButtonCoords.x - modalCoords.x + 'px';\n  emojiPopup.style.top = emojiButtonCoords.y - modalCoords.y + emojiButtonCoords.height + 'px';\n\n  return emojiPopup;\n};\n\nexport class EmojiPipeline extends Pipeline {\n  #modal: HTMLElement | null;\n  #picker: Picker | null;\n  #cursor: Cursor | null;\n  readonly #eventKeeper: EventKeeper;\n  #elems: { [key: string]: HTMLElement };\n  #expanded: boolean;\n  readonly #pauseOuterServices: () => void;\n  readonly #resumeOuterServices: () => void;\n\n  constructor(pauseCallback: () => void, resumeCallback: () => void) {\n    super();\n    this.#modal = null;\n    this.#picker = null;\n    this.#cursor = null;\n\n    this.#eventKeeper = new EventKeeper();\n    this.#elems = {};\n\n    this.#expanded = false;\n    this.#pauseOuterServices = pauseCallback;\n    this.#resumeOuterServices = resumeCallback;\n  }\n\n  deploy(modal: HTMLElement): void {", "export class EmojiPipeline extends Pipeline {\n  #modal: HTMLElement | null;\n  #picker: Picker | null;\n  #cursor: Cursor | null;\n  readonly #eventKeeper: EventKeeper;\n  #elems: { [key: string]: HTMLElement };\n  #expanded: boolean;\n  readonly #pauseOuterServices: () => void;\n  readonly #resumeOuterServices: () => void;\n\n  constructor(pauseCallback: () => void, resumeCallback: () => void) {\n    super();\n    this.#modal = null;\n    this.#picker = null;\n    this.#cursor = null;\n\n    this.#eventKeeper = new EventKeeper();\n    this.#elems = {};\n\n    this.#expanded = false;\n    this.#pauseOuterServices = pauseCallback;\n    this.#resumeOuterServices = resumeCallback;\n  }\n\n  deploy(modal: HTMLElement): void {", "    if (this.#modal !== null) {\n      log('EmojiPipeline already deployed');\n      return;\n    }\n\n    this.#modal = modal;\n    this.#picker = this.#createPicker();\n\n    Promise.all([\n      ultimatelyFind(modal, [COMPOSE_PHOTO_BUTTON]),\n      ultimatelyFind(modal, COMPOSE_CONTENT_EDITABLE)\n    ]).then(([photoButton, contentEditable]) => {\n      this.#elems.photoButton = photoButton;\n      this.#elems.contentEditable = contentEditable;\n\n      this.#elems.emojiButton = createEmojiButton(this.#elems.photoButton);\n      this.#elems.photoButton.insertAdjacentElement('afterend', this.#elems.emojiButton);\n\n      this.#elems.emojiPopup = createEmojiPopup(modal, this.#elems.emojiButton);\n      this.#elems.emojiPopup.appendChild(this.#picker as unknown as HTMLElement);\n      modal.appendChild(this.#elems.emojiPopup);\n\n      this.#eventKeeper.add(this.#elems.emojiButton, 'click', this.#onButtonClick.bind(this));\n\n      this.#cursor = new Cursor(this.#elems.contentEditable);\n      const outerCallback = (): void => this.#cursor?.save();\n      this.#eventKeeper.add(this.#elems.contentEditable, 'keyup', outerCallback);\n      this.#eventKeeper.add(this.#elems.contentEditable, 'mouseup', outerCallback);\n    });\n  }\n\n  terminate(): void {", "    if (this.#modal === null) {\n      log('EmojiPipeline already terminated');\n      return;\n    }\n\n    this.#removeElements();\n    this.#eventKeeper.cancelAll();\n    this.#modal = this.#picker = this.#cursor = null;\n  }\n\n  #createPicker(): Picker {\n    return new Picker({\n      emojiData,\n      emojiSize: 22,\n      onEmojiSelect: (emoji: { [key: string]: any }): void => {\n        this.#cursor?.restore();\n        typeText(emoji.native);\n        this.#cursor?.move(EMOJI_CHARACTER_LENGTH);\n        this.#focusOnPickerSearch();\n      }\n    });\n  }\n\n  #focusOnPickerSearch(): void {", "    if (!this.#picker) return;\n    this.#getPickerSearch()?.focus();\n  }\n\n  #clearPickerSearch(): void {\n    if (!this.#picker) return;\n    const pickerSearch = this.#getPickerSearch();\n    if (pickerSearch) pickerSearch.value = '';\n  }\n\n  #getPickerSearch(): HTMLInputElement | null {\n    const picker = this.#picker as unknown as HTMLElement;\n    return picker.shadowRoot?.querySelector('input[type=\"search\"]') as HTMLInputElement;\n  }\n\n  #onButtonClick(): void {", "    if (this.#expanded) return;\n\n    this.#elems.emojiPopup.style.display = 'block';\n    this.#expanded = true;\n    this.#pauseOuterServices();\n    this.#focusOnPickerSearch();\n\n    const clickOutside = (event: Event): void => {\n      const target = event.target as HTMLElement;\n      if (this.#elems.emojiPopup && !this.#elems.emojiPopup.contains(target) && target !== this.#elems.emojiButton) {\n        this.#elems.emojiPopup.style.display = 'none';\n        this.#clearPickerSearch();\n        this.#expanded = false;\n        this.#modal?.removeEventListener('click', clickOutside);\n        document.removeEventListener('click', clickOutside);\n        this.#resumeOuterServices();\n        this.#elems.contentEditable.focus();\n      }\n    };\n\n    this.#modal?.addEventListener('click', clickOutside);\n    document.addEventListener('click', clickOutside);\n  }\n\n  #removeElements(): void {", "      if (this.#elems.emojiPopup && !this.#elems.emojiPopup.contains(target) && target !== this.#elems.emojiButton) {\n        this.#elems.emojiPopup.style.display = 'none';\n        this.#clearPickerSearch();\n        this.#expanded = false;\n        this.#modal?.removeEventListener('click', clickOutside);\n        document.removeEventListener('click', clickOutside);\n        this.#resumeOuterServices();\n        this.#elems.contentEditable.focus();\n      }\n    };\n\n    this.#modal?.addEventListener('click', clickOutside);\n    document.addEventListener('click', clickOutside);\n  }\n\n  #removeElements(): void {", "    for (const element of Object.values(this.#elems)) {\n      try {\n        if (element.parentElement) {\n          element.parentElement.removeChild(element);\n        } else {\n          element.remove();\n        }\n      } catch (e) {\n        noop();\n      }\n    }\n\n    this.#elems = {};\n  }\n}\n"]}
{"filename": "src/content/pipelines/quotePost.ts", "chunked_list": ["import {COMPOSE_CONTENT_EDITABLE, COMPOSE_LINK_CARD_BUTTON} from '../dom/selectors';\nimport {log} from '../utils/logger';\nimport {typeText, backspace} from '../utils/text';\nimport {Pipeline} from './pipeline';\nimport {ultimatelyFind} from '../dom/utils';\nimport {EventKeeper} from '../utils/eventKeeper';\n\nconst STAGING_URL_REGEX = /.*(https:\\/\\/staging\\.bsky\\.app\\/profile\\/.*\\/post\\/.*\\/?)$/;\nconst URL_REGEX = /.*(https:\\/\\/bsky\\.app\\/profile\\/.*\\/post\\/.*\\/?)$/;\n\nexport class QuotePostPipeline extends Pipeline {\n  #modal: HTMLElement | null;\n  #contentEditable: HTMLElement | null;\n  readonly #eventKeeper: EventKeeper;\n\n  constructor() {\n    super();\n    this.#modal = null;\n    this.#contentEditable = null;\n    this.#eventKeeper = new EventKeeper();\n  }\n\n  deploy(modal: HTMLElement): void {", "const URL_REGEX = /.*(https:\\/\\/bsky\\.app\\/profile\\/.*\\/post\\/.*\\/?)$/;\n\nexport class QuotePostPipeline extends Pipeline {\n  #modal: HTMLElement | null;\n  #contentEditable: HTMLElement | null;\n  readonly #eventKeeper: EventKeeper;\n\n  constructor() {\n    super();\n    this.#modal = null;\n    this.#contentEditable = null;\n    this.#eventKeeper = new EventKeeper();\n  }\n\n  deploy(modal: HTMLElement): void {", "    if (this.#modal !== null) {\n      log('QuotePostPipeline is already deployed');\n      return;\n    }\n\n    this.#modal = modal;\n\n    ultimatelyFind(modal, COMPOSE_CONTENT_EDITABLE).then((contentEditable) => {\n      this.#contentEditable = contentEditable;\n      this.#eventKeeper.add(contentEditable, 'paste', this.onPaste.bind(this), {capture: true});\n    });\n  }\n\n  terminate(): void {", "    if (this.#modal === null) {\n      log('QuotePostPipeline is not deployed');\n      return;\n    }\n\n    this.#eventKeeper.cancelAll();\n    this.#modal = this.#contentEditable = null;\n  }\n\n  onPaste(event: ClipboardEvent): void {\n    if (!event.clipboardData || !this.#contentEditable) return;", "    if (!event.clipboardData || !this.#contentEditable) return;\n    if (event.clipboardData.types.indexOf('text/plain') === -1) return;\n\n    event.preventDefault();\n    const contentEditable = this.#contentEditable;\n\n    let data = event.clipboardData.getData('text/plain');\n    if (data.match(STAGING_URL_REGEX) !== null) {\n      data = data.replace('https://staging.bsky.app/', 'https://bsky.app/');\n    }\n\n    contentEditable.focus();\n    typeText(data);\n    typeText(' '); // Add a space after the link for it to resolve as one\n\n    // Wait for the text to be inserted into the contentEditable\n    setTimeout(() => {\n      const lastChar = contentEditable.textContent?.slice(-1) ?? '';", "      if (lastChar === ' ') backspace();\n      if (data.match(URL_REGEX) !== null) {\n        this.#modal && ultimatelyFind(this.#modal, COMPOSE_LINK_CARD_BUTTON).then((linkCardButton) => {\n          linkCardButton.click();\n        });\n      }\n    }, 50);\n  }\n}\n"]}
{"filename": "src/content/utils/pipelineManager.ts", "chunked_list": ["import {Pipeline} from '../pipelines/pipeline';\nimport {log} from './logger';\n\nexport class PipelineManager {\n  pipelines: { [key: string]: Pipeline[] };\n\n  constructor(pipelines: { [key: string]: Pipeline[] }) {\n    this.pipelines = pipelines;\n  }\n\n  deploy(type: string, target: HTMLElement): void {\n    this.pipelines[type].forEach((pipeline) => {", "      try {\n        pipeline.deploy(target);\n      } catch (e) {\n        log(`Pipeline ${pipeline.constructor.name} was deployed with errors`, e);\n      }\n    });\n  }\n\n  terminate(type: string): void {\n    this.pipelines[type].forEach((pipeline) => {\n      try {\n        pipeline.terminate();", "      try {\n        pipeline.terminate();\n      } catch (e) {\n        log(`Pipeline ${pipeline.constructor.name} was terminated with errors`, e);\n      }\n    });\n  }\n\n  terminateAll(): void {\n    Object.keys(this.pipelines).forEach((t) => this.terminate(t));\n  }\n\n  terminateExcept(type: string): void {\n    Object.keys(this.pipelines).filter((t) => t !== type).forEach((t) => this.terminate(t));\n  }\n}\n"]}
{"filename": "src/content/utils/eventKeeper.ts", "chunked_list": ["import type {TEventKey, TEventListener, TEventOptions} from '../../types';\nimport {noop} from '../../shared/misc';\n\ntype TElement = Element | Document | Window;\ntype TEventListenerUnion = TEventListener<Event> | TEventListener<KeyboardEvent> | TEventListener<ClipboardEvent> | TEventListener<MouseEvent>;\n\ntype TEventRequisites = {\n  element: TElement;\n  event: TEventKey;\n  listener: TEventListenerUnion;\n  options?: TEventOptions;\n};\n", "export class EventKeeper {\n  #events: TEventRequisites[] = [];\n\n  add(element: TElement, eventKey: TEventKey, listener: TEventListenerUnion, options?: TEventOptions): void {\n    try {\n      element.addEventListener(eventKey, listener as TEventListener<Event>, options);\n      this.#events.push({element, event: eventKey, listener, options});\n    } catch (e) {\n      noop();\n    }\n  }\n\n  cancelAll(): void {", "    for (const {element, event, listener, options} of this.#events) {\n      try {\n        element.removeEventListener(event, listener as TEventListener<Event>, options);\n      } catch (e) {\n        noop();\n      }\n    }\n\n    this.#events = [];\n  }\n}\n"]}
{"filename": "src/content/utils/text.ts", "chunked_list": ["export const typeText = (text: string): boolean => document.execCommand('insertText', false, text);\nexport const backspace = (): boolean => document.execCommand('delete', false, undefined);\n"]}
{"filename": "src/content/utils/logger.ts", "chunked_list": ["export const log = (message: string, ...args: any): void => {\n  console.debug(`Bluesky Overhaul: ${message}`, ...args);\n};\n"]}
{"filename": "src/content/utils/callThrottler.ts", "chunked_list": ["export class CallThrottler {\n  readonly #delay: number;\n  #locked: boolean;\n\n  constructor (delay: number) {\n    this.#delay = delay;\n    this.#locked = false;\n  }\n\n  call (fn: (...args: any) => any, ...args: any): void {\n    if (this.#locked) return;\n    this.#locked = true;\n    fn(...args);\n    setTimeout(() => {\n      this.#locked = false;\n    }, this.#delay);\n  }\n}\n", "    if (this.#locked) return;\n    this.#locked = true;\n    fn(...args);\n    setTimeout(() => {\n      this.#locked = false;\n    }, this.#delay);\n  }\n}\n"]}
{"filename": "src/content/utils/notifications.ts", "chunked_list": ["import AWN from 'awesome-notifications';\n\ntype NotificationFn = (message: string) => void;\n\nconst DURATION = 3000;\n\n// TODO : fix the source of why notifications are updated so often\nconst throttle = (fn: NotificationFn, delay = DURATION - 1000): NotificationFn => {\n  const lastCalls = {} as { [key: string]: number };\n  return (message: string): void => {\n    const now = (new Date()).getTime();\n    const lastCall = lastCalls[message] || 0;", "    if (now - lastCall > delay) {\n      lastCalls[message] = now;\n      fn(message);\n    }\n  };\n};\n\nconst notifier = new AWN({\n  maxNotifications: 3,\n  durations: {\n    global: DURATION\n  }\n});\n\nexport const alert = throttle((message: string): void => {\n  notifier.alert(message);\n});\n\nexport const modal = throttle((message: string): void => {\n  notifier.modal(message);\n});\n\nexport const success = throttle((message: string): void => {\n  notifier.success(message);\n});\n\nexport const tip = throttle((message: string): void => {\n  notifier.tip(message);\n});\n"]}
{"filename": "src/content/utils/cursor.ts", "chunked_list": ["import {getCurrentCursorPosition, setCurrentCursorPosition} from './selection';\n\nexport class Cursor {\n  #position: number;\n  readonly #contentEditable: HTMLElement;\n\n  constructor(contentEditable: HTMLElement) {\n    this.#contentEditable = contentEditable;\n    this.#position = 0;\n  }\n\n  save(): void {\n    this.#position = getCurrentCursorPosition(this.#contentEditable);\n  }\n\n  restore(): void {\n    this.#contentEditable.focus();\n    setCurrentCursorPosition(this.#position, this.#contentEditable);\n  }\n\n  move(step: number): void {", "    if (this.#contentEditable.textContent === null) return;\n    this.#position += step;\n    if (this.#position < 0) {\n      this.#position = 0;\n    } else if (this.#position > this.#contentEditable.textContent.length) {\n      this.#position = this.#contentEditable.textContent.length;\n    }\n  }\n}\n"]}
{"filename": "src/content/utils/selection.ts", "chunked_list": ["// This code is courtesy of https://stackoverflow.com/a/62700928/1887427\n// Here, it has been restructured into exported and non-exported functions\n\nconst createRange = (node: Node, chars: { count: number }, range?: Range): Range => {\n  if (!range) {\n    range = document.createRange();\n    range.selectNode(node);\n    range.setStart(node, 0);\n  }\n\n  if (chars.count === 0) {\n    range.setEnd(node, chars.count);", "  if (chars.count === 0) {\n    range.setEnd(node, chars.count);\n  } else if (node && node.textContent && chars.count > 0) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      if (node.textContent.length < chars.count) {\n        chars.count -= node.textContent.length;\n      } else {\n        range.setEnd(node, chars.count);\n        chars.count = 0;\n      }\n    } else {", "      for (let lp = 0; lp < node.childNodes.length; lp++) {\n        range = createRange(node.childNodes[lp], chars, range);\n        if (chars.count === 0) break;\n      }\n    }\n  }\n\n  return range;\n};\n\nconst isChildOf = (node: Node, parentElement: Node): boolean => {", "  while (node !== null) {\n    if (node === parentElement) return true;\n    node = node.parentNode as Node;\n  }\n\n  return false;\n};\n\nexport const getCurrentCursorPosition = (parentElement: HTMLElement): number => {\n  const selection = window.getSelection();\n  let charCount = -1;\n  let node = null;\n", "  if (selection && selection.focusNode) {\n    if (isChildOf(selection.focusNode, parentElement)) {\n      node = selection.focusNode;\n      charCount = selection.focusOffset;\n\n      while (node) {\n        if (node === parentElement) break;\n        if (node.previousSibling) {\n          node = node.previousSibling;\n          charCount += node.textContent?.length ?? 0;\n        } else {\n          node = node.parentNode;", "          if (node === null) break;\n        }\n      }\n    }\n  }\n\n  return charCount;\n};\n\nexport const setCurrentCursorPosition = (chars: number, element: HTMLElement): void => {\n  if (chars >= 0) {\n    const selection = window.getSelection();\n    const range = createRange(element, {count: chars});\n", "  if (chars >= 0) {\n    const selection = window.getSelection();\n    const range = createRange(element, {count: chars});\n\n    if (selection && range) {\n      range.collapse(false);\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n  }\n};\n"]}
{"filename": "src/content/bsky/api.ts", "chunked_list": ["import {Post} from '@atproto/api/dist/src/types/app/bsky/getPostThread';\nimport {BskyAgent} from '@atproto/api';\n\nexport class LoginError extends Error {}\n\nexport const getAgent = async (identifier: string, password: string): Promise<BskyAgent> => {\n  const agent = new BskyAgent({service: 'https://bsky.social'});\n  // TODO : cache session\n  try {\n    await agent.login({identifier, password});\n    return agent;\n  } catch {\n    throw new LoginError();\n  }\n};\n\nexport const fetchPost = async (agent: BskyAgent, username: string, postId: string): Promise<Post> => {\n  const did = await agent.resolveHandle({ handle: username }).then((response) => response.data.did);\n  const response = await agent.getPostThread({uri: `at://${did}/app.bsky.feed.post/${postId}`});\n  return response.data.thread.post as Post;\n};\n", "  try {\n    await agent.login({identifier, password});\n    return agent;\n  } catch {\n    throw new LoginError();\n  }\n};\n\nexport const fetchPost = async (agent: BskyAgent, username: string, postId: string): Promise<Post> => {\n  const did = await agent.resolveHandle({ handle: username }).then((response) => response.data.did);\n  const response = await agent.getPostThread({uri: `at://${did}/app.bsky.feed.post/${postId}`});\n  return response.data.thread.post as Post;\n};\n"]}
{"filename": "src/content/dom/selectors.ts", "chunked_list": ["import {FIRST_CHILD_MARKER, LAST_CHILD_MARKER, POST_ITEM_LINK_INJECTED_MARKER} from './constants';\nimport {Selector} from './selector';\nimport {SelectorGroup} from './selectorGroup';\n\n// TODO : remake Selector and SelectorGroup in such a way they could support relative chaining\n\nexport const FIRST_CHILD = new Selector(FIRST_CHILD_MARKER);\nexport const LAST_CHILD = new Selector(LAST_CHILD_MARKER);\n\nexport const ROOT_CONTAINER = new Selector('#root > div > div');", "\nexport const ROOT_CONTAINER = new Selector('#root > div > div');\nexport const FEED_CONTAINER = [FIRST_CHILD, FIRST_CHILD, FIRST_CHILD]; // relative to ROOT_CONTAINER\nexport const MODAL_CONTAINER = LAST_CHILD; // relative to ROOT_CONTAINER\n\nexport const COMPOSE_MODAL = new Selector('[data-testid=\"composePostView\"]'); // relative to MODAL_CONTAINER\n\n// All the following are relative to COMPOSE_MODAL\nexport const COMPOSE_CANCEL_BUTTON = new Selector('[data-testid=\"composerCancelButton\"]');\nexport const COMPOSE_CONTENT_EDITABLE = new Selector('div.ProseMirror');", "export const COMPOSE_CANCEL_BUTTON = new Selector('[data-testid=\"composerCancelButton\"]');\nexport const COMPOSE_CONTENT_EDITABLE = new Selector('div.ProseMirror');\nexport const COMPOSE_LINK_CARD_BUTTON = new Selector('[data-testid=\"addLinkCardBtn\"]');\nexport const COMPOSE_PHOTO_BUTTON = new Selector('[data-testid=\"openGalleryBtn\"]');\n\nexport const SEARCH_BAR = new Selector('[data-testid=\"searchTextInput\"]'); // relative to FEED_CONTAINER\n\nexport const POST_ITEMS = new SelectorGroup([\n  new Selector('[data-testid^=\"postThreadItem\"]', {exhaustAfter: 5000}),\n  new Selector('[data-testid^=\"feedItem\"]', {exhaustAfter: 5000})", "  new Selector('[data-testid^=\"postThreadItem\"]', {exhaustAfter: 5000}),\n  new Selector('[data-testid^=\"feedItem\"]', {exhaustAfter: 5000})\n]);\n\n// relative to POST_ITEMS\nexport const POST_ITEM_LINKS = new SelectorGroup([\n  new Selector(`a[href*=\"youtu.be/\"]:not([${POST_ITEM_LINK_INJECTED_MARKER}])`),\n  new Selector(`a[href*=\"youtube.com/watch\"]:not([${POST_ITEM_LINK_INJECTED_MARKER}])`)\n]);\n", "]);\n"]}
{"filename": "src/content/dom/selector.ts", "chunked_list": ["import {FIRST_CHILD_MARKER, LAST_CHILD_MARKER} from './constants';\n\nconst DEFAULT_SEARCH_TIMEOUT = 2000;\n\n// TODO : make an InstantSelector class that would have exhaustAfter = 0\n\nexport class Selector {\n  // TODO : add .matches(element: HTMLElement) method\n\n  readonly selector: string;\n  readonly #firstOnly: boolean;\n  readonly exhaustAfter: number;\n\n  constructor(selector: string, {firstOnly = false, exhaustAfter = DEFAULT_SEARCH_TIMEOUT} = {}) {\n    this.selector = selector;\n    this.#firstOnly = firstOnly;\n    this.exhaustAfter = exhaustAfter;\n  }\n\n  retrieveFrom(elements: HTMLElement[]): HTMLElement[] {\n    let result;", "    if (this.selector === FIRST_CHILD_MARKER) {\n      result = elements.map((elem) => elem.firstChild);\n    } else if (this.selector === LAST_CHILD_MARKER) {\n      result = elements.map((elem) => elem.lastChild);\n    } else if (this.#firstOnly) {\n      result = elements.map((elem) => elem.querySelector(this.selector));\n    } else {\n      result = elements.map((elem) => Array.from(elem.querySelectorAll(this.selector))).flat();\n    }\n\n    return result.filter((elem) => elem !== null && elem !== undefined) as HTMLElement[];\n  }\n\n  clone(): Selector {\n    return new Selector(this.selector, {firstOnly: this.#firstOnly, exhaustAfter: this.exhaustAfter});\n  }\n}\n"]}
{"filename": "src/content/dom/constants.ts", "chunked_list": ["export const FIRST_CHILD_MARKER = '~~FIRST_CHILD~~';\nexport const LAST_CHILD_MARKER = '~~LAST_CHILD~~';\n\nexport const POST_ITEM_LINK_INJECTED_MARKER = 'bluesky-overhaul-youtube-injected';\n"]}
{"filename": "src/content/dom/utils.ts", "chunked_list": ["import {Selector} from './selector';\nimport {SelectorGroup} from './selectorGroup';\n\nexport type TSelectorLike = Selector | SelectorGroup;\ntype TSelectorOrArray = TSelectorLike | TSelectorLike[];\n\nconst findInElements = (selector: TSelectorLike, elements: HTMLElement[]): Promise<HTMLElement[]> => {\n  return new Promise((resolve, reject) => {\n    const firstAttemptResult = selector.retrieveFrom(elements);\n    if (firstAttemptResult.length > 0) {\n      resolve(firstAttemptResult);\n    } else {\n      const observer = new MutationObserver(() => {\n        const foundElements = selector.retrieveFrom(elements);", "    if (firstAttemptResult.length > 0) {\n      resolve(firstAttemptResult);\n    } else {\n      const observer = new MutationObserver(() => {\n        const foundElements = selector.retrieveFrom(elements);\n        if (foundElements.length > 0) {\n          observer.disconnect();\n          resolve(foundElements);\n        }\n      });\n", "      for (const element of elements) {\n        observer.observe(element, {childList: true, subtree: true});\n      }\n\n      setTimeout(() => {\n        observer.disconnect();\n        reject();\n      }, selector.exhaustAfter);\n    }\n  });\n};\n\nexport const ultimatelyFindAll = (rootElement: HTMLElement, selectors: TSelectorOrArray): Promise<HTMLElement[]> => {", "  if (!(selectors instanceof Array)) selectors = [selectors];\n\n  return selectors.reduce(async (previousPromise, selector): Promise<HTMLElement[]> => {\n    const foundElements = await previousPromise;\n    return findInElements(selector, foundElements);\n  }, Promise.resolve([rootElement]));\n};\n\nexport const ultimatelyFind = (rootElement: HTMLElement, selectors: TSelectorOrArray): Promise<HTMLElement> => {\n  return ultimatelyFindAll(rootElement, selectors).then((foundElements) => foundElements?.[0] ?? null);\n};\n"]}
{"filename": "src/content/dom/selectorGroup.ts", "chunked_list": ["import {Selector} from './selector';\n\nexport class SelectorGroup {\n  readonly #selectors: Selector[];\n  readonly exhaustAfter: number;\n\n  constructor(selectors: Selector[]) {\n    // TODO : add .merge() method to SelectorGroup (probably a static one)\n    // TODO : add .extend() method to SelectorGroup (probably a static one)\n\n    if (selectors.some((selector) => selector.exhaustAfter !== selectors[0].exhaustAfter)) {\n      throw new Error('All selectors in a group must have the same exhaustAfter value');\n    }\n\n    this.#selectors = selectors;\n    this.exhaustAfter = selectors[0].exhaustAfter;\n  }\n\n  retrieveFrom(elements: HTMLElement[]): HTMLElement[] {\n    const result = this.#selectors.map((selector) => selector.retrieveFrom(elements));\n    return result.flat();\n  }\n\n  clone(): SelectorGroup {\n    return new SelectorGroup(this.#selectors.map((selector) => selector.clone()));\n  }\n}\n", "    if (selectors.some((selector) => selector.exhaustAfter !== selectors[0].exhaustAfter)) {\n      throw new Error('All selectors in a group must have the same exhaustAfter value');\n    }\n\n    this.#selectors = selectors;\n    this.exhaustAfter = selectors[0].exhaustAfter;\n  }\n\n  retrieveFrom(elements: HTMLElement[]): HTMLElement[] {\n    const result = this.#selectors.map((selector) => selector.retrieveFrom(elements));\n    return result.flat();\n  }\n\n  clone(): SelectorGroup {\n    return new SelectorGroup(this.#selectors.map((selector) => selector.clone()));\n  }\n}\n"]}
{"filename": "src/content/browser/settingsManager.ts", "chunked_list": ["import {TSetting, TSettings} from '../../types';\nimport {ISettingsSubscriber} from '../../interfaces';\nimport {APP_SETTINGS} from '../../shared/appSettings';\nimport {subscribeToSettings} from '../../shared/browserApi';\nimport {SettingsProvider} from '../../shared/settingsProvider';\nimport {success} from '../utils/notifications';\n\nexport type TListener = (settingName: APP_SETTINGS, value: TSetting) => void;\n\nclass SettingsManager extends SettingsProvider {\n  readonly #listeners: { [key in APP_SETTINGS]?: TListener[] } = {};\n\n  async initialize(): Promise<void> {\n    await super.initialize();\n    subscribeToSettings(this.#onSettingsChange.bind(this));\n  }\n\n  subscribe(subscriber: ISettingsSubscriber): void {", "class SettingsManager extends SettingsProvider {\n  readonly #listeners: { [key in APP_SETTINGS]?: TListener[] } = {};\n\n  async initialize(): Promise<void> {\n    await super.initialize();\n    subscribeToSettings(this.#onSettingsChange.bind(this));\n  }\n\n  subscribe(subscriber: ISettingsSubscriber): void {\n    if (!this.isInitialized) throw new Error('SettingsManager is not initialized');\n    subscriber.SETTINGS.forEach((settingName: APP_SETTINGS) => {", "    if (!this.isInitialized) throw new Error('SettingsManager is not initialized');\n    subscriber.SETTINGS.forEach((settingName: APP_SETTINGS) => {\n      if (!this.#listeners[settingName]) {\n        this.#listeners[settingName] = [];\n      }\n\n      const callback = subscriber.onSettingChange.bind(subscriber);\n      this.#listeners[settingName]?.push(callback);\n      if (settingName in this.settings) {\n        callback(settingName, this.settings[settingName] as TSetting);\n      }\n    });\n  }\n\n  #onSettingsChange(newSettings: TSettings): void {\n    this.settings = {...this.settings, ...newSettings};", "      if (settingName in this.settings) {\n        callback(settingName, this.settings[settingName] as TSetting);\n      }\n    });\n  }\n\n  #onSettingsChange(newSettings: TSettings): void {\n    this.settings = {...this.settings, ...newSettings};\n    for (const [key, value] of Object.entries(newSettings)) {\n      if (key in this.#listeners) {\n        const settingName = key as APP_SETTINGS;\n        const listeners = this.#listeners[settingName] as TListener[];\n        listeners.forEach((listener) => listener(settingName, value));\n      }\n    }\n\n    success('Settings updated');\n  }\n}\n\nconst settingsManager = new SettingsManager();\n\nexport const getSettingsManager = async (): Promise<SettingsManager> => {\n  await settingsManager.initialize();\n  return settingsManager;\n};\n", "    for (const [key, value] of Object.entries(newSettings)) {\n      if (key in this.#listeners) {\n        const settingName = key as APP_SETTINGS;\n        const listeners = this.#listeners[settingName] as TListener[];\n        listeners.forEach((listener) => listener(settingName, value));\n      }\n    }\n\n    success('Settings updated');\n  }\n}\n\nconst settingsManager = new SettingsManager();\n\nexport const getSettingsManager = async (): Promise<SettingsManager> => {\n  await settingsManager.initialize();\n  return settingsManager;\n};\n"]}
{"filename": "src/content/watchers/postDatetime.ts", "chunked_list": ["import { createPopper } from '@popperjs/core';\n\nimport {TSetting, TSettings} from '../../types';\nimport {APP_SETTINGS} from '../../shared/appSettings';\nimport {ISettingsSubscriber} from '../../interfaces';\nimport {Watcher} from './watcher';\nimport {getSettingsManager} from '../browser/settingsManager';\nimport {getAgent, fetchPost, LoginError} from '../bsky/api';\nimport {alert} from '../utils/notifications';\n", "import {alert} from '../utils/notifications';\n\nconst DEFAULT_SETTINGS: Partial<TSettings> = {\n  [APP_SETTINGS.SHOW_POST_DATETIME]: false,\n  [APP_SETTINGS.BSKY_IDENTIFIER]: '',\n  [APP_SETTINGS.BSKY_PASSWORD]: ''\n};\n\ntype PostUrl = {\n  username: string;\n  postId: string;\n};\n\nconst POST_HREF_REGEX = /profile\\/(.+)\\/post\\/([a-zA-Z0-9]+)$/;\nconst DATETIME_MARKER = 'data-bluesky-overhaul-datetime';\n\nconst getCredentials = async (): Promise<[string, string]> => {\n  const settingsManager = await getSettingsManager();\n  return await Promise.all([\n    settingsManager.get(APP_SETTINGS.BSKY_IDENTIFIER) as string,\n    settingsManager.get(APP_SETTINGS.BSKY_PASSWORD) as string\n  ]);\n};\n\nconst parsePostUrl = (url: string | null): PostUrl => {", "type PostUrl = {\n  username: string;\n  postId: string;\n};\n\nconst POST_HREF_REGEX = /profile\\/(.+)\\/post\\/([a-zA-Z0-9]+)$/;\nconst DATETIME_MARKER = 'data-bluesky-overhaul-datetime';\n\nconst getCredentials = async (): Promise<[string, string]> => {\n  const settingsManager = await getSettingsManager();\n  return await Promise.all([\n    settingsManager.get(APP_SETTINGS.BSKY_IDENTIFIER) as string,\n    settingsManager.get(APP_SETTINGS.BSKY_PASSWORD) as string\n  ]);\n};\n\nconst parsePostUrl = (url: string | null): PostUrl => {", "  if (!url) throw new Error('Missing post URL');\n  const match = url.match(POST_HREF_REGEX);\n  if (!match) throw new Error('Invalid post URL');\n  return {username: match[1], postId: match[2]};\n};\n\nconst parsePostDatetime = (datetime: string): string => {\n  const date = new Date(datetime);\n  return date.toLocaleString('en-US', {\n    month: 'long', day: 'numeric', year: 'numeric', hour: 'numeric', minute: 'numeric'\n  });\n};\n\nconst createDatetimeTooltip = (datetime: string): HTMLElement => {\n  const tooltip = document.createElement('div');\n  tooltip.role = 'tooltip';\n  tooltip.className = 'bluesky-overhaul-tooltip';\n  tooltip.textContent = datetime;\n  return tooltip;\n};\n", "export class PostDatetimeWatcher extends Watcher implements ISettingsSubscriber {\n  #container: HTMLElement;\n  #enabled: boolean;\n\n  constructor(container: HTMLElement) {\n    super();\n    this.#container = container;\n    this.#enabled = DEFAULT_SETTINGS[APP_SETTINGS.SHOW_POST_DATETIME] as boolean;\n  }\n\n  watch(): void {\n    this.#container.addEventListener('mouseover', this.#handleMouseOver.bind(this));\n  }\n\n  onSettingChange(name: APP_SETTINGS, value: TSetting): void {", "    if (!this.SETTINGS.includes(name)) throw new Error(`Unknown setting name \"${name}\"`);\n    if (typeof value !== typeof DEFAULT_SETTINGS[name]) throw new Error(`Invalid value \"${value}\" for \"${name}\"`);\n\n    if (name === APP_SETTINGS.SHOW_POST_DATETIME) {\n      this.#enabled = value as boolean;\n    }\n  }\n\n  get SETTINGS(): APP_SETTINGS[] {\n    return Object.keys(DEFAULT_SETTINGS) as APP_SETTINGS[];\n  }\n\n  async #handleMouseOver(event: MouseEvent): Promise<void> {", "    if (!this.#enabled) return;\n\n    const target = event.target as HTMLElement;\n    if (target.tagName.toLowerCase() !== 'a') return;\n\n    let datetime = target.getAttribute(DATETIME_MARKER);\n    if (!datetime) {\n      try {\n        const {username, postId} = parsePostUrl(target.getAttribute('href'));\n        if (username && postId) {\n          const [identifier, password] = await getCredentials();\n", "        if (username && postId) {\n          const [identifier, password] = await getCredentials();\n\n          try {\n            const agent = await getAgent(identifier, password);\n            const post = await fetchPost(agent, username, postId);\n\n            datetime = parsePostDatetime(post.indexedAt);\n            target.setAttribute(DATETIME_MARKER, datetime);\n          } catch (error) {\n            if (error instanceof LoginError) alert('Login failed: wrong identifier or password');\n            return;\n          }\n        } else {\n          return;\n        }\n      } catch {\n        return;\n      }\n    }\n\n    const tooltip = createDatetimeTooltip(datetime);\n    document.body.appendChild(tooltip);\n    const instance = createPopper(target, tooltip, {\n      placement: 'top'\n    });\n\n    target.addEventListener('mouseleave', () => {\n      instance.destroy();\n      tooltip.remove();\n    }, {once: true});\n  }\n}\n", "          } catch (error) {\n            if (error instanceof LoginError) alert('Login failed: wrong identifier or password');\n            return;\n          }\n        } else {\n          return;\n        }\n      } catch {\n        return;\n      }\n    }\n\n    const tooltip = createDatetimeTooltip(datetime);\n    document.body.appendChild(tooltip);\n    const instance = createPopper(target, tooltip, {\n      placement: 'top'\n    });\n\n    target.addEventListener('mouseleave', () => {\n      instance.destroy();\n      tooltip.remove();\n    }, {once: true});\n  }\n}\n"]}
{"filename": "src/content/watchers/youtube.ts", "chunked_list": ["import {Watcher} from './watcher';\nimport {CallThrottler} from '../utils/callThrottler';\nimport {POST_ITEM_LINK_INJECTED_MARKER} from '../dom/constants';\nimport {POST_ITEMS, POST_ITEM_LINKS} from '../dom/selectors';\nimport {ultimatelyFindAll} from '../dom/utils';\nimport {noop} from '../../shared/misc';\n\nconst THROTTLING_INTERVAL = 500;\nconst YOUTU_BE_REGEX = /youtu\\.be\\/([a-zA-Z0-9_-]+)/;\nconst YOUTUBE_WATCH_REGEX = /youtube\\.com\\/watch\\?v=([a-zA-Z0-9_-]+)/;", "const YOUTU_BE_REGEX = /youtu\\.be\\/([a-zA-Z0-9_-]+)/;\nconst YOUTUBE_WATCH_REGEX = /youtube\\.com\\/watch\\?v=([a-zA-Z0-9_-]+)/;\n\nconst resolveYoutubeId = (url: string): string | null => {\n  let match;\n  if (url.includes('youtu.be')) {\n    match = url.match(YOUTU_BE_REGEX);\n  } else if (url.includes('youtube.com/watch')) {\n    match = url.match(YOUTUBE_WATCH_REGEX);\n  }\n  return match?.[1] ?? null;\n};\n\nconst injectYoutubePlayers = (youtubeLinks: HTMLLinkElement[]): void => {\n  youtubeLinks.forEach((link) => {", "    if (link.getAttribute(POST_ITEM_LINK_INJECTED_MARKER)) return;\n\n    const videoId = resolveYoutubeId(link.href ?? '');\n    if (!videoId) return;\n\n    const iframe = document.createElement('iframe');\n    iframe.setAttribute('src', `https://www.youtube.com/embed/${videoId}`);\n    iframe.setAttribute('allow', 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture');\n    iframe.setAttribute('allowfullscreen', 'true');\n    iframe.style.width = '100%';\n    iframe.style.height = '400px';\n    iframe.style.border = 'none';\n    iframe.style.flexGrow = '1';\n    iframe.style.paddingTop = '10px';\n\n    link.parentNode?.parentNode?.appendChild(iframe);\n    link.setAttribute(POST_ITEM_LINK_INJECTED_MARKER, 'true');\n\n    const blueskyYoutubePreview = iframe.parentNode?.nextSibling as HTMLElement;", "    if (blueskyYoutubePreview?.getAttribute('tabindex') === '0') {\n      blueskyYoutubePreview.style.display = 'none';\n    }\n  });\n};\n\nconst createYoutubePlayers = (container: HTMLElement): void => {\n  ultimatelyFindAll(container, [POST_ITEMS, POST_ITEM_LINKS])\n    .then((links) => injectYoutubePlayers(links as HTMLLinkElement[]))\n    .catch(noop);\n};\n", "    .catch(noop);\n};\n\nexport class YoutubeWatcher extends Watcher {\n  readonly #container: HTMLElement;\n  readonly #throttler: CallThrottler = new CallThrottler(THROTTLING_INTERVAL);\n  readonly #observer: MutationObserver;\n\n  constructor(container: HTMLElement) {\n    super();\n    this.#container = container;\n    this.#observer = new MutationObserver(() => {\n      const currentLayout = this.#container.lastChild as HTMLElement;\n      this.#throttler.call(() => createYoutubePlayers(currentLayout));\n    });\n  }\n\n  watch(): void {\n    const initialLayout = this.#container.lastChild as HTMLElement;\n    this.#throttler.call(() => createYoutubePlayers(initialLayout));\n    this.#observer.observe(this.#container, {childList: true, subtree: true});\n  }\n}\n"]}
{"filename": "src/content/watchers/keydown.ts", "chunked_list": ["import {TSetting, TSettings} from '../../types';\nimport {IPausable, ISettingsSubscriber} from '../../interfaces';\nimport {APP_SETTINGS} from '../../shared/appSettings';\nimport {Watcher} from './watcher';\nimport {VimKeybindingsHandler} from './helpers/vimKeybindings';\nimport {ultimatelyFind} from '../dom/utils';\nimport {Selector} from '../dom/selector';\n\nconst DEFAULT_SETTINGS: Partial<TSettings> = {\n  [APP_SETTINGS.HANDLE_VIM_KEYBINDINGS]: false", "const DEFAULT_SETTINGS: Partial<TSettings> = {\n  [APP_SETTINGS.HANDLE_VIM_KEYBINDINGS]: false\n};\n\nconst LEFT_ARROW_BUTTON = new Selector('[aria-label=\"Previous image\"]', {exhaustAfter: 0});\nconst RIGHT_ARROW_BUTTON = new Selector('[aria-label=\"Next image\"]', {exhaustAfter: 0});\nconst PHOTO_KEYS = ['ArrowLeft', 'ArrowRight'];\n\nexport class KeydownWatcher extends Watcher implements IPausable, ISettingsSubscriber {\n  readonly #container: HTMLElement;\n  readonly #vimHandler: VimKeybindingsHandler;\n  #isPaused = false;\n\n  constructor(targetContainer: HTMLElement, vimContainer: HTMLElement) {\n    super();\n    this.#container = targetContainer;\n    this.#vimHandler = new VimKeybindingsHandler(vimContainer, true);\n  }\n\n  watch(): void {\n    document.addEventListener('keydown', this.#onKeydown.bind(this));\n  }\n\n  start(): void {", "export class KeydownWatcher extends Watcher implements IPausable, ISettingsSubscriber {\n  readonly #container: HTMLElement;\n  readonly #vimHandler: VimKeybindingsHandler;\n  #isPaused = false;\n\n  constructor(targetContainer: HTMLElement, vimContainer: HTMLElement) {\n    super();\n    this.#container = targetContainer;\n    this.#vimHandler = new VimKeybindingsHandler(vimContainer, true);\n  }\n\n  watch(): void {\n    document.addEventListener('keydown', this.#onKeydown.bind(this));\n  }\n\n  start(): void {", "    if (!this.#isPaused) return;\n    this.#vimHandler.start();\n    this.#isPaused = false;\n  }\n\n  pause(): void {\n    if (this.#isPaused) return;\n    this.#vimHandler.pause();\n    this.#isPaused = true;\n  }\n\n  onSettingChange(name: APP_SETTINGS, value: TSetting): void {", "    if (!this.SETTINGS.includes(name)) throw new Error(`Unknown setting name \"${name}\"`);\n    if (typeof value !== typeof DEFAULT_SETTINGS[name]) throw new Error(`Invalid value \"${value}\" for \"${name}\"`);\n\n    if (name === APP_SETTINGS.HANDLE_VIM_KEYBINDINGS) {\n      if (value === true) {\n        this.#vimHandler.start();\n      } else {\n        this.#vimHandler.pause();\n      }\n    }\n  }\n\n  get SETTINGS(): APP_SETTINGS[] {\n    return Object.keys(DEFAULT_SETTINGS) as APP_SETTINGS[];\n  }\n\n  #onKeydown(event: KeyboardEvent): void {", "    if (this.#isPaused || event.ctrlKey || event.metaKey) return;\n\n    if (PHOTO_KEYS.includes(event.key)) {\n      Promise.all([\n        ultimatelyFind(this.#container, LEFT_ARROW_BUTTON).catch(() => null),\n        ultimatelyFind(this.#container, RIGHT_ARROW_BUTTON).catch(() => null)\n      ]).then(([leftArrow, rightArrow]) => {\n        if (event.key === 'ArrowLeft' && leftArrow !== null) {\n          leftArrow.click();\n        } else if (event.key === 'ArrowRight' && rightArrow !== null) {\n          rightArrow.click();\n        }\n      });\n    } else {\n      this.#vimHandler.handle(event);\n    }\n  }\n}\n", "        } else if (event.key === 'ArrowRight' && rightArrow !== null) {\n          rightArrow.click();\n        }\n      });\n    } else {\n      this.#vimHandler.handle(event);\n    }\n  }\n}\n"]}
{"filename": "src/content/watchers/watcher.ts", "chunked_list": ["export abstract class Watcher {\n  abstract watch(): void;\n}\n"]}
{"filename": "src/content/watchers/countersConcealer.ts", "chunked_list": ["import {TSetting, TSettings} from '../../types';\nimport {APP_SETTINGS} from '../../shared/appSettings';\nimport {ISettingsSubscriber} from '../../interfaces';\nimport {Watcher} from './watcher';\n\nconst DEFAULT_SETTINGS: Partial<TSettings> = {\n  [APP_SETTINGS.HIDE_FOLLOWERS_COUNT]: false,\n  [APP_SETTINGS.HIDE_FOLLOWING_COUNT]: false,\n  [APP_SETTINGS.HIDE_POSTS_COUNT]: false\n};", "  [APP_SETTINGS.HIDE_POSTS_COUNT]: false\n};\n\nconst CONCEALER_CLASS = 'bluesky-overhaul-concealer';\nconst HIDE_FOLLOWERS_CLASS = 'bluesky-overhaul-hide-followers';\nconst HIDE_FOLLOWING_CLASS = 'bluesky-overhaul-hide-following';\nconst HIDE_POSTS_CLASS = 'bluesky-overhaul-hide-posts';\n\nexport class CountersConcealer extends Watcher implements ISettingsSubscriber {\n  #container: HTMLElement;\n\n  constructor(documentBody: HTMLElement) {\n    super();\n    this.#container = documentBody;\n  }\n\n  watch(): void {\n    this.#container.classList.add(CONCEALER_CLASS);\n  }\n\n  onSettingChange(name: APP_SETTINGS, value: TSetting): void {", "export class CountersConcealer extends Watcher implements ISettingsSubscriber {\n  #container: HTMLElement;\n\n  constructor(documentBody: HTMLElement) {\n    super();\n    this.#container = documentBody;\n  }\n\n  watch(): void {\n    this.#container.classList.add(CONCEALER_CLASS);\n  }\n\n  onSettingChange(name: APP_SETTINGS, value: TSetting): void {", "    if (!this.SETTINGS.includes(name)) throw new Error(`Unknown setting name \"${name}\"`);\n    if (typeof value !== typeof DEFAULT_SETTINGS[name]) throw new Error(`Invalid value \"${value}\" for \"${name}\"`);\n\n    if (name === APP_SETTINGS.HIDE_FOLLOWERS_COUNT) {\n      this.#toggleClass(value as boolean, HIDE_FOLLOWERS_CLASS);\n    } else if (name === APP_SETTINGS.HIDE_FOLLOWING_COUNT) {\n      this.#toggleClass(value as boolean, HIDE_FOLLOWING_CLASS);\n    } else if (name === APP_SETTINGS.HIDE_POSTS_COUNT) {\n      this.#toggleClass(value as boolean, HIDE_POSTS_CLASS);\n    }\n  }\n\n  get SETTINGS(): APP_SETTINGS[] {\n    return Object.keys(DEFAULT_SETTINGS) as APP_SETTINGS[];\n  }\n\n  #toggleClass(enable: boolean, className: string): void {", "    if (enable) {\n      this.#container.classList.add(className);\n    } else {\n      this.#container.classList.remove(className);\n    }\n  }\n}\n"]}
{"filename": "src/content/watchers/helpers/postList.ts", "chunked_list": ["import {IPausable} from '../../../interfaces';\nimport {TSelectorLike, ultimatelyFindAll} from '../../dom/utils';\nimport {LAST_CHILD, POST_ITEMS} from '../../dom/selectors';\nimport {Selector} from '../../dom/selector';\nimport {EventKeeper} from '../../utils/eventKeeper';\n\nconst LAG = 100;\n\nconst FOLLOWING_DATA = 'homeScreenFeedTabs-Following';\nconst WHATSHOT_DATA = 'homeScreenFeedTabs-What\\'s hot';", "const FOLLOWING_DATA = 'homeScreenFeedTabs-Following';\nconst WHATSHOT_DATA = 'homeScreenFeedTabs-What\\'s hot';\n\nconst TAB_BUTTONS = new Selector('[data-testid=\"homeScreenFeedTabs\"]', {exhaustAfter: LAG});\nconst FOLLOWING_FEED = new Selector('[data-testid=\"followingFeedPage\"]');\nconst WHATSHOT_FEED = new Selector('[data-testid=\"whatshotFeedPage\"]');\n\nconst getNextPost = (post: HTMLElement): HTMLElement | null => {\n  if (post.nextSibling) {\n    return post.nextSibling as HTMLElement;\n  } else {\n    const parent = post.parentElement;", "  if (post.nextSibling) {\n    return post.nextSibling as HTMLElement;\n  } else {\n    const parent = post.parentElement;\n    if (parent && parent.nextSibling) {\n      return parent.nextSibling.firstChild as HTMLElement;\n    } else {\n      return null;\n    }\n  }\n};\n\nconst getPreviousPost = (post: HTMLElement): HTMLElement | null => {", "  if (post.previousSibling) {\n    return post.previousSibling as HTMLElement;\n  } else {\n    const parent = post.parentElement;\n    if (parent && parent.previousSibling) {\n      return parent.previousSibling.lastChild as HTMLElement;\n    } else {\n      return null;\n    }\n  }\n};\n\nconst isPostThreadDelimiter = (postCandidate: HTMLElement): boolean => {\n  return postCandidate.getAttribute('role') === 'link' && postCandidate.getAttribute('tabindex') === '0';\n};\n", "export class PostList implements IPausable {\n  readonly #container: HTMLElement;\n  readonly #mutationObserver: MutationObserver;\n  readonly #tabButtonEventKeeper = new EventKeeper();\n  #activeTabSelector: Selector = FOLLOWING_FEED;\n  #currentPost: HTMLElement | null = null;\n  #isPaused: boolean;\n\n  constructor(targetContainer: HTMLElement, startPaused = true) {\n    this.#container = targetContainer;\n    this.#mutationObserver = new MutationObserver(this.#onContainerMutation.bind(this));\n    this.#isPaused = startPaused;", "    if (!startPaused) this.start();\n  }\n\n  start(): void {\n    this.#isPaused = false;\n  }\n\n  pause(): void {\n    this.#isPaused = true;\n  }\n\n  getCurrentFeedTab(): Promise<Selector> {\n    return this.#isMainPage().then((isMainPage) => {", "      if (isMainPage) {\n        return this.#activeTabSelector.clone();\n      } else {\n        return Promise.reject('Not on main page');\n      }\n    });\n  }\n\n  setCurrentPost(element: HTMLElement): Promise<HTMLElement> {\n    return this.#resolveList().then((posts) => {\n      for (const post of posts) {", "      for (const post of posts) {\n        if (post === element || post.parentElement === element || post.contains(element)) {\n          this.#currentPost = post;\n          return this.#currentPost;\n        }\n      }\n\n      return Promise.reject('Element is not a post');\n    });\n  }\n\n  getNextPost(): Promise<HTMLElement> {\n    return this.#getNeighborPost(getNextPost);\n  }\n\n  getPreviousPost(): Promise<HTMLElement> {\n    return this.#getNeighborPost(getPreviousPost);\n  }\n\n  #getNeighborPost(retrieveFn: (post: HTMLElement) => HTMLElement | null): Promise<HTMLElement> {", "    if (this.#isPaused) return Promise.reject('PostList is paused');\n\n    return this.#resolveList().then((posts) => {\n      if (posts.length === 0) {\n        return Promise.reject('No posts found');\n      } else if (this.#currentPost) {\n        const neighborPost = retrieveFn(this.#currentPost);\n        if (neighborPost && (posts.includes(neighborPost) || isPostThreadDelimiter(neighborPost))) {\n          this.#currentPost = neighborPost;\n        } else if (!posts.includes(this.#currentPost)) {\n          this.#currentPost = posts[0];\n        }\n      } else {\n        this.#currentPost = posts[0];\n      }\n\n      return this.#currentPost;\n    });\n  }\n\n  #isMainPage(): Promise<boolean> {\n    return this.#findElements([TAB_BUTTONS]).then((tabButtonsList) => {", "        } else if (!posts.includes(this.#currentPost)) {\n          this.#currentPost = posts[0];\n        }\n      } else {\n        this.#currentPost = posts[0];\n      }\n\n      return this.#currentPost;\n    });\n  }\n\n  #isMainPage(): Promise<boolean> {\n    return this.#findElements([TAB_BUTTONS]).then((tabButtonsList) => {", "      if (tabButtonsList.length !== 1) throw new Error('There should be exactly one tab button container');\n      this.#subscribeToTabButtons(tabButtonsList[0]);\n      return true;\n    }).catch(() => false);\n  }\n\n  #resolveList(): Promise<HTMLElement[]> {\n    return this.#isMainPage().then((isMainPage) => {\n      const prefixingSelectors = isMainPage ? [this.#activeTabSelector] : [];\n      return this.#findElements([...prefixingSelectors, POST_ITEMS]).then((posts) => {\n        if (posts.length === 0) {\n          return Promise.reject('No posts found');\n        } else {\n          return posts;\n        }\n      });\n    });\n  }\n\n  #subscribeToTabButtons(tabButtons: HTMLElement): void {\n    this.#tabButtonEventKeeper.cancelAll();\n    this.#tabButtonEventKeeper.add(tabButtons, 'click', this.#onTabButtonClick.bind(this));\n  }\n\n  #onContainerMutation(mutations: MutationRecord[]): void {\n    mutations.forEach((mutation) => {", "        if (posts.length === 0) {\n          return Promise.reject('No posts found');\n        } else {\n          return posts;\n        }\n      });\n    });\n  }\n\n  #subscribeToTabButtons(tabButtons: HTMLElement): void {\n    this.#tabButtonEventKeeper.cancelAll();\n    this.#tabButtonEventKeeper.add(tabButtons, 'click', this.#onTabButtonClick.bind(this));\n  }\n\n  #onContainerMutation(mutations: MutationRecord[]): void {\n    mutations.forEach((mutation) => {", "      if (mutation.target === this.#container) {\n        this.#currentPost = null;\n      }\n    });\n  }\n\n  #onTabButtonClick(event: MouseEvent): void {\n    const target = event.target as HTMLElement;\n    const data = target.getAttribute('data-testid');\n    if (data === FOLLOWING_DATA || target.querySelector(`[data-testid=\"${FOLLOWING_DATA}\"]`)) {\n      if (this.#activeTabSelector !== FOLLOWING_FEED) this.#currentPost = null;\n      this.#activeTabSelector = FOLLOWING_FEED;", "    if (data === FOLLOWING_DATA || target.querySelector(`[data-testid=\"${FOLLOWING_DATA}\"]`)) {\n      if (this.#activeTabSelector !== FOLLOWING_FEED) this.#currentPost = null;\n      this.#activeTabSelector = FOLLOWING_FEED;\n    } else if (data === WHATSHOT_DATA || target.querySelector(`[data-testid=\"${WHATSHOT_DATA}\"]`)) {\n      if (this.#activeTabSelector !== WHATSHOT_FEED) this.#currentPost = null;\n      this.#activeTabSelector = WHATSHOT_FEED;\n    }\n  }\n\n  #findElements(selectors: TSelectorLike[]): Promise<HTMLElement[]> {\n    return ultimatelyFindAll(this.#container, [LAST_CHILD, ...selectors]);\n  }\n}\n"]}
{"filename": "src/content/watchers/helpers/vimActions.ts", "chunked_list": ["export enum VIM_ACTIONS {\n  EXPAND_IMAGE = 'expand_image',\n  LIKE = 'like',\n  LOAD_NEW_POSTS = 'load_new_posts',\n  CREATE_POST = 'create_post',\n  NEXT_POST = 'next_post',\n  OPEN_POST = 'open_post',\n  PREVIOUS_POST = 'previous_post',\n  REPLY = 'reply',\n  REPOST = 'repost',\n  SEARCH = 'search',\n  SHOW_HELP = 'show_help'\n}\n\nexport const VIM_KEY_MAP = {\n  '?': VIM_ACTIONS.SHOW_HELP,\n  '/': VIM_ACTIONS.SEARCH,\n  '.': VIM_ACTIONS.LOAD_NEW_POSTS,\n  'j': VIM_ACTIONS.NEXT_POST,\n  'k': VIM_ACTIONS.PREVIOUS_POST,\n  'l': VIM_ACTIONS.LIKE,\n  'n': VIM_ACTIONS.CREATE_POST,\n  'o': VIM_ACTIONS.EXPAND_IMAGE,\n  'r': VIM_ACTIONS.REPLY,\n  't': VIM_ACTIONS.REPOST,\n  'ArrowDown': VIM_ACTIONS.NEXT_POST,\n  'ArrowUp': VIM_ACTIONS.PREVIOUS_POST,\n  'Enter': VIM_ACTIONS.OPEN_POST\n};\n\nconst toNormalText = (name: string): string => {\n  name = name.replace(/_/g, ' ');\n  return name.charAt(0).toUpperCase() + name.slice(1);\n};\n\nexport const generateHelpMessage = (): string => {\n  const actions: { [key: string]: string[] } = {};", "  for (const [key, action] of Object.entries(VIM_KEY_MAP)) {\n    if (!(action in actions)) actions[action] = [];\n    actions[action].push(`<span class=\"mono\">${key}</span>`);\n  }\n\n  const helpMessage = [];\n  for (const [action, buttons] of Object.entries(actions)) {\n    helpMessage.push(`<b>${toNormalText(action)}</b>: ${buttons.join('&nbsp;')}`);\n  }\n\n  return `\n    <div class=\"bluesky-overhaul-help\">\n      <h3>Bluesky Overhaul Vim Keybindings</h3>\n      <p>${helpMessage.join('<br/>')}</p>\n      <p>You can also Alt+Click to focus any specific post</p>\n    </div>\n  `;\n};\n"]}
{"filename": "src/content/watchers/helpers/vimKeybindings.ts", "chunked_list": ["import {IPausable} from '../../../interfaces';\nimport {ROOT_CONTAINER, SEARCH_BAR} from '../../dom/selectors';\nimport {EventKeeper} from '../../utils/eventKeeper';\nimport {noop} from '../../../shared/misc';\nimport {modal, tip} from '../../utils/notifications';\nimport {PostList} from './postList';\nimport {generateHelpMessage, VIM_ACTIONS, VIM_KEY_MAP} from './vimActions';\nimport {ultimatelyFind} from '../../dom/utils';\n\nenum DIRECTION { NEXT, PREVIOUS }\n\nconst FOCUSED_POST_CLASS = 'bluesky-overhaul-focused-post';\nconst MISSING_POST_ERROR = 'No post is focused';\n\nconst REPLY_BUTTON_SELECTOR = '[data-testid=\"replyBtn\"]';\nconst REPOST_BUTTON_SELECTOR = '[data-testid=\"repostBtn\"]';\nconst LIKE_BUTTON_SELECTOR = '[data-testid=\"likeBtn\"]';\n", "\nenum DIRECTION { NEXT, PREVIOUS }\n\nconst FOCUSED_POST_CLASS = 'bluesky-overhaul-focused-post';\nconst MISSING_POST_ERROR = 'No post is focused';\n\nconst REPLY_BUTTON_SELECTOR = '[data-testid=\"replyBtn\"]';\nconst REPOST_BUTTON_SELECTOR = '[data-testid=\"repostBtn\"]';\nconst LIKE_BUTTON_SELECTOR = '[data-testid=\"likeBtn\"]';\n\nexport class VimKeybindingsHandler implements IPausable {\n  readonly #container: HTMLElement;\n  readonly #postList: PostList;\n  readonly #postClickEventKeeper = new EventKeeper();\n  readonly #searchBarEventKeeper = new EventKeeper();\n  #currentPost: HTMLElement | null = null;\n  #stashedPost: HTMLElement | null = null;\n  #isPaused: boolean;\n\n  constructor(targetContainer: HTMLElement, startPaused = true) {\n    this.#container = targetContainer;\n    this.#postList = new PostList(targetContainer, startPaused);\n    this.#isPaused = startPaused;\n  }\n\n  start(): void {", "export class VimKeybindingsHandler implements IPausable {\n  readonly #container: HTMLElement;\n  readonly #postList: PostList;\n  readonly #postClickEventKeeper = new EventKeeper();\n  readonly #searchBarEventKeeper = new EventKeeper();\n  #currentPost: HTMLElement | null = null;\n  #stashedPost: HTMLElement | null = null;\n  #isPaused: boolean;\n\n  constructor(targetContainer: HTMLElement, startPaused = true) {\n    this.#container = targetContainer;\n    this.#postList = new PostList(targetContainer, startPaused);\n    this.#isPaused = startPaused;\n  }\n\n  start(): void {", "    if (!this.#isPaused) return;\n    this.#postList.start();\n    this.#postClickEventKeeper.add(this.#container, 'click', this.#onPostAltClick.bind(this));\n    this.#blurSearchBar();\n    this.#isPaused = false;\n  }\n\n  pause(): void {\n    if (this.#isPaused) return;\n    this.#postList.pause();\n    this.#postClickEventKeeper.cancelAll();\n    this.#searchBarEventKeeper.cancelAll();\n    this.#removeHighlight();\n    this.#isPaused = true;\n  }\n\n  handle(event: KeyboardEvent): void {", "    if (this.#isPaused) return;\n    this.#postList.pause();\n    this.#postClickEventKeeper.cancelAll();\n    this.#searchBarEventKeeper.cancelAll();\n    this.#removeHighlight();\n    this.#isPaused = true;\n  }\n\n  handle(event: KeyboardEvent): void {\n    if (this.#isPaused) return;\n    event.preventDefault();\n\n    const key = event.key;", "    if (this.#isPaused) return;\n    event.preventDefault();\n\n    const key = event.key;\n    if (!(key in VIM_KEY_MAP)) return;\n\n    const action = VIM_KEY_MAP[key as keyof typeof VIM_KEY_MAP];\n    switch (action) {\n    case VIM_ACTIONS.SHOW_HELP:\n      modal(generateHelpMessage());\n      break;\n    case VIM_ACTIONS.SEARCH:\n      this.#focusSearchBar();\n      break;\n    case VIM_ACTIONS.LOAD_NEW_POSTS:\n      this.#loadNewPosts();\n      break;\n    case VIM_ACTIONS.NEXT_POST:\n      this.#selectPost(DIRECTION.NEXT);\n      break;\n    case VIM_ACTIONS.PREVIOUS_POST:\n      this.#selectPost(DIRECTION.PREVIOUS);\n      break;\n    case VIM_ACTIONS.LIKE:\n      this.#likePost();\n      break;\n    case VIM_ACTIONS.CREATE_POST:\n      this.#newPost();\n      break;\n    case VIM_ACTIONS.EXPAND_IMAGE:\n      this.#expandImage();\n      break;\n    case VIM_ACTIONS.REPLY:\n      this.#replyToPost();\n      break;\n    case VIM_ACTIONS.REPOST:\n      this.#repostPost();\n      break;\n    case VIM_ACTIONS.OPEN_POST:\n      this.#currentPost?.click();\n      break;\n    default:\n      tip(`Action \"${action}\" is not implemented yet`);\n    }\n  }\n\n  #selectPost(direction: DIRECTION): void {", "    if (direction === DIRECTION.NEXT) {\n      this.#postList.getNextPost().then((p) => this.#highlightPost(p));\n    } else {\n      this.#postList.getPreviousPost().then((p) => this.#highlightPost(p));\n    }\n  }\n\n  #replyToPost(): void {\n    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n    const reply = this.#currentPost.querySelector(REPLY_BUTTON_SELECTOR) as HTMLElement;\n    reply?.click();\n  }\n\n  #repostPost(): void {", "    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n    const reply = this.#currentPost.querySelector(REPLY_BUTTON_SELECTOR) as HTMLElement;\n    reply?.click();\n  }\n\n  #repostPost(): void {\n    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n    const repost = this.#currentPost.querySelector(REPOST_BUTTON_SELECTOR) as HTMLElement;\n    repost?.click();\n  }\n\n  #likePost(): void {", "    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n    const like = this.#currentPost.querySelector(LIKE_BUTTON_SELECTOR) as HTMLElement;\n    like?.click();\n  }\n\n  #expandImage(): void {\n    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n    const imageContainer = this.#currentPost.querySelector('div.expo-image-container') as HTMLElement;\n    imageContainer?.click();\n  }\n\n  #onPostAltClick(event: MouseEvent): void {", "    if (this.#isPaused || !event.altKey) return;\n    event.preventDefault();\n\n    this.#postList.setCurrentPost(event.target as HTMLElement).then((p) => this.#highlightPost(p)).catch(noop);\n  }\n\n  #highlightPost(post: HTMLElement): void {\n    if (post === this.#currentPost) return;\n    this.#removeHighlight();\n\n    this.#stashedPost = null;\n    this.#currentPost = post;\n    this.#currentPost.classList.add(FOCUSED_POST_CLASS);\n    this.#currentPost.scrollIntoView({block: 'center', behavior: 'smooth'});\n  }\n\n  #removeHighlight(): void {\n    this.#stashedPost = this.#currentPost;\n    this.#currentPost?.classList.remove(FOCUSED_POST_CLASS);\n    this.#currentPost = null;\n  }\n\n  #focusSearchBar(): void {\n    this.#removeHighlight();\n    this.#findSearchBar().then((searchBar) => {\n      this.#searchBarEventKeeper.cancelAll();\n      searchBar.focus();\n      this.#searchBarEventKeeper.add(searchBar, 'blur', this.#blurSearchBar.bind(this));\n      this.#searchBarEventKeeper.add(searchBar, 'keydown', (event: KeyboardEvent) => {", "        if (event.key === 'Escape') searchBar.blur();\n      });\n    }).catch(() => tip('Search bar not found'));\n  }\n\n  #blurSearchBar(): void {\n    this.#searchBarEventKeeper.cancelAll();\n    this.#findSearchBar().then((searchBar) => {\n      searchBar.blur();\n      this.#stashedPost && this.#highlightPost(this.#stashedPost);\n      this.#searchBarEventKeeper.add(searchBar, 'focus', this.#focusSearchBar.bind(this));\n    });\n  }\n\n  #findSearchBar(): Promise<HTMLElement> {\n    return ultimatelyFind(document.body, SEARCH_BAR);\n  }\n\n  async #loadNewPosts(): Promise<void> {", "    try {\n      const tab = await this.#postList.getCurrentFeedTab();\n      const tabContainer = await ultimatelyFind(this.#container, tab);\n      const newPostsButton = tabContainer.childNodes[1] as HTMLElement;\n\n      if (newPostsButton && newPostsButton.nextSibling) {\n        newPostsButton.click();\n        this.#container.scrollIntoView({block: 'start', behavior: 'smooth'});\n      } else {\n        tip('No new posts to load');\n      }\n    } catch {\n      tip('You are not on the feed page');\n    }\n  }\n\n  async #newPost(): Promise<void> {\n    const rootContainer = await ultimatelyFind(document.body, ROOT_CONTAINER);\n    const children = rootContainer.childNodes;\n    const menuItems = children[1].childNodes;\n    const newPostButton = menuItems[menuItems.length - 1] as HTMLElement;\n", "    if (newPostButton) {\n      newPostButton.click();\n    } else {\n      tip('No new post button found');\n    }\n  }\n}\n"]}
{"filename": "src/content/hacks/emojiDataWrapper.ts", "chunked_list": ["import * as data from '@emoji-mart/data';\n\n// This is done to make `data.categories` amenable to being rewritten by the emoji-mart library\nexport const emojiData = { ...data };\n"]}
