{"filename": "cli/src/nftCollection.ts", "chunked_list": ["import { Sender, toNano } from 'ton-core'\nimport {NftCollection, NftCollectionData} from '../../src/wrappers/getgems/NftCollection/NftCollection'\nimport importKeyPair from './utils/importKeyPair';\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\nimport { error } from 'console';\nimport { env } from 'process';\nimport { Address } from 'ton-core'\nimport { TonClient4 } from 'ton';\nimport createSender from './utils/createSender'\n\nexport async function createNftCollection(\n    client: TonClient4,\n    config: NftCollectionData,\n    options?: {\n        secretKey?: string\n    }\n) {\n    let keypair = await importKeyPair(options?.secretKey);\n    \n    let sender = await createSender(keypair, client)\n    \n\n    const nftCollection = client.open(\n        await NftCollection.createFromConfig(\n            config\n        )\n    );\n\n    await nftCollection.sendDeploy(sender, toNano('0.05'));\n\n    console.log(\n        `NFT Single deployed at ${nftCollection.address}`\n    )\n\n    await writeFileSync(\n        './NftCollection.json',\n        JSON.stringify({\n            config: config,\n            address: nftCollection.address,\n            init: nftCollection.init\n        }\n    ))\n    \n    console.log(\n        `Saved Config`\n    )\n\n    return nftCollection;\n}\n", "import createSender from './utils/createSender'\n\nexport async function createNftCollection(\n    client: TonClient4,\n    config: NftCollectionData,\n    options?: {\n        secretKey?: string\n    }\n) {\n    let keypair = await importKeyPair(options?.secretKey);\n    \n    let sender = await createSender(keypair, client)\n    \n\n    const nftCollection = client.open(\n        await NftCollection.createFromConfig(\n            config\n        )\n    );\n\n    await nftCollection.sendDeploy(sender, toNano('0.05'));\n\n    console.log(\n        `NFT Single deployed at ${nftCollection.address}`\n    )\n\n    await writeFileSync(\n        './NftCollection.json',\n        JSON.stringify({\n            config: config,\n            address: nftCollection.address,\n            init: nftCollection.init\n        }\n    ))\n    \n    console.log(\n        `Saved Config`\n    )\n\n    return nftCollection;\n}\n", "export async function importExistingNftCollection(\n    client: TonClient4,\n    options?: {\n        configPath?: string,\n        address?: Address\n    }\n) {\n    if (options?.configPath) {\n        const config = JSON.parse(\n            readFileSync(\n                options?.configPath,\n                'utf-8'\n            )\n        )\n\n        const nftCollection = client.open(\n            await NftCollection.createFromAddress(\n                config.address\n            )\n        );\n\n        return nftCollection", "    } else if (existsSync(String(env.PATH_TO_CONFIG))) {\n        const config = JSON.parse(readFileSync(String(env.PATH_TO_CONFIG), 'utf-8'));\n\n        const nftCollection = client.open(\n            await NftCollection.createFromAddress(\n                config.address\n            )\n        );\n\n        return nftCollection;\n    } else {\n        const nftCollection = client.open(\n            await NftCollection.createFromAddress(\n                options?.address ?? Address.parse(String(env.NFT_COLLECTION_ADDRESS))\n            )\n        );\n\n        return nftCollection;\n    }\n}\n\n", "export async function mint(\n    client: TonClient4,\n    itemOwner: Address,\n    collectionAddress: Address,\n    itemContent: string,\n    options?: {\n        configPath?: string,\n        secretKey?: string\n    }\n) {\n    const nftCollection = await importExistingNftCollection(\n        client,\n        {\n            configPath: options?.configPath,\n            address: collectionAddress\n        }\n    );\n\n    let keypair = await importKeyPair(\n        options?.secretKey\n    )\n\n    let sender = await createSender(keypair, client);\n\n    let collectionData = await nftCollection.getCollectionData();\n\n    let tx = await nftCollection.sendMint(\n        sender,\n        {\n            value: toNano(\"0.05\"),\n            passAmount: toNano(\"0\"),\n            itemIndex: Number(collectionData.nextItemIndex),\n            itemOwnerAddress: itemOwner,\n            itemContent: itemContent\n        }\n    );\n\n    console.log(\n        `Minted NFT to ${itemOwner.toString()}`\n    )\n}"]}
{"filename": "cli/src/nftSingle.ts", "chunked_list": ["import { Sender, toNano } from 'ton-core'\nimport {NftSingle, NftSingleData} from '../../src/wrappers/getgems/NftSingle/NftSingle'\nimport importKeyPair from './utils/importKeyPair';\nimport { readFileSync, writeFileSync } from 'fs';\nimport { error } from 'console';\nimport { env } from 'process';\nimport { Address } from 'ton-core'\nimport { TonClient4 } from 'ton';\nimport createSender from './utils/createSender'\n\nexport async function createNftSingle(\n    client: TonClient4,\n    config: NftSingleData,\n    options?: {\n        secretKey?: string\n    }\n) {\n    let keypair = await importKeyPair(options?.secretKey);\n    \n    let sender = await createSender(keypair, client)\n    \n\n    const nftSingle = client.open(\n        await NftSingle.createFromConfig(\n            config\n        )\n    );\n\n    await nftSingle.sendDeploy(sender, toNano('0.05'));\n\n    console.log(\n        `NFT Single deployed at ${nftSingle.address}`\n    )\n\n    await writeFileSync(\n        './nftSingle.json',\n        JSON.stringify({\n            config: config,\n            address: nftSingle.address,\n            init: nftSingle.init\n        }\n    ))\n    \n    console.log(\n        `Saved Config`\n    )\n\n    return nftSingle;\n}\n", "import createSender from './utils/createSender'\n\nexport async function createNftSingle(\n    client: TonClient4,\n    config: NftSingleData,\n    options?: {\n        secretKey?: string\n    }\n) {\n    let keypair = await importKeyPair(options?.secretKey);\n    \n    let sender = await createSender(keypair, client)\n    \n\n    const nftSingle = client.open(\n        await NftSingle.createFromConfig(\n            config\n        )\n    );\n\n    await nftSingle.sendDeploy(sender, toNano('0.05'));\n\n    console.log(\n        `NFT Single deployed at ${nftSingle.address}`\n    )\n\n    await writeFileSync(\n        './nftSingle.json',\n        JSON.stringify({\n            config: config,\n            address: nftSingle.address,\n            init: nftSingle.init\n        }\n    ))\n    \n    console.log(\n        `Saved Config`\n    )\n\n    return nftSingle;\n}\n", "export async function importExistingNftSingle(\n    client: TonClient4,\n    options?: {\n        configPath?: string\n    }\n) {\n    if (options?.configPath) {\n        const config = JSON.parse(\n            readFileSync(\n                options?.configPath,\n                'utf-8'\n            )\n        )\n\n        const nftSingle = client.open(\n            await NftSingle.createFromAddress(\n                config.address\n            )\n        );\n\n        return nftSingle\n    } else {\n        const config = JSON.parse(readFileSync(String(env.PATH_TO_CONFIG), 'utf-8'));\n\n        const nftSingle = client.open(\n            await NftSingle.createFromAddress(\n                config.address\n            )\n        );\n\n        return nftSingle;\n    }\n}\n", "export async function transfer(\n    client: TonClient4,\n    destination: string,\n    options?: {\n        configPath?: string,\n        secretKey?: string\n    }\n) {\n    const nftSingle = await importExistingNftSingle(\n        client,\n        options\n    );\n\n    let keypair = await importKeyPair(\n        options?.secretKey\n    )\n\n    let sender = await createSender(keypair, client);\n\n    let tx = await nftSingle.sendTransfer(\n        sender,\n        {\n            value: toNano('0.05'),\n            queryId: toNano('0'),\n            newOwner: Address.parse(destination),\n            responseDestination: sender.address,\n            forwardAmount: toNano('0')\n        }\n    );\n\n    console.log(\n        `Transferred NFT from ${sender.address?.toString()} to ${destination}`\n    )\n}"]}
{"filename": "cli/src/index.ts", "chunked_list": ["#!/usr/bin/env node\n\nimport yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers';\nimport {Pinata} from \"../../src/storage/Pinata\"\nimport {AmazonS3} from \"../../src/storage/AmazonS3\"\nimport {TonNftClient} from '../../src/ton-api'\nimport {TonAPI} from '../../src/ton-api/TonAPI'\nimport { Address } from 'ton-core'\nimport {createNftSingle, transfer} from \"./nftSingle\"", "import { Address } from 'ton-core'\nimport {createNftSingle, transfer} from \"./nftSingle\"\nimport {createNftCollection} from \"./nftCollection\"\nimport { TonClient4 } from 'ton';\nimport createKeyPair from './utils/createKeyPair';\n\nyargs(hideBin(process.argv))\n  .command(\n    'upload pinata [path]',\n    'Upload an NFT via Pinata',", "    'upload pinata [path]',\n    'Upload an NFT via Pinata',\n    (yargs) => {\n      return yargs\n        .positional('path', {\n          describe: 'Path to the file to be uploaded',\n          type: 'string',\n          default: './assets',\n        })\n        .option('apiKey', {", "        })\n        .option('apiKey', {\n          alias: 'k',\n          describe: 'API key for authentication',\n          type: 'string',\n          demandOption: true,\n        })\n        .option('secretApiKey', {\n          alias: 's',\n          describe: 'Secret API key for authentication',", "          alias: 's',\n          describe: 'Secret API key for authentication',\n          type: 'string',\n          demandOption: true,\n        });\n    },\n    async (argv) => {\n      if (typeof argv.path === 'string' \n          && typeof argv.apiKey === 'string' \n          && typeof argv.secretApiKey == 'string'\n      ) {\n        console.log(`Using API key: ${argv.apiKey}`);\n        console.log(`Using secret API key: ${argv.secretApiKey}`);\n\n        let pinata = new Pinata(argv.apiKey, argv.secretApiKey);\n        let imagesUrls = await pinata.uploadBulk(argv.path)\n\n        console.log(`URLs: ${imagesUrls}`)\n      }\n    }\n  )\n\n  .command(\n    'upload s3 [path]',\n    'Upload an NFT via Amazon S3',\n    (yargs) => {\n      return yargs\n        .positional('path', {\n          describe: 'Path to the file to be uploaded',\n          type: 'string',\n          default: './assets',\n        })\n        .option('accessKey', {\n          alias: 'k',\n          describe: 'Access key for authentication',\n          type: 'string',\n          demandOption: true,\n        })\n        .option('secretAccessKey', {\n          alias: 's',\n          describe: 'Secret access key for authentication',\n          type: 'string',\n          demandOption: true,\n        })\n        .option('bucketName', {\n          alias: 'b',\n          describe: 'Bucket Name',\n          type:'string',\n          demandOption: true,\n        })\n        .option('fileType', {\n          alias: 'f',", "          describe: 'File type of the image',\n          type: 'string',\n          demandOption: true,\n          default: \"image/jpeg\"\n        });\n    },\n    async (argv) => {\n      if (typeof argv.path === 'string' \n          && typeof argv.apiKey === 'string' \n          && typeof argv.secretApiKey == 'string'\n      ) {\n        console.log(`Using API key: ${argv.apiKey}`);\n        console.log(`Using secret API key: ${argv.secretApiKey}`);\n        console.log(`Using bucket name: ${argv.bucketName}`);\n\n        let s3 = new AmazonS3(argv.apiKey, argv.secretApiKey, argv.bucketName);\n        let imagesUrls = await s3.uploadBulk(argv.path)\n\n        console.log(`URLs: ${imagesUrls}`)\n      }\n    }\n  )\n\n  // New command for getNftCollections\n  .command(\n    'collections [limit] [offset]',\n    'Get NFT collections',\n    (yargs) => {\n      return yargs\n        .positional('limit', {\n          describe: 'Maximum number of collections to return',\n          type: 'number',\n          default: 10,\n        })\n        .positional('offset', {\n          describe: 'Number of collections to skip',\n          type: 'number',\n          default: 0,\n        });\n    },\n    async (argv) => {\n      const tonClient = new TonNftClient(new TonAPI());\n      const collections = await tonClient.getNftCollections(argv.limit, argv.offset);\n      console.log(collections);\n    }\n  )\n  // New command for getNftCollectionByAddress\n  .command(\n    'collection <address>',\n    'Get NFT collection by address',\n    (yargs) => {\n      return yargs.positional('address', {\n        describe: 'Collection address',\n        type: 'string',\n      });\n    },\n    async (argv) => {", "      if (typeof argv.address === 'string') {\n        const tonClient = new TonNftClient(new TonAPI());\n        const collection = await tonClient.getNftCollection(argv.address);\n        console.log(collection);\n      }\n    }\n  )\n  // New command for getNftItemsFromCollectionByAddress\n  .command(\n    'collection-items <address> [limit] [offset]',\n    'Get NFT items from collection by address',\n    (yargs) => {\n      return yargs\n        .positional('address', {\n          describe: 'Collection address',\n          type: 'string',\n        })\n        .positional('limit', {\n          describe: 'Maximum number of items to return',\n          type: 'number',\n          default: 10,\n        })\n        .positional('offset', {\n          describe: 'Number of items to skip',\n          type: 'number',\n          default: 0,\n        });\n    },\n    async (argv) => {", "      if (typeof argv.address === 'string') {\n        const tonClient = new TonNftClient(new TonAPI());\n        const items = await tonClient.getNftItems(argv.address, argv.limit, argv.offset);\n        console.log(items);\n      }\n    }\n  )\n\n  // New command for getNftItemByAddress\n  .command(\n    'item <address>',\n    'Get NFT item by its address',\n    (yargs) => {\n      return yargs.positional('address', {\n        describe: 'Item address',\n        type: 'string',\n      });\n    },\n    async (argv) => {", "      if (typeof argv.address === 'string') {\n        const tonClient = new TonNftClient(new TonAPI());\n        const item = await tonClient.getNftItem(argv.address);\n        console.log(item);\n      }\n    }\n  )\n\n  .command(\n    'keypair create',\n    'Creates Keypair',\n    (yargs) => {\n      \n    },\n    async (argv) => {\n      await createKeyPair();\n  })\n\n  .command(\n    'nft-single create <configPath> [secretKey]',\n    'Create a single NFT',\n    (yargs) => {\n      return yargs\n        .positional('configPath', {\n          describe: 'Path to the NFT single data config JSON file',\n          type: 'string',\n        })\n        .positional('secretKey', {\n          describe: 'Secret key for creating the NFT',\n          type: 'string',\n          default: undefined,\n        });\n    },\n    async (argv) => {", "      if (typeof argv.configPath === 'string') {\n        const client = new TonClient4({\n          endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n        });\n        const config = require(argv.configPath);\n        const options = { secretKey: argv.secretKey };\n        await createNftSingle(client, config, options);\n      }\n    }\n  )\n\n  .command(\n    'nft-single transfer <destination> [configPath] [secretKey]',\n    'Transfer an NFT Single',\n    (yargs) => {\n      return yargs\n        .positional('destination', {\n          describe: 'Destination address',\n          type: 'string',\n        })\n        .positional('configPath', {\n          describe: 'Path to the transfer configuration JSON file',\n          type: 'string',\n          default: undefined,\n        })\n        .positional('secretKey', {\n          describe: 'Secret key of the Sender',\n          type: 'string',\n          default: undefined,\n        });\n    },\n    async (argv) => {", "      if (typeof argv.destination === 'string') {\n        const client = new TonClient4({\n          endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n        });\n\n        const options = { configPath: argv.configPath, secretKey: argv.secretKey };\n        await transfer(client, argv.destination, options);\n      }\n    }\n  )\n\n  .command(\n    'nft-collection create <configPath> [secretKey]',\n    'Create a NFT Collection',\n    (yargs) => {\n      return yargs\n       .positional('configPath', {\n          describe: 'Path to the NFT collection data config JSON file',\n          type:'string',\n        })\n       .positional('secretKey', {\n          describe: 'Secret key for creating the NFT',\n          type:'string',\n          default: undefined,\n        });\n        },\n    async (argv) => {", "      if (typeof argv.configPath ==='string') {\n        const client = new TonClient4({\n          endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n        });\n        const config = require(argv.configPath);\n        const options = { secretKey: argv.secretKey };\n        await createNftCollection(client, config, options);\n      }\n    }\n  )\n\n  \n  .demandCommand(1, 'You need at least one command before moving on')\n  .help()\n  .alias('h', 'help')\n  .strict()\n  .parse();\n"]}
{"filename": "cli/src/utils/createSender.ts", "chunked_list": ["import { KeyPair } from \"ton-crypto\";\nimport { TonClient4, WalletContractV4 } from \"ton\";\n\nexport async function createSender(\n    keypair: KeyPair,\n    client: TonClient4\n) {\n    let wallet = WalletContractV4.create(\n        {\n            workchain: 0,\n            publicKey: keypair.publicKey\n        }\n    )\n    \n    let contract = client.open(\n        wallet\n    );\n\n    return contract.sender(keypair.secretKey);\n}\n\nexport default createSender;"]}
{"filename": "cli/src/utils/importKeyPair.ts", "chunked_list": ["import { env } from 'process'\nimport { KeyPair, keyPairFromSecretKey } from \"ton-crypto\"\nimport { readFileSync } from 'fs';\n\nexport async function importKeyPair(\n    secretKey?: string\n) {\n    let keyPair: KeyPair;\n\n    if (secretKey) {\n        keyPair = keyPairFromSecretKey(Buffer.from(secretKey, 'hex'));\n    } else {\n        const content = readFileSync(String(env.SECRET_KEY), 'utf-8');\n        keyPair = keyPairFromSecretKey(Buffer.from(content, 'hex'));\n    }\n\n    return keyPair;\n}\n\nexport default importKeyPair;", "    if (secretKey) {\n        keyPair = keyPairFromSecretKey(Buffer.from(secretKey, 'hex'));\n    } else {\n        const content = readFileSync(String(env.SECRET_KEY), 'utf-8');\n        keyPair = keyPairFromSecretKey(Buffer.from(content, 'hex'));\n    }\n\n    return keyPair;\n}\n\nexport default importKeyPair;"]}
{"filename": "cli/src/utils/createKeyPair.ts", "chunked_list": ["import { writeFileSync } from \"fs\";\nimport {mnemonicNew, mnemonicToPrivateKey} from \"ton-crypto\"\n\nexport async function createKeyPair() {\n    let mnemonic = await mnemonicNew()\n    let keypair = await mnemonicToPrivateKey(mnemonic)\n\n    writeFileSync(\n        \"./keypair.json\",\n        JSON.stringify(keypair)\n    );\n\n    writeFileSync(\n        \"./.env\",\n        `SECRET_KEY=${keypair.secretKey.toString()}`\n    )\n}\n\nexport default createKeyPair;"]}
{"filename": "examples/TonAPI.ts", "chunked_list": ["import {TonNftClient} from '../src/ton-api'\nimport {TonAPI} from '../src/ton-api/TonAPI'\n\nasync function main() {\n    const tonApi = new TonAPI()\n    const tonClient = new TonNftClient(\n        tonApi\n    )\n\n    // Telegram Number Collection\n    const collection = await tonClient.getNftCollection('EQAOQdwdw8kGftJCSFgOErM1mBjYPe4DBPq8-AhF6vr9si5N')\n\n    // Prints the Collection Data\n    console.log(collection)\n\n    // NFT Collections\n    const collections = await tonClient.getNftCollections(\n        10,\n        10\n    )\n\n    // Prints the Collection Data\n    console.log(collections)\n\n    // Get NFT items from collection by collection address\n    const items = await tonClient.getNftItems('EQAOQdwdw8kGftJCSFgOErM1mBjYPe4DBPq8-AhF6vr9si5N',10,10)\n\n    // Prints the Collection Data\n    console.log(items)\n\n    // Get NFT item by its address\n    const item = await tonClient.getNftItem('EQBn9d_1SaXIqogjb884eIDlbA3_4lgVv1rl8GyTpQpp_1Oi')\n\n    // Prints the Collection Data\n    console.log(item)\n}\n\nmain()\n"]}
{"filename": "examples/deployNftCollection.ts", "chunked_list": ["import {toNano} from 'ton-core'\nimport {NftCollection} from '../src/wrappers/getgems/NftCollection/NftCollection'\nimport {NftItem} from '../src/wrappers/getgems/NftItem/NftItem'\nimport {randomAddress, importKeyPair, createSender} from '../src/utils'\nimport {ENDPOINT} from '../src'\nimport { TonClient4 } from 'ton'\nimport { Storage } from '../src/storage'\nimport { Pinata } from '../src/storage/Pinata'\n\nasync function main() {\n    // Config\n    const keypair = await importKeyPair('')\n    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n    const wallet = await createSender(keypair, client)\n    const address = wallet.address ?? randomAddress()\n\n    // Addresses\n    const ownerAddress = address\n\n    // Deploying Assets\n    const pinata = new Pinata('<apiKey>', '<secretApiKey>')\n    const storage = new Storage(pinata)\n\n    // String [0] - Images\n    // String [1] - Json\n    const data: [string[], string[]] = await storage.uploadBulk('./assets')\n\n    // Creates NFT Collection\n    const nftCollection = client.open(\n        await NftCollection.createFromConfig({\n            ownerAddress: ownerAddress,\n            nextItemIndex: 1,\n            collectionContent: data[1][0],\n            commonContent: '',\n            nftItemCode: NftItem.code,\n            royaltyParams: {\n                royaltyFactor: 10,\n                royaltyBase: 100,\n                royaltyAddress: ownerAddress\n            }\n        })\n    )\n\n    // Deploys Nft Collection\n    const deployResult = await nftCollection.sendDeploy(wallet, toNano('0.05'))\n\n    // Prints Result\n    console.log(deployResult)\n\n    // Fetches Nft Collection Data\n    const collectionData = await nftCollection.getCollectionData()\n\n    // Prints Nft Collection Data\n    console.log(collectionData)    \n}\n\nmain()", "\nasync function main() {\n    // Config\n    const keypair = await importKeyPair('')\n    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n    const wallet = await createSender(keypair, client)\n    const address = wallet.address ?? randomAddress()\n\n    // Addresses\n    const ownerAddress = address\n\n    // Deploying Assets\n    const pinata = new Pinata('<apiKey>', '<secretApiKey>')\n    const storage = new Storage(pinata)\n\n    // String [0] - Images\n    // String [1] - Json\n    const data: [string[], string[]] = await storage.uploadBulk('./assets')\n\n    // Creates NFT Collection\n    const nftCollection = client.open(\n        await NftCollection.createFromConfig({\n            ownerAddress: ownerAddress,\n            nextItemIndex: 1,\n            collectionContent: data[1][0],\n            commonContent: '',\n            nftItemCode: NftItem.code,\n            royaltyParams: {\n                royaltyFactor: 10,\n                royaltyBase: 100,\n                royaltyAddress: ownerAddress\n            }\n        })\n    )\n\n    // Deploys Nft Collection\n    const deployResult = await nftCollection.sendDeploy(wallet, toNano('0.05'))\n\n    // Prints Result\n    console.log(deployResult)\n\n    // Fetches Nft Collection Data\n    const collectionData = await nftCollection.getCollectionData()\n\n    // Prints Nft Collection Data\n    console.log(collectionData)    \n}\n\nmain()"]}
{"filename": "examples/transferNft.ts", "chunked_list": ["import {toNano} from 'ton-core'\nimport {NftItem} from '../src/wrappers/getgems/NftItem/NftItem'\nimport {randomAddress, importKeyPair, createSender} from '../src/utils'\nimport {ENDPOINT} from '../src'\nimport { TonClient4 } from 'ton'\n\nasync function main() {\n    // Config\n    const keypair = await importKeyPair('')\n    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n    const wallet = await createSender(keypair, client)\n    const address = wallet.address ?? randomAddress()\n\n    // Addresses\n    const ownerAddress = address\n    const newOwner = randomAddress()\n    const nft = randomAddress()\n\n    // Creates NFT Item Instance\n    const nftItem = client.open(\n        await NftItem.createFromAddress(\n            nft\n        )\n    )\n\n    // Transfers Nft\n    const result = await nftItem.sendTransfer(\n        wallet,\n        {\n            value: toNano(1),\n            queryId: BigInt(1),\n            newOwner: newOwner,\n            responseDestination: ownerAddress,\n            forwardAmount: toNano(0)\n        }\n    )\n\n    // Prints Result\n    console.log(result)\n\n    // Fetches Nft Data\n    const nftData = await nftItem.getNftData()\n\n    // Prints Nft Data\n    console.log(nftData)    \n}\n\nmain()"]}
{"filename": "examples/transaction-parsing.ts", "chunked_list": ["import {Address} from 'ton-core'\nimport {NftItem} from '../src/wrappers/standard/NftItem'\nimport { TonClient } from 'ton'\nimport { getHttpEndpoint } from '@orbs-network/ton-access'\n\nasync function main() {\n    // Config\n    const client = new TonClient({\n        endpoint: await getHttpEndpoint()\n    })\n\n    // Transfer TX\n    const txData = await client.getTransactions(Address.parse('EQCWbV3k8hlLGiFlxPE_RAJDLUpm_WnCCbCxaprvWxh1_AOI'), {\n        limit: 10,\n        hash: 'odtysMOr5JY0JQ+31TtmzGzldPBH2IMTIL21CAiJ9G8='\n    })\n\n    console.log(txData)\n\n    const data = NftItem.parseTransfer(txData[0])\n\n    // Prints Transaction Data\n    console.log(data)\n}\n\nmain()"]}
{"filename": "examples/mintNft.ts", "chunked_list": ["import {Address, toNano} from 'ton-core'\nimport {NftCollection} from '../src/wrappers/getgems/NftCollection/NftCollection'\nimport {randomAddress, importKeyPair, createSender} from '../src/utils'\nimport {ENDPOINT} from '../src'\nimport { TonClient4 } from 'ton'\nimport { Storage } from '../src/storage'\nimport { Pinata } from '../src/storage/Pinata'\n\nasync function main() {\n    // Config\n    const keypair = await importKeyPair('')\n    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n    const wallet = await createSender(keypair, client)\n    const address = wallet.address ?? randomAddress()\n\n    // Addresses\n    const ownerAddress = address\n    const collectionAddress = Address.parse('')\n\n    // Deploying Assets\n    const pinata = new Pinata('<apiKey>', '<secretApiKey>')\n    const storage = new Storage(pinata)\n    const data: [string[], string[]] = await storage.uploadBulk('./assets')\n\n    // Creates NFT Item\n    const nftCollection = client.open(\n        await NftCollection.createFromAddress(\n            collectionAddress\n        )\n    )\n\n    // Mints NFT\n    const mintResult = await nftCollection.sendMint(\n        wallet,\n        {\n            queryId: 1,\n            value: toNano(1),\n            passAmount: toNano(1),\n            itemIndex: 0,\n            itemOwnerAddress: ownerAddress,\n            itemContent: data[1][0]\n        }\n    )\n\n    // Prints Result\n    console.log(mintResult)\n\n    // Fetches Nft Data\n    const collectionData = await nftCollection.getCollectionData()\n\n    // Prints Nft Data\n    console.log(collectionData)    \n}\n\nmain()", "async function main() {\n    // Config\n    const keypair = await importKeyPair('')\n    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n    const wallet = await createSender(keypair, client)\n    const address = wallet.address ?? randomAddress()\n\n    // Addresses\n    const ownerAddress = address\n    const collectionAddress = Address.parse('')\n\n    // Deploying Assets\n    const pinata = new Pinata('<apiKey>', '<secretApiKey>')\n    const storage = new Storage(pinata)\n    const data: [string[], string[]] = await storage.uploadBulk('./assets')\n\n    // Creates NFT Item\n    const nftCollection = client.open(\n        await NftCollection.createFromAddress(\n            collectionAddress\n        )\n    )\n\n    // Mints NFT\n    const mintResult = await nftCollection.sendMint(\n        wallet,\n        {\n            queryId: 1,\n            value: toNano(1),\n            passAmount: toNano(1),\n            itemIndex: 0,\n            itemOwnerAddress: ownerAddress,\n            itemContent: data[1][0]\n        }\n    )\n\n    // Prints Result\n    console.log(mintResult)\n\n    // Fetches Nft Data\n    const collectionData = await nftCollection.getCollectionData()\n\n    // Prints Nft Data\n    console.log(collectionData)    \n}\n\nmain()"]}
{"filename": "src/index.ts", "chunked_list": ["// Storage\nimport {AmazonS3} from './storage/AmazonS3'\nimport {Pinata} from './storage/Pinata'\n\n// Wrappers\nexport * from './wrappers/getgems/NftCollection/NftCollection'\nexport * from './wrappers/getgems/NftItem/NftItem'\nexport * from './wrappers/getgems/SbtSingle/SbtSingle'\nexport * from './wrappers/standard/NftItemRoyalty'\nexport * from './wrappers/getgems/NftAuction/NftAuction'", "export * from './wrappers/standard/NftItemRoyalty'\nexport * from './wrappers/getgems/NftAuction/NftAuction'\nexport * from './wrappers/getgems/NftAuctionV2/NftAuctionV2'\nexport * from './wrappers/getgems/NftFixedPrice/NftFixedPrice'\nexport * from './wrappers/getgems/NftFixedPriceV2/NftFixedPriceV2'\nexport * from './wrappers/getgems/NftFixedPriceV3/NftFixedPriceV3'\nexport * from './wrappers/getgems/NftMarketplace/NftMarketplace'\nexport * from './wrappers/getgems/NftOffer/NftOffer'\nexport * from './wrappers/getgems/NftSwap/NftSwap'\n", "export * from './wrappers/getgems/NftSwap/NftSwap'\n\n// Utils\nexport * from './utils'\n\n// Data Encoders & Decoders\nexport * from './types/Content'\n\n// Transaction Parsing\nexport * as TransactionParsing from './transaction-parsing/'", "// Transaction Parsing\nexport * as TransactionParsing from './transaction-parsing/'\n\nexport {\n    AmazonS3, \n    Pinata\n}\n\nexport {Storage} from './storage'\n", "export {Storage} from './storage'\n\n// TON API\nexport * from './ton-api'\n\n// Endpoints\nexport enum ENDPOINT {\n    MAINNET = 'https://toncenter.com/api/v2/jsonRPC',\n    TESTNET = 'https://testnet.toncenter.com/api/v2/jsonRPC'\n}"]}
{"filename": "src/utils/createTempFile.ts", "chunked_list": ["import {uuid} from './uuid'\nimport * as os from 'os'\nimport path from 'path'\nimport {writeFile, unlink} from 'fs/promises'\n\nexport async function createTempFile(ext: string) {\n    const name = uuid()\n    const fullPath = path.resolve(os.tmpdir(), name + ext)\n    await writeFile(fullPath, Buffer.alloc(0))\n    return {\n        name: fullPath,\n        destroy: async  () => {\n            await unlink(fullPath)\n        }\n    }\n}\n"]}
{"filename": "src/utils/EligibleInternalTx.ts", "chunked_list": ["import { Transaction } from 'ton-core'\n\nexport function isEligibleTransaction(tx: Transaction): boolean {\n    return (\n        tx.inMessage?.info.type == 'internal' &&\n        tx.description.type == 'generic' &&\n        tx.description.computePhase.type == 'vm' &&\n        tx.description.computePhase.exitCode == 0\n    )\n}"]}
{"filename": "src/utils/createSender.ts", "chunked_list": ["import { KeyPair } from \"ton-crypto\";\nimport { TonClient4, WalletContractV4 } from \"ton\";\n\nexport async function createSender(\n    keypair: KeyPair,\n    client: TonClient4\n) {\n    let wallet = WalletContractV4.create(\n        {\n            workchain: 0,\n            publicKey: keypair.publicKey\n        }\n    )\n    \n    let contract = client.open(\n        wallet\n    );\n\n    return contract.sender(keypair.secretKey);\n}\n\nexport default createSender;"]}
{"filename": "src/utils/randomKeyPair.ts", "chunked_list": ["import {mnemonicNew, mnemonicToPrivateKey} from \"ton-crypto\";\n\nexport async function randomKeyPair() {\n    let mnemonics = await mnemonicNew()\n    return mnemonicToPrivateKey(mnemonics)\n}"]}
{"filename": "src/utils/importKeyPair.ts", "chunked_list": ["import { env } from 'process'\nimport { KeyPair, keyPairFromSecretKey } from \"ton-crypto\"\nimport { readFileSync } from 'fs';\n\nexport async function importKeyPair(\n    secretKey?: string\n) {\n    let keyPair: KeyPair;\n\n    if (secretKey) {\n        keyPair = keyPairFromSecretKey(Buffer.from(secretKey, 'hex'));\n    } else {\n        const content = readFileSync(String(env.SECRET_KEY), 'utf-8');\n        keyPair = keyPairFromSecretKey(Buffer.from(content, 'hex'));\n    }\n\n    return keyPair;\n}\n\nexport default importKeyPair;", "    if (secretKey) {\n        keyPair = keyPairFromSecretKey(Buffer.from(secretKey, 'hex'));\n    } else {\n        const content = readFileSync(String(env.SECRET_KEY), 'utf-8');\n        keyPair = keyPairFromSecretKey(Buffer.from(content, 'hex'));\n    }\n\n    return keyPair;\n}\n\nexport default importKeyPair;"]}
{"filename": "src/utils/uuid.ts", "chunked_list": ["import {v4} from 'uuid'\n\nexport const uuid = () => v4()"]}
{"filename": "src/utils/createKeyPair.ts", "chunked_list": ["import { writeFileSync } from \"fs\";\nimport {mnemonicNew, mnemonicToPrivateKey} from \"ton-crypto\"\n\nexport async function createKeyPair() {\n    let mnemonic = await mnemonicNew()\n    let keypair = await mnemonicToPrivateKey(mnemonic)\n\n    writeFileSync(\n        \"./keypair.json\",\n        JSON.stringify(keypair)\n    );\n\n    writeFileSync(\n        \"./.env\",\n        `SECRET_KEY=${keypair.secretKey}`\n    )\n}\n\nexport default createKeyPair;"]}
{"filename": "src/utils/randomAddress.ts", "chunked_list": ["import {Address} from \"ton-core\";\nimport {pseudoRandomBytes} from \"crypto\";\n\nexport function randomAddress() {\n    return new Address(0, pseudoRandomBytes(256/8))\n}"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export * from './EligibleInternalTx'\nexport * from './createTempFile'\nexport * from './randomAddress'\nexport * from './randomKeyPair'\nexport * from './uuid'\nexport * from './importKeyPair'\nexport * from './createSender'"]}
{"filename": "src/storage/index.ts", "chunked_list": ["export class Storage {\n    constructor(\n        readonly provider: ProviderInterface\n    ) {}\n\n    // Function to upload images\n    async uploadImage(\n        imagePath: string\n    ): Promise<string> {\n        return await this.provider.uploadImage(imagePath)\n    }\n\n    // Function to upload multiple images\n    async uploadImages(\n        folderPath: string\n    ): Promise<string[]> {\n        return await this.provider.uploadImages(folderPath)\n    }\n\n    // Function to upload json file\n    async uploadJson(\n        jsonPath: string\n    ): Promise<string> {\n        return await this.provider.uploadJson(jsonPath)\n    }\n\n    // Function to upload multiple json files\n    async uploadJsonBulk(\n        folderPath: string\n    ): Promise<string[]> {\n        return await this.provider.uploadJsonBulk(folderPath)\n    }\n\n    // Function to upload multiple json files\n    async uploadBulk(\n        assetsFolderPath: string\n    ): Promise<[string[], string[]]> {\n        return await this.provider.uploadBulk(assetsFolderPath)\n    }\n}\n", "export interface ProviderInterface {\n    uploadImage: (imagePath: string) => Promise<string>\n    uploadImages: (folderPath: string) => Promise<string[]>\n    uploadJson: (jsonPath: string) => Promise<string>\n    uploadJsonBulk: (folderPath: string) => Promise<string[]>\n    uploadBulk: (assetsFolderPath: string) => Promise<[string[], string[]]>\n}"]}
{"filename": "src/storage/Pinata.ts", "chunked_list": ["import PinataClient from '@pinata/sdk'\nimport { error } from 'console'\nimport fs from 'fs'\nimport path from 'path'\nimport { ProviderInterface } from '.'\n\n/**\n * Pinata is a class that provides utility functions for interacting with Pinata for IPFS integration.\n */\nexport class Pinata implements ProviderInterface {\n    private pinata: PinataClient\n\n    /**\n     * Creates an instance of the Pinata class.\n     * @param apiKey - The API key for Pinata.\n     * @param secretApiKey - The secret API key for Pinata.\n     */\n    constructor (\n        apiKey: string,\n        secretApiKey: string,\n    ) {\n        this.pinata = new PinataClient(apiKey, secretApiKey)\n    }\n\n    /**\n     * Uploads an image file to IPFS using Pinata SDK.\n     * @param imagePath - The path to the image file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded image on IPFS.\n     */\n    async uploadImage(imagePath: string): Promise<string> {\n        const fileContent = fs.createReadStream(imagePath)\n        const response = await this.pinata.pinFileToIPFS(fileContent)\n        return `https://gateway.pinata.cloud/ipfs/${response.IpfsHash}`\n    }\n    \n    /**\n     * Uploads multiple image files from a folder to IPFS using Pinata SDK.\n     * @param folderPath - The path to the folder containing the image files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded images on IPFS.\n     */\n    async uploadImages(folderPath: string): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadImage(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n    \n    /**\n     * Uploads a JSON file to IPFS using Pinata SDK.\n     * @param jsonPath - The path to the JSON file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded JSON file on IPFS.\n     */\n    async uploadJson(jsonPath: string): Promise<string> {\n        const fileContent = fs.readFileSync(jsonPath)\n        const jsonData = JSON.parse(fileContent.toString())\n        const response = await this.pinata.pinJSONToIPFS(jsonData)\n        return `https://gateway.pinata.cloud/ipfs/${response.IpfsHash}`\n    }\n    \n    /**\n     * Uploads multiple JSON files from a folder to IPFS using Pinata SDK.\n     * @param folderPath - The path to the folder containing the JSON files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded JSON files on IPFS.\n     */\n    async uploadJsonBulk(folderPath: string): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadJson(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n\n    /**\n     * Uploads images in bulk to IPFS using Pinata SDK in ascending order of file names and returns their URLs.\n     * @param assetsFolderPath - The path to the folder containing the image and JSON files.\n     * @returns A Promise that resolves to an array of two arrays:\n     * - The first array contains the URLs of the uploaded images on IPFS.\n     * - The second array contains the URLs of the uploaded JSON files on IPFS.\n     */\n    async uploadBulk(\n        assetsFolderPath: string\n    ): Promise<[string[], string[]]> {", "export class Pinata implements ProviderInterface {\n    private pinata: PinataClient\n\n    /**\n     * Creates an instance of the Pinata class.\n     * @param apiKey - The API key for Pinata.\n     * @param secretApiKey - The secret API key for Pinata.\n     */\n    constructor (\n        apiKey: string,\n        secretApiKey: string,\n    ) {\n        this.pinata = new PinataClient(apiKey, secretApiKey)\n    }\n\n    /**\n     * Uploads an image file to IPFS using Pinata SDK.\n     * @param imagePath - The path to the image file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded image on IPFS.\n     */\n    async uploadImage(imagePath: string): Promise<string> {\n        const fileContent = fs.createReadStream(imagePath)\n        const response = await this.pinata.pinFileToIPFS(fileContent)\n        return `https://gateway.pinata.cloud/ipfs/${response.IpfsHash}`\n    }\n    \n    /**\n     * Uploads multiple image files from a folder to IPFS using Pinata SDK.\n     * @param folderPath - The path to the folder containing the image files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded images on IPFS.\n     */\n    async uploadImages(folderPath: string): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadImage(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n    \n    /**\n     * Uploads a JSON file to IPFS using Pinata SDK.\n     * @param jsonPath - The path to the JSON file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded JSON file on IPFS.\n     */\n    async uploadJson(jsonPath: string): Promise<string> {\n        const fileContent = fs.readFileSync(jsonPath)\n        const jsonData = JSON.parse(fileContent.toString())\n        const response = await this.pinata.pinJSONToIPFS(jsonData)\n        return `https://gateway.pinata.cloud/ipfs/${response.IpfsHash}`\n    }\n    \n    /**\n     * Uploads multiple JSON files from a folder to IPFS using Pinata SDK.\n     * @param folderPath - The path to the folder containing the JSON files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded JSON files on IPFS.\n     */\n    async uploadJsonBulk(folderPath: string): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadJson(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n\n    /**\n     * Uploads images in bulk to IPFS using Pinata SDK in ascending order of file names and returns their URLs.\n     * @param assetsFolderPath - The path to the folder containing the image and JSON files.\n     * @returns A Promise that resolves to an array of two arrays:\n     * - The first array contains the URLs of the uploaded images on IPFS.\n     * - The second array contains the URLs of the uploaded JSON files on IPFS.\n     */\n    async uploadBulk(\n        assetsFolderPath: string\n    ): Promise<[string[], string[]]> {", "        try {\n            // Read the directory\n            const files = fs.readdirSync(assetsFolderPath)\n        \n            // Filter and sort image files\n            const imageFiles = files\n                .filter((file) => /\\.(jpg|jpeg|png|gif)$/i.test(file))\n                .sort((a, b) => parseInt(a) - parseInt(b))\n        \n            // Process image uploads in ascending order and collect their URLs\n            const imageUrls: string[] = []\n\n            const jsonUrls: string[] = []\n        ", "            for (const imageFile of imageFiles) {\n                // Read image file\n                const imagePath = path.join(assetsFolderPath, imageFile)\n                const imageData = fs.createReadStream(imagePath)\n        \n                // Upload the image to IPFS using Pinata SDK\n                const result = await this.pinata.pinFileToIPFS(imageData, {\n                    pinataMetadata: {\n                        name: imageFile,\n                    },\n                })\n        \n                // Add the image URL to the array\n                const ipfsUrl = `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`\n                imageUrls.push(ipfsUrl)\n        \n                // Read the JSON file with the same filename as the image\n                const jsonFilePath = path.join(\n                    assetsFolderPath,\n                    `${path.parse(imageFile).name}.json`\n                )\n        ", "                if (fs.existsSync(jsonFilePath)) {\n                    const jsonFile = fs.readFileSync(jsonFilePath, 'utf8')\n                    const jsonData = JSON.parse(jsonFile)\n            \n                    // Add the IPFS URL to the JSON data\n                    jsonData.image = ipfsUrl\n            \n                    // Write the updated JSON data to the file\n                    fs.writeFileSync(jsonFilePath, JSON.stringify(jsonData))\n\n                    // Upload the JSON file to IPFS using Pinata SDK\n                    const jsonFileData = fs.createReadStream(\n                        jsonFilePath\n                    )\n                \n                    const jsonResult = await this.pinata.pinFileToIPFS(jsonFileData, {\n                        pinataMetadata: {\n                            name: `${path.parse(imageFile).name}.json`,\n                        },\n                    })\n                \n                    const jsonUrl = `https://gateway.pinata.cloud/ipfs/${jsonResult.IpfsHash}`\n                    jsonUrls.push(jsonUrl)\n                    console.log(`JSON file uploaded to IPFS: ${jsonUrl}`)\n                } else {\n                    error('Metadata not found for', path.parse(imageFile).name)\n                }\n            }\n        \n            console.log('All images uploaded successfully!')\n            return [imageUrls, jsonUrls]", "        } catch (error) {\n            console.error('Error uploading images to IPFS:', error)\n            throw error\n        }            \n    }\n}\n"]}
{"filename": "src/storage/AmazonS3.ts", "chunked_list": ["import { S3 } from 'aws-sdk'\nimport { error } from 'console'\nimport fs from 'fs'\nimport path from 'path'\nimport {ProviderInterface} from './'\n\n/**\n * AmazonS3 is a class that provides utility functions for interacting with Amazon S3.\n */\nexport class AmazonS3 implements ProviderInterface {\n    public s3: S3\n\n    /**\n     * Creates an instance of the AmazonS3 class.\n     * @param accessKeyId - The access key ID for your AWS account.\n     * @param secretAccessKey - The secret access key for your AWS account.\n     */\n    constructor (\n        accessKeyId: string,\n        secretAccessKey: string,\n        readonly bucketName: string\n    ) {\n        this.s3 = new S3(\n            {\n                accessKeyId: accessKeyId,\n                secretAccessKey: secretAccessKey,\n            }\n        )\n    }\n\n    /**\n     * Uploads an image file to an S3 bucket.\n     * @param imagePath - The path to the image file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded image.\n     */\n    async uploadImage(\n        imagePath: string\n    ): Promise<string> {\n        const fileContent = fs.readFileSync(imagePath)\n\n        const params = {\n            Bucket: this.bucketName, // Set the bucket name passed as an option or use the default bucket name\n            Key: path.basename(imagePath), // File name you want to save as in S3\n            Body: fileContent,\n            ContentType: 'image/jpeg', // adjust as needed\n        }\n\n        await this.s3.upload(params).promise()\n\n        return `https://${this.bucketName}.s3.amazonaws.com/${params.Key}`\n    }\n\n    /**\n     * Uploads multiple image files from a folder to an S3 bucket.\n     * @param folderPath - The path to the folder containing the image files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded images.\n     */\n    async uploadImages(\n        folderPath: string\n    ): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadImage(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n\n    /**\n     * Uploads a JSON file to an S3 bucket.\n     * @param jsonPath - The path to the JSON file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded JSON file.\n     */\n    async uploadJson(\n        jsonPath: string\n    ): Promise<string> {\n        const fileContent = fs.readFileSync(jsonPath)\n\n        const params = {\n            Bucket: this.bucketName,\n            Key: path.basename(jsonPath), // File name you want to save as in S3\n            Body: fileContent,\n            ContentType: 'application/json', // JSON file mimetype\n        }\n\n        await this.s3.upload(params).promise()\n\n        return `https://${this.bucketName}.s3.amazonaws.com/${params.Key}`\n    }\n\n    /**\n     * Uploads multiple JSON files from a folder to an S3 bucket.\n     * @param folderPath - The path to the folder containing the JSON files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded JSON files.\n     */\n    async uploadJsonBulk(\n        folderPath: string\n    ): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadJson(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n\n    /**\n     * Uploads images in bulk to IPFS using Pinata SDK in ascending order of file names and returns their URLs.\n     * @param assetsFolderPath - The path to the folder containing the image and JSON files.\n     * @returns A Promise that resolves to an array of two arrays:\n     * - The first array contains the URLs of the uploaded images on IPFS.\n     * - The second array contains the URLs of the uploaded JSON files on IPFS.\n     */\n    async uploadBulk(\n        assetsFolderPath: string\n    ): Promise<[string[], string[]]> {", "export class AmazonS3 implements ProviderInterface {\n    public s3: S3\n\n    /**\n     * Creates an instance of the AmazonS3 class.\n     * @param accessKeyId - The access key ID for your AWS account.\n     * @param secretAccessKey - The secret access key for your AWS account.\n     */\n    constructor (\n        accessKeyId: string,\n        secretAccessKey: string,\n        readonly bucketName: string\n    ) {\n        this.s3 = new S3(\n            {\n                accessKeyId: accessKeyId,\n                secretAccessKey: secretAccessKey,\n            }\n        )\n    }\n\n    /**\n     * Uploads an image file to an S3 bucket.\n     * @param imagePath - The path to the image file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded image.\n     */\n    async uploadImage(\n        imagePath: string\n    ): Promise<string> {\n        const fileContent = fs.readFileSync(imagePath)\n\n        const params = {\n            Bucket: this.bucketName, // Set the bucket name passed as an option or use the default bucket name\n            Key: path.basename(imagePath), // File name you want to save as in S3\n            Body: fileContent,\n            ContentType: 'image/jpeg', // adjust as needed\n        }\n\n        await this.s3.upload(params).promise()\n\n        return `https://${this.bucketName}.s3.amazonaws.com/${params.Key}`\n    }\n\n    /**\n     * Uploads multiple image files from a folder to an S3 bucket.\n     * @param folderPath - The path to the folder containing the image files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded images.\n     */\n    async uploadImages(\n        folderPath: string\n    ): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadImage(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n\n    /**\n     * Uploads a JSON file to an S3 bucket.\n     * @param jsonPath - The path to the JSON file to be uploaded.\n     * @returns A Promise that resolves to the URL of the uploaded JSON file.\n     */\n    async uploadJson(\n        jsonPath: string\n    ): Promise<string> {\n        const fileContent = fs.readFileSync(jsonPath)\n\n        const params = {\n            Bucket: this.bucketName,\n            Key: path.basename(jsonPath), // File name you want to save as in S3\n            Body: fileContent,\n            ContentType: 'application/json', // JSON file mimetype\n        }\n\n        await this.s3.upload(params).promise()\n\n        return `https://${this.bucketName}.s3.amazonaws.com/${params.Key}`\n    }\n\n    /**\n     * Uploads multiple JSON files from a folder to an S3 bucket.\n     * @param folderPath - The path to the folder containing the JSON files.\n     * @returns A Promise that resolves to an array of URLs of the uploaded JSON files.\n     */\n    async uploadJsonBulk(\n        folderPath: string\n    ): Promise<string[]> {\n        const files = fs.readdirSync(folderPath)\n        const uploadPromises = files.map(file => this.uploadJson(path.join(folderPath, file)))\n        return Promise.all(uploadPromises)\n    }\n\n    /**\n     * Uploads images in bulk to IPFS using Pinata SDK in ascending order of file names and returns their URLs.\n     * @param assetsFolderPath - The path to the folder containing the image and JSON files.\n     * @returns A Promise that resolves to an array of two arrays:\n     * - The first array contains the URLs of the uploaded images on IPFS.\n     * - The second array contains the URLs of the uploaded JSON files on IPFS.\n     */\n    async uploadBulk(\n        assetsFolderPath: string\n    ): Promise<[string[], string[]]> {", "        try {\n            // Read the directory\n            const files = fs.readdirSync(assetsFolderPath)\n    \n            // Filter and sort image files\n            const imageFiles = files\n                .filter((file) => /\\.(jpg|jpeg|png|gif)$/i.test(file))\n                .sort((a, b) => parseInt(a) - parseInt(b))\n    \n            // Process image uploads in ascending order and collect their URLs\n            const imageUrls: string[] = []\n            const jsonUrls: string[] = []\n    ", "            for (const imageFile of imageFiles) {\n                // Read image file\n                const imagePath = path.join(assetsFolderPath, imageFile)\n    \n                // Upload the image to S3\n                const imageUrl = await this.uploadImage(imagePath)\n                imageUrls.push(imageUrl)\n    \n                // Read the JSON file with the same filename as the image\n                const jsonFilePath = path.join(\n                    assetsFolderPath,\n                    `${path.parse(imageFile).name}.json`\n                )\n    ", "                if (fs.existsSync(jsonFilePath)) {\n                    // Upload the JSON file to S3\n                    const jsonUrl = await this.uploadJson(jsonFilePath)\n                    jsonUrls.push(jsonUrl)\n                    console.log(`JSON file uploaded to S3: ${jsonUrl}`)\n                } else {\n                    error('Metadata not found for', path.parse(imageFile).name)\n                }\n            }\n    \n            console.log('All images uploaded successfully!')\n            return [imageUrls, jsonUrls]", "        } catch (error) {\n            console.error('Error uploading images to S3:', error)\n            throw error\n        }\n    }    \n}"]}
{"filename": "src/ton-api/TonAPI.ts", "chunked_list": ["import { Address, Transaction } from 'ton-core'\nimport {ClientInterface} from './'\n\n/**\n * Class representing a TON API client.\n */\nexport class TonAPI implements ClientInterface {\n    private url: string\n\n    /**\n     * Create a new TON API client.\n     * @param {string} [url] - The base URL for the TON API. Default is 'https://tonapi.io'.\n     */\n    constructor(url?: string) {\n        this.url = url ? url : 'https://tonapi.io'\n    }\n\n    /**\n     * Fetch NFT collections.\n     * @param {number} [limit] - The maximum number of collections to fetch.\n     * @param {number} [offset] - The offset to start fetching from.\n     */\n    async getNftCollections(\n        limit?: number,\n        offset?: number,\n    ) {\n        const response = await request(\n            `${this.url}/v2/nfts/collections?limit=${limit}&offset=${offset}`,\n            {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        )\n\n        return response\n    }\n\n    /**\n     * Fetch an NFT collection by its address.\n     * @param {string} collectionAddress - The address of the collection to fetch.\n     */\n    async getNftCollection(\n        collectionAddress: string,\n    ) {\n        const response = await request(\n            `${this.url}/v2/nfts/collections/${collectionAddress}`,\n            {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        )\n\n        return response\n    }\n\n    /**\n     * Fetch NFT items from a collection by the collection's address.\n     * @param {string} collectionAddress - The address of the collection to fetch items from.\n     * @param {number} [limit] - The maximum number of items to fetch.\n     * @param {number} [offset] - The offset to start fetching from.\n     */\n    async getNftItems(\n        collectionAddress: string,\n        limit?: number,\n        offset?: number,\n    ) {\n        const response = await request(\n            `${this.url}/v2/nfts/collections/${collectionAddress}/items?limit=${limit}&offset=${offset}`,\n            {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        )\n\n        return response\n    }\n\n    /**\n     * Fetch an NFT item by its address.\n     * @param {string} itemAddress - The address of the item to fetch.\n     */\n    async getNftItem(\n        itemAddress: string,\n    ) {\n        const response = await request(\n            `${this.url}/v2/nfts/${itemAddress}`,\n            {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        )\n\n        return response\n    }\n\n    /**\n     * Fetch transactions by address.\n     * @param {Address} address - The address to fetch transactions for.\n     * @param {number} limit - The maximum number of transactions to fetch.\n     * @returns {Promise<any>} A promise resolving with the fetched transactions.\n     */\n    async getTransactionsByAddress(\n        address: Address,\n        limit?: number\n    ) {\n        const response = await request(\n            `${this.url}/v1/blockchain/getTransactions?account=${address.toString()}&limit=${limit}`,\n            {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        )\n\n        return response\n    }\n\n    /**\n     * Fetch transaction data.\n     * @param {string} transactionId - The ID of the transaction to fetch data for.\n     * @returns {Promise<Transaction>} A promise resolving with the fetched transaction data.\n     */\n    async getTransactionData(\n        transactionId: string\n    ): Promise<Transaction> {\n        const response: Transaction = await request(\n            `${this.url}/v2/blockchain/transactions/${transactionId}`,\n            {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        )\n\n        return response\n    }\n}\n\n/**\n * Send a request to a URL and return the response as JSON.\n * @template TResponse The expected shape of the response body.\n * @param {string} url - The URL to send the request to.\n * @param {RequestInit} config - The configuration options for the request.\n * @returns {Promise<TResponse>} A promise resolving with the response body.\n */", "async function request<TResponse>(\n    url: string, \n    config: RequestInit\n): Promise<TResponse> {\n    const response = await fetch(url, config)\n    return (await response.json()) as TResponse\n}"]}
{"filename": "src/ton-api/index.ts", "chunked_list": ["import { Address } from 'ton-core'\n\nexport class TonNftClient {\n    constructor(\n        readonly client: ClientInterface\n    ) {}\n\n    async getNftCollections(\n        limit?: number,\n        offset?: number,\n    ) {\n        return await this.client.getNftCollections(limit, offset)\n    }\n\n    async getNftCollection(\n        collectionAddress: string,\n    ) {\n        return await this.client.getNftCollection(collectionAddress)\n    }\n\n    async getNftItems(\n        collectionAddress: string,\n        limit?: number,\n        offset?: number,\n    ) {\n        return await this.client.getNftItems(collectionAddress, limit, offset)\n    }\n\n    async getNftItem(\n        itemAddress: string,\n    ) {\n        return await this.client.getNftItem(itemAddress)\n    }\n\n    async getTransactionsByAddress(\n        address: Address,\n        limit?: number\n    ) {\n        return await this.client.getTransactionsByAddress(address, limit)\n    }\n}\n", "export interface ClientInterface {\n    getNftCollections: (limit?: number, offset?: number) => Promise<unknown>\n    getNftCollection: (collectionAddress: string) => Promise<unknown>\n    getNftItems: (collectionAddress: string, limit?: number, offset?: number) => Promise<unknown>\n    getNftItem: (itemAddress: string) => Promise<unknown>\n    getTransactionsByAddress: (address: Address, limit?: number) => Promise<unknown>\n}"]}
{"filename": "src/wrappers/getgems/NftAuction/NftAuction.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\n/**\n * Class representing an NFT auction contract.\n */\nexport class NftAuction implements Contract {\n    /**\n     * Creates an `NftAuction` instance from an address and initialization data.\n     * @param address - The address of the contract.\n     * @param init - The initialization data.\n     * @returns A new `NftAuction` instance.\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n    \n    static code = Cell.fromBoc(Buffer.from('te6cckECLgEABqIAART/APSkE/S88sgLAQIBIAIDAgFIBAUCKPIw2zyBA+74RMD/8vL4AH/4ZNs8LBkCAs4GBwIBIBwdAgEgCAkCASAaGwT1DPQ0wMBcbDyQPpAMNs8+ENSEMcF+EKwwP+Oz1vTHyHAAI0EnJlcGVhdF9lbmRfYXVjdGlvboFIgxwWwjoNb2zzgAcAAjQRZW1lcmdlbmN5X21lc3NhZ2WBSIMcFsJrUMNDTB9QwAfsA4DDg+FdSEMcFjoQxAds84PgjgLBEKCwATIIQO5rKAAGphIAFcMYED6fhW10nCAvLygQPqAdMfghAFE42REroS8vSAQNch+kAw+HZw+GJ/+GTbPBkESPhTvo8GbCHbPNs84PhCwP+OhGwh2zzg+FZSEMcF+ENSIMcFsRcRFwwEeI+4MYED6wLTHwHDABPy8otmNhbmNlbIUiDHBY6DIds83otHN0b3CBLHBfhWUiDHBbCPBNs82zyRMOLgMg0XEQ4B9oED7ItmNhbmNlbIEscFs/Ly+FHCAI5FcCCAGMjLBfhQzxb4UfoCy2rLH40KVlvdXIgYmlkIGhhcyBiZWVuIG91dGJpZCBieSBhbm90aGVyIHVzZXIugzxbJcvsA3nAg+CWCEF/MPRTIyx/LP/hWzxb4Vs8WywAh+gLLAA8BBNs8EAFMyXGAGMjLBfhXzxZw+gLLasyCCA9CQHD7AsmDBvsAf/hif/hm2zwZBPSBA+34QsD/8vL4U/gjuY8FMNs82zzg+E7CAPhOUiC+sI7V+FGORXAggBjIywX4UM8W+FH6Astqyx+NClZb3VyIGJpZCBoYXMgYmVlbiBvdXRiaWQgYnkgYW5vdGhlciB1c2VyLoM8WyXL7AN4B+HD4cfgj+HLbPOD4UxcRERICkvhRwACOPHAg+CWCEF/MPRTIyx/LP/hWzxb4Vs8WywAh+gLLAMlxgBjIywX4V88WcPoCy2rMgggPQkBw+wLJgwb7AOMOf/hi2zwTGQP8+FWh+CO5l/hT+FSg+HPe+FGOlIED6PhNUiC58vL4cfhw+CP4cts84fhR+E+gUhC5joMw2zzgcCCAGMjLBfhQzxb4UfoCy2rLH40KVlvdXIgYmlkIGhhcyBiZWVuIG91dGJpZCBieSBhbm90aGVyIHVzZXIugzxbJcvsAAfhwGRcYA/hwIPglghBfzD0UyMsfyz/4UM8W+FbPFssAggnJw4D6AssAyXGAGMjLBfhXzxaCEDuaygD6AstqzMly+wD4UfhI+EnwAyDCAJEw4w34UfhL+EzwAyDCAJEw4w2CCA9CQHD7AnAggBjIywX4Vs8WIfoCy2rLH4nPFsmDBvsAFBUWAHhwIIAYyMsF+EfPFlAD+gISy2rLH40H01hcmtldHBsYWNlIGNvbW1pc3Npb24gd2l0aGRyYXeDPFslz+wAAcHAggBjIywX4Ss8WUAP6AhLLassfjQbUm95YWx0eSBjb21taXNzaW9uIHdpdGhkcmF3gzxbJc/sAAC5QcmV2aW91cyBvd25lciB3aXRoZHJhdwCIcCCAGMjLBVADzxYh+gISy2rLH40J1lvdXIgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIGFjY2VwdGVkLoM8WyYBA+wABEPhx+CP4cts8GQDQ+Ez4S/hJ+EjI+EfPFssfyx/4Ss8Wyx/LH/hV+FT4U/hSyPhN+gL4TvoC+E/6AvhQzxb4UfoCyx/LH8sfyx/I+FbPFvhXzxbJAckCyfhG+EX4RPhCyMoA+EPPFsoAyh/KAMwSzMzJ7VQAESCEDuaygCphIAANFnwAgHwAYAIBIB4fAgEgJCUCAWYgIQElupFds8+FbXScEDknAg4PhW+kSCwBEa8u7Z58KH0iQCwCASAiIwEYqrLbPPhI+En4S/hMLAFeqCzbPIIIQVVD+EL4U/hD+Ff4VvhR+FD4T/hH+Ej4SfhK+Ev4TPhO+E34RfhS+EYsAgEgJicCAW4qKwEdt++7Z58JvwnfCf8KPwpwLAIBICgpARGwybbPPhK+kSAsARGxlvbPPhH+kSAsARGvK22efCH9IkAsASWsre2efCvrpOCByTgQcHwr/SJALAH2+EFu3e1E0NIAAfhi+kAB+GPSAAH4ZNIfAfhl0gAB+GbUAdD6QAH4Z9MfAfho0x8B+Gn6QAH4atMfAfhr0x8w+GzUAdD6AAH4bfoAAfhu+gAB+G/6QAH4cPoAAfhx0x8B+HLTHwH4c9MfAfh00x8w+HXUMND6QAH4dvpALQAMMPh3f/hhRQVNYw==', 'base64'))[0]\n\n    /**\n     * Builds the data cell for the auction contract.\n     * @param data - The data for building the data cell.\n     * @returns The built data cell.\n     */\n    static buildDataCell(data: NftAuctionData) {\n\n        const feesCell = beginCell()\n        feesCell.storeAddress(data.marketplaceFeeAddress)      // mp_fee_addr\n        feesCell.storeUint(data.marketplaceFeeFactor, 32)               // mp_fee_factor\n        feesCell.storeUint(data.marketplaceFeeBase, 32)   // mp_fee_base\n        feesCell.storeAddress(data.royaltyAddress)  // royalty_fee_addr\n        feesCell.storeUint(data.royaltyFactor, 32)              // royalty_fee_factor\n        feesCell.storeUint(data.royaltyBase, 32)   // royalty_fee_base\n\n\n        const bidsCell = beginCell()\n        bidsCell.storeCoins(data.minBid)       // min_bid\n        bidsCell.storeCoins(data.maxBid)       // max_bid\n        bidsCell.storeCoins(data.minStep)       // min_step\n        bidsCell.storeBuffer(Buffer.from([0,0]))        // last_member\n        bidsCell.storeCoins(0)       // last_bid\n        bidsCell.storeUint(0, 32) // last_bid_at\n        bidsCell.storeUint(data.endTimestamp, 32)    // end_time\n        bidsCell.storeUint(data.stepTimeSeconds, 32)               // step_time\n        bidsCell.storeUint(data.tryStepTimeSeconds, 32)               // try_step_time\n\n        const nftCell = beginCell()", "        if (data.nftOwnerAddress) {\n            nftCell.storeAddress(data.nftOwnerAddress)\n        } else {\n            nftCell.storeBuffer(Buffer.from([0, 0]))\n        }\n        nftCell.storeAddress(data.nftAddress)          // nft_addr\n\n\n        const storage = beginCell()\n        storage.storeBit(data.end)     // end?\n        storage.storeAddress(data.marketplaceAddress)   // mp_addr\n        storage.storeBit(data.activated)    // activated\n        storage.storeUint(data.createdAtTimestamp, 32)\n        storage.storeBit(false) // is_canceled\n        storage.storeRef(feesCell.endCell())\n        storage.storeRef(bidsCell.endCell())\n        storage.storeRef(nftCell.endCell())\n\n        return storage.endCell()\n    }\n\n    /**\n     * Creates an `NftAuction` instance from an address.\n     * @param address - The address to create from.\n     * @returns A new `NftAuction` instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftAuction(\n            address\n        )\n    }\n\n    /**\n     * Creates an `NftAuction` instance from configuration data.\n     * @param config - The configuration data for creating the instance.\n     * @param workchain - The workchain ID (default: 0).\n     * @returns A new `NftAuction` instance.\n     */\n    static async createFromConfig(\n        config: NftAuctionData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftAuction(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a cancel command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the cancel command.\n     * @param params - The parameters for the cancel command.\n     */\n    async sendCancel(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0,32)\n                .storeBuffer(Buffer.from('cancel'))\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n    \n    /**\n     * Sends a stop command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the stop command.\n     * @param params - The parameters for the stop command.\n     */\n    async sendStop(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0,32)\n                .storeBuffer(Buffer.from('cancel'))\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a repeat end auction command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the repeat end auction command.\n     * @param params - The parameters for the repeat end auction command.\n     */\n    async sendRepeatEndAuction(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0,32)\n                .storeBuffer(Buffer.from('repeat_end_auction'))\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends an emergency message to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the emergency message.\n     * @param params - The parameters for the emergency message.\n     */\n    async sendEmergencyMessage(provider: ContractProvider, via: Sender, params: { \n        value: bigint,\n        marketplaceAddress: Address,\n        coins: bigint\n    }) {\n        const transfer = beginCell()\n        transfer.storeUint(0x18, 6)\n        transfer.storeAddress(params.marketplaceAddress)\n        transfer.storeCoins(params.coins)\n        transfer.storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        transfer.storeRef(beginCell().storeUint(555,32).endCell())\n\n        const transferBox = beginCell()\n        transferBox.storeUint(2, 8)\n        transferBox.storeRef(transfer.endCell())\n\n        const msgResend = beginCell().storeUint(0, 32).storeBuffer(Buffer.from('emergency_message')).storeRef(transferBox.endCell()).endCell()\n\n        await provider.internal(via, {\n            value: params.value,\n            body: msgResend,\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the sale data from the contract.\n     * @param provider - The contract provider.\n     * @returns The sale data.\n     */\n    async getSaleData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_sale_data', [])\n        \n        // pops out saleType\n        stack.pop()\n        \n        return {\n            // saleType: stack.readBigNumber(),\n            end: stack.readBoolean(),\n            endTimestamp: stack.readBigNumber(),\n            marketplaceAddress: stack.readAddressOpt(),\n            nftAddress: stack.readAddressOpt(),\n            nftOwnerAddress: stack.readAddressOpt(),\n            lastBidAmount: stack.readBigNumber(),\n            lastBidAddress: stack.readAddressOpt(),\n            minStep: stack.readBigNumber(),\n            marketplaceFeeAddress: stack.readAddressOpt(),\n            marketplaceFeeFactor: stack.readBigNumber(), \n            marketplaceFeeBase: stack.readBigNumber(),\n            royaltyAddress: stack.readAddressOpt(),\n            royaltyFactor: stack.readBigNumber(), \n            royaltyBase: stack.readBigNumber(),\n            maxBid: stack.readBigNumber(),\n            minBid: stack.readBigNumber(),\n            createdAt: stack.readBigNumber(),\n            lastBidAt: stack.readBigNumber(),\n            isCanceled: stack.readBigNumber(),\n        }\n    }\n}\n\n/**\n * Type representing the data for an NFT auction contract version 2.\n */", "export type NftAuctionData = {\n    marketplaceFeeAddress: Address,\n    marketplaceFeeFactor: bigint,\n    marketplaceFeeBase: bigint,\n\n\n    royaltyAddress: Address,\n    royaltyFactor: bigint,\n    royaltyBase: bigint,\n\n\n    minBid: bigint,\n    maxBid: bigint,\n    minStep: bigint,\n    endTimestamp: number,\n    createdAtTimestamp: number,\n\n    stepTimeSeconds: number,\n    tryStepTimeSeconds: number,\n\n    nftOwnerAddress: Address | null,\n    nftAddress: Address,\n\n    end: boolean,\n    marketplaceAddress: Address,\n    activated: boolean,\n}"]}
{"filename": "src/wrappers/getgems/NftOffer/NftOffer.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\n/**\n * Class representing a Non-Fungible Token (NFT) Offer contract.\n */\nexport class NftOffer implements Contract {\n    /**\n     * Constructs an instance of the NftOffer contract.\n     * @param address - The address of the contract.\n     * @param init - The initial code and data for the contract.\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECFgEABEkAART/APSkE/S88sgLAQIBIAQCAVby7UTQ0wDTH9Mf+kD6QPpA+gDU0wAwMAfAAfLRlPgjJb7jAl8IggD//vLwAwDOB9MfgQ+jAsMAEvLygQ+kIddKwwDy8oEPpSHXSYEB9Lzy8vgAgggPQkBw+wJwIIAQyMsFJM8WIfoCy2rLHwHPFsmDBvsAcQdVBXAIyMsAF8sfFcsfUAPPFgHPFgHPFgH6AszLAMntVAIBSAYFAIOhRh/aiaGmAaY/pj/0gfSB9IH0AammAGBhofSBpj+mP/SBpj+mPmCo7CHgBqjuqeAGpQVCA0MEMJ6MjIqkHYACq4ECAswLBwP322ERFofSBpj+mP/SBpj+mPmBSs+AGqJCH4Aam4UJHQxbKDk3szS6QTrLgQQAhkZYKoAueLKAH9AQnltWWPgOeLZLj9gBFhABFrpOEBWEk2EPGGkGEASK3xhrgQQQgv5h6KZGWPieWfk2eLKAHni2UAQQRMS0B9AWUAZLjAoJCAB4gBjIywUmzxZw+gLLasyCCA9CQHD7AsmDBvsAcVVgcAjIywAXyx8Vyx9QA88WAc8WAc8WAfoCzMsAye1UAEyLlPZmZlciBmZWWHAggBDIywVQBc8WUAP6AhPLassfAc8WyXH7AABYi+T2ZmZXIgcm95YWxpZXOBNwIIAQyMsFUAXPFlAD+gITy2rLHwHPFslx+wACAUgPDAIBIA4NAB0IMAAk18DcOBZ8AIB8AGAAESCEDuaygCphIAIBIBEQABMghA7msoAAamEgAfcAdDTAwFxsJJfBOD6QDDtRNDTANMf0x/6QPpA+kD6ANTTADDAAY4lMTc3OFUzEnAIyMsAF8sfFcsfUAPPFgHPFgHPFgH6AszLAMntVOB/KscBwACOGjAJ0x8hwACLZjYW5jZWyFIgxwWwknMy3lCq3iCBAiu6KcABsFOmgEgLQxwWwnhCsXwzUMNDTB9QwAfsA4IIQBRONkVIQuuMCPCfAAfLRlCvAAFOTxwWwjis4ODlQdqAQN0ZQRAMCcAjIywAXyx8Vyx9QA88WAc8WAc8WAfoCzMsAye1U4Dc5CcAD4wJfCYQP8vAVEwGsU1jHBVNixwWx8uHKgggPQkBw+wJRUccFjhQ1cIAQyMsFKM8WIfoCy2rJgwb7AOMNcUcXUGYFBANwCMjLABfLHxXLH1ADzxYBzxYBzxYB+gLMywDJ7VQUALYF+gAhghAdzWUAvJeCEB3NZQAy3o0EE9mZmVyIGNhbmNlbCBmZWWBURzNwIIAQyMsFUAXPFlAD+gITy2rLHwHPFslx+wDUMHGAEMjLBSnPFnD6AstqzMmDBvsAAMYwCdM/+kAwU5THBQnAABmwK4IQO5rKAL6wnjgQWhBJEDhHFQNEZPAIjjg5XwYzM3AgghBfzD0UyMsfE8s/I88WUAPPFsoAIfoCygDJcYAYyMsFUAPPFnD6AhLLaszJgED7AOK1Lpfy', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT offer.\n     * @param data - The data for the NFT offer.\n     * @returns A cell containing the data for the NFT offer.\n     */\n    static buildDataCell(data: NftOfferData) {\n        const feesCell = beginCell()\n    \n        feesCell.storeAddress(data.marketplaceFeeAddress)\n        feesCell.storeUint(data.marketplaceFactor, 32)\n        feesCell.storeUint(data.marketplaceBase, 32)\n        feesCell.storeAddress(data.royaltyAddress)\n        feesCell.storeUint(data.royaltyFactor, 32)\n        feesCell.storeUint(data.royaltyBase, 32)\n    \n        const dataCell = beginCell()\n    \n        dataCell.storeUint(data.isComplete ? 1 : 0, 1)\n        dataCell.storeUint(data.createdAt, 32)\n        dataCell.storeUint(data.finishAt, 32)\n        dataCell.storeAddress(data.marketplaceAddress)\n        dataCell.storeAddress(data.nftAddress)\n        dataCell.storeAddress(data.offerOwnerAddress)\n        dataCell.storeCoins(data.fullPrice) // fullPrice\n        dataCell.storeRef(feesCell)\n        dataCell.storeUint(1, 1) // can_deploy\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftOffer instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftOffer instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftOffer(\n            address\n        )\n    }\n\n    /**\n     * Creates an NftOffer instance from a configuration object.\n     * @param config - The configuration data for the NFT offer.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new NftOffer instance.\n     */\n    static async createFromConfig(\n        config: NftOfferData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftOffer(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a cancel offer command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the cancel command.\n     * @param params - Parameters for the cancel command including optional message and value.\n     */\n    async sendCancelOffer(provider: ContractProvider, via: Sender, params: { \n        message?: string,\n        value: bigint\n    }) {\n        const nextPayload = beginCell()\n", "        if (params.message) {\n            nextPayload.storeUint(0, 32)\n            const m = Buffer.from(params.message.substring(0, 121), 'utf-8')\n            nextPayload.storeBuffer(m.slice(0, 121))\n        }\n\n        nextPayload.endCell()\n\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0,32)\n                .storeBuffer(Buffer.from('cancel'))\n                .storeRef(nextPayload)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a cancel offer command to the contract by the marketplace.\n     * @param provider - The contract provider.\n     * @param via - The sender of the cancel command.\n     * @param params - Parameters for the cancel command including amount, optional message and value.\n     */\n    async sendCancelOfferByMarketplace(provider: ContractProvider, via: Sender, params: { \n        amount: bigint; \n        message?: string \n        value: bigint\n    }) {\n        const nextPayload = beginCell()\n", "        if (params.message) {\n            nextPayload.storeUint(0, 32)\n            const m = Buffer.from(params.message.substring(0, 121), 'utf-8')\n            nextPayload.storeBuffer(m.slice(0, 121))\n        }\n\n        nextPayload.endCell()\n\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(3,32)\n                .storeCoins(params.amount)\n                .storeRef(nextPayload)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Gets the data of the offer.\n     * @param provider - The contract provider.\n     * @returns The current data of the offer.\n     */\n    async getOfferData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_offer_data', [])\n\n        return {\n            offerType: stack.readBigNumber(),\n            isComplete: stack.readBoolean(),\n            createdAt: stack.readBigNumber(),\n            finishAt: stack.readBigNumber(),\n            marketplaceAddress: stack.readAddress(),\n            nftAddress: stack.readAddress(),\n            offerOwnerAddress: stack.readAddress(),\n            fullPrice: stack.readBigNumber(),\n            marketplaceFeeAddress: stack.readAddress(),\n            marketplaceFactor: stack.readBigNumber(),\n            marketplaceBase: stack.readBigNumber(),\n            royaltyAddress: stack.readAddress(),\n            royaltyFactor: stack.readBigNumber(),\n            royaltyBase: stack.readBigNumber(),\n            profitPrice: stack.readBigNumber(),\n        }\n    }\n}\n\n/**\n * Type definition for the data of an NFT offer.\n */", "export type NftOfferData = {\n    isComplete: boolean\n    createdAt: number\n    finishAt: number\n    marketplaceAddress: Address\n    nftAddress: Address\n    offerOwnerAddress: Address\n    fullPrice: bigint\n    marketplaceFeeAddress: Address\n    royaltyAddress: Address\n    marketplaceFactor: number\n    marketplaceBase: number\n    royaltyFactor: number\n    royaltyBase: number\n}"]}
{"filename": "src/wrappers/getgems/SbtSingle/SbtSingle.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\nimport { storeOffchainContent } from '../../../types/Content'\n\n/**\n * Represents a single item of the SBT (Soul Bound Token) NFT.\n * Implements the Contract interface.\n */\nexport class SbtSingle implements Contract {\n    /**\n     * Constructs an instance of the SbtSingle contract.\n     * @param address - The address of the contract.\n     * @param init - Optional initialization data for the contract.\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    // Data\n\n    static code = Cell.fromBoc(Buffer.from('te6ccgECGQEABBgAART/APSkE/S88sgLAQIBYgIDAgLOBAUCASATFAIBIAYHAgEgERIB7QyIccAkl8D4NDTA/pA+kAx+gAxcdch+gAx+gAw8AID0x8DcbCOTBAkXwTTH4IQBSTHrhK6jjnTPzCAEPhCcIIQwY6G0lUDbYBAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCRMOLgAtM/gCAARPpEMHC68uFNgBPyCEC/LJqJSQLqOQDBsIjJwyMv/iwLPFoAQcIIQi3cXNUBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wDgghDQw7/qUkC64wKCEATe0UhSQLrjAoIQHARBKlJAuo6FM0AD2zzgNDSCEBoLnVFSILoJCgsMAMBsM/pA1NMAMPhFcMjL/1AGzxb4Qs8WEswUyz9SMMsAA8MAlvhDUAPMAt6AEHixcIIQDdYH40A1FIBAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAAyGwz+EJQA8cF8uGRAfpA1NMAMPhFcMjL//hCzxYTzBLLP1IQywABwwCU+EMBzN6AEHixcIIQBSTHrkBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAB9PhBFMcF8uGR+kAh8AH6QNIAMfoAggr68IAXoSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIY49yPhBzxZQB88WgBCCEFEaRGMTcSZUSFADyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AJI2MOIDDQP+jhAxMvhBEscF8uGa1DD4Y/AD4DKCEB8EU3pSELqORzD4QiHHBfLhkYAQcIIQ1TJ220EEbYMGA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCLAvhiiwL4ZPAD4IIQb4n141IQuuMCghDRNtOzUhC64wJsIQ4PEACAjjYi8AGAEIIQ1TJ22xRFA21xA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCSbDHi+GHwAwAuMDH4RAHHBfLhkfhFwADy4ZP4I/hl8AMAijD4QiHHBfLhkYIK+vCAcPsCgBBwghDVMnbbQQRtgwYDyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AAAgghBfzD0UupPywZ3ehA/y8AA3O1E0PpAAfhi+kAB+GHUAfhj+kAB+GTTPzD4ZYAAvPhF+EPI+ELPFvhBzxbM+ETPFss/ye1UgAgFYFRYAGbx+f4AT+4RYF8IXwhwADbVjHgBfCJACASAXGAANsB08AL4QYAANs2D8AL4RYA==', 'base64'))[0]\n\n    /**\n     * Builds a data cell for the SbtSingle contract.\n     * @param data - The data for the contract.\n     * @returns A data cell.\n     */\n    static buildDataCell(data: SbtSingleData) {\n        const dataCell= beginCell()\n    \n        const contentCell = storeOffchainContent({\n            type: 'offchain',\n            uri: data.content\n        })\n    \n        dataCell.storeAddress(data.ownerAddress)\n        dataCell.storeAddress(data.editorAddress)\n        dataCell.store(contentCell)\n        dataCell.storeAddress(data.authorityAddress)\n        dataCell.storeUint(data.revokedAt ? data.revokedAt : 0, 64)\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Constructs an instance of the SbtSingle contract from an address.\n     * @param address - The address of the contract.\n     * @returns An instance of SbtSingle.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new SbtSingle(\n            address\n        )\n    }\n\n    /**\n     * Constructs an instance of the SbtSingle contract from a configuration object.\n     * @param config - The configuration object for the contract.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns An instance of SbtSingle.\n     */\n    static async createFromConfig(\n        config: SbtSingleData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new SbtSingle(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value sent with the deploy command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a prove ownership command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the prove ownership command.\n     * @param params - The parameters for the prove ownership command, including value, queryId, dest, forwardPayload, and withContent.\n     */\n    async sendProveOwnership(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n        dest: Address\n        forwardPayload?: Cell\n        withContent: boolean\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x04ded148, 32)\n                .storeUint(params.queryId, 64)\n                .storeAddress(params.dest)\n                .storeMaybeRef(params.forwardPayload)\n                .storeBit(params.withContent)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a request owner command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the request owner command.\n     * @param params - The parameters for the request owner command, including value, queryId, dest, forwardPayload, and withContent.\n     */\n    async sendRequestOwner(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n        dest: Address\n        forwardPayload?: Cell\n        withContent: boolean\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0xd0c3bfea, 32)\n                .storeUint(params.queryId, 64)\n                .storeAddress(params.dest)\n                .storeMaybeRef(params.forwardPayload)\n                .storeBit(params.withContent)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a revoke command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the revoke command.\n     * @param params - The parameters for the revoke command, including value and queryId.\n     */\n    async sendRevoke(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x6f89f5e3, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the NFT data from the contract.\n     * @param provider - The contract provider.\n     * @returns An object containing the NFT data, including init, index, collectionAddress, ownerAddress, and individualContent.\n     */\n    async getNftData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_nft_data', [])\n        return {\n            init: stack.readBoolean(),\n            index: stack.readBigNumber(),\n            collectionAddress: stack.readAddressOpt(),\n            ownerAddress: stack.readAddressOpt(),\n            individualContent: stack.readCellOpt(),\n        }\n    }\n\n    /**\n     * Retrieves the authority address from the contract.\n     * @param provider - The contract provider.\n     * @returns An object containing the authority address.\n     */\n    async getAuthorityAddress(provider: ContractProvider) {\n        const { stack } = await provider.get('get_authority_address', [])\n        return {\n            authorityAddress: stack.readAddressOpt(),\n        }\n    }\n\n    /**\n     * Retrieves the time when the contract was revoked.\n     * @param provider - The contract provider.\n     * @returns An object containing the revoked time.\n     */\n    async getRevokedTime(provider: ContractProvider) {\n        const { stack } = await provider.get('get_revoked_time', [])\n        return {\n            revoked_time: stack.readBigNumber(),\n        }\n    }\n}\n\n// Utils\n\n/**\n * Represents the data required to create a new SbtSingle contract.\n */", "export type SbtSingleData = {\n    ownerAddress: Address\n    editorAddress: Address\n    content: string\n    authorityAddress: Address\n    revokedAt?: number\n}"]}
{"filename": "src/wrappers/getgems/NftRaffle/NftRaffle.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode } from 'ton-core'\n\n/**\n * The object containing operation codes for different operations\n */\nexport const OperationCodes = {\n    cancel: 2001,\n    addCoins: 2002\n}\n", "}\n\n/**\n * Class representing a NFT Raffle\n */\nexport class NftRaffle implements Contract {\n    /**\n     * @param address - The address of the NFT Raffle\n     * @param init - The initialization data for the NFT Raffle\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    /**\n     * The code for the NFT Raffle contract\n     */\n    static code = Cell.fromBoc(Buffer.from('te6ccsECGgEABKgAAA0AEgAXAD0AQwCdANwA+AEgAV4BwQHoAh8CcQJ/Ar4CwwMRAy8DYwObA7cD8QQGBEUEqAEU/wD0pBP0vPLICwECAWIFAgIBWAQDAUW6KJ2zz4QvhD+ET4RfhG+Ef4SPhJ+Er4S/hM+E34TvhP+FCBkBBbtguBUEqNAz0NMDAXGw8kDbPPpAMALTH/hHUkDHBfhIUlDHBfhJUmDHBYIQBRONkVJQuo6GEDRfBNs84IEH0VJQuo6ObDMzgQPqWbFYsfL02zzgMIEH0lJAuhkNCgYDdI6YM4ED6lMxsfL0cAGSMHHeApJyMt5DMNs84FuBB9RSILqOhhAjXwPbPOAygQfTuo6C2zzgW4QP8vAJCAcANIED6fhCcbry8oED6vhJE8cFEvL01NMHMPsAAUqBA+n4QnO98vL4RfhDoPhOqIED61IiufLy+EX4Q6CpBPhQAds8EwNyMDGBA+n4QnG68vQhwAGd+EyCCJiWgFIgoaD4bN4BwAKc+E2CCJiWgBKhoPhtkTDi2zyOgts83ts8FQ8RBLqBA+n4QnG98vKBA+nbPPLycvhi+E/4TvhH+EjbPIIID0JAcPsC+Ef4TI0E05GVCByYWZmbGUgY2FuY2VsZWSBy2zz4SPhNjQTTkZUIHJhZmZsZSBjYW5jZWxlZIHIVDBILA0TbPPhJcI0E05GVCByYWZmbGUgY2FuY2VsZWSCBAILbPNs8EhIRAmZ/jy0kgwf0fG+lII8eItcLA8ACjoZxVHZS2zzeAtcLA8ADjoZxVHUx2zzekTLiAbPmXwUYGASYggiYloASofhOoSDBAPhCcb2xjoMw2zzgIvpEMfhPAds8XLGzjoRfBNs84DQ0+G8Cm/hGpPhm+EwioPhs3pv4RKT4ZPhNAaD4bZEw4hcWFw4DEts8joLbPN7bPBUPEQRyc/hi+FD4T9s8+HD4UPhO2zyCCA9CQHD7AvhJcI0FU5GVCByYWZmbGUgY29tbWlzc2lvboIEAgts8FBMSEAEE2zwRAJj4UPhPyPQA9ADJyPhK+gL4S/oC+Ez6AvhN+gL4TvoCycj4R88W+EjPFvhJzxbJ+Eb4RfhE+EP4QsjLAcsDywPLA8sDycjMzMzMye1UADhwIIAYyMsFUAbPFlAE+gIUy2oSyx8BzxbJAfsAAmB/jyoigwf0fG+lII8bAtcLAMABjohw+EdUZDHbPI6IcPhIVGQx2zzikTLiAbPmXwMYGABsf44xIYMH9HxvpTIhjiNy+BHAAJ1xyMsAydBUIAWDB/QWnXDIywDJ0FQgBYMH9BbiA94Bs+ZbATLbPPhD+ES6+EX4Rrqw+Ez4Sr6w+E34S76wGQBwcFRwEoMH9A5vocAAlF8EcCDg0wMwwACeMXLIywPJ0EADgwf0Fn+fMHPIywPJ0EADgwf0Fn8C4lgBJIBA1yH6QDAB+kQxgEACcALbPBgAenAg+CWCEF/MPRTIyx/LPyTPFlAEzxYTygAi+gISygDJcXAgcoAYyMsFywHLAMsHE8v/UAP6AstqzMkB+wAAwvhBbt3tRNDUAdDTAQH4YtMDAfhj0wMB+GTTAwH4ZdMDMPhm1AHQ+kAB+Gf6QAH4aPpAMPhp1AHQ+gAB+Gr6AAH4a/oAAfhs+gAB+G36ADD4btQw0PQEAfhv9AQw+HB/+GEoOcFW', 'base64'))[0]\n\n    /**\n     * Creates an NftRaffle instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftRaffle instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftRaffle(\n            address\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a cancel command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the cancel command.\n     * @param params - Parameters for the cancel command including value.\n     */\n    async sendCancel(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.cancel, 32)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends an addCoins command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the addCoins command.\n     * @param params - Parameters for the addCoins command including value.\n     */\n    async sendAddCoins(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.addCoins, 32)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Gets the state of the raffle.\n     * @param provider - The contract provider.\n     * @returns The current state of the raffle.\n     */\n    async getRaffleState(\n        provider: ContractProvider\n    ) {\n        const { stack } = await provider.get('raffle_state', [])\n        return {\n            state: stack.readBigNumber(), \n            rightNftsCount: stack.readBigNumber(), \n            rightNftsReceived: stack.readBigNumber(), \n            leftNftsCount: stack.readBigNumber(),\n            leftNftsReceived: stack.readBigNumber(), \n            leftUser: stack.readAddressOpt(), \n            rightUser: stack.readAddressOpt(), \n            superUser: stack.readAddressOpt(), \n            leftCommission: stack.readBigNumber(),\n            rightCommission: stack.readBigNumber(), \n            leftCoinsGot: stack.readBigNumber(), \n            rightCoinsGot: stack.readBigNumber(),\n            nftTransferFee: stack.readCell(), \n            nfts: stack.readCell(), \n            raffledNfts: stack.readCell()\n        }\n    }\n}"]}
{"filename": "src/wrappers/getgems/NftSwap/NftSwap.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Dictionary, Sender, SendMode, contractAddress } from 'ton-core'\n\n/**\n * OperationCodes are identifiers for various actions that can be performed by the contract.\n */\nconst OperationCodes = {\n    ownershipAssigned: 0x05138d91,\n    addCoins: 1,\n    cancel: 2,\n    maintain: 3,", "    cancel: 2,\n    maintain: 3,\n    topup: 4,\n    transferCommission: 0x82bd8f2a,\n    transferCancel: 0xb5188860,\n    transferComplete: 0xef03d009,\n}\n\n/**\n * SwapState represents the different states of a swap.", "/**\n * SwapState represents the different states of a swap.\n */\nexport const SwapState = {\n    Active: 1,\n    Cancelled: 2,\n    Completed: 3,\n}\n\n/**", "\n/**\n * Interface representing an NFT item, containing an address and whether it has been sent.\n */\ninterface NFTItem {\n    addr: Address\n    sent: boolean\n}\n\n/**\n * SwapData represents the information of a swap operation.\n */", "export type SwapData = {\n    state: number,\n    leftAddress: Address\n    rightAddress: Address\n    rightNft: NFTItem[]\n    leftNft: NFTItem[]\n    supervisorAddress: Address\n    commissionAddress: Address\n    leftCommission: bigint\n    leftAmount: bigint\n    leftCoinsGot: bigint\n    rightCommission: bigint\n    rightAmount: bigint\n    rightCoinsGot: bigint\n}\n\n/**\n * Class representing an NFT Swap, implementing the Contract interface.\n */", "export class NftSwap implements Contract {\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECDAEAAqAAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAP10A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEwthGmP6Z+lVW8Q4AHxgRDAgRXdFOAA2CnT44LYTwhWL4ZqGGhpg+oYAP2AcBRgAPloyhJrpOEBWfGBHByUYABOGxuIHCOyiiGYOHgC8BRgAMCwoJAC6SXwvgCMACmFVEECQQI/AF4F8KhA/y8ACAMDM5OVNSxwWSXwngUVHHBfLh9IIQBRONkRW68uH1BPpAMEBmBXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVADYMTc4OYIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxXLPyfPFifPFhTKACP6AhPKAMmAQPsAcVBmRRUEcAfIywAWyx9QBM8WWM8WAc8WAfoCzMsAye1UM/Vflw==', 'base64'))[0]\n\n    static buildDataCell(data: SwapData) {\n        const dataCell = beginCell()\n        dataCell.storeUint(data.state, 2)\n        dataCell.storeAddress(data.leftAddress)\n        dataCell.storeAddress(data.rightAddress)\n\n        dataCell.storeCoins(data.leftCommission)\n        dataCell.storeCoins(data.leftAmount)\n        dataCell.storeCoins(data.leftCoinsGot)\n        dataCell.storeBit(data.leftNft.length > 0)\n", "        if (data.leftNft.length > 0) {\n            const leftNft = Dictionary.empty(\n                Dictionary.Keys.BigUint(256)\n            )\n            \n            for (const leftNftKey in data.leftNft) {\n                const bitCell = beginCell()\n                bitCell.storeBit(data.leftNft[leftNftKey].sent)\n\n                leftNft.store(bitCell)\n            }\n            dataCell.storeDict(leftNft)\n        }\n\n        dataCell.storeCoins(data.rightCommission)\n        dataCell.storeCoins(data.rightAmount)\n        dataCell.storeCoins(data.rightCoinsGot)\n        dataCell.storeBit(data.rightNft.length > 0)\n", "        if (data.rightNft.length > 0) {\n            const rightNft = Dictionary.empty(\n                Dictionary.Keys.BigUint(256)\n            )\n            \n            for (const rightNftKey in data.rightNft) {\n                const bitCell = beginCell()\n                bitCell.storeBit(data.rightNft[rightNftKey].sent)\n\n                rightNft.store(bitCell)\n            }\n            dataCell.storeDict(rightNft)\n        }\n\n        const marketCell = beginCell()\n        marketCell.storeAddress(data.commissionAddress)\n        marketCell.storeAddress(data.supervisorAddress)\n        dataCell.storeRef(marketCell)\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Method to create a new NftSwap instance from an address.\n     * @param address - The address of the swap.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftSwap(\n            address\n        )\n    }\n\n    /**\n     * Method to create a new NftSwap instance from a configuration.\n     * @param config - The configuration of the swap.\n     * @param workchain - The workchain of the swap.\n     */\n    static async createFromConfig(\n        config: SwapData,\n        workchain = 0\n    ) {\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftSwap(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Method to send a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value sent with the deploy command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a cancel command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the cancel command.\n     * @param params - Parameters for the cancel command including value and optional queryId.\n     */\n    async sendCancel(provider: ContractProvider, via: Sender, params: { \n        value: bigint,\n        queryId?: number\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.cancel, 32)\n                .storeUint(params.queryId || 0, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends an addCoins command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the addCoins command.\n     * @param params - Parameters for the addCoins command including value, optional queryId, and coins.\n     */\n    async sendAddCoins(provider: ContractProvider, via: Sender, params: { \n        value: bigint,\n        queryId?: number,\n        coins: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.addCoins, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeCoins(params.coins)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a maintain command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the maintain command.\n     * @param params - Parameters for the maintain command including value, optional queryId, mode, and msg.\n     */\n    async sendMaintain(\n        provider: ContractProvider,\n        via: Sender,\n        params: {\n            value: bigint,\n            queryId?: number,\n            mode: number,\n            msg: Cell\n        }\n    ) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.maintain, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeUint(params.mode, 8)\n                .storeRef(params.msg)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a topup command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the topup command.\n     * @param params - Parameters for the topup command including value and optional queryId.\n     */\n    async sendTopup(provider: ContractProvider, via: Sender, params: { \n        value: bigint,\n        queryId?: number \n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.topup, 32)\n                .storeUint(params.queryId || 0, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Gets the current state of the trade from the contract.\n     * @param provider - The contract provider.\n     * @returns An object representing the current state of the trade.\n     */\n    async getTradeState(\n        provider: ContractProvider\n    ) {\n        const { stack } = await provider.get('get_trade_state', [])\n        return {\n            state: stack.readBigNumber() ?? 0, \n            left_ok: !(stack.readBigNumber().toString() == '0'), \n            right_ok: !(stack.readBigNumber().toString() == '0'), \n            leftAddress: stack.readAddressOpt(), \n            rightAddress: stack.readAddressOpt(), \n            leftNft: stack.readCell(), \n            rightNft: stack.readCell(),\n            leftComm: stack.readBigNumber(), \n            leftAmount: stack.readBigNumber(), \n            leftGot: stack.readBigNumber(), \n            rightComm: stack.readBigNumber(), \n            rightAmount: stack.readBigNumber(), \n            rightGot: stack.readBigNumber()\n        }\n    }\n\n    /**\n     * Gets the supervisor of the contract.\n     * @param provider - The contract provider.\n     * @returns An object representing the supervisor.\n     */\n    async getSupervisor(\n        provider: ContractProvider\n    ) {\n        const { stack } = await provider.get('get_supervisor', [])\n        return {\n            supervisor: stack.readAddressOpt()\n        }\n    }   \n}"]}
{"filename": "src/wrappers/getgems/NftFixedPriceV2/NftFixedPriceV2.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\n/**\n * Class representing a NFT fixed price sale contract (Version 2).\n */\nexport class NftFixedPriceV2 implements Contract {\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECDAEAAikAART/APSkE/S88sgLAQIBIAMCAATyMAIBSAUEAFGgOFnaiaGmAaY/9IH0gfSB9AGoYaH0gfQB9IH0AGEEIIySsKAVgAKrAQICzQgGAfdmCEDuaygBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkHCAEMjLBVADzxYB+gLLaslx+wAlwgAl10nCArCOF1BFcIAQyMsFUAPPFgH6AstqyXH7ABAjkjQ04lpwgBDIywVQA88WAfoCy2rJcfsAcCCCEF/MPRSBwCCIYAYyMsFKs8WIfoCy2rLHxPLPyPPFlADzxbKACH6AsoAyYMG+wBxVVAGyMsAFcsfUAPPFgHPFgHPFgH6AszJ7VQC99AOhpgYC42EkvgnB9IBh2omhpgGmP/SB9IH0gfQBqGBNgAPloyhFrpOEBWccgGRwcKaDjgskvhHAoomOC+XD6AmmPwQgCicbIiV15cPrpn5j9IBggKwNkZYAK5Y+oAeeLAOeLAOeLAP0BZmT2qnAbE+OAcYED6Y/pn5gQwLCQFKwAGSXwvgIcACnzEQSRA4R2AQJRAkECPwBeA6wAPjAl8JhA/y8AoAyoIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxnLPyfPFifPFhjKACf6AhfKAMmAQPsAcQZQREUVBsjLABXLH1ADzxYBzxYBzxYB+gLMye1UABY3EDhHZRRDMHDwBTThaBI=', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT fixed price sale.\n     * @param data - The data for the NFT sale.\n     * @returns A cell containing the data for the NFT sale.\n     */\n    static buildDataCell(data: NftFixPriceSaleV2Data) {\n\n        const feesCell = beginCell()\n    \n        feesCell.storeAddress(data.marketplaceFeeAddress)\n        feesCell.storeCoins(data.marketplaceFee)\n        feesCell.storeAddress(data.royaltyAddress)\n        feesCell.storeCoins(data.royaltyAmount)\n    \n        const dataCell = beginCell()\n    \n        dataCell.storeUint(data.isComplete ? 1 : 0, 1)\n        dataCell.storeUint(data.createdAt, 32)\n        dataCell.storeAddress(data.marketplaceAddress)\n        dataCell.storeAddress(data.nftAddress)\n        dataCell.storeAddress(data.nftOwnerAddress)\n        dataCell.storeCoins(data.fullPrice)\n        dataCell.storeRef(feesCell)\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftFixedPriceV2 instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftFixedPriceV2 instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftFixedPriceV2(\n            address\n        )\n    }\n\n    /**\n     * Creates an NftFixedPriceV2 instance from a configuration object.\n     * @param config - The configuration data for the NFT sale.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new NftFixedPriceV2 instance.\n     */\n    static async createFromConfig(\n        config: NftFixPriceSaleV2Data,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftFixedPriceV2(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends coins to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the coins.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendCoins(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(1, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a command to cancel the sale.\n     * @param provider - The contract provider.\n     * @param via - The sender of the command.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendCancelSale(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(3, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a command to buy the NFT.\n     * @param provider - The contract provider.\n     * @param via - The sender of the command.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendBuy(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell().\n                storeUint(params.queryId || 0, 32).\n                endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the sale data from the contract.\n     * @param provider - The contract provider.\n     * @returns An object containing the sale data.\n     */\n    async getSaleData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_sale_data', [])\n\n        // pops out saleType\n        stack.pop()\n        \n        return {\n            isComplete: stack.readBigNumber(),\n            createdAt: stack.readBigNumber(),\n            marketplaceAddress: stack.readAddressOpt(),\n            nftAddress: stack.readAddressOpt(),\n            nftOwnerAddress: stack.readAddressOpt(),\n            fullPrice: stack.readBigNumber(),\n            marketplaceFeeAddress: stack.readAddressOpt(),\n            marketplaceFee: stack.readBigNumber(),\n            royaltyAddress: stack.readAddressOpt(),\n            royaltyAmount:  stack.readBigNumber()\n        }\n    }\n}\n\n/**\n * Type definition for the data of an NFT fixed price sale, version 2.\n */", "export type NftFixPriceSaleV2Data = {\n    isComplete: boolean\n    createdAt: number\n    marketplaceAddress: Address\n    nftAddress: Address\n    nftOwnerAddress: Address|null\n    fullPrice: bigint\n    marketplaceFeeAddress: Address\n    marketplaceFee: bigint\n    royaltyAddress: Address\n    royaltyAmount: bigint\n}"]}
{"filename": "src/wrappers/getgems/NftItem/NftItem.ts", "chunked_list": ["import { Address, beginCell, Cell, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\nimport { NftItemRoyalty } from '../../standard/NftItemRoyalty'\n\n/**\n* Class representing a Non-Fungible Token (NFT) Item.\n* This class extends the NftItemRoyalty class.\n*/\nexport class NftItem extends NftItemRoyalty {\n    static code = Cell.fromBoc(Buffer.from('te6cckECDQEAAdAAART/APSkE/S88sgLAQIBYgMCAAmhH5/gBQICzgcEAgEgBgUAHQDyMs/WM8WAc8WzMntVIAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAgEgCQgAET6RDBwuvLhTYALXDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAw8AIEs44UMGwiNFIyxwXy4ZUB+kDUMBAj8APgBtMf0z+CEF/MPRRSMLqOhzIQN14yQBPgMDQ0NTWCEC/LJqISuuMCXwSED/LwgCwoAcnCCEIt3FzUFyMv/UATPFhAkgEBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAH2UTXHBfLhkfpAIfAB+kDSADH6AIIK+vCAG6EhlFMVoKHeItcLAcMAIJIGoZE24iDC//LhkiGOPoIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHlBAqN1viDACCAo41JvABghDVMnbbEDdEAG1xcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wCTMDI04lUC8ANqhGIu', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT item.\n     * @param data - The data for the NFT item.\n     * @returns A cell containing the data for the NFT item.\n     */\n    static buildDataCell(data: NftItemData) {\n        const dataCell = beginCell()\n    \n        const contentCell = beginCell()\n        // contentCell.bits.writeString(data.content)\n        contentCell.storeBuffer(Buffer.from(data.content))\n    \n        dataCell.storeUint(data.index, 64)\n        dataCell.storeAddress(data.collectionAddress)\n        dataCell.storeAddress(data.ownerAddress)\n        dataCell.storeRef(contentCell)\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftItem instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftItem instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftItem(\n            address\n        )\n    }\n\n    /**\n     * Creates an NftItem instance from a configuration object.\n     * @param config - The configuration data for the NFT item.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new NftItem instance.\n     */\n    static async createFromConfig(\n        config: NftItemData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftItem(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a command to transfer editorship of the NFT item.\n     * @param provider - The contract provider.\n     * @param via - The sender of the command.\n     * @param params - Parameters for the operation, including the value, queryId, new editor address, response address, and forward amount.\n     */\n    async sendTransferEditorship(provider: ContractProvider, via: Sender, params: { \n        value: bigint, \n        queryId?: number,\n        newEditor: Address, \n        responseTo: Address|null,\n        forwardAmount?: bigint \n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x1c04412a, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeAddress(params.newEditor)\n                .storeAddress(params.responseTo)\n                .storeBit(false)\n                .storeCoins(params.forwardAmount || 0)\n                .storeBit(false)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n}\n\n/**\n * Type definition for the data of an NFT item.\n */", "export type NftItemData = {\n    index: number\n    collectionAddress: Address | null\n    ownerAddress: Address\n    content: string\n}"]}
{"filename": "src/wrappers/getgems/NftFixedPriceV3/NftFixedPriceV3.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\n/**\n * Class representing a NFT fixed price sale contract V3\n */\nexport class NftFixedPriceV3 implements Contract {\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECDAEAAqAAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAP10A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEwthGmP6Z+lVW8Q4AHxgRDAgRXdFOAA2CnT44LYTwhWL4ZqGGhpg+oYAP2AcBRgAPloyhJrpOEBWfGBHByUYABOGxuIHCOyiiGYOHgC8BRgAMCwoJAC6SXwvgCMACmFVEECQQI/AF4F8KhA/y8ACAMDM5OVNSxwWSXwngUVHHBfLh9IIQBRONkRW68uH1BPpAMEBmBXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVADYMTc4OYIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxXLPyfPFifPFhTKACP6AhPKAMmAQPsAcVBmRRUEcAfIywAWyx9QBM8WWM8WAc8WAfoCzMsAye1UM/Vflw==', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT fixed price sale.\n     * @param data - The data for the NFT sale.\n     * @returns A cell containing the data for the NFT sale.\n     */\n    static buildDataCell(data: NftFixPriceSaleV3Data) {\n        const feesCell = beginCell()\n    \n        feesCell.storeAddress(data.marketplaceFeeAddress)\n        feesCell.storeCoins(data.marketplaceFee)\n        feesCell.storeAddress(data.royaltyAddress)\n        feesCell.storeCoins(data.royaltyAmount)\n    \n        const dataCell = beginCell()\n    \n        dataCell.storeUint(data.isComplete ? 1 : 0, 1)\n        dataCell.storeUint(data.createdAt, 32)\n        dataCell.storeAddress(data.marketplaceAddress)\n        dataCell.storeAddress(data.nftAddress)\n        dataCell.storeAddress(data.nftOwnerAddress)\n        dataCell.storeCoins(data.fullPrice)\n        dataCell.storeRef(feesCell)\n        dataCell.storeUint(data.canDeployByExternal ? 1 : 0, 1) // can_deploy_by_external\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftFixedPriceV3 instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftFixedPriceV3 instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftFixedPriceV3(\n            address\n        )\n    }\n\n    /**\n     * Creates an NftFixedPriceV3 instance from a configuration object.\n     * @param config - The configuration data for the NFT sale.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new NftFixedPriceV3 instance.\n     */\n    static async createFromConfig(\n        config: NftFixPriceSaleV3Data,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftFixedPriceV3(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends coins to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the coins.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendCoins(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(1, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a command to cancel the sale.\n     * @param provider - The contract provider.\n     * @param via - The sender of the command.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendCancelSale(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(3, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a command to buy the NFT.\n     * @param provider - The contract provider.\n     * @param via - The sender of the command.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendBuy(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell().endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the sale data from the contract.\n     * @param provider - The contract provider.\n     * @returns An object containing the sale data.\n     */\n    async getSaleData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_sale_data', [])\n\n        // pops out saleType\n        stack.pop()\n\n        return {\n            // saleType: stack.readBigNumber(),\n            isComplete: stack.readBigNumber(),\n            createdAt: stack.readBigNumber(),\n            marketplaceAddress: stack.readAddressOpt(),\n            nftAddress: stack.readAddressOpt(),\n            nftOwnerAddress: stack.readAddressOpt(),\n            fullPrice: stack.readBigNumber(),\n            marketplaceFeeAddress: stack.readAddressOpt(),\n            marketplaceFee: stack.readBigNumber(),\n            royaltyAddress: stack.readAddressOpt(),\n            royaltyAmount:  stack.readBigNumber()\n        }\n    }\n}\n\n/**\n * Type definition for the data of an NFT fixed price sale.\n */", "export type NftFixPriceSaleV3Data = {\n    isComplete: boolean\n    createdAt: number\n    marketplaceAddress: Address\n    nftAddress: Address\n    nftOwnerAddress: Address | null\n    fullPrice: bigint\n    marketplaceFeeAddress: Address\n    marketplaceFee: bigint\n    royaltyAddress: Address\n    royaltyAmount: bigint\n    canDeployByExternal?: boolean\n  }\n  "]}
{"filename": "src/wrappers/getgems/NftCollection/NftCollection.ts", "chunked_list": ["import { Address, beginCell, Cell, ContractProvider, Transaction, Sender, SendMode, contractAddress, ExternalAddress } from 'ton-core'\nimport { storeOffchainContent } from '../../../types/Content'\nimport { NftCollectionRoyalty } from '../../standard/NftCollectionRoyalty'\nimport { isEligibleTransaction } from '../../../utils/EligibleInternalTx'\nimport { Maybe } from 'ton-core/dist/utils/maybe'\n\nexport type CollectionMintItemInput = {\n    passAmount: bigint\n    index: number\n    ownerAddress: Address\n    content: string\n}\n", "export type RoyaltyParams = {\n    royaltyFactor: number\n    royaltyBase: number\n    royaltyAddress: Address\n}\n\nexport const OperationCodes = {\n    Mint: 1,\n    BatchMint: 2,\n    ChangeOwner: 3,\n    EditContent: 4,\n    GetRoyaltyParams: 0x693d3950,\n    GetRoyaltyParamsResponse: 0xa8cb00ad\n}\n\n/**\n * Class representing a Non-Fungible Token (NFT) collection contract.", " * This class extends from the `NftCollectionRoyalty` class.\n */\nexport class NftCollection extends NftCollectionRoyalty {\n    static code = Cell.fromBoc(Buffer.from('te6cckECFAEAAh8AART/APSkE/S88sgLAQIBYgkCAgEgBAMAJbyC32omh9IGmf6mpqGC3oahgsQCASAIBQIBIAcGAC209H2omh9IGmf6mpqGAovgngCOAD4AsAAvtdr9qJofSBpn+pqahg2IOhph+mH/SAYQAEO4tdMe1E0PpA0z/U1NQwECRfBNDUMdQw0HHIywcBzxbMyYAgLNDwoCASAMCwA9Ra8ARwIfAFd4AYyMsFWM8WUAT6AhPLaxLMzMlx+wCAIBIA4NABs+QB0yMsCEsoHy//J0IAAtAHIyz/4KM8WyXAgyMsBE/QA9ADLAMmAE59EGOASK3wAOhpgYC42Eit8H0gGADpj+mf9qJofSBpn+pqahhBCDSenKgpQF1HFBuvgoDoQQhUZYBWuEAIZGWCqALnixJ9AQpltQnlj+WfgOeLZMAgfYBwGyi544L5cMiS4ADxgRLgAXGBEuAB8YEYGYHgAkExIREAA8jhXU1DAQNEEwyFAFzxYTyz/MzMzJ7VTgXwSED/LwACwyNAH6QDBBRMhQBc8WE8s/zMzMye1UAKY1cAPUMI43gED0lm+lII4pBqQggQD6vpPywY/egQGTIaBTJbvy9AL6ANQwIlRLMPAGI7qTAqQC3gSSbCHis+YwMlBEQxPIUAXPFhPLP8zMzMntVABgNQLTP1MTu/LhklMTugH6ANQwKBA0WfAGjhIBpENDyFAFzxYTyz/MzMzJ7VSSXwXiN0CayQ==', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT collection.\n     * @param data - The data for the NFT collection.\n     * @returns A cell containing the data for the NFT collection.\n     */\n    static buildDataCell(data: NftCollectionData) {\n        const dataCell = beginCell()\n\n        dataCell.storeAddress(data.ownerAddress)\n        dataCell.storeUint(data.nextItemIndex, 64)\n\n        const contentCell = beginCell()\n\n        const collectionContent = storeOffchainContent({\n            type: 'offchain',\n            uri: data.collectionContent\n        })\n\n        const commonContent = beginCell()\n        commonContent.storeBuffer(Buffer.from(data.commonContent))\n\n        contentCell.store(collectionContent)\n        contentCell.storeRef(commonContent)\n        dataCell.storeRef(contentCell)\n\n        dataCell.storeRef(data.nftItemCode)\n\n        const royaltyCell = beginCell()\n        royaltyCell.storeUint(data.royaltyParams.royaltyFactor, 16)\n        royaltyCell.storeUint(data.royaltyParams.royaltyBase, 16)\n        royaltyCell.storeAddress(data.royaltyParams.royaltyAddress)\n        dataCell.storeRef(royaltyCell)\n\n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an `NftCollection` instance from an address.\n     * @param address - The address to create from.\n     * @returns A new `NftCollection` instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftCollection(\n            address\n        )\n    }\n\n    /**\n     * Creates an `NftCollection` instance from a configuration object.\n     * @param config - The configuration data for the NFT collection.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new `NftCollection` instance.\n     */\n    static async createFromConfig(\n        config: NftCollectionData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftCollection(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a mint command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the mint command.\n     * @param params - The parameters for the mint command.\n     */\n    async sendMint(provider: ContractProvider, via: Sender, params: { \n        queryId?: number, \n        value: bigint,\n        passAmount: bigint, \n        itemIndex: number, \n        itemOwnerAddress: Address, \n        itemContent: string \n    }) {\n        const itemContent = beginCell()\n        // itemContent.bits.writeString(params.itemContent)\n        itemContent.storeBuffer(Buffer.from(params.itemContent)).endCell()\n\n        const nftItemMessage = beginCell()\n\n        nftItemMessage.storeAddress(params.itemOwnerAddress)\n        nftItemMessage.storeRef(itemContent).endCell()\n\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(1, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeUint(params.itemIndex, 64)\n                .storeCoins(params.passAmount)\n                .storeRef(nftItemMessage)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a change owner command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the change owner command.\n     * @param params - The parameters for the change owner command.\n     */\n    async sendChangeOwner(provider: ContractProvider, via: Sender, params: { \n        queryId?: number, \n        value: bigint,\n        newOwner: Address\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.ChangeOwner, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeAddress(params.newOwner)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY\n        })\n    }\n\n    /**\n     * Parses a mint transaction.\n     * @param tx - The transaction to parse.\n     * @returns The parsed mint transaction, or undefined if parsing failed.\n     */\n    static parseMint(tx: Transaction): NftMint | undefined {", "        try {\n            const body = tx.inMessage?.body.beginParse()\n\n            if (body === undefined) return undefined \n\n            const op = body.loadUint(32)\n            \n            if (op !== 1) return undefined \n\n\n            if (!isEligibleTransaction(tx)) {\n                return undefined\n            }\n\n            return {\n                queryId: body.loadUint(64),\n                from: tx.inMessage?.info.src ?? undefined,\n                to: tx.inMessage?.info.dest ?? undefined,\n                itemIndex: body.loadUint(64),\n                passAmount: body.loadCoins(),\n                nftItemMessage: body.loadRef()\n            }", "            if (!isEligibleTransaction(tx)) {\n                return undefined\n            }\n\n            return {\n                queryId: body.loadUint(64),\n                from: tx.inMessage?.info.src ?? undefined,\n                to: tx.inMessage?.info.dest ?? undefined,\n                itemIndex: body.loadUint(64),\n                passAmount: body.loadCoins(),\n                nftItemMessage: body.loadRef()\n            }", "        } catch (e) { /* empty */ }\n        return undefined\n    }\n\n\n    /**\n     * Parses an ownership transfer transaction.\n     * @param tx - The transaction to parse.\n     * @returns The parsed ownership transfer transaction, or undefined if parsing failed.\n     */\n    static parseOwnershipTransfer(tx: Transaction): OwnershipTransfer | undefined {", "        try {\n            const body = tx.inMessage?.body.beginParse()\n\n            if (body === undefined) return undefined \n\n            const op = body.loadUint(32)\n            \n            if (op !== 3) return undefined \n\n            if (!isEligibleTransaction(tx)) {\n                return undefined\n            }\n\n            return {\n                queryId: body.loadUint(64),\n                oldOwner: tx.inMessage?.info.src ?? undefined,\n                newOwner: body.loadAddress()\n            }", "            if (!isEligibleTransaction(tx)) {\n                return undefined\n            }\n\n            return {\n                queryId: body.loadUint(64),\n                oldOwner: tx.inMessage?.info.src ?? undefined,\n                newOwner: body.loadAddress()\n            }\n        } catch (e) { /* empty */ }\n\n        return undefined\n    }\n}\n\n/**\n * Type definition for the data of an NFT collection.\n */", "        } catch (e) { /* empty */ }\n\n        return undefined\n    }\n}\n\n/**\n * Type definition for the data of an NFT collection.\n */\nexport type NftCollectionData = {\n    ownerAddress: Address,\n    nextItemIndex: number | bigint\n    collectionContent: string\n    commonContent: string\n    nftItemCode: Cell\n    royaltyParams: RoyaltyParams\n}\n\n/**\n * Type definition for the data of an NFT mint transaction.\n */", "export type NftCollectionData = {\n    ownerAddress: Address,\n    nextItemIndex: number | bigint\n    collectionContent: string\n    commonContent: string\n    nftItemCode: Cell\n    royaltyParams: RoyaltyParams\n}\n\n/**\n * Type definition for the data of an NFT mint transaction.\n */", "export type NftMint = {\n    queryId: number\n    from?: Address | Maybe<ExternalAddress>\n    to?: Address | Maybe<ExternalAddress>\n    itemIndex: number\n    passAmount: bigint\n    nftItemMessage: Cell\n}\n\n/**\n * Type definition for the data of an ownership transfer transaction.\n */", "export type OwnershipTransfer = {\n    queryId: number\n    oldOwner?: Address | Maybe<ExternalAddress>\n    newOwner: Address\n}"]}
{"filename": "src/wrappers/getgems/NftCollectionEditable/NftCollectionEditable.ts", "chunked_list": ["import { Address, beginCell, ContractProvider, Sender, SendMode } from 'ton-core'\nimport { NftCollectionRoyalty } from '../../standard/NftCollectionRoyalty'\n\nexport type CollectionMintItemInput = {\n    passAmount: bigint\n    index: number\n    ownerAddress: Address\n    content: string\n}\n\nexport type RoyaltyParams = {\n    royaltyFactor: number\n    royaltyBase: number\n    royaltyAddress: Address\n}\n\nconst OperationCodes = {\n    Mint: 1,\n    BatchMint: 2,\n    ChangeOwner: 3,\n    EditContent: 4,\n    GetRoyaltyParams: 0x693d3950,\n    GetRoyaltyParamsResponse: 0xa8cb00ad\n}\n\n/**\n * Class representing an editable Non-Fungible Token (NFT) collection contract.", "export type RoyaltyParams = {\n    royaltyFactor: number\n    royaltyBase: number\n    royaltyAddress: Address\n}\n\nconst OperationCodes = {\n    Mint: 1,\n    BatchMint: 2,\n    ChangeOwner: 3,\n    EditContent: 4,\n    GetRoyaltyParams: 0x693d3950,\n    GetRoyaltyParamsResponse: 0xa8cb00ad\n}\n\n/**\n * Class representing an editable Non-Fungible Token (NFT) collection contract.", " * This class extends from the `NftCollectionRoyalty` class.\n */\nexport class NftCollectionEditable extends NftCollectionRoyalty {\n    /**\n     * Creates an `NftCollectionEditable` instance from an address.\n     * @param address - The address to create from.\n     * @returns A new `NftCollectionEditable` instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftCollectionEditable(\n            address\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a mint command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the mint command.\n     * @param params - The parameters for the mint command.\n     */\n    async sendMint(provider: ContractProvider, via: Sender, params: { \n        queryId?: number, \n        value: bigint,\n        passAmount: bigint, \n        itemIndex: number, \n        itemOwnerAddress: Address, \n        itemContent: string \n    }) {\n        const itemContent = beginCell()\n        itemContent.storeBuffer(Buffer.from(params.itemContent)).endCell()\n\n        const nftItemMessage = beginCell()\n\n        nftItemMessage.storeAddress(params.itemOwnerAddress)\n        nftItemMessage.storeRef(itemContent).endCell()\n\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(1, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeUint(params.itemIndex, 64)\n                .storeCoins(params.passAmount)\n                .storeRef(nftItemMessage)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Sends a change owner command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the change owner command.\n     * @param params - The parameters for the change owner command.\n     */\n    async sendChangeOwner(provider: ContractProvider, via: Sender, params: { \n        queryId?: number, \n        value: bigint,\n        newOwner: Address\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(OperationCodes.ChangeOwner, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeAddress(params.newOwner)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY\n        })\n    }\n}\n"]}
{"filename": "src/wrappers/getgems/NftAuctionV2/NftAuctionV2.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\n/**\n * Class representing an NFT auction contract version 2.\n */\nexport class NftAuctionV2 implements Contract {\n    /**\n     * Creates an `NftAuctionV2` instance from an address and initialization data.\n     * @param address - The address of the contract.\n     * @param init - The initialization data.\n     * @returns A new `NftAuctionV2` instance.\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECHQEABZMAART/APSkE/S88sgLAQIBIAIDAgFIBAUCKPIw2zyBA+74RMD/8vL4AH/4ZNs8GxwCAs4GBwKLoDhZtnm2eQQQgqqH8IXwofCH8KfwpfCd8JvwmfCX8JXwi/Cf8IwaIiYaGCIkGBYiIhYUIiAUIT4hHCD6INggtiD0INIgsRsaAgEgCAkCASAYGQT1AHQ0wMBcbDyQPpAMNs8+ELA//hDUiDHBbCO0DMx0x8hwACNBJyZXBlYXRfZW5kX2F1Y3Rpb26BSIMcFsI6DW9s84DLAAI0EWVtZXJnZW5jeV9tZXNzYWdlgUiDHBbCa1DDQ0wfUMAH7AOAw4PhTUhDHBY6EMzHbPOABgGxIKCwATIIQO5rKAAGphIAFcMYED6fhS10nCAvLygQPqAdMfghAFE42REroS8vSAQNch+kAw+HJw+GJ/+GTbPBwEhts8IMABjzgwgQPt+CP4UL7y8oED7fhCwP/y8oED8AKCEDuaygC5EvLy+FJSEMcF+ENSIMcFsfLhkwF/2zzbPOAgwAIMFQ0OAIwgxwDA/5IwcODTHzGLZjYW5jZWyCHHBZIwceCLRzdG9wghxwWSMHLgi2ZmluaXNoghxwWSMHLgi2ZGVwbG95gBxwWRc+BwAYpwIPglghBfzD0UyMsfyz/4Us8WUAPPFhLLACH6AssAyXGAGMjLBfhTzxZw+gLLasyCCA9CQHD7AsmDBvsAf/hif/hm2zwcBPyOwzAygQPt+ELA//LygQPwAYIQO5rKALny8vgj+FC+jhf4UlIQxwX4Q1IgxwWx+E1SIMcFsfLhk5n4UlIQxwXy4ZPi2zzgwAOSXwPg+ELA//gj+FC+sZdfA4ED7fLw4PhLghA7msoAoFIgvvhLwgCw4wL4UPhRofgjueMA+E4SDxARAiwCcNs8IfhtghA7msoAofhu+CP4b9s8FRIADvhQ+FGg+HADcI6VMoED6PhKUiC58vL4bvht+CP4b9s84fhO+EygUiC5l18DgQPo8vDgAnDbPAH4bfhu+CP4b9s8HBUcApT4TsAAjj1wIPglghBfzD0UyMsfyz/4Us8WUAPPFhLLACH6AssAyXGAGMjLBfhTzxZw+gLLasyCCA9CQHD7AsmDBvsA4w5/+GLbPBMcAvrbPPhOQFTwAyDCAI4rcCCAEMjLBVAHzxYi+gIWy2oVyx+L9NYXJrZXRwbGFjZSBmZWWM8WyXL7AJE04vhOQAPwAyDCAI4jcCCAEMjLBVAEzxYi+gITy2oSyx+LdSb3lhbHR5jPFsly+wCRMeKCCA9CQHD7AvhOWKEBoSDCABoUAMCOInAggBDIywX4Us8WUAP6AhLLassfi2UHJvZml0jPFsly+wCRMOJwIPglghBfzD0UyMsfyz/4Tc8WUAPPFhLLAIIImJaA+gLLAMlxgBjIywX4U88WcPoCy2rMyYMG+wAC8vhOwQGRW+D4TvhHoSKCCJiWgKFSELyZMAGCCJiWgKEBkTLijQpWW91ciBiaWQgaGFzIGJlZW4gb3V0YmlkIGJ5IGFub3RoZXIgdXNlci6ABwP+OHzCNBtBdWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZC6DeIcIA4w8WFwA4cCCAGMjLBfhNzxZQBPoCE8tqEssfAc8WyXL7AAACWwARIIQO5rKAKmEgAB0IMAAk18DcOBZ8AIB8AGAAIPhI0PpA0x/TH/pA0x/THzAAyvhBbt3tRNDSAAH4YtIAAfhk0gAB+Gb6QAH4bfoAAfhu0x8B+G/THwH4cPpAAfhy1AH4aNQw+Gn4SdDSHwH4Z/pAAfhj+gAB+Gr6AAH4a/oAAfhs0x8B+HH6QAH4c9MfMPhlf/hhAFT4SfhI+FD4T/hG+ET4QsjKAMoAygD4Tc8W+E76Assfyx/4Us8WzMzJ7VQBqlR8', 'base64'))[0]\n\n    /**\n     * Builds the data cell for the auction contract.\n     * @param data - The data for building the data cell.\n     * @returns The built data cell.\n     */\n    static buildDataCell(data: NftAuctionV2Data) {\n\n        const constantCell = beginCell()\n        const subGasPriceFromBid = 8449000\n        constantCell.storeUint(subGasPriceFromBid, 32)\n        constantCell.storeAddress(data.marketplaceAddress)\n        constantCell.storeCoins(data.minBid)\n        constantCell.storeCoins(data.maxBid)\n        constantCell.storeCoins(data.minStep)\n        constantCell.storeUint(data.stepTimeSeconds, 32) // step_time\n        constantCell.storeAddress(data.nftAddress)\n        constantCell.storeUint(data.createdAtTimestamp, 32)\n\n        const feesCell = beginCell()\n        feesCell.storeAddress(data.marketplaceFeeAddress)      // mp_fee_addr\n        feesCell.storeUint(data.marketplaceFeeFactor, 32)               // mp_fee_factor\n        feesCell.storeUint(data.marketplaceFeeBase, 32)   // mp_fee_base\n        feesCell.storeAddress(data.royaltyAddress)  // royalty_fee_addr\n        feesCell.storeUint(data.royaltyFactor, 32)              // royalty_fee_factor\n        feesCell.storeUint(data.royaltyBase, 32)   // royalty_fee_base\n\n\n        const storage = beginCell()\n        storage.storeBit(data.end) // end?\n        storage.storeBit(data.activated) // activated\n        storage.storeBit(false) // is_canceled\n        storage.storeBuffer(Buffer.from([0, 0]))        // last_member\n        storage.storeCoins(0)       // last_bid\n        storage.storeUint(0, 32) // last_bid_at\n        storage.storeUint(data.endTimestamp, 32)    // end_time", "        if (data.nftOwnerAddress) {\n            storage.storeAddress(data.nftOwnerAddress)\n        } else {\n            storage.storeBuffer(Buffer.from([0, 0]))\n        }\n        storage.storeRef(feesCell.endCell())\n        storage.storeRef(constantCell.endCell())\n\n        return storage.endCell()\n    }\n\n    /**\n     * Creates an `NftAuctionV2` instance from an address.\n     * @param address - The address to create from.\n     * @returns A new `NftAuctionV2` instance.\n     */\n    static createFromAddress(\n        address: Address,\n    ) {\n        return new NftAuctionV2(\n            address\n        )\n    }\n\n    /**\n     * Creates an `NftAuctionV2` instance from configuration data.\n     * @param config - The configuration data for creating the instance.\n     * @param workchain - The workchain ID (default: 0).\n     * @returns A new `NftAuctionV2` instance.\n     */\n    static createFromConfig(\n        config: NftAuctionV2Data,\n        workchain = 0\n    ) {\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftAuctionV2(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a cancel command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the cancel command.\n     * @param params - The parameters for the cancel command.\n     */\n    async sendCancel(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0,32)\n                .storeBuffer(Buffer.from('cancel'))\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n    \n    /**\n     * Sends a stop command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the stop command.\n     * @param params - The parameters for the stop command.\n     */\n    async sendStop(provider: ContractProvider, via: Sender, params: { \n        value: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0,32)\n                .storeBuffer(Buffer.from('cancel'))\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the sale data from the contract.\n     * @param provider - The contract provider.\n     * @returns The sale data.\n     */\n    async getSaleData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_sale_data', [])\n\n        // pops out saleType\n        stack.pop()\n\n        return {\n            end: stack.readBigNumber(),\n            endTimestamp: stack.readBigNumber(),\n            marketplaceAddress: stack.readAddressOpt(),\n            nftAddress: stack.readAddressOpt(),\n            nftOwnerAddress: stack.readAddressOpt(),\n            lastBidAmount: stack.readBigNumber(),\n            lastBidAddress: stack.readAddressOpt(),\n            minStep: stack.readBigNumber(),\n            marketplaceFeeAddress: stack.readAddressOpt(),\n            marketplaceFeeFactor: stack.readBigNumber(), \n            marketplaceFeeBase: stack.readBigNumber(),\n            royaltyAddress: stack.readAddressOpt(),\n            royaltyFactor: stack.readBigNumber(), \n            royaltyBase: stack.readBigNumber(),\n            maxBid: stack.readBigNumber(),\n            minBid: stack.readBigNumber(),\n            createdAt: stack.readBigNumber(),\n            lastBidAt: stack.readBigNumber(),\n            isCanceled: stack.readBigNumber(),\n        }\n    }\n}\n\n/**\n * Type representing the data for an NFT auction contract version 2.\n */", "export type NftAuctionV2Data = {\n    marketplaceFeeAddress: Address,\n    marketplaceFeeFactor: bigint,\n    marketplaceFeeBase: bigint,\n\n\n    royaltyAddress: Address,\n    royaltyFactor: bigint,\n    royaltyBase: bigint,\n\n\n    minBid: bigint,\n    maxBid: bigint,\n    minStep: bigint,\n    endTimestamp: number,\n    createdAtTimestamp: number,\n\n    stepTimeSeconds: number,\n    tryStepTimeSeconds: number,\n\n    nftOwnerAddress: Address | null,\n    nftAddress: Address,\n\n    end: boolean,\n    marketplaceAddress: Address,\n    activated: boolean,\n\n}"]}
{"filename": "src/wrappers/getgems/NftSingle/NftSingle.ts", "chunked_list": ["import { Address, beginCell, Cell, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\nimport { NftItemRoyalty } from '../../standard/NftItemRoyalty'\nimport { storeOffchainContent } from '../../../types/Content'\n\n/**\n * Class representing a single Non-Fungible Token (NFT) with royalty.\n */\nexport class NftSingle extends NftItemRoyalty {   \n    // Data\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECFQEAAwoAART/APSkE/S88sgLAQIBYgcCAgEgBAMAI7x+f4ARgYuGRlgOS/uAFoICHAIBWAYFABG0Dp4AQgRr4HAAHbXa/gBNhjoaYfph/0gGEAICzgsIAgEgCgkAGzIUATPFljPFszMye1UgABU7UTQ+kD6QNTUMIAIBIA0MABE+kQwcLry4U2AEuQyIccAkl8D4NDTAwFxsJJfA+D6QPpAMfoAMXHXIfoAMfoAMPACBtMf0z+CEF/MPRRSMLqOhzIQRxA2QBXgghAvyyaiUjC64wKCEGk9OVBSMLrjAoIQHARBKlIwuoBMSEQ4BXI6HMhBHEDZAFeAxMjQ1NYIQGgudURK6n1ETxwXy4ZoB1NQwECPwA+BfBIQP8vAPAfZRNscF8uGR+kAh8AH6QNIAMfoAggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIY4+ghBRGkRjyFAKzxZQC88WcSRKFFRGsHCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAEFeUECo4W+IQAIICjjUm8AGCENUydtsQN0UAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AJMwMzTiVQLwAwBUFl8GMwHQEoIQqMsArXCAEMjLBVAFzxYk+gIUy2oTyx/LPwHPFsmAQPsAAIYWXwZsInDIywHJcIIQi3cXNSHIy/8D0BPPFhOAQHCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAAfZRN8cF8uGR+kAh8AH6QNIAMfoAggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIMIA8uGSIY4+ghAFE42RyFALzxZQC88WcSRLFFRGwHCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAEGeUECo5W+IUAIICjjUm8AGCENUydtsQN0YAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AJMwNDTiVQLwA+GNLv4=', 'base64'))[0]\n\n    /**\n     * Builds a data cell for the NFT.\n     * @param data - The data for the NFT.\n     * @returns The built data cell.\n     */\n    static buildDataCell(data: NftSingleData) {\n        const dataCell = beginCell()\n\n        const contentCell = storeOffchainContent({\n            type: 'offchain',\n            uri: data.content\n        })\n\n        const royaltyCell = beginCell()\n        royaltyCell.storeUint(data.royaltyParams.royaltyFactor, 16)\n        royaltyCell.storeUint(data.royaltyParams.royaltyBase, 16)\n        royaltyCell.storeAddress(data.royaltyParams.royaltyAddress)\n\n        dataCell.storeAddress(data.ownerAddress)\n        dataCell.storeAddress(data.editorAddress)\n        dataCell.store(contentCell)\n        dataCell.storeRef(royaltyCell)\n\n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftSingle instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftSingle instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftSingle(\n            address\n        )\n    }\n\n    /**\n    * Creates an NftSingle instance from a config.\n    * @param config - The config to create from.\n    * @param workchain - The workchain to use (default is 0).\n    * @returns A new NftSingle instance.\n    */\n    static async createFromConfig(\n        config: NftSingleData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftSingle(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends a transferEditorship command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the transferEditorship command.\n     * @param params - Parameters for the transferEditorship command including value, optional queryId, newEditor, responseTo, and optional forwardAmount.\n     */\n    async sendTransferEditorship(provider: ContractProvider, via: Sender, params: { \n        value: bigint, \n        queryId?: number,\n        newEditor: Address, \n        responseTo: Address|null,\n        forwardAmount?: bigint \n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x1c04412a, 32)\n                .storeUint(params.queryId || 0, 64)\n                .storeAddress(params.newEditor)\n                .storeAddress(params.responseTo)\n                .storeBit(false)\n                .storeCoins(params.forwardAmount || 0)\n                .storeBit(false)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n}\n\n/**\n * Represents the parameters for royalty.\n */", "export type RoyaltyParams = {\n    // Numerator of the royalty factor.\n    royaltyFactor: number,\n    // Denominator of the royalty factor.\n    royaltyBase: number,\n    // Address to send the royalty to.\n    royaltyAddress: Address\n}\n\n/**\n * Represents the data for a single NFT.\n */", "export type NftSingleData = {\n    // Address of the owner of the NFT.\n    ownerAddress: Address,\n    // Address of the editor of the NFT.\n    editorAddress: Address,\n    // Content of the NFT.\n    content: string,\n    // Royalty parameters for the NFT.\n    royaltyParams: RoyaltyParams\n}"]}
{"filename": "src/wrappers/getgems/NftFixedPrice/NftFixedPrice.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, contractAddress } from 'ton-core'\n\n/**\n * Class representing a Non-Fungible Token (NFT) fixed price sale contract.\n */\nexport class NftFixedPrice implements Contract {\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    static code = Cell.fromBoc(Buffer.from('te6cckECCgEAAbIAART/APSkE/S88sgLAQIBIAMCAATyMAIBSAUEADegOFnaiaH0gfSB9IH0AahhofQB9IH0gfQAYCBHAgLNCAYB99G8EIHc1lACkgUCkQX3lw4QFofQB9IH0gfQAYOEAIZGWCqATniyi6UJDQqFrQilAK/QEK5bVkuP2AOEAIZGWCrGeLKAP9AQtltWS4/YA4QAhkZYKsZ4ssfQFltWS4/YA4EEEIL+YeihDADGRlgqgC54sRfQEKZbUJ5Y+JwHAC7LPyPPFlADzxYSygAh+gLKAMmBAKD7AAH30A6GmBgLjYSS+CcH0gGHaiaH0gfSB9IH0AahgRa6ThAVnHHZkbGymQ44LJL4NwKJFjgvlw+gFpj8EIAonGyIldeXD66Z+Y/SAYIBpkKALniygB54sA54sA/QFmZPaqcBNjgEybCBsimYI4eAJwA2mP6Z+YEOAAyS+FcBDAkAtsACmjEQRxA2RUAS8ATgMjQ0NDXAA449ghA7msoAE77y4clwIIIQX8w9FCGAEMjLBVAHzxYi+gIWy2oVyx8Tyz8hzxYBzxYSygAh+gLKAMmBAKD7AOBfBIQP8vCVeDe4', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT fixed price sale.\n     * @param data - The data for the NFT sale.\n     * @returns A cell containing the data for the NFT sale.\n     */\n    static buildDataCell(data: NftFixPriceSaleData) {\n\n        const feesCell = beginCell()\n    \n        feesCell.storeCoins(data.marketplaceFee)\n        feesCell.storeAddress(data.marketplaceFeeAddress)\n        feesCell.storeAddress(data.royaltyAddress)\n        feesCell.storeCoins(data.royaltyAmount)\n    \n        const dataCell = beginCell()\n    \n        dataCell.storeAddress(data.marketplaceAddress)\n        dataCell.storeAddress(data.nftAddress)\n        dataCell.storeAddress(data.nftOwnerAddress)\n        dataCell.storeCoins(data.fullPrice)\n        dataCell.storeRef(feesCell)\n    \n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftFixedPrice instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftFixedPrice instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftFixedPrice(\n            address\n        )\n    }\n\n    /**\n     * Creates an NftFixedPrice instance from a configuration object.\n     * @param config - The configuration data for the NFT sale.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new NftFixedPrice instance.\n     */\n    static async createFromConfig(\n        config: NftFixPriceSaleData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftFixedPrice(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Retrieves the sale data from the contract.\n     * @param provider - The contract provider.\n     * @returns An object containing the sale data.\n     */\n    async getSaleData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_sale_data', [])\n        return {\n            marketplaceAddress: stack.readAddressOpt(),\n            nftAddress: stack.readAddressOpt(),\n            nftOwnerAddress: stack.readAddressOpt(),\n            fullPrice: stack.readBigNumber(),\n            marketplaceFeeAddress: stack.readAddressOpt(),\n            marketplaceFee: stack.readBigNumber(),\n            royaltyAddress: stack.readAddressOpt(),\n            royaltyAmount:  stack.readBigNumber()\n        }\n    }\n}\n\n/**\n * Type definition for the data of an NFT fixed price sale.\n */", "export type NftFixPriceSaleData = {\n    marketplaceAddress: Address\n    nftAddress: Address\n    nftOwnerAddress: Address|null\n    fullPrice: bigint\n    marketplaceFee: bigint\n    marketplaceFeeAddress: Address\n    royaltyAmount: bigint\n    royaltyAddress: Address\n}"]}
{"filename": "src/wrappers/getgems/NftMarketplace/NftMarketplace.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\nimport { KeyPair, sign } from 'ton-crypto'\n\n/**\n * Class representing a NFT Marketplace contract.\n */\nexport class NftMarketplace implements Contract {\n    /**\n     * Constructs an instance of the NftMarketplace contract.\n     * @param address - The address of the contract.\n     * @param init - The initial code and data for the contract.\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    /**\n     * Creates an NftMarketplace instance from an address.\n     * @param address - The address to create from.\n     * @returns A new NftMarketplace instance.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftMarketplace(\n            address\n        )\n    }\n\n    static code = Cell.fromBoc(Buffer.from('te6cckEBDAEA7wABFP8A9KQT9LzyyAsBAgEgAwIAePKDCNcYINMf0x/THwL4I7vyY/ABUTK68qFRRLryogT5AVQQVfkQ8qP4AJMg10qW0wfUAvsA6DABpALwAgIBSAcEAgFIBgUAEbjJftRNDXCx+AAXuznO1E0NM/MdcL/4AgLOCQgAF0AsjLH8sfy//J7VSAIBIAsKABU7UTQ0x/TH9P/MIACpGwiIMcAkVvgAdDTAzBxsJEw4PABbCEB0x8BwAGONIMI1xgg+QFAA/kQ8qPU1DAh+QBwyMoHy//J0Hd0gBjIywXLAljPFnD6AstrEszMyYBA+wDgW4NC26jQ=', 'base64'))[0]\n\n    /**\n     * Builds the data cell for an NFT marketplace.\n     * @param data - The data for the NFT marketplace.\n     * @returns A cell containing the data for the NFT marketplace.\n     */\n    static buildDataCell(data: NftMarketplaceData) {\n        const dataCell= beginCell()\n\n        dataCell.storeUint(data.seqno, 32)\n        dataCell.storeUint(data.subwallet, 32)\n        dataCell.storeBuffer(data.publicKey)\n\n        return dataCell.endCell()\n    }\n\n    /**\n     * Creates an NftMarketplace instance from a configuration object.\n     * @param config - The configuration data for the NFT marketplace.\n     * @param workchain - The workchain ID (default is 0).\n     * @returns A new NftMarketplace instance.\n     */\n    static async createFromConfig(\n        config: NftMarketplaceData,\n        workchain = 0\n    ) {\n\n        const data = this.buildDataCell(config)\n        const address = contractAddress(\n            workchain,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n\n        return new NftMarketplace(\n            address,\n            {\n                code: this.code,\n                data: data\n            }\n        )\n    }\n\n    /**\n     * Sends a deploy command to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the deploy command.\n     * @param value - The value to send with the command.\n     */\n    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n        await provider.internal(via, {\n            value,\n            body: beginCell().endCell(),\n        })\n    }\n\n    /**\n     * Sends coins to the contract.\n     * @param provider - The contract provider.\n     * @param via - The sender of the coins.\n     * @param params - Parameters for the operation, including the value and queryId.\n     */\n    async sendCoins(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(1, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n}\n\n/**\n * Type definition for the data of an NFT marketplace.\n */", "export type NftMarketplaceData = {\n    seqno: number\n    subwallet: number\n    publicKey: Buffer\n}\n\n/**\n * Builds a signature for an operation.\n * @param params - Parameters for the signature, including the key pair, sale state initialization, and sale message body.\n * @returns The generated signature.\n */", "export function buildSignature(params: { \n    keyPair: KeyPair, \n    saleStateInit: Cell, \n    saleMessageBody: Cell \n}) {\n    const bodyCell = beginCell()\n    bodyCell.storeRef(params.saleStateInit)\n    bodyCell.storeRef(params.saleMessageBody)\n\n    return sign(bodyCell.endCell().hash(), params.keyPair.secretKey)\n}"]}
{"filename": "src/wrappers/standard/NftCollection.ts", "chunked_list": ["import { Address, Cell, Contract, ContractProvider } from 'ton-core'\n\n/**\n * Represents a collection of NFT items.\n */\nexport class NftCollection implements Contract {\n\n    /**\n     * Constructs an instance of the NftCollection contract.\n     * @param address - The address of the contract.\n     * @param init - Optional initialization data for the contract's code and data.\n     */\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    /**\n     * Constructs an instance of the NftCollection contract from an address.\n     * @param address - The address of the contract.\n     * @returns An instance of NftCollection.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftCollection(\n            address\n        )\n    }\n\n    /**\n     * Retrieves the collection data from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @returns An object with the collection data.\n     */\n    async getCollectionData(\n        provider: ContractProvider\n    ) {\n        const { stack } = await provider.get('get_collection_data', [])\n        return {\n            nextItemIndex: stack.readBigNumber(),\n            collectionContent: stack.readCellOpt(),\n            ownerAddress: stack.readAddressOpt(),\n        }\n    }\n\n    /**\n     * Retrieves the NFT address by index from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @param index - The index of the NFT in the collection.\n     * @returns An object with the NFT address.\n     */\n    async getNftAddressByIndex(\n        provider: ContractProvider,\n        index: bigint\n    ) {\n        const { stack } = await provider.get('get_nft_address_by_index', [\n            { type: 'int', value: index }\n        ])\n        return {\n            nftAddress: stack.readAddressOpt(),\n        }\n    }\n\n    /**\n     * Retrieves the NFT content from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @param index - The index of the NFT in the collection.\n     * @param individualContent - The individual content of the NFT.\n     * @returns An object with the full NFT content.\n     */\n    async getNftContent(\n        provider: ContractProvider,\n        index: bigint,\n        individualContent: Cell\n    ) {\n        const { stack } = await provider.get('get_nft_content', [\n            { type: 'int', value: index },\n            { type: 'cell', cell: individualContent }\n        ])\n        return {\n            fullContent: stack.readCellOpt(),\n        }\n    }\n\n}"]}
{"filename": "src/wrappers/standard/NftCollectionRoyalty.ts", "chunked_list": ["import { Address, ContractProvider, Sender, SendMode, beginCell } from 'ton-core'\nimport { NftCollection } from './NftCollection'\n\n/**\n * Represents a collection of NFT items with royalty features.\n * Inherits from the NftCollection class.\n */\nexport class NftCollectionRoyalty extends NftCollection {\n    /**\n     * Constructs an instance of the NftCollectionRoyalty contract from an address.\n     * @param address - The address of the contract.\n     * @returns An instance of NftCollectionRoyalty.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftCollectionRoyalty(\n            address\n        )\n    }\n\n    /**\n     * Sends a request to get the royalty parameters from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @param via - The Sender initiating the data retrieval.\n     * @param params - The parameters for the data retrieval.\n     */\n    async sendGetRoyaltyParams(\n        provider: ContractProvider,\n        via: Sender,\n        params: {\n            value: bigint\n            queryId: bigint\n        }\n    ) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x693d3950, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the royalty parameters of the NFT collection from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @returns An object with the royalty parameters.\n     */\n    async getRoyaltyParams(\n        provider: ContractProvider\n    ) {\n        const { stack } = await provider.get('royalty_params', [])\n        return {\n            init: stack.readBoolean(),\n            numerator: stack.readBigNumber(),\n            denominator: stack.readBigNumber(),\n            destination: stack.readAddressOpt()\n        }\n    }\n\n}"]}
{"filename": "src/wrappers/standard/NftItem.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, Transaction, SendMode, ExternalAddress } from 'ton-core'\nimport { isEligibleTransaction } from '../../utils/EligibleInternalTx'\nimport { Maybe } from 'ton-core/dist/utils/maybe'\n\n/**\n * Represents an NFT item contract. \n */\nexport class NftItem implements Contract {\n    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\n    /**\n     * Sends a transfer from the contract.\n     * @param provider - The ContractProvider to facilitate the transfer.\n     * @param via - The Sender initiating the transfer.\n     * @param params - The parameters for the transfer.\n     */\n    async sendTransfer(provider: ContractProvider, via: Sender, params: {\n        value: bigint\n        queryId: bigint\n        newOwner: Address\n        responseDestination?: Address\n        customPayload?: Cell\n        forwardAmount: bigint\n        forwardPayload?: Cell\n    }) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x5fcc3d14, 32)\n                .storeUint(params.queryId, 64)\n                .storeAddress(params.newOwner)\n                .storeAddress(params.responseDestination)\n                .storeMaybeRef(params.customPayload)\n                .storeCoins(params.forwardAmount)\n                .storeMaybeRef(params.forwardPayload)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Gets static data from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @param via - The Sender initiating the data retrieval.\n     * @param params - The parameters for the data retrieval.\n     */\n    async sendGetStaticData(\n        provider: ContractProvider,\n        via: Sender,\n        params: {\n            value: bigint\n            queryId: bigint\n        }\n    ) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x2fcb26a2, 32)\n                .storeUint(params.queryId || 0, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    // Getter Functions\n\n    /**\n     * Retrieves the data of the NFT from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     */\n    async getNftData(provider: ContractProvider) {\n        const { stack } = await provider.get('get_nft_data', [])\n        return {\n            init: stack.readBoolean(),\n            index: stack.readBigNumber(),\n            collectionAddress: stack.readAddressOpt(),\n            ownerAddress: stack.readAddressOpt(),\n            individualContent: stack.readCellOpt(),\n        }\n    }\n\n    // Transaction Parsing\n\n    /**\n     * Parses a transfer transaction.\n     * @param tx - The Transaction to be parsed.\n     * @returns A NftTransfer object if the transaction is valid, undefined otherwise.\n     */\n    static parseTransfer(tx: Transaction): NftTransfer | undefined {", "        try {\n            const body = tx.inMessage?.body.beginParse()\n\n            if (body === undefined) return undefined \n\n            const op = body.loadUint(32)\n            \n            if (op !== 0x5fcc3d14) return undefined \n\n            if (!isEligibleTransaction(tx)) {\n                return undefined\n            } \n\n            return {\n                queryId: body.loadUint(64),\n                from: tx.inMessage?.info.src ?? undefined,\n                to: body.loadAddress(),\n                responseTo: body.loadAddress(),\n                customPayload: body.loadMaybeRef(),\n                forwardAmount: body.loadCoins(),\n                forwardPayload: body.loadMaybeRef(),\n            }", "            if (!isEligibleTransaction(tx)) {\n                return undefined\n            } \n\n            return {\n                queryId: body.loadUint(64),\n                from: tx.inMessage?.info.src ?? undefined,\n                to: body.loadAddress(),\n                responseTo: body.loadAddress(),\n                customPayload: body.loadMaybeRef(),\n                forwardAmount: body.loadCoins(),\n                forwardPayload: body.loadMaybeRef(),\n            }", "        } catch (e) { console.log(e) }\n\n        return undefined\n    }\n}\n\n/**\n * Represents the data structure of an NFT transfer.\n */\nexport type NftTransfer = {\n    queryId: number\n    from?: Address | Maybe<ExternalAddress>\n    to: Address\n    responseTo?: Address\n    customPayload: Cell | null\n    forwardAmount: bigint\n    forwardPayload: Cell | null\n}", "export type NftTransfer = {\n    queryId: number\n    from?: Address | Maybe<ExternalAddress>\n    to: Address\n    responseTo?: Address\n    customPayload: Cell | null\n    forwardAmount: bigint\n    forwardPayload: Cell | null\n}"]}
{"filename": "src/wrappers/standard/NftItemRoyalty.ts", "chunked_list": ["import { Address, beginCell, ContractProvider, Sender, SendMode } from 'ton-core'\nimport { NftItem } from './NftItem'\n\n/**\n * Represents an NFT item contract with royalty features.\n * Inherits from the NftItem class.\n */\nexport class NftItemRoyalty extends NftItem {\n    /**\n     * Constructs an instance of the NftItemRoyalty contract from an address.\n     * @param address - The address of the contract.\n     * @returns An instance of NftItemRoyalty.\n     */\n    static createFromAddress(\n        address: Address\n    ) {\n        return new NftItemRoyalty(\n            address\n        )\n    }\n\n    /**\n     * Sends a request to get the royalty parameters from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @param via - The Sender initiating the data retrieval.\n     * @param params - The parameters for the data retrieval.\n     */\n    async sendGetRoyaltyParams(\n        provider: ContractProvider,\n        via: Sender,\n        params: {\n            value: bigint\n            queryId: bigint\n        }\n    ) {\n        await provider.internal(via, {\n            value: params.value,\n            body: beginCell()\n                .storeUint(0x693d3950, 32)\n                .storeUint(params.queryId, 64)\n                .endCell(),\n            sendMode: SendMode.PAY_GAS_SEPARATELY,\n        })\n    }\n\n    /**\n     * Retrieves the royalty parameters of the NFT from the contract.\n     * @param provider - The ContractProvider to facilitate the data retrieval.\n     * @returns An object with the royalty parameters.\n     */\n    async getRoyaltyParams(\n        provider: ContractProvider\n    ) {\n        const { stack } = await provider.get('royalty_params', [])\n        return {\n            init: stack.readBoolean(),\n            numerator: stack.readBigNumber(),\n            denominator: stack.readBigNumber(),\n            destination: stack.readAddressOpt()\n        }\n    }\n}\n\n"]}
{"filename": "src/types/Content.ts", "chunked_list": ["import { beginCell, Builder, Slice, Dictionary } from 'ton-core'\nimport {sha256_sync} from 'ton-crypto'\n\n// offchain#01 uri:Text = FullContent\n\ntype OnchainContent = {\n    type: 'onchain'\n    knownKeys: Map<string, string>\n    unknownKeys: Map<bigint, string>\n};\n  ", "type OffchainContent = {\n    type: 'offchain'\n    uri: string\n};\n  \ntype FullContent = OnchainContent | OffchainContent;\n\nconst propertyNames = ['uri', 'name', 'description', 'image', 'image_data']\n  \n// onchain#00 data:(HashMapE 256 ^ContentData) = FullContent;\n// offchain#01 uri:Text = FullContent;\n// preloads a uint8 then calls either the onchain or the offchain variant", "export function loadFullContent(slice: Slice): FullContent {\n    const data = slice.preloadUint(8)\n\n    switch (data) {\n\n    case 0x00:\n        return loadOnchainContent(slice)\n    case 0x01:\n        return loadOffchainContent(slice)\n    default:    \n        throw new Error(`Unknown content type: ${data.toString(16)}`)\n        \n    }\n}\n", "export function storeFullContent(src: FullContent): (builder: Builder) => void {\n    switch (src.type) {\n    case 'onchain':\n        return storeOnchainContent(src)\n    case 'offchain':\n        return storeOffchainContent(src)\n    default:\n        throw new Error('Unknown content type')\n    }\n}\n  \n// onchain#00 data:(HashMapE 256 ^ContentData) = FullContent;\n// loads a uint8, checks that it is 0x00, calls loadOnchainDict, inserts known keys into the respective fields", "export function loadOnchainContent(slice: Slice): OnchainContent {\n    const data = slice.loadUint(8)\n\n    if (data !== 0x00) {\n        throw new Error(`Unknown content type: ${data.toString(16)}`)\n    }\n\n    const onchainDict = loadOnchainDict(slice)\n    const knownKeys = new Map<string, string>()\n    for (const knownProperty of propertyNames) {\n        const hashedKey = BigInt('0x' + sha256_sync(knownProperty).toString('hex'))\n        const value = onchainDict.get(hashedKey)\n        ", "    for (const knownProperty of propertyNames) {\n        const hashedKey = BigInt('0x' + sha256_sync(knownProperty).toString('hex'))\n        const value = onchainDict.get(hashedKey)\n        \n        if (onchainDict.has(hashedKey) && value !== undefined) {\n            knownKeys.set(knownProperty, value)\n        }\n    }\n\n    return {\n        type: 'onchain',\n        knownKeys,\n        unknownKeys: onchainDict\n    }\n}\n", "export function storeOnchainContent(src: OnchainContent): (builder: Builder) => void {\n    const map = new Map<bigint, string>()\n\n    for (const [key, value] of src.unknownKeys) map.set(key, value)\n\n\n    for (const [key] of src.knownKeys) {\n        const hashedKey = BigInt('0x' + sha256_sync(key).toString('hex'))\n        map.set(hashedKey, key)\n    }\n\n    return (builder: Builder) => {\n        builder.storeUint(8, 0x00)\n        builder.store(storeOnchainDict(map))\n    }\n}\n\n// offchain#01 uri:Text = FullContent;\n// loads a uint8, checks that it is 0x01, calls loadSnakeData", "export function loadOffchainContent(slice: Slice): OffchainContent {\n    const prefix = slice.loadUint(8)\n\n    if (prefix !== 0x01) {\n        throw new Error(`Unknown content prefix: ${prefix.toString(16)}`)\n    }\n    \n    return {\n        type: 'offchain',\n        uri: slice.loadStringTail()\n    }\n}\n", "export function storeOffchainContent(src: OffchainContent): (builder: Builder) => void {\n    return (builder: Builder) => {\n        builder\n            .storeUint(0x01, 8)\n            .storeStringTail(src.uri)\n    }\n}\n\n// snake#00 data:(SnakeData ~n) = ContentData;\n// chunks#01 data:ChunkedData = ContentData;\n// preloads a uint8 then calls either loadSnakeData or loadChunkedData", "export function loadContentData(slice: Slice): string {\n    const data = slice.preloadUint(8)\n\n    switch (data) {\n    case 0x00:\n        return loadSnakeData(slice)\n    case 0x01:\n        return loadChunkedData(slice)\n    default:\n        throw new Error(`Unknown content type: ${data.toString(16)}`)\n    }\n}\n// notice that there is no storeContentData\n\n// snake#00 data:(SnakeData ~n) = ContentData;\n// loads a uint8, checks that it is 0x00, calls slice.loadStringTail", "export function loadSnakeData(slice: Slice): string {\n    const prefix = slice.loadUint(8)\n\n    if (prefix !== 0x00) {\n        throw new Error(`Unknown content prefix: ${prefix.toString(16)}`)\n    }\n    \n    return slice.loadStringTail()\n}\n\nexport function storeSnakeData(src: string): (builder: Builder) => void {\n    return (builder: Builder) => {\n        builder\n            .storeUint(0x00, 8)\n            .storeStringTail(src)\n    }\n}\n\n// chunks#01 data:ChunkedData = ContentData;\n// chunked_data#_ data:(HashMapE 32 ^(SnakeData ~0)) = ChunkedData;\n// notice that above it is `SnakeData ~0` which means `the last layer` so there must be no refs in it, and it should be an integer number of bytes\n// loads a uint8, checks that it is 0x01, calls loadChunkedRaw", "export function storeSnakeData(src: string): (builder: Builder) => void {\n    return (builder: Builder) => {\n        builder\n            .storeUint(0x00, 8)\n            .storeStringTail(src)\n    }\n}\n\n// chunks#01 data:ChunkedData = ContentData;\n// chunked_data#_ data:(HashMapE 32 ^(SnakeData ~0)) = ChunkedData;\n// notice that above it is `SnakeData ~0` which means `the last layer` so there must be no refs in it, and it should be an integer number of bytes\n// loads a uint8, checks that it is 0x01, calls loadChunkedRaw", "export function loadChunkedData(slice: Slice): string {\n    const prefix = slice.loadUint(8)\n\n    if (prefix !== 0x01) {\n        throw new Error(`Unknown content prefix: ${prefix.toString(16)}`)\n    }\n\n    return loadChunkedRaw(slice)\n}\n\nexport function storeChunkedData(src: string): (builder: Builder) => void {\n    return (builder: Builder) => {\n        builder\n            .storeUint(0x01, 8)\n            .store(storeChunkedRaw(src))\n    }\n}\n\n// these two only work with the dict (HashMapE 32 ^(SnakeData ~0))\n// load must iterate over all parts and combine them, store must split the string as needed", "export function storeChunkedData(src: string): (builder: Builder) => void {\n    return (builder: Builder) => {\n        builder\n            .storeUint(0x01, 8)\n            .store(storeChunkedRaw(src))\n    }\n}\n\n// these two only work with the dict (HashMapE 32 ^(SnakeData ~0))\n// load must iterate over all parts and combine them, store must split the string as needed\nexport function loadChunkedRaw(slice: Slice): string {\n    const dict = slice.loadDict(\n        Dictionary.Keys.Uint(32), \n        Dictionary.Values.Cell()\n    )\n\n    let data = ''\n", "export function loadChunkedRaw(slice: Slice): string {\n    const dict = slice.loadDict(\n        Dictionary.Keys.Uint(32), \n        Dictionary.Values.Cell()\n    )\n\n    let data = ''\n\n    for (let i = 0; i < dict.size; i++) {\n        const value = dict.get(i)\n", "    for (let i = 0; i < dict.size; i++) {\n        const value = dict.get(i)\n\n        if (!value) {\n            throw new Error(`Missing value for key: ${i.toString(16)}`)\n        }\n    \n        data += (value.beginParse().loadStringRefTail())\n    }\n\n    return data\n}\n", "export function storeChunkedRaw(src: string): (builder: Builder) => void {\n    const dict = Dictionary.empty(\n        Dictionary.Keys.Uint(32),\n        Dictionary.Values.Cell()\n    )\n\n    const nChunks = Math.ceil(src.length / 127)\n\n    for (let i = 0; i < nChunks; i++) {\n        const chunk = src.slice(i * 127, (i + 1) * 127)\n        dict.set(i, beginCell().storeStringRefTail(chunk).endCell())\n    }\n\n    return (builder: Builder) => {\n        builder\n            .storeDict(\n                dict\n            )\n    }\n}\n\n// uses the Dictionary primitive with loadContentData to parse the dict", "    for (let i = 0; i < nChunks; i++) {\n        const chunk = src.slice(i * 127, (i + 1) * 127)\n        dict.set(i, beginCell().storeStringRefTail(chunk).endCell())\n    }\n\n    return (builder: Builder) => {\n        builder\n            .storeDict(\n                dict\n            )\n    }\n}\n\n// uses the Dictionary primitive with loadContentData to parse the dict", "export function loadOnchainDict(slice: Slice): Map<bigint, string> {\n    const dict = slice.loadDict(\n        Dictionary.Keys.BigUint(256), \n        Dictionary.Values.Cell()\n    )\n\n    const data = new Map<bigint, string>()\n\n    for (const [key, value] of dict) {\n        data.set(key, loadContentData(value.beginParse()))\n    }\n\n    return data\n}\n\n// uses the Dictionary primitive and either storeSnakeData or storeChunkedData (probably just choose the former one for now)", "    for (const [key, value] of dict) {\n        data.set(key, loadContentData(value.beginParse()))\n    }\n\n    return data\n}\n\n// uses the Dictionary primitive and either storeSnakeData or storeChunkedData (probably just choose the former one for now)\nexport function storeOnchainDict(src: Map<bigint, string>): (builder: Builder) => void {\n    const dict = Dictionary.empty(\n        Dictionary.Keys.BigUint(256),\n        Dictionary.Values.Cell()\n    )\n", "export function storeOnchainDict(src: Map<bigint, string>): (builder: Builder) => void {\n    const dict = Dictionary.empty(\n        Dictionary.Keys.BigUint(256),\n        Dictionary.Values.Cell()\n    )\n\n    for (const [key, value] of src) {\n        dict.set(key, beginCell().store(storeSnakeData(value)).endCell())\n    }\n\n    return (builder: Builder) => {\n        builder.storeDict(dict)\n    }\n}"]}
{"filename": "src/transaction-parsing/index.ts", "chunked_list": ["import { Transaction } from \"ton-core\"\n\nexport function parseTransaction<E extends ((input: Transaction) => any)>(tx: Transaction, parsers: E[]): (E extends ((input: Transaction) => infer RR) ? RR : never) | undefined {\n\n    for (const p of parsers) {\n        const parsed = p(tx);\n        if (parsed !== undefined) return parsed;\n    }\n\n    return undefined;\n}"]}
