{"filename": "src/config.ts", "chunked_list": ["import { ok } from \"assert\";\nimport * as core from \"@actions/core\";\nimport { join } from \"path\";\n\nimport { createTempPath } from \"./utility\";\n\nexport type Config = {\n  commitBranch: string;\n  commitMessage: string;\n  commitUserEmail: string;\n  commitUserName: string;\n  fullPath: string;\n  path: string;\n  prAssignee?: string;\n  prBody: string;\n  prEnabled: boolean;\n  prLabels: string[];\n  prReviewUsers: string[];\n  prTitle: string;\n  prToken?: string;\n  syncAuth?: string;\n  syncPath: string;\n  syncRepository: string;\n  syncTree: string;\n  templateVariables: Record<string, string>;\n};\n", "export function getConfig(): Config {\n  const path = core.getInput(\"path\", { required: false });\n  const workspace = process.env.GITHUB_WORKSPACE;\n  ok(workspace, \"Expected GITHUB_WORKSPACE to be defined\");\n\n  return {\n    commitBranch: core.getInput(\"commit-branch\", { required: true }),\n    commitMessage: core.getInput(\"commit-message\", { required: true }),\n    commitUserEmail: core.getInput(\"commit-user-email\", { required: true }),\n    commitUserName: core.getInput(\"commit-user-name\", { required: true }),\n    fullPath: join(workspace, path),\n    path: path,\n    prBody: core.getInput(\"pr-body\", { required: false }),\n    prEnabled: core.getBooleanInput(\"pr-enabled\", { required: true }),\n    prLabels: core.getMultilineInput(\"pr-labels\", { required: false }),\n    prReviewUsers: core.getMultilineInput(\"pr-review-users\", {\n      required: false,\n    }),\n    prTitle: core.getInput(\"pr-title\", { required: true }),\n    prToken: core.getInput(\"pr-token\", { required: false }),\n    syncAuth: core.getInput(\"sync-auth\", { required: false }),\n    syncPath: createTempPath(),\n    syncRepository: core.getInput(\"sync-repository\", { required: true }),\n    syncTree:\n      core.getInput(\"sync-branch\", { required: false }) ||\n      core.getInput(\"sync-tree\", { required: true }),\n    templateVariables: {},\n  };\n}\n"]}
{"filename": "src/git.ts", "chunked_list": ["import { ok } from \"assert\";\nimport * as core from \"@actions/core\";\nimport { exec } from \"@actions/exec\";\nimport { RequestError } from \"@octokit/request-error\";\nimport { mkdirP } from \"@actions/io\";\n\nimport { Config } from \"./config\";\nimport { getOctokit } from \"./octokit\";\n\nexport async function cloneRepository(config: Config): Promise<void> {\n  const { syncAuth, syncPath, syncRepository, syncTree } = config;\n\n  const tempDirectory = await mkdirP(syncPath);\n\n  await exec(\n    `git clone https://${syncAuth}@${syncRepository} ${syncPath}`,\n    [],\n    {\n      silent: !core.isDebug(),\n    },\n  );\n\n  await exec(`git fetch`, [], {\n    cwd: syncPath,\n    silent: !core.isDebug(),\n  });\n\n  await exec(`git checkout --progress --force ${syncTree}`, [], {\n    cwd: syncPath,\n    silent: !core.isDebug(),\n  });\n}\n", "\nexport async function cloneRepository(config: Config): Promise<void> {\n  const { syncAuth, syncPath, syncRepository, syncTree } = config;\n\n  const tempDirectory = await mkdirP(syncPath);\n\n  await exec(\n    `git clone https://${syncAuth}@${syncRepository} ${syncPath}`,\n    [],\n    {\n      silent: !core.isDebug(),\n    },\n  );\n\n  await exec(`git fetch`, [], {\n    cwd: syncPath,\n    silent: !core.isDebug(),\n  });\n\n  await exec(`git checkout --progress --force ${syncTree}`, [], {\n    cwd: syncPath,\n    silent: !core.isDebug(),\n  });\n}\n", "export async function configureRepository(config: Config): Promise<void> {\n  await exec(\"git\", [\"config\", \"user.email\", config.commitUserEmail], {\n    cwd: config.fullPath,\n    silent: !core.isDebug(),\n  });\n\n  await exec(\"git\", [\"config\", \"user.name\", config.commitUserName], {\n    cwd: config.fullPath,\n    silent: !core.isDebug(),\n  });\n\n  await exec(\"git\", [\"checkout\", \"-f\", \"-b\", config.commitBranch], {\n    cwd: config.fullPath,\n    silent: !core.isDebug(),\n  });\n}\n", "export async function commitChanges(config: Config): Promise<boolean> {\n  await exec(\"git\", [\"add\", \"-A\"], {\n    cwd: config.fullPath,\n    failOnStdErr: false,\n    ignoreReturnCode: true,\n    silent: !core.isDebug(),\n  });\n\n  const exitCode = await exec(\"git\", [\"commit\", \"-m\", config.commitMessage], {\n    cwd: config.fullPath,\n    failOnStdErr: false,\n    ignoreReturnCode: true,\n    silent: !core.isDebug(),\n  });\n\n  return exitCode === 0;\n}\n", "export async function createPr(config: Config): Promise<void> {\n  await exec(\"git\", [\"push\", \"-f\", \"-u\", \"origin\", config.commitBranch], {\n    cwd: config.fullPath,\n    silent: !core.isDebug(),\n  });\n\n  ok(process.env.GITHUB_REPOSITORY, \"Expected GITHUB_REPOSITORY to be defined\");\n  ok(config.prToken, \"Expected PR_TOKEN to be defined\");\n\n  const [owner, repo] = process.env.GITHUB_REPOSITORY.split(\"/\");\n  const octokit = getOctokit(config.prToken);\n\n  const { data: repository } = await octokit.rest.repos.get({ owner, repo });\n", "  for (const name of config.prLabels) {\n    core.debug(`Creating issue label ${name}`);\n    try {\n      await octokit.rest.issues.createLabel({ owner, repo, name });\n    } catch (err) {\n      if (err instanceof RequestError && err.status === 422) {\n        core.debug(`Issue label ${name} already exists`);\n      } else {\n        throw err;\n      }\n    }\n  }\n", "  try {\n    const res = await octokit.rest.pulls.create({\n      owner,\n      repo,\n      base: repository.default_branch,\n      body: config.prBody,\n      head: config.commitBranch,\n      maintainer_can_modify: true,\n      title: config.prTitle,\n    });\n\n    await octokit.rest.issues.addLabels({\n      owner,\n      repo,\n      issue_number: res.data.number,\n      labels: config.prLabels,\n    });\n\n    await octokit.rest.pulls.requestReviewers({\n      owner,\n      repo,\n      pull_number: res.data.number,\n      reviewers: config.prReviewUsers,\n    });\n\n    core.setOutput(\"pr-url\", res.data.html_url);", "  } catch (err) {\n    if (err instanceof RequestError && err.status === 422) {\n      core.debug(\"PR already exists\");\n    } else {\n      throw err;\n    }\n  }\n}\n"]}
{"filename": "src/octokit.ts", "chunked_list": ["import type { Octokit } from \"@octokit/core\";\nimport { getOctokit as upstreamOctokit } from \"@actions/github\";\nimport { retry } from \"@octokit/plugin-retry\";\nimport { throttling } from \"@octokit/plugin-throttling\";\n\nfunction onLimit(\n  retryAfter: number,\n  { method, url }: { method: string; url: string },\n  octokit: Octokit,\n) {\n  octokit.log.warn(`Request quota exhausted for request ${method} ${url}`);\n  octokit.log.info(`Retrying after ${retryAfter} seconds`);\n  return true;\n}\n", "export function getOctokit(token: string) {\n  return upstreamOctokit(\n    token,\n    {\n      retry: {\n        enabled: true,\n      },\n      throttle: {\n        enabled: true,\n        onSecondaryRateLimit: onLimit,\n        onRateLimit: onLimit,\n        timeout: 1000 * 60 * 20,\n      },\n    },\n    retry,\n    throttling,\n  );\n}\n"]}
{"filename": "src/scripts.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\nimport { resolve } from \"path\";\n\nimport { readOutput } from \"./scripts\";\n\ndescribe.concurrent(\"scripts\", () => {\n  it(\"parses single line output\", async () => {\n    const fixturePath = resolve(\n      __dirname,\n      \"../test/fixtures/scripts/single-line-output\",", "      __dirname,\n      \"../test/fixtures/scripts/single-line-output\",\n    );\n    const output = await readOutput(fixturePath);\n    expect(output).toEqual({\n      keyone: \"valueone\",\n      key_two: \"value_two\",\n      keyThree: \"valueThree\",\n    });\n  });", "    });\n  });\n\n  it(\"parses quoted string output\", async () => {\n    const fixturePath = resolve(\n      __dirname,\n      \"../test/fixtures/scripts/single-line-quoted-string-output\",\n    );\n    const output = await readOutput(fixturePath);\n    expect(output).toEqual({", "    const output = await readOutput(fixturePath);\n    expect(output).toEqual({\n      keyone: \"valueone\",\n      key_two: \"value_two\",\n      keyThree: \"valueThree\",\n    });\n  });\n\n  it(\"parses multi line heredocs\", async () => {\n    // NOTE: This trims whitespace due to how we parse and the ugly regex. Should be fine for our use case.", "  it(\"parses multi line heredocs\", async () => {\n    // NOTE: This trims whitespace due to how we parse and the ugly regex. Should be fine for our use case.\n    const fixturePath = resolve(\n      __dirname,\n      \"../test/fixtures/scripts/multi-line-heredoc-output\",\n    );\n    const output = await readOutput(fixturePath);\n    expect(output).toEqual({\n      keyone: \"testing line one\\ntesting line two\",\n      key_two:", "      keyone: \"testing line one\\ntesting line two\",\n      key_two:\n        'testing line one\\n\"testing line two\"\\nextra empty line after this',\n    });\n  });\n});\n"]}
{"filename": "src/templates.test.ts", "chunked_list": ["import { readFile, mkdtemp, rm } from \"fs/promises\";\nimport { afterEach, beforeEach, describe, expect, it } from \"vitest\";\nimport { join, resolve } from \"path\";\nimport { tmpdir } from \"os\";\nimport { v4 as uuid } from \"uuid\";\n\nimport { Config } from \"./config\";\nimport { templateFiles } from \"./templates\";\n\ninterface LocalTestContext {\n  config: Config;\n}\n\ndescribe.concurrent(\"templates\", () => {\n  beforeEach<LocalTestContext>(async (ctx) => {\n    const fullPath = await mkdtemp(join(tmpdir(), \"actions-sync\"));\n\n    ctx.config = {\n      commitBranch: \"main\",\n      commitMessage: \"commit message\",\n      commitUserEmail: \"test@example.com\",\n      commitUserName: \"testing\",\n      fullPath,\n      path: \"\",\n      prAssignee: \"\",\n      prBody: \"testing\",\n      prEnabled: false,\n      prLabels: [],\n      prReviewUsers: [],\n      prTitle: \"testing\",\n      syncAuth: \"\",\n      syncBranch: \"main\",\n      syncPath: resolve(__dirname, \"../test/fixtures\"),\n      syncRepository: \"test/test\",\n      templateVariables: {},\n    };\n  });\n\n  afterEach<LocalTestContext>(async (ctx) => {\n    await rm(ctx.config.fullPath, { recursive: true });\n  });\n\n  it<LocalTestContext>(\"can template basic json files\", async (ctx) => {\n    await templateFiles(ctx.config);\n    const path = join(ctx.config.fullPath, \"basic.json\");\n    const data = await readFile(path, \"utf8\");\n\n    expect(data).toEqual(\n      `{\\n  \"keyOne\": true,\\n  \"keyThree\": \"valueThree\"\\n}\\n`,\n    );\n  });\n\n  it<LocalTestContext>(\"can use template variables\", async (ctx) => {\n    await templateFiles({\n      ...ctx.config,\n      templateVariables: { KEY_TWO: \"true\" },\n    });\n    const path = join(ctx.config.fullPath, \"basic.json\");\n    const data = await readFile(path, \"utf8\");\n\n    expect(data).toEqual(\n      `{\\n  \"keyOne\": true,\\n  \"keyTwo\": \"valueTwo\",\\n  \"keyThree\": \"valueThree\"\\n}\\n`,\n    );\n  });\n});\n", "\ninterface LocalTestContext {\n  config: Config;\n}\n\ndescribe.concurrent(\"templates\", () => {\n  beforeEach<LocalTestContext>(async (ctx) => {\n    const fullPath = await mkdtemp(join(tmpdir(), \"actions-sync\"));\n\n    ctx.config = {\n      commitBranch: \"main\",\n      commitMessage: \"commit message\",\n      commitUserEmail: \"test@example.com\",\n      commitUserName: \"testing\",\n      fullPath,\n      path: \"\",\n      prAssignee: \"\",\n      prBody: \"testing\",\n      prEnabled: false,\n      prLabels: [],\n      prReviewUsers: [],\n      prTitle: \"testing\",\n      syncAuth: \"\",\n      syncBranch: \"main\",\n      syncPath: resolve(__dirname, \"../test/fixtures\"),\n      syncRepository: \"test/test\",\n      templateVariables: {},\n    };\n  });\n\n  afterEach<LocalTestContext>(async (ctx) => {\n    await rm(ctx.config.fullPath, { recursive: true });\n  });\n\n  it<LocalTestContext>(\"can template basic json files\", async (ctx) => {\n    await templateFiles(ctx.config);\n    const path = join(ctx.config.fullPath, \"basic.json\");\n    const data = await readFile(path, \"utf8\");\n\n    expect(data).toEqual(\n      `{\\n  \"keyOne\": true,\\n  \"keyThree\": \"valueThree\"\\n}\\n`,\n    );\n  });\n\n  it<LocalTestContext>(\"can use template variables\", async (ctx) => {\n    await templateFiles({\n      ...ctx.config,\n      templateVariables: { KEY_TWO: \"true\" },\n    });\n    const path = join(ctx.config.fullPath, \"basic.json\");\n    const data = await readFile(path, \"utf8\");\n\n    expect(data).toEqual(\n      `{\\n  \"keyOne\": true,\\n  \"keyTwo\": \"valueTwo\",\\n  \"keyThree\": \"valueThree\"\\n}\\n`,\n    );\n  });\n});\n"]}
{"filename": "src/utility.ts", "chunked_list": ["import { ok } from \"assert\";\nimport { join } from \"path\";\nimport { v4 as uuid } from \"uuid\";\n\nexport function createTempPath(): string {\n  return join(getTempDirectory(), uuid());\n}\n\nexport function getTempDirectory(): string {\n  const tempDirectory = process.env[\"RUNNER_TEMP\"] || \"\";\n  ok(tempDirectory, \"Expected RUNNER_TEMP to be defined\");\n  return tempDirectory;\n}\n", "export function getTempDirectory(): string {\n  const tempDirectory = process.env[\"RUNNER_TEMP\"] || \"\";\n  ok(tempDirectory, \"Expected RUNNER_TEMP to be defined\");\n  return tempDirectory;\n}\n"]}
{"filename": "src/templates.ts", "chunked_list": ["import * as core from \"@actions/core\";\nimport * as glob from \"@actions/glob\";\nimport { open, readFile, writeFile } from \"fs/promises\";\nimport Handlebars from \"handlebars\";\nimport { dirname, join, relative } from \"path\";\nimport { mkdirP } from \"@actions/io\";\n\nimport { Config } from \"./config\";\n\nexport async function templateFiles(config: Config): Promise<void> {\n  const templateGlob = await glob.create(`${config.syncPath}/templates/*`, {\n    matchDirectories: false,\n  });\n  const templatePaths = await templateGlob.glob();\n\n  core.info(`Templating ${templatePaths.length} files...`);\n", "\nexport async function templateFiles(config: Config): Promise<void> {\n  const templateGlob = await glob.create(`${config.syncPath}/templates/*`, {\n    matchDirectories: false,\n  });\n  const templatePaths = await templateGlob.glob();\n\n  core.info(`Templating ${templatePaths.length} files...`);\n\n  for (const templatePath of templatePaths) {\n    const relativePath = relative(`${config.syncPath}/templates`, templatePath);\n    core.info(`Template ${relativePath}`);\n", "  for (const templatePath of templatePaths) {\n    const relativePath = relative(`${config.syncPath}/templates`, templatePath);\n    core.info(`Template ${relativePath}`);\n\n    try {\n      const templateData = await readFile(templatePath, \"utf8\");\n      const templateHandlebar = Handlebars.compile(templateData);\n      const fileData = templateHandlebar(config.templateVariables);\n\n      core.debug(fileData);\n\n      const writePath = join(config.fullPath, relativePath);\n      core.debug(`Writing: ${writePath}`);\n\n      await mkdirP(dirname(writePath));\n      const io = await open(writePath, \"a\");\n      await io.close();\n      await writeFile(writePath, fileData);\n\n      core.debug(\"File written.\");", "    } catch (err) {\n      core.error(`Error templating ${relativePath}: ${err}`);\n    }\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import * as core from \"@actions/core\";\n\nimport {\n  configureRepository,\n  cloneRepository,\n  commitChanges,\n  createPr,\n} from \"./git\";\nimport { getConfig } from \"./config\";\nimport { templateFiles } from \"./templates\";", "import { getConfig } from \"./config\";\nimport { templateFiles } from \"./templates\";\nimport { runScripts } from \"./scripts\";\n\nexport async function run() {\n  const config = getConfig();\n\n  await configureRepository(config);\n  await cloneRepository(config);\n  await runScripts(config);\n  await templateFiles(config);\n", "  if (config.prEnabled) {\n    const hasChanges = await commitChanges(config);\n\n    if (hasChanges === false) {\n      core.info(\"No changes to commit.\");\n      return;\n    }\n\n    core.info(\"Creating PR\");\n    await createPr(config);\n    core.info(\"Created PR\");\n  } else {\n    core.info(\"Skipping PR creation\");\n  }\n}\n"]}
{"filename": "src/scripts.ts", "chunked_list": ["import * as core from \"@actions/core\";\nimport { exec } from \"@actions/exec\";\nimport * as glob from \"@actions/glob\";\nimport { relative } from \"path\";\nimport { open, readFile, utimes } from \"fs/promises\";\n\nimport { Config } from \"./config\";\nimport { createTempPath } from \"./utility\";\nimport { rmRF } from \"@actions/io\";\n", "import { rmRF } from \"@actions/io\";\n\nconst LINE_REGEX =\n  /(?:^)([\\w.-]+)=(?:<<([\\w.-]+)\\n([\\s\\S]*)\\n\\2)?(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:$|$)/gm;\n\nexport async function runScripts(config: Config): Promise<void> {\n  const scriptGlob = await glob.create(`${config.syncPath}/scripts/*`);\n  const scriptPathsUnsorted = await scriptGlob.glob();\n  const scriptPaths = scriptPathsUnsorted.sort();\n\n  core.info(`Running ${scriptPaths.length} scripts...`);\n", "  for (const scriptPath of scriptPaths) {\n    core.startGroup(`Run ${relative(config.syncPath, scriptPath)}`);\n\n    const newTemplateVariables = await runScript(scriptPath, config);\n    core.debug(\n      \"Adding new template variables\\n\" +\n        JSON.stringify(newTemplateVariables, null, 2),\n    );\n    config.templateVariables = {\n      ...config.templateVariables,\n      ...newTemplateVariables,\n    };\n\n    core.endGroup();\n  }\n}\n", "export async function runScript(\n  scriptPath: string,\n  config: Config,\n): Promise<Record<string, string>> {\n  const outputFilePath = createTempPath();\n  const io = await open(outputFilePath, \"a\");\n  await io.close();\n\n  await exec(scriptPath, [], {\n    cwd: config.fullPath,\n    env: {\n      ...process.env,\n      ...config.templateVariables,\n      SYNC_BRANCH: config.syncTree,\n      SYNC_PATH: config.syncPath,\n      SYNC_REPOSITORY: config.syncRepository,\n      SYNC_TREE: config.syncTree,\n      TEMPLATE_ENV: outputFilePath,\n    },\n    silent: false,\n    failOnStdErr: false,\n    ignoreReturnCode: true,\n  });\n\n  const newTemplateVariables = await readOutput(outputFilePath);\n  await rmRF(outputFilePath);\n  return newTemplateVariables;\n}\n\n// Most of the code taken from dotenv and adapted for heredocs to match GitHub Actions output", "export async function readOutput(\n  path: string,\n): Promise<Record<string, string>> {\n  const result = {} as Record<string, string>;\n\n  const lines = (await readFile(path, \"utf8\")).replace(/\\r\\n?/gm, \"\\n\");\n\n  let match;\n  while ((match = LINE_REGEX.exec(lines)) != null) {\n    const key = match[1];\n    const isHeredoc = match[3] != null;\n\n    let value = ((isHeredoc ? match[3] : match[4]) || \"\").trim();\n", "  while ((match = LINE_REGEX.exec(lines)) != null) {\n    const key = match[1];\n    const isHeredoc = match[3] != null;\n\n    let value = ((isHeredoc ? match[3] : match[4]) || \"\").trim();\n\n    if (!isHeredoc) {\n      const maybeQuote = value[0];\n\n      value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/gm, \"$2\");\n", "      if (maybeQuote === '\"') {\n        value = value.replace(/\\\\n/g, \"\\n\");\n        value = value.replace(/\\\\r/g, \"\\r\");\n      }\n    }\n\n    result[key] = value;\n  }\n\n  return result;\n}\n"]}
{"filename": "src/entrypoint.ts", "chunked_list": ["import * as core from \"@actions/core\";\n\nimport { run } from \"./index\";\n\n(async () => {\n  try {\n    await run();\n  } catch (error) {\n    if (error instanceof Error) {\n      core.setFailed(error.message);\n    } else if (typeof error === \"string\") {\n      core.setFailed(error);\n    } else {\n      core.setFailed(\"Unknown error occurred\");\n    }\n\n    process.exit(1);\n  }\n})();\n", "    if (error instanceof Error) {\n      core.setFailed(error.message);\n    } else if (typeof error === \"string\") {\n      core.setFailed(error);\n    } else {\n      core.setFailed(\"Unknown error occurred\");\n    }\n\n    process.exit(1);\n  }\n})();\n"]}
