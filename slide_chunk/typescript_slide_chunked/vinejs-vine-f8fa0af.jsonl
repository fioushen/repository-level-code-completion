{"filename": "index.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Vine } from './src/vine/main.js'", "\nimport { Vine } from './src/vine/main.js'\n\nexport { Vine }\nexport * as symbols from './src/symbols.js'\nexport * as errors from './src/errors/main.js'\nexport { VineAny } from './src/schema/any/main.js'\nexport { VineEnum } from './src/schema/enum/main.js'\nexport { VineTuple } from './src/schema/tuple/main.js'\nexport { VineUnion } from './src/schema/union/main.js'", "export { VineTuple } from './src/schema/tuple/main.js'\nexport { VineUnion } from './src/schema/union/main.js'\nexport { VineArray } from './src/schema/array/main.js'\nexport { VineValidator } from './src/vine/validator.js'\nexport { VineString } from './src/schema/string/main.js'\nexport { VineNumber } from './src/schema/number/main.js'\nexport { VineRecord } from './src/schema/record/main.js'\nexport { VineObject } from './src/schema/object/main.js'\nexport { VineLiteral } from './src/schema/literal/main.js'\nexport { VineBoolean } from './src/schema/boolean/main.js'", "export { VineLiteral } from './src/schema/literal/main.js'\nexport { VineBoolean } from './src/schema/boolean/main.js'\nexport { VineAccepted } from './src/schema/accepted/main.js'\nexport { BaseLiteralType } from './src/schema/base/literal.js'\nexport { BaseType, BaseModifiersType } from './src/schema/base/main.js'\nexport { SimpleErrorReporter } from './src/reporters/simple_error_reporter.js'\nexport { SimpleMessagesProvider } from './src/messages_provider/simple_messages_provider.js'\n\nconst vine = new Vine()\nexport default vine", "const vine = new Vine()\nexport default vine\n"]}
{"filename": "bin/test.ts", "chunked_list": ["import { Assert, assert } from '@japa/assert'\nimport { expectTypeOf } from '@japa/expect-type'\nimport { processCLIArgs, configure, run } from '@japa/runner'\nimport { ValidationError } from '../src/errors/validation_error.js'\n\nAssert.macro('validationErrors', async function (this: Assert, promiseLike, messages) {\n  let hasFailed = false\n\n  try {\n    await promiseLike\n  } catch (error) {\n    hasFailed = true\n    this.instanceOf(error, ValidationError)\n    this.deepEqual(error.messages, messages)\n  }\n", "  try {\n    await promiseLike\n  } catch (error) {\n    hasFailed = true\n    this.instanceOf(error, ValidationError)\n    this.deepEqual(error.messages, messages)\n  }\n\n  if (!hasFailed) {\n    throw new Error('Expected validation to fail, but passed')\n  }\n})\n\nAssert.macro('validationOutput', async function (this: Assert, promiseLike, messages) {\n  this.deepEqual(await promiseLike, messages)\n})\n\n/*\n|--------------------------------------------------------------------------\n| Configure tests\n|--------------------------------------------------------------------------\n|\n| The configure method accepts the configuration to configure the Japa\n| tests runner.\n|\n| The first method call \"processCliArgs\" process the command line arguments\n| and turns them into a config object. Using this method is not mandatory.\n|\n| Please consult japa.dev/runner-config for the config docs.\n*/\nprocessCLIArgs(process.argv.slice(2))\nconfigure({\n  suites: [\n    {\n      name: 'unit',\n      files: ['tests/unit/**/*.spec(.js|.ts)'],\n    },\n    {\n      name: 'integration',\n      files: ['tests/integration/**/*.spec(.js|.ts)'],\n    },\n  ],\n  plugins: [assert(), expectTypeOf()],\n})\n\n/*\n|--------------------------------------------------------------------------\n| Run tests\n|--------------------------------------------------------------------------\n|\n| The following \"run\" method is required to execute all the tests.\n|\n*/\n// eslint-disable-next-line @typescript-eslint/no-floating-promises\nrun()\n", "  if (!hasFailed) {\n    throw new Error('Expected validation to fail, but passed')\n  }\n})\n\nAssert.macro('validationOutput', async function (this: Assert, promiseLike, messages) {\n  this.deepEqual(await promiseLike, messages)\n})\n\n/*\n|--------------------------------------------------------------------------\n| Configure tests\n|--------------------------------------------------------------------------\n|\n| The configure method accepts the configuration to configure the Japa\n| tests runner.\n|\n| The first method call \"processCliArgs\" process the command line arguments\n| and turns them into a config object. Using this method is not mandatory.\n|\n| Please consult japa.dev/runner-config for the config docs.\n*/\nprocessCLIArgs(process.argv.slice(2))\nconfigure({\n  suites: [\n    {\n      name: 'unit',\n      files: ['tests/unit/**/*.spec(.js|.ts)'],\n    },\n    {\n      name: 'integration',\n      files: ['tests/integration/**/*.spec(.js|.ts)'],\n    },\n  ],\n  plugins: [assert(), expectTypeOf()],\n})\n\n/*\n|--------------------------------------------------------------------------\n| Run tests\n|--------------------------------------------------------------------------\n|\n| The following \"run\" method is required to execute all the tests.\n|\n*/\n// eslint-disable-next-line @typescript-eslint/no-floating-promises\nrun()\n"]}
{"filename": "bin/japa_types.ts", "chunked_list": ["import '@japa/assert'\n\ndeclare module '@japa/assert' {\n  interface Assert {\n    validationErrors(promiseLike: Promise<any>, messages: any): Promise<void>\n    validationOutput(promiseLike: Promise<any>, output: any): Promise<void>\n  }\n}\n"]}
{"filename": "tests/integration/validator.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine, {\n  Vine,\n  VineEnum,\n  VineTuple,\n  VineArray,\n  VineNumber,\n  VineObject,\n  VineRecord,", "  VineObject,\n  VineRecord,\n  VineString,\n  VineLiteral,\n  VineBoolean,\n} from '../../index.js'\n\ntest.group('Validator | metadata', () => {\n  test('pass metadata to the validation pipeline', async ({ assert }) => {\n    assert.plan(2)", "  test('pass metadata to the validation pipeline', async ({ assert }) => {\n    assert.plan(2)\n\n    const author = vine.object({\n      name: vine.string(),\n      email: vine.string().email(),\n      role: vine.string().in((field) => {\n        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n        return field.meta.choices\n      }),", "        return field.meta.choices\n      }),\n    })\n\n    const validator = vine.compile(author)\n    await assert.validationOutput(\n      validator.validate(\n        { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n        { meta: { choices: ['admin', 'guest'] } }\n      ),", "        { meta: { choices: ['admin', 'guest'] } }\n      ),\n      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n    )\n  })\n\n  test('define metadata types', async ({ assert }) => {\n    assert.plan(2)\n\n    const author = vine.object({", "\n    const author = vine.object({\n      name: vine.string(),\n      email: vine.string().email(),\n      role: vine.string().in((field) => {\n        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n        return field.meta.choices\n      }),\n    })\n", "    })\n\n    const validator = vine.withMetaData<{ choices: string[] }>().compile(author)\n    await assert.validationOutput(\n      validator.validate(\n        { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n        { meta: { choices: ['admin', 'guest'] } }\n      ),\n      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n    )", "      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n    )\n  })\n\n  test('validate metadata', async ({ assert }) => {\n    assert.plan(3)\n\n    const author = vine.object({\n      name: vine.string(),\n      email: vine.string().email(),", "      name: vine.string(),\n      email: vine.string().email(),\n      role: vine.string().in((field) => {\n        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n        return field.meta.choices\n      }),\n    })\n\n    const validator = vine\n      .withMetaData<{ choices: string[] }>((meta) => {", "    const validator = vine\n      .withMetaData<{ choices: string[] }>((meta) => {\n        assert.deepEqual(meta, { choices: ['admin', 'guest'] })\n      })\n      .compile(author)\n    await assert.validationOutput(\n      validator.validate(\n        { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n        { meta: { choices: ['admin', 'guest'] } }\n      ),", "        { meta: { choices: ['admin', 'guest'] } }\n      ),\n      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n    )\n  })\n\n  test('fail when metadata validation fails', async ({ assert }) => {\n    const author = vine.object({\n      name: vine.string(),\n      email: vine.string().email(),", "      name: vine.string(),\n      email: vine.string().email(),\n      role: vine.string().in((field) => {\n        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n        return field.meta.choices\n      }),\n    })\n\n    const validator = vine\n      .withMetaData<{ choices: string[] }>(() => {", "    const validator = vine\n      .withMetaData<{ choices: string[] }>(() => {\n        throw new Error('Invalid metadata')\n      })\n      .compile(author)\n\n    validator.validate(\n      { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n      { meta: { choices: ['admin', 'guest'] } }\n    )", "      { meta: { choices: ['admin', 'guest'] } }\n    )\n  }).throws('Invalid metadata')\n})\n\ntest.group('Validator | extend schema classes', () => {\n  test('extend VineString class', ({ assert }) => {\n    VineString.macro('notPawned' as any, function (value: string) {\n      return value\n    })", "      return value\n    })\n\n    assert.equal((vine.string() as any).notPawned('foo@bar.com'), 'foo@bar.com')\n  })\n\n  test('extend VineBoolean class', ({ assert }) => {\n    VineBoolean.macro('isTrue' as any, function () {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine.boolean() as any).isTrue())\n  })\n\n  test('extend VineNumber class', ({ assert }) => {\n    VineNumber.macro('isPrime' as any, function () {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine.number() as any).isPrime())\n  })\n\n  test('extend VineObject class', ({ assert }) => {\n    VineObject.macro('validatesEmail' as any, function (this: VineObject<any, any, any>) {\n      return 'email' in this.getProperties()\n    })", "      return 'email' in this.getProperties()\n    })\n\n    assert.isTrue((vine.object({ email: vine.string() }) as any).validatesEmail())\n  })\n\n  test('extend VineArray class', ({ assert }) => {\n    VineArray.macro('atLeastOne' as any, function (this: VineArray<any>) {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine.array(vine.string()) as any).atLeastOne())\n  })\n\n  test('extend VineRecord class', ({ assert }) => {\n    VineRecord.macro('atLeastOne' as any, function (this: VineRecord<any>) {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine.record(vine.string()) as any).atLeastOne())\n  })\n\n  test('extend VineTuple class', ({ assert }) => {\n    VineTuple.macro('atLeastOne' as any, function (this: VineTuple<any, any, any>) {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine.tuple([vine.string()]) as any).atLeastOne())\n  })\n\n  test('extend VineLiteral class', ({ assert }) => {\n    VineLiteral.macro('isTruthy' as any, function (this: VineLiteral<any>) {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine.literal(true) as any).isTruthy())\n  })\n\n  test('extend VineEnum class', ({ assert }) => {\n    VineEnum.macro('hasMultipleOptions' as any, function (this: VineEnum<any>) {\n      return this.getChoices().length > 0\n    })", "      return this.getChoices().length > 0\n    })\n\n    assert.isTrue((vine.enum(['guest', 'moderator', 'admin']) as any).hasMultipleOptions())\n  })\n\n  test('extend Vine class', ({ assert }) => {\n    Vine.macro('money' as any, function (this: Vine) {\n      return true\n    })", "      return true\n    })\n\n    assert.isTrue((vine as any).money())\n  })\n})\n"]}
{"filename": "tests/integration/schema/number.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('VineNumber', () => {\n  test('fail when value is not a number', async ({ assert }) => {\n    const schema = vine.object({\n      age: vine.number().withoutDecimals(),\n    })\n", "    })\n\n    const data = { age: 'foo' }\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'age',\n        message: 'The age field must be a number',\n        rule: 'number',\n      },\n    ])", "      },\n    ])\n  })\n\n  test('fail when value has decimal places', async ({ assert }) => {\n    const schema = vine.object({\n      age: vine.number().withoutDecimals(),\n    })\n\n    const data = { age: '22.12' }", "\n    const data = { age: '22.12' }\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'age',\n        message: 'The age field must be an integer',\n        rule: 'withoutDecimals',\n      },\n    ])\n  })", "    ])\n  })\n\n  test('pass when value is a valid integer', async ({ assert }) => {\n    const schema = vine.object({\n      age: vine.number().withoutDecimals(),\n    })\n\n    const data = { age: '22' }\n    await assert.validationOutput(vine.validate({ schema, data }), {", "    const data = { age: '22' }\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      age: 22,\n    })\n  })\n})\n"]}
{"filename": "tests/integration/schema/enum.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\nimport { SimpleMessagesProvider } from '../../../src/messages_provider/simple_messages_provider.js'\n\ntest.group('Enum', () => {\n  test('fail when value is not a subset of choices', async ({ assert }) => {\n    const schema = vine.object({\n      role: vine.enum(['admin', 'moderator', 'owner', 'user']),\n    })", "      role: vine.enum(['admin', 'moderator', 'owner', 'user']),\n    })\n\n    const data = {\n      role: 'foo',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'role',", "      {\n        field: 'role',\n        message: 'The selected role is invalid',\n        rule: 'enum',\n        meta: {\n          choices: ['admin', 'moderator', 'owner', 'user'],\n        },\n      },\n    ])\n  })", "    ])\n  })\n\n  test('pass when value is a subset of choices', async ({ assert }) => {\n    const schema = vine.object({\n      role: vine.enum(['admin', 'moderator', 'owner', 'user']),\n    })\n\n    const data = {\n      role: 'admin',", "    const data = {\n      role: 'admin',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      role: 'admin',\n    })\n  })\n})\n", "})\n\ntest.group('Enum | Native enum', () => {\n  test('fail when value is not a subset of choices', async ({ assert }) => {\n    enum Roles {\n      ADMIN = 'admin',\n      MOD = 'moderator',\n      OWNER = 'owner',\n      USER = 'user',\n    }\n\n    const schema = vine.object({\n      role: vine.enum(Roles),\n    })\n\n    const data = {\n      role: 'foo',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'role',\n        message: 'The selected role is invalid',\n        rule: 'enum',\n        meta: {\n          choices: ['admin', 'moderator', 'owner', 'user'],\n        },\n      },\n    ])\n  })\n\n  test('pass when value is a subset of choices', async ({ assert }) => {", "    enum Roles {\n      ADMIN = 'admin',\n      MOD = 'moderator',\n      OWNER = 'owner',\n      USER = 'user',\n    }\n\n    const schema = vine.object({\n      role: vine.enum(Roles),\n    })\n\n    const data = {\n      role: 'admin',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      role: 'admin',\n    })\n  })\n})\n", "test.group('Enum | Lazily compute enum choices', () => {\n  test('fail when value is not a subset of choices', async ({ assert }) => {\n    const schema = vine.object({\n      creative_device: vine.enum(['mobile', 'desktop']),\n      banner_width: vine.enum((field) => {\n        if (field.parent.creative_device === 'mobile') {\n          return ['320px', '640px'] as const\n        }\n\n        return ['1080px', '1280px'] as const\n      }),\n    })\n\n    const data = {\n      creative_device: 'desktop',\n      banner_width: '640px',\n    }\n\n    const messagesProvider = new SimpleMessagesProvider({}, { banner_width: 'banner width' })\n    await assert.validationErrors(vine.validate({ schema, data, messagesProvider }), [\n      {\n        field: 'banner_width',\n        message: 'The selected banner width is invalid',\n        rule: 'enum',\n        meta: {\n          choices: ['1080px', '1280px'],\n        },\n      },\n    ])\n  })\n\n  test('pass when value is a subset of choices', async ({ assert }) => {\n    const schema = vine.object({\n      creative_device: vine.enum(['mobile', 'desktop']),\n      banner_width: vine.enum((field) => {", "        if (field.parent.creative_device === 'mobile') {\n          return ['320px', '640px'] as const\n        }\n\n        return ['1080px', '1280px'] as const\n      }),\n    })\n\n    const data = {\n      creative_device: 'mobile',\n      banner_width: '640px',\n    }\n\n    const messagesProvider = new SimpleMessagesProvider({}, { banner_width: 'banner width' })\n    await assert.validationOutput(vine.validate({ schema, data, messagesProvider }), data)\n  })\n})\n"]}
{"filename": "tests/integration/schema/any.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\nimport { SimpleMessagesProvider } from '../../../src/messages_provider/simple_messages_provider.js'\n\ntest.group('Accepted', () => {\n  test('fail when field is missing', async ({ assert }) => {\n    const schema = vine.object({\n      secret_message: vine.any(),\n    })", "      secret_message: vine.any(),\n    })\n\n    const data = {}\n    const messagesProvider = new SimpleMessagesProvider(\n      {},\n      {\n        secret_message: 'message',\n      }\n    )", "      }\n    )\n\n    await assert.validationErrors(\n      vine.validate({\n        schema,\n        data,\n        messagesProvider,\n      }),\n      [", "      }),\n      [\n        {\n          field: 'secret_message',\n          message: 'The message field must be defined',\n          rule: 'required',\n        },\n      ]\n    )\n  })", "    )\n  })\n\n  test('pass when field value exists', async ({ assert }) => {\n    const schema = vine.object({\n      secret_message: vine.any(),\n    })\n\n    const data = {\n      secret_message: false,", "    const data = {\n      secret_message: false,\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      secret_message: false,\n    })\n  })\n})\n", "})\n"]}
{"filename": "tests/integration/schema/literal.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('Literal', () => {\n  test('fail when value is not same as the expected value', async ({ assert }) => {\n    const schema = vine.object({\n      is_hiring_guide: vine.literal(true),\n    })\n", "    })\n\n    const data = {\n      is_hiring_guide: false,\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'is_hiring_guide',\n        message: 'The is_hiring_guide field must be true',", "        field: 'is_hiring_guide',\n        message: 'The is_hiring_guide field must be true',\n        rule: 'literal',\n        meta: {\n          expectedValue: true,\n        },\n      },\n    ])\n  })\n", "  })\n\n  test('pass when value is same as the expected value', async ({ assert }) => {\n    const schema = vine.object({\n      is_hiring_guide: vine.literal(true),\n    })\n\n    const data = {\n      is_hiring_guide: 'true',\n    }", "      is_hiring_guide: 'true',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      is_hiring_guide: true,\n    })\n  })\n})\n", ""]}
{"filename": "tests/integration/schema/object.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('VineObject | flat object', () => {\n  test('fail when value is not an object', async ({ assert }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })", "      password: vine.string(),\n    })\n\n    const data = 'foo'\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: '',\n        message: 'The data field must be an object',\n        rule: 'object',\n      },", "        rule: 'object',\n      },\n    ])\n  })\n\n  test('fail when object has missing properties', async ({ assert }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })", "      password: vine.string(),\n    })\n\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'username',\n        message: 'The username field must be defined',\n        rule: 'required',\n      },", "        rule: 'required',\n      },\n      {\n        field: 'password',\n        message: 'The password field must be defined',\n        rule: 'required',\n      },\n    ])\n  })\n", "  })\n\n  test('pass when object has all the properties', async ({ assert }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })\n\n    const data = {\n      username: 'virk',", "    const data = {\n      username: 'virk',\n      password: 'secret',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n\n  test('drop unknown properties', async ({ assert }) => {\n    const schema = vine.object({", "  test('drop unknown properties', async ({ assert }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })\n\n    const data = {\n      username: 'virk',\n      password: 'secret',\n      rememberMe: true,", "      password: 'secret',\n      rememberMe: true,\n      trackLogin: true,\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      username: 'virk',\n      password: 'secret',\n    })\n  })", "    })\n  })\n\n  test('merge properties from an existing object', async ({ assert }) => {\n    const author = vine.object({\n      name: vine.string(),\n      email: vine.string().email(),\n    })\n\n    const schema = vine.object({", "\n    const schema = vine.object({\n      ...author.getProperties(),\n      body: vine.string(),\n    })\n\n    const data = {\n      name: 'virk',\n      email: 'foo@bar.com',\n      body: 'This is post 101',", "      email: 'foo@bar.com',\n      body: 'This is post 101',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n})\n\ntest.group('VineObject | allow unknown properties', () => {\n  test('fail when value is not an object', async ({ assert }) => {", "test.group('VineObject | allow unknown properties', () => {\n  test('fail when value is not an object', async ({ assert }) => {\n    const schema = vine\n      .object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n      .allowUnknownProperties()\n\n    const data = 'foo'", "\n    const data = 'foo'\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: '',\n        message: 'The data field must be an object',\n        rule: 'object',\n      },\n    ])\n  })", "    ])\n  })\n\n  test('fail when object has missing properties', async ({ assert }) => {\n    const schema = vine\n      .object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n      .allowUnknownProperties()", "      })\n      .allowUnknownProperties()\n\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'username',\n        message: 'The username field must be defined',\n        rule: 'required',\n      },", "        rule: 'required',\n      },\n      {\n        field: 'password',\n        message: 'The password field must be defined',\n        rule: 'required',\n      },\n    ])\n  })\n", "  })\n\n  test('copy unknown properties to the output', async ({ assert }) => {\n    const schema = vine\n      .object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n      .allowUnknownProperties()\n", "      .allowUnknownProperties()\n\n    const data = {\n      username: 'virk',\n      password: 'secret',\n      rememberMe: true,\n      trackLogin: true,\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), data)", "\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n})\n\ntest.group('VineObject | object group', () => {\n  test('fail when group schema reports error', async ({ assert }) => {\n    const guideSchema = vine.group([\n      vine.group.if((data) => vine.helpers.isTrue(data.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        guide_id: vine.string(),\n        amount: vine.number(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        name: vine.string(),\n        group_size: vine.number(),\n        phone_number: vine.string(),\n      })\n      .merge(guideSchema)\n\n    const data = {\n      name: 'virk',\n      group_size: 10,\n      phone_number: '0001010',\n      is_hiring_guide: true,\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'guide_id',\n        message: 'The guide_id field must be defined',\n        rule: 'required',\n      },\n      {\n        field: 'amount',\n        message: 'The amount field must be defined',\n        rule: 'required',\n      },\n    ])\n  })\n\n  test('pass when group schema is valid', async ({ assert }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        guide_id: vine.string(),\n        amount: vine.number(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        name: vine.string(),\n        group_size: vine.number(),\n        phone_number: vine.string(),\n      })\n      .merge(guideSchema)\n\n    const data = {\n      name: 'virk',\n      group_size: 10,\n      phone_number: '0001010',\n      is_hiring_guide: true,\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'guide_id',\n        message: 'The guide_id field must be defined',\n        rule: 'required',\n      },\n      {\n        field: 'amount',\n        message: 'The amount field must be defined',\n        rule: 'required',\n      },\n    ])\n  })\n\n  test('pass when group schema is valid', async ({ assert }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        guide_id: vine.string(),\n        amount: vine.number(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        name: vine.string(),\n        group_size: vine.number(),\n        phone_number: vine.string(),\n      })\n      .merge(guideSchema)\n\n    const data = {\n      name: 'virk',\n      group_size: 10,\n      phone_number: '0001010',\n      is_hiring_guide: false,\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      name: 'virk',\n      group_size: 10,\n      phone_number: '0001010',\n      is_hiring_guide: false,\n    })\n  })\n\n  test('fail when none of the group conditions match', async ({ assert }) => {\n    const fiscalHost = vine.group([", "      vine.group.if((data) => data.type === 'stripe', {\n        type: vine.literal('stripe'),\n        account_id: vine.string(),\n      }),\n      vine.group.if((data) => data.type === 'paypal', {\n        type: vine.literal('paypal'),\n        email: vine.string().email(),\n      }),\n      vine.group.if((data) => data.type === 'open_collective', {\n        type: vine.literal('open_collective'),\n        project_url: vine.string(),\n      }),\n    ])\n\n    const schema = vine.object({}).merge(fiscalHost)\n\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: '',\n        message: 'Invalid value provided for data field',\n        rule: 'unionGroup',\n      },\n    ])\n  })\n\n  test('fail when group reports an error', async ({ assert }) => {\n    const fiscalHost = vine\n      .group([", "      vine.group.if((data) => data.type === 'open_collective', {\n        type: vine.literal('open_collective'),\n        project_url: vine.string(),\n      }),\n    ])\n\n    const schema = vine.object({}).merge(fiscalHost)\n\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: '',\n        message: 'Invalid value provided for data field',\n        rule: 'unionGroup',\n      },\n    ])\n  })\n\n  test('fail when group reports an error', async ({ assert }) => {\n    const fiscalHost = vine\n      .group([", "        vine.group.if((data) => data.type === 'stripe', {\n          type: vine.literal('stripe'),\n          account_id: vine.string(),\n        }),\n        vine.group.if((data) => data.type === 'paypal', {\n          type: vine.literal('paypal'),\n          email: vine.string().email(),\n        }),\n        vine.group.if((data) => data.type === 'open_collective', {\n          type: vine.literal('open_collective'),\n          project_url: vine.string(),\n        }),\n      ])\n      .otherwise((_, field) => {", "        vine.group.if((data) => data.type === 'open_collective', {\n          type: vine.literal('open_collective'),\n          project_url: vine.string(),\n        }),\n      ])\n      .otherwise((_, field) => {\n        field.report('Missing type property', 'type', field)\n      })\n\n    const schema = vine.object({}).merge(fiscalHost)\n\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: '',", "        message: 'Missing type property',\n        rule: 'type',\n      },\n    ])\n  })\n})\n"]}
{"filename": "tests/integration/schema/accepted.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('Accepted', () => {\n  test('fail when field is missing', async ({ assert }) => {\n    const schema = vine.object({\n      terms: vine.accepted(),\n    })\n", "    })\n\n    const data = {}\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'terms',\n        message: 'The terms field must be defined',\n        rule: 'required',\n      },", "        rule: 'required',\n      },\n    ])\n  })\n\n  test('fail when field is defined but not accepted', async ({ assert }) => {\n    const schema = vine.object({\n      terms: vine.accepted(),\n    })\n", "    })\n\n    const data = {\n      terms: 'no',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'terms',\n        message: 'The terms field must be accepted',", "        field: 'terms',\n        message: 'The terms field must be accepted',\n        rule: 'accepted',\n      },\n    ])\n  })\n\n  test('pass when field is accepted', async ({ assert }) => {\n    const schema = vine.object({\n      terms: vine.boolean(),", "    const schema = vine.object({\n      terms: vine.boolean(),\n    })\n\n    const data = {\n      terms: 'on',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      terms: true,", "    await assert.validationOutput(vine.validate({ schema, data }), {\n      terms: true,\n    })\n  })\n})\n"]}
{"filename": "tests/integration/schema/record.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('VineRecord', () => {\n  test('fail when value is not an object', async ({ assert }) => {\n    const schema = vine.object({\n      colors: vine.record(vine.string().hexCode()),\n    })\n", "    })\n\n    const data = {\n      colors: 'foo',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'colors',\n        message: 'The colors field must be an object',", "        field: 'colors',\n        message: 'The colors field must be an object',\n        rule: 'object',\n      },\n    ])\n  })\n\n  test('pass when value is an object', async ({ assert }) => {\n    const schema = vine.object({\n      colors: vine.record(vine.string().hexCode()),", "    const schema = vine.object({\n      colors: vine.record(vine.string().hexCode()),\n    })\n\n    const data = {\n      colors: {\n        white: '#ffffff',\n        black: '#000000',\n        lime: '#99d52a',\n      },", "        lime: '#99d52a',\n      },\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n\n  test('validate union of types')\n})\n", "})\n"]}
{"filename": "tests/integration/schema/tuple.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('VineTuple', () => {\n  test('fail when value is not an array', async ({ assert }) => {\n    const schema = vine.object({\n      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n    })\n", "    })\n\n    const data = {\n      top_scores: 'foo',\n    }\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'top_scores',\n        message: 'The top_scores field must be an array',\n        rule: 'array',", "        message: 'The top_scores field must be an array',\n        rule: 'array',\n      },\n    ])\n  })\n\n  test('fail when tuple elements are missing', async ({ assert }) => {\n    const schema = vine.object({\n      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n    })", "      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n    })\n\n    const data = {\n      top_scores: [1],\n    }\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'top_scores.1',\n        message: 'The 1 field must be defined',", "        field: 'top_scores.1',\n        message: 'The 1 field must be defined',\n        rule: 'required',\n        index: 1,\n      },\n      {\n        field: 'top_scores.2',\n        message: 'The 2 field must be defined',\n        rule: 'required',\n        index: 2,", "        rule: 'required',\n        index: 2,\n      },\n    ])\n  })\n\n  test('pass when all elements are defined', async ({ assert }) => {\n    const schema = vine.object({\n      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n    })", "      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n    })\n\n    const data = {\n      top_scores: [1, 2, 3],\n    }\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n\n  test('drop unknown properties', async ({ assert }) => {", "\n  test('drop unknown properties', async ({ assert }) => {\n    const schema = vine.object({\n      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n    })\n\n    const data = {\n      top_scores: [98, 96, 92, 88, 84],\n    }\n    await assert.validationOutput(vine.validate({ schema, data }), {", "    }\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      top_scores: [98, 96, 92],\n    })\n  })\n})\n\ntest.group('VineTuple | allowUnknownProperties', () => {\n  test('fail when tuple elements are missing', async ({ assert }) => {\n    const schema = vine.object({", "  test('fail when tuple elements are missing', async ({ assert }) => {\n    const schema = vine.object({\n      top_scores: vine\n        .tuple([vine.number(), vine.number(), vine.number()])\n        .allowUnknownProperties(),\n    })\n\n    const data = {\n      top_scores: [1],\n    }", "      top_scores: [1],\n    }\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'top_scores.1',\n        message: 'The 1 field must be defined',\n        rule: 'required',\n        index: 1,\n      },\n      {", "      },\n      {\n        field: 'top_scores.2',\n        message: 'The 2 field must be defined',\n        rule: 'required',\n        index: 2,\n      },\n    ])\n  })\n", "  })\n\n  test('keep unknown elements', async ({ assert }) => {\n    const schema = vine.object({\n      top_scores: vine\n        .tuple([vine.number(), vine.number(), vine.number()])\n        .allowUnknownProperties(),\n    })\n\n    const data = {", "\n    const data = {\n      top_scores: [98, 96, 92, 'foo', 'bar'],\n    }\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      top_scores: [98, 96, 92, 'foo', 'bar'],\n    })\n  })\n})\n", "})\n"]}
{"filename": "tests/integration/schema/boolean.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('Boolean', () => {\n  test('fail when value is not a boolean', async ({ assert }) => {\n    const schema = vine.object({\n      is_admin: vine.boolean(),\n    })\n", "    })\n\n    const data = {\n      is_admin: 'foo',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'is_admin',\n        message: 'The value must be a boolean',", "        field: 'is_admin',\n        message: 'The value must be a boolean',\n        rule: 'boolean',\n      },\n    ])\n  })\n\n  test('pass when value is a boolean', async ({ assert }) => {\n    const schema = vine.object({\n      is_admin: vine.boolean(),", "    const schema = vine.object({\n      is_admin: vine.boolean(),\n    })\n\n    const data = {\n      is_admin: false,\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      is_admin: false,", "    await assert.validationOutput(vine.validate({ schema, data }), {\n      is_admin: false,\n    })\n  })\n\n  test('pass when value is a string representation of boolean', async ({ assert }) => {\n    const schema = vine.object({\n      is_admin: vine.boolean(),\n    })\n", "    })\n\n    const data = {\n      is_admin: 'true',\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      is_admin: true,\n    })\n  })", "    })\n  })\n})\n\ntest.group('Boolean | strict mode', () => {\n  test('fail when when is not a boolean', async ({ assert }) => {\n    const schema = vine.object({\n      is_admin: vine.boolean({ strict: true }),\n    })\n", "    })\n\n    const data = {\n      is_admin: 'foo',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'is_admin',\n        message: 'The value must be a boolean',", "        field: 'is_admin',\n        message: 'The value must be a boolean',\n        rule: 'boolean',\n      },\n    ])\n  })\n\n  test('pass when value is a boolean', async ({ assert }) => {\n    const schema = vine.object({\n      is_admin: vine.boolean({ strict: true }),", "    const schema = vine.object({\n      is_admin: vine.boolean({ strict: true }),\n    })\n\n    const data = {\n      is_admin: false,\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      is_admin: false,", "    await assert.validationOutput(vine.validate({ schema, data }), {\n      is_admin: false,\n    })\n  })\n\n  test('fail when value is a string representation of boolean', async ({ assert }) => {\n    const schema = vine.object({\n      is_admin: vine.boolean({ strict: true }),\n    })\n", "    })\n\n    const data = {\n      is_admin: 'true',\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'is_admin',\n        message: 'The value must be a boolean',", "        field: 'is_admin',\n        message: 'The value must be a boolean',\n        rule: 'boolean',\n      },\n    ])\n  })\n})\n"]}
{"filename": "tests/integration/schema/array.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('Array | array of numbers', () => {\n  test('fail when array does not have numbers', async ({ assert }) => {\n    const schema = vine.object({\n      categories: vine.array(vine.number()),\n    })\n", "    })\n\n    const data = {\n      categories: [1, 'foo', 'bar', 11],\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'categories.*',\n        index: 1,", "        field: 'categories.*',\n        index: 1,\n        message: 'The 1 field must be a number',\n        rule: 'number',\n      },\n      {\n        field: 'categories.*',\n        index: 2,\n        message: 'The 2 field must be a number',\n        rule: 'number',", "        message: 'The 2 field must be a number',\n        rule: 'number',\n      },\n    ])\n  })\n\n  test('pass when array has numbers and numerical strings', async ({ assert }) => {\n    const schema = vine.object({\n      categories: vine.array(vine.number()),\n    })", "      categories: vine.array(vine.number()),\n    })\n\n    const data = {\n      categories: [1, '2', '20', 11],\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), {\n      categories: [1, 2, 20, 11],\n    })", "      categories: [1, 2, 20, 11],\n    })\n  })\n})\n\ntest.group('Array | array of objects', () => {\n  test('fail when array does not have an object', async ({ assert }) => {\n    const schema = vine.object({\n      contacts: vine.array(\n        vine.object({", "      contacts: vine.array(\n        vine.object({\n          id: vine.number(),\n          is_primary: vine.boolean(),\n        })\n      ),\n    })\n\n    const data = {\n      contacts: ['foo'],", "    const data = {\n      contacts: ['foo'],\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'contacts.*',\n        index: 0,\n        message: 'The 0 field must be an object',\n        rule: 'object',", "        message: 'The 0 field must be an object',\n        rule: 'object',\n      },\n    ])\n  })\n\n  test('pass when array has objects matching the desired shape', async ({ assert }) => {\n    const schema = vine.object({\n      contacts: vine.array(\n        vine.object({", "      contacts: vine.array(\n        vine.object({\n          id: vine.number(),\n          is_primary: vine.boolean(),\n        })\n      ),\n    })\n\n    const data = {\n      contacts: [", "    const data = {\n      contacts: [\n        { id: 1, is_primary: false },\n        { id: 2, is_primary: true },\n      ],\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n})", "  })\n})\n\ntest.group('Array | array of unions', () => {\n  test('fail when none of the conditions match', async ({ assert }) => {\n    /**\n     * Re-usable helper to check if the field value\n     * is an object and has a matching type\n     */\n    function hasType(value: unknown, type: string) {\n      return vine.helpers.isObject(value) && value.type === type\n    }\n\n    /**", "     */\n    function hasType(value: unknown, type: string) {\n      return vine.helpers.isObject(value) && value.type === type\n    }\n\n    /**\n     * Schema type for email contact\n     */\n    const emailContact = vine.object({\n      type: vine.literal('email'),\n      email: vine.string().email(),\n    })\n\n    /**", "     * Schema type for phone contact\n     */\n    const phoneContact = vine.object({\n      type: vine.literal('phone'),\n      phone: vine.string().mobile(),\n    })\n\n    /**\n     * Define a contact union with conditionals and\n     * their associated schema\n     */\n    const contact = vine.union([", "      vine.union.if((value) => hasType(value, 'email'), emailContact),\n      vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n    ])\n\n    const schema = vine.object({\n      contacts: vine.array(contact),\n    })\n\n    const data = {\n      contacts: ['foo'],\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'contacts.*',\n        index: 0,\n        message: 'Invalid value provided for 0 field',\n        rule: 'union',\n      },\n    ])\n  })\n\n  test('fail when union reports an error', async ({ assert }) => {\n    /**\n     * Re-usable helper to check if the field value\n     * is an object and has a matching type\n     */", "    function hasType(value: unknown, type: string) {\n      return vine.helpers.isObject(value) && value.type === type\n    }\n\n    /**\n     * Schema type for email contact\n     */\n    const emailContact = vine.object({\n      type: vine.literal('email'),\n      email: vine.string().email(),\n    })\n\n    /**", "     * Schema type for phone contact\n     */\n    const phoneContact = vine.object({\n      type: vine.literal('phone'),\n      phone: vine.string().mobile(),\n    })\n\n    /**\n     * Define a contact union with conditionals and\n     * their associated schema\n     */\n    const contact = vine\n      .union([", "        vine.union.if((value) => hasType(value, 'email'), emailContact),\n        vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n      ])\n      .otherwise((_, field) => {\n        field.report(\n          'Invalid contact. Either provide an email or a phone number',\n          'unknown_contact_type',\n          field\n        )\n      })\n\n    const schema = vine.object({\n      contacts: vine.array(contact),\n    })\n\n    const data = {\n      contacts: ['foo'],\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'contacts.*',\n        index: 0,\n        message: 'Invalid contact. Either provide an email or a phone number',\n        rule: 'unknown_contact_type',\n      },\n    ])\n  })\n\n  test('fail when union schema reports error', async ({ assert }) => {\n    /**\n     * Re-usable helper to check if the field value\n     * is an object and has a matching type\n     */", "    function hasType(value: unknown, type: string) {\n      return vine.helpers.isObject(value) && value.type === type\n    }\n\n    /**\n     * Schema type for email contact\n     */\n    const emailContact = vine.object({\n      type: vine.literal('email'),\n      email: vine.string().email(),\n    })\n\n    /**", "     * Schema type for phone contact\n     */\n    const phoneContact = vine.object({\n      type: vine.literal('phone'),\n      phone: vine.string().mobile(),\n    })\n\n    /**\n     * Define a contact union with conditionals and\n     * their associated schema\n     */\n    const contact = vine\n      .union([", "        vine.union.if((value) => hasType(value, 'email'), emailContact),\n        vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n      ])\n      .otherwise((_, field) => {\n        field.report(\n          'Invalid contact. Either provide an email or a phone number',\n          'unknown_contact_type',\n          field\n        )\n      })\n\n    const schema = vine.object({\n      contacts: vine.array(contact),\n    })\n\n    const data = {\n      contacts: [\n        {\n          type: 'email',\n          email: 'foo',\n        },\n      ],\n    }\n\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'contacts.*.email',\n        message: 'The email field must be a valid email address',\n        rule: 'email',\n      },\n    ])\n  })\n\n  test('pass when union schema is valid', async ({ assert }) => {\n    assert.plan(1)\n\n    /**\n     * Re-usable helper to check if the field value\n     * is an object and has a matching type\n     */", "    function hasType(value: unknown, type: string) {\n      return vine.helpers.isObject(value) && value.type === type\n    }\n\n    /**\n     * Schema type for email contact\n     */\n    const emailContact = vine.object({\n      type: vine.literal('email'),\n      email: vine.string().email(),\n    })\n\n    /**", "     * Schema type for phone contact\n     */\n    const phoneContact = vine.object({\n      type: vine.literal('phone'),\n      phone: vine.string().mobile(),\n    })\n\n    /**\n     * Define a contact union with conditionals and\n     * their associated schema\n     */\n    const contact = vine\n      .union([", "        vine.union.if((value) => hasType(value, 'email'), emailContact),\n        vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n      ])\n      .otherwise((_, field) => {\n        field.report(\n          'Invalid contact. Either provide an email or a phone number',\n          'unknown_contact_type',\n          field\n        )\n      })\n\n    const schema = vine.object({\n      contacts: vine.array(contact),\n    })\n\n    const data = {\n      contacts: [\n        {\n          type: 'email' as const,\n          email: 'foo@bar.com',\n        },\n      ],\n    }\n\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n})\n"]}
{"filename": "tests/integration/schema/union_of_types.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport vine from '../../../index.js'\n\ntest.group('UnionOfTypes', () => {\n  test('report error when none of the unions match', async ({ assert }) => {\n    const schema = vine.object({\n      health_check: vine.unionOfTypes([vine.boolean(), vine.string().url()]),\n    })\n", "    })\n\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        rule: 'unionOfTypes',\n        field: 'health_check',\n        message: 'Invalid value provided for health_check field',\n      },\n    ])", "      },\n    ])\n  })\n\n  test('report error when union schema reports error', async ({ assert }) => {\n    const schema = vine.object({\n      health_check: vine.unionOfTypes([vine.boolean(), vine.string().url()]),\n    })\n\n    const data = {", "\n    const data = {\n      health_check: 'foo',\n    }\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        rule: 'url',\n        field: 'health_check',\n        message: 'The health_check field must be a valid URL',\n      },", "        message: 'The health_check field must be a valid URL',\n      },\n    ])\n  })\n\n  test('pass validation when data is valid as per union schema', async ({ assert }) => {\n    const schema = vine.object({\n      health_check: vine.unionOfTypes([vine.boolean(), vine.string().url()]),\n    })\n", "    })\n\n    const data = {\n      health_check: 'https://foo.com',\n    }\n    await assert.validationOutput(vine.validate({ schema, data }), data)\n  })\n\n  test('report error using otherwise callback', async ({ assert }) => {\n    const schema = vine.object({", "  test('report error using otherwise callback', async ({ assert }) => {\n    const schema = vine.object({\n      health_check: vine\n        .unionOfTypes([vine.boolean(), vine.string().url()])\n        .otherwise((_, field) => {\n          field.report('The health_check url must be a boolean or string', 'invalid_url', field)\n        }),\n    })\n\n    const data = {}", "\n    const data = {}\n    await assert.validationErrors(vine.validate({ schema, data }), [\n      {\n        field: 'health_check',\n        message: 'The health_check url must be a boolean or string',\n        rule: 'invalid_url',\n      },\n    ])\n  })", "    ])\n  })\n\n  test('disallow duplicate types', async ({ assert }) => {\n    assert.throws(\n      () => vine.unionOfTypes([vine.string().email(), vine.string().url()]),\n      'Cannot use duplicate schema \"vine.string\". \"vine.unionOfTypes\" needs distinct schema types only'\n    )\n\n    assert.throws(", "\n    assert.throws(\n      () => vine.unionOfTypes([vine.record(vine.string()), vine.record(vine.number())]),\n      'Cannot use duplicate schema \"vine.object\". \"vine.unionOfTypes\" needs distinct schema types only'\n    )\n  })\n\n  test('disallow union inside union of types', async ({ assert }) => {\n    assert.throws(\n      () => vine.unionOfTypes([vine.union([])]),\n      'Cannot use \"VineUnion\". The schema type is not compatible for use with \"vine.unionOfTypes\"'\n    )\n  })\n})\n", "    assert.throws(\n      () => vine.unionOfTypes([vine.union([])]),\n      'Cannot use \"VineUnion\". The schema type is not compatible for use with \"vine.unionOfTypes\"'\n    )\n  })\n})\n"]}
{"filename": "tests/types/types.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Vine } from '../../src/vine/main.js'\nimport { Infer, ValidationOptions } from '../../src/types.js'\n\nconst vine = new Vine()\n\ntest.group('Types | Flat schema', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({", "  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string(),\n      is_admin: vine.boolean(),\n    })\n\n    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string\n      is_admin: boolean\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string().nullable(),\n      is_admin: vine.boolean(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null\n      is_admin: boolean\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string().optional().nullable(),\n      is_admin: vine.boolean().optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null | undefined\n      is_admin: boolean | undefined\n    }>()\n  })\n\n  test('infer types with transform function', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string().transform((value) => value),\n      email: vine.string().nullable().optional(),\n      is_admin: vine\n        .boolean()\n        .nullable()\n        .transform((value) => {", "          if (value === null) {\n            return false\n          }\n\n          return value\n        }),\n    })\n\n    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null | undefined\n      is_admin: boolean\n    }>()\n  })\n\n  test('convert keys to camelCase', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        username: vine.string().transform((value) => value),\n        email: vine.string().nullable().optional(),\n        is_admin: vine\n          .boolean()\n          .nullable()\n          .transform((value) => {", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null | undefined\n      is_admin: boolean\n    }>()\n  })\n\n  test('convert keys to camelCase', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        username: vine.string().transform((value) => value),\n        email: vine.string().nullable().optional(),\n        is_admin: vine\n          .boolean()\n          .nullable()\n          .transform((value) => {", "            if (value === null) {\n              return false\n            }\n\n            return value\n          }),\n      })\n      .toCamelCase()\n\n    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null | undefined\n      isAdmin: boolean\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        username: vine\n          .string()\n          .clone()\n          .transform((value) => value),\n        email: vine.string().nullable().optional().clone(),\n        is_admin: vine\n          .boolean()\n          .nullable()\n          .transform((value) => {", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null | undefined\n      isAdmin: boolean\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        username: vine\n          .string()\n          .clone()\n          .transform((value) => value),\n        email: vine.string().nullable().optional().clone(),\n        is_admin: vine\n          .boolean()\n          .nullable()\n          .transform((value) => {", "            if (value === null) {\n              return false\n            }\n\n            return value\n          })\n          .clone(),\n      })\n      .toCamelCase()\n      .clone()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | null | undefined\n      isAdmin: boolean\n    }>()\n  })\n})\n\ntest.group('Types | Nested schema', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string(),\n      is_admin: vine.boolean(),\n      profile: vine.object({\n        twitter_handle: vine.string(),\n        github_username: vine.string(),\n      }),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string\n      is_admin: boolean\n      profile: {\n        twitter_handle: string\n        github_username: string\n      }\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string(),\n      is_admin: vine.boolean(),\n      profile: vine\n        .object({\n          twitter_handle: vine.string(),\n          github_username: vine.string(),\n        })\n        .nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string\n      is_admin: boolean\n      profile: {\n        twitter_handle: string\n        github_username: string\n      } | null\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string().optional(),\n      is_admin: vine.boolean(),\n      profile: vine\n        .object({\n          twitter_handle: vine.string(),\n          github_username: vine.string().optional(),\n        })\n        .nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | undefined\n      is_admin: boolean\n      profile: {\n        twitter_handle: string\n        github_username: string | undefined\n      } | null\n    }>()\n  })\n\n  test('infer types with transform function', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string().optional(),\n      is_admin: vine.boolean(),\n      profile: vine\n        .object({\n          twitter_handle: vine.string(),\n          github_username: vine\n            .string()\n            .nullable()\n            .transform((value) => value || true),\n        })\n        .nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | undefined\n      is_admin: boolean\n      profile: {\n        twitter_handle: string\n        github_username: string | true\n      } | null\n    }>()\n  })\n\n  test('convert keys to camelCase', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        username: vine.string(),\n        email: vine.string().optional(),\n        is_admin: vine.boolean(),\n        profile: vine\n          .object({\n            twitter_handle: vine.string(),\n            github_username: vine.string().nullable(),\n          })\n          .nullable(),\n      })\n      .toCamelCase()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | undefined\n      isAdmin: boolean\n      profile: {\n        twitterHandle: string\n        githubUsername: string | null\n      } | null\n    }>()\n  })\n\n  test('convert nested object keys to camelCase', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      username: vine.string(),\n      email: vine.string().optional(),\n      is_admin: vine.boolean(),\n      profile: vine\n        .object({\n          twitter_handle: vine.string(),\n          github_username: vine.string().nullable(),\n        })\n        .toCamelCase()\n        .nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | undefined\n      is_admin: boolean\n      profile: {\n        twitterHandle: string\n        githubUsername: string | null\n      } | null\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        username: vine.string().clone(),\n        email: vine.string().optional().clone(),\n        is_admin: vine.boolean(),\n        profile: vine\n          .object({\n            twitter_handle: vine.string(),\n            github_username: vine.string().nullable(),\n          })\n          .clone()\n          .nullable(),\n      })\n      .clone()\n      .toCamelCase()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string | undefined\n      isAdmin: boolean\n      profile: {\n        twitterHandle: string\n        githubUsername: string | null\n      } | null\n    }>()\n  })\n})\n\ntest.group('Types | Object groups', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      {\n        visitor_name: string\n      } & (\n        | {\n            hiring_guide: true\n            guide_name: string\n            fees: string\n          }\n        | {\n            hiring_guide: false\n          }\n      )\n    >()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .nullable()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      | ({\n          visitor_name: string\n        } & (\n          | {\n              hiring_guide: true\n              guide_name: string\n              fees: string\n            }\n          | {\n              hiring_guide: false\n            }\n        ))\n      | null\n    >()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .optional()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      | ({\n          visitor_name: string\n        } & (\n          | {\n              hiring_guide: true\n              guide_name: string\n              fees: string\n            }\n          | {\n              hiring_guide: false\n            }\n        ))\n      | undefined\n    >()\n  })\n\n  test('infer types with multiple groups', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const monumentSchema = vine.group([", "      vine.group.if((data) => data.monument === 'foo', {\n        monument: vine.literal('foo'),\n        available_transport: vine.enum(['bus', 'train']),\n        has_free_entry: vine.literal(false),\n      }),\n      vine.group.if((data) => data.monument === 'bar', {\n        monument: vine.literal('bar'),\n        available_transport: vine.enum(['bus', 'car']),\n        has_free_entry: vine.literal(true),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .merge(monumentSchema)\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      {\n        visitor_name: string\n      } & (\n        | {\n            hiring_guide: true\n            guide_name: string\n            fees: string\n          }\n        | {\n            hiring_guide: false\n          }\n      ) &\n        (\n          | {\n              monument: 'foo'\n              available_transport: 'bus' | 'train'\n              has_free_entry: false\n            }\n          | {\n              monument: 'bar'\n              available_transport: 'bus' | 'car'\n              has_free_entry: true\n            }\n        )\n    >()\n  })\n\n  test('convert keys to camelCase', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .toCamelCase()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      {\n        visitorName: string\n      } & (\n        | {\n            hiringGuide: true\n            guideName: string\n            fees: string\n          }\n        | {\n            hiringGuide: false\n          }\n      )\n    >()\n  })\n\n  test('infer types when allowUnknownProperties is true', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .allowUnknownProperties()\n      .optional()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      | (({\n          visitor_name: string\n        } & (\n          | {\n              hiring_guide: true\n              guide_name: string\n              fees: string\n            }\n          | {\n              hiring_guide: false\n            }\n        )) & { [K: string]: unknown })\n      | undefined\n    >()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string().clone(),\n      })\n      .merge(guideSchema)\n      .allowUnknownProperties()\n      .optional()\n      .clone()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<\n      | (({\n          visitor_name: string\n        } & (\n          | {\n              hiring_guide: true\n              guide_name: string\n              fees: string\n            }\n          | {\n              hiring_guide: false\n            }\n        )) & { [K: string]: unknown })\n      | undefined\n    >()\n  })\n})\n\ntest.group('Types | Arrays', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contacts: vine.array(\n        vine.object({\n          email: vine.string(),\n          is_primary: vine.boolean(),\n        })\n      ),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contacts: {\n        email: string\n        is_primary: boolean\n      }[]\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contacts: vine\n        .array(\n          vine.object({\n            email: vine.string(),\n            is_primary: vine.boolean(),\n          })\n        )\n        .nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contacts:\n        | {\n            email: string\n            is_primary: boolean\n          }[]\n        | null\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contacts: vine\n        .array(\n          vine.object({\n            email: vine.string(),\n            is_primary: vine.boolean(),\n          })\n        )\n        .nullable()\n        .optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contacts:\n        | {\n            email: string\n            is_primary: boolean\n          }[]\n        | null\n        | undefined\n    }>()\n  })\n\n  test('convert keys to camelCase', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        contacts: vine\n          .array(\n            vine.object({\n              email: vine.string(),\n              is_primary: vine.boolean(),\n            })\n          )\n          .nullable()\n          .optional(),\n      })\n      .toCamelCase()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contacts:\n        | {\n            email: string\n            isPrimary: boolean\n          }[]\n        | null\n        | undefined\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        contacts: vine\n          .array(\n            vine.object({\n              email: vine.string().clone(),\n              is_primary: vine.boolean().clone(),\n            })\n          )\n          .nullable()\n          .clone()\n          .optional(),\n      })\n      .toCamelCase()\n      .clone()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contacts:\n        | {\n            email: string\n            isPrimary: boolean\n          }[]\n        | null\n        | undefined\n    }>()\n  })\n})\n\ntest.group('Types | Tuples', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine.tuple([vine.string(), vine.string(), vine.string()]),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: [string, string, string]\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine.tuple([vine.string(), vine.string(), vine.string()]).nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: [string, string, string] | null\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine.tuple([vine.string(), vine.string(), vine.string()]).nullable().optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: [string, string, string] | null | undefined\n    }>()\n  })\n\n  test('allow unknown properties', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine\n        .tuple([vine.string(), vine.string(), vine.string()])\n        .allowUnknownProperties()\n        .nullable()\n        .optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: [string, string, string, ...unknown[]] | null | undefined\n    }>()\n  })\n\n  test('convert keys to camelCase', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        colors: vine\n          .tuple([\n            vine.string(),\n            vine.string(),\n            vine.object({\n              primary_1: vine.string(),\n            }),\n          ])\n          .allowUnknownProperties()\n          .nullable()\n          .optional(),\n      })\n      .toCamelCase()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: [string, string, { primary1: string }, ...unknown[]] | null | undefined\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        colors: vine\n          .tuple([\n            vine.string().clone(),\n            vine.string().clone(),\n            vine\n              .object({\n                primary_1: vine.string(),\n              })\n              .clone(),\n          ])\n          .allowUnknownProperties()\n          .nullable()\n          .clone()\n          .optional(),\n      })\n      .toCamelCase()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: [string, string, { primary1: string }, ...unknown[]] | null | undefined\n    }>()\n  })\n})\n\ntest.group('Types | Union', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contact: vine.union([", "        vine.union.if(\n          (value) => vine.helpers.isObject(value) && 'email' in value,\n          vine.object({\n            email: vine.string(),\n            otp: vine.string(),\n          })\n        ),\n        vine.union.if(\n          (value) => vine.helpers.isObject(value) && 'username' in value,\n          vine.object({\n            username: vine.string(),\n            password: vine.string(),\n          })\n        ),\n      ]),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contact:\n        | {\n            email: string\n            otp: string\n          }\n        | {\n            username: string\n            password: string\n          }\n    }>()\n  })\n\n  test('infer types of nested unions', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contact: vine.union([", "        vine.union.if(\n          (value) => vine.helpers.isObject(value) && 'email' in value,\n          vine.union([\n            vine.union.if(\n              (value) => vine.helpers.isObject(value) && 'otp' in value,\n              vine.object({\n                otp: vine.string(),\n              })\n            ),\n            vine.union.else(\n              vine.object({\n                email: vine.string(),\n              })\n            ),\n          ])\n        ),", "        vine.union.if(\n          (value) => vine.helpers.isObject(value) && 'username' in value,\n          vine.object({\n            username: vine.string(),\n            password: vine.string(),\n          })\n        ),\n      ]),\n    })\n\n    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contact:\n        | {\n            email: string\n          }\n        | {\n            otp: string\n          }\n        | {\n            username: string\n            password: string\n          }\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contact: vine\n        .union([", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contact:\n        | {\n            email: string\n          }\n        | {\n            otp: string\n          }\n        | {\n            username: string\n            password: string\n          }\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      contact: vine\n        .union([", "          vine.union.if(\n            (value) => vine.helpers.isObject(value) && 'email' in value,\n            vine.union([\n              vine.union.if(\n                (value) => vine.helpers.isObject(value) && 'otp' in value,\n                vine\n                  .object({\n                    otp: vine.string(),\n                  })\n                  .clone()\n              ),\n              vine.union.else(\n                vine\n                  .object({\n                    email: vine.string(),\n                  })\n                  .clone()\n              ),\n            ])\n          ),", "          vine.union.if(\n            (value) => vine.helpers.isObject(value) && 'username' in value,\n            vine.object({\n              username: vine.string().clone(),\n              password: vine.string().clone(),\n            })\n          ),\n        ])\n        .clone(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      contact:\n        | {\n            email: string\n          }\n        | {\n            otp: string\n          }\n        | {\n            username: string\n            password: string\n          }\n    }>()\n  })\n})\n\ntest.group('Types | Record', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine.record(vine.string()),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: {\n        [K: string]: string\n      }\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine.record(vine.string()).nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: {\n        [K: string]: string\n      } | null\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      colors: vine.record(vine.string()).optional().nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors:\n        | {\n            [K: string]: string\n          }\n        | undefined\n        | null\n    }>()\n  })\n\n  test('infer union record types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      /**\n       * @todo: Use union of types here\n       */\n      colors: vine.record(vine.string()),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: {\n        [K: string]: string\n      }\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      /**\n       * @todo: Use union of types here\n       */\n      colors: vine.record(vine.string()).clone(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      colors: {\n        [K: string]: string\n      }\n    }>()\n  })\n})\n\ntest.group('Types | Enum', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        role: vine.enum(['admin', 'moderator', 'writer']),\n      })\n      .clone()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      role: 'admin' | 'moderator' | 'writer'\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      role: vine.enum(['admin', 'moderator', 'writer']).nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      role: 'admin' | 'moderator' | 'writer' | null\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      role: vine.enum(['admin', 'moderator', 'writer']).nullable().optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      role: 'admin' | 'moderator' | 'writer' | null | undefined\n    }>()\n  })\n\n  test('infer types from native enum', ({ expectTypeOf }) => {\n    enum Role {\n      MODERATOR = 'moderator',\n      WRITER = 'writer',\n      ADMIN = 'admin',\n    }\n\n    const schema = vine.object({\n      role: vine.enum(Role).nullable().optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      role: Role | null | undefined\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    enum Role {\n      MODERATOR = 'moderator',\n      WRITER = 'writer',\n      ADMIN = 'admin',\n    }\n\n    const schema = vine\n      .object({\n        role: vine.enum(Role).nullable().optional().clone(),\n      })\n      .clone()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      role: Role | null | undefined\n    }>()\n  })\n})\n\ntest.group('Types | Accepted', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      terms_and_conditions: vine.accepted(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      terms_and_conditions: true\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      terms_and_conditions: vine.accepted().nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      terms_and_conditions: true | null\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      terms_and_conditions: vine.accepted().nullable().optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      terms_and_conditions: true | null | undefined\n    }>()\n  })\n\n  test('infer types with transformer', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      terms_and_conditions: vine\n        .accepted()\n        .nullable()\n        .optional()\n        .transform(() => {\n          return true\n        }),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      terms_and_conditions: boolean\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      terms_and_conditions: vine.accepted().clone().nullable().optional(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      terms_and_conditions: true | null | undefined\n    }>()\n  })\n})\n\ntest.group('Types | Any', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      secret_message: vine.any(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      secret_message: any\n    }>()\n  })\n\n  test('infer types with nullable fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      secret_message: vine.any().nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      secret_message: any\n    }>()\n  })\n\n  test('infer types with optional fields', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      secret_message: vine.any().optional().nullable(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      secret_message: any\n    }>()\n  })\n\n  test('infer types with transformer', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      secret_message: vine.any().transform(() => {\n        return '1234'\n      }),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      secret_message: string\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      secret_message: vine\n        .any()\n        .transform(() => {\n          return '1234'\n        })\n        .clone(),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      secret_message: string\n    }>()\n  })\n})\n\ntest.group('Types | UnionOfTypes', () => {\n  test('infer types', ({ expectTypeOf }) => {\n    const schema = vine.object({\n      health_check: vine.unionOfTypes([vine.boolean(), vine.string()]),\n    })\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      health_check: boolean | string\n    }>()\n  })\n\n  test('clone types', ({ expectTypeOf }) => {\n    const schema = vine\n      .object({\n        health_check: vine.unionOfTypes([vine.boolean(), vine.string()]),\n      })\n      .clone()\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      health_check: boolean | string\n    }>()\n  })\n})\n\ntest.group('Types | compiled schema', () => {\n  test('infer types from compiled schema', ({ expectTypeOf }) => {\n    const schema = vine.compile(\n      vine.object({\n        username: vine.string(),\n        email: vine.string(),\n        is_admin: vine.boolean(),\n      })\n    )\n", "    type Schema = Infer<typeof schema>\n    expectTypeOf<Schema>().toEqualTypeOf<{\n      username: string\n      email: string\n      is_admin: boolean\n    }>()\n  })\n\n  test('ensure type-safety for metadata', ({ expectTypeOf }) => {\n    const schema = vine.withMetaData<{ userId: number }>().compile(\n      vine.object({\n        username: vine.string(),\n        email: vine.string(),\n        is_admin: vine.boolean(),\n      })\n    )\n\n    // @ts-expect-error\n    schema.validate({})\n    // @ts-expect-error\n    schema.validate({}, {})\n    // @ts-expect-error\n    schema.validate({}, { meta: { foo: 'bar' } })\n\n    expectTypeOf<typeof schema.validate>().parameters.toEqualTypeOf<\n      [any, ValidationOptions<{ userId: number }>]\n    >\n  })\n})\n"]}
{"filename": "tests/unit/create_rule.spec.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { createRule } from '../../src/vine/create_rule.js'\n\ntest.group('Create rule', () => {\n  test('create a custom validation rule', ({ assert }) => {\n    function validator() {}\n    const ruleFn = createRule(validator)\n\n    assert.strictEqual(ruleFn().rule.validator, validator)\n  })\n\n  test('infer options from validator', ({ assert, expectTypeOf }) => {", "    function validator(_: unknown, __: { foo: string; bar: boolean }) {}\n    const ruleFn = createRule(validator)\n\n    expectTypeOf(ruleFn).parameters.toEqualTypeOf<[{ foo: string; bar: boolean }]>()\n    assert.deepEqual(ruleFn({ foo: '1', bar: true }).options, { foo: '1', bar: true })\n  })\n\n  test('infer optional options from validator', ({ assert, expectTypeOf }) => {\n    function validator(_: unknown, __?: { foo: string; bar: boolean }) {}\n    const ruleFn = createRule(validator)\n\n    expectTypeOf(ruleFn).parameters.toEqualTypeOf<[{ foo: string; bar: boolean }?]>()\n    assert.deepEqual(ruleFn({ foo: '1', bar: true }).options, { foo: '1', bar: true })\n  })\n\n  test('infer async validator functions', ({ assert }) => {", "    function validator(_: unknown, __?: { foo: string; bar: boolean }) {}\n    const ruleFn = createRule(validator)\n\n    expectTypeOf(ruleFn).parameters.toEqualTypeOf<[{ foo: string; bar: boolean }?]>()\n    assert.deepEqual(ruleFn({ foo: '1', bar: true }).options, { foo: '1', bar: true })\n  })\n\n  test('infer async validator functions', ({ assert }) => {\n    async function validator() {}\n    const ruleFn = createRule(validator)\n\n    assert.isTrue(ruleFn().rule.isAsync)\n  })\n\n  test('mark validation as implicit', ({ assert }) => {", "    async function validator() {}\n    const ruleFn = createRule(validator)\n\n    assert.isTrue(ruleFn().rule.isAsync)\n  })\n\n  test('mark validation as implicit', ({ assert }) => {\n    async function validator() {}\n    const ruleFn = createRule(validator, { implicit: true })\n\n    assert.isTrue(ruleFn().rule.implicit)\n  })\n\n  test('do not allow marking async functions as non-async', ({ assert }) => {", "    async function validator() {}\n    const ruleFn = createRule(validator, { implicit: true, isAsync: false })\n\n    assert.isTrue(ruleFn().rule.isAsync)\n  })\n\n  test('allow marking functions as async', ({ assert }) => {\n    function validator() {}\n    const ruleFn = createRule(validator, { implicit: true, isAsync: true })\n\n    assert.isTrue(ruleFn().rule.isAsync)\n  })\n\n  test('allow marking non async functions as non-async', ({ assert }) => {", "    function validator() {}\n    const ruleFn = createRule(validator, { implicit: true, isAsync: false })\n\n    assert.isFalse(ruleFn().rule.isAsync)\n  })\n})\n"]}
{"filename": "tests/unit/validation_error.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { ValidationError } from '../../src/errors/validation_error.js'\n\ntest.group('Exception', () => {\n  test('create exception with error messages', ({ assert }) => {\n    const error = new ValidationError([{ message: 'Field is required' }])\n\n    assert.equal(error.message, 'Validation failure')\n    assert.equal(error.status, 422)", "    assert.equal(error.message, 'Validation failure')\n    assert.equal(error.status, 422)\n    assert.equal(error.code, 'E_VALIDATION_ERROR')\n    assert.deepEqual(error.messages, [{ message: 'Field is required' }])\n  })\n\n  test('point stack trace to correct file', ({ assert }) => {\n    assert.plan(1)\n\n    try {\n      throw new ValidationError([{ message: 'Field is required' }])", "\n    try {\n      throw new ValidationError([{ message: 'Field is required' }])\n    } catch (error) {\n      assert.match(error.stack.split('\\n')[1], /validation_error.spec.ts/)\n    }\n  })\n\n  test('convert error to string', ({ assert }) => {\n    const error = new ValidationError([{ message: 'Field is required' }])\n    assert.equal(error.toString(), 'Error [E_VALIDATION_ERROR]: Validation failure')\n  })\n", "  test('get class string name', ({ assert }) => {\n    const error = new ValidationError([{ message: 'Field is required' }])\n    assert.equal(Object.prototype.toString.call(error), '[object ValidationError]')\n  })\n})\n"]}
{"filename": "tests/unit/helpers.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { Vine } from '../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('Vine Helpers', () => {\n  test('check if the value is true', ({ assert }) => {\n    assert.isTrue(vine.helpers.isTrue(true))\n    assert.isTrue(vine.helpers.isTrue(1))", "    assert.isTrue(vine.helpers.isTrue(true))\n    assert.isTrue(vine.helpers.isTrue(1))\n    assert.isTrue(vine.helpers.isTrue('true'))\n    assert.isTrue(vine.helpers.isTrue('1'))\n    assert.isTrue(vine.helpers.isTrue('on'))\n    assert.isFalse(vine.helpers.isTrue('foo'))\n  })\n\n  test('check if the value is false', ({ assert }) => {\n    assert.isTrue(vine.helpers.isFalse(false))", "  test('check if the value is false', ({ assert }) => {\n    assert.isTrue(vine.helpers.isFalse(false))\n    assert.isTrue(vine.helpers.isFalse(0))\n    assert.isTrue(vine.helpers.isFalse('false'))\n    assert.isTrue(vine.helpers.isFalse('0'))\n    assert.isFalse(vine.helpers.isFalse('on'))\n    assert.isFalse(vine.helpers.isFalse('true'))\n  })\n\n  test('check if the value is string', ({ assert, expectTypeOf }) => {", "\n  test('check if the value is string', ({ assert, expectTypeOf }) => {\n    assert.isTrue(vine.helpers.isString('hello'))\n    assert.isFalse(vine.helpers.isString(true))\n\n    const value: unknown = 'hello'\n    if (vine.helpers.isString(value)) {\n      expectTypeOf(value).toEqualTypeOf<string>()\n    }\n  })\n\n  test('check if the value is object', ({ assert, expectTypeOf }) => {\n    assert.isTrue(vine.helpers.isObject({}))\n    assert.isFalse(vine.helpers.isObject(null))\n    assert.isFalse(vine.helpers.isObject([]))\n    assert.isFalse(vine.helpers.isObject('hello'))\n\n    const value: unknown = { foo: 'bar' }", "    if (vine.helpers.isObject(value)) {\n      expectTypeOf(value).toEqualTypeOf<Record<PropertyKey, unknown>>()\n      assert.equal(value.foo, 'bar')\n      assert.isUndefined(value.baz)\n    }\n\n    if (vine.helpers.isObject<string>(value)) {\n      expectTypeOf(value).toEqualTypeOf<Record<PropertyKey, string>>()\n    }\n  })\n\n  test('check if the value is array', ({ assert, expectTypeOf }) => {\n    assert.isTrue(vine.helpers.isArray([]))\n    assert.isFalse(vine.helpers.isArray(null))\n    assert.isFalse(vine.helpers.isArray({}))\n    assert.isFalse(vine.helpers.isArray('hello'))\n\n    const value: unknown = ['hello', 'world']", "    if (vine.helpers.isArray(value)) {\n      expectTypeOf(value).toEqualTypeOf<unknown[]>()\n      assert.equal(value[0], 'hello')\n      assert.equal(value[1], 'world')\n    }\n\n    if (vine.helpers.isArray<string>(value)) {\n      expectTypeOf(value).toEqualTypeOf<string[]>()\n    }\n  })\n\n  test('check if the value is numeric', ({ assert }) => {\n    assert.isTrue(vine.helpers.isNumeric('22'))\n    assert.isTrue(vine.helpers.isNumeric('22.12'))\n    assert.isTrue(vine.helpers.isNumeric('22.00'))\n    assert.isFalse(vine.helpers.isNumeric('foo'))\n  })\n\n  test('convert value to number', ({ assert }) => {\n    assert.equal(vine.helpers.asNumber('22'), 22)\n    assert.equal(vine.helpers.asNumber('22.12'), 22.12)\n    assert.equal(vine.helpers.asNumber('22.00'), 22)\n    assert.isNaN(vine.helpers.asNumber('foo'))\n  })\n\n  test('convert value to boolean', ({ assert }) => {\n    assert.equal(vine.helpers.asBoolean(true), true)\n    assert.equal(vine.helpers.asBoolean(1), true)\n    assert.equal(vine.helpers.asBoolean('true'), true)\n    assert.equal(vine.helpers.asBoolean('1'), true)\n    assert.equal(vine.helpers.asBoolean('on'), true)\n    assert.isNull(vine.helpers.asBoolean('foo'))\n\n    assert.equal(vine.helpers.asBoolean(false), false)\n    assert.equal(vine.helpers.asBoolean(0), false)\n    assert.equal(vine.helpers.asBoolean('false'), false)\n    assert.equal(vine.helpers.asBoolean('0'), false)\n    assert.isNull(vine.helpers.asBoolean('foo'))\n  })\n\n  test('check if the value is missing', ({ assert }) => {\n    assert.isTrue(vine.helpers.isMissing(null))\n    assert.isTrue(vine.helpers.isMissing(undefined))\n    assert.isFalse(vine.helpers.isMissing(''))\n  })\n\n  test('check if the value exists', ({ assert }) => {\n    assert.isFalse(vine.helpers.exists(null))\n    assert.isFalse(vine.helpers.exists(undefined))\n    assert.isTrue(vine.helpers.exists(''))\n  })\n\n  test('DNS: return {result} for {url}')", "    .with([\n      {\n        url: 'foo',\n        result: false,\n      },\n      {\n        url: 'https://foo',\n        result: false,\n      },\n      {\n        url: 'http://google.com',\n        result: true,\n      },\n      {\n        url: 'http://www.google.com',\n        result: true,\n      },\n      {\n        url: 'http://www.google.com/terms',\n        result: true,\n      },\n    ])\n    .run(async ({ assert }, { url, result }) => {\n      assert.equal(await vine.helpers.isActiveURL(url), result)\n    })\n\n  test('mobileLocales contains the list of mobile locales', ({ assert }) => {\n    const codes = vine.helpers.mobileLocales\n    assert.containsSubset(codes, ['fr-FR', 'en-GB', 'de-DE'])\n  })\n\n  test('postalCountryCodes contains the list of postal country codes', ({ assert }) => {\n    const codes = vine.helpers.postalCountryCodes\n    assert.containsSubset(codes, ['FR', 'GB', 'IT'])\n  })\n\n  test('validator.js functions are working', ({ assert }) => {\n    assert.isTrue(vine.helpers.isSlug('hello-world'))\n    assert.isTrue(vine.helpers.isPostalCode('69200', 'FR'))\n    assert.isTrue(vine.helpers.isMobilePhone('0612345678', 'fr-FR'))\n  })\n})\n"]}
{"filename": "tests/unit/simple_messages_provider.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { fieldContext } from '../../factories/main.js'\nimport { SimpleMessagesProvider } from '../../src/messages_provider/simple_messages_provider.js'\n\ntest.group('Simple messages provider | resolving messages', () => {\n  test('get custom message for a rule', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        required: 'The field is required',", "      {\n        required: 'The field is required',\n      },\n      {}\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n      'The field is required'\n    )", "      'The field is required'\n    )\n  })\n\n  test('give priority to field message', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        'required': 'The field is required',\n        'username.required': 'Username is required',\n      },", "        'username.required': 'Username is required',\n      },\n      {}\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n      'Username is required'\n    )\n  })", "    )\n  })\n\n  test('use default message when no message is provided', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        'username.required': 'Username is required',\n      },\n      {}\n    )", "      {}\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'required', fieldContext.create('email', undefined)),\n      'Enter value'\n    )\n  })\n})\n", "})\n\ntest.group('Simple messages provider | resolving fields', () => {\n  test('substitue field name in custom message', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        required: 'The {{ field }} field is required',\n      },\n      {\n        username: 'account id',", "      {\n        username: 'account id',\n      }\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n      'The account id field is required'\n    )\n  })", "    )\n  })\n\n  test('substitue field name in field message', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        'required': 'The field is required',\n        'username.required': 'The {{ field }} is required',\n      },\n      {", "      },\n      {\n        username: 'account id',\n      }\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n      'The account id is required'\n    )", "      'The account id is required'\n    )\n  })\n\n  test('substitue field name in default message', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        'username.required': 'Username is required',\n      },\n      {", "      },\n      {\n        email: 'email address',\n      }\n    )\n\n    assert.equal(\n      provider.getMessage('Enter {{ field }}', 'required', fieldContext.create('email', undefined)),\n      'Enter email address'\n    )", "      'Enter email address'\n    )\n  })\n})\n\ntest.group('Simple messages provider | interpolation', () => {\n  test('interpolate reported args', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        min: 'The {{ field }} field must have {{ min }} items',", "      {\n        min: 'The {{ field }} field must have {{ min }} items',\n      },\n      {}\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {\n        min: 11,\n      }),", "        min: 11,\n      }),\n      'The scores field must have 11 items'\n    )\n  })\n\n  test('interpolate nested args', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        min: 'The {{ field }} field must have {{ items.min }} items',", "      {\n        min: 'The {{ field }} field must have {{ items.min }} items',\n      },\n      {}\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {\n        items: {\n          min: 11,", "        items: {\n          min: 11,\n        },\n      }),\n      'The scores field must have 11 items'\n    )\n  })\n\n  test('replace missing values with undefined', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(", "  test('replace missing values with undefined', ({ assert }) => {\n    const provider = new SimpleMessagesProvider(\n      {\n        min: 'The {{ field }} field must have {{ items.min }} items',\n      },\n      {}\n    )\n\n    assert.equal(\n      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {}),", "    assert.equal(\n      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {}),\n      'The scores field must have undefined items'\n    )\n  })\n})\n"]}
{"filename": "tests/unit/simple_error_reporter.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { fieldContext } from '../../factories/main.js'\nimport { ValidationError } from '../../src/errors/validation_error.js'\nimport { SimpleErrorReporter } from '../../src/reporters/simple_error_reporter.js'\n\ntest.group('Simple error reporter', () => {\n  test('collect reported errors', ({ assert }) => {\n    const reporter = new SimpleErrorReporter()\n    const field = fieldContext.create('username', '')", "    const reporter = new SimpleErrorReporter()\n    const field = fieldContext.create('username', '')\n    reporter.report('The username field is required', 'required', field)\n\n    assert.isTrue(reporter.hasErrors)\n    assert.deepEqual(reporter.errors, [\n      {\n        field: 'username',\n        message: 'The username field is required',\n        rule: 'required',", "        message: 'The username field is required',\n        rule: 'required',\n      },\n    ])\n  })\n\n  test('collect error meta data', ({ assert }) => {\n    const reporter = new SimpleErrorReporter()\n    const field = fieldContext.create('username', '')\n    reporter.report('The username field is required', 'required', field, {", "    const field = fieldContext.create('username', '')\n    reporter.report('The username field is required', 'required', field, {\n      requiredWhen: {\n        missing: 'email',\n      },\n    })\n\n    assert.isTrue(reporter.hasErrors)\n    assert.deepEqual(reporter.errors, [\n      {", "    assert.deepEqual(reporter.errors, [\n      {\n        field: 'username',\n        message: 'The username field is required',\n        rule: 'required',\n        meta: {\n          requiredWhen: {\n            missing: 'email',\n          },\n        },", "          },\n        },\n      },\n    ])\n  })\n\n  test('report array index when field is an array member', ({ assert }) => {\n    const reporter = new SimpleErrorReporter()\n    const field = fieldContext.create('username', '')\n    reporter.report('Scores are required', 'required', {", "    const field = fieldContext.create('username', '')\n    reporter.report('Scores are required', 'required', {\n      ...field,\n      ...{\n        isArrayMember: true,\n        name: 0,\n        wildCardPath: 'scores.*',\n        parent: [],\n      },\n    })", "      },\n    })\n\n    assert.isTrue(reporter.hasErrors)\n    assert.deepEqual(reporter.errors, [\n      {\n        field: 'scores.*',\n        message: 'Scores are required',\n        index: 0,\n        rule: 'required',", "        index: 0,\n        rule: 'required',\n      },\n    ])\n  })\n\n  test('convert errors to an instance of validation error', ({ assert }) => {\n    const reporter = new SimpleErrorReporter()\n    const field = fieldContext.create('username', '')\n    reporter.report('The username field is required', 'required', field, {", "    const field = fieldContext.create('username', '')\n    reporter.report('The username field is required', 'required', field, {\n      requiredWhen: {\n        missing: 'email',\n      },\n    })\n\n    const error = reporter.createError()\n    assert.isTrue(reporter.hasErrors)\n    assert.instanceOf(error, ValidationError)", "    assert.isTrue(reporter.hasErrors)\n    assert.instanceOf(error, ValidationError)\n    assert.deepEqual(error.messages, [\n      {\n        field: 'username',\n        message: 'The username field is required',\n        rule: 'required',\n        meta: {\n          requiredWhen: {\n            missing: 'email',", "          requiredWhen: {\n            missing: 'email',\n          },\n        },\n      },\n    ])\n  })\n})\n", ""]}
{"filename": "tests/unit/rules/number.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validator } from '../../../factories/main.js'\nimport {\n  minRule,\n  maxRule,\n  rangeRule,\n  numberRule,\n  positiveRule,\n  negativeRule,", "  positiveRule,\n  negativeRule,\n  decimalRule,\n  withoutDecimalsRule,\n} from '../../../src/schema/number/rules.js'\n\ntest.group('Number | number', () => {\n  test('report when value is not a number', () => {\n    const number = numberRule({})\n    const validated = validator.execute(number, 'foo')", "    const number = numberRule({})\n    const validated = validator.execute(number, 'foo')\n\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('pass validation when value is a number', () => {\n    const number = numberRule({})\n    const validated = validator.execute(number, 22)\n", "    const validated = validator.execute(number, 22)\n\n    validated.assertSucceeded()\n    validated.assertOutput(22)\n  })\n\n  test('pass validation when value is a string representation of a number', () => {\n    const number = numberRule({})\n    const validated = validator.execute(number, '22')\n", "    const validated = validator.execute(number, '22')\n\n    validated.assertSucceeded()\n    validated.assertOutput(22)\n  })\n\n  test('disallow string representation in strict mode', () => {\n    const number = numberRule({ strict: true })\n\n    const validated = validator.execute(number, '22')", "\n    const validated = validator.execute(number, '22')\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n\n    const withNaN = validator.execute(number, Number.NaN)\n    withNaN.assertErrorsCount(1)\n    withNaN.assertError('The dummy field must be a number')\n  })\n", "  })\n\n  test('report when value is an infinite number', () => {\n    const number = numberRule({})\n    const validated = validator.execute(\n      number,\n      '3177777777777777777777777777777777777777777777777777777777777777777777777770000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999991111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n    )\n\n    validated.assertError('The dummy field must be a number')", "\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report when value is a negative infinite number', () => {\n    const number = numberRule({})\n    const validated = validator.execute(\n      number,\n      '-3177777777777777777777777777777777777777777777777777777777777777777777777770000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999991111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n    )", "      '-3177777777777777777777777777777777777777777777777777777777777777777777777770000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999991111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n    )\n\n    validated.assertError('The dummy field must be a number')\n  })\n})\n\ntest.group('Number | min', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})", "  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const min = minRule({ min: 18 })\n    const validated = validator.execute([number, min], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {", "\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const min = minRule({ min: 18 })\n    const validated = validator.bail(false).execute([number, min], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n", "  })\n\n  test('report error when value is less than the minimum value', () => {\n    const number = numberRule({})\n    const min = minRule({ min: 18 })\n    const validated = validator.execute([number, min], 12)\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be at least 18')\n  })", "    validated.assertError('The dummy field must be at least 18')\n  })\n\n  test('pass validation when value is same or greater than the minimum value', () => {\n    const number = numberRule({})\n    const min = minRule({ min: 18 })\n\n    validator.execute([number, min], 18).assertErrorsCount(0)\n    validator.execute([number, min], 20).assertErrorsCount(0)\n  })", "    validator.execute([number, min], 20).assertErrorsCount(0)\n  })\n})\n\ntest.group('Number | max', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const max = maxRule({ max: 60 })\n    const validated = validator.execute([number, max], 'foo')\n", "    const validated = validator.execute([number, max], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const max = maxRule({ max: 60 })\n    const validated = validator.bail(false).execute([number, max], 'foo')", "    const max = maxRule({ max: 60 })\n    const validated = validator.bail(false).execute([number, max], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report error when value is greater than the maximum value', () => {\n    const number = numberRule({})\n    const max = maxRule({ max: 60 })", "    const number = numberRule({})\n    const max = maxRule({ max: 60 })\n    const validated = validator.execute([number, max], 72)\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must not be greater than 60')\n  })\n\n  test('pass validation when value is same or less than the minimum value', () => {\n    const number = numberRule({})", "  test('pass validation when value is same or less than the minimum value', () => {\n    const number = numberRule({})\n    const max = maxRule({ max: 60 })\n\n    validator.execute([number, max], 60).assertErrorsCount(0)\n    validator.execute([number, max], 32).assertErrorsCount(0)\n  })\n})\n\ntest.group('Number | range', () => {", "\ntest.group('Number | range', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const range = rangeRule({ min: 18, max: 60 })\n    const validated = validator.execute([number, range], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })", "    validated.assertError('The dummy field must be a number')\n  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const range = rangeRule({ min: 18, max: 60 })\n    const validated = validator.bail(false).execute([number, range], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')", "    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report error when value is greater than the maximum value', () => {\n    const number = numberRule({})\n    const range = rangeRule({ min: 18, max: 60 })\n    const validated = validator.execute([number, range], 72)\n\n    validated.assertErrorsCount(1)", "\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be between 18 and 60')\n  })\n\n  test('report error when value is less than the minimum value', () => {\n    const number = numberRule({})\n    const range = rangeRule({ min: 18, max: 60 })\n    const validated = validator.execute([number, range], 12)\n", "    const validated = validator.execute([number, range], 12)\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be between 18 and 60')\n  })\n\n  test('pass validation when value is under the range', () => {\n    const number = numberRule({})\n    const range = rangeRule({ min: 18, max: 60 })\n", "    const range = rangeRule({ min: 18, max: 60 })\n\n    validator.execute([number, range], 18).assertErrorsCount(0)\n    validator.execute([number, range], 60).assertErrorsCount(0)\n    validator.execute([number, range], 22).assertErrorsCount(0)\n  })\n})\n\ntest.group('Number | positive', () => {\n  test('skip validation when value is not a number', () => {", "test.group('Number | positive', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const positive = positiveRule()\n    const validated = validator.execute([number, positive], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n", "  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const positive = positiveRule()\n    const validated = validator.bail(false).execute([number, positive], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })", "    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report error when value is negative', () => {\n    const number = numberRule({})\n    const positive = positiveRule()\n\n    const validated = validator.execute([number, positive], -10)\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be positive')", "    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be positive')\n\n    const validated1 = validator.execute([number, positive], '-10')\n    validated1.assertErrorsCount(1)\n    validated1.assertError('The dummy field must be positive')\n  })\n\n  test('pass validation when value is positive', () => {\n    const number = numberRule({})", "  test('pass validation when value is positive', () => {\n    const number = numberRule({})\n    const positive = positiveRule()\n\n    validator.execute([number, positive], 10).assertErrorsCount(0)\n    validator.execute([number, positive], '0').assertErrorsCount(0)\n  })\n})\n\ntest.group('Number | negative', () => {", "\ntest.group('Number | negative', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const negative = negativeRule()\n    const validated = validator.execute([number, negative], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })", "    validated.assertError('The dummy field must be a number')\n  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const negative = negativeRule()\n    const validated = validator.bail(false).execute([number, negative], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')", "    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report error when value is positive', () => {\n    const number = numberRule({})\n    const negative = negativeRule()\n\n    const validated = validator.execute([number, negative], 0)\n    validated.assertErrorsCount(1)", "    const validated = validator.execute([number, negative], 0)\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be negative')\n\n    const validated1 = validator.execute([number, negative], '10')\n    validated1.assertErrorsCount(1)\n    validated1.assertError('The dummy field must be negative')\n  })\n\n  test('pass validation when value is negative', () => {", "\n  test('pass validation when value is negative', () => {\n    const number = numberRule({})\n    const negative = negativeRule()\n\n    validator.execute([number, negative], '-10').assertErrorsCount(0)\n    validator.execute([number, negative], -1).assertErrorsCount(0)\n  })\n})\n", "})\n\ntest.group('Number | decimals', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [0, 2] })\n    const validated = validator.execute([number, decimal], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')", "    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [0, 2] })\n    const validated = validator.bail(false).execute([number, decimal], 'foo')\n\n    validated.assertErrorsCount(1)", "\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report error when value has less than fixed decimal places', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [2] })\n    const validated = validator.execute([number, decimal], '9')\n", "    const validated = validator.execute([number, decimal], '9')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must have 2 decimal places')\n  })\n\n  test('report error when value has more than fixed decimal places', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [2] })\n    const validated = validator.execute([number, decimal], '9.9899')", "    const decimal = decimalRule({ range: [2] })\n    const validated = validator.execute([number, decimal], '9.9899')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must have 2 decimal places')\n  })\n\n  test('work fine when value has exact decimal places', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [2] })", "    const number = numberRule({})\n    const decimal = decimalRule({ range: [2] })\n    const validated = validator.execute([number, decimal], '9.99')\n\n    validated.assertSucceeded()\n    validated.assertOutput(9.99)\n  })\n\n  test('report error when value has less than the range of decimal places', () => {\n    const number = numberRule({})", "  test('report error when value has less than the range of decimal places', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [2, 4] })\n    const validated = validator.execute([number, decimal], '9')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must have 2-4 decimal places')\n  })\n\n  test('report error when value has more than the range of decimal places', () => {", "\n  test('report error when value has more than the range of decimal places', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [2, 4] })\n    const validated = validator.execute([number, decimal], '9.90009')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must have 2-4 decimal places')\n  })\n", "  })\n\n  test('work fine when value decimal places are in range', () => {\n    const number = numberRule({})\n    const decimal = decimalRule({ range: [0, 2] })\n\n    const validated = validator.execute([number, decimal], '9.99')\n    validated.assertSucceeded()\n    validated.assertOutput(9.99)\n", "    validated.assertOutput(9.99)\n\n    const validated1 = validator.execute([number, decimal], '9')\n    validated1.assertSucceeded()\n    validated1.assertOutput(9)\n  })\n})\n\ntest.group('Number | withoutDecimals', () => {\n  test('skip validation when value is not a number', () => {", "test.group('Number | withoutDecimals', () => {\n  test('skip validation when value is not a number', () => {\n    const number = numberRule({})\n    const withoutDecimals = withoutDecimalsRule()\n    const validated = validator.execute([number, withoutDecimals], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })\n", "  })\n\n  test('skip validation when value is not a number with bail mode disabled', () => {\n    const number = numberRule({})\n    const withoutDecimals = withoutDecimalsRule()\n    const validated = validator.bail(false).execute([number, withoutDecimals], 'foo')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a number')\n  })", "    validated.assertError('The dummy field must be a number')\n  })\n\n  test('report error when value has decimal places', () => {\n    const number = numberRule({})\n    const withoutDecimals = withoutDecimalsRule()\n    const validated = validator.execute([number, withoutDecimals], '18.11')\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be an integer')", "    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be an integer')\n  })\n\n  test('work fine when value is an integer', () => {\n    const number = numberRule({})\n    const withoutDecimals = withoutDecimalsRule()\n    const validated = validator.execute([number, withoutDecimals], '18.00')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput(18)\n  })\n})\n"]}
{"filename": "tests/unit/rules/enum.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { enumRule } from '../../../src/schema/enum/rules.js'\nimport { ValidatorFactory } from '../../../factories/validator.js'\n\ntest.group('Rules | enum', () => {\n  test('report error when field value is not a subset of pre-defined choices', () => {\n    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n    const value = 'foo'\n", "    const value = 'foo'\n\n    const validated = new ValidatorFactory().execute(validation, value)\n    validated.assertError('The selected dummy is invalid')\n  })\n\n  test('do not validate when value is undefined', () => {\n    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n    const value = undefined\n", "    const value = undefined\n\n    const validated = new ValidatorFactory().execute(validation, value)\n    validated.assertErrorsCount(0)\n  })\n\n  test('do not validate when value is null', () => {\n    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n    const value = null\n", "    const value = null\n\n    const validated = new ValidatorFactory().execute(validation, value)\n    validated.assertErrorsCount(0)\n  })\n\n  test('report error when value is empty string', () => {\n    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n    const value = ''\n", "    const value = ''\n\n    const validated = new ValidatorFactory().execute(validation, value)\n    validated.assertError('The selected dummy is invalid')\n  })\n\n  test('pass validation when value is a subset of choices', () => {\n    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n    const value = 'admin'\n", "    const value = 'admin'\n\n    const validated = new ValidatorFactory().execute(validation, value)\n    validated.assertErrorsCount(0)\n  })\n\n  test('compute choices from a callback', () => {\n    const validation = enumRule({ choices: () => ['admin', 'moderator', 'guest'] })\n    const value = 'admin'\n", "    const value = 'admin'\n\n    const validated = new ValidatorFactory().execute(validation, value)\n    validated.assertErrorsCount(0)\n  })\n})\n"]}
{"filename": "tests/unit/rules/string.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validator } from '../../../factories/main.js'\nimport {\n  urlRule,\n  trimRule,\n  regexRule,\n  alphaRule,\n  emailRule,\n  stringRule,", "  emailRule,\n  stringRule,\n  mobileRule,\n  hexCodeRule,\n  endsWithRule,\n  confirmedRule,\n  activeUrlRule,\n  minLengthRule,\n  maxLengthRule,\n  startsWithRule,", "  maxLengthRule,\n  startsWithRule,\n  fixedLengthRule,\n  alphaNumericRule,\n  normalizeEmailRule,\n  sameAsRule,\n  notSameAsRule,\n  inRule,\n  notInRule,\n  ipAddressRule,", "  notInRule,\n  ipAddressRule,\n  creditCardRule,\n  passportRule,\n  postalCodeRule,\n  uuidRule,\n  asciiRule,\n  ibanRule,\n  jwtRule,\n  coordinatesRule,", "  jwtRule,\n  coordinatesRule,\n  toUpperCaseRule,\n  toLowerCaseRule,\n  toCamelCaseRule,\n  escapeRule,\n  normalizeUrlRule,\n} from '../../../src/schema/string/rules.js'\nimport type { FieldContext, Validation } from '../../../src/types.js'\n\ntype DataSet = {\n  errorsCount?: number\n  error?: string\n  bail?: boolean\n  rule: Validation<any>\n  value: any\n  output?: any\n  field?: Partial<FieldContext>\n}\n\n/**", "import type { FieldContext, Validation } from '../../../src/types.js'\n\ntype DataSet = {\n  errorsCount?: number\n  error?: string\n  bail?: boolean\n  rule: Validation<any>\n  value: any\n  output?: any\n  field?: Partial<FieldContext>\n}\n\n/**", " * Helpers to run string schema type validations\n */\nasync function stringRuleValidator(_: any, dataset: DataSet) {\n  const string = stringRule()\n  const validated = dataset.rule.rule.isAsync\n    ? await validator\n        .bail(dataset.bail === false ? false : true)\n        .withContext(dataset.field || {})\n        .executeAsync([string, dataset.rule], dataset.value)\n    : validator\n        .bail(dataset.bail === false ? false : true)\n        .withContext(dataset.field || {})\n        .execute([string, dataset.rule], dataset.value)\n", "  if (dataset.error && dataset.errorsCount) {\n    validated.assertErrorsCount(dataset.errorsCount)\n    validated.assertError(dataset.error)\n  } else {\n    validated.assertSucceeded()\n    validated.assertOutput(dataset.output || dataset.value)\n  }\n}\n\ntest.group('String | string', () => {\n  test('report when value is not a string', () => {\n    const string = stringRule()\n    const validated = validator.execute(string, 22)\n\n    validated.assertErrorsCount(1)\n    validated.assertError('The dummy field must be a string')\n  })\n\n  test('pass validation when value is a string', () => {\n    const string = stringRule()\n    const validated = validator.execute(string, '22')\n\n    validated.assertSucceeded()\n    validated.assertOutput('22')\n  })\n})\n\ntest.group('String | email', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: emailRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: emailRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: emailRule(),\n        value: 'foo',\n        error: 'The dummy field must be a valid email address',\n      },\n      {\n        rule: emailRule(),\n        value: 'foo@bar.com',\n      },\n      {\n        rule: emailRule({ allow_display_name: true }),\n        value: 'Foo <foo@bar.com>',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | mobile', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: mobileRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: mobileRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: mobileRule(),\n        value: '20202',\n        error: 'The dummy field must be a valid mobile phone number',\n      },\n      {\n        rule: mobileRule(),\n        value: '804 225 1616',\n      },\n      {\n        errorsCount: 1,\n        rule: mobileRule({ locale: ['en-IN'] }),\n        value: '(555) 555-1234',\n        error: 'The dummy field must be a valid mobile phone number',\n      },\n      {\n        rule: mobileRule({ locale: ['en-IN'] }),\n        value: '9883443344',\n      },\n      {\n        rule: mobileRule({ locale: ['en-IN', 'en-US'] }),\n        value: '(555) 555-1234',\n      },\n      {\n        rule: mobileRule({ locale: ['en-IN', 'en-US'] }),\n        value: '9883443344',\n      },\n      {\n        rule: mobileRule({ locale: ['en-IN', 'en-US'], strictMode: true }),\n        value: '+1 (555) 555-1234',\n      },\n      {\n        rule: mobileRule({ locale: ['en-IN', 'en-US'], strictMode: true }),\n        value: '+919883443344',\n      },\n      {\n        rule: mobileRule(() => {\n          return { locale: ['en-IN', 'en-US'] }\n        }),\n        value: '(555) 555-1234',\n      },\n      {\n        rule: mobileRule(() => {\n          return { locale: ['en-IN', 'en-US'] }\n        }),\n        value: '9883443344',\n      },\n      {\n        rule: mobileRule(() => {\n          return {}\n        }),\n        value: '(555) 555-1234',\n      },\n      {\n        rule: mobileRule(() => {\n          return {}\n        }),\n        value: '9883443344',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | hexCode', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: hexCodeRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: hexCodeRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: hexCodeRule(),\n        value: 'fff',\n        error: 'The dummy field must be a valid hex color code',\n      },\n      {\n        errorsCount: 1,\n        rule: hexCodeRule(),\n        value: 'red',\n        error: 'The dummy field must be a valid hex color code',\n      },\n      {\n        rule: hexCodeRule(),\n        value: '#fff',\n      },\n      {\n        rule: hexCodeRule(),\n        value: '#ffffff',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | url', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: urlRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: urlRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: urlRule(),\n        value: 'foo_bar',\n        error: 'The dummy field must be a valid URL',\n      },\n      {\n        errorsCount: 1,\n        rule: urlRule({ allow_underscores: false }),\n        value: 'https://foo_bar.com',\n        error: 'The dummy field must be a valid URL',\n      },\n      {\n        rule: urlRule(),\n        value: 'https://google.com',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | activeUrl', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: activeUrlRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: activeUrlRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: activeUrlRule(),\n        value: 'foo_bar',\n        error: 'The dummy field must be a valid URL',\n      },\n      {\n        errorsCount: 1,\n        rule: activeUrlRule(),\n        value: 'https://foo.com',\n        error: 'The dummy field must be a valid URL',\n      },\n      {\n        rule: activeUrlRule(),\n        value: 'https://google.com',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | regex', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: regexRule(/^[a-zA-Z0-9]+$/),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: regexRule(/^[a-zA-Z0-9]+$/),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: regexRule(/^[a-zA-Z0-9]+$/),\n        value: 'foo_bar',\n        error: 'The dummy field format is invalid',\n      },\n      {\n        rule: regexRule(/^[a-zA-Z0-9]+$/),\n        value: 'hello',\n      },\n      {\n        rule: regexRule(/^[a-zA-Z0-9]+$/),\n        value: 'hello1234',\n      },\n      {\n        rule: regexRule(new RegExp('^[a-zA-Z0-9]+$')),\n        value: 'hello',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | alpha', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: alphaRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: alphaRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: alphaRule(),\n        value: 'foo_bar',\n        error: 'The dummy field must contain only letters',\n      },\n      {\n        rule: alphaRule(),\n        value: 'hello',\n      },\n      {\n        rule: alphaRule({ allowSpaces: true }),\n        value: 'hello world',\n      },\n      {\n        rule: alphaRule({ allowUnderscores: true }),\n        value: 'hello_world',\n      },\n      {\n        rule: alphaRule({ allowDashes: true }),\n        value: 'hello-world',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | alphaNumeric', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: alphaNumericRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: alphaNumericRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: alphaNumericRule(),\n        value: 'foo_bar',\n        error: 'The dummy field must contain only letters and numbers',\n      },\n      {\n        rule: alphaNumericRule(),\n        value: 'hello1244',\n      },\n      {\n        rule: alphaNumericRule({ allowSpaces: true }),\n        value: 'hello 1244',\n      },\n      {\n        rule: alphaNumericRule({ allowUnderscores: true }),\n        value: 'hello_1244',\n      },\n      {\n        rule: alphaNumericRule({ allowDashes: true }),\n        value: 'hello-1244',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | minLength', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: minLengthRule({ min: 10 }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: minLengthRule({ min: 10 }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: minLengthRule({ min: 10 }),\n        value: 'foo_bar',\n        error: 'The dummy field must have at least 10 characters',\n      },\n      {\n        rule: minLengthRule({ min: 10 }),\n        value: 'hello_universe',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | maxLength', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: maxLengthRule({ max: 10 }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: maxLengthRule({ max: 10 }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: maxLengthRule({ max: 10 }),\n        value: 'hello_universe',\n        error: 'The dummy field must not be greater than 10 characters',\n      },\n      {\n        rule: maxLengthRule({ max: 10 }),\n        value: 'foo_bar',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | fixedLength', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: fixedLengthRule({ size: 10 }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: fixedLengthRule({ size: 10 }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: fixedLengthRule({ size: 10 }),\n        value: 'hello_universe',\n        error: 'The dummy field must be 10 characters long',\n      },\n      {\n        errorsCount: 1,\n        rule: fixedLengthRule({ size: 10 }),\n        value: 'foo',\n        error: 'The dummy field must be 10 characters long',\n      },\n      {\n        rule: fixedLengthRule({ size: 10 }),\n        value: 'helloworld',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | confirmed', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: confirmedRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: confirmedRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: confirmedRule(),\n        value: 'foo',\n        error: 'The dummy field and dummy_confirmation field must be the same',\n      },\n      {\n        errorsCount: 1,\n        rule: confirmedRule(),\n        value: 'foo',\n        field: {\n          parent: {\n            dummy_confirmation: '',\n          },\n        },\n        error: 'The dummy field and dummy_confirmation field must be the same',\n      },\n      {\n        rule: confirmedRule(),\n        value: 'foo',\n        field: {\n          parent: {\n            dummy_confirmation: 'foo',\n          },\n        },\n      },\n      {\n        rule: confirmedRule({ confirmationField: 'dummyConfirmed' }),\n        value: 'foo',\n        field: {\n          parent: {\n            dummyConfirmed: 'foo',\n          },\n        },\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | trim', () => {\n  test('trim whitespaces from: {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: trimRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: trimRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: trimRule(),\n        value: ' hello worl  ',\n        output: 'hello worl',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | normalizeEmail', () => {\n  test('normalize email: {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: normalizeEmailRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: normalizeEmailRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: normalizeEmailRule(),\n        value: 'FOO@bar.com',\n        output: 'foo@bar.com',\n      },\n      {\n        rule: normalizeEmailRule(),\n        value: 'foo.bar@gmail.com',\n        output: 'foobar@gmail.com',\n      },\n      {\n        rule: normalizeEmailRule({ gmail_remove_dots: false }),\n        value: 'foo.bar@gmail.com',\n        output: 'foo.bar@gmail.com',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | startsWith', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: startsWithRule({ substring: 'foo' }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: startsWithRule({ substring: 'foo' }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: startsWithRule({ substring: 'foo' }),\n        value: 'hello world',\n        error: 'The dummy field must start with foo',\n      },\n      {\n        rule: startsWithRule({ substring: 'foo' }),\n        value: 'foo world',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | endsWith', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: endsWithRule({ substring: 'foo' }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: endsWithRule({ substring: 'foo' }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: endsWithRule({ substring: 'foo' }),\n        value: 'hello world',\n        error: 'The dummy field must end with foo',\n      },\n      {\n        rule: endsWithRule({ substring: 'foo' }),\n        value: 'world foo',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | sameAs', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: sameAsRule({ otherField: 'password' }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: sameAsRule({ otherField: 'password' }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: sameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n        },\n        error: 'The password_confirmation field and password field must be the same',\n      },\n      {\n        errorsCount: 1,\n        rule: sameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n          parent: {\n            password: '',\n          },\n        },\n        error: 'The password_confirmation field and password field must be the same',\n      },\n      {\n        rule: sameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n          parent: {\n            password: 'foo',\n          },\n        },\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | notSameAs', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: notSameAsRule({ otherField: 'password' }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: notSameAsRule({ otherField: 'password' }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: notSameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n        },\n      },\n      {\n        errorsCount: 1,\n        rule: notSameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n          parent: {\n            password: 'foo',\n          },\n        },\n        error: 'The password_confirmation field and password field must be different',\n      },\n      {\n        rule: notSameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n          parent: {\n            password: 'bar',\n          },\n        },\n      },\n      {\n        rule: notSameAsRule({ otherField: 'password' }),\n        value: 'foo',\n        field: {\n          name: 'password_confirmation',\n          parent: {\n            password: '',\n          },\n        },\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | in', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n        value: 'foo',\n        error: 'The selected dummy is invalid',\n      },\n      {\n        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n        value: 'admin',\n      },\n      {\n        errorsCount: 1,\n        rule: inRule({ choices: () => ['admin', 'moderator', 'writer'] }),\n        value: 'foo',\n        error: 'The selected dummy is invalid',\n      },\n      {\n        rule: inRule({ choices: () => ['admin', 'moderator', 'writer'] }),\n        value: 'admin',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | notIn', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n        value: 'admin',\n        error: 'The selected dummy is invalid',\n      },\n      {\n        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n        value: 'root',\n      },\n      {\n        errorsCount: 1,\n        rule: notInRule({ list: () => ['admin', 'moderator', 'writer'] }),\n        value: 'admin',\n        error: 'The selected dummy is invalid',\n      },\n      {\n        rule: notInRule({ list: () => ['admin', 'moderator', 'writer'] }),\n        value: 'root',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | ipAddress', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: ipAddressRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: ipAddressRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: ipAddressRule(),\n        value: 'foobar',\n        error: 'The dummy field must be a valid IP address',\n      },\n      {\n        rule: ipAddressRule(),\n        value: '192.168.1.2',\n      },\n      {\n        rule: ipAddressRule(),\n        value: '::1234:5678',\n      },\n      {\n        rule: ipAddressRule({ version: 4 }),\n        value: '192.168.1.2',\n      },\n      {\n        rule: ipAddressRule({ version: 6 }),\n        value: '::1234:5678',\n      },\n      {\n        errorsCount: 1,\n        rule: ipAddressRule({ version: 6 }),\n        value: '192.168.1.2',\n        error: 'The dummy field must be a valid IP address',\n      },\n      {\n        errorsCount: 1,\n        rule: ipAddressRule({ version: 4 }),\n        value: '::1234:5678',\n        error: 'The dummy field must be a valid IP address',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | creditCard', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: creditCardRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: creditCardRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: creditCardRule(),\n        value: '123456789',\n        error: 'The dummy field must be a valid credit card number',\n      },\n      {\n        rule: creditCardRule(),\n        value: '30569309025904',\n      },\n      {\n        errorsCount: 1,\n        rule: creditCardRule({ provider: ['amex'] }),\n        value: '30569309025904',\n        error: 'The dummy field must be a valid amex card number',\n      },\n      {\n        errorsCount: 1,\n        rule: creditCardRule({ provider: ['amex', 'visa'] }),\n        value: '30569309025904',\n        error: 'The dummy field must be a valid amex/visa card number',\n      },\n      {\n        rule: creditCardRule({ provider: ['amex', 'visa', 'dinersclub'] }),\n        value: '30569309025904',\n      },\n      {\n        rule: creditCardRule(() => {}),\n        value: '30569309025904',\n      },\n      {\n        errorsCount: 1,\n        rule: creditCardRule(() => {\n          return { provider: ['amex'] }\n        }),\n        value: '30569309025904',\n        error: 'The dummy field must be a valid amex card number',\n      },\n      {\n        errorsCount: 1,\n        rule: creditCardRule(() => {\n          return { provider: ['amex', 'visa'] }\n        }),\n        value: '30569309025904',\n        error: 'The dummy field must be a valid amex/visa card number',\n      },\n      {\n        rule: creditCardRule(() => {\n          return { provider: ['amex', 'visa', 'dinersclub'] }\n        }),\n        value: '30569309025904',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | passport', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: passportRule({ countryCode: ['IN'] }),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: passportRule({ countryCode: ['IN'] }),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: passportRule({ countryCode: ['IN'] }),\n        value: '1999010301',\n        error: 'The dummy field must be a valid passport number',\n      },\n      {\n        rule: passportRule({ countryCode: ['IN'] }),\n        value: 'J8369854',\n      },\n      {\n        rule: passportRule({ countryCode: ['US'] }),\n        value: 'J8369854',\n        errorsCount: 1,\n        error: 'The dummy field must be a valid passport number',\n      },\n      {\n        rule: passportRule({ countryCode: ['IN', 'US'] }),\n        value: 'J8369854',\n      },\n      {\n        errorsCount: 1,\n        rule: passportRule(() => {\n          return { countryCode: ['IN'] }\n        }),\n        value: '1999010301',\n        error: 'The dummy field must be a valid passport number',\n      },\n      {\n        rule: passportRule(() => {\n          return { countryCode: ['IN'] }\n        }),\n        value: 'J8369854',\n      },\n      {\n        rule: passportRule(() => {\n          return { countryCode: ['US'] }\n        }),\n        value: 'J8369854',\n        errorsCount: 1,\n        error: 'The dummy field must be a valid passport number',\n      },\n      {\n        rule: passportRule(() => {\n          return { countryCode: ['IN', 'US'] }\n        }),\n        value: 'J8369854',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | postalCode', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: postalCodeRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: postalCodeRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: postalCodeRule(),\n        value: '1999010301',\n        error: 'The dummy field must be a valid postal code',\n      },\n      {\n        rule: postalCodeRule(),\n        value: '110001',\n      },\n      {\n        errorsCount: 1,\n        rule: postalCodeRule({ countryCode: ['US'] }),\n        value: '110001',\n        error: 'The dummy field must be a valid postal code',\n      },\n      {\n        rule: postalCodeRule({ countryCode: ['US', 'IN'] }),\n        value: '110001',\n      },\n      {\n        errorsCount: 1,\n        rule: postalCodeRule(() => {}),\n        value: '1999010301',\n        error: 'The dummy field must be a valid postal code',\n      },\n      {\n        rule: postalCodeRule(() => {}),\n        value: '110001',\n      },\n      {\n        errorsCount: 1,\n        rule: postalCodeRule(() => {\n          return { countryCode: ['US'] }\n        }),\n        value: '110001',\n        error: 'The dummy field must be a valid postal code',\n      },\n      {\n        rule: postalCodeRule(() => {\n          return { countryCode: ['US', 'IN'] }\n        }),\n        value: '110001',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | uuid', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: uuidRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: uuidRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: uuidRule(),\n        value: '1999010301',\n        error: 'The dummy field must be a valid UUID',\n      },\n      {\n        rule: uuidRule(),\n        value: '71e4fbab-3498-447b-a97c-2c6060069678',\n      },\n      {\n        errorsCount: 1,\n        rule: uuidRule({ version: [1] }),\n        value: '71e4fbab-3498-447b-a97c-2c6060069678',\n        error: 'The dummy field must be a valid UUID',\n      },\n      {\n        rule: uuidRule({ version: [1, 4] }),\n        value: '71e4fbab-3498-447b-a97c-2c6060069678',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | ascii', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: asciiRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: asciiRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: asciiRule(),\n        value: '\uff11\uff12\uff13456',\n        error: 'The dummy field must only contain ASCII characters',\n      },\n      {\n        rule: asciiRule(),\n        value: 'foobar',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | iban', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: ibanRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: ibanRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: ibanRule(),\n        value: 'foobar',\n        error: 'The dummy field must be a valid IBAN number',\n      },\n      {\n        rule: ibanRule(),\n        value: 'GB94BARC10201530093459',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | jwt', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: jwtRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: jwtRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: jwtRule(),\n        value: 'foobar',\n        error: 'The dummy field must be a valid JWT token',\n      },\n      {\n        rule: jwtRule(),\n        value:\n          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | coordinates', () => {\n  test('validate {value}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: coordinatesRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: coordinatesRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: coordinatesRule(),\n        value: 'helloworld',\n        error: 'The dummy field must contain latitude and longitude coordinates',\n      },\n      {\n        errorsCount: 1,\n        rule: coordinatesRule(),\n        value: 'hello,world',\n        error: 'The dummy field must contain latitude and longitude coordinates',\n      },\n      {\n        rule: coordinatesRule(),\n        value: '(7.264394, 165.058594)',\n      },\n      {\n        rule: coordinatesRule(),\n        value: '7.264394,165.058594',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | toUpperCase', () => {\n  test('convert {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: toUpperCaseRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: toUpperCaseRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: toUpperCaseRule(),\n        value: 'hello world',\n        output: 'HELLO WORLD',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | toLowerCase', () => {\n  test('convert {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: toLowerCaseRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: toLowerCaseRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: toLowerCaseRule(),\n        value: 'HELLO WORLD',\n        output: 'hello world',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | toCamelCase', () => {\n  test('convert {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: toCamelCaseRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: toCamelCaseRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: toCamelCaseRule(),\n        value: 'HELLO WORLD',\n        output: 'helloWorld',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | escape', () => {\n  test('convert {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: escapeRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: escapeRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: escapeRule(),\n        value: '<h1> Hello world </h1>',\n        output: '&lt;h1&gt; Hello world &lt;&#x2F;h1&gt;',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n\ntest.group('String | normalizeUrl', () => {\n  test('convert {value} to {output}')", "    .with([\n      {\n        errorsCount: 1,\n        rule: normalizeUrlRule(),\n        value: 22,\n        error: 'The dummy field must be a string',\n      },\n      {\n        errorsCount: 1,\n        rule: normalizeUrlRule(),\n        value: 22,\n        bail: false,\n        error: 'The dummy field must be a string',\n      },\n      {\n        rule: normalizeUrlRule(),\n        value: 'foobar',\n        output: 'http://foobar',\n      },\n      {\n        rule: normalizeUrlRule({ stripWWW: true }),\n        value: 'www.foo.com',\n        output: 'http://foo.com',\n      },\n    ])\n    .run(stringRuleValidator)\n})\n"]}
{"filename": "tests/unit/rules/literal.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validator } from '../../../factories/main.js'\nimport { equalsRule } from '../../../src/schema/literal/rules.js'\n\ntest.group('Literal | equals', () => {\n  test('report when input value is not same as expected value', () => {\n    const equals = equalsRule({ expectedValue: 1 })\n    const validated = validator.execute(equals, 'foo')\n", "    const validated = validator.execute(equals, 'foo')\n\n    validated.assertError('The dummy field must be 1')\n  })\n\n  test('pass when input value is same as expected value', () => {\n    const equals = equalsRule({ expectedValue: 1 })\n    const validated = validator.execute(equals, 1)\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput(1)\n  })\n\n  test('normalize input value when expected value is a number', () => {\n    const equals = equalsRule({ expectedValue: 1 })\n    const validated = validator.execute(equals, '1')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput(1)\n  })\n\n  test('normalize input value when expected value is a boolean', () => {\n    const equals = equalsRule({ expectedValue: false })\n    const validated = validator.execute(equals, 'false')\n    validated.assertSucceeded()\n    validated.assertOutput(false)", "    validated.assertSucceeded()\n    validated.assertOutput(false)\n\n    const equals1 = equalsRule({ expectedValue: true })\n    const validated1 = validator.execute(equals1, 'true')\n    validated1.assertSucceeded()\n    validated1.assertOutput(true)\n  })\n})\n", "})\n"]}
{"filename": "tests/unit/rules/record.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validator } from '../../../factories/main.js'\nimport {\n  maxLengthRule,\n  minLengthRule,\n  fixedLengthRule,\n  validateKeysRule,\n} from '../../../src/schema/record/rules.js'\n", "} from '../../../src/schema/record/rules.js'\n\ntest.group('Record | minLength', () => {\n  test('skip when field is invalid', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.withContext({ isValid: false }).execute(minLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })", "    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)\n      .execute(minLength, 'foo')\n", "      .execute(minLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when object length is less than the expected length', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.execute(minLength, { foo: 'bar' })\n", "    const validated = validator.execute(minLength, { foo: 'bar' })\n\n    validated.assertError('The dummy field must have at least 2 items')\n  })\n\n  test('pass validation when length is same or greater than expected length', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.execute(minLength, { foo: 'bar', bar: 'baz' })\n    validated.assertSucceeded()\n    validated.assertOutput({ foo: 'bar', bar: 'baz' })", "    validated.assertSucceeded()\n    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n\n    const validated1 = validator.execute(minLength, { foo: 'bar', bar: 'baz', baz: 'foo' })\n    validated1.assertSucceeded()\n    validated1.assertOutput({ foo: 'bar', bar: 'baz', baz: 'foo' })\n  })\n})\n\ntest.group('Record | maxLength', () => {", "\ntest.group('Record | maxLength', () => {\n  test('skip when field is invalid', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.withContext({ isValid: false }).execute(maxLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n", "  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)\n      .execute(maxLength, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when object length is greater than the expected length', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.execute(maxLength, { foo: 'bar', bar: 'baz', baz: 'foo' })\n\n    validated.assertError('The dummy field must not have more than 2 items')", "\n    validated.assertError('The dummy field must not have more than 2 items')\n  })\n\n  test('pass validation when length is same or less than expected length', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.execute(maxLength, { foo: 'bar', bar: 'baz' })\n    validated.assertSucceeded()\n    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n", "    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n\n    const validated1 = validator.execute(maxLength, { foo: 'bar' })\n    validated1.assertSucceeded()\n    validated1.assertOutput({ foo: 'bar' })\n  })\n})\n\ntest.group('Record | fixedLength', () => {\n  test('skip when field is invalid', () => {", "test.group('Record | fixedLength', () => {\n  test('skip when field is invalid', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator.withContext({ isValid: false }).execute(fixedLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {", "\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)\n      .execute(fixedLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')", "    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when object length is greater than the expected length', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator.execute(fixedLength, { foo: 'bar', bar: 'baz', baz: 'foo' })\n\n    validated.assertError('The dummy field must contain 2 items')\n  })", "    validated.assertError('The dummy field must contain 2 items')\n  })\n\n  test('report when object length is less than the expected length', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator.execute(fixedLength, { foo: 'bar' })\n\n    validated.assertError('The dummy field must contain 2 items')\n  })\n", "  })\n\n  test('pass validation when length is same as the expected length', () => {\n    const maxLength = fixedLengthRule({ size: 2 })\n    const validated = validator.execute(maxLength, { foo: 'bar', bar: 'baz' })\n    validated.assertSucceeded()\n    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n  })\n})\n", "})\n\ntest.group('Record | validateKeys', () => {\n  test('skip when field is invalid', () => {\n    const validateKeys = validateKeysRule(() => {\n      throw new Error('Never expected to be invoked')\n    })\n    const validated = validator.withContext({ isValid: false }).execute(validateKeys, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const validateKeys = validateKeysRule(() => {\n      throw new Error('Never expected to be invoked')\n    })\n    const validated = validator", "    })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)\n      .execute(validateKeys, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n", "  })\n\n  test('invoke callback and pass object keys to it', ({ assert }) => {\n    assert.plan(1)\n\n    const validateKeys = validateKeysRule((keys) => {\n      assert.deepEqual(keys, ['foo', 'bar', 'baz'])\n    })\n\n    const validated = validator.execute(validateKeys, {", "\n    const validated = validator.execute(validateKeys, {\n      foo: 'bar',\n      bar: 'baz',\n      baz: 'foo',\n    })\n\n    validated.assertSucceeded()\n    validated.assertOutput({\n      foo: 'bar',", "    validated.assertOutput({\n      foo: 'bar',\n      bar: 'baz',\n      baz: 'foo',\n    })\n  })\n\n  test('fail validation when validate keys reports an error', () => {\n    const validateKeys = validateKeysRule((_, field) => {\n      field.report('Invalid keys', 'record.keys', field)", "    const validateKeys = validateKeysRule((_, field) => {\n      field.report('Invalid keys', 'record.keys', field)\n    })\n\n    const validated = validator.execute(validateKeys, {\n      foo: 'bar',\n      bar: 'baz',\n      baz: 'foo',\n    })\n", "    })\n\n    validated.assertErrorsCount(1)\n    validated.assertError('Invalid keys')\n  })\n})\n"]}
{"filename": "tests/unit/rules/boolean.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validator } from '../../../factories/main.js'\nimport { booleanRule } from '../../../src/schema/boolean/rules.js'\n\ntest.group('Boolean | boolean', () => {\n  test('report when value is not a boolean', () => {\n    const boolean = booleanRule({})\n    const validated = validator.execute(boolean, 'foo')\n", "    const validated = validator.execute(boolean, 'foo')\n\n    validated.assertError('The value must be a boolean')\n  })\n\n  test('pass validation when value is a boolean', () => {\n    const boolean = booleanRule({})\n\n    const withTrue = validator.execute(boolean, true)\n    withTrue.assertSucceeded()", "    const withTrue = validator.execute(boolean, true)\n    withTrue.assertSucceeded()\n    withTrue.assertOutput(true)\n\n    const withFalse = validator.execute(boolean, false)\n    withFalse.assertSucceeded()\n    withFalse.assertOutput(false)\n\n    const withZero = validator.execute(boolean, 0)\n    withZero.assertSucceeded()", "    const withZero = validator.execute(boolean, 0)\n    withZero.assertSucceeded()\n    withZero.assertOutput(false)\n\n    const withOne = validator.execute(boolean, 1)\n    withOne.assertSucceeded()\n    withOne.assertOutput(true)\n  })\n\n  test('pass validation when value is a string representation of boolean', () => {", "\n  test('pass validation when value is a string representation of boolean', () => {\n    const boolean = booleanRule({})\n\n    const withTrue = validator.execute(boolean, 'true')\n    withTrue.assertSucceeded()\n    withTrue.assertOutput(true)\n\n    const withFalse = validator.execute(boolean, 'false')\n    withFalse.assertSucceeded()", "    const withFalse = validator.execute(boolean, 'false')\n    withFalse.assertSucceeded()\n    withFalse.assertOutput(false)\n\n    const withZero = validator.execute(boolean, '0')\n    withZero.assertSucceeded()\n    withZero.assertOutput(false)\n\n    const withOne = validator.execute(boolean, '1')\n    withOne.assertSucceeded()", "    const withOne = validator.execute(boolean, '1')\n    withOne.assertSucceeded()\n    withOne.assertOutput(true)\n  })\n\n  test('disallow string representation in strict mode', () => {\n    const boolean = booleanRule({ strict: true })\n\n    const withTrue = validator.execute(boolean, 'true')\n    withTrue.assertError('The value must be a boolean')", "    const withTrue = validator.execute(boolean, 'true')\n    withTrue.assertError('The value must be a boolean')\n\n    const withFalse = validator.execute(boolean, 'false')\n    withFalse.assertError('The value must be a boolean')\n\n    const withZero = validator.execute(boolean, '0')\n    withZero.assertError('The value must be a boolean')\n\n    const withOne = validator.execute(boolean, '1')", "\n    const withOne = validator.execute(boolean, '1')\n    withOne.assertError('The value must be a boolean')\n  })\n\n  test('report when value is a number other than 0 or 1', () => {\n    const boolean = booleanRule({})\n    const validated = validator.execute(boolean, 2)\n\n    validated.assertError('The value must be a boolean')", "\n    validated.assertError('The value must be a boolean')\n  })\n})\n"]}
{"filename": "tests/unit/rules/array.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { validator } from '../../../factories/main.js'\nimport {\n  compactRule,\n  distinctRule,\n  notEmptyRule,\n  maxLengthRule,\n  minLengthRule,\n  fixedLengthRule,", "  minLengthRule,\n  fixedLengthRule,\n} from '../../../src/schema/array/rules.js'\n\ntest.group('Array | minLength', () => {\n  test('skip when field is invalid', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.withContext({ isValid: false }).execute(minLength, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)", "      .withContext({ isValid: false })\n      .bail(false)\n      .execute(minLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when array length is less than the expected length', () => {\n    const minLength = minLengthRule({ min: 2 })", "  test('report when array length is less than the expected length', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.execute(minLength, ['foo'])\n\n    validated.assertError('The dummy field must have at least 2 items')\n  })\n\n  test('pass validation when length is same or greater than expected length', () => {\n    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.execute(minLength, ['foo', 'bar'])", "    const minLength = minLengthRule({ min: 2 })\n    const validated = validator.execute(minLength, ['foo', 'bar'])\n    validated.assertSucceeded()\n    validated.assertOutput(['foo', 'bar'])\n\n    const validated1 = validator.execute(minLength, ['foo', 'bar', 'baz'])\n    validated1.assertSucceeded()\n    validated1.assertOutput(['foo', 'bar', 'baz'])\n  })\n})", "  })\n})\n\ntest.group('Array | maxLength', () => {\n  test('skip when field is invalid', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.withContext({ isValid: false }).execute(maxLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')", "    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)\n      .execute(maxLength, 'foo')", "      .bail(false)\n      .execute(maxLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when array length is greater than the expected length', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.execute(maxLength, ['foo', 'bar', 'baz'])", "    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.execute(maxLength, ['foo', 'bar', 'baz'])\n\n    validated.assertError('The dummy field must not have more than 2 items')\n  })\n\n  test('pass validation when length is same or less than expected length', () => {\n    const maxLength = maxLengthRule({ max: 2 })\n    const validated = validator.execute(maxLength, ['foo', 'bar'])\n    validated.assertSucceeded()", "    const validated = validator.execute(maxLength, ['foo', 'bar'])\n    validated.assertSucceeded()\n    validated.assertOutput(['foo', 'bar'])\n\n    const validated1 = validator.execute(maxLength, ['foo'])\n    validated1.assertSucceeded()\n    validated1.assertOutput(['foo'])\n  })\n})\n", "})\n\ntest.group('Array | fixedLength', () => {\n  test('skip when field is invalid', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator.withContext({ isValid: false }).execute(fixedLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })", "    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator\n      .withContext({ isValid: false })\n      .bail(false)\n      .execute(fixedLength, 'foo')\n", "      .execute(fixedLength, 'foo')\n\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when array length is greater than the expected length', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator.execute(fixedLength, ['foo', 'bar', 'baz'])\n", "    const validated = validator.execute(fixedLength, ['foo', 'bar', 'baz'])\n\n    validated.assertError('The dummy field must contain 2 items')\n  })\n\n  test('report when array length is less than the expected length', () => {\n    const fixedLength = fixedLengthRule({ size: 2 })\n    const validated = validator.execute(fixedLength, ['foo'])\n\n    validated.assertError('The dummy field must contain 2 items')", "\n    validated.assertError('The dummy field must contain 2 items')\n  })\n\n  test('pass validation when length is same as the expected length', () => {\n    const maxLength = fixedLengthRule({ size: 2 })\n    const validated = validator.execute(maxLength, ['foo', 'bar'])\n    validated.assertSucceeded()\n    validated.assertOutput(['foo', 'bar'])\n  })", "    validated.assertOutput(['foo', 'bar'])\n  })\n})\n\ntest.group('Array | notEmpty', () => {\n  test('skip when field is invalid', () => {\n    const notEmpty = notEmptyRule()\n    const validated = validator.withContext({ isValid: false }).execute(notEmpty, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const notEmpty = notEmptyRule()\n    const validated = validator.withContext({ isValid: false }).bail(false).execute(notEmpty, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('report when array is empty', () => {\n    const notEmpty = notEmptyRule()\n    const validated = validator.execute(notEmpty, [])\n\n    validated.assertError('The dummy field must not be empty')", "\n    validated.assertError('The dummy field must not be empty')\n  })\n\n  test('pass validation when array has one or more items', () => {\n    const notEmpty = notEmptyRule()\n    const validated = validator.execute(notEmpty, ['foo', 'bar'])\n    validated.assertSucceeded()\n    validated.assertOutput(['foo', 'bar'])\n  })", "    validated.assertOutput(['foo', 'bar'])\n  })\n})\n\ntest.group('Array | distinct', () => {\n  test('skip when field is invalid', () => {\n    const distinct = distinctRule({})\n    const validated = validator.withContext({ isValid: false }).execute(distinct, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const distinct = distinctRule({})\n    const validated = validator.withContext({ isValid: false }).bail(false).execute(distinct, 'foo')\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n    validated.assertOutput('foo')\n  })\n\n  test('pass validation when array is empty', () => {\n    const distinct = distinctRule({})\n    const validated = validator.execute(distinct, [])\n\n    validated.assertSucceeded()", "\n    validated.assertSucceeded()\n  })\n\n  test('pass validation when array has unique items', () => {\n    const distinct = distinctRule({})\n    const validated = validator.execute(distinct, ['foo', 'bar', 'baz'])\n    validated.assertSucceeded()\n\n    const validated1 = validator.execute(distinct, [11, 12, 13])", "\n    const validated1 = validator.execute(distinct, [11, 12, 13])\n    validated1.assertSucceeded()\n\n    const validated2 = validator.execute(distinct, [true, false])\n    validated2.assertSucceeded()\n  })\n\n  test('report error when array has duplicates', () => {\n    const distinct = distinctRule({})", "  test('report error when array has duplicates', () => {\n    const distinct = distinctRule({})\n    const validated = validator.execute(distinct, ['foo', 'bar', 'foo'])\n    validated.assertError('The dummy field has duplicate values')\n\n    const validated1 = validator.execute(distinct, [11, 12, 11])\n    validated1.assertError('The dummy field has duplicate values')\n\n    const validated2 = validator.execute(distinct, [true, true])\n    validated2.assertError('The dummy field has duplicate values')", "    const validated2 = validator.execute(distinct, [true, true])\n    validated2.assertError('The dummy field has duplicate values')\n  })\n\n  test('pass validation when array of objects have unique items', () => {\n    const distinct = distinctRule({ fields: 'email' })\n    const validated = validator.execute(distinct, [\n      {\n        email: 'foo@bar.com',\n      },", "        email: 'foo@bar.com',\n      },\n      {\n        email: 'baz@bar.com',\n      },\n    ])\n\n    validated.assertSucceeded()\n  })\n", "  })\n\n  test('report error when array of objects has duplicate items', () => {\n    const distinct = distinctRule({ fields: 'email' })\n    const validated = validator.execute(distinct, [\n      {\n        email: 'foo@bar.com',\n      },\n      {\n        email: 'foo@bar.com',", "      {\n        email: 'foo@bar.com',\n      },\n    ])\n    validated.assertError('The dummy field has duplicate values')\n  })\n\n  test('pass validation when object has unique items for a composite key', () => {\n    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [", "    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [\n      {\n        email: 'foo@bar.com',\n        company_id: 1,\n      },\n      {\n        email: 'foo@bar.com',\n        company_id: 2,\n      },", "        company_id: 2,\n      },\n    ])\n\n    validated.assertSucceeded()\n  })\n\n  test('report error when object has duplicate items for a composite key', () => {\n    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [", "    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [\n      {\n        email: 'foo@bar.com',\n        company_id: 1,\n      },\n      {\n        email: 'foo@bar.com',\n        company_id: 1,\n      },", "        company_id: 1,\n      },\n    ])\n\n    validated.assertError('The dummy field has duplicate values')\n  })\n\n  test('skip when one or more fields are missing in objects', () => {\n    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [", "    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [\n      {\n        email: 'foo@bar.com',\n      },\n      {\n        email: 'foo@bar.com',\n      },\n    ])\n", "    ])\n\n    validated.assertSucceeded()\n  })\n\n  test('skip when array elements are not objects', () => {\n    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n    const validated = validator.execute(distinct, [\n      {\n        email: 'foo@bar.com',", "      {\n        email: 'foo@bar.com',\n      },\n      'foo@bar.com',\n    ])\n\n    validated.assertSucceeded()\n  })\n})\n", "})\n\ntest.group('Array | compact', () => {\n  test('skip when field is invalid', () => {\n    const compact = compactRule()\n    const validated = validator.withContext({ isValid: false }).execute(compact, 'foo')\n    validated.assertOutput('foo')\n  })\n\n  test('skip when field is invalid and bail mode is disabled', () => {", "\n  test('skip when field is invalid and bail mode is disabled', () => {\n    const compact = compactRule()\n    const validated = validator.withContext({ isValid: false }).bail(false).execute(compact, 'foo')\n    validated.assertOutput('foo')\n  })\n\n  test('remove empty strings null and undefined values', () => {\n    const compact = compactRule()\n    const validated = validator.execute(compact, [", "    const compact = compactRule()\n    const validated = validator.execute(compact, [\n      'foo',\n      'bar',\n      '',\n      null,\n      undefined,\n      'baz',\n      null,\n      true,", "      null,\n      true,\n      false,\n      1,\n      0,\n    ])\n\n    validated.assertOutput(['foo', 'bar', 'baz', true, false, 1, 0])\n  })\n})", "  })\n})\n"]}
{"filename": "tests/unit/schema/number.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\nimport {\n  maxRule,\n  minRule,\n  rangeRule,", "  minRule,\n  rangeRule,\n  decimalRule,\n  negativeRule,\n  positiveRule,\n  withoutDecimalsRule,\n} from '../../../src/schema/number/rules.js'\n\nconst vine = new Vine()\n", "const vine = new Vine()\n\ntest.group('VineNumber', () => {\n  test('create number schema', ({ assert }) => {\n    const schema = vine.number()\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.number().nullable()\n", "    const schema = vine.number().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.number().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {", "\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.number().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply rules', ({ assert }) => {\n    const schema = vine.number().bail(false).min(10).max(20)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://3',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.number().transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.number().parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },", "          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n\n  test('check if value is a number using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.number()\n\n    assert.isTrue(schema[IS_OF_TYPE]('1'))", "\n    assert.isTrue(schema[IS_OF_TYPE]('1'))\n    assert.isTrue(schema[IS_OF_TYPE]('0'))\n    assert.isTrue(schema[IS_OF_TYPE](1))\n    assert.isTrue(schema[IS_OF_TYPE]('9.99'))\n    assert.isFalse(schema[IS_OF_TYPE]('foo'))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE]({}))\n  })", "    assert.isFalse(schema[IS_OF_TYPE]({}))\n  })\n})\n\ntest.group('VineNumber | clone', () => {\n  test('clone number schema', ({ assert }) => {\n    const schema = vine.number()\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.number()\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {", "\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.number()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.number()\n    const schema1 = schema.clone().bail(false)", "    const schema = vine.number()\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,", "      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('clone and apply rules', ({ assert }) => {\n    const schema = vine.number().bail(false).min(10)\n    const schema1 = schema.clone().max(20)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n        {", "        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://3',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.number()\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.number()\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineNumber | applying rules', () => {", "\ntest.group('VineNumber | applying rules', () => {\n  test('apply min rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().min(18)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],", "        },\n      ],\n    })\n\n    const min = minRule({ min: 18 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: min.rule.validator,\n      options: min.options,\n    })\n  })", "    })\n  })\n\n  test('apply max rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().max(18)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },", "          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n\n    const max = maxRule({ max: 18 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: max.rule.validator,\n      options: max.options,\n    })", "      options: max.options,\n    })\n  })\n\n  test('apply range rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().range([18, 60])\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',", "          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n\n    const range = rangeRule({ min: 18, max: 60 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: range.rule.validator,\n      options: range.options,", "      validator: range.rule.validator,\n      options: range.options,\n    })\n  })\n\n  test('apply positive rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().positive()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n\n    const positive = positiveRule()\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: positive.rule.validator,", "    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: positive.rule.validator,\n      options: positive.options,\n    })\n  })\n\n  test('apply negative rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().negative()\n", "    const schema = vine.number().negative()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,", "      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n\n    const negative = negativeRule()\n    assert.deepEqual(refs.toJSON()['ref://2'], {", "    const negative = negativeRule()\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: negative.rule.validator,\n      options: negative.options,\n    })\n  })\n\n  test('apply decimal rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().decimal([0, 2])", "    const refs = refsBuilder()\n    const schema = vine.number().decimal([0, 2])\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {", "        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n\n    const decimal = decimalRule({ range: [0, 2] })", "\n    const decimal = decimalRule({ range: [0, 2] })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: decimal.rule.validator,\n      options: decimal.options,\n    })\n  })\n\n  test('apply decimal rule with fixed value', ({ assert }) => {\n    const refs = refsBuilder()", "  test('apply decimal rule with fixed value', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().decimal(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n", "    })\n\n    const decimal = decimalRule({ range: [2] })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: decimal.rule.validator,\n      options: decimal.options,\n    })\n  })\n\n  test('apply withoutDecimals rule', ({ assert }) => {", "\n  test('apply withoutDecimals rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.number().withoutDecimals()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })", "      ],\n    })\n\n    const withoutDecimals = withoutDecimalsRule()\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: withoutDecimals.rule.validator,\n      options: withoutDecimals.options,\n    })\n  })\n})", "  })\n})\n"]}
{"filename": "tests/unit/schema/enum.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('VineEnum', () => {\n  test('create enum schema', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineEnum | clone', () => {", "\ntest.group('VineEnum', () => {\n  test('create enum schema', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator']).parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineEnum | clone', () => {", "  test('clone enum schema', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.enum(['guest', 'admin', 'moderator'])\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/string.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport { RuleBuilder } from '../../../src/types.js'\nimport { createRule } from '../../../src/vine/create_rule.js'\nimport { IS_OF_TYPE, PARSE, VALIDATION } from '../../../src/symbols.js'\nimport {\n  inRule,", "import {\n  inRule,\n  urlRule,\n  emailRule,\n  trimRule,\n  alphaRule,\n  notInRule,\n  regexRule,\n  sameAsRule,\n  endsWithRule,", "  sameAsRule,\n  endsWithRule,\n  notSameAsRule,\n  ipAddressRule,\n  confirmedRule,\n  activeUrlRule,\n  maxLengthRule,\n  minLengthRule,\n  startsWithRule,\n  fixedLengthRule,", "  startsWithRule,\n  fixedLengthRule,\n  alphaNumericRule,\n  normalizeEmailRule,\n  creditCardRule,\n  passportRule,\n  postalCodeRule,\n  uuidRule,\n  asciiRule,\n  ibanRule,", "  asciiRule,\n  ibanRule,\n  jwtRule,\n  coordinatesRule,\n  toUpperCaseRule,\n  toLowerCaseRule,\n  toCamelCaseRule,\n  escapeRule,\n  normalizeUrlRule,\n  mobileRule,", "  normalizeUrlRule,\n  mobileRule,\n} from '../../../src/schema/string/rules.js'\n\nconst vine = new Vine()\n\ntest.group('VineString', () => {\n  test('create string schema', ({ assert }) => {\n    const schema = vine.string()\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "    const schema = vine.string()\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.string().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.string().optional()", "  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.string().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,", "      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.string().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.string().transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('check if value is an object using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.string()\n", "    const schema = vine.string()\n\n    assert.isTrue(schema[IS_OF_TYPE](''))\n    assert.isFalse(schema[IS_OF_TYPE]({}))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE]([]))\n    assert.isFalse(schema[IS_OF_TYPE](1))\n  })\n})", "  })\n})\n\ntest.group('VineString | clone', () => {\n  test('clone string schema', ({ assert }) => {\n    const schema = vine.string()\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.string()\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.string()", "  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.string()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,", "      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.string()\n    const schema1 = schema.clone().bail(false)\n", "    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,", "      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.string()\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',", "      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('apply nullable modifier and clone', ({ assert }) => {\n    const schema = vine.string().nullable()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('apply optional modifier and clone', ({ assert }) => {\n    const schema = vine.string().optional()\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply transform modifier and clone', ({ assert }) => {\n    const schema = vine.string().transform(() => {})", "  test('apply transform modifier and clone', ({ assert }) => {\n    const schema = vine.string().transform(() => {})\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,", "      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineString | applying rules', () => {", "\ntest.group('VineString | applying rules', () => {\n  test('register rule via rule builder', ({ assert }) => {\n    const passwordRule = createRule(() => {})\n    class Password implements RuleBuilder {\n      [VALIDATION]() {\n        return passwordRule()\n      }\n    }\n\n    const refs = refsBuilder()\n    const password = new Password()\n    const schema = vine.string().use(password)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: passwordRule().rule.validator,\n      options: passwordRule().options,\n    })\n  })\n\n  test('apply {name} rule via schema API')", "    .with([\n      {\n        name: 'email',\n        schema: vine.string().email(),\n        rule: emailRule(),\n      },\n      {\n        name: 'regex',\n        schema: vine.string().regex(/^[a-zA-Z0-9]+$/),\n        rule: regexRule(/^[a-zA-Z0-9]+$/),\n      },\n      {\n        name: 'url',\n        schema: vine.string().url(),\n        rule: urlRule(),\n      },\n      {\n        name: 'activeUrl',\n        schema: vine.string().activeUrl(),\n        rule: activeUrlRule(),\n      },\n      {\n        name: 'alpha',\n        schema: vine.string().alpha(),\n        rule: alphaRule(),\n      },\n      {\n        name: 'mobile',\n        schema: vine.string().mobile(),\n        rule: mobileRule(),\n      },\n      {\n        name: 'alphaNumeric',\n        schema: vine.string().alphaNumeric(),\n        rule: alphaNumericRule(),\n      },\n      {\n        name: 'maxLength',\n        schema: vine.string().maxLength(10),\n        rule: maxLengthRule({ max: 10 }),\n      },\n      {\n        name: 'minLength',\n        schema: vine.string().minLength(10),\n        rule: minLengthRule({ min: 10 }),\n      },\n      {\n        name: 'fixedLength',\n        schema: vine.string().fixedLength(10),\n        rule: fixedLengthRule({ size: 10 }),\n      },\n      {\n        name: 'confirmed',\n        schema: vine.string().confirmed(),\n        rule: confirmedRule(),\n      },\n      {\n        name: 'trim',\n        schema: vine.string().trim(),\n        rule: trimRule(),\n      },\n      {\n        name: 'normalizeEmail',\n        schema: vine.string().normalizeEmail(),\n        rule: normalizeEmailRule(),\n      },\n      {\n        name: 'startsWith',\n        schema: vine.string().startsWith('foo'),\n        rule: startsWithRule({ substring: 'foo' }),\n      },\n      {\n        name: 'endsWith',\n        schema: vine.string().endsWith('foo'),\n        rule: endsWithRule({ substring: 'foo' }),\n      },\n      {\n        name: 'sameAs',\n        schema: vine.string().sameAs('password'),\n        rule: sameAsRule({ otherField: 'password' }),\n      },\n      {\n        name: 'notSameAs',\n        schema: vine.string().notSameAs('password'),\n        rule: notSameAsRule({ otherField: 'password' }),\n      },\n      {\n        name: 'in',\n        schema: vine.string().in(['admin']),\n        rule: inRule({ choices: ['admin'] }),\n      },\n      {\n        name: 'notIn',\n        schema: vine.string().notIn(['admin']),\n        rule: notInRule({ list: ['admin'] }),\n      },\n      {\n        name: 'ipAddress',\n        schema: vine.string().ipAddress(),\n        rule: ipAddressRule(),\n      },\n      {\n        name: 'ipAddress',\n        schema: vine.string().ipAddress(4),\n        rule: ipAddressRule({ version: 4 }),\n      },\n      {\n        name: 'creditCard',\n        schema: vine.string().creditCard(),\n        rule: creditCardRule(),\n      },\n      {\n        name: 'passport',\n        schema: vine.string().passport({ countryCode: ['IN'] }),\n        rule: passportRule({ countryCode: ['IN'] }),\n      },\n      {\n        name: 'postalCode',\n        schema: vine.string().postalCode({ countryCode: ['IN'] }),\n        rule: postalCodeRule({ countryCode: ['IN'] }),\n      },\n      {\n        name: 'uuid',\n        schema: vine.string().uuid(),\n        rule: uuidRule(),\n      },\n      {\n        name: 'ascii',\n        schema: vine.string().ascii(),\n        rule: asciiRule(),\n      },\n      {\n        name: 'iban',\n        schema: vine.string().iban(),\n        rule: ibanRule(),\n      },\n      {\n        name: 'jwt',\n        schema: vine.string().jwt(),\n        rule: jwtRule(),\n      },\n      {\n        name: 'coordinates',\n        schema: vine.string().coordinates(),\n        rule: coordinatesRule(),\n      },\n      {\n        name: 'toUpperCase',\n        schema: vine.string().toUpperCase(),\n        rule: toUpperCaseRule(),\n      },\n      {\n        name: 'toLowerCase',\n        schema: vine.string().toLowerCase(),\n        rule: toLowerCaseRule(),\n      },\n      {\n        name: 'toCamelCase',\n        schema: vine.string().toCamelCase(),\n        rule: toCamelCaseRule(),\n      },\n      {\n        name: 'escape',\n        schema: vine.string().escape(),\n        rule: escapeRule(),\n      },\n      {\n        name: 'normalizeUrl',\n        schema: vine.string().normalizeUrl(),\n        rule: normalizeUrlRule(),\n      },\n    ])\n    .run(({ assert }, { schema, rule }) => {\n      const refs = refsBuilder()\n\n      assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        allowNull: false,\n        isOptional: false,\n        bail: true,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n          {\n            implicit: false,\n            isAsync: rule.rule.isAsync,\n            ruleFnId: 'ref://2',\n          },\n        ],\n      })\n\n      assert.deepEqual(refs.toJSON()['ref://2'], {\n        validator: rule.rule.validator,\n        options: rule.options,\n      })\n    })\n})\n"]}
{"filename": "tests/unit/schema/any.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('VineAny', () => {", "\ntest.group('VineAny', () => {\n  test('create any schema', ({ assert }) => {\n    const schema = vine.any()\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.any().nullable()", "  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.any().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.any().optional()\n", "    const schema = vine.any().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.any().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [],", "      parseFnId: undefined,\n      validations: [],\n    })\n  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.any().parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [],\n    })\n  })", "    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.any().transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://1',\n      validations: [],\n    })\n  })\n})", "  })\n})\n\ntest.group('VineAny | clone', () => {\n  test('clone any schema', ({ assert }) => {\n    const schema = vine.any()\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })", "      validations: [],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.any()\n    const schema1 = schema.clone().nullable()\n", "    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,", "      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.any()", "  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.any()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n  })\n", "  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.any()\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [],\n    })", "      validations: [],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.any()\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })", "      validations: [],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://1',\n      validations: [],\n    })\n  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.any()", "  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.any()\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [],\n    })\n  })\n})", "  })\n})\n"]}
{"filename": "tests/unit/schema/union.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('Vine Union', () => {", "\ntest.group('Vine Union', () => {\n  test('construct union schema', ({ assert }) => {\n    const schema = vine.union([\n      vine.union.if(\n        (data) => data.type === 'stripe',\n        vine.object({\n          type: vine.literal('stripe'),\n          account_id: vine.string(),\n        })\n      ),", "      vine.union.if(\n        (data) => data.type === 'paypal',\n        vine.object({\n          type: vine.literal('paypal'),\n          email: vine.string(),\n        })\n      ),\n      vine.union.if(\n        (data) => data.type === 'open_collective',\n        vine.object({\n          type: vine.literal('open_collective'),\n          project_url: vine.string(),\n        })\n      ),\n    ])\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'account_id',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'project_url',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n    })\n  })\n\n  test('define callback schema using union.else', ({ assert }) => {\n    const schema = vine.union([", "      vine.union.if(\n        (data) => data.type === 'stripe',\n        vine.object({\n          type: vine.literal('stripe'),\n          account_id: vine.string(),\n        })\n      ),\n      vine.union.if(\n        (data) => data.type === 'paypal',\n        vine.object({\n          type: vine.literal('paypal'),\n          email: vine.string(),\n        })\n      ),\n      vine.union.else(\n        vine.object({\n          type: vine.literal('open_collective'),\n          project_url: vine.string(),\n        })\n      ),\n    ])\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'account_id',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'project_url',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n    })\n  })\n\n  test('clone schema', ({ assert }) => {\n    const schema = vine.union([", "      vine.union.if(\n        (data) => data.type === 'stripe',\n        vine.object({\n          type: vine.literal('stripe'),\n          account_id: vine.string(),\n        })\n      ),\n      vine.union.if(\n        (data) => data.type === 'paypal',\n        vine.object({\n          type: vine.literal('paypal'),\n          email: vine.string(),\n        })\n      ),", "      vine.union.if(\n        (data) => data.type === 'open_collective',\n        vine.object({\n          type: vine.literal('open_collective'),\n          project_url: vine.string(),\n        })\n      ),\n    ])\n\n    const schema1 = schema.clone().otherwise(() => {})\n    const refs = refsBuilder()\n    const refs1 = refsBuilder()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'account_id',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'project_url',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs1, { toCamelCase: false }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'account_id',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'project_url',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n    })\n\n    assert.notDeepEqual(refs.toJSON()['ref://1'], refs1.toJSON()['ref://1'])\n  })\n\n  test('apply camelcase transform to propertyName', ({ assert }) => {\n    const schema = vine.union([", "      vine.union.if(\n        (data) => data.type === 'stripe',\n        vine.object({\n          type: vine.literal('stripe'),\n          account_id: vine.string(),\n        })\n      ),\n      vine.union.if(\n        (data) => data.type === 'paypal',\n        vine.object({\n          type: vine.literal('paypal'),\n          email: vine.string(),\n        })\n      ),\n      vine.union.else(\n        vine.object({\n          type: vine.literal('open_collective'),\n          project_url: vine.string(),\n        })\n      ),\n    ])\n\n    assert.deepEqual(schema[PARSE]('fiscal_host', refsBuilder(), { toCamelCase: true }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: 'fiscal_host',\n            propertyName: 'fiscalHost',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'accountId',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: 'fiscal_host',\n            propertyName: 'fiscalHost',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: 'fiscal_host',\n            propertyName: 'fiscalHost',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'projectUrl',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: 'fiscal_host',\n      propertyName: 'fiscalHost',\n      type: 'union',\n    })\n  })\n\n  test('copy otherwise callback to the cloned schema', ({ assert }) => {\n    const schema = vine\n      .union([", "        vine.union.if(\n          (data) => data.type === 'stripe',\n          vine.object({\n            type: vine.literal('stripe'),\n            account_id: vine.string(),\n          })\n        ),\n        vine.union.if(\n          (data) => data.type === 'paypal',\n          vine.object({\n            type: vine.literal('paypal'),\n            email: vine.string(),\n          })\n        ),", "        vine.union.if(\n          (data) => data.type === 'open_collective',\n          vine.object({\n            type: vine.literal('open_collective'),\n            project_url: vine.string(),\n          })\n        ),\n      ])\n      .otherwise(() => {})\n\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'account_id',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'project_url',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://3',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'account_id',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'account_id',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://4',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://5',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://6',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'email',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'email',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://7',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://8',\n          schema: {\n            allowNull: false,\n            allowUnknownProperties: false,\n            bail: true,\n            fieldName: '*',\n            groups: [],\n            isOptional: false,\n            parseFnId: undefined,\n            properties: [\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'type',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'type',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://9',\n                  },\n                ],\n              },\n              {\n                allowNull: false,\n                bail: true,\n                fieldName: 'project_url',\n                isOptional: false,\n                parseFnId: undefined,\n                propertyName: 'project_url',\n                type: 'literal',\n                validations: [\n                  {\n                    implicit: false,\n                    isAsync: false,\n                    ruleFnId: 'ref://10',\n                  },\n                ],\n              },\n            ],\n            propertyName: '*',\n            type: 'object',\n            validations: [],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n      fieldName: '*',\n      propertyName: '*',\n      type: 'union',\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/literal.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('VineLiteral', () => {", "\ntest.group('VineLiteral', () => {\n  test('create literal schema', ({ assert }) => {\n    const schema = vine.literal(22)\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.literal(22).nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.literal(22).optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.literal(22).bail(false)", "  test('disable bail mode', ({ assert }) => {\n    const schema = vine.literal(22).bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,", "      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.literal(22).transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.literal(22).parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },", "          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineLiteral | clone', () => {\n  test('clone boolean schema', ({ assert }) => {\n    const schema = vine.literal(22)", "  test('clone boolean schema', ({ assert }) => {\n    const schema = vine.literal(22)\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.literal(22)\n    const schema1 = schema.clone().nullable()\n", "    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.literal(22)\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.literal(22)\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.literal(22)", "  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.literal(22)\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.literal(22)", "  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.literal(22)\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',", "          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/object.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\nconst vine = new Vine()\n\ntest.group('VineObject', () => {", "\ntest.group('VineObject', () => {\n  test('create object', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({})\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [],", "      parseFnId: undefined,\n      properties: [],\n    })\n  })\n\n  test('define object properties', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      username: vine.string(),\n    })", "      username: vine.string(),\n    })\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',", "          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .nullable()", "      })\n      .nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,", "      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',", "          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .optional()", "      })\n      .optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,", "      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',", "          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('allow unknown properties', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .allowUnknownProperties()", "      })\n      .allowUnknownProperties()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',", "          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .bail(false)", "      })\n      .bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',", "          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('merge group', ({ assert }) => {\n    const hiringGuide = vine.group([\n      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        name: vine.string(),\n        price: vine.string(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n      .merge(hiringGuide)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('merge multiple group', ({ assert }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const monumentSchema = vine.group([", "      vine.group.if((data) => data.monument === 'foo', {\n        monument: vine.literal('foo'),\n        available_transport: vine.enum(['bus', 'train']),\n        has_free_entry: vine.literal(false),\n      }),\n      vine.group.if((data) => data.monument === 'bar', {\n        monument: vine.literal('bar'),\n        available_transport: vine.enum(['bus', 'car']),\n        has_free_entry: vine.literal(true),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .merge(monumentSchema)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://2',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://6',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'hiring_guide',\n                    propertyName: 'hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://3',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'guide_name',\n                    propertyName: 'guide_name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'fees',\n                    propertyName: 'fees',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://8',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'hiring_guide',\n                    propertyName: 'hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://7',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://9',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://13',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'monument',\n                    propertyName: 'monument',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://10',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'available_transport',\n                    propertyName: 'available_transport',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://11',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'has_free_entry',\n                    propertyName: 'has_free_entry',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://12',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://17',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'monument',\n                    propertyName: 'monument',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://14',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'available_transport',\n                    propertyName: 'available_transport',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://15',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'has_free_entry',\n                    propertyName: 'has_free_entry',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://16',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'visitor_name',\n          propertyName: 'visitor_name',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('define custom otherwise callback', ({ assert }) => {", "    function failOtherwise() {}\n\n    const hiringGuide = vine\n      .group([\n        vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n          is_hiring_guide: vine.literal(true),\n          name: vine.string(),\n          price: vine.string(),\n        }),\n        vine.group.else({\n          is_hiring_guide: vine.literal(false),\n        }),\n      ])\n      .otherwise(failOtherwise)\n\n    const schema = vine\n      .object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n      .merge(hiringGuide)\n\n    const refs = refsBuilder()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n    assert.deepEqual(refs.toJSON()['ref://3'], failOtherwise)\n  })\n\n  test('create nested object', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      user: vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      }),\n    })\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'username',\n              propertyName: 'username',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://1',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'password',\n              propertyName: 'password',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('deeply apply camelcase transform', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        post_id: vine.number(),\n        user: vine.object({\n          user_name: vine.string(),\n          pass_word: vine.string(),\n        }),\n      })\n      .toCamelCase()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('apply camelcase transform to nested object', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      post_id: vine.number(),\n      user: vine\n        .object({\n          user_name: vine.string(),\n          pass_word: vine.string(),\n        })\n        .toCamelCase(),\n    })\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'post_id',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('apply camelcase transform to groups', ({ assert }) => {\n    const hiringGuide = vine.group([", "      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        name: vine.string(),\n        price: vine.string(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n      .merge(hiringGuide)\n      .toCamelCase()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'isHiringGuide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'isHiringGuide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('merge camelcase transform to multiple group', ({ assert }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const monumentSchema = vine.group([", "      vine.group.if((data) => data.monument === 'foo', {\n        monument: vine.literal('foo'),\n        available_transport: vine.enum(['bus', 'train']),\n        has_free_entry: vine.literal(false),\n      }),\n      vine.group.if((data) => data.monument === 'bar', {\n        monument: vine.literal('bar'),\n        available_transport: vine.enum(['bus', 'car']),\n        has_free_entry: vine.literal(true),\n      }),\n    ])\n\n    const schema = vine\n      .object({\n        visitor_name: vine.string(),\n      })\n      .merge(guideSchema)\n      .merge(monumentSchema)\n      .toCamelCase()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://2',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://6',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'hiring_guide',\n                    propertyName: 'hiringGuide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://3',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'guide_name',\n                    propertyName: 'guideName',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'fees',\n                    propertyName: 'fees',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://8',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'hiring_guide',\n                    propertyName: 'hiringGuide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://7',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://9',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://13',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'monument',\n                    propertyName: 'monument',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://10',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'available_transport',\n                    propertyName: 'availableTransport',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://11',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'has_free_entry',\n                    propertyName: 'hasFreeEntry',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://12',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://17',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'monument',\n                    propertyName: 'monument',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://14',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'available_transport',\n                    propertyName: 'availableTransport',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://15',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'has_free_entry',\n                    propertyName: 'hasFreeEntry',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://16',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'visitor_name',\n          propertyName: 'visitorName',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('deeply apply camelcase transform', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        post_id: vine.number(),\n        user: vine.object({\n          user_name: vine.string(),\n          pass_word: vine.string(),\n        }),\n      })\n      .toCamelCase()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('define parser', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({}).parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: 'ref://1',\n      properties: [],\n    })\n  })\n\n  test('apply nullable modifier after camelcase modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        post_id: vine.number(),\n        user: vine.object({\n          user_name: vine.string(),\n          pass_word: vine.string(),\n        }),\n      })\n      .toCamelCase()\n      .nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier after camelcase modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        post_id: vine.number(),\n        user: vine.object({\n          user_name: vine.string(),\n          pass_word: vine.string(),\n        }),\n      })\n      .toCamelCase()\n      .optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('check if value is an object using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.object({})\n\n    assert.isTrue(schema[IS_OF_TYPE]({}))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE]([]))\n    assert.isFalse(schema[IS_OF_TYPE](''))\n    assert.isFalse(schema[IS_OF_TYPE](1))\n  })\n\n  test('check if value is an object after applying camelcase modifier', ({ assert }) => {\n    const schema = vine.object({}).toCamelCase()\n\n    assert.isTrue(schema[IS_OF_TYPE]({}))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE]([]))\n    assert.isFalse(schema[IS_OF_TYPE](''))\n    assert.isFalse(schema[IS_OF_TYPE](1))\n  })\n})\n\ntest.group('VineObject | clone', () => {\n  test('clone object', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({})\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [],\n    })\n  })\n\n  test('copy properties during clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      username: vine.string(),\n    })\n\n    const schema1 = vine.object({\n      ...schema.getProperties(),\n      password: vine.string(),\n    })\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://3',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      username: vine.string(),\n    })\n\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      username: vine.string(),\n    })\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and allow unknown properties', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      username: vine.string(),\n    })\n\n    const schema1 = schema.clone().allowUnknownProperties()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.object({\n      username: vine.string(),\n    })\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('merge group to cloned object', ({ assert }) => {\n    const hiringGuide = vine.group([", "      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        name: vine.string(),\n        price: vine.string(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })\n    const schema1 = schema.clone().merge(hiringGuide)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('merge groups across original and cloned objects', ({ assert }) => {\n    const guideSchema = vine.group([", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n        hiring_guide: vine.literal(true),\n        guide_name: vine.string(),\n        fees: vine.string(),\n      }),\n      vine.group.if(() => true, {\n        hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const monumentSchema = vine.group([", "      vine.group.if((data) => data.monument === 'foo', {\n        monument: vine.literal('foo'),\n        available_transport: vine.enum(['bus', 'train']),\n        has_free_entry: vine.literal(false),\n      }),\n      vine.group.if((data) => data.monument === 'bar', {\n        monument: vine.literal('bar'),\n        available_transport: vine.enum(['bus', 'car']),\n        has_free_entry: vine.literal(true),\n      }),\n    ])\n\n    const schema = vine.object({\n      visitor_name: vine.string(),\n    })\n    const schema1 = schema.clone().merge(monumentSchema)\n    schema.merge(guideSchema)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://2',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://6',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'hiring_guide',\n                    propertyName: 'hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://3',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'guide_name',\n                    propertyName: 'guide_name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'fees',\n                    propertyName: 'fees',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://8',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'hiring_guide',\n                    propertyName: 'hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://7',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'visitor_name',\n          propertyName: 'visitor_name',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://2',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://6',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'monument',\n                    propertyName: 'monument',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://3',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'available_transport',\n                    propertyName: 'available_transport',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'has_free_entry',\n                    propertyName: 'has_free_entry',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://10',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'monument',\n                    propertyName: 'monument',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://7',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'available_transport',\n                    propertyName: 'available_transport',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'has_free_entry',\n                    propertyName: 'has_free_entry',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://9',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'visitor_name',\n          propertyName: 'visitor_name',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('clone and deeply apply camelcase transform', ({ assert }) => {\n    const schema = vine.object({\n      post_id: vine.number(),\n      user: vine.object({\n        user_name: vine.string(),\n        pass_word: vine.string(),\n      }),\n    })\n\n    const schema1 = schema.clone().toCamelCase()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'post_id',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'user_name',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'pass_word',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('re-use schema via cloning', ({ assert }) => {\n    const user = vine.object({\n      user_name: vine.string(),\n      pass_word: vine.string(),\n    })\n\n    const schema = vine\n      .object({\n        post_id: vine.number(),\n        user: user.clone(),\n      })\n      .toCamelCase()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(user[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'user_name',\n          propertyName: 'user_name',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'pass_word',\n          propertyName: 'pass_word',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('clone group', ({ assert }) => {", "    function failOtherwise() {}\n\n    const hiringGuide = vine.group([\n      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n        is_hiring_guide: vine.literal(true),\n        name: vine.string(),\n        price: vine.string(),\n      }),\n      vine.group.else({\n        is_hiring_guide: vine.literal(false),\n      }),\n    ])\n\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })\n\n    const schema1 = schema.clone().merge(hiringGuide.clone().otherwise(failOtherwise))\n    schema.merge(hiringGuide)\n\n    const refs = refsBuilder()\n    const refs1 = refsBuilder()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs1, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.notDeepEqual(refs.toJSON()['ref://3'], refs1.toJSON()['ref://3'])\n  })\n\n  test('define otherwise callback and clone group', ({ assert }) => {\n    const hiringGuide = vine\n      .group([", "        vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n          is_hiring_guide: vine.literal(true),\n          name: vine.string(),\n          price: vine.string(),\n        }),\n        vine.group.else({\n          is_hiring_guide: vine.literal(false),\n        }),\n      ])\n      .otherwise(() => {})\n\n    const schema = vine.object({\n      username: vine.string(),\n      password: vine.string(),\n    })\n\n    const schema1 = schema.clone().merge(hiringGuide.clone())\n    schema.merge(hiringGuide)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [\n        {\n          type: 'group',\n          elseConditionalFnRefId: 'ref://3',\n          conditions: [\n            {\n              conditionalFnRefId: 'ref://7',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://4',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'name',\n                    propertyName: 'name',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://5',\n                      },\n                    ],\n                  },\n                  {\n                    type: 'literal',\n                    fieldName: 'price',\n                    propertyName: 'price',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://6',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n            {\n              conditionalFnRefId: 'ref://9',\n              schema: {\n                type: 'sub_object',\n                groups: [],\n                properties: [\n                  {\n                    type: 'literal',\n                    fieldName: 'is_hiring_guide',\n                    propertyName: 'is_hiring_guide',\n                    bail: true,\n                    allowNull: false,\n                    isOptional: false,\n                    parseFnId: undefined,\n                    validations: [\n                      {\n                        implicit: false,\n                        isAsync: false,\n                        ruleFnId: 'ref://8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            },\n          ],\n        },\n      ],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'literal',\n          fieldName: 'password',\n          propertyName: 'password',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('apply toCamelCase transform and clone', ({ assert }) => {\n    const schema = vine\n      .object({\n        post_id: vine.number(),\n        user: vine.object({\n          user_name: vine.string(),\n          pass_word: vine.string(),\n        }),\n      })\n      .toCamelCase()\n\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'post_id',\n          propertyName: 'postId',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          parseFnId: undefined,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n        },\n        {\n          type: 'object',\n          fieldName: 'user',\n          propertyName: 'user',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          allowUnknownProperties: false,\n          validations: [],\n          groups: [],\n          parseFnId: undefined,\n          properties: [\n            {\n              type: 'literal',\n              fieldName: 'user_name',\n              propertyName: 'userName',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://2',\n                },\n              ],\n            },\n            {\n              type: 'literal',\n              fieldName: 'pass_word',\n              propertyName: 'passWord',\n              bail: true,\n              allowNull: false,\n              isOptional: false,\n              parseFnId: undefined,\n              validations: [\n                {\n                  implicit: false,\n                  isAsync: false,\n                  ruleFnId: 'ref://3',\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    })\n  })\n\n  test('allow unknown properties and clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .allowUnknownProperties()\n\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier and clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .nullable()\n\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier and clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine\n      .object({\n        username: vine.string(),\n      })\n      .optional()\n\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'object',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      groups: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: 'username',\n          propertyName: 'username',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/accepted.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('VineAccepted', () => {", "\ntest.group('VineAccepted', () => {\n  test('create accepted schema', ({ assert }) => {\n    const schema = vine.accepted()\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.accepted().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.accepted().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.accepted().bail(false)", "  test('disable bail mode', ({ assert }) => {\n    const schema = vine.accepted().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,", "      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.accepted().parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {", "\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.accepted().transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineAccepted | clone', () => {\n  test('clone accepted schema', ({ assert }) => {\n    const schema = vine.accepted()", "  test('clone accepted schema', ({ assert }) => {\n    const schema = vine.accepted()\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.accepted()\n    const schema1 = schema.clone().nullable()\n", "    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.accepted()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.accepted()\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.accepted()", "  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.accepted()\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.accepted()", "  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.accepted()\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },", "          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },", "          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/record.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\nimport {\n  maxLengthRule,\n  minLengthRule,\n  fixedLengthRule,", "  minLengthRule,\n  fixedLengthRule,\n  validateKeysRule,\n} from '../../../src/schema/record/rules.js'\n\nconst vine = new Vine()\n\ntest.group('VineRecord', () => {\n  test('construct record schema', ({ assert }) => {\n    const schema = vine.record(", "  test('construct record schema', ({ assert }) => {\n    const schema = vine.record(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {", "      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],", "        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,", "            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',", "                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,", "            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',", "                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n", "  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )", "        })\n      )\n      .nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,", "      bail: true,\n      allowNull: true,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({", "      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {", "      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],", "        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,", "            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',", "                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,", "            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',", "                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n", "  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )", "        })\n      )\n      .bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,", "      bail: false,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n  })\n\n  test('define parser', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({", "      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: 'ref://3',\n      each: {", "      parseFnId: 'ref://3',\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],", "        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,", "            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',", "                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,", "            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',", "                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n", "  })\n\n  test('convert propertyName to camelCase', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )", "        })\n      )\n      .parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('app_users', refsBuilder(), { toCamelCase: true }), {\n      type: 'record',\n      fieldName: 'app_users',\n      propertyName: 'appUsers',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: 'ref://3',\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n  })\n\n  test('check if value is an object using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.record(vine.string())\n\n    assert.isTrue(schema[IS_OF_TYPE]({}))", "\n    assert.isTrue(schema[IS_OF_TYPE]({}))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE]([]))\n    assert.isFalse(schema[IS_OF_TYPE](''))\n    assert.isFalse(schema[IS_OF_TYPE](1))\n  })\n})\n", "})\n\ntest.group('VineRecord | clone', () => {\n  test('clone record schema', ({ assert }) => {\n    const schema = vine.record(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )", "      })\n    )\n\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [", "        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,", "            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },", "            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,", "            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },", "            ],\n          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [", "        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,", "            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },", "            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,", "            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },", "            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.record(\n      vine.object({", "    const schema = vine.record(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {", "      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],", "        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,", "            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',", "                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,", "            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',", "                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {", "      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],", "        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,", "            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',", "                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,", "            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',", "                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n", "  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.record(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n    const schema1 = schema.clone().optional()", "    )\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,", "      allowNull: false,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.record(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),", "        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',", "      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {", "      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],", "        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,", "            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',", "                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,", "            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',", "                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n", "  })\n\n  test('apply nullable modifier and clone', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )", "        })\n      )\n      .nullable()\n\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',", "        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,", "        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,", "            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],", "              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,", "            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],", "              },\n            ],\n          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',", "        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,", "        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,", "            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],", "              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,", "            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],", "              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('apply optional modifier and clone', ({ assert }) => {\n    const schema = vine", "  test('apply optional modifier and clone', ({ assert }) => {\n    const schema = vine\n      .record(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .optional()\n", "      .optional()\n\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,", "      bail: true,\n      allowNull: true,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n  })\n})\n\ntest.group('VineRecord | applying rules', () => {\n  test('apply minLength rule', ({ assert }) => {\n    const refs = refsBuilder()", "  test('apply minLength rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.record(vine.string()).minLength(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],", "        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,", "        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],", "          },\n        ],\n      },\n    })\n\n    const minLength = minLengthRule({ min: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })", "      options: minLength.options,\n    })\n  })\n\n  test('apply maxLength rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.record(vine.string()).maxLength(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'record',", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',", "        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,", "          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },\n    })\n\n    const maxLength = maxLengthRule({ max: 2 })", "\n    const maxLength = maxLengthRule({ max: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: maxLength.rule.validator,\n      options: maxLength.options,\n    })\n  })\n\n  test('apply fixedLength rule', ({ assert }) => {\n    const refs = refsBuilder()", "  test('apply fixedLength rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.record(vine.string()).fixedLength(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],", "        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,", "        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],", "          },\n        ],\n      },\n    })\n\n    const fixedLength = fixedLengthRule({ size: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: fixedLength.rule.validator,\n      options: fixedLength.options,\n    })", "      options: fixedLength.options,\n    })\n  })\n\n  test('apply validateKeys rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const callback = () => {}\n    const schema = vine.record(vine.string()).validateKeys(callback)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'record',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',", "      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {", "        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },\n    })\n", "    })\n\n    const validateKeys = validateKeysRule(callback)\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: validateKeys.rule.validator,\n      options: validateKeys.options,\n    })\n  })\n})\n", "})\n"]}
{"filename": "tests/unit/schema/tuple.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\nconst vine = new Vine()\n\ntest.group('VineTuple', () => {", "\ntest.group('VineTuple', () => {\n  test('create tuple', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([])\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [],\n    })", "      properties: [],\n    })\n  })\n\n  test('define tuple elements', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,", "      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,", "          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,", "          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).nullable()", "    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,", "      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',", "          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',", "              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string(), vine.number()]).optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {", "      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {", "          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n        {", "        },\n        {\n          type: 'literal',\n          fieldName: '1',\n          propertyName: '1',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {", "          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('allow unknown properties', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).allowUnknownProperties()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],", "      allowUnknownProperties: true,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,", "          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],", "            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const refs = refsBuilder()", "  test('disable bail mode', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,", "      bail: false,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',", "          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('define parser', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',", "      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: 'ref://1',\n      properties: [", "      parseFnId: 'ref://1',\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [", "          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },", "          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('convert propertyName to camelCase', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).parse(() => {})\n", "    const schema = vine.tuple([vine.string()]).parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('user_scores', refs, { toCamelCase: true }), {\n      type: 'tuple',\n      fieldName: 'user_scores',\n      propertyName: 'userScores',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,", "      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: 'ref://1',\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,", "          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },", "              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('check if value is an array using IS_OF_TYPE method', ({ assert }) => {", "\n  test('check if value is an array using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.tuple([])\n\n    assert.isTrue(schema[IS_OF_TYPE]([]))\n    assert.isFalse(schema[IS_OF_TYPE]({}))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE](''))\n  })", "    assert.isFalse(schema[IS_OF_TYPE](''))\n  })\n})\n\ntest.group('VineTuple | clone', () => {\n  test('clone tuple', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([])\n    const schema1 = schema.clone()\n", "    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,", "      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',", "      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [],", "      parseFnId: undefined,\n      properties: [],\n    })\n  })\n\n  test('clone tuple with elements', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])\n    const schema1 = schema.clone()\n", "    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,", "      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,", "          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },", "              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',", "    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,", "      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,", "          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,", "          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])", "    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',", "          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,", "              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n", "    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,", "      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,", "          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },", "              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {", "\n  test('clone and apply optional modifier', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string(), vine.number()])\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {", "      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {", "          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n        {", "        },\n        {\n          type: 'literal',\n          fieldName: '1',\n          propertyName: '1',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {", "          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],", "        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,", "      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',", "          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://3',", "              isAsync: false,\n              ruleFnId: 'ref://3',\n            },\n          ],\n          parseFnId: undefined,\n        },\n        {\n          type: 'literal',\n          fieldName: '1',\n          propertyName: '1',", "          fieldName: '1',\n          propertyName: '1',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://4',", "              isAsync: false,\n              ruleFnId: 'ref://4',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('clone and allow unknown properties', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])\n    const schema1 = schema.clone().allowUnknownProperties()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',", "      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [", "      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [", "          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },", "          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',", "        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,", "            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],", "      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,", "          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],", "            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',", "      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [", "      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [", "          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },", "          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('clone and define parser', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()])\n    const schema1 = schema.clone().parse(() => {})", "    const schema = vine.tuple([vine.string()])\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',", "          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',", "              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {", "\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],", "      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: 'ref://2',\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,", "          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://3',\n            },\n          ],", "            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n\n  test('allow unknown properties and clone', ({ assert }) => {\n    const refs = refsBuilder()", "  test('allow unknown properties and clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).allowUnknownProperties()\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',", "        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,", "            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })", "      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      allowUnknownProperties: true,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',", "          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',", "              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('allow nullable modifier and clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).nullable()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',", "      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [", "      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [", "          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],\n          parseFnId: undefined,\n        },", "          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',", "        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,", "            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('allow optional modifier and clone', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.tuple([vine.string()]).optional()\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],", "      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,", "          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://1',\n            },\n          ],", "            },\n          ],\n          parseFnId: undefined,\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'tuple',\n      fieldName: '*',", "      type: 'tuple',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      allowUnknownProperties: false,\n      validations: [],\n      parseFnId: undefined,\n      properties: [", "      parseFnId: undefined,\n      properties: [\n        {\n          type: 'literal',\n          fieldName: '0',\n          propertyName: '0',\n          bail: true,\n          allowNull: false,\n          isOptional: false,\n          validations: [", "          isOptional: false,\n          validations: [\n            {\n              implicit: false,\n              isAsync: false,\n              ruleFnId: 'ref://2',\n            },\n          ],\n          parseFnId: undefined,\n        },", "          parseFnId: undefined,\n        },\n      ],\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/boolean.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\nimport { booleanRule } from '../../../src/schema/boolean/rules.js'\n\nconst vine = new Vine()\n", "const vine = new Vine()\n\ntest.group('VineBoolean', () => {\n  test('create boolean schema', ({ assert }) => {\n    const schema = vine.boolean()\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('create boolean schema in strict mode', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.boolean({ strict: true })", "    const refs = refsBuilder()\n    const schema = vine.boolean({ strict: true })\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n\n    const rule = booleanRule({ strict: true })\n    assert.deepEqual(refs.toJSON()['ref://1'], {\n      validator: rule.rule.validator,\n      options: rule.options,\n    })\n  })\n", "  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.boolean().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,", "      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.boolean().optional()\n", "    const schema = vine.boolean().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.boolean().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply parser', ({ assert }) => {", "\n  test('apply parser', ({ assert }) => {\n    const schema = vine.boolean().parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.boolean().transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {", "      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n", "  })\n\n  test('check if value is a boolean using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = vine.boolean({ strict: true })\n\n    assert.isTrue(schema[IS_OF_TYPE](true))\n    assert.isTrue(schema[IS_OF_TYPE](false))\n    assert.isTrue(schema[IS_OF_TYPE](0))\n    assert.isTrue(schema[IS_OF_TYPE](1))", "    assert.isTrue(schema[IS_OF_TYPE](0))\n    assert.isTrue(schema[IS_OF_TYPE](1))\n    assert.isTrue(schema[IS_OF_TYPE]('true'))\n    assert.isTrue(schema[IS_OF_TYPE]('false'))\n    assert.isTrue(schema[IS_OF_TYPE]('on'))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE](''))\n\n    assert.isTrue(schema1[IS_OF_TYPE](true))", "\n    assert.isTrue(schema1[IS_OF_TYPE](true))\n    assert.isTrue(schema1[IS_OF_TYPE](false))\n    assert.isFalse(schema1[IS_OF_TYPE](0))\n    assert.isFalse(schema1[IS_OF_TYPE](1))\n    assert.isFalse(schema1[IS_OF_TYPE]('true'))\n    assert.isFalse(schema1[IS_OF_TYPE]('false'))\n    assert.isFalse(schema1[IS_OF_TYPE]('on'))\n    assert.isFalse(schema1[IS_OF_TYPE](null))\n    assert.isFalse(schema1[IS_OF_TYPE](undefined))", "    assert.isFalse(schema1[IS_OF_TYPE](null))\n    assert.isFalse(schema1[IS_OF_TYPE](undefined))\n    assert.isFalse(schema1[IS_OF_TYPE](''))\n  })\n})\n\ntest.group('VineBoolean | clone', () => {\n  test('clone boolean schema', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = schema.clone()", "    const schema = vine.boolean()\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [", "      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })", "    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',", "      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,", "        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {", "\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,", "      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = schema.clone().transform(() => {})", "    const schema = vine.boolean()\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',", "          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.boolean()\n    const schema1 = schema.clone().parse(() => {})", "    const schema = vine.boolean()\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],", "        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,", "      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],", "        },\n      ],\n    })\n  })\n\n  test('clone strict mode boolean', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.boolean({ strict: true })\n    const schema1 = schema.clone()\n", "    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })", "      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,", "      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })", "      ],\n    })\n\n    const rule = booleanRule({ strict: true })\n    assert.deepEqual(refs.toJSON()['ref://1'], {\n      validator: rule.rule.validator,\n      options: rule.options,\n    })\n\n    assert.deepEqual(refs.toJSON()['ref://2'], {", "\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: rule.rule.validator,\n      options: rule.options,\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/native_enum.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\nenum Role {\n  GUEST = 'guest',\n  MODERATOR = 'moderator',\n  ADMIN = 'admin',\n}\n\ntest.group('VineNativeEnum', () => {", "enum Role {\n  GUEST = 'guest',\n  MODERATOR = 'moderator',\n  ADMIN = 'admin',\n}\n\ntest.group('VineNativeEnum', () => {\n  test('create enum schema', ({ assert }) => {\n    const schema = vine.enum(Role)\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine.enum(Role).nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine.enum(Role).optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine.enum(Role).bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply transformer', ({ assert }) => {\n    const schema = vine.enum(Role).transform(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('apply parser', ({ assert }) => {\n    const schema = vine.enum(Role).parse(() => {})\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n\ntest.group('VineNativeEnum | clone', () => {", "  test('clone enum schema', ({ assert }) => {\n    const schema = vine.enum(Role)\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.enum(Role)\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: true,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.enum(Role)\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: true,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.enum(Role)\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: false,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply transformer', ({ assert }) => {\n    const schema = vine.enum(Role)\n    const schema1 = schema.clone().transform(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      transformFnId: 'ref://2',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n  })\n\n  test('clone and apply parser', ({ assert }) => {\n    const schema = vine.enum(Role)\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: undefined,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://1',\n        },\n      ],\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'literal',\n      fieldName: '*',\n      propertyName: '*',\n      allowNull: false,\n      isOptional: false,\n      bail: true,\n      parseFnId: 'ref://1',\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/array.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { Vine } from '../../../src/vine/main.js'\nimport type { RuleBuilder } from '../../../src/types.js'\nimport { IS_OF_TYPE, PARSE, VALIDATION } from '../../../src/symbols.js'\nimport {\n  compactRule,\n  distinctRule,", "  compactRule,\n  distinctRule,\n  notEmptyRule,\n  maxLengthRule,\n  minLengthRule,\n  fixedLengthRule,\n} from '../../../src/schema/array/rules.js'\n\nconst vine = new Vine()\n", "const vine = new Vine()\n\ntest.group('VineArray', () => {\n  test('construct array schema', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )", "      })\n    )\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n  })\n\n  test('apply nullable modifier', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),", "        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('apply optional modifier', ({ assert }) => {", "\n  test('apply optional modifier', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .optional()", "      )\n      .optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,", "      allowNull: false,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n  })\n\n  test('disable bail mode', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),", "        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('apply rules', ({ assert }) => {", "\n  test('apply rules', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .minLength(10)", "      )\n      .minLength(10)\n      .maxLength(20)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://3',\n        },\n        {", "        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://4',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('define parser', ({ assert }) => {", "\n  test('define parser', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .parse(() => {})", "      )\n      .parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: 'ref://3',\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n  })\n\n  test('convert property name to camelcase', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),", "        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('app_users', refsBuilder(), { toCamelCase: true }), {\n      type: 'array',\n      fieldName: 'app_users',", "      type: 'array',\n      fieldName: 'app_users',\n      propertyName: 'appUsers',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: 'ref://3',\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('check if value is an array using IS_OF_TYPE method', ({ assert }) => {", "\n  test('check if value is an array using IS_OF_TYPE method', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n\n    assert.isTrue(schema[IS_OF_TYPE]([]))", "\n    assert.isTrue(schema[IS_OF_TYPE]([]))\n    assert.isFalse(schema[IS_OF_TYPE]({}))\n    assert.isFalse(schema[IS_OF_TYPE](null))\n    assert.isFalse(schema[IS_OF_TYPE](undefined))\n    assert.isFalse(schema[IS_OF_TYPE](''))\n  })\n})\n\ntest.group('VineArray | clone', () => {", "\ntest.group('VineArray | clone', () => {\n  test('clone array schema', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n", "    )\n\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,", "        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {", "        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {", "          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [", "            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],", "          },\n        ],\n      },\n    })\n  })\n\n  test('clone and apply nullable modifier', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),", "      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('clone and apply optional modifier', ({ assert }) => {", "\n  test('clone and apply optional modifier', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n    const schema1 = schema.clone().optional()\n", "    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],", "      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,", "        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',", "            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,", "              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',", "            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,", "              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })", "      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      validations: [],", "      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,", "        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',", "            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,", "              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',", "            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,", "              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })", "      },\n    })\n  })\n\n  test('clone and disable bail mode', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })", "        password: vine.string(),\n      })\n    )\n\n    const schema1 = schema.clone().bail(false)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',", "        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,", "        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,", "            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],", "              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,", "            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],", "              },\n            ],\n          },\n        ],\n      },\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: false,\n      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('clone and apply rules', ({ assert }) => {", "\n  test('clone and apply rules', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .minLength(10)", "      )\n      .minLength(10)\n\n    const schema1 = schema.clone().maxLength(20)\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,", "      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://3',\n        },", "          ruleFnId: 'ref://3',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,", "      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://3',\n        },\n        {", "        },\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://4',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n\n  test('clone and define parser', ({ assert }) => {", "\n  test('clone and define parser', ({ assert }) => {\n    const schema = vine.array(\n      vine.object({\n        username: vine.string(),\n        password: vine.string(),\n      })\n    )\n\n    const schema1 = schema.clone().parse(() => {})", "\n    const schema1 = schema.clone().parse(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [],\n      parseFnId: 'ref://3',\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,", "        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',", "          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },", "        ],\n      },\n    })\n  })\n\n  test('apply nullable modifier and clone', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),", "        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })\n      )\n      .nullable()\n\n    const schema1 = schema.clone().optional()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: false,\n      validations: [],\n      parseFnId: undefined,", "      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,", "        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',", "            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,", "                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',", "            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,", "                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,", "      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,", "        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',", "            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,", "                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',", "            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,", "                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })", "    })\n  })\n\n  test('apply optional modifier and clone', ({ assert }) => {\n    const schema = vine\n      .array(\n        vine.object({\n          username: vine.string(),\n          password: vine.string(),\n        })", "          password: vine.string(),\n        })\n      )\n      .optional()\n\n    const schema1 = schema.clone().nullable()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: true,\n      isOptional: true,\n      validations: [],\n      parseFnId: undefined,\n      each: {\n        type: 'object',", "      each: {\n        type: 'object',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        allowUnknownProperties: false,\n        validations: [],\n        groups: [],", "        validations: [],\n        groups: [],\n        parseFnId: undefined,\n        properties: [\n          {\n            type: 'literal',\n            fieldName: 'username',\n            propertyName: 'username',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://1',\n              },", "                ruleFnId: 'ref://1',\n              },\n            ],\n          },\n          {\n            type: 'literal',\n            fieldName: 'password',\n            propertyName: 'password',\n            bail: true,\n            allowNull: false,", "            bail: true,\n            allowNull: false,\n            isOptional: false,\n            parseFnId: undefined,\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://2',\n              },", "                ruleFnId: 'ref://2',\n              },\n            ],\n          },\n        ],\n      },\n    })\n  })\n})\n", "})\n\ntest.group('VineArray | applying rules', () => {\n  test('apply minLength rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).minLength(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,", "            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },\n    })\n\n    const minLength = minLengthRule({ min: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {", "    const minLength = minLengthRule({ min: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })\n\n  test('apply maxLength rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).maxLength(2)", "    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).maxLength(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,", "      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,", "        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },", "        ],\n      },\n    })\n\n    const minLength = maxLengthRule({ max: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })", "    })\n  })\n\n  test('apply fixedLength rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).fixedLength(2)\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,", "            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },\n    })\n\n    const minLength = fixedLengthRule({ size: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {", "    const minLength = fixedLengthRule({ size: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })\n\n  test('apply notEmpty rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).notEmpty()", "    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).notEmpty()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,", "      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,", "        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },", "        ],\n      },\n    })\n\n    const minLength = notEmptyRule()\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })", "    })\n  })\n\n  test('apply distinct rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).distinct()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',", "      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,", "          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',", "        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,", "            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },\n    })\n\n    const minLength = distinctRule({ fields: undefined })\n    assert.deepEqual(refs.toJSON()['ref://2'], {", "    const minLength = distinctRule({ fields: undefined })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })\n\n  test('apply compact rule', ({ assert }) => {\n    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).compact()", "    const refs = refsBuilder()\n    const schema = vine.array(vine.string()).compact()\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,", "      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,", "      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,", "        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },", "        ],\n      },\n    })\n\n    const minLength = compactRule()\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })", "    })\n  })\n\n  test('register rule via rule builder', ({ assert }) => {\n    const refs = refsBuilder()\n\n    class LengthAwareValidator implements RuleBuilder {\n      [VALIDATION]() {\n        return minLengthRule({ min: 2 })\n      }\n    }\n\n    const schema = vine.array(vine.string()).use(new LengthAwareValidator())\n\n    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n      type: 'array',\n      fieldName: '*',\n      propertyName: '*',\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      validations: [\n        {\n          implicit: false,\n          isAsync: false,\n          ruleFnId: 'ref://2',\n        },\n      ],\n      parseFnId: undefined,\n      each: {\n        type: 'literal',\n        fieldName: '*',\n        propertyName: '*',\n        bail: true,\n        allowNull: false,\n        isOptional: false,\n        parseFnId: undefined,\n        validations: [\n          {\n            implicit: false,\n            isAsync: false,\n            ruleFnId: 'ref://1',\n          },\n        ],\n      },\n    })\n\n    const minLength = minLengthRule({ min: 2 })\n    assert.deepEqual(refs.toJSON()['ref://2'], {\n      validator: minLength.rule.validator,\n      options: minLength.options,\n    })\n  })\n})\n"]}
{"filename": "tests/unit/schema/union_of_types.spec.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { test } from '@japa/runner'", "\nimport { test } from '@japa/runner'\nimport { refsBuilder } from '@vinejs/compiler'\n\nimport { PARSE } from '../../../src/symbols.js'\nimport { Vine } from '../../../src/vine/main.js'\n\nconst vine = new Vine()\n\ntest.group('Vine UnionOfTypes', () => {", "\ntest.group('Vine UnionOfTypes', () => {\n  test('construct union schema', ({ assert }) => {\n    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'union',\n      fieldName: '*',\n      propertyName: '*',\n      conditions: [", "      propertyName: '*',\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,", "            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://3',\n              },", "                ruleFnId: 'ref://3',\n              },\n            ],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://4',\n          schema: {\n            allowNull: false,\n            bail: true,", "            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,", "              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://5',\n              },\n            ],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',", "      ],\n      elseConditionalFnRefId: 'ref://1',\n    })\n  })\n\n  test('clone schema', ({ assert }) => {\n    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n    const schema1 = schema.clone().otherwise(() => {})\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {", "\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'union',\n      fieldName: '*',\n      propertyName: '*',\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,", "          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://3',\n              },\n            ],\n          },\n        },\n        {", "        },\n        {\n          conditionalFnRefId: 'ref://4',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',", "            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://5',\n              },\n            ],", "              },\n            ],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'union',\n      fieldName: '*',", "      type: 'union',\n      fieldName: '*',\n      propertyName: '*',\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',", "            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,", "                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://3',\n              },\n            ],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://4',\n          schema: {", "          conditionalFnRefId: 'ref://4',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [", "            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://5',\n              },\n            ],\n          },\n        },", "          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n    })\n  })\n\n  test('apply camelcase transform to propertyName', ({ assert }) => {\n    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n", "    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n\n    assert.deepEqual(schema[PARSE]('health_check', refsBuilder(), { toCamelCase: true }), {\n      type: 'union',\n      fieldName: 'health_check',\n      propertyName: 'healthCheck',\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {", "          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: 'health_check',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: 'healthCheck',\n            type: 'literal',\n            validations: [", "            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://3',\n              },\n            ],\n          },\n        },", "          },\n        },\n        {\n          conditionalFnRefId: 'ref://4',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: 'health_check',\n            isOptional: false,\n            parseFnId: undefined,", "            isOptional: false,\n            parseFnId: undefined,\n            propertyName: 'healthCheck',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://5',\n              },", "                ruleFnId: 'ref://5',\n              },\n            ],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n    })\n  })\n", "  })\n\n  test('copy otherwise callback to the cloned schema', ({ assert }) => {\n    const schema = vine.unionOfTypes([vine.boolean(), vine.string()]).otherwise(() => {})\n    const schema1 = schema.clone()\n\n    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'union',\n      fieldName: '*',\n      propertyName: '*',", "      fieldName: '*',\n      propertyName: '*',\n      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,", "            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://3',", "                isAsync: false,\n                ruleFnId: 'ref://3',\n              },\n            ],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://4',\n          schema: {\n            allowNull: false,", "          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {", "            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://5',\n              },\n            ],\n          },\n        },\n      ],", "        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n    })\n    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n      type: 'union',\n      fieldName: '*',\n      propertyName: '*',\n      conditions: [\n        {", "      conditions: [\n        {\n          conditionalFnRefId: 'ref://2',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',", "            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://3',\n              },\n            ],", "              },\n            ],\n          },\n        },\n        {\n          conditionalFnRefId: 'ref://4',\n          schema: {\n            allowNull: false,\n            bail: true,\n            fieldName: '*',", "            bail: true,\n            fieldName: '*',\n            isOptional: false,\n            parseFnId: undefined,\n            propertyName: '*',\n            type: 'literal',\n            validations: [\n              {\n                implicit: false,\n                isAsync: false,", "                implicit: false,\n                isAsync: false,\n                ruleFnId: 'ref://5',\n              },\n            ],\n          },\n        },\n      ],\n      elseConditionalFnRefId: 'ref://1',\n    })", "      elseConditionalFnRefId: 'ref://1',\n    })\n  })\n})\n"]}
{"filename": "benchmarks/nested_object.ts", "chunked_list": ["// @ts-ignore\nimport Benchmark from 'benchmark'\nimport { z } from 'zod'\nimport yup from 'yup'\nimport vine from '../index.js'\n\nfunction getData() {\n  return {\n    username: 'virk',\n    password: 'secret',\n    contact: {\n      name: 'virk',\n      address: 'universe',\n    },\n  }\n}\n\nconst zodSchema = z.object({\n  username: z.string(),\n  password: z.string(),\n  contact: z.object({\n    name: z.string(),\n    address: z.string().optional(),\n  }),\n})\n\nconst yupSchema = yup\n  .object({\n    username: yup.string().required(),\n    password: yup.string().required(),\n    contact: yup\n      .object({\n        name: yup.string().required(),\n        address: yup.string(),\n      })\n      .required(),\n  })\n  .required()\n\nconst vineSchema = vine.compile(\n  vine.object({\n    username: vine.string(),\n    password: vine.string(),\n    contact: vine.object({\n      name: vine.string(),\n      address: vine.string().optional(),\n    }),\n  })\n)\n\nconsole.log('=================================')\nconsole.log('Benchmarking with nested object')\nconsole.log('=================================')\n\nconst suite = new Benchmark.Suite()\nsuite\n  .add('Vine', {\n    defer: true,\n    fn: function (deferred: any) {\n      vineSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn: function (deferred: any) {\n      zodSchema\n        .parseAsync(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .add('Yup', {\n    defer: true,\n    fn: function (deferred: any) {\n      yupSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Yup', {\n    defer: true,\n    fn: function (deferred: any) {\n      yupSchema\n        .validate(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n", "        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n"]}
{"filename": "benchmarks/array.ts", "chunked_list": ["// @ts-ignore\nimport Benchmark from 'benchmark'\nimport { z } from 'zod'\nimport yup from 'yup'\nimport vine from '../index.js'\n\nfunction getData() {\n  return {\n    contacts: [\n      {\n        type: 'email',\n        value: 'foo@bar.com',\n      },\n      {\n        type: 'phone',\n        value: '12345678',\n      },\n    ],\n  }\n}\n\nconst zodSchema = z.object({\n  contacts: z.array(\n    z.object({\n      type: z.string(),\n      value: z.string(),\n    })\n  ),\n})\n\nconst yupSchema = yup\n  .object({\n    contacts: yup\n      .array(\n        yup\n          .object({\n            type: yup.string().required(),\n            value: yup.string().required(),\n          })\n          .required()\n      )\n      .required(),\n  })\n  .required()\n\nconst vineSchema = vine.compile(\n  vine.object({\n    contacts: vine.array(\n      vine.object({\n        type: vine.string(),\n        value: vine.string(),\n      })\n    ),\n  })\n)\n\nconsole.log('======================')\nconsole.log('Benchmarking arrays')\nconsole.log('======================')\n\nconst suite = new Benchmark.Suite()\nsuite\n  .add('Vine', {\n    defer: true,\n    fn: function (deferred: any) {\n      vineSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn: function (deferred: any) {\n      zodSchema\n        .parseAsync(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .add('Yup', {\n    defer: true,\n    fn: function (deferred: any) {\n      yupSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Yup', {\n    defer: true,\n    fn: function (deferred: any) {\n      yupSchema\n        .validate(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n", "        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n"]}
{"filename": "benchmarks/union.ts", "chunked_list": ["// @ts-ignore\nimport Benchmark from 'benchmark'\nimport { z } from 'zod'\nimport vine from '../index.js'\n\nfunction getData() {\n  return {\n    contact: {\n      type: 'phone',\n      mobile_number: '9210210102',\n    },\n  }\n}\n\nconst zodSchema = z.object({\n  contact: z.union([\n    z.object({\n      type: z.literal('email'),\n      email: z.string(),\n    }),\n    z.object({\n      type: z.literal('phone'),\n      mobile_number: z.string(),\n    }),\n  ]),\n})\n\nconst vineSchema = vine.compile(\n  vine.object({\n    contact: vine.union([", "      vine.union.if(\n        (value) => vine.helpers.isObject(value) && value.type === 'email',\n        vine.object({\n          type: vine.literal('email'),\n          email: vine.string(),\n        })\n      ),\n      vine.union.if(\n        (value) => vine.helpers.isObject(value) && value.type === 'phone',\n        vine.object({\n          type: vine.literal('phone'),\n          mobile_number: vine.string(),\n        })\n      ),\n    ]),\n  })\n)\n\nconsole.log('=======================')\nconsole.log('Benchmarking unions')\nconsole.log('=======================')\n\nconst suite = new Benchmark.Suite()\nsuite\n  .add('Vine', {\n    defer: true,\n    fn: function (deferred: any) {\n      vineSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn: function (deferred: any) {\n      zodSchema\n        .parseAsync(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n", "        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n"]}
{"filename": "benchmarks/flat_object.ts", "chunked_list": ["// @ts-ignore\nimport Benchmark from 'benchmark'\nimport { z } from 'zod'\nimport yup from 'yup'\nimport vine from '../index.js'\n\nfunction getData() {\n  return {\n    username: 'virk',\n    password: 'secret',\n  }\n}\n\nconst zodSchema = z.object({\n  username: z.string(),\n  password: z.string(),\n})\n\nconst yupSchema = yup\n  .object({\n    username: yup.string().required(),\n    password: yup.string().required(),\n  })\n  .required()\n\nconst vineSchema = vine.compile(\n  vine.object({\n    username: vine.string(),\n    password: vine.string(),\n  })\n)\n\nconsole.log('===============================')\nconsole.log('Benchmarking with flat object')\nconsole.log('===============================')\n\nconst suite = new Benchmark.Suite()\nsuite\n  .add('Vine', {\n    defer: true,\n    fn: function (deferred: any) {\n      vineSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Zod', {\n    defer: true,\n    fn: function (deferred: any) {\n      zodSchema\n        .parseAsync(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .add('Yup', {\n    defer: true,\n    fn: function (deferred: any) {\n      yupSchema\n        .validate(getData())\n        .then(() => deferred.resolve())", "        .catch(console.log)\n    },\n  })\n  .add('Yup', {\n    defer: true,\n    fn: function (deferred: any) {\n      yupSchema\n        .validate(getData())\n        .then(() => deferred.resolve())\n        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n", "        .catch(console.log)\n    },\n  })\n  .on('cycle', function (event: any) {\n    console.log(String(event.target))\n  })\n  .on('complete', function (this: any) {\n    console.log('Fastest is ' + this.filter('fastest').map('name'))\n  })\n  .run({ async: false })\n"]}
{"filename": "factories/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { FieldFactory } from './field.js'", "\nimport { FieldFactory } from './field.js'\nimport { ValidatorFactory } from './validator.js'\n\n/**\n * Validator factory is used for unit testing validation\n * rules.\n */\nexport const validator = new ValidatorFactory()\nexport const fieldContext = new FieldFactory()", "export const validator = new ValidatorFactory()\nexport const fieldContext = new FieldFactory()\n"]}
{"filename": "factories/field.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ErrorReporterContract } from '@vinejs/compiler/types'", "\nimport { ErrorReporterContract } from '@vinejs/compiler/types'\n\nimport { helpers } from '../src/vine/helpers.js'\nimport type { FieldContext, MessagesProviderContact } from '../src/types.js'\nimport { SimpleErrorReporter } from '../src/reporters/simple_error_reporter.js'\nimport { SimpleMessagesProvider } from '../src/messages_provider/simple_messages_provider.js'\n\n/**\n * Exposes API to create a dummy field context", "/**\n * Exposes API to create a dummy field context\n */\nexport class FieldFactory {\n  create(\n    fieldName: string,\n    value: any,\n    messagesProvider?: MessagesProviderContact,\n    errorReporter?: ErrorReporterContract\n  ) {\n    const reporter = errorReporter || new SimpleErrorReporter()\n    const provider = messagesProvider || new SimpleMessagesProvider({}, {})\n\n    return {\n      value: value,\n      isArrayMember: false,\n      parent: { [fieldName]: value } as any,\n      data: { [fieldName]: value },\n      name: fieldName as any,\n      wildCardPath: fieldName,\n      isDefined: helpers.exists(value),\n      isValid: true,\n      meta: {},\n      mutate(newValue) {\n        this.value = newValue\n        this.isDefined = helpers.exists(newValue)\n        return this\n      },\n      report(message, rule, context, args) {\n        this.isValid = false\n        reporter.report(provider.getMessage(message, rule, context, args), rule, context, args)\n      },\n    } satisfies FieldContext\n  }\n}\n"]}
{"filename": "factories/validator.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { AssertionError, deepEqual } from 'node:assert'", "\nimport { AssertionError, deepEqual } from 'node:assert'\n\nimport { FieldFactory } from './field.js'\nimport type { FieldContext, Validation } from '../src/types.js'\nimport { SimpleErrorReporter } from '../src/reporters/simple_error_reporter.js'\n\n/**\n * Exposes APIs for writing validation assertions\n */\nclass ValidationResult {\n  #outputValue: any\n  #reporter: SimpleErrorReporter\n\n  constructor(outputValue: any, reporter: SimpleErrorReporter) {\n    this.#outputValue = outputValue\n    this.#reporter = reporter\n  }\n\n  /**\n   * Creates an assertion error instance\n   */\n  #assertionError(\n    options: ConstructorParameters<typeof AssertionError>[0] & { showDiff?: boolean }\n  ) {\n    const assertion = new AssertionError(options)\n    Object.defineProperty(assertion, 'showDiff', { value: true })\n    return assertion\n  }\n\n  /**\n   * Returns the validation result output\n   */\n  getOutput() {\n    return this.#outputValue\n  }\n\n  /**\n   * Returns an array of errors reported to the\n   * error reporter\n   */\n  getErrors() {\n    return this.#reporter.errors\n  }\n\n  /**\n   * Assert one or more validation errors have occurred\n   */\n  assertSucceeded() {", " * Exposes APIs for writing validation assertions\n */\nclass ValidationResult {\n  #outputValue: any\n  #reporter: SimpleErrorReporter\n\n  constructor(outputValue: any, reporter: SimpleErrorReporter) {\n    this.#outputValue = outputValue\n    this.#reporter = reporter\n  }\n\n  /**\n   * Creates an assertion error instance\n   */\n  #assertionError(\n    options: ConstructorParameters<typeof AssertionError>[0] & { showDiff?: boolean }\n  ) {\n    const assertion = new AssertionError(options)\n    Object.defineProperty(assertion, 'showDiff', { value: true })\n    return assertion\n  }\n\n  /**\n   * Returns the validation result output\n   */\n  getOutput() {\n    return this.#outputValue\n  }\n\n  /**\n   * Returns an array of errors reported to the\n   * error reporter\n   */\n  getErrors() {\n    return this.#reporter.errors\n  }\n\n  /**\n   * Assert one or more validation errors have occurred\n   */\n  assertSucceeded() {", "    if (this.#reporter.hasErrors) {\n      const errorsCount = this.#reporter.errors.length\n      throw this.#assertionError({\n        message: `Expected validation to pass. Instead failed with \"${errorsCount} error(s)\"`,\n        operator: 'strictEqual',\n        stackStartFn: this.assertSucceeded,\n      })\n    }\n  }\n\n  /**\n   * Assert the output value of validation. The output value is\n   * same as the input value, unless \"mutate\" method is called\n   */\n  assertOutput(expectedOutput: any) {\n    deepEqual(this.#outputValue, expectedOutput)\n  }\n\n  /**\n   * Assert one or more validation errors have occurred\n   */\n  assertFailed() {", "    if (!this.#reporter.hasErrors) {\n      throw this.#assertionError({\n        message: `Expected validation to report one or more errors`,\n        operator: 'strictEqual',\n        stackStartFn: this.assertFailed,\n      })\n    }\n  }\n\n  /**\n   * Assert the number of errors have occurred\n   */\n  assertErrorsCount(count: number) {\n    const errorsCount = this.#reporter.errors.length\n", "    if (errorsCount !== count) {\n      throw this.#assertionError({\n        message: `Expected validation to report \"${count}\" errors. Received \"${errorsCount}\"`,\n        expected: count,\n        actual: errorsCount,\n        operator: 'strictEqual',\n        stackStartFn: this.assertErrorsCount,\n        showDiff: true,\n      })\n    }\n  }\n\n  /**\n   * Assert error messages to include a given error message\n   */\n  assertError(message: string) {\n    const messages = this.#reporter.errors.map((e) => e.message)\n", "    if (!messages.includes(message)) {\n      throw this.#assertionError({\n        message: `Expected validation errors to include \"${message}\" message`,\n        expected: [message],\n        actual: messages,\n        operator: 'includes',\n        stackStartFn: this.assertError,\n        showDiff: true,\n      })\n    }\n  }\n}\n\n/**\n * Validator factory exposes the API to execute validations\n * during tests\n */", "export class ValidatorFactory {\n  #field?: Partial<FieldContext>\n  #bail?: boolean\n\n  constructor(field?: Partial<FieldContext>, bail?: boolean) {\n    this.#field = field\n    this.#bail = bail\n  }\n\n  /**\n   * Creates an instance of the error reporter required\n   * to report errors.\n   */\n  #getReporter() {\n    return new SimpleErrorReporter()\n  }\n\n  /**\n   * Define field context for the validation\n   */\n  withContext(field: Partial<FieldContext>) {\n    return new ValidatorFactory(field, this.#bail)\n  }\n\n  /**\n   * Toggle bail mode for the validation\n   */\n  bail(state: boolean) {\n    return new ValidatorFactory(this.#field, state)\n  }\n\n  /**\n   * Executes a validation against the provided value\n   */\n  execute(validation: Validation<any> | Validation<any>[], value: any) {\n    const errorReporter = this.#getReporter()\n    const bail = this.#bail === false ? false : true\n    const field: FieldContext = {\n      ...new FieldFactory().create('dummy', value, undefined, errorReporter),\n      ...this.#field,\n    }\n\n    const validations = Array.isArray(validation) ? validation : [validation]", "    for (let one of validations) {\n      if (one.rule.isAsync) {\n        throw new Error(\n          `Cannot execute async rule \"${one.rule.validator.name}\". Use \"validator.executeAsync\" instead`\n        )\n      }\n\n      if ((field.isDefined || one.rule.implicit) && (field.isValid || !bail)) {\n        one.rule.validator(field.value, one.options, field)\n      }\n    }\n\n    return new ValidationResult(field.value, errorReporter)\n  }\n\n  /**\n   * Executes an async validation against the provided\n   * value\n   */\n  async executeAsync(validation: Validation<any> | Validation<any>[], value: any) {\n    const errorReporter = this.#getReporter()\n    const bail = this.#bail === false ? false : true\n    const field: FieldContext = {\n      ...new FieldFactory().create('dummy', value, undefined, errorReporter),\n      ...this.#field,\n    }\n\n    const validations = Array.isArray(validation) ? validation : [validation]", "    for (let one of validations) {\n      if ((field.isDefined || one.rule.implicit) && (field.isValid || !bail)) {\n        await one.rule.validator(field.value, one.options, field)\n      }\n    }\n\n    return new ValidationResult(field.value, errorReporter)\n  }\n}\n"]}
{"filename": "src/defaults.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Collection of default error messages to use\n */\nexport const messages = {\n  'required': 'The {{ field }} field must be defined',\n\n  'string': 'The {{ field }} field must be a string',\n  'email': 'The {{ field }} field must be a valid email address',\n  'mobile': 'The {{ field }} field must be a valid mobile phone number',", "  'email': 'The {{ field }} field must be a valid email address',\n  'mobile': 'The {{ field }} field must be a valid mobile phone number',\n  'creditCard': 'The {{ field }} field must be a valid {{ providersList }} card number',\n  'passport': 'The {{ field }} field must be a valid passport number',\n  'postalCode': 'The {{ field }} field must be a valid postal code',\n  'regex': 'The {{ field }} field format is invalid',\n  'ascii': 'The {{ field }} field must only contain ASCII characters',\n  'iban': 'The {{ field }} field must be a valid IBAN number',\n  'jwt': 'The {{ field }} field must be a valid JWT token',\n  'coordinates': 'The {{ field }} field must contain latitude and longitude coordinates',", "  'jwt': 'The {{ field }} field must be a valid JWT token',\n  'coordinates': 'The {{ field }} field must contain latitude and longitude coordinates',\n  'url': 'The {{ field }} field must be a valid URL',\n  'activeUrl': 'The {{ field }} field must be a valid URL',\n  'alpha': 'The {{ field }} field must contain only letters',\n  'alphaNumeric': 'The {{ field }} field must contain only letters and numbers',\n  'minLength': 'The {{ field }} field must have at least {{ min }} characters',\n  'maxLength': 'The {{ field }} field must not be greater than {{ max }} characters',\n  'fixedLength': 'The {{ field }} field must be {{ size }} characters long',\n  'confirmed': 'The {{ field }} field and {{ otherField }} field must be the same',", "  'fixedLength': 'The {{ field }} field must be {{ size }} characters long',\n  'confirmed': 'The {{ field }} field and {{ otherField }} field must be the same',\n  'endsWith': 'The {{ field }} field must end with {{ substring }}',\n  'startsWith': 'The {{ field }} field must start with {{ substring }}',\n  'sameAs': 'The {{ field }} field and {{ otherField }} field must be the same',\n  'notSameAs': 'The {{ field }} field and {{ otherField }} field must be different',\n  'in': 'The selected {{ field }} is invalid',\n  'notIn': 'The selected {{ field }} is invalid',\n  'ipAddress': 'The {{ field }} field must be a valid IP address',\n  'uuid': 'The {{ field }} field must be a valid UUID',", "  'ipAddress': 'The {{ field }} field must be a valid IP address',\n  'uuid': 'The {{ field }} field must be a valid UUID',\n  'hexCode': 'The {{ field }} field must be a valid hex color code',\n\n  'boolean': 'The value must be a boolean',\n\n  'number': 'The {{ field }} field must be a number',\n  'min': 'The {{ field }} field must be at least {{ min }}',\n  'max': 'The {{ field }} field must not be greater than {{ max }}',\n  'range': 'The {{ field }} field must be between {{ min }} and {{ max }}',", "  'max': 'The {{ field }} field must not be greater than {{ max }}',\n  'range': 'The {{ field }} field must be between {{ min }} and {{ max }}',\n  'positive': 'The {{ field }} field must be positive',\n  'negative': 'The {{ field }} field must be negative',\n  'decimal': 'The {{ field }} field must have {{ digits }} decimal places',\n  'withoutDecimals': 'The {{ field }} field must be an integer',\n\n  'accepted': 'The {{ field }} field must be accepted',\n\n  'enum': 'The selected {{ field }} is invalid',", "\n  'enum': 'The selected {{ field }} is invalid',\n\n  'literal': 'The {{ field }} field must be {{ expectedValue }}',\n\n  'object': 'The {{ field }} field must be an object',\n\n  'array': 'The {{ field }} field must be an array',\n  'array.minLength': 'The {{ field }} field must have at least {{ min }} items',\n  'array.maxLength': 'The {{ field }} field must not have more than {{ max }} items',", "  'array.minLength': 'The {{ field }} field must have at least {{ min }} items',\n  'array.maxLength': 'The {{ field }} field must not have more than {{ max }} items',\n  'array.fixedLength': 'The {{ field }} field must contain {{ size }} items',\n  'notEmpty': 'The {{ field }} field must not be empty',\n  'distinct': 'The {{ field }} field has duplicate values',\n\n  'record': 'The {{ field }} field must be an object',\n  'record.minLength': 'The {{ field }} field must have at least {{ min }} items',\n  'record.maxLength': 'The {{ field }} field must not have more than {{ max }} items',\n  'record.fixedLength': 'The {{ field }} field must contain {{ size }} items',", "  'record.maxLength': 'The {{ field }} field must not have more than {{ max }} items',\n  'record.fixedLength': 'The {{ field }} field must contain {{ size }} items',\n\n  'tuple': 'The {{ field }} field must be an array',\n  'union': 'Invalid value provided for {{ field }} field',\n  'unionGroup': 'Invalid value provided for {{ field }} field',\n  'unionOfTypes': 'Invalid value provided for {{ field }} field',\n}\n\n/**", "\n/**\n * Collection of default fields\n */\nexport const fields = {\n  '': 'data',\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type {", "\nimport type {\n  ParseFn,\n  RefsStore,\n  TransformFn,\n  FieldContext,\n  CompilerNodes,\n  MessagesProviderContact,\n  ErrorReporterContract as BaseReporter,\n} from '@vinejs/compiler/types'", "  ErrorReporterContract as BaseReporter,\n} from '@vinejs/compiler/types'\nimport type { Options as UrlOptions } from 'normalize-url'\nimport type { IsURLOptions } from 'validator/lib/isURL.js'\nimport type { IsEmailOptions } from 'validator/lib/isEmail.js'\nimport type { NormalizeEmailOptions } from 'validator/lib/normalizeEmail.js'\nimport type { IsMobilePhoneOptions, MobilePhoneLocale } from 'validator/lib/isMobilePhone.js'\nimport type { PostalCodeLocale } from 'validator/lib/isPostalCode.js'\n\nimport type { helpers } from './vine/helpers.js'", "\nimport type { helpers } from './vine/helpers.js'\nimport type { ValidationError } from './errors/validation_error.js'\nimport type { OTYPE, COTYPE, PARSE, VALIDATION, UNIQUE_NAME, IS_OF_TYPE } from './symbols.js'\n\n/**\n * Options accepted by the mobile number validation\n */\nexport type MobileOptions = { locale?: MobilePhoneLocale[] } & IsMobilePhoneOptions\n\n/**\n * Options accepted by the email address validation\n */", "export type MobileOptions = { locale?: MobilePhoneLocale[] } & IsMobilePhoneOptions\n\n/**\n * Options accepted by the email address validation\n */\nexport type EmailOptions = IsEmailOptions\n\n/**\n * Options accepted by the normalize email\n */\nexport { NormalizeEmailOptions }\n\n/**\n * Options accepted by the URL validation\n */", "export type URLOptions = IsURLOptions\n\n/**\n * Options accepted by the credit card validation\n */\nexport type CreditCardOptions = {\n  provider: ('amex' | 'dinersclub' | 'discover' | 'jcb' | 'mastercard' | 'unionpay' | 'visa')[]\n}\n\n/**\n * Options accepted by the passport validation\n */", "export type PassportOptions = {\n  countryCode: (typeof helpers)['passportCountryCodes'][number][]\n}\n\n/**\n * Options accepted by the postal code validation\n */\nexport type PostalCodeOptions = {\n  countryCode: PostalCodeLocale[]\n}\n\n/**\n * Options accepted by the alpha rule\n */", "export type AlphaOptions = {\n  allowSpaces?: boolean\n  allowUnderscores?: boolean\n  allowDashes?: boolean\n}\n\nexport type NormalizeUrlOptions = UrlOptions\n\n/**\n * Options accepted by the alpha numeric rule\n */", "export type AlphaNumericOptions = AlphaOptions\n\n/**\n * Re-exporting selected types from compiler\n */\nexport type {\n  Refs,\n  FieldContext,\n  RefIdentifier,\n  ConditionalFn,\n  MessagesProviderContact,\n} from '@vinejs/compiler/types'\n\n/**", " * Representation of a native enum like type\n */\nexport type EnumLike = { [K: string]: string | number; [number: number]: string }\n\n/**\n * Representation of fields and messages accepted by the messages\n * provider\n */\nexport type ValidationMessages = Record<string, string>\nexport type ValidationFields = Record<string, string>\n\n/**", "export type ValidationMessages = Record<string, string>\nexport type ValidationFields = Record<string, string>\n\n/**\n * Constructable schema type refers to any type that can be\n * constructed for type inference and compiler output\n */\nexport interface ConstructableSchema<Output, CamelCaseOutput> {\n  [OTYPE]: Output\n  [COTYPE]: CamelCaseOutput\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes\n  clone(): this\n\n  /**", "   * Implement if you want schema type to be used with the unionOfTypes\n   */\n  [UNIQUE_NAME]?: string\n  [IS_OF_TYPE]?: (value: unknown, field: FieldContext) => boolean\n}\nexport type SchemaTypes = ConstructableSchema<any, any>\n\n/**\n * Representation of a function that performs validation.\n * The function receives the following arguments.\n *\n * - the current value of the input field\n * - runtime options\n * - field context\n */", " * Representation of a function that performs validation.\n * The function receives the following arguments.\n *\n * - the current value of the input field\n * - runtime options\n * - field context\n */\nexport type Validator<Options extends any> = (\n  value: unknown,\n  options: Options,\n  field: FieldContext\n) => any | Promise<any>\n\n/**\n * A validation rule is a combination of a validator and\n * some metadata required at the time of compiling the\n * rule.\n *", " * Think of this type as \"Validator\" + \"metaData\"\n */\nexport type ValidationRule<Options extends any> = {\n  validator: Validator<Options>\n  isAsync: boolean\n  implicit: boolean\n}\n\n/**\n * Validation is a combination of a validation rule and the options\n * to supply to validator at the time of validating the field.\n *", " * Think of this type as \"ValidationRule\" + \"options\"\n */\nexport type Validation<Options extends any> = {\n  /**\n   * Options to pass to the validator function.\n   */\n  options?: Options\n\n  /**\n   * The rule to use\n   */\n  rule: ValidationRule<Options>\n}\n\n/**\n * A rule builder is an object that implements the \"VALIDATION\"\n * method and returns [[Validation]] type\n */", "export interface RuleBuilder {\n  [VALIDATION](): Validation<any>\n}\n\n/**\n * The transform function to mutate the output value\n */\nexport type Transformer<Schema extends SchemaTypes, Output> = TransformFn<\n  Exclude<Schema[typeof OTYPE], undefined>,\n  Output\n>\n\n/**", " * The parser function to mutate the input value\n */\nexport type Parser = ParseFn\n\n/**\n * A set of options accepted by the field\n */\nexport type FieldOptions = {\n  allowNull: boolean\n  bail: boolean\n  isOptional: boolean\n  parse?: Parser\n}\n\n/**\n * Options accepted when compiling schema types.\n */", "export type ParserOptions = {\n  toCamelCase: boolean\n}\n\n/**\n * Method to invoke when union has no match\n */\nexport type UnionNoMatchCallback<Input> = (value: Input, field: FieldContext) => any\n\n/**\n * Error reporters must implement the reporter contract interface\n */", "export interface ErrorReporterContract extends BaseReporter {\n  createError(): ValidationError\n}\n\n/**\n * The validator function to validate metadata given to a validation\n * pipeline\n */\nexport type MetaDataValidator = (meta: Record<string, any>) => void\n\n/**\n * Options accepted during the validate call.\n */", "export type MetaDataValidator = (meta: Record<string, any>) => void\n\n/**\n * Options accepted during the validate call.\n */\nexport type ValidationOptions<MetaData extends Record<string, any> | undefined> = {\n  /**\n   * Messages provider is used to resolve error messages during\n   * the validation lifecycle\n   */\n  messagesProvider?: MessagesProviderContact\n\n  /**\n   * Validation errors are reported directly to an error reporter. The reporter\n   * can decide how to format and output errors.\n   */\n  errorReporter?: () => ErrorReporterContract\n} & ([undefined] extends MetaData\n  ? {\n      meta?: MetaData\n    }\n  : {\n      meta: MetaData\n    })\n\n/**\n * Infers the schema type\n */", "export type Infer<Schema extends { [OTYPE]: any }> = Schema[typeof OTYPE]\n"]}
{"filename": "src/symbols.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * The symbol to define a unique name for the schema type\n */\nexport const UNIQUE_NAME = Symbol.for('schema_nme')\n\n/**\n * The symbol to check if a value is of the given schema\n * type\n */\nexport const IS_OF_TYPE = Symbol.for('is_of_type')\n\n/**\n * The symbol for the compile method\n */", "export const IS_OF_TYPE = Symbol.for('is_of_type')\n\n/**\n * The symbol for the compile method\n */\nexport const PARSE = Symbol.for('parse')\n\n/**\n * The symbol for the opaque type\n */\nexport const OTYPE = Symbol.for('opaque_type')\n\n/**\n * The symbol for the camelcase opaque type\n */", "export const OTYPE = Symbol.for('opaque_type')\n\n/**\n * The symbol for the camelcase opaque type\n */\nexport const COTYPE = Symbol.for('camelcase_opaque_type')\n\n/**\n * The symbol to generate a validation rule from rule builder\n */\nexport const VALIDATION = Symbol.for('to_validation')\n", "export const VALIDATION = Symbol.for('to_validation')\n"]}
{"filename": "src/messages_provider/simple_messages_provider.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type {", "\nimport type {\n  FieldContext,\n  ValidationFields,\n  ValidationMessages,\n  MessagesProviderContact,\n} from '../types.js'\n\n/**\n * Default messages provider performs messages lookup inside", "/**\n * Default messages provider performs messages lookup inside\n * a collection of key-value pair.\n */\nexport class SimpleMessagesProvider implements MessagesProviderContact {\n  #messages: ValidationMessages\n  #fields: ValidationFields\n\n  constructor(messages: ValidationMessages, fields: ValidationFields) {\n    this.#messages = messages\n    this.#fields = fields\n  }\n\n  /**\n   * Interpolates place holders within error messages\n   */\n  #interpolate(message: string, data: any): string {", "    if (!message.includes('{{')) {\n      return message\n    }\n\n    return message.replace(/(\\\\)?{{(.*?)}}/g, (_, __, key) => {\n      const tokens = key.trim().split('.')\n      let output = data\n\n      while (tokens.length) {\n        if (output === null || typeof output !== 'object') {\n          return\n        }\n        const token = tokens.shift()\n        output = Object.hasOwn(output, token) ? output[token] : undefined\n      }\n\n      return output\n    })\n  }\n\n  /**\n   * Returns a validation message for a given field + rule.\n   */\n  getMessage(rawMessage: string, rule: string, field: FieldContext, args?: Record<string, any>) {\n    const fieldName = this.#fields[field.name] || field.name\n\n    /**\n     * 1st priority is given to the field messages\n     */\n    const fieldMessage = this.#messages[`${field.wildCardPath}.${rule}`]", "      while (tokens.length) {\n        if (output === null || typeof output !== 'object') {\n          return\n        }\n        const token = tokens.shift()\n        output = Object.hasOwn(output, token) ? output[token] : undefined\n      }\n\n      return output\n    })\n  }\n\n  /**\n   * Returns a validation message for a given field + rule.\n   */\n  getMessage(rawMessage: string, rule: string, field: FieldContext, args?: Record<string, any>) {\n    const fieldName = this.#fields[field.name] || field.name\n\n    /**\n     * 1st priority is given to the field messages\n     */\n    const fieldMessage = this.#messages[`${field.wildCardPath}.${rule}`]", "    if (fieldMessage) {\n      return this.#interpolate(fieldMessage, {\n        field: fieldName,\n        ...args,\n      })\n    }\n\n    /**\n     * 2nd priority is for rule messages\n     */\n    const ruleMessage = this.#messages[rule]", "    if (ruleMessage) {\n      return this.#interpolate(ruleMessage, {\n        field: fieldName,\n        ...args,\n      })\n    }\n\n    /**\n     * Fallback to raw message\n     */\n    return this.#interpolate(rawMessage, {\n      field: fieldName,\n      ...args,\n    })\n  }\n}\n"]}
{"filename": "src/vine/create_rule.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Validation, ValidationRule, Validator } from '../types.js'", "\nimport type { Validation, ValidationRule, Validator } from '../types.js'\n\n/**\n * Returns args for the validation function.\n */\ntype GetArgs<T> = undefined extends T ? [options?: T] : [options: T]\n\n/**\n * Convert a validator function to a rule that you can apply\n * to any schema type using the `schema.use` method.\n */", " * Convert a validator function to a rule that you can apply\n * to any schema type using the `schema.use` method.\n */\nexport function createRule<Options = undefined>(\n  validator: Validator<Options>,\n  metaData?: {\n    implicit?: boolean\n    isAsync?: boolean\n  }\n) {\n  const rule: ValidationRule<Options> = {\n    validator,\n    isAsync: metaData?.isAsync || validator.constructor.name === 'AsyncFunction',\n    implicit: metaData?.implicit ?? false,\n  }\n\n  return function (...options: GetArgs<Options>): Validation<Options> {\n    return {\n      rule,\n      options: options[0],\n    }\n  }\n}\n"]}
{"filename": "src/vine/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { helpers } from './helpers.js'", "\nimport { helpers } from './helpers.js'\nimport { createRule } from './create_rule.js'\nimport { SchemaBuilder } from '../schema/builder.js'\nimport { SimpleMessagesProvider } from '../messages_provider/simple_messages_provider.js'\n\nimport { VineValidator } from './validator.js'\nimport { fields, messages } from '../defaults.js'\nimport type {\n  Infer,", "import type {\n  Infer,\n  SchemaTypes,\n  MetaDataValidator,\n  ValidationOptions,\n  ErrorReporterContract,\n  MessagesProviderContact,\n} from '../types.js'\nimport { SimpleErrorReporter } from '../reporters/simple_error_reporter.js'\n", "import { SimpleErrorReporter } from '../reporters/simple_error_reporter.js'\n\n/**\n * Validate user input with type-safety using a pre-compiled schema.\n */\nexport class Vine extends SchemaBuilder {\n  /**\n   * Messages provider to use on the validator\n   */\n  messagesProvider: MessagesProviderContact = new SimpleMessagesProvider(messages, fields)\n\n  /**\n   * Error reporter to use on the validator\n   */\n  errorReporter: () => ErrorReporterContract = () => new SimpleErrorReporter()\n\n  /**\n   * Control whether or not to convert empty strings to null\n   */\n  convertEmptyStringsToNull: boolean = false\n\n  /**\n   * Helpers to perform type-checking or cast types keeping\n   * HTML forms serialization behavior in mind.\n   */\n  helpers = helpers\n\n  /**", "   * Convert a validation function to a Vine schema rule\n   */\n  createRule = createRule\n\n  /**\n   * Pre-compiles a schema into a validation function.\n   *\n   * ```ts\n   * const validate = vine.compile(schema)\n   * await validate({ data })\n   * ```\n   */\n  compile<Schema extends SchemaTypes>(schema: Schema) {\n    return new VineValidator<Schema, Record<string, any> | undefined>(schema, {\n      convertEmptyStringsToNull: this.convertEmptyStringsToNull,\n      messagesProvider: this.messagesProvider,\n      errorReporter: this.errorReporter,\n    })\n  }\n\n  /**\n   * Define a callback to validate the metadata given to the validator\n   * at runtime\n   */\n  withMetaData<MetaData extends Record<string, any>>(callback?: MetaDataValidator) {\n    return {\n      compile: <Schema extends SchemaTypes>(schema: Schema) => {\n        return new VineValidator<Schema, MetaData>(schema, {\n          convertEmptyStringsToNull: this.convertEmptyStringsToNull,\n          messagesProvider: this.messagesProvider,\n          errorReporter: this.errorReporter,\n          metaDataValidator: callback,\n        })\n      },\n    }\n  }\n\n  /**\n   * Validate data against a schema. Optionally, you can define\n   * error messages, fields, a custom messages provider,\n   * or an error reporter.\n   *\n   * ```ts\n   * await vine.validate({ schema, data })\n   * await vine.validate({ schema, data, messages, fields })\n   *\n   * await vine.validate({ schema, data, messages, fields }, {\n   *   errorReporter\n   * })\n   * ```\n   */\n  validate<Schema extends SchemaTypes>(\n    options: {\n      /**\n       * Schema to use for validation\n       */\n      schema: Schema\n\n      /**\n       * Data to validate\n       */\n      data: any\n    } & ValidationOptions<Record<string, any> | undefined>\n  ): Promise<Infer<Schema>> {\n    const validator = this.compile(options.schema)\n    return validator.validate(options.data, options)\n  }\n}\n"]}
{"filename": "src/vine/helpers.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport isEmail from 'validator/lib/isEmail.js'", "\nimport isEmail from 'validator/lib/isEmail.js'\nimport isURL from 'validator/lib/isURL.js'\nimport isAlpha from 'validator/lib/isAlpha.js'\nimport isAlphanumeric from 'validator/lib/isAlphanumeric.js'\nimport isIP from 'validator/lib/isIP.js'\nimport isUUID from 'validator/lib/isUUID.js'\nimport isAscii from 'validator/lib/isAscii.js'\nimport isCreditCard from 'validator/lib/isCreditCard.js'\nimport isIBAN from 'validator/lib/isIBAN.js'", "import isCreditCard from 'validator/lib/isCreditCard.js'\nimport isIBAN from 'validator/lib/isIBAN.js'\nimport isJWT from 'validator/lib/isJWT.js'\nimport isLatLong from 'validator/lib/isLatLong.js'\nimport isPassportNumber from 'validator/lib/isPassportNumber.js'\nimport isSlug from 'validator/lib/isSlug.js'\nimport isDecimal from 'validator/lib/isDecimal.js'\nimport isHexColor from 'validator/lib/isHexColor.js'\nimport isMobilePhone, { type MobilePhoneLocale } from 'validator/lib/isMobilePhone.js'\nimport isPostalCode, { type PostalCodeLocale } from 'validator/lib/isPostalCode.js'\n// @ts-ignore type missing from @types/validator\nimport { locales as mobilePhoneLocales } from 'validator/lib/isMobilePhone.js'", "import isMobilePhone, { type MobilePhoneLocale } from 'validator/lib/isMobilePhone.js'\nimport isPostalCode, { type PostalCodeLocale } from 'validator/lib/isPostalCode.js'\n// @ts-ignore type missing from @types/validator\nimport { locales as mobilePhoneLocales } from 'validator/lib/isMobilePhone.js'\n// @ts-ignore type missing from @types/validator\nimport { locales as postalCodeLocales } from 'validator/lib/isPostalCode.js'\n\nimport { resolve4, resolve6 } from 'node:dns/promises'\n\nconst BOOLEAN_POSITIVES = ['1', 1, 'true', true, 'on']\nconst BOOLEAN_NEGATIVES = ['0', 0, 'false', false]\n\n/**\n * Collection of helpers used across the codebase to coerce\n * and type-check values from HTML forms.\n */\nexport const helpers = {\n  /**\n   * Returns true when value is not null and neither\n   * undefined\n   */\n  exists(value: any): boolean {\n    return value !== null && value !== undefined\n  },\n\n  /**\n   * Returns true when value is null or value is undefined\n   */\n  isMissing(value: any): boolean {\n    return !this.exists(value)\n  },\n\n  /**\n   * Returns true when the value is one of the following.\n   *\n   * true\n   * 1\n   * \"1\"\n   * \"true\"\n   * \"on\"\n   */\n  isTrue(value: any): boolean {\n    return BOOLEAN_POSITIVES.includes(value)\n  },\n\n  /**\n   * Returns true when the value is one of the following.\n   *\n   * false\n   * 0\n   * \"0\"\n   * \"false\"\n   */\n  isFalse(value: any) {\n    return BOOLEAN_NEGATIVES.includes(value)\n  },\n\n  /**\n   * Check if the value is a valid string. This method narrows", "   * the type of value to string.\n   */\n  isString(value: unknown): value is string {\n    return typeof value === 'string'\n  },\n\n  /**\n   * Check if the value is a plain JavaScript object. This method\n   * filters out null and Arrays and does not consider them as Objects.\n   */\n  isObject<Value>(value: unknown): value is Record<PropertyKey, Value> {\n    return !!(value && typeof value === 'object' && !Array.isArray(value))\n  },\n\n  /**\n   * Check if an object has all the mentioned keys\n   */\n  hasKeys(value: Record<string, any>, keys: string[]) {", "    for (let key of keys) {\n      if (key in value === false) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Check if the value is an Array.\n   */\n  isArray<Value>(value: unknown): value is Value[] {\n    return Array.isArray(value)\n  },\n\n  /**\n   * Check if the value is a number or a string representation of a number.\n   */\n  isNumeric(value: any): boolean {\n    return !Number.isNaN(Number(value))\n  },\n\n  /**\n   * Casts the value to a number using the Number method.\n   * Returns NaN when unable to cast.\n   */\n  asNumber(value: any): number {\n    return value === null ? Number.NaN : Number(value)\n  },\n\n  /**\n   * Casts the value to a boolean.\n   *\n   * - [true, 1, \"1\", \"true\", \"on\"] will be converted to true.\n   * - [false, 0, \"0\", \"false\"] will be converted to false.\n   * - Everything else will return null. So make sure to handle that case.\n   */\n  asBoolean(value: any): boolean | null {", "    if (this.isTrue(value)) {\n      return true\n    }\n\n    if (this.isFalse(value)) {\n      return false\n    }\n\n    return null\n  },\n\n  isEmail: isEmail.default,\n  isURL: isURL.default,\n  isAlpha: isAlpha.default,\n  isAlphaNumeric: isAlphanumeric.default,\n  isIP: isIP.default,\n  isUUID: isUUID.default,\n  isAscii: isAscii.default,\n  isCreditCard: isCreditCard.default,\n  isIBAN: isIBAN.default,\n  isJWT: isJWT.default,\n  isLatLong: isLatLong.default,\n  isMobilePhone: isMobilePhone.default,\n  isPassportNumber: isPassportNumber.default,\n  isPostalCode: isPostalCode.default,\n  isSlug: isSlug.default,\n  isDecimal: isDecimal.default,\n  mobileLocales: mobilePhoneLocales as MobilePhoneLocale[],\n  postalCountryCodes: postalCodeLocales as PostalCodeLocale[],\n  passportCountryCodes: [\n    'AM',\n    'AR',\n    'AT',\n    'AU',\n    'AZ',\n    'BE',\n    'BG',\n    'BR',\n    'BY',\n    'CA',\n    'CH',\n    'CY',\n    'CZ',\n    'DE',\n    'DK',\n    'DZ',\n    'ES',\n    'FI',\n    'FR',\n    'GB',\n    'GR',\n    'HR',\n    'HU',\n    'IE',\n    'IN',\n    'ID',\n    'IR',\n    'IS',\n    'IT',\n    'JM',\n    'JP',\n    'KR',\n    'KZ',\n    'LI',\n    'LT',\n    'LU',\n    'LV',\n    'LY',\n    'MT',\n    'MZ',\n    'MY',\n    'MX',\n    'NL',\n    'NZ',\n    'PH',\n    'PK',\n    'PL',\n    'PT',\n    'RO',\n    'RU',\n    'SE',\n    'SL',\n    'SK',\n    'TH',\n    'TR',\n    'UA',\n    'US',\n  ] as const,\n\n  /**\n   * Check if the value is a valid color hexcode\n   */\n  isHexColor: (value: string) => {", "    if (!value.startsWith('#')) {\n      return false\n    }\n    return isHexColor.default(value)\n  },\n\n  /**\n   * Check if a URL has valid `A` or `AAAA` DNS records\n   */\n  isActiveURL: async (url: string): Promise<boolean> => {\n    try {\n      const { hostname } = new URL(url)\n      const v6Addresses = await resolve6(hostname)", "    try {\n      const { hostname } = new URL(url)\n      const v6Addresses = await resolve6(hostname)\n      if (v6Addresses.length) {\n        return true\n        /* c8 ignore next 4 */\n      } else {\n        const v4Addresses = await resolve4(hostname)\n        return v4Addresses.length > 0\n      }\n    } catch {\n      return false\n    }\n  },\n\n  /**\n   * Check if all the elements inside the dataset are unique.\n   *\n   * In case of an array of objects, you must provide one or more keys\n   * for the fields that must be unique across the objects.\n   *\n   * ```ts\n   * helpers.isDistinct([1, 2, 4, 5]) // true\n   *\n   * // Null and undefined values are ignored\n   * helpers.isDistinct([1, null, 2, null, 4, 5]) // true\n   *\n   * helpers.isDistinct([\n   *   {\n   *     email: 'foo@bar.com',\n   *     name: 'foo'\n   *   },\n   *   {\n   *     email: 'baz@bar.com',\n   *     name: 'baz'\n   *   }\n   * ], 'email') // true\n   *\n   * helpers.isDistinct([\n   *   {\n   *     email: 'foo@bar.com',\n   *     tenant_id: 1,\n   *     name: 'foo'\n   *   },\n   *   {\n   *     email: 'foo@bar.com',\n   *     tenant_id: 2,\n   *     name: 'baz'\n   *   }\n   * ], ['email', 'tenant_id']) // true\n   * ```\n   */\n  isDistinct: (dataSet: any[], fields?: string | string[]): boolean => {\n    const uniqueItems: Set<any> = new Set()\n\n    /**\n     * Check for duplicates when no fields are provided\n     */", "    if (!fields) {\n      for (let item of dataSet) {\n        if (helpers.exists(item)) {\n          if (uniqueItems.has(item)) {\n            return false\n          } else {\n            uniqueItems.add(item)\n          }\n        }\n      }\n      return true\n    }\n\n    /**\n     * Checking for duplicates when one or more fields are mentioned\n     */\n    const fieldsList = Array.isArray(fields) ? fields : [fields]", "    for (let item of dataSet) {\n      /**\n       * Only process item, if it is an object and has all the fields\n       * required for uniqueness check\n       */\n      if (helpers.isObject(item) && helpers.hasKeys(item, fieldsList)) {\n        const element = fieldsList.map((field) => item[field]).join('_')\n        if (uniqueItems.has(element)) {\n          return false\n        } else {\n          uniqueItems.add(element)\n        }\n      }\n    }\n\n    return true\n  },\n}\n"]}
{"filename": "src/vine/validator.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Compiler, refsBuilder } from '@vinejs/compiler'", "\nimport { Compiler, refsBuilder } from '@vinejs/compiler'\nimport type { MessagesProviderContact, Refs } from '@vinejs/compiler/types'\n\nimport { messages } from '../defaults.js'\nimport { OTYPE, PARSE } from '../symbols.js'\nimport type {\n  Infer,\n  SchemaTypes,\n  MetaDataValidator,", "  SchemaTypes,\n  MetaDataValidator,\n  ValidationOptions,\n  ErrorReporterContract,\n} from '../types.js'\n\n/**\n * Error messages to share with the compiler\n */\nconst COMPILER_ERROR_MESSAGES = {", " */\nconst COMPILER_ERROR_MESSAGES = {\n  required: messages.required,\n  array: messages.array,\n  object: messages.object,\n}\n\n/**\n * Vine Validator exposes the API to validate data using a pre-compiled\n * schema.", " * Vine Validator exposes the API to validate data using a pre-compiled\n * schema.\n */\nexport class VineValidator<\n  Schema extends SchemaTypes,\n  MetaData extends undefined | Record<string, any>,\n> {\n  /**\n   * Reference to static types\n   */\n  declare [OTYPE]: Schema[typeof OTYPE]\n\n  /**\n   * Validator to use to validate metadata\n   */\n  #metaDataValidator?: MetaDataValidator\n\n  /**\n   * Messages provider to use on the validator\n   */\n  messagesProvider: MessagesProviderContact\n\n  /**\n   * Error reporter to use on the validator\n   */\n  errorReporter: () => ErrorReporterContract\n\n  /**\n   * Parses schema to compiler nodes.\n   */\n  #parse(schema: Schema) {\n    const refs = refsBuilder()\n    return {\n      compilerNode: {\n        type: 'root' as const,\n        schema: schema[PARSE]('', refs, { toCamelCase: false }),\n      },\n      refs: refs.toJSON(),\n    }\n  }\n\n  /**\n   * Refs computed from the compiled output\n   */\n  #refs: Refs\n\n  /**\n   * Compiled validator function\n   */\n  #validateFn: ReturnType<Compiler['compile']>\n\n  constructor(\n    schema: Schema,\n    options: {\n      convertEmptyStringsToNull: boolean\n      metaDataValidator?: MetaDataValidator\n      messagesProvider: MessagesProviderContact\n      errorReporter: () => ErrorReporterContract\n    }\n  ) {\n    const { compilerNode, refs } = this.#parse(schema)\n\n    this.#refs = refs\n    this.#validateFn = new Compiler(compilerNode, {\n      convertEmptyStringsToNull: options.convertEmptyStringsToNull,\n      messages: COMPILER_ERROR_MESSAGES,\n    }).compile()\n\n    this.errorReporter = options.errorReporter\n    this.messagesProvider = options.messagesProvider\n    this.#metaDataValidator = options.metaDataValidator\n  }\n\n  /**\n   * Validate data against a schema. Optionally, you can share metaData with\n   * the validator\n   *\n   * ```ts\n   * await validator.validate(data)\n   * await validator.validate(data, { meta: {} })\n   *\n   * await validator.validate(data, {\n   *   meta: { userId: auth.user.id },\n   *   errorReporter,\n   *   messagesProvider\n   * })\n   * ```\n   */\n  validate(\n    data: any,\n    ...[options]: [undefined] extends MetaData\n      ? [options?: ValidationOptions<MetaData> | undefined]\n      : [options: ValidationOptions<MetaData>]\n  ): Promise<Infer<Schema>> {", "    if (options?.meta && this.#metaDataValidator) {\n      this.#metaDataValidator(options.meta)\n    }\n\n    const errorReporter = options?.errorReporter || this.errorReporter\n    const messagesProvider = options?.messagesProvider || this.messagesProvider\n    return this.#validateFn(\n      data,\n      options?.meta || {},\n      this.#refs,\n      messagesProvider,\n      errorReporter()\n    )\n  }\n}\n"]}
{"filename": "src/reporters/simple_error_reporter.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { E_VALIDATION_ERROR } from '../errors/main.js'", "\nimport { E_VALIDATION_ERROR } from '../errors/main.js'\nimport { ValidationError } from '../errors/validation_error.js'\nimport type { ErrorReporterContract, FieldContext } from '../types.js'\n\n/**\n * Shape of the error message collected by the SimpleErrorReporter\n */\ntype SimpleError = {\n  message: string\n  field: string\n  rule: string\n  index?: number\n  meta?: Record<string, any>\n}\n\n/**\n * Simple error reporter collects error messages as an array of object.\n * Each object has following properties.\n *\n * - message: string\n * - field: string\n * - rule: string\n * - index?: number (in case of an array member)\n * - args?: Record<string, any>\n */", "type SimpleError = {\n  message: string\n  field: string\n  rule: string\n  index?: number\n  meta?: Record<string, any>\n}\n\n/**\n * Simple error reporter collects error messages as an array of object.\n * Each object has following properties.\n *\n * - message: string\n * - field: string\n * - rule: string\n * - index?: number (in case of an array member)\n * - args?: Record<string, any>\n */", "export class SimpleErrorReporter implements ErrorReporterContract {\n  /**\n   * Boolean to know one or more errors have been reported\n   */\n  hasErrors: boolean = false\n\n  /**\n   * Collection of errors\n   */\n  errors: SimpleError[] = []\n\n  /**\n   * Report an error.\n   */\n  report(\n    message: string,\n    rule: string,\n    field: FieldContext,\n    meta?: Record<string, any> | undefined\n  ) {\n    const error: SimpleError = {\n      message,\n      rule,\n      field: field.wildCardPath,\n    }\n", "    if (meta) {\n      error.meta = meta\n    }\n    if (field.isArrayMember) {\n      error.index = field.name as number\n    }\n\n    this.hasErrors = true\n    this.errors.push(error)\n  }\n\n  /**\n   * Returns an instance of the validation error\n   */\n  createError(): ValidationError {\n    return new E_VALIDATION_ERROR(this.errors)\n  }\n}\n"]}
{"filename": "src/schema/builder.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport Macroable from '@poppinss/macroable'", "\nimport Macroable from '@poppinss/macroable'\n\nimport { VineAny } from './any/main.js'\nimport { VineEnum } from './enum/main.js'\nimport { union } from './union/builder.js'\nimport { VineTuple } from './tuple/main.js'\nimport { VineArray } from './array/main.js'\nimport { VineObject } from './object/main.js'\nimport { VineRecord } from './record/main.js'", "import { VineObject } from './object/main.js'\nimport { VineRecord } from './record/main.js'\nimport { VineString } from './string/main.js'\nimport { VineNumber } from './number/main.js'\nimport { VineBoolean } from './boolean/main.js'\nimport { VineLiteral } from './literal/main.js'\nimport { CamelCase } from './camelcase_types.js'\nimport { VineAccepted } from './accepted/main.js'\nimport { group } from './object/group_builder.js'\nimport { VineNativeEnum } from './enum/native_enum.js'", "import { group } from './object/group_builder.js'\nimport { VineNativeEnum } from './enum/native_enum.js'\nimport { VineUnionOfTypes } from './union_of_types/main.js'\nimport { OTYPE, COTYPE, IS_OF_TYPE, UNIQUE_NAME } from '../symbols.js'\nimport type { EnumLike, FieldContext, SchemaTypes } from '../types.js'\n\n/**\n * Schema builder exposes methods to construct a Vine schema. You may\n * add custom methods to it using macros.\n */\nexport class SchemaBuilder extends Macroable {\n  /**\n   * Define a sub-object as a union\n   */\n  group = group\n\n  /**\n   * Define a union value\n   */\n  union = union\n\n  /**\n   * Define a string value\n   */\n  string() {\n    return new VineString()\n  }\n\n  /**\n   * Define a boolean value\n   */\n  boolean(options?: { strict: boolean }) {\n    return new VineBoolean(options)\n  }\n\n  /**\n   * Validate a checkbox to be checked\n   */\n  accepted() {\n    return new VineAccepted()\n  }\n\n  /**\n   * Define a number value\n   */\n  number(options?: { strict: boolean }) {\n    return new VineNumber(options)\n  }\n\n  /**", " * add custom methods to it using macros.\n */\nexport class SchemaBuilder extends Macroable {\n  /**\n   * Define a sub-object as a union\n   */\n  group = group\n\n  /**\n   * Define a union value\n   */\n  union = union\n\n  /**\n   * Define a string value\n   */\n  string() {\n    return new VineString()\n  }\n\n  /**\n   * Define a boolean value\n   */\n  boolean(options?: { strict: boolean }) {\n    return new VineBoolean(options)\n  }\n\n  /**\n   * Validate a checkbox to be checked\n   */\n  accepted() {\n    return new VineAccepted()\n  }\n\n  /**\n   * Define a number value\n   */\n  number(options?: { strict: boolean }) {\n    return new VineNumber(options)\n  }\n\n  /**", "   * Define a schema type in which the input value\n   * matches the pre-defined value\n   */\n  literal<const Value>(value: Value) {\n    return new VineLiteral<Value>(value)\n  }\n\n  /**\n   * Define an object with known properties. You may call \"allowUnknownProperties\"\n   * to merge unknown properties.\n   */\n  object<Properties extends Record<string, SchemaTypes>>(properties: Properties) {\n    return new VineObject<\n      Properties,\n      {\n        [K in keyof Properties]: Properties[K][typeof OTYPE]\n      },\n      {\n        [K in keyof Properties as CamelCase<K & string>]: Properties[K][typeof COTYPE]\n      }\n    >(properties)\n  }\n\n  /**\n   * Define an array field and validate its children elements.\n   */\n  array<Schema extends SchemaTypes>(schema: Schema) {\n    return new VineArray<Schema>(schema)\n  }\n\n  /**\n   * Define an array field with known length and each children\n   * element may have its own schema.\n   */\n  tuple<Schema extends SchemaTypes[]>(schemas: [...Schema]) {\n    return new VineTuple<\n      Schema,\n      { [K in keyof Schema]: Schema[K][typeof OTYPE] },\n      { [K in keyof Schema]: Schema[K][typeof COTYPE] }\n    >(schemas)\n  }\n\n  /**\n   * Define an object field with key-value pair. The keys in\n   * a record are unknown and values can be of a specific\n   * schema type.\n   */\n  record<Schema extends SchemaTypes>(schema: Schema) {\n    return new VineRecord<Schema>(schema)\n  }\n\n  /**", "   * Define a field whose value matches the enum choices.\n   */\n  enum<const Values extends readonly unknown[]>(\n    values: Values | ((field: FieldContext) => Values)\n  ): VineEnum<Values>\n  enum<Values extends EnumLike>(values: Values): VineNativeEnum<Values>\n  enum<Values extends readonly unknown[] | EnumLike>(values: Values): any {\n    if (Array.isArray(values) || typeof values === 'function') {\n      return new VineEnum(values)\n    }\n    return new VineNativeEnum(values as EnumLike)\n  }\n\n  /**\n   * Allow the field value to be anything\n   */\n  any() {\n    return new VineAny()\n  }\n\n  /**\n   * Define a union of unique schema types.\n   */\n  unionOfTypes<Schema extends SchemaTypes>(schemas: Schema[]) {\n    const schemasInUse: Set<string> = new Set()\n    schemas.forEach((schema) => {", "      if (!schema[IS_OF_TYPE] || !schema[UNIQUE_NAME]) {\n        throw new Error(\n          `Cannot use \"${schema.constructor.name}\". The schema type is not compatible for use with \"vine.unionOfTypes\"`\n        )\n      }\n\n      if (schemasInUse.has(schema[UNIQUE_NAME])) {\n        throw new Error(\n          `Cannot use duplicate schema \"${schema[UNIQUE_NAME]}\". \"vine.unionOfTypes\" needs distinct schema types only`\n        )\n      }\n\n      schemasInUse.add(schema[UNIQUE_NAME])\n    })\n    schemasInUse.clear()\n    return new VineUnionOfTypes(schemas)\n  }\n}\n"]}
{"filename": "src/schema/camelcase_types.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**", "\n/**\n * Copy-pasted from\n * https://github.com/ts-essentials/ts-essentials/blob/3f5d46a203cad06728fbf2a089a5b39bd473bf4e/lib/camel-case/index.ts\n *\n * Since, we need just one helper, I decided to not pull in the entire package and just copy-paste\n * the types\n */\n\ntype IsStringLiteral<Type> = Type extends string ? (string extends Type ? false : true) : false\n", "\ntype IsStringLiteral<Type> = Type extends string ? (string extends Type ? false : true) : false\n\ntype WordInPascalCase<Type> = Capitalize<WordInCamelCase<Uncapitalize<Type & string>>>\n\ntype WordInCamelCase<\n  Type,\n  Character extends string = '',\n> = Type extends `${Character}${infer NextCharacter}${infer _}`\n  ? NextCharacter extends Capitalize<NextCharacter>\n    ? Character\n    : WordInCamelCase<Type, `${Character}${NextCharacter}`>\n  : Character\n", "type Separator = '_' | '-'\n\ntype IncludesSeparator<Type> = Type extends `${string}${Separator}${string}` ? true : false\n\ntype IsOneWord<Type> = Type extends Lowercase<Type & string>\n  ? true\n  : Type extends Uppercase<Type & string>\n  ? true\n  : false\n\ntype IsCamelCase<Type> = Type extends Uncapitalize<Type & string> ? true : false\n", "type IsCamelCase<Type> = Type extends Uncapitalize<Type & string> ? true : false\n\ntype IsPascalCase<Type> = Type extends Capitalize<Type & string> ? true : false\n\n/** snake_case, CONSTANT_CASE, kebab-case or COBOL-CASE */\ntype SeparatorCaseParser<\n  Type,\n  Tuple extends readonly any[] = [],\n> = Type extends `${infer Word}${Separator}${infer Tail}`\n  ? SeparatorCaseParser<Tail, [...Tuple, Lowercase<Word>]>\n  : Type extends `${infer Word}`\n  ? [...Tuple, Lowercase<Word>]\n  : Tuple\n", "type CamelCaseParser<Type, Tuple extends readonly any[] = []> = Type extends ''\n  ? Tuple\n  : Type extends `${WordInCamelCase<Type & string>}${infer Tail}`\n  ? Type extends `${infer Word}${Tail}`\n    ? CamelCaseParser<Uncapitalize<Tail>, [...Tuple, Lowercase<Word>]>\n    : never\n  : never\n\ntype PascalCaseParser<Type, Tuple extends readonly any[] = []> = Type extends ''\n  ? Tuple\n  : Type extends `${WordInPascalCase<Type & string>}${infer Tail}`\n  ? Type extends `${infer Word}${Tail}`\n    ? PascalCaseParser<Tail, [...Tuple, Lowercase<Word>]>\n    : never\n  : never\n", "type PascalCaseParser<Type, Tuple extends readonly any[] = []> = Type extends ''\n  ? Tuple\n  : Type extends `${WordInPascalCase<Type & string>}${infer Tail}`\n  ? Type extends `${infer Word}${Tail}`\n    ? PascalCaseParser<Tail, [...Tuple, Lowercase<Word>]>\n    : never\n  : never\n\ntype SplitAnyCase<Type> = IncludesSeparator<Type> extends true\n  ? SeparatorCaseParser<Type>\n  : IsOneWord<Type> extends true\n  ? [Lowercase<Type & string>]\n  : IsCamelCase<Type> extends true\n  ? CamelCaseParser<Type>\n  : IsPascalCase<Type> extends true\n  ? PascalCaseParser<Type>\n  : []\n", "type SplitAnyCase<Type> = IncludesSeparator<Type> extends true\n  ? SeparatorCaseParser<Type>\n  : IsOneWord<Type> extends true\n  ? [Lowercase<Type & string>]\n  : IsCamelCase<Type> extends true\n  ? CamelCaseParser<Type>\n  : IsPascalCase<Type> extends true\n  ? PascalCaseParser<Type>\n  : []\n\ntype PascalCapitalizer<Type, Tuple extends readonly any[] = []> = Type extends [\n  infer Head,\n  ...infer Tail,\n]\n  ? Head extends string\n    ? PascalCapitalizer<Tail, [...Tuple, Capitalize<Head>]>\n    : PascalCapitalizer<Tail, Tuple>\n  : Tuple\n", "type PascalCapitalizer<Type, Tuple extends readonly any[] = []> = Type extends [\n  infer Head,\n  ...infer Tail,\n]\n  ? Head extends string\n    ? PascalCapitalizer<Tail, [...Tuple, Capitalize<Head>]>\n    : PascalCapitalizer<Tail, Tuple>\n  : Tuple\n\ntype CamelCapitalizer<Type> = Type extends [infer First, ...infer Tail]\n  ? PascalCapitalizer<Tail, [First]>\n  : []\n", "type CamelCapitalizer<Type> = Type extends [infer First, ...infer Tail]\n  ? PascalCapitalizer<Tail, [First]>\n  : []\n\ntype Join<Type, JoinedString extends string = ''> = Type extends [infer Head, ...infer Tail]\n  ? Head extends string\n    ? Join<Tail, `${JoinedString}${Head}`>\n    : Join<Tail>\n  : JoinedString\n\nexport type CamelCase<Type> = IsStringLiteral<Type> extends true\n  ? Join<CamelCapitalizer<SplitAnyCase<Type>>>\n  : Type\n", "export type CamelCase<Type> = IsStringLiteral<Type> extends true\n  ? Join<CamelCapitalizer<SplitAnyCase<Type>>>\n  : Type\n"]}
{"filename": "src/schema/union_of_types/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport type { RefsStore, UnionNode } from '@vinejs/compiler/types'\n\nimport { messages } from '../../defaults.js'\nimport { OTYPE, COTYPE, PARSE, IS_OF_TYPE } from '../../symbols.js'\nimport type {\n  SchemaTypes,\n  ParserOptions,\n  ConstructableSchema,", "  ParserOptions,\n  ConstructableSchema,\n  UnionNoMatchCallback,\n} from '../../types.js'\n\n/**\n * Vine union represents a union data type. A union is a collection\n * of conditionals and each condition has an associated schema\n */\nexport class VineUnionOfTypes<Schema extends SchemaTypes>\n  implements ConstructableSchema<Schema[typeof OTYPE], Schema[typeof COTYPE]>\n{\n  declare [OTYPE]: Schema[typeof OTYPE];\n  declare [COTYPE]: Schema[typeof COTYPE]\n\n  #schemas: Schema[]\n  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n    field.report(messages.unionOfTypes, 'unionOfTypes', field)\n  }\n\n  constructor(schemas: Schema[]) {\n    this.#schemas = schemas\n  }\n\n  /**\n   * Define a fallback method to invoke when all of the union conditions\n   * fail. You may use this method to report an error.\n   */\n  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n    this.#otherwiseCallback = callback\n    return this\n  }\n\n  /**\n   * Clones the VineUnionOfTypes schema type.\n   */\n  clone(): this {\n    const cloned = new VineUnionOfTypes<Schema>(this.#schemas)\n    cloned.otherwise(this.#otherwiseCallback)\n\n    return cloned as this\n  }\n\n  /**\n   * Compiles to a union\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode {\n    return {\n      type: 'union',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n      conditions: this.#schemas.map((schema) => {\n        return {\n          conditionalFnRefId: refs.trackConditional((value, field) => {\n            return schema[IS_OF_TYPE]!(value, field)\n          }),\n          schema: schema[PARSE](propertyName, refs, options),\n        }\n      }),\n    }\n  }\n}\n", " */\nexport class VineUnionOfTypes<Schema extends SchemaTypes>\n  implements ConstructableSchema<Schema[typeof OTYPE], Schema[typeof COTYPE]>\n{\n  declare [OTYPE]: Schema[typeof OTYPE];\n  declare [COTYPE]: Schema[typeof COTYPE]\n\n  #schemas: Schema[]\n  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n    field.report(messages.unionOfTypes, 'unionOfTypes', field)\n  }\n\n  constructor(schemas: Schema[]) {\n    this.#schemas = schemas\n  }\n\n  /**\n   * Define a fallback method to invoke when all of the union conditions\n   * fail. You may use this method to report an error.\n   */\n  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n    this.#otherwiseCallback = callback\n    return this\n  }\n\n  /**\n   * Clones the VineUnionOfTypes schema type.\n   */\n  clone(): this {\n    const cloned = new VineUnionOfTypes<Schema>(this.#schemas)\n    cloned.otherwise(this.#otherwiseCallback)\n\n    return cloned as this\n  }\n\n  /**\n   * Compiles to a union\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode {\n    return {\n      type: 'union',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n      conditions: this.#schemas.map((schema) => {\n        return {\n          conditionalFnRefId: refs.trackConditional((value, field) => {\n            return schema[IS_OF_TYPE]!(value, field)\n          }),\n          schema: schema[PARSE](propertyName, refs, options),\n        }\n      }),\n    }\n  }\n}\n"]}
{"filename": "src/schema/accepted/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { acceptedRule } from './rules.js'", "\nimport { acceptedRule } from './rules.js'\nimport { BaseLiteralType } from '../base/literal.js'\nimport type { FieldOptions, Validation } from '../../types.js'\n\n/**\n * VineAccepted represents a checkbox input that must be checked\n */\nexport class VineAccepted extends BaseLiteralType<true, true> {\n  /**\n   * Default collection of accepted rules\n   */\n  static rules = {\n    accepted: acceptedRule,\n  }\n\n  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n    super(options, validations || [acceptedRule()])\n  }\n\n  /**\n   * Clones the VineAccepted schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineAccepted(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n", "export class VineAccepted extends BaseLiteralType<true, true> {\n  /**\n   * Default collection of accepted rules\n   */\n  static rules = {\n    accepted: acceptedRule,\n  }\n\n  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n    super(options, validations || [acceptedRule()])\n  }\n\n  /**\n   * Clones the VineAccepted schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineAccepted(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/accepted/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { messages } from '../../defaults.js'", "\nimport { messages } from '../../defaults.js'\nimport { createRule } from '../../vine/create_rule.js'\n\nconst ACCEPTED_VALUES = ['on', '1', 'yes', 'true', true, 1]\n\n/**\n * Validates the value to be present and have one of\n * the following values.\n *", " * the following values.\n *\n * - \"on\"\n * - \"1\"\n * - \"yes\"\n * - \"true\"\n */\nexport const acceptedRule = createRule((value, _, field) => {\n  if (!ACCEPTED_VALUES.includes(value as any)) {\n    field.report(messages.accepted, 'accepted', field)\n  }\n})\n", "  if (!ACCEPTED_VALUES.includes(value as any)) {\n    field.report(messages.accepted, 'accepted', field)\n  }\n})\n"]}
{"filename": "src/schema/object/conditional.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { ConditionalFn, ObjectGroupNode, RefsStore } from '@vinejs/compiler/types'", "\nimport type { ConditionalFn, ObjectGroupNode, RefsStore } from '@vinejs/compiler/types'\n\nimport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\nimport type { ParserOptions, SchemaTypes } from '../../types.js'\n\n/**\n * Group conditional represents a sub-set of object wrapped\n * inside a conditional\n */\nexport class GroupConditional<\n  Properties extends Record<string, SchemaTypes>,\n  Output,\n  CamelCaseOutput,\n> {\n  declare [OTYPE]: Output;\n  declare [COTYPE]: CamelCaseOutput\n\n  /**\n   * Properties to merge when conditonal is true\n   */\n  #properties: Properties\n\n  /**\n   * Conditional to evaluate\n   */\n  #conditional: ConditionalFn<Record<string, unknown>>\n\n  constructor(conditional: ConditionalFn<Record<string, unknown>>, properties: Properties) {\n    this.#properties = properties\n    this.#conditional = conditional\n  }\n\n  /**\n   * Compiles to a union conditional\n   */\n  [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode['conditions'][number] {\n    return {\n      schema: {\n        type: 'sub_object',\n        properties: Object.keys(this.#properties).map((property) => {\n          return this.#properties[property][PARSE](property, refs, options)\n        }),\n        groups: [], // Compiler allows nested groups, but we are not implementing it\n      },\n      conditionalFnRefId: refs.trackConditional(this.#conditional),\n    }\n  }\n}\n", " * inside a conditional\n */\nexport class GroupConditional<\n  Properties extends Record<string, SchemaTypes>,\n  Output,\n  CamelCaseOutput,\n> {\n  declare [OTYPE]: Output;\n  declare [COTYPE]: CamelCaseOutput\n\n  /**\n   * Properties to merge when conditonal is true\n   */\n  #properties: Properties\n\n  /**\n   * Conditional to evaluate\n   */\n  #conditional: ConditionalFn<Record<string, unknown>>\n\n  constructor(conditional: ConditionalFn<Record<string, unknown>>, properties: Properties) {\n    this.#properties = properties\n    this.#conditional = conditional\n  }\n\n  /**\n   * Compiles to a union conditional\n   */\n  [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode['conditions'][number] {\n    return {\n      schema: {\n        type: 'sub_object',\n        properties: Object.keys(this.#properties).map((property) => {\n          return this.#properties[property][PARSE](property, refs, options)\n        }),\n        groups: [], // Compiler allows nested groups, but we are not implementing it\n      },\n      conditionalFnRefId: refs.trackConditional(this.#conditional),\n    }\n  }\n}\n"]}
{"filename": "src/schema/object/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport type { ObjectNode, RefsStore } from '@vinejs/compiler/types'\n\nimport { ObjectGroup } from './group.js'\nimport { GroupConditional } from './conditional.js'\nimport { BaseModifiersType, BaseType } from '../base/main.js'\nimport { OTYPE, COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js'\nimport type { Validation, SchemaTypes, FieldOptions, ParserOptions } from '../../types.js'\n", "import type { Validation, SchemaTypes, FieldOptions, ParserOptions } from '../../types.js'\n\n/**\n * Converts schema properties to camelCase\n */\nexport class VineCamelCaseObject<\n  Schema extends VineObject<any, any, any>,\n> extends BaseModifiersType<Schema[typeof COTYPE], Schema[typeof COTYPE]> {\n  #schema: Schema;\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'types.object';\n\n  /**\n   * Checks if the value is of object type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    return value !== null && typeof value === 'object' && !Array.isArray(value)\n  }\n\n  constructor(schema: Schema) {\n    super()\n    this.#schema = schema\n  }\n\n  /**\n   * Clone object\n   */\n  clone(): this {\n    return new VineCamelCaseObject<Schema>(this.#schema.clone()) as this\n  }\n\n  /**", "   * Compiles the schema type to a compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode {\n    options.toCamelCase = true\n    return this.#schema[PARSE](propertyName, refs, options)\n  }\n}\n\n/**\n * VineObject represents an object value in the validation\n * schema.\n */", "export class VineObject<\n  Properties extends Record<string, SchemaTypes>,\n  Output,\n  CamelCaseOutput,\n> extends BaseType<Output, CamelCaseOutput> {\n  /**\n   * Object properties\n   */\n  #properties: Properties\n\n  /**\n   * Object groups to merge based on conditionals\n   */\n  #groups: ObjectGroup<GroupConditional<any, any, any>>[] = []\n\n  /**\n   * Whether or not to allow unknown properties\n   */\n  #allowUnknownProperties: boolean = false;\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.object';\n\n  /**\n   * Checks if the value is of object type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    return value !== null && typeof value === 'object' && !Array.isArray(value)\n  }\n\n  constructor(properties: Properties, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations)\n    this.#properties = properties\n  }\n\n  /**\n   * Returns a clone copy of the object properties. The object groups\n   * are not copied to keep the implementations simple and easy to\n   * reason about.\n   */\n  getProperties(): Properties {\n    return Object.keys(this.#properties).reduce((result, key) => {\n      result[key as keyof Properties] = this.#properties[\n        key\n      ].clone() as Properties[keyof Properties]\n      return result\n    }, {} as Properties)\n  }\n\n  /**\n   * Copy unknown properties to the final output.\n   */\n  allowUnknownProperties<Value>(): VineObject<\n    Properties,\n    Output & { [K: string]: Value },\n    CamelCaseOutput & { [K: string]: Value }\n  > {\n    this.#allowUnknownProperties = true\n    return this as VineObject<\n      Properties,\n      Output & { [K: string]: Value },\n      CamelCaseOutput & { [K: string]: Value }\n    >\n  }\n\n  /**\n   * Merge a union to the object groups. The union can be a \"vine.union\"\n   * with objects, or a \"vine.object.union\" with properties.\n   */\n  merge<Group extends ObjectGroup<GroupConditional<any, any, any>>>(\n    group: Group\n  ): VineObject<Properties, Output & Group[typeof OTYPE], CamelCaseOutput & Group[typeof COTYPE]> {\n    this.#groups.push(group)\n    return this as VineObject<\n      Properties,\n      Output & Group[typeof OTYPE],\n      CamelCaseOutput & Group[typeof COTYPE]\n    >\n  }\n\n  /**\n   * Clone object\n   */\n  clone(): this {\n    const cloned = new VineObject<Properties, Output, CamelCaseOutput>(\n      this.getProperties(),\n      this.cloneOptions(),\n      this.cloneValidations()\n    )\n\n    this.#groups.forEach((group) => cloned.merge(group))", "    if (this.#allowUnknownProperties) {\n      cloned.allowUnknownProperties()\n    }\n\n    return cloned as this\n  }\n\n  /**\n   * Applies camelcase transform\n   */\n  toCamelCase() {\n    return new VineCamelCaseObject(this)\n  }\n\n  /**", "   * Compiles the schema type to a compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode {\n    return {\n      type: 'object',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      bail: this.options.bail,\n      allowNull: this.options.allowNull,\n      isOptional: this.options.isOptional,\n      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n      allowUnknownProperties: this.#allowUnknownProperties,\n      validations: this.compileValidations(refs),\n      properties: Object.keys(this.#properties).map((property) => {\n        return this.#properties[property][PARSE](property, refs, options)\n      }),\n      groups: this.#groups.map((group) => {\n        return group[PARSE](refs, options)\n      }),\n    }\n  }\n}\n"]}
{"filename": "src/schema/object/group_builder.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ObjectGroup } from './group.js'", "\nimport { ObjectGroup } from './group.js'\nimport { OTYPE, COTYPE } from '../../symbols.js'\nimport { CamelCase } from '../camelcase_types.js'\nimport { GroupConditional } from './conditional.js'\nimport type { FieldContext, SchemaTypes } from '../../types.js'\n\n/**\n * Create an object group. Groups are used to conditionally merge properties\n * to an existing object.", " * Create an object group. Groups are used to conditionally merge properties\n * to an existing object.\n */\nexport function group<Conditional extends GroupConditional<any, any, any>>(\n  conditionals: Conditional[]\n) {\n  return new ObjectGroup<Conditional>(conditionals)\n}\n\n/**\n * Wrap object properties inside a conditonal\n */", "group.if = function groupIf<Properties extends Record<string, SchemaTypes>>(\n  conditon: (value: Record<string, unknown>, field: FieldContext) => any,\n  properties: Properties\n) {\n  return new GroupConditional<\n    Properties,\n    {\n      [K in keyof Properties]: Properties[K][typeof OTYPE]\n    },\n    {\n      [K in keyof Properties as CamelCase<K & string>]: Properties[K][typeof COTYPE]\n    }\n  >(conditon, properties)\n}\n\n/**\n * Wrap object properties inside an else conditon\n */", "group.else = function groupElse<Properties extends Record<string, SchemaTypes>>(\n  properties: Properties\n) {\n  return new GroupConditional<\n    Properties,\n    {\n      [K in keyof Properties]: Properties[K][typeof OTYPE]\n    },\n    {\n      [K in keyof Properties as CamelCase<K & string>]: Properties[K][typeof COTYPE]\n    }\n  >(() => true, properties)\n}\n"]}
{"filename": "src/schema/object/group.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ObjectGroupNode, RefsStore } from '@vinejs/compiler/types'", "\nimport { ObjectGroupNode, RefsStore } from '@vinejs/compiler/types'\n\nimport { messages } from '../../defaults.js'\nimport { GroupConditional } from './conditional.js'\nimport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\nimport type { ParserOptions, UnionNoMatchCallback } from '../../types.js'\n\n/**\n * Object group represents a group with multiple conditionals, where each", "/**\n * Object group represents a group with multiple conditionals, where each\n * condition returns a set of object properties to merge into the\n * existing object.\n */\nexport class ObjectGroup<Conditional extends GroupConditional<any, any, any>> {\n  declare [OTYPE]: Conditional[typeof OTYPE];\n  declare [COTYPE]: Conditional[typeof COTYPE]\n\n  #conditionals: Conditional[]\n  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n    field.report(messages.unionGroup, 'unionGroup', field)\n  }\n\n  constructor(conditionals: Conditional[]) {\n    this.#conditionals = conditionals\n  }\n\n  /**\n   * Clones the ObjectGroup schema type.\n   */\n  clone(): this {\n    const cloned = new ObjectGroup<Conditional>(this.#conditionals)\n    cloned.otherwise(this.#otherwiseCallback)\n    return cloned as this\n  }\n\n  /**\n   * Define a fallback method to invoke when all of the group conditions\n   * fail. You may use this method to report an error.\n   */\n  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n    this.#otherwiseCallback = callback\n    return this\n  }\n\n  /**\n   * Compiles the group\n   */\n  [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode {\n    return {\n      type: 'group',\n      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n      conditions: this.#conditionals.map((conditional) => conditional[PARSE](refs, options)),\n    }\n  }\n}\n"]}
{"filename": "src/schema/boolean/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { booleanRule } from './rules.js'", "\nimport { booleanRule } from './rules.js'\nimport { helpers } from '../../vine/helpers.js'\nimport { BaseLiteralType } from '../base/literal.js'\nimport { IS_OF_TYPE, UNIQUE_NAME } from '../../symbols.js'\nimport type { FieldOptions, Validation } from '../../types.js'\n\n/**\n * VineBoolean represents a boolean value in the validation schema.\n */\nexport class VineBoolean extends BaseLiteralType<boolean, boolean> {\n  /**\n   * Default collection of boolean rules\n   */\n  static rules = {\n    boolean: booleanRule,\n  }\n\n  protected declare options: FieldOptions & { strict?: boolean };\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.boolean';\n\n  /**\n   * Checks if the value is of boolean type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    const valueAsBoolean = this.options.strict === true ? value : helpers.asBoolean(value)\n    return typeof valueAsBoolean === 'boolean'\n  }\n\n  constructor(\n    options?: Partial<FieldOptions> & { strict?: boolean },\n    validations?: Validation<any>[]\n  ) {\n    super(options, validations || [booleanRule(options || {})])\n  }\n\n  /**\n   * Clones the VineBoolean schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineBoolean(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n", " * VineBoolean represents a boolean value in the validation schema.\n */\nexport class VineBoolean extends BaseLiteralType<boolean, boolean> {\n  /**\n   * Default collection of boolean rules\n   */\n  static rules = {\n    boolean: booleanRule,\n  }\n\n  protected declare options: FieldOptions & { strict?: boolean };\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.boolean';\n\n  /**\n   * Checks if the value is of boolean type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    const valueAsBoolean = this.options.strict === true ? value : helpers.asBoolean(value)\n    return typeof valueAsBoolean === 'boolean'\n  }\n\n  constructor(\n    options?: Partial<FieldOptions> & { strict?: boolean },\n    validations?: Validation<any>[]\n  ) {\n    super(options, validations || [booleanRule(options || {})])\n  }\n\n  /**\n   * Clones the VineBoolean schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineBoolean(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/boolean/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { helpers } from '../../vine/helpers.js'", "\nimport { helpers } from '../../vine/helpers.js'\nimport { messages } from '../../defaults.js'\nimport { createRule } from '../../vine/create_rule.js'\n\n/**\n * Validates the value to be a boolean\n */\nexport const booleanRule = createRule<{ strict?: boolean }>((value, options, field) => {\n  const valueAsBoolean = options.strict === true ? value : helpers.asBoolean(value)\n  if (typeof valueAsBoolean !== 'boolean') {\n    field.report(messages.boolean, 'boolean', field)\n    return\n  }\n\n  field.mutate(valueAsBoolean, field)\n})\n", "export const booleanRule = createRule<{ strict?: boolean }>((value, options, field) => {\n  const valueAsBoolean = options.strict === true ? value : helpers.asBoolean(value)\n  if (typeof valueAsBoolean !== 'boolean') {\n    field.report(messages.boolean, 'boolean', field)\n    return\n  }\n\n  field.mutate(valueAsBoolean, field)\n})\n"]}
{"filename": "src/schema/string/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseLiteralType } from '../base/literal.js'", "\nimport { BaseLiteralType } from '../base/literal.js'\nimport { IS_OF_TYPE, UNIQUE_NAME } from '../../symbols.js'\nimport type {\n  Validation,\n  AlphaOptions,\n  FieldContext,\n  FieldOptions,\n  AlphaNumericOptions,\n  NormalizeEmailOptions,", "  AlphaNumericOptions,\n  NormalizeEmailOptions,\n} from '../../types.js'\n\nimport {\n  inRule,\n  urlRule,\n  uuidRule,\n  trimRule,\n  alphaRule,", "  trimRule,\n  alphaRule,\n  emailRule,\n  notInRule,\n  regexRule,\n  sameAsRule,\n  mobileRule,\n  escapeRule,\n  stringRule,\n  hexCodeRule,", "  stringRule,\n  hexCodeRule,\n  passportRule,\n  endsWithRule,\n  ipAddressRule,\n  confirmedRule,\n  notSameAsRule,\n  activeUrlRule,\n  minLengthRule,\n  maxLengthRule,", "  minLengthRule,\n  maxLengthRule,\n  startsWithRule,\n  creditCardRule,\n  postalCodeRule,\n  fixedLengthRule,\n  alphaNumericRule,\n  normalizeEmailRule,\n  asciiRule,\n  ibanRule,", "  asciiRule,\n  ibanRule,\n  jwtRule,\n  coordinatesRule,\n  toUpperCaseRule,\n  toLowerCaseRule,\n  toCamelCaseRule,\n  normalizeUrlRule,\n} from './rules.js'\n", "} from './rules.js'\n\n/**\n * VineString represents a string value in the validation schema.\n */\nexport class VineString extends BaseLiteralType<string, string> {\n  static rules = {\n    in: inRule,\n    jwt: jwtRule,\n    url: urlRule,\n    iban: ibanRule,\n    uuid: uuidRule,\n    trim: trimRule,\n    email: emailRule,\n    alpha: alphaRule,\n    ascii: asciiRule,\n    notIn: notInRule,\n    regex: regexRule,\n    escape: escapeRule,\n    sameAs: sameAsRule,\n    mobile: mobileRule,\n    string: stringRule,\n    hexCode: hexCodeRule,\n    passport: passportRule,\n    endsWith: endsWithRule,\n    confirmed: confirmedRule,\n    activeUrl: activeUrlRule,\n    minLength: minLengthRule,\n    notSameAs: notSameAsRule,\n    maxLength: maxLengthRule,\n    ipAddress: ipAddressRule,\n    creditCard: creditCardRule,\n    postalCode: postalCodeRule,\n    startsWith: startsWithRule,\n    toUpperCase: toUpperCaseRule,\n    toLowerCase: toLowerCaseRule,\n    toCamelCase: toCamelCaseRule,\n    fixedLength: fixedLengthRule,\n    coordinates: coordinatesRule,\n    normalizeUrl: normalizeUrlRule,\n    alphaNumeric: alphaNumericRule,\n    normalizeEmail: normalizeEmailRule,\n  };\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.string';\n\n  /**\n   * Checks if the value is of string type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    return typeof value === 'string'\n  }\n\n  constructor(options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations || [stringRule()])\n  }\n\n  /**\n   * Validates the value to be a valid URL\n   */\n  url(...args: Parameters<typeof urlRule>) {\n    return this.use(urlRule(...args))\n  }\n\n  /**\n   * Validates the value to be an active URL\n   */\n  activeUrl() {\n    return this.use(activeUrlRule())\n  }\n\n  /**\n   * Validates the value to be a valid email address\n   */\n  email(...args: Parameters<typeof emailRule>) {\n    return this.use(emailRule(...args))\n  }\n\n  /**\n   * Validates the value to be a valid mobile number\n   */\n  mobile(...args: Parameters<typeof mobileRule>) {\n    return this.use(mobileRule(...args))\n  }\n\n  /**\n   * Validates the value to be a valid IP address.\n   */\n  ipAddress(version?: 4 | 6) {\n    return this.use(ipAddressRule(version ? { version } : undefined))\n  }\n\n  /**\n   * Validates the value to be a valid hex color code\n   */\n  hexCode() {\n    return this.use(hexCodeRule())\n  }\n\n  /**\n   * Validates the value to be an active URL\n   */\n  regex(expression: RegExp) {\n    return this.use(regexRule(expression))\n  }\n\n  /**\n   * Validates the value to contain only letters\n   */\n  alpha(options?: AlphaOptions) {\n    return this.use(alphaRule(options))\n  }\n\n  /**\n   * Validates the value to contain only letters and\n   * numbers\n   */\n  alphaNumeric(options?: AlphaNumericOptions) {\n    return this.use(alphaNumericRule(options))\n  }\n\n  /**\n   * Enforce a minimum length on a string field\n   */\n  minLength(expectedLength: number) {\n    return this.use(minLengthRule({ min: expectedLength }))\n  }\n\n  /**\n   * Enforce a maximum length on a string field\n   */\n  maxLength(expectedLength: number) {\n    return this.use(maxLengthRule({ max: expectedLength }))\n  }\n\n  /**\n   * Enforce a fixed length on a string field\n   */\n  fixedLength(expectedLength: number) {\n    return this.use(fixedLengthRule({ size: expectedLength }))\n  }\n\n  /**\n   * Ensure the field under validation is confirmed by\n   * having another field with the same name.\n   */\n  confirmed(options?: { confirmationField: string }) {\n    return this.use(confirmedRule(options))\n  }\n\n  /**\n   * Trims whitespaces around the string value\n   */\n  trim() {\n    return this.use(trimRule())\n  }\n\n  /**\n   * Normalizes the email address\n   */\n  normalizeEmail(options?: NormalizeEmailOptions) {\n    return this.use(normalizeEmailRule(options))\n  }\n\n  /**\n   * Converts the field value to UPPERCASE.\n   */\n  toUpperCase() {\n    return this.use(toUpperCaseRule())\n  }\n\n  /**\n   * Converts the field value to lowercase.\n   */\n  toLowerCase() {\n    return this.use(toLowerCaseRule())\n  }\n\n  /**\n   * Converts the field value to camelCase.\n   */\n  toCamelCase() {\n    return this.use(toCamelCaseRule())\n  }\n\n  /**\n   * Escape string for HTML entities\n   */\n  escape() {\n    return this.use(escapeRule())\n  }\n\n  /**\n   * Normalize a URL\n   */\n  normalizeUrl(...args: Parameters<typeof normalizeUrlRule>) {\n    return this.use(normalizeUrlRule(...args))\n  }\n\n  /**\n   * Ensure the value starts with the pre-defined substring\n   */\n  startsWith(substring: string) {\n    return this.use(startsWithRule({ substring }))\n  }\n\n  /**\n   * Ensure the value ends with the pre-defined substring\n   */\n  endsWith(substring: string) {\n    return this.use(endsWithRule({ substring }))\n  }\n\n  /**\n   * Ensure the value ends with the pre-defined substring\n   */\n  sameAs(otherField: string) {\n    return this.use(sameAsRule({ otherField }))\n  }\n\n  /**\n   * Ensure the value ends with the pre-defined substring\n   */\n  notSameAs(otherField: string) {\n    return this.use(notSameAsRule({ otherField }))\n  }\n\n  /**\n   * Ensure the field's value under validation is a subset of the pre-defined list.\n   */\n  in(choices: string[] | ((field: FieldContext) => string[])) {\n    return this.use(inRule({ choices }))\n  }\n\n  /**\n   * Ensure the field's value under validation is not inside the pre-defined list.\n   */\n  notIn(list: string[] | ((field: FieldContext) => string[])) {\n    return this.use(notInRule({ list }))\n  }\n\n  /**\n   * Validates the value to be a valid credit card number\n   */\n  creditCard(...args: Parameters<typeof creditCardRule>) {\n    return this.use(creditCardRule(...args))\n  }\n\n  /**\n   * Validates the value to be a valid passport number\n   */\n  passport(...args: Parameters<typeof passportRule>) {\n    return this.use(passportRule(...args))\n  }\n\n  /**\n   * Validates the value to be a valid postal code\n   */\n  postalCode(...args: Parameters<typeof postalCodeRule>) {\n    return this.use(postalCodeRule(...args))\n  }\n\n  /**\n   * Validates the value to be a valid UUID\n   */\n  uuid(...args: Parameters<typeof uuidRule>) {\n    return this.use(uuidRule(...args))\n  }\n\n  /**\n   * Validates the value contains ASCII characters only\n   */\n  ascii() {\n    return this.use(asciiRule())\n  }\n\n  /**\n   * Validates the value to be a valid IBAN number\n   */\n  iban() {\n    return this.use(ibanRule())\n  }\n\n  /**\n   * Validates the value to be a valid JWT token\n   */\n\n  jwt() {\n    return this.use(jwtRule())\n  }\n\n  /**\n   * Ensure the value is a string with latitude and longitude coordinates\n   */\n  coordinates() {\n    return this.use(coordinatesRule())\n  }\n\n  /**\n   * Clones the VineString schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineString(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/string/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport normalizeEmail from 'validator/lib/normalizeEmail.js'", "\nimport normalizeEmail from 'validator/lib/normalizeEmail.js'\nimport escape from 'validator/lib/escape.js'\nimport type { FieldContext } from '@vinejs/compiler/types'\n\nimport { helpers } from '../../vine/helpers.js'\nimport { messages } from '../../defaults.js'\nimport { createRule } from '../../vine/create_rule.js'\nimport type {\n  URLOptions,", "import type {\n  URLOptions,\n  AlphaOptions,\n  EmailOptions,\n  MobileOptions,\n  PassportOptions,\n  CreditCardOptions,\n  PostalCodeOptions,\n  NormalizeUrlOptions,\n  AlphaNumericOptions,", "  NormalizeUrlOptions,\n  AlphaNumericOptions,\n  NormalizeEmailOptions,\n} from '../../types.js'\nimport camelcase from 'camelcase'\nimport normalizeUrl from 'normalize-url'\n\n/**\n * Validates the value to be a string\n */", " * Validates the value to be a string\n */\nexport const stringRule = createRule((value, _, field) => {\n  if (typeof value !== 'string') {\n    field.report(messages.string, 'string', field)\n  }\n})\n\n/**\n * Validates the value to be a valid email address\n */\nexport const emailRule = createRule<EmailOptions | undefined>((value, options, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isEmail(value as string, options)) {\n    field.report(messages.email, 'email', field)\n  }\n})\n\n/**\n * Validates the value to be a valid mobile number\n */\nexport const mobileRule = createRule<\n  MobileOptions | undefined | ((field: FieldContext) => MobileOptions | undefined)\n>((value, options, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  const normalizedOptions = options && typeof options === 'function' ? options(field) : options\n  const locales = normalizedOptions?.locale || 'any'\n\n  if (!helpers.isMobilePhone(value as string, locales, normalizedOptions)) {\n    field.report(messages.mobile, 'mobile', field)\n  }\n})\n\n/**\n * Validates the value to be a valid IP address.\n */\nexport const ipAddressRule = createRule<{ version: 4 | 6 } | undefined>((value, options, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isIP(value as string, options?.version)) {\n    field.report(messages.ipAddress, 'ipAddress', field)\n  }\n})\n\n/**\n * Validates the value against a regular expression\n */\nexport const regexRule = createRule<RegExp>((value, expression, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!expression.test(value as string)) {\n    field.report(messages.regex, 'regex', field)\n  }\n})\n\n/**\n * Validates the value to be a valid hex color code\n */\nexport const hexCodeRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isHexColor(value as string)) {\n    field.report(messages.hexCode, 'hexCode', field)\n  }\n})\n\n/**\n * Validates the value to be a valid URL\n */\nexport const urlRule = createRule<URLOptions | undefined>((value, options, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isURL(value as string, options)) {\n    field.report(messages.url, 'url', field)\n  }\n})\n\n/**\n * Validates the value to be an active URL\n */\nexport const activeUrlRule = createRule(async (value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!(await helpers.isActiveURL(value as string))) {\n    field.report(messages.activeUrl, 'activeUrl', field)\n  }\n})\n\n/**\n * Validates the value to contain only letters\n */\nexport const alphaRule = createRule<AlphaOptions | undefined>((value, options, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  let characterSet = 'a-zA-Z'\n  if (options) {\n    if (options.allowSpaces) {\n      characterSet += '\\\\s'\n    }\n    if (options.allowDashes) {\n      characterSet += '-'\n    }", "    if (options.allowDashes) {\n      characterSet += '-'\n    }\n    if (options.allowUnderscores) {\n      characterSet += '_'\n    }\n  }\n\n  const expression = new RegExp(`^[${characterSet}]+$`)\n  if (!expression.test(value as string)) {\n    field.report(messages.alpha, 'alpha', field)\n  }\n})\n\n/**\n * Validates the value to contain only letters and numbers\n */\nexport const alphaNumericRule = createRule<AlphaNumericOptions | undefined>(\n  (value, options, field) => {", "  if (!expression.test(value as string)) {\n    field.report(messages.alpha, 'alpha', field)\n  }\n})\n\n/**\n * Validates the value to contain only letters and numbers\n */\nexport const alphaNumericRule = createRule<AlphaNumericOptions | undefined>(\n  (value, options, field) => {\n    if (!field.isValid) {\n      return\n    }\n\n    let characterSet = 'a-zA-Z0-9'", "    if (!field.isValid) {\n      return\n    }\n\n    let characterSet = 'a-zA-Z0-9'\n    if (options) {\n      if (options.allowSpaces) {\n        characterSet += '\\\\s'\n      }\n      if (options.allowDashes) {\n        characterSet += '-'\n      }", "      if (options.allowDashes) {\n        characterSet += '-'\n      }\n      if (options.allowUnderscores) {\n        characterSet += '_'\n      }\n    }\n\n    const expression = new RegExp(`^[${characterSet}]+$`)\n    if (!expression.test(value as string)) {\n      field.report(messages.alphaNumeric, 'alphaNumeric', field)\n    }\n  }\n)\n\n/**\n * Enforce a minimum length on a string field\n */\nexport const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "    if (!expression.test(value as string)) {\n      field.report(messages.alphaNumeric, 'alphaNumeric', field)\n    }\n  }\n)\n\n/**\n * Enforce a minimum length on a string field\n */\nexport const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n  if ((value as string).length < options.min) {\n    field.report(messages.minLength, 'minLength', field, options)\n  }\n})\n\n/**\n * Enforce a maximum length on a string field\n */\nexport const maxLengthRule = createRule<{ max: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as string).length > options.max) {\n    field.report(messages.maxLength, 'maxLength', field, options)\n  }\n})\n\n/**\n * Enforce a fixed length on a string field\n */\nexport const fixedLengthRule = createRule<{ size: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as string).length !== options.size) {\n    field.report(messages.fixedLength, 'fixedLength', field, options)\n  }\n})\n\n/**\n * Ensure the value ends with the pre-defined substring\n */\nexport const endsWithRule = createRule<{ substring: string }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if (!(value as string).endsWith(options.substring)) {\n    field.report(messages.endsWith, 'endsWith', field, options)\n  }\n})\n\n/**\n * Ensure the value starts with the pre-defined substring\n */\nexport const startsWithRule = createRule<{ substring: string }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if (!(value as string).startsWith(options.substring)) {\n    field.report(messages.startsWith, 'startsWith', field, options)\n  }\n})\n\n/**\n * Ensure the field's value under validation is the same as the other field's value\n */\nexport const sameAsRule = createRule<{ otherField: string }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  const input = field.parent[options.otherField]\n\n  /**\n   * Performing validation and reporting error\n   */\n  if (input !== value) {\n    field.report(messages.sameAs, 'sameAs', field, options)\n    return\n  }\n})\n\n/**\n * Ensure the field's value under validation is different from another field's value\n */\nexport const notSameAsRule = createRule<{ otherField: string }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (input !== value) {\n    field.report(messages.sameAs, 'sameAs', field, options)\n    return\n  }\n})\n\n/**\n * Ensure the field's value under validation is different from another field's value\n */\nexport const notSameAsRule = createRule<{ otherField: string }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  const input = field.parent[options.otherField]\n\n  /**\n   * Performing validation and reporting error\n   */\n  if (input === value) {\n    field.report(messages.notSameAs, 'notSameAs', field, options)\n    return\n  }\n})\n\n/**\n * Ensure the field under validation is confirmed by\n * having another field with the same name\n */\nexport const confirmedRule = createRule<{ confirmationField: string } | undefined>(\n  (value, options, field) => {\n    /**\n     * Skip if the field is not valid.\n     */", "  if (input === value) {\n    field.report(messages.notSameAs, 'notSameAs', field, options)\n    return\n  }\n})\n\n/**\n * Ensure the field under validation is confirmed by\n * having another field with the same name\n */\nexport const confirmedRule = createRule<{ confirmationField: string } | undefined>(\n  (value, options, field) => {\n    /**\n     * Skip if the field is not valid.\n     */", "    if (!field.isValid) {\n      return\n    }\n\n    const otherField = options?.confirmationField || `${field.name}_confirmation`\n    const input = field.parent[otherField]\n\n    /**\n     * Performing validation and reporting error\n     */\n    if (input !== value) {\n      field.report(messages.confirmed, 'confirmed', field, { otherField })\n      return\n    }\n  }\n)\n\n/**\n * Trims whitespaces around the string value\n */\nexport const trimRule = createRule((value, _, field) => {", "    if (input !== value) {\n      field.report(messages.confirmed, 'confirmed', field, { otherField })\n      return\n    }\n  }\n)\n\n/**\n * Trims whitespaces around the string value\n */\nexport const trimRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  field.mutate((value as string).trim(), field)\n})\n\n/**\n * Normalizes the email address\n */\nexport const normalizeEmailRule = createRule<NormalizeEmailOptions | undefined>(\n  (value, options, field) => {", "    if (!field.isValid) {\n      return\n    }\n\n    field.mutate(normalizeEmail.default(value as string, options), field)\n  }\n)\n\n/**\n * Converts the field value to UPPERCASE.\n */\nexport const toUpperCaseRule = createRule<string | string[] | undefined>(\n  (value, locales, field) => {", "    if (!field.isValid) {\n      return\n    }\n\n    field.mutate((value as string).toLocaleUpperCase(locales), field)\n  }\n)\n\n/**\n * Converts the field value to lowercase.\n */\nexport const toLowerCaseRule = createRule<string | string[] | undefined>(\n  (value, locales, field) => {", "    if (!field.isValid) {\n      return\n    }\n\n    field.mutate((value as string).toLocaleLowerCase(locales), field)\n  }\n)\n\n/**\n * Converts the field value to camelCase.\n */\nexport const toCamelCaseRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  field.mutate(camelcase(value as string), field)\n})\n\n/**\n * Escape string for HTML entities\n */\nexport const escapeRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  field.mutate(escape.default(value as string), field)\n})\n\n/**\n * Normalize a URL\n */\nexport const normalizeUrlRule = createRule<undefined | NormalizeUrlOptions>(\n  (value, options, field) => {", "    if (!field.isValid) {\n      return\n    }\n\n    field.mutate(normalizeUrl(value as string, options), field)\n  }\n)\n\n/**\n * Ensure the field's value under validation is a subset of the pre-defined list.\n */\nexport const inRule = createRule<{ choices: string[] | ((field: FieldContext) => string[]) }>(\n  (value, options, field) => {\n    /**\n     * Skip if the field is not valid.\n     */", "    if (!field.isValid) {\n      return\n    }\n\n    const choices = typeof options.choices === 'function' ? options.choices(field) : options.choices\n\n    /**\n     * Performing validation and reporting error\n     */\n    if (!choices.includes(value as string)) {\n      field.report(messages.in, 'in', field, options)\n      return\n    }\n  }\n)\n\n/**\n * Ensure the field's value under validation is not inside the pre-defined list.\n */\nexport const notInRule = createRule<{ list: string[] | ((field: FieldContext) => string[]) }>(\n  (value, options, field) => {\n    /**\n     * Skip if the field is not valid.\n     */", "    if (!choices.includes(value as string)) {\n      field.report(messages.in, 'in', field, options)\n      return\n    }\n  }\n)\n\n/**\n * Ensure the field's value under validation is not inside the pre-defined list.\n */\nexport const notInRule = createRule<{ list: string[] | ((field: FieldContext) => string[]) }>(\n  (value, options, field) => {\n    /**\n     * Skip if the field is not valid.\n     */", "    if (!field.isValid) {\n      return\n    }\n\n    const list = typeof options.list === 'function' ? options.list(field) : options.list\n\n    /**\n     * Performing validation and reporting error\n     */\n    if (list.includes(value as string)) {\n      field.report(messages.notIn, 'notIn', field, options)\n      return\n    }\n  }\n)\n\n/**\n * Validates the value to be a valid credit card number\n */\nexport const creditCardRule = createRule<\n  CreditCardOptions | undefined | ((field: FieldContext) => CreditCardOptions | void | undefined)\n>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "    if (list.includes(value as string)) {\n      field.report(messages.notIn, 'notIn', field, options)\n      return\n    }\n  }\n)\n\n/**\n * Validates the value to be a valid credit card number\n */\nexport const creditCardRule = createRule<\n  CreditCardOptions | undefined | ((field: FieldContext) => CreditCardOptions | void | undefined)\n>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  const providers = options\n    ? typeof options === 'function'\n      ? options(field)?.provider || []\n      : options.provider\n    : []\n\n  if (!providers.length) {", "  if (!providers.length) {\n    if (!helpers.isCreditCard(value as string)) {\n      field.report(messages.creditCard, 'creditCard', field, {\n        providersList: 'credit',\n      })\n    }\n  } else {\n    const matchesAnyProvider = providers.find((provider) =>\n      helpers.isCreditCard(value as string, { provider })\n    )\n", "    if (!matchesAnyProvider) {\n      field.report(messages.creditCard, 'creditCard', field, {\n        providers: providers,\n        providersList: providers.join('/'),\n      })\n    }\n  }\n})\n\n/**\n * Validates the value to be a valid passport number\n */\nexport const passportRule = createRule<\n  PassportOptions | ((field: FieldContext) => PassportOptions)\n>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  const countryCodes =\n    typeof options === 'function' ? options(field).countryCode : options.countryCode\n\n  const matchesAnyCountryCode = countryCodes.find((countryCode) =>\n    helpers.isPassportNumber(value as string, countryCode)\n  )\n  if (!matchesAnyCountryCode) {\n    field.report(messages.passport, 'passport', field, { countryCodes })\n  }\n})\n\n/**\n * Validates the value to be a valid postal code\n */\nexport const postalCodeRule = createRule<\n  PostalCodeOptions | undefined | ((field: FieldContext) => PostalCodeOptions | void | undefined)\n>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!matchesAnyCountryCode) {\n    field.report(messages.passport, 'passport', field, { countryCodes })\n  }\n})\n\n/**\n * Validates the value to be a valid postal code\n */\nexport const postalCodeRule = createRule<\n  PostalCodeOptions | undefined | ((field: FieldContext) => PostalCodeOptions | void | undefined)\n>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  const countryCodes = options\n    ? typeof options === 'function'\n      ? options(field)?.countryCode || []\n      : options.countryCode\n    : []\n\n  if (!countryCodes.length) {", "  if (!countryCodes.length) {\n    if (!helpers.isPostalCode(value as string, 'any')) {\n      field.report(messages.postalCode, 'postalCode', field)\n    }\n  } else {\n    const matchesAnyCountryCode = countryCodes.find((countryCode) =>\n      helpers.isPostalCode(value as string, countryCode)\n    )\n    if (!matchesAnyCountryCode) {\n      field.report(messages.postalCode, 'postalCode', field, { countryCodes })\n    }\n  }\n})\n\n/**\n * Validates the value to be a valid UUID\n */\nexport const uuidRule = createRule<{ version?: (1 | 2 | 3 | 4 | 5)[] } | undefined>(\n  (value, options, field) => {", "    if (!matchesAnyCountryCode) {\n      field.report(messages.postalCode, 'postalCode', field, { countryCodes })\n    }\n  }\n})\n\n/**\n * Validates the value to be a valid UUID\n */\nexport const uuidRule = createRule<{ version?: (1 | 2 | 3 | 4 | 5)[] } | undefined>(\n  (value, options, field) => {", "    if (!field.isValid) {\n      return\n    }\n\n    if (!options || !options.version) {\n      if (!helpers.isUUID(value as string)) {\n        field.report(messages.uuid, 'uuid', field)\n      }\n    } else {\n      const matchesAnyVersion = options.version.find((version) =>\n        helpers.isUUID(value as string, version)\n      )", "      if (!matchesAnyVersion) {\n        field.report(messages.uuid, 'uuid', field, options)\n      }\n    }\n  }\n)\n\n/**\n * Validates the value contains ASCII characters only\n */\nexport const asciiRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isAscii(value as string)) {\n    field.report(messages.ascii, 'ascii', field)\n  }\n})\n\n/**\n * Validates the value to be a valid IBAN number\n */\nexport const ibanRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isIBAN(value as string)) {\n    field.report(messages.iban, 'iban', field)\n  }\n})\n\n/**\n * Validates the value to be a valid JWT token\n */\nexport const jwtRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isJWT(value as string)) {\n    field.report(messages.jwt, 'jwt', field)\n  }\n})\n\n/**\n * Ensure the value is a string with latitude and longitude coordinates\n */\nexport const coordinatesRule = createRule((value, _, field) => {", "  if (!field.isValid) {\n    return\n  }\n\n  if (!helpers.isLatLong(value as string)) {\n    field.report(messages.coordinates, 'coordinates', field)\n  }\n})\n"]}
{"filename": "src/schema/union/conditional.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ConditionalFn, RefsStore, UnionNode } from '@vinejs/compiler/types'", "\nimport { ConditionalFn, RefsStore, UnionNode } from '@vinejs/compiler/types'\n\nimport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\nimport type { ParserOptions, SchemaTypes } from '../../types.js'\n\n/**\n * Represents a union conditional type. A conditional is a predicate\n * with a schema\n */\nexport class UnionConditional<Schema extends SchemaTypes> {\n  declare [OTYPE]: Schema[typeof OTYPE];\n  declare [COTYPE]: Schema[typeof COTYPE]\n\n  /**\n   * Properties to merge when conditonal is true\n   */\n  #schema: Schema\n\n  /**\n   * Conditional to evaluate\n   */\n  #conditional: ConditionalFn<Record<string, unknown>>\n\n  constructor(conditional: ConditionalFn<Record<string, unknown>>, schema: Schema) {\n    this.#schema = schema\n    this.#conditional = conditional\n  }\n\n  /**\n   * Compiles to a union conditional\n   */\n  [PARSE](\n    propertyName: string,\n    refs: RefsStore,\n    options: ParserOptions\n  ): UnionNode['conditions'][number] {\n    return {\n      conditionalFnRefId: refs.trackConditional(this.#conditional),\n      schema: this.#schema[PARSE](propertyName, refs, options),\n    }\n  }\n}\n", " * with a schema\n */\nexport class UnionConditional<Schema extends SchemaTypes> {\n  declare [OTYPE]: Schema[typeof OTYPE];\n  declare [COTYPE]: Schema[typeof COTYPE]\n\n  /**\n   * Properties to merge when conditonal is true\n   */\n  #schema: Schema\n\n  /**\n   * Conditional to evaluate\n   */\n  #conditional: ConditionalFn<Record<string, unknown>>\n\n  constructor(conditional: ConditionalFn<Record<string, unknown>>, schema: Schema) {\n    this.#schema = schema\n    this.#conditional = conditional\n  }\n\n  /**\n   * Compiles to a union conditional\n   */\n  [PARSE](\n    propertyName: string,\n    refs: RefsStore,\n    options: ParserOptions\n  ): UnionNode['conditions'][number] {\n    return {\n      conditionalFnRefId: refs.trackConditional(this.#conditional),\n      schema: this.#schema[PARSE](propertyName, refs, options),\n    }\n  }\n}\n"]}
{"filename": "src/schema/union/builder.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { VineUnion } from './main.js'", "\nimport { VineUnion } from './main.js'\nimport { UnionConditional } from './conditional.js'\nimport type { FieldContext, SchemaTypes } from '../../types.js'\n\n/**\n * Create a new union schema type. A union is a collection of conditionals\n * and schema associated with it.\n */\nexport function union<Conditional extends UnionConditional<any>>(conditionals: Conditional[]) {\n  return new VineUnion<Conditional>(conditionals)\n}\n\n/**\n * Wrap object properties inside a conditonal\n */", " */\nexport function union<Conditional extends UnionConditional<any>>(conditionals: Conditional[]) {\n  return new VineUnion<Conditional>(conditionals)\n}\n\n/**\n * Wrap object properties inside a conditonal\n */\nunion.if = function unionIf<Schema extends SchemaTypes>(\n  conditon: (value: Record<string, unknown>, field: FieldContext) => any,\n  schema: Schema\n) {\n  return new UnionConditional<Schema>(conditon, schema)\n}\n\n/**\n * Wrap object properties inside an else conditon\n */", "union.if = function unionIf<Schema extends SchemaTypes>(\n  conditon: (value: Record<string, unknown>, field: FieldContext) => any,\n  schema: Schema\n) {\n  return new UnionConditional<Schema>(conditon, schema)\n}\n\n/**\n * Wrap object properties inside an else conditon\n */\nunion.else = function unionElse<Schema extends SchemaTypes>(schema: Schema) {\n  return new UnionConditional<Schema>(() => true, schema)\n}\n", "union.else = function unionElse<Schema extends SchemaTypes>(schema: Schema) {\n  return new UnionConditional<Schema>(() => true, schema)\n}\n"]}
{"filename": "src/schema/union/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport { RefsStore, UnionNode } from '@vinejs/compiler/types'\n\nimport { messages } from '../../defaults.js'\nimport { UnionConditional } from './conditional.js'\nimport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\nimport type {\n  ConstructableSchema,\n  ParserOptions,", "  ConstructableSchema,\n  ParserOptions,\n  SchemaTypes,\n  UnionNoMatchCallback,\n} from '../../types.js'\n\n/**\n * Vine union represents a union data type. A union is a collection\n * of conditionals and each condition has an associated schema\n */\nexport class VineUnion<Conditional extends UnionConditional<SchemaTypes>>\n  implements ConstructableSchema<Conditional[typeof OTYPE], Conditional[typeof COTYPE]>\n{\n  declare [OTYPE]: Conditional[typeof OTYPE];\n  declare [COTYPE]: Conditional[typeof COTYPE]\n\n  #conditionals: Conditional[]\n  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n    field.report(messages.union, 'union', field)\n  }\n\n  constructor(conditionals: Conditional[]) {\n    this.#conditionals = conditionals\n  }\n\n  /**\n   * Define a fallback method to invoke when all of the union conditions\n   * fail. You may use this method to report an error.\n   */\n  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n    this.#otherwiseCallback = callback\n    return this\n  }\n\n  /**\n   * Clones the VineUnion schema type.\n   */\n  clone(): this {\n    const cloned = new VineUnion<Conditional>(this.#conditionals)\n    cloned.otherwise(this.#otherwiseCallback)\n\n    return cloned as this\n  }\n\n  /**\n   * Compiles to a union\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode {\n    return {\n      type: 'union',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n      conditions: this.#conditionals.map((conditional) =>\n        conditional[PARSE](propertyName, refs, options)\n      ),\n    }\n  }\n}\n", " * of conditionals and each condition has an associated schema\n */\nexport class VineUnion<Conditional extends UnionConditional<SchemaTypes>>\n  implements ConstructableSchema<Conditional[typeof OTYPE], Conditional[typeof COTYPE]>\n{\n  declare [OTYPE]: Conditional[typeof OTYPE];\n  declare [COTYPE]: Conditional[typeof COTYPE]\n\n  #conditionals: Conditional[]\n  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n    field.report(messages.union, 'union', field)\n  }\n\n  constructor(conditionals: Conditional[]) {\n    this.#conditionals = conditionals\n  }\n\n  /**\n   * Define a fallback method to invoke when all of the union conditions\n   * fail. You may use this method to report an error.\n   */\n  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n    this.#otherwiseCallback = callback\n    return this\n  }\n\n  /**\n   * Clones the VineUnion schema type.\n   */\n  clone(): this {\n    const cloned = new VineUnion<Conditional>(this.#conditionals)\n    cloned.otherwise(this.#otherwiseCallback)\n\n    return cloned as this\n  }\n\n  /**\n   * Compiles to a union\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode {\n    return {\n      type: 'union',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n      conditions: this.#conditionals.map((conditional) =>\n        conditional[PARSE](propertyName, refs, options)\n      ),\n    }\n  }\n}\n"]}
{"filename": "src/schema/literal/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { equalsRule } from './rules.js'", "\nimport { equalsRule } from './rules.js'\nimport { BaseLiteralType } from '../base/literal.js'\nimport type { FieldOptions, Validation } from '../../types.js'\n\n/**\n * VineLiteral represents a type that matches an exact value\n */\nexport class VineLiteral<Value> extends BaseLiteralType<Value, Value> {\n  /**\n   * Default collection of literal rules\n   */\n  static rules = {\n    equals: equalsRule,\n  }\n\n  #value: Value\n\n  constructor(value: Value, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations || [equalsRule({ expectedValue: value })])\n    this.#value = value\n  }\n\n  /**\n   * Clones the VineLiteral schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineLiteral(this.#value, this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n", "export class VineLiteral<Value> extends BaseLiteralType<Value, Value> {\n  /**\n   * Default collection of literal rules\n   */\n  static rules = {\n    equals: equalsRule,\n  }\n\n  #value: Value\n\n  constructor(value: Value, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations || [equalsRule({ expectedValue: value })])\n    this.#value = value\n  }\n\n  /**\n   * Clones the VineLiteral schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineLiteral(this.#value, this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/literal/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { messages } from '../../defaults.js'", "\nimport { messages } from '../../defaults.js'\nimport { helpers } from '../../vine/helpers.js'\nimport { createRule } from '../../vine/create_rule.js'\n\n/**\n * Verifies two equals are equal considering the HTML forms\n * serialization behavior.\n */\nexport const equalsRule = createRule<{ expectedValue: any }>((value, options, field) => {", " */\nexport const equalsRule = createRule<{ expectedValue: any }>((value, options, field) => {\n  let input = value\n\n  /**\n   * Normalizing the field value as per the expected\n   * value.\n   */\n  if (typeof options.expectedValue === 'boolean') {\n    input = helpers.asBoolean(value)\n  } else if (typeof options.expectedValue === 'number') {\n    input = helpers.asNumber(value)\n  }\n\n  /**\n   * Performing validation and reporting error\n   */", "  if (typeof options.expectedValue === 'boolean') {\n    input = helpers.asBoolean(value)\n  } else if (typeof options.expectedValue === 'number') {\n    input = helpers.asNumber(value)\n  }\n\n  /**\n   * Performing validation and reporting error\n   */\n  if (input !== options.expectedValue) {\n    field.report(messages.literal, 'literal', field, options)\n    return\n  }\n\n  /**\n   * Mutating input with normalized value\n   */\n  field.mutate(input, field)\n})\n", "  if (input !== options.expectedValue) {\n    field.report(messages.literal, 'literal', field, options)\n    return\n  }\n\n  /**\n   * Mutating input with normalized value\n   */\n  field.mutate(input, field)\n})\n"]}
{"filename": "src/schema/enum/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { enumRule } from './rules.js'", "\nimport { enumRule } from './rules.js'\nimport { BaseLiteralType } from '../base/literal.js'\nimport type { FieldContext, FieldOptions, Validation } from '../../types.js'\n\n/**\n * VineEnum represents a enum data type that performs validation\n * against a pre-defined choices list.\n */\nexport class VineEnum<const Values extends readonly unknown[]> extends BaseLiteralType<\n  Values[number],\n  Values[number]\n> {\n  /**", "export class VineEnum<const Values extends readonly unknown[]> extends BaseLiteralType<\n  Values[number],\n  Values[number]\n> {\n  /**\n   * Default collection of enum rules\n   */\n  static rules = {\n    enum: enumRule,\n  }\n\n  #values: Values | ((field: FieldContext) => Values)\n\n  /**", "   * Returns the enum choices\n   */\n  getChoices() {\n    return this.#values\n  }\n\n  constructor(\n    values: Values | ((field: FieldContext) => Values),\n    options?: FieldOptions,\n    validations?: Validation<any>[]\n  ) {\n    super(options, validations || [enumRule({ choices: values })])\n    this.#values = values\n  }\n\n  /**\n   * Clones the VineEnum schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineEnum(this.#values, this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/enum/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { createRule } from '../../vine/create_rule.js'", "\nimport { createRule } from '../../vine/create_rule.js'\nimport { messages } from '../../defaults.js'\nimport { FieldContext } from '@vinejs/compiler/types'\n\n/**\n * Enum rule is used to validate the field's value to be one\n * from the pre-defined choices.\n */\nexport const enumRule = createRule<{", " */\nexport const enumRule = createRule<{\n  choices: readonly any[] | ((field: FieldContext) => readonly any[])\n}>((value, options, field) => {\n  const choices = typeof options.choices === 'function' ? options.choices(field) : options.choices\n\n  /**\n   * Report error when value is not part of the pre-defined\n   * options\n   */\n  if (!choices.includes(value)) {\n    field.report(messages.enum, 'enum', field, { choices })\n  }\n})\n", "   * options\n   */\n  if (!choices.includes(value)) {\n    field.report(messages.enum, 'enum', field, { choices })\n  }\n})\n"]}
{"filename": "src/schema/enum/native_enum.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { enumRule } from './rules.js'", "\nimport { enumRule } from './rules.js'\nimport { BaseLiteralType } from '../base/literal.js'\nimport type { EnumLike, FieldOptions, Validation } from '../../types.js'\n\n/**\n * VineNativeEnum represents a enum data type that performs validation\n * against a pre-defined choices list.\n *\n * The choices list is derived from TypeScript enum data type or an\n * object\n */", " * The choices list is derived from TypeScript enum data type or an\n * object\n */\nexport class VineNativeEnum<Values extends EnumLike> extends BaseLiteralType<\n  Values[keyof Values],\n  Values[keyof Values]\n> {\n  /**\n   * Default collection of enum rules\n   */\n  static rules = {\n    enum: enumRule,\n  }\n\n  #values: Values\n\n  constructor(values: Values, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations || [enumRule({ choices: Object.values(values) })])\n    this.#values = values\n  }\n\n  /**\n   * Clones the VineNativeEnum schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineNativeEnum(this.#values, this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n", "   * Default collection of enum rules\n   */\n  static rules = {\n    enum: enumRule,\n  }\n\n  #values: Values\n\n  constructor(values: Values, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations || [enumRule({ choices: Object.values(values) })])\n    this.#values = values\n  }\n\n  /**\n   * Clones the VineNativeEnum schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineNativeEnum(this.#values, this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/any/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { BaseLiteralType } from '../base/literal.js'", "\nimport { BaseLiteralType } from '../base/literal.js'\nimport type { FieldOptions, Validation } from '../../types.js'\n\n/**\n * VineAny represents a value that can be anything\n */\nexport class VineAny extends BaseLiteralType<any, any> {\n  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n    super(options, validations)\n  }\n\n  /**\n   * Clones the VineAny schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineAny(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/number/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { helpers } from '../../vine/helpers.js'", "\nimport { helpers } from '../../vine/helpers.js'\nimport { BaseLiteralType } from '../base/literal.js'\nimport { FieldOptions, Validation } from '../../types.js'\nimport { IS_OF_TYPE, UNIQUE_NAME } from '../../symbols.js'\n\nimport {\n  maxRule,\n  minRule,\n  rangeRule,", "  minRule,\n  rangeRule,\n  numberRule,\n  decimalRule,\n  negativeRule,\n  positiveRule,\n  withoutDecimalsRule,\n} from './rules.js'\n\n/**", "\n/**\n * VineNumber represents a numeric value in the validation schema.\n */\nexport class VineNumber extends BaseLiteralType<number, number> {\n  protected declare options: FieldOptions & { strict?: boolean }\n\n  /**\n   * Default collection of number rules\n   */\n  static rules = {\n    max: maxRule,\n    min: minRule,\n    range: rangeRule,\n    number: numberRule,\n    decimal: decimalRule,\n    negative: negativeRule,\n    positive: positiveRule,\n    withoutDecimals: withoutDecimalsRule,\n  };\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.number';\n\n  /**\n   * Checks if the value is of number type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    const valueAsNumber = helpers.asNumber(value)\n    return !Number.isNaN(valueAsNumber)\n  }\n\n  constructor(\n    options?: Partial<FieldOptions> & { strict?: boolean },\n    validations?: Validation<any>[]\n  ) {\n    super(options, validations || [numberRule(options || {})])\n  }\n\n  /**\n   * Enforce a minimum value for the number input\n   */\n  min(value: number) {\n    return this.use(minRule({ min: value }))\n  }\n\n  /**\n   * Enforce a maximum value for the number input\n   */\n  max(value: number) {\n    return this.use(maxRule({ max: value }))\n  }\n\n  /**\n   * Enforce value to be within the range of minimum and maximum output.\n   */\n  range(value: [min: number, max: number]) {\n    return this.use(rangeRule({ min: value[0], max: value[1] }))\n  }\n\n  /**\n   * Enforce the value be a positive number\n   */\n  positive() {\n    return this.use(positiveRule())\n  }\n\n  /**\n   * Enforce the value be a negative number\n   */\n  negative() {\n    return this.use(negativeRule())\n  }\n\n  /**\n   * Enforce the value to have fixed or range\n   * of decimal places\n   */\n  decimal(range: number | [number, number]) {\n    return this.use(decimalRule({ range: Array.isArray(range) ? range : [range] }))\n  }\n\n  /**\n   * Enforce the value to be an integer (aka without decimals)\n   */\n  withoutDecimals() {\n    return this.use(withoutDecimalsRule())\n  }\n\n  /**\n   * Clones the VineNumber schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineNumber(this.cloneOptions(), this.cloneValidations()) as this\n  }\n}\n"]}
{"filename": "src/schema/number/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { helpers } from '../../vine/helpers.js'", "\nimport { helpers } from '../../vine/helpers.js'\nimport { createRule } from '../../vine/create_rule.js'\nimport { messages } from '../../defaults.js'\n\n/**\n * Enforce the value to be a number or a string representation\n * of a number\n */\nexport const numberRule = createRule<{ strict?: boolean }>((value, options, field) => {", " */\nexport const numberRule = createRule<{ strict?: boolean }>((value, options, field) => {\n  const valueAsNumber = options.strict ? value : helpers.asNumber(value)\n\n  if (\n    typeof valueAsNumber !== 'number' ||\n    Number.isNaN(valueAsNumber) ||\n    valueAsNumber === Number.POSITIVE_INFINITY ||\n    valueAsNumber === Number.NEGATIVE_INFINITY\n  ) {\n    field.report(messages.number, 'number', field)\n    return\n  }\n\n  field.mutate(valueAsNumber, field)\n})\n\n/**\n * Enforce a minimum value on a number field\n */\nexport const minRule = createRule<{ min: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as number) < options.min) {\n    field.report(messages.min, 'min', field, options)\n  }\n})\n\n/**\n * Enforce a maximum value on a number field\n */\nexport const maxRule = createRule<{ max: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as number) > options.max) {\n    field.report(messages.max, 'max', field, options)\n  }\n})\n\n/**\n * Enforce a range of values on a number field.\n */\nexport const rangeRule = createRule<{ min: number; max: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as number) < options.min || (value as number) > options.max) {\n    field.report(messages.range, 'range', field, options)\n  }\n})\n\n/**\n * Enforce the value is a positive number\n */\nexport const positiveRule = createRule((value, _, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as number) < 0) {\n    field.report(messages.positive, 'positive', field)\n  }\n})\n\n/**\n * Enforce the value is a negative number\n */\nexport const negativeRule = createRule<undefined>((value, _, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if ((value as number) >= 0) {\n    field.report(messages.negative, 'negative', field)\n  }\n})\n\n/**\n * Enforce the value to have a fixed or range of decimals\n */\nexport const decimalRule = createRule<{ range: [number, number?] }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if (\n    !helpers.isDecimal(String(value), {\n      force_decimal: options.range[0] !== 0,\n      decimal_digits: options.range.join(','),\n    })\n  ) {\n    field.report(messages.decimal, 'decimal', field, { digits: options.range.join('-') })\n  }\n})\n\n/**\n * Enforce the value to not have decimal places\n */\nexport const withoutDecimalsRule = createRule((value, _, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  if (!Number.isInteger(value)) {\n    field.report(messages.withoutDecimals, 'withoutDecimals', field)\n  }\n})\n"]}
{"filename": "src/schema/record/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport { RefsStore, RecordNode } from '@vinejs/compiler/types'\n\nimport { BaseType } from '../base/main.js'\nimport { OTYPE, COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js'\nimport type { FieldOptions, ParserOptions, SchemaTypes, Validation } from '../../types.js'\nimport { fixedLengthRule, maxLengthRule, minLengthRule, validateKeysRule } from './rules.js'\n\n/**", "\n/**\n * VineRecord represents an object of key-value pair in which\n * keys are unknown\n */\nexport class VineRecord<Schema extends SchemaTypes> extends BaseType<\n  { [K: string]: Schema[typeof OTYPE] },\n  { [K: string]: Schema[typeof COTYPE] }\n> {\n  /**\n   * Default collection of record rules\n   */\n  static rules = {\n    maxLength: maxLengthRule,\n    minLength: minLengthRule,\n    fixedLength: fixedLengthRule,\n    validateKeys: validateKeysRule,\n  }\n\n  #schema: Schema;\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.object';\n\n  /**\n   * Checks if the value is of object type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    return value !== null && typeof value === 'object' && !Array.isArray(value)\n  }\n\n  constructor(schema: Schema, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations)\n    this.#schema = schema\n  }\n\n  /**\n   * Enforce a minimum length on an object field\n   */\n  minLength(expectedLength: number) {\n    return this.use(minLengthRule({ min: expectedLength }))\n  }\n\n  /**\n   * Enforce a maximum length on an object field\n   */\n  maxLength(expectedLength: number) {\n    return this.use(maxLengthRule({ max: expectedLength }))\n  }\n\n  /**\n   * Enforce a fixed length on an object field\n   */\n  fixedLength(expectedLength: number) {\n    return this.use(fixedLengthRule({ size: expectedLength }))\n  }\n\n  /**\n   * Register a callback to validate the object keys\n   */\n  validateKeys(...args: Parameters<typeof validateKeysRule>) {\n    return this.use(validateKeysRule(...args))\n  }\n\n  /**\n   * Clones the VineRecord schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineRecord(\n      this.#schema.clone(),\n      this.cloneOptions(),\n      this.cloneValidations()\n    ) as this\n  }\n\n  /**\n   * Compiles to record data type\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): RecordNode {\n    return {\n      type: 'record',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      bail: this.options.bail,\n      allowNull: this.options.allowNull,\n      isOptional: this.options.isOptional,\n      each: this.#schema[PARSE]('*', refs, options),\n      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n      validations: this.compileValidations(refs),\n    }\n  }\n}\n"]}
{"filename": "src/schema/record/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { FieldContext } from '@vinejs/compiler/types'", "\nimport { FieldContext } from '@vinejs/compiler/types'\nimport { messages } from '../../defaults.js'\nimport { createRule } from '../../vine/create_rule.js'\n\n/**\n * Enforce a minimum length on an object field\n */\nexport const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n  /**", "export const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */\n  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an object if the field is valid.\n   */", "  if (Object.keys(value as Record<string, any>).length < options.min) {\n    field.report(messages['record.minLength'], 'record.minLength', field, options)\n  }\n})\n\n/**\n * Enforce a maximum length on an object field\n */\nexport const maxLengthRule = createRule<{ max: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an object if the field is valid.\n   */\n  if (Object.keys(value as Record<string, any>).length > options.max) {\n    field.report(messages['record.maxLength'], 'record.maxLength', field, options)\n  }\n})\n\n/**\n * Enforce a fixed length on an object field\n */\nexport const fixedLengthRule = createRule<{ size: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an object if the field is valid.\n   */\n  if (Object.keys(value as Record<string, any>).length !== options.size) {\n    field.report(messages['record.fixedLength'], 'record.fixedLength', field, options)\n  }\n})\n\n/**\n * Register a callback to validate the object keys\n */\nexport const validateKeysRule = createRule<(keys: string[], field: FieldContext) => void>(\n  (value, callback, field) => {\n    /**\n     * Skip if the field is not valid.\n     */", "    if (!field.isValid) {\n      return\n    }\n\n    callback(Object.keys(value as Record<string, any>), field)\n  }\n)\n"]}
{"filename": "src/schema/array/main.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport { RefsStore, ArrayNode } from '@vinejs/compiler/types'\n\nimport { BaseType } from '../base/main.js'\nimport { OTYPE, COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js'\nimport type { FieldOptions, ParserOptions, SchemaTypes, Validation } from '../../types.js'\n\nimport {\n  compactRule,", "import {\n  compactRule,\n  notEmptyRule,\n  distinctRule,\n  minLengthRule,\n  maxLengthRule,\n  fixedLengthRule,\n} from './rules.js'\n\n/**\n * VineArray represents an array schema type in the validation\n * pipeline\n */", "\n/**\n * VineArray represents an array schema type in the validation\n * pipeline\n */\nexport class VineArray<Schema extends SchemaTypes> extends BaseType<\n  Schema[typeof OTYPE][],\n  Schema[typeof COTYPE][]\n> {\n  /**\n   * Default collection of array rules\n   */\n  static rules = {\n    compact: compactRule,\n    notEmpty: notEmptyRule,\n    distinct: distinctRule,\n    minLength: minLengthRule,\n    maxLength: maxLengthRule,\n    fixedLength: fixedLengthRule,\n  }\n\n  #schema: Schema;\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.array';\n\n  /**\n   * Checks if the value is of array type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    return Array.isArray(value)\n  }\n\n  constructor(schema: Schema, options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations)\n    this.#schema = schema\n  }\n\n  /**\n   * Enforce a minimum length on an array field\n   */\n  minLength(expectedLength: number) {\n    return this.use(minLengthRule({ min: expectedLength }))\n  }\n\n  /**\n   * Enforce a maximum length on an array field\n   */\n  maxLength(expectedLength: number) {\n    return this.use(maxLengthRule({ max: expectedLength }))\n  }\n\n  /**\n   * Enforce a fixed length on an array field\n   */\n  fixedLength(expectedLength: number) {\n    return this.use(fixedLengthRule({ size: expectedLength }))\n  }\n\n  /**\n   * Ensure the array is not empty\n   */\n  notEmpty() {\n    return this.use(notEmptyRule())\n  }\n\n  /**\n   * Ensure array elements are distinct/unique\n   */\n  distinct(fields?: string | string[]) {\n    return this.use(distinctRule({ fields }))\n  }\n\n  /**\n   * Removes empty strings, null and undefined values from the array\n   */\n  compact() {\n    return this.use(compactRule())\n  }\n\n  /**\n   * Clones the VineArray schema type. The applied options\n   * and validations are copied to the new instance\n   */\n  clone(): this {\n    return new VineArray(this.#schema.clone(), this.cloneOptions(), this.cloneValidations()) as this\n  }\n\n  /**\n   * Compiles to array data type\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ArrayNode {\n    return {\n      type: 'array',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      bail: this.options.bail,\n      allowNull: this.options.allowNull,\n      isOptional: this.options.isOptional,\n      each: this.#schema[PARSE]('*', refs, options),\n      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n      validations: this.compileValidations(refs),\n    }\n  }\n}\n"]}
{"filename": "src/schema/array/rules.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { helpers } from '../../vine/helpers.js'", "\nimport { helpers } from '../../vine/helpers.js'\nimport { messages } from '../../defaults.js'\nimport { createRule } from '../../vine/create_rule.js'\n\n/**\n * Enforce a minimum length on an array field\n */\nexport const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n  /**", "export const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */\n  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an array if the field is valid.\n   */", "  if ((value as unknown[]).length < options.min) {\n    field.report(messages['array.minLength'], 'array.minLength', field, options)\n  }\n})\n\n/**\n * Enforce a maximum length on an array field\n */\nexport const maxLengthRule = createRule<{ max: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an array if the field is valid.\n   */\n  if ((value as unknown[]).length > options.max) {\n    field.report(messages['array.maxLength'], 'array.maxLength', field, options)\n  }\n})\n\n/**\n * Enforce a fixed length on an array field\n */\nexport const fixedLengthRule = createRule<{ size: number }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an array if the field is valid.\n   */\n  if ((value as unknown[]).length !== options.size) {\n    field.report(messages['array.fixedLength'], 'array.fixedLength', field, options)\n  }\n})\n\n/**\n * Ensure the array is not empty\n */\nexport const notEmptyRule = createRule<undefined>((value, _, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an array if the field is valid.\n   */\n  if ((value as unknown[]).length <= 0) {\n    field.report(messages.notEmpty, 'notEmpty', field)\n  }\n})\n\n/**\n * Ensure array elements are distinct/unique\n */\nexport const distinctRule = createRule<{ fields?: string | string[] }>((value, options, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  /**\n   * Value will always be an array if the field is valid.\n   */\n  if (!helpers.isDistinct(value as any[], options.fields)) {\n    field.report(messages.distinct, 'distinct', field, options)\n  }\n})\n\n/**\n * Removes empty strings, null and undefined values from the array\n */\nexport const compactRule = createRule<undefined>((value, _, field) => {\n  /**\n   * Skip if the field is not valid.\n   */", "  if (!field.isValid) {\n    return\n  }\n\n  field.mutate(\n    (value as unknown[]).filter((item) => helpers.exists(item) && item !== ''),\n    field\n  )\n})\n"]}
{"filename": "src/schema/base/literal.ts", "chunked_list": ["/*\n * vinejs\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport Macroable from '@poppinss/macroable'\nimport type { LiteralNode, RefsStore } from '@vinejs/compiler/types'\n\nimport { OTYPE, COTYPE, PARSE, VALIDATION } from '../../symbols.js'\nimport type {\n  Parser,\n  Validation,\n  RuleBuilder,", "  Validation,\n  RuleBuilder,\n  Transformer,\n  FieldOptions,\n  ParserOptions,\n  ConstructableSchema,\n} from '../../types.js'\n\n/**\n * Base schema type with only modifiers applicable on all the schema types.\n */", "/**\n * Base schema type with only modifiers applicable on all the schema types.\n */\nabstract class BaseModifiersType<Output, CamelCaseOutput>\n  extends Macroable\n  implements ConstructableSchema<Output, CamelCaseOutput>\n{\n  /**\n   * Each subtype should implement the compile method that returns\n   * one of the known compiler nodes\n   */\n  abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode\n\n  /**", "   * The child class must implement the clone method\n   */\n  abstract clone(): this\n\n  /**\n   * The output value of the field. The property points to a type only\n   * and not the real value.\n   */\n  declare [OTYPE]: Output;\n  declare [COTYPE]: CamelCaseOutput\n\n  /**\n   * Mark the field under validation as optional. An optional\n   * field allows both null and undefined values.\n   */\n  optional(): OptionalModifier<this> {\n    return new OptionalModifier(this)\n  }\n\n  /**\n   * Mark the field under validation to be null. The null value will\n   * be written to the output as well.\n   *\n   * If `optional` and `nullable` are used together, then both undefined\n   * and null values will be allowed.\n   */\n  nullable(): NullableModifier<this> {\n    return new NullableModifier(this)\n  }\n\n  /**\n   * Apply transform on the final validated value. The transform method may\n   * convert the value to any new datatype.\n   */\n  transform<TransformedOutput>(\n    transformer: Transformer<this, TransformedOutput>\n  ): TransformModifier<this, TransformedOutput> {\n    return new TransformModifier(transformer, this)\n  }\n}\n\n/**", " * Modifies the schema type to allow null values\n */\nclass NullableModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n  Schema[typeof OTYPE] | null,\n  Schema[typeof COTYPE] | null\n> {\n  #parent: Schema\n  constructor(parent: Schema) {\n    super()\n    this.#parent = parent\n  }\n\n  /**\n   * Creates a fresh instance of the underlying schema type\n   * and wraps it inside the nullable modifier\n   */\n  clone(): this {\n    return new NullableModifier(this.#parent.clone()) as this\n  }\n\n  /**\n   * Compiles to compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n    const output = this.#parent[PARSE](propertyName, refs, options)\n    output.allowNull = true\n    return output\n  }\n}\n\n/**", " * Modifies the schema type to allow undefined values\n */\nclass OptionalModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n  Schema[typeof OTYPE] | undefined,\n  Schema[typeof COTYPE] | undefined\n> {\n  #parent: Schema\n  constructor(parent: Schema) {\n    super()\n    this.#parent = parent\n  }\n\n  /**\n   * Creates a fresh instance of the underlying schema type\n   * and wraps it inside the optional modifier\n   */\n  clone(): this {\n    return new OptionalModifier(this.#parent.clone()) as this\n  }\n\n  /**\n   * Compiles to compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n    const output = this.#parent[PARSE](propertyName, refs, options)\n    output.isOptional = true\n    return output\n  }\n}\n\n/**", " * Modifies the schema type to allow custom transformed values\n */\nclass TransformModifier<\n  Schema extends BaseModifiersType<any, any>,\n  Output,\n> extends BaseModifiersType<Output, Output> {\n  /**\n   * The output value of the field. The property points to a type only\n   * and not the real value.\n   */\n  declare [OTYPE]: Output;\n  declare [COTYPE]: Output\n\n  #parent: Schema\n  #transform: Transformer<Schema, Output>\n\n  constructor(transform: Transformer<Schema, Output>, parent: Schema) {\n    super()\n    this.#transform = transform\n    this.#parent = parent\n  }\n\n  /**\n   * Creates a fresh instance of the underlying schema type\n   * and wraps it inside the transform modifier.\n   */\n  clone(): this {\n    return new TransformModifier(this.#transform, this.#parent.clone()) as this\n  }\n\n  /**\n   * Compiles to compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n    const output = this.#parent[PARSE](propertyName, refs, options)\n    output.transformFnId = refs.trackTransformer(this.#transform)\n    return output\n  }\n}\n\n/**", " * The base type for creating a custom literal type. Literal type\n * is a schema type that has no children elements.\n */\nexport abstract class BaseLiteralType<Output, CamelCaseOutput> extends BaseModifiersType<\n  Output,\n  CamelCaseOutput\n> {\n  /**\n   * The child class must implement the clone method\n   */\n  abstract clone(): this\n\n  /**\n   * Field options\n   */\n  protected options: FieldOptions\n\n  /**\n   * Set of validations to run\n   */\n  protected validations: Validation<any>[]\n\n  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n    super()\n    this.options = {\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      ...options,\n    }\n\n    this.validations = validations || []\n  }\n\n  /**\n   * Shallow clones the validations. Since, there are no API's to mutate\n   * the validation options, we can safely copy them by reference.\n   */\n  protected cloneValidations(): Validation<any>[] {\n    return this.validations.map((validation) => {\n      return {\n        options: validation.options,\n        rule: validation.rule,\n      }\n    })\n  }\n\n  /**\n   * Shallow clones the options\n   */\n  protected cloneOptions(): FieldOptions {\n    return { ...this.options }\n  }\n\n  /**\n   * Compiles validations\n   */\n  protected compileValidations(refs: RefsStore) {\n    return this.validations.map((validation) => {\n      return {\n        ruleFnId: refs.track({\n          validator: validation.rule.validator,\n          options: validation.options,\n        }),\n        implicit: validation.rule.implicit,\n        isAsync: validation.rule.isAsync,\n      }\n    })\n  }\n\n  /**\n   * Define a method to parse the input value. The method\n   * is invoked before any validation and hence you must\n   * perform type-checking to know the value you are\n   * working it.\n   */\n  parse(callback: Parser): this {\n    this.options.parse = callback\n    return this\n  }\n\n  /**\n   * Push a validation to the validations chain.\n   */\n  use(validation: Validation<any> | RuleBuilder): this {\n    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation)\n    return this\n  }\n\n  /**\n   * Enable/disable the bail mode. In bail mode, the field validations\n   * are stopped after the first error.\n   */\n  bail(state: boolean) {\n    this.options.bail = state\n    return this\n  }\n\n  /**", "   * The child class must implement the clone method\n   */\n  abstract clone(): this\n\n  /**\n   * Field options\n   */\n  protected options: FieldOptions\n\n  /**\n   * Set of validations to run\n   */\n  protected validations: Validation<any>[]\n\n  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n    super()\n    this.options = {\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n      ...options,\n    }\n\n    this.validations = validations || []\n  }\n\n  /**\n   * Shallow clones the validations. Since, there are no API's to mutate\n   * the validation options, we can safely copy them by reference.\n   */\n  protected cloneValidations(): Validation<any>[] {\n    return this.validations.map((validation) => {\n      return {\n        options: validation.options,\n        rule: validation.rule,\n      }\n    })\n  }\n\n  /**\n   * Shallow clones the options\n   */\n  protected cloneOptions(): FieldOptions {\n    return { ...this.options }\n  }\n\n  /**\n   * Compiles validations\n   */\n  protected compileValidations(refs: RefsStore) {\n    return this.validations.map((validation) => {\n      return {\n        ruleFnId: refs.track({\n          validator: validation.rule.validator,\n          options: validation.options,\n        }),\n        implicit: validation.rule.implicit,\n        isAsync: validation.rule.isAsync,\n      }\n    })\n  }\n\n  /**\n   * Define a method to parse the input value. The method\n   * is invoked before any validation and hence you must\n   * perform type-checking to know the value you are\n   * working it.\n   */\n  parse(callback: Parser): this {\n    this.options.parse = callback\n    return this\n  }\n\n  /**\n   * Push a validation to the validations chain.\n   */\n  use(validation: Validation<any> | RuleBuilder): this {\n    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation)\n    return this\n  }\n\n  /**\n   * Enable/disable the bail mode. In bail mode, the field validations\n   * are stopped after the first error.\n   */\n  bail(state: boolean) {\n    this.options.bail = state\n    return this\n  }\n\n  /**", "   * Compiles the schema type to a compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n    return {\n      type: 'literal',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      bail: this.options.bail,\n      allowNull: this.options.allowNull,\n      isOptional: this.options.isOptional,\n      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n      validations: this.compileValidations(refs),\n    }\n  }\n}\n"]}
{"filename": "src/schema/base/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CompilerNodes, RefsStore } from '@vinejs/compiler/types'", "\nimport type { CompilerNodes, RefsStore } from '@vinejs/compiler/types'\n\nimport { OTYPE, COTYPE, PARSE, VALIDATION } from '../../symbols.js'\nimport type {\n  Parser,\n  Validation,\n  RuleBuilder,\n  FieldOptions,\n  ParserOptions,", "  FieldOptions,\n  ParserOptions,\n  ConstructableSchema,\n} from '../../types.js'\nimport Macroable from '@poppinss/macroable'\n\n/**\n * Base schema type with only modifiers applicable on all the schema types.\n */\nexport abstract class BaseModifiersType<Output, CamelCaseOutput>\n  extends Macroable\n  implements ConstructableSchema<Output, CamelCaseOutput>\n{\n  /**\n   * Each subtype should implement the compile method that returns\n   * one of the known compiler nodes\n   */\n  abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes\n\n  /**", "export abstract class BaseModifiersType<Output, CamelCaseOutput>\n  extends Macroable\n  implements ConstructableSchema<Output, CamelCaseOutput>\n{\n  /**\n   * Each subtype should implement the compile method that returns\n   * one of the known compiler nodes\n   */\n  abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes\n\n  /**", "   * The child class must implement the clone method\n   */\n  abstract clone(): this\n\n  /**\n   * The output value of the field. The property points to a type only\n   * and not the real value.\n   */\n  declare [OTYPE]: Output;\n  declare [COTYPE]: CamelCaseOutput\n\n  /**\n   * Mark the field under validation as optional. An optional\n   * field allows both null and undefined values.\n   */\n  optional(): OptionalModifier<this> {\n    return new OptionalModifier(this)\n  }\n\n  /**\n   * Mark the field under validation to be null. The null value will\n   * be written to the output as well.\n   *\n   * If `optional` and `nullable` are used together, then both undefined\n   * and null values will be allowed.\n   */\n  nullable(): NullableModifier<this> {\n    return new NullableModifier(this)\n  }\n}\n\n/**", " * Modifies the schema type to allow null values\n */\nclass NullableModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n  Schema[typeof OTYPE] | null,\n  Schema[typeof COTYPE] | null\n> {\n  #parent: Schema\n  constructor(parent: Schema) {\n    super()\n    this.#parent = parent\n  }\n\n  /**\n   * Creates a fresh instance of the underlying schema type\n   * and wraps it inside the nullable modifier\n   */\n  clone(): this {\n    return new NullableModifier(this.#parent.clone()) as this\n  }\n\n  /**\n   * Compiles to compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes {\n    const output = this.#parent[PARSE](propertyName, refs, options)", "    if (output.type !== 'union') {\n      output.allowNull = true\n    }\n\n    return output\n  }\n}\n\n/**\n * Modifies the schema type to allow undefined values\n */", " * Modifies the schema type to allow undefined values\n */\nclass OptionalModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n  Schema[typeof OTYPE] | undefined,\n  Schema[typeof COTYPE] | undefined\n> {\n  #parent: Schema\n  constructor(parent: Schema) {\n    super()\n    this.#parent = parent\n  }\n\n  /**\n   * Creates a fresh instance of the underlying schema type\n   * and wraps it inside the optional modifier\n   */\n  clone(): this {\n    return new OptionalModifier(this.#parent.clone()) as this\n  }\n\n  /**\n   * Compiles to compiler node\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes {\n    const output = this.#parent[PARSE](propertyName, refs, options)", "    if (output.type !== 'union') {\n      output.isOptional = true\n    }\n\n    return output\n  }\n}\n\n/**\n * The BaseSchema class abstracts the repetitive parts of creating\n * a custom schema type.\n */", " * The BaseSchema class abstracts the repetitive parts of creating\n * a custom schema type.\n */\nexport abstract class BaseType<Output, CamelCaseOutput> extends BaseModifiersType<\n  Output,\n  CamelCaseOutput\n> {\n  /**\n   * Field options\n   */\n  protected options: FieldOptions\n\n  /**\n   * Set of validations to run\n   */\n  protected validations: Validation<any>[]\n\n  constructor(options?: FieldOptions, validations?: Validation<any>[]) {\n    super()\n    this.options = options || {\n      bail: true,\n      allowNull: false,\n      isOptional: false,\n    }\n\n    this.validations = validations || []\n  }\n\n  /**\n   * Shallow clones the validations. Since, there are no API's to mutate\n   * the validation options, we can safely copy them by reference.\n   */\n  protected cloneValidations(): Validation<any>[] {\n    return this.validations.map((validation) => {\n      return {\n        options: validation.options,\n        rule: validation.rule,\n      }\n    })\n  }\n\n  /**\n   * Shallow clones the options\n   */\n  protected cloneOptions(): FieldOptions {\n    return { ...this.options }\n  }\n\n  /**\n   * Compiles validations\n   */\n  protected compileValidations(refs: RefsStore) {\n    return this.validations.map((validation) => {\n      return {\n        ruleFnId: refs.track({\n          validator: validation.rule.validator,\n          options: validation.options,\n        }),\n        implicit: validation.rule.implicit,\n        isAsync: validation.rule.isAsync,\n      }\n    })\n  }\n\n  /**\n   * Define a method to parse the input value. The method\n   * is invoked before any validation and hence you must\n   * perform type-checking to know the value you are\n   * working it.\n   */\n  parse(callback: Parser): this {\n    this.options.parse = callback\n    return this\n  }\n\n  /**\n   * Push a validation to the validations chain.\n   */\n  use(validation: Validation<any> | RuleBuilder): this {\n    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation)\n    return this\n  }\n\n  /**\n   * Enable/disable the bail mode. In bail mode, the field validations\n   * are stopped after the first error.\n   */\n  bail(state: boolean) {\n    this.options.bail = state\n    return this\n  }\n}\n"]}
{"filename": "src/schema/tuple/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport camelcase from 'camelcase'", "\nimport camelcase from 'camelcase'\nimport { RefsStore, TupleNode } from '@vinejs/compiler/types'\n\nimport { BaseType } from '../base/main.js'\nimport { IS_OF_TYPE, PARSE, UNIQUE_NAME } from '../../symbols.js'\nimport type { FieldOptions, ParserOptions, SchemaTypes, Validation } from '../../types.js'\n\n/**\n * VineTuple is an array with known length and may have different\n * schema type for each array element.\n */", "/**\n * VineTuple is an array with known length and may have different\n * schema type for each array element.\n */\nexport class VineTuple<\n  Schema extends SchemaTypes[],\n  Output extends any[],\n  CamelCaseOutput extends any[],\n> extends BaseType<Output, CamelCaseOutput> {\n  #schemas: [...Schema]\n\n  /**\n   * Whether or not to allow unknown properties\n   */\n  #allowUnknownProperties: boolean = false;\n\n  /**\n   * The property must be implemented for \"unionOfTypes\"\n   */\n  [UNIQUE_NAME] = 'vine.array';\n\n  /**\n   * Checks if the value is of array type. The method must be\n   * implemented for \"unionOfTypes\"\n   */\n  [IS_OF_TYPE] = (value: unknown) => {\n    return Array.isArray(value)\n  }\n\n  constructor(schemas: [...Schema], options?: FieldOptions, validations?: Validation<any>[]) {\n    super(options, validations)\n    this.#schemas = schemas\n  }\n\n  /**\n   * Copy unknown properties to the final output.\n   */\n  allowUnknownProperties<Value>(): VineTuple<\n    Schema,\n    [...Output, ...Value[]],\n    [...CamelCaseOutput, ...Value[]]\n  > {\n    this.#allowUnknownProperties = true\n    return this as unknown as VineTuple<\n      Schema,\n      [...Output, ...Value[]],\n      [...CamelCaseOutput, ...Value[]]\n    >\n  }\n\n  /**\n   * Clone object\n   */\n  clone(): this {\n    const cloned = new VineTuple<Schema, Output, CamelCaseOutput>(\n      this.#schemas.map((schema) => schema.clone()) as Schema,\n      this.cloneOptions(),\n      this.cloneValidations()\n    )\n", "    if (this.#allowUnknownProperties) {\n      cloned.allowUnknownProperties()\n    }\n\n    return cloned as this\n  }\n\n  /**\n   * Compiles to array data type\n   */\n  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): TupleNode {\n    return {\n      type: 'tuple',\n      fieldName: propertyName,\n      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n      bail: this.options.bail,\n      allowNull: this.options.allowNull,\n      isOptional: this.options.isOptional,\n      allowUnknownProperties: this.#allowUnknownProperties,\n      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n      validations: this.compileValidations(refs),\n      properties: this.#schemas.map((schema, index) => schema[PARSE](String(index), refs, options)),\n    }\n  }\n}\n"]}
{"filename": "src/errors/validation_error.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Validation error is a superset of Error class with validation\n * error messages\n */", "\n/**\n * Validation error is a superset of Error class with validation\n * error messages\n */\nexport class ValidationError extends Error {\n  /**\n   * Http status code for the validation error\n   */\n  status: number = 422\n\n  /**\n   * Internal code for handling the validation error\n   * exception\n   */\n  code: string = 'E_VALIDATION_ERROR'\n\n  constructor(\n    public messages: any,\n    options?: ErrorOptions\n  ) {\n    super('Validation failure', options)\n    const ErrorConstructor = this.constructor as typeof ValidationError\n    Error.captureStackTrace(this, ErrorConstructor)\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n}\n"]}
{"filename": "src/errors/main.ts", "chunked_list": ["/*\n * @vinejs/vine\n *\n * (c) VineJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { ValidationError } from './validation_error.js'", "\nimport { ValidationError } from './validation_error.js'\n\n/**\n * Create an instance of validation error\n */\nexport const E_VALIDATION_ERROR = ValidationError\n"]}
