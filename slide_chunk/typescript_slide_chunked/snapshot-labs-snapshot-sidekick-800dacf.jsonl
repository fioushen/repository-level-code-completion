{"filename": "jest.config.ts", "chunked_list": ["/*\n * For a detailed explanation regarding each configuration property and type check, visit:\n * https://jestjs.io/docs/configuration\n */\n\nexport default {\n  clearMocks: true,\n  collectCoverage: true,\n  coverageThreshold: {\n    global: {\n      lines: 50\n    }\n  },\n  collectCoverageFrom: ['./src/**'],\n  coverageDirectory: 'coverage',\n  coverageProvider: 'v8',\n\n  // An array of regexp pattern strings used to skip coverage collection\n  coveragePathIgnorePatterns: ['/node_modules/', '<rootDir>/dist/', '<rootDir>/test/fixtures/'],\n\n  preset: 'ts-jest',\n  testEnvironment: 'jest-environment-node-single-context',\n  setupFiles: ['dotenv/config'],\n  //setupFilesAfterEnv: ['<rootDir>src/setupTests.ts'],\n  moduleFileExtensions: ['js', 'ts'],\n  testPathIgnorePatterns: ['dist/'],\n  verbose: true\n};\n"]}
{"filename": "test/fixtures/moderation.ts", "chunked_list": ["// Mock return results from SQL\nexport const SqlFixtures: Record<string, any[]> = {\n  flaggedLinks: [\n    { action: 'flag', type: 'link', value: 'https://gogle.com', created: 100 },\n    { action: 'flag', type: 'link', value: 'https://facebook.com', created: 100 }\n  ],\n  flaggedProposals: [\n    { action: 'flag', type: 'proposal', value: '0x1', created: 100 },\n    { action: 'flag', type: 'proposal', value: '0x2', created: 100 }\n  ],", "    { action: 'flag', type: 'proposal', value: '0x2', created: 100 }\n  ],\n  flaggedSpaces: [\n    { action: 'flag', type: 'space', value: 'space3.eth', created: 100 },\n    { action: 'flag', type: 'space', value: 'space4.eth', created: 100 }\n  ],\n  flaggedIps: [\n    {\n      action: 'flag',\n      type: 'ip',", "      action: 'flag',\n      type: 'ip',\n      value: '12ca17b49af2289436f303e0166030a21e525d266e209267433801a8fd4071a0',\n      created: 100\n    },\n    {\n      action: 'flag',\n      type: 'ip',\n      value: '19e36255972107d42b8cecb77ef5622e842e8a50778a6ed8dd1ce94732daca9e',\n      created: 100", "      value: '19e36255972107d42b8cecb77ef5622e842e8a50778a6ed8dd1ce94732daca9e',\n      created: 100\n    }\n  ],\n  verifiedSpaces: [\n    { action: 'verify', type: 'space', value: 'space1.eth', created: 100 },\n    { action: 'verify', type: 'space', value: 'space2.eth', created: 100 }\n  ]\n};\n", "};\n"]}
{"filename": "test/e2e/nftClaimer.test.ts", "chunked_list": ["import request from 'supertest';\n\nconst HOST = `http://localhost:${process.env.PORT || 3003}`;\n\ndescribe('nftClaimer', () => {\n  describe('GET /api/nft-claimer', () => {\n    it('returns an object with the snapshotFee', async () => {\n      const response = await request(HOST).get('/api/nft-claimer');\n      const fee = response.body.snapshotFee;\n", "      const fee = response.body.snapshotFee;\n\n      expect(response.statusCode).toBe(200);\n      expect(fee).toBeLessThan(100);\n      expect(fee).toBeGreaterThanOrEqual(1);\n    });\n  });\n});\n", ""]}
{"filename": "test/e2e/votesReport.test.ts", "chunked_list": ["import request from 'supertest';\nimport VotesReport from '../../src/lib/votesReport';\nimport { storageEngine } from '../../src/helpers/utils';\nimport { rmSync } from 'fs';\n\nconst HOST = `http://localhost:${process.env.PORT || 3003}`;\n\ndescribe('GET /api/votes/:id', () => {\n  const id = '0x1e5fdb5c87867a94c1c7f27025d62851ea47f6072f2296ca53a48fce1b87cdef';\n  const storage = storageEngine(process.env.VOTE_REPORT_SUBDIR);", "  const id = '0x1e5fdb5c87867a94c1c7f27025d62851ea47f6072f2296ca53a48fce1b87cdef';\n  const storage = storageEngine(process.env.VOTE_REPORT_SUBDIR);\n\n  afterEach(() => {\n    rmSync(storage.path(), { recursive: true });\n  });\n\n  describe('when the cache exists', () => {\n    const votesReport = new VotesReport(id, storage);\n", "    const votesReport = new VotesReport(id, storage);\n\n    beforeAll(async () => {\n      await votesReport.createCache();\n    });\n\n    it('returns the cached file', async () => {\n      const response = await request(HOST).post(`/api/votes/${id}`);\n\n      expect(response.statusCode).toBe(200);", "\n      expect(response.statusCode).toBe(200);\n      expect(response.text).toEqual((await votesReport.getCache()).toString());\n    });\n  });\n\n  describe('when the cache does not exist', () => {\n    describe('when the proposal exists', () => {\n      it('returns a 202 status code, and creates the cache', async () => {\n        const response = await request(HOST).post(`/api/votes/${id}`);", "      it('returns a 202 status code, and creates the cache', async () => {\n        const response = await request(HOST).post(`/api/votes/${id}`);\n\n        expect(response.statusCode).toBe(202);\n\n        const votesReport = new VotesReport(id, storage);\n        expect(typeof (await votesReport.getCache())).not.toBe(false);\n      });\n    });\n", "    });\n\n    describe('when proposal does not exist', () => {\n      it('returns a 404 error', async () => {\n        const response = await request(HOST).post('/api/votes/0x000');\n\n        expect(response.statusCode).toBe(404);\n      });\n    });\n  });", "    });\n  });\n});\n"]}
{"filename": "test/e2e/moderation.test.ts", "chunked_list": ["import request from 'supertest';\nimport db from '../../src/helpers/mysql';\nimport { SqlFixtures as moderation } from '../fixtures/moderation';\n\nconst HOST = `http://localhost:${process.env.PORT || 3003}`;\n\ndescribe('GET /api/moderation', () => {\n  beforeAll(async () => {\n    const data = Object.values(moderation)\n      .flat()", "    const data = Object.values(moderation)\n      .flat()\n      .map(d => Object.values(d));\n    await db.queryAsync(`INSERT INTO moderation (action, type, value, created) VALUES ?`, [\n      data as any\n    ]);\n  });\n\n  afterAll(async () => {\n    await db.queryAsync('DELETE FROM sidekick_test.moderation;');", "  afterAll(async () => {\n    await db.queryAsync('DELETE FROM sidekick_test.moderation;');\n    await db.endAsync();\n  });\n\n  describe('when list params is empty', () => {\n    it('returns all the list', async () => {\n      const response = await request(HOST).get('/api/moderation');\n\n      expect(response.statusCode).toBe(200);", "\n      expect(response.statusCode).toBe(200);\n      expect(response.body).toMatchSnapshot();\n    });\n  });\n\n  describe('when list params is set', () => {\n    it.each(['flaggedLinks', 'verifiedSpaces', 'flaggedProposals', 'verifiedTokens'])(\n      'returns only the selected %s list',\n      async field => {", "      'returns only the selected %s list',\n      async field => {\n        const response = await request(HOST).get(`/api/moderation?list=${field}`);\n\n        expect(response.statusCode).toBe(200);\n        expect(response.body).toMatchSnapshot();\n      }\n    );\n  });\n", "  });\n\n  it('returns multiple list: verifiedSpaces,flaggedProposals', async () => {\n    const response = await request(HOST).get(\n      `/api/moderation?list=verifiedSpaces,flaggedProposals`\n    );\n\n    expect(response.statusCode).toBe(200);\n    expect(response.body).toMatchSnapshot();\n  });", "    expect(response.body).toMatchSnapshot();\n  });\n\n  it('ignores invalid field, and returns only verifiedSpaces', async () => {\n    const response = await request(HOST).get(`/api/moderation?list=verifiedSpaces,testInvalid`);\n\n    expect(response.statusCode).toBe(200);\n    expect(response.body).toMatchSnapshot();\n  });\n});", "  });\n});\n"]}
{"filename": "test/unit/lib/moderationList.test.ts", "chunked_list": ["import getModerationList from '../../../src/lib/moderationList';\nimport { SqlFixtures } from '../../fixtures/moderation';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockDbQueryAsync = jest.fn((query: string, args?: string[]): any[] => {\n  return [];\n});\njest.mock('../../../src/helpers/mysql', () => ({\n  __esModule: true,\n  default: { queryAsync: (query: string, args?: string[]) => mockDbQueryAsync(query, args) }", "  __esModule: true,\n  default: { queryAsync: (query: string, args?: string[]) => mockDbQueryAsync(query, args) }\n}));\n\ndescribe('moderationList', () => {\n  it.each(['flaggedLinks', 'verifiedSpaces', 'flaggedProposals'])(\n    'returns only the %s',\n    async field => {\n      mockDbQueryAsync.mockImplementationOnce(() => {\n        return SqlFixtures[field];", "      mockDbQueryAsync.mockImplementationOnce(() => {\n        return SqlFixtures[field];\n      });\n\n      const list = await getModerationList([field]);\n\n      expect(list).toMatchSnapshot();\n    }\n  );\n", "  );\n\n  it('returns multiple list: flaggedLinks and verifiedSpaces', async () => {\n    mockDbQueryAsync.mockImplementationOnce(() => {\n      return SqlFixtures.flaggedLinks.concat(SqlFixtures.verifiedSpaces);\n    });\n\n    const list = await getModerationList(['flaggedLinks', 'verifiedSpaces']);\n    expect(list).toMatchSnapshot();\n  });", "    expect(list).toMatchSnapshot();\n  });\n\n  it('ignores invalid fields, and only returns verifiedSpaces', async () => {\n    mockDbQueryAsync.mockImplementationOnce(() => {\n      return SqlFixtures.verifiedSpaces;\n    });\n\n    const list = await getModerationList(['a', 'b', 'verifiedSpaces']);\n    expect(list).toMatchSnapshot();", "    const list = await getModerationList(['a', 'b', 'verifiedSpaces']);\n    expect(list).toMatchSnapshot();\n  });\n\n  it('returns all fields by default', async () => {\n    mockDbQueryAsync.mockImplementationOnce(() => {\n      return Object.values(SqlFixtures).flat();\n    });\n\n    const list = await getModerationList();", "\n    const list = await getModerationList();\n    expect(list).toMatchSnapshot();\n  });\n});\n"]}
{"filename": "test/unit/lib/votesReport.test.ts", "chunked_list": ["import { readFileSync, rmSync } from 'fs';\nimport VotesReport from '../../../src/lib/votesReport';\nimport { storageEngine } from '../../../src/helpers/utils';\n\nconst TEST_CACHE_DIR = 'test-cache';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockFetchProposal = jest.fn((id: string): any => {\n  return [];\n});", "  return [];\n});\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockFetchVotes = jest.fn((id: string): any => {\n  return [];\n});\njest.mock('../../../src/helpers/snapshot', () => {\n  const originalModule = jest.requireActual('../../../src/helpers/snapshot');\n\n  return {", "\n  return {\n    __esModule: true,\n    ...originalModule,\n    fetchProposal: (id: string) => mockFetchProposal(id),\n    fetchVotes: (id: string) => mockFetchVotes(id)\n  };\n});\n\ndescribe('VotesReport', () => {", "\ndescribe('VotesReport', () => {\n  const id = '0x1e5fdb5c87867a94c1c7f27025d62851ea47f6072f2296ca53a48fce1b87cdef';\n  const weightedId = '0x79ae5f9eb3c710179cfbf706fa451459ddd18d4b0bce37c22aae601128efe927';\n  const testStorageEngine = storageEngine(TEST_CACHE_DIR);\n  const space = { id: '', name: '', network: '', settings: '' };\n\n  function fixtureFilePath(id: string) {\n    return `${__dirname}/../../fixtures/snapshot-votes-report-${id}.csv`;\n  }\n\n  afterAll(() => {\n    rmSync(testStorageEngine.path(), { recursive: true });\n  });\n\n  it.each([\n    ['single', id],\n    ['weighted', weightedId]\n  ])('generates a %s choices votes report', async (type: string, pid: string) => {\n    const report = new VotesReport(pid, testStorageEngine);\n    mockFetchProposal.mockResolvedValueOnce(\n      JSON.parse(readFileSync(`${__dirname}/../../fixtures/hub-proposal-${pid}.json`, 'utf8'))\n    );\n    mockFetchVotes.mockResolvedValueOnce(\n      JSON.parse(readFileSync(`${__dirname}/../../fixtures/hub-votes-${pid}.json`, 'utf8'))\n    );\n\n    const content = await report.getContent();\n\n    expect(content).toEqual(readFileSync(fixtureFilePath(pid), 'utf8'));\n    expect(mockFetchProposal).toHaveBeenCalled();\n    expect(mockFetchVotes).toHaveBeenCalled();\n  });\n\n  describe('isCacheable()', () => {\n    it('raises an error when the proposal does not exist', () => {\n      const report = new VotesReport('test', testStorageEngine);\n      mockFetchProposal.mockResolvedValueOnce(null);\n\n      expect(report.isCacheable()).rejects.toBe('RECORD_NOT_FOUND');\n      expect(mockFetchProposal).toHaveBeenCalled();\n    });\n\n    it('raises an error when the proposal is not closed', async () => {\n      const report = new VotesReport(id, testStorageEngine);\n      mockFetchProposal.mockResolvedValueOnce({\n        state: 'pending',\n        id: '',\n        title: '',\n        votes: 0,\n        author: '',\n        choices: [],\n        space\n      });\n\n      expect(report.isCacheable()).rejects.toBe('RECORD_NOT_FOUND');\n      expect(mockFetchProposal).toHaveBeenCalled();\n    });\n\n    it('returns true when the proposal can be cached', async () => {\n      const report = new VotesReport(id, testStorageEngine);\n      mockFetchProposal.mockResolvedValueOnce({\n        state: 'closed',\n        id: '',\n        title: '',\n        votes: 0,\n        author: '',\n        choices: [],\n        space\n      });\n\n      expect(await report.isCacheable()).toBe(true);\n      expect(mockFetchProposal).toHaveBeenCalled();\n    });\n  });\n});\n"]}
{"filename": "test/unit/lib/cache.test.ts", "chunked_list": ["import { readFileSync, rmSync, writeFileSync } from 'fs';\nimport { storageEngine } from '../../../src/helpers/utils';\nimport Cache from '../../../src/lib/cache';\n\nconst TEST_CACHE_DIR = 'cache-test';\nconst TEST_ID = 'test';\nconst TEST_STRING_CONTENT = 'test content';\n\ndescribe('Cache', () => {\n  const testStorageEngine = storageEngine(TEST_CACHE_DIR);", "describe('Cache', () => {\n  const testStorageEngine = storageEngine(TEST_CACHE_DIR);\n  const cache = new Cache(TEST_ID, testStorageEngine);\n\n  afterAll(() => {\n    rmSync(testStorageEngine.path(), { recursive: true });\n  });\n\n  describe('getCache()', () => {\n    describe('when the cache exists', () => {", "  describe('getCache()', () => {\n    describe('when the cache exists', () => {\n      const file = testStorageEngine.path(cache.filename);\n\n      beforeEach(() => writeFileSync(file, TEST_STRING_CONTENT));\n      afterEach(() => rmSync(file));\n\n      it('returns the cached content', async () => {\n        expect((await cache.getCache()).toString()).toEqual(TEST_STRING_CONTENT);\n      });", "        expect((await cache.getCache()).toString()).toEqual(TEST_STRING_CONTENT);\n      });\n\n      it('returns a Buffer', async () => {\n        expect(await cache.getCache()).toBeInstanceOf(Buffer);\n      });\n    });\n\n    describe('when the cache does not exists', () => {\n      it('returns false', async () => {", "    describe('when the cache does not exists', () => {\n      it('returns false', async () => {\n        expect(await cache.getCache()).toBe(false);\n      });\n    });\n  });\n\n  describe('createCache()', () => {\n    it('creates the cache file from a string', async () => {\n      const spy = jest.spyOn(cache, 'getContent').mockResolvedValueOnce(TEST_STRING_CONTENT);", "    it('creates the cache file from a string', async () => {\n      const spy = jest.spyOn(cache, 'getContent').mockResolvedValueOnce(TEST_STRING_CONTENT);\n      await cache.createCache();\n\n      expect((await cache.getCache()).toString()).toEqual(TEST_STRING_CONTENT);\n      expect(spy).toHaveBeenCalledTimes(1);\n    });\n\n    it('creates the cache file from a Buffer', async () => {\n      const fixture = readFileSync(`${__dirname}/../../fixtures/icon.png`);", "    it('creates the cache file from a Buffer', async () => {\n      const fixture = readFileSync(`${__dirname}/../../fixtures/icon.png`);\n      const spy = jest.spyOn(cache, 'getContent').mockResolvedValueOnce(fixture);\n      await cache.createCache();\n\n      expect(await cache.getCache()).toEqual(fixture);\n      expect(spy).toHaveBeenCalledTimes(1);\n    });\n  });\n});", "  });\n});\n"]}
{"filename": "test/unit/lib/nftClaimer/mint.test.ts", "chunked_list": ["import { BigNumber } from '@ethersproject/bignumber';\nimport { recoverAddress } from '@ethersproject/transactions';\nimport { getAddress } from '@ethersproject/address';\nimport payload from '../../../../src/lib/nftClaimer/mint';\n\nconst TEST_MINT_DOMAIN = 'TestDAO';\nconst proposer = '0x0000000000000000000000000000004242424242';\n\nconst NAN = ['', false, null, 'test'];\n", "const NAN = ['', false, null, 'test'];\n\nconst mockFetchProposal = jest.fn((id: string): any => {\n  return {\n    id: id,\n    author: proposer,\n    space: { id: TEST_MINT_DOMAIN }\n  };\n});\njest.mock('../../../../src/helpers/snapshot', () => ({", "});\njest.mock('../../../../src/helpers/snapshot', () => ({\n  __esModule: true,\n  fetchProposal: (id: string) => mockFetchProposal(id)\n}));\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockGetProposalContract = jest.fn((id: string): any => {\n  return '0x2e234DAe75C793f67A35089C9d99245E1C58470b';\n});", "  return '0x2e234DAe75C793f67A35089C9d99245E1C58470b';\n});\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockValidateProposal = jest.fn((proposal: any): void => {\n  return;\n});\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockMintingAllowed = jest.fn((space: any): boolean => {\n  return true;\n});", "  return true;\n});\njest.mock('../../../../src/lib/nftClaimer/utils', () => {\n  // Require the original module to not be mocked...\n  const originalModule = jest.requireActual('../../../../src/lib/nftClaimer/utils');\n\n  return {\n    __esModule: true,\n    ...originalModule,\n    getProposalContract: (id: string) => mockGetProposalContract(id),\n    validateProposal: (id: any) => mockValidateProposal(id),\n    mintingAllowed: (space: any) => mockMintingAllowed(space)\n  };\n});\n\ndescribe('nftClaimer', () => {\n  describe('payload()', () => {\n    const signer = '0xD60349c24dB7F1053086eF0D6364b64B1e0313f0';\n    const recipient = getAddress('0x0000000000000000000000000000000000001234');\n    const proposalId = 42;\n    const hexProposalId = BigNumber.from(proposalId).toHexString();\n    const salt = '0';\n\n    // Signature expected by the smart contract\n    const expectedScSignature = {\n      r: '0xf27b32f51f5804eb53705e7c0e3c63169282f0ac83543f515970531650d42be4',\n      s: '0x54124669256e730bc60147fb00afcf1d5f028045f15e7d5bd77b2093cd2f9554',\n      v: 27\n    };\n\n    const expectedDigest = '0x65b2c526e8c21a68583765e51f03990a67a0a0cb46794ab7ec666e88808eb93a';\n\n    const input = {\n      proposalAuthor: proposer,\n      recipient,\n      id: hexProposalId,\n      salt\n    };\n", "    async function getPayload(customParams = {}) {\n      return payload({ ...input, ...customParams });\n    }\n\n    describe('when mintable', () => {\n      it('generates the same signature as the smart contract from the data', async () => {\n        const { signature } = await getPayload();\n\n        expect(mockFetchProposal).toHaveBeenCalledWith(hexProposalId);\n        expect(signature.r).toEqual(expectedScSignature.r);\n        expect(signature.s).toEqual(expectedScSignature.s);\n        expect(signature.v).toEqual(expectedScSignature.v);\n      });\n\n      it('can recover the signer from the digest', async () => {\n        const recoveredSigner = recoverAddress(expectedDigest, {\n          r: expectedScSignature.r,\n          s: expectedScSignature.s,\n          v: expectedScSignature.v\n        });\n\n        expect(recoveredSigner).toEqual(signer);\n      });\n    });\n\n    describe('when spaceCollection is not found', () => {\n      it('throws a SpaceCollection not found error', async () => {\n        mockGetProposalContract.mockImplementationOnce(() => {\n          throw new Error();\n        });\n        return expect(async () => await getPayload()).rejects.toThrow();\n      });\n    });\n\n    describe('when space has closed minting', () => {\n      it('throws an error', () => {\n        mockMintingAllowed.mockReturnValueOnce(false);\n        return expect(async () => await payload(input)).rejects.toThrow();\n      });\n    });\n\n    describe('when maxSupply has been reached', () => {\n      it.todo('throws an error');\n    });\n\n    describe('when passing invalid values', () => {\n      it('throws an error when the proposalAuthor address is not valid', () => {\n        expect(async () => getPayload({ proposalAuthor: 'test' })).rejects.toThrow();\n      });\n\n      it('throws an error when the recipient address is not valid', () => {\n        expect(\n          async () =>\n            await getPayload({\n              recipient: 'test'\n            })\n        ).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the salt is not a number (%s)', val => {\n        return expect(\n          async () =>\n            await getPayload({\n              salt: val as any\n            })\n        ).rejects.toThrow();\n      });\n\n      it('throws an error when the proposal is not found', () => {\n        mockFetchProposal.mockReturnValueOnce(null);\n        return expect(getPayload()).rejects.toThrow();\n      });\n    });\n  });\n});\n"]}
{"filename": "test/unit/lib/nftClaimer/deploy.test.ts", "chunked_list": ["import { recoverAddress } from '@ethersproject/transactions';\nimport payload from '../../../../src/lib/nftClaimer/deploy';\nimport type { Space } from '../../../../src/helpers/snapshot';\nimport { signer } from '../../../../src/lib/nftClaimer/utils';\n\nconst mockFetchSpace = jest.fn((id: string): any => {\n  return { id: id };\n});\njest.mock('../../../../src/helpers/snapshot', () => ({\n  __esModule: true,", "jest.mock('../../../../src/helpers/snapshot', () => ({\n  __esModule: true,\n  fetchSpace: (id: string) => mockFetchSpace(id)\n}));\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockValidateSpace = jest.fn((address: string, space: Space | null): any => {\n  return true;\n});\n// eslint-disable-next-line @typescript-eslint/no-unused-vars", "});\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst mockValidateDeployInput = jest.fn((input: any): any => {\n  return {};\n});\njest.mock('../../../../src/lib/nftClaimer/utils', () => {\n  const originalModule = jest.requireActual('../../../../src/lib/nftClaimer/utils');\n\n  return {\n    __esModule: true,", "  return {\n    __esModule: true,\n    ...originalModule,\n    validateSpace: (address: string, space: Space | null) => mockValidateSpace(address, space),\n    validateDeployInput: (input: any) => mockValidateDeployInput(input)\n  };\n});\n\nconst NAN = ['', false, null, 'test'];\n", "const NAN = ['', false, null, 'test'];\n\ndescribe('nftClaimer', () => {\n  describe('payload()', () => {\n    const spaceOwner = '0x5EF29cf961cf3Fc02551B9BdaDAa4418c446c5dd';\n    const spaceTreasury = '0x5EF29cf961cf3Fc02551B9BdaDAa4418c446c5dd';\n    const spaceId = 'TestDAO';\n    const maxSupply = '10';\n    const mintPrice = '100000000000000000';\n    const proposerFee = '10';", "    const mintPrice = '100000000000000000';\n    const proposerFee = '10';\n    const salt = '72536493147621360896130495100276306361343381736075662552878320684807833746288';\n\n    // Signature expected by the smart contract\n    const expectedScSignature = {\n      r: '0xd921452d76ea510debe0260f7eba6327e1cb7172e22fcc0179a734a3e7234ca2',\n      s: '0x0ee9397c6c803436aac0c8c496c50264b68f6664f4940f7addc5f9140b8b8237',\n      v: 27\n    };", "      v: 27\n    };\n\n    const expectedDigest = '0xc3a4ff2bd44ee17fbc4f802953bd55392238b034c71ca4f5de2ad2f23fa31af7';\n    const expectedInitializer =\n      '0x977b0efb00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000005ef29cf961cf3fc02551b9bdadaa4418c446c5dd0000000000000000000000005ef29cf961cf3fc02551b9bdadaa4418c446c5dd00000000000000000000000000000000000000000000000000000000000000075465737444414f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003302e310000000000000000000000000000000000000000000000000000000000';\n\n    const input = {\n      spaceOwner,\n      id: spaceId,", "      spaceOwner,\n      id: spaceId,\n      maxSupply,\n      mintPrice,\n      proposerFee,\n      salt,\n      spaceTreasury\n    };\n\n    function getPayload(customParams = {}) {\n      return payload({ ...input, ...customParams });\n    }\n\n    describe('when deployable', () => {\n      it('generates the same signature as the smart contract from the data', async () => {\n        mockValidateDeployInput.mockReturnValueOnce(input);\n\n        const { signature } = await getPayload();\n\n        expect(mockValidateSpace).toHaveBeenCalled();\n        expect(mockValidateDeployInput).toHaveBeenCalled();\n        expect(signature.r).toEqual(expectedScSignature.r);\n        expect(signature.s).toEqual(expectedScSignature.s);\n        expect(signature.v).toEqual(expectedScSignature.v);\n      });\n\n      it('generates the same initializer as the smart contract from the data', async () => {\n        mockValidateDeployInput.mockReturnValueOnce(input);\n\n        const { initializer } = await getPayload();\n\n        expect(mockValidateSpace).toHaveBeenCalled();\n        expect(mockValidateDeployInput).toHaveBeenCalled();\n        expect(initializer).toEqual(expectedInitializer);\n      });\n\n      it('can recover the signer from the digest', async () => {\n        mockValidateDeployInput.mockReturnValueOnce(input);\n\n        const recoveredSigner = recoverAddress(expectedDigest, {\n          r: expectedScSignature.r,\n          s: expectedScSignature.s,\n          v: expectedScSignature.v\n        });\n\n        expect(recoveredSigner).toEqual(signer.address);\n      });\n    });\n\n    describe('when the space validation failed', () => {\n      it('throws an error', () => {\n        mockValidateSpace.mockImplementation(() => {\n          throw new Error();\n        });\n\n        expect(async () => await getPayload()).rejects.toThrow();\n      });\n    });\n\n    describe('when passing invalid values', () => {\n      it('throws an error when the spaceOwer address is not valid', () => {\n        expect(async () => await getPayload({ spaceOwner: 'test' })).rejects.toThrow();\n      });\n\n      it('throws an error when the spaceTreasury address is not valid', () => {\n        expect(async () => await getPayload({ spaceTreasury: 'test' })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the salt is not a number (%s)', val => {\n        expect(async () => await getPayload({ salt: val as any })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the maxSupply is not a number (%s', val => {\n        expect(async () => await getPayload({ maxSupply: val as any })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the mintPrice is not a number (%s)', val => {\n        expect(async () => await getPayload({ mintPrice: val as any })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the proposerFee is not a number (%s)', val => {\n        expect(async () => await getPayload({ proposerFee: val as any })).rejects.toThrow();\n      });\n\n      it('throws an error when the proposerFee is out of range', () => {\n        expect(async () => await getPayload({ proposerFee: '101' })).rejects.toThrow();\n        expect(async () => await getPayload({ proposerFee: '-5' })).rejects.toThrow();\n      });\n    });\n  });\n});\n", "\n    function getPayload(customParams = {}) {\n      return payload({ ...input, ...customParams });\n    }\n\n    describe('when deployable', () => {\n      it('generates the same signature as the smart contract from the data', async () => {\n        mockValidateDeployInput.mockReturnValueOnce(input);\n\n        const { signature } = await getPayload();\n\n        expect(mockValidateSpace).toHaveBeenCalled();\n        expect(mockValidateDeployInput).toHaveBeenCalled();\n        expect(signature.r).toEqual(expectedScSignature.r);\n        expect(signature.s).toEqual(expectedScSignature.s);\n        expect(signature.v).toEqual(expectedScSignature.v);\n      });\n\n      it('generates the same initializer as the smart contract from the data', async () => {\n        mockValidateDeployInput.mockReturnValueOnce(input);\n\n        const { initializer } = await getPayload();\n\n        expect(mockValidateSpace).toHaveBeenCalled();\n        expect(mockValidateDeployInput).toHaveBeenCalled();\n        expect(initializer).toEqual(expectedInitializer);\n      });\n\n      it('can recover the signer from the digest', async () => {\n        mockValidateDeployInput.mockReturnValueOnce(input);\n\n        const recoveredSigner = recoverAddress(expectedDigest, {\n          r: expectedScSignature.r,\n          s: expectedScSignature.s,\n          v: expectedScSignature.v\n        });\n\n        expect(recoveredSigner).toEqual(signer.address);\n      });\n    });\n\n    describe('when the space validation failed', () => {\n      it('throws an error', () => {\n        mockValidateSpace.mockImplementation(() => {\n          throw new Error();\n        });\n\n        expect(async () => await getPayload()).rejects.toThrow();\n      });\n    });\n\n    describe('when passing invalid values', () => {\n      it('throws an error when the spaceOwer address is not valid', () => {\n        expect(async () => await getPayload({ spaceOwner: 'test' })).rejects.toThrow();\n      });\n\n      it('throws an error when the spaceTreasury address is not valid', () => {\n        expect(async () => await getPayload({ spaceTreasury: 'test' })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the salt is not a number (%s)', val => {\n        expect(async () => await getPayload({ salt: val as any })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the maxSupply is not a number (%s', val => {\n        expect(async () => await getPayload({ maxSupply: val as any })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the mintPrice is not a number (%s)', val => {\n        expect(async () => await getPayload({ mintPrice: val as any })).rejects.toThrow();\n      });\n\n      it.each(NAN)('throws an error when the proposerFee is not a number (%s)', val => {\n        expect(async () => await getPayload({ proposerFee: val as any })).rejects.toThrow();\n      });\n\n      it('throws an error when the proposerFee is out of range', () => {\n        expect(async () => await getPayload({ proposerFee: '101' })).rejects.toThrow();\n        expect(async () => await getPayload({ proposerFee: '-5' })).rejects.toThrow();\n      });\n    });\n  });\n});\n"]}
{"filename": "test/unit/lib/nftClaimer/utils.test.ts", "chunked_list": ["import {\n  validateAddresses,\n  validateProposal,\n  validateProposerFee\n} from '../../../../src/lib/nftClaimer/utils';\n\ndescribe('NFTClaimer/utils', () => {\n  describe('validateAddresses()', () => {\n    it('returns true when all addresses are valid', () => {\n      expect(", "    it('returns true when all addresses are valid', () => {\n      expect(\n        validateAddresses({\n          contractA: '0x054a600d8B766c786270E25872236507D8459D8F',\n          contractB: '0x33505720a7921d23E6b02EB69623Ed6A008Ca511'\n        })\n      ).toBe(true);\n    });\n    it('throws an error when some of the addresses are invalid', () => {\n      expect(() => {", "    it('throws an error when some of the addresses are invalid', () => {\n      expect(() => {\n        validateAddresses({\n          contractA: '0x054a600d8B766c786270E25872236507D8459D8F',\n          contractB: 'hello-world'\n        });\n      }).toThrowError();\n    });\n  });\n", "  });\n\n  describe('validateProposerFee()', () => {\n    it('throws an error when proposerFee + snapshotFee > 100', () => {\n      return expect(async () => {\n        await validateProposerFee(100);\n      }).rejects.toThrow();\n    });\n  });\n", "  });\n\n  describe('validateProposal()', () => {\n    it('throws an error when the proposalAuthor is not matching', () => {\n      const address = '0x054a600d8B766c786270E25872236507D8459D8F';\n\n      expect(async () => {\n        validateProposal({ author: address } as any, '');\n      }).rejects.toThrow();\n    });", "      }).rejects.toThrow();\n    });\n\n    it('throws an error when the proposal does not exist', () => {\n      expect(async () => {\n        validateProposal(null, '');\n      }).rejects.toThrowError('RECORD_NOT_FOUND');\n    });\n\n    it.todo('throws an error when the space has closed minting');", "\n    it.todo('throws an error when the space has closed minting');\n  });\n});\n"]}
{"filename": "src/api.ts", "chunked_list": ["import express from 'express';\nimport { capture } from './helpers/sentry';\nimport { rpcError, rpcSuccess, storageEngine } from './helpers/utils';\nimport getModerationList from './lib/moderationList';\nimport VotesReport from './lib/votesReport';\nimport mintPayload from './lib/nftClaimer/mint';\nimport deployPayload from './lib/nftClaimer/deploy';\nimport { queue, getProgress } from './lib/queue';\nimport { snapshotFee } from './lib/nftClaimer/utils';\n", "import { snapshotFee } from './lib/nftClaimer/utils';\n\nconst router = express.Router();\n\nrouter.post('/votes/:id', async (req, res) => {\n  const { id } = req.params;\n  const votesReport = new VotesReport(id, storageEngine(process.env.VOTE_REPORT_SUBDIR));\n\n  try {\n    const file = await votesReport.getCache();\n", "  try {\n    const file = await votesReport.getCache();\n\n    if (file) {\n      res.header('Content-Type', 'text/csv');\n      res.attachment(votesReport.filename);\n      return res.end(file);\n    }\n\n    try {\n      await votesReport.isCacheable();\n      queue(votesReport);\n      return rpcSuccess(res.status(202), getProgress(id).toString(), id);", "    try {\n      await votesReport.isCacheable();\n      queue(votesReport);\n      return rpcSuccess(res.status(202), getProgress(id).toString(), id);\n    } catch (e: any) {\n      capture(e);\n      rpcError(res, e, id);\n    }\n  } catch (e) {\n    capture(e);\n    return rpcError(res, 'INTERNAL_ERROR', id);\n  }\n});\n\nrouter.get('/moderation', async (req, res) => {\n  const { list } = req.query;\n", "  } catch (e) {\n    capture(e);\n    return rpcError(res, 'INTERNAL_ERROR', id);\n  }\n});\n\nrouter.get('/moderation', async (req, res) => {\n  const { list } = req.query;\n\n  try {\n    res.json(await getModerationList(list ? (list as string).split(',') : undefined));", "  try {\n    res.json(await getModerationList(list ? (list as string).split(',') : undefined));\n  } catch (e) {\n    capture(e);\n    return rpcError(res, 'INTERNAL_ERROR', '');\n  }\n});\n\nrouter.get('/nft-claimer', async (req, res) => {\n  try {\n    return res.json({ snapshotFee: await snapshotFee() });", "  try {\n    return res.json({ snapshotFee: await snapshotFee() });\n  } catch (e: any) {\n    capture(e);\n    return rpcError(res, e, '');\n  }\n});\n\nrouter.post('/nft-claimer/deploy', async (req, res) => {\n  const { address, id, salt, maxSupply, mintPrice, spaceTreasury, proposerFee } = req.body;\n  try {\n    return res.json(\n      await deployPayload({\n        spaceOwner: address,\n        id,\n        maxSupply,\n        mintPrice,\n        proposerFee,\n        salt,\n        spaceTreasury\n      })\n    );", "  try {\n    return res.json(\n      await deployPayload({\n        spaceOwner: address,\n        id,\n        maxSupply,\n        mintPrice,\n        proposerFee,\n        salt,\n        spaceTreasury\n      })\n    );", "  } catch (e: any) {\n    capture(e);\n    return rpcError(res, e, salt);\n  }\n});\n\nrouter.post('/nft-claimer/mint', async (req, res) => {\n  const { proposalAuthor, address, id, salt } = req.body;\n  try {\n    return res.json(await mintPayload({ proposalAuthor, recipient: address, id, salt }));\n  } catch (e: any) {\n    capture(e);\n    return rpcError(res, e, salt);\n  }\n});\n\nexport default router;\n", "  try {\n    return res.json(await mintPayload({ proposalAuthor, recipient: address, id, salt }));\n  } catch (e: any) {\n    capture(e);\n    return rpcError(res, e, salt);\n  }\n});\n\nexport default router;\n"]}
{"filename": "src/sentryTunnel.ts", "chunked_list": ["import express from 'express';\nimport fetch from 'cross-fetch';\nimport bodyParser from 'body-parser';\nimport { URL } from 'url';\nimport { rpcError } from './helpers/utils';\nimport { capture } from './helpers/sentry';\n\nconst router = express.Router();\n\nrouter.post('/sentry', bodyParser.raw({ type: () => true, limit: '4mb' }), async (req, res) => {\n  try {\n    const { dsn, event_id } = JSON.parse(req.body.toString().split('\\n')[0]);\n", "\nrouter.post('/sentry', bodyParser.raw({ type: () => true, limit: '4mb' }), async (req, res) => {\n  try {\n    const { dsn, event_id } = JSON.parse(req.body.toString().split('\\n')[0]);\n\n    if (dsn !== process.env.TUNNEL_SENTRY_DSN) {\n      return rpcError(res, 'UNAUTHORIZED', event_id);\n    }\n\n    const dnsUri = new URL(dsn);\n    const sentryApiUrl = `https://${dnsUri.hostname}/api${dnsUri.pathname}/envelope/`;\n    const response = await fetch(sentryApiUrl, {\n      method: 'post',\n      body: req.body\n    });\n\n    const status = response.status;", "    if (status !== 200) {\n      console.debug(await response.text());\n    }\n    return res.sendStatus(status);\n  } catch (e: any) {\n    capture(e);\n    rpcError(res, e, '');\n  }\n});\n\nexport default router;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import 'dotenv/config';\nimport path from 'path';\nimport express from 'express';\nimport compression from 'compression';\nimport cors from 'cors';\nimport morgan from 'morgan';\nimport favicon from 'serve-favicon';\nimport api from './api';\nimport webhook from './webhook';\nimport sentryTunnel from './sentryTunnel';", "import webhook from './webhook';\nimport sentryTunnel from './sentryTunnel';\nimport './lib/queue';\nimport { name, version } from '../package.json';\nimport { rpcError } from './helpers/utils';\nimport { initLogger, fallbackLogger } from './helpers/sentry';\n\nconst app = express();\nconst PORT = process.env.PORT || 3005;\n", "const PORT = process.env.PORT || 3005;\n\ninitLogger(app);\n\napp.use(express.json({ limit: '4mb' }));\napp.use(cors({ maxAge: 86400 }));\napp.use(compression());\napp.use(\n  morgan(\n    '[http] [:date[clf]] ' +", "  morgan(\n    '[http] [:date[clf]] ' +\n      '\":method :url HTTP/:http-version\" :status :res[content-length] ' +\n      '\":referrer\" \":user-agent\" - :response-time ms'\n  )\n);\napp.use(favicon(path.join(__dirname, '../public', 'favicon.png')));\napp.use('/api', api);\napp.use('/', webhook);\napp.use('/', sentryTunnel);", "app.use('/', webhook);\napp.use('/', sentryTunnel);\n\napp.get('/', (req, res) => {\n  const commit = process.env.COMMIT_HASH || '';\n  const v = commit ? `${version}#${commit.substring(0, 7)}` : version;\n  return res.json({\n    name,\n    version: v\n  });", "    version: v\n  });\n});\n\nfallbackLogger(app);\n\napp.use((_, res) => {\n  rpcError(res, 'RECORD_NOT_FOUND', '');\n});\n", "});\n\napp.listen(PORT, () => console.log(`[http] Start server at http://localhost:${PORT}`));\n"]}
{"filename": "src/webhook.ts", "chunked_list": ["import express from 'express';\nimport { rpcError, rpcSuccess, storageEngine } from './helpers/utils';\nimport { capture } from './helpers/sentry';\nimport VotesReport from './lib/votesReport';\nimport { queue } from './lib/queue';\n\nconst router = express.Router();\n\nfunction processVotesReport(id: string, event: string) {\n  if (event == 'proposal/end') {\n    queue(new VotesReport(id, storageEngine(process.env.VOTE_REPORT_SUBDIR)));\n  }\n}\n\nrouter.post('/webhook', (req, res) => {\n  const body = req.body || {};\n  const event = body.event?.toString() ?? '';\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { type, id } = body.id?.toString().split('/');\n", "function processVotesReport(id: string, event: string) {\n  if (event == 'proposal/end') {\n    queue(new VotesReport(id, storageEngine(process.env.VOTE_REPORT_SUBDIR)));\n  }\n}\n\nrouter.post('/webhook', (req, res) => {\n  const body = req.body || {};\n  const event = body.event?.toString() ?? '';\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { type, id } = body.id?.toString().split('/');\n", "  if (req.headers['authentication'] !== `${process.env.WEBHOOK_AUTH_TOKEN ?? ''}`) {\n    return rpcError(res, 'UNAUTHORIZED', id);\n  }\n\n  if (!event || !id) {\n    return rpcError(res, 'Invalid Request', id);\n  }\n\n  try {\n    processVotesReport(id, event);\n    return rpcSuccess(res, 'Webhook received', id);", "  try {\n    processVotesReport(id, event);\n    return rpcSuccess(res, 'Webhook received', id);\n  } catch (e) {\n    capture(e);\n    return rpcError(res, 'INTERNAL_ERROR', id);\n  }\n});\n\nexport default router;\n"]}
{"filename": "src/lib/queue.ts", "chunked_list": ["import { sleep } from '../helpers/utils';\nimport { capture } from '../helpers/sentry';\nimport Cache from './cache';\n\nconst queues = new Set<Cache>();\nconst processingItems = new Map<string, Cache>();\n\nasync function processItem(cacheable: Cache) {\n  console.log(`[queue] Processing queue item: ${cacheable}`);\n  try {\n    processingItems.set(cacheable.id, cacheable);\n    await cacheable.createCache();", "  try {\n    processingItems.set(cacheable.id, cacheable);\n    await cacheable.createCache();\n  } catch (e) {\n    capture(e);\n    console.error(`[queue] Error while processing item`, e);\n  } finally {\n    queues.delete(cacheable);\n    processingItems.delete(cacheable.id);\n  }\n}\n", "export function queue(cacheable: Cache) {\n  queues.add(cacheable);\n\n  return queues.size;\n}\n\nexport function getProgress(id: string) {\n  if (processingItems.has(id)) {\n    return processingItems.get(id)?.generationProgress as number;\n  }\n\n  return 0;\n}\n", "async function run() {\n  try {\n    console.log(`[queue] Poll queue (found ${queues.size} items)`);\n    queues.forEach(async cacheable => {\n      if (processingItems.has(cacheable.id)) {\n        console.log(\n          `[queue] Skip: ${cacheable} is currently being processed, progress: ${processingItems.get(\n            cacheable.id\n          )?.generationProgress}%`\n        );\n        return;\n      }\n\n      processItem(cacheable);\n    });", "  } catch (e) {\n    capture(e);\n  } finally {\n    await sleep(15e3);\n    await run();\n  }\n}\n\nrun();\n"]}
{"filename": "src/lib/moderationList.ts", "chunked_list": ["import { readFileSync } from 'fs';\nimport path from 'path';\nimport db from '../helpers/mysql';\n\ntype MODERATION_LIST = Record<string, string[] | JSON>;\n\nconst CACHE_PATH = path.resolve(__dirname, `../../${process.env.MODERATION_LIST_PATH || 'data'}`);\nconst FIELDS = new Map<keyof MODERATION_LIST, Record<string, string>>([\n  ['flaggedLinks', { action: 'flag', type: 'link' }],\n  ['flaggedProposals', { action: 'flag', type: 'proposal' }],\n  ['flaggedSpaces', { action: 'flag', type: 'space' }],\n  ['flaggedIps', { action: 'flag', type: 'ip' }],\n  ['verifiedSpaces', { action: 'verify', type: 'space' }],\n  ['verifiedTokens', { file: 'verifiedTokens.json' }]\n]);\n", "export function readFile(filename: string) {\n  return parseFileContent(\n    readFileSync(path.join(CACHE_PATH, filename), { encoding: 'utf8' }),\n    filename.split('.')[1]\n  );\n}\n\nfunction parseFileContent(content: string, parser: string): MODERATION_LIST[keyof MODERATION_LIST] {\n  switch (parser) {\n    case 'txt':\n      return content.split('\\n').filter(value => value !== '');\n    case 'json':\n      return JSON.parse(content);\n    default:\n      throw new Error('Invalid file type');\n  }\n}\n", "export default async function getModerationList(fields = Array.from(FIELDS.keys())) {\n  const list: Partial<MODERATION_LIST> = {};\n  const reverseMapping: Record<string, keyof MODERATION_LIST> = {};\n  const queryWhereStatement: string[] = [];\n  let queryWhereArgs: string[] = [];\n\n  fields.forEach(field => {\n    if (FIELDS.has(field)) {\n      const args = FIELDS.get(field) as Record<string, string>;\n\n      if (!args.file) {\n        list[field] = [];\n        reverseMapping[`${args.action}-${args.type}`] = field;\n\n        queryWhereStatement.push(`(action = ? AND type = ?)`);\n        queryWhereArgs = queryWhereArgs.concat([args.action, args.type]);\n      } else {\n        list[field] = readFile(args.file);\n      }\n    }\n  });\n", "      if (!args.file) {\n        list[field] = [];\n        reverseMapping[`${args.action}-${args.type}`] = field;\n\n        queryWhereStatement.push(`(action = ? AND type = ?)`);\n        queryWhereArgs = queryWhereArgs.concat([args.action, args.type]);\n      } else {\n        list[field] = readFile(args.file);\n      }\n    }\n  });\n", "  if (queryWhereStatement.length > 0) {\n    const dbResults = await db.queryAsync(\n      `SELECT * FROM moderation WHERE ${queryWhereStatement.join(' OR ')}`,\n      queryWhereArgs\n    );\n\n    dbResults.forEach(row => {\n      (list[reverseMapping[`${row.action}-${row.type}`]] as string[]).push(row.value as string);\n    });\n  }\n\n  return list;\n}\n"]}
{"filename": "src/lib/votesReport.ts", "chunked_list": ["import { fetchProposal, fetchVotes, Proposal, Vote } from '../helpers/snapshot';\nimport type { IStorage } from './storage/types';\nimport Cache from './cache';\n\nclass VotesReport extends Cache {\n  proposal?: Proposal | null;\n\n  constructor(id: string, storage: IStorage) {\n    super(id, storage);\n    this.filename = `snapshot-votes-report-${this.id}.csv`;\n  }\n\n  async isCacheable() {\n    this.proposal = await fetchProposal(this.id);\n", "    if (!this.proposal || this.proposal.state !== 'closed') {\n      return Promise.reject('RECORD_NOT_FOUND');\n    }\n\n    return true;\n  }\n\n  getContent = async () => {\n    this.isCacheable();\n    const votes = await this.fetchAllVotes();\n\n    let content = '';\n\n    console.log(`[votes-report] Generating report for ${this.id}`);\n\n    const headers = [\n      'address',\n      votes.length === 0 || typeof votes[0].choice === 'number'\n        ? 'choice'\n        : this.proposal && this.proposal.choices.map((_choice, index) => `choice.${index + 1}`),\n      'voting_power',\n      'timestamp',\n      'author_ipfs_hash',\n      'reason'\n    ].flat();\n\n    content += headers.join(',');\n    content += `\\n${votes.map(vote => this.#formatCsvLine(vote)).join('\\n')}`;\n\n    console.log(`[votes-report] Report for ${this.id} ready with ${votes.length} items`);\n\n    return content;\n  };\n\n  fetchAllVotes = async () => {\n    let votes: Vote[] = [];\n    let page = 0;\n    let createdPivot = 0;\n    const pageSize = 1000;\n    let resultsSize = 0;\n    const maxPage = 5;\n\n    do {\n      let newVotes = await fetchVotes(this.id, {\n        first: pageSize,\n        skip: page * pageSize,\n        created_gte: createdPivot,\n        orderBy: 'created',\n        orderDirection: 'asc'\n      });\n      resultsSize = newVotes.length;\n", "      if (page === 0 && createdPivot > 0) {\n        // Loosely assuming that there will never be more than 1000 duplicates\n        const existingIpfs = votes.slice(-pageSize).map(vote => vote.ipfs);\n\n        newVotes = newVotes.filter(vote => {\n          return !existingIpfs.includes(vote.ipfs);\n        });\n      }\n\n      if (page === maxPage) {\n        page = 0;\n        createdPivot = newVotes[newVotes.length - 1].created;\n      } else {\n        page++;\n      }\n\n      votes = votes.concat(newVotes);\n\n      this.generationProgress = Number(\n        ((votes.length / (this.proposal?.votes as number)) * 100).toFixed(2)\n      );", "      if (page === maxPage) {\n        page = 0;\n        createdPivot = newVotes[newVotes.length - 1].created;\n      } else {\n        page++;\n      }\n\n      votes = votes.concat(newVotes);\n\n      this.generationProgress = Number(\n        ((votes.length / (this.proposal?.votes as number)) * 100).toFixed(2)\n      );", "    } while (resultsSize === pageSize);\n\n    return votes;\n  };\n\n  toString() {\n    return `VotesReport#${this.id}`;\n  }\n\n  #formatCsvLine = (vote: Vote) => {\n    let choices: Vote['choice'][] = [];\n", "    if (typeof vote.choice !== 'number' && this.proposal) {\n      choices = Array.from({ length: this.proposal.choices.length });\n      for (const [key, value] of Object.entries(vote.choice)) {\n        choices[parseInt(key) - 1] = value;\n      }\n    } else {\n      choices.push(vote.choice);\n    }\n\n    return [\n      vote.voter,\n      ...choices,\n      vote.vp,\n      vote.created,\n      vote.ipfs,\n      `\"${vote.reason.replace(/(\\r\\n|\\n|\\r)/gm, '')}\"`\n    ]\n      .flat()\n      .join(',');\n  };\n}\n\nexport default VotesReport;\n"]}
{"filename": "src/lib/cache.ts", "chunked_list": ["import { IStorage } from './storage/types';\n\nexport default class Cache {\n  id: string;\n  filename: string;\n  storage: IStorage;\n  generationProgress: number;\n\n  constructor(id: string, storage: IStorage) {\n    this.id = id;\n    this.filename = `${id}.cache`;\n    this.storage = storage;\n    this.generationProgress = 0;\n  }\n\n  async getContent(): Promise<string | Buffer> {\n    return '';\n  }\n\n  getCache() {\n    return this.storage.get(this.filename);\n  }\n\n  async isCacheable() {\n    return true;\n  }\n\n  async createCache() {\n    await this.isCacheable();\n    const content = await this.getContent();\n\n    console.log(`[votes-report] File cache ready to be saved`);\n\n    this.storage.set(this.filename, content);\n\n    return content;\n  }\n}\n"]}
{"filename": "src/lib/storage/types.ts", "chunked_list": ["export interface IStorage {\n  subDir?: string;\n\n  set(key: string, value: string | Buffer): Promise<boolean>;\n  get(key: string): Promise<Buffer | boolean>;\n}\n\nexport interface IStorageConstructor {\n  new (subDir?: string): IStorage;\n}\n"]}
{"filename": "src/lib/storage/aws.ts", "chunked_list": ["import { S3Client, GetObjectCommand, PutObjectCommand } from '@aws-sdk/client-s3';\nimport { capture } from '../../helpers/sentry';\nimport type { IStorage } from './types';\nimport type { Readable } from 'stream';\n\nconst CACHE_PATH = 'public';\n\nclass Aws implements IStorage {\n  client: S3Client;\n  subDir?: string;\n\n  constructor(subDir?: string) {\n    const region = process.env.AWS_REGION;\n    const accessKeyId = process.env.AWS_ACCESS_KEY_ID;\n    const secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY;\n", "    if (!region || !accessKeyId || !secretAccessKey) {\n      throw new Error('[storage:aws] AWS credentials missing');\n    }\n\n    this.client = new S3Client({ endpoint: process.env.AWS_ENDPOINT });\n    this.subDir = subDir;\n  }\n\n  async set(key: string, value: string | Buffer) {\n    try {\n      const command = new PutObjectCommand({\n        Bucket: process.env.AWS_BUCKET_NAME,\n        Key: this.path(key),\n        Body: value,\n        ContentType: 'text/csv; charset=utf-8'\n      });\n\n      await this.client.send(command);\n      console.log(`[storage:aws] File saved to ${this.path(key)}`);\n\n      return true;", "    try {\n      const command = new PutObjectCommand({\n        Bucket: process.env.AWS_BUCKET_NAME,\n        Key: this.path(key),\n        Body: value,\n        ContentType: 'text/csv; charset=utf-8'\n      });\n\n      await this.client.send(command);\n      console.log(`[storage:aws] File saved to ${this.path(key)}`);\n\n      return true;", "    } catch (e) {\n      capture(e);\n      console.error('[storage:aws] File storage failed', e);\n      throw new Error('Unable to access storage');\n    }\n  }\n\n  async get(key: string) {\n    try {\n      const command = new GetObjectCommand({\n        Bucket: process.env.AWS_BUCKET_NAME,\n        Key: this.path(key)\n      });\n      const response = await this.client.send(command);\n", "    try {\n      const command = new GetObjectCommand({\n        Bucket: process.env.AWS_BUCKET_NAME,\n        Key: this.path(key)\n      });\n      const response = await this.client.send(command);\n\n      if (!response.Body) {\n        return false;\n      }\n\n      const stream = response.Body as Readable;\n\n      return new Promise<Buffer>((resolve, reject) => {\n        const chunks: Buffer[] = [];\n        stream.on('data', chunk => chunks.push(chunk));\n        stream.once('end', () => resolve(Buffer.concat(chunks)));\n        stream.once('error', reject);\n      });", "    } catch (e: any) {\n      if (e['$metadata']?.httpStatusCode !== 404) {\n        capture(e);\n        console.error('[storage:aws] File fetch failed', e);\n      }\n\n      return false;\n    }\n  }\n\n  path(key?: string) {\n    return [CACHE_PATH, this.subDir?.replace(/^\\/+|\\/+$/, ''), key].filter(p => p).join('/');\n  }\n}\n\nexport default Aws;\n"]}
{"filename": "src/lib/storage/file.ts", "chunked_list": ["import { writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs';\nimport { capture } from '../../helpers/sentry';\nimport type { IStorage } from './types';\n\nconst CACHE_PATH = `${__dirname}/../../../tmp`;\n\nclass File implements IStorage {\n  subDir?: string;\n\n  constructor(subDir?: string) {\n    this.subDir = subDir;\n", "    if (!existsSync(this.path())) {\n      mkdirSync(this.path(), { recursive: true });\n    }\n  }\n\n  async set(key: string, value: string | Buffer) {\n    try {\n      writeFileSync(this.path(key), value);\n      console.log(`[storage:file] File saved to ${this.path(key)}`);\n\n      return true;", "    } catch (e) {\n      capture(e);\n      console.error('[storage:file] File storage failed', e);\n      throw e;\n    }\n  }\n\n  async get(key: string) {\n    try {\n      if (!existsSync(this.path(key))) {\n        return false;\n      }\n\n      console.log(`[storage:file] File fetched from ${this.path(key)}`);\n      return readFileSync(this.path(key));", "    try {\n      if (!existsSync(this.path(key))) {\n        return false;\n      }\n\n      console.log(`[storage:file] File fetched from ${this.path(key)}`);\n      return readFileSync(this.path(key));\n    } catch (e) {\n      capture(e);\n      console.error('[storage:file] Fetch file failed', e);\n      return false;\n    }\n  }\n\n  path(key?: string) {\n    return [CACHE_PATH, this.subDir?.replace(/^\\/+|\\/+$/, ''), key].filter(p => p).join('/');\n  }\n}\n\nexport default File;\n"]}
{"filename": "src/lib/nftClaimer/mint.ts", "chunked_list": ["import { splitSignature } from '@ethersproject/bytes';\nimport { fetchProposal, Space } from '../../helpers/snapshot';\nimport {\n  validateProposal,\n  getProposalContract,\n  signer,\n  numberizeProposalId,\n  validateMintInput,\n  mintingAllowed\n} from './utils';", "  mintingAllowed\n} from './utils';\nimport abi from './spaceCollectionImplementationAbi.json';\nimport { FormatTypes, Interface } from '@ethersproject/abi';\n\nconst MintType = {\n  Mint: [\n    { name: 'proposer', type: 'address' },\n    { name: 'recipient', type: 'address' },\n    { name: 'proposalId', type: 'uint256' },", "    { name: 'recipient', type: 'address' },\n    { name: 'proposalId', type: 'uint256' },\n    { name: 'salt', type: 'uint256' }\n  ]\n};\n\nconst NFT_CLAIMER_NETWORK = process.env.NFT_CLAIMER_NETWORK;\n\nexport default async function payload(input: {\n  proposalAuthor: string;\n  recipient: string;\n  id: string;\n  salt: string;\n}) {\n  const params = await validateMintInput(input);\n\n  const proposal = await fetchProposal(params.id);\n  validateProposal(proposal, params.proposalAuthor);\n  const spaceId = proposal?.space.id as string;\n\n  const verifyingContract = await getProposalContract(spaceId);", "export default async function payload(input: {\n  proposalAuthor: string;\n  recipient: string;\n  id: string;\n  salt: string;\n}) {\n  const params = await validateMintInput(input);\n\n  const proposal = await fetchProposal(params.id);\n  validateProposal(proposal, params.proposalAuthor);\n  const spaceId = proposal?.space.id as string;\n\n  const verifyingContract = await getProposalContract(spaceId);", "  if (!mintingAllowed(proposal?.space as Space)) {\n    throw new Error('Space has closed minting');\n  }\n\n  const message = {\n    proposer: params.proposalAuthor,\n    recipient: params.recipient,\n    proposalId: numberizeProposalId(params.id),\n    salt: BigInt(params.salt)\n  };\n\n  return {\n    signature: await generateSignature(verifyingContract, spaceId, message),\n    contractAddress: verifyingContract,\n    spaceId: proposal?.space.id,\n    ...message,\n    salt: params.salt,\n    abi: new Interface(abi).getFunction('mint').format(FormatTypes.full)\n  };\n}\n", "async function generateSignature(\n  verifyingContract: string,\n  domain: string,\n  message: Record<string, string | bigint>\n) {\n  return splitSignature(\n    await signer._signTypedData(\n      {\n        name: domain,\n        version: '0.1',\n        chainId: NFT_CLAIMER_NETWORK,\n        verifyingContract\n      },\n      MintType,\n      message\n    )\n  );\n}\n"]}
{"filename": "src/lib/nftClaimer/deploy.ts", "chunked_list": ["import { getAddress } from '@ethersproject/address';\nimport { splitSignature } from '@ethersproject/bytes';\nimport { FormatTypes, Interface } from '@ethersproject/abi';\nimport { fetchSpace } from '../../helpers/snapshot';\nimport { signer, validateDeployInput, validateSpace } from './utils';\nimport spaceCollectionAbi from './spaceCollectionImplementationAbi.json';\nimport spaceFactoryAbi from './spaceFactoryAbi.json';\n\nconst DeployType = {\n  Deploy: [", "const DeployType = {\n  Deploy: [\n    { name: 'implementation', type: 'address' },\n    { name: 'initializer', type: 'bytes' },\n    { name: 'salt', type: 'uint256' }\n  ]\n};\n\nconst VERIFYING_CONTRACT = getAddress(process.env.NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT as string);\nconst IMPLEMENTATION_ADDRESS = getAddress(", "const VERIFYING_CONTRACT = getAddress(process.env.NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT as string);\nconst IMPLEMENTATION_ADDRESS = getAddress(\n  process.env.NFT_CLAIMER_DEPLOY_IMPLEMENTATION_ADDRESS as string\n);\nconst NFT_CLAIMER_NETWORK = process.env.NFT_CLAIMER_NETWORK;\nconst INITIALIZE_SELECTOR = process.env.NFT_CLAIMER_DEPLOY_INITIALIZE_SELECTOR;\n\nexport default async function payload(input: {\n  spaceOwner: string;\n  id: string;\n  maxSupply: string;\n  mintPrice: string;\n  proposerFee: string;\n  salt: string;\n  spaceTreasury: string;\n}) {\n  const params = await validateDeployInput(input);\n\n  const space = await fetchSpace(params.id);\n  await validateSpace(params.spaceOwner, space);\n\n  const initializer = getInitializer({\n    spaceOwner: params.spaceOwner,\n    spaceId: space?.id as string,\n    maxSupply: params.maxSupply,\n    mintPrice: params.mintPrice,\n    proposerFee: params.proposerFee,\n    spaceTreasury: params.spaceTreasury\n  });\n  const result = {\n    initializer,\n    salt: params.salt,\n    abi: new Interface(spaceFactoryAbi).getFunction('deployProxy').format(FormatTypes.full),\n    verifyingContract: VERIFYING_CONTRACT,\n    implementation: IMPLEMENTATION_ADDRESS,\n    signature: await generateSignature(IMPLEMENTATION_ADDRESS, initializer, params.salt)\n  };\n\n  console.debug('Signer', signer.address);\n  console.debug('Payload', result);\n\n  return result;\n}\n", "function getInitializer(args: {\n  spaceId: string;\n  maxSupply: number;\n  mintPrice: string;\n  proposerFee: number;\n  spaceTreasury: string;\n  spaceOwner: string;\n}) {\n  const params = [\n    args.spaceId,\n    '0.1',\n    args.maxSupply,\n    BigInt(args.mintPrice),\n    args.proposerFee,\n    getAddress(args.spaceTreasury),\n    getAddress(args.spaceOwner)\n  ];\n\n  // This encodeFunctionData should ignore the last 4 params compared to\n  // the smart contract version\n  // NOTE Do not forget to remove the last 4 params in the ABI when copy/pasting\n  // from the smart contract\n  const initializer = new Interface(spaceCollectionAbi).encodeFunctionData('initialize', params);\n  const result = `${INITIALIZE_SELECTOR}${initializer.slice(10)}`;\n\n  console.debug('Initializer params', params);\n\n  return result;\n}\n", "async function generateSignature(implementation: string, initializer: string, salt: string) {\n  const params = {\n    domain: {\n      name: 'SpaceCollectionFactory',\n      version: '0.1',\n      chainId: NFT_CLAIMER_NETWORK,\n      verifyingContract: VERIFYING_CONTRACT\n    },\n    types: DeployType,\n    value: {\n      implementation,\n      initializer,\n      salt: BigInt(salt)\n    }\n  };\n\n  return splitSignature(await signer._signTypedData(params.domain, params.types, params.value));\n}\n"]}
{"filename": "src/lib/nftClaimer/utils.ts", "chunked_list": ["import { gql, ApolloClient, InMemoryCache, HttpLink } from '@apollo/client/core';\nimport fetch from 'cross-fetch';\nimport snapshot from '@snapshot-labs/snapshot.js';\nimport { CID } from 'multiformats/cid';\nimport { Wallet } from '@ethersproject/wallet';\nimport { Contract } from '@ethersproject/contracts';\nimport { getAddress, isAddress } from '@ethersproject/address';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { capture } from '../../helpers/sentry';\nimport type { Proposal, Space } from '../../helpers/snapshot';", "import { capture } from '../../helpers/sentry';\nimport type { Proposal, Space } from '../../helpers/snapshot';\n\nconst requiredEnvKeys = [\n  'NFT_CLAIMER_PRIVATE_KEY',\n  'NFT_CLAIMER_NETWORK',\n  'NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT',\n  'NFT_CLAIMER_DEPLOY_IMPLEMENTATION_ADDRESS',\n  'NFT_CLAIMER_DEPLOY_INITIALIZE_SELECTOR',\n  'NFT_CLAIMER_SUBGRAPH_URL'", "  'NFT_CLAIMER_DEPLOY_INITIALIZE_SELECTOR',\n  'NFT_CLAIMER_SUBGRAPH_URL'\n];\n\nconst HUB_NETWORK = process.env.HUB_URL === 'https://hub.snapshot.org' ? '1' : '5';\nconst DEPLOY_CONTRACT = getAddress(process.env.NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT as string);\nconst NFT_CLAIMER_NETWORK = parseInt(process.env.NFT_CLAIMER_NETWORK as string);\n\nconst missingEnvKeys: string[] = [];\nrequiredEnvKeys.forEach(key => {\n  if (!process.env[key]) {\n    missingEnvKeys.push(key);\n  }\n});\n", "const missingEnvKeys: string[] = [];\nrequiredEnvKeys.forEach(key => {\n  if (!process.env[key]) {\n    missingEnvKeys.push(key);\n  }\n});\n\nif (missingEnvKeys.length > 0) {\n  throw new Error(\n    `NFT Claimer not configured properly, missing env keys: ${missingEnvKeys.join(', ')}`\n  );\n}\n\nexport const signer = new Wallet(process.env.NFT_CLAIMER_PRIVATE_KEY as string);\n", "export async function mintingAllowed(space: Space) {\n  return (await getSpaceCollection(space.id)).enabled;\n}\n\nexport async function validateSpace(address: string, space: Space | null) {\n  if (!space) {\n    throw new Error('RECORD_NOT_FOUND');\n  }\n\n  if (NFT_CLAIMER_NETWORK !== 5 && !(await isSpaceOwner(space.id, address))) {\n    throw new Error('Address is not the space owner');\n  }\n\n  const contract = await getSpaceCollection(space.id);", "  if (NFT_CLAIMER_NETWORK !== 5 && !(await isSpaceOwner(space.id, address))) {\n    throw new Error('Address is not the space owner');\n  }\n\n  const contract = await getSpaceCollection(space.id);\n  if (contract) {\n    throw new Error(`SpaceCollection contract already exist (${contract.id})`);\n  }\n}\n\nasync function isSpaceOwner(spaceId: string, address: string) {\n  return (await snapshot.utils.getSpaceController(spaceId, HUB_NETWORK)) === getAddress(address);\n}\n", "async function isSpaceOwner(spaceId: string, address: string) {\n  return (await snapshot.utils.getSpaceController(spaceId, HUB_NETWORK)) === getAddress(address);\n}\n\nexport function validateProposal(proposal: Proposal | null, proposer: string) {\n  if (!proposal) {\n    throw new Error('RECORD_NOT_FOUND');\n  }\n\n  if (getAddress(proposer) !== getAddress(proposal.author)) {\n    throw new Error('Proposal author is not matching');\n  }\n", "  if (getAddress(proposer) !== getAddress(proposal.author)) {\n    throw new Error('Proposal author is not matching');\n  }\n\n  if (!mintingAllowed(proposal.space)) {\n    throw new Error('Space has not allowed minting');\n  }\n}\n\nexport async function getProposalContract(spaceId: string) {\n  const contract = await getSpaceCollection(spaceId);\n", "export async function getProposalContract(spaceId: string) {\n  const contract = await getSpaceCollection(spaceId);\n\n  if (!contract) {\n    throw new Error(`SpaceCollection contract is not found for space ${spaceId}`);\n  }\n\n  return contract.id;\n}\n\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: process.env.NFT_CLAIMER_SUBGRAPH_URL, fetch }),\n  cache: new InMemoryCache({\n    addTypename: false\n  }),\n  defaultOptions: {\n    query: {\n      fetchPolicy: 'no-cache'\n    }\n  }\n});\n\nconst SPACE_COLLECTION_QUERY = gql`\n  query SpaceCollections($spaceId: String) {\n    spaceCollections(where: { spaceId: $spaceId }, first: 1) {\n      id\n      enabled\n    }\n  }\n`;\n", "type SpaceCollection = {\n  id: string;\n  enabled: boolean;\n};\n\nexport async function getSpaceCollection(spaceId: string) {\n  const {\n    data: { spaceCollections }\n  }: { data: { spaceCollections: SpaceCollection[] } } = await client.query({\n    query: SPACE_COLLECTION_QUERY,\n    variables: {\n      spaceId\n    }\n  });\n\n  return spaceCollections[0];\n}\n", "export function numberizeProposalId(id: string) {\n  return BigNumber.from(id.startsWith('0x') ? id : CID.parse(id).bytes).toString();\n}\n\nexport function validateAddresses(addresses: Record<string, string>) {\n  Object.entries(addresses).forEach(([key, value]) => {\n    if (!isAddress(value)) {\n      throw new Error(`Value for ${key} is not a valid address (${value})`);\n    }\n  });\n\n  return true;\n}\n", "function validateNumbers(numbers: Record<string, string>) {\n  Object.entries(numbers).forEach(([key, value]) => {\n    try {\n      BigNumber.from(value).toString();\n    } catch (e: any) {\n      throw new Error(`Value for ${key} is not a valid number (${value})`);\n    }\n  });\n\n  return true;\n}\n", "export async function validateProposerFee(fee: number) {\n  if (fee < 0 || fee > 100) {\n    throw new Error('proposerFee should be between 0 and 100');\n  }\n\n  const sFee = await snapshotFee();\n  if (sFee + fee > 100) {\n    throw new Error(`proposerFee should not be greater than ${100 - sFee}`);\n  }\n\n  return true;\n}\n", "export async function validateDeployInput(params: any) {\n  validateAddresses({ spaceOwner: params.spaceOwner, spaceTreasury: params.spaceTreasury });\n  validateNumbers({\n    maxSupply: params.maxSupply,\n    proposerFee: params.proposerFee,\n    mintPrice: params.mintPrice,\n    salt: params.salt\n  });\n  await validateProposerFee(parseInt(params.proposerFee));\n\n  return {\n    spaceOwner: getAddress(params.spaceOwner),\n    spaceTreasury: getAddress(params.spaceTreasury),\n    proposerFee: parseInt(params.proposerFee),\n    maxSupply: parseInt(params.maxSupply),\n    mintPrice: parseInt(params.mintPrice),\n    ...params\n  };\n}\n", "export async function validateMintInput(params: any) {\n  validateAddresses({ proposalAuthor: params.proposalAuthor, recipient: params.recipient });\n  validateNumbers({\n    salt: params.salt\n  });\n\n  return {\n    proposalAuthor: getAddress(params.proposalAuthor),\n    recipient: getAddress(params.recipient),\n    ...params\n  };\n}\n", "export async function snapshotFee(): Promise<number> {\n  try {\n    const provider = snapshot.utils.getProvider(NFT_CLAIMER_NETWORK);\n    const contract = new Contract(\n      DEPLOY_CONTRACT,\n      ['function snapshotFee() public view returns (uint8)'],\n      provider\n    );\n\n    return contract.snapshotFee();\n  } catch (e: any) {\n    capture(e);\n    throw 'Unable to retrieve the snapshotFee';\n  }\n}\n", "  } catch (e: any) {\n    capture(e);\n    throw 'Unable to retrieve the snapshotFee';\n  }\n}\n"]}
{"filename": "src/helpers/mysql.ts", "chunked_list": ["import mysql from 'mysql';\n// @ts-ignore\nimport Pool from 'mysql/lib/Pool';\n// @ts-ignore\nimport Connection from 'mysql/lib/Connection';\nimport bluebird from 'bluebird';\nimport { ConnectionString } from 'connection-string';\n\ntype values = string | number | boolean | null;\nexport type SqlRow = Record<string, values>;\ntype SqlQueryArgs = values | Record<string, values>;\n", "type values = string | number | boolean | null;\nexport type SqlRow = Record<string, values>;\ntype SqlQueryArgs = values | Record<string, values>;\n\ninterface PromisedPool {\n  queryAsync: (query: string, args?: SqlQueryArgs | SqlQueryArgs[]) => Promise<SqlRow[]>;\n  endAsync: () => Promise<any>;\n}\n\nconst config = new ConnectionString(process.env.DATABASE_URL || '');\nbluebird.promisifyAll([Pool, Connection]);\n\nconst db: PromisedPool = mysql.createPool({\n  ...config,\n  host: config.hosts?.[0].name,\n  port: config.hosts?.[0].port,\n  connectionLimit: parseInt(process.env.CONNECTION_LIMIT || '10'),\n  multipleStatements: true,\n  connectTimeout: 60e3,\n  acquireTimeout: 60e3,\n  timeout: 60e3,\n  charset: 'utf8mb4',\n  database: config.path?.[0]\n}) as mysql.Pool & PromisedPool;\n\nexport default db;\n"]}
{"filename": "src/helpers/snapshot.ts", "chunked_list": ["import { gql, ApolloClient, InMemoryCache, createHttpLink } from '@apollo/client/core';\nimport { setContext } from '@apollo/client/link/context';\nimport fetch from 'cross-fetch';\n\nexport type Proposal = {\n  id: string;\n  state: string;\n  choices: string[];\n  space: Space;\n  votes: number;\n  author: string;\n};\n", "export type Vote = {\n  ipfs: string;\n  voter: string;\n  choice: Record<string, number> | number;\n  vp: number;\n  reason: string;\n  created: number;\n};\n\nexport type Space = {\n  id: string;\n  network: string;\n};\n\nconst httpLink = createHttpLink({\n  uri: `${process.env.HUB_URL || 'https://hub.snapshot.org'}/graphql`,\n  fetch\n});\n\nconst authLink = setContext((_, { headers }) => {\n  const apiHeaders: Record<string, string> = {};\n  const apiKey = process.env.KEYCARD_API_KEY;\n", "export type Space = {\n  id: string;\n  network: string;\n};\n\nconst httpLink = createHttpLink({\n  uri: `${process.env.HUB_URL || 'https://hub.snapshot.org'}/graphql`,\n  fetch\n});\n\nconst authLink = setContext((_, { headers }) => {\n  const apiHeaders: Record<string, string> = {};\n  const apiKey = process.env.KEYCARD_API_KEY;\n", "  if (apiKey && apiKey.length > 0) {\n    apiHeaders['x-api-key'] = apiKey;\n  }\n\n  return {\n    headers: {\n      ...headers,\n      ...apiHeaders\n    }\n  };\n});\n\nconst client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache: new InMemoryCache({\n    addTypename: false\n  }),\n  defaultOptions: {\n    query: {\n      fetchPolicy: 'no-cache'\n    }\n  }\n});\n\nconst PROPOSAL_QUERY = gql`\n  query Proposal($id: String) {\n    proposal(id: $id) {\n      id\n      state\n      choices\n      votes\n      author\n      space {\n        id\n        network\n      }\n    }\n  }\n`;\n\nconst VOTES_QUERY = gql`\n  query Votes(\n    $id: String!\n    $first: Int\n    $skip: Int\n    $orderBy: String\n    $orderDirection: OrderDirection\n    $created_gte: Int\n  ) {\n    votes(\n      first: $first\n      skip: $skip\n      where: { proposal: $id, created_gte: $created_gte }\n      orderBy: $orderBy\n      orderDirection: $orderDirection\n    ) {\n      ipfs\n      voter\n      choice\n      vp\n      reason\n      created\n    }\n  }\n`;\n\nconst SPACE_QUERY = gql`\n  query Space($id: String) {\n    space(id: $id) {\n      id\n      network\n    }\n  }\n`;\n", "export async function fetchProposal(id: string) {\n  const {\n    data: { proposal }\n  }: { data: { proposal: Proposal | null } } = await client.query({\n    query: PROPOSAL_QUERY,\n    variables: {\n      id\n    }\n  });\n\n  return proposal;\n}\n", "export async function fetchVotes(\n  id: string,\n  { first = 1000, skip = 0, orderBy = 'created_gte', orderDirection = 'asc', created_gte = 0 } = {}\n) {\n  const {\n    data: { votes }\n  }: { data: { votes: Vote[] } } = await client.query({\n    query: VOTES_QUERY,\n    variables: {\n      id,\n      orderBy,\n      orderDirection,\n      first,\n      skip,\n      created_gte\n    }\n  });\n\n  return votes;\n}\n", "export async function fetchSpace(id: string) {\n  const {\n    data: { space }\n  }: { data: { space: Space | null } } = await client.query({\n    query: SPACE_QUERY,\n    variables: {\n      id\n    }\n  });\n\n  return space;\n}\n"]}
{"filename": "src/helpers/sentry.ts", "chunked_list": ["import * as Sentry from '@sentry/node';\nimport type { Express } from 'express';\n\nexport function initLogger(app: Express) {\n  if (process.env.NODE_ENV !== 'production') {\n    return;\n  }\n\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    integrations: [\n      new Sentry.Integrations.Http({ tracing: true }),\n      new Sentry.Integrations.Express({ app }),\n      ...Sentry.autoDiscoverNodePerformanceMonitoringIntegrations()\n    ],\n\n    tracesSampleRate: parseFloat(process.env.SENTRY_TRACE_SAMPLE_RATE as string)\n  });\n\n  app.use(Sentry.Handlers.requestHandler());\n  app.use(Sentry.Handlers.tracingHandler());\n}\n", "export function fallbackLogger(app: Express) {\n  if (process.env.NODE_ENV !== 'production') {\n    return;\n  }\n\n  app.use(Sentry.Handlers.errorHandler());\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  app.use(function onError(err: any, req: any, res: any, _: any) {\n    res.statusCode = 500;\n    res.end(`${res.sentry}\\n`);\n  });\n}\n", "export function capture(e: any) {\n  if (process.env.NODE_ENV !== 'production') {\n    return console.error(e);\n  }\n\n  Sentry.captureException(e);\n}\n"]}
{"filename": "src/helpers/utils.ts", "chunked_list": ["import FileStorageEngine from '../lib/storage/file';\nimport AwsStorageEngine from '../lib/storage/aws';\nimport type { Response } from 'express';\n\nconst ERROR_CODES: Record<string, number> = {\n  'Invalid Request': -32600,\n  RECORD_NOT_FOUND: 404,\n  UNAUTHORIZED: 401\n};\n\nexport function rpcSuccess(res: Response, result: string, id: string | number) {\n  res.json({\n    jsonrpc: '2.0',\n    result,\n    id\n  });\n}\n", "};\n\nexport function rpcSuccess(res: Response, result: string, id: string | number) {\n  res.json({\n    jsonrpc: '2.0',\n    result,\n    id\n  });\n}\n\nexport function rpcError(res: Response, e: Error | string, id: string | number) {\n  const errorMessage = e instanceof Error ? e.message : e;\n  const errorCode = ERROR_CODES[errorMessage] ? ERROR_CODES[errorMessage] : -32603;\n\n  res.status(errorCode > 0 ? errorCode : 500).json({\n    jsonrpc: '2.0',\n    error: {\n      code: errorCode,\n      message: errorMessage\n    },\n    id\n  });\n}\n", "export function rpcError(res: Response, e: Error | string, id: string | number) {\n  const errorMessage = e instanceof Error ? e.message : e;\n  const errorCode = ERROR_CODES[errorMessage] ? ERROR_CODES[errorMessage] : -32603;\n\n  res.status(errorCode > 0 ? errorCode : 500).json({\n    jsonrpc: '2.0',\n    error: {\n      code: errorCode,\n      message: errorMessage\n    },\n    id\n  });\n}\n", "export async function sleep(time: number) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nexport function storageEngine(subDir?: string) {\n  if (process.env.STORAGE_ENGINE === 'aws') {\n    return new AwsStorageEngine(subDir);\n  } else {\n    return new FileStorageEngine(subDir);\n  }\n}\n"]}
