{"filename": "jest.config.ts", "chunked_list": ["/*\n * For a detailed explanation regarding each configuration property and type check, visit:\n * https://jestjs.io/docs/configuration\n */\nimport type { Config } from 'jest'\n\nconst config: Config = {\n  verbose: true,\n  transform: {\n    '^.+\\\\.tsx?$': 'ts-jest',\n  },\n  testPathIgnorePatterns: ['node_modules', 'dist', '.venv'],\n}\nexport default config\n"]}
{"filename": "scripts/update-approvals.ts", "chunked_list": ["import * as fs from 'fs'\nimport * as path from 'path'\nimport { colorConsole } from '../src/util/color-console'\n\nfunction updateApprovals() {\n  const dirs = ['helloworld', 'lifecycle', 'state', 'voting'].map((app) => path.join(process.cwd(), 'examples', app))\n\n  for (const exampleDir of dirs) {\n    const generatedPath = path.join(exampleDir, 'client.generated.ts')\n    const approvedPath = path.join(exampleDir, 'client.ts')\n", "    if (!fs.existsSync(generatedPath)) {\n      colorConsole.error`Need to run ${'npm run dev'} task first to generate latest clients. Could not find file ${generatedPath}`\n      process.exit(-1)\n    }\n    colorConsole.info`Overwriting ${approvedPath} with contents of ${generatedPath}`\n    fs.rmSync(approvedPath)\n    const generated = fs.readFileSync(generatedPath, 'utf-8')\n    fs.writeFileSync(approvedPath, generated, 'utf-8')\n  }\n  colorConsole.success`Operation completed successfully`\n}\n\nupdateApprovals()\n"]}
{"filename": "examples/helloworld/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { beforeEach, describe, expect, test } from '@jest/globals'\nimport { HelloWorldAppClient } from './client'\nimport { AtomicTransactionComposer } from 'algosdk'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\ndescribe('hello world typed client', () => {\n  const localnet = algorandFixture({\n    testAccountFunding: microAlgos(1_000_000),\n  })", "    testAccountFunding: microAlgos(1_000_000),\n  })\n  beforeEach(localnet.beforeEach, 10_000)\n\n  test('Calls hello', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new HelloWorldAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,", "        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy()\n\n    const response = await client.hello({ name: 'World' })", "\n    const response = await client.hello({ name: 'World' })\n    expect(response.return).toBe('Hello, World')\n\n    const response2 = await client.hello(['World!'])\n    expect(response2.return).toBe('Hello, World!')\n\n    const response3 = await client.helloWorldCheck({ name: 'World' })\n    expect(response3.return).toBe(undefined)\n  })", "    expect(response3.return).toBe(undefined)\n  })\n\n  test('Composer works with manually added transaction', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new HelloWorldAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,", "        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy()\n\n    const atc = new AtomicTransactionComposer()\n    await client.helloWorldCheck({ name: 'World' }, { sendParams: { atc, skipSending: true } })", "    const atc = new AtomicTransactionComposer()\n    await client.helloWorldCheck({ name: 'World' }, { sendParams: { atc, skipSending: true } })\n    const [transactionWithSigner] = atc.buildGroup()\n\n    const { transaction: rawTransaction } = await client.hello({ name: 'Bananas' }, { sendParams: { skipSending: true } })\n\n    // Add a transactions in the middle of the method calls and check that it doesn't mess up the return values\n    const result = await client\n      .compose()\n      .hello(['World'])", "      .compose()\n      .hello(['World'])\n      .addTransaction(transactionWithSigner)\n      .addTransaction(rawTransaction)\n      .addTransaction(\n        client.appClient.fundAppAccount({\n          amount: microAlgos(100_000),\n          sendParams: { skipSending: true },\n        }),\n      )", "        }),\n      )\n      .hello({ name: 'World!' })\n      .execute()\n\n    expect(result.returns[0]).toBe('Hello, World')\n    expect(result.returns[1]).toBe('Hello, World!')\n    expect(result.txIds.length).toBe(5)\n  })\n})", "  })\n})\n"]}
{"filename": "examples/helloworld/client.ts", "chunked_list": ["/* eslint-disable */\n/**\n * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n * DO NOT MODIFY IT BY HAND.\n * requires: @algorandfoundation/algokit-utils: ^2\n */\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport type {\n  AppCallTransactionResult,\n  AppCallTransactionResultOfType,", "  AppCallTransactionResult,\n  AppCallTransactionResultOfType,\n  CoreAppCallArgs,\n  RawAppCallArgs,\n  AppState,\n  TealTemplateParams,\n  ABIAppCallArg,\n} from '@algorandfoundation/algokit-utils/types/app'\nimport type {\n  AppClientCallCoreParams,", "import type {\n  AppClientCallCoreParams,\n  AppClientCompilationParams,\n  AppClientDeployCoreParams,\n  AppDetails,\n  ApplicationClient,\n} from '@algorandfoundation/algokit-utils/types/app-client'\nimport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\nimport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'", "import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'\nimport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\nexport const APP_SPEC: AppSpec = {\n  \"hints\": {\n    \"hello(string)string\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },", "      }\n    },\n    \"hello_world_check(string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMQp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDAyYmVjZTExIC8vICJoZWxsbyhzdHJpbmcpc3RyaW5nIgo9PQpibnogbWFpbl9sNQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGJmOWMxZWRmIC8vICJoZWxsb193b3JsZF9jaGVjayhzdHJpbmcpdm9pZCIKPT0KYm56IG1haW5fbDQKZXJyCm1haW5fbDQ6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBoZWxsb3dvcmxkY2hlY2tfMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGhlbGxvXzIKc3RvcmUgMApwdXNoYnl0ZXMgMHgxNTFmN2M3NSAvLyAweDE1MWY3Yzc1CmxvYWQgMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w2Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CmJueiBtYWluX2wxMgp0eG4gT25Db21wbGV0aW9uCnB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sMTEKdHhuIE9uQ29tcGxldGlvbgpwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KPT0KYm56IG1haW5fbDEwCmVycgptYWluX2wxMDoKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KYXNzZXJ0CmNhbGxzdWIgZGVsZXRlXzEKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDExOgp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiB1cGRhdGVfMAppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMTI6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydAppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIHVwZGF0ZQp1cGRhdGVfMDoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX1VQREFUQUJMRSAvLyBUTVBMX1VQREFUQUJMRQovLyBDaGVjayBhcHAgaXMgdXBkYXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGRlbGV0ZQpkZWxldGVfMToKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX0RFTEVUQUJMRSAvLyBUTVBMX0RFTEVUQUJMRQovLyBDaGVjayBhcHAgaXMgZGVsZXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzI6CnByb3RvIDEgMQpwdXNoYnl0ZXMgMHggLy8gIiIKcHVzaGJ5dGVzIDB4NDg2NTZjNmM2ZjJjMjAgLy8gIkhlbGxvLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBoZWxsb193b3JsZF9jaGVjawpoZWxsb3dvcmxkY2hlY2tfMzoKcHJvdG8gMSAwCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApwdXNoYnl0ZXMgMHg1NzZmNzI2YzY0IC8vICJXb3JsZCIKPT0KYXNzZXJ0CnJldHN1Yg==\",", "  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMQp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDAyYmVjZTExIC8vICJoZWxsbyhzdHJpbmcpc3RyaW5nIgo9PQpibnogbWFpbl9sNQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGJmOWMxZWRmIC8vICJoZWxsb193b3JsZF9jaGVjayhzdHJpbmcpdm9pZCIKPT0KYm56IG1haW5fbDQKZXJyCm1haW5fbDQ6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBoZWxsb3dvcmxkY2hlY2tfMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGhlbGxvXzIKc3RvcmUgMApwdXNoYnl0ZXMgMHgxNTFmN2M3NSAvLyAweDE1MWY3Yzc1CmxvYWQgMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w2Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CmJueiBtYWluX2wxMgp0eG4gT25Db21wbGV0aW9uCnB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sMTEKdHhuIE9uQ29tcGxldGlvbgpwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KPT0KYm56IG1haW5fbDEwCmVycgptYWluX2wxMDoKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KYXNzZXJ0CmNhbGxzdWIgZGVsZXRlXzEKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDExOgp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiB1cGRhdGVfMAppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMTI6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydAppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIHVwZGF0ZQp1cGRhdGVfMDoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX1VQREFUQUJMRSAvLyBUTVBMX1VQREFUQUJMRQovLyBDaGVjayBhcHAgaXMgdXBkYXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGRlbGV0ZQpkZWxldGVfMToKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX0RFTEVUQUJMRSAvLyBUTVBMX0RFTEVUQUJMRQovLyBDaGVjayBhcHAgaXMgZGVsZXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzI6CnByb3RvIDEgMQpwdXNoYnl0ZXMgMHggLy8gIiIKcHVzaGJ5dGVzIDB4NDg2NTZjNmM2ZjJjMjAgLy8gIkhlbGxvLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBoZWxsb193b3JsZF9jaGVjawpoZWxsb3dvcmxkY2hlY2tfMzoKcHJvdG8gMSAwCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApwdXNoYnl0ZXMgMHg1NzZmNzI2YzY0IC8vICJXb3JsZCIKPT0KYXNzZXJ0CnJldHN1Yg==\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    },\n    \"local\": {", "    },\n    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"schema\": {\n    \"global\": {\n      \"declared\": {},\n      \"reserved\": {}", "      \"declared\": {},\n      \"reserved\": {}\n    },\n    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    }\n  },\n  \"contract\": {\n    \"name\": \"HelloWorldApp\",", "  \"contract\": {\n    \"name\": \"HelloWorldApp\",\n    \"methods\": [\n      {\n        \"name\": \"hello\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"name\"\n          }", "            \"name\": \"name\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        },\n        \"desc\": \"Returns Hello, {name}\"\n      },\n      {\n        \"name\": \"hello_world_check\",", "      {\n        \"name\": \"hello_world_check\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"name\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"", "        \"returns\": {\n          \"type\": \"void\"\n        },\n        \"desc\": \"Asserts {name} is \\\"World\\\"\"\n      }\n    ],\n    \"networks\": {}\n  },\n  \"bare_call_config\": {\n    \"delete_application\": \"CALL\",", "  \"bare_call_config\": {\n    \"delete_application\": \"CALL\",\n    \"no_op\": \"CREATE\",\n    \"update_application\": \"CALL\"\n  }\n}\n\n/**\n * Defines an onCompletionAction of 'no_op'\n */\nexport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */", " * Defines an onCompletionAction of 'no_op'\n */\nexport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */\nexport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n/**\n * Defines an onCompletionAction of 'close_out'\n */\nexport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */", "export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */\nexport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n/**\n * Defines an onCompletionAction of 'update_application'\n */\nexport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */", "export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */\nexport type IntegerState = {\n  /**\n   * Gets the state value as a BigInt \n   */\n  asBigInt(): bigint\n  /**\n   * Gets the state value as a number.\n   */\n  asNumber(): number\n}\n/**\n * A state record containing binary data\n */", "export type BinaryState = {\n  /**\n   * Gets the state value as a Uint8Array\n   */\n  asByteArray(): Uint8Array\n  /**\n   * Gets the state value as a string\n   */\n  asString(): string\n}\n\n/**\n * Defines the types of available calls and state of the HelloWorldApp smart contract.\n */", "export type HelloWorldApp = {\n  /**\n   * Maps method signatures / names to their argument and return types.\n   */\n  methods:\n    & Record<'hello(string)string' | 'hello', {\n      argsObj: {\n        name: string\n      }\n      argsTuple: [name: string]\n      returns: string\n    }>\n    & Record<'hello_world_check(string)void' | 'hello_world_check', {\n      argsObj: {\n        name: string\n      }\n      argsTuple: [name: string]\n      returns: void\n    }>\n}\n/**\n * Defines the possible abi call signatures\n */", "export type HelloWorldAppSig = keyof HelloWorldApp['methods']\n/**\n * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n */\nexport type TypedCallParams<TSignature extends HelloWorldAppSig | undefined> = {\n  method: TSignature\n  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n} & AppClientCallCoreParams & CoreAppCallArgs\n/**\n * Defines the arguments required for a bare call\n */", "export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n/**\n * Maps a method signature from the HelloWorldApp smart contract to the method's arguments in either tuple of struct form\n */\nexport type MethodArgs<TSignature extends HelloWorldAppSig> = HelloWorldApp['methods'][TSignature]['argsObj' | 'argsTuple']\n/**\n * Maps a method signature from the HelloWorldApp smart contract to the method's return type\n */\nexport type MethodReturn<TSignature extends HelloWorldAppSig> = HelloWorldApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */", "export type MethodReturn<TSignature extends HelloWorldAppSig> = HelloWorldApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */\nexport type HelloWorldAppCreateCalls = (typeof HelloWorldAppCallFactory)['create']\n/**\n * Defines supported create methods for this smart contract\n */\nexport type HelloWorldAppCreateCallParams =\n  | (TypedCallParams<undefined> & (OnCompleteNoOp))\n/**\n * A factory for available 'update' calls\n */", "export type HelloWorldAppCreateCallParams =\n  | (TypedCallParams<undefined> & (OnCompleteNoOp))\n/**\n * A factory for available 'update' calls\n */\nexport type HelloWorldAppUpdateCalls = (typeof HelloWorldAppCallFactory)['update']\n/**\n * Defines supported update methods for this smart contract\n */\nexport type HelloWorldAppUpdateCallParams =\n  | TypedCallParams<undefined>\n/**\n * A factory for available 'delete' calls\n */", "export type HelloWorldAppUpdateCallParams =\n  | TypedCallParams<undefined>\n/**\n * A factory for available 'delete' calls\n */\nexport type HelloWorldAppDeleteCalls = (typeof HelloWorldAppCallFactory)['delete']\n/**\n * Defines supported delete methods for this smart contract\n */\nexport type HelloWorldAppDeleteCallParams =\n  | TypedCallParams<undefined>\n/**\n * Defines arguments required for the deploy method.\n */", "export type HelloWorldAppDeleteCallParams =\n  | TypedCallParams<undefined>\n/**\n * Defines arguments required for the deploy method.\n */\nexport type HelloWorldAppDeployArgs = {\n  deployTimeParams?: TealTemplateParams\n  /**\n   * A delegate which takes a create call factory and returns the create call params for this smart contract\n   */\n  createCall?: (callFactory: HelloWorldAppCreateCalls) => HelloWorldAppCreateCallParams\n  /**\n   * A delegate which takes a update call factory and returns the update call params for this smart contract\n   */\n  updateCall?: (callFactory: HelloWorldAppUpdateCalls) => HelloWorldAppUpdateCallParams\n  /**\n   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n   */\n  deleteCall?: (callFactory: HelloWorldAppDeleteCalls) => HelloWorldAppDeleteCallParams\n}\n\n\n/**\n * Exposes methods for constructing all available smart contract calls\n */", "export abstract class HelloWorldAppCallFactory {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the HelloWorldApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the HelloWorldApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available delete call factories\n   */\n  static get delete() {\n    return {\n      /**\n       * Constructs a delete call for the HelloWorldApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Constructs a no op call for the hello(string)string ABI method\n   *\n   * Returns Hello, {name}\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static hello(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'hello(string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.name],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the hello_world_check(string)void ABI method\n   *\n   * Asserts {name} is \"World\"\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'hello_world_check(string)void' as const,\n      methodArgs: Array.isArray(args) ? args : [args.name],\n      ...params,\n    }\n  }\n}\n\n/**\n * A client to make calls to the HelloWorldApp smart contract\n */", "export class HelloWorldAppClient {\n  /**\n   * The underlying `ApplicationClient` for when you want to have more flexibility\n   */\n  public readonly appClient: ApplicationClient\n\n  private readonly sender: SendTransactionFrom | undefined\n\n  /**\n   * Creates a new instance of `HelloWorldAppClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails: AppDetails, private algod: Algodv2) {\n    this.sender = appDetails.sender\n    this.appClient = algokit.getAppClient({\n      ...appDetails,\n      app: APP_SPEC\n    }, algod)\n  }\n\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {", "    if(result.return?.decodeError) {\n      throw result.return.decodeError\n    }\n    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n      ? returnValueFormatter(result.return.returnValue)\n      : result.return?.returnValue as TReturn | undefined\n      return { ...result, return: returnValue }\n  }\n\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  public async call<TSignature extends keyof HelloWorldApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n  }\n\n  /**\n   * Idempotently deploys the HelloWorldApp smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  public deploy(params: HelloWorldAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n    const createArgs = params.createCall?.(HelloWorldAppCallFactory.create)\n    const updateArgs = params.updateCall?.(HelloWorldAppCallFactory.update)\n    const deleteArgs = params.deleteCall?.(HelloWorldAppCallFactory.delete)\n    return this.appClient.deploy({\n      ...params,\n      updateArgs,\n      deleteArgs,\n      createArgs,\n      createOnCompleteAction: createArgs?.onCompleteAction,\n    })\n  }\n\n  /**\n   * Gets available create methods\n   */\n  public get create() {\n    const $this = this\n    return {\n      /**\n       * Creates a new instance of the HelloWorldApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The create result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.create(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n    }\n  }\n\n  /**\n   * Gets available update methods\n   */\n  public get update() {\n    const $this = this\n    return {\n      /**\n       * Updates an existing instance of the HelloWorldApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The update result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.update(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n    }\n  }\n\n  /**\n   * Gets available delete methods\n   */\n  public get delete() {\n    const $this = this\n    return {\n      /**\n       * Deletes an existing instance of the HelloWorldApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The delete result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.delete(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n    }\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the HelloWorldApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.appClient.clearState(args)\n  }\n\n  /**\n   * Calls the hello(string)string ABI method.\n   *\n   * Returns Hello, {name}\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public hello(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(HelloWorldAppCallFactory.hello(args, params))\n  }\n\n  /**\n   * Calls the hello_world_check(string)void ABI method.\n   *\n   * Asserts {name} is \"World\"\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(HelloWorldAppCallFactory.helloWorldCheck(args, params))\n  }\n\n  public compose(): HelloWorldAppComposer {\n    const client = this\n    const atc = new AtomicTransactionComposer()\n    let promiseChain:Promise<unknown> = Promise.resolve()\n    const resultMappers: Array<undefined | ((x: any) => any)> = []\n    return {\n      hello(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.hello(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.helloWorldCheck(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      get update() {\n        const $this = this\n        return {\n          bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs) {\n            promiseChain = promiseChain.then(() => client.update.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      get delete() {\n        const $this = this\n        return {\n          bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n            promiseChain = promiseChain.then(() => client.delete.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n        return this\n      },\n      async atc() {\n        await promiseChain\n        return atc\n      },\n      async execute() {\n        await promiseChain\n        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n        return {\n          ...result,\n          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n        }\n      }\n    } as unknown as HelloWorldAppComposer\n  }\n}", "export type HelloWorldAppComposer<TReturns extends [...any[]] = []> = {\n  /**\n   * Calls the hello(string)string ABI method.\n   *\n   * Returns Hello, {name}\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  hello(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, MethodReturn<'hello(string)string'>]>\n\n  /**\n   * Calls the hello_world_check(string)void ABI method.\n   *\n   * Asserts {name} is \"World\"\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, MethodReturn<'hello_world_check(string)void'>]>\n\n  /**\n   * Gets available update methods\n   */\n  readonly update: {\n    /**\n     * Updates an existing instance of the HelloWorldApp smart contract using a bare call.\n     *\n     * @param args The arguments for the bare call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, undefined]>\n  }\n\n  /**\n   * Gets available delete methods\n   */\n  readonly delete: {\n    /**\n     * Deletes an existing instance of the HelloWorldApp smart contract using a bare call.\n     *\n     * @param args The arguments for the bare call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, undefined]>\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the HelloWorldApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, undefined]>\n\n  /**\n   * Adds a transaction to the composer\n   *\n   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n   */\n  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): HelloWorldAppComposer<TReturns>\n  /**\n   * Returns the underlying AtomicTransactionComposer instance\n   */\n  atc(): Promise<AtomicTransactionComposer>\n  /**\n   * Executes the transaction group and returns an array of results\n   */\n  execute(): Promise<HelloWorldAppComposerResults<TReturns>>\n}", "export type HelloWorldAppComposerResults<TReturns extends [...any[]]> = {\n  returns: TReturns\n  groupId: string\n  txIds: string[]\n  transactions: Transaction[]\n}\n"]}
{"filename": "examples/lifecycle/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { beforeEach, describe, expect, test } from '@jest/globals'\nimport { OnApplicationComplete } from 'algosdk'\nimport invariant from 'tiny-invariant'\nimport { expectType } from 'tsd'\nimport { LifeCycleAppClient } from './client'\n\ndescribe('lifecycle typed client', () => {\n  const localnet = algorandFixture()\n  beforeEach(localnet.beforeEach, 10_000)", "  const localnet = algorandFixture()\n  beforeEach(localnet.beforeEach, 10_000)\n\n  let client: LifeCycleAppClient\n\n  beforeEach(() => {\n    const { algod, indexer, testAccount } = localnet.context\n    client = new LifeCycleAppClient(\n      {\n        resolveBy: 'creatorAndName',", "      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n  })\n", "  })\n\n  test('create_bare', async () => {\n    const createResult = await client.create.bare({ updatable: true })\n    expectType<undefined>(createResult.return)\n    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.NoOpOC)\n\n    const response = await client.helloStringString(['Bare'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('Hello, Bare\\n')", "    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('Hello, Bare\\n')\n  })\n\n  test('create_bare_optin', async () => {\n    const createResult = await client.create.bare({ updatable: true, onCompleteAction: 'opt_in' })\n    expectType<undefined>(createResult.return)\n    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.OptInOC)\n\n    const response = await client.helloStringString(['Bare'])", "\n    const response = await client.helloStringString(['Bare'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('Hello, Bare\\n')\n  })\n\n  test('deploy_bare', async () => {\n    const createResult = await client.deploy()\n    invariant(createResult.operationPerformed === 'create')\n    // The return in deploy isn't strongly typed since it's too complex to do", "    invariant(createResult.operationPerformed === 'create')\n    // The return in deploy isn't strongly typed since it's too complex to do\n    expect(createResult.return?.returnValue).toBe(undefined)\n    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.NoOpOC)\n\n    const response = await client.helloStringString(['Bare'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('Hello, Bare\\n')\n  })\n", "  })\n\n  test('deploy_bare_opt_in', async () => {\n    const createResult = await client.deploy({\n      createCall: (calls) => calls.bare({ onCompleteAction: 'opt_in' }),\n    })\n    invariant(createResult.operationPerformed === 'create')\n    // The return in deploy isn't strongly typed since it's too complex to do\n    expect(createResult.return?.returnValue).toBe(undefined)\n    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.OptInOC)", "    expect(createResult.return?.returnValue).toBe(undefined)\n    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.OptInOC)\n\n    const response = await client.helloStringString(['Bare'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('Hello, Bare\\n')\n  })\n\n  test('create_1arg', async () => {\n    const createResult = await client.create.createStringString({ greeting: 'greeting' }, { updatable: true })", "  test('create_1arg', async () => {\n    const createResult = await client.create.createStringString({ greeting: 'greeting' }, { updatable: true })\n    expectType<string | undefined>(createResult.return)\n    expect(createResult.return).toBe('greeting_1')\n\n    const response = await client.helloStringString(['1 Arg'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('greeting, 1 Arg\\n')\n  })\n", "  })\n\n  test('deploy_create_1arg', async () => {\n    const createResult = await client.deploy({\n      createCall: (calls) => calls.createStringString({ greeting: 'greeting' }),\n    })\n    invariant(createResult.operationPerformed === 'create')\n    // The return in deploy isn't strongly typed since it's too complex to do\n    expect(createResult.return?.returnValue).toBe('greeting_1')\n", "    expect(createResult.return?.returnValue).toBe('greeting_1')\n\n    const response = await client.helloStringString(['1 Arg'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('greeting, 1 Arg\\n')\n  })\n\n  test('create_2arg', async () => {\n    const createResult = await client.create.createStringUint32Void({ greeting: 'Greetings', times: 2 }, { updatable: true })\n    expectType<void | undefined>(createResult.return)", "    const createResult = await client.create.createStringUint32Void({ greeting: 'Greetings', times: 2 }, { updatable: true })\n    expectType<void | undefined>(createResult.return)\n\n    const response = await client.helloStringString(['2 Arg'])\n    expectType<string | undefined>(response.return)\n    expect(response.return).toBe('Greetings, 2 Arg\\nGreetings, 2 Arg\\n')\n  })\n})\n", ""]}
{"filename": "examples/lifecycle/client.ts", "chunked_list": ["/* eslint-disable */\n/**\n * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n * DO NOT MODIFY IT BY HAND.\n * requires: @algorandfoundation/algokit-utils: ^2\n */\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport type {\n  AppCallTransactionResult,\n  AppCallTransactionResultOfType,", "  AppCallTransactionResult,\n  AppCallTransactionResultOfType,\n  CoreAppCallArgs,\n  RawAppCallArgs,\n  AppState,\n  TealTemplateParams,\n  ABIAppCallArg,\n} from '@algorandfoundation/algokit-utils/types/app'\nimport type {\n  AppClientCallCoreParams,", "import type {\n  AppClientCallCoreParams,\n  AppClientCompilationParams,\n  AppClientDeployCoreParams,\n  AppDetails,\n  ApplicationClient,\n} from '@algorandfoundation/algokit-utils/types/app-client'\nimport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\nimport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'", "import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'\nimport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\nexport const APP_SPEC: AppSpec = {\n  \"hints\": {\n    \"hello(string)string\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },", "      }\n    },\n    \"hello()string\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"create(string)string\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"", "      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },\n    \"create(string,uint32)void\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    }\n  },", "    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMApieXRlY2Jsb2NrIDB4IDB4NzQ2OTZkNjU3MyAweDY3NzI2NTY1NzQ2OTZlNjcgMHgxNTFmN2M3NQp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgwMmJlY2UxMSAvLyAiaGVsbG8oc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDkKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhYjA2YzFhOCAvLyAiaGVsbG8oKXN0cmluZyIKPT0KYm56IG1haW5fbDgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg5N2YxZmMxMSAvLyAiY3JlYXRlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2w3CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4NjAxOTMyNjQgLy8gImNyZWF0ZShzdHJpbmcsdWludDMyKXZvaWQiCj09CmJueiBtYWluX2w2CmVycgptYWluX2w2Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCnN0b3JlIDMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgppbnRjXzAgLy8gMApleHRyYWN0X3VpbnQzMgpzdG9yZSA0CmxvYWQgMwpsb2FkIDQKY2FsbHN1YiBjcmVhdGVfNwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNzoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAo9PQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGNyZWF0ZV82CnN0b3JlIDIKYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CmxvYWQgMgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w4Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGhlbGxvXzQKc3RvcmUgMQpieXRlY18zIC8vIDB4MTUxZjdjNzUKbG9hZCAxCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDk6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBoZWxsb18zCnN0b3JlIDAKYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CmxvYWQgMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxMDoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQpibnogbWFpbl9sMTYKdHhuIE9uQ29tcGxldGlvbgppbnRjXzEgLy8gT3B0SW4KPT0KYm56IG1haW5fbDE1CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCA0IC8vIFVwZGF0ZUFwcGxpY2F0aW9uCj09CmJueiBtYWluX2wxNAplcnIKbWFpbl9sMTQ6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIHVwZGF0ZV8yCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxNToKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKPT0KYXNzZXJ0CmNhbGxzdWIgYmFyZWNyZWF0ZV81CmludGNfMSAvLyAxCnJldHVybgptYWluX2wxNjoKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKPT0KYXNzZXJ0CmNhbGxzdWIgYmFyZWNyZWF0ZV81CmludGNfMSAvLyAxCnJldHVybgoKLy8gaW50X3RvX2FzY2lpCmludHRvYXNjaWlfMDoKcHJvdG8gMSAxCnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18xIC8vIDEKZXh0cmFjdDMKcmV0c3ViCgovLyBpdG9hCml0b2FfMToKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV8xX2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzFfbDQKYnl0ZWNfMCAvLyAiIgppdG9hXzFfbDM6CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKJQpjYWxsc3ViIGludHRvYXNjaWlfMApjb25jYXQKYiBpdG9hXzFfbDYKaXRvYV8xX2w0OgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCi8KY2FsbHN1YiBpdG9hXzEKYiBpdG9hXzFfbDMKaXRvYV8xX2w1OgpwdXNoYnl0ZXMgMHgzMCAvLyAiMCIKaXRvYV8xX2w2OgpyZXRzdWIKCi8vIHVwZGF0ZQp1cGRhdGVfMjoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX1VQREFUQUJMRSAvLyBUTVBMX1VQREFUQUJMRQovLyBDaGVjayBhcHAgaXMgdXBkYXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzM6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmJ5dGVjXzAgLy8gIiIKc3RvcmUgNQppbnRjXzAgLy8gMApzdG9yZSA2CmhlbGxvXzNfbDE6CmxvYWQgNgpieXRlY18xIC8vICJ0aW1lcyIKYXBwX2dsb2JhbF9nZXQKPApieiBoZWxsb18zX2wzCmxvYWQgNQpieXRlY18yIC8vICJncmVldGluZyIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJjMjAgLy8gIiwgIgpjb25jYXQKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNvbmNhdApwdXNoYnl0ZXMgMHgwYSAvLyAiXG4iCmNvbmNhdApzdG9yZSA1CmxvYWQgNgppbnRjXzEgLy8gMQorCnN0b3JlIDYKYiBoZWxsb18zX2wxCmhlbGxvXzNfbDM6CmxvYWQgNQpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzQ6CnByb3RvIDAgMQpieXRlY18wIC8vICIiCmJ5dGVjXzAgLy8gIiIKc3RvcmUgNwppbnRjXzAgLy8gMApzdG9yZSA4CmhlbGxvXzRfbDE6CmxvYWQgOApieXRlY18xIC8vICJ0aW1lcyIKYXBwX2dsb2JhbF9nZXQKPApieiBoZWxsb180X2wzCmxvYWQgNwpieXRlY18yIC8vICJncmVldGluZyIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJjMjA2ZDc5NzM3NDY1NzI3OTIwNzA2NTcyNzM2ZjZlMGEgLy8gIiwgbXlzdGVyeSBwZXJzb25cbiIKY29uY2F0CnN0b3JlIDcKbG9hZCA4CmludGNfMSAvLyAxCisKc3RvcmUgOApiIGhlbGxvXzRfbDEKaGVsbG9fNF9sMzoKbG9hZCA3CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gYmFyZV9jcmVhdGUKYmFyZWNyZWF0ZV81Ogpwcm90byAwIDAKYnl0ZWNfMiAvLyAiZ3JlZXRpbmciCnB1c2hieXRlcyAweDQ4NjU2YzZjNmYgLy8gIkhlbGxvIgphcHBfZ2xvYmFsX3B1dApieXRlY18xIC8vICJ0aW1lcyIKaW50Y18xIC8vIDEKYXBwX2dsb2JhbF9wdXQKaW50Y18xIC8vIDEKcmV0dXJuCgovLyBjcmVhdGUKY3JlYXRlXzY6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmJ5dGVjXzIgLy8gImdyZWV0aW5nIgpmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWNfMSAvLyAidGltZXMiCmludGNfMSAvLyAxCmFwcF9nbG9iYWxfcHV0CmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApwdXNoYnl0ZXMgMHg1ZiAvLyAiXyIKY29uY2F0CmJ5dGVjXzEgLy8gInRpbWVzIgphcHBfZ2xvYmFsX2dldApjYWxsc3ViIGl0b2FfMQpjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBjcmVhdGUKY3JlYXRlXzc6CnByb3RvIDIgMApieXRlY18yIC8vICJncmVldGluZyIKZnJhbWVfZGlnIC0yCmV4dHJhY3QgMiAwCmFwcF9nbG9iYWxfcHV0CmJ5dGVjXzEgLy8gInRpbWVzIgpmcmFtZV9kaWcgLTEKYXBwX2dsb2JhbF9wdXQKaW50Y18xIC8vIDEKcmV0dXJu\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDEKY2FsbHN1YiBjbGVhcl8wCmludGNfMCAvLyAxCnJldHVybgoKLy8gY2xlYXIKY2xlYXJfMDoKcHJvdG8gMCAwCmludGNfMCAvLyAxCnJldHVybg==\"\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 1,\n      \"num_uints\": 1", "      \"num_byte_slices\": 1,\n      \"num_uints\": 1\n    },\n    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"schema\": {\n    \"global\": {", "  \"schema\": {\n    \"global\": {\n      \"declared\": {\n        \"greeting\": {\n          \"type\": \"bytes\",\n          \"key\": \"greeting\",\n          \"descr\": \"\"\n        },\n        \"times\": {\n          \"type\": \"uint64\",", "        \"times\": {\n          \"type\": \"uint64\",\n          \"key\": \"times\",\n          \"descr\": \"\"\n        }\n      },\n      \"reserved\": {}\n    },\n    \"local\": {\n      \"declared\": {},", "    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    }\n  },\n  \"contract\": {\n    \"name\": \"LifeCycleApp\",\n    \"methods\": [\n      {\n        \"name\": \"hello\",", "      {\n        \"name\": \"hello\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"name\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"", "        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"hello\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"string\"\n        }", "          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"create\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"greeting\",\n            \"desc\": \"The greeting\"", "            \"name\": \"greeting\",\n            \"desc\": \"The greeting\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\",\n          \"desc\": \"The formatted greeting\"\n        },\n        \"desc\": \"ABI create method with 1 argument\"\n      },", "        \"desc\": \"ABI create method with 1 argument\"\n      },\n      {\n        \"name\": \"create\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"greeting\"\n          },\n          {", "          },\n          {\n            \"type\": \"uint32\",\n            \"name\": \"times\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        },\n        \"desc\": \"ABI create method with 2 arguments\"", "        },\n        \"desc\": \"ABI create method with 2 arguments\"\n      }\n    ],\n    \"networks\": {}\n  },\n  \"bare_call_config\": {\n    \"no_op\": \"CREATE\",\n    \"opt_in\": \"CREATE\",\n    \"update_application\": \"CALL\"", "    \"opt_in\": \"CREATE\",\n    \"update_application\": \"CALL\"\n  }\n}\n\n/**\n * Defines an onCompletionAction of 'no_op'\n */\nexport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */", "export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */\nexport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n/**\n * Defines an onCompletionAction of 'close_out'\n */\nexport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */", "export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */\nexport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n/**\n * Defines an onCompletionAction of 'update_application'\n */\nexport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */", "export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */\nexport type IntegerState = {\n  /**\n   * Gets the state value as a BigInt \n   */\n  asBigInt(): bigint\n  /**\n   * Gets the state value as a number.\n   */\n  asNumber(): number\n}\n/**\n * A state record containing binary data\n */", "export type BinaryState = {\n  /**\n   * Gets the state value as a Uint8Array\n   */\n  asByteArray(): Uint8Array\n  /**\n   * Gets the state value as a string\n   */\n  asString(): string\n}\n\n/**\n * Defines the types of available calls and state of the LifeCycleApp smart contract.\n */", "export type LifeCycleApp = {\n  /**\n   * Maps method signatures / names to their argument and return types.\n   */\n  methods:\n    & Record<'hello(string)string', {\n      argsObj: {\n        name: string\n      }\n      argsTuple: [name: string]\n      returns: string\n    }>\n    & Record<'hello()string', {\n      argsObj: {\n      }\n      argsTuple: []\n      returns: string\n    }>\n    & Record<'create(string)string', {\n      argsObj: {\n        /**\n         * The greeting\n         */\n        greeting: string\n      }\n      argsTuple: [greeting: string]\n      /**\n       * The formatted greeting\n       */\n      returns: string\n    }>\n    & Record<'create(string,uint32)void', {\n      argsObj: {\n        greeting: string\n        times: number\n      }\n      argsTuple: [greeting: string, times: number]\n      returns: void\n    }>\n  /**\n   * Defines the shape of the global and local state of the application.\n   */\n  state: {\n    global: {\n      'greeting'?: BinaryState\n      'times'?: IntegerState\n    }\n  }\n}\n/**\n * Defines the possible abi call signatures\n */", "export type LifeCycleAppSig = keyof LifeCycleApp['methods']\n/**\n * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n */\nexport type TypedCallParams<TSignature extends LifeCycleAppSig | undefined> = {\n  method: TSignature\n  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n} & AppClientCallCoreParams & CoreAppCallArgs\n/**\n * Defines the arguments required for a bare call\n */", "export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n/**\n * Maps a method signature from the LifeCycleApp smart contract to the method's arguments in either tuple of struct form\n */\nexport type MethodArgs<TSignature extends LifeCycleAppSig> = LifeCycleApp['methods'][TSignature]['argsObj' | 'argsTuple']\n/**\n * Maps a method signature from the LifeCycleApp smart contract to the method's return type\n */\nexport type MethodReturn<TSignature extends LifeCycleAppSig> = LifeCycleApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */", "export type MethodReturn<TSignature extends LifeCycleAppSig> = LifeCycleApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */\nexport type LifeCycleAppCreateCalls = (typeof LifeCycleAppCallFactory)['create']\n/**\n * Defines supported create methods for this smart contract\n */\nexport type LifeCycleAppCreateCallParams =\n  | (TypedCallParams<undefined> & (OnCompleteNoOp | OnCompleteOptIn))\n  | (TypedCallParams<'create(string)string'> & (OnCompleteNoOp))\n  | (TypedCallParams<'create(string,uint32)void'> & (OnCompleteNoOp))\n/**\n * A factory for available 'update' calls\n */", "export type LifeCycleAppCreateCallParams =\n  | (TypedCallParams<undefined> & (OnCompleteNoOp | OnCompleteOptIn))\n  | (TypedCallParams<'create(string)string'> & (OnCompleteNoOp))\n  | (TypedCallParams<'create(string,uint32)void'> & (OnCompleteNoOp))\n/**\n * A factory for available 'update' calls\n */\nexport type LifeCycleAppUpdateCalls = (typeof LifeCycleAppCallFactory)['update']\n/**\n * Defines supported update methods for this smart contract\n */", "export type LifeCycleAppUpdateCallParams =\n  | TypedCallParams<undefined>\n/**\n * Defines arguments required for the deploy method.\n */\nexport type LifeCycleAppDeployArgs = {\n  deployTimeParams?: TealTemplateParams\n  /**\n   * A delegate which takes a create call factory and returns the create call params for this smart contract\n   */\n  createCall?: (callFactory: LifeCycleAppCreateCalls) => LifeCycleAppCreateCallParams\n  /**\n   * A delegate which takes a update call factory and returns the update call params for this smart contract\n   */\n  updateCall?: (callFactory: LifeCycleAppUpdateCalls) => LifeCycleAppUpdateCallParams\n}\n\n\n/**\n * Exposes methods for constructing all available smart contract calls\n */", "export abstract class LifeCycleAppCallFactory {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the LifeCycleApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp | OnCompleteOptIn) = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n      /**\n       * Constructs a create call for the LifeCycleApp smart contract using the create(string)string ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createStringString(args: MethodArgs<'create(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n        return {\n          method: 'create(string)string' as const,\n          methodArgs: Array.isArray(args) ? args : [args.greeting],\n          ...params,\n        }\n      },\n      /**\n       * Constructs a create call for the LifeCycleApp smart contract using the create(string,uint32)void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createStringUint32Void(args: MethodArgs<'create(string,uint32)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n        return {\n          method: 'create(string,uint32)void' as const,\n          methodArgs: Array.isArray(args) ? args : [args.greeting, args.times],\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the LifeCycleApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Constructs a no op call for the hello(string)string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static helloStringString(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'hello(string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.name],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the hello()string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static helloString(args: MethodArgs<'hello()string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'hello()string' as const,\n      methodArgs: Array.isArray(args) ? args : [],\n      ...params,\n    }\n  }\n}\n\n/**\n * A client to make calls to the LifeCycleApp smart contract\n */", "export class LifeCycleAppClient {\n  /**\n   * The underlying `ApplicationClient` for when you want to have more flexibility\n   */\n  public readonly appClient: ApplicationClient\n\n  private readonly sender: SendTransactionFrom | undefined\n\n  /**\n   * Creates a new instance of `LifeCycleAppClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails: AppDetails, private algod: Algodv2) {\n    this.sender = appDetails.sender\n    this.appClient = algokit.getAppClient({\n      ...appDetails,\n      app: APP_SPEC\n    }, algod)\n  }\n\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {", "    if(result.return?.decodeError) {\n      throw result.return.decodeError\n    }\n    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n      ? returnValueFormatter(result.return.returnValue)\n      : result.return?.returnValue as TReturn | undefined\n      return { ...result, return: returnValue }\n  }\n\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  public async call<TSignature extends keyof LifeCycleApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n  }\n\n  /**\n   * Idempotently deploys the LifeCycleApp smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  public deploy(params: LifeCycleAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n    const createArgs = params.createCall?.(LifeCycleAppCallFactory.create)\n    const updateArgs = params.updateCall?.(LifeCycleAppCallFactory.update)\n    return this.appClient.deploy({\n      ...params,\n      updateArgs,\n      createArgs,\n      createOnCompleteAction: createArgs?.onCompleteAction,\n    })\n  }\n\n  /**\n   * Gets available create methods\n   */\n  public get create() {\n    const $this = this\n    return {\n      /**\n       * Creates a new instance of the LifeCycleApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The create result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs & (OnCompleteNoOp | OnCompleteOptIn) = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.create(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n      /**\n       * Creates a new instance of the LifeCycleApp smart contract using the create(string)string ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result: The formatted greeting\n       */\n      async createStringString(args: MethodArgs<'create(string)string'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create(string)string'>>> {\n        return $this.mapReturnValue(await $this.appClient.create(LifeCycleAppCallFactory.create.createStringString(args, params)))\n      },\n      /**\n       * Creates a new instance of the LifeCycleApp smart contract using the create(string,uint32)void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      async createStringUint32Void(args: MethodArgs<'create(string,uint32)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create(string,uint32)void'>>> {\n        return $this.mapReturnValue(await $this.appClient.create(LifeCycleAppCallFactory.create.createStringUint32Void(args, params)))\n      },\n    }\n  }\n\n  /**\n   * Gets available update methods\n   */\n  public get update() {\n    const $this = this\n    return {\n      /**\n       * Updates an existing instance of the LifeCycleApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The update result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.update(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n    }\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the LifeCycleApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.appClient.clearState(args)\n  }\n\n  /**\n   * Calls the hello(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public helloStringString(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(LifeCycleAppCallFactory.helloStringString(args, params))\n  }\n\n  /**\n   * Calls the hello()string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public helloString(args: MethodArgs<'hello()string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(LifeCycleAppCallFactory.helloString(args, params))\n  }\n\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {\n    const value = state[key]", "    if (!value) return undefined\n    if (!('valueRaw' in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)\n    return {\n      asString(): string {\n        return value.value\n      },\n      asByteArray(): Uint8Array {\n        return value.valueRaw\n      }\n    }\n  }\n\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {\n    const value = state[key]", "    if (!value) return undefined\n    if ('valueRaw' in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)\n    return {\n      asBigInt() {\n        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)\n      },\n      asNumber(): number {\n        return typeof value.value === 'bigint' ? Number(value.value) : value.value\n      },\n    }\n  }\n\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  public async getGlobalState(): Promise<LifeCycleApp['state']['global']> {\n    const state = await this.appClient.getGlobalState()\n    return {\n      get greeting() {\n        return LifeCycleAppClient.getBinaryState(state, 'greeting')\n      },\n      get times() {\n        return LifeCycleAppClient.getIntegerState(state, 'times')\n      },\n    }\n  }\n\n  public compose(): LifeCycleAppComposer {\n    const client = this\n    const atc = new AtomicTransactionComposer()\n    let promiseChain:Promise<unknown> = Promise.resolve()\n    const resultMappers: Array<undefined | ((x: any) => any)> = []\n    return {\n      helloStringString(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.helloStringString(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      helloString(args: MethodArgs<'hello()string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.helloString(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      get update() {\n        const $this = this\n        return {\n          bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs) {\n            promiseChain = promiseChain.then(() => client.update.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n        return this\n      },\n      async atc() {\n        await promiseChain\n        return atc\n      },\n      async execute() {\n        await promiseChain\n        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n        return {\n          ...result,\n          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n        }\n      }\n    } as unknown as LifeCycleAppComposer\n  }\n}", "export type LifeCycleAppComposer<TReturns extends [...any[]] = []> = {\n  /**\n   * Calls the hello(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  helloStringString(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, MethodReturn<'hello(string)string'>]>\n\n  /**\n   * Calls the hello()string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  helloString(args: MethodArgs<'hello()string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, MethodReturn<'hello()string'>]>\n\n  /**\n   * Gets available update methods\n   */\n  readonly update: {\n    /**\n     * Updates an existing instance of the LifeCycleApp smart contract using a bare call.\n     *\n     * @param args The arguments for the bare call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, undefined]>\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the LifeCycleApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, undefined]>\n\n  /**\n   * Adds a transaction to the composer\n   *\n   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n   */\n  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): LifeCycleAppComposer<TReturns>\n  /**\n   * Returns the underlying AtomicTransactionComposer instance\n   */\n  atc(): Promise<AtomicTransactionComposer>\n  /**\n   * Executes the transaction group and returns an array of results\n   */\n  execute(): Promise<LifeCycleAppComposerResults<TReturns>>\n}", "export type LifeCycleAppComposerResults<TReturns extends [...any[]]> = {\n  returns: TReturns\n  groupId: string\n  txIds: string[]\n  transactions: Transaction[]\n}\n"]}
{"filename": "examples/voting/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { beforeEach, describe, expect, test } from '@jest/globals'\nimport * as ed from '@noble/ed25519'\nimport algosdk, { AtomicTransactionComposer } from 'algosdk'\nimport invariant from 'tiny-invariant'\nimport { expectType } from 'tsd'\nimport { VotingPreconditions, VotingRoundAppClient } from './client'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\nconst rndInt = (min: number, max: number) => Math.floor(Math.random() * (max - min)) + min", "\nconst rndInt = (min: number, max: number) => Math.floor(Math.random() * (max - min)) + min\n\ndescribe('voting typed client', () => {\n  const localnet = algorandFixture({\n    testAccountFunding: microAlgos(100_000_000_000),\n  })\n  beforeEach(localnet.beforeEach, 10_000)\n\n  let client: VotingRoundAppClient", "\n  let client: VotingRoundAppClient\n\n  beforeEach(() => {\n    const { algod, indexer, testAccount } = localnet.context\n    client = new VotingRoundAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,", "        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n  })\n\n  async function createRandomVotingRoundApp() {\n    const { algod, testAccount } = localnet.context\n    const status = await algod.status().do()\n    const lastRound = Number(status['last-round'])\n    const round = await algod.block(lastRound).do()\n    const currentTime = Number(round.block.ts)\n\n    const quorum = rndInt(1, 1000)\n    const questionCount = rndInt(1, 10)\n    const questionCounts = new Array(questionCount).fill(0).map((_) => rndInt(1, 10))\n    const totalQuestionOptions = questionCounts.reduce((a, b) => a + b, 0)\n\n    const privateKey = Buffer.from(ed.utils.randomPrivateKey())\n    const publicKey = await ed.getPublicKey(privateKey)\n\n    const createResult = await client.create.create(\n      {\n        vote_id: `V${new Date().getTime().toString(32).toUpperCase()}`,\n        metadata_ipfs_cid: 'cid',\n        start_time: BigInt(currentTime), // todo: allow number and convert\n        end_time: BigInt(currentTime + 1000),\n        quorum: BigInt(quorum),\n        snapshot_public_key: publicKey,\n        nft_image_url: 'ipfs://cid',\n        option_counts: questionCounts,\n      },\n      { deletable: true, sendParams: { fee: (1_000 + 1_000 * 4).microAlgos() } },\n    )\n    expectType<void>(createResult.return)\n\n    const randomAnswerIds = questionCounts.map((c) => rndInt(0, c - 1))\n\n    const decoded = algosdk.decodeAddress(testAccount.addr)\n    const signature = await ed.sign(decoded.publicKey, privateKey)\n    return {\n      algod,\n      totalQuestionOptions,\n      testAccount,\n      privateKey,\n      quorum,\n      questionCount,\n      questionCounts,\n      publicKey,\n      currentTime,\n      signature,\n      randomAnswerIds,\n    }\n  }\n\n  test('struct_mapping', async () => {\n    const { testAccount, totalQuestionOptions, privateKey } = await createRandomVotingRoundApp()\n\n    await client.bootstrap(\n      {\n        fund_min_bal_req: client.appClient.fundAppAccount({\n          amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n          sendParams: { skipSending: true },\n        }),\n      },\n      {\n        boxes: ['V'],\n        sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n      },\n    )\n\n    const decoded = algosdk.decodeAddress(testAccount.addr)\n    const signature = await ed.sign(decoded.publicKey, privateKey)\n    const preconditionsResult = await client.getPreconditions(\n      {\n        signature,\n      },\n      {\n        sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n        boxes: [testAccount],\n      },\n    )\n    expect(preconditionsResult.return).toBeDefined()\n    expectType<VotingPreconditions | undefined>(preconditionsResult.return)\n  })\n\n  test('global_state', async () => {\n    const { questionCounts, currentTime, quorum, publicKey, totalQuestionOptions } = await createRandomVotingRoundApp()\n\n    const state = await client.getGlobalState()\n\n    invariant(state.snapshot_public_key !== undefined)\n    expect(state.snapshot_public_key.asByteArray()).toEqual(publicKey)\n\n    expect(state.metadata_ipfs_cid!.asString()).toBe('cid')\n    expect(state.start_time!.asNumber()).toBe(currentTime)\n    expect(state.end_time!.asNumber()).toBe(currentTime + 1000)\n    expect(state.close_time!.asNumber()).toBe(0)\n    expect(state.quorum!.asNumber()).toBe(quorum)\n    expect(state.is_bootstrapped!.asNumber()).toBe(0)\n    expect(state.voter_count!.asNumber()).toBe(0)\n    expect(state.nft_image_url!.asString()).toBe('ipfs://cid')\n    expect(state.nft_asset_id!.asNumber()).toBe(0)\n    expect(state.total_options!.asNumber()).toBe(totalQuestionOptions)\n    const optionCountsType = new algosdk.ABIArrayDynamicType(new algosdk.ABIUintType(8))\n    expect(optionCountsType.decode(state.option_counts!.asByteArray()).map(Number)).toEqual(questionCounts)\n  })\n\n  describe('given a usage scenario', () => {\n    test('it works with separate transactions', async () => {\n      const { signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\n      const preconditionsResultBefore = await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n          boxes: [testAccount],\n        },\n      )\n\n      expect(preconditionsResultBefore.return?.is_allowed_to_vote).toBe(1n)\n      expect(preconditionsResultBefore.return?.has_already_voted).toBe(0n)\n\n      await client.bootstrap(\n        {\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n            sendParams: { skipSending: true },\n          }),\n        },\n        {\n          boxes: ['V'],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n        },\n      )\n\n      await client.vote(\n        {\n          answer_ids: randomAnswerIds,\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n            sendParams: { skipSending: true },\n          }),\n          signature,\n        },\n        {\n          boxes: ['V', testAccount],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 16) },\n        },\n      )\n      const preconditionsResultAfter = await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n          boxes: [testAccount],\n        },\n      )\n\n      expect(preconditionsResultAfter.return?.has_already_voted).toBe(1n)\n    })\n\n    test('it works with manual use of the AtomicTransactionComposer', async () => {\n      const { algod, signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\n      const atc = new AtomicTransactionComposer()\n      await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000), atc, skipSending: true },\n          boxes: [testAccount],\n        },\n      )\n      await client.bootstrap(\n        {\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n            sendParams: { skipSending: true },\n          }),\n        },\n        {\n          boxes: ['V'],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 4), atc, skipSending: true },\n        },\n      )\n      await client.vote(\n        {\n          answer_ids: randomAnswerIds,\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n            sendParams: { skipSending: true },\n          }),\n          signature,\n        },\n        {\n          boxes: ['V', testAccount],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 16), atc, skipSending: true },\n        },\n      )\n      await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000), atc, skipSending: true },\n          boxes: [testAccount],\n          note: 'hmmm',\n        },\n      )\n      atc.buildGroup()\n\n      const result = await atc.execute(algod, 5)\n\n      expect(result.methodResults).toBeDefined()\n    })\n\n    test('it works using the fluent composer', async () => {\n      const { signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\n      const result = await client\n        .compose()\n        .getPreconditions(\n          {\n            signature,\n          },\n          {\n            sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n            boxes: [testAccount],\n          },\n        )\n        .bootstrap(\n          {\n            fund_min_bal_req: client.appClient.fundAppAccount({\n              amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n              sendParams: { skipSending: true },\n            }),\n          },\n          {\n            boxes: ['V'],\n            sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n          },\n        )\n        .vote(\n          {\n            answer_ids: randomAnswerIds,\n            fund_min_bal_req: client.appClient.fundAppAccount({\n              amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n              sendParams: { skipSending: true },\n            }),\n            signature,\n          },\n          {\n            boxes: ['V', testAccount],\n            sendParams: { fee: microAlgos(1_000 + 1_000 * 16) },\n          },\n        )\n        .getPreconditions(\n          {\n            signature,\n          },\n          {\n            sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n            boxes: [testAccount],\n            note: 'hmmm',\n          },\n        )\n        .execute()\n\n      expect(result.returns[0].has_already_voted).toBe(0n)\n      expect(result.returns[3].has_already_voted).toBe(1n)\n    })\n  })\n})\n", "  async function createRandomVotingRoundApp() {\n    const { algod, testAccount } = localnet.context\n    const status = await algod.status().do()\n    const lastRound = Number(status['last-round'])\n    const round = await algod.block(lastRound).do()\n    const currentTime = Number(round.block.ts)\n\n    const quorum = rndInt(1, 1000)\n    const questionCount = rndInt(1, 10)\n    const questionCounts = new Array(questionCount).fill(0).map((_) => rndInt(1, 10))\n    const totalQuestionOptions = questionCounts.reduce((a, b) => a + b, 0)\n\n    const privateKey = Buffer.from(ed.utils.randomPrivateKey())\n    const publicKey = await ed.getPublicKey(privateKey)\n\n    const createResult = await client.create.create(\n      {\n        vote_id: `V${new Date().getTime().toString(32).toUpperCase()}`,\n        metadata_ipfs_cid: 'cid',\n        start_time: BigInt(currentTime), // todo: allow number and convert\n        end_time: BigInt(currentTime + 1000),\n        quorum: BigInt(quorum),\n        snapshot_public_key: publicKey,\n        nft_image_url: 'ipfs://cid',\n        option_counts: questionCounts,\n      },\n      { deletable: true, sendParams: { fee: (1_000 + 1_000 * 4).microAlgos() } },\n    )\n    expectType<void>(createResult.return)\n\n    const randomAnswerIds = questionCounts.map((c) => rndInt(0, c - 1))\n\n    const decoded = algosdk.decodeAddress(testAccount.addr)\n    const signature = await ed.sign(decoded.publicKey, privateKey)\n    return {\n      algod,\n      totalQuestionOptions,\n      testAccount,\n      privateKey,\n      quorum,\n      questionCount,\n      questionCounts,\n      publicKey,\n      currentTime,\n      signature,\n      randomAnswerIds,\n    }\n  }\n\n  test('struct_mapping', async () => {\n    const { testAccount, totalQuestionOptions, privateKey } = await createRandomVotingRoundApp()\n\n    await client.bootstrap(\n      {\n        fund_min_bal_req: client.appClient.fundAppAccount({\n          amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n          sendParams: { skipSending: true },\n        }),\n      },\n      {\n        boxes: ['V'],\n        sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n      },\n    )\n\n    const decoded = algosdk.decodeAddress(testAccount.addr)\n    const signature = await ed.sign(decoded.publicKey, privateKey)\n    const preconditionsResult = await client.getPreconditions(\n      {\n        signature,\n      },\n      {\n        sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n        boxes: [testAccount],\n      },\n    )\n    expect(preconditionsResult.return).toBeDefined()\n    expectType<VotingPreconditions | undefined>(preconditionsResult.return)\n  })\n\n  test('global_state', async () => {\n    const { questionCounts, currentTime, quorum, publicKey, totalQuestionOptions } = await createRandomVotingRoundApp()\n\n    const state = await client.getGlobalState()\n\n    invariant(state.snapshot_public_key !== undefined)\n    expect(state.snapshot_public_key.asByteArray()).toEqual(publicKey)\n\n    expect(state.metadata_ipfs_cid!.asString()).toBe('cid')\n    expect(state.start_time!.asNumber()).toBe(currentTime)\n    expect(state.end_time!.asNumber()).toBe(currentTime + 1000)\n    expect(state.close_time!.asNumber()).toBe(0)\n    expect(state.quorum!.asNumber()).toBe(quorum)\n    expect(state.is_bootstrapped!.asNumber()).toBe(0)\n    expect(state.voter_count!.asNumber()).toBe(0)\n    expect(state.nft_image_url!.asString()).toBe('ipfs://cid')\n    expect(state.nft_asset_id!.asNumber()).toBe(0)\n    expect(state.total_options!.asNumber()).toBe(totalQuestionOptions)\n    const optionCountsType = new algosdk.ABIArrayDynamicType(new algosdk.ABIUintType(8))\n    expect(optionCountsType.decode(state.option_counts!.asByteArray()).map(Number)).toEqual(questionCounts)\n  })\n\n  describe('given a usage scenario', () => {\n    test('it works with separate transactions', async () => {\n      const { signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\n      const preconditionsResultBefore = await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n          boxes: [testAccount],\n        },\n      )\n\n      expect(preconditionsResultBefore.return?.is_allowed_to_vote).toBe(1n)\n      expect(preconditionsResultBefore.return?.has_already_voted).toBe(0n)\n\n      await client.bootstrap(\n        {\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n            sendParams: { skipSending: true },\n          }),\n        },\n        {\n          boxes: ['V'],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n        },\n      )\n\n      await client.vote(\n        {\n          answer_ids: randomAnswerIds,\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n            sendParams: { skipSending: true },\n          }),\n          signature,\n        },\n        {\n          boxes: ['V', testAccount],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 16) },\n        },\n      )\n      const preconditionsResultAfter = await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n          boxes: [testAccount],\n        },\n      )\n\n      expect(preconditionsResultAfter.return?.has_already_voted).toBe(1n)\n    })\n\n    test('it works with manual use of the AtomicTransactionComposer', async () => {\n      const { algod, signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\n      const atc = new AtomicTransactionComposer()\n      await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000), atc, skipSending: true },\n          boxes: [testAccount],\n        },\n      )\n      await client.bootstrap(\n        {\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n            sendParams: { skipSending: true },\n          }),\n        },\n        {\n          boxes: ['V'],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 4), atc, skipSending: true },\n        },\n      )\n      await client.vote(\n        {\n          answer_ids: randomAnswerIds,\n          fund_min_bal_req: client.appClient.fundAppAccount({\n            amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n            sendParams: { skipSending: true },\n          }),\n          signature,\n        },\n        {\n          boxes: ['V', testAccount],\n          sendParams: { fee: microAlgos(1_000 + 1_000 * 16), atc, skipSending: true },\n        },\n      )\n      await client.getPreconditions(\n        {\n          signature,\n        },\n        {\n          sendParams: { fee: microAlgos(1_000 + 3 * 1_000), atc, skipSending: true },\n          boxes: [testAccount],\n          note: 'hmmm',\n        },\n      )\n      atc.buildGroup()\n\n      const result = await atc.execute(algod, 5)\n\n      expect(result.methodResults).toBeDefined()\n    })\n\n    test('it works using the fluent composer', async () => {\n      const { signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\n      const result = await client\n        .compose()\n        .getPreconditions(\n          {\n            signature,\n          },\n          {\n            sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n            boxes: [testAccount],\n          },\n        )\n        .bootstrap(\n          {\n            fund_min_bal_req: client.appClient.fundAppAccount({\n              amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n              sendParams: { skipSending: true },\n            }),\n          },\n          {\n            boxes: ['V'],\n            sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n          },\n        )\n        .vote(\n          {\n            answer_ids: randomAnswerIds,\n            fund_min_bal_req: client.appClient.fundAppAccount({\n              amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n              sendParams: { skipSending: true },\n            }),\n            signature,\n          },\n          {\n            boxes: ['V', testAccount],\n            sendParams: { fee: microAlgos(1_000 + 1_000 * 16) },\n          },\n        )\n        .getPreconditions(\n          {\n            signature,\n          },\n          {\n            sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n            boxes: [testAccount],\n            note: 'hmmm',\n          },\n        )\n        .execute()\n\n      expect(result.returns[0].has_already_voted).toBe(0n)\n      expect(result.returns[3].has_already_voted).toBe(1n)\n    })\n  })\n})\n"]}
{"filename": "examples/voting/client.ts", "chunked_list": ["/* eslint-disable */\n/**\n * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n * DO NOT MODIFY IT BY HAND.\n * requires: @algorandfoundation/algokit-utils: ^2\n */\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport type {\n  AppCallTransactionResult,\n  AppCallTransactionResultOfType,", "  AppCallTransactionResult,\n  AppCallTransactionResultOfType,\n  CoreAppCallArgs,\n  RawAppCallArgs,\n  AppState,\n  TealTemplateParams,\n  ABIAppCallArg,\n} from '@algorandfoundation/algokit-utils/types/app'\nimport type {\n  AppClientCallCoreParams,", "import type {\n  AppClientCallCoreParams,\n  AppClientCompilationParams,\n  AppClientDeployCoreParams,\n  AppDetails,\n  ApplicationClient,\n} from '@algorandfoundation/algokit-utils/types/app-client'\nimport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\nimport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'", "import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'\nimport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\nexport const APP_SPEC: AppSpec = {\n  \"hints\": {\n    \"create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },", "      }\n    },\n    \"bootstrap(pay)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"close()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"", "      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"get_preconditions(byte[])(uint64,uint64,uint64,uint64)\": {\n      \"read_only\": true,\n      \"structs\": {\n        \"output\": {\n          \"name\": \"VotingPreconditions\",\n          \"elements\": [", "          \"name\": \"VotingPreconditions\",\n          \"elements\": [\n            [\n              \"is_voting_open\",\n              \"uint64\"\n            ],\n            [\n              \"is_allowed_to_vote\",\n              \"uint64\"\n            ],", "              \"uint64\"\n            ],\n            [\n              \"has_already_voted\",\n              \"uint64\"\n            ],\n            [\n              \"current_time\",\n              \"uint64\"\n            ]", "              \"uint64\"\n            ]\n          ]\n        }\n      },\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"vote(pay,byte[],uint8[])void\": {", "    },\n    \"vote(pay,byte[],uint8[])void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMCA1CmJ5dGVjYmxvY2sgMHggMHgwNjgxMDEgMHg3NjZmNzQ2NTVmNjk2NCAweDZmNzA3NDY5NmY2ZTVmNjM2Zjc1NmU3NDczIDB4Njk3MzVmNjI2ZjZmNzQ3Mzc0NzI2MTcwNzA2NTY0IDB4NzY2Zjc0NjU3MjVmNjM2Zjc1NmU3NCAweDYzNmM2ZjczNjU1Zjc0Njk2ZDY1IDB4NzQ2Zjc0NjE2YzVmNmY3MDc0Njk2ZjZlNzMgMHg1NiAweDczNmU2MTcwNzM2ODZmNzQ1ZjcwNzU2MjZjNjk2MzVmNmI2NTc5IDB4NmQ2NTc0NjE2NDYxNzQ2MTVmNjk3MDY2NzM1ZjYzNjk2NCAweDczNzQ2MTcyNzQ1Zjc0Njk2ZDY1IDB4NjU2ZTY0NWY3NDY5NmQ2NSAweDcxNzU2ZjcyNzU2ZCAweDZlNjY3NDVmNjk2ZDYxNjc2NTVmNzU3MjZjIDB4NmU2Njc0NWY2MTczNzM2NTc0NWY2OTY0IDB4MmMKdHhuIE51bUFwcEFyZ3MKaW50Y18wIC8vIDAKPT0KYm56IG1haW5fbDEyCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YWU4OTdmNmIgLy8gImNyZWF0ZShzdHJpbmcsYnl0ZVtdLHN0cmluZyx1aW50NjQsdWludDY0LHVpbnQ4W10sdWludDY0LHN0cmluZyl2b2lkIgo9PQpibnogbWFpbl9sMTEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGU4ZDE2NCAvLyAiYm9vdHN0cmFwKHBheSl2b2lkIgo9PQpibnogbWFpbl9sMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg5NjU2MDQ3YSAvLyAiY2xvc2UoKXZvaWQiCj09CmJueiBtYWluX2w5CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YmNiMTU4OTYgLy8gImdldF9wcmVjb25kaXRpb25zKGJ5dGVbXSkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKPT0KYm56IG1haW5fbDgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg4NGE1M2M2ZSAvLyAidm90ZShwYXksYnl0ZVtdLHVpbnQ4W10pdm9pZCIKPT0KYm56IG1haW5fbDcKZXJyCm1haW5fbDc6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKc3RvcmUgMTEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpzdG9yZSAxMgp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCnN0b3JlIDEwCmxvYWQgMTAKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQphc3NlcnQKbG9hZCAxMApsb2FkIDExCmxvYWQgMTIKY2FsbHN1YiB2b3RlXzkKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDg6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBnZXRwcmVjb25kaXRpb25zXzgKc3RvcmUgOQpwdXNoYnl0ZXMgMHgxNTFmN2M3NSAvLyAweDE1MWY3Yzc1CmxvYWQgOQpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w5Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGNsb3NlXzMKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDEwOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCnN0b3JlIDgKbG9hZCA4Cmd0eG5zIFR5cGVFbnVtCmludGNfMSAvLyBwYXkKPT0KYXNzZXJ0CmxvYWQgOApjYWxsc3ViIGJvb3RzdHJhcF8yCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAo9PQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpzdG9yZSAwCnR4bmEgQXBwbGljYXRpb25BcmdzIDIKc3RvcmUgMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAzCnN0b3JlIDIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApidG9pCnN0b3JlIDMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQpidG9pCnN0b3JlIDQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgpzdG9yZSA1CnR4bmEgQXBwbGljYXRpb25BcmdzIDcKYnRvaQpzdG9yZSA2CnR4bmEgQXBwbGljYXRpb25BcmdzIDgKc3RvcmUgNwpsb2FkIDAKbG9hZCAxCmxvYWQgMgpsb2FkIDMKbG9hZCA0CmxvYWQgNQpsb2FkIDYKbG9hZCA3CmNhbGxzdWIgY3JlYXRlXzEKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDEyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMyAvLyBEZWxldGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sMTQKZXJyCm1haW5fbDE0Ogp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiBkZWxldGVfMAppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIGRlbGV0ZQpkZWxldGVfMDoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX0RFTEVUQUJMRSAvLyBUTVBMX0RFTEVUQUJMRQovLyBDaGVjayBhcHAgaXMgZGVsZXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGNyZWF0ZQpjcmVhdGVfMToKcHJvdG8gOCAwCmludGNfMCAvLyAwCmR1cApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gMgpwdXNoaW50IDI4MDAgLy8gMjgwMAppbnRjXzIgLy8gMTAKKwpzdG9yZSAxMwpjcmVhdGVfMV9sMToKbG9hZCAxMwpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYm56IGNyZWF0ZV8xX2w1CmZyYW1lX2RpZyAtNQpmcmFtZV9kaWcgLTQKPD0KLy8gRW5kIHRpbWUgc2hvdWxkIGJlIGFmdGVyIHN0YXJ0IHRpbWUKYXNzZXJ0CmZyYW1lX2RpZyAtNApnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCj49Ci8vIEVuZCB0aW1lIHNob3VsZCBiZSBpbiB0aGUgZnV0dXJlCmFzc2VydAppbnRjXzAgLy8gMApieXRlY18yIC8vICJ2b3RlX2lkIgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSAxNQpzdG9yZSAxNApsb2FkIDE1CiEKYXNzZXJ0CmJ5dGVjXzIgLy8gInZvdGVfaWQiCmZyYW1lX2RpZyAtOApleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyA5IC8vICJzbmFwc2hvdF9wdWJsaWNfa2V5IgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSAxNwpzdG9yZSAxNgpsb2FkIDE3CiEKYXNzZXJ0CmJ5dGVjIDkgLy8gInNuYXBzaG90X3B1YmxpY19rZXkiCmZyYW1lX2RpZyAtNwpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyAxMCAvLyAibWV0YWRhdGFfaXBmc19jaWQiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDE5CnN0b3JlIDE4CmxvYWQgMTkKIQphc3NlcnQKYnl0ZWMgMTAgLy8gIm1ldGFkYXRhX2lwZnNfY2lkIgpmcmFtZV9kaWcgLTYKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDIxCnN0b3JlIDIwCmxvYWQgMjEKIQphc3NlcnQKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmZyYW1lX2RpZyAtNQphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyAxMiAvLyAiZW5kX3RpbWUiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDIzCnN0b3JlIDIyCmxvYWQgMjMKIQphc3NlcnQKYnl0ZWMgMTIgLy8gImVuZF90aW1lIgpmcmFtZV9kaWcgLTQKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTMgLy8gInF1b3J1bSIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjUKc3RvcmUgMjQKbG9hZCAyNQohCmFzc2VydApieXRlYyAxMyAvLyAicXVvcnVtIgpmcmFtZV9kaWcgLTIKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNCAvLyAiaXNfYm9vdHN0cmFwcGVkIgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApieXRlYyA1IC8vICJ2b3Rlcl9jb3VudCIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNiAvLyAiY2xvc2VfdGltZSIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDI3CnN0b3JlIDI2CmxvYWQgMjcKIQphc3NlcnQKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApieXRlYyAxNSAvLyAibmZ0X2Fzc2V0X2lkIgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApmcmFtZV9kaWcgLTMKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCi8vIG9wdGlvbl9jb3VudHMgc2hvdWxkIGJlIG5vbi1lbXB0eQphc3NlcnQKZnJhbWVfZGlnIC0zCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMQpmcmFtZV9kaWcgMQpwdXNoaW50IDExMiAvLyAxMTIKPD0KLy8gQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTEyIHF1ZXN0aW9ucwphc3NlcnQKaW50Y18wIC8vIDAKYnl0ZWNfMyAvLyAib3B0aW9uX2NvdW50cyIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjkKc3RvcmUgMjgKbG9hZCAyOQohCmFzc2VydApieXRlY18zIC8vICJvcHRpb25fY291bnRzIgpmcmFtZV9kaWcgLTMKYXBwX2dsb2JhbF9wdXQKYnl0ZWNfMyAvLyAib3B0aW9uX2NvdW50cyIKYXBwX2dsb2JhbF9nZXQKZnJhbWVfYnVyeSAyCmludGNfMCAvLyAwCnN0b3JlIDMxCmZyYW1lX2RpZyAyCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMwpmcmFtZV9kaWcgMwpzdG9yZSAzMgppbnRjXzAgLy8gMApzdG9yZSAzMwpjcmVhdGVfMV9sMzoKbG9hZCAzMwpsb2FkIDMyCjwKYnogY3JlYXRlXzFfbDYKZnJhbWVfZGlnIDIKaW50Y18xIC8vIDEKbG9hZCAzMwoqCnB1c2hpbnQgMiAvLyAyCisKZ2V0Ynl0ZQpmcmFtZV9idXJ5IDQKbG9hZCAzMQpmcmFtZV9kaWcgNAorCnN0b3JlIDMxCmxvYWQgMzMKaW50Y18xIC8vIDEKKwpzdG9yZSAzMwpiIGNyZWF0ZV8xX2wzCmNyZWF0ZV8xX2w1OgppdHhuX2JlZ2luCnB1c2hpbnQgNiAvLyBhcHBsCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18wIC8vIDAKaXR4bl9maWVsZCBGZWUKaW50Y18zIC8vIERlbGV0ZUFwcGxpY2F0aW9uCml0eG5fZmllbGQgT25Db21wbGV0aW9uCmJ5dGVjXzEgLy8gMHgwNjgxMDEKaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCml0eG5fc3VibWl0CmIgY3JlYXRlXzFfbDEKY3JlYXRlXzFfbDY6CmxvYWQgMzEKc3RvcmUgMzAKbG9hZCAzMApwdXNoaW50IDEyOCAvLyAxMjgKPD0KLy8gQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTI4IHZvdGUgb3B0aW9ucwphc3NlcnQKaW50Y18wIC8vIDAKYnl0ZWMgNyAvLyAidG90YWxfb3B0aW9ucyIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMzUKc3RvcmUgMzQKbG9hZCAzNQohCmFzc2VydApieXRlYyA3IC8vICJ0b3RhbF9vcHRpb25zIgpsb2FkIDMwCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gYm9vdHN0cmFwCmJvb3RzdHJhcF8yOgpwcm90byAxIDAKaW50Y18wIC8vIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApieXRlYyA0IC8vICJpc19ib290c3RyYXBwZWQiCmFwcF9nbG9iYWxfZ2V0CiEKLy8gQWxyZWFkeSBib290c3RyYXBwZWQKYXNzZXJ0CmJ5dGVjIDQgLy8gImlzX2Jvb3RzdHJhcHBlZCIKaW50Y18xIC8vIDEKYXBwX2dsb2JhbF9wdXQKcHVzaGludCAyMDM5MDAgLy8gMjAzOTAwCmJ5dGVjIDcgLy8gInRvdGFsX29wdGlvbnMiCmFwcF9nbG9iYWxfZ2V0CnB1c2hpbnQgMzIwMCAvLyAzMjAwCioKKwpzdG9yZSAzNgpmcmFtZV9kaWcgLTEKZ3R4bnMgUmVjZWl2ZXIKZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKPT0KLy8gUGF5bWVudCBtdXN0IGJlIHRvIGFwcCBhZGRyZXNzCmFzc2VydApsb2FkIDM2Cml0b2IKbG9nCmZyYW1lX2RpZyAtMQpndHhucyBBbW91bnQKbG9hZCAzNgo9PQovLyBQYXltZW50IG11c3QgYmUgZm9yIHRoZSBleGFjdCBtaW4gYmFsYW5jZSByZXF1aXJlbWVudAphc3NlcnQKYnl0ZWMgOCAvLyAiViIKYnl0ZWMgNyAvLyAidG90YWxfb3B0aW9ucyIKYXBwX2dsb2JhbF9nZXQKcHVzaGludCA4IC8vIDgKKgpib3hfY3JlYXRlCnBvcApyZXRzdWIKCi8vIGNsb3NlCmNsb3NlXzM6CnByb3RvIDAgMApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gMgp0eG4gU2VuZGVyCmdsb2JhbCBDcmVhdG9yQWRkcmVzcwo9PQovLyB1bmF1dGhvcml6ZWQKYXNzZXJ0CnB1c2hpbnQgMjAwMDAgLy8gMjAwMDAKaW50Y18yIC8vIDEwCisKc3RvcmUgMzcKY2xvc2VfM19sMToKbG9hZCAzNwpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYm56IGNsb3NlXzNfbDE3CmJ5dGVjIDYgLy8gImNsb3NlX3RpbWUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09Ci8vIEFscmVhZHkgY2xvc2VkCmFzc2VydApieXRlYyA2IC8vICJjbG9zZV90aW1lIgpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDdiMjI3Mzc0NjE2ZTY0NjE3MjY0MjIzYTIyNjE3MjYzMzYzOTIyMmMyMjY0NjU3MzYzNzI2OTcwNzQ2OTZmNmUyMjNhMjI1NDY4Njk3MzIwNjk3MzIwNjEyMDc2NmY3NDY5NmU2NzIwNzI2NTczNzU2Yzc0MjA0ZTQ2NTQyMDY2NmY3MjIwNzY2Zjc0Njk2ZTY3MjA3MjZmNzU2ZTY0MjA3NzY5NzQ2ODIwNDk0NDIwIC8vICJ7XCJzdGFuZGFyZFwiOlwiYXJjNjlcIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIGEgdm90aW5nIHJlc3VsdCBORlQgZm9yIHZvdGluZyByb3VuZCB3aXRoIElEICIKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJlMjIyYzIyNzA3MjZmNzA2NTcyNzQ2OTY1NzMyMjNhN2IyMjZkNjU3NDYxNjQ2MTc0NjEyMjNhMjI2OTcwNjY3MzNhMmYyZiAvLyAiLlwiLFwicHJvcGVydGllc1wiOntcIm1ldGFkYXRhXCI6XCJpcGZzOi8vIgpjb25jYXQKYnl0ZWMgMTAgLy8gIm1ldGFkYXRhX2lwZnNfY2lkIgphcHBfZ2xvYmFsX2dldApjb25jYXQKcHVzaGJ5dGVzIDB4MjIyYzIyNjk2NDIyM2EyMiAvLyAiXCIsXCJpZFwiOlwiIgpjb25jYXQKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDIyMmMyMjcxNzU2ZjcyNzU2ZDIyM2EgLy8gIlwiLFwicXVvcnVtXCI6Igpjb25jYXQKYnl0ZWMgMTMgLy8gInF1b3J1bSIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpdG9hXzcKY29uY2F0CnB1c2hieXRlcyAweDJjMjI3NjZmNzQ2NTcyNDM2Zjc1NmU3NDIyM2EgLy8gIixcInZvdGVyQ291bnRcIjoiCmNvbmNhdApieXRlYyA1IC8vICJ2b3Rlcl9jb3VudCIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpdG9hXzcKY29uY2F0CnB1c2hieXRlcyAweDJjMjI3NDYxNmM2YzY5NjU3MzIyM2E1YiAvLyAiLFwidGFsbGllc1wiOlsiCmNvbmNhdApzdG9yZSAzOApieXRlY18zIC8vICJvcHRpb25fY291bnRzIgphcHBfZ2xvYmFsX2dldApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSAxCmZyYW1lX2RpZyAxCnN0b3JlIDM5CmludGNfMCAvLyAwCnN0b3JlIDQwCmludGNfMCAvLyAwCnN0b3JlIDQxCmludGNfMCAvLyAwCnN0b3JlIDQyCmNsb3NlXzNfbDM6CmxvYWQgNDIKbG9hZCAzOQo8CmJ6IGNsb3NlXzNfbDE4CmZyYW1lX2RpZyAwCmludGNfMSAvLyAxCmxvYWQgNDIKKgpwdXNoaW50IDIgLy8gMgorCmdldGJ5dGUKZnJhbWVfYnVyeSAyCmZyYW1lX2RpZyAyCnN0b3JlIDQzCmludGNfMCAvLyAwCnN0b3JlIDQ0CmNsb3NlXzNfbDU6CmxvYWQgNDQKbG9hZCA0Mwo8CmJueiBjbG9zZV8zX2w3CmxvYWQgNDIKaW50Y18xIC8vIDEKKwpzdG9yZSA0MgpiIGNsb3NlXzNfbDMKY2xvc2VfM19sNzoKcHVzaGludCA4IC8vIDgKbG9hZCA0MQoqCnN0b3JlIDQ1CmJ5dGVjIDggLy8gIlYiCmxvYWQgNDUKcHVzaGludCA4IC8vIDgKYm94X2V4dHJhY3QKYnRvaQpzdG9yZSA0MApsb2FkIDM4CmxvYWQgNDQKaW50Y18wIC8vIDAKPT0KYm56IGNsb3NlXzNfbDE2CmJ5dGVjXzAgLy8gIiIKY2xvc2VfM19sOToKY29uY2F0CmxvYWQgNDAKY2FsbHN1YiBpdG9hXzcKY29uY2F0CmxvYWQgNDQKbG9hZCA0MwppbnRjXzEgLy8gMQotCj09CmJueiBjbG9zZV8zX2wxMgpieXRlYyAxNiAvLyAiLCIKY2xvc2VfM19sMTE6CmNvbmNhdApzdG9yZSAzOApsb2FkIDQxCmludGNfMSAvLyAxCisKc3RvcmUgNDEKbG9hZCA0NAppbnRjXzEgLy8gMQorCnN0b3JlIDQ0CmIgY2xvc2VfM19sNQpjbG9zZV8zX2wxMjoKcHVzaGJ5dGVzIDB4NWQgLy8gIl0iCmxvYWQgNDIKbG9hZCAzOQppbnRjXzEgLy8gMQotCj09CmJueiBjbG9zZV8zX2wxNQpieXRlYyAxNiAvLyAiLCIKY2xvc2VfM19sMTQ6CmNvbmNhdApiIGNsb3NlXzNfbDExCmNsb3NlXzNfbDE1OgpieXRlY18wIC8vICIiCmIgY2xvc2VfM19sMTQKY2xvc2VfM19sMTY6CnB1c2hieXRlcyAweDViIC8vICJbIgpiIGNsb3NlXzNfbDkKY2xvc2VfM19sMTc6Cml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiBjbG9zZV8zX2wxCmNsb3NlXzNfbDE4OgppdHhuX2JlZ2luCnB1c2hpbnQgMyAvLyBhY2ZnCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18xIC8vIDEKaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCmludGNfMCAvLyAwCml0eG5fZmllbGQgQ29uZmlnQXNzZXREZWNpbWFscwppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbgpwdXNoYnl0ZXMgMHg1YjU2NGY1NDQ1MjA1MjQ1NTM1NTRjNTQ1ZDIwIC8vICJbVk9URSBSRVNVTFRdICIKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0Cml0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCnB1c2hieXRlcyAweDU2NGY1NDQ1NTI1MzRjNTQgLy8gIlZPVEVSU0xUIgppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmFwcF9nbG9iYWxfZ2V0Cml0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKbG9hZCAzOApwdXNoYnl0ZXMgMHg1ZDdkN2QgLy8gIl19fSIKY29uY2F0Cml0eG5fZmllbGQgTm90ZQppdHhuX3N1Ym1pdApieXRlYyAxNSAvLyAibmZ0X2Fzc2V0X2lkIgppdHhuIENyZWF0ZWRBc3NldElECmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gYWxsb3dlZF90b192b3RlCmFsbG93ZWR0b3ZvdGVfNDoKcHJvdG8gMSAxCnB1c2hpbnQgMjAwMCAvLyAyMDAwCmludGNfMiAvLyAxMAorCnN0b3JlIDQ2CmFsbG93ZWR0b3ZvdGVfNF9sMToKbG9hZCA0NgpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYnogYWxsb3dlZHRvdm90ZV80X2wzCml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiBhbGxvd2VkdG92b3RlXzRfbDEKYWxsb3dlZHRvdm90ZV80X2wzOgp0eG4gU2VuZGVyCmZyYW1lX2RpZyAtMQpieXRlYyA5IC8vICJzbmFwc2hvdF9wdWJsaWNfa2V5IgphcHBfZ2xvYmFsX2dldAplZDI1NTE5dmVyaWZ5X2JhcmUKcmV0c3ViCgovLyB2b3Rpbmdfb3Blbgp2b3RpbmdvcGVuXzU6CnByb3RvIDAgMQpieXRlYyA0IC8vICJpc19ib290c3RyYXBwZWQiCmFwcF9nbG9iYWxfZ2V0CmludGNfMSAvLyAxCj09CmJ5dGVjIDYgLy8gImNsb3NlX3RpbWUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09CiYmCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmFwcF9nbG9iYWxfZ2V0Cj49CiYmCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYnl0ZWMgMTIgLy8gImVuZF90aW1lIgphcHBfZ2xvYmFsX2dldAo8CiYmCnJldHN1YgoKLy8gYWxyZWFkeV92b3RlZAphbHJlYWR5dm90ZWRfNjoKcHJvdG8gMCAxCmJ5dGVjXzAgLy8gIiIKdHhuIFNlbmRlcgpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCnB1c2hpbnQgMzIgLy8gMzIKPT0KYXNzZXJ0CmZyYW1lX2RpZyAwCmJveF9sZW4Kc3RvcmUgNDgKc3RvcmUgNDcKbG9hZCA0OApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpdG9hCml0b2FfNzoKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV83X2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzdfbDQKYnl0ZWNfMCAvLyAiIgppdG9hXzdfbDM6CnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCiUKaW50Y18xIC8vIDEKZXh0cmFjdDMKY29uY2F0CmIgaXRvYV83X2w2Cml0b2FfN19sNDoKZnJhbWVfZGlnIC0xCmludGNfMiAvLyAxMAovCmNhbGxzdWIgaXRvYV83CmIgaXRvYV83X2wzCml0b2FfN19sNToKcHVzaGJ5dGVzIDB4MzAgLy8gIjAiCml0b2FfN19sNjoKcmV0c3ViCgovLyBnZXRfcHJlY29uZGl0aW9ucwpnZXRwcmVjb25kaXRpb25zXzg6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gNQpieXRlY18wIC8vICIiCmR1cApjYWxsc3ViIHZvdGluZ29wZW5fNQpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNhbGxzdWIgYWxsb3dlZHRvdm90ZV80CmZyYW1lX2J1cnkgMgpjYWxsc3ViIGFscmVhZHl2b3RlZF82CmZyYW1lX2J1cnkgMwpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmZyYW1lX2J1cnkgNApmcmFtZV9kaWcgMQppdG9iCmZyYW1lX2RpZyAyCml0b2IKY29uY2F0CmZyYW1lX2RpZyAzCml0b2IKY29uY2F0CmZyYW1lX2RpZyA0Cml0b2IKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIHZvdGUKdm90ZV85Ogpwcm90byAzIDAKYnl0ZWNfMCAvLyAiIgppbnRjXzAgLy8gMApkdXBuIDcKYnl0ZWNfMCAvLyAiIgpwdXNoaW50IDc3MDAgLy8gNzcwMAppbnRjXzIgLy8gMTAKKwpzdG9yZSA0OQp2b3RlXzlfbDE6CmxvYWQgNDkKZ2xvYmFsIE9wY29kZUJ1ZGdldAo+CmJueiB2b3RlXzlfbDUKZnJhbWVfZGlnIC0yCmV4dHJhY3QgMiAwCmNhbGxzdWIgYWxsb3dlZHRvdm90ZV80Ci8vIE5vdCBhbGxvd2VkIHRvIHZvdGUKYXNzZXJ0CmNhbGxzdWIgdm90aW5nb3Blbl81Ci8vIFZvdGluZyBub3Qgb3Blbgphc3NlcnQKY2FsbHN1YiBhbHJlYWR5dm90ZWRfNgohCi8vIEFscmVhZHkgdm90ZWQKYXNzZXJ0CmJ5dGVjXzMgLy8gIm9wdGlvbl9jb3VudHMiCmFwcF9nbG9iYWxfZ2V0CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMAppbnRjXzAgLy8gMApleHRyYWN0X3VpbnQxNgpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKc3RvcmUgNTAKZnJhbWVfZGlnIC0xCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgMgpsb2FkIDUwCj09Ci8vIE51bWJlciBvZiBhbnN3ZXJzIGluY29ycmVjdAphc3NlcnQKcHVzaGludCAyNTAwIC8vIDI1MDAKcHVzaGludCAzNCAvLyAzNAppbnRjXzEgLy8gMQpmcmFtZV9kaWcgLTEKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSA0CmZyYW1lX2RpZyA0CioKKwpwdXNoaW50IDQwMCAvLyA0MDAKKgorCnN0b3JlIDUxCmZyYW1lX2RpZyAtMwpndHhucyBSZWNlaXZlcgpnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwo9PQovLyBQYXltZW50IG11c3QgYmUgdG8gYXBwIGFkZHJlc3MKYXNzZXJ0CmxvYWQgNTEKaXRvYgpsb2cKZnJhbWVfZGlnIC0zCmd0eG5zIEFtb3VudApsb2FkIDUxCj09Ci8vIFBheW1lbnQgbXVzdCBiZSB0aGUgZXhhY3QgbWluIGJhbGFuY2UgcmVxdWlyZW1lbnQKYXNzZXJ0CmludGNfMCAvLyAwCnN0b3JlIDUyCmludGNfMCAvLyAwCnN0b3JlIDUzCnZvdGVfOV9sMzoKbG9hZCA1Mwpsb2FkIDUwCjwKYnogdm90ZV85X2w2CmZyYW1lX2RpZyAtMQppbnRjXzEgLy8gMQpsb2FkIDUzCioKcHVzaGludCAyIC8vIDIKKwpnZXRieXRlCmZyYW1lX2J1cnkgNQpmcmFtZV9kaWcgMAppbnRjXzEgLy8gMQpsb2FkIDUzCioKcHVzaGludCAyIC8vIDIKKwpnZXRieXRlCmZyYW1lX2J1cnkgNwpmcmFtZV9kaWcgNQpmcmFtZV9kaWcgNwo8Ci8vIEFuc3dlciBvcHRpb24gaW5kZXggaW52YWxpZAphc3NlcnQKcHVzaGludCA4IC8vIDgKbG9hZCA1MgpmcmFtZV9kaWcgNQorCioKc3RvcmUgNTQKYnl0ZWMgOCAvLyAiViIKbG9hZCA1NApwdXNoaW50IDggLy8gOApib3hfZXh0cmFjdApidG9pCnN0b3JlIDU1CmJ5dGVjIDggLy8gIlYiCmxvYWQgNTQKbG9hZCA1NQppbnRjXzEgLy8gMQorCml0b2IKYm94X3JlcGxhY2UKbG9hZCA1MgpmcmFtZV9kaWcgNworCnN0b3JlIDUyCmxvYWQgNTMKaW50Y18xIC8vIDEKKwpzdG9yZSA1MwpiIHZvdGVfOV9sMwp2b3RlXzlfbDU6Cml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiB2b3RlXzlfbDEKdm90ZV85X2w2Ogp0eG4gU2VuZGVyCmZyYW1lX2J1cnkgOQpmcmFtZV9kaWcgOQpsZW4KcHVzaGludCAzMiAvLyAzMgo9PQphc3NlcnQKZnJhbWVfZGlnIDkKYm94X2RlbApwb3AKZnJhbWVfZGlnIDkKZnJhbWVfZGlnIC0xCmJveF9wdXQKYnl0ZWMgNSAvLyAidm90ZXJfY291bnQiCmJ5dGVjIDUgLy8gInZvdGVyX2NvdW50IgphcHBfZ2xvYmFsX2dldAppbnRjXzEgLy8gMQorCmFwcF9nbG9iYWxfcHV0CnJldHN1Yg==\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"", "    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMCA1CmJ5dGVjYmxvY2sgMHggMHgwNjgxMDEgMHg3NjZmNzQ2NTVmNjk2NCAweDZmNzA3NDY5NmY2ZTVmNjM2Zjc1NmU3NDczIDB4Njk3MzVmNjI2ZjZmNzQ3Mzc0NzI2MTcwNzA2NTY0IDB4NzY2Zjc0NjU3MjVmNjM2Zjc1NmU3NCAweDYzNmM2ZjczNjU1Zjc0Njk2ZDY1IDB4NzQ2Zjc0NjE2YzVmNmY3MDc0Njk2ZjZlNzMgMHg1NiAweDczNmU2MTcwNzM2ODZmNzQ1ZjcwNzU2MjZjNjk2MzVmNmI2NTc5IDB4NmQ2NTc0NjE2NDYxNzQ2MTVmNjk3MDY2NzM1ZjYzNjk2NCAweDczNzQ2MTcyNzQ1Zjc0Njk2ZDY1IDB4NjU2ZTY0NWY3NDY5NmQ2NSAweDcxNzU2ZjcyNzU2ZCAweDZlNjY3NDVmNjk2ZDYxNjc2NTVmNzU3MjZjIDB4NmU2Njc0NWY2MTczNzM2NTc0NWY2OTY0IDB4MmMKdHhuIE51bUFwcEFyZ3MKaW50Y18wIC8vIDAKPT0KYm56IG1haW5fbDEyCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YWU4OTdmNmIgLy8gImNyZWF0ZShzdHJpbmcsYnl0ZVtdLHN0cmluZyx1aW50NjQsdWludDY0LHVpbnQ4W10sdWludDY0LHN0cmluZyl2b2lkIgo9PQpibnogbWFpbl9sMTEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGU4ZDE2NCAvLyAiYm9vdHN0cmFwKHBheSl2b2lkIgo9PQpibnogbWFpbl9sMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg5NjU2MDQ3YSAvLyAiY2xvc2UoKXZvaWQiCj09CmJueiBtYWluX2w5CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YmNiMTU4OTYgLy8gImdldF9wcmVjb25kaXRpb25zKGJ5dGVbXSkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKPT0KYm56IG1haW5fbDgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg4NGE1M2M2ZSAvLyAidm90ZShwYXksYnl0ZVtdLHVpbnQ4W10pdm9pZCIKPT0KYm56IG1haW5fbDcKZXJyCm1haW5fbDc6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKc3RvcmUgMTEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpzdG9yZSAxMgp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCnN0b3JlIDEwCmxvYWQgMTAKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQphc3NlcnQKbG9hZCAxMApsb2FkIDExCmxvYWQgMTIKY2FsbHN1YiB2b3RlXzkKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDg6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBnZXRwcmVjb25kaXRpb25zXzgKc3RvcmUgOQpwdXNoYnl0ZXMgMHgxNTFmN2M3NSAvLyAweDE1MWY3Yzc1CmxvYWQgOQpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w5Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGNsb3NlXzMKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDEwOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCnN0b3JlIDgKbG9hZCA4Cmd0eG5zIFR5cGVFbnVtCmludGNfMSAvLyBwYXkKPT0KYXNzZXJ0CmxvYWQgOApjYWxsc3ViIGJvb3RzdHJhcF8yCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAo9PQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpzdG9yZSAwCnR4bmEgQXBwbGljYXRpb25BcmdzIDIKc3RvcmUgMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAzCnN0b3JlIDIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApidG9pCnN0b3JlIDMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQpidG9pCnN0b3JlIDQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgpzdG9yZSA1CnR4bmEgQXBwbGljYXRpb25BcmdzIDcKYnRvaQpzdG9yZSA2CnR4bmEgQXBwbGljYXRpb25BcmdzIDgKc3RvcmUgNwpsb2FkIDAKbG9hZCAxCmxvYWQgMgpsb2FkIDMKbG9hZCA0CmxvYWQgNQpsb2FkIDYKbG9hZCA3CmNhbGxzdWIgY3JlYXRlXzEKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDEyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMyAvLyBEZWxldGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sMTQKZXJyCm1haW5fbDE0Ogp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiBkZWxldGVfMAppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIGRlbGV0ZQpkZWxldGVfMDoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX0RFTEVUQUJMRSAvLyBUTVBMX0RFTEVUQUJMRQovLyBDaGVjayBhcHAgaXMgZGVsZXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGNyZWF0ZQpjcmVhdGVfMToKcHJvdG8gOCAwCmludGNfMCAvLyAwCmR1cApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gMgpwdXNoaW50IDI4MDAgLy8gMjgwMAppbnRjXzIgLy8gMTAKKwpzdG9yZSAxMwpjcmVhdGVfMV9sMToKbG9hZCAxMwpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYm56IGNyZWF0ZV8xX2w1CmZyYW1lX2RpZyAtNQpmcmFtZV9kaWcgLTQKPD0KLy8gRW5kIHRpbWUgc2hvdWxkIGJlIGFmdGVyIHN0YXJ0IHRpbWUKYXNzZXJ0CmZyYW1lX2RpZyAtNApnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCj49Ci8vIEVuZCB0aW1lIHNob3VsZCBiZSBpbiB0aGUgZnV0dXJlCmFzc2VydAppbnRjXzAgLy8gMApieXRlY18yIC8vICJ2b3RlX2lkIgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSAxNQpzdG9yZSAxNApsb2FkIDE1CiEKYXNzZXJ0CmJ5dGVjXzIgLy8gInZvdGVfaWQiCmZyYW1lX2RpZyAtOApleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyA5IC8vICJzbmFwc2hvdF9wdWJsaWNfa2V5IgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSAxNwpzdG9yZSAxNgpsb2FkIDE3CiEKYXNzZXJ0CmJ5dGVjIDkgLy8gInNuYXBzaG90X3B1YmxpY19rZXkiCmZyYW1lX2RpZyAtNwpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyAxMCAvLyAibWV0YWRhdGFfaXBmc19jaWQiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDE5CnN0b3JlIDE4CmxvYWQgMTkKIQphc3NlcnQKYnl0ZWMgMTAgLy8gIm1ldGFkYXRhX2lwZnNfY2lkIgpmcmFtZV9kaWcgLTYKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDIxCnN0b3JlIDIwCmxvYWQgMjEKIQphc3NlcnQKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmZyYW1lX2RpZyAtNQphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyAxMiAvLyAiZW5kX3RpbWUiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDIzCnN0b3JlIDIyCmxvYWQgMjMKIQphc3NlcnQKYnl0ZWMgMTIgLy8gImVuZF90aW1lIgpmcmFtZV9kaWcgLTQKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTMgLy8gInF1b3J1bSIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjUKc3RvcmUgMjQKbG9hZCAyNQohCmFzc2VydApieXRlYyAxMyAvLyAicXVvcnVtIgpmcmFtZV9kaWcgLTIKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNCAvLyAiaXNfYm9vdHN0cmFwcGVkIgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApieXRlYyA1IC8vICJ2b3Rlcl9jb3VudCIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNiAvLyAiY2xvc2VfdGltZSIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDI3CnN0b3JlIDI2CmxvYWQgMjcKIQphc3NlcnQKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApieXRlYyAxNSAvLyAibmZ0X2Fzc2V0X2lkIgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApmcmFtZV9kaWcgLTMKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCi8vIG9wdGlvbl9jb3VudHMgc2hvdWxkIGJlIG5vbi1lbXB0eQphc3NlcnQKZnJhbWVfZGlnIC0zCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMQpmcmFtZV9kaWcgMQpwdXNoaW50IDExMiAvLyAxMTIKPD0KLy8gQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTEyIHF1ZXN0aW9ucwphc3NlcnQKaW50Y18wIC8vIDAKYnl0ZWNfMyAvLyAib3B0aW9uX2NvdW50cyIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjkKc3RvcmUgMjgKbG9hZCAyOQohCmFzc2VydApieXRlY18zIC8vICJvcHRpb25fY291bnRzIgpmcmFtZV9kaWcgLTMKYXBwX2dsb2JhbF9wdXQKYnl0ZWNfMyAvLyAib3B0aW9uX2NvdW50cyIKYXBwX2dsb2JhbF9nZXQKZnJhbWVfYnVyeSAyCmludGNfMCAvLyAwCnN0b3JlIDMxCmZyYW1lX2RpZyAyCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMwpmcmFtZV9kaWcgMwpzdG9yZSAzMgppbnRjXzAgLy8gMApzdG9yZSAzMwpjcmVhdGVfMV9sMzoKbG9hZCAzMwpsb2FkIDMyCjwKYnogY3JlYXRlXzFfbDYKZnJhbWVfZGlnIDIKaW50Y18xIC8vIDEKbG9hZCAzMwoqCnB1c2hpbnQgMiAvLyAyCisKZ2V0Ynl0ZQpmcmFtZV9idXJ5IDQKbG9hZCAzMQpmcmFtZV9kaWcgNAorCnN0b3JlIDMxCmxvYWQgMzMKaW50Y18xIC8vIDEKKwpzdG9yZSAzMwpiIGNyZWF0ZV8xX2wzCmNyZWF0ZV8xX2w1OgppdHhuX2JlZ2luCnB1c2hpbnQgNiAvLyBhcHBsCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18wIC8vIDAKaXR4bl9maWVsZCBGZWUKaW50Y18zIC8vIERlbGV0ZUFwcGxpY2F0aW9uCml0eG5fZmllbGQgT25Db21wbGV0aW9uCmJ5dGVjXzEgLy8gMHgwNjgxMDEKaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCml0eG5fc3VibWl0CmIgY3JlYXRlXzFfbDEKY3JlYXRlXzFfbDY6CmxvYWQgMzEKc3RvcmUgMzAKbG9hZCAzMApwdXNoaW50IDEyOCAvLyAxMjgKPD0KLy8gQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTI4IHZvdGUgb3B0aW9ucwphc3NlcnQKaW50Y18wIC8vIDAKYnl0ZWMgNyAvLyAidG90YWxfb3B0aW9ucyIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMzUKc3RvcmUgMzQKbG9hZCAzNQohCmFzc2VydApieXRlYyA3IC8vICJ0b3RhbF9vcHRpb25zIgpsb2FkIDMwCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gYm9vdHN0cmFwCmJvb3RzdHJhcF8yOgpwcm90byAxIDAKaW50Y18wIC8vIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApieXRlYyA0IC8vICJpc19ib290c3RyYXBwZWQiCmFwcF9nbG9iYWxfZ2V0CiEKLy8gQWxyZWFkeSBib290c3RyYXBwZWQKYXNzZXJ0CmJ5dGVjIDQgLy8gImlzX2Jvb3RzdHJhcHBlZCIKaW50Y18xIC8vIDEKYXBwX2dsb2JhbF9wdXQKcHVzaGludCAyMDM5MDAgLy8gMjAzOTAwCmJ5dGVjIDcgLy8gInRvdGFsX29wdGlvbnMiCmFwcF9nbG9iYWxfZ2V0CnB1c2hpbnQgMzIwMCAvLyAzMjAwCioKKwpzdG9yZSAzNgpmcmFtZV9kaWcgLTEKZ3R4bnMgUmVjZWl2ZXIKZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKPT0KLy8gUGF5bWVudCBtdXN0IGJlIHRvIGFwcCBhZGRyZXNzCmFzc2VydApsb2FkIDM2Cml0b2IKbG9nCmZyYW1lX2RpZyAtMQpndHhucyBBbW91bnQKbG9hZCAzNgo9PQovLyBQYXltZW50IG11c3QgYmUgZm9yIHRoZSBleGFjdCBtaW4gYmFsYW5jZSByZXF1aXJlbWVudAphc3NlcnQKYnl0ZWMgOCAvLyAiViIKYnl0ZWMgNyAvLyAidG90YWxfb3B0aW9ucyIKYXBwX2dsb2JhbF9nZXQKcHVzaGludCA4IC8vIDgKKgpib3hfY3JlYXRlCnBvcApyZXRzdWIKCi8vIGNsb3NlCmNsb3NlXzM6CnByb3RvIDAgMApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gMgp0eG4gU2VuZGVyCmdsb2JhbCBDcmVhdG9yQWRkcmVzcwo9PQovLyB1bmF1dGhvcml6ZWQKYXNzZXJ0CnB1c2hpbnQgMjAwMDAgLy8gMjAwMDAKaW50Y18yIC8vIDEwCisKc3RvcmUgMzcKY2xvc2VfM19sMToKbG9hZCAzNwpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYm56IGNsb3NlXzNfbDE3CmJ5dGVjIDYgLy8gImNsb3NlX3RpbWUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09Ci8vIEFscmVhZHkgY2xvc2VkCmFzc2VydApieXRlYyA2IC8vICJjbG9zZV90aW1lIgpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDdiMjI3Mzc0NjE2ZTY0NjE3MjY0MjIzYTIyNjE3MjYzMzYzOTIyMmMyMjY0NjU3MzYzNzI2OTcwNzQ2OTZmNmUyMjNhMjI1NDY4Njk3MzIwNjk3MzIwNjEyMDc2NmY3NDY5NmU2NzIwNzI2NTczNzU2Yzc0MjA0ZTQ2NTQyMDY2NmY3MjIwNzY2Zjc0Njk2ZTY3MjA3MjZmNzU2ZTY0MjA3NzY5NzQ2ODIwNDk0NDIwIC8vICJ7XCJzdGFuZGFyZFwiOlwiYXJjNjlcIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIGEgdm90aW5nIHJlc3VsdCBORlQgZm9yIHZvdGluZyByb3VuZCB3aXRoIElEICIKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJlMjIyYzIyNzA3MjZmNzA2NTcyNzQ2OTY1NzMyMjNhN2IyMjZkNjU3NDYxNjQ2MTc0NjEyMjNhMjI2OTcwNjY3MzNhMmYyZiAvLyAiLlwiLFwicHJvcGVydGllc1wiOntcIm1ldGFkYXRhXCI6XCJpcGZzOi8vIgpjb25jYXQKYnl0ZWMgMTAgLy8gIm1ldGFkYXRhX2lwZnNfY2lkIgphcHBfZ2xvYmFsX2dldApjb25jYXQKcHVzaGJ5dGVzIDB4MjIyYzIyNjk2NDIyM2EyMiAvLyAiXCIsXCJpZFwiOlwiIgpjb25jYXQKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDIyMmMyMjcxNzU2ZjcyNzU2ZDIyM2EgLy8gIlwiLFwicXVvcnVtXCI6Igpjb25jYXQKYnl0ZWMgMTMgLy8gInF1b3J1bSIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpdG9hXzcKY29uY2F0CnB1c2hieXRlcyAweDJjMjI3NjZmNzQ2NTcyNDM2Zjc1NmU3NDIyM2EgLy8gIixcInZvdGVyQ291bnRcIjoiCmNvbmNhdApieXRlYyA1IC8vICJ2b3Rlcl9jb3VudCIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpdG9hXzcKY29uY2F0CnB1c2hieXRlcyAweDJjMjI3NDYxNmM2YzY5NjU3MzIyM2E1YiAvLyAiLFwidGFsbGllc1wiOlsiCmNvbmNhdApzdG9yZSAzOApieXRlY18zIC8vICJvcHRpb25fY291bnRzIgphcHBfZ2xvYmFsX2dldApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSAxCmZyYW1lX2RpZyAxCnN0b3JlIDM5CmludGNfMCAvLyAwCnN0b3JlIDQwCmludGNfMCAvLyAwCnN0b3JlIDQxCmludGNfMCAvLyAwCnN0b3JlIDQyCmNsb3NlXzNfbDM6CmxvYWQgNDIKbG9hZCAzOQo8CmJ6IGNsb3NlXzNfbDE4CmZyYW1lX2RpZyAwCmludGNfMSAvLyAxCmxvYWQgNDIKKgpwdXNoaW50IDIgLy8gMgorCmdldGJ5dGUKZnJhbWVfYnVyeSAyCmZyYW1lX2RpZyAyCnN0b3JlIDQzCmludGNfMCAvLyAwCnN0b3JlIDQ0CmNsb3NlXzNfbDU6CmxvYWQgNDQKbG9hZCA0Mwo8CmJueiBjbG9zZV8zX2w3CmxvYWQgNDIKaW50Y18xIC8vIDEKKwpzdG9yZSA0MgpiIGNsb3NlXzNfbDMKY2xvc2VfM19sNzoKcHVzaGludCA4IC8vIDgKbG9hZCA0MQoqCnN0b3JlIDQ1CmJ5dGVjIDggLy8gIlYiCmxvYWQgNDUKcHVzaGludCA4IC8vIDgKYm94X2V4dHJhY3QKYnRvaQpzdG9yZSA0MApsb2FkIDM4CmxvYWQgNDQKaW50Y18wIC8vIDAKPT0KYm56IGNsb3NlXzNfbDE2CmJ5dGVjXzAgLy8gIiIKY2xvc2VfM19sOToKY29uY2F0CmxvYWQgNDAKY2FsbHN1YiBpdG9hXzcKY29uY2F0CmxvYWQgNDQKbG9hZCA0MwppbnRjXzEgLy8gMQotCj09CmJueiBjbG9zZV8zX2wxMgpieXRlYyAxNiAvLyAiLCIKY2xvc2VfM19sMTE6CmNvbmNhdApzdG9yZSAzOApsb2FkIDQxCmludGNfMSAvLyAxCisKc3RvcmUgNDEKbG9hZCA0NAppbnRjXzEgLy8gMQorCnN0b3JlIDQ0CmIgY2xvc2VfM19sNQpjbG9zZV8zX2wxMjoKcHVzaGJ5dGVzIDB4NWQgLy8gIl0iCmxvYWQgNDIKbG9hZCAzOQppbnRjXzEgLy8gMQotCj09CmJueiBjbG9zZV8zX2wxNQpieXRlYyAxNiAvLyAiLCIKY2xvc2VfM19sMTQ6CmNvbmNhdApiIGNsb3NlXzNfbDExCmNsb3NlXzNfbDE1OgpieXRlY18wIC8vICIiCmIgY2xvc2VfM19sMTQKY2xvc2VfM19sMTY6CnB1c2hieXRlcyAweDViIC8vICJbIgpiIGNsb3NlXzNfbDkKY2xvc2VfM19sMTc6Cml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiBjbG9zZV8zX2wxCmNsb3NlXzNfbDE4OgppdHhuX2JlZ2luCnB1c2hpbnQgMyAvLyBhY2ZnCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18xIC8vIDEKaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCmludGNfMCAvLyAwCml0eG5fZmllbGQgQ29uZmlnQXNzZXREZWNpbWFscwppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbgpwdXNoYnl0ZXMgMHg1YjU2NGY1NDQ1MjA1MjQ1NTM1NTRjNTQ1ZDIwIC8vICJbVk9URSBSRVNVTFRdICIKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0Cml0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCnB1c2hieXRlcyAweDU2NGY1NDQ1NTI1MzRjNTQgLy8gIlZPVEVSU0xUIgppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmFwcF9nbG9iYWxfZ2V0Cml0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKbG9hZCAzOApwdXNoYnl0ZXMgMHg1ZDdkN2QgLy8gIl19fSIKY29uY2F0Cml0eG5fZmllbGQgTm90ZQppdHhuX3N1Ym1pdApieXRlYyAxNSAvLyAibmZ0X2Fzc2V0X2lkIgppdHhuIENyZWF0ZWRBc3NldElECmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gYWxsb3dlZF90b192b3RlCmFsbG93ZWR0b3ZvdGVfNDoKcHJvdG8gMSAxCnB1c2hpbnQgMjAwMCAvLyAyMDAwCmludGNfMiAvLyAxMAorCnN0b3JlIDQ2CmFsbG93ZWR0b3ZvdGVfNF9sMToKbG9hZCA0NgpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYnogYWxsb3dlZHRvdm90ZV80X2wzCml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiBhbGxvd2VkdG92b3RlXzRfbDEKYWxsb3dlZHRvdm90ZV80X2wzOgp0eG4gU2VuZGVyCmZyYW1lX2RpZyAtMQpieXRlYyA5IC8vICJzbmFwc2hvdF9wdWJsaWNfa2V5IgphcHBfZ2xvYmFsX2dldAplZDI1NTE5dmVyaWZ5X2JhcmUKcmV0c3ViCgovLyB2b3Rpbmdfb3Blbgp2b3RpbmdvcGVuXzU6CnByb3RvIDAgMQpieXRlYyA0IC8vICJpc19ib290c3RyYXBwZWQiCmFwcF9nbG9iYWxfZ2V0CmludGNfMSAvLyAxCj09CmJ5dGVjIDYgLy8gImNsb3NlX3RpbWUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09CiYmCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmFwcF9nbG9iYWxfZ2V0Cj49CiYmCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYnl0ZWMgMTIgLy8gImVuZF90aW1lIgphcHBfZ2xvYmFsX2dldAo8CiYmCnJldHN1YgoKLy8gYWxyZWFkeV92b3RlZAphbHJlYWR5dm90ZWRfNjoKcHJvdG8gMCAxCmJ5dGVjXzAgLy8gIiIKdHhuIFNlbmRlcgpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCnB1c2hpbnQgMzIgLy8gMzIKPT0KYXNzZXJ0CmZyYW1lX2RpZyAwCmJveF9sZW4Kc3RvcmUgNDgKc3RvcmUgNDcKbG9hZCA0OApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpdG9hCml0b2FfNzoKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV83X2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzdfbDQKYnl0ZWNfMCAvLyAiIgppdG9hXzdfbDM6CnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCiUKaW50Y18xIC8vIDEKZXh0cmFjdDMKY29uY2F0CmIgaXRvYV83X2w2Cml0b2FfN19sNDoKZnJhbWVfZGlnIC0xCmludGNfMiAvLyAxMAovCmNhbGxzdWIgaXRvYV83CmIgaXRvYV83X2wzCml0b2FfN19sNToKcHVzaGJ5dGVzIDB4MzAgLy8gIjAiCml0b2FfN19sNjoKcmV0c3ViCgovLyBnZXRfcHJlY29uZGl0aW9ucwpnZXRwcmVjb25kaXRpb25zXzg6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gNQpieXRlY18wIC8vICIiCmR1cApjYWxsc3ViIHZvdGluZ29wZW5fNQpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNhbGxzdWIgYWxsb3dlZHRvdm90ZV80CmZyYW1lX2J1cnkgMgpjYWxsc3ViIGFscmVhZHl2b3RlZF82CmZyYW1lX2J1cnkgMwpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmZyYW1lX2J1cnkgNApmcmFtZV9kaWcgMQppdG9iCmZyYW1lX2RpZyAyCml0b2IKY29uY2F0CmZyYW1lX2RpZyAzCml0b2IKY29uY2F0CmZyYW1lX2RpZyA0Cml0b2IKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIHZvdGUKdm90ZV85Ogpwcm90byAzIDAKYnl0ZWNfMCAvLyAiIgppbnRjXzAgLy8gMApkdXBuIDcKYnl0ZWNfMCAvLyAiIgpwdXNoaW50IDc3MDAgLy8gNzcwMAppbnRjXzIgLy8gMTAKKwpzdG9yZSA0OQp2b3RlXzlfbDE6CmxvYWQgNDkKZ2xvYmFsIE9wY29kZUJ1ZGdldAo+CmJueiB2b3RlXzlfbDUKZnJhbWVfZGlnIC0yCmV4dHJhY3QgMiAwCmNhbGxzdWIgYWxsb3dlZHRvdm90ZV80Ci8vIE5vdCBhbGxvd2VkIHRvIHZvdGUKYXNzZXJ0CmNhbGxzdWIgdm90aW5nb3Blbl81Ci8vIFZvdGluZyBub3Qgb3Blbgphc3NlcnQKY2FsbHN1YiBhbHJlYWR5dm90ZWRfNgohCi8vIEFscmVhZHkgdm90ZWQKYXNzZXJ0CmJ5dGVjXzMgLy8gIm9wdGlvbl9jb3VudHMiCmFwcF9nbG9iYWxfZ2V0CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMAppbnRjXzAgLy8gMApleHRyYWN0X3VpbnQxNgpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKc3RvcmUgNTAKZnJhbWVfZGlnIC0xCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgMgpsb2FkIDUwCj09Ci8vIE51bWJlciBvZiBhbnN3ZXJzIGluY29ycmVjdAphc3NlcnQKcHVzaGludCAyNTAwIC8vIDI1MDAKcHVzaGludCAzNCAvLyAzNAppbnRjXzEgLy8gMQpmcmFtZV9kaWcgLTEKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSA0CmZyYW1lX2RpZyA0CioKKwpwdXNoaW50IDQwMCAvLyA0MDAKKgorCnN0b3JlIDUxCmZyYW1lX2RpZyAtMwpndHhucyBSZWNlaXZlcgpnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwo9PQovLyBQYXltZW50IG11c3QgYmUgdG8gYXBwIGFkZHJlc3MKYXNzZXJ0CmxvYWQgNTEKaXRvYgpsb2cKZnJhbWVfZGlnIC0zCmd0eG5zIEFtb3VudApsb2FkIDUxCj09Ci8vIFBheW1lbnQgbXVzdCBiZSB0aGUgZXhhY3QgbWluIGJhbGFuY2UgcmVxdWlyZW1lbnQKYXNzZXJ0CmludGNfMCAvLyAwCnN0b3JlIDUyCmludGNfMCAvLyAwCnN0b3JlIDUzCnZvdGVfOV9sMzoKbG9hZCA1Mwpsb2FkIDUwCjwKYnogdm90ZV85X2w2CmZyYW1lX2RpZyAtMQppbnRjXzEgLy8gMQpsb2FkIDUzCioKcHVzaGludCAyIC8vIDIKKwpnZXRieXRlCmZyYW1lX2J1cnkgNQpmcmFtZV9kaWcgMAppbnRjXzEgLy8gMQpsb2FkIDUzCioKcHVzaGludCAyIC8vIDIKKwpnZXRieXRlCmZyYW1lX2J1cnkgNwpmcmFtZV9kaWcgNQpmcmFtZV9kaWcgNwo8Ci8vIEFuc3dlciBvcHRpb24gaW5kZXggaW52YWxpZAphc3NlcnQKcHVzaGludCA4IC8vIDgKbG9hZCA1MgpmcmFtZV9kaWcgNQorCioKc3RvcmUgNTQKYnl0ZWMgOCAvLyAiViIKbG9hZCA1NApwdXNoaW50IDggLy8gOApib3hfZXh0cmFjdApidG9pCnN0b3JlIDU1CmJ5dGVjIDggLy8gIlYiCmxvYWQgNTQKbG9hZCA1NQppbnRjXzEgLy8gMQorCml0b2IKYm94X3JlcGxhY2UKbG9hZCA1MgpmcmFtZV9kaWcgNworCnN0b3JlIDUyCmxvYWQgNTMKaW50Y18xIC8vIDEKKwpzdG9yZSA1MwpiIHZvdGVfOV9sMwp2b3RlXzlfbDU6Cml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiB2b3RlXzlfbDEKdm90ZV85X2w2Ogp0eG4gU2VuZGVyCmZyYW1lX2J1cnkgOQpmcmFtZV9kaWcgOQpsZW4KcHVzaGludCAzMiAvLyAzMgo9PQphc3NlcnQKZnJhbWVfZGlnIDkKYm94X2RlbApwb3AKZnJhbWVfZGlnIDkKZnJhbWVfZGlnIC0xCmJveF9wdXQKYnl0ZWMgNSAvLyAidm90ZXJfY291bnQiCmJ5dGVjIDUgLy8gInZvdGVyX2NvdW50IgphcHBfZ2xvYmFsX2dldAppbnRjXzEgLy8gMQorCmFwcF9nbG9iYWxfcHV0CnJldHN1Yg==\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 5,\n      \"num_uints\": 8\n    },\n    \"local\": {\n      \"num_byte_slices\": 0,", "    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"schema\": {\n    \"global\": {\n      \"declared\": {\n        \"close_time\": {\n          \"type\": \"uint64\",", "        \"close_time\": {\n          \"type\": \"uint64\",\n          \"key\": \"close_time\",\n          \"descr\": \"The unix timestamp of the time the vote was closed\"\n        },\n        \"end_time\": {\n          \"type\": \"uint64\",\n          \"key\": \"end_time\",\n          \"descr\": \"The unix timestamp of the ending time of voting\"\n        },", "          \"descr\": \"The unix timestamp of the ending time of voting\"\n        },\n        \"is_bootstrapped\": {\n          \"type\": \"uint64\",\n          \"key\": \"is_bootstrapped\",\n          \"descr\": \"Whether or not the contract has been bootstrapped with answers\"\n        },\n        \"metadata_ipfs_cid\": {\n          \"type\": \"bytes\",\n          \"key\": \"metadata_ipfs_cid\",", "          \"type\": \"bytes\",\n          \"key\": \"metadata_ipfs_cid\",\n          \"descr\": \"The IPFS content ID of the voting metadata file\"\n        },\n        \"nft_asset_id\": {\n          \"type\": \"uint64\",\n          \"key\": \"nft_asset_id\",\n          \"descr\": \"The asset ID of a result NFT if one has been created\"\n        },\n        \"nft_image_url\": {", "        },\n        \"nft_image_url\": {\n          \"type\": \"bytes\",\n          \"key\": \"nft_image_url\",\n          \"descr\": \"The IPFS URL of the default image to use as the media of the result NFT\"\n        },\n        \"option_counts\": {\n          \"type\": \"bytes\",\n          \"key\": \"option_counts\",\n          \"descr\": \"The number of options for each question\"", "          \"key\": \"option_counts\",\n          \"descr\": \"The number of options for each question\"\n        },\n        \"quorum\": {\n          \"type\": \"uint64\",\n          \"key\": \"quorum\",\n          \"descr\": \"The minimum number of voters to reach quorum\"\n        },\n        \"snapshot_public_key\": {\n          \"type\": \"bytes\",", "        \"snapshot_public_key\": {\n          \"type\": \"bytes\",\n          \"key\": \"snapshot_public_key\",\n          \"descr\": \"The public key of the Ed25519 compatible private key that was used to encrypt entries in the vote gating snapshot\"\n        },\n        \"start_time\": {\n          \"type\": \"uint64\",\n          \"key\": \"start_time\",\n          \"descr\": \"The unix timestamp of the starting time of voting\"\n        },", "          \"descr\": \"The unix timestamp of the starting time of voting\"\n        },\n        \"total_options\": {\n          \"type\": \"uint64\",\n          \"key\": \"total_options\",\n          \"descr\": \"The total number of options\"\n        },\n        \"vote_id\": {\n          \"type\": \"bytes\",\n          \"key\": \"vote_id\",", "          \"type\": \"bytes\",\n          \"key\": \"vote_id\",\n          \"descr\": \"The identifier of this voting round\"\n        },\n        \"voter_count\": {\n          \"type\": \"uint64\",\n          \"key\": \"voter_count\",\n          \"descr\": \"The minimum number of voters who have voted\"\n        }\n      },", "        }\n      },\n      \"reserved\": {}\n    },\n    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    }\n  },\n  \"contract\": {", "  },\n  \"contract\": {\n    \"name\": \"VotingRoundApp\",\n    \"methods\": [\n      {\n        \"name\": \"create\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"vote_id\"", "            \"type\": \"string\",\n            \"name\": \"vote_id\"\n          },\n          {\n            \"type\": \"byte[]\",\n            \"name\": \"snapshot_public_key\"\n          },\n          {\n            \"type\": \"string\",\n            \"name\": \"metadata_ipfs_cid\"", "            \"type\": \"string\",\n            \"name\": \"metadata_ipfs_cid\"\n          },\n          {\n            \"type\": \"uint64\",\n            \"name\": \"start_time\"\n          },\n          {\n            \"type\": \"uint64\",\n            \"name\": \"end_time\"", "            \"type\": \"uint64\",\n            \"name\": \"end_time\"\n          },\n          {\n            \"type\": \"uint8[]\",\n            \"name\": \"option_counts\"\n          },\n          {\n            \"type\": \"uint64\",\n            \"name\": \"quorum\"", "            \"type\": \"uint64\",\n            \"name\": \"quorum\"\n          },\n          {\n            \"type\": \"string\",\n            \"name\": \"nft_image_url\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"", "        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"bootstrap\",\n        \"args\": [\n          {\n            \"type\": \"pay\",\n            \"name\": \"fund_min_bal_req\"", "            \"type\": \"pay\",\n            \"name\": \"fund_min_bal_req\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"close\",", "      {\n        \"name\": \"close\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"get_preconditions\",\n        \"args\": [", "        \"name\": \"get_preconditions\",\n        \"args\": [\n          {\n            \"type\": \"byte[]\",\n            \"name\": \"signature\",\n            \"desc\": \"The signature for the given voter account\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"(uint64,uint64,uint64,uint64)\",", "        \"returns\": {\n          \"type\": \"(uint64,uint64,uint64,uint64)\",\n          \"desc\": \"The precondition values\"\n        },\n        \"desc\": \"Returns the calculated pre-conditions for the voting round.\"\n      },\n      {\n        \"name\": \"vote\",\n        \"args\": [\n          {", "        \"args\": [\n          {\n            \"type\": \"pay\",\n            \"name\": \"fund_min_bal_req\"\n          },\n          {\n            \"type\": \"byte[]\",\n            \"name\": \"signature\"\n          },\n          {", "          },\n          {\n            \"type\": \"uint8[]\",\n            \"name\": \"answer_ids\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      }", "        }\n      }\n    ],\n    \"networks\": {}\n  },\n  \"bare_call_config\": {\n    \"delete_application\": \"CALL\"\n  }\n}\n", "}\n\n/**\n * Defines an onCompletionAction of 'no_op'\n */\nexport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */\nexport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n/**\n * Defines an onCompletionAction of 'close_out'\n */", "export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n/**\n * Defines an onCompletionAction of 'close_out'\n */\nexport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */\nexport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n/**\n * Defines an onCompletionAction of 'update_application'\n */", "export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n/**\n * Defines an onCompletionAction of 'update_application'\n */\nexport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */\nexport type IntegerState = {\n  /**\n   * Gets the state value as a BigInt \n   */\n  asBigInt(): bigint\n  /**\n   * Gets the state value as a number.\n   */\n  asNumber(): number\n}\n/**\n * A state record containing binary data\n */", "export type IntegerState = {\n  /**\n   * Gets the state value as a BigInt \n   */\n  asBigInt(): bigint\n  /**\n   * Gets the state value as a number.\n   */\n  asNumber(): number\n}\n/**\n * A state record containing binary data\n */", "export type BinaryState = {\n  /**\n   * Gets the state value as a Uint8Array\n   */\n  asByteArray(): Uint8Array\n  /**\n   * Gets the state value as a string\n   */\n  asString(): string\n}\n\n/**\n * Defines the types of available calls and state of the VotingRoundApp smart contract.\n */", "export type VotingRoundApp = {\n  /**\n   * Maps method signatures / names to their argument and return types.\n   */\n  methods:\n    & Record<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void' | 'create', {\n      argsObj: {\n        vote_id: string\n        snapshot_public_key: Uint8Array\n        metadata_ipfs_cid: string\n        start_time: bigint | number\n        end_time: bigint | number\n        option_counts: number[]\n        quorum: bigint | number\n        nft_image_url: string\n      }\n      argsTuple: [vote_id: string, snapshot_public_key: Uint8Array, metadata_ipfs_cid: string, start_time: bigint | number, end_time: bigint | number, option_counts: number[], quorum: bigint | number, nft_image_url: string]\n      returns: void\n    }>\n    & Record<'bootstrap(pay)void' | 'bootstrap', {\n      argsObj: {\n        fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>\n      }\n      argsTuple: [fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>]\n      returns: void\n    }>\n    & Record<'close()void' | 'close', {\n      argsObj: {\n      }\n      argsTuple: []\n      returns: void\n    }>\n    & Record<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)' | 'get_preconditions', {\n      argsObj: {\n        /**\n         * The signature for the given voter account\n         */\n        signature: Uint8Array\n      }\n      argsTuple: [signature: Uint8Array]\n      /**\n       * The precondition values\n       */\n      returns: VotingPreconditions\n    }>\n    & Record<'vote(pay,byte[],uint8[])void' | 'vote', {\n      argsObj: {\n        fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>\n        signature: Uint8Array\n        answer_ids: number[]\n      }\n      argsTuple: [fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>, signature: Uint8Array, answer_ids: number[]]\n      returns: void\n    }>\n  /**\n   * Defines the shape of the global and local state of the application.\n   */\n  state: {\n    global: {\n      /**\n       * The unix timestamp of the time the vote was closed\n       */\n      'close_time'?: IntegerState\n      /**\n       * The unix timestamp of the ending time of voting\n       */\n      'end_time'?: IntegerState\n      /**\n       * Whether or not the contract has been bootstrapped with answers\n       */\n      'is_bootstrapped'?: IntegerState\n      /**\n       * The IPFS content ID of the voting metadata file\n       */\n      'metadata_ipfs_cid'?: BinaryState\n      /**\n       * The asset ID of a result NFT if one has been created\n       */\n      'nft_asset_id'?: IntegerState\n      /**\n       * The IPFS URL of the default image to use as the media of the result NFT\n       */\n      'nft_image_url'?: BinaryState\n      /**\n       * The number of options for each question\n       */\n      'option_counts'?: BinaryState\n      /**\n       * The minimum number of voters to reach quorum\n       */\n      'quorum'?: IntegerState\n      /**\n       * The public key of the Ed25519 compatible private key that was used to encrypt entries in the vote gating snapshot\n       */\n      'snapshot_public_key'?: BinaryState\n      /**\n       * The unix timestamp of the starting time of voting\n       */\n      'start_time'?: IntegerState\n      /**\n       * The total number of options\n       */\n      'total_options'?: IntegerState\n      /**\n       * The identifier of this voting round\n       */\n      'vote_id'?: BinaryState\n      /**\n       * The minimum number of voters who have voted\n       */\n      'voter_count'?: IntegerState\n    }\n  }\n}\n/**\n * Defines the possible abi call signatures\n */", "export type VotingRoundAppSig = keyof VotingRoundApp['methods']\n/**\n * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n */\nexport type TypedCallParams<TSignature extends VotingRoundAppSig | undefined> = {\n  method: TSignature\n  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n} & AppClientCallCoreParams & CoreAppCallArgs\n/**\n * Defines the arguments required for a bare call\n */", "export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n/**\n * Represents a VotingPreconditions result as a struct\n */\nexport type VotingPreconditions = {\n  is_voting_open: bigint\n  is_allowed_to_vote: bigint\n  has_already_voted: bigint\n  current_time: bigint\n}\n/**\n * Converts the tuple representation of a VotingPreconditions to the struct representation\n */", "export function VotingPreconditions([is_voting_open, is_allowed_to_vote, has_already_voted, current_time]: [bigint, bigint, bigint, bigint] ) {\n  return {\n    is_voting_open,\n    is_allowed_to_vote,\n    has_already_voted,\n    current_time,\n  }\n}\n/**\n * Maps a method signature from the VotingRoundApp smart contract to the method's arguments in either tuple of struct form\n */", "export type MethodArgs<TSignature extends VotingRoundAppSig> = VotingRoundApp['methods'][TSignature]['argsObj' | 'argsTuple']\n/**\n * Maps a method signature from the VotingRoundApp smart contract to the method's return type\n */\nexport type MethodReturn<TSignature extends VotingRoundAppSig> = VotingRoundApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */\nexport type VotingRoundAppCreateCalls = (typeof VotingRoundAppCallFactory)['create']\n/**\n * Defines supported create methods for this smart contract\n */", "export type VotingRoundAppCreateCalls = (typeof VotingRoundAppCallFactory)['create']\n/**\n * Defines supported create methods for this smart contract\n */\nexport type VotingRoundAppCreateCallParams =\n  | (TypedCallParams<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'> & (OnCompleteNoOp))\n/**\n * A factory for available 'delete' calls\n */\nexport type VotingRoundAppDeleteCalls = (typeof VotingRoundAppCallFactory)['delete']\n/**\n * Defines supported delete methods for this smart contract\n */", "export type VotingRoundAppDeleteCalls = (typeof VotingRoundAppCallFactory)['delete']\n/**\n * Defines supported delete methods for this smart contract\n */\nexport type VotingRoundAppDeleteCallParams =\n  | TypedCallParams<undefined>\n/**\n * Defines arguments required for the deploy method.\n */\nexport type VotingRoundAppDeployArgs = {\n  deployTimeParams?: TealTemplateParams\n  /**\n   * A delegate which takes a create call factory and returns the create call params for this smart contract\n   */\n  createCall?: (callFactory: VotingRoundAppCreateCalls) => VotingRoundAppCreateCallParams\n  /**\n   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n   */\n  deleteCall?: (callFactory: VotingRoundAppDeleteCalls) => VotingRoundAppDeleteCallParams\n}\n\n\n/**\n * Exposes methods for constructing all available smart contract calls\n */", "export type VotingRoundAppDeployArgs = {\n  deployTimeParams?: TealTemplateParams\n  /**\n   * A delegate which takes a create call factory and returns the create call params for this smart contract\n   */\n  createCall?: (callFactory: VotingRoundAppCreateCalls) => VotingRoundAppCreateCallParams\n  /**\n   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n   */\n  deleteCall?: (callFactory: VotingRoundAppDeleteCalls) => VotingRoundAppDeleteCallParams\n}\n\n\n/**\n * Exposes methods for constructing all available smart contract calls\n */", "export abstract class VotingRoundAppCallFactory {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the VotingRoundApp smart contract using the create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      create(args: MethodArgs<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n        return {\n          method: 'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void' as const,\n          methodArgs: Array.isArray(args) ? args : [args.vote_id, args.snapshot_public_key, args.metadata_ipfs_cid, args.start_time, args.end_time, args.option_counts, args.quorum, args.nft_image_url],\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available delete call factories\n   */\n  static get delete() {\n    return {\n      /**\n       * Constructs a delete call for the VotingRoundApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Constructs a no op call for the bootstrap(pay)void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'bootstrap(pay)void' as const,\n      methodArgs: Array.isArray(args) ? args : [args.fund_min_bal_req],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the close()void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static close(args: MethodArgs<'close()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'close()void' as const,\n      methodArgs: Array.isArray(args) ? args : [],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the get_preconditions(byte[])(uint64,uint64,uint64,uint64) ABI method\n   *\n   * Returns the calculated pre-conditions for the voting round.\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'get_preconditions(byte[])(uint64,uint64,uint64,uint64)' as const,\n      methodArgs: Array.isArray(args) ? args : [args.signature],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the vote(pay,byte[],uint8[])void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'vote(pay,byte[],uint8[])void' as const,\n      methodArgs: Array.isArray(args) ? args : [args.fund_min_bal_req, args.signature, args.answer_ids],\n      ...params,\n    }\n  }\n}\n\n/**\n * A client to make calls to the VotingRoundApp smart contract\n */", "export class VotingRoundAppClient {\n  /**\n   * The underlying `ApplicationClient` for when you want to have more flexibility\n   */\n  public readonly appClient: ApplicationClient\n\n  private readonly sender: SendTransactionFrom | undefined\n\n  /**\n   * Creates a new instance of `VotingRoundAppClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails: AppDetails, private algod: Algodv2) {\n    this.sender = appDetails.sender\n    this.appClient = algokit.getAppClient({\n      ...appDetails,\n      app: APP_SPEC\n    }, algod)\n  }\n\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {", "    if(result.return?.decodeError) {\n      throw result.return.decodeError\n    }\n    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n      ? returnValueFormatter(result.return.returnValue)\n      : result.return?.returnValue as TReturn | undefined\n      return { ...result, return: returnValue }\n  }\n\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  public async call<TSignature extends keyof VotingRoundApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n  }\n\n  /**\n   * Idempotently deploys the VotingRoundApp smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  public deploy(params: VotingRoundAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n    const createArgs = params.createCall?.(VotingRoundAppCallFactory.create)\n    const deleteArgs = params.deleteCall?.(VotingRoundAppCallFactory.delete)\n    return this.appClient.deploy({\n      ...params,\n      deleteArgs,\n      createArgs,\n      createOnCompleteAction: createArgs?.onCompleteAction,\n    })\n  }\n\n  /**\n   * Gets available create methods\n   */\n  public get create() {\n    const $this = this\n    return {\n      /**\n       * Creates a new instance of the VotingRoundApp smart contract using the create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      async create(args: MethodArgs<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'>>> {\n        return $this.mapReturnValue(await $this.appClient.create(VotingRoundAppCallFactory.create.create(args, params)))\n      },\n    }\n  }\n\n  /**\n   * Gets available delete methods\n   */\n  public get delete() {\n    const $this = this\n    return {\n      /**\n       * Deletes an existing instance of the VotingRoundApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The delete result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.delete(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n    }\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the VotingRoundApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.appClient.clearState(args)\n  }\n\n  /**\n   * Calls the bootstrap(pay)void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(VotingRoundAppCallFactory.bootstrap(args, params))\n  }\n\n  /**\n   * Calls the close()void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public close(args: MethodArgs<'close()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(VotingRoundAppCallFactory.close(args, params))\n  }\n\n  /**\n   * Calls the get_preconditions(byte[])(uint64,uint64,uint64,uint64) ABI method.\n   *\n   * Returns the calculated pre-conditions for the voting round.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call: The precondition values\n   */\n  public getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(VotingRoundAppCallFactory.getPreconditions(args, params), VotingPreconditions)\n  }\n\n  /**\n   * Calls the vote(pay,byte[],uint8[])void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(VotingRoundAppCallFactory.vote(args, params))\n  }\n\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {\n    const value = state[key]", "    if (!value) return undefined\n    if (!('valueRaw' in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)\n    return {\n      asString(): string {\n        return value.value\n      },\n      asByteArray(): Uint8Array {\n        return value.valueRaw\n      }\n    }\n  }\n\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {\n    const value = state[key]", "    if (!value) return undefined\n    if ('valueRaw' in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)\n    return {\n      asBigInt() {\n        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)\n      },\n      asNumber(): number {\n        return typeof value.value === 'bigint' ? Number(value.value) : value.value\n      },\n    }\n  }\n\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  public async getGlobalState(): Promise<VotingRoundApp['state']['global']> {\n    const state = await this.appClient.getGlobalState()\n    return {\n      get close_time() {\n        return VotingRoundAppClient.getIntegerState(state, 'close_time')\n      },\n      get end_time() {\n        return VotingRoundAppClient.getIntegerState(state, 'end_time')\n      },\n      get is_bootstrapped() {\n        return VotingRoundAppClient.getIntegerState(state, 'is_bootstrapped')\n      },\n      get metadata_ipfs_cid() {\n        return VotingRoundAppClient.getBinaryState(state, 'metadata_ipfs_cid')\n      },\n      get nft_asset_id() {\n        return VotingRoundAppClient.getIntegerState(state, 'nft_asset_id')\n      },\n      get nft_image_url() {\n        return VotingRoundAppClient.getBinaryState(state, 'nft_image_url')\n      },\n      get option_counts() {\n        return VotingRoundAppClient.getBinaryState(state, 'option_counts')\n      },\n      get quorum() {\n        return VotingRoundAppClient.getIntegerState(state, 'quorum')\n      },\n      get snapshot_public_key() {\n        return VotingRoundAppClient.getBinaryState(state, 'snapshot_public_key')\n      },\n      get start_time() {\n        return VotingRoundAppClient.getIntegerState(state, 'start_time')\n      },\n      get total_options() {\n        return VotingRoundAppClient.getIntegerState(state, 'total_options')\n      },\n      get vote_id() {\n        return VotingRoundAppClient.getBinaryState(state, 'vote_id')\n      },\n      get voter_count() {\n        return VotingRoundAppClient.getIntegerState(state, 'voter_count')\n      },\n    }\n  }\n\n  public compose(): VotingRoundAppComposer {\n    const client = this\n    const atc = new AtomicTransactionComposer()\n    let promiseChain:Promise<unknown> = Promise.resolve()\n    const resultMappers: Array<undefined | ((x: any) => any)> = []\n    return {\n      bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.bootstrap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      close(args: MethodArgs<'close()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.close(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.getPreconditions(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(VotingPreconditions)\n        return this\n      },\n      vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.vote(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      get delete() {\n        const $this = this\n        return {\n          bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n            promiseChain = promiseChain.then(() => client.delete.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n        return this\n      },\n      async atc() {\n        await promiseChain\n        return atc\n      },\n      async execute() {\n        await promiseChain\n        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n        return {\n          ...result,\n          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n        }\n      }\n    } as unknown as VotingRoundAppComposer\n  }\n}", "export type VotingRoundAppComposer<TReturns extends [...any[]] = []> = {\n  /**\n   * Calls the bootstrap(pay)void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'bootstrap(pay)void'>]>\n\n  /**\n   * Calls the close()void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  close(args: MethodArgs<'close()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'close()void'>]>\n\n  /**\n   * Calls the get_preconditions(byte[])(uint64,uint64,uint64,uint64) ABI method.\n   *\n   * Returns the calculated pre-conditions for the voting round.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>]>\n\n  /**\n   * Calls the vote(pay,byte[],uint8[])void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'vote(pay,byte[],uint8[])void'>]>\n\n  /**\n   * Gets available delete methods\n   */\n  readonly delete: {\n    /**\n     * Deletes an existing instance of the VotingRoundApp smart contract using a bare call.\n     *\n     * @param args The arguments for the bare call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, undefined]>\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the VotingRoundApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, undefined]>\n\n  /**\n   * Adds a transaction to the composer\n   *\n   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n   */\n  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): VotingRoundAppComposer<TReturns>\n  /**\n   * Returns the underlying AtomicTransactionComposer instance\n   */\n  atc(): Promise<AtomicTransactionComposer>\n  /**\n   * Executes the transaction group and returns an array of results\n   */\n  execute(): Promise<VotingRoundAppComposerResults<TReturns>>\n}", "export type VotingRoundAppComposerResults<TReturns extends [...any[]]> = {\n  returns: TReturns\n  groupId: string\n  txIds: string[]\n  transactions: Transaction[]\n}\n"]}
{"filename": "examples/state/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { beforeEach, describe, expect, test } from '@jest/globals'\nimport { StateAppClient } from './client'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\ndescribe('state typed client', () => {\n  const localnet = algorandFixture()\n  beforeEach(localnet.beforeEach, 10_000)\n\n  test('Exposes state correctly', async () => {", "\n  test('Exposes state correctly', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new StateAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },", "        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\n    await client.setGlobal({ int1: 1, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n\n    const globalState = await client.getGlobalState()\n", "    const globalState = await client.getGlobalState()\n\n    expect(globalState.int1?.asNumber()).toBe(1)\n    expect(globalState.int2?.asNumber()).toBe(2)\n    expect(globalState.bytes1?.asString()).toBe('asdf')\n    expect(globalState.bytes2?.asByteArray()).toEqual(new Uint8Array([1, 2, 3, 4]))\n\n    await client.optIn.optIn([])\n    await client.setLocal({ int1: 1, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n", "    await client.setLocal({ int1: 1, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n\n    const localState = await client.getLocalState(testAccount)\n\n    expect(localState.local_int1?.asNumber()).toBe(1)\n    expect(localState.local_int2?.asNumber()).toBe(2)\n    expect(localState.local_bytes1?.asString()).toBe('asdf')\n    expect(localState.local_bytes2?.asByteArray()).toEqual(new Uint8Array([1, 2, 3, 4]))\n  })\n", "  })\n\n  test('Readonly methods do not consume algos', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new StateAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,", "        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\n    const minBalance = 100_000\n    const txCost = 1_000\n", "    const txCost = 1_000\n\n    const lowFundsAccount = await localnet.context.generateAccount({ initialFunds: microAlgos(minBalance + txCost) })\n\n    const result = await client.callAbi({ value: 'oh hi' }, { sender: lowFundsAccount })\n\n    expect(result.return).toBe('Hello, oh hi')\n\n    // If we can invoke this method twice it confirms that we are still above the min balance + single tx amount and the previous call\n    // did not consume algos", "    // If we can invoke this method twice it confirms that we are still above the min balance + single tx amount and the previous call\n    // did not consume algos\n    await client.callAbi({ value: 'oh hi' }, { sender: lowFundsAccount })\n  })\n\n  test('Arguments with defaults defined are not required, and use their default value strategies when set to undefined', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new StateAppClient(\n      {\n        resolveBy: 'creatorAndName',", "      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n    await client.setGlobal({ int1: 50, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })", "    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n    await client.setGlobal({ int1: 50, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n    await client.optIn.optIn({})\n    await client.setLocal({ bytes1: 'default value', int2: 0, int1: 0, bytes2: new Uint8Array([1, 2, 3, 4]) })\n\n    const constantDefined = await client.defaultValue({ arg_with_default: 'defined value' })\n    expect(constantDefined.return).toBe('defined value')\n\n    const constantDefault = await client.defaultValue({})\n    expect(constantDefault.return).toBe('default value')", "    const constantDefault = await client.defaultValue({})\n    expect(constantDefault.return).toBe('default value')\n\n    const abiDefined = await client.defaultValueFromAbi({ arg_with_default: 'defined value' })\n    expect(abiDefined.return).toBe('ABI, defined value')\n\n    const abiDefault = await client.defaultValueFromAbi({})\n    expect(abiDefault.return).toBe('ABI, default value')\n\n    const intDefined = await client.defaultValueInt({ arg_with_default: 42 })", "\n    const intDefined = await client.defaultValueInt({ arg_with_default: 42 })\n    expect(intDefined.return).toBe(42n)\n\n    const intDefault = await client.defaultValueInt({})\n    expect(intDefault.return).toBe(123n)\n\n    const globalDefined = await client.defaultValueFromGlobalState({ arg_with_default: 123 })\n    expect(globalDefined.return).toBe(123n)\n", "    expect(globalDefined.return).toBe(123n)\n\n    const globalState = await client.getGlobalState()\n    const globalDefault = await client.defaultValueFromGlobalState({})\n    expect(globalDefault.return).toBe(globalState.int1?.asBigInt())\n\n    const localDefined = await client.defaultValueFromLocalState({ arg_with_default: 'defined value' })\n    expect(localDefined.return).toBe('Local state, defined value')\n\n    const localState = await client.getLocalState(testAccount)", "\n    const localState = await client.getLocalState(testAccount)\n    const localDefault = await client.defaultValueFromLocalState({})\n    expect(localDefault.return).toBe(`Local state, ${localState.local_bytes1?.asString()}`)\n  })\n\n  test('Methods can be composed', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new StateAppClient(\n      {", "    const client = new StateAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })", "    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\n    await client\n      .compose()\n      .optIn.optIn({})\n      .setLocal({ bytes1: 'default value', int2: 0, int1: 0, bytes2: new Uint8Array([1, 2, 3, 4]) })\n      .execute()\n\n    const localState = await client.getLocalState(testAccount)", "\n    const localState = await client.getLocalState(testAccount)\n\n    expect(localState.local_bytes1?.asString()).toBe('default value')\n  })\n\n  test('ABI methods which take references can be called', async () => {\n    const { algod, indexer, testAccount } = localnet.context\n    const client = new StateAppClient(\n      {", "    const client = new StateAppClient(\n      {\n        resolveBy: 'creatorAndName',\n        sender: testAccount,\n        creatorAddress: testAccount.addr,\n        findExistingUsing: indexer,\n      },\n      algod,\n    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })", "    )\n    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\n    // Call with number\n    await client.callWithReferences({\n      asset: 1234,\n      account: testAccount.addr,\n      application: (await client.appClient.getAppReference()).appId,\n    })\n  })", "    })\n  })\n})\n"]}
{"filename": "examples/state/client.ts", "chunked_list": ["/* eslint-disable */\n/**\n * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n * DO NOT MODIFY IT BY HAND.\n * requires: @algorandfoundation/algokit-utils: ^2\n */\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport type {\n  AppCallTransactionResult,\n  AppCallTransactionResultOfType,", "  AppCallTransactionResult,\n  AppCallTransactionResultOfType,\n  CoreAppCallArgs,\n  RawAppCallArgs,\n  AppState,\n  TealTemplateParams,\n  ABIAppCallArg,\n} from '@algorandfoundation/algokit-utils/types/app'\nimport type {\n  AppClientCallCoreParams,", "import type {\n  AppClientCallCoreParams,\n  AppClientCompilationParams,\n  AppClientDeployCoreParams,\n  AppDetails,\n  ApplicationClient,\n} from '@algorandfoundation/algokit-utils/types/app-client'\nimport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\nimport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'", "import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'\nimport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\nexport const APP_SPEC: AppSpec = {\n  \"hints\": {\n    \"call_abi(string)string\": {\n      \"read_only\": true,\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }", "        \"no_op\": \"CALL\"\n      }\n    },\n    \"call_abi_txn(pay,string)string\": {\n      \"read_only\": true,\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"call_with_references(asset,account,application)uint64\": {", "    },\n    \"call_with_references(asset,account,application)uint64\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"set_global(uint64,uint64,string,byte[4])void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }", "        \"no_op\": \"CALL\"\n      }\n    },\n    \"set_local(uint64,uint64,string,byte[4])void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"set_box(byte[4],string)void\": {\n      \"call_config\": {", "    \"set_box(byte[4],string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"error()void\": {\n      \"read_only\": true,\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }", "        \"no_op\": \"CALL\"\n      }\n    },\n    \"default_value(string)string\": {\n      \"read_only\": true,\n      \"default_arguments\": {\n        \"arg_with_default\": {\n          \"source\": \"constant\",\n          \"data\": \"default value\"\n        }", "          \"data\": \"default value\"\n        }\n      },\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"default_value_int(uint64)uint64\": {\n      \"read_only\": true,\n      \"default_arguments\": {", "      \"read_only\": true,\n      \"default_arguments\": {\n        \"arg_with_default\": {\n          \"source\": \"constant\",\n          \"data\": 123\n        }\n      },\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }", "        \"no_op\": \"CALL\"\n      }\n    },\n    \"default_value_from_abi(string)string\": {\n      \"read_only\": true,\n      \"default_arguments\": {\n        \"arg_with_default\": {\n          \"source\": \"abi-method\",\n          \"data\": {\n            \"name\": \"default_value\",", "          \"data\": {\n            \"name\": \"default_value\",\n            \"args\": [\n              {\n                \"type\": \"string\",\n                \"name\": \"arg_with_default\"\n              }\n            ],\n            \"returns\": {\n              \"type\": \"string\"", "            \"returns\": {\n              \"type\": \"string\"\n            }\n          }\n        }\n      },\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },", "      }\n    },\n    \"default_value_from_global_state(uint64)uint64\": {\n      \"read_only\": true,\n      \"default_arguments\": {\n        \"arg_with_default\": {\n          \"source\": \"global-state\",\n          \"data\": \"int1\"\n        }\n      },", "        }\n      },\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"default_value_from_local_state(string)string\": {\n      \"read_only\": true,\n      \"default_arguments\": {\n        \"arg_with_default\": {", "      \"default_arguments\": {\n        \"arg_with_default\": {\n          \"source\": \"local-state\",\n          \"data\": \"local_bytes1\"\n        }\n      },\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },", "      }\n    },\n    \"create_abi(string)string\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },\n    \"update_abi(string)string\": {\n      \"call_config\": {\n        \"update_application\": \"CALL\"", "      \"call_config\": {\n        \"update_application\": \"CALL\"\n      }\n    },\n    \"delete_abi(string)string\": {\n      \"call_config\": {\n        \"delete_application\": \"CALL\"\n      }\n    },\n    \"opt_in()void\": {", "    },\n    \"opt_in()void\": {\n      \"call_config\": {\n        \"opt_in\": \"CALL\"\n      }\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMCA1IFRNUExfVVBEQVRBQkxFIFRNUExfREVMRVRBQkxFCmJ5dGVjYmxvY2sgMHgxNTFmN2M3NSAweAp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sMzQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhmMTdlODBhNSAvLyAiY2FsbF9hYmkoc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDMzCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4MGE5MmE4MWUgLy8gImNhbGxfYWJpX3R4bihwYXksc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDMyCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4ZmVmZGYxMWUgLy8gImNhbGxfd2l0aF9yZWZlcmVuY2VzKGFzc2V0LGFjY291bnQsYXBwbGljYXRpb24pdWludDY0Igo9PQpibnogbWFpbl9sMzEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGNmOGRlYSAvLyAic2V0X2dsb2JhbCh1aW50NjQsdWludDY0LHN0cmluZyxieXRlWzRdKXZvaWQiCj09CmJueiBtYWluX2wzMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGNlYzI4MzRhIC8vICJzZXRfbG9jYWwodWludDY0LHVpbnQ2NCxzdHJpbmcsYnl0ZVs0XSl2b2lkIgo9PQpibnogbWFpbl9sMjkKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGI0YTIzMCAvLyAic2V0X2JveChieXRlWzRdLHN0cmluZyl2b2lkIgo9PQpibnogbWFpbl9sMjgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg0NGQwZGEwZCAvLyAiZXJyb3IoKXZvaWQiCj09CmJueiBtYWluX2wyNwp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDU3NGI1NWM4IC8vICJkZWZhdWx0X3ZhbHVlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDM2MDM2MmU5IC8vICJkZWZhdWx0X3ZhbHVlX2ludCh1aW50NjQpdWludDY0Igo9PQpibnogbWFpbl9sMjUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg0NmQyMTFhMyAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2FiaShzdHJpbmcpc3RyaW5nIgo9PQpibnogbWFpbl9sMjQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgwY2ZjYmIwMCAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2dsb2JhbF9zdGF0ZSh1aW50NjQpdWludDY0Igo9PQpibnogbWFpbl9sMjMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhkMGYwYmFmOCAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2xvY2FsX3N0YXRlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDlkNTIzMDQwIC8vICJjcmVhdGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDNjYTVjZWI3IC8vICJ1cGRhdGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDI3MWI0ZWU5IC8vICJkZWxldGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wxOQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDMwYzZkNThhIC8vICJvcHRfaW4oKXZvaWQiCj09CmJueiBtYWluX2wxOAplcnIKbWFpbl9sMTg6CnR4biBPbkNvbXBsZXRpb24KaW50Y18xIC8vIE9wdEluCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIG9wdGluXzE5CmludGNfMSAvLyAxCnJldHVybgptYWluX2wxOToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBkZWxldGVhYmlfMTgKc3RvcmUgMjUKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMjUKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjA6CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCA0IC8vIFVwZGF0ZUFwcGxpY2F0aW9uCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgdXBkYXRlYWJpXzE2CnN0b3JlIDI0CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDI0CmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIxOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgY3JlYXRlYWJpXzE0CnN0b3JlIDIzCmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDIzCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgZGVmYXVsdHZhbHVlZnJvbWxvY2Fsc3RhdGVfMTIKc3RvcmUgMjIKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMjIKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpjYWxsc3ViIGRlZmF1bHR2YWx1ZWZyb21nbG9iYWxzdGF0ZV8xMQpzdG9yZSAyMQpieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAyMQppdG9iCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgZGVmYXVsdHZhbHVlZnJvbWFiaV8xMApzdG9yZSAyMApieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAyMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpidG9pCmNhbGxzdWIgZGVmYXVsdHZhbHVlaW50XzkKc3RvcmUgMTkKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMTkKaXRvYgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGRlZmF1bHR2YWx1ZV84CnN0b3JlIDE4CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDE4CmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI3Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGVycm9yXzcKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI4Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCnN0b3JlIDE2CnR4bmEgQXBwbGljYXRpb25BcmdzIDIKc3RvcmUgMTcKbG9hZCAxNgpsb2FkIDE3CmNhbGxzdWIgc2V0Ym94XzYKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI5Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmJ0b2kKc3RvcmUgMTIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpidG9pCnN0b3JlIDEzCnR4bmEgQXBwbGljYXRpb25BcmdzIDMKc3RvcmUgMTQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApzdG9yZSAxNQpsb2FkIDEyCmxvYWQgMTMKbG9hZCAxNApsb2FkIDE1CmNhbGxzdWIgc2V0bG9jYWxfNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzA6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpzdG9yZSA4CnR4bmEgQXBwbGljYXRpb25BcmdzIDIKYnRvaQpzdG9yZSA5CnR4bmEgQXBwbGljYXRpb25BcmdzIDMKc3RvcmUgMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApzdG9yZSAxMQpsb2FkIDgKbG9hZCA5CmxvYWQgMTAKbG9hZCAxMQpjYWxsc3ViIHNldGdsb2JhbF80CmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDYKbG9hZCA0CmxvYWQgNQpsb2FkIDYKY2FsbHN1YiBjYWxsd2l0aHJlZmVyZW5jZXNfMwpzdG9yZSA3CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDcKaXRvYgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpzdG9yZSAyCnR4biBHcm91cEluZGV4CmludGNfMSAvLyAxCi0Kc3RvcmUgMQpsb2FkIDEKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQphc3NlcnQKbG9hZCAxCmxvYWQgMgpjYWxsc3ViIGNhbGxhYml0eG5fMgpzdG9yZSAzCmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDMKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBjYWxsYWJpXzAKc3RvcmUgMApieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAwCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDM0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CmJueiBtYWluX2w0Mgp0eG4gT25Db21wbGV0aW9uCmludGNfMSAvLyBPcHRJbgo9PQpibnogbWFpbl9sNDEKdHhuIE9uQ29tcGxldGlvbgpwdXNoaW50IDQgLy8gVXBkYXRlQXBwbGljYXRpb24KPT0KYm56IG1haW5fbDQwCnR4biBPbkNvbXBsZXRpb24KaW50Y18zIC8vIERlbGV0ZUFwcGxpY2F0aW9uCj09CmJueiBtYWluX2wzOQplcnIKbWFpbl9sMzk6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIGRlbGV0ZV8xNwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDA6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIHVwZGF0ZV8xNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDE6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydApjYWxsc3ViIGNyZWF0ZV8xMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDI6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydApjYWxsc3ViIGNyZWF0ZV8xMwppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIGNhbGxfYWJpCmNhbGxhYmlfMDoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKcHVzaGJ5dGVzIDB4NDg2NTZjNmM2ZjJjMjAgLy8gIkhlbGxvLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpdG9hCml0b2FfMToKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV8xX2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzFfbDQKYnl0ZWNfMSAvLyAiIgppdG9hXzFfbDM6CnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCiUKaW50Y18xIC8vIDEKZXh0cmFjdDMKY29uY2F0CmIgaXRvYV8xX2w2Cml0b2FfMV9sNDoKZnJhbWVfZGlnIC0xCmludGNfMiAvLyAxMAovCmNhbGxzdWIgaXRvYV8xCmIgaXRvYV8xX2wzCml0b2FfMV9sNToKcHVzaGJ5dGVzIDB4MzAgLy8gIjAiCml0b2FfMV9sNjoKcmV0c3ViCgovLyBjYWxsX2FiaV90eG4KY2FsbGFiaXR4bl8yOgpwcm90byAyIDEKYnl0ZWNfMSAvLyAiIgpwdXNoYnl0ZXMgMHg1MzY1NmU3NDIwIC8vICJTZW50ICIKZnJhbWVfZGlnIC0yCmd0eG5zIEFtb3VudApjYWxsc3ViIGl0b2FfMQpjb25jYXQKcHVzaGJ5dGVzIDB4MmUyMCAvLyAiLiAiCmNvbmNhdApmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKY29uY2F0CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gY2FsbF93aXRoX3JlZmVyZW5jZXMKY2FsbHdpdGhyZWZlcmVuY2VzXzM6CnByb3RvIDMgMQppbnRjXzAgLy8gMApmcmFtZV9kaWcgLTMKdHhuYXMgQXNzZXRzCi8vIGFzc2V0IG5vdCBwcm92aWRlZAphc3NlcnQKZnJhbWVfZGlnIC0yCnR4bmFzIEFjY291bnRzCmxlbgovLyBhY2NvdW50IG5vdCBwcm92aWRlZAphc3NlcnQKZnJhbWVfZGlnIC0xCnR4bmFzIEFwcGxpY2F0aW9ucwovLyBhcHBsaWNhdGlvbiBub3QgcHJvdmlkZWQKYXNzZXJ0CmludGNfMSAvLyAxCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIHNldF9nbG9iYWwKc2V0Z2xvYmFsXzQ6CnByb3RvIDQgMApwdXNoYnl0ZXMgMHg2OTZlNzQzMSAvLyAiaW50MSIKZnJhbWVfZGlnIC00CmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDY5NmU3NDMyIC8vICJpbnQyIgpmcmFtZV9kaWcgLTMKYXBwX2dsb2JhbF9wdXQKcHVzaGJ5dGVzIDB4NjI3OTc0NjU3MzMxIC8vICJieXRlczEiCmZyYW1lX2RpZyAtMgpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApwdXNoYnl0ZXMgMHg2Mjc5NzQ2NTczMzIgLy8gImJ5dGVzMiIKZnJhbWVfZGlnIC0xCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gc2V0X2xvY2FsCnNldGxvY2FsXzU6CnByb3RvIDQgMAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjY5NmU3NDMxIC8vICJsb2NhbF9pbnQxIgpmcmFtZV9kaWcgLTQKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjY5NmU3NDMyIC8vICJsb2NhbF9pbnQyIgpmcmFtZV9kaWcgLTMKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjYyNzk3NDY1NzMzMSAvLyAibG9jYWxfYnl0ZXMxIgpmcmFtZV9kaWcgLTIKZXh0cmFjdCAyIDAKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjYyNzk3NDY1NzMzMiAvLyAibG9jYWxfYnl0ZXMyIgpmcmFtZV9kaWcgLTEKYXBwX2xvY2FsX3B1dApyZXRzdWIKCi8vIHNldF9ib3gKc2V0Ym94XzY6CnByb3RvIDIgMApmcmFtZV9kaWcgLTIKYm94X2RlbApwb3AKZnJhbWVfZGlnIC0yCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApib3hfcHV0CnJldHN1YgoKLy8gZXJyb3IKZXJyb3JfNzoKcHJvdG8gMCAwCmludGNfMCAvLyAwCi8vIERlbGliZXJhdGUgZXJyb3IKYXNzZXJ0CnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZQpkZWZhdWx0dmFsdWVfODoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZV9pbnQKZGVmYXVsdHZhbHVlaW50Xzk6CnByb3RvIDEgMQppbnRjXzAgLy8gMApmcmFtZV9kaWcgLTEKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZV9mcm9tX2FiaQpkZWZhdWx0dmFsdWVmcm9tYWJpXzEwOgpwcm90byAxIDEKYnl0ZWNfMSAvLyAiIgpwdXNoYnl0ZXMgMHg0MTQyNDkyYzIwIC8vICJBQkksICIKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNvbmNhdApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGRlZmF1bHRfdmFsdWVfZnJvbV9nbG9iYWxfc3RhdGUKZGVmYXVsdHZhbHVlZnJvbWdsb2JhbHN0YXRlXzExOgpwcm90byAxIDEKaW50Y18wIC8vIDAKZnJhbWVfZGlnIC0xCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGRlZmF1bHRfdmFsdWVfZnJvbV9sb2NhbF9zdGF0ZQpkZWZhdWx0dmFsdWVmcm9tbG9jYWxzdGF0ZV8xMjoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKcHVzaGJ5dGVzIDB4NGM2ZjYzNjE2YzIwNzM3NDYxNzQ2NTJjMjAgLy8gIkxvY2FsIHN0YXRlLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBjcmVhdGUKY3JlYXRlXzEzOgpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApwdXNoYnl0ZXMgMHg3NjYxNmM3NTY1IC8vICJ2YWx1ZSIKcHVzaGludCBUTVBMX1ZBTFVFIC8vIFRNUExfVkFMVUUKYXBwX2dsb2JhbF9wdXQKcmV0c3ViCgovLyBjcmVhdGVfYWJpCmNyZWF0ZWFiaV8xNDoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyB1cGRhdGUKdXBkYXRlXzE1Ogpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydAppbnRjIDQgLy8gVE1QTF9VUERBVEFCTEUKLy8gQ2hlY2sgYXBwIGlzIHVwZGF0YWJsZQphc3NlcnQKcmV0c3ViCgovLyB1cGRhdGVfYWJpCnVwZGF0ZWFiaV8xNjoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydAppbnRjIDQgLy8gVE1QTF9VUERBVEFCTEUKLy8gQ2hlY2sgYXBwIGlzIHVwZGF0YWJsZQphc3NlcnQKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVsZXRlCmRlbGV0ZV8xNzoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKaW50YyA1IC8vIFRNUExfREVMRVRBQkxFCi8vIENoZWNrIGFwcCBpcyBkZWxldGFibGUKYXNzZXJ0CnJldHN1YgoKLy8gZGVsZXRlX2FiaQpkZWxldGVhYmlfMTg6CnByb3RvIDEgMQpieXRlY18xIC8vICIiCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKaW50YyA1IC8vIFRNUExfREVMRVRBQkxFCi8vIENoZWNrIGFwcCBpcyBkZWxldGFibGUKYXNzZXJ0CmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIG9wdF9pbgpvcHRpbl8xOToKcHJvdG8gMCAwCmludGNfMSAvLyAxCnJldHVybg==\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"", "    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMCA1IFRNUExfVVBEQVRBQkxFIFRNUExfREVMRVRBQkxFCmJ5dGVjYmxvY2sgMHgxNTFmN2M3NSAweAp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sMzQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhmMTdlODBhNSAvLyAiY2FsbF9hYmkoc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDMzCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4MGE5MmE4MWUgLy8gImNhbGxfYWJpX3R4bihwYXksc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDMyCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4ZmVmZGYxMWUgLy8gImNhbGxfd2l0aF9yZWZlcmVuY2VzKGFzc2V0LGFjY291bnQsYXBwbGljYXRpb24pdWludDY0Igo9PQpibnogbWFpbl9sMzEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGNmOGRlYSAvLyAic2V0X2dsb2JhbCh1aW50NjQsdWludDY0LHN0cmluZyxieXRlWzRdKXZvaWQiCj09CmJueiBtYWluX2wzMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGNlYzI4MzRhIC8vICJzZXRfbG9jYWwodWludDY0LHVpbnQ2NCxzdHJpbmcsYnl0ZVs0XSl2b2lkIgo9PQpibnogbWFpbl9sMjkKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGI0YTIzMCAvLyAic2V0X2JveChieXRlWzRdLHN0cmluZyl2b2lkIgo9PQpibnogbWFpbl9sMjgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg0NGQwZGEwZCAvLyAiZXJyb3IoKXZvaWQiCj09CmJueiBtYWluX2wyNwp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDU3NGI1NWM4IC8vICJkZWZhdWx0X3ZhbHVlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDM2MDM2MmU5IC8vICJkZWZhdWx0X3ZhbHVlX2ludCh1aW50NjQpdWludDY0Igo9PQpibnogbWFpbl9sMjUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg0NmQyMTFhMyAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2FiaShzdHJpbmcpc3RyaW5nIgo9PQpibnogbWFpbl9sMjQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgwY2ZjYmIwMCAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2dsb2JhbF9zdGF0ZSh1aW50NjQpdWludDY0Igo9PQpibnogbWFpbl9sMjMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhkMGYwYmFmOCAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2xvY2FsX3N0YXRlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDlkNTIzMDQwIC8vICJjcmVhdGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDNjYTVjZWI3IC8vICJ1cGRhdGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDI3MWI0ZWU5IC8vICJkZWxldGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wxOQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDMwYzZkNThhIC8vICJvcHRfaW4oKXZvaWQiCj09CmJueiBtYWluX2wxOAplcnIKbWFpbl9sMTg6CnR4biBPbkNvbXBsZXRpb24KaW50Y18xIC8vIE9wdEluCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIG9wdGluXzE5CmludGNfMSAvLyAxCnJldHVybgptYWluX2wxOToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBkZWxldGVhYmlfMTgKc3RvcmUgMjUKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMjUKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjA6CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCA0IC8vIFVwZGF0ZUFwcGxpY2F0aW9uCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgdXBkYXRlYWJpXzE2CnN0b3JlIDI0CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDI0CmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIxOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgY3JlYXRlYWJpXzE0CnN0b3JlIDIzCmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDIzCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgZGVmYXVsdHZhbHVlZnJvbWxvY2Fsc3RhdGVfMTIKc3RvcmUgMjIKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMjIKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpjYWxsc3ViIGRlZmF1bHR2YWx1ZWZyb21nbG9iYWxzdGF0ZV8xMQpzdG9yZSAyMQpieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAyMQppdG9iCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgZGVmYXVsdHZhbHVlZnJvbWFiaV8xMApzdG9yZSAyMApieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAyMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpidG9pCmNhbGxzdWIgZGVmYXVsdHZhbHVlaW50XzkKc3RvcmUgMTkKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMTkKaXRvYgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGRlZmF1bHR2YWx1ZV84CnN0b3JlIDE4CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDE4CmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI3Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGVycm9yXzcKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI4Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCnN0b3JlIDE2CnR4bmEgQXBwbGljYXRpb25BcmdzIDIKc3RvcmUgMTcKbG9hZCAxNgpsb2FkIDE3CmNhbGxzdWIgc2V0Ym94XzYKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI5Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmJ0b2kKc3RvcmUgMTIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpidG9pCnN0b3JlIDEzCnR4bmEgQXBwbGljYXRpb25BcmdzIDMKc3RvcmUgMTQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApzdG9yZSAxNQpsb2FkIDEyCmxvYWQgMTMKbG9hZCAxNApsb2FkIDE1CmNhbGxzdWIgc2V0bG9jYWxfNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzA6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpzdG9yZSA4CnR4bmEgQXBwbGljYXRpb25BcmdzIDIKYnRvaQpzdG9yZSA5CnR4bmEgQXBwbGljYXRpb25BcmdzIDMKc3RvcmUgMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApzdG9yZSAxMQpsb2FkIDgKbG9hZCA5CmxvYWQgMTAKbG9hZCAxMQpjYWxsc3ViIHNldGdsb2JhbF80CmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDYKbG9hZCA0CmxvYWQgNQpsb2FkIDYKY2FsbHN1YiBjYWxsd2l0aHJlZmVyZW5jZXNfMwpzdG9yZSA3CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDcKaXRvYgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpzdG9yZSAyCnR4biBHcm91cEluZGV4CmludGNfMSAvLyAxCi0Kc3RvcmUgMQpsb2FkIDEKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQphc3NlcnQKbG9hZCAxCmxvYWQgMgpjYWxsc3ViIGNhbGxhYml0eG5fMgpzdG9yZSAzCmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDMKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBjYWxsYWJpXzAKc3RvcmUgMApieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAwCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDM0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CmJueiBtYWluX2w0Mgp0eG4gT25Db21wbGV0aW9uCmludGNfMSAvLyBPcHRJbgo9PQpibnogbWFpbl9sNDEKdHhuIE9uQ29tcGxldGlvbgpwdXNoaW50IDQgLy8gVXBkYXRlQXBwbGljYXRpb24KPT0KYm56IG1haW5fbDQwCnR4biBPbkNvbXBsZXRpb24KaW50Y18zIC8vIERlbGV0ZUFwcGxpY2F0aW9uCj09CmJueiBtYWluX2wzOQplcnIKbWFpbl9sMzk6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIGRlbGV0ZV8xNwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDA6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIHVwZGF0ZV8xNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDE6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydApjYWxsc3ViIGNyZWF0ZV8xMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDI6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydApjYWxsc3ViIGNyZWF0ZV8xMwppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIGNhbGxfYWJpCmNhbGxhYmlfMDoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKcHVzaGJ5dGVzIDB4NDg2NTZjNmM2ZjJjMjAgLy8gIkhlbGxvLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpdG9hCml0b2FfMToKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV8xX2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzFfbDQKYnl0ZWNfMSAvLyAiIgppdG9hXzFfbDM6CnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCiUKaW50Y18xIC8vIDEKZXh0cmFjdDMKY29uY2F0CmIgaXRvYV8xX2w2Cml0b2FfMV9sNDoKZnJhbWVfZGlnIC0xCmludGNfMiAvLyAxMAovCmNhbGxzdWIgaXRvYV8xCmIgaXRvYV8xX2wzCml0b2FfMV9sNToKcHVzaGJ5dGVzIDB4MzAgLy8gIjAiCml0b2FfMV9sNjoKcmV0c3ViCgovLyBjYWxsX2FiaV90eG4KY2FsbGFiaXR4bl8yOgpwcm90byAyIDEKYnl0ZWNfMSAvLyAiIgpwdXNoYnl0ZXMgMHg1MzY1NmU3NDIwIC8vICJTZW50ICIKZnJhbWVfZGlnIC0yCmd0eG5zIEFtb3VudApjYWxsc3ViIGl0b2FfMQpjb25jYXQKcHVzaGJ5dGVzIDB4MmUyMCAvLyAiLiAiCmNvbmNhdApmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKY29uY2F0CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gY2FsbF93aXRoX3JlZmVyZW5jZXMKY2FsbHdpdGhyZWZlcmVuY2VzXzM6CnByb3RvIDMgMQppbnRjXzAgLy8gMApmcmFtZV9kaWcgLTMKdHhuYXMgQXNzZXRzCi8vIGFzc2V0IG5vdCBwcm92aWRlZAphc3NlcnQKZnJhbWVfZGlnIC0yCnR4bmFzIEFjY291bnRzCmxlbgovLyBhY2NvdW50IG5vdCBwcm92aWRlZAphc3NlcnQKZnJhbWVfZGlnIC0xCnR4bmFzIEFwcGxpY2F0aW9ucwovLyBhcHBsaWNhdGlvbiBub3QgcHJvdmlkZWQKYXNzZXJ0CmludGNfMSAvLyAxCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIHNldF9nbG9iYWwKc2V0Z2xvYmFsXzQ6CnByb3RvIDQgMApwdXNoYnl0ZXMgMHg2OTZlNzQzMSAvLyAiaW50MSIKZnJhbWVfZGlnIC00CmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDY5NmU3NDMyIC8vICJpbnQyIgpmcmFtZV9kaWcgLTMKYXBwX2dsb2JhbF9wdXQKcHVzaGJ5dGVzIDB4NjI3OTc0NjU3MzMxIC8vICJieXRlczEiCmZyYW1lX2RpZyAtMgpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApwdXNoYnl0ZXMgMHg2Mjc5NzQ2NTczMzIgLy8gImJ5dGVzMiIKZnJhbWVfZGlnIC0xCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gc2V0X2xvY2FsCnNldGxvY2FsXzU6CnByb3RvIDQgMAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjY5NmU3NDMxIC8vICJsb2NhbF9pbnQxIgpmcmFtZV9kaWcgLTQKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjY5NmU3NDMyIC8vICJsb2NhbF9pbnQyIgpmcmFtZV9kaWcgLTMKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjYyNzk3NDY1NzMzMSAvLyAibG9jYWxfYnl0ZXMxIgpmcmFtZV9kaWcgLTIKZXh0cmFjdCAyIDAKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjYyNzk3NDY1NzMzMiAvLyAibG9jYWxfYnl0ZXMyIgpmcmFtZV9kaWcgLTEKYXBwX2xvY2FsX3B1dApyZXRzdWIKCi8vIHNldF9ib3gKc2V0Ym94XzY6CnByb3RvIDIgMApmcmFtZV9kaWcgLTIKYm94X2RlbApwb3AKZnJhbWVfZGlnIC0yCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApib3hfcHV0CnJldHN1YgoKLy8gZXJyb3IKZXJyb3JfNzoKcHJvdG8gMCAwCmludGNfMCAvLyAwCi8vIERlbGliZXJhdGUgZXJyb3IKYXNzZXJ0CnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZQpkZWZhdWx0dmFsdWVfODoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZV9pbnQKZGVmYXVsdHZhbHVlaW50Xzk6CnByb3RvIDEgMQppbnRjXzAgLy8gMApmcmFtZV9kaWcgLTEKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZV9mcm9tX2FiaQpkZWZhdWx0dmFsdWVmcm9tYWJpXzEwOgpwcm90byAxIDEKYnl0ZWNfMSAvLyAiIgpwdXNoYnl0ZXMgMHg0MTQyNDkyYzIwIC8vICJBQkksICIKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNvbmNhdApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGRlZmF1bHRfdmFsdWVfZnJvbV9nbG9iYWxfc3RhdGUKZGVmYXVsdHZhbHVlZnJvbWdsb2JhbHN0YXRlXzExOgpwcm90byAxIDEKaW50Y18wIC8vIDAKZnJhbWVfZGlnIC0xCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGRlZmF1bHRfdmFsdWVfZnJvbV9sb2NhbF9zdGF0ZQpkZWZhdWx0dmFsdWVmcm9tbG9jYWxzdGF0ZV8xMjoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKcHVzaGJ5dGVzIDB4NGM2ZjYzNjE2YzIwNzM3NDYxNzQ2NTJjMjAgLy8gIkxvY2FsIHN0YXRlLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBjcmVhdGUKY3JlYXRlXzEzOgpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApwdXNoYnl0ZXMgMHg3NjYxNmM3NTY1IC8vICJ2YWx1ZSIKcHVzaGludCBUTVBMX1ZBTFVFIC8vIFRNUExfVkFMVUUKYXBwX2dsb2JhbF9wdXQKcmV0c3ViCgovLyBjcmVhdGVfYWJpCmNyZWF0ZWFiaV8xNDoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyB1cGRhdGUKdXBkYXRlXzE1Ogpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydAppbnRjIDQgLy8gVE1QTF9VUERBVEFCTEUKLy8gQ2hlY2sgYXBwIGlzIHVwZGF0YWJsZQphc3NlcnQKcmV0c3ViCgovLyB1cGRhdGVfYWJpCnVwZGF0ZWFiaV8xNjoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydAppbnRjIDQgLy8gVE1QTF9VUERBVEFCTEUKLy8gQ2hlY2sgYXBwIGlzIHVwZGF0YWJsZQphc3NlcnQKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVsZXRlCmRlbGV0ZV8xNzoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKaW50YyA1IC8vIFRNUExfREVMRVRBQkxFCi8vIENoZWNrIGFwcCBpcyBkZWxldGFibGUKYXNzZXJ0CnJldHN1YgoKLy8gZGVsZXRlX2FiaQpkZWxldGVhYmlfMTg6CnByb3RvIDEgMQpieXRlY18xIC8vICIiCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKaW50YyA1IC8vIFRNUExfREVMRVRBQkxFCi8vIENoZWNrIGFwcCBpcyBkZWxldGFibGUKYXNzZXJ0CmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIG9wdF9pbgpvcHRpbl8xOToKcHJvdG8gMCAwCmludGNfMSAvLyAxCnJldHVybg==\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 3,\n      \"num_uints\": 3\n    },\n    \"local\": {\n      \"num_byte_slices\": 3,", "    \"local\": {\n      \"num_byte_slices\": 3,\n      \"num_uints\": 2\n    }\n  },\n  \"schema\": {\n    \"global\": {\n      \"declared\": {\n        \"bytes1\": {\n          \"type\": \"bytes\",", "        \"bytes1\": {\n          \"type\": \"bytes\",\n          \"key\": \"bytes1\",\n          \"descr\": \"\"\n        },\n        \"bytes2\": {\n          \"type\": \"bytes\",\n          \"key\": \"bytes2\",\n          \"descr\": \"\"\n        },", "          \"descr\": \"\"\n        },\n        \"int1\": {\n          \"type\": \"uint64\",\n          \"key\": \"int1\",\n          \"descr\": \"\"\n        },\n        \"int2\": {\n          \"type\": \"uint64\",\n          \"key\": \"int2\",", "          \"type\": \"uint64\",\n          \"key\": \"int2\",\n          \"descr\": \"\"\n        },\n        \"value\": {\n          \"type\": \"uint64\",\n          \"key\": \"value\",\n          \"descr\": \"\"\n        }\n      },", "        }\n      },\n      \"reserved\": {\n        \"reserved_global_bytes\": {\n          \"type\": \"bytes\",\n          \"max_keys\": 1,\n          \"descr\": \"Reserved global state description\"\n        }\n      }\n    },", "      }\n    },\n    \"local\": {\n      \"declared\": {\n        \"local_bytes1\": {\n          \"type\": \"bytes\",\n          \"key\": \"local_bytes1\",\n          \"descr\": \"\"\n        },\n        \"local_bytes2\": {", "        },\n        \"local_bytes2\": {\n          \"type\": \"bytes\",\n          \"key\": \"local_bytes2\",\n          \"descr\": \"\"\n        },\n        \"local_int1\": {\n          \"type\": \"uint64\",\n          \"key\": \"local_int1\",\n          \"descr\": \"\"", "          \"key\": \"local_int1\",\n          \"descr\": \"\"\n        },\n        \"local_int2\": {\n          \"type\": \"uint64\",\n          \"key\": \"local_int2\",\n          \"descr\": \"\"\n        }\n      },\n      \"reserved\": {", "      },\n      \"reserved\": {\n        \"reserved_local_bytes\": {\n          \"type\": \"bytes\",\n          \"max_keys\": 1,\n          \"descr\": \"Reserved local state description\"\n        }\n      }\n    }\n  },", "    }\n  },\n  \"contract\": {\n    \"name\": \"StateApp\",\n    \"methods\": [\n      {\n        \"name\": \"call_abi\",\n        \"args\": [\n          {\n            \"type\": \"string\",", "          {\n            \"type\": \"string\",\n            \"name\": \"value\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {", "      },\n      {\n        \"name\": \"call_abi_txn\",\n        \"args\": [\n          {\n            \"type\": \"pay\",\n            \"name\": \"txn\"\n          },\n          {\n            \"type\": \"string\",", "          {\n            \"type\": \"string\",\n            \"name\": \"value\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {", "      },\n      {\n        \"name\": \"call_with_references\",\n        \"args\": [\n          {\n            \"type\": \"asset\",\n            \"name\": \"asset\"\n          },\n          {\n            \"type\": \"account\",", "          {\n            \"type\": \"account\",\n            \"name\": \"account\"\n          },\n          {\n            \"type\": \"application\",\n            \"name\": \"application\"\n          }\n        ],\n        \"returns\": {", "        ],\n        \"returns\": {\n          \"type\": \"uint64\"\n        }\n      },\n      {\n        \"name\": \"set_global\",\n        \"args\": [\n          {\n            \"type\": \"uint64\",", "          {\n            \"type\": \"uint64\",\n            \"name\": \"int1\"\n          },\n          {\n            \"type\": \"uint64\",\n            \"name\": \"int2\"\n          },\n          {\n            \"type\": \"string\",", "          {\n            \"type\": \"string\",\n            \"name\": \"bytes1\"\n          },\n          {\n            \"type\": \"byte[4]\",\n            \"name\": \"bytes2\"\n          }\n        ],\n        \"returns\": {", "        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"set_local\",\n        \"args\": [\n          {\n            \"type\": \"uint64\",", "          {\n            \"type\": \"uint64\",\n            \"name\": \"int1\"\n          },\n          {\n            \"type\": \"uint64\",\n            \"name\": \"int2\"\n          },\n          {\n            \"type\": \"string\",", "          {\n            \"type\": \"string\",\n            \"name\": \"bytes1\"\n          },\n          {\n            \"type\": \"byte[4]\",\n            \"name\": \"bytes2\"\n          }\n        ],\n        \"returns\": {", "        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"set_box\",\n        \"args\": [\n          {\n            \"type\": \"byte[4]\",", "          {\n            \"type\": \"byte[4]\",\n            \"name\": \"name\"\n          },\n          {\n            \"type\": \"string\",\n            \"name\": \"value\"\n          }\n        ],\n        \"returns\": {", "        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"error\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"", "        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"default_value\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"arg_with_default\"", "            \"type\": \"string\",\n            \"name\": \"arg_with_default\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"default_value_int\",", "      {\n        \"name\": \"default_value_int\",\n        \"args\": [\n          {\n            \"type\": \"uint64\",\n            \"name\": \"arg_with_default\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"uint64\"", "        \"returns\": {\n          \"type\": \"uint64\"\n        }\n      },\n      {\n        \"name\": \"default_value_from_abi\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"arg_with_default\"", "            \"type\": \"string\",\n            \"name\": \"arg_with_default\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"default_value_from_global_state\",", "      {\n        \"name\": \"default_value_from_global_state\",\n        \"args\": [\n          {\n            \"type\": \"uint64\",\n            \"name\": \"arg_with_default\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"uint64\"", "        \"returns\": {\n          \"type\": \"uint64\"\n        }\n      },\n      {\n        \"name\": \"default_value_from_local_state\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"arg_with_default\"", "            \"type\": \"string\",\n            \"name\": \"arg_with_default\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"create_abi\",", "      {\n        \"name\": \"create_abi\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"input\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"", "        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"update_abi\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"input\"", "            \"type\": \"string\",\n            \"name\": \"input\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"delete_abi\",", "      {\n        \"name\": \"delete_abi\",\n        \"args\": [\n          {\n            \"type\": \"string\",\n            \"name\": \"input\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"string\"", "        \"returns\": {\n          \"type\": \"string\"\n        }\n      },\n      {\n        \"name\": \"opt_in\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }", "          \"type\": \"void\"\n        }\n      }\n    ],\n    \"networks\": {}\n  },\n  \"bare_call_config\": {\n    \"delete_application\": \"CALL\",\n    \"no_op\": \"CREATE\",\n    \"opt_in\": \"CREATE\",", "    \"no_op\": \"CREATE\",\n    \"opt_in\": \"CREATE\",\n    \"update_application\": \"CALL\"\n  }\n}\n\n/**\n * Defines an onCompletionAction of 'no_op'\n */\nexport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */", " */\nexport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n/**\n * Defines an onCompletionAction of 'opt_in'\n */\nexport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n/**\n * Defines an onCompletionAction of 'close_out'\n */\nexport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */", "export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n/**\n * Defines an onCompletionAction of 'delete_application'\n */\nexport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n/**\n * Defines an onCompletionAction of 'update_application'\n */\nexport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */", "export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n/**\n * A state record containing a single unsigned integer\n */\nexport type IntegerState = {\n  /**\n   * Gets the state value as a BigInt \n   */\n  asBigInt(): bigint\n  /**\n   * Gets the state value as a number.\n   */\n  asNumber(): number\n}\n/**\n * A state record containing binary data\n */", "export type BinaryState = {\n  /**\n   * Gets the state value as a Uint8Array\n   */\n  asByteArray(): Uint8Array\n  /**\n   * Gets the state value as a string\n   */\n  asString(): string\n}\n\n/**\n * Defines the types of available calls and state of the StateApp smart contract.\n */", "export type StateApp = {\n  /**\n   * Maps method signatures / names to their argument and return types.\n   */\n  methods:\n    & Record<'call_abi(string)string' | 'call_abi', {\n      argsObj: {\n        value: string\n      }\n      argsTuple: [value: string]\n      returns: string\n    }>\n    & Record<'call_abi_txn(pay,string)string' | 'call_abi_txn', {\n      argsObj: {\n        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>\n        value: string\n      }\n      argsTuple: [txn: TransactionToSign | Transaction | Promise<SendTransactionResult>, value: string]\n      returns: string\n    }>\n    & Record<'call_with_references(asset,account,application)uint64' | 'call_with_references', {\n      argsObj: {\n        asset: number | bigint\n        account: string | Uint8Array\n        application: number | bigint\n      }\n      argsTuple: [asset: number | bigint, account: string | Uint8Array, application: number | bigint]\n      returns: bigint\n    }>\n    & Record<'set_global(uint64,uint64,string,byte[4])void' | 'set_global', {\n      argsObj: {\n        int1: bigint | number\n        int2: bigint | number\n        bytes1: string\n        bytes2: Uint8Array\n      }\n      argsTuple: [int1: bigint | number, int2: bigint | number, bytes1: string, bytes2: Uint8Array]\n      returns: void\n    }>\n    & Record<'set_local(uint64,uint64,string,byte[4])void' | 'set_local', {\n      argsObj: {\n        int1: bigint | number\n        int2: bigint | number\n        bytes1: string\n        bytes2: Uint8Array\n      }\n      argsTuple: [int1: bigint | number, int2: bigint | number, bytes1: string, bytes2: Uint8Array]\n      returns: void\n    }>\n    & Record<'set_box(byte[4],string)void' | 'set_box', {\n      argsObj: {\n        name: Uint8Array\n        value: string\n      }\n      argsTuple: [name: Uint8Array, value: string]\n      returns: void\n    }>\n    & Record<'error()void' | 'error', {\n      argsObj: {\n      }\n      argsTuple: []\n      returns: void\n    }>\n    & Record<'default_value(string)string' | 'default_value', {\n      argsObj: {\n        arg_with_default?: string\n      }\n      argsTuple: [arg_with_default: string | undefined]\n      returns: string\n    }>\n    & Record<'default_value_int(uint64)uint64' | 'default_value_int', {\n      argsObj: {\n        arg_with_default?: bigint | number\n      }\n      argsTuple: [arg_with_default: bigint | number | undefined]\n      returns: bigint\n    }>\n    & Record<'default_value_from_abi(string)string' | 'default_value_from_abi', {\n      argsObj: {\n        arg_with_default?: string\n      }\n      argsTuple: [arg_with_default: string | undefined]\n      returns: string\n    }>\n    & Record<'default_value_from_global_state(uint64)uint64' | 'default_value_from_global_state', {\n      argsObj: {\n        arg_with_default?: bigint | number\n      }\n      argsTuple: [arg_with_default: bigint | number | undefined]\n      returns: bigint\n    }>\n    & Record<'default_value_from_local_state(string)string' | 'default_value_from_local_state', {\n      argsObj: {\n        arg_with_default?: string\n      }\n      argsTuple: [arg_with_default: string | undefined]\n      returns: string\n    }>\n    & Record<'create_abi(string)string' | 'create_abi', {\n      argsObj: {\n        input: string\n      }\n      argsTuple: [input: string]\n      returns: string\n    }>\n    & Record<'update_abi(string)string' | 'update_abi', {\n      argsObj: {\n        input: string\n      }\n      argsTuple: [input: string]\n      returns: string\n    }>\n    & Record<'delete_abi(string)string' | 'delete_abi', {\n      argsObj: {\n        input: string\n      }\n      argsTuple: [input: string]\n      returns: string\n    }>\n    & Record<'opt_in()void' | 'opt_in', {\n      argsObj: {\n      }\n      argsTuple: []\n      returns: void\n    }>\n  /**\n   * Defines the shape of the global and local state of the application.\n   */\n  state: {\n    global: {\n      'bytes1'?: BinaryState\n      'bytes2'?: BinaryState\n      'int1'?: IntegerState\n      'int2'?: IntegerState\n      'value'?: IntegerState\n    }\n    local: {\n      'local_bytes1'?: BinaryState\n      'local_bytes2'?: BinaryState\n      'local_int1'?: IntegerState\n      'local_int2'?: IntegerState\n    }\n  }\n}\n/**\n * Defines the possible abi call signatures\n */", "export type StateAppSig = keyof StateApp['methods']\n/**\n * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n */\nexport type TypedCallParams<TSignature extends StateAppSig | undefined> = {\n  method: TSignature\n  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n} & AppClientCallCoreParams & CoreAppCallArgs\n/**\n * Defines the arguments required for a bare call\n */", "export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n/**\n * Maps a method signature from the StateApp smart contract to the method's arguments in either tuple of struct form\n */\nexport type MethodArgs<TSignature extends StateAppSig> = StateApp['methods'][TSignature]['argsObj' | 'argsTuple']\n/**\n * Maps a method signature from the StateApp smart contract to the method's return type\n */\nexport type MethodReturn<TSignature extends StateAppSig> = StateApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */", "export type MethodReturn<TSignature extends StateAppSig> = StateApp['methods'][TSignature]['returns']\n\n/**\n * A factory for available 'create' calls\n */\nexport type StateAppCreateCalls = (typeof StateAppCallFactory)['create']\n/**\n * Defines supported create methods for this smart contract\n */\nexport type StateAppCreateCallParams =\n  | (TypedCallParams<undefined> & (OnCompleteNoOp | OnCompleteOptIn))\n  | (TypedCallParams<'create_abi(string)string'> & (OnCompleteNoOp))\n/**\n * A factory for available 'update' calls\n */", "export type StateAppCreateCallParams =\n  | (TypedCallParams<undefined> & (OnCompleteNoOp | OnCompleteOptIn))\n  | (TypedCallParams<'create_abi(string)string'> & (OnCompleteNoOp))\n/**\n * A factory for available 'update' calls\n */\nexport type StateAppUpdateCalls = (typeof StateAppCallFactory)['update']\n/**\n * Defines supported update methods for this smart contract\n */\nexport type StateAppUpdateCallParams =\n  | TypedCallParams<undefined>\n  | TypedCallParams<'update_abi(string)string'>\n/**\n * A factory for available 'delete' calls\n */", "export type StateAppUpdateCallParams =\n  | TypedCallParams<undefined>\n  | TypedCallParams<'update_abi(string)string'>\n/**\n * A factory for available 'delete' calls\n */\nexport type StateAppDeleteCalls = (typeof StateAppCallFactory)['delete']\n/**\n * Defines supported delete methods for this smart contract\n */\nexport type StateAppDeleteCallParams =\n  | TypedCallParams<undefined>\n  | TypedCallParams<'delete_abi(string)string'>\n/**\n * Defines arguments required for the deploy method.\n */", "export type StateAppDeleteCallParams =\n  | TypedCallParams<undefined>\n  | TypedCallParams<'delete_abi(string)string'>\n/**\n * Defines arguments required for the deploy method.\n */\nexport type StateAppDeployArgs = {\n  deployTimeParams?: TealTemplateParams\n  /**\n   * A delegate which takes a create call factory and returns the create call params for this smart contract\n   */\n  createCall?: (callFactory: StateAppCreateCalls) => StateAppCreateCallParams\n  /**\n   * A delegate which takes a update call factory and returns the update call params for this smart contract\n   */\n  updateCall?: (callFactory: StateAppUpdateCalls) => StateAppUpdateCallParams\n  /**\n   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n   */\n  deleteCall?: (callFactory: StateAppDeleteCalls) => StateAppDeleteCallParams\n}\n\n\n/**\n * Exposes methods for constructing all available smart contract calls\n */", "export abstract class StateAppCallFactory {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the StateApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp | OnCompleteOptIn) = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n      /**\n       * Constructs a create call for the StateApp smart contract using the create_abi(string)string ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createAbi(args: MethodArgs<'create_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n        return {\n          method: 'create_abi(string)string' as const,\n          methodArgs: Array.isArray(args) ? args : [args.input],\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the StateApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n      /**\n       * Constructs an update call for the StateApp smart contract using the update_abi(string)string ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      updateAbi(args: MethodArgs<'update_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n        return {\n          method: 'update_abi(string)string' as const,\n          methodArgs: Array.isArray(args) ? args : [args.input],\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available delete call factories\n   */\n  static get delete() {\n    return {\n      /**\n       * Constructs a delete call for the StateApp smart contract using a bare call\n       *\n       * @param params Any parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n        return {\n          method: undefined,\n          methodArgs: undefined,\n          ...params,\n        }\n      },\n      /**\n       * Constructs a delete call for the StateApp smart contract using the delete_abi(string)string ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n        return {\n          method: 'delete_abi(string)string' as const,\n          methodArgs: Array.isArray(args) ? args : [args.input],\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Gets available optIn call factories\n   */\n  static get optIn() {\n    return {\n      /**\n       * Constructs an opt in call for the StateApp smart contract using the opt_in()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      optIn(args: MethodArgs<'opt_in()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n        return {\n          method: 'opt_in()void' as const,\n          methodArgs: Array.isArray(args) ? args : [],\n          ...params,\n        }\n      },\n    }\n  }\n\n  /**\n   * Constructs a no op call for the call_abi(string)string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static callAbi(args: MethodArgs<'call_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'call_abi(string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.value],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the call_abi_txn(pay,string)string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'call_abi_txn(pay,string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.txn, args.value],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the call_with_references(asset,account,application)uint64 ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'call_with_references(asset,account,application)uint64' as const,\n      methodArgs: Array.isArray(args) ? args : [args.asset, args.account, args.application],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the set_global(uint64,uint64,string,byte[4])void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'set_global(uint64,uint64,string,byte[4])void' as const,\n      methodArgs: Array.isArray(args) ? args : [args.int1, args.int2, args.bytes1, args.bytes2],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the set_local(uint64,uint64,string,byte[4])void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'set_local(uint64,uint64,string,byte[4])void' as const,\n      methodArgs: Array.isArray(args) ? args : [args.int1, args.int2, args.bytes1, args.bytes2],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the set_box(byte[4],string)void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'set_box(byte[4],string)void' as const,\n      methodArgs: Array.isArray(args) ? args : [args.name, args.value],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the error()void ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static error(args: MethodArgs<'error()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'error()void' as const,\n      methodArgs: Array.isArray(args) ? args : [],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the default_value(string)string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static defaultValue(args: MethodArgs<'default_value(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'default_value(string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the default_value_int(uint64)uint64 ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'default_value_int(uint64)uint64' as const,\n      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the default_value_from_abi(string)string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'default_value_from_abi(string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the default_value_from_global_state(uint64)uint64 ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'default_value_from_global_state(uint64)uint64' as const,\n      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n      ...params,\n    }\n  }\n  /**\n   * Constructs a no op call for the default_value_from_local_state(string)string ABI method\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n    return {\n      method: 'default_value_from_local_state(string)string' as const,\n      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n      ...params,\n    }\n  }\n}\n\n/**\n * A client to make calls to the StateApp smart contract\n */", "export class StateAppClient {\n  /**\n   * The underlying `ApplicationClient` for when you want to have more flexibility\n   */\n  public readonly appClient: ApplicationClient\n\n  private readonly sender: SendTransactionFrom | undefined\n\n  /**\n   * Creates a new instance of `StateAppClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails: AppDetails, private algod: Algodv2) {\n    this.sender = appDetails.sender\n    this.appClient = algokit.getAppClient({\n      ...appDetails,\n      app: APP_SPEC\n    }, algod)\n  }\n\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {", "    if(result.return?.decodeError) {\n      throw result.return.decodeError\n    }\n    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n      ? returnValueFormatter(result.return.returnValue)\n      : result.return?.returnValue as TReturn | undefined\n      return { ...result, return: returnValue }\n  }\n\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  public async call<TSignature extends keyof StateApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n  }\n\n  /**\n   * Idempotently deploys the StateApp smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  public deploy(params: StateAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n    const createArgs = params.createCall?.(StateAppCallFactory.create)\n    const updateArgs = params.updateCall?.(StateAppCallFactory.update)\n    const deleteArgs = params.deleteCall?.(StateAppCallFactory.delete)\n    return this.appClient.deploy({\n      ...params,\n      updateArgs,\n      deleteArgs,\n      createArgs,\n      createOnCompleteAction: createArgs?.onCompleteAction,\n    })\n  }\n\n  /**\n   * Gets available create methods\n   */\n  public get create() {\n    const $this = this\n    return {\n      /**\n       * Creates a new instance of the StateApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The create result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs & (OnCompleteNoOp | OnCompleteOptIn) = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.create(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n      /**\n       * Creates a new instance of the StateApp smart contract using the create_abi(string)string ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      async createAbi(args: MethodArgs<'create_abi(string)string'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create_abi(string)string'>>> {\n        return $this.mapReturnValue(await $this.appClient.create(StateAppCallFactory.create.createAbi(args, params)))\n      },\n    }\n  }\n\n  /**\n   * Gets available update methods\n   */\n  public get update() {\n    const $this = this\n    return {\n      /**\n       * Updates an existing instance of the StateApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The update result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.update(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n      /**\n       * Updates an existing instance of the StateApp smart contract using the update_abi(string)string ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The update result\n       */\n      async updateAbi(args: MethodArgs<'update_abi(string)string'>, params: AppClientCallCoreParams & AppClientCompilationParams = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'update_abi(string)string'>>> {\n        return $this.mapReturnValue(await $this.appClient.update(StateAppCallFactory.update.updateAbi(args, params)))\n      },\n    }\n  }\n\n  /**\n   * Gets available delete methods\n   */\n  public get delete() {\n    const $this = this\n    return {\n      /**\n       * Deletes an existing instance of the StateApp smart contract using a bare call.\n       *\n       * @param args The arguments for the bare call\n       * @returns The delete result\n       */\n      bare(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n        return $this.appClient.delete(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n      },\n      /**\n       * Deletes an existing instance of the StateApp smart contract using the delete_abi(string)string ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The delete result\n       */\n      async deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params: AppClientCallCoreParams = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'delete_abi(string)string'>>> {\n        return $this.mapReturnValue(await $this.appClient.delete(StateAppCallFactory.delete.deleteAbi(args, params)))\n      },\n    }\n  }\n\n  /**\n   * Gets available optIn methods\n   */\n  public get optIn() {\n    const $this = this\n    return {\n      /**\n       * Opts the user into an existing instance of the StateApp smart contract using the opt_in()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The optIn result\n       */\n      async optIn(args: MethodArgs<'opt_in()void'>, params: AppClientCallCoreParams = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'opt_in()void'>>> {\n        return $this.mapReturnValue(await $this.appClient.optIn(StateAppCallFactory.optIn.optIn(args, params)))\n      },\n    }\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the StateApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.appClient.clearState(args)\n  }\n\n  /**\n   * Calls the call_abi(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public callAbi(args: MethodArgs<'call_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.callAbi(args, params))\n  }\n\n  /**\n   * Calls the call_abi_txn(pay,string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.callAbiTxn(args, params))\n  }\n\n  /**\n   * Calls the call_with_references(asset,account,application)uint64 ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.callWithReferences(args, params))\n  }\n\n  /**\n   * Calls the set_global(uint64,uint64,string,byte[4])void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.setGlobal(args, params))\n  }\n\n  /**\n   * Calls the set_local(uint64,uint64,string,byte[4])void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.setLocal(args, params))\n  }\n\n  /**\n   * Calls the set_box(byte[4],string)void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.setBox(args, params))\n  }\n\n  /**\n   * Calls the error()void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public error(args: MethodArgs<'error()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.error(args, params))\n  }\n\n  /**\n   * Calls the default_value(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public defaultValue(args: MethodArgs<'default_value(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.defaultValue(args, params))\n  }\n\n  /**\n   * Calls the default_value_int(uint64)uint64 ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.defaultValueInt(args, params))\n  }\n\n  /**\n   * Calls the default_value_from_abi(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.defaultValueFromAbi(args, params))\n  }\n\n  /**\n   * Calls the default_value_from_global_state(uint64)uint64 ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.defaultValueFromGlobalState(args, params))\n  }\n\n  /**\n   * Calls the default_value_from_local_state(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  public defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n    return this.call(StateAppCallFactory.defaultValueFromLocalState(args, params))\n  }\n\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {\n    const value = state[key]", "    if (!value) return undefined\n    if (!('valueRaw' in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)\n    return {\n      asString(): string {\n        return value.value\n      },\n      asByteArray(): Uint8Array {\n        return value.valueRaw\n      }\n    }\n  }\n\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {\n    const value = state[key]", "    if (!value) return undefined\n    if ('valueRaw' in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)\n    return {\n      asBigInt() {\n        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)\n      },\n      asNumber(): number {\n        return typeof value.value === 'bigint' ? Number(value.value) : value.value\n      },\n    }\n  }\n\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  public async getGlobalState(): Promise<StateApp['state']['global']> {\n    const state = await this.appClient.getGlobalState()\n    return {\n      get bytes1() {\n        return StateAppClient.getBinaryState(state, 'bytes1')\n      },\n      get bytes2() {\n        return StateAppClient.getBinaryState(state, 'bytes2')\n      },\n      get int1() {\n        return StateAppClient.getIntegerState(state, 'int1')\n      },\n      get int2() {\n        return StateAppClient.getIntegerState(state, 'int2')\n      },\n      get value() {\n        return StateAppClient.getIntegerState(state, 'value')\n      },\n    }\n  }\n\n  /**\n   * Returns the smart contract's local state wrapped in a strongly typed accessor with options to format the stored value\n   *\n   * @param account The address of the account for which to read local state from\n   */\n  public async getLocalState(account: string | SendTransactionFrom): Promise<StateApp['state']['local']> {\n    const state = await this.appClient.getLocalState(account)\n    return {\n      get local_bytes1() {\n        return StateAppClient.getBinaryState(state, 'local_bytes1')\n      },\n      get local_bytes2() {\n        return StateAppClient.getBinaryState(state, 'local_bytes2')\n      },\n      get local_int1() {\n        return StateAppClient.getIntegerState(state, 'local_int1')\n      },\n      get local_int2() {\n        return StateAppClient.getIntegerState(state, 'local_int2')\n      },\n    }\n  }\n\n  public compose(): StateAppComposer {\n    const client = this\n    const atc = new AtomicTransactionComposer()\n    let promiseChain:Promise<unknown> = Promise.resolve()\n    const resultMappers: Array<undefined | ((x: any) => any)> = []\n    return {\n      callAbi(args: MethodArgs<'call_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.callAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.callAbiTxn(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.callWithReferences(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.setGlobal(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.setLocal(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.setBox(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      error(args: MethodArgs<'error()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.error(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      defaultValue(args: MethodArgs<'default_value(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.defaultValue(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.defaultValueInt(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.defaultValueFromAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.defaultValueFromGlobalState(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.defaultValueFromLocalState(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      get update() {\n        const $this = this\n        return {\n          bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs) {\n            promiseChain = promiseChain.then(() => client.update.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n          updateAbi(args: MethodArgs<'update_abi(string)string'>, params?: AppClientCallCoreParams & AppClientCompilationParams) {\n            promiseChain = promiseChain.then(() => client.update.updateAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      get delete() {\n        const $this = this\n        return {\n          bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n            promiseChain = promiseChain.then(() => client.delete.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n          deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params?: AppClientCallCoreParams) {\n            promiseChain = promiseChain.then(() => client.delete.deleteAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      get optIn() {\n        const $this = this\n        return {\n          optIn(args: MethodArgs<'opt_in()void'>, params?: AppClientCallCoreParams) {\n            promiseChain = promiseChain.then(() => client.optIn.optIn(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n            resultMappers.push(undefined)\n            return $this\n          },\n        }\n      },\n      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n        resultMappers.push(undefined)\n        return this\n      },\n      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n        return this\n      },\n      async atc() {\n        await promiseChain\n        return atc\n      },\n      async execute() {\n        await promiseChain\n        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n        return {\n          ...result,\n          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n        }\n      }\n    } as unknown as StateAppComposer\n  }\n}", "export type StateAppComposer<TReturns extends [...any[]] = []> = {\n  /**\n   * Calls the call_abi(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  callAbi(args: MethodArgs<'call_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'call_abi(string)string'>]>\n\n  /**\n   * Calls the call_abi_txn(pay,string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'call_abi_txn(pay,string)string'>]>\n\n  /**\n   * Calls the call_with_references(asset,account,application)uint64 ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'call_with_references(asset,account,application)uint64'>]>\n\n  /**\n   * Calls the set_global(uint64,uint64,string,byte[4])void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'set_global(uint64,uint64,string,byte[4])void'>]>\n\n  /**\n   * Calls the set_local(uint64,uint64,string,byte[4])void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'set_local(uint64,uint64,string,byte[4])void'>]>\n\n  /**\n   * Calls the set_box(byte[4],string)void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'set_box(byte[4],string)void'>]>\n\n  /**\n   * Calls the error()void ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  error(args: MethodArgs<'error()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'error()void'>]>\n\n  /**\n   * Calls the default_value(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  defaultValue(args: MethodArgs<'default_value(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value(string)string'>]>\n\n  /**\n   * Calls the default_value_int(uint64)uint64 ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_int(uint64)uint64'>]>\n\n  /**\n   * Calls the default_value_from_abi(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_from_abi(string)string'>]>\n\n  /**\n   * Calls the default_value_from_global_state(uint64)uint64 ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_from_global_state(uint64)uint64'>]>\n\n  /**\n   * Calls the default_value_from_local_state(string)string ABI method.\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_from_local_state(string)string'>]>\n\n  /**\n   * Gets available update methods\n   */\n  readonly update: {\n    /**\n     * Updates an existing instance of the StateApp smart contract using a bare call.\n     *\n     * @param args The arguments for the bare call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs): StateAppComposer<[...TReturns, undefined]>\n    /**\n     * Updates an existing instance of the StateApp smart contract using the update_abi(string)string ABI method.\n     *\n     * @param args The arguments for the smart contract call\n     * @param params Any additional parameters for the call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    updateAbi(args: MethodArgs<'update_abi(string)string'>, params?: AppClientCallCoreParams & AppClientCompilationParams): StateAppComposer<[...TReturns, MethodReturn<'update_abi(string)string'>]>\n  }\n\n  /**\n   * Gets available delete methods\n   */\n  readonly delete: {\n    /**\n     * Deletes an existing instance of the StateApp smart contract using a bare call.\n     *\n     * @param args The arguments for the bare call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, undefined]>\n    /**\n     * Deletes an existing instance of the StateApp smart contract using the delete_abi(string)string ABI method.\n     *\n     * @param args The arguments for the smart contract call\n     * @param params Any additional parameters for the call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params?: AppClientCallCoreParams): StateAppComposer<[...TReturns, MethodReturn<'delete_abi(string)string'>]>\n  }\n\n  /**\n   * Gets available optIn methods\n   */\n  readonly optIn: {\n    /**\n     * Opts the user into an existing instance of the StateApp smart contract using the opt_in()void ABI method.\n     *\n     * @param args The arguments for the smart contract call\n     * @param params Any additional parameters for the call\n     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n     */\n    optIn(args: MethodArgs<'opt_in()void'>, params?: AppClientCallCoreParams): StateAppComposer<[...TReturns, MethodReturn<'opt_in()void'>]>\n  }\n\n  /**\n   * Makes a clear_state call to an existing instance of the StateApp smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n   */\n  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, undefined]>\n\n  /**\n   * Adds a transaction to the composer\n   *\n   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n   */\n  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): StateAppComposer<TReturns>\n  /**\n   * Returns the underlying AtomicTransactionComposer instance\n   */\n  atc(): Promise<AtomicTransactionComposer>\n  /**\n   * Executes the transaction group and returns an array of results\n   */\n  execute(): Promise<StateAppComposerResults<TReturns>>\n}", "export type StateAppComposerResults<TReturns extends [...any[]]> = {\n  returns: TReturns\n  groupId: string\n  txIds: string[]\n  transactions: Transaction[]\n}\n"]}
{"filename": "src/cli.ts", "chunked_list": ["import { Command } from 'commander'\nimport { load } from './schema/load'\nimport * as path from 'path'\nimport { generate } from './client/generate'\nimport { writeDocumentPartsToStream } from './output/writer'\nimport fs from 'fs'\nimport { colorConsole } from './util/color-console'\n\nexport function cli(workingDirectory: string, args: string[]) {\n  const program = new Command()\n  program\n    .command('generate')\n    .description('Generates a TypeScript client for the given application.json file')\n    .requiredOption('-a --application <path>', 'Specifies the application.json file')\n    .requiredOption('-o --output <path>', 'Specifies the output file path')\n    .action(({ application, output }: { application: string; output: string }): void => {\n      const resolvedAppJsonPath = path.resolve(workingDirectory, application)\n      const resolvedOutPath = path.resolve(workingDirectory, output)\n      const resolvedOutDir = path.dirname(resolvedOutPath)\n      colorConsole.info`Reading application.json file from path ${resolvedAppJsonPath}`\n      const spec = load(resolvedAppJsonPath)\n      colorConsole.info`Generating TS client for ${spec.contract.name}`\n      const parts = generate(spec)", "export function cli(workingDirectory: string, args: string[]) {\n  const program = new Command()\n  program\n    .command('generate')\n    .description('Generates a TypeScript client for the given application.json file')\n    .requiredOption('-a --application <path>', 'Specifies the application.json file')\n    .requiredOption('-o --output <path>', 'Specifies the output file path')\n    .action(({ application, output }: { application: string; output: string }): void => {\n      const resolvedAppJsonPath = path.resolve(workingDirectory, application)\n      const resolvedOutPath = path.resolve(workingDirectory, output)\n      const resolvedOutDir = path.dirname(resolvedOutPath)\n      colorConsole.info`Reading application.json file from path ${resolvedAppJsonPath}`\n      const spec = load(resolvedAppJsonPath)\n      colorConsole.info`Generating TS client for ${spec.contract.name}`\n      const parts = generate(spec)", "      if (!fs.existsSync(resolvedOutDir)) {\n        colorConsole.warn`Output directory ${resolvedOutDir} does not exist and will be created.`\n        fs.mkdirSync(resolvedOutDir, { recursive: true })\n      }\n      colorConsole.info`Writing TS client to ${resolvedOutPath}`\n      const file = fs.createWriteStream(resolvedOutPath, {\n        flags: 'w',\n      })\n      writeDocumentPartsToStream(parts, file)\n      colorConsole.success`Operation completed successfully`\n    })\n    .configureOutput({\n      writeErr(str: string) {\n        colorConsole.error`${str}`\n      },\n    })", "  try {\n    program.parse(args)\n  } catch (err) {\n    if (err instanceof Error) {\n      colorConsole.error`Unhandled error: \\n\\n${err.stack}`\n    } else {\n      colorConsole.error`Unhandled error: \\n\\n${err}`\n    }\n    process.exit(-1)\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { cli } from './cli'\ncli(process.cwd(), process.argv)\n"]}
{"filename": "src/tests/approval-tests.spec.ts", "chunked_list": ["import fs from 'fs'\nimport path from 'path'\nimport { generate } from '../client/generate'\nimport { writeDocumentPartsToString } from '../output/writer'\nimport { load } from '../schema/load'\n\nconst writeActual = process.env.TEST_ENV !== 'ci'\n\nconst testContracts = ['helloworld', 'lifecycle', 'state', 'voting'] as const\n", "const testContracts = ['helloworld', 'lifecycle', 'state', 'voting'] as const\n\ndescribe('When generating a ts client for a the contract', () => {\n  test.each(testContracts)('%s approval', (contractName) => {\n    const dir = path.join(__dirname, `../../examples/${contractName}/`)\n    const spec = load(path.join(dir, `application.json`))\n\n    const result = writeDocumentPartsToString(generate(spec))\n    if (writeActual) fs.writeFileSync(path.join(dir, `client.generated.ts`), result)\n\n    const approvedClient = fs.readFileSync(path.join(dir, `client.ts`), 'utf-8')\n\n    expect(result).toBe(approvedClient)\n  })\n})\n", "    if (writeActual) fs.writeFileSync(path.join(dir, `client.generated.ts`), result)\n\n    const approvedClient = fs.readFileSync(path.join(dir, `client.ts`), 'utf-8')\n\n    expect(result).toBe(approvedClient)\n  })\n})\n"]}
{"filename": "src/util/color-console.ts", "chunked_list": ["import chalk from 'chalk'\n\ntype ColorFn = (text: string) => string\n\nconst createColorFormatter =\n  (textColor: ColorFn, argColor: ColorFn, consoleFn: 'log' | 'error' | 'info' | 'warn') =>\n  (textParts: TemplateStringsArray, ...args: unknown[]): void => {\n    // eslint-disable-next-line no-console\n    console[consoleFn](\n      textParts\n        .flatMap((t, i) => (args.length > i ? [textColor(t), argColor(`${args[i]}`)] : textColor(t)))\n        .reduce((acc, cur) => acc + cur, ''),\n    )\n  }\n\nexport const colorConsole = {\n  info: createColorFormatter(chalk.cyan, chalk.blue, 'info'),\n  warn: createColorFormatter(chalk.yellow, chalk.yellow.bold, 'warn'),\n  success: createColorFormatter(chalk.green, chalk.green.bold, 'info'),\n  error: createColorFormatter(chalk.red, chalk.red.bold, 'error'),\n}\n"]}
{"filename": "src/util/boom.ts", "chunked_list": ["export const boom = (reason: string): never => {\n  throw new Error(reason)\n}\n"]}
{"filename": "src/util/sanitization.ts", "chunked_list": ["import { camelCase, pascalCase } from 'change-case'\n\nconst replaceInvalidWithUnderscore = (value: string) => value.replace(/[^a-z0-9_$]+/gi, '_')\n\nexport const makeSafeTypeIdentifier = (value: string) => pascalCase(replaceInvalidWithUnderscore(value))\nexport const makeSafeMethodIdentifier = (value: string) => camelCase(replaceInvalidWithUnderscore(value))\n\nexport const isSafeVariableIdentifier = (value: string) => /^[a-z$_][a-z0-9_$]*$/i.test(value)\n\nexport const makeSafeVariableIdentifier = (value: string) =>", "\nexport const makeSafeVariableIdentifier = (value: string) =>\n  isSafeVariableIdentifier(value) ? value : camelCase(replaceInvalidWithUnderscore(value)) || 'arg'\n\nconst escapeQuotes = (value: string) => value.replace(/['\"]/g, (val) => `\\\\${val}`)\n\nexport const makeSafePropertyIdentifier = (value: string) => (isSafeVariableIdentifier(value) ? value : `'${escapeQuotes(value)}'`)\n"]}
{"filename": "src/util/not-falsy.ts", "chunked_list": ["export const notFalsy = <T>(value: T): value is Exclude<T, 0 | false | undefined | null | ''> => Boolean(value)\n"]}
{"filename": "src/output/writer.ts", "chunked_list": ["import type fs from 'fs'\n\nexport const IncIndent = Symbol('Increase Indent')\nexport const DecIndent = Symbol('Decrease Indent')\nexport const DecIndentAndCloseBlock = Symbol('Decrease Indent and write a closing brace')\nexport const NewLineMode = Symbol('New Line Mode')\nexport const RestoreLineMode = Symbol('Restore Line Mode')\nexport const PropertyDelimiter = Symbol('Property Delimiter')\nexport const InlineMode = Symbol('Inline Mode')\nexport const NewLine = Symbol('New Line')\n", "export type Part =\n  | string\n  | typeof IncIndent\n  | typeof DecIndent\n  | typeof NewLineMode\n  | typeof DecIndentAndCloseBlock\n  | typeof InlineMode\n  | typeof NewLine\n  | typeof RestoreLineMode\n  | typeof PropertyDelimiter\nexport type DocumentParts = Generator<Part, void>\n", "export type DocumentParts = Generator<Part, void>\n\nexport type WriteOptions = {\n  indent?: string\n  disableEslint?: boolean\n  header?: string\n}\n\ninterface StringWriter {\n  write(value: string): void\n  get last(): string\n}\n", "interface StringWriter {\n  write(value: string): void\n  get last(): string\n}\n\nexport function writeDocumentPartsToStream(document: DocumentParts, stream: fs.WriteStream, options: WriteOptions = {}) {\n  const writer = {\n    _last: '',\n    write(val: string) {\n      this._last = val\n      stream.write(val)\n    },\n    get last() {\n      return this._last\n    },\n  }\n  writeDocumentPartsTo(document, options, writer)\n}\n", "export function writeDocumentPartsToString(document: DocumentParts, options: WriteOptions = {}) {\n  const writer = {\n    result: [] as string[],\n    _last: '',\n    write(val: string) {\n      this._last = val\n      this.result.push(val)\n    },\n    get last() {\n      return this._last\n    },\n    toString() {\n      return this.result.join('')\n    },\n  }\n  writeDocumentPartsTo(document, options, writer)\n  return writer.toString()\n}\n\nexport function* inline(...parts: Array<Part | DocumentParts>) {\n  yield InlineMode", "  for (const part of parts) {\n    if (typeof part === 'string' || typeof part === 'symbol') yield part\n    else yield* part\n  }\n  yield RestoreLineMode\n}\n\nexport function* indent(...parts: Array<Part | DocumentParts>) {\n  yield IncIndent\n  for (const part of parts) {\n    if (typeof part === 'string' || typeof part === 'symbol') yield part\n    else yield* part\n  }\n  yield DecIndent\n}\n\nexport function* jsDoc(docs: string | { description: string; abiDescription?: string; params?: Record<string, string>; returns?: string }) {\n  yield `/**`", "  for (const part of parts) {\n    if (typeof part === 'string' || typeof part === 'symbol') yield part\n    else yield* part\n  }\n  yield DecIndent\n}\n\nexport function* jsDoc(docs: string | { description: string; abiDescription?: string; params?: Record<string, string>; returns?: string }) {\n  yield `/**`\n  if (typeof docs === 'string') {\n    yield ` * ${docs}`\n  } else {\n    yield ` * ${docs.description}`", "  if (typeof docs === 'string') {\n    yield ` * ${docs}`\n  } else {\n    yield ` * ${docs.description}`\n    if (docs.abiDescription) {\n      yield ' *'\n      yield ` * ${docs.abiDescription}`\n    }\n    if (docs.params || docs.returns) {\n      yield ' *'\n    }", "    if (docs.params || docs.returns) {\n      yield ' *'\n    }\n    for (const [paramName, paramDesc] of Object.entries(docs.params ?? {})) {\n      yield ` * @param ${paramName} ${paramDesc}`\n    }\n    if (docs.returns) yield ` * @returns ${docs.returns}`\n  }\n  yield ' */'\n}\n", "function writeDocumentPartsTo(document: DocumentParts, { indent = '  ', ...options }: WriteOptions, writer: StringWriter): void {\n  if (options.header) writer.write(`${options.header}\\n`)\n  if (options.disableEslint) writer.write('/* eslint-disable */\\n')\n\n  const lineModes = [NewLineMode]\n  const currentLineMode = () => lineModes.at(-1) ?? NewLineMode\n\n  let curIndent = ''\n  for (const part of document) {\n    switch (part) {\n      case IncIndent:\n        curIndent += indent\n        break\n      case DecIndent:\n        curIndent = curIndent.slice(0, -indent.length)\n        break\n      case DecIndentAndCloseBlock:\n        curIndent = curIndent.slice(0, -indent.length)\n        writer.write(`${curIndent}}\\n`)\n        break\n      case NewLineMode:\n        lineModes.push(NewLineMode)", "  for (const part of document) {\n    switch (part) {\n      case IncIndent:\n        curIndent += indent\n        break\n      case DecIndent:\n        curIndent = curIndent.slice(0, -indent.length)\n        break\n      case DecIndentAndCloseBlock:\n        curIndent = curIndent.slice(0, -indent.length)\n        writer.write(`${curIndent}}\\n`)\n        break\n      case NewLineMode:\n        lineModes.push(NewLineMode)", "        if (writer.last.slice(-1)[0] !== '\\n') {\n          writer.write('\\n')\n        }\n        break\n      case InlineMode:\n        lineModes.push(InlineMode)\n        break\n      case RestoreLineMode:\n        lineModes.pop()\n\n        if (currentLineMode() === NewLineMode && writer.last.slice(-1)[0] !== '\\n') {\n          writer.write('\\n')\n        }\n        break\n      case PropertyDelimiter:", "        if (currentLineMode() === NewLineMode && writer.last.slice(-1)[0] !== '\\n') {\n          writer.write('\\n')\n        }\n        break\n      case PropertyDelimiter:\n        if (currentLineMode() === NewLineMode) {\n          writer.write('\\n')\n        } else {\n          writer.write(', ')\n        }\n        break\n      case NewLine:\n        writer.write('\\n')\n        break\n      default:", "        if (writer.last.slice(-1)[0] === '\\n') writer.write(curIndent)\n        writer.write(part)\n        if (currentLineMode() === NewLineMode) writer.write('\\n')\n        break\n    }\n  }\n}\n"]}
{"filename": "src/client/call-factory.ts", "chunked_list": ["import { ContractMethod } from '../schema/application'\nimport { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc, NewLine } from '../output/writer'\nimport { isSafeVariableIdentifier, makeSafeMethodIdentifier, makeSafePropertyIdentifier } from '../util/sanitization'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { GeneratorContext } from './generator-context'\nimport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\nimport { getCreateOnCompleteOptions } from './deploy-types'\n\nexport function* callFactory(ctx: GeneratorContext): DocumentParts {\n  yield* jsDoc('Exposes methods for constructing all available smart contract calls')", "export function* callFactory(ctx: GeneratorContext): DocumentParts {\n  yield* jsDoc('Exposes methods for constructing all available smart contract calls')\n  yield `export abstract class ${ctx.name}CallFactory {`\n  yield IncIndent\n\n  yield* opMethods(ctx)\n\n  for (const method of ctx.app.contract.methods) {\n    yield* callFactoryMethod(ctx, method)\n  }\n\n  yield DecIndent\n\n  yield '}'\n}\n\nfunction* opMethods(ctx: GeneratorContext): DocumentParts {\n  const { app, callConfig } = ctx\n\n  yield* operationMethod(\n    ctx,\n    `Constructs a create call for the ${app.contract.name} smart contract`,\n    callConfig.createMethods,\n    'create',\n    true,\n  )\n  yield* operationMethod(\n    ctx,\n    `Constructs an update call for the ${app.contract.name} smart contract`,\n    callConfig.updateMethods,\n    'update',\n    true,\n  )\n  yield* operationMethod(ctx, `Constructs a delete call for the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete')\n  yield* operationMethod(ctx, `Constructs an opt in call for the ${app.contract.name} smart contract`, callConfig.optInMethods, 'optIn')\n  yield* operationMethod(\n    ctx,\n    `Constructs a close out call for the ${app.contract.name} smart contract`,\n    callConfig.closeOutMethods,\n    'closeOut',\n  )\n}\n\nfunction* operationMethod(\n  { app, methodSignatureToUniqueName }: GeneratorContext,\n  description: string,\n  methods: MethodList,\n  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n  includeCompilation?: boolean,\n): DocumentParts {", "  if (methods.length) {\n    yield* jsDoc(`Gets available ${verb} call factories`)\n    yield `static get ${verb}() {`\n    yield IncIndent\n    yield `return {`\n    yield IncIndent\n    for (const methodSig of methods) {\n      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n      if (methodSig === BARE_CALL) {\n        yield* jsDoc({\n          description: `${description} using a bare call`,\n          params: {\n            params: `Any parameters for the call`,\n          },\n          returns: `A TypedCallParams object for the call`,\n        })\n        yield* factoryMethod({\n          isNested: true,\n          name: 'bare',\n          paramTypes: `BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs${\n            includeCompilation ? ' & AppClientCompilationParams' : ''\n          }${onComplete?.type ? ` & ${onComplete.type}` : ''}${onComplete?.isOptional !== false ? ' = {}' : ''}`,\n        })\n      } else {\n        const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig)!\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        yield* jsDoc({\n          description: `${description} using the ${methodSig} ABI method`,\n          params: {\n            args: `Any args for the contract call`,\n            params: `Any additional parameters for the call`,\n          },\n          returns: `A TypedCallParams object for the call`,\n        })\n        yield* factoryMethod({\n          isNested: true,\n          name: makeSafeMethodIdentifier(uniqueName),\n          signature: methodSig,\n          args: method.args,\n          paramTypes: `AppClientCallCoreParams & CoreAppCallArgs${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n            onComplete?.type ? ` & ${onComplete.type}` : ''\n          }${onComplete?.isOptional !== false ? ' = {}' : ''}`,\n        })\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n}\n\nfunction* callFactoryMethod({ methodSignatureToUniqueName, callConfig }: GeneratorContext, method: ContractMethod) {\n  const methodSignature = algokit.getABIMethodSignature(method)", "      if (methodSig === BARE_CALL) {\n        yield* jsDoc({\n          description: `${description} using a bare call`,\n          params: {\n            params: `Any parameters for the call`,\n          },\n          returns: `A TypedCallParams object for the call`,\n        })\n        yield* factoryMethod({\n          isNested: true,\n          name: 'bare',\n          paramTypes: `BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs${\n            includeCompilation ? ' & AppClientCompilationParams' : ''\n          }${onComplete?.type ? ` & ${onComplete.type}` : ''}${onComplete?.isOptional !== false ? ' = {}' : ''}`,\n        })\n      } else {\n        const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig)!\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        yield* jsDoc({\n          description: `${description} using the ${methodSig} ABI method`,\n          params: {\n            args: `Any args for the contract call`,\n            params: `Any additional parameters for the call`,\n          },\n          returns: `A TypedCallParams object for the call`,\n        })\n        yield* factoryMethod({\n          isNested: true,\n          name: makeSafeMethodIdentifier(uniqueName),\n          signature: methodSig,\n          args: method.args,\n          paramTypes: `AppClientCallCoreParams & CoreAppCallArgs${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n            onComplete?.type ? ` & ${onComplete.type}` : ''\n          }${onComplete?.isOptional !== false ? ' = {}' : ''}`,\n        })\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n}\n\nfunction* callFactoryMethod({ methodSignatureToUniqueName, callConfig }: GeneratorContext, method: ContractMethod) {\n  const methodSignature = algokit.getABIMethodSignature(method)", "  if (!callConfig.callMethods.includes(methodSignature)) return\n\n  yield* jsDoc({\n    description: `Constructs a no op call for the ${methodSignature} ABI method`,\n    abiDescription: method.desc,\n    params: {\n      args: `Any args for the contract call`,\n      params: `Any additional parameters for the call`,\n    },\n    returns: `A TypedCallParams object for the call`,\n  })\n  yield* factoryMethod({\n    isNested: false,\n    name: makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature]),\n    signature: methodSignature,\n    args: method.args,\n    paramTypes: 'AppClientCallCoreParams & CoreAppCallArgs',\n  })\n}\n\nfunction* factoryMethod({\n  isNested,\n  name,\n  signature,\n  args,\n  paramTypes,\n}:\n  | {\n      isNested: boolean\n      name?: string\n      signature?: undefined\n      args?: undefined\n      paramTypes: string\n    }\n  | {\n      isNested: boolean\n      name?: string\n      signature: string\n      args: Array<{ name: string }>\n      paramTypes: string\n    }) {\n  yield `${isNested ? '' : 'static '}${name}(${signature === undefined ? '' : `args: MethodArgs<'${signature}'>, `}params: ${paramTypes}) {`\n  yield IncIndent\n  yield `return {`\n  yield IncIndent", "  if (signature) {\n    yield `method: '${signature}' as const,`\n    yield `methodArgs: Array.isArray(args) ? args : [${args\n      .map((a) => (isSafeVariableIdentifier(a.name) ? `args.${a.name}` : `args['${makeSafePropertyIdentifier(a.name)}']`))\n      .join(', ')}],`\n  } else {\n    yield `method: undefined,`\n    yield `methodArgs: undefined,`\n  }\n\n  yield '...params,'\n  yield DecIndent\n  yield '}'\n  yield DecIndent\n  yield `}${isNested ? ',' : ''}`\n}\n"]}
{"filename": "src/client/imports.ts", "chunked_list": ["import { DocumentParts } from '../output/writer'\n\nexport function* imports(): DocumentParts {\n  yield `import * as algokit from '@algorandfoundation/algokit-utils'\nimport type {\n  AppCallTransactionResult,\n  AppCallTransactionResultOfType,\n  CoreAppCallArgs,\n  RawAppCallArgs,\n  AppState,", "  RawAppCallArgs,\n  AppState,\n  TealTemplateParams,\n  ABIAppCallArg,\n} from '@algorandfoundation/algokit-utils/types/app'\nimport type {\n  AppClientCallCoreParams,\n  AppClientCompilationParams,\n  AppClientDeployCoreParams,\n  AppDetails,", "  AppClientDeployCoreParams,\n  AppDetails,\n  ApplicationClient,\n} from '@algorandfoundation/algokit-utils/types/app-client'\nimport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\nimport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\nimport type { TransactionWithSigner } from 'algosdk'\nimport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'`\n}\n", "}\n"]}
{"filename": "src/client/call-composer.ts", "chunked_list": ["import { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent } from '../output/writer'\nimport { GeneratorContext } from './generator-context'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { makeSafeMethodIdentifier } from '../util/sanitization'\nimport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\nimport { getCreateOnCompleteOptions } from './deploy-types'\n\nexport function* composeMethod(ctx: GeneratorContext): DocumentParts {\n  const { name, callConfig } = ctx\n  yield `public compose(): ${name}Composer {`", "  const { name, callConfig } = ctx\n  yield `public compose(): ${name}Composer {`\n  yield IncIndent\n\n  yield `const client = this`\n  yield `const atc = new AtomicTransactionComposer()`\n  yield `let promiseChain:Promise<unknown> = Promise.resolve()`\n  yield `const resultMappers: Array<undefined | ((x: any) => any)> = []`\n  yield `return {`\n  yield IncIndent", "  yield `return {`\n  yield IncIndent\n\n  yield* callComposerNoops(ctx)\n  yield* callComposerOperationMethods(ctx, callConfig.updateMethods, 'update', true)\n  yield* callComposerOperationMethods(ctx, callConfig.deleteMethods, 'delete')\n  yield* callComposerOperationMethods(ctx, callConfig.optInMethods, 'optIn')\n  yield* callComposerOperationMethods(ctx, callConfig.closeOutMethods, 'closeOut')\n  yield* callComposerClearState()\n", "  yield* callComposerClearState()\n\n  yield `addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {`\n  yield IncIndent\n  yield 'promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ??' +\n    ' client.sender)))'\n  yield 'return this'\n  yield DecIndent\n  yield '},'\n", "  yield '},'\n\n  yield `async atc() {`\n  yield IncIndent\n  yield 'await promiseChain'\n  yield 'return atc'\n  yield DecIndent\n  yield '},'\n\n  yield `async execute() {`", "\n  yield `async execute() {`\n  yield IncIndent\n  yield `await promiseChain`\n  yield `const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)`\n  yield `return {`\n  yield IncIndent\n  yield `...result,`\n  yield `returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)`\n  yield DecIndentAndCloseBlock", "  yield `returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)`\n  yield DecIndentAndCloseBlock\n  yield DecIndentAndCloseBlock\n  yield DecIndent\n  yield `} as unknown as ${name}Composer`\n\n  yield DecIndentAndCloseBlock\n}\n\nfunction* callComposerNoops({ app, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {\n  for (const method of app.contract.methods) {\n    const methodSignature = algokit.getABIMethodSignature(method)\n    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n    // Skip methods which don't support a no_op call config", "\nfunction* callComposerNoops({ app, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {\n  for (const method of app.contract.methods) {\n    const methodSignature = algokit.getABIMethodSignature(method)\n    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n    // Skip methods which don't support a no_op call config\n    if (!callConfig.callMethods.includes(methodSignature)) continue\n\n    yield `${methodName}(args: MethodArgs<'${methodSignature}'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {`\n    yield IncIndent\n    yield `promiseChain = promiseChain.then(() => client.${methodName}(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))`\n    const outputTypeName = app.hints?.[methodSignature]?.structs?.output?.name\n    yield `resultMappers.push(${outputTypeName ?? 'undefined'})`\n    yield `return this`\n    yield DecIndent\n    yield '},'\n  }\n}\n\nfunction* callComposerClearState(): DocumentParts {\n  yield `clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {`\n  yield IncIndent\n  yield `promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))`\n  yield `resultMappers.push(undefined)`\n  yield `return this`\n  yield DecIndent\n  yield '},'\n}\n\nfunction* callComposerOperationMethods(\n  { app, methodSignatureToUniqueName }: GeneratorContext,\n  methods: MethodList,\n  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n  includeCompilation?: boolean,\n): DocumentParts {", "  if (methods.length) {\n    yield `get ${verb}() {`\n    yield IncIndent\n    yield `const $this = this`\n    yield `return {`\n    yield IncIndent\n    for (const methodSig of methods) {\n      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n      if (methodSig === BARE_CALL) {\n        yield `bare(args${onComplete?.isOptional !== false ? '?' : ''}: BareCallArgs & AppClientCallCoreParams ${\n          includeCompilation ? '& AppClientCompilationParams ' : ''\n        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}) {`\n        yield IncIndent\n        yield `promiseChain = promiseChain.then(() => client.${verb}.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))`\n        yield `resultMappers.push(undefined)`\n        yield `return $this`\n        yield DecIndent\n        yield '},'\n      } else {\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        const methodName = makeSafeMethodIdentifier(uniqueName)\n        yield `${methodName}(args: MethodArgs<'${methodSig}'>, params${\n          onComplete?.isOptional !== false ? '?' : ''\n        }: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n          onComplete?.type ? ` & ${onComplete.type}` : ''\n        }) {`\n        yield IncIndent\n        yield `promiseChain = promiseChain.then(() => client.${verb}.${methodName}(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))`\n        const outputTypeName = app.hints?.[methodSig]?.structs?.output?.name\n        yield `resultMappers.push(${outputTypeName ?? 'undefined'})`\n        yield `return $this`\n        yield DecIndent\n        yield '},'\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndent\n    yield '},'\n  }\n}\n", "      if (methodSig === BARE_CALL) {\n        yield `bare(args${onComplete?.isOptional !== false ? '?' : ''}: BareCallArgs & AppClientCallCoreParams ${\n          includeCompilation ? '& AppClientCompilationParams ' : ''\n        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}) {`\n        yield IncIndent\n        yield `promiseChain = promiseChain.then(() => client.${verb}.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))`\n        yield `resultMappers.push(undefined)`\n        yield `return $this`\n        yield DecIndent\n        yield '},'\n      } else {\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        const methodName = makeSafeMethodIdentifier(uniqueName)\n        yield `${methodName}(args: MethodArgs<'${methodSig}'>, params${\n          onComplete?.isOptional !== false ? '?' : ''\n        }: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n          onComplete?.type ? ` & ${onComplete.type}` : ''\n        }) {`\n        yield IncIndent\n        yield `promiseChain = promiseChain.then(() => client.${verb}.${methodName}(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))`\n        const outputTypeName = app.hints?.[methodSig]?.structs?.output?.name\n        yield `resultMappers.push(${outputTypeName ?? 'undefined'})`\n        yield `return $this`\n        yield DecIndent\n        yield '},'\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndent\n    yield '},'\n  }\n}\n"]}
{"filename": "src/client/utility-types.ts", "chunked_list": ["import { DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc } from '../output/writer'\n\nexport function* utilityTypes(): DocumentParts {\n  yield* jsDoc(`Defines an onCompletionAction of 'no_op'`)\n  yield `export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }`\n  yield* jsDoc(`Defines an onCompletionAction of 'opt_in'`)\n  yield `export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }`\n  yield* jsDoc(`Defines an onCompletionAction of 'close_out'`)\n  yield `export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }`\n  yield* jsDoc(`Defines an onCompletionAction of 'delete_application'`)\n  yield `export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }`\n  yield* jsDoc(`Defines an onCompletionAction of 'update_application'`)", "  yield `export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }`\n  yield* jsDoc(`Defines an onCompletionAction of 'delete_application'`)\n  yield `export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }`\n  yield* jsDoc(`Defines an onCompletionAction of 'update_application'`)\n  yield `export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }`\n\n  yield* jsDoc('A state record containing a single unsigned integer')\n  yield `export type IntegerState = {`\n  yield IncIndent\n  yield* jsDoc('Gets the state value as a BigInt ')\n  yield `asBigInt(): bigint`\n  yield* jsDoc('Gets the state value as a number.')\n  yield `asNumber(): number`\n  yield DecIndentAndCloseBlock\n  yield* jsDoc('A state record containing binary data')", "  yield `export type BinaryState = {`\n  yield IncIndent\n  yield* jsDoc('Gets the state value as a Uint8Array')\n  yield `asByteArray(): Uint8Array`\n  yield* jsDoc('Gets the state value as a string')\n  yield `asString(): string`\n  yield DecIndentAndCloseBlock\n}\n\nexport const OnCompleteCodeMap = {\n  no_op: 'OnCompleteNoOp',\n  opt_in: 'OnCompleteOptIn',\n  close_out: 'OnCompleteCloseOut',\n  delete_application: 'OnCompleteDelApp',\n  update_application: 'OnCompleteUpdApp',\n}\n"]}
{"filename": "src/client/call-client.ts", "chunked_list": ["import * as algokit from '@algorandfoundation/algokit-utils'\nimport { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, indent, inline, jsDoc, NewLine } from '../output/writer'\nimport { makeSafeMethodIdentifier, makeSafeTypeIdentifier } from '../util/sanitization'\nimport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\nimport { GeneratorContext } from './generator-context'\nimport { getCreateOnCompleteOptions } from './deploy-types'\nimport { composeMethod } from './call-composer'\n\nexport function* callClient(ctx: GeneratorContext): DocumentParts {\n  const { app, name } = ctx", "export function* callClient(ctx: GeneratorContext): DocumentParts {\n  const { app, name } = ctx\n\n  yield* jsDoc(`A client to make calls to the ${app.contract.name} smart contract`)\n  yield `export class ${makeSafeTypeIdentifier(app.contract.name)}Client {`\n  yield IncIndent\n  yield* jsDoc(`The underlying \\`ApplicationClient\\` for when you want to have more flexibility`)\n  yield 'public readonly appClient: ApplicationClient'\n  yield NewLine\n  yield `private readonly sender: SendTransactionFrom | undefined`", "  yield NewLine\n  yield `private readonly sender: SendTransactionFrom | undefined`\n  yield NewLine\n\n  yield* jsDoc({\n    description: `Creates a new instance of \\`${makeSafeTypeIdentifier(app.contract.name)}Client\\``,\n    params: {\n      appDetails: 'appDetails The details to identify the app to deploy',\n      algod: 'An algod client instance',\n    },", "      algod: 'An algod client instance',\n    },\n  })\n\n  yield `constructor(appDetails: AppDetails, private algod: Algodv2) {`\n  yield IncIndent\n  yield `this.sender = appDetails.sender`\n  yield 'this.appClient = algokit.getAppClient({'\n  yield* indent('...appDetails,', 'app: APP_SPEC')\n  yield '}, algod)'", "  yield* indent('...appDetails,', 'app: APP_SPEC')\n  yield '}, algod)'\n  yield DecIndent\n  yield '}'\n  yield NewLine\n\n  yield* jsDoc({\n    description: 'Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type',\n    params: {\n      result: 'The AppCallTransactionResult to be mapped',", "    params: {\n      result: 'The AppCallTransactionResult to be mapped',\n      returnValueFormatter: 'An optional delegate to format the return value if required',\n    },\n    returns: 'The smart contract response with an updated return value',\n  })\n  yield* inline(\n    `protected mapReturnValue<TReturn>`,\n    `(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): `,\n    `AppCallTransactionResultOfType<TReturn> {`,", "    `(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): `,\n    `AppCallTransactionResultOfType<TReturn> {`,\n  )\n  yield IncIndent\n  yield `if(result.return?.decodeError) {`\n  yield* indent(`throw result.return.decodeError`)\n  yield `}`\n  yield `const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined`\n  yield IncIndent\n  yield `? returnValueFormatter(result.return.returnValue)`\n  yield `: result.return?.returnValue as TReturn | undefined`\n  yield `return { ...result, return: returnValue }`\n  yield DecIndent\n  yield DecIndentAndCloseBlock\n  yield NewLine\n\n  yield* jsDoc({\n    description: 'Calls the ABI method with the matching signature using an onCompletion code of NO_OP',\n    params: {\n      typedCallParams: 'An object containing the method signature, args, and any other relevant parameters',\n      returnValueFormatter: 'An optional delegate which when provided will be used to map non-undefined return values to the target type',\n    },\n    returns: 'The result of the smart contract call',\n  })\n  yield `public async call<TSignature extends keyof ${name}['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {`\n  yield IncIndent\n  yield `return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)`\n  yield DecIndentAndCloseBlock\n  yield NewLine\n\n  yield* opMethods(ctx)\n  yield* clearState(ctx)\n  yield* noopMethods(ctx)\n  yield* getStateMethods(ctx)\n  yield* composeMethod(ctx)\n  yield DecIndentAndCloseBlock\n}\n\nfunction* opMethods(ctx: GeneratorContext): DocumentParts {\n  const { app, callConfig, name } = ctx\n\n  yield* jsDoc({\n    description: `Idempotently deploys the ${app.contract.name} smart contract.`,\n    params: {\n      params: 'The arguments for the contract calls and any additional parameters for the call',\n    },\n    returns: 'The deployment result',\n  })\n  yield `public deploy(params: ${name}DeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {`\n  yield IncIndent\n", "  if (callConfig.createMethods.length) yield `const createArgs = params.createCall?.(${name}CallFactory.create)`\n  if (callConfig.updateMethods.length) yield `const updateArgs = params.updateCall?.(${name}CallFactory.update)`\n  if (callConfig.deleteMethods.length) yield `const deleteArgs = params.deleteCall?.(${name}CallFactory.delete)`\n\n  yield `return this.appClient.deploy({`\n  yield IncIndent\n  yield `...params,`\n  if (callConfig.updateMethods.length) yield 'updateArgs,'\n  if (callConfig.deleteMethods.length) yield 'deleteArgs,'\n  if (callConfig.createMethods.length) {\n    yield 'createArgs,'\n    yield `createOnCompleteAction: createArgs?.onCompleteAction,`\n  }\n  yield DecIndent\n  yield `})`\n  yield DecIndentAndCloseBlock\n  yield NewLine\n  yield* operationMethod(ctx, `Creates a new instance of the ${app.contract.name} smart contract`, callConfig.createMethods, 'create', true)\n  yield* operationMethod(\n    ctx,\n    `Updates an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.updateMethods,\n    'update',\n    true,\n  )\n  yield* operationMethod(ctx, `Deletes an existing instance of the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete')\n  yield* operationMethod(\n    ctx,\n    `Opts the user into an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.optInMethods,\n    'optIn',\n  )\n  yield* operationMethod(\n    ctx,\n    `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.closeOutMethods,\n    'closeOut',\n  )\n}\n\nfunction* operationMethod(\n  { app, methodSignatureToUniqueName, name }: GeneratorContext,\n  description: string,\n  methods: MethodList,\n  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n  includeCompilation?: boolean,\n): DocumentParts {", "  if (callConfig.deleteMethods.length) yield 'deleteArgs,'\n  if (callConfig.createMethods.length) {\n    yield 'createArgs,'\n    yield `createOnCompleteAction: createArgs?.onCompleteAction,`\n  }\n  yield DecIndent\n  yield `})`\n  yield DecIndentAndCloseBlock\n  yield NewLine\n  yield* operationMethod(ctx, `Creates a new instance of the ${app.contract.name} smart contract`, callConfig.createMethods, 'create', true)\n  yield* operationMethod(\n    ctx,\n    `Updates an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.updateMethods,\n    'update',\n    true,\n  )\n  yield* operationMethod(ctx, `Deletes an existing instance of the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete')\n  yield* operationMethod(\n    ctx,\n    `Opts the user into an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.optInMethods,\n    'optIn',\n  )\n  yield* operationMethod(\n    ctx,\n    `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.closeOutMethods,\n    'closeOut',\n  )\n}\n\nfunction* operationMethod(\n  { app, methodSignatureToUniqueName, name }: GeneratorContext,\n  description: string,\n  methods: MethodList,\n  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n  includeCompilation?: boolean,\n): DocumentParts {", "  if (methods.length) {\n    yield* jsDoc(`Gets available ${verb} methods`)\n    yield `public get ${verb}() {`\n    yield IncIndent\n    yield `const $this = this`\n    yield `return {`\n    yield IncIndent\n    for (const methodSig of methods) {\n      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n      if (methodSig === BARE_CALL) {\n        yield* jsDoc({\n          description: `${description} using a bare call.`,\n          params: {\n            args: `The arguments for the bare call`,\n          },\n          returns: `The ${verb} result`,\n        })\n        yield `bare(args: BareCallArgs & AppClientCallCoreParams ${\n          includeCompilation ? '& AppClientCompilationParams ' : ''\n        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}${\n          onComplete?.isOptional !== false ? ' = {}' : ''\n        }): Promise<AppCallTransactionResultOfType<undefined>> {`\n        yield* indent(`return $this.appClient.${verb}(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>`)\n        yield '},'\n      } else {\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig)\n        yield* jsDoc({\n          description: `${description} using the ${methodSig} ABI method.`,\n          params: {\n            args: `The arguments for the smart contract call`,\n            params: `Any additional parameters for the call`,\n          },\n          returns: `The ${verb} result${method?.returns?.desc ? `: ${method.returns.desc}` : ''}`,\n        })\n        yield `async ${makeSafeMethodIdentifier(uniqueName)}(args: MethodArgs<'${methodSig}'>, params: AppClientCallCoreParams${\n          includeCompilation ? ' & AppClientCompilationParams' : ''\n        }${onComplete?.type ? ` & ${onComplete.type}` : ''}${\n          onComplete?.isOptional !== false ? ' = {}' : ''\n        }): Promise<AppCallTransactionResultOfType<MethodReturn<'${methodSig}'>>> {`\n        yield* indent(\n          `return $this.mapReturnValue(await $this.appClient.${verb}(${name}CallFactory.${verb}.${makeSafeMethodIdentifier(\n            uniqueName,\n          )}(args, params)))`,\n        )\n        yield '},'\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n}\n\nfunction* clearState({ app }: GeneratorContext): DocumentParts {\n  yield* jsDoc({\n    description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,\n    params: {\n      args: `The arguments for the bare call`,\n    },\n    returns: `The clear_state result`,\n  })\n  yield `public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {`\n  yield IncIndent\n  yield `return this.appClient.clearState(args)`\n  yield DecIndentAndCloseBlock\n  yield NewLine\n}\n\nfunction* noopMethods({ app, name, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {", "      if (methodSig === BARE_CALL) {\n        yield* jsDoc({\n          description: `${description} using a bare call.`,\n          params: {\n            args: `The arguments for the bare call`,\n          },\n          returns: `The ${verb} result`,\n        })\n        yield `bare(args: BareCallArgs & AppClientCallCoreParams ${\n          includeCompilation ? '& AppClientCompilationParams ' : ''\n        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}${\n          onComplete?.isOptional !== false ? ' = {}' : ''\n        }): Promise<AppCallTransactionResultOfType<undefined>> {`\n        yield* indent(`return $this.appClient.${verb}(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>`)\n        yield '},'\n      } else {\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig)\n        yield* jsDoc({\n          description: `${description} using the ${methodSig} ABI method.`,\n          params: {\n            args: `The arguments for the smart contract call`,\n            params: `Any additional parameters for the call`,\n          },\n          returns: `The ${verb} result${method?.returns?.desc ? `: ${method.returns.desc}` : ''}`,\n        })\n        yield `async ${makeSafeMethodIdentifier(uniqueName)}(args: MethodArgs<'${methodSig}'>, params: AppClientCallCoreParams${\n          includeCompilation ? ' & AppClientCompilationParams' : ''\n        }${onComplete?.type ? ` & ${onComplete.type}` : ''}${\n          onComplete?.isOptional !== false ? ' = {}' : ''\n        }): Promise<AppCallTransactionResultOfType<MethodReturn<'${methodSig}'>>> {`\n        yield* indent(\n          `return $this.mapReturnValue(await $this.appClient.${verb}(${name}CallFactory.${verb}.${makeSafeMethodIdentifier(\n            uniqueName,\n          )}(args, params)))`,\n        )\n        yield '},'\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n}\n\nfunction* clearState({ app }: GeneratorContext): DocumentParts {\n  yield* jsDoc({\n    description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,\n    params: {\n      args: `The arguments for the bare call`,\n    },\n    returns: `The clear_state result`,\n  })\n  yield `public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {`\n  yield IncIndent\n  yield `return this.appClient.clearState(args)`\n  yield DecIndentAndCloseBlock\n  yield NewLine\n}\n\nfunction* noopMethods({ app, name, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {", "  for (const method of app.contract.methods) {\n    const methodSignature = algokit.getABIMethodSignature(method)\n    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n    // Skip methods which don't support a no_op call config\n    if (!callConfig.callMethods.includes(methodSignature)) continue\n    yield* jsDoc({\n      description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,\n      abiDescription: method.desc,\n      params: {\n        args: `The arguments for the contract call`,\n        params: `Any additional parameters for the call`,\n      },\n      returns: `The result of the call${method?.returns?.desc ? `: ${method.returns.desc}` : ''}`,\n    })\n    yield `public ${methodName}(args: MethodArgs<'${methodSignature}'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {`\n    yield IncIndent\n    const outputTypeName = app.hints?.[methodSignature]?.structs?.output?.name\n    yield `return this.call(${name}CallFactory.${methodName}(args, params)${\n      outputTypeName === undefined ? '' : `, ${makeSafeTypeIdentifier(outputTypeName)}`\n    })`\n    yield DecIndent\n    yield '}'\n    yield NewLine\n  }\n}\n\nfunction* getStateMethods({ app, name }: GeneratorContext): DocumentParts {\n  const globalStateValues = app.schema.global?.declared && Object.values(app.schema.global?.declared)\n  const localStateValues = app.schema.local?.declared && Object.values(app.schema.local?.declared)", "  if (globalStateValues?.length || localStateValues?.length) {\n    yield* jsDoc({\n      description: 'Extracts a binary state value out of an AppState dictionary',\n      params: {\n        state: 'The state dictionary containing the state value',\n        key: 'The key of the state value',\n      },\n      returns: 'A BinaryState instance containing the state value, or undefined if the key was not found',\n    })\n    yield `private static getBinaryState(state: AppState, key: string): BinaryState | undefined {`\n    yield IncIndent\n    yield `const value = state[key]`", "    yield `if (!value) return undefined`\n    yield `if (!('valueRaw' in value))`\n    yield* indent(`throw new Error(\\`Failed to parse state value for \\${key}; received an int when expected a byte array\\`)`)\n    yield `return {`\n    yield IncIndent\n    yield `asString(): string {`\n    yield* indent(`return value.value`)\n    yield `},`\n    yield `asByteArray(): Uint8Array {`\n    yield* indent(`return value.valueRaw`)\n    yield `}`\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n\n    yield* jsDoc({\n      description: 'Extracts a integer state value out of an AppState dictionary',\n      params: {\n        state: 'The state dictionary containing the state value',\n        key: 'The key of the state value',\n      },\n      returns: 'An IntegerState instance containing the state value, or undefined if the key was not found',\n    })\n    yield `private static getIntegerState(state: AppState, key: string): IntegerState | undefined {`\n    yield IncIndent\n    yield `const value = state[key]`", "    yield `if (!value) return undefined`\n    yield `if ('valueRaw' in value)`\n    yield* indent(`throw new Error(\\`Failed to parse state value for \\${key}; received a byte array when expected a number\\`)`)\n    yield `return {`\n    yield IncIndent\n    yield `asBigInt() {`\n    yield* indent(`return typeof value.value === 'bigint' ? value.value : BigInt(value.value)`)\n    yield `},`\n    yield `asNumber(): number {`\n    yield* indent(`return typeof value.value === 'bigint' ? Number(value.value) : value.value`)\n    yield `},`\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n", "  if (globalStateValues?.length) {\n    yield* jsDoc(`Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value`)\n    yield `public async getGlobalState(): Promise<${name}['state']['global']> {`\n    yield IncIndent\n    yield `const state = await this.appClient.getGlobalState()`\n    yield `return {`\n    yield IncIndent\n    for (const stateValue of globalStateValues) {\n      yield `get ${stateValue.key}() {`\n      if (stateValue.type === 'uint64') {\n        yield* indent(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`)\n      } else {\n        yield* indent(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`)\n      }\n      yield '},'\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n", "      if (stateValue.type === 'uint64') {\n        yield* indent(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`)\n      } else {\n        yield* indent(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`)\n      }\n      yield '},'\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n", "  if (localStateValues?.length) {\n    yield* jsDoc({\n      description: `Returns the smart contract's local state wrapped in a strongly typed accessor with options to format the stored value`,\n      params: {\n        account: `The address of the account for which to read local state from`,\n      },\n    })\n    yield `public async getLocalState(account: string | SendTransactionFrom): Promise<${name}['state']['local']> {`\n    yield IncIndent\n    yield `const state = await this.appClient.getLocalState(account)`\n    yield `return {`\n    yield IncIndent", "    for (const stateValue of localStateValues) {\n      yield `get ${stateValue.key}() {`\n      if (stateValue.type === 'uint64') {\n        yield* indent(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`)\n      } else {\n        yield* indent(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`)\n      }\n      yield '},'\n    }\n    yield DecIndentAndCloseBlock\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n}\n"]}
{"filename": "src/client/app-types.ts", "chunked_list": ["import { GeneratorContext } from './generator-context'\nimport { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, inline, jsDoc, NewLine } from '../output/writer'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { getEquivalentType } from './helpers/get-equivalent-type'\nimport { makeSafePropertyIdentifier, makeSafeTypeIdentifier, makeSafeVariableIdentifier } from '../util/sanitization'\n\nexport function* appTypes(ctx: GeneratorContext): DocumentParts {\n  const { app, methodSignatureToUniqueName, name } = ctx\n  yield* jsDoc(`Defines the types of available calls and state of the ${name} smart contract.`)\n  yield `export type ${name} = {`", "  yield* jsDoc(`Defines the types of available calls and state of the ${name} smart contract.`)\n  yield `export type ${name} = {`\n  yield IncIndent\n  yield* jsDoc('Maps method signatures / names to their argument and return types.')\n  yield 'methods:'\n  yield IncIndent\n  for (const method of app.contract.methods) {\n    const methodSig = algokit.getABIMethodSignature(method)\n    const uniqueName = methodSignatureToUniqueName[methodSig]\n    yield `& Record<'${methodSig}'${methodSig !== uniqueName ? ` | '${uniqueName}'` : ''}, {`\n    yield IncIndent\n    yield `argsObj: {`\n    yield IncIndent\n\n    const argsMeta = method.args.map((arg) => ({\n      ...arg,\n      hasDefault: app.hints?.[methodSig]?.default_arguments?.[arg.name],\n      tsType: getEquivalentType(arg.type, 'input'),\n    }))\n", "    for (const arg of argsMeta) {\n      if (arg.desc) yield* jsDoc(arg.desc)\n      yield `${makeSafePropertyIdentifier(arg.name)}${arg.hasDefault ? '?' : ''}: ${arg.tsType}`\n    }\n    yield DecIndentAndCloseBlock\n    yield* inline(\n      `argsTuple: [`,\n      argsMeta\n        .map(\n          (arg) =>\n            `${makeSafeVariableIdentifier(arg.name)}: ${getEquivalentType(arg.type, 'input')}${arg.hasDefault ? ' | undefined' : ''}`,\n        )\n        .join(', '),\n      ']',\n    )\n    const outputStruct = ctx.app.hints?.[methodSig]?.structs?.output", "    if (method.returns.desc) yield* jsDoc(method.returns.desc)\n    if (outputStruct) {\n      yield `returns: ${makeSafeTypeIdentifier(outputStruct.name)}`\n    } else {\n      yield `returns: ${getEquivalentType(method.returns.type ?? 'void', 'output')}`\n    }\n\n    yield DecIndent\n    yield '}>'\n  }\n  yield DecIndent\n  yield* appState(ctx)\n  yield DecIndentAndCloseBlock\n\n  yield* jsDoc('Defines the possible abi call signatures')\n  yield `export type ${name}Sig = keyof ${name}['methods']`\n  yield* jsDoc(\n    'Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a' +\n      ' bare call is made',\n  )", "  yield `export type TypedCallParams<TSignature extends ${name}Sig | undefined> = {`\n  yield IncIndent\n  yield 'method: TSignature'\n  yield 'methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>'\n  yield DecIndent\n  yield '} & AppClientCallCoreParams & CoreAppCallArgs'\n  yield* jsDoc('Defines the arguments required for a bare call')\n  yield `export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>`\n\n  yield* structs(ctx)\n  yield* jsDoc(`Maps a method signature from the ${name} smart contract to the method's arguments in either tuple of struct form`)", "  yield `export type MethodArgs<TSignature extends ${name}Sig> = ${name}['methods'][TSignature]['argsObj' | 'argsTuple']`\n  yield* jsDoc(`Maps a method signature from the ${name} smart contract to the method's return type`)\n  yield `export type MethodReturn<TSignature extends ${name}Sig> = ${name}['methods'][TSignature]['returns']`\n  yield NewLine\n}\n\nfunction* structs({ app }: GeneratorContext): DocumentParts {\n  if (app.hints === undefined) return\n  for (const methodHint of Object.values(app.hints)) {\n    if (methodHint.structs === undefined) continue\n    for (const struct of Object.values(methodHint.structs)) {\n      yield* jsDoc(`Represents a ${struct.name} result as a struct`)\n      yield `export type ${makeSafeTypeIdentifier(struct.name)} = {`\n      yield IncIndent", "  for (const methodHint of Object.values(app.hints)) {\n    if (methodHint.structs === undefined) continue\n    for (const struct of Object.values(methodHint.structs)) {\n      yield* jsDoc(`Represents a ${struct.name} result as a struct`)\n      yield `export type ${makeSafeTypeIdentifier(struct.name)} = {`\n      yield IncIndent\n      for (const [key, type] of struct.elements) {\n        yield `${makeSafePropertyIdentifier(key)}: ${getEquivalentType(type, 'output')}`\n      }\n      yield DecIndentAndCloseBlock\n      yield* jsDoc(`Converts the tuple representation of a ${struct.name} to the struct representation`)\n      yield* inline(\n        `export function ${makeSafeTypeIdentifier(struct.name)}(`,\n        `[${struct.elements.map(([key]) => makeSafeVariableIdentifier(key)).join(', ')}]: `,\n        `[${struct.elements.map(([_, type]) => getEquivalentType(type, 'output')).join(', ')}] ) {`,\n      )\n      yield IncIndent\n      yield `return {`\n      yield IncIndent", "      for (const [key] of struct.elements) {\n        const prop = makeSafePropertyIdentifier(key)\n        const param = makeSafeVariableIdentifier(key)\n        yield `${prop}${prop !== param ? `: ${param}` : ''},`\n      }\n      yield DecIndentAndCloseBlock\n      yield DecIndentAndCloseBlock\n    }\n  }\n}\n\nfunction* appState({ app }: GeneratorContext): DocumentParts {\n  const hasLocal = app.schema.local?.declared && Object.keys(app.schema.local.declared).length\n  const hasGlobal = app.schema.global?.declared && Object.keys(app.schema.global.declared).length", "  if (hasLocal || hasGlobal) {\n    yield* jsDoc('Defines the shape of the global and local state of the application.')\n    yield 'state: {'\n    yield IncIndent\n    if (hasGlobal) {\n      yield 'global: {'\n      yield IncIndent\n      for (const prop of Object.values(app.schema.global!.declared!)) {\n        if (prop.descr) {\n          yield* jsDoc(prop.descr)\n        }\n\n        yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`\n      }\n      yield DecIndentAndCloseBlock\n    }", "        if (prop.descr) {\n          yield* jsDoc(prop.descr)\n        }\n\n        yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`\n      }\n      yield DecIndentAndCloseBlock\n    }\n    if (hasLocal) {\n      yield 'local: {'\n      yield IncIndent", "    if (hasLocal) {\n      yield 'local: {'\n      yield IncIndent\n      for (const prop of Object.values(app.schema.local!.declared!)) {\n        if (prop.descr) {\n          yield* jsDoc(prop.descr)\n        }\n\n        yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`\n      }\n      yield DecIndentAndCloseBlock\n    }\n\n    yield DecIndentAndCloseBlock\n  }\n}\n"]}
{"filename": "src/client/call-composer-types.ts", "chunked_list": ["import { DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc, NewLine } from '../output/writer'\nimport { GeneratorContext } from './generator-context'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { makeSafeMethodIdentifier } from '../util/sanitization'\nimport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\nimport { getCreateOnCompleteOptions } from './deploy-types'\n\nexport function* callComposerType(ctx: GeneratorContext): DocumentParts {\n  const { name, callConfig, app } = ctx\n  yield `export type ${name}Composer<TReturns extends [...any[]] = []> = {`", "  const { name, callConfig, app } = ctx\n  yield `export type ${name}Composer<TReturns extends [...any[]] = []> = {`\n  yield IncIndent\n\n  yield* callComposerTypeNoops(ctx)\n  yield* callComposerOperationMethodType(\n    ctx,\n    `Updates an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.updateMethods,\n    'update',", "    callConfig.updateMethods,\n    'update',\n    true,\n  )\n  yield* callComposerOperationMethodType(\n    ctx,\n    `Deletes an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.deleteMethods,\n    'delete',\n  )", "    'delete',\n  )\n  yield* callComposerOperationMethodType(\n    ctx,\n    `Opts the user into an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.optInMethods,\n    'optIn',\n  )\n  yield* callComposerOperationMethodType(\n    ctx,", "  yield* callComposerOperationMethodType(\n    ctx,\n    `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`,\n    callConfig.closeOutMethods,\n    'closeOut',\n  )\n\n  yield* callComposerTypeClearState(ctx)\n\n  yield* jsDoc({", "\n  yield* jsDoc({\n    description: 'Adds a transaction to the composer',\n    params: {\n      txn: 'One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)',\n      defaultSender:\n        'The default sender to be used to obtain a signer where the object provided to the transaction parameter does not' +\n        ' include a signer.',\n    },\n  })", "    },\n  })\n  yield `addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): ${name}Composer<TReturns>`\n\n  yield* jsDoc({\n    description: 'Returns the underlying AtomicTransactionComposer instance',\n  })\n  yield `atc(): Promise<AtomicTransactionComposer>`\n\n  yield* jsDoc({", "\n  yield* jsDoc({\n    description: 'Executes the transaction group and returns an array of results',\n  })\n  yield `execute(): Promise<${name}ComposerResults<TReturns>>`\n\n  yield DecIndentAndCloseBlock\n\n  yield `export type ${name}ComposerResults<TReturns extends [...any[]]> = {`\n  yield IncIndent", "  yield `export type ${name}ComposerResults<TReturns extends [...any[]]> = {`\n  yield IncIndent\n  yield `returns: TReturns`\n  yield `groupId: string`\n  yield `txIds: string[]`\n  yield `transactions: Transaction[]`\n  yield DecIndentAndCloseBlock\n}\n\nfunction* callComposerTypeClearState({ app, name }: GeneratorContext): DocumentParts {", "\nfunction* callComposerTypeClearState({ app, name }: GeneratorContext): DocumentParts {\n  yield* jsDoc({\n    description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,\n    params: {\n      args: `The arguments for the bare call`,\n    },\n    returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n  })\n  yield `clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, undefined]>`", "  })\n  yield `clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, undefined]>`\n  yield NewLine\n}\n\nfunction* callComposerTypeNoops({ app, name, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {\n  for (const method of app.contract.methods) {\n    const methodSignature = algokit.getABIMethodSignature(method)\n    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n    // Skip methods which don't support a no_op call config\n    if (!callConfig.callMethods.includes(methodSignature)) continue\n    yield* jsDoc({\n      description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,\n      abiDescription: method.desc,\n      params: {\n        args: `The arguments for the contract call`,\n        params: `Any additional parameters for the call`,\n      },\n      returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n    })\n    yield `${methodName}(args: MethodArgs<'${methodSignature}'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, MethodReturn<'${methodSignature}'>]>`\n    yield NewLine\n  }\n}\n\nfunction* callComposerOperationMethodType(\n  { app, methodSignatureToUniqueName, name }: GeneratorContext,\n  description: string,\n  methods: MethodList,\n  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n  includeCompilation?: boolean,\n): DocumentParts {", "    if (!callConfig.callMethods.includes(methodSignature)) continue\n    yield* jsDoc({\n      description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,\n      abiDescription: method.desc,\n      params: {\n        args: `The arguments for the contract call`,\n        params: `Any additional parameters for the call`,\n      },\n      returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n    })\n    yield `${methodName}(args: MethodArgs<'${methodSignature}'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, MethodReturn<'${methodSignature}'>]>`\n    yield NewLine\n  }\n}\n\nfunction* callComposerOperationMethodType(\n  { app, methodSignatureToUniqueName, name }: GeneratorContext,\n  description: string,\n  methods: MethodList,\n  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n  includeCompilation?: boolean,\n): DocumentParts {", "  if (methods.length) {\n    yield* jsDoc(`Gets available ${verb} methods`)\n    yield `readonly ${verb}: {`\n    yield IncIndent\n    for (const methodSig of methods) {\n      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n      if (methodSig === BARE_CALL) {\n        yield* jsDoc({\n          description: `${description} using a bare call.`,\n          params: {\n            args: `The arguments for the bare call`,\n          },\n          returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n        })\n        yield `bare(args${onComplete?.isOptional !== false ? '?' : ''}: BareCallArgs & AppClientCallCoreParams ${\n          includeCompilation ? '& AppClientCompilationParams ' : ''\n        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}): ${name}Composer<[...TReturns, undefined]>`\n      } else {\n        const uniqueName = methodSignatureToUniqueName[methodSig]\n        yield* jsDoc({\n          description: `${description} using the ${methodSig} ABI method.`,\n          params: {\n            args: `The arguments for the smart contract call`,\n            params: `Any additional parameters for the call`,\n          },\n          returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n        })\n        yield `${makeSafeMethodIdentifier(uniqueName)}(args: MethodArgs<'${methodSig}'>, params${\n          onComplete?.isOptional !== false ? '?' : ''\n        }: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n          onComplete?.type ? ` & ${onComplete.type}` : ''\n        }): ${name}Composer<[...TReturns, MethodReturn<'${methodSig}'>]>`\n      }\n    }\n    yield DecIndentAndCloseBlock\n    yield NewLine\n  }\n}\n"]}
{"filename": "src/client/generate.ts", "chunked_list": ["import { DocumentParts, inline, NewLine } from '../output/writer'\nimport { AlgoAppSpec } from '../schema/application'\nimport { callFactory } from './call-factory'\nimport { callClient } from './call-client'\nimport { deployTypes } from './deploy-types'\nimport { utilityTypes } from './utility-types'\nimport { imports } from './imports'\nimport { createGeneratorContext } from './generator-context'\nimport { appTypes } from './app-types'\nimport { callComposerType } from './call-composer-types'", "import { appTypes } from './app-types'\nimport { callComposerType } from './call-composer-types'\n\nexport function* generate(app: AlgoAppSpec): DocumentParts {\n  const ctx = createGeneratorContext(app)\n  yield `/* eslint-disable */`\n  yield `/**`\n  yield ` * This file was automatically generated by @algorandfoundation/algokit-client-generator.`\n  yield ` * DO NOT MODIFY IT BY HAND.`\n  yield ` * requires: @algorandfoundation/algokit-utils: ^2`", "  yield ` * DO NOT MODIFY IT BY HAND.`\n  yield ` * requires: @algorandfoundation/algokit-utils: ^2`\n  yield ` */`\n\n  yield* imports()\n  yield* inline('export const APP_SPEC: AppSpec = ', JSON.stringify(app, undefined, 2))\n  yield NewLine\n\n  yield* utilityTypes()\n  yield NewLine", "  yield* utilityTypes()\n  yield NewLine\n  yield* appTypes(ctx)\n  yield* deployTypes(ctx)\n  yield NewLine\n\n  // Write a call factory\n  yield* callFactory(ctx)\n  yield NewLine\n  // Write a client", "  yield NewLine\n  // Write a client\n  yield* callClient(ctx)\n\n  yield* callComposerType(ctx)\n}\n"]}
{"filename": "src/client/generator-context.ts", "chunked_list": ["import { AlgoAppSpec } from '../schema/application'\nimport { CallConfigSummary, getCallConfigSummary } from './helpers/get-call-config-summary'\nimport { makeSafeTypeIdentifier } from '../util/sanitization'\nimport * as algokit from '@algorandfoundation/algokit-utils'\n\nexport type GeneratorContext = {\n  app: AlgoAppSpec\n  name: string\n  callConfig: CallConfigSummary\n  methodSignatureToUniqueName: Record<string, string>\n}\n\nexport const createGeneratorContext = (app: AlgoAppSpec) => ({\n  app,\n  name: makeSafeTypeIdentifier(app.contract.name),\n  callConfig: getCallConfigSummary(app),\n  methodSignatureToUniqueName: app.contract.methods.reduce((acc, cur) => {\n    const signature = algokit.getABIMethodSignature(cur)\n    acc[signature] = app.contract.methods.some((m) => m.name === cur.name && m !== cur) ? signature : cur.name\n    return acc\n  }, {} as Record<string, string>),\n})\n"]}
{"filename": "src/client/deploy-types.ts", "chunked_list": ["import { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc, NewLine } from '../output/writer'\nimport { makeSafeTypeIdentifier } from '../util/sanitization'\nimport { BARE_CALL, MethodIdentifier } from './helpers/get-call-config-summary'\nimport { GeneratorContext } from './generator-context'\nimport { AlgoAppSpec, CallConfig } from '../schema/application'\nimport { OnCompleteCodeMap } from './utility-types'\n\nexport function getCreateOnCompleteOptions(method: MethodIdentifier, app: AlgoAppSpec) {\n  const callConfig = method === BARE_CALL ? app.bare_call_config : app.hints?.[method]?.call_config\n  const hasNoOp = callConfig?.no_op === 'ALL' || callConfig?.no_op === 'CREATE'\n  const onCompleteType = callConfig\n    ? `(${Object.entries(callConfig)\n        .filter(([_, value]) => value === 'ALL' || value === 'CREATE')\n        .map(([oc]) => OnCompleteCodeMap[oc as keyof CallConfig])\n        .join(' | ')})`\n    : {}\n  return {\n    type: onCompleteType,\n    isOptional: hasNoOp,\n  }\n}\n\nexport function* deployTypes({ app, callConfig }: GeneratorContext): DocumentParts {\n  const name = makeSafeTypeIdentifier(app.contract.name)\n", "  if (callConfig.createMethods.length > 0) {\n    yield* jsDoc(`A factory for available 'create' calls`)\n    yield `export type ${name}CreateCalls = (typeof ${name}CallFactory)['create']`\n    yield* jsDoc('Defines supported create methods for this smart contract')\n    yield `export type ${name}CreateCallParams =`\n    yield IncIndent\n    for (const method of callConfig.createMethods) {\n      const onComplete = getCreateOnCompleteOptions(method, app)\n      if (method === BARE_CALL) {\n        yield `| (TypedCallParams<undefined> & ${onComplete.type})`\n      } else {\n        yield `| (TypedCallParams<'${method}'> & ${onComplete.type})`\n      }\n    }\n    yield DecIndent\n  }", "      if (method === BARE_CALL) {\n        yield `| (TypedCallParams<undefined> & ${onComplete.type})`\n      } else {\n        yield `| (TypedCallParams<'${method}'> & ${onComplete.type})`\n      }\n    }\n    yield DecIndent\n  }\n  if (callConfig.updateMethods.length > 0) {\n    yield* jsDoc(`A factory for available 'update' calls`)\n\n    yield `export type ${name}UpdateCalls = (typeof ${name}CallFactory)['update']`\n    yield* jsDoc('Defines supported update methods for this smart contract')\n    yield `export type ${name}UpdateCallParams =`\n    yield IncIndent", "  if (callConfig.updateMethods.length > 0) {\n    yield* jsDoc(`A factory for available 'update' calls`)\n\n    yield `export type ${name}UpdateCalls = (typeof ${name}CallFactory)['update']`\n    yield* jsDoc('Defines supported update methods for this smart contract')\n    yield `export type ${name}UpdateCallParams =`\n    yield IncIndent\n    for (const method of callConfig.updateMethods) {\n      if (method === BARE_CALL) {\n        yield `| TypedCallParams<undefined>`\n      } else {\n        yield `| TypedCallParams<'${method}'>`\n      }\n    }\n    yield DecIndent\n  }\n", "      if (method === BARE_CALL) {\n        yield `| TypedCallParams<undefined>`\n      } else {\n        yield `| TypedCallParams<'${method}'>`\n      }\n    }\n    yield DecIndent\n  }\n\n  if (callConfig.deleteMethods.length > 0) {\n    yield* jsDoc(`A factory for available 'delete' calls`)\n\n    yield `export type ${name}DeleteCalls = (typeof ${name}CallFactory)['delete']`\n\n    yield* jsDoc('Defines supported delete methods for this smart contract')\n    yield `export type ${name}DeleteCallParams =`\n    yield IncIndent", "  if (callConfig.deleteMethods.length > 0) {\n    yield* jsDoc(`A factory for available 'delete' calls`)\n\n    yield `export type ${name}DeleteCalls = (typeof ${name}CallFactory)['delete']`\n\n    yield* jsDoc('Defines supported delete methods for this smart contract')\n    yield `export type ${name}DeleteCallParams =`\n    yield IncIndent\n    for (const method of callConfig.deleteMethods) {\n      if (method === BARE_CALL) {\n        yield `| TypedCallParams<undefined>`\n      } else {\n        yield `| TypedCallParams<'${method}'>`\n      }\n    }\n    yield DecIndent\n  }\n\n  yield* jsDoc('Defines arguments required for the deploy method.')\n  yield `export type ${name}DeployArgs = {`\n  yield IncIndent\n  yield `deployTimeParams?: TealTemplateParams`", "    for (const method of callConfig.deleteMethods) {\n      if (method === BARE_CALL) {\n        yield `| TypedCallParams<undefined>`\n      } else {\n        yield `| TypedCallParams<'${method}'>`\n      }\n    }\n    yield DecIndent\n  }\n\n  yield* jsDoc('Defines arguments required for the deploy method.')\n  yield `export type ${name}DeployArgs = {`\n  yield IncIndent\n  yield `deployTimeParams?: TealTemplateParams`", "  if (callConfig.createMethods.length) {\n    yield* jsDoc('A delegate which takes a create call factory and returns the create call params for this smart contract')\n    yield `createCall?: (callFactory: ${name}CreateCalls) => ${name}CreateCallParams`\n  }\n  if (callConfig.updateMethods.length) {\n    yield* jsDoc('A delegate which takes a update call factory and returns the update call params for this smart contract')\n    yield `updateCall?: (callFactory: ${name}UpdateCalls) => ${name}UpdateCallParams`\n  }\n  if (callConfig.deleteMethods.length) {\n    yield* jsDoc('A delegate which takes a delete call factory and returns the delete call params for this smart contract')\n    yield `deleteCall?: (callFactory: ${name}DeleteCalls) => ${name}DeleteCallParams`\n  }\n  yield DecIndentAndCloseBlock\n  yield NewLine\n}\n", "  if (callConfig.deleteMethods.length) {\n    yield* jsDoc('A delegate which takes a delete call factory and returns the delete call params for this smart contract')\n    yield `deleteCall?: (callFactory: ${name}DeleteCalls) => ${name}DeleteCallParams`\n  }\n  yield DecIndentAndCloseBlock\n  yield NewLine\n}\n"]}
{"filename": "src/client/helpers/get-call-config-summary.ts", "chunked_list": ["import { pascalCase } from 'change-case'\nimport { AlgoAppSpec, CallConfig, CallConfigValue } from '../../schema/application'\n\nexport const BARE_CALL = Symbol('bare')\n\nexport type MethodIdentifier = string | typeof BARE_CALL\n\nexport type MethodList = Array<MethodIdentifier>\n\nexport type CallConfigSummary = {\n  createMethods: MethodList\n  callMethods: MethodList\n  deleteMethods: MethodList\n  updateMethods: MethodList\n  optInMethods: MethodList\n  closeOutMethods: MethodList\n}\nexport const getCallConfigSummary = (app: AlgoAppSpec) => {\n  const result: CallConfigSummary = {\n    createMethods: [],\n    callMethods: [],\n    deleteMethods: [],\n    updateMethods: [],\n    optInMethods: [],\n    closeOutMethods: [],\n  }", "export type CallConfigSummary = {\n  createMethods: MethodList\n  callMethods: MethodList\n  deleteMethods: MethodList\n  updateMethods: MethodList\n  optInMethods: MethodList\n  closeOutMethods: MethodList\n}\nexport const getCallConfigSummary = (app: AlgoAppSpec) => {\n  const result: CallConfigSummary = {\n    createMethods: [],\n    callMethods: [],\n    deleteMethods: [],\n    updateMethods: [],\n    optInMethods: [],\n    closeOutMethods: [],\n  }", "  if (app.bare_call_config) {\n    addToConfig(result, BARE_CALL, app.bare_call_config)\n  }\n  if (app.hints) {\n    for (const [method, hints] of Object.entries(app.hints)) {\n      if (hints.call_config) {\n        addToConfig(result, method, hints.call_config)\n      }\n    }\n  }\n  return result\n}\n\nexport const getCreateOnComplete = (app: AlgoAppSpec, method: MethodIdentifier) => {\n  const callConfig = method === BARE_CALL ? app.bare_call_config : app.hints?.[method]?.call_config", "  if (!callConfig) {\n    return ''\n  }\n  const hasNoOp = callConfig.no_op === 'ALL' || callConfig.no_op === 'CREATE'\n  return `{ onCompleteAction${hasNoOp ? '?' : ''}: ${getCreateOnCompleteTypes(callConfig)} }`\n}\n\nconst getCreateOnCompleteTypes = (config: CallConfig) => {\n  return Object.keys(config)\n    .map((oc) => oc as keyof CallConfig)\n    .filter((oc) => config[oc] === 'ALL' || config[oc] === 'CREATE')\n    .map((oc) => `'${oc}' | OnApplicationComplete.${pascalCase(oc)}OC`)\n    .join(' | ')\n}\n\nconst addToConfig = (result: CallConfigSummary, method: MethodIdentifier, config: CallConfig) => {", "  if (hasCall(config.no_op)) {\n    result.callMethods.push(method)\n  }\n  if (\n    hasCreate(config.no_op) ||\n    hasCreate(config.opt_in) ||\n    hasCreate(config.close_out) ||\n    hasCreate(config.update_application) ||\n    hasCreate(config.delete_application)\n  ) {\n    result.createMethods.push(method)\n  }", "  if (hasCall(config.delete_application)) {\n    result.deleteMethods.push(method)\n  }\n  if (hasCall(config.update_application)) {\n    result.updateMethods.push(method)\n  }\n  if (hasCall(config.opt_in)) {\n    result.optInMethods.push(method)\n  }\n  if (hasCall(config.close_out)) {\n    result.closeOutMethods.push(method)\n  }\n}\n\nconst hasCall = (config: CallConfigValue | undefined) => {\n  return config === 'CALL' || config === 'ALL'\n}\nconst hasCreate = (config: CallConfigValue | undefined) => {\n  return config === 'CREATE' || config === 'ALL'\n}\n", "  if (hasCall(config.close_out)) {\n    result.closeOutMethods.push(method)\n  }\n}\n\nconst hasCall = (config: CallConfigValue | undefined) => {\n  return config === 'CALL' || config === 'ALL'\n}\nconst hasCreate = (config: CallConfigValue | undefined) => {\n  return config === 'CREATE' || config === 'ALL'\n}\n"]}
{"filename": "src/client/helpers/get-equivalent-type.ts", "chunked_list": ["import {\n  ABIAddressType,\n  ABIArrayDynamicType,\n  ABIArrayStaticType,\n  ABIBoolType,\n  ABIByteType,\n  ABIReferenceType,\n  ABIStringType,\n  ABITupleType,\n  ABIType,", "  ABITupleType,\n  ABIType,\n  ABIUfixedType,\n  ABIUintType,\n  abiTypeIsTransaction,\n} from 'algosdk'\n\nexport function getEquivalentType(abiTypeStr: string, ioType: 'input' | 'output'): string {\n  if (abiTypeStr == 'void') {\n    return 'void'\n  }", "  if (abiTypeStr == 'void') {\n    return 'void'\n  }\n  if (abiTypeIsTransaction(abiTypeStr)) {\n    return 'TransactionToSign | Transaction | Promise<SendTransactionResult>'\n  }\n  if (abiTypeStr == ABIReferenceType.account) {\n    return 'string | Uint8Array'\n  }\n  if (abiTypeStr == ABIReferenceType.application || abiTypeStr == ABIReferenceType.asset) {\n    return 'number | bigint'\n  }\n\n  const abiType = ABIType.from(abiTypeStr)\n\n  return abiTypeToTs(abiType, ioType)\n", "  if (abiTypeStr == ABIReferenceType.application || abiTypeStr == ABIReferenceType.asset) {\n    return 'number | bigint'\n  }\n\n  const abiType = ABIType.from(abiTypeStr)\n\n  return abiTypeToTs(abiType, ioType)\n\n  function abiTypeToTs(abiType: ABIType, ioType: 'input' | 'output'): string {\n    if (abiType instanceof ABIUintType) {\n      if (abiType.bitSize <= 51) return 'number'\n      return ioType === 'input' ? 'bigint | number' : 'bigint'\n    }", "  function abiTypeToTs(abiType: ABIType, ioType: 'input' | 'output'): string {\n    if (abiType instanceof ABIUintType) {\n      if (abiType.bitSize <= 51) return 'number'\n      return ioType === 'input' ? 'bigint | number' : 'bigint'\n    }\n    if (abiType instanceof ABIArrayDynamicType) {\n      if (abiType.childType instanceof ABIByteType) return 'Uint8Array'\n      return `${abiTypeToTs(abiType.childType, ioType)}[]`\n    }\n    if (abiType instanceof ABIArrayStaticType) {\n      if (abiType.childType instanceof ABIByteType) return 'Uint8Array'\n      return `[${new Array(abiType.staticLength).fill(abiTypeToTs(abiType.childType, ioType)).join(', ')}]`\n    }", "    if (abiType instanceof ABIArrayStaticType) {\n      if (abiType.childType instanceof ABIByteType) return 'Uint8Array'\n      return `[${new Array(abiType.staticLength).fill(abiTypeToTs(abiType.childType, ioType)).join(', ')}]`\n    }\n    if (abiType instanceof ABIAddressType) {\n      return 'string'\n    }\n    if (abiType instanceof ABIBoolType) {\n      return 'boolean'\n    }\n    if (abiType instanceof ABIUfixedType) {\n      return 'number'\n    }", "    if (abiType instanceof ABIUfixedType) {\n      return 'number'\n    }\n    if (abiType instanceof ABITupleType) {\n      return `[${abiType.childTypes.map((c) => abiTypeToTs(c, ioType)).join(', ')}]`\n    }\n    if (abiType instanceof ABIByteType) {\n      return 'number'\n    }\n    if (abiType instanceof ABIStringType) {\n      return 'string'\n    }\n    return 'unknown'\n  }\n}\n", "    if (abiType instanceof ABIStringType) {\n      return 'string'\n    }\n    return 'unknown'\n  }\n}\n"]}
{"filename": "src/schema/application.d.ts", "chunked_list": ["/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run json-schema-to-typescript to regenerate this file.\n */\n\n/**\n * @minItems 2\n */\nexport type StructElement = [FieldName, ABIType];", " * @minItems 2\n */\nexport type StructElement = [FieldName, ABIType];\nexport type FieldName = string;\nexport type ABIType = string;\n/**\n * Defines a strategy for obtaining a default value for a given ABI arg.\n */\nexport type DefaultArgument =\n  | {\n      /**\n       * The default value should be fetched by invoking an ABI method\n       */\n      source: \"abi-method\";\n      data: ContractMethod;\n    }\n  | {\n      /**\n       * The default value should be fetched from global state\n       */\n      source: \"global-state\";\n      /**\n       * The key of the state variable\n       */\n      data: string;\n    }\n  | {\n      /**\n       * The default value should be fetched from the local state of the sender user\n       */\n      source: \"local-state\";\n      /**\n       * The key of the state variable\n       */\n      data: string;\n    }\n  | {\n      /**\n       * The default value is a constant.\n       */\n      source: \"constant\";\n      /**\n       * The static default value to use.\n       */\n      data: string | number;\n    };", "export type DefaultArgument =\n  | {\n      /**\n       * The default value should be fetched by invoking an ABI method\n       */\n      source: \"abi-method\";\n      data: ContractMethod;\n    }\n  | {\n      /**\n       * The default value should be fetched from global state\n       */\n      source: \"global-state\";\n      /**\n       * The key of the state variable\n       */\n      data: string;\n    }\n  | {\n      /**\n       * The default value should be fetched from the local state of the sender user\n       */\n      source: \"local-state\";\n      /**\n       * The key of the state variable\n       */\n      data: string;\n    }\n  | {\n      /**\n       * The default value is a constant.\n       */\n      source: \"constant\";\n      /**\n       * The static default value to use.\n       */\n      data: string | number;\n    };", "export type CallConfigValue = \"NEVER\" | \"CALL\" | \"CREATE\" | \"ALL\";\n\nexport interface AlgoAppSpec {\n  hints?: {\n    [k: string]: Hint;\n  };\n  source: AppSources;\n  contract: AbiContract;\n  schema: SchemaSpec;\n  state: StateSchemaSpec;\n  bare_call_config?: CallConfig;\n}", "export interface Hint {\n  read_only?: boolean;\n  structs?: {\n    output?: Struct;\n    [k: string]: Struct;\n  };\n  default_arguments?: {\n    [k: string]: DefaultArgument;\n  };\n  call_config?: CallConfig;\n}", "export interface Struct {\n  name: string;\n  elements: StructElement[];\n}\n/**\n * The contract of the ABI method to invoke.\n */\nexport interface ContractMethod {\n  name: string;\n  args: ContractMethodArg[];\n  desc?: string;\n  returns: {\n    desc?: string;\n    /**\n     * Catch all for fixed length arrays and tuples\n     */\n    type: string;\n  };\n}", "export interface ContractMethodArg {\n  desc?: string;\n  /**\n   * Catch all for fixed length arrays and tuples\n   */\n  type: string;\n  name: string;\n}\nexport interface CallConfig {\n  no_op?: CallConfigValue;\n  opt_in?: CallConfigValue;\n  close_out?: CallConfigValue;\n  update_application?: CallConfigValue;\n  delete_application?: CallConfigValue;\n}", "export interface CallConfig {\n  no_op?: CallConfigValue;\n  opt_in?: CallConfigValue;\n  close_out?: CallConfigValue;\n  update_application?: CallConfigValue;\n  delete_application?: CallConfigValue;\n}\nexport interface AppSources {\n  approval?: string;\n  clear?: string;\n}", "export interface AbiContract {\n  name: string;\n  desc?: string;\n  methods: ContractMethod1[];\n  networks?: {\n    [k: string]: {\n      appID: number;\n    };\n  };\n}\nexport interface ContractMethod1 {\n  name: string;\n  args: ContractMethodArg[];\n  desc?: string;\n  returns: {\n    desc?: string;\n    /**\n     * Catch all for fixed length arrays and tuples\n     */\n    type: string;\n  };\n}\n/**\n * The schema for global and local storage\n */", "export interface ContractMethod1 {\n  name: string;\n  args: ContractMethodArg[];\n  desc?: string;\n  returns: {\n    desc?: string;\n    /**\n     * Catch all for fixed length arrays and tuples\n     */\n    type: string;\n  };\n}\n/**\n * The schema for global and local storage\n */", "export interface SchemaSpec {\n  global?: Schema;\n  local?: Schema;\n}\nexport interface Schema {\n  declared?: {\n    [k: string]: DeclaredSchemaValueSpec;\n  };\n  reserved?: {\n    [k: string]: ReservedSchemaValueSpec;\n  };\n}", "export interface DeclaredSchemaValueSpec {\n  /**\n   * The type of the value\n   */\n  type: \"uint64\" | \"bytes\";\n  /**\n   * The name of the key\n   */\n  key: string;\n  /**\n   * A description of the variable\n   */\n  descr?: string;\n  /**\n   * Whether the value is set statically (at create time only) or dynamically\n   */\n  static?: boolean;\n}", "export interface ReservedSchemaValueSpec {\n  /**\n   * The type of the value\n   */\n  type: \"uint64\" | \"bytes\";\n  /**\n   * A description of the variable\n   */\n  descr?: string;\n  /**\n   * The maximum number of slots to reserve\n   */\n  max_keys?: number;\n  [k: string]: unknown;\n}", "export interface StateSchemaSpec {\n  global: StateSchema;\n  local: StateSchema;\n}\nexport interface StateSchema {\n  num_uints: number;\n  num_byte_slices: number;\n}\n"]}
{"filename": "src/schema/load.ts", "chunked_list": ["import * as fs from 'fs'\nimport { Schema, Validator } from 'jsonschema'\nimport { boom } from '../util/boom'\nimport { AlgoAppSpec } from './application'\nimport appJsonSchema from './application.schema.json'\nimport contractSchema from './contract.schema.json'\n\nexport function load(appJsonPath: string) {\n  if (!fs.existsSync(appJsonPath)) boom(`Could not find application.json file at ${appJsonPath}`)\n  const validator = new Validator()\n  validator.addSchema(contractSchema, '/contract.schema.json')\n\n  const file = JSON.parse(fs.readFileSync(appJsonPath, 'utf-8'))\n  const result = validator.validate(file, appJsonSchema as unknown as Schema)\n", "  if (!fs.existsSync(appJsonPath)) boom(`Could not find application.json file at ${appJsonPath}`)\n  const validator = new Validator()\n  validator.addSchema(contractSchema, '/contract.schema.json')\n\n  const file = JSON.parse(fs.readFileSync(appJsonPath, 'utf-8'))\n  const result = validator.validate(file, appJsonSchema as unknown as Schema)\n\n  if (!result.valid) boom(result.toString())\n\n  return file as AlgoAppSpec\n}\n"]}
