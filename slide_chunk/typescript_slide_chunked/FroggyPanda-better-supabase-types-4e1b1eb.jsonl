{"filename": "example/afterSchema.ts", "chunked_list": ["export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[];\n\nexport interface Database {\n  public: {\n    Tables: {\n      todos: {\n        Row: {\n          id: number;\n          inserted_at: string;\n          is_complete: boolean | null;\n          task: string | null;\n          user_id: string;\n        };\n        Insert: {\n          id?: number;\n          inserted_at?: string;\n          is_complete?: boolean | null;\n          task?: string | null;\n          user_id: string;\n        };\n        Update: {\n          id?: number;\n          inserted_at?: string;\n          is_complete?: boolean | null;\n          task?: string | null;\n          user_id?: string;\n        };\n        Relationships: [\n          {\n            foreignKeyName: 'todos_user_id_fkey';\n            columns: ['user_id'];\n            referencedRelation: 'users';\n            referencedColumns: ['id'];\n          }\n        ];\n      };\n    };\n    Views: {\n      [_ in never]: never;\n    };\n    Functions: {\n      [_ in never]: never;\n    };\n    Enums: {\n      [_ in never]: never;\n    };\n    CompositeTypes: {\n      [_ in never]: never;\n    };\n  };\n}\n\n//Schema: public\n//Tables", "export interface Database {\n  public: {\n    Tables: {\n      todos: {\n        Row: {\n          id: number;\n          inserted_at: string;\n          is_complete: boolean | null;\n          task: string | null;\n          user_id: string;\n        };\n        Insert: {\n          id?: number;\n          inserted_at?: string;\n          is_complete?: boolean | null;\n          task?: string | null;\n          user_id: string;\n        };\n        Update: {\n          id?: number;\n          inserted_at?: string;\n          is_complete?: boolean | null;\n          task?: string | null;\n          user_id?: string;\n        };\n        Relationships: [\n          {\n            foreignKeyName: 'todos_user_id_fkey';\n            columns: ['user_id'];\n            referencedRelation: 'users';\n            referencedColumns: ['id'];\n          }\n        ];\n      };\n    };\n    Views: {\n      [_ in never]: never;\n    };\n    Functions: {\n      [_ in never]: never;\n    };\n    Enums: {\n      [_ in never]: never;\n    };\n    CompositeTypes: {\n      [_ in never]: never;\n    };\n  };\n}\n\n//Schema: public\n//Tables", "export type Todo = Database['public']['Tables']['todos']['Row'];\nexport type InsertTodo = Database['public']['Tables']['todos']['Insert'];\nexport type UpdateTodo = Database['public']['Tables']['todos']['Update'];\n"]}
{"filename": "example/beforeSchema.ts", "chunked_list": ["export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[]\n\nexport interface Database {\n  public: {\n    Tables: {\n      todos: {\n        Row: {\n          id: number\n          inserted_at: string\n          is_complete: boolean | null\n          task: string | null\n          user_id: string\n        }\n        Insert: {\n          id?: number\n          inserted_at?: string\n          is_complete?: boolean | null\n          task?: string | null\n          user_id: string\n        }\n        Update: {\n          id?: number\n          inserted_at?: string\n          is_complete?: boolean | null\n          task?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"todos_user_id_fkey\"\n            columns: [\"user_id\"]\n            referencedRelation: \"users\"\n            referencedColumns: [\"id\"]\n          }\n        ]\n      }\n    }\n    Views: {\n      [_ in never]: never\n    }\n    Functions: {\n      [_ in never]: never\n    }\n    Enums: {\n      [_ in never]: never\n    }\n    CompositeTypes: {\n      [_ in never]: never\n    }\n  }\n}\n", "export interface Database {\n  public: {\n    Tables: {\n      todos: {\n        Row: {\n          id: number\n          inserted_at: string\n          is_complete: boolean | null\n          task: string | null\n          user_id: string\n        }\n        Insert: {\n          id?: number\n          inserted_at?: string\n          is_complete?: boolean | null\n          task?: string | null\n          user_id: string\n        }\n        Update: {\n          id?: number\n          inserted_at?: string\n          is_complete?: boolean | null\n          task?: string | null\n          user_id?: string\n        }\n        Relationships: [\n          {\n            foreignKeyName: \"todos_user_id_fkey\"\n            columns: [\"user_id\"]\n            referencedRelation: \"users\"\n            referencedColumns: [\"id\"]\n          }\n        ]\n      }\n    }\n    Views: {\n      [_ in never]: never\n    }\n    Functions: {\n      [_ in never]: never\n    }\n    Enums: {\n      [_ in never]: never\n    }\n    CompositeTypes: {\n      [_ in never]: never\n    }\n  }\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["#!/usr/bin/env node\nimport yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers';\nimport { generate } from './generate';\nimport { z } from 'zod';\nimport fs from 'fs';\n\nconst configExists = fs.existsSync('.betterrc.json');\nconst prePackageJsonFile = fs.readFileSync('package.json', 'utf-8');\nconst packageJsonFile = JSON.parse(prePackageJsonFile);", "const prePackageJsonFile = fs.readFileSync('package.json', 'utf-8');\nconst packageJsonFile = JSON.parse(prePackageJsonFile);\n\nconst schema = z\n  .object({\n    input: z.string(),\n    output: z.string().optional(),\n    force: z.boolean().optional(),\n    prettier: z.string().optional().default('.prettierrc'),\n    singular: z.boolean().optional().default(false),", "    prettier: z.string().optional().default('.prettierrc'),\n    singular: z.boolean().optional().default(false),\n  })\n  .strict();\n\n// Load config from '.betterrc' file\nif (configExists) {\n  const prefile = fs.readFileSync('.betterrc.json', 'utf-8');\n  const json = JSON.parse(prefile);\n\n  // Check if config is correct\n  const result = schema.safeParse(json);", "  if (!result.success) {\n    console.log('Invalid config file');\n  } else {\n    if (!result.data.output && !result.data.force) {\n      console.log(\n        'It looks like you want to overwrite your input file. Add the force property to do that in your config file.'\n      );\n    } else {\n      const input = result.data.input;\n      const output = result.data.output || result.data.input;\n      const prettier = result.data.prettier;\n      const singular = result.data.singular ?? false;\n\n      generate(input, output, prettier, singular);\n    }\n  }", "} else if (packageJsonFile['betterConfig']) {\n  // Load config from 'package.json' file\n\n  // Check if config is correct\n  const result = schema.safeParse(packageJsonFile['betterConfig']);\n  if (!result.success) {\n    console.log('Invalid config in package.json');\n  } else {\n    if (!result.data.output && !result.data.force) {\n      console.log(\n        'It looks like you want to overwrite your input file. Add the force property to do that in your config file.'\n      );\n    } else {\n      const input = result.data.input;\n      const output = result.data.output || result.data.input;\n      const prettier = result.data.prettier;\n      const singular = result.data.singular ?? false;\n\n      generate(input, output, prettier, singular);\n    }\n  }\n} else {\n  // Load config from command line\n  yargs(hideBin(process.argv))\n    .command(\n      '*',\n      '',\n      (yargs) => {\n        return yargs\n          .options({\n            input: {\n              type: 'string',\n              alias: ['i'],\n              describe: 'Path to the input file',\n              requiresArg: true,\n            },\n            output: {\n              type: 'string',\n              alias: ['o'],\n              describe: 'Path to the output file',\n              requiresArg: true,\n            },\n            prettier: {\n              type: 'string',\n              alias: ['p'],\n              describe: 'Path to the prettier config file',\n              requiresArg: false,\n              default: '.prettierrc',\n            },\n            force: {\n              type: 'boolean',\n              alias: ['f'],\n              describe: 'Force the overwrite of the input file',\n            },\n            singular: {\n              type: 'boolean',\n              alias: ['s'],\n              describe:\n                'Convert table names to singular form instead of plural form',\n              requiresArg: false,\n              default: false,\n            },\n          })\n          .demandOption(['input']);\n      },\n      (argv) => {", "    if (!result.data.output && !result.data.force) {\n      console.log(\n        'It looks like you want to overwrite your input file. Add the force property to do that in your config file.'\n      );\n    } else {\n      const input = result.data.input;\n      const output = result.data.output || result.data.input;\n      const prettier = result.data.prettier;\n      const singular = result.data.singular ?? false;\n\n      generate(input, output, prettier, singular);\n    }\n  }\n} else {\n  // Load config from command line\n  yargs(hideBin(process.argv))\n    .command(\n      '*',\n      '',\n      (yargs) => {\n        return yargs\n          .options({\n            input: {\n              type: 'string',\n              alias: ['i'],\n              describe: 'Path to the input file',\n              requiresArg: true,\n            },\n            output: {\n              type: 'string',\n              alias: ['o'],\n              describe: 'Path to the output file',\n              requiresArg: true,\n            },\n            prettier: {\n              type: 'string',\n              alias: ['p'],\n              describe: 'Path to the prettier config file',\n              requiresArg: false,\n              default: '.prettierrc',\n            },\n            force: {\n              type: 'boolean',\n              alias: ['f'],\n              describe: 'Force the overwrite of the input file',\n            },\n            singular: {\n              type: 'boolean',\n              alias: ['s'],\n              describe:\n                'Convert table names to singular form instead of plural form',\n              requiresArg: false,\n              default: false,\n            },\n          })\n          .demandOption(['input']);\n      },\n      (argv) => {", "        if (!argv.output && !argv.force) {\n          console.error(\n            'It looks like you want to overwrite your input file. Add the force flag to do that.'\n          );\n          return;\n        }\n\n        const input = argv.input;\n        const output = argv.output || argv.input;\n        const prettier = argv.prettier;\n        const singular = argv.singular ?? false;\n\n        generate(input, output, prettier, singular);\n      }\n    )\n    .help()\n    .strict()\n    .parse();\n}\n"]}
{"filename": "src/generate.ts", "chunked_list": ["import fs from 'fs';\nimport {\n  getEnumValuesText,\n  getEnumsProperties,\n  getFunctionReturnTypes,\n  getSchemasProperties,\n  getTablesProperties,\n  prettierFormat,\n  toPascalCase,\n} from './utils';", "  toPascalCase,\n} from './utils';\nimport { ModuleKind, Project, ScriptTarget } from 'ts-morph';\nimport chalk from 'chalk';\n\nexport async function generate(\n  input: string,\n  output: string,\n  prettierConfigPath?: string,\n  makeSingular: boolean = false\n) {\n  const exists = fs.existsSync(input);\n\n  const project = new Project({\n    compilerOptions: {\n      allowSyntheticDefaultImports: true,\n      esModuleInterop: true,\n      module: ModuleKind.ESNext,\n      target: ScriptTarget.ESNext,\n      strictNullChecks: true,\n    },\n  });\n\n  const sourceFile = project.addSourceFileAtPath(input);\n", "  if (!exists) {\n    console.error(`${chalk.red.bold('error')} Input file not found`);\n    return;\n  }\n\n  const types: string[] = [];\n\n  const schemas = getSchemasProperties(project, sourceFile);\n  for (const schema of schemas) {\n    types.push(`// Schema: ${schema.getName()}`);\n\n    const schemaName = schema.getName();\n    const tablesProperties = getTablesProperties(\n      project,\n      sourceFile,\n      schemaName\n    );\n    const enumsProperties = getEnumsProperties(project, sourceFile, schemaName);\n    const functionProperties = getFunctionReturnTypes(\n      project,\n      sourceFile,\n      schemaName\n    );\n", "  for (const schema of schemas) {\n    types.push(`// Schema: ${schema.getName()}`);\n\n    const schemaName = schema.getName();\n    const tablesProperties = getTablesProperties(\n      project,\n      sourceFile,\n      schemaName\n    );\n    const enumsProperties = getEnumsProperties(project, sourceFile, schemaName);\n    const functionProperties = getFunctionReturnTypes(\n      project,\n      sourceFile,\n      schemaName\n    );\n", "    if (enumsProperties.length > 0) {\n      types.push('// Enums');\n    }\n    for (const enumProperty of enumsProperties) {\n      const enumName = enumProperty.getName();\n      const enumNameType = toPascalCase(enumName, makeSingular);\n\n      types.push(\n        `export enum ${enumNameType} {`,\n        ...(getEnumValuesText(enumProperty) ?? []),\n        '}',\n        '\\n'\n      );\n    }\n", "    if (tablesProperties.length > 0) {\n      types.push('// Tables');\n    }\n    for (const table of tablesProperties) {\n      const tableName = table.getName();\n      const tableNameType = toPascalCase(tableName, makeSingular);\n\n      types.push(\n        `export type ${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Row'];`,\n        `export type Insert${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Insert'];`,\n        `export type Update${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Update'];`,\n        '\\n'\n      );\n    }\n", "        `export type Insert${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Insert'];`,\n        `export type Update${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Update'];`,\n        '\\n'\n      );\n    }\n\n    if (functionProperties.length > 0) {\n      types.push('// Functions');\n    }\n    for (const functionProperty of functionProperties) {\n      const functionName = functionProperty.getName();\n      const functionNameType = toPascalCase(functionName, makeSingular);\n\n      types.push(", "    for (const functionProperty of functionProperties) {\n      const functionName = functionProperty.getName();\n      const functionNameType = toPascalCase(functionName, makeSingular);\n\n      types.push(\n        `export type Args${functionNameType} = Database['${schemaName}']['Functions']['${functionName}']['Args'];`,\n        `export type ReturnType${functionNameType} = Database['${schemaName}']['Functions']['${functionName}']['Returns'];`,\n        '\\n'\n      );\n    }\n  }\n\n  const fileContent = fs.readFileSync(input, 'utf-8');\n  let updatedFileContent = fileContent + '\\n' + types.join('\\n') + '\\n';", "  if (prettierConfigPath) {\n    updatedFileContent = await prettierFormat(\n      updatedFileContent,\n      prettierConfigPath\n    );\n  }\n\n  fs.writeFileSync(output, updatedFileContent);\n}\n"]}
{"filename": "src/utils/toPascalCase.ts", "chunked_list": ["import { singular } from 'pluralize';\n\nconst wordToPascalCase = (makeSingular: boolean) => (word: string) => {\n  const singularWord = makeSingular ? singular(word) : word;\n  return singularWord.charAt(0).toUpperCase() + singularWord.substring(1);\n}\n\nexport function toPascalCase(str: string, makeSingular: boolean = false) {\n  return str\n    .split('_')\n    .map(wordToPascalCase(makeSingular))\n    .join('');\n}\n\n"]}
{"filename": "src/utils/getSchemasProperties.ts", "chunked_list": ["import { Project, SourceFile } from 'ts-morph';\n\nexport function getSchemasProperties(project: Project, sourceFile: SourceFile) {\n  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n\n  const schemasType = project\n    .getProgram()\n    .getTypeChecker()\n    .getTypeAtLocation(databaseInterface);\n  const schemasProperties = schemasType.getProperties();\n", "  if (schemasProperties.length < 1)\n    throw new Error('No schemas found within the Database property.');\n\n  return schemasProperties;\n}\n"]}
{"filename": "src/utils/getEnumsProperties.ts", "chunked_list": ["import { LiteralTypeNode, Project, SourceFile, ts } from 'ts-morph';\nimport { toCamelCase } from './toCamelCase';\nimport chalk from 'chalk';\n\nexport function getEnumsProperties(\n  project: Project,\n  sourceFile: SourceFile,\n  schema: string\n) {\n  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n  const publicProperty = databaseInterface.getPropertyOrThrow(schema);\n  const publicType = publicProperty.getType();\n\n  const enumsProperty = publicType\n    .getApparentProperties()\n    .find((property) => property.getName() === 'Enums');\n", "  if (!enumsProperty) {\n    console.log(\n      `${chalk.yellow.bold(\n        'warn'\n      )} No Enums property found within the Database interface for schema ${schema}.`\n    );\n    return [];\n  }\n\n  const enumsType = project\n    .getProgram()\n    .getTypeChecker()\n    .getTypeAtLocation(enumsProperty.getValueDeclarationOrThrow());\n  const enumsProperties = enumsType.getProperties();\n", "  if (enumsProperties.length < 1) {\n    console.log(\n      `${chalk.yellow.bold(\n        'warn'\n      )} No enums found within the Enums property for schema ${schema}.`\n    );\n    return [];\n  }\n\n  return enumsProperties;\n}\n", "function getEnumValueLabel(value: LiteralTypeNode) {\n  let enumValue = value.getText().replace(/\"/g, '');\n  if (enumValue.includes(' ')) {\n    enumValue.replace(/ /g, '_');\n  }\n  if (enumValue.includes('-')) {\n    enumValue.replace(/-/g, '_');\n  }\n  if (enumValue.includes('.')) {\n    enumValue = toCamelCase(enumValue, '.');\n  }\n  return enumValue;\n}\n", "  if (enumValue.includes('.')) {\n    enumValue = toCamelCase(enumValue, '.');\n  }\n  return enumValue;\n}\n\nfunction getEnumValueText(value: LiteralTypeNode) {\n  return value.getText();\n}\n\nexport function getEnumValuesText(\n  enumProperty: ReturnType<typeof getEnumsProperties>[number]\n) {\n  const enumValues = enumProperty\n    .getValueDeclarationOrThrow()\n    .getChildrenOfKind(ts.SyntaxKind.UnionType)\n    .flatMap((enumValue) =>\n      enumValue.getChildrenOfKind(ts.SyntaxKind.LiteralType)\n    );\n\n  return enumValues.map(\n    (value) => `  ${getEnumValueLabel(value)} = ${getEnumValueText(value)},`\n  );\n}\n", "export function getEnumValuesText(\n  enumProperty: ReturnType<typeof getEnumsProperties>[number]\n) {\n  const enumValues = enumProperty\n    .getValueDeclarationOrThrow()\n    .getChildrenOfKind(ts.SyntaxKind.UnionType)\n    .flatMap((enumValue) =>\n      enumValue.getChildrenOfKind(ts.SyntaxKind.LiteralType)\n    );\n\n  return enumValues.map(\n    (value) => `  ${getEnumValueLabel(value)} = ${getEnumValueText(value)},`\n  );\n}\n"]}
{"filename": "src/utils/getTablesProperties.ts", "chunked_list": ["import chalk from 'chalk';\nimport { Project, SourceFile } from 'ts-morph';\n\nexport function getTablesProperties(\n  project: Project,\n  sourceFile: SourceFile,\n  schema: string\n) {\n  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n  const publicProperty = databaseInterface.getPropertyOrThrow(schema);\n  const publicType = publicProperty.getType();\n\n  const tablesProperty = publicType\n    .getApparentProperties()\n    .find((property) => property.getName() === 'Tables');\n", "  if (!tablesProperty) {\n    console.log(\n      `${chalk.yellow.bold(\n        'warn'\n      )} No Tables property found within the Database interface for schema ${schema}.`\n    );\n    return [];\n  }\n\n  const tablesType = project\n    .getProgram()\n    .getTypeChecker()\n    .getTypeAtLocation(tablesProperty.getValueDeclarationOrThrow());\n  const tablesProperties = tablesType.getProperties();\n", "  if (tablesProperties.length < 1) {\n    console.log(\n      `${chalk.yellow.bold(\n        'warn'\n      )} No tables found within the Tables property for schema ${schema}.`\n    );\n    return [];\n  }\n\n  return tablesProperties;\n}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export * from './getEnumsProperties';\nexport * from './getSchemasProperties';\nexport * from './getTablesProperties';\nexport * from './getFunctionProperties';\nexport * from './prettierFormat';\nexport * from './toPascalCase';\n"]}
{"filename": "src/utils/prettierFormat.ts", "chunked_list": ["import { format, resolveConfig } from 'prettier';\n\nexport async function prettierFormat(fileContent: string, configPath: string): Promise<string> {\n  const prettierConfig = await resolveConfig(configPath);\n\n  const formattedFileContent = format(fileContent, {\n    parser: 'typescript',\n    ...(prettierConfig || {}),\n  });\n\n  return formattedFileContent;\n}\n"]}
{"filename": "src/utils/toCamelCase.ts", "chunked_list": ["export function toCamelCase(str: string, delimiter: string = '-') {\n  const pattern = new RegExp(('\\\\' + delimiter + '([a-z])'), 'g')\n  return str.replace(pattern, (match, capture) => capture.toUpperCase())\n}"]}
{"filename": "src/utils/getFunctionProperties.ts", "chunked_list": ["import chalk from 'chalk';\nimport { Project, SourceFile } from 'ts-morph';\n\nexport function getFunctionReturnTypes(\n  project: Project,\n  sourceFile: SourceFile,\n  schema: string\n) {\n  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n  const publicProperty = databaseInterface.getPropertyOrThrow(schema);\n  const publicType = publicProperty.getType();\n\n  const functionProperty = publicType\n    .getApparentProperties()\n    .find((property) => property.getName() === 'Functions');\n", "  if (!functionProperty) {\n    console.log(\n      `${chalk.yellow.bold(\n        'warn'\n      )} No Functions property found within the Database interface for schema ${schema}.`\n    );\n    return [];\n  }\n\n  const functionType = project\n    .getProgram()\n    .getTypeChecker()\n    .getTypeAtLocation(functionProperty.getValueDeclarationOrThrow());\n  const functionProperties = functionType.getProperties();\n", "  if (functionProperties.length < 1) {\n    console.log(\n      `${chalk.yellow.bold(\n        'warn'\n      )} No functions found within the Functions property for schema ${schema}.`\n    );\n    return [];\n  }\n\n  return functionProperties;\n}\n"]}
