{"filename": "dist/Storage.d.ts", "chunked_list": ["import { serverFeatureType, accFeatureType, weightsType } from \"./types\";\nimport { mastodon } from \"masto\";\nexport declare enum Key {\n    TOP_FAVS = \"favs\",\n    TOP_REBLOGS = \"reblogs\",\n    TOP_INTERACTS = \"interacts\",\n    CORE_SERVER = \"coreServer\",\n    USER = \"algouser\",\n    WEIGHTS = \"weights\",\n    OPENINGS = \"openings\"\n}", "type StorageValue = serverFeatureType | accFeatureType | mastodon.v1.Account | weightsType | string;\nexport default class Storage {\n    protected static get(key: Key, groupedByUser?: boolean, suffix?: string): Promise<StorageValue>;\n    protected static set(key: Key, value: StorageValue, groupedByUser?: boolean, suffix?: string): Promise<void>;\n    static suffix(key: Key, suffix: any): string;\n    protected static remove(key: Key, groupedByUser?: boolean, suffix?: string): Promise<void>;\n    protected static prefix(key: string): Promise<string>;\n    static logOpening(): Promise<void>;\n    static getOpenings(): Promise<number>;\n    static getIdentity(): Promise<mastodon.v1.Account>;\n    static setIdentity(user: mastodon.v1.Account): Promise<void>;\n}\nexport {};\n"]}
{"filename": "dist/types.d.ts", "chunked_list": ["import { mastodon } from 'masto';\nexport interface weightsType {\n    [key: string]: number;\n}\nexport type accFeatureType = {\n    [key: mastodon.v1.Account[\"acct\"]]: number;\n};\nexport type serverFeatureType = {\n    [key: mastodon.v1.Instance[\"uri\"]]: number;\n};\nexport interface StatusType extends mastodon.v1.Status {\n    topPost?: boolean;\n    scores?: weightsType;\n    value?: number;\n    reblog?: StatusType;\n    reblogBy?: string;\n}", "export interface StatusType extends mastodon.v1.Status {\n    topPost?: boolean;\n    scores?: weightsType;\n    value?: number;\n    reblog?: StatusType;\n    reblogBy?: string;\n}\nexport type FeedFetcher = (api: mastodon.Client) => Promise<StatusType[]>;\nexport type Scorer = (api: mastodon.Client, status: StatusType) => number;\n", "export type Scorer = (api: mastodon.Client, status: StatusType) => number;\n"]}
{"filename": "dist/index.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { FeedFetcher, StatusType, weightsType } from \"./types\";\nimport { favsFeatureScorer, interactsFeatureScorer, reblogsFeatureScorer, diversityFeedScorer, reblogsFeedScorer, FeatureScorer, FeedScorer, topPostFeatureScorer } from \"./scorer\";\nimport getHomeFeed from \"./feeds/homeFeed\";\nexport default class TheAlgorithm {\n    user: mastodon.v1.Account;\n    fetchers: (typeof getHomeFeed)[];\n    featureScorer: (favsFeatureScorer | interactsFeatureScorer | reblogsFeatureScorer | topPostFeatureScorer)[];\n    feedScorer: (diversityFeedScorer | reblogsFeedScorer)[];\n    feed: StatusType[];\n    api: mastodon.Client;\n    constructor(api: mastodon.Client, user: mastodon.v1.Account, valueCalculator?: (((scores: weightsType) => Promise<number>) | null));\n    getFeedAdvanced(fetchers: Array<FeedFetcher>, featureScorer: Array<FeatureScorer>, feedScorer: Array<FeedScorer>): Promise<StatusType[]>;\n    getFeed(): Promise<StatusType[]>;\n    private _getScoreObj;\n    private _getValueFromScores;\n    getWeightNames(): string[];\n    setDefaultWeights(): Promise<void>;\n    getWeightDescriptions(): string[];\n    getWeights(): Promise<weightsType>;\n    setWeights(weights: weightsType): Promise<StatusType[]>;\n    getDescription(verboseName: string): string;\n    weightAdjust(statusWeights: weightsType): Promise<weightsType | undefined>;\n}\n"]}
{"filename": "dist/Paginator.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { StatusType } from \"./types\";\nexport declare class StaticArrayPaginator implements AsyncIterableIterator<StatusType[]> {\n    private currentIndex;\n    private pageSize;\n    private dataArray;\n    private algo;\n    constructor(api: mastodon.Client, user: mastodon.v1.Account, pageSize?: number);\n    next(): Promise<IteratorResult<StatusType[]>>;\n    [Symbol.asyncIterator](): this;\n}\n"]}
{"filename": "dist/features/favsFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { accFeatureType } from \"../types\";\nexport default function favFeature(api: mastodon.Client): Promise<accFeatureType>;\n"]}
{"filename": "dist/features/FeatureStore.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { serverFeatureType, accFeatureType } from \"../types\";\nimport Storage from \"../Storage\";\nexport default class FeatureStorage extends Storage {\n    static getTopFavs(api: mastodon.Client): Promise<accFeatureType>;\n    static getTopReblogs(api: mastodon.Client): Promise<accFeatureType>;\n    static getTopInteracts(api: mastodon.Client): Promise<accFeatureType>;\n    static getCoreServer(api: mastodon.Client): Promise<serverFeatureType>;\n}\n"]}
{"filename": "dist/features/reblogsFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nexport default function getReblogsFeature(api: mastodon.Client): Promise<any>;\n"]}
{"filename": "dist/features/interactsFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { accFeatureType } from \"../types\";\nexport default function interactFeature(api: mastodon.Client): Promise<accFeatureType>;\n"]}
{"filename": "dist/features/coreServerFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { serverFeatureType } from \"../types\";\nexport default function coreServerFeature(api: mastodon.Client, user: mastodon.v1.Account): Promise<serverFeatureType>;\n"]}
{"filename": "dist/weights/weightsStore.d.ts", "chunked_list": ["import { weightsType } from \"../types\";\nimport Storage from \"../Storage\";\nexport default class weightsStore extends Storage {\n    static getWeight(verboseName: string): Promise<weightsType>;\n    static setWeights(weights: weightsType, verboseName: string): Promise<void>;\n    static getWeightsMulti(verboseNames: string[]): Promise<weightsType>;\n    static setWeightsMulti(weights: weightsType): Promise<void>;\n    static defaultFallback(verboseName: string, defaultWeight: number): Promise<boolean>;\n}\n"]}
{"filename": "dist/scorer/index.d.ts", "chunked_list": ["import favsFeatureScorer from \"./feature/favsFeatureScorer\";\nimport interactsFeatureScorer from \"./feature/interactsFeatureScorer\";\nimport reblogsFeatureScorer from \"./feature/reblogsFeatureScorer\";\nimport topPostFeatureScorer from \"./feature/topPostFeatureScorer\";\nimport diversityFeedScorer from \"./feed/diversityFeedScorer\";\nimport reblogsFeedScorer from \"./feed/reblogsFeedScorer\";\nimport FeedScorer from \"./FeedScorer\";\nimport FeatureScorer from \"./FeatureScorer\";\nexport { favsFeatureScorer, interactsFeatureScorer, reblogsFeatureScorer, topPostFeatureScorer, diversityFeedScorer, reblogsFeedScorer, FeedScorer, FeatureScorer };\n", "export { favsFeatureScorer, interactsFeatureScorer, reblogsFeatureScorer, topPostFeatureScorer, diversityFeedScorer, reblogsFeedScorer, FeedScorer, FeatureScorer };\n"]}
{"filename": "dist/scorer/FeedScorer.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { StatusType } from \"../types\";\nexport default class FeedScorer {\n    private _verboseName;\n    private _isReady;\n    private _description;\n    private _defaultWeight;\n    features: any;\n    constructor(verboseName: string, description?: string, defaultWeight?: number);\n    setFeed(feed: StatusType[]): Promise<void>;\n    feedExtractor(feed: StatusType[]): any;\n    score(status: mastodon.v1.Status): Promise<number>;\n    getVerboseName(): string;\n    getDescription(): string;\n    getDefaultWeight(): number;\n}\n"]}
{"filename": "dist/scorer/FeatureScorer.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { StatusType, accFeatureType } from \"../types\";\ninterface RankParams {\n    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n    verboseName: string;\n    description?: string;\n    defaultWeight?: number;\n}\nexport default class FeatureScorer {\n    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n    private _verboseName;\n    private _isReady;\n    private _description;\n    feature: accFeatureType;\n    private _defaultWeight;\n    constructor(params: RankParams);\n    getFeature(api: mastodon.Client): Promise<void>;\n    score(api: mastodon.Client, status: StatusType): Promise<number>;\n    getVerboseName(): string;\n    getDescription(): string;\n    getDefaultWeight(): number;\n}\nexport {};\n", "export default class FeatureScorer {\n    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n    private _verboseName;\n    private _isReady;\n    private _description;\n    feature: accFeatureType;\n    private _defaultWeight;\n    constructor(params: RankParams);\n    getFeature(api: mastodon.Client): Promise<void>;\n    score(api: mastodon.Client, status: StatusType): Promise<number>;\n    getVerboseName(): string;\n    getDescription(): string;\n    getDefaultWeight(): number;\n}\nexport {};\n"]}
{"filename": "dist/scorer/feed/diversityFeedScorer.d.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\nimport { StatusType } from \"../../types\";\nexport default class diversityFeedScorer extends FeedScorer {\n    constructor();\n    feedExtractor(feed: StatusType[]): any;\n    score(status: StatusType): Promise<any>;\n}\n"]}
{"filename": "dist/scorer/feed/reblogsFeedScorer.d.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\nimport { StatusType } from \"../../types\";\nexport default class reblogsFeedScorer extends FeedScorer {\n    constructor();\n    feedExtractor(feed: StatusType[]): any;\n    score(status: StatusType): Promise<any>;\n}\n"]}
{"filename": "dist/scorer/feature/favsFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer';\nimport { StatusType } from '../../types';\nimport { mastodon } from 'masto';\nexport default class favsFeatureScorer extends FeatureScorer {\n    constructor();\n    score(api: mastodon.Client, status: StatusType): Promise<number>;\n}\n"]}
{"filename": "dist/scorer/feature/topPostFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer';\nimport { StatusType } from \"../../types\";\nimport { mastodon } from \"masto\";\nexport default class topPostFeatureScorer extends FeatureScorer {\n    constructor();\n    score(api: mastodon.Client, status: StatusType): Promise<0 | 1>;\n}\n"]}
{"filename": "dist/scorer/feature/reblogsFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\nimport { StatusType } from \"../../types\";\nimport { mastodon } from \"masto\";\nexport default class reblogsFeatureScorer extends FeatureScorer {\n    constructor();\n    score(api: mastodon.Client, status: StatusType): Promise<number>;\n}\n"]}
{"filename": "dist/scorer/feature/interactsFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\nimport { StatusType } from \"../../types\";\nimport { mastodon } from \"masto\";\nexport default class interactsFeatureScorer extends FeatureScorer {\n    constructor();\n    score(api: mastodon.Client, status: StatusType): Promise<number>;\n}\n"]}
{"filename": "dist/feeds/homeFeed.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nexport default function getHomeFeed(api: mastodon.Client, user: mastodon.v1.Account): Promise<any[]>;\n"]}
{"filename": "dist/feeds/topPostsFeed.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\nexport default function getTopPostFeed(api: mastodon.Client): Promise<mastodon.v1.Status[]>;\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { mastodon } from 'masto';\n\nexport interface weightsType {\n    [key: string]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n}\n\nexport type accFeatureType = {\n    [key: mastodon.v1.Account[\"acct\"]]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n}\n\nexport type serverFeatureType = {\n    [key: mastodon.v1.Instance[\"uri\"]]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n}\n", "export type serverFeatureType = {\n    [key: mastodon.v1.Instance[\"uri\"]]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n}\n\nexport interface StatusType extends mastodon.v1.Status {\n    topPost?: boolean;\n    scores?: weightsType;\n    value?: number;\n    reblog?: StatusType;\n    reblogBy?: string;\n}\n", "export type FeedFetcher = (api: mastodon.Client) => Promise<StatusType[]>;\nexport type Scorer = (api: mastodon.Client, status: StatusType) => number;"]}
{"filename": "src/index.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { FeedFetcher, Scorer, StatusType, weightsType } from \"./types\";\nimport {\n    favsFeatureScorer,\n    interactsFeatureScorer,\n    reblogsFeatureScorer,\n    diversityFeedScorer,\n    reblogsFeedScorer,\n    FeatureScorer,\n    FeedScorer,", "    FeatureScorer,\n    FeedScorer,\n    topPostFeatureScorer\n} from \"./scorer\";\nimport weightsStore from \"./weights/weightsStore\";\nimport getHomeFeed from \"./feeds/homeFeed\";\nimport topPostsFeed from \"./feeds/topPostsFeed\";\nimport Storage from \"./Storage\";\nimport { StaticArrayPaginator } from \"./Paginator\"\n\nexport default class TheAlgorithm {\n    user: mastodon.v1.Account;\n    fetchers = [getHomeFeed, topPostsFeed]\n    featureScorer = [new favsFeatureScorer(), new reblogsFeatureScorer(), new interactsFeatureScorer(), new topPostFeatureScorer()]\n    feedScorer = [new reblogsFeedScorer(), new diversityFeedScorer()]\n    feed: StatusType[] = [];\n    api: mastodon.Client;\n    constructor(api: mastodon.Client, user: mastodon.v1.Account, valueCalculator: (((scores: weightsType) => Promise<number>) | null) = null) {\n        this.api = api;\n        this.user = user;\n        Storage.setIdentity(user);\n        Storage.logOpening();", "import { StaticArrayPaginator } from \"./Paginator\"\n\nexport default class TheAlgorithm {\n    user: mastodon.v1.Account;\n    fetchers = [getHomeFeed, topPostsFeed]\n    featureScorer = [new favsFeatureScorer(), new reblogsFeatureScorer(), new interactsFeatureScorer(), new topPostFeatureScorer()]\n    feedScorer = [new reblogsFeedScorer(), new diversityFeedScorer()]\n    feed: StatusType[] = [];\n    api: mastodon.Client;\n    constructor(api: mastodon.Client, user: mastodon.v1.Account, valueCalculator: (((scores: weightsType) => Promise<number>) | null) = null) {\n        this.api = api;\n        this.user = user;\n        Storage.setIdentity(user);\n        Storage.logOpening();", "        if (valueCalculator) {\n            this._getValueFromScores = valueCalculator;\n        }\n        this.setDefaultWeights();\n    }\n\n    async getFeedAdvanced(\n        fetchers: Array<FeedFetcher>,\n        featureScorer: Array<FeatureScorer>,\n        feedScorer: Array<FeedScorer>\n    ) {\n        this.fetchers = fetchers;\n        this.featureScorer = featureScorer;\n        this.feedScorer = feedScorer;\n        return this.getFeed();\n    }\n\n    async getFeed(): Promise<StatusType[]> {\n        const { fetchers, featureScorer, feedScorer } = this;\n        const response = await Promise.all(fetchers.map(fetcher => fetcher(this.api, this.user)))\n        this.feed = response.flat();\n\n        // Load and Prepare Features\n        await Promise.all(featureScorer.map(scorer => scorer.getFeature(this.api)));\n        await Promise.all(feedScorer.map(scorer => scorer.setFeed(this.feed)));\n\n        // Get Score Names\n        const scoreNames = featureScorer.map(scorer => scorer.getVerboseName());\n        const feedScoreNames = feedScorer.map(scorer => scorer.getVerboseName());\n\n        // Score Feed\n        let scoredFeed: StatusType[] = []", "        for (const status of this.feed) {\n            // Load Scores for each status\n            const featureScore = await Promise.all(featureScorer.map(scorer => scorer.score(this.api, status)));\n            const feedScore = await Promise.all(feedScorer.map(scorer => scorer.score(status)));\n\n            // Turn Scores into Weight Objects\n            const featureScoreObj = this._getScoreObj(scoreNames, featureScore);\n            const feedScoreObj = this._getScoreObj(feedScoreNames, feedScore);\n            const scoreObj = { ...featureScoreObj, ...feedScoreObj };\n\n            // Add Weight Object to Status\n            status[\"scores\"] = scoreObj;\n            status[\"value\"] = await this._getValueFromScores(scoreObj);\n            scoredFeed.push(status);\n        }\n\n        // Remove Replies, Stuff Already Retweeted, and Nulls\n        scoredFeed = scoredFeed\n            .filter((item: StatusType) => item != undefined)\n            .filter((item: StatusType) => item.inReplyToId === null)\n            .filter((item: StatusType) => item.content.includes(\"RT @\") === false)\n            .filter((item: StatusType) => !(item?.reblog?.reblogged ?? false))\n\n\n        // Add Time Penalty\n        scoredFeed = scoredFeed.map((item: StatusType) => {\n            const seconds = Math.floor((new Date().getTime() - new Date(item.createdAt).getTime()) / 1000);\n            const timediscount = Math.pow((1 + 0.7 * 0.2), -Math.pow((seconds / 3600), 2));\n            item.value = (item.value ?? 0) * timediscount\n            return item;\n        })\n\n        // Sort Feed\n        scoredFeed = scoredFeed.sort((a, b) => (b.value ?? 0) - (a.value ?? 0));\n\n        //Remove duplicates\n        scoredFeed = [...new Map(scoredFeed.map((item: StatusType) => [item[\"uri\"], item])).values()];\n\n        this.feed = scoredFeed\n        console.log(this.feed);\n        return this.feed;\n    }\n\n    private _getScoreObj(scoreNames: string[], scores: number[]): weightsType {\n        return scoreNames.reduce((obj: weightsType, cur, i) => {\n            obj[cur] = scores[i];\n            return obj;\n        }, {});\n    }\n\n    private async _getValueFromScores(scores: weightsType): Promise<number> {\n        const weights = await weightsStore.getWeightsMulti(Object.keys(scores));\n        const weightedScores = Object.keys(scores).reduce((obj: number, cur) => {\n            obj = obj + (scores[cur] * weights[cur] ?? 0)\n            return obj;\n        }, 0);\n        return weightedScores;\n    }\n\n    getWeightNames(): string[] {\n        const scorers = [...this.featureScorer, ...this.feedScorer];\n        return [...scorers.map(scorer => scorer.getVerboseName())]\n    }\n\n    async setDefaultWeights(): Promise<void> {\n        //Set Default Weights if they don't exist\n        const scorers = [...this.featureScorer, ...this.feedScorer];\n        Promise.all(scorers.map(scorer => weightsStore.defaultFallback(scorer.getVerboseName(), scorer.getDefaultWeight())))\n    }\n\n    getWeightDescriptions(): string[] {\n        const scorers = [...this.featureScorer, ...this.feedScorer];\n        return [...scorers.map(scorer => scorer.getDescription())]\n    }\n\n    async getWeights(): Promise<weightsType> {\n        const verboseNames = this.getWeightNames();\n        const weights = await weightsStore.getWeightsMulti(verboseNames);\n        return weights;\n    }\n\n    async setWeights(weights: weightsType): Promise<StatusType[]> {\n        await weightsStore.setWeightsMulti(weights);\n        const scoredFeed: StatusType[] = []", "        for (const status of this.feed) {\n            if (!status[\"scores\"]) {\n                return this.getFeed();\n            }\n            status[\"value\"] = await this._getValueFromScores(status[\"scores\"]);\n            scoredFeed.push(status);\n        }\n        this.feed = scoredFeed.sort((a, b) => (b.value ?? 0) - (a.value ?? 0));\n        return this.feed;\n    }\n\n    getDescription(verboseName: string): string {\n        const scorers = [...this.featureScorer, ...this.feedScorer];\n        const scorer = scorers.find(scorer => scorer.getVerboseName() === verboseName);", "        if (scorer) {\n            return scorer.getDescription();\n        }\n        return \"\";\n    }\n\n    async weightAdjust(statusWeights: weightsType): Promise<weightsType | undefined> {\n        //Adjust Weights based on user interaction\n        if (statusWeights == undefined) return;\n        const mean = Object.values(statusWeights).reduce((accumulator, currentValue) => accumulator + Math.abs(currentValue), 0) / Object.values(statusWeights).length;\n        const currentWeight: weightsType = await this.getWeights()\n        const currentMean = Object.values(currentWeight).reduce((accumulator, currentValue) => accumulator + currentValue, 0) / Object.values(currentWeight).length;", "        if (statusWeights == undefined) return;\n        const mean = Object.values(statusWeights).reduce((accumulator, currentValue) => accumulator + Math.abs(currentValue), 0) / Object.values(statusWeights).length;\n        const currentWeight: weightsType = await this.getWeights()\n        const currentMean = Object.values(currentWeight).reduce((accumulator, currentValue) => accumulator + currentValue, 0) / Object.values(currentWeight).length;\n        for (let key in currentWeight) {\n            let reweight = 1 - (Math.abs(statusWeights[key]) / mean) / (currentWeight[key] / currentMean);\n            currentWeight[key] = currentWeight[key] + 0.02 * currentWeight[key] * reweight;\n            console.log(reweight);\n        }\n        await this.setWeights(currentWeight);\n        return currentWeight;\n    }\n}"]}
{"filename": "src/Storage.ts", "chunked_list": ["import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { serverFeatureType, accFeatureType, weightsType } from \"./types\";\nimport { mastodon } from \"masto\";\n\nexport enum Key {\n    TOP_FAVS = 'favs',\n    TOP_REBLOGS = 'reblogs',\n    TOP_INTERACTS = 'interacts',\n    CORE_SERVER = 'coreServer',\n    USER = 'algouser',\n    WEIGHTS = 'weights',\n    OPENINGS = \"openings\",\n}\n", "type StorageValue = serverFeatureType | accFeatureType | mastodon.v1.Account | weightsType | string\n\n\nexport default class Storage {\n    protected static async get(key: Key, groupedByUser = true, suffix = \"\"): Promise<StorageValue> {\n        const suffixKey = this.suffix(key, suffix);\n        const storageKey = groupedByUser ? await this.prefix(suffixKey) : suffixKey;\n        const jsonValue = await AsyncStorage.getItem(storageKey);\n        const value = jsonValue != null ? JSON.parse(jsonValue) : null;\n        return value != null ? value[storageKey] : null;\n    }\n\n    protected static async set(key: Key, value: StorageValue, groupedByUser = true, suffix = \"\") {\n        const suffixKey = this.suffix(key, suffix);\n        const storageKey = groupedByUser ? await this.prefix(suffixKey) : suffixKey;\n        const jsonValue = JSON.stringify({ [storageKey]: value })\n        await AsyncStorage.setItem(storageKey, jsonValue);\n    }\n\n    static suffix(key: Key, suffix: any) {", "        if (suffix === \"\") return key;\n        return `${key}_${suffix}`;\n    }\n\n    protected static async remove(key: Key, groupedByUser = true, suffix = \"\") {\n        const suffixKey = this.suffix(key, suffix);\n        const storageKey = groupedByUser ? await Storage.prefix(suffixKey) : suffixKey;\n        await AsyncStorage.removeItem(storageKey);\n    }\n\n    protected static async prefix(key: string) {\n        const user = await this.getIdentity();\n        return `${user.id}_${key}`;\n    }\n\n    static async logOpening() {\n        console.log(\"Logging Opening\")\n        const openings = parseInt(await this.get(Key.OPENINGS, true) as string);\n", "        if (openings == null || isNaN(openings)) {\n            await this.set(Key.OPENINGS, \"1\", true);\n        } else {\n            await this.set(Key.OPENINGS, (openings + 1).toString(), true);\n        }\n    }\n\n    static async getOpenings() {\n        const openings = parseInt(await this.get(Key.OPENINGS, true) as string);\n        return openings;\n    }\n\n    static async getIdentity(): Promise<mastodon.v1.Account> {\n        const userJson = await AsyncStorage.getItem(Key.USER);\n        const user: mastodon.v1.Account = userJson != null ? JSON.parse(userJson) : null;\n        return user;\n    }\n\n    static async setIdentity(user: mastodon.v1.Account) {\n        const userJson = JSON.stringify(user);\n        await AsyncStorage.setItem(Key.USER, userJson);\n    }\n}"]}
{"filename": "src/Paginator.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport TheAlgorithm from \"./index\";\nimport { StatusType } from \"./types\";\n\ninterface PaginationResult<StatusType> {\n    data: StatusType[];\n    hasNextPage: boolean;\n}\n\nexport class StaticArrayPaginator implements AsyncIterableIterator<StatusType[]> {\n    private currentIndex: number = 0;\n    private pageSize: number;\n    private dataArray: StatusType[] = [];\n    private algo: TheAlgorithm;\n\n    constructor(api: mastodon.Client, user: mastodon.v1.Account, pageSize: number = 10) {\n        this.algo = new TheAlgorithm(api, user);\n        this.pageSize = pageSize;\n    }\n\n    async next(): Promise<IteratorResult<StatusType[]>> {", "export class StaticArrayPaginator implements AsyncIterableIterator<StatusType[]> {\n    private currentIndex: number = 0;\n    private pageSize: number;\n    private dataArray: StatusType[] = [];\n    private algo: TheAlgorithm;\n\n    constructor(api: mastodon.Client, user: mastodon.v1.Account, pageSize: number = 10) {\n        this.algo = new TheAlgorithm(api, user);\n        this.pageSize = pageSize;\n    }\n\n    async next(): Promise<IteratorResult<StatusType[]>> {", "        if (this.dataArray.length == 0) {\n            this.dataArray = await this.algo.getFeed();\n        }\n        const data: StatusType[] = [];\n        let hasNextPage = false;\n\n        const startIndex = this.currentIndex;\n        const endIndex = this.currentIndex + this.pageSize;\n        const currentData = this.dataArray.slice(startIndex, endIndex);\n\n        currentData.forEach((item) => data.push(item));\n", "        if (endIndex < this.dataArray.length) {\n            hasNextPage = true;\n        }\n\n        this.currentIndex += this.pageSize;\n\n        return {\n            done: !hasNextPage,\n            value: data as StatusType[]\n        };\n    }\n\n    [Symbol.asyncIterator]() {\n        return this\n    }\n}"]}
{"filename": "src/features/coreServerFeature.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { serverFeatureType } from \"../types\";\n\nexport default async function coreServerFeature(api: mastodon.Client, user: mastodon.v1.Account): Promise<serverFeatureType> {\n    let results: mastodon.v1.Account[] = [];\n    let pages = 10;\n    for await (const page of api.v1.accounts.listFollowing(user.id, { limit: 80 })) {\n        results = results.concat(page)\n        pages--;\n        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const serverFrequ = results.reduce((accumulator: serverFeatureType, follower: mastodon.v1.Account) => {\n        const server = follower.url.split(\"@\")[0].split(\"https://\")[1];", "        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const serverFrequ = results.reduce((accumulator: serverFeatureType, follower: mastodon.v1.Account) => {\n        const server = follower.url.split(\"@\")[0].split(\"https://\")[1];\n        if (server in accumulator) {\n            accumulator[server] += 1;\n        } else {\n            accumulator[server] = 1;\n        }\n        return accumulator\n    }, {})\n\n    return serverFrequ;\n}"]}
{"filename": "src/features/interactsFeature.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { accFeatureType } from \"../types\";\n\nexport default async function interactFeature(api: mastodon.Client): Promise<accFeatureType> {\n    let results: any[] = [];\n    let pages = 3;\n    for await (const page of api.v1.notifications.list({ limit: 80 })) {\n        results = results.concat(page)\n        pages--;\n        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const interactFrequ = results.reduce((accumulator: any, status: mastodon.v1.Status,) => {", "        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const interactFrequ = results.reduce((accumulator: any, status: mastodon.v1.Status,) => {\n        if (!status.account) return accumulator;\n        if (status.account.acct in accumulator) {\n            accumulator[status.account.acct] += 1;\n        } else {\n            accumulator[status.account.acct] = 1;\n        }\n\n        return accumulator\n    }, {})\n\n    return interactFrequ;\n}"]}
{"filename": "src/features/FeatureStore.ts", "chunked_list": ["import { mastodon } from \"masto\";\nimport { serverFeatureType, accFeatureType } from \"../types\";\nimport FavsFeature from \"./favsFeature\";\nimport reblogsFeature from \"./reblogsFeature\";\nimport interactsFeature from \"./interactsFeature\";\nimport coreServerFeature from \"./coreServerFeature\";\nimport Storage, { Key } from \"../Storage\";\n\n\nexport default class FeatureStorage extends Storage {\n    static async getTopFavs(api: mastodon.Client): Promise<accFeatureType> {\n        const topFavs: accFeatureType = await this.get(Key.TOP_FAVS) as accFeatureType;\n        console.log(topFavs);", "\nexport default class FeatureStorage extends Storage {\n    static async getTopFavs(api: mastodon.Client): Promise<accFeatureType> {\n        const topFavs: accFeatureType = await this.get(Key.TOP_FAVS) as accFeatureType;\n        console.log(topFavs);\n        if (topFavs != null && await this.getOpenings() < 10) {\n            return topFavs;\n        } else {\n            const favs = await FavsFeature(api);\n            await this.set(Key.TOP_FAVS, favs);\n            return favs;\n        }\n    }\n\n    static async getTopReblogs(api: mastodon.Client): Promise<accFeatureType> {\n        const topReblogs: accFeatureType = await this.get(Key.TOP_REBLOGS) as accFeatureType;\n        console.log(topReblogs);", "        if (topReblogs != null && await this.getOpenings() < 10) {\n            return topReblogs;\n        } else {\n            const reblogs = await reblogsFeature(api);\n            await this.set(Key.TOP_REBLOGS, reblogs);\n            return reblogs;\n        }\n    }\n\n    static async getTopInteracts(api: mastodon.Client): Promise<accFeatureType> {\n        const topInteracts: accFeatureType = await this.get(Key.TOP_INTERACTS) as accFeatureType;\n        console.log(topInteracts);", "        if (topInteracts != null && await this.getOpenings() < 10) {\n            return topInteracts;\n        } else {\n            const interacts = await interactsFeature(api);\n            await this.set(Key.TOP_INTERACTS, interacts);\n            return interacts;\n        }\n    }\n\n    static async getCoreServer(api: mastodon.Client): Promise<serverFeatureType> {\n        const coreServer: serverFeatureType = await this.get(Key.CORE_SERVER) as serverFeatureType;\n        console.log(coreServer);", "        if (coreServer != null && await this.getOpenings() < 10) {\n            return coreServer;\n        } else {\n            const user = await this.getIdentity();\n            const server = await coreServerFeature(api, user);\n            await this.set(Key.CORE_SERVER, server);\n            return server;\n        }\n    }\n\n}\n"]}
{"filename": "src/features/favsFeature.ts", "chunked_list": ["import { login, mastodon } from \"masto\";\nimport { accFeatureType } from \"../types\";\n\nexport default async function favFeature(api: mastodon.Client): Promise<accFeatureType> {\n    let results: mastodon.v1.Status[] = [];\n    let pages = 3;\n    for await (const page of api.v1.favourites.list({ limit: 80 })) {\n        results = results.concat(page)\n        pages--;\n        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const favFrequ = results.reduce((accumulator: accFeatureType, status: mastodon.v1.Status,) => {", "        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const favFrequ = results.reduce((accumulator: accFeatureType, status: mastodon.v1.Status,) => {\n        if (!status.account) return accumulator;\n        if (status.account.acct in accumulator) {\n            accumulator[status.account.acct] += 1;\n        } else {\n            accumulator[status.account.acct] = 1;\n        }\n        return accumulator\n    }, {})\n\n    return favFrequ;\n}"]}
{"filename": "src/features/reblogsFeature.ts", "chunked_list": ["import { login, mastodon } from \"masto\";\n\nexport default async function getReblogsFeature(api: mastodon.Client) {\n    let results: any[] = [];\n    let pages = 3;\n    for await (const page of api.v1.timelines.listHome({ limit: 80 })) {\n        results = results.concat(page)\n        pages--;\n        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const reblogFrequ = results.reduce((accumulator: any, status: mastodon.v1.Status) => {", "        if (pages === 0 || results.length < 80) {\n            break;\n        }\n    }\n\n    const reblogFrequ = results.reduce((accumulator: any, status: mastodon.v1.Status) => {\n        if (status.reblog) {\n            if (status.reblog.account.acct in accumulator) {\n                accumulator[status.reblog.account.acct] += 1;\n            } else {\n                accumulator[status.reblog.account.acct] = 1;\n            }\n        }\n        return accumulator\n    }, {})\n\n    return reblogFrequ;\n}"]}
{"filename": "src/weights/weightsStore.ts", "chunked_list": ["import { weightsType } from \"../types\";\nimport Storage, { Key } from \"../Storage\";\n\nexport default class weightsStore extends Storage {\n    static async getWeight(verboseName: string) {\n        const weight = await this.get(Key.WEIGHTS, true, verboseName) as weightsType;\n        if (weight != null) {\n            return weight;\n        }\n        return { [verboseName]: 1 };\n    }\n\n    static async setWeights(weights: weightsType, verboseName: string) {\n        await this.set(Key.WEIGHTS, weights, true, verboseName);\n    }\n\n    static async getWeightsMulti(verboseNames: string[]) {\n        const weights: weightsType = {}", "        for (const verboseName of verboseNames) {\n            const weight = await this.getWeight(verboseName);\n            weights[verboseName] = weight[verboseName]\n        }\n        return weights;\n    }\n\n    static async setWeightsMulti(weights: weightsType) {\n        for (const verboseName in weights) {\n            await this.setWeights({ [verboseName]: weights[verboseName] }, verboseName);\n        }\n    }\n\n    static async defaultFallback(verboseName: string, defaultWeight: number): Promise<boolean> {\n        // If the weight is not set, set it to the default weight\n        const weight = await this.get(Key.WEIGHTS, true, verboseName) as weightsType;", "        for (const verboseName in weights) {\n            await this.setWeights({ [verboseName]: weights[verboseName] }, verboseName);\n        }\n    }\n\n    static async defaultFallback(verboseName: string, defaultWeight: number): Promise<boolean> {\n        // If the weight is not set, set it to the default weight\n        const weight = await this.get(Key.WEIGHTS, true, verboseName) as weightsType;\n        if (weight == null) {\n            await this.setWeights({ [verboseName]: defaultWeight }, verboseName);\n            return true;\n        }\n        return false;\n    }\n\n}", "        if (weight == null) {\n            await this.setWeights({ [verboseName]: defaultWeight }, verboseName);\n            return true;\n        }\n        return false;\n    }\n\n}"]}
{"filename": "src/scorer/FeatureScorer.ts", "chunked_list": ["import { mastodon } from \"masto\"\nimport { StatusType, accFeatureType } from \"../types\";\n\ninterface RankParams {\n    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>,\n    verboseName: string,\n    description?: string,\n    defaultWeight?: number,\n}\n\n", "export default class FeatureScorer {\n    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n    private _verboseName: string;\n    private _isReady: boolean = false;\n    private _description: string = \"\";\n    feature: accFeatureType = {};\n    private _defaultWeight: number = 1;\n\n    constructor(params: RankParams) {\n        this.featureGetter = params.featureGetter;\n        this._verboseName = params.verboseName;\n        this._description = params.description || \"\";\n        this._defaultWeight = params.defaultWeight || 1;\n    }\n\n    async getFeature(api: mastodon.Client) {\n        this._isReady = true;\n        this.feature = await this.featureGetter(api);\n    }\n\n    async score(api: mastodon.Client, status: StatusType): Promise<number> {", "        if (!this._isReady) {\n            await this.getFeature(api);\n            this._isReady = true;\n        }\n        return 0\n    }\n\n    getVerboseName() {\n        return this._verboseName;\n    }\n\n    getDescription() {\n        return this._description;\n    }\n\n    getDefaultWeight() {\n        return this._defaultWeight;\n    }\n}"]}
{"filename": "src/scorer/FeedScorer.ts", "chunked_list": ["import { mastodon } from \"masto\"\nimport { StatusType } from \"../types\";\n\nexport default class FeedScorer {\n    private _verboseName: string = \"BaseScorer\";\n    private _isReady: boolean = false;\n    private _description: string = \"\";\n    private _defaultWeight: number = 1;\n\n    features: any = {};\n\n\n    constructor(verboseName: string, description?: string, defaultWeight?: number) {\n        this._verboseName = verboseName;\n        this._description = description || \"\";\n        this._defaultWeight = defaultWeight || 1;\n    }\n\n    async setFeed(feed: StatusType[]) {\n        this.features = await this.feedExtractor(feed);\n        this._isReady = true;\n    }\n\n    feedExtractor(feed: StatusType[]): any {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    async score(status: mastodon.v1.Status) {", "        if (!this._isReady) {\n            throw new Error(\"FeedScorer not ready\");\n        }\n        return 0;\n    }\n\n    getVerboseName() {\n        return this._verboseName;\n    }\n\n    getDescription() {\n        return this._description;\n    }\n    getDefaultWeight() {\n        return this._defaultWeight;\n    }\n}"]}
{"filename": "src/scorer/index.ts", "chunked_list": ["import favsFeatureScorer from \"./feature/favsFeatureScorer\";\nimport interactsFeatureScorer from \"./feature/interactsFeatureScorer\";\nimport reblogsFeatureScorer from \"./feature/reblogsFeatureScorer\";\nimport topPostFeatureScorer from \"./feature/topPostFeatureScorer\";\nimport diversityFeedScorer from \"./feed/diversityFeedScorer\";\nimport reblogsFeedScorer from \"./feed/reblogsFeedScorer\";\nimport FeedScorer from \"./FeedScorer\";\nimport FeatureScorer from \"./FeatureScorer\";\n\n", "\n\nexport {\n    favsFeatureScorer,\n    interactsFeatureScorer,\n    reblogsFeatureScorer,\n    topPostFeatureScorer,\n    diversityFeedScorer,\n    reblogsFeedScorer,\n    FeedScorer,", "    reblogsFeedScorer,\n    FeedScorer,\n    FeatureScorer\n}"]}
{"filename": "src/scorer/feed/diversityFeedScorer.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\nimport { StatusType } from \"../../types\";\n\nexport default class diversityFeedScorer extends FeedScorer {\n    constructor() {\n        super(\"Diversity\", \"Downranks posts from users that you have seen a lot of posts from\");\n    }\n\n    feedExtractor(feed: StatusType[]) {\n        return feed.reduce((obj: any, status) => {\n            obj[status.account.acct] = (obj[status.account.acct] || 0) - 1;\n            return obj;\n        }, {});\n    }\n\n    async score(status: StatusType) {\n        super.score(status);\n        const frequ = this.features[status.account.acct]\n        this.features[status.account.acct] = frequ + 1\n        return frequ + 1\n    }\n}"]}
{"filename": "src/scorer/feed/reblogsFeedScorer.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\nimport { StatusType } from \"../../types\";\nimport { mastodon } from \"masto\";\n\nexport default class reblogsFeedScorer extends FeedScorer {\n    constructor() {\n        super(\"reblogsFeed\", \"More Weight to posts that are reblogged a lot\", 6);\n    }\n\n    feedExtractor(feed: StatusType[]) {\n        return feed.reduce((obj: any, status) => {", "            if (status.reblog) {\n                obj[status.reblog.uri] = (obj[status.reblog.uri] || 0) + 1;\n            } else {\n                obj[status.uri] = (obj[status.uri] || 0) + 1;\n            }\n            return obj;\n        }, {});\n    }\n\n    async score(status: StatusType) {\n        super.score(status);\n        const features = this.features;", "        if (status.reblog) {\n            return features[status.reblog.uri] || 0;\n        }\n        return 0;\n    }\n}"]}
{"filename": "src/scorer/feature/favsFeatureScorer.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer'\nimport favsFeature from '../../features/favsFeature'\nimport { StatusType, accFeatureType } from '../../types'\nimport { mastodon } from 'masto'\nimport FeatureStorage from '../../features/FeatureStore'\n\nexport default class favsFeatureScorer extends FeatureScorer {\n\n    constructor() {\n        super({\n            featureGetter: (api: mastodon.Client) => FeatureStorage.getTopFavs(api),\n            verboseName: \"Favs\",\n            description: \"Posts that are from your most favorited users\",\n            defaultWeight: 1,\n        })\n    }\n\n    async score(api: mastodon.Client, status: StatusType) {\n        return (status.account.acct in this.feature) ? this.feature[status.account.acct] : 0\n    }\n}"]}
{"filename": "src/scorer/feature/topPostFeatureScorer.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer';\nimport { StatusType, accFeatureType } from \"../../types\";\nimport { mastodon } from \"masto\";\nimport FeatureStorage from \"../../features/FeatureStore\";\n\nexport default class topPostFeatureScorer extends FeatureScorer {\n    constructor() {\n        super({\n            featureGetter: (api: mastodon.Client) => { return Promise.resolve({}) },\n            verboseName: \"TopPosts\",\n            description: \"Posts that are trending on multiple of your most popular instances\",\n            defaultWeight: 1,\n        })\n    }\n\n    async score(api: mastodon.Client, status: StatusType) {\n        return status.topPost ? 1 : 0\n    }\n}"]}
{"filename": "src/scorer/feature/interactsFeatureScorer.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\nimport { StatusType, accFeatureType } from \"../../types\";\nimport { mastodon } from \"masto\";\nimport FeatureStorage from \"../../features/FeatureStore\";\n\nexport default class interactsFeatureScorer extends FeatureScorer {\n    constructor() {\n        super({\n            featureGetter: (api: mastodon.Client) => { return FeatureStorage.getTopInteracts(api) },\n            verboseName: \"Interacts\",\n            description: \"Posts that are from users, that often interact with your posts\",\n            defaultWeight: 2,\n        })\n    }\n\n    async score(api: mastodon.Client, status: StatusType) {\n        return (status.account.acct in this.feature) ? this.feature[status.account.acct] : 0\n    }\n}"]}
{"filename": "src/scorer/feature/reblogsFeatureScorer.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\nimport { StatusType, accFeatureType } from \"../../types\";\nimport { mastodon } from \"masto\";\nimport FeatureStorage from \"../../features/FeatureStore\";\n\nexport default class reblogsFeatureScorer extends FeatureScorer {\n    constructor() {\n        super({\n            featureGetter: (api: mastodon.Client) => { return FeatureStorage.getTopReblogs(api) },\n            verboseName: \"Reblogs\",\n            description: \"Posts that are from your most reblogger users\",\n            defaultWeight: 3,\n        })\n    }\n\n    async score(api: mastodon.Client, status: StatusType) {\n        const authorScore = (status.account.acct in this.feature) ? this.feature[status.account.acct] : 0\n        const reblogScore = (status.reblog && status.reblog.account.acct in this.feature) ? this.feature[status.reblog.account.acct] : 0\n        return authorScore + reblogScore\n    }\n}"]}
{"filename": "src/feeds/homeFeed.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\nexport default async function getHomeFeed(api: mastodon.Client, user: mastodon.v1.Account) {\n    let results: any[] = [];\n    let pages = 10;\n    for await (const page of api.v1.timelines.listHome()) {\n        results = results.concat(page)\n        pages--;\n        //check if status is less than 12 hours old\n        if (pages === 0 || new Date(page[0].createdAt) < new Date(Date.now() - 43200000)) {\n            break;\n        }\n    }\n    return results;\n}", "        if (pages === 0 || new Date(page[0].createdAt) < new Date(Date.now() - 43200000)) {\n            break;\n        }\n    }\n    return results;\n}"]}
{"filename": "src/feeds/topPostsFeed.ts", "chunked_list": ["import { SerializerNativeImpl, mastodon } from \"masto\";\nimport FeatureStore from \"../features/FeatureStore\";\n\nexport default async function getTopPostFeed(api: mastodon.Client): Promise<mastodon.v1.Status[]> {\n    const core_servers = await FeatureStore.getCoreServer(api)\n    let results: any[] = [];\n    const serializer = new SerializerNativeImpl();\n    //Get Top Servers\n    const servers = Object.keys(core_servers).sort((a, b) => {\n        return core_servers[b] - core_servers[a]\n    }).slice(0, 10)\n\n    results = await Promise.all(servers.map(async (server: string): Promise<mastodon.v1.Status[]> => {", "        if (server === \"undefined\" || typeof server == \"undefined\" || server === \"\") return [];\n        let res;\n        try {\n            res = await fetch(\"https://\" + server + \"/api/v1/trends/statuses\")\n        }\n        catch (e) {\n            return [];\n        }\n        if (!res.ok) {\n            return [];\n        }\n        const data: any[] = serializer.deserialize('application/json', await res.text());", "        if (!res.ok) {\n            return [];\n        }\n        const data: any[] = serializer.deserialize('application/json', await res.text());\n        if (data === undefined) {\n            return [];\n        }\n        return data.map((status: any) => {\n            status.topPost = true;\n            return status;\n        }).slice(0, 10)\n    }))\n    console.log(results)\n    return results.flat();\n}"]}
