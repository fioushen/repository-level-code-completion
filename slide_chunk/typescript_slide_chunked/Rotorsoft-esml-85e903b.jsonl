{"filename": "tests/esml.spec.ts", "chunked_list": ["describe(\"esml\", () => {\n  it.todo(\"should compile\");\n  it.todo(\"shoudl fail\");\n});\n"]}
{"filename": "src/canvas.ts", "chunked_list": ["import { esml } from \"./esml\";\nimport type { ContextNode, Node, Schema } from \"./types\";\nimport { EventEmitter, debounce } from \"./utils\";\n\nconst MIN_X = 0,\n  MIN_Y = 0;\n\ntype Options = {\n  SCALE: number;\n  WIDTH: number;\n  HEIGHT: number;\n  coordsSpan?: HTMLSpanElement;\n  zoomBtn?: HTMLButtonElement;\n  zoomInBtn?: HTMLButtonElement;\n  zoomOutBtn?: HTMLButtonElement;\n};\n", "type State = {\n  code: string;\n  font: string;\n  x?: number;\n  y?: number;\n  zoom?: number;\n};\n\nconst renderSchema = (ctx: ContextNode, schema?: Schema): string => {\n  return schema\n    ? renderSchema(ctx, schema.base).concat(`<div class=\"schema\">\n  ${[...schema.values()]\n    .map((field) => {\n      const name =\n        field.name.length > 20\n          ? field.name.substring(0, 20) + \"...\"\n          : field.name;\n      const nel = field.required ? \"b\" : \"span\";\n      const tel = typeof field.type === \"object\" ? \"i\" : \"span\";\n      return `<div class=\"field\"><${nel}>${name}</${nel}><${tel}>${\n        field.type\n      }</${tel}>\n      </div>", "      ${tel === \"i\" ? renderSchema(ctx, field.type as Schema) : \"\"}`;\n    })\n    .join(\"\")}\n</div>`)\n    : \"\";\n};\n\nexport declare interface Canvas {\n  on(event: \"transformed\", listener: (args: State) => void): this;\n}\n", "export class Canvas extends EventEmitter {\n  readonly SCALE: number = 80;\n  readonly WIDTH = this.SCALE * 100;\n  readonly HEIGHT = this.SCALE * 100;\n  readonly svg: Element;\n  readonly coordsSpan: HTMLSpanElement | undefined;\n  readonly zoomBtn: HTMLButtonElement | undefined;\n  readonly zoomInBtn: HTMLButtonElement | undefined;\n  readonly zoomOutBtn: HTMLButtonElement | undefined;\n\n  readonly details: HTMLElement | null;\n  private nodes?: HTMLDivElement;\n\n  private dragging = false;\n  private dx = 0;\n  private dy = 0;\n\n  private zoom = 1;\n  private x = 0;\n  private y = 0;\n  private w = 0;\n  private h = 0;\n\n  constructor(\n    private document: Document,\n    private container: HTMLDivElement,\n    options?: Options\n  ) {\n    super();\n    this.details = this.document.getElementById(\"details\");\n", "    if (options) {\n      this.SCALE = options.SCALE;\n      this.WIDTH = options.WIDTH;\n      this.HEIGHT = options.HEIGHT;\n      this.coordsSpan = options.coordsSpan;\n      this.zoomBtn = options.zoomBtn;\n      this.zoomInBtn = options.zoomInBtn;\n      this.zoomOutBtn = options.zoomOutBtn;\n    }\n    this.svg = this.document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"svg\"\n    );\n    this.svg.setAttributeNS(\n      \"http://www.w3.org/2000/xmlns/\",\n      \"xmlns:xlink\",\n      \"http://www.w3.org/1999/xlink\"\n    );\n    this.svg.setAttribute(\n      \"viewBox\",\n      `${MIN_X} ${MIN_Y} ${this.WIDTH} ${this.HEIGHT}`\n    );\n    this.svg.setAttribute(\"width\", `${this.WIDTH}`);\n    this.svg.setAttribute(\"height\", `${this.HEIGHT}`);\n    this.container.appendChild(this.svg);\n\n    this.container.addEventListener(\"wheel\", (e: WheelEvent) => {\n      e.preventDefault();", "      if (e.metaKey || e.ctrlKey) {\n        this.fitZoom(this.zoom + e.deltaY * -0.01);\n        this.transform();\n      } else {\n        this.transform(e.deltaX, e.deltaY);\n      }\n    });\n\n    type Pos = { clientX: number; clientY: number };\n    const dragStart = ({ clientX, clientY }: Pos) => {\n      this.dragging = true;\n      this.dx = clientX;\n      this.dy = clientY;\n      this.container.style.cursor = \"grabbing\";\n    };\n\n    const dragEnd = () => {\n      this.dragging = false;\n      this.container.style.cursor = \"default\";\n    };\n\n    const drag = ({ clientX, clientY }: Pos) => {", "    type Pos = { clientX: number; clientY: number };\n    const dragStart = ({ clientX, clientY }: Pos) => {\n      this.dragging = true;\n      this.dx = clientX;\n      this.dy = clientY;\n      this.container.style.cursor = \"grabbing\";\n    };\n\n    const dragEnd = () => {\n      this.dragging = false;\n      this.container.style.cursor = \"default\";\n    };\n\n    const drag = ({ clientX, clientY }: Pos) => {", "      if (this.dragging) {\n        this.transform(this.dx - clientX, this.dy - clientY);\n        this.dx = clientX;\n        this.dy = clientY;\n      }\n    };\n\n    this.container.addEventListener(\"mousedown\", dragStart);\n    this.container.addEventListener(\"mouseup\", dragEnd);\n    this.container.addEventListener(\"mousemove\", drag);\n    this.container.addEventListener(\"touchstart\", (e) =>\n      dragStart(e.touches[0])\n    );\n    this.container.addEventListener(\"touchend\", dragEnd);\n    this.container.addEventListener(\"touchmove\", (e) => drag(e.touches[0]));\n\n    this.zoomBtn &&\n      (this.zoomBtn.onclick = () => this.fitToContainer.apply(this));\n    this.zoomInBtn &&\n      (this.zoomInBtn.onclick = () => this.zoomTo.apply(this, [0.1]));\n    this.zoomOutBtn &&\n      (this.zoomOutBtn.onclick = () => this.zoomTo.apply(this, [-0.1]));\n  }\n\n  public fitToContainer() {\n    const vw = Math.min(this.container.clientWidth, window.innerWidth);\n    const vh = Math.min(this.container.clientHeight, window.innerHeight);", "    if (this.w && this.h && vw && vh) {\n      // avoid NaN\n      this.fitZoom(Math.min(vw / this.w, vh / this.h));\n      this.x = Math.floor((vw - this.w * this.zoom) / 2);\n      this.y = Math.floor((vh - this.h * this.zoom) / 2);\n      this.transform();\n    }\n  }\n\n  private zoomTo(z: number) {\n    this.fitZoom(this.zoom + z);\n    this.transform();\n  }\n\n  private fitZoom(z: number) {\n    this.zoom = Math.round(Math.min(Math.max(0.1, z), 3) * 100) / 100;\n  }\n\n  private transform(dx = 0, dy = 0) {\n    const g = this.svg.children[0];", "    if (g) {\n      this.x = Math.floor(\n        Math.min(Math.max(this.x - dx, MIN_X - this.w * this.zoom), this.WIDTH)\n      );\n      this.y = Math.floor(\n        Math.min(Math.max(this.y - dy, MIN_Y - this.h * this.zoom), this.HEIGHT)\n      );\n      this.coordsSpan &&\n        (this.coordsSpan.innerText = `x:${this.x} y:${this.y} w:${this.w} h:${this.h}`);\n      this.zoomBtn &&\n        (this.zoomBtn.innerText = `${Math.floor(this.zoom * 100)}%`);\n      g.setAttribute(\n        \"transform\",\n        `translate(${this.x}, ${this.y}) scale(${this.zoom})`\n      );\n      this.emit(\"transformed\", { x: this.x, y: this.y, zoom: this.zoom });\n    }\n  }\n\n  private renderNodeDetails(node: Node, schema?: Schema) {\n    return `<div class=\"name\">${node.name}</div>\n    <div class=\"description\">${node.description || \"\"}</div>\n    ${renderSchema(node.ctx, schema)}\n    `;\n  }\n\n  private addNodes(nodes: Node[]) {\n    const fadable = Object.fromEntries(\n      nodes\n        .filter((n) =>\n          [\"aggregate\", \"system\", \"policy\", \"process\", \"projector\"].includes(\n            n.visual\n          )\n        )\n        .map(({ index, visual }) => [`n${index}`, visual])\n    );\n\n    const fade = debounce((id: string) => {", "      if (id) {\n        const fade = document.querySelectorAll(`g:not(.${id}):not(.context)`);\n        for (let e of fade) {\n          e.id !== id && e.classList.add(\"faded\");\n        }\n      }\n    }, 500);\n\n    const handleMouseEnter = (event: MouseEvent) => {\n      const g = event.target as SVGGElement;\n", "      if (fadable[g.id]) fade(g.id);\n\n      const node = this.document.getElementById(\"node-\" + g.id);\n      if (this.details && node) {\n        this.details.innerHTML = node.innerHTML;\n        this.details.style.visibility = \"visible\";\n      }\n    };\n\n    const handleMouseLeave = () => {\n      fade(\"\");\n      const faded = document.querySelectorAll(\".faded\");", "      for (let e of faded) {\n        e.classList.remove(\"faded\");\n      }\n      this.details && (this.details.style.visibility = \"hidden\");\n    };\n\n    this.nodes && this.container.removeChild(this.nodes);\n    this.nodes = this.document.createElement(\"div\");\n    this.container.appendChild(this.nodes);\n    this.nodes.style.visibility = \"hidden\";\n\n    nodes.map((node) => {\n      const g = this.document.getElementById(\"n\" + node.index);", "      if (g) {\n        if (!g.classList.contains(\"context\")) {\n          g.addEventListener(\"mouseenter\", handleMouseEnter);\n          g.addEventListener(\"mouseleave\", handleMouseLeave);\n        }\n        // details\n        const schema = node.ctx.schemas.get(node.name);\n        if (node.description || schema) {\n          const el = this.document.createElement(\"div\");\n          el.id = `node-${g.id}`;\n          el.innerHTML = this.renderNodeDetails(node, schema);\n          this.nodes?.appendChild(el);\n        }\n      }\n    });\n  }\n\n  public render(state: State): Error | undefined {\n    const { error, svg, width, height, nodes } = esml(\n      state.code,\n      this.SCALE,\n      state.font\n    );", "    if (error) return error;\n    this.svg.innerHTML = svg!;\n    nodes && this.addNodes(nodes);\n    this.w = Math.floor(width!);\n    this.h = Math.floor(height!);\n    if (state.zoom) {\n      this.x = state.x || 0;\n      this.y = state.y || 0;\n      this.zoom = state.zoom;\n    }\n    this.transform();\n  }\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { Vector } from \"./utils\";\n\nexport type Style = {\n  scale: number;\n  margin: number;\n  padding: number;\n  stroke: string;\n  fill: string;\n  font: string;\n  fontSize: number;\n};\n\nexport const Visuals = [\n  \"context\",\n  \"aggregate\",\n  \"system\",\n  \"projector\",\n  \"policy\",\n  \"process\",\n  \"command\",\n  \"event\",\n  \"actor\",\n] as const;\nexport const Actions = [\n  \"invokes\",\n  \"handles\",\n  \"emits\",\n  \"includes\",\n  \"requires\",\n  \"optional\",\n] as const;", "export type Visual = (typeof Visuals)[number];\nexport type Action = (typeof Actions)[number];\n\nexport const COLORS: { [key in Visual]: string } = {\n  context: \"white\",\n  actor: \"#ffc107\",\n  aggregate: \"#fffabb\",\n  system: \"#eca0c3\",\n  projector: \"#d5f694\",\n  policy: \"#c595cd\",\n  process: \"#c595cd\",\n  command: \"#7adcfb\",\n  event: \"#ffaa61\",\n};\n\nexport const ScalarFieldTypes = [\n  \"string\",\n  \"number\",\n  \"boolean\",\n  \"uuid\",\n  \"date\",\n] as const;\n", "export type FieldType = (typeof ScalarFieldTypes)[number] | Schema;\nexport class Field {\n  constructor(\n    readonly name: string,\n    readonly required: boolean,\n    readonly type: FieldType,\n    readonly size?: number\n  ) {}\n}\n\nexport class Schema extends Map<string, Field> {\n  constructor(readonly name: string, description?: string) {\n    super();\n    this._base = undefined;\n    this._description = description;\n  }\n\n  private _base: Schema | undefined;\n  public set base(v: Schema) {\n    this._base = v;\n  }\n  public get base(): Schema | undefined {\n    return this._base;\n  }\n\n  private _description: string | undefined;\n  public set description(v: string) {\n    this._description = v;\n  }\n  public get description(): string | undefined {\n    return this._description;\n  }\n\n  toString() {\n    return this.name;\n  }\n}\n", "export class Schema extends Map<string, Field> {\n  constructor(readonly name: string, description?: string) {\n    super();\n    this._base = undefined;\n    this._description = description;\n  }\n\n  private _base: Schema | undefined;\n  public set base(v: Schema) {\n    this._base = v;\n  }\n  public get base(): Schema | undefined {\n    return this._base;\n  }\n\n  private _description: string | undefined;\n  public set description(v: string) {\n    this._description = v;\n  }\n  public get description(): string | undefined {\n    return this._description;\n  }\n\n  toString() {\n    return this.name;\n  }\n}\n", "export type Edge = {\n  source: Node;\n  target: Node;\n  color?: string;\n  arrow?: boolean;\n  path?: Vector[];\n};\n\nexport type Node = {\n  index: number;\n  name: string;\n  visual: Visual;\n  ctx: ContextNode;\n  description?: string;\n  color?: string;\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  refs?: Set<Node>;\n  useRefs?: boolean;\n  rels?: Set<number>;\n};\n", "export type Node = {\n  index: number;\n  name: string;\n  visual: Visual;\n  ctx: ContextNode;\n  description?: string;\n  color?: string;\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  refs?: Set<Node>;\n  useRefs?: boolean;\n  rels?: Set<number>;\n};\n", "export type ContextNode = Node & {\n  visual: \"context\";\n  nodes: Map<string, Node>;\n  edges: Map<string, Edge>;\n  schemas: Map<string, Schema>;\n};\n\nexport const isContextNode = (node: Node): node is ContextNode =>\n  \"nodes\" in node;\n\nexport type Edger = (\n  source: Node,\n  target: Node,\n  root: ContextNode\n) => Edge | undefined;\n", "export type Edger = (\n  source: Node,\n  target: Node,\n  root: ContextNode\n) => Edge | undefined;\n"]}
{"filename": "src/schema.ts", "chunked_list": ["import { z } from \"zod\";\nimport { ScalarFieldTypes } from \"./types\";\n\nconst Pascal = /^[A-Z][A-Za-z0-9]+$/;\nconst Camel = /^[a-z][A-Za-z0-9]+$/;\nconst Reference = /^([A-Z][A-Za-z0-9]+)(\\.[A-Z][A-Za-z0-9]*){0,1}$/;\n\nconst CommandList = z\n  .array(\n    z.string().regex(Pascal, {", "  .array(\n    z.string().regex(Pascal, {\n      message: \"Invalid command name. Use Pascal case!\",\n    })\n  )\n  .optional()\n  .describe(\"A list of references to internal commands\");\n\nconst EventList = z\n  .array(", "const EventList = z\n  .array(\n    z.string().regex(Reference, {\n      message: \"Invalid event name. Use [Context.]Name in Pascal case!\",\n    })\n  )\n  .optional()\n  .describe(\"A list of references to internal or external events\");\n\nconst Fields = z", "\nconst Fields = z\n  .record(\n    z.string().regex(Camel, {\n      message: \"Invalid field name. Use camel case!\",\n    }),\n    z.enum(ScalarFieldTypes).or(\n      z.string().regex(Pascal, {\n        message: \"Invalid schema name. Use Pascal case!\",\n      })", "        message: \"Invalid schema name. Use Pascal case!\",\n      })\n    )\n  )\n  .describe(\n    \"A map of field names and types (scalars or references to internal schemas)\"\n  );\n\nconst Schema = z\n  .object({", "const Schema = z\n  .object({\n    description: z.string().optional(),\n    base: z\n      .string()\n      .regex(Pascal, { message: \"Invalid schema name. Use Pascal case!\" })\n      .optional(),\n    requires: Fields.optional(),\n    optional: Fields.optional(),\n  })", "    optional: Fields.optional(),\n  })\n  .strict()\n  .describe(\"The data schema of internal messages or artifact states\");\n\nconst Event = z\n  .object({\n    type: z.literal(\"event\"),\n    description: z.string().optional(),\n    schema: Schema.optional(),", "    description: z.string().optional(),\n    schema: Schema.optional(),\n  })\n  .strict()\n  .describe(\"An event\");\n\nconst Command = z\n  .object({\n    type: z.literal(\"command\"),\n    description: z.string().optional(),", "    type: z.literal(\"command\"),\n    description: z.string().optional(),\n    schema: Schema.optional(),\n    actors: z\n      .record(\n        z.string().regex(Pascal, {\n          message: \"Invalid actor name. Use Pascal case!\",\n        }),\n        z.array(\n          z.string().regex(Reference, {", "        z.array(\n          z.string().regex(Reference, {\n            message:\n              \"Invalid projector name. Use [Context.]Projector in Pascal case!\",\n          })\n        )\n      )\n      .optional(),\n  })\n  .strict()", "  })\n  .strict()\n  .describe(\"A command, with actors that can read projections\");\n\nconst System = z\n  .object({\n    type: z.literal(\"system\"),\n    description: z.string().optional(),\n    handles: CommandList,\n    emits: EventList,", "    handles: CommandList,\n    emits: EventList,\n  })\n  .strict()\n  .describe(\"System artifact, can handle commands and emit events\");\n\nconst Aggregate = z\n  .object({\n    type: z.literal(\"aggregate\"),\n    description: z.string().optional(),", "    type: z.literal(\"aggregate\"),\n    description: z.string().optional(),\n    handles: CommandList,\n    emits: EventList,\n    schema: Schema.optional(),\n  })\n  .strict()\n  .describe(\n    \"Aggregate artifact, can handle commands and emit events, with a state\"\n  );", "    \"Aggregate artifact, can handle commands and emit events, with a state\"\n  );\n\nconst Policy = z\n  .object({\n    type: z.literal(\"policy\"),\n    description: z.string().optional(),\n    handles: EventList,\n    invokes: CommandList,\n    useRefs: z", "    invokes: CommandList,\n    useRefs: z\n      .boolean()\n      .optional()\n      .describe(\"Render near commands, with no edges\"),\n  })\n  .strict()\n  .describe(\n    \"Policy artifact, can handle (react to) events, and invoke commands\"\n  );", "    \"Policy artifact, can handle (react to) events, and invoke commands\"\n  );\n\nconst Process = z\n  .object({\n    type: z.literal(\"process\"),\n    description: z.string().optional(),\n    handles: EventList,\n    invokes: CommandList,\n    schema: Schema.optional(),", "    invokes: CommandList,\n    schema: Schema.optional(),\n    useRefs: z\n      .boolean()\n      .optional()\n      .describe(\"Render near commands, with no edges\"),\n  })\n  .strict()\n  .describe(\n    \"Process manager artifact, can handle (react to) events, and invoke commands, with a state\"", "  .describe(\n    \"Process manager artifact, can handle (react to) events, and invoke commands, with a state\"\n  );\n\nconst Projector = z\n  .object({\n    type: z.literal(\"projector\"),\n    description: z.string().optional(),\n    handles: EventList,\n    schema: Schema.optional(),", "    handles: EventList,\n    schema: Schema.optional(),\n  })\n  .strict()\n  .describe(\n    \"Projector artifact, can handle (project) events into a state (projection)\"\n  );\n\nconst ObjectSchema = z\n  .object({", "const ObjectSchema = z\n  .object({\n    type: z.literal(\"schema\"),\n    description: z.string().optional(),\n    base: z\n      .string()\n      .regex(Pascal, { message: \"Invalid schema name. Use Pascal case!\" })\n      .optional(),\n    requires: Fields.optional(),\n    optional: Fields.optional(),", "    requires: Fields.optional(),\n    optional: Fields.optional(),\n  })\n  .strict()\n  .describe(\"Object schemas can be used as base types or value objects\");\n\nconst Statement = z.union([\n  Command,\n  Event,\n  System,", "  Event,\n  System,\n  Aggregate,\n  Policy,\n  Process,\n  Projector,\n  ObjectSchema,\n]);\n\nexport const Grammar = z", "\nexport const Grammar = z\n  .record(\n    z.string().regex(Pascal, {\n      message: \"Invalid context name. Use Pascal case!\",\n    }),\n    z.record(\n      z.string().regex(Pascal, {\n        message: \"Invalid artifact name. Use Pascal case!\",\n      }),", "        message: \"Invalid artifact name. Use Pascal case!\",\n      }),\n      Statement\n    )\n  )\n  .describe(\"The model is a map of bounded contexts with internal artifacts\");\n\nexport type Grammar = z.infer<typeof Grammar>;\nexport type Statement = z.infer<typeof Statement>;\nexport type Schema = z.infer<typeof Schema>;\n", "export type Statement = z.infer<typeof Statement>;\nexport type Schema = z.infer<typeof Schema>;\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export interface Vector {\n  x: number;\n  y: number;\n}\nexport const magnitude = (v: Vector) => Math.sqrt(v.x * v.x + v.y * v.y);\nexport const difference = (a: Vector, b: Vector) => ({\n  x: a.x - b.x,\n  y: a.y - b.y,\n});\nexport const distance = (a: Vector, b: Vector) => magnitude(difference(a, b));\nexport const add = (a: Vector, b: Vector) => ({ x: a.x + b.x, y: a.y + b.y });\nexport const multiply = (v: Vector, factor: number) => ({\n  x: factor * v.x,\n  y: factor * v.y,\n});\nexport const normalize = (v: Vector) => multiply(v, 1 / magnitude(v));\nexport const rotate = (a: Vector) => ({ x: a.y, y: -a.x });\n\nexport const pad = (n: number, l: number) => n.toString().padStart(l);\nexport const splitName = (name: string) => name.trim().split(/(?=[A-Z])/);\n", "type F = (this: ThisParameterType<void>, ...args: any[]) => void;\nexport const debounce = (func: F, delay: number): F => {\n  let timeout: NodeJS.Timeout;\n  return function (this: ThisParameterType<void>, ...args: any[]): void {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n};\n", "type ListenerFn = (...args: any[]) => void;\nexport class EventEmitter {\n  private listeners = new Map<string, Set<ListenerFn>>();\n  public on(eventName: string, listener: ListenerFn): void {\n    !this.listeners.has(eventName) && this.listeners.set(eventName, new Set());\n    this.listeners.get(eventName)!.add(listener);\n  }\n  public emit(eventName: string, ...args: any[]): void {\n    this.listeners.has(eventName) &&\n      this.listeners.get(eventName)!.forEach((listener) => listener(...args));\n  }\n}\n"]}
{"filename": "src/compiler.ts", "chunked_list": ["import {\n  COLORS,\n  Field,\n  ScalarFieldTypes,\n  Schema,\n  type Action,\n  type ContextNode,\n  type Edge,\n  type Node,\n  type Visual,\n  Edger,\n} from \"./types\";\nimport * as schema from \"./schema\";\n\nconst rules: Partial<Record<Visual, Partial<Record<Action, Visual>>>> = {\n  system: {\n    handles: \"command\",\n    emits: \"event\",\n  },\n  aggregate: {\n    handles: \"command\",\n    emits: \"event\",\n  },\n  policy: {\n    handles: \"event\",\n    invokes: \"command\",\n  },\n  process: {\n    handles: \"event\",\n    invokes: \"command\",\n  },\n  projector: { handles: \"event\" },\n};\n\nconst system: Edger = (source, target) =>\n  target.visual === \"command\"\n    ? { source: target, target: source }\n    : { source, target };\n\nconst policy: Edger = (source, target) =>\n  target.visual === \"event\"\n    ? {\n        source: source.ctx === target.ctx ? target : { ...target },\n        target: source,\n        color: COLORS.event,\n        arrow: false,\n      }\n    : source.ctx === target.ctx && !source.useRefs\n    ? {\n        source,\n        target,\n        color: COLORS.command,\n        arrow: false,\n      }\n    : undefined; // commands with policy refs\n\nconst edgers: { [key in Visual]: Edger } = {\n  context: (source, target, root) => {", "  type Node,\n  type Visual,\n  Edger,\n} from \"./types\";\nimport * as schema from \"./schema\";\n\nconst rules: Partial<Record<Visual, Partial<Record<Action, Visual>>>> = {\n  system: {\n    handles: \"command\",\n    emits: \"event\",\n  },\n  aggregate: {\n    handles: \"command\",\n    emits: \"event\",\n  },\n  policy: {\n    handles: \"event\",\n    invokes: \"command\",\n  },\n  process: {\n    handles: \"event\",\n    invokes: \"command\",\n  },\n  projector: { handles: \"event\" },\n};\n\nconst system: Edger = (source, target) =>\n  target.visual === \"command\"\n    ? { source: target, target: source }\n    : { source, target };\n\nconst policy: Edger = (source, target) =>\n  target.visual === \"event\"\n    ? {\n        source: source.ctx === target.ctx ? target : { ...target },\n        target: source,\n        color: COLORS.event,\n        arrow: false,\n      }\n    : source.ctx === target.ctx && !source.useRefs\n    ? {\n        source,\n        target,\n        color: COLORS.command,\n        arrow: false,\n      }\n    : undefined; // commands with policy refs\n\nconst edgers: { [key in Visual]: Edger } = {\n  context: (source, target, root) => {", "    if (target.visual === \"event\")\n      return {\n        source: root.nodes.get(target.ctx.name)!,\n        target: root.nodes.get(source.ctx.name)!,\n        color: COLORS.event,\n        arrow: true,\n      };\n\n    if (target.visual === \"command\")\n      return {\n        source: root.nodes.get(source.ctx.name)!,\n        target: root.nodes.get(target.ctx.name)!,\n        color: COLORS.command,\n        arrow: true,\n      };\n", "    if (target.visual === \"command\")\n      return {\n        source: root.nodes.get(source.ctx.name)!,\n        target: root.nodes.get(target.ctx.name)!,\n        color: COLORS.command,\n        arrow: true,\n      };\n\n    if (target.visual === \"projector\")\n      return {\n        source: root.nodes.get(source.ctx.name)!,\n        target: root.nodes.get(target.ctx.name)!,\n        color: COLORS.projector,\n        arrow: true,\n      };\n  },\n  aggregate: system,\n  system: system,\n  policy: policy,\n  process: policy,\n  projector: (source, target) => ({\n    source: source.ctx === target.ctx ? target : { ...target },\n    target: source,\n    color: COLORS.event,\n    arrow: false,\n  }),\n  command: () => undefined,\n  event: () => undefined,\n  actor: () => undefined,\n};\n\nconst addRef = (source: Node, target: Node) => {\n  !source.refs && (source.refs = new Set());\n  source.refs.add(target);\n};\n\nconst addRel = (stm: Node, msg: Node) => {\n  msg.rels = msg.rels ?? new Set<number>();\n  msg.rels.add(stm.index);\n};\n\nconst addSchema = (\n  ctx: ContextNode,\n  name: string,\n  { requires, optional, description }: schema.Schema\n) => {\n  const schema = ctx.schemas.get(name) ?? new Schema(name, description);", "    if (target.visual === \"projector\")\n      return {\n        source: root.nodes.get(source.ctx.name)!,\n        target: root.nodes.get(target.ctx.name)!,\n        color: COLORS.projector,\n        arrow: true,\n      };\n  },\n  aggregate: system,\n  system: system,\n  policy: policy,\n  process: policy,\n  projector: (source, target) => ({\n    source: source.ctx === target.ctx ? target : { ...target },\n    target: source,\n    color: COLORS.event,\n    arrow: false,\n  }),\n  command: () => undefined,\n  event: () => undefined,\n  actor: () => undefined,\n};\n\nconst addRef = (source: Node, target: Node) => {\n  !source.refs && (source.refs = new Set());\n  source.refs.add(target);\n};\n\nconst addRel = (stm: Node, msg: Node) => {\n  msg.rels = msg.rels ?? new Set<number>();\n  msg.rels.add(stm.index);\n};\n\nconst addSchema = (\n  ctx: ContextNode,\n  name: string,\n  { requires, optional, description }: schema.Schema\n) => {\n  const schema = ctx.schemas.get(name) ?? new Schema(name, description);", "  if (description && !schema.description) schema.description = description;\n  ctx.schemas.set(name, schema);\n\n  const append = (name: string, type: string, required: boolean) => {\n    const scalar = ScalarFieldTypes.includes(type as any);\n    if (!scalar) {\n      if (!ctx.schemas.has(type)) ctx.schemas.set(type, new Schema(type));\n      schema.set(name, new Field(name, required, ctx.schemas.get(type)!));\n    } else schema.set(name, new Field(name, required, type as any));\n  };\n\n  requires &&\n    Object.entries(requires).forEach(([name, type]) =>\n      append(name, type, true)\n    );\n\n  optional &&\n    Object.entries(optional).forEach(([name, type]) =>\n      append(name, type, false)\n    );\n};\n\nconst addBaseSchema = (ctx: ContextNode, name: string, base: string) => {\n  const schema = ctx.schemas.get(name);\n  const baseSchema = ctx.schemas.get(base);\n  schema && baseSchema && (schema.base = baseSchema);\n};\n\nexport const compile = (model: schema.Grammar): ContextNode => {\n  let count = 0;\n\n  const newContext = (\n    parent?: ContextNode,\n    name = \"\",\n    hidden = false\n  ): ContextNode => ({\n    index: ++count,\n    name,\n    visual: \"context\",\n    ctx: parent ?? ({} as ContextNode),\n    color: hidden ? undefined : COLORS.context,\n    nodes: new Map(),\n    edges: new Map(),\n    schemas: new Map(),\n    x: 0,\n    y: 0,\n  });\n\n  const root = newContext();\n\n  const getNode = (ctx: ContextNode, name: string, visual: Visual): Node => {\n    // resolve [Context.]Target\n    const [a, b] = name.split(\".\");", "    } else schema.set(name, new Field(name, required, type as any));\n  };\n\n  requires &&\n    Object.entries(requires).forEach(([name, type]) =>\n      append(name, type, true)\n    );\n\n  optional &&\n    Object.entries(optional).forEach(([name, type]) =>\n      append(name, type, false)\n    );\n};\n\nconst addBaseSchema = (ctx: ContextNode, name: string, base: string) => {\n  const schema = ctx.schemas.get(name);\n  const baseSchema = ctx.schemas.get(base);\n  schema && baseSchema && (schema.base = baseSchema);\n};\n\nexport const compile = (model: schema.Grammar): ContextNode => {\n  let count = 0;\n\n  const newContext = (\n    parent?: ContextNode,\n    name = \"\",\n    hidden = false\n  ): ContextNode => ({\n    index: ++count,\n    name,\n    visual: \"context\",\n    ctx: parent ?? ({} as ContextNode),\n    color: hidden ? undefined : COLORS.context,\n    nodes: new Map(),\n    edges: new Map(),\n    schemas: new Map(),\n    x: 0,\n    y: 0,\n  });\n\n  const root = newContext();\n\n  const getNode = (ctx: ContextNode, name: string, visual: Visual): Node => {\n    // resolve [Context.]Target\n    const [a, b] = name.split(\".\");", "    if (b) {\n      ctx = root.nodes.get(a) as ContextNode;\n      if (!ctx) {\n        ctx = newContext(root, a);\n        root.nodes.set(a, ctx);\n      }\n      name = b;\n    }\n    !ctx.nodes.has(name) &&\n      ctx.nodes.set(name, {\n        index: ++count,\n        name,\n        visual,\n        color: COLORS[visual],\n        ctx,\n      });\n    const node = ctx.nodes.get(name)!;\n    return node;\n  };\n\n  const addStmt = (\n    ctx: ContextNode,\n    name: string,\n    statement: schema.Statement\n  ): void => {", "    if (statement.type === \"schema\") {\n      addSchema(ctx, name, statement);\n    } else {\n      const node = getNode(ctx, name, statement.type);\n      node.description = statement.description;\n      if (\"useRefs\" in statement) node.useRefs = statement.useRefs;\n      if (\"schema\" in statement) addSchema(ctx, name, statement.schema!);\n      if (statement.type === \"command\") {\n        statement.actors &&\n          Object.keys(statement.actors).forEach((actor) =>\n            getNode(ctx, actor, \"actor\")\n          );", "      } else if (statement.type !== \"event\") {\n        Object.entries(statement).forEach(([action, list]) => {\n          if (Array.isArray(list)) {\n            const visual = rules[statement.type]![action as Action];\n            visual &&\n              list.forEach((rel) => {\n                const msg = getNode(ctx, rel, visual);\n                addRel(node, msg);\n              });\n          }\n        });\n      }\n    }\n  };\n\n  // compile statements\n  Object.entries(model).forEach(([name, context]) => {\n    const ctx = (root.nodes.get(name) as ContextNode) ?? newContext(root, name);\n    root.nodes.set(name, ctx);\n    Object.entries(context).forEach(([name, statement]) =>\n      addStmt(ctx, name, statement)\n    );\n  });\n\n  // connect the model!\n  Object.entries(model).forEach(([name, context]) => {\n    const ctx = root.nodes.get(name) as ContextNode;\n    Object.entries(context).forEach(([name, statement]) => {", "      if (statement.type === \"schema\") {\n        statement.base && addBaseSchema(ctx, name, statement.base);\n      } else {\n        const edger = edgers[statement.type];\n        const source = ctx.nodes.get(name)!;\n\n        // connect base and value objects in schema\n        if (\"schema\" in statement && statement.schema?.base)\n          addBaseSchema(ctx, name, statement.schema.base);\n\n        // connect actors and read models", "        if (statement.type === \"command\" && statement.actors) {\n          Object.entries(statement.actors).forEach(([name, projectors]) => {\n            const actor = { ...ctx.nodes.get(name)! }; // clone it!\n            addRef(source, actor);\n            projectors.forEach((name) => {\n              const projector = getNode(ctx, name, \"projector\");\n              if (projector && projector.visual === \"projector\") {\n                addRef(actor, projector);\n                addRel(projector, source);\n              }\n            });\n          });\n        }\n\n        Object.entries(statement).forEach(([action, list]) => {\n          Array.isArray(list) &&\n            list.forEach((name: string) => {\n              const target = getNode(\n                ctx,\n                name,\n                rules[statement.type]![action as Action]!\n              );\n\n              // connect policies invoking commands", "              if (\n                (source.visual === \"policy\" || source.visual === \"process\") &&\n                target.visual === \"command\" &&\n                (source.ctx !== target.ctx || source.useRefs)\n              ) {\n                addRef(target, source);\n                addRel(source, target);\n              }\n\n              // connect contexts\n              if (ctx.color && source.ctx !== target.ctx) {\n                const edge = edgers.context(source, target, root) as Edge;", "              if (ctx.color && source.ctx !== target.ctx) {\n                const edge = edgers.context(source, target, root) as Edge;\n                if (edge) {\n                  const key = `${edge.source.name}->${edge.target.name}-${\n                    edge.color || \"\"\n                  }`;\n                  !root.edges.has(key) && root.edges.set(key, edge);\n                }\n              }\n\n              // connect edges inside context\n              const edge = edger(source, target, root);", "              if (edge) {\n                ctx.edges.set(`${edge.source.name}->${edge.target.name}`, edge);\n                ctx.nodes.set(edge.source.name, edge.source);\n                ctx.nodes.set(edge.target.name, edge.target);\n              }\n            });\n        });\n      }\n    });\n  });\n\n  return root;\n};\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { Canvas } from \"./canvas\";\nimport { esml } from \"./esml\";\nimport { EventEmitter, debounce } from \"./utils\";\n\nexport { Canvas, EventEmitter, debounce, esml };\n"]}
{"filename": "src/esml.ts", "chunked_list": ["import json5 from \"json5\";\nimport { ZodError } from \"zod\";\nimport { compile } from \"./compiler\";\nimport { layout, render } from \"./graphics\";\nimport { Grammar } from \"./schema\";\nimport type { ContextNode, Node, Style } from \"./types\";\n\nexport class Json5Error extends Error {\n  constructor(\n    readonly message: string,\n    readonly source: {\n      from: { line: number; col: number };\n      to: { line: number; col: number };\n    }\n  ) {\n    super(message);\n  }\n}\n", "type Font = \"monospace\" | \"inconsolata\" | \"caveat\" | \"handlee\";\nconst FONTS: { [key in Font]: string } = {\n  monospace: \"Monospace\",\n  inconsolata: \"Inconsolata\",\n  caveat: \"Caveat\",\n  handlee: \"Handlee\",\n};\nconst DEFAULT_FONT = \"inconsolata\";\n\nexport const esml = (\n  code: string,\n  scale: number,\n  font = DEFAULT_FONT\n): {\n  error?: Error;\n  svg?: string;\n  width?: number;\n  height?: number;\n  nodes?: Node[];\n} => {\n  const style: Style = {\n    scale,\n    stroke: \"#dedede\",\n    fill: \"white\",\n    font: FONTS[font.toLowerCase() as Font] || FONTS[DEFAULT_FONT],\n    fontSize: 12,\n    padding: 30,\n    margin: 40,\n  };\n", "  try {\n    const model = Grammar.parse(json5.parse(code));\n    const root = compile(model);\n    layout(root, style);\n    const svg = render(root, style);\n    const nodes = [...root.nodes.values()].flatMap((n) => [\n      ...(n as ContextNode).nodes.values(),\n    ]);\n    return {\n      svg,\n      width: root.width,\n      height: root.height,\n      nodes,\n    };", "  } catch (error: any) {\n    if (\"lineNumber\" in error && \"columnNumber\" in error)\n      return {\n        error: new Json5Error(error.message, {\n          from: { line: error.lineNumber - 1, col: 0 },\n          to: { line: error.lineNumber - 1, col: error.columnNumber },\n        }),\n      };\n    if (error instanceof ZodError)\n      return {\n        error: Error(\n          error.issues\n            .map((i) => `${i.path.join(\".\")}: ${i.message}`)\n            .join(\"\\n\")\n        ),\n      };", "    if (error instanceof ZodError)\n      return {\n        error: Error(\n          error.issues\n            .map((i) => `${i.path.join(\".\")}: ${i.message}`)\n            .join(\"\\n\")\n        ),\n      };\n    if (error instanceof Error) {\n      const message = error.stack!.split(\"\\n\").slice(0, 2).join(\" \");\n      return { error: Error(message) };\n    }\n    return { error: Error(error) };\n  }\n};\n", "    if (error instanceof Error) {\n      const message = error.stack!.split(\"\\n\").slice(0, 2).join(\" \");\n      return { error: Error(message) };\n    }\n    return { error: Error(error) };\n  }\n};\n"]}
{"filename": "src/graphics/render.ts", "chunked_list": ["import {\n  isContextNode,\n  type ContextNode,\n  type Edge,\n  type Node,\n  type Style,\n} from \"../types\";\nimport {\n  add,\n  difference,\n  multiply,\n  normalize,\n  rotate,\n  splitName,\n} from \"../utils\";\nimport { SvgGraphics } from \"./SvgGraphics\";\nimport { Graphics, Path, Renderable, SvgAttrs } from \"./types\";\n\nconst CTX_STROKE = \"#aaaaaa\";\nconst NOTE_STROKE = \"#555555\";\nconst ARROW_SIZE = 1.5;\n\nconst pickFontSize = (words: string[], w: number) => {\n  const max = words\n    .map((word) => word.length)\n    .sort((a, b) => b - a)\n    .at(0)!;\n  return Math.floor(Math.min(Math.max(Math.ceil(w / max), 8), 24));\n};\n\nconst sizeText = (\n  text: string[],\n  w: number,\n  h: number\n): { lines: string[]; fontSize: number } => {\n  let fontSize = pickFontSize(text, w);", "  while (fontSize > 5) {\n    const maxWidth = Math.ceil(w / fontSize) - 1;\n    const maxHeight = Math.floor(h / fontSize) - 1;\n    const lines: string[] = [];\n    let line = text[0];\n    let n = 1;\n    while (n < text.length) {\n      const word = text[n++];\n      if (line.length + word.length >= maxWidth) {\n        lines.push(line);\n        line = word;\n      } else line = line.concat(line.length ? \" \" : \"\", word);\n    }\n    lines.push(line);", "      if (line.length + word.length >= maxWidth) {\n        lines.push(line);\n        line = word;\n      } else line = line.concat(line.length ? \" \" : \"\", word);\n    }\n    lines.push(line);\n    if (n === text.length && lines.length <= maxHeight)\n      return {\n        lines,\n        fontSize,\n      };\n    fontSize--;\n  }\n  return {\n    lines: [text.join(\" \")],\n    fontSize,\n  };\n};\n\nconst renderText = (\n  text: string[],\n  w: number,\n  h: number,\n  g: Graphics,\n  options: {\n    fit: boolean;\n    x?: number;\n    y?: number;\n    w?: number;\n    h?: number;\n    fontSize?: number;\n  } = { fit: true }\n) => {\n  const width = options.w || w || 0;\n  const height = options.h || h || 0;\n\n  const { lines, fontSize } = options.fit\n    ? sizeText(text, width, height)\n    : {\n        lines: text,\n        fontSize: options.fontSize || 12,\n      };\n\n  g.attr(\"font-size\", fontSize + \"pt\");\n  const x = options.x || Math.floor(width / 2);\n  const y = options.y || Math.floor(height / 2);\n  const m = Math.floor(lines.length / 2);\n  const o = lines.length % 2 ? 0.3 : 0.9;\n  lines.forEach((line, i) => {\n    g.text(line, x, y, {\n      fill: NOTE_STROKE,\n      dy: `${((i - m) * 1.2 + o).toFixed(2)}em`,\n    });\n  });\n};\n\nconst getPath = (edge: Edge): Path[] => {", "  if (edge.path) {\n    const path = edge.path!.slice(1, -1);\n    const endDir = normalize(difference(path[path.length - 2], path.at(-1)!));\n    const end = path.length - 1;\n    const copy = path.map((p) => ({ x: p.x, y: p.y }));\n    copy[end] = add(\n      copy[end],\n      multiply(endDir, ARROW_SIZE * (edge.arrow ? 5 : 0))\n    );\n    return copy;\n  }\n  const x1 = edge.source.x! + edge.source.width! / 2;\n  const x2 = edge.target.x! - edge.target.width! / 2;\n  const y1 = edge.source.y!;\n  const y2 = edge.target.y!;", "  if (y1 === y2) return [{ x: x1, y: y1 }, { dx: x2 - x1 }];\n  const dx = Math.floor((x2 - x1) / 2);\n  const dy = Math.floor(y2 - y1);\n  return [{ x: x1, y: y1 }, { dx }, { dy }, { dx }];\n};\n\nconst renderEdge = (edge: Edge, g: Graphics) => {\n  const attrs: SvgAttrs = {\n    fill: \"none\",\n    stroke: edge.arrow ? edge.color : edge.target.color,\n  };\n  edge.arrow && (attrs[\"stroke-width\"] = 3);\n  g.path(getPath(edge), false, { ...attrs });", "  if (edge.arrow) {\n    const end = edge.path![edge.path!.length - 2];\n    const path = edge.path!.slice(1, -1);\n    const dir = normalize(difference(path[path.length - 2], path.at(-1)!));\n    const x = (s: number) => add(end, multiply(dir, s * ARROW_SIZE));\n    const y = (s: number) => multiply(rotate(dir), s * ARROW_SIZE);\n    g.path([add(x(10), y(4)), x(5), add(x(10), y(-4)), end], true, {\n      ...attrs,\n      fill: edge.color,\n    });\n  }\n};\n\nconst renderSimpleRef = (\n  node: Node,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  g: Graphics\n) => {\n  g.group(\"\", \"\").attr(\"fill\", node.color);\n  g.rect(x, y, w, h);\n  renderText(splitName(node.name), w, h, g, {\n    fit: true,\n    x: x + w / 2,\n    y: y + h / 2,\n    w,\n    h,\n  });\n  g.ungroup();\n};\n\nconst renderRef = (\n  node: Node,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  g: Graphics\n) => {\n  renderSimpleRef(node, x, y, w, h, g);\n  const hw = Math.ceil(w / 2);\n  const hh = Math.ceil(h / 2);\n  node.refs &&\n    [...node.refs].forEach((target, i) =>\n      renderSimpleRef(target, x - hw + 4, y + i * (hh + 2) - 4, hw, hh, g)\n    );\n};\n\nconst renderMultilineRef = (\n  targets: Node[],\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  g: Graphics\n) => {\n  const text = targets.map((target) => `- ${splitName(target.name).join(\" \")}`);\n  g.group(\"\", \"\")\n    .attr(\"fill\", targets[0].color)\n    .attr(\"text-align\", \"left\")\n    .attr(\"text-anchor\", \"start\");\n  g.rect(x, y, w, h);\n  renderText(text, w, h, g, {\n    fit: true,\n    x: x + 4,\n    y: y + h / 2,\n    w,\n    h,\n  });\n  g.ungroup();\n};\n\nconst renderCommandRefs = (\n  node: Node,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  g: Graphics\n) => {\n  const targets = [...node.refs!];\n  const th = Math.floor(h / targets.length);\n  targets.forEach((target, i) =>\n    renderRef(target, x, y + i * (th + 2), w, th, g)\n  );\n};\n\nconst renderRefs = (node: Node, g: Graphics, style: Style) => {", "  if (node.refs && node.visual !== \"actor\") {\n    const x = Math.floor(node.x! - node.width! / 2 - style.scale * 0.2);\n    const y = Math.floor(node.y! + node.height! * 0.4);\n    const w = Math.floor(style.scale);\n    const h = Math.floor(style.scale / 2);\n    node.refs?.size > 1\n      ? node.visual === \"command\"\n        ? renderCommandRefs(node, x, y, w, h, g)\n        : renderMultilineRef([...node.refs], x, y, w, h, g)\n      : renderRef([...node.refs][0], x, y, w, h, g);\n  }\n};\n\nconst context: Renderable = (ctx: Node, g: Graphics, style: Style) => {", "  if (isContextNode(ctx)) {\n    if (ctx.name) {\n      const words = splitName(ctx.name);\n      g.text(words.join(\" \"), 0, 0, {\n        fill: CTX_STROKE,\n        stroke: CTX_STROKE,\n        dy: -style.fontSize,\n      });\n      g.rect(0, 0, ctx.width!, ctx.height!, { rx: 25, ry: 25 });\n    }\n    g.group(`n${ctx.index}`, \"\", { dx: style.padding, dy: style.padding });", "    if (ctx.name)\n      g.attr(\"text-align\", \"center\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"stroke\", NOTE_STROKE);\n    ctx.edges.forEach(\n      (e) =>\n        e.color &&\n        renderEdge({ ...e, source: ctx.nodes.get(e.source.name)! }, g)\n    );\n    ctx.nodes.forEach((n) => n.color && renderNode(n, g, style));\n    ctx.nodes.forEach((n) => n.refs && renderRefs(n, g, style));\n    g.ungroup();\n  }\n};\n\nconst note: Renderable = (node: Node, g: Graphics) => {\n  g.attr(\"fill\", node.color!);\n  g.rect(0, 0, node.width!, node.height!);", "  if (node.rels)\n    g.attr(\n      \"class\",\n      node.visual.concat(\" \", [...node.rels].map((i) => `n${i}`).join(\" \"))\n    );\n  renderText(splitName(node.name), node.width!, node.height!, g);\n  const schema = node.ctx.schemas.get(node.name);\n  schema &&\n    g.text(`{${schema.size}}`, node.width! - 6, 6, {\n      \"font-size\": \"6pt\",\n      fill: NOTE_STROKE,\n    });\n};\n\nconst renderNode = (node: Node, g: Graphics, style: Style) => {\n  const dx = Math.floor(node.x! - node.width! / 2);\n  const dy = Math.floor(node.y! - node.height! / 2);\n  const render =\n    node.visual === \"context\"\n      ? context\n      : node.visual !== \"actor\"\n      ? note\n      : undefined; // don't render actors as nodes", "  if (render) {\n    g.group(`n${node.index}`, node.name, { class: node.visual, dx, dy });\n    render(node, g, style);\n    g.ungroup();\n  }\n};\n\nexport const render = (root: ContextNode, style: Style): string => {\n  const g = new SvgGraphics({\n    fill: style.fill,\n    \"font-family\": style.font,\n    \"font-size\": style.fontSize + \"pt\",\n    \"text-align\": \"left\",\n    stroke: style.stroke,\n    \"stroke-width\": 1,\n  });\n  context(root, g, style);\n  return g.serialize();\n};\n"]}
{"filename": "src/graphics/types.ts", "chunked_list": ["import type { Style, Node } from \"../types\";\n\nexport type SvgElementType = \"g\" | \"path\" | \"rect\" | \"text\" | \"tspan\";\n\nexport type SvgAttr = {\n  id?: string;\n  \"data-name\"?: string;\n  class?: string;\n  transform?: string;\n  fill?: string;\n  stroke?: string;\n  \"stroke-width\"?: number;\n  \"stroke-dasharray\"?: string;\n  \"font-family\"?: string;\n  \"font-size\"?: number | string;\n  \"font-weight\"?: \"bold\" | \"normal\";\n  \"font-style\"?: \"italic\" | \"normal\";\n  \"text-align\"?: \"left\" | \"center\" | \"right\";\n  \"text-anchor\"?: \"start\" | \"middle\" | \"end\";\n  d?: string;\n  x?: number;\n  y?: number;\n  dx?: number | string;\n  dy?: number | string;\n  rx?: number;\n  ry?: number;\n  height?: number;\n  width?: number;\n  style?: string;\n};\n", "export type Path = { x?: number; y?: number; dx?: number; dy?: number };\n\nexport type SvgAttrs = { [K in keyof SvgAttr]?: SvgAttr[K] };\n\nexport interface Graphics {\n  group(\n    id: string,\n    name: string,\n    attrs?: { class?: string; dx?: number; dy?: number }\n  ): this;\n  ungroup(): void;\n  attr<K extends keyof SvgAttr>(key: K, val: SvgAttrs[K]): this;\n  text(\n    text: string,\n    x: number,\n    y: number,\n    attrs?: {\n      fill?: string;\n      stroke?: string;\n      dy?: number | string;\n      \"font-family\"?: string;\n      \"font-size\"?: number | string;\n    }\n  ): void;\n  rect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    attrs?: {\n      fill?: string;\n      stroke?: string;\n      style?: string;\n      rx?: number;\n      ry?: number;\n    }\n  ): void;\n  path(path: Path[], close?: boolean, attrs?: SvgAttrs): void;\n  serialize(): string;\n}\n", "export type Renderable = (node: Node, g: Graphics, style: Style) => void;\n"]}
{"filename": "src/graphics/layout.ts", "chunked_list": ["import * as dagre from \"dagre\";\nimport type { ContextNode, Node, Style, Visual } from \"../types\";\nimport { splitName } from \"../utils\";\n\ntype Layouter = (node: Node, style: Style) => void;\n\nconst square: Layouter = (node: Node, style: Style) => {\n  node.x = 0;\n  node.y = 0;\n  node.width = style.scale;\n  node.height = style.scale;\n};\n\nconst rectangle: Layouter = (node: Node, style: Style) => {\n  node.x = 0;\n  node.y = 0;\n  node.width = style.scale * 2;\n  node.height = style.scale;\n};\n\n// don't render actors as nodes\nconst actor: Layouter = (node: Node) => {\n  node.x = 0;\n  node.y = 0;\n  node.width = 0;\n  node.height = 0;\n};\n\nexport const layout = (root: ContextNode, style: Style) => {", "  function layouter(visual: Visual): Layouter {\n    switch (visual) {\n      case \"context\":\n        return layoutContext as Layouter;\n      case \"actor\":\n        return actor;\n      case \"command\":\n      case \"event\":\n        return square;\n      default:\n        return rectangle;\n    }\n  }\n\n  const PAD = 2 * style.padding;\n  const layoutContext = (ctx: ContextNode, style: Style) => {", "    if (ctx.nodes.size) {\n      const graph = new dagre.graphlib.Graph({\n        multigraph: true,\n      });\n      graph.setGraph({\n        nodesep: style.margin,\n        edgesep: style.margin,\n        ranksep: style.margin,\n        acyclicer: ctx.name && \"greedy\",\n        rankdir: \"LR\",\n        ranker: \"network-simplex\",\n      });\n      ctx.nodes.forEach((n) => n.color && layouter(n.visual)(n, style));\n      ctx.nodes.forEach(\n        ({ name, width, height }) =>\n          width && height && graph.setNode(name, { width, height })\n      );\n      ctx.edges.forEach(({ source, target }, name) =>\n        graph.setEdge(source.name, target.name, {}, name)\n      );\n      dagre.layout(graph);\n\n      ctx.nodes.forEach((n) => {\n        const gn = graph.node(n.name);", "        if (gn) {\n          n.x = gn.x;\n          n.y = gn.y;\n        }\n      });\n\n      !ctx.name &&\n        graph.edges().forEach((e) => {\n          const ge = graph.edge(e);\n          const ne = ctx.edges.get(e.name!)!;\n          ne.path = [ne.source, ...ge.points!, ne.target].map((n) => ({\n            x: Math.floor(n.x!),\n            y: Math.floor(n.y!),\n          }));\n        });\n      const { width = 0, height = 0 } = graph.graph();\n      ctx.width = width + PAD;\n      ctx.height = height + PAD;\n    } else {\n      ctx.width = splitName(ctx.name).join(\" \").length * style.fontSize + PAD;\n      ctx.height = style.fontSize + PAD;\n    }\n  };\n\n  return layoutContext(root, style);\n};\n"]}
{"filename": "src/graphics/SvgGraphics.ts", "chunked_list": ["import { Graphics, Path, SvgAttr, SvgAttrs, SvgElementType } from \"./types\";\n\nfunction encode(val?: string | number) {\n  if (\"number\" === typeof val) return val.toFixed(0);\n  return (val ?? \"\")\n    .toString()\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\");\n}\n", "function attrs(attrs: SvgAttrs): string {\n  return Object.entries(attrs)\n    .filter(([_, val]) => val)\n    .map(([key, val]) => `${key}=\"${encode(val)}\"`)\n    .join(\" \");\n}\n\nclass SvgElement {\n  private readonly children: SvgElement[] = [];\n  constructor(\n    private readonly type: SvgElementType,\n    private readonly attrs: SvgAttrs,\n    private parent?: SvgElement,\n    private text?: string\n  ) {}\n  get group() {\n    return this.parent;\n  }\n  attr<K extends keyof SvgAttr>(key: K, val: SvgAttrs[K]) {\n    this.attrs[key] = val;\n    return this;\n  }\n  append(el: SvgElement) {\n    el.parent = this;\n    this.children.push(el);\n    return el;\n  }\n  serialize(): string {\n    const attr = attrs({ ...this.attrs });\n    const body =\n      this.children.map((o) => o.serialize()).join(\"\") || encode(this.text);\n    return `<${this.type} ${attr}>${body}</${this.type}>`;\n  }\n}\n", "export class SvgGraphics implements Graphics {\n  private readonly root: SvgElement;\n  private current: SvgElement;\n\n  private _new(type: SvgElementType, attr: SvgAttrs, text?: string) {\n    this.current.append(new SvgElement(type, attr, this.current, text));\n  }\n\n  constructor(attrs: SvgAttrs) {\n    this.root = this.current = new SvgElement(\"g\", {\n      ...attrs,\n      \"data-name\": \"root\",\n    });\n  }\n\n  group(\n    id: string,\n    name: string,\n    attrs?: { class?: string; dx?: number; dy?: number }\n  ) {\n    const element = new SvgElement(\"g\", {}, this.current);\n    this.current.append(element);\n    this.current = element;", "    if (name) {\n      this.attr(\"id\", id);\n      this.attr(\"data-name\", name);\n    }\n    if (attrs) {\n      attrs.class && this.attr(\"class\", attrs.class);\n      (attrs.dx || attrs.dy) &&\n        this.attr(\"transform\", `translate(${attrs.dx}, ${attrs.dy})`);\n    }\n    return this;\n  }\n  ungroup() {\n    this.current.group && (this.current = this.current.group);\n  }\n  attr<K extends keyof SvgAttr>(key: K, val: SvgAttrs[K]) {\n    this.current.attr(key, val);\n    return this;\n  }\n  rect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    attrs?: {\n      fill?: string;\n      stroke?: string;\n      style?: string;\n      rx?: number;\n      ry?: number;\n    }\n  ) {\n    this._new(\"rect\", { x, y, height, width, ...attrs });\n  }\n  path(path: Path[], close?: boolean, attrs?: SvgAttrs) {\n    const d = path\n      .map((p, i) =>\n        p.x && p.y\n          ? (i ? \"L\" : \"M\") + p.x.toFixed(0) + \" \" + p.y.toFixed(0)\n          : p.dx\n          ? \"h\" + p.dx.toFixed(0)\n          : p.dy\n          ? \"v\" + p.dy.toFixed(0)\n          : \"\"\n      )\n      .join(\" \")\n      .concat(close ? \" Z\" : \"\");\n    this._new(\"path\", { ...attrs, d });\n  }\n  text(\n    text: string,\n    x: number,\n    y: number,\n    attrs?: {\n      fill?: string;\n      stroke?: string;\n      dy?: number | string;\n      \"font-family\"?: string;\n      \"font-size\"?: number | string;\n    }\n  ) {\n    this._new(\"text\", { x, y, ...attrs }, text);\n  }\n  serialize() {\n    return this.root.serialize();\n  }\n}\n"]}
{"filename": "src/graphics/index.ts", "chunked_list": ["export { layout } from \"./layout\";\nexport { render } from \"./render\";\n"]}
{"filename": "src/cli/configs.ts", "chunked_list": ["import path from \"node:path\";\nimport os from \"node:os\";\nimport { createFile } from \"./utils\";\n\ntype Package = {\n  name: string;\n  version: string;\n  description: string;\n  author: {\n    name: string;\n    email: string;\n  };\n  license: \"MIT\";\n  main?: string;\n  workspaces?: string[];\n  scripts?: Record<string, string>;\n  dependencies?: Record<string, string>;\n  devDependencies?: Record<string, string>;\n};\n", "export function createPackageJson(\n  dir: string,\n  name: string,\n  workspaces?: string[]\n): void {\n  const username = os.userInfo().username || \"username\";\n  const pkg: Package = {\n    name,\n    version: \"0.1.0\",\n    description: `Describe your ${name} project here`,\n    author: {\n      name: username,\n      email: `${username}@email.com`,\n    },\n    license: \"MIT\",\n  };", "  if (workspaces) {\n    pkg.workspaces = workspaces;\n    pkg.scripts = {\n      build: \"npm run build --workspaces\",\n      test: \"npm run test --workspaces\",\n      dev: \"sh ./scripts/dev.sh\",\n      up: \"npm run build && docker-compose up\",\n      down: \"docker-compose down\",\n    };\n    pkg.devDependencies = {\n      \"@types/express\": \"^4\",\n      \"@types/jest\": \"^29\",\n      \"@types/node\": \"^18\",\n      jest: \"^29\",\n      \"ts-jest\": \"^29\",\n      \"ts-node\": \"^10\",\n      \"ts-node-dev\": \"^2\",\n      typescript: \"^5\",\n    };\n  } else {\n    pkg.main = \"dist/index.js\";\n    pkg.scripts = {\n      start: \"node dist/index.js\",\n      test: \"jest --coverage\",\n      build: \"tsc\",\n    };\n    pkg.dependencies = {\n      \"@rotorsoft/eventually\": \"^5\",\n      \"@rotorsoft/eventually-express\": \"^5\",\n      \"@rotorsoft/eventually-openapi\": \"^0\",\n      \"@rotorsoft/eventually-pg\": \"^5\",\n      express: \"^4\",\n      zod: \"^3\",\n    };\n  }\n  createFile(path.join(dir, \"package.json\"), JSON.stringify(pkg, null, 2));\n}\n", "export function createTsConfig(dir: string, base?: string): void {\n  const tsConfig = base\n    ? {\n        extends: base,\n        compilerOptions: {\n          rootDir: \"src\",\n          outDir: \"dist\",\n        },\n        include: [\"src\"],\n        exclude: [\"src/__tests__\"],\n      }\n    : {\n        compilerOptions: {\n          target: \"ES2021\",\n          module: \"commonjs\",\n          strict: true,\n          sourceMap: true,\n          declaration: true,\n          declarationMap: true,\n          noImplicitAny: true,\n          esModuleInterop: true,\n          skipLibCheck: true,\n        },\n        exclude: [\"node_modules\"],\n      };\n  createFile(\n    path.join(dir, \"tsconfig.json\"),\n    JSON.stringify(tsConfig, null, 2)\n  );\n}\n", "export function createJestConfig(dir: string): void {\n  const jestConfig = {\n    preset: \"ts-jest\",\n    testEnvironment: \"node\",\n    testMatch: [\"**/*spec.ts\"],\n    coveragePathIgnorePatterns: [\n      \"node_modules\",\n      \"dist\",\n      \"__tests__\",\n      \"__mocks__\",\n    ],\n  };\n  createFile(\n    path.join(dir, \"jest.config.js\"),\n    `/* eslint-disable no-undef */\n/** @type {import('ts-jest/dist/types').JestConfigWithTsJest} */\nmodule.exports = ${JSON.stringify(jestConfig, null, 2)};\n`\n  );\n}\n", "export function createEnv(dir: string): void {\n  createFile(\n    path.join(dir, \".env\"),\n    `LOG_LEVEL=trace\nOAS_UI=Rapidoc\n\n# local PG docker container\nPG_HOST=localhost\nPG_USER=postgres\nPG_PASSWORD=postgres\nPG_DATABASE=postgres\n`\n  );\n}\n", "export function createGitIgnore(dir: string): void {\n  createFile(\n    path.join(dir, \".gitignore\"),\n    `node_modules\ndist\ncoverage\n`\n  );\n}\n"]}
{"filename": "src/cli/create-eventually-app.ts", "chunked_list": ["#!/usr/bin/env node\n\nimport path from \"node:path\";\nimport {\n  createDirectory,\n  executeCommand,\n  loadFile,\n  parseArguments,\n  resolvePath,\n} from \"./utils\";", "  resolvePath,\n} from \"./utils\";\nimport { generateContexts } from \"./generators\";\nimport { createEnv, createGitIgnore, createTsConfig } from \"./configs\";\n\nconst use =\n  \"Use: npx create-eventually-app --src=path-to-model --dir=path-to-target --project=project-name\";\n\nconst { dir, src, project } = parseArguments(process.argv);\nif (!(dir && src && project)) {\n  console.log(use);\n  process.exit(1);\n}\n\nconst srcPath = resolvePath(src);\nconsole.log(\"Source path:\", srcPath);\nconst dirPath = resolvePath(dir);\nconst projectPath = path.join(dirPath, project);\nconsole.log(\"Project path:\", projectPath);\n\nconst code = loadFile(srcPath);", "const { dir, src, project } = parseArguments(process.argv);\nif (!(dir && src && project)) {\n  console.log(use);\n  process.exit(1);\n}\n\nconst srcPath = resolvePath(src);\nconsole.log(\"Source path:\", srcPath);\nconst dirPath = resolvePath(dir);\nconst projectPath = path.join(dirPath, project);\nconsole.log(\"Project path:\", projectPath);\n\nconst code = loadFile(srcPath);", "if (!code) {\n  console.error(\"Model not found at:\", srcPath);\n  process.exit(1);\n}\n\ncreateDirectory(projectPath);\ncreateTsConfig(projectPath);\ncreateEnv(projectPath);\ncreateGitIgnore(projectPath);\ngenerateContexts(projectPath, project, code);\nexecuteCommand(`cd ${projectPath} && npm install`);\n\nconsole.log(`Successfully created eventually project '${project}' \ud83d\ude80`);\n"]}
{"filename": "src/cli/types.ts", "chunked_list": ["import type { Node } from \"../types\";\n\nexport interface Arguments {\n  [key: string]: string;\n}\n\nexport type Art = Node & {\n  in: Array<Node>;\n  out: Array<Node>;\n};\n"]}
{"filename": "src/cli/create-eventually-arts.ts", "chunked_list": ["#!/usr/bin/env node\n\nimport json5 from \"json5\";\nimport path from \"node:path\";\nimport { compile } from \"../compiler\";\nimport { Grammar } from \"../schema\";\nimport { createArtifacts } from \"./generators\";\nimport {\n  createDirectory,\n  createFile,", "  createDirectory,\n  createFile,\n  decamelize,\n  loadFile,\n  parseArguments,\n  resolvePath,\n} from \"./utils\";\nimport { ContextNode } from \"../types\";\n\nconst use =", "\nconst use =\n  \"Use: npx create-eventually-arts --src=path-to-model --dir=path-to-target\";\n\nconst { dir, src } = parseArguments(process.argv);\nif (!(dir && src)) {\n  console.log(use);\n  process.exit(1);\n}\n\nconst srcPath = resolvePath(src);\nconsole.log(\"Source path:\", srcPath);\nconst dirPath = resolvePath(dir);\nconsole.log(\"Target path:\", dirPath);\n\nconst code = loadFile(srcPath);", "if (!code) {\n  console.error(\"Model not found at:\", srcPath);\n  process.exit(1);\n}\n\ncreateDirectory(dirPath);\n\nconst model = Grammar.parse(json5.parse(code));\nconst root = compile(model);\nroot.nodes.forEach((ctx, name) => {\n  const pkg = decamelize(name);\n  const cdir = path.join(dirPath, pkg);\n  createDirectory(path.join(cdir));\n  createDirectory(path.join(cdir, \"/schemas\"));\n\n  console.log(`Creating artifacts in context ${ctx.name}:`, cdir, \"...\");\n  createArtifacts(ctx as ContextNode, (art, result, schemas) => {\n    console.log(`... ${art.visual} ${art.name}`);\n    createFile(path.join(cdir, `${art.name}.${art.visual}.ts`), result.content);\n    createFile(path.join(cdir, `${art.name}.spec.ts`), result.unitTest);\n    Object.entries(schemas.schemas).forEach(([name, content]) =>\n      createFile(path.join(cdir, `/schemas/${name}.schema.ts`), content)\n    );\n    createFile(path.join(cdir, `/schemas/${art.name}.ts`), schemas.map);\n  });\n});\n\nconsole.log(\"Successfully created eventually artifacts \ud83d\ude80\");\n"]}
{"filename": "src/cli/utils.ts", "chunked_list": ["import { execSync } from \"node:child_process\";\nimport * as fs from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { Arguments } from \"./types\";\n\nexport function parseArguments(args: string[]): Arguments {\n  const parsedArgs: Arguments = {};\n\n  args.forEach((arg) => {\n    const matches = arg.match(/^--([^=]+)=(.*)$/);", "    if (matches) {\n      const key = matches[1];\n      const value = matches[2];\n      parsedArgs[key] = value;\n    }\n  });\n\n  return parsedArgs;\n}\n\nexport function resolvePath(p: string): string {\n  return p\n    ? p.startsWith(\"~/\")\n      ? path.resolve(os.homedir(), p.slice(2))\n      : path.resolve(p)\n    : process.cwd();\n}\n", "export function resolvePath(p: string): string {\n  return p\n    ? p.startsWith(\"~/\")\n      ? path.resolve(os.homedir(), p.slice(2))\n      : path.resolve(p)\n    : process.cwd();\n}\n\nexport function createDirectory(directory: string): void {\n  if (!fs.existsSync(directory)) {\n    fs.mkdirSync(directory);\n  }\n}\n", "export function createDirectory(directory: string): void {\n  if (!fs.existsSync(directory)) {\n    fs.mkdirSync(directory);\n  }\n}\n\nexport function createFile(filePath: string, content: string): void {\n  fs.writeFileSync(filePath, content);\n}\n\nexport function loadFile(filePath: string): string | undefined {\n  return fs.existsSync(filePath)\n    ? fs.readFileSync(filePath).toString()\n    : undefined;\n}\n", "export function loadFile(filePath: string): string | undefined {\n  return fs.existsSync(filePath)\n    ? fs.readFileSync(filePath).toString()\n    : undefined;\n}\n\nexport function executeCommand(command: string): void {\n  execSync(command, { stdio: \"inherit\" });\n}\n\nexport function decamelize(value: string): string {\n  return value\n    .replace(/([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})/gu, \"$1-$2\")\n    .replace(\n      /(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n      \"$1-$2\"\n    )\n    .toLowerCase();\n}\n", "export function decamelize(value: string): string {\n  return value\n    .replace(/([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})/gu, \"$1-$2\")\n    .replace(\n      /(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n      \"$1-$2\"\n    )\n    .toLowerCase();\n}\n"]}
{"filename": "src/cli/schemas.ts", "chunked_list": ["import { randomUUID } from \"node:crypto\";\nimport {\n  ScalarFieldTypes,\n  type FieldType,\n  type Node,\n  Schema,\n  Visual,\n} from \"../types\";\nimport type { Art } from \"./types\";\n\nfunction toZodType(type: FieldType, required = true): string {\n  let t: string;", "function toZodType(type: FieldType, required = true): string {\n  let t: string;\n  if (ScalarFieldTypes.includes(type as any)) {\n    switch (type) {\n      case \"uuid\":\n        t = \"z.string().uuid()\";\n        break;\n      default:\n        t = `z.${type}()`;\n        break;\n    }\n  } else t = type.toString();\n  return required ? t : t.concat(\".optional()\");\n}\n", "function toZod(schema?: Schema, indent = 3): string {\n  return `z.object({${\n    schema && schema.size > 0\n      ? \"\\n\".concat(\n          [...schema.values()]\n            .map(\n              (f) =>\n                `${\" \".repeat(indent * 2)}${f.name}: ${toZodType(\n                  f.type,\n                  f.required\n                )}`\n            )\n            .join(\",\\n\"),\n          \"\\n\",\n          \" \".repeat((indent - 1) * 2),\n          \"})\"\n        )\n      : \"})\"\n  }${schema?.description ? `.describe(\"${schema.description}\")` : \"\"}`;\n}\n", "function toDefaultValue(type: FieldType): string {\n  switch (type) {\n    case \"boolean\":\n      return \"true\";\n    case \"number\":\n      return \"0\";\n    case \"uuid\":\n      return `\"${randomUUID()}\"`;\n    case \"date\":\n      return \"new Date()\";\n    case \"string\":\n      return '\"\"';\n    default:\n      return toDefault(type);\n  }\n}\n", "export function toDefault(schema?: Schema): string {\n  return `{${\n    schema\n      ? [...(schema.base?.values() ?? []), ...schema.values()]\n          .map((f) => `${f.name}: ${toDefaultValue(f.type)}`)\n          .join(\", \")\n      : \"\"\n  }}`;\n}\n\nexport function toDefaultEvent(event: Node): string {\n  return `{ name: \"${\n    event.name\n  }\", id: 0, stream: \"\", version: 0, created: new Date(), metadata: { correlation: \"\", causation: {} }, data: ${toDefault(\n    event.ctx.schemas.get(event.name)\n  )} }`;\n}\n", "export function toDefaultEvent(event: Node): string {\n  return `{ name: \"${\n    event.name\n  }\", id: 0, stream: \"\", version: 0, created: new Date(), metadata: { correlation: \"\", causation: {} }, data: ${toDefault(\n    event.ctx.schemas.get(event.name)\n  )} }`;\n}\n\nfunction toSchema(art: Art): string | undefined {\n  const inputs = art.in.map((v) => `    ${v.name}`).join(\",\\n\");\n  const outputs = art.out.map((v) => `    ${v.name}`).join(\",\\n\");\n\n  switch (art.visual) {\n    case \"system\":\n      return `\n  commands: {\n${inputs} \n  },\n  events: {\n${outputs} \n  },`;\n\n    case \"aggregate\":\n      return `\n  state: ${art.name},\n  commands: {\n${inputs} \n  },\n  events: {\n${outputs} \n  },`;\n\n    case \"policy\":\n      return `\n  commands: {\n${outputs} \n  },\n  events: {\n${inputs} \n  },`;\n\n    case \"process\":\n      return `\n  state: ${art.name},\n  commands: {\n${outputs} \n  },\n  events: {\n${inputs} \n  },`;\n\n    case \"projector\":\n      return `\n  state: ${art.name},\n  events: {\n${inputs} \n  },`;\n  }\n}\n\nconst withState: Visual[] = [\"aggregate\", \"process\", \"projector\"];\n", "function toSchema(art: Art): string | undefined {\n  const inputs = art.in.map((v) => `    ${v.name}`).join(\",\\n\");\n  const outputs = art.out.map((v) => `    ${v.name}`).join(\",\\n\");\n\n  switch (art.visual) {\n    case \"system\":\n      return `\n  commands: {\n${inputs} \n  },\n  events: {\n${outputs} \n  },`;\n\n    case \"aggregate\":\n      return `\n  state: ${art.name},\n  commands: {\n${inputs} \n  },\n  events: {\n${outputs} \n  },`;\n\n    case \"policy\":\n      return `\n  commands: {\n${outputs} \n  },\n  events: {\n${inputs} \n  },`;\n\n    case \"process\":\n      return `\n  state: ${art.name},\n  commands: {\n${outputs} \n  },\n  events: {\n${inputs} \n  },`;\n\n    case \"projector\":\n      return `\n  state: ${art.name},\n  events: {\n${inputs} \n  },`;\n  }\n}\n\nconst withState: Visual[] = [\"aggregate\", \"process\", \"projector\"];\n", "export function createSchemas(art: Art): {\n  map: string;\n  schemas: Record<string, string>;\n} {\n  const schemas: Record<string, string> = {};\n\n  const addSchema = (schema: Schema) => {\n    const name = schema.toString();\n    console.log(\"... schema\", name);\n\n    let content = toZod(schema, 1);\n    const refs: string[] = [];\n", "    if (schema.base) {\n      refs.push(schema.base.toString());\n      addSchema(schema.base);\n      content = `${schema.base.toString()}.and(${content})`;\n    }\n    schema.forEach((field) => {\n      if (!ScalarFieldTypes.includes(field.type as any)) {\n        const ref = field.type as Schema;\n        refs.push(ref.toString());\n        addSchema(ref);\n      }\n    });\n    const imports = refs\n      .sort()\n      .map((schema) => `import { ${schema} } from \"./${schema}.schema\";`)\n      .join(\"\\n\");\n\n    schemas[name] = `import { z } from \"zod\";\n${imports.length ? `${imports}\\n` : \"\"}\nexport const ${name} = ${content}\n  `;\n  };\n\n  // collect schemas\n  let state = art.ctx.schemas.get(art.name);", "  if (withState.includes(art.visual) && !state) {\n    state = new Schema(art.name);\n    if (art.visual === \"projector\")\n      state.set(\"id\", { name: \"id\", type: \"string\", required: true });\n  }\n  const artSchemas = [\n    state,\n    ...art.in.map((v) => v.ctx.schemas.get(v.name) ?? new Schema(v.name)),\n    ...art.out.map((v) => v.ctx.schemas.get(v.name) ?? new Schema(v.name)),\n  ].filter(Boolean);\n  artSchemas.forEach((schema) => addSchema(schema!));\n\n  // fake ouput schema for processes\n  const outputSchema =\n    art.visual === \"process\" &&\n    `export const ${art.name}OutputSchema = {\n  TodoOutputEvents: z.object({}),\n};`;\n\n  // collect art schemas in a file with imports to message and state schemas\n  const map = `${artSchemas\n    .map((schema) => schema!.name)\n    .sort()\n    .map((name) => `import { ${name} } from \"./${name}.schema\";`)\n    .join(\"\\n\")}  \n    \nexport const ${art.name}Schemas = {${toSchema(art)}\n};\n\n${outputSchema || \"\"}\n`;\n\n  return { map, schemas };\n}\n"]}
{"filename": "src/cli/gen-schema.ts", "chunked_list": ["#!/usr/bin/env node\n\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { Grammar } from \"../schema\";\n\nconst schema = zodToJsonSchema(Grammar, \"esml\");\nconsole.log(JSON.stringify(schema, null, 2));\n"]}
{"filename": "src/cli/generators.ts", "chunked_list": ["import json5 from \"json5\";\nimport path from \"node:path\";\nimport { compile } from \"../compiler\";\nimport { Grammar } from \"../schema\";\nimport type { ContextNode, Visual } from \"../types\";\nimport { createJestConfig, createPackageJson, createTsConfig } from \"./configs\";\nimport { createSchemas, toDefault, toDefaultEvent } from \"./schemas\";\nimport {\n  generateDockerCompose,\n  generateScripts,", "  generateDockerCompose,\n  generateScripts,\n  generateVsCodeTasks,\n} from \"./scripts\";\nimport { Art } from \"./types\";\nimport { createDirectory, createFile, decamelize } from \"./utils\";\n\nfunction createIndexFile(filePath: string, arts: Art[]): void {\n  const indexContent = `import { app, bootstrap } from \"@rotorsoft/eventually\";\nimport { ExpressApp } from \"@rotorsoft/eventually-express\";\n${arts\n  .map(({ name, visual }) => `import { ${name} } from \"./${name}.${visual}\";`)\n  .join(\"\\n\")}\n  \nbootstrap(async () => {\n  app(new ExpressApp())\\n${arts", "    .map(({ name }) => `    .with(${name})`)\n    .join(\"\\n\")};\n  app().build();\n  await app().listen();\n});`;\n  createFile(filePath, indexContent);\n}\n\ntype ArtResult = { content: string; unitTest: string };\n\nconst artMap: { [key in Visual]?: (art: Art) => ArtResult } = {\n  aggregate: createAggregate,\n  system: createSystem,\n  policy: createPolicy,\n  process: createProcess,\n  projector: createProjector,\n};\n\nconst Arts: Array<Visual> = [\n  \"aggregate\",\n  \"system\",\n  \"policy\",\n  \"process\",\n  \"projector\",\n];\n", "type ArtResult = { content: string; unitTest: string };\n\nconst artMap: { [key in Visual]?: (art: Art) => ArtResult } = {\n  aggregate: createAggregate,\n  system: createSystem,\n  policy: createPolicy,\n  process: createProcess,\n  projector: createProjector,\n};\n\nconst Arts: Array<Visual> = [\n  \"aggregate\",\n  \"system\",\n  \"policy\",\n  \"process\",\n  \"projector\",\n];\n", "function createAggregate(art: Art): ArtResult {\n  const content = `import { InferAggregate } from \"@rotorsoft/eventually\";\nimport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n  \nexport const ${art.name} = (stream: string): InferAggregate<typeof ${\n    art.name\n  }Schemas> => ({\n  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n  stream,\n  schemas: ${art.name}Schemas,\n  init: () => (${toDefault(art.ctx.schemas.get(art.name))}),\n  reduce: {\n${art.out\n  .map(\n    (event) => `    ${event.name}: (state, { data }) => ({ ...state, ...data })`\n  )\n  .join(\",\\n\")} \n  },\n  given: {\n${art.in.map((command) => `    ${command.name}: []`).join(\",\\n\")} \n  },\n  on: {\n${art.in\n  .map(\n    (command) =>\n      `    ${command.name}: (data, state, actor) => { return Promise.resolve([]); }`\n  )\n  .join(\",\\n\")} \n  },\n});  \n`;\n\n  const unitTest = `import { app, client, dispose } from \"@rotorsoft/eventually\";\nimport { ${art.name} } from \"../${art.name}.${art.visual}\";\nimport { randomUUID } from \"node:crypto\";\n\ndescribe(\"${art.name} ${art.visual}\", () => {\n  beforeAll(() => {", "    app().with(${art.name}).build();\n  });\n\n  afterAll(async () => {\n    await dispose()();\n  });\n\n  it(\"should handle commands\", async() => {\n    const target = { stream: randomUUID(), actor: { id: randomUUID(), name: \"actor\", roles: [] } };\n${art.in\n  .map(\n    (command) =>\n      `    await client().command(${art.name}, \"${command.name}\", ${toDefault(\n        command.ctx.schemas.get(command.name)\n      )}, target);`\n  )\n  .join(\"\\n\")}\n    const snap = await client().load(${art.name}, target.stream);\n    expect(snap.state).toBeDefined;\n  })\n})  \n`;\n\n  return { content, unitTest };\n}\n", "function createSystem(art: Art): ArtResult {\n  const content = `import { InferSystem } from \"@rotorsoft/eventually\";\nimport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n  \nexport const ${art.name} = (): InferSystem<typeof ${art.name}Schemas> => ({\n  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n  stream: \"${art.name}\",\n  schemas: ${art.name}Schemas,\n  on: {\n${art.in\n  .map(\n    (command) =>\n      `    ${command.name}: (data, state, actor) => { return Promise.resolve([]); }`\n  )\n  .join(\",\\n\")} \n  },\n});  \n`;\n\n  const unitTest = `import { app, client, dispose } from \"@rotorsoft/eventually\";\nimport { ${art.name} } from \"../${art.name}.${art.visual}\";\nimport { randomUUID } from \"node:crypto\";\n\ndescribe(\"${art.name} ${art.visual}\", () => {\n  beforeAll(() => {", "    app().with(${art.name}).build();\n  });\n\n  afterAll(async () => {\n    await dispose()();\n  });\n\n  it(\"should handle commands\", async() => {\n    const target = { stream: randomUUID(), actor: { id: randomUUID(), name: \"actor\", roles: [] } };\n${art.in\n  .map(\n    (command) =>\n      `    await client().command(${art.name}, \"${command.name}\", ${toDefault(\n        command.ctx.schemas.get(command.name)\n      )}, target);`\n  )\n  .join(\"\\n\")}\n    const result = await client().query({ stream: \"${art.name}\" });\n    expect(result).toBeDefined();\n  })\n})  \n`;\n\n  return { content, unitTest };\n}\n", "function createPolicy(art: Art): ArtResult {\n  const content = `import { InferPolicy } from \"@rotorsoft/eventually\";\nimport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n  \nexport const ${art.name} = (): InferPolicy<typeof ${art.name}Schemas> => ({\n  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n  schemas: ${art.name}Schemas,\n  on: {\n${art.in\n  .map(\n    (event) => `    ${event.name}: () => { return Promise.resolve(undefined); }`\n  )\n  .join(\",\\n\")} \n  },\n});\n`;\n\n  const unitTest = `import { app, broker, client, dispose } from \"@rotorsoft/eventually\";\nimport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\ndescribe(\"${art.name} ${art.visual}\", () => {\n  beforeAll(() => {", "    app().with(${art.name}).build();\n  });\n\n  afterAll(async () => {\n    await dispose()();\n  });\n\n  it(\"should handle events\", async() => {\n${art.in\n  .map(\n    (event) =>\n      `    await client().event(${art.name}, ${toDefaultEvent(event)});`\n  )\n  .join(\"\\n\")}\n    await broker().drain();\n    expect(1).toBeDefined; // TODO: expect side effects\n  })\n})  \n`;\n\n  return { content, unitTest };\n}\n", "function createProcess(art: Art): ArtResult {\n  const content = `import { InferProcessManager } from \"@rotorsoft/eventually\";\nimport { ${art.name}Schemas, ${art.name}OutputSchema } from \"./schemas/${\n    art.name\n  }\";\n  \nexport const ${art.name} = (): InferProcessManager<typeof ${\n    art.name\n  }Schemas, typeof ${art.name}OutputSchema> => ({\n  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n  schemas: ${art.name}Schemas,\n  init: () => (${toDefault(art.ctx.schemas.get(art.name))}),\n  reduce: {\n    TodoOutputEvents: (state, { data }) => ({ ...state, ...data }), // TODO: reduce all output events\n  },\n  actor: {\n${art.in\n  .map((event) => `    ${event.name}: ({ stream }) => stream`)\n  .join(\",\\n\")} \n  },\n  on: {\n${art.in\n  .map(\n    (event) => `    ${event.name}: () => { return Promise.resolve(undefined); }`\n  )\n  .join(\",\\n\")} \n  },\n});\n`;\n\n  const unitTest = `import { app, broker, client, dispose } from \"@rotorsoft/eventually\";\nimport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\ndescribe(\"${art.name} ${art.visual}\", () => {\n  beforeAll(() => {", "    app().with(${art.name}).build();\n  });\n\n  afterAll(async () => {\n    await dispose()();\n  });\n\n  it(\"should handle events\", async() => {\n${art.in\n  .map(\n    (event) =>\n      `    await client().event(${art.name}, ${toDefaultEvent(event)});`\n  )\n  .join(\"\\n\")}\n    await broker().drain();\n    expect(1).toBeDefined; // TODO: expect side effects\n  })\n})  \n`;\n\n  return { content, unitTest };\n}\n", "function createProjector(art: Art): ArtResult {\n  const content = `import { client, InferProjector } from \"@rotorsoft/eventually\";\nimport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n  \nexport const ${art.name} = (): InferProjector<typeof ${art.name}Schemas> => ({\n  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n  schemas: ${art.name}Schemas,\n  on: {\n${art.in\n  .map(\n    (event) =>\n      `    ${event.name}: async ({ stream, data }, map) => {\n        const id = stream; // TBD\n        // load current state?\n        const state = map.records.get(id) ?? (await client().read(${art.name}, id)).at(0)?.state ?? { id };\n        const patches = [{}]; // TBD\n        return patches; // TBD\n      }`\n  )\n  .join(\",\\n\")} \n  },\n});\n`;\n\n  const unitTest = `import { app, broker, client, dispose } from \"@rotorsoft/eventually\";\nimport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\ndescribe(\"${art.name} ${art.visual}\", () => {\n  beforeAll(() => {", "    app().with(${art.name}).build();\n  });\n\n  afterAll(async () => {\n    await dispose()();\n  });\n\n  it(\"should handle events\", async() => {\n    await client().project(${art.name}, [\n${art.in.map((event) => `      ${toDefaultEvent(event)}`).join(\",\\n\")}\n    ]);\n    await broker().drain();\n    const records = await client().read(${art.name}, \"projectionId\", ()=>{});\n  })\n})  \n`;\n\n  return { content, unitTest };\n}\n", "export function createArtifacts(\n  ctx: ContextNode,\n  callback: (\n    art: Art,\n    result: ArtResult,\n    schemas: { map: string; schemas: Record<string, string> }\n  ) => void\n): Art[] {\n  const refs = ctx\n    ? [...ctx.nodes.values()]\n        .filter((node) => node.visual === \"command\" && node.refs) // commands with refs\n        .flatMap((cmd) =>\n          [...cmd.refs!.values()]\n            .filter((ref) => ref.visual !== \"actor\") // skip actor refs\n            .flatMap(({ name }) => ({ name, cmd }))\n        )\n    : [];\n\n  const arts: Art[] = ctx\n    ? [...ctx.nodes.entries()]\n        .filter(([, value]) => Arts.includes(value.visual))\n        .map(([name, value]) => ({\n          ...value,\n          in: [...ctx.edges.values()]\n            .filter(({ target }) => target.name === name)\n            .map(({ source }) => source),\n          out: [...ctx.edges.values()]\n            .filter(({ source }) => source.name === name)\n            .map(({ target }) => target)\n            .concat(\n              refs.filter((ref) => ref.name === name).map(({ cmd }) => cmd) // commands with refs to this art\n            ),\n        }))\n        .sort((a, b) => a.name.localeCompare(b.name))\n    : [];\n\n  arts.forEach((art) => {\n    const result = artMap[art.visual]!(art);\n    const schemas = createSchemas(art);\n    callback(art, result, schemas);\n  });\n\n  return arts;\n}\n", "function generateContext(\n  cdir: string,\n  name: string,\n  ctx: ContextNode,\n  workspace = false\n): void {\n  createDirectory(cdir);\n  createPackageJson(cdir, name);\n  createJestConfig(cdir);\n  workspace && createTsConfig(cdir, \"../../tsconfig.json\");\n  createDirectory(path.join(cdir, \"src\"));\n  createDirectory(path.join(cdir, \"src\", \"schemas\"));\n  createDirectory(path.join(cdir, \"src\", \"__tests__\"));\n  createDirectory(path.join(cdir, \"dist\"));\n\n  const arts = createArtifacts(ctx, (art, result, schemas) => {\n    createFile(\n      path.join(cdir, `src/${art.name}.${art.visual}.ts`),\n      result.content\n    );\n    createFile(\n      path.join(cdir, `src/__tests__/${art.name}.spec.ts`),\n      result.unitTest\n    );\n    Object.entries(schemas.schemas).forEach(([name, content]) =>\n      createFile(path.join(cdir, `src/schemas/${name}.schema.ts`), content)\n    );\n    createFile(path.join(cdir, `src/schemas/${art.name}.ts`), schemas.map);\n  });\n\n  createIndexFile(path.join(cdir, \"src/index.ts\"), arts);\n}\n", "export function generateContexts(\n  pdir: string,\n  project: string,\n  code: string\n): void {\n  const model = Grammar.parse(json5.parse(code));\n  const root = compile(model);\n  const ids = [...root.nodes.keys()].map((id) => decamelize(id)).sort();\n  createPackageJson(\n    pdir,\n    project,\n    ids.map((id) => `packages/${id}`)\n  );\n  createDirectory(path.join(pdir, \"packages\"));\n  root.nodes.forEach((node, name) => {\n    const pkg = decamelize(name);\n    generateContext(\n      path.join(pdir, \"packages\", pkg),\n      pkg,\n      node as ContextNode,\n      true\n    );\n  });\n  generateVsCodeTasks(path.join(pdir, \".vscode\"), ids);\n  generateScripts(path.join(pdir, \"scripts\"));\n  generateDockerCompose(pdir, ids);\n}\n"]}
{"filename": "src/cli/scripts.ts", "chunked_list": ["import path from \"node:path\";\nimport { createDirectory, createFile } from \"./utils\";\n\nconst devScript = `#!/bin/bash\nset -e\n\nif [ $# -eq 0 ]; then\n    echo \"Missing service name!\"\n    echo \"Usage: npm run dev service-name [port]\"\n    exit 1", "    echo \"Usage: npm run dev service-name [port]\"\n    exit 1\nfi;\n\nreadonly service=\"$1\"\nreadonly target=\"./packages/$\\{service\\}\"\n\nif [ ! -d $target ]; then\n    echo \"Invalid service name: $\\{service\\}\"\n    exit 1", "    echo \"Invalid service name: $\\{service\\}\"\n    exit 1\nfi;\n\nreadonly port=\"$2\"\n\necho \">>> Loading [.env] variables...\"\nset -o allexport\n# shellcheck source=/dev/null # Disable shellcheck source following\n. ./.env set", "# shellcheck source=/dev/null # Disable shellcheck source following\n. ./.env set\nset +o allexport\n\necho \">>> Running [$service] in development mode...\"\ncd $target\nPORT=$port ts-node-dev --transpile-only --respawn ./src/index.ts\ncd ../..\n`;\n\nexport function generateScripts(dir: string): void {\n  createDirectory(dir);\n  createFile(path.join(dir, \"dev.sh\"), devScript);\n}\n", "`;\n\nexport function generateScripts(dir: string): void {\n  createDirectory(dir);\n  createFile(path.join(dir, \"dev.sh\"), devScript);\n}\n\nexport function generateVsCodeTasks(dir: string, ids: string[]): void {\n  createDirectory(dir);\n  const group = \"all-eventually-apps\";\n  const tasks = {\n    version: \"2.0.0\",\n    tasks: [{ label: group, dependsOn: ids }].concat(\n      ids.map(\n        (id, index) =>\n          ({\n            label: id,\n            type: \"shell\",\n            command: `npm run dev ${id} ${3000 + index}`,\n            presentation: {\n              reveal: \"always\",\n              panel: \"new\",\n              group,\n            },\n          } as any)\n      )\n    ),\n  };\n  createFile(path.join(dir, \"tasks.json\"), JSON.stringify(tasks, null, 2));\n}\n", "export function generateDockerCompose(dir: string, ids: string[]): void {\n  ids.forEach((id) =>\n    createFile(\n      path.join(dir, \"packages\", id, \"Dockerfile\"),\n      `FROM node:18-alpine\nWORKDIR /app\nCOPY dist ./dist\nCOPY package.json ./\nRUN npm install\nEXPOSE 3000\nCMD [ \"npm\", \"start\" ]\n`\n    )\n  );\n  createFile(\n    path.join(dir, \"docker-compose.yml\"),\n    `version: '3'\nservices:\n${ids\n  .map(\n    (id, index) => `  ${id}:\n    build:\n      context: ./packages/${id}\n      dockerfile: Dockerfile\n    ports:\n      - ${3000 + index}:3000\n    environment:\n      - LOG_LEVEL=trace\n      - OAS_UI=Rapidoc\n    command: npm start\n`\n  )\n  .join(\"\\n\")}\n`\n  );\n}\n"]}
