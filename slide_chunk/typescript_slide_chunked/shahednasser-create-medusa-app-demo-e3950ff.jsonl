{"filename": "src/index.ts", "chunked_list": ["#!/usr/bin/env node\nimport { program } from \"commander\"\nimport create from \"./commands/create.js\"\n\nprogram\n  .description(\"Create a new Medusa project\")\n  .option(\"--repo-url <url>\", \"URL of repository to use to setup project.\")\n  .option(\"--seed\", \"Seed the created database with demo data.\")\n  .parse()\n", "  .parse()\n\ncreate(program.opts())\n"]}
{"filename": "src/commands/create.ts", "chunked_list": ["import inquirer from \"inquirer\"\nimport slugifyType from \"slugify\"\nimport chalk from \"chalk\"\nimport pg from \"pg\"\nimport createDb from \"../utils/create-db.js\"\nimport postgresClient from \"../utils/postgres-client.js\"\nimport cloneRepo from \"../utils/clone-repo.js\"\nimport prepareProject from \"../utils/prepare-project.js\"\nimport startMedusa from \"../utils/start-medusa.js\"\nimport open from \"open\"", "import startMedusa from \"../utils/start-medusa.js\"\nimport open from \"open\"\nimport waitOn from \"wait-on\"\nimport formatConnectionString from \"../utils/format-connection-string.js\"\nimport ora from \"ora\"\nimport fs from \"fs\"\nimport { nanoid } from \"nanoid\"\nimport isEmailImported from \"validator/lib/isEmail.js\"\nimport logMessage from \"../utils/log-message.js\"\nimport onProcessTerminated from \"../utils/on-process-terminated.js\"", "import logMessage from \"../utils/log-message.js\"\nimport onProcessTerminated from \"../utils/on-process-terminated.js\"\nimport createAbortController, {\n  isAbortError,\n} from \"../utils/create-abort-controller.js\"\n\nconst slugify = slugifyType.default\nconst isEmail = isEmailImported.default\n\ntype CreateOptions = {\n  repoUrl?: string\n  seed?: boolean\n}\n\nexport default async ({ repoUrl = \"\", seed }: CreateOptions) => {\n  const abortController = createAbortController()\n\n  const { projectName } = await inquirer.prompt([\n    {\n      type: \"input\",\n      name: \"projectName\",\n      message: \"What's the name of your project?\",\n      default: \"my-medusa-store\",\n      filter: (input) => {\n        return slugify(input)\n      },\n      validate: (input) => {", "\ntype CreateOptions = {\n  repoUrl?: string\n  seed?: boolean\n}\n\nexport default async ({ repoUrl = \"\", seed }: CreateOptions) => {\n  const abortController = createAbortController()\n\n  const { projectName } = await inquirer.prompt([\n    {\n      type: \"input\",\n      name: \"projectName\",\n      message: \"What's the name of your project?\",\n      default: \"my-medusa-store\",\n      filter: (input) => {\n        return slugify(input)\n      },\n      validate: (input) => {", "        if (!input.length) {\n          return \"Please enter a project name\"\n        }\n        return fs.existsSync(input) && fs.lstatSync(input).isDirectory()\n          ? \"A directory already exists with the same name. Please enter a different project name.\"\n          : true\n      },\n    },\n  ])\n\n  let client: pg.Client | undefined\n  let dbConnectionString = \"\"\n  let postgresUsername = \"postgres\"\n  let postgresPassword = \"\"\n\n  // try to log in with default db username and password", "  try {\n    client = await postgresClient({\n      user: postgresUsername,\n      password: postgresPassword,\n    })\n  } catch (e) {\n    // ask for the user's credentials\n    const answers = await inquirer.prompt([\n      {\n        type: \"input\",\n        name: \"postgresUsername\",\n        message: \"Enter your Postgres username\",\n        default: \"postgres\",\n        validate: (input) => {\n          return typeof input === \"string\" && input.length > 0\n        },\n      },\n      {\n        type: \"password\",\n        name: \"postgresPassword\",\n        message: \"Enter your Postgres password\",\n      },\n    ])\n\n    postgresUsername = answers.postgresUsername\n    postgresPassword = answers.postgresPassword\n", "    try {\n      client = await postgresClient({\n        user: postgresUsername,\n        password: postgresPassword,\n      })\n    } catch (e) {\n      logMessage({\n        message:\n          \"Couldn't connect to PostgreSQL. Make sure you have PostgreSQL installed and the credentials you provided are correct.\\n\\n\" +\n          \"You can learn how to install PostgreSQL here: https://docs.medusajs.com/development/backend/prepare-environment#postgresql\",\n        type: \"error\",\n      })\n    }\n  }\n\n  const { adminEmail } = await inquirer.prompt([\n    {\n      type: \"input\",\n      name: \"adminEmail\",\n      message: \"Enter an email for your admin dashboard user\",\n      default: !seed ? \"admin@medusa-test.com\" : undefined,\n      validate: (input) => {\n        return typeof input === \"string\" && input.length > 0 && isEmail(input)\n          ? true\n          : \"Please enter a valid email\"\n      },\n    },\n  ])\n\n  const spinner = ora(chalk.white(\"Setting up project\")).start()\n\n  onProcessTerminated(() => spinner.stop())\n\n  // clone repository", "  try {\n    await cloneRepo({\n      directoryName: projectName,\n      repoUrl,\n      abortController,\n    })\n  } catch (e) {\n    if (isAbortError(e)) {\n      process.exit()\n    }\n\n    logMessage({\n      message: `An error occurred while setting up your project: ${e}`,\n      type: \"error\",\n    })\n  }\n\n  spinner.succeed(chalk.green(\"Created project directory\")).start()\n", "  if (client) {\n    spinner.text = chalk.white(\"Creating database...\")\n    const dbName = `medusa-${nanoid(4)}`\n    // create postgres database\n    try {\n      await createDb({\n        client,\n        db: dbName,\n      })\n    } catch (e) {\n      logMessage({\n        message: `An error occurred while trying to create your database: ${e}`,\n        type: \"error\",\n      })\n    }\n\n    // format connection string\n    dbConnectionString = formatConnectionString({\n      user: postgresUsername,\n      password: postgresPassword,\n      host: client.host,\n      db: dbName,\n    })\n\n    spinner.succeed(chalk.green(`Database ${dbName} created`)).start()\n  }\n\n  spinner.text = chalk.white(\"Preparing project...\")\n\n  // prepare project\n  let inviteToken: string | undefined = undefined", "    } catch (e) {\n      logMessage({\n        message: `An error occurred while trying to create your database: ${e}`,\n        type: \"error\",\n      })\n    }\n\n    // format connection string\n    dbConnectionString = formatConnectionString({\n      user: postgresUsername,\n      password: postgresPassword,\n      host: client.host,\n      db: dbName,\n    })\n\n    spinner.succeed(chalk.green(`Database ${dbName} created`)).start()\n  }\n\n  spinner.text = chalk.white(\"Preparing project...\")\n\n  // prepare project\n  let inviteToken: string | undefined = undefined", "  try {\n    inviteToken = await prepareProject({\n      directory: projectName,\n      dbConnectionString,\n      admin: {\n        email: adminEmail,\n      },\n      seed,\n      spinner,\n      abortController,\n    })", "  } catch (e: any) {\n    if (isAbortError(e)) {\n      process.exit()\n    }\n\n    logMessage({\n      message: `An error occurred while preparing project: ${e}`,\n      type: \"error\",\n    })\n  }\n\n  spinner.succeed(chalk.green(\"Project Prepared\"))\n\n  // close db connection\n  await client?.end()\n\n  // start backend\n  logMessage({\n    message: \"Starting Medusa...\",\n  })\n", "  try {\n    startMedusa({\n      directory: projectName,\n      abortController,\n    })\n  } catch (e) {\n    if (isAbortError(e)) {\n      process.exit()\n    }\n\n    logMessage({\n      message: `An error occurred while starting Medusa`,\n      type: \"error\",\n    })\n  }\n\n  waitOn({\n    resources: [\"http://localhost:9000/health\"],\n  }).then(() =>\n    open(\n      inviteToken\n        ? `http://localhost:9000/app/invite?token=${inviteToken}`\n        : \"http://localhost:9000/app\"\n    )\n  )\n}\n"]}
{"filename": "src/utils/on-process-terminated.ts", "chunked_list": ["export default (fn: Function) => {\n  process.on(\"SIGTERM\", () => fn())\n  process.on(\"SIGINT\", () => fn())\n}\n"]}
{"filename": "src/utils/prepare-project.ts", "chunked_list": ["import chalk from \"chalk\"\nimport fs from \"fs\"\nimport path from \"path\"\nimport { Ora } from \"ora\"\nimport promiseExec from \"./promise-exec.js\"\nimport { EOL } from \"os\"\nimport runProcess from \"./run-process.js\"\nimport getFact from \"./get-fact.js\"\nimport onProcessTerminated from \"./on-process-terminated.js\"\nimport boxen from \"boxen\"", "import onProcessTerminated from \"./on-process-terminated.js\"\nimport boxen from \"boxen\"\n\ntype PrepareOptions = {\n  directory: string\n  dbConnectionString: string\n  admin?: {\n    email: string\n  }\n  seed?: boolean\n  spinner?: Ora\n  abortController?: AbortController\n}\n\nconst showFact = (lastFact: string, spinner: Ora): string => {\n  const fact = getFact(lastFact)\n  spinner.text = `${boxen(fact, {\n    title: chalk.cyan(\"Installing Dependencies...\"),\n    titleAlignment: \"center\",\n    textAlignment: \"center\",\n    padding: 1,\n    margin: 1,\n    float: \"center\",\n  })}`\n  return fact\n}\n\nexport default async ({\n  directory,\n  dbConnectionString,\n  admin,\n  seed,\n  spinner,\n  abortController,\n}: PrepareOptions) => {\n  // initialize execution options\n  const execOptions = {\n    cwd: directory,\n    signal: abortController?.signal,\n  }\n\n  // initialize the invite token to return\n  let inviteToken: string | undefined = undefined\n\n  // add connection string to project\n  fs.appendFileSync(\n    path.join(directory, `.env`),\n    `DATABASE_TYPE=postgres${EOL}DATABASE_URL=${dbConnectionString}`\n  )\n\n  let interval: NodeJS.Timer | undefined = undefined\n  let fact = \"\"", "  if (spinner) {\n    spinner.spinner = {\n      frames: [\"\"],\n    }\n    fact = showFact(fact, spinner)\n    interval = setInterval(() => {\n      fact = showFact(fact, spinner)\n    }, 6000)\n\n    onProcessTerminated(() => clearInterval(interval))\n  }\n\n  await runProcess({\n    process: async () => {", "      try {\n        await promiseExec(`yarn`, execOptions)\n      } catch (e) {\n        // yarn isn't available\n        // use npm\n        await promiseExec(`npm install`, execOptions)\n      }\n    },\n    ignoreERESOLVE: true,\n  })\n", "  if (interval) {\n    clearInterval(interval)\n  }\n\n  if (spinner) {\n    spinner.spinner = \"dots\"\n    spinner.succeed(chalk.green(\"Installed Dependencies\"))\n    spinner.start(chalk.white(\"Running Migrations...\"))\n  }\n\n  // run migrations\n  await runProcess({\n    process: async () => {\n      await promiseExec(\n        \"npx -y @medusajs/medusa-cli@latest migrations run\",\n        execOptions\n      )\n    },\n  })\n\n  spinner?.succeed(chalk.green(\"Ran Migrations\")).start()\n", "  if (admin) {\n    // create admin user\n    if (spinner) {\n      spinner.text = chalk.white(\"Creating an admin user...\")\n    }\n\n    await runProcess({\n      process: async () => {\n        const proc = await promiseExec(\n          `npx -y @medusajs/medusa-cli@1.3.15-snapshot-20230529090917 user -e ${admin.email} --invite`,\n          execOptions\n        )\n        // get invite token from stdout\n        const match = proc.stdout.match(/Invite token: (?<token>.+)/)\n        inviteToken = match?.groups?.token\n      },\n    })\n\n    spinner?.succeed(chalk.green(\"Created admin user\")).start()\n  }\n", "  if (seed) {\n    if (spinner) {\n      spinner.text = chalk.white(\"Seeding database...\")\n    }\n\n    // check if a seed file exists in the project\n    if (!fs.existsSync(path.join(directory, \"data\", \"seed.jsons\"))) {\n      spinner\n        ?.warn(\n          chalk.yellow(\n            \"Seed file was not found in the project. Skipping seeding...\"\n          )\n        )\n        .start()\n      return\n    }\n", "    if (spinner) {\n      spinner.text = chalk.white(\"Seeding database with demo data...\")\n    }\n\n    await runProcess({\n      process: async () => {\n        await promiseExec(\n          `npx -y @medusajs/medusa-cli@latest seed --seed-file=${path.join(\n            \"data\",\n            \"seed.json\"\n          )}`,\n          execOptions\n        )\n      },\n    })\n\n    spinner?.succeed(chalk.green(\"Seeded database with demo data\")).start()\n  }\n\n  return inviteToken\n}\n"]}
{"filename": "src/utils/create-db.ts", "chunked_list": ["import pg from \"pg\"\n\ntype CreateDbOptions = {\n  client: pg.Client\n  db: string\n}\n\nexport default async ({ client, db }: CreateDbOptions) => {\n  await client.query(`CREATE DATABASE \"${db}\"`)\n}\n"]}
{"filename": "src/utils/promise-exec.ts", "chunked_list": ["import { exec } from \"child_process\"\nimport util from \"util\"\n\nconst promiseExec = util.promisify(exec)\n\nexport default promiseExec\n"]}
{"filename": "src/utils/postgres-client.ts", "chunked_list": ["import pg from \"pg\"\nconst { Client } = pg\n\ntype PostgresConnection = {\n  user?: string\n  password?: string\n}\n\nexport default async (connect: PostgresConnection) => {\n  const client = new Client(connect)\n\n  await client.connect()\n\n  return client\n}\n"]}
{"filename": "src/utils/create-abort-controller.ts", "chunked_list": ["import onProcessTerminated from \"./on-process-terminated.js\"\n\nexport default () => {\n  const abortController = new AbortController()\n  onProcessTerminated(() => abortController.abort())\n  return abortController\n}\n\nexport const isAbortError = (e: any) =>\n  e !== null && \"code\" in e && e.code === \"ABORT_ERR\"", "export const isAbortError = (e: any) =>\n  e !== null && \"code\" in e && e.code === \"ABORT_ERR\"\n"]}
{"filename": "src/utils/get-fact.ts", "chunked_list": ["const facts = [\n  \"Plugins allow you to integrate third-party services for payment, fulfillment, notifications, and more.\",\n  \"You can specify a product's availability in one or more sales channels.\",\n  \"Payment and shipping options and providers can be configured per region.\",\n  \"Tax-inclusive pricing allows you to set prices for products, shipping options, and more without having to worry about calculating taxes.\",\n  \"Medusa provides multi-currency and region support, with full control over prices for each currency and region.\",\n  \"You can organize customers by customer groups and set special prices for them.\",\n  \"You can specify the inventory of products per location and sales channel.\",\n  \"Publishable-API Keys allow you to send requests to the backend within a scoped resource.\",\n  \"You can create custom endpoints by creating a TypeScript file under the src/api directory.\",", "  \"Publishable-API Keys allow you to send requests to the backend within a scoped resource.\",\n  \"You can create custom endpoints by creating a TypeScript file under the src/api directory.\",\n  \"You can listen to events to perform asynchornus actions using Subscribers.\",\n  \"An entity represents a table in the database. You can create a table by creating a custom entity and migration.\",\n  \"Medusa's store endpoint paths are prefixed by /store. The admin endpoints are prefixed by /admin.\",\n  \"Medusa provides a JavaScript client and a React library that you can use to build a storefront or a custom admin.\",\n  \"Services are classes with methods related to an entity or functionality. You can create a custom service in a TypeScript file under src/services.\",\n  \"Modules allow you to replace an entire functionality with your custom logic.\",\n  \"The event bus module is responsible for triggering events and relaying them to subscribers.\",\n  \"The cache module is responsible for caching data that requires heavy computation.\",\n]\n\nexport default (lastFact = \"\") => {\n  let index = 0", "  \"The event bus module is responsible for triggering events and relaying them to subscribers.\",\n  \"The cache module is responsible for caching data that requires heavy computation.\",\n]\n\nexport default (lastFact = \"\") => {\n  let index = 0\n  if (lastFact.length) {\n    const lastFactIndex = facts.findIndex((fact) => fact === lastFact)\n\n    if (lastFactIndex !== facts.length - 1) {\n      index = lastFactIndex + 1\n    }\n  }\n\n  return facts[index]\n}\n", "    if (lastFactIndex !== facts.length - 1) {\n      index = lastFactIndex + 1\n    }\n  }\n\n  return facts[index]\n}\n"]}
{"filename": "src/utils/run-process.ts", "chunked_list": ["type ProcessOptions = {\n  process: Function\n  ignoreERESOLVE?: boolean\n}\n\n// when running commands with npx or npm sometimes they\n// terminate with EAGAIN error unexpectedly\n// this utility function allows retrying the process if\n// EAGAIN occurs, or otherwise throw the error that occurs\nexport default async ({ process, ignoreERESOLVE }: ProcessOptions) => {\n  let processError = false\n  do {", "    try {\n      await process()\n    } catch (error) {\n      if (\n        typeof error === \"object\" &&\n        error !== null &&\n        \"code\" in error &&\n        error?.code === \"EAGAIN\"\n      ) {\n        processError = true\n      } else if (\n        ignoreERESOLVE &&\n        typeof error === \"object\" &&\n        error !== null &&\n        \"code\" in error &&\n        error?.code === \"ERESOLVE\"\n      ) {\n        // ignore error\n      } else {\n        throw error\n      }\n    }", "      } else if (\n        ignoreERESOLVE &&\n        typeof error === \"object\" &&\n        error !== null &&\n        \"code\" in error &&\n        error?.code === \"ERESOLVE\"\n      ) {\n        // ignore error\n      } else {\n        throw error\n      }\n    }", "  } while (processError)\n}\n"]}
{"filename": "src/utils/format-connection-string.ts", "chunked_list": ["type ConnectionStringOptions = {\n  user?: string\n  password?: string\n  host?: string\n  db: string\n}\n\nexport default ({ user, password, host, db }: ConnectionStringOptions) => {\n  let connection = `postgres://`\n  if (user) {\n    connection += user\n  }\n", "  if (user) {\n    connection += user\n  }\n\n  if (password) {\n    connection += `:${password}`\n  }\n\n  if (user || password) {\n    connection += \"@\"\n  }\n\n  connection += `${host}/${db}`\n\n  return connection\n}\n", "  if (user || password) {\n    connection += \"@\"\n  }\n\n  connection += `${host}/${db}`\n\n  return connection\n}\n"]}
{"filename": "src/utils/clone-repo.ts", "chunked_list": ["import promiseExec from \"./promise-exec.js\"\n\ntype CloneRepoOptions = {\n  directoryName?: string\n  repoUrl?: string\n  abortController?: AbortController\n}\n\nconst DEFAULT_REPO =\n  \"https://github.com/medusajs/medusa-starter-default -b feat/onboarding\"\n\nexport default async ({\n  directoryName = \"\",\n  repoUrl,\n  abortController,\n}: CloneRepoOptions) => {\n  await promiseExec(`git clone ${repoUrl || DEFAULT_REPO} ${directoryName}`, {\n    signal: abortController?.signal,\n  })\n}\n"]}
{"filename": "src/utils/start-medusa.ts", "chunked_list": ["import { exec } from \"child_process\"\n\ntype StartOptions = {\n  directory: string\n  abortController?: AbortController\n}\n\nexport default ({ directory, abortController }: StartOptions) => {\n  const childProcess = exec(`npx -y @medusajs/medusa-cli develop`, {\n    cwd: directory,\n    signal: abortController?.signal,\n  })\n\n  childProcess.stdout?.pipe(process.stdout)\n}\n"]}
{"filename": "src/utils/log-message.ts", "chunked_list": ["import chalk from \"chalk\"\nimport { program } from \"commander\"\n\ntype LogOptions = {\n  message: string\n  type?: \"error\" | \"success\" | \"info\" | \"warning\"\n}\n\nexport default ({ message, type = \"info\" }: LogOptions) => {\n  switch (type) {\n    case \"info\":\n      console.log(chalk.white(message))\n      break\n    case \"success\":\n      console.log(chalk.green(message))\n      break\n    case \"warning\":\n      console.log(chalk.yellow(message))\n      break\n    case \"error\":\n      program.error(chalk.bold.red(message))\n  }\n}\n"]}
