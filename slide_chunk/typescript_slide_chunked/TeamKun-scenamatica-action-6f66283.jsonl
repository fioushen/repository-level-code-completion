{"filename": "src/main.ts", "chunked_list": ["import * as fs from \"node:fs\"\nimport { deployServer } from \"./server/deployer.js\"\nimport { startTests } from \"./server/controller.js\"\nimport type { Args } from \"./utils.js\"\nimport { getArguments } from \"./utils.js\"\nimport {info, setFailed} from \"@actions/core\";\nimport {context, getOctokit} from \"@actions/github\";\nimport type {PullRequestInfo} from \"./outputs/pull-request/appender\";\nimport {initPullRequest} from \"./server/client\";\n", "import {initPullRequest} from \"./server/client\";\n\nconst main = async (): Promise<void> => {\n    const args: Args = getArguments()\n\n    const { mcVersion,\n        javaVersion,\n        scenamaticaVersion,\n        serverDir,\n        pluginFile,", "        serverDir,\n        pluginFile,\n        githubToken\n    } = args\n\n    const pullRequest = context.payload.pull_request\n\n    if (pullRequest) {\n        initPRMode(pullRequest, githubToken)\n    }\n", "    if (!fs.existsSync(pluginFile)) {\n        setFailed(`Plugin file ${pluginFile} does not exist`)\n\n        return\n    }\n\n    const paper = await deployServer(serverDir, javaVersion, mcVersion, scenamaticaVersion)\n\n    info(\"Starting tests...\")\n\n    await startTests(serverDir, paper, pluginFile)\n}\n\nconst initPRMode = (pullRequest: {number: number}, token: string) => {\n    info(`Running in Pull Request mode for PR #${pullRequest.number}`)\n\n    const prInfo: PullRequestInfo = {\n        number: pullRequest.number,\n        octokit: getOctokit(token),\n        owner: context.repo.owner,\n        repository: context.repo.repo\n    }\n\n\n    initPullRequest(prInfo)\n}\n", "main().catch((error) => {\n    if (error instanceof Error)\n        setFailed(error)\n    else {\n        const message = error as string\n\n        setFailed(message)\n    }\n})\n"]}
{"filename": "src/logging.ts", "chunked_list": ["import type {PacketSessionEnd, Scenario, TestState} from \"./packets\";\nimport { TestResultCause} from \"./packets\";\nimport {endGroup, info, startGroup, warning} from \"@actions/core\";\n\nexport const logTestStart = (scenario: Scenario): void => {\n    startGroup(`Test: ${scenario.name}`)\n    info(`Starting test: ${scenario.name} (${scenario.description ?? \"(No description provided)\"})`)\n}\n\nexport const logTestEnd = (", "\nexport const logTestEnd = (\n    name: string,\n    state: TestState,\n    cause: TestResultCause,\n    startedAt: number,\n    finishedAt: number,\n): void => {\n    const elapsed = `${finishedAt - startedAt} ms`\n    const emoji = getEmojiForCause(cause)", "    const elapsed = `${finishedAt - startedAt} ms`\n    const emoji = getEmojiForCause(cause)\n\n    switch (cause) {\n        case TestResultCause.CANCELLED: {\n            info(`${emoji} The test ${name} is cancelled with state ${state} in ${elapsed}.`)\n\n            break\n        }\n", "        }\n\n        case TestResultCause.PASSED: {\n            info(`${emoji} The test ${name} is passed with state ${state} in ${elapsed}.`)\n\n            break\n        }\n\n        case TestResultCause.SKIPPED: {\n            info(`${emoji} The test ${name} is skipped with state ${state} in ${elapsed}.`)", "        case TestResultCause.SKIPPED: {\n            info(`${emoji} The test ${name} is skipped with state ${state} in ${elapsed}.`)\n\n            break\n        }\n\n        default: {\n            warning(`${emoji} The test ${name} is failed with state ${state} in ${elapsed}.`)\n\n            break", "\n            break\n        }\n    }\n\n    endGroup()\n}\n\nexport const getEmojiForCause = (cause: TestResultCause): string => {\n    switch (cause) {", "export const getEmojiForCause = (cause: TestResultCause): string => {\n    switch (cause) {\n        case TestResultCause.PASSED: {\n            return \"\u2714\"\n        }\n\n        case TestResultCause.SKIPPED: {\n            return \"\u2794\"\n        }\n", "        }\n\n        case TestResultCause.CANCELLED: {\n            return \":no_entry:\"\n        }\n\n        default: {\n            return \"\u274c\"\n        }\n    }", "        }\n    }\n}\n\nexport const logSessionStart = (startedAt: number, tests: number): void => {\n    info(\"--------------------------------------\")\n    info(\" T E S T S\")\n    info(\"--------------------------------------\")\n    info(`The session is started at ${startedAt}, ${tests} tests are marked to be run.`)\n}", "    info(`The session is started at ${startedAt}, ${tests} tests are marked to be run.`)\n}\n\nexport const logSessionEnd = (sessionEnd: PacketSessionEnd): void => {\n    const elapsed = `${Math.ceil((sessionEnd.finishedAt - sessionEnd.startedAt) / 1000)} sec`\n    const {results} = sessionEnd\n    const total = results.length\n\n    const failures = results.filter(\n        (t) =>", "    const failures = results.filter(\n        (t) =>\n            !(\n                t.cause === TestResultCause.PASSED ||\n                t.cause === TestResultCause.SKIPPED ||\n                t.cause === TestResultCause.CANCELLED\n            ),\n    ).length\n\n    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length", "\n    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length\n\n    info(`\\nResults:\\n`)\n    info(`Tests run: ${total}, Failures: ${failures}, Skipped: ${skipped}, Time elapsed: ${elapsed}\\n`)\n}\n\n"]}
{"filename": "src/packets.ts", "chunked_list": ["// @ts-nocheck\n\nexport class Packet<T extends Packet<T>> {\n    public constructor(public genre: string, public type: string, public date: number) {}\n}\n\nexport interface Scenario {\n    name: string\n    description?: string\n}\n", "export class PacketTestStart implements Packet<PacketTestStart> {\n    public genre = \"test\"\n\n    public type = \"start\"\n\n    public constructor(public date: number, public scenario: Scenario) {}\n}\n\nexport enum TestState {\n    STAND_BY = \"STAND_BY\",\n    CONTEXT_PREPARING = \"CONTEXT_PREPARING\",\n    STARTING = \"STARTING\",\n    RUNNING_BEFORE = \"RUNNING_BEFORE\",\n    RUNNING_MAIN = \"RUNNING_MAIN\",\n    RUNNING_AFTER = \"RUNNING_AFTER\",\n    FINISHED = \"FINISHED\",\n}\n", "export enum TestState {\n    STAND_BY = \"STAND_BY\",\n    CONTEXT_PREPARING = \"CONTEXT_PREPARING\",\n    STARTING = \"STARTING\",\n    RUNNING_BEFORE = \"RUNNING_BEFORE\",\n    RUNNING_MAIN = \"RUNNING_MAIN\",\n    RUNNING_AFTER = \"RUNNING_AFTER\",\n    FINISHED = \"FINISHED\",\n}\n\nexport enum TestResultCause {\n    PASSED = \"PASSED\",\n\n    CONTEXT_PREPARATION_FAILED = \"CONTEXT_PREPARATION_FAILED\",\n    ACTION_EXECUTION_FAILED = \"ACTION_EXECUTION_FAILED\",\n    ACTION_EXPECTATION_JUMPED = \"ACTION_EXPECTATION_JUMPED\",\n    SCENARIO_TIMED_OUT = \"SCENARIO_TIMED_OUT\",\n    ILLEGAL_CONDITION = \"ILLEGAL_CONDITION\",\n\n    INTERNAL_ERROR = \"INTERNAL_ERROR\",\n    CANCELLED = \"CANCELLED\",\n    SKIPPED = \"SKIPPED\",\n}\n", "export enum TestResultCause {\n    PASSED = \"PASSED\",\n\n    CONTEXT_PREPARATION_FAILED = \"CONTEXT_PREPARATION_FAILED\",\n    ACTION_EXECUTION_FAILED = \"ACTION_EXECUTION_FAILED\",\n    ACTION_EXPECTATION_JUMPED = \"ACTION_EXPECTATION_JUMPED\",\n    SCENARIO_TIMED_OUT = \"SCENARIO_TIMED_OUT\",\n    ILLEGAL_CONDITION = \"ILLEGAL_CONDITION\",\n\n    INTERNAL_ERROR = \"INTERNAL_ERROR\",\n    CANCELLED = \"CANCELLED\",\n    SKIPPED = \"SKIPPED\",\n}\n", "export class PacketTestEnd implements Packet<PacketTestEnd> {\n    public genre = \"test\"\n\n    public type = \"end\"\n\n    public constructor(\n        public date: number,\n        public scenario: Scenario,\n        public state: TestState,\n        public cause: TestResultCause,\n        public startedAt: number,\n        public finishedAt: number,\n    ) {}\n}\n", "export class PacketSessionStart implements Packet<PacketSessionStart> {\n    public genre = \"session\"\n\n    public type = \"start\"\n\n    public constructor(\n        public date: number,\n        public tests: PacketTestStart[],\n        public isAutoStart: boolean,\n        public startedAt: number,\n    ) {}\n}\n", "export class PacketSessionEnd implements Packet<PacketSessionEnd> {\n    public genre = \"session\"\n\n    public type = \"end\"\n\n    public constructor(\n        public date: number,\n        public results: PacketTestEnd[],\n        public startedAt: number,\n        public finishedAt: number,\n    ) {}\n}\n", "export class PacketScenamaticaError implements Packet<PacketScenamaticaError> {\n    public genre = \"general\"\n\n    public type = \"error\"\n    public constructor(public date: number, public exception: string, public message: string, public stackTrace: string[]) {}\n}\n\nexport const parsePacket = (\n    packet: string,\n): Packet<PacketSessionEnd | PacketSessionStart | PacketTestEnd | PacketTestStart> | null => {\n    const json: unknown = JSON.parse(packet)\n\n    switch (json.genre) {\n        case \"session\": {\n            switch (json.type) {\n                case \"start\": {\n                    return new PacketSessionStart(json.date, json.tests, json.isAutoStart, json.startedAt)\n                }\n\n                case \"end\": {\n                    return new PacketSessionEnd(json.date, json.results, json.startedAt, json.date)\n                }\n            }\n\n            break\n        }\n        case \"test\": {\n            switch (json.type) {\n                case \"start\": {\n                    return new PacketTestStart(json.date, json.scenario)\n                }\n\n                case \"end\": {\n                    return new PacketTestEnd(\n                        json.date,\n                        json.scenario,\n                        json.state,\n                        json.cause,\n                        json.startedAt,\n                        json.finishedAt,\n                    )\n                }\n            }\n\n            break\n        }\n\n        case \"general\": {\n            switch (json.type) {\n                case \"error\": {\n                    return new PacketScenamaticaError(json.date, json.exception, json.message, json.stackTrace)\n                }\n            }\n\n            break\n        }\n    }\n\n    return null\n}\n\nexport * from \"./packets\"\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import * as core from \"@actions/core\"\nimport type {PacketTestEnd} from \"./packets\";\nimport {TestResultCause} from \"./packets\";\n\nconst DEFAULT_SCENAMATICA_VERSION = \"0.7.0\"\nconst ENV_NO_SCENAMATICA = \"NO_SCENAMATICA\"\n\nconst extractTestResults = (results: PacketTestEnd[]) => {\n    const total = results.length\n    const passed = results.filter((t) => t.cause === TestResultCause.PASSED).length", "    const total = results.length\n    const passed = results.filter((t) => t.cause === TestResultCause.PASSED).length\n    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length\n    const cancelled = results.filter((t) => t.cause === TestResultCause.CANCELLED).length\n\n    const failures = results.filter(\n        (t) =>\n            !(\n                t.cause === TestResultCause.PASSED ||\n                t.cause === TestResultCause.SKIPPED ||", "                t.cause === TestResultCause.PASSED ||\n                t.cause === TestResultCause.SKIPPED ||\n                t.cause === TestResultCause.CANCELLED\n            ),\n    ).length\n\n\n    return {\n        total,\n        passed,", "        total,\n        passed,\n        failures,\n        skipped,\n        cancelled,\n    }\n}\n\nexport const isTestSucceed = (results: PacketTestEnd[]) => {\n    const {failures} = extractTestResults(results)", "export const isTestSucceed = (results: PacketTestEnd[]) => {\n    const {failures} = extractTestResults(results)\n    const threshold = getArguments().failThreshold\n\n    return failures <= threshold\n}\n\ninterface Args {\n    mcVersion: string\n    scenamaticaVersion: string\n    serverDir: string\n    pluginFile: string\n    javaVersion: string\n    githubToken: string\n    failThreshold: number\n}\n\nconst getArguments = (): Args => {\n    return {\n        mcVersion: core.getInput(\"minecraft\") || \"1.16.5\",\n        scenamaticaVersion: core.getInput(\"scenamatica\", ) || DEFAULT_SCENAMATICA_VERSION,\n        serverDir: core.getInput(\"server-dir\") || \"server\",\n        pluginFile: core.getInput(\"plugin\", { required: true }),\n        javaVersion: core.getInput(\"java\") || \"17\",\n        githubToken: core.getInput(\"github-token\") || process.env.GITHUB_TOKEN!,\n        failThreshold: Number.parseInt(core.getInput(\"fail-threshold\"), 10) || 0,\n    }\n}\n\nconst isNoScenamatica = (): boolean => {\n    return process.env[ENV_NO_SCENAMATICA] === \"true\"\n}\n\nexport { extractTestResults, getArguments, Args, isNoScenamatica }\n"]}
{"filename": "src/outputs/messages.ts", "chunked_list": ["import {extractTestResults, getArguments} from \"../utils\";\nimport type {PacketTestEnd} from \"../packets\";\nimport {getEmojiForCause} from \"../logging\";\n\nconst MESSAGES_PASSED = [\n    \":tada: Congrats! All tests passed! :star2:\",\n    \":raised_hands: High-five! You nailed all the tests! :tada::tada:\",\n    \":confetti_ball: Hooray! Everything's working perfectly! :tada::confetti_ball:\",\n    \":100: Perfect score! All tests passed with flying colors! :rainbow::clap:\",\n    \":thumbsup: Great job! All tests passed without a hitch! :rocket::star2:\",", "    \":100: Perfect score! All tests passed with flying colors! :rainbow::clap:\",\n    \":thumbsup: Great job! All tests passed without a hitch! :rocket::star2:\",\n    \":metal: Rock on! All tests passed flawlessly! :guitar::metal:\",\n    \":partying_face: Celebrate good times! All tests passed with flying colors! :tada::confetti_ball::balloon:\",\n    \":muscle: You crushed it! All tests passed with ease! :fire::muscle:\",\n    \":1st_place_medal: Gold medal performance! All tests passed with flying colors! :1st_place_medal::star2:\",\n    \":champagne: Pop the champagne! All tests passed, time to celebrate! :champagne::tada:\"\n];\n\nconst MESSAGES_NO_TESTS = [", "\nconst MESSAGES_NO_TESTS = [\n    \"Alright, who forgot to write tests? :face_with_raised_eyebrow:\",\n    \"No tests? Time to break out the crystal ball. :crystal_ball:\",\n    \"Tests? Who writes tests? :person_shrugging:\",\n    \"No tests found. Did they run away? :man_running: :woman_running:\",\n    \"No tests, no glory. :trophy:\",\n    \"Tests? We don't need no stinkin' tests! :shushing_face:\",\n    \"No tests? I guess we'll just have to wing it. :eagle:\",\n    \"You get a test, and you get a test! Everybody gets a test! :gift: :tada:\",", "    \"No tests? I guess we'll just have to wing it. :eagle:\",\n    \"You get a test, and you get a test! Everybody gets a test! :gift: :tada:\",\n    \"No tests? That's impossible! :dizzy_face:\",\n    \"Tests make the code go round. :carousel_horse:\"\n];\n\nconst MESSAGES_FAILED = [\n    \"Oops! Something went wrong! :scream_cat:\",\n    \"Oh no! The tests have betrayed us! :scream:\",\n    \"Houston, we have a problem. :rocket:\",", "    \"Oh no! The tests have betrayed us! :scream:\",\n    \"Houston, we have a problem. :rocket:\",\n    \"Looks like we have some debugging to do. :beetle:\",\n    \"Failures? More like opportunities to improve! :muscle:\",\n    \"This is not the result we were looking for. :confused:\",\n    \"Looks like we need to rethink our strategy. :thinking:\",\n    \"Don't worry, we'll get 'em next time! :sunglasses:\",\n    \"Keep calm and debug on. :female_detective:\",\n    \"The only way is up from here! :rocket:\"\n];", "    \"The only way is up from here! :rocket:\"\n];\n\nconst MESSAGES_PASSED_WITH_THRESHOLD = [\n    \"Tests passed, but some are being rebellious. Debug mode: ON! :microscope:\",\n    \"Almost there! Some tests failed, but hey, progress is progress! :turtle:\",\n    \"Good news: most tests passed. Bad news: a few had different plans. Let's fix 'em! :hammer:\",\n    \"We're on the right track, but some tests are playing hard to get. Challenge accepted! :muscle:\",\n    \"Tests went well overall, but we have a few stubborn failures. Time for some gentle persuasion! :wrench:\",\n    \"Success with a side of failures. It's like a bittersweet symphony. Let's sweeten it up! :musical_note:\",", "    \"Tests went well overall, but we have a few stubborn failures. Time for some gentle persuasion! :wrench:\",\n    \"Success with a side of failures. It's like a bittersweet symphony. Let's sweeten it up! :musical_note:\",\n    \"We're soaring high, but some tests got left behind. Time to reel them back in! :fishing_pole_and_fish:\",\n    \"Great progress, but we've got some test gremlins causing trouble. Let's send them packing! :imp:\",\n    \"Victory is ours, with a sprinkle of defeat. Let's conquer those pesky failures! :crossed_swords:\",\n    \"We're almost there, but a few tests are being rebellious. Let's bring them back to the flock! :sheep:\"\n];\n\nconst REPORT_URL = \"https://github.com/TeamKun/Scenamatica/issues/new?assignees=PeyaPeyaPeyang&labels=Type%3A+Bug&projects=&template=bug_report.yml&title=%E3%80%90%E3%83%90%E3%82%B0%E3%80%91\"\n", "const REPORT_URL = \"https://github.com/TeamKun/Scenamatica/issues/new?assignees=PeyaPeyaPeyang&labels=Type%3A+Bug&projects=&template=bug_report.yml&title=%E3%80%90%E3%83%90%E3%82%B0%E3%80%91\"\n\nexport const getHeader = (isError: boolean) => {\n    const result = [ wrap(\"h1\", \"Scenamatica\"), wrap(\"h2\", \"Summary\"), \"<hr />\"]\n\n    if (isError) {\n        result.push(\n            wrap(\"h4\", \":no_entry: ERROR!!\"),\n            wrap(\"p\", \"An unexpected error occurred while running the server and Scenamatica daemon.\"),\n            wrap(\"h2\", \"Error details\")\n        )\n    }\n\n    return joinLine(...result)\n}\n\nexport const getRunningMessage = () => {\n    const messages = [\n        wrap(\"h4\", \":hourglass_flowing_sand: Hey there! :wave: We're currently testing your plugin.\"),\n        wrap(\"p\", \"The testing process may take some time, but we'll update this message once it's complete.\")\n    ]\n\n    return joinLine(...messages)\n}\n\nexport const getTestSummary = (results: PacketTestEnd[], startedAt: number, finishedAt: number) => {\n    const elapsed = (finishedAt - startedAt) / 1000\n\n    const {\n        total,\n        passed,\n        failures,\n        skipped,\n        cancelled\n    } = extractTestResults(results)\n\n\n    return joinLine(\n        getSummaryHeader(total, elapsed, passed, failures, skipped, cancelled),\n        \"<hr />\",\n        wrap(\"h2\", \"Details\")\n    )\n}\n\nexport const getTestResultTable = (results: PacketTestEnd[], minimize = false) => {\n    const header = wrap(\"thead\", joinLine(\n            wrap(\"tr\", joinLine(\n                wrap(\"th\", \" \"),\n                wrap(\"th\", \"Test\"),\n                wrap(\"th\", \"Cause\"),\n                wrap(\"th\", \"State\"),\n                wrap(\"th\", \"Started at\"),\n                wrap(\"th\", \"Finished at\"),\n                wrap(\"th\", \"Elapsed\"),\n                wrap(\"th\", \"Test description\")\n            ))\n        )\n    )\n\n    const body = wrap(\"tbody\", joinLine(...results.map((result) => {\n            const {\n                cause,\n                state,\n                scenario,\n                startedAt,\n                finishedAt\n            } = result\n\n            const emoji = getEmojiForCause(cause)\n            const { name } = scenario\n            const startedAtStr = new Date(startedAt).toLocaleString()\n            const finishedAtStr = new Date(finishedAt).toLocaleString()\n            const testElapsed = `${Math.ceil((finishedAt - startedAt) / 1000)} sec`\n            const description = scenario.description || \"No description\"\n\n            return wrap(\"tr\", joinLine(\n                wrap(\"td\", emoji),\n                wrap(\"td\", name),\n                wrap(\"td\", cause),\n                wrap(\"td\", state),\n                wrap(\"td\", startedAtStr),\n                wrap(\"td\", finishedAtStr),\n                wrap(\"td\", testElapsed),\n                wrap(\"td\", description)\n            ))\n        }))\n    )\n\n    const table = wrap(\"table\", joinLine(header, body))\n", "    if (minimize)\n        return wrap(\"details\", joinLine(\n            wrap(\"summary\", \"Full test results\"),\n            table\n        ))\n\n    return table\n}\n\nconst getSummaryHeader = (total: number, elapsed: number, passed: number, failures: number, skipped: number, cancelled: number) => {\n    const threshold = getArguments().failThreshold\n\n    let messageSource: string[]\n", "    if (total === passed + skipped) messageSource = MESSAGES_PASSED\n    else if (failures === 0) messageSource = MESSAGES_NO_TESTS\n    else if (failures <= threshold) messageSource = MESSAGES_PASSED_WITH_THRESHOLD\n    else messageSource = MESSAGES_FAILED\n\n    const summaryText = messageSource[Math.floor(Math.random() * messageSource.length)]\n\n    return joinLine(\n        wrap(\"h4\", summaryText),\n        \"<br />\",\n        wrap(\"p\", join(\", \",\n            `Tests run: ${total}`,\n            `Failures: ${failures}`,\n            `Skipped: ${skipped}`,\n            `Cancelled: ${cancelled}`,\n            `Time elapsed: ${elapsed} sec`\n        ))\n    )\n}\n\nexport const getExceptionString = (errorType: string, errorMessage: string, errorStackTrace: string[]) => {\n    return wrap(\"pre\", wrap(\"code\", joinLine(\n                \"An unexpected error has occurred while running Scenamatica daemon:\",\n                `${errorType}: ${errorMessage}`,\n                ...errorStackTrace.map((s) => `    at ${s}`)\n            )\n    ))\n}\n\nexport const getReportingMessage = () => {\n    return joinLine(\n        wrap(\"h2\", \"Reporting bugs\"),\n        wrap(\"p\", combine(\n            \"If you believe this is a bug, please report it to \",\n            wrap(\"a\", \"Scenamatica\", { href: REPORT_URL }),\n            \" along with the contents of this error message, the above stack trace, and the environment information listed below.\"\n        )),\n        getEnvInfoMessage()\n    )\n}\n\nexport const getFooter = () => {\n    return joinLine(\n        \"<hr />\",\n        getLicenseMessage()\n    )\n}\n\nconst getEnvInfoMessage = () => {\n    const runArgs = getArguments()\n\n    const envInfo = [\n        \"+ Versions:\",\n        `  - Scenamatica: ${runArgs.scenamaticaVersion}`,\n        `  - Minecraft: ${runArgs.mcVersion}`,\n        `  - Java: ${runArgs.javaVersion}`,\n        `  - Node.js: ${process.version}`,\n        \"+ Runner:\",\n        `  - OS: ${process.platform}`,\n        `  - Arch: ${process.arch}`,\n    ]\n\n    return wrap(\"details\", joinLine(\n        wrap(\"summary\", \"Environment Information\"),\n        wrap(\"pre\", wrap(\"code\", envInfo.join(\"\\n\")))\n    ))\n}\n\nconst getLicenseMessage = () => {\n    return joinLine(\n        wrap(\"h2\" , \"License\"),\n        wrap(\"small\", `This test report has been generated by ${\n            wrap(\"a\", \"Scenamatica\", { href: \"https://github.com/TeamKUN/Scenamatica\" })\n        } and licensed under ${\n            wrap(\"a\", \"MIT License\", { href: \"https://github.com/TeamKUN/Scenamatica/blob/main/LICENSE\" })\n        }.`),\n        \"<br />\",\n        wrap(\"small\", \"You can redistribute it and/or modify it under the terms of the MIT License.\")\n    )\n}\n\nconst wrap = (tag: string, text: string, props: { [key: string]: string } = {}) => {\n    const attributes = Object.entries(props).map(([key, value]) => `${key}=\"${value}\"`).join(\" \")\n\n    return `<${tag} ${attributes}>${text}</${tag}>`\n}\n\nconst joinLine = (...texts: string[]) => {\n    return texts.join(\"\\n\")\n}\n\nconst join = (delimiter: string, ...texts: string[]) => {\n    return texts.join(delimiter)\n}\n\nconst combine = (...texts: string[]) => {\n    return texts.join(\"\")\n}\n"]}
{"filename": "src/outputs/publisher.ts", "chunked_list": ["import type { PacketSessionEnd,PacketScenamaticaError} from \"../packets\";\nimport {printErrorSummary, printSummary} from \"./summary\";\nimport {publishOutput} from \"./action-output\";\nimport type { PullRequestInfo} from \"./pull-request/appender\";\nimport {publishPRComment, reportRunning, reportError, reportSessionEnd} from \"./pull-request/appender\";\n\nexport const publishSessionEnd = async (packet: PacketSessionEnd) => {\n    await printSummary(packet)\n    publishOutput(packet)\n", "    publishOutput(packet)\n\n    reportSessionEnd(packet)\n}\n\nexport const publishScenamaticaError = async (packet: PacketScenamaticaError) => {\n    const {exception, message, stackTrace} = packet\n\n    await printErrorSummary(exception, message, stackTrace)\n    publishOutput(packet)", "    await printErrorSummary(exception, message, stackTrace)\n    publishOutput(packet)\n\n    reportError(packet)\n}\n\nexport const publishRunning = (info: PullRequestInfo) => {\n    reportRunning()\n    publishPRComment(info)  // \u5373\u53cd\u6620\n        .catch(console.error)\n}\n", "    publishPRComment(info)  // \u5373\u53cd\u6620\n        .catch(console.error)\n}\n"]}
{"filename": "src/outputs/summary.ts", "chunked_list": ["import type {PacketSessionEnd} from \"../packets\"\nimport {summary} from \"@actions/core\";\nimport {\n    getExceptionString,\n    getFooter,\n    getHeader,\n    getReportingMessage,\n    getTestResultTable,\n    getTestSummary\n} from \"./messages\";", "    getTestSummary\n} from \"./messages\";\n\nconst printSummary = async (sessionEnd: PacketSessionEnd) => {\n    const {results, finishedAt, startedAt} = sessionEnd\n\n    summary.addRaw(getHeader(false))\n    summary.addRaw(getTestSummary(results, startedAt, finishedAt))\n\n    summary.addRaw(getTestResultTable(results))", "\n    summary.addRaw(getTestResultTable(results))\n\n    await summary.write()\n}\n\nlet errorHeaderPrinted = false\nlet errorReportingMessagePrinted = false\n\nconst printErrorSummary = async (errorType: string, errorMessage: string, errorStackTrace: string[]) => {\n    if (!errorHeaderPrinted) {\n        summary.addRaw(getHeader(true))\n        errorHeaderPrinted = true\n    }\n\n    summary.addRaw(getExceptionString(errorType, errorMessage, errorStackTrace))\n", "\nconst printErrorSummary = async (errorType: string, errorMessage: string, errorStackTrace: string[]) => {\n    if (!errorHeaderPrinted) {\n        summary.addRaw(getHeader(true))\n        errorHeaderPrinted = true\n    }\n\n    summary.addRaw(getExceptionString(errorType, errorMessage, errorStackTrace))\n\n    if (!errorReportingMessagePrinted) {\n        summary.addRaw(getReportingMessage())\n        errorReportingMessagePrinted = true\n    }\n\n    await summary.write()\n}\n\nconst printFooter = async () => {\n    summary.addRaw(getFooter())\n\n    await summary.write()\n}\n\nexport { printSummary, printErrorSummary, printFooter }\n", "    if (!errorReportingMessagePrinted) {\n        summary.addRaw(getReportingMessage())\n        errorReportingMessagePrinted = true\n    }\n\n    await summary.write()\n}\n\nconst printFooter = async () => {\n    summary.addRaw(getFooter())\n\n    await summary.write()\n}\n\nexport { printSummary, printErrorSummary, printFooter }\n"]}
{"filename": "src/outputs/action-output.ts", "chunked_list": ["import type { PacketSessionEnd} from \"../packets\";\nimport {PacketScenamaticaError, TestResultCause} from \"../packets\";\nimport {setOutput} from \"@actions/core\";\nimport {isTestSucceed} from \"../utils\";\n\nexport const publishOutput = (packet: PacketScenamaticaError | PacketSessionEnd) => {\n    if (packet instanceof PacketScenamaticaError) {\n        publishError(packet)\n    } else {\n        publishSessionEnd(packet);\n    }\n}\n\nconst publishError = (packet: PacketScenamaticaError) => {\n    const {exception, message} = packet\n\n    setOutput(\"success\", false)\n    setOutput(\"runner-error-type\", exception)\n    setOutput(\"runner-error-message\", message)\n}\n\nconst publishSessionEnd = (packet: PacketSessionEnd) => {\n    const {results} = packet\n    const all = results.length\n    const passed = results.filter((t) => t.cause === TestResultCause.PASSED).length\n    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length\n    const cancelled = results.filter((t) => t.cause === TestResultCause.CANCELLED).length\n    const failed = all - passed - skipped - cancelled\n\n    setOutput(\"success\", isTestSucceed(results))\n    setOutput(\"tests\", all)\n    setOutput(\"tests-passes\", passed)\n    setOutput(\"tests-failures\", failed)\n    setOutput(\"tests-skips\", skipped)\n    setOutput(\"tests-cancels\", cancelled)\n}\n"]}
{"filename": "src/outputs/pull-request/appender.ts", "chunked_list": ["import type {PacketSessionEnd} from \"../../packets\";\nimport {\n    getExceptionString,\n    getFooter,\n    getHeader, getReportingMessage,\n    getRunningMessage,\n    getTestResultTable,\n    getTestSummary\n} from \"../messages\";\nimport { upsertReport} from \"./writer\";", "} from \"../messages\";\nimport { upsertReport} from \"./writer\";\nimport type {PacketScenamaticaError} from \"../../packets\";\nimport type {GitHub} from \"@actions/github/lib/utils\";\n\nlet headerPrinted = false\nlet containsError = false\nlet outMessage = \"\"\n\n\nexport interface PullRequestInfo {\n    octokit: InstanceType<typeof GitHub>;\n    owner: string;\n    repository: string;\n    number: number;\n}\n\nexport const reportError = (packet: PacketScenamaticaError) => {\n    const {exception, message, stackTrace} = packet\n\n    appendHeaderIfNotPrinted()\n\n    outMessage += getExceptionString(exception, message, stackTrace)\n    containsError = true\n}\n\nexport const reportRunning = () => {\n    appendHeaderIfNotPrinted()\n    outMessage += getRunningMessage()\n}\n\nexport const reportSessionEnd = (packet: PacketSessionEnd) => {\n    const {results, finishedAt, startedAt} = packet\n\n    appendHeaderIfNotPrinted()\n\n    outMessage += `${getTestSummary(results, startedAt, finishedAt)}\n        ${getTestResultTable(results, true)}\n    `\n}\n\nconst appendHeaderIfNotPrinted = () => {", "\n\nexport interface PullRequestInfo {\n    octokit: InstanceType<typeof GitHub>;\n    owner: string;\n    repository: string;\n    number: number;\n}\n\nexport const reportError = (packet: PacketScenamaticaError) => {\n    const {exception, message, stackTrace} = packet\n\n    appendHeaderIfNotPrinted()\n\n    outMessage += getExceptionString(exception, message, stackTrace)\n    containsError = true\n}\n\nexport const reportRunning = () => {\n    appendHeaderIfNotPrinted()\n    outMessage += getRunningMessage()\n}\n\nexport const reportSessionEnd = (packet: PacketSessionEnd) => {\n    const {results, finishedAt, startedAt} = packet\n\n    appendHeaderIfNotPrinted()\n\n    outMessage += `${getTestSummary(results, startedAt, finishedAt)}\n        ${getTestResultTable(results, true)}\n    `\n}\n\nconst appendHeaderIfNotPrinted = () => {", "    if (!headerPrinted) {\n        outMessage += `${getHeader(false)}`\n\n        headerPrinted = true\n    }\n}\n\nexport const publishPRComment = async (runData: PullRequestInfo) => {\n    if (containsError)\n        outMessage += getReportingMessage()\n\n    outMessage += getFooter()\n\n    await upsertReport(\n        runData.octokit,\n        runData.owner,\n        runData.repository,\n        runData.number,\n        outMessage\n    )\n\n    outMessage = \"\"\n    containsError = false\n    headerPrinted = false\n}\n", "    if (containsError)\n        outMessage += getReportingMessage()\n\n    outMessage += getFooter()\n\n    await upsertReport(\n        runData.octokit,\n        runData.owner,\n        runData.repository,\n        runData.number,\n        outMessage\n    )\n\n    outMessage = \"\"\n    containsError = false\n    headerPrinted = false\n}\n"]}
{"filename": "src/outputs/pull-request/writer.ts", "chunked_list": ["import type {IssueComment, Maybe, Repository} from \"@octokit/graphql-schema\";\nimport type {GitHub} from \"@actions/github/lib/utils\";\n\nconst COMMENT_IDENTIFIER = \"<!-- ### Scenamatica plugin analysis report ### -->\";\nconst COMMENT_AUTHOR_LOGIN = \"github-actions\"\n\nexport const findFirstReportComment = async (\n    octokit: InstanceType<typeof GitHub>,\n    owner: string,\n    repo: string,", "    owner: string,\n    repo: string,\n    number: number\n): Promise<IssueComment | undefined> => {\n    const query = `\n        query ($repo: String!, $owner: String!, $number: Int!) {\n            repository(name: $repo, owner: $owner) {\n                pullRequest(number: $number) {\n                    comments(first: 25) {\n                        nodes {", "                    comments(first: 25) {\n                        nodes {\n                            id\n                            author {\n                                login\n                            }\n                            body\n                        }\n                    }\n                }", "                    }\n                }\n            }\n        }\n    `\n\n    const response = await octokit.graphql<{repository: Repository}>(\n        query,\n        {\n            repo,", "        {\n            repo,\n            owner,\n            number\n        }\n    )\n\n    if (!response.repository.pullRequest) {\n        return undefined\n    }\n\n    const comment = response.repository.pullRequest.comments.nodes?.find(isScenamaticaReport)\n\n    return comment ?? undefined\n\n}\n\nexport const upsertReport = async (\n    octokit: InstanceType<typeof GitHub>,\n    owner: string,\n    repo: string,\n    number: number,\n    report: string\n) => {\n    const comment = await findFirstReportComment(octokit, owner, repo, number)\n\n    await (comment ? updateOldComment(octokit, owner, repo, comment.id, report) : postNewComment(octokit, owner, repo, number, report));\n}\n\nconst postNewComment = async (octokit: InstanceType<typeof GitHub>,\n                              owner: string,\n                              repo: string,\n                              number: number,\n                              body: string\n) => {\n    const fullBody = `${COMMENT_IDENTIFIER} \\n${body}`\n\n    await octokit.issues.createComment({\n        owner,\n        repo,\n        issue_number: number,\n        body: fullBody\n    })\n}\n\nconst updateOldComment = async (octokit: InstanceType<typeof GitHub>,\n                                owner: string,\n                                repo: string,\n                                commentId: string,\n                                body: string\n) => {\n    const fullBody = `${COMMENT_IDENTIFIER} \\n${body}`\n\n    const query = `\n        mutation ($input: UpdateIssueCommentInput!) {\n            updateIssueComment(input: $input) {\n                issueComment {\n                    id\n                    body\n                }\n            }\n        }\n    `\n\n    await octokit.graphql(\n        query,\n        {\n            input: {\n                id: commentId,\n                body: fullBody\n            }\n        })\n}\n\nconst isScenamaticaReport = (comment: Maybe<IssueComment>) => {", "    if (!comment) {\n        return false;\n    }\n\n    return comment.author?.login === COMMENT_AUTHOR_LOGIN\n        && comment.body.includes(COMMENT_IDENTIFIER);\n}\n"]}
{"filename": "src/server/deployer.ts", "chunked_list": ["import * as tc from \"@actions/tool-cache\"\nimport * as cache from \"@actions/cache\"\nimport * as io from \"@actions/io\"\nimport * as core from \"@actions/core\"\nimport path from \"node:path\"\nimport * as fs from \"node:fs\"\nimport * as yaml from \"js-yaml\"\nimport { exec } from \"@actions/exec\"\nimport fetch from \"node-fetch\"\nimport {startServerOnly} from \"./controller\";", "import fetch from \"node-fetch\"\nimport {startServerOnly} from \"./controller\";\nimport {info} from \"@actions/core\";\nimport {compare} from \"compare-versions\";\n\nconst PAPER_NAME = \"paper.jar\"\nconst PAPER_VERSION_URL = \"https://papermc.io/api/v2/projects/paper/versions/{version}/\"\nconst PAPER_DOWNLOAD_URL = `${PAPER_VERSION_URL}/builds/{build}/downloads/paper-{version}-{build}.jar`\nconst SCENAMATICA_URL = \"https://github.com/TeamKun/Scenamatica/releases/download/v{version}/Scenamatica-{version}.jar\"\n", "const SCENAMATICA_URL = \"https://github.com/TeamKun/Scenamatica/releases/download/v{version}/Scenamatica-{version}.jar\"\n\n\nconst JAVA_FETCH_URL =\n    \"https://api.azul.com/zulu/download/community/v1.0/bundles/?os={os}&arch={arch}&ext={ext}&java_version={version}&type=jdk\"\n\nconst genCacheKey = (javaVersion: string, mcVersion: string, scenamaticaVersion: string) => {\n    return `server-${mcVersion}-scenamatica-v${scenamaticaVersion}@java-${javaVersion}`\n}\n", "}\n\nconst restoreCache = async (\n    dir: string,\n    javaVersion: string,\n    mcVersion: string,\n    scenamaticaVersion: string,\n) => {\n    const cacheKey = genCacheKey(javaVersion, mcVersion, scenamaticaVersion)\n", "    const cacheKey = genCacheKey(javaVersion, mcVersion, scenamaticaVersion)\n\n    info(`Checking cache for ${cacheKey}`)\n\n    const cachedKey = await cache.restoreCache([dir], cacheKey)\n\n    return cachedKey === cacheKey\n}\n\nconst retrieveLatestPaperBuildFor = async (mcVersion: string): Promise<string> => {", "\nconst retrieveLatestPaperBuildFor = async (mcVersion: string): Promise<string> => {\n    const url = PAPER_VERSION_URL.replace(/\\{version}/g, mcVersion)\n    const response = await fetch(url)\n    const json = (await response.json()) as { builds: string[] }\n\n    return json.builds[json.builds.length - 1] // \u6700\u65b0\u306e\u30d3\u30eb\u30c9\u3092\u8fd4\u3059\n}\n\nconst downloadLatestPaper = async (destDir: string, mcVersion: string) => {", "\nconst downloadLatestPaper = async (destDir: string, mcVersion: string) => {\n    info(`Retrieving latest Paper build for ${mcVersion}`)\n\n    const build = await retrieveLatestPaperBuildFor(mcVersion)\n\n    info(`Retrieved latest Paper build for ${mcVersion}: The latest build is ${build}`)\n\n    const url = PAPER_DOWNLOAD_URL\n        .replace(/\\{version}/g, mcVersion)", "    const url = PAPER_DOWNLOAD_URL\n        .replace(/\\{version}/g, mcVersion)\n        .replace(/\\{build}/g, build)\n\n    info(`Downloading Paper ${mcVersion} build ${build} from ${url}`)\n\n    await io.mkdirP(destDir)\n\n    const dest = await tc.downloadTool(url, path.join(destDir, \"paper.jar\"))\n    // permission \u304c\u306a\u3044\u3068\u8d77\u52d5\u3067\u304d\u306a\u3044\u306e\u3067\u3001chmod \u3067\u4ed8\u4e0e\u3059\u308b", "    const dest = await tc.downloadTool(url, path.join(destDir, \"paper.jar\"))\n    // permission \u304c\u306a\u3044\u3068\u8d77\u52d5\u3067\u304d\u306a\u3044\u306e\u3067\u3001chmod \u3067\u4ed8\u4e0e\u3059\u308b\n    const os = process.platform === \"win32\" ? \"windows\" : \"unix\"\n\n    await (os === \"unix\" ? exec(\"chmod\", [\"+x\", dest]) : exec(\"icacls\", [dest, \"/grant\", \"Everyone:(F)\"]));\n\n    info(`Downloaded Paper ${mcVersion} build ${build} to ${dest}`)\n\n    return build\n}", "    return build\n}\n\nconst writeEula = async (dir: string) => {\n    const eulaPath = path.join(dir, \"eula.txt\")\n    const eulaContent = \"eula=true\\n\"\n\n    await fs.promises.writeFile(eulaPath, eulaContent)\n    info(`Wrote eula.txt to ${eulaPath}`)\n}", "    info(`Wrote eula.txt to ${eulaPath}`)\n}\n\nconst downloadScenamatica = async (destDir: string, version: string) => {\n    const url = SCENAMATICA_URL.replace(/\\{version}/g, version)\n\n    info(`Downloading Scenamatica ${version} from ${url}`)\n\n    const destPath = await tc.downloadTool(url, path.join(destDir, `Scenamatica-${version}.jar`))\n", "    const destPath = await tc.downloadTool(url, path.join(destDir, `Scenamatica-${version}.jar`))\n\n    info(`Downloaded Scenamatica ${version} to ${destPath}`)\n\n    return destPath\n}\n\nconst fetchLatestJavaLinkFor = async (version: string) => {\n    const processPlatform = process.platform\n    const platform = processPlatform === \"win32\" ? \"windows\" : processPlatform === \"darwin\" ? \"macos\" : \"linux\"", "    const processPlatform = process.platform\n    const platform = processPlatform === \"win32\" ? \"windows\" : processPlatform === \"darwin\" ? \"macos\" : \"linux\"\n    const arch = process.arch === \"x64\" ? \"x86_64\" : \"x86\"\n    const ext = platform === \"windows\" ? \"zip\" : \"tar.gz\"\n\n    const url = JAVA_FETCH_URL.replace(/\\{os}/g, platform)\n        .replace(/\\{arch}/g, arch)\n        .replace(/\\{ext}/g, ext)\n        .replace(/\\{version}/g, version)\n", "        .replace(/\\{version}/g, version)\n\n    const response = await fetch(url)\n    const json = (await response.json()) as Array<{ url: string }>\n\n    return {\n        url: json[0].url,\n        isTar: ext === \"tar.gz\",\n    }\n}", "    }\n}\n\nconst downloadJava = async (destBaseDir: string, version: string) => {\n    info(`Retrieving latest Java build for ${version}`)\n\n    const { url, isTar } = await fetchLatestJavaLinkFor(version) // \u6700\u65b0\u306e Java \u30d3\u30eb\u30c9\u306e URL \u3092\u53d6\u5f97\n\n    info(`Retrieved latest Java build for ${version}: ${url}`)\n", "    info(`Retrieved latest Java build for ${version}: ${url}`)\n\n    const dest = await tc.downloadTool(url, path.join(destBaseDir, \"java-package\"))\n\n    info(`Downloaded Java ${version} to ${dest}`)\n\n    const destDir = path.join(destBaseDir, \"java\")\n\n    info(\"Extracting...\")\n    await (isTar ? tc.extractTar(dest, destDir) : tc.extractZip(dest, destDir))", "    info(\"Extracting...\")\n    await (isTar ? tc.extractTar(dest, destDir) : tc.extractZip(dest, destDir))\n\n    core.addPath(path.join(destDir, \"bin\"))\n\n    info(`Installed Java ${version}`)\n}\n\nconst isJavaInstalled = async () => {\n    try {\n        await exec(\"java\", [\"-version\"])\n\n        return true\n    } catch {\n        return false\n    }\n}\n\nexport const deployServer = async (\n    dir: string,\n    javaVersion: string,\n    mcVersion: string,\n    scenamaticaVersion: string,\n): Promise<string> => {\n    const pluginDir = path.join(dir, \"plugins\")\n    // \u30ad\u30e3\u30c3\u30b7\u30e5\u306e\u5fa9\u5143\n    const cached = await restoreCache(dir, javaVersion, mcVersion, scenamaticaVersion)\n", "const isJavaInstalled = async () => {\n    try {\n        await exec(\"java\", [\"-version\"])\n\n        return true\n    } catch {\n        return false\n    }\n}\n\nexport const deployServer = async (\n    dir: string,\n    javaVersion: string,\n    mcVersion: string,\n    scenamaticaVersion: string,\n): Promise<string> => {\n    const pluginDir = path.join(dir, \"plugins\")\n    // \u30ad\u30e3\u30c3\u30b7\u30e5\u306e\u5fa9\u5143\n    const cached = await restoreCache(dir, javaVersion, mcVersion, scenamaticaVersion)\n", "    if (cached)\n        return new Promise<string>((resolve) => {\n            resolve(PAPER_NAME)\n        })\n    // \u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u306a\u3044\u306e\u3067 Paper \u3092\u30d3\u30eb\u30c9\u3059\u308b\u3002\n\n    info(\"Building server...\")\n\n    // Java \u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n    if (!(await isJavaInstalled())) await downloadJava(dir, javaVersion)\n\n    // Paper \u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n    await io.mkdirP(pluginDir)\n    await downloadLatestPaper(dir, mcVersion)\n    await downloadScenamatica(pluginDir, scenamaticaVersion)\n\n    await writeEula(dir) // eula.txt \u3092\u66f8\u304d\u8fbc\u307e\u306a\u3044\u3068 Paper \u304c\u8d77\u52d5V\u3057\u306a\u3044\n    await startServerOnly(dir, PAPER_NAME)\n\n    await initScenamaticaConfig(path.join(pluginDir, \"Scenamatica\"), scenamaticaVersion)\n\n    await cache.saveCache([dir], genCacheKey(javaVersion, mcVersion, scenamaticaVersion))\n\n    return PAPER_NAME\n}\n\nexport const deployPlugin = async (serverDir: string, pluginFile: string) => {\n    const pluginDir = path.join(serverDir, \"plugins\")\n\n    await io.mkdirP(pluginDir)\n\n    await io.cp(pluginFile, pluginDir)\n}\n\nconst initScenamaticaConfig = async (configDir: string, scenamaticaVersion: string) => {\n    const configPath = path.join(configDir, \"config.yml\")\n\n    const configData = yaml.load(await fs.promises.readFile(configPath, \"utf8\")) as {\n        interfaces?: {\n            raw: boolean\n        },\n        reporting?: {  // v0.6.1 \u304b\u3089\u3002\n            raw: boolean\n        }\n    }\n", "    if (!(await isJavaInstalled())) await downloadJava(dir, javaVersion)\n\n    // Paper \u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n    await io.mkdirP(pluginDir)\n    await downloadLatestPaper(dir, mcVersion)\n    await downloadScenamatica(pluginDir, scenamaticaVersion)\n\n    await writeEula(dir) // eula.txt \u3092\u66f8\u304d\u8fbc\u307e\u306a\u3044\u3068 Paper \u304c\u8d77\u52d5V\u3057\u306a\u3044\n    await startServerOnly(dir, PAPER_NAME)\n\n    await initScenamaticaConfig(path.join(pluginDir, \"Scenamatica\"), scenamaticaVersion)\n\n    await cache.saveCache([dir], genCacheKey(javaVersion, mcVersion, scenamaticaVersion))\n\n    return PAPER_NAME\n}\n\nexport const deployPlugin = async (serverDir: string, pluginFile: string) => {\n    const pluginDir = path.join(serverDir, \"plugins\")\n\n    await io.mkdirP(pluginDir)\n\n    await io.cp(pluginFile, pluginDir)\n}\n\nconst initScenamaticaConfig = async (configDir: string, scenamaticaVersion: string) => {\n    const configPath = path.join(configDir, \"config.yml\")\n\n    const configData = yaml.load(await fs.promises.readFile(configPath, \"utf8\")) as {\n        interfaces?: {\n            raw: boolean\n        },\n        reporting?: {  // v0.6.1 \u304b\u3089\u3002\n            raw: boolean\n        }\n    }\n", "    if (compare(scenamaticaVersion, \"0.7.0\", \">=\")) {\n        configData[\"reporting\"]![\"raw\"] = true\n    } else {\n        configData[\"interfaces\"]![\"raw\"] = true\n    }\n\n\n    await fs.promises.writeFile(configPath, yaml.dump(configData))\n}\n"]}
{"filename": "src/server/controller.ts", "chunked_list": ["import {isNoScenamatica} from \"../utils.js\"\nimport {deployPlugin} from \"./deployer.js\"\nimport {kill, onDataReceived} from \"./client\";\nimport type {ChildProcess} from \"node:child_process\";\nimport {spawn} from \"node:child_process\";\nimport type {Writable} from \"node:stream\";\nimport * as fs from \"node:fs\";\nimport path from \"node:path\";\nimport {info, setFailed, warning} from \"@actions/core\";\nimport {printFooter} from \"../outputs/summary\";", "import {info, setFailed, warning} from \"@actions/core\";\nimport {printFooter} from \"../outputs/summary\";\n\nlet serverProcess: ChildProcess | undefined\nlet serverStdin: Writable | undefined\n\nconst genArgs = (executable: string, args: string[]) => {\n    return [\n        ...args,\n        \"-jar\",", "        ...args,\n        \"-jar\",\n        executable,\n        \"nogui\"\n    ]\n}\n\nconst createServerProcess = (workDir: string, executable: string, args: string[] = []) => {\n    const cp = spawn(\n        \"java\",", "    const cp = spawn(\n        \"java\",\n        genArgs(executable, args),\n        {\n            cwd: workDir\n        }\n    )\n\n    serverStdin = cp.stdin\n    serverProcess = cp", "    serverStdin = cp.stdin\n    serverProcess = cp\n\n    return cp\n}\n\nexport const startServerOnly = async (workDir: string, executable: string, args: string[] = []) => {\n    info(`Starting server with executable ${executable} and args ${args.join(\" \")}`)\n\n    const cp = createServerProcess(workDir, executable, args)", "\n    const cp = createServerProcess(workDir, executable, args)\n\n    cp.stdout.on(\"data\", (data: Buffer) => {\n        const line = data.toString(\"utf8\")\n\n        if (line.includes(\"Done\") && line.includes(\"For help, type \\\"help\\\"\"))\n            serverStdin?.write(\"stop\\n\")\n\n        if (line.endsWith(\"\\n\"))\n            info(line.slice(0, - 1))\n        else\n            info(line)\n    })\n\n    return new Promise<number>((resolve, reject) => {\n        cp.on(\"exit\", (code) => {", "        if (line.endsWith(\"\\n\"))\n            info(line.slice(0, - 1))\n        else\n            info(line)\n    })\n\n    return new Promise<number>((resolve, reject) => {\n        cp.on(\"exit\", (code) => {\n            if (code === 0)\n                resolve(code)\n            else\n                reject(code)\n        })\n    })\n}\n\nexport const stopServer = () => {", "            if (code === 0)\n                resolve(code)\n            else\n                reject(code)\n        })\n    })\n}\n\nexport const stopServer = () => {\n    if (!serverStdin || !serverProcess)\n        return\n\n    info(\"Stopping server...\")\n\n    serverStdin.write(\"stop\\n\")\n    \n    setTimeout(() => {", "    if (!serverStdin || !serverProcess)\n        return\n\n    info(\"Stopping server...\")\n\n    serverStdin.write(\"stop\\n\")\n    \n    setTimeout(() => {\n        if (serverProcess!.killed)\n            return\n\n        warning(\"Server didn't stop in time, killing it...\")\n        serverProcess?.kill(\"SIGKILL\")\n    }, 1000 * 20)\n}\n\nexport const startTests = async (serverDir: string, executable: string, pluginFile: string) => {\n    info(`Starting tests of plugin ${pluginFile}.`)\n", "        if (serverProcess!.killed)\n            return\n\n        warning(\"Server didn't stop in time, killing it...\")\n        serverProcess?.kill(\"SIGKILL\")\n    }, 1000 * 20)\n}\n\nexport const startTests = async (serverDir: string, executable: string, pluginFile: string) => {\n    info(`Starting tests of plugin ${pluginFile}.`)\n", "    if (isNoScenamatica())\n        await removeScenamatica(serverDir)\n\n\n    await deployPlugin(serverDir, pluginFile)\n\n    const cp = createServerProcess(serverDir, executable)\n\n    cp.stdout.on(\"data\", async (data: Buffer) => {\n        await onDataReceived(data.toString(\"utf8\"))\n    })\n}\n\nconst removeScenamatica = async (serverDir: string) => {\n    info(\"Removing Scenamatica from server...\")\n\n    const pluginDir = path.join(serverDir, \"plugins\")\n    const files = await fs.promises.readdir(pluginDir)\n", "    for (const file of files) {\n        if (file.includes(\"Scenamatica\") && file.endsWith(\".jar\")) {\n            info(`Removing ${file}...`)\n            await fs.promises.rm(path.join(pluginDir, file))\n        }\n    }\n}\n\nexport const endTests = async (succeed: boolean) => {\n    info(\"Ending tests, shutting down server...\")\n\n    kill()\n    stopServer()\n\n    await printFooter()\n\n    let code: number\n", "    if (succeed) {\n        info(\"Tests succeeded\")\n\n        code = 0\n    } else {\n        setFailed(\"Tests failed\")\n\n        code = 1\n    }\n\n\n    process.exit(code)\n}\n"]}
{"filename": "src/server/client.ts", "chunked_list": ["import type {\n    PacketScenamaticaError,\n    PacketSessionEnd,\n    PacketSessionStart,\n    PacketTestEnd,\n    PacketTestStart\n} from \"../packets.js\"\nimport {parsePacket} from \"../packets.js\"\nimport {error, info} from \"@actions/core\";\nimport {", "import {error, info} from \"@actions/core\";\nimport {\n    publishRunning,\n    publishScenamaticaError,\n    publishSessionEnd\n} from \"../outputs/publisher\";\nimport {logSessionEnd, logSessionStart, logTestEnd, logTestStart} from \"../logging\";\nimport type {PullRequestInfo} from \"../outputs/pull-request/appender\";\nimport {endTests} from \"./controller\";\nimport {isTestSucceed} from \"../utils\";", "import {endTests} from \"./controller\";\nimport {isTestSucceed} from \"../utils\";\nimport {publishPRComment} from \"../outputs/pull-request/appender\";\n\nlet incomingBuffer: string | undefined\nlet alive = true\nlet prInfo: PullRequestInfo | undefined\n\nexport const initPullRequest = (pi: PullRequestInfo) => {\n    prInfo = pi", "export const initPullRequest = (pi: PullRequestInfo) => {\n    prInfo = pi\n\n    publishRunning(pi)\n}\n\nexport const onDataReceived = async (chunkMessage: string) => {\n    incomingBuffer = incomingBuffer ? incomingBuffer + chunkMessage : chunkMessage\n\n    while (incomingBuffer && incomingBuffer.includes(\"\\n\")) {\n        const messages: string[] = incomingBuffer.split(\"\\n\")\n\n        incomingBuffer = messages.slice(1).join(\"\\n\") || undefined", "\n    while (incomingBuffer && incomingBuffer.includes(\"\\n\")) {\n        const messages: string[] = incomingBuffer.split(\"\\n\")\n\n        incomingBuffer = messages.slice(1).join(\"\\n\") || undefined\n        if (!await processPacket(messages[0]))\n            info(messages[0])\n    }\n}\n\nexport const kill = () => {\n    alive = false\n}\n\nconst processPacket = async (msg: string) => {", "    if (!alive) {\n        return false\n    }\n\n    let packet\n\n    try {\n        packet = parsePacket(msg)\n    } catch {\n        return false\n    }\n", "    if (!packet) {\n        return false\n    }\n\n    switch (packet.genre) {\n        case \"session\": {\n            await processSessionPackets(packet as PacketSessionEnd | PacketSessionStart)\n\n            break\n        }\n\n        case \"test\": {\n            processTestsPacket(packet as PacketTestEnd | PacketTestStart)\n\n            break\n        }\n\n        case \"general\": {", "            if (packet.type !== \"error\") {\n                return false // general \u30b8\u30e3\u30f3\u30eb\u306f\u3001\u30a8\u30e9\u30fc\u306e\u307f\u3057\u304b\u306a\u3044\n            }\n\n            const errorPacket = packet as PacketScenamaticaError\n\n            error(`An error occurred in Scenamatica: ${errorPacket.exception}: ${errorPacket.message}`)\n            await publishScenamaticaError(errorPacket)\n            if (prInfo)\n                await publishPRComment(prInfo)\n\n            await endTests(false)\n\n            break\n        }\n    }\n\n    return true\n}\n\nconst processTestsPacket = (packet: PacketTestEnd | PacketTestStart) => {\n    switch (packet.type) {\n        case \"start\": {\n            logTestStart(packet.scenario)\n\n            break\n        }\n\n        case \"end\": {\n            const endPacket = packet as PacketTestEnd\n\n            logTestEnd(\n                packet.scenario.name,\n                endPacket.state,\n                endPacket.cause,\n                endPacket.startedAt,\n                endPacket.finishedAt\n            )\n\n            break\n        }\n    }\n}\n\nconst processSessionPackets = async (packet: PacketSessionEnd | PacketSessionStart) => {\n    switch (packet.type) {\n        case \"start\": {\n            const sessionStart = packet as PacketSessionStart\n\n            logSessionStart(packet.startedAt, sessionStart.tests.length)\n\n            break\n        }\n\n        case \"end\": {\n            const sessionEnd = packet as PacketSessionEnd\n\n            logSessionEnd(sessionEnd)\n            await publishSessionEnd(sessionEnd)", "            if (prInfo)\n                await publishPRComment(prInfo)\n\n            await endTests(false)\n\n            break\n        }\n    }\n\n    return true\n}\n\nconst processTestsPacket = (packet: PacketTestEnd | PacketTestStart) => {\n    switch (packet.type) {\n        case \"start\": {\n            logTestStart(packet.scenario)\n\n            break\n        }\n\n        case \"end\": {\n            const endPacket = packet as PacketTestEnd\n\n            logTestEnd(\n                packet.scenario.name,\n                endPacket.state,\n                endPacket.cause,\n                endPacket.startedAt,\n                endPacket.finishedAt\n            )\n\n            break\n        }\n    }\n}\n\nconst processSessionPackets = async (packet: PacketSessionEnd | PacketSessionStart) => {\n    switch (packet.type) {\n        case \"start\": {\n            const sessionStart = packet as PacketSessionStart\n\n            logSessionStart(packet.startedAt, sessionStart.tests.length)\n\n            break\n        }\n\n        case \"end\": {\n            const sessionEnd = packet as PacketSessionEnd\n\n            logSessionEnd(sessionEnd)\n            await publishSessionEnd(sessionEnd)", "            if (prInfo)\n                await publishPRComment(prInfo)\n\n            await endTests(isTestSucceed(sessionEnd.results))\n\n            break\n        }\n    }\n}\n\n"]}
