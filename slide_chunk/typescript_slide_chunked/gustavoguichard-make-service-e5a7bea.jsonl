{"filename": "vitest.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\nimport { configDefaults, defineConfig } from 'vitest/config'\n\nexport default defineConfig(() => ({\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    maxConcurrency: 1,\n    minThreads: 0,\n    maxThreads: 1,", "    minThreads: 0,\n    maxThreads: 1,\n  },\n}))\n"]}
{"filename": "src/api.ts", "chunked_list": ["import { HTTP_METHODS } from './constants'\nimport { getJson, getText } from './internals'\nimport {\n  addQueryToURL,\n  ensureStringBody,\n  makeGetApiURL,\n  mergeHeaders,\n  replaceURLParams,\n} from './primitives'\nimport {", "} from './primitives'\nimport {\n  EnhancedRequestInit,\n  HTTPMethod,\n  ServiceRequestInit,\n  TypedResponse,\n} from './types'\n\n/**\n * It hacks the Response object to add typed json and text methods", "/**\n * It hacks the Response object to add typed json and text methods\n * @param response the Response to be proxied\n * @returns a Response with typed json and text methods\n * @example const response = await fetch(\"https://example.com/api/users\");\n * const users = await response.json(userSchema);\n * //    ^? User[]\n * const untyped = await response.json();\n * //    ^? unknown\n * const text = await response.text();", " * //    ^? unknown\n * const text = await response.text();\n * //    ^? string\n * const typedJson = await response.json<User[]>();\n * //    ^? User[]\n */\nfunction typedResponse(response: Response): TypedResponse {\n  return new Proxy(response, {\n    get(target, prop) {\n      if (prop === 'json') return getJson(target)\n      if (prop === 'text') return getText(target)\n      return target[prop as keyof Response]\n    },\n  }) as Omit<Response, 'json' | 'text'> & {\n    json: ReturnType<typeof getJson>\n    text: ReturnType<typeof getText>\n  }\n}\n\n/**\n *\n * @param url a string or URL to be fetched\n * @param requestInit the requestInit to be passed to the fetch request. It is the same as the `RequestInit` type, but it also accepts a JSON-like `body` and an object-like `query` parameter.\n * @param requestInit.body the body of the request. It will be automatically stringified so you can send a JSON-like object\n * @param requestInit.query the query parameters to be added to the URL", "      if (prop === 'json') return getJson(target)\n      if (prop === 'text') return getText(target)\n      return target[prop as keyof Response]\n    },\n  }) as Omit<Response, 'json' | 'text'> & {\n    json: ReturnType<typeof getJson>\n    text: ReturnType<typeof getText>\n  }\n}\n\n/**\n *\n * @param url a string or URL to be fetched\n * @param requestInit the requestInit to be passed to the fetch request. It is the same as the `RequestInit` type, but it also accepts a JSON-like `body` and an object-like `query` parameter.\n * @param requestInit.body the body of the request. It will be automatically stringified so you can send a JSON-like object\n * @param requestInit.query the query parameters to be added to the URL", " * @param requestInit.trace a function that receives the URL and the requestInit and can be used to log the request\n * @returns a Response with typed json and text methods\n * @example const response = await fetch(\"https://example.com/api/users\");\n * const users = await response.json(userSchema);\n * //    ^? User[]\n * const untyped = await response.json();\n * //    ^? unknown\n */\nasync function enhancedFetch<T extends string | URL>(\n  url: T,\n  requestInit?: EnhancedRequestInit<T>,\n) {\n  const { query, trace, ...reqInit } = requestInit ?? {}\n  const headers = mergeHeaders(\n    {\n      'content-type': 'application/json',\n    },\n    reqInit.headers ?? {},\n  )\n  const withParams = replaceURLParams<T>(url, reqInit.params ?? ({} as never))\n  const fullURL = addQueryToURL(withParams, query)\n  const body = ensureStringBody(reqInit.body)\n\n  const enhancedReqInit = { ...reqInit, headers, body }\n  trace?.(fullURL, enhancedReqInit)\n  const response = await fetch(fullURL, enhancedReqInit)\n\n  return typedResponse(response)\n}\n\n/**\n *\n * @param baseURL the base URL to be fetched in every request\n * @param baseHeaders any headers that should be sent with every request", "async function enhancedFetch<T extends string | URL>(\n  url: T,\n  requestInit?: EnhancedRequestInit<T>,\n) {\n  const { query, trace, ...reqInit } = requestInit ?? {}\n  const headers = mergeHeaders(\n    {\n      'content-type': 'application/json',\n    },\n    reqInit.headers ?? {},\n  )\n  const withParams = replaceURLParams<T>(url, reqInit.params ?? ({} as never))\n  const fullURL = addQueryToURL(withParams, query)\n  const body = ensureStringBody(reqInit.body)\n\n  const enhancedReqInit = { ...reqInit, headers, body }\n  trace?.(fullURL, enhancedReqInit)\n  const response = await fetch(fullURL, enhancedReqInit)\n\n  return typedResponse(response)\n}\n\n/**\n *\n * @param baseURL the base URL to be fetched in every request\n * @param baseHeaders any headers that should be sent with every request", " * @returns a function that receive a path and requestInit and return a serialized json response that can be typed or not.\n * @example const headers = { Authorization: \"Bearer 123\" }\n * const fetcher = makeFetcher(\"https://example.com/api\", headers);\n * const response = await fetcher(\"/users\", { method: \"GET\" })\n * const users = await response.json(userSchema);\n * //    ^? User[]\n */\nfunction makeFetcher(\n  baseURL: string | URL,\n  baseHeaders?: HeadersInit | (() => HeadersInit | Promise<HeadersInit>),\n) {\n  return async <T extends string>(\n    path: T,\n    requestInit: EnhancedRequestInit<T> = {},\n  ) => {\n    const url = makeGetApiURL(baseURL)(path)\n    const response = await enhancedFetch(url, {\n      ...requestInit,\n      headers: mergeHeaders(\n        typeof baseHeaders === 'function'\n          ? await baseHeaders()\n          : baseHeaders ?? {},\n        requestInit?.headers ?? {},\n      ),\n    })\n    return response\n  }\n}\n\n/**\n *\n * @param baseURL the base URL to the API\n * @param baseHeaders any headers that should be sent with every request\n * @returns a service object with HTTP methods that are functions that receive a path and requestInit and return a serialized json response that can be typed or not.\n * @example const headers = { Authorization: \"Bearer 123\" }\n * const api = makeService(\"https://example.com/api\", headers);\n * const response = await api.get(\"/users\")\n * const users = await response.json(userSchema);\n * //    ^? User[]\n */", "function makeService(\n  baseURL: string | URL,\n  baseHeaders?: HeadersInit | (() => HeadersInit | Promise<HeadersInit>),\n) {\n  const fetcher = makeFetcher(baseURL, baseHeaders)\n\n  function appliedService(method: HTTPMethod) {\n    return async <T extends string>(\n      path: T,\n      requestInit: ServiceRequestInit<T> = {},\n    ) => fetcher(path, { ...requestInit, method })\n  }\n\n  let service = {} as Record<\n    Lowercase<HTTPMethod>,\n    ReturnType<typeof appliedService>\n  >", "  for (const method of HTTP_METHODS) {\n    const lowerMethod = method.toLowerCase() as Lowercase<HTTPMethod>\n    service[lowerMethod] = appliedService(method)\n  }\n  return service\n}\n\nexport { enhancedFetch, makeFetcher, makeService, typedResponse }\n"]}
{"filename": "src/internals.ts", "chunked_list": ["import { Schema } from './types'\n\n/**\n * It returns the JSON object or throws an error if the response is not ok.\n * @param response the Response to be parsed\n * @returns the response.json method that accepts a type or Zod schema for a typed json response\n */\nfunction getJson(response: Response) {\n  return async <T = unknown>(schema?: Schema<T>): Promise<T> => {\n    const json = await response.json()\n    return schema ? schema.parse(json) : (json as T)\n  }\n}\n\n/**\n * @param response the Response to be parsed", " * @returns the response.text method that accepts a type or Zod schema for a typed response\n */\nfunction getText(response: Response) {\n  return async <T extends string = string>(schema?: Schema<T>): Promise<T> => {\n    const text = await response.text()\n    return schema ? schema.parse(text) : (text as T)\n  }\n}\n\n/**\n * This is an enhanced version of the typeof operator to check the type of more complex values.\n * @param t the value to be checked", " * This is an enhanced version of the typeof operator to check the type of more complex values.\n * @param t the value to be checked\n * @returns the type of the value\n */\nfunction typeOf(t: unknown) {\n  return Object.prototype.toString\n    .call(t)\n    .replace(/^\\[object (.+)\\]$/, '$1')\n    .toLowerCase() as\n    | 'array'\n    | 'arraybuffer'\n    | 'bigint'\n    | 'blob'\n    | 'boolean'\n    | 'formdata'\n    | 'function'\n    | 'null'\n    | 'number'\n    | 'object'\n    | 'readablestream'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n    | 'url'\n    | 'urlsearchparams'\n}\n\nexport { getJson, getText, typeOf }\n"]}
{"filename": "src/primitives.ts", "chunked_list": ["import { typeOf } from './internals'\nimport { JSONValue, PathParams, SearchParams } from './types'\n\n/**\n * @param url a string or URL to which the query parameters will be added\n * @param searchParams the query parameters\n * @returns the url with the query parameters added with the same type as the url\n */\nfunction addQueryToURL(\n  url: string | URL,\n  searchParams?: SearchParams,\n): string | URL {", "function addQueryToURL(\n  url: string | URL,\n  searchParams?: SearchParams,\n): string | URL {\n  if (!searchParams) return url\n\n  if (typeof url === 'string') {\n    const separator = url.includes('?') ? '&' : '?'\n    return `${url}${separator}${new URLSearchParams(searchParams)}`\n  }\n  if (searchParams && url instanceof URL) {", "  if (searchParams && url instanceof URL) {\n    for (const [key, value] of Object.entries(\n      new URLSearchParams(searchParams),\n    )) {\n      url.searchParams.set(key, value)\n    }\n  }\n  return url\n}\n\n/**\n * @param body the JSON-like body of the request\n * @returns the body is stringified if it is not a string and it is a JSON-like object. It also accepts other types of BodyInit such as Blob, ReadableStream, etc.\n */", "function ensureStringBody<B extends JSONValue | BodyInit | null>(\n  body?: B,\n): B extends JSONValue ? string : B {\n  if (typeof body === 'undefined') return body as never\n  if (typeof body === 'string') return body as never\n\n  return (\n    ['number', 'boolean', 'array', 'object'].includes(typeOf(body))\n      ? JSON.stringify(body)\n      : body\n  ) as never\n}\n\n/**\n * @param baseURL the base path to the API", " * @returns a function that receives a path and an object of query parameters and returns a URL\n */\nfunction makeGetApiURL<T extends string | URL>(baseURL: T) {\n  const base = baseURL instanceof URL ? baseURL.toString() : baseURL\n  return (path: string, searchParams?: SearchParams): T => {\n    const url = `${base}/${path}`.replace(/([^https?:]\\/)\\/+/g, '$1')\n    return addQueryToURL(url, searchParams) as T\n  }\n}\n\n/**\n * It merges multiple HeadersInit objects into a single Headers object\n * @param entries Any number of HeadersInit objects\n * @returns a new Headers object with the merged headers\n */", "function mergeHeaders(\n  ...entries: (\n    | HeadersInit\n    | [string, undefined][]\n    | Record<string, undefined>\n  )[]\n) {\n  const result = new Map<string, string>()\n\n  for (const entry of entries) {\n    const headers = new Headers(entry as HeadersInit)\n", "  for (const entry of entries) {\n    const headers = new Headers(entry as HeadersInit)\n\n    for (const [key, value] of headers.entries()) {\n      if (value === undefined || value === 'undefined') {\n        result.delete(key)\n      } else {\n        result.set(key, value)\n      }\n    }\n  }\n\n  return new Headers(Array.from(result.entries()))\n}\n\n/**\n *\n * @param url the url string or URL object to replace the params\n * @param params the params map to be replaced in the url", " * @returns the url with the params replaced and with the same type as the given url\n */\nfunction replaceURLParams<T extends string | URL>(\n  url: T,\n  params: PathParams<T>,\n): T {\n  // TODO: use the URL Pattern API as soon as it has better browser support\n  if (!params) return url as T\n\n  let urlString = String(url)\n  Object.entries(params).forEach(([key, value]) => {\n    urlString = urlString.replace(new RegExp(`:${key}($|\\/)`), `${value}$1`)\n  })\n  return (url instanceof URL ? new URL(urlString) : urlString) as T\n}\n\nexport {\n  addQueryToURL,\n  ensureStringBody,\n  makeGetApiURL,\n  mergeHeaders,\n  replaceURLParams,\n}\n"]}
{"filename": "src/test.d.ts", "chunked_list": ["type Expect<T extends true> = T\ntype Equal<A, B> =\n  // prettier-ignore\n  (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2)\n    ? true\n    : false\n"]}
{"filename": "src/transforms.ts", "chunked_list": ["import { typeOf } from './internals'\n\ntype KebabToCamel<Str> = Str extends `${infer First}-${infer Rest}`\n  ? `${First}${Capitalize<KebabToCamel<Rest>>}`\n  : Str\n\ntype SnakeToCamel<Str> = Str extends `${infer First}_${infer Rest}`\n  ? `${First}${Capitalize<SnakeToCamel<Rest>>}`\n  : Str\n\ntype KebabToSnake<Str> = Str extends `${infer First}-${infer Rest}`\n  ? `${First}_${KebabToSnake<Rest>}`\n  : Str\n", "type KebabToSnake<Str> = Str extends `${infer First}-${infer Rest}`\n  ? `${First}_${KebabToSnake<Rest>}`\n  : Str\n\ntype SnakeToKebab<Str> = Str extends `${infer First}_${infer Rest}`\n  ? `${First}-${SnakeToKebab<Rest>}`\n  : Str\n\ntype HandleFirstChar<Str> = Str extends `${infer First}${infer Rest}`\n  ? `${Lowercase<First>}${Rest}`\n  : Str\n", "type HandleFirstChar<Str> = Str extends `${infer First}${infer Rest}`\n  ? `${Lowercase<First>}${Rest}`\n  : Str\n\ntype CamelToSnakeFn<Str> = Str extends `${infer First}${infer Rest}`\n  ? `${First extends Capitalize<First>\n      ? '_'\n      : ''}${Lowercase<First>}${CamelToSnakeFn<Rest>}`\n  : Str\n\ntype CamelToSnake<Str> = CamelToSnakeFn<HandleFirstChar<Str>>\n", "type CamelToSnake<Str> = CamelToSnakeFn<HandleFirstChar<Str>>\n\ntype CamelToKebabFn<Str> = Str extends `${infer First}${infer Rest}`\n  ? `${First extends Capitalize<First>\n      ? '-'\n      : ''}${Lowercase<First>}${CamelToKebabFn<Rest>}`\n  : Str\n\ntype CamelToKebab<Str> = CamelToKebabFn<HandleFirstChar<Str>>\n\nfunction words(str: string) {\n  const matches = str.match(\n    /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g,\n  )\n  return matches ? Array.from(matches) : [str]\n}\n", "type CamelToKebab<Str> = CamelToKebabFn<HandleFirstChar<Str>>\n\nfunction words(str: string) {\n  const matches = str.match(\n    /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g,\n  )\n  return matches ? Array.from(matches) : [str]\n}\n\nfunction toCamelCase(str: string) {\n  const result = words(str)\n    .map((x) => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())\n    .join('')\n  return result.slice(0, 1).toLowerCase() + result.slice(1)\n}\n", "function toCamelCase(str: string) {\n  const result = words(str)\n    .map((x) => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())\n    .join('')\n  return result.slice(0, 1).toLowerCase() + result.slice(1)\n}\n\nfunction toKebabCase(str: string) {\n  return words(str)\n    .map((x) => x.toLowerCase())\n    .join('-')\n}\n", "function toSnakeCase(str: string) {\n  return words(str)\n    .map((x) => x.toLowerCase())\n    .join('_')\n}\n\nfunction deepTransformKeys<T>(obj: T, transform: (s: string) => string): T {\n  if (!['object', 'array'].includes(typeOf(obj))) return obj\n\n  if (Array.isArray(obj)) {\n    return obj.map((x) => deepTransformKeys(x, transform)) as T\n  }\n  const res = {} as T", "  if (Array.isArray(obj)) {\n    return obj.map((x) => deepTransformKeys(x, transform)) as T\n  }\n  const res = {} as T\n  for (const key in obj) {\n    res[transform(key) as keyof T] = deepTransformKeys(obj[key], transform)\n  }\n  return res\n}\n\ntype DeepKebabToCamel<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepKebabToCamel<T[I]> }\n  : T extends (infer V)[]\n  ? DeepKebabToCamel<V>[]\n  : {\n      [K in keyof T as KebabToCamel<K>]: DeepKebabToCamel<T[K]>\n    }", "type DeepKebabToCamel<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepKebabToCamel<T[I]> }\n  : T extends (infer V)[]\n  ? DeepKebabToCamel<V>[]\n  : {\n      [K in keyof T as KebabToCamel<K>]: DeepKebabToCamel<T[K]>\n    }\nfunction kebabToCamel<T>(obj: T): DeepKebabToCamel<T> {\n  return deepTransformKeys(obj, toCamelCase) as never\n}\n", "type DeepSnakeToCamel<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepSnakeToCamel<T[I]> }\n  : T extends (infer V)[]\n  ? DeepSnakeToCamel<V>[]\n  : {\n      [K in keyof T as SnakeToCamel<K>]: DeepSnakeToCamel<T[K]>\n    }\nfunction snakeToCamel<T>(obj: T): DeepSnakeToCamel<T> {\n  return deepTransformKeys(obj, toCamelCase) as never\n}\n", "type DeepCamelToSnake<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepCamelToSnake<T[I]> }\n  : T extends (infer V)[]\n  ? DeepCamelToSnake<V>[]\n  : {\n      [K in keyof T as CamelToSnake<K>]: DeepCamelToSnake<T[K]>\n    }\nfunction camelToSnake<T>(obj: T): DeepCamelToSnake<T> {\n  return deepTransformKeys(obj, toSnakeCase) as never\n}\n", "type DeepCamelToKebab<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepCamelToKebab<T[I]> }\n  : T extends (infer V)[]\n  ? DeepCamelToKebab<V>[]\n  : {\n      [K in keyof T as CamelToKebab<K>]: DeepCamelToKebab<T[K]>\n    }\nfunction camelToKebab<T>(obj: T): DeepCamelToKebab<T> {\n  return deepTransformKeys(obj, toKebabCase) as never\n}\n", "type DeepSnakeToKebab<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepSnakeToKebab<T[I]> }\n  : T extends (infer V)[]\n  ? DeepSnakeToKebab<V>[]\n  : {\n      [K in keyof T as SnakeToKebab<K>]: DeepSnakeToKebab<T[K]>\n    }\nfunction snakeToKebab<T>(obj: T): DeepSnakeToKebab<T> {\n  return deepTransformKeys(obj, toKebabCase) as never\n}\n", "type DeepKebabToSnake<T> = T extends [any, ...any]\n  ? { [I in keyof T]: DeepKebabToSnake<T[I]> }\n  : T extends (infer V)[]\n  ? DeepKebabToSnake<V>[]\n  : {\n      [K in keyof T as KebabToSnake<K>]: DeepKebabToSnake<T[K]>\n    }\nfunction kebabToSnake<T>(obj: T): DeepKebabToSnake<T> {\n  return deepTransformKeys(obj, toSnakeCase) as never\n}\n\nexport type {\n  CamelToKebab,\n  CamelToSnake,\n  DeepCamelToKebab,\n  DeepCamelToSnake,\n  DeepKebabToCamel,\n  DeepKebabToSnake,\n  DeepSnakeToCamel,\n  DeepSnakeToKebab,\n  KebabToCamel,\n  KebabToSnake,\n  SnakeToCamel,\n  SnakeToKebab,\n}\nexport {\n  camelToKebab,\n  camelToSnake,\n  kebabToCamel,\n  kebabToSnake,\n  snakeToCamel,\n  snakeToKebab,\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { HTTP_METHODS } from './constants'\nimport { getJson, getText } from './internals'\n\ntype Schema<T> = { parse: (d: unknown) => T }\n\ntype JSONValue =\n  | string\n  | number\n  | boolean\n  | { [x: string]: JSONValue }\n  | Array<JSONValue>\n", "type SearchParams = ConstructorParameters<typeof URLSearchParams>[0]\n\ntype TypedResponse = Omit<Response, 'json' | 'text'> & {\n  json: TypedResponseJson\n  text: TypedResponseText\n}\n\ntype PathParams<T> = T extends string\n  ? ExtractPathParams<T> extends Record<string, unknown>\n    ? ExtractPathParams<T>\n    : Record<string, string>\n  : Record<string, string>\n", "type EnhancedRequestInit<T = string> = Omit<RequestInit, 'body' | 'method'> & {\n  method?: HTTPMethod | Lowercase<HTTPMethod>\n  body?: JSONValue | BodyInit | null\n  query?: SearchParams\n  params?: PathParams<T>\n  trace?: (...args: Parameters<typeof fetch>) => void\n}\n\ntype ServiceRequestInit<T = string> = Omit<EnhancedRequestInit<T>, 'method'>\n\ntype HTTPMethod = (typeof HTTP_METHODS)[number]\n", "type ServiceRequestInit<T = string> = Omit<EnhancedRequestInit<T>, 'method'>\n\ntype HTTPMethod = (typeof HTTP_METHODS)[number]\n\ntype TypedResponseJson = ReturnType<typeof getJson>\ntype TypedResponseText = ReturnType<typeof getText>\n\ntype Prettify<T> = {\n  [K in keyof T]: T[K]\n} & {}\n", "type ExtractPathParams<T extends string> =\n  T extends `${infer _}:${infer Param}/${infer Rest}`\n    ? Prettify<Omit<{ [K in Param]: string } & ExtractPathParams<Rest>, ''>>\n    : T extends `${infer _}:${infer Param}`\n    ? { [K in Param]: string }\n    : {}\n\nexport type {\n  EnhancedRequestInit,\n  HTTPMethod,\n  JSONValue,\n  PathParams,\n  Schema,\n  SearchParams,\n  ServiceRequestInit,\n  TypedResponse,\n  TypedResponseJson,\n  TypedResponseText,\n}\n"]}
{"filename": "src/primitives.test.ts", "chunked_list": ["import * as subject from './primitives'\n\nbeforeEach(() => {\n  vi.clearAllMocks()\n})\n\ndescribe('addQueryToURL', () => {\n  it('should add the query object to a string input', () => {\n    expect(subject.addQueryToURL('https://example.com/api', { id: '1' })).toBe(\n      'https://example.com/api?id=1',", "    expect(subject.addQueryToURL('https://example.com/api', { id: '1' })).toBe(\n      'https://example.com/api?id=1',\n    )\n    expect(\n      subject.addQueryToURL('https://example.com/api', 'page=2&foo=bar'),\n    ).toBe('https://example.com/api?page=2&foo=bar')\n  })\n\n  it('should add the query object to a URL input', () => {\n    expect(", "  it('should add the query object to a URL input', () => {\n    expect(\n      subject.addQueryToURL(new URL('https://example.com/api'), {\n        id: '1',\n      }),\n    ).toEqual(new URL('https://example.com/api?id=1'))\n    expect(\n      subject.addQueryToURL(new URL('https://example.com/api'), 'page=2'),\n    ).toEqual(new URL('https://example.com/api?page=2'))\n  })", "    ).toEqual(new URL('https://example.com/api?page=2'))\n  })\n\n  it('should append the query to a URL string that already has QS', () => {\n    expect(\n      subject.addQueryToURL('https://example.com/api?id=1', { page: '2' }),\n    ).toBe('https://example.com/api?id=1&page=2')\n    expect(\n      subject.addQueryToURL('https://example.com/api?id=1', 'page=2'),\n    ).toBe('https://example.com/api?id=1&page=2')", "      subject.addQueryToURL('https://example.com/api?id=1', 'page=2'),\n    ).toBe('https://example.com/api?id=1&page=2')\n    expect(\n      subject.addQueryToURL(\n        'https://example.com/api?id=1',\n        new URLSearchParams({ page: '2' }),\n      ),\n    ).toBe('https://example.com/api?id=1&page=2')\n  })\n", "  })\n\n  it('should append the query to a URL instance that already has QS', () => {\n    expect(\n      subject.addQueryToURL(new URL('https://example.com/api?id=1'), {\n        page: '2',\n      }),\n    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n    expect(\n      subject.addQueryToURL(new URL('https://example.com/api?id=1'), 'page=2'),", "    expect(\n      subject.addQueryToURL(new URL('https://example.com/api?id=1'), 'page=2'),\n    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n    expect(\n      subject.addQueryToURL(\n        new URL('https://example.com/api?id=1'),\n        new URLSearchParams({ page: '2' }),\n      ),\n    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n  })", "    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n  })\n\n  it(\"should return the input in case there's no query\", () => {\n    expect(subject.addQueryToURL('https://example.com/api')).toBe(\n      'https://example.com/api',\n    )\n    expect(subject.addQueryToURL(new URL('https://example.com/api'))).toEqual(\n      new URL('https://example.com/api'),\n    )", "      new URL('https://example.com/api'),\n    )\n  })\n})\n\ndescribe('ensureStringBody', () => {\n  it('should return the same if body was string', () => {\n    expect(subject.ensureStringBody('foo')).toBe('foo')\n  })\n", "  })\n\n  it('should return the same if body was not defined', () => {\n    expect(subject.ensureStringBody()).toBeUndefined()\n  })\n\n  it('should stringify the body if it is a JSON-like value', () => {\n    expect(subject.ensureStringBody({ page: 2 })).toBe(`{\"page\":2}`)\n    expect(subject.ensureStringBody([1, 2])).toBe(`[1,2]`)\n    expect(subject.ensureStringBody(3)).toBe(`3`)", "    expect(subject.ensureStringBody([1, 2])).toBe(`[1,2]`)\n    expect(subject.ensureStringBody(3)).toBe(`3`)\n    expect(subject.ensureStringBody(true)).toBe(`true`)\n    expect(subject.ensureStringBody({})).toBe(`{}`)\n  })\n\n  it('should not stringify other valid kinds of BodyInit', () => {\n    const ab = new ArrayBuffer(0)\n    expect(subject.ensureStringBody(ab)).toBe(ab)\n    const rs = new ReadableStream()", "    expect(subject.ensureStringBody(ab)).toBe(ab)\n    const rs = new ReadableStream()\n    expect(subject.ensureStringBody(rs)).toBe(rs)\n    const fd = new FormData()\n    expect(subject.ensureStringBody(fd)).toBe(fd)\n    const usp = new URLSearchParams()\n    expect(subject.ensureStringBody(usp)).toBe(usp)\n    const blob = new Blob()\n    expect(subject.ensureStringBody(blob)).toBe(blob)\n  })", "    expect(subject.ensureStringBody(blob)).toBe(blob)\n  })\n})\n\ndescribe('makeGetApiURL', () => {\n  it('should return a URL which is baseURL and path joined', () => {\n    expect(subject.makeGetApiURL('https://example.com/api')('/users')).toBe(\n      'https://example.com/api/users',\n    )\n  })", "    )\n  })\n\n  it('should accept an object-like queryString and return it joined to the URL', () => {\n    const getApiURL = subject.makeGetApiURL('https://example.com/api')\n    expect(getApiURL('/users', { id: '1' })).toBe(\n      'https://example.com/api/users?id=1',\n    )\n    expect(getApiURL('/users', { active: 'true', page: '2' })).toBe(\n      'https://example.com/api/users?active=true&page=2',", "    expect(getApiURL('/users', { active: 'true', page: '2' })).toBe(\n      'https://example.com/api/users?active=true&page=2',\n    )\n  })\n\n  it('should accept a URL as baseURL and remove extra slashes', () => {\n    expect(\n      subject.makeGetApiURL(new URL('https://example.com/api'))('/users'),\n    ).toBe('https://example.com/api/users')\n    expect(", "    ).toBe('https://example.com/api/users')\n    expect(\n      subject.makeGetApiURL(new URL('https://example.com/api/'))('/users'),\n    ).toBe('https://example.com/api/users')\n    expect(\n      subject.makeGetApiURL(new URL('https://example.com/api/'))('///users'),\n    ).toBe('https://example.com/api/users')\n  })\n\n  it('should add missing slashes', () => {", "\n  it('should add missing slashes', () => {\n    expect(\n      subject.makeGetApiURL(new URL('https://example.com/api'))('users'),\n    ).toBe('https://example.com/api/users')\n  })\n})\n\ndescribe('mergeHeaders', () => {\n  it('should merge diferent kinds of Headers', () => {", "describe('mergeHeaders', () => {\n  it('should merge diferent kinds of Headers', () => {\n    expect(\n      subject.mergeHeaders(new Headers({ a: '1' }), { b: '2' }, [['c', '3']]),\n    ).toEqual(new Headers({ a: '1', b: '2', c: '3' }))\n  })\n\n  it('should merge diferent kinds of Headers and override values', () => {\n    expect(\n      subject.mergeHeaders(new Headers({ a: '1' }), { a: '2' }, [['a', '3']]),", "    expect(\n      subject.mergeHeaders(new Headers({ a: '1' }), { a: '2' }, [['a', '3']]),\n    ).toEqual(new Headers({ a: '3' }))\n  })\n\n  it('should merge diferent kinds of Headers and delete undefined values', () => {\n    expect(\n      subject.mergeHeaders(new Headers({ a: '1' }), { a: undefined }),\n    ).toEqual(new Headers({}))\n    expect(", "    ).toEqual(new Headers({}))\n    expect(\n      subject.mergeHeaders(new Headers({ a: '1' }), { a: 'undefined' }),\n    ).toEqual(new Headers({}))\n    expect(\n      subject.mergeHeaders(new Headers({ a: '1' }), [['a', undefined]]),\n    ).toEqual(new Headers({}))\n  })\n})\n", "})\n\ndescribe('replaceURLParams', () => {\n  it('should replace the wildcards in an URL string with the given parameters', () => {\n    expect(subject.replaceURLParams('/users/:id', { id: '1' })).toBe('/users/1')\n    expect(\n      subject.replaceURLParams('http://example.com/users/:id/posts/:postId', {\n        id: '1',\n        postId: '3',\n      }),", "        postId: '3',\n      }),\n    ).toBe('http://example.com/users/1/posts/3')\n  })\n\n  it('should replace the wildcards in an instance of URL', () => {\n    expect(\n      subject.replaceURLParams(new URL('/users/:id', 'http://example.com'), {\n        id: '1',\n      }),", "        id: '1',\n      }),\n    ).toEqual(new URL('http://example.com/users/1'))\n  })\n})\n"]}
{"filename": "src/transforms.test.ts", "chunked_list": ["import type * as Subject from './transforms'\nimport * as subject from './transforms'\n\nnamespace TypeTransforms {\n  type test1 = Expect<\n    Equal<Subject.CamelToKebab<'camelToKebab'>, 'camel-to-kebab'>\n  >\n  type test2 = Expect<\n    Equal<Subject.CamelToSnake<'camelToSnake'>, 'camel_to_snake'>\n  >\n  type test3 = Expect<\n    Equal<Subject.KebabToCamel<'kebab-to-camel'>, 'kebabToCamel'>\n  >", "  type test3 = Expect<\n    Equal<Subject.KebabToCamel<'kebab-to-camel'>, 'kebabToCamel'>\n  >\n  type test4 = Expect<\n    Equal<Subject.KebabToSnake<'kebab-to-snake'>, 'kebab_to_snake'>\n  >\n  type test5 = Expect<\n    Equal<Subject.SnakeToCamel<'snake_to_camel'>, 'snakeToCamel'>\n  >\n  type test6 = Expect<\n    Equal<Subject.SnakeToKebab<'snake_to_kebab'>, 'snake-to-kebab'>\n  >\n}\n\ndescribe('deep transforms', () => {\n  test('camelToKebab', () => {\n    const result = subject.camelToKebab({\n      some: { deepNested: { value: true } },\n      otherValue: true,\n    })\n    expect(result).toEqual({\n      some: { 'deep-nested': { value: true } },\n      'other-value': true,\n    })", "  type test6 = Expect<\n    Equal<Subject.SnakeToKebab<'snake_to_kebab'>, 'snake-to-kebab'>\n  >\n}\n\ndescribe('deep transforms', () => {\n  test('camelToKebab', () => {\n    const result = subject.camelToKebab({\n      some: { deepNested: { value: true } },\n      otherValue: true,\n    })\n    expect(result).toEqual({\n      some: { 'deep-nested': { value: true } },\n      'other-value': true,\n    })", "    type test = Expect<\n      Equal<\n        typeof result,\n        { some: { 'deep-nested': { value: boolean } }; 'other-value': boolean }\n      >\n    >\n  })\n\n  test('camelToSnake', () => {\n    const result = subject.camelToSnake({\n      some: { deepNested: { value: true } },\n      otherValue: true,\n    })\n    expect(result).toEqual({\n      some: { deep_nested: { value: true } },\n      other_value: true,\n    })", "    type test = Expect<\n      Equal<\n        typeof result,\n        { some: { deep_nested: { value: boolean } }; other_value: boolean }\n      >\n    >\n  })\n\n  test('kebabToCamel', () => {\n    const result = subject.kebabToCamel({\n      some: { 'deep-nested': { value: true } },\n      'other-value': true,\n    })\n    expect(result).toEqual({\n      some: { deepNested: { value: true } },\n      otherValue: true,\n    })", "    type test = Expect<\n      Equal<\n        typeof result,\n        { some: { deepNested: { value: boolean } }; otherValue: boolean }\n      >\n    >\n  })\n\n  test('kebabToSnake', () => {\n    const result = subject.kebabToSnake({\n      some: { 'deep-nested': { value: true } },\n      'other-value': true,\n    })\n    expect(result).toEqual({\n      some: { deep_nested: { value: true } },\n      other_value: true,\n    })", "    type test = Expect<\n      Equal<\n        typeof result,\n        { some: { deep_nested: { value: boolean } }; other_value: boolean }\n      >\n    >\n  })\n\n  test('snakeToCamel', () => {\n    const result = subject.snakeToCamel({\n      some: { deep_nested: { value: true } },\n      other_value: true,\n    })\n    expect(result).toEqual({\n      some: { deepNested: { value: true } },\n      otherValue: true,\n    })", "    type test = Expect<\n      Equal<\n        typeof result,\n        { some: { deepNested: { value: boolean } }; otherValue: boolean }\n      >\n    >\n  })\n\n  test('snakeToKebab', () => {\n    const result = subject.snakeToKebab({\n      some: { deep_nested: { value: true } },\n      other_value: true,\n    })\n    expect(result).toEqual({\n      some: { 'deep-nested': { value: true } },\n      'other-value': true,\n    })", "    type test = Expect<\n      Equal<\n        typeof result,\n        { some: { 'deep-nested': { value: boolean } }; 'other-value': boolean }\n      >\n    >\n  })\n\n  test('should transform deep nested objects and array of objects', () => {\n    const result = subject.kebabToCamel([\n      { some: { 'deep-nested': [{ value: true }] } },\n    ])\n    expect(result).toEqual([{ some: { deepNested: [{ value: true }] } }])", "    type test = Expect<\n      Equal<typeof result, { some: { deepNested: { value: boolean }[] } }[]>\n    >\n  })\n})\n"]}
{"filename": "src/constants.ts", "chunked_list": ["const HTTP_METHODS = [\n  'GET',\n  'POST',\n  'PUT',\n  'DELETE',\n  'PATCH',\n  'OPTIONS',\n  'HEAD',\n  'CONNECT',\n  // 'TRACE', it has no support in most browsers yet", "  'CONNECT',\n  // 'TRACE', it has no support in most browsers yet\n] as const\n\nexport { HTTP_METHODS }\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { enhancedFetch, makeFetcher, makeService, typedResponse } from './api'\nexport {\n  addQueryToURL,\n  ensureStringBody,\n  makeGetApiURL,\n  mergeHeaders,\n  replaceURLParams,\n} from './primitives'\nexport {\n  camelToKebab,", "export {\n  camelToKebab,\n  camelToSnake,\n  kebabToCamel,\n  kebabToSnake,\n  snakeToCamel,\n  snakeToKebab,\n} from './transforms'\nexport type {\n  CamelToKebab,", "export type {\n  CamelToKebab,\n  CamelToSnake,\n  DeepCamelToKebab,\n  DeepCamelToSnake,\n  DeepKebabToCamel,\n  DeepKebabToSnake,\n  DeepSnakeToCamel,\n  DeepSnakeToKebab,\n  KebabToCamel,", "  DeepSnakeToKebab,\n  KebabToCamel,\n  KebabToSnake,\n  SnakeToCamel,\n  SnakeToKebab,\n} from './transforms'\nexport type * from './types'\n"]}
{"filename": "src/api.test.ts", "chunked_list": ["import { HTTP_METHODS } from './constants'\nimport * as subject from './api'\nimport * as z from 'zod'\nimport { HTTPMethod } from './types'\nimport { kebabToCamel } from './transforms'\n\nconst reqMock = vi.fn()\nfunction successfulFetch(response: string | Record<string, unknown>) {\n  return async (input: URL | RequestInfo, init?: RequestInit | undefined) => {\n    reqMock({\n      url: input,\n      headers: init?.headers,\n      method: init?.method,\n      body: init?.body,\n    })\n    return new Response(\n      typeof response === 'string' ? response : JSON.stringify(response),\n    )\n  }\n}\n\nbeforeEach(() => {\n  vi.clearAllMocks()\n})\n\ndescribe('enhancedFetch', () => {\n  describe('json', () => {\n    it('should be untyped by default', async () => {\n      vi.spyOn(global, 'fetch').mockImplementationOnce(\n        successfulFetch({ foo: 'bar' }),\n      )\n      const result = await subject\n        .enhancedFetch('https://example.com/api/users')\n        .then((r) => r.json())", "      type _R = Expect<Equal<typeof result, unknown>>\n      expect(result).toEqual({ foo: 'bar' })\n    })\n\n    it('should accept a type', async () => {\n      vi.spyOn(global, 'fetch').mockImplementationOnce(\n        successfulFetch({ foo: 'bar' }),\n      )\n      const result = await subject\n        .enhancedFetch('https://example.com/api/users')\n        .then((r) => r.json<{ foo: string }>())", "      type _R = Expect<Equal<typeof result, { foo: string }>>\n      expect(result).toEqual({ foo: 'bar' })\n    })\n\n    it('should accept a parser', async () => {\n      vi.spyOn(global, 'fetch').mockImplementationOnce(\n        successfulFetch({ foo: 'bar' }),\n      )\n      const result = await subject\n        .enhancedFetch('https://example.com/api/users')\n        .then((r) => r.json(z.object({ foo: z.string() })))", "      type _R = Expect<Equal<typeof result, { foo: string }>>\n      expect(result).toEqual({ foo: 'bar' })\n    })\n  })\n\n  describe('text', () => {\n    it('should be untyped by default', async () => {\n      vi.spyOn(global, 'fetch').mockImplementationOnce(\n        successfulFetch({ foo: 'bar' }),\n      )\n      const result = await subject\n        .enhancedFetch('https://example.com/api/users')\n        .then((r) => r.text())", "      type _R = Expect<Equal<typeof result, string>>\n      expect(result).toEqual(`{\"foo\":\"bar\"}`)\n    })\n\n    it('should accept a type', async () => {\n      vi.spyOn(global, 'fetch').mockImplementationOnce(\n        successfulFetch('john@doe.com'),\n      )\n      const result = await subject\n        .enhancedFetch('https://example.com/api/users')\n        .then((r) => r.text<`${string}@${string}.${string}`>())", "      type _R = Expect<Equal<typeof result, `${string}@${string}.${string}`>>\n      expect(result).toEqual('john@doe.com')\n    })\n\n    it('should accept a parser', async () => {\n      vi.spyOn(global, 'fetch').mockImplementationOnce(\n        successfulFetch('john@doe.com'),\n      )\n      const result = await subject\n        .enhancedFetch('https://example.com/api/users')\n        .then((r) => r.text(z.string().email()))", "      type _R = Expect<Equal<typeof result, string>>\n      expect(result).toEqual('john@doe.com')\n    })\n  })\n\n  it('should accept a schema that transforms the response', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: { 'deep-nested': { 'kind-of-value': true } } }),\n    )\n    const result = await subject\n      .enhancedFetch('https://example.com/api/users')\n      .then((r) =>\n        r.json(\n          z\n            .object({\n              foo: z.object({\n                'deep-nested': z.object({ 'kind-of-value': z.boolean() }),\n              }),\n            })\n            .transform(kebabToCamel),\n        ),\n      )", "    type _R = Expect<\n      Equal<typeof result, { foo: { deepNested: { kindOfValue: boolean } } }>\n    >\n    expect(result).toEqual({ foo: { deepNested: { kindOfValue: true } } })\n  })\n\n  it('should replace params in the URL', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    await subject.enhancedFetch(\n      'https://example.com/api/users/:user/page/:page',\n      {\n        params: {\n          user: '1',\n          page: '2',\n          // @ts-expect-error\n          foo: 'bar',\n        },\n      },\n    )\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users/1/page/2',\n      headers: new Headers({\n        'content-type': 'application/json',\n      }),\n    })\n  })\n\n  it('should accept a requestInit and a query', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    await subject.enhancedFetch('https://example.com/api/users', {\n      headers: { Authorization: 'Bearer 123' },\n      query: { admin: 'true' },\n    })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users?admin=true',\n      headers: new Headers({\n        authorization: 'Bearer 123',\n        'content-type': 'application/json',\n      }),\n    })\n  })\n\n  it('should accept a stringified body', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    await subject.enhancedFetch('https://example.com/api/users', {\n      body: JSON.stringify({ id: 1, name: { first: 'John', last: 'Doe' } }),\n      method: 'POST',\n    })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({ 'content-type': 'application/json' }),\n      method: 'POST',\n      body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n    })\n  })\n\n  it('should stringify the body', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    await subject.enhancedFetch('https://example.com/api/users', {\n      body: { id: 1, name: { first: 'John', last: 'Doe' } },\n      method: 'POST',\n    })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({ 'content-type': 'application/json' }),\n      method: 'POST',\n      body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n    })\n  })\n", "  it('should accept a trace function for debugging purposes', async () => {\n    const trace = vi.fn()\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    await subject.enhancedFetch('https://example.com/api/users', {\n      body: { id: 1, name: { first: 'John', last: 'Doe' } },\n      query: { admin: 'true' },\n      trace,\n      method: 'POST',\n    })\n    expect(trace).toHaveBeenCalledWith(\n      'https://example.com/api/users?admin=true',\n      {\n        headers: new Headers({ 'content-type': 'application/json' }),\n        method: 'POST',\n        body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n      },\n    )\n  })\n})\n\ndescribe('makeFetcher', () => {\n  it('should return a applied enhancedFetch', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const service = subject.makeFetcher('https://example.com/api')\n    const result = await service('/users', { method: 'post' }).then((r) =>\n      r.json(z.object({ foo: z.string() })),\n    )", "    type _R = Expect<Equal<typeof result, { foo: string }>>\n    expect(result).toEqual({ foo: 'bar' })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({ 'content-type': 'application/json' }),\n      method: 'post',\n    })\n  })\n\n  it('should add headers to the request', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const fetcher = subject.makeFetcher('https://example.com/api', {\n      Authorization: 'Bearer 123',\n    })\n    await fetcher('/users')\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({\n        authorization: 'Bearer 123',\n        'content-type': 'application/json',\n      }),\n    })\n  })\n\n  it('should accept a typed params object', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const fetcher = subject.makeFetcher('https://example.com/api')\n    await fetcher('/users/:id', {\n      params: {\n        id: '1',\n        // @ts-expect-error\n        foo: 'bar',\n      },\n    })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users/1',\n      headers: new Headers({ 'content-type': 'application/json' }),\n    })\n  })\n", "  it('should accept a function for dynamic headers', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const fetcher = subject.makeFetcher('https://example.com/api', () => ({\n      Authorization: 'Bearer 123',\n    }))\n    await fetcher('/users')\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({\n        authorization: 'Bearer 123',\n        'content-type': 'application/json',\n      }),\n    })\n  })\n", "  it('should accept an async function for dynamic headers', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const fetcher = subject.makeFetcher(\n      'https://example.com/api',\n      async () => ({\n        Authorization: 'Bearer 123',\n      }),\n    )\n    await fetcher('/users')\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({\n        authorization: 'Bearer 123',\n        'content-type': 'application/json',\n      }),\n    })\n  })\n\n  it('should accept a query, trace, and JSON-like body', async () => {\n    const trace = vi.fn()\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const fetcher = subject.makeFetcher('https://example.com/api')\n    await fetcher('/users', {\n      method: 'POST',\n      body: { id: 1, name: { first: 'John', last: 'Doe' } },\n      query: { admin: 'true' },\n      trace,\n    })\n    expect(trace).toHaveBeenCalledWith(\n      'https://example.com/api/users?admin=true',\n      {\n        headers: new Headers({ 'content-type': 'application/json' }),\n        method: 'POST',\n        body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n      },\n    )\n  })\n})\n\ndescribe('makeService', () => {\n  it('should return an object with http methods', () => {\n    const service = subject.makeService('https://example.com/api')", "    for (const method of HTTP_METHODS) {\n      expect(\n        typeof service[method.toLocaleLowerCase() as Lowercase<HTTPMethod>],\n      ).toBe('function')\n    }\n  })\n\n  it('should return an API with enhancedFetch', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const service = subject.makeService('https://example.com/api')\n    const result = await service\n      .post('/users')\n      .then((r) => r.json(z.object({ foo: z.string() })))", "    type _R = Expect<Equal<typeof result, { foo: string }>>\n    expect(result).toEqual({ foo: 'bar' })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users',\n      headers: new Headers({ 'content-type': 'application/json' }),\n      method: 'POST',\n    })\n  })\n\n  it('should accept a typed params object', async () => {\n    vi.spyOn(global, 'fetch').mockImplementationOnce(\n      successfulFetch({ foo: 'bar' }),\n    )\n    const service = subject.makeService('https://example.com/api')\n    await service.get('/users/:id', {\n      params: {\n        id: '1',\n        // @ts-expect-error\n        foo: 'bar',\n      },\n    })\n    expect(reqMock).toHaveBeenCalledWith({\n      url: 'https://example.com/api/users/1',\n      headers: new Headers({ 'content-type': 'application/json' }),\n      method: 'GET',\n    })\n  })\n})\n\ndescribe('typedResponse', () => {\n  it('should return unknown by default when turning into a JSON', async () => {\n    const result = await subject.typedResponse(new Response('1')).json()", "    type _R = Expect<Equal<typeof result, unknown>>\n    expect(result).toEqual(1)\n  })\n\n  it('should accept a type for the JSON method', async () => {\n    const result = await subject\n      .typedResponse(new Response(`{\"foo\":\"bar\"}`))\n      .json<{ foo: string }>()\n    type _R = Expect<Equal<typeof result, { foo: string }>>\n    expect(result).toEqual({ foo: 'bar' })\n  })\n\n  it('should accept a parser for the JSON method', async () => {\n    const result = await subject\n      .typedResponse(new Response(`{\"foo\":\"bar\"}`))\n      .json(z.object({ foo: z.string() }))", "    type _R = Expect<Equal<typeof result, { foo: string }>>\n    expect(result).toEqual({ foo: 'bar' })\n  })\n\n  it('should accept a parser for the JSON method', async () => {\n    const result = await subject\n      .typedResponse(new Response(`{\"foo\":\"bar\"}`))\n      .json(z.object({ foo: z.string() }))\n    type _R = Expect<Equal<typeof result, { foo: string }>>\n    expect(result).toEqual({ foo: 'bar' })\n  })\n})\n", "    type _R = Expect<Equal<typeof result, { foo: string }>>\n    expect(result).toEqual({ foo: 'bar' })\n  })\n})\n"]}
