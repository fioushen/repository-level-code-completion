{"filename": "manifest.ts", "chunked_list": ["import { defineManifest } from '@crxjs/vite-plugin'\nimport packageJson from './package.json'\n\nconst { description, version } = packageJson\n\nexport default defineManifest({\n  name: 'GitHub Account Switcher',\n  description,\n  version,\n  manifest_version: 3,", "  version,\n  manifest_version: 3,\n  icons: {\n    '16': 'img/logo-16.png',\n    '32': 'img/logo-32.png',\n    '48': 'img/logo-48.png',\n    '128': 'img/logo-128.png',\n  },\n  action: {\n    default_popup: 'popup.html',", "  action: {\n    default_popup: 'popup.html',\n    default_icon: 'img/logo-48.png',\n  },\n  background: {\n    service_worker: 'src/background/index.ts',\n    type: 'module',\n  },\n  content_scripts: [\n    {", "  content_scripts: [\n    {\n      matches: ['https://*.github.com/*'],\n      run_at: 'document_start',\n      js: ['src/content/index.ts'],\n    },\n  ],\n  web_accessible_resources: [],\n  host_permissions: ['https://*.github.com/'],\n  permissions: ['cookies', 'storage', 'webRequest', 'declarativeNetRequest'],", "  host_permissions: ['https://*.github.com/'],\n  permissions: ['cookies', 'storage', 'webRequest', 'declarativeNetRequest'],\n})\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { crx } from '@crxjs/vite-plugin'\nimport react from '@vitejs/plugin-react'\nimport { defineConfig } from 'vite'\nimport manifest from './manifest'\n\nexport default defineConfig({\n  plugins: [react(), crx({ manifest })],\n})\n", ""]}
{"filename": "scripts/build.ts", "chunked_list": ["import cpy from 'cpy'\nimport { deleteAsync } from 'del'\nimport fs from 'fs/promises'\nimport { join } from 'path'\nimport AdmZip from 'adm-zip'\n\nconst __dirname = new URL('.', import.meta.url).pathname\n\n// Convert Chrome manifest V3 to Firefox manifest V2\nasync function buildFirefox() {\n  const distFolder = join(__dirname, '../dist')\n  const distFirefoxFolder = join(__dirname, '../dist_firefox')\n\n  // copy dist folder to dist_firefox\n  await deleteAsync(distFirefoxFolder)\n  await cpy(`${distFolder}/**`, distFirefoxFolder)\n\n  const manifest = JSON.parse(await fs.readFile(join(distFirefoxFolder, 'manifest.json'), 'utf-8'))\n  const {\n    action,\n    background: { service_worker },\n    web_accessible_resources,\n    host_permissions,\n    permissions,\n    ...rest\n  } = manifest\n\n  const combinedPermissions = permissions\n    .filter(\n      (permission: string) =>\n        permission !== 'declarativeNetRequest' && permission !== 'declarativeNetRequestFeedback',\n    )\n    .concat(['webRequestBlocking', ...host_permissions])\n\n  const webAccessibleResources = web_accessible_resources.reduce((acc: string[], item: any) => {\n    return acc.concat(item.resources)\n  }, [])\n\n  const firefoxManifest = {\n    ...rest,\n    manifest_version: 2,\n    browser_action: action,\n    background: {\n      page: 'background.html',\n    },\n    web_accessible_resources: webAccessibleResources,\n    permissions: combinedPermissions,\n  }\n\n  const backgroundHtml = `<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>${manifest.name} Background Page</title>\n  </head>\n  <body>\n    <script src=\"${service_worker}\" type=\"module\"></script>\n  </body>\n</html>\n`\n  await fs.writeFile(join(distFirefoxFolder, 'background.html'), backgroundHtml)\n  await fs.writeFile(\n    join(distFirefoxFolder, 'manifest.json'),\n    JSON.stringify(firefoxManifest, null, 2),\n  )\n\n  console.log('Firefox manifest built')\n}\n", "// Convert Chrome manifest V3 to Firefox manifest V2\nasync function buildFirefox() {\n  const distFolder = join(__dirname, '../dist')\n  const distFirefoxFolder = join(__dirname, '../dist_firefox')\n\n  // copy dist folder to dist_firefox\n  await deleteAsync(distFirefoxFolder)\n  await cpy(`${distFolder}/**`, distFirefoxFolder)\n\n  const manifest = JSON.parse(await fs.readFile(join(distFirefoxFolder, 'manifest.json'), 'utf-8'))\n  const {\n    action,\n    background: { service_worker },\n    web_accessible_resources,\n    host_permissions,\n    permissions,\n    ...rest\n  } = manifest\n\n  const combinedPermissions = permissions\n    .filter(\n      (permission: string) =>\n        permission !== 'declarativeNetRequest' && permission !== 'declarativeNetRequestFeedback',\n    )\n    .concat(['webRequestBlocking', ...host_permissions])\n\n  const webAccessibleResources = web_accessible_resources.reduce((acc: string[], item: any) => {\n    return acc.concat(item.resources)\n  }, [])\n\n  const firefoxManifest = {\n    ...rest,\n    manifest_version: 2,\n    browser_action: action,\n    background: {\n      page: 'background.html',\n    },\n    web_accessible_resources: webAccessibleResources,\n    permissions: combinedPermissions,\n  }\n\n  const backgroundHtml = `<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>${manifest.name} Background Page</title>\n  </head>\n  <body>\n    <script src=\"${service_worker}\" type=\"module\"></script>\n  </body>\n</html>\n`\n  await fs.writeFile(join(distFirefoxFolder, 'background.html'), backgroundHtml)\n  await fs.writeFile(\n    join(distFirefoxFolder, 'manifest.json'),\n    JSON.stringify(firefoxManifest, null, 2),\n  )\n\n  console.log('Firefox manifest built')\n}\n", "async function createZip(folder: string, target: string) {\n  const source = join(__dirname, `../${folder}`)\n  const destination = join(__dirname, `../release/${target}`)\n\n  await deleteAsync(destination)\n\n  const zip = new AdmZip()\n  zip.addLocalFolder(source)\n  zip.writeZip(destination)\n}\n", "async function main() {\n  await buildFirefox()\n  await createZip('dist', 'chrome.zip')\n  await createZip('dist_firefox', 'firefox.zip')\n}\n\nawait main()\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { Rule } from './services/rule'\n\ntype Message<T extends string, P = {}> = { type: T } & P\n\ntype ErrorResponse = { success: false; error: Error }\nexport type Response<T = void> = { success: true; data: T } | ErrorResponse\n\nexport type GetAccountsMessage = Message<'getAccounts'>\nexport type GetAccountsResponse = Response<string[]>\n\nexport type SwitchAccountMessage = Message<'switchAccount', { account: string }>", "export type GetAccountsResponse = Response<string[]>\n\nexport type SwitchAccountMessage = Message<'switchAccount', { account: string }>\nexport type SwitchAccountResponse = Response\n\nexport type ClearCookiesMessage = Message<'clearCookies'>\nexport type ClearCookiesResponse = Response\n\nexport type RemoveAccountMessage = Message<'removeAccount', { account: string }>\nexport type RemoveAccountResponse = Response\n", "export type RemoveAccountMessage = Message<'removeAccount', { account: string }>\nexport type RemoveAccountResponse = Response\n\nexport type GetAutoSwitchRulesMessage = Message<'getAutoSwitchRules'>\nexport type GetAutoSwitchRulesResponse = Response<Rule[]>\n\nexport type RequestMessage =\n  | GetAccountsMessage\n  | ClearCookiesMessage\n  | SwitchAccountMessage\n  | RemoveAccountMessage\n  | GetAutoSwitchRulesMessage\n"]}
{"filename": "src/global.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\ndeclare const __APP_VERSION__: string\n\ndeclare module '*?script&module' {\n  const src: string\n  export default src\n}\n", ""]}
{"filename": "src/shared.ts", "chunked_list": ["import browser from 'webextension-polyfill'\nimport { Rule } from './services/rule'\n\nfunction urlMatchesRule(url: string, rule: Rule) {\n  const pattern = new RegExp(rule.urlPattern)\n  return pattern.test(url)\n}\n\nfunction urlMatchesAnyRule(url: string, rules: Rule[]) {\n  return rules.some((rule) => urlMatchesRule(url, rule))\n}\n", "function urlMatchesAnyRule(url: string, rules: Rule[]) {\n  return rules.some((rule) => urlMatchesRule(url, rule))\n}\n\nexport function isGitHubUrl(url: string | undefined) {\n  if (!url) {\n    return false\n  }\n\n  return /^https:\\/\\/(.+?\\.)?github\\.com/.test(url)\n}\n", "export function isNormalGitHubUrl(url: string | undefined, rules: Rule[]) {\n  if (!url) {\n    return false\n  }\n\n  if (!isGitHubUrl(url)) {\n    return false\n  }\n\n  if (urlMatchesAnyRule(url, rules)) {\n    return false\n  }\n\n  return true\n}\n", "  if (urlMatchesAnyRule(url, rules)) {\n    return false\n  }\n\n  return true\n}\n\nexport async function removeAccount(account: string) {\n  await browser.runtime.sendMessage({ type: 'removeAccount', account })\n}\n"]}
{"filename": "src/background/index.ts", "chunked_list": ["import browser, { DeclarativeNetRequest } from 'webextension-polyfill'\nimport accountService from '../services/account'\nimport { setBadgeText } from '../services/badge'\nimport cookie from '../services/cookie'\nimport ruleService from '../services/rule'\nimport { RequestMessage, Response } from '../types'\n\nconst RESOURCE_TYPES: DeclarativeNetRequest.ResourceType[] = [\n  'main_frame',\n  'sub_frame',", "  'main_frame',\n  'sub_frame',\n  'csp_report',\n  'websocket',\n  'xmlhttprequest',\n]\n\nasync function syncAccounts() {\n  const usernameCookie = await cookie.get('dotcom_user')\n  const sessionCookie = await cookie.get('user_session')\n", "  if (!usernameCookie || !sessionCookie) {\n    return\n  }\n\n  const { value: account } = usernameCookie\n  if (!account) {\n    return\n  }\n\n  await accountService.upsert(account, await cookie.getAll())\n  const accounts = await accountService.getAll()\n  console.info('synced accounts', accounts)\n\n  await updateDynamicRequestRules()\n\n  const res = await fetch(`https://github.com/${account}.png?size=100`)", "  if (res.status === 200) {\n    accountService.saveAvatar(account, res.url)\n  }\n\n  await setBadgeText(account.slice(0, 2))\n}\n\nasync function removeAccount(accountName: string) {\n  await accountService.remove(accountName)\n  await updateDynamicRequestRules()\n}\n", "async function buildCookieValue(accountName: string): Promise<string | null> {\n  const account = await accountService.find(accountName)\n  const cookies = account?.cookies || []\n\n  if (!cookies.length) {\n    return null\n  }\n\n  return cookies\n    .map((cookie) => `${cookie.name}=${cookie.value}`)\n    .concat(`__account__=${accountName}`)\n    .join('; ')\n}\n", "async function buildAddRules(): Promise<DeclarativeNetRequest.Rule[]> {\n  const requestRules: DeclarativeNetRequest.Rule[] = []\n  const autoSwitchRules = await ruleService.getAll()\n\n  for (const [index, rule] of autoSwitchRules.entries()) {\n    const cookieValue = await buildCookieValue(rule.account)\n    if (!cookieValue) {\n      continue\n    }\n\n    requestRules.push({\n      id: index + 1,\n      priority: 1,\n      action: {\n        type: 'modifyHeaders',\n        requestHeaders: [\n          {\n            header: 'Cookie',\n            operation: 'set',\n            value: cookieValue,\n          },\n        ],\n      },\n      condition: {\n        regexFilter: `${rule.urlPattern}|__account__=${rule.account}`,\n        resourceTypes: RESOURCE_TYPES,\n      },\n    })\n  }\n  return requestRules\n}\n", "async function updateDynamicRequestRules() {\n  if (!browser.declarativeNetRequest) {\n    return\n  }\n\n  const existingRules = await browser.declarativeNetRequest.getDynamicRules()\n  const removeRuleIds = existingRules.map((rule) => rule.id)\n  const addRules = await buildAddRules()\n\n  await browser.declarativeNetRequest.updateDynamicRules({\n    removeRuleIds,\n    addRules,\n  })\n\n  const rules = await browser.declarativeNetRequest.getDynamicRules()\n  console.info('Current dynamic rules:', rules)\n}\n\n// Watch the requests, if the main_frame url matches any of the auto switch rules, switch to the account", "function watchAutoSwitchRequests() {\n  browser.webRequest.onBeforeRequest.addListener(\n    (details) => {\n      ruleService.getAll().then((autoSwitchRules) => {\n        for (const rule of autoSwitchRules) {\n          if (new RegExp(rule.urlPattern).test(details.url)) {\n            console.info('onBeforeRequest: found an auto switch rule for url', details.url, rule)\n            return accountService.switchTo(rule.account)\n          }\n        }\n      })\n    },\n    {\n      urls: ['https://github.com/*'],\n      types: ['main_frame'],\n    },\n  )\n}\n", "function watchCookies() {\n  browser.cookies.onChanged.addListener(async (changeInfo) => {\n    const { cookie, removed } = changeInfo\n    // Ignore other cookies\n    if (cookie.name !== 'dotcom_user') {\n      return\n    }\n\n    if (removed) {\n      if (cookie.name === 'dotcom_user') {\n        console.info('dotcom_user cookie removed')\n        await setBadgeText('...')\n      }\n      return\n    }\n\n    console.info('New dotcom_user cookie', cookie.value)\n    await syncAccounts()\n  })\n}\n", "    if (removed) {\n      if (cookie.name === 'dotcom_user') {\n        console.info('dotcom_user cookie removed')\n        await setBadgeText('...')\n      }\n      return\n    }\n\n    console.info('New dotcom_user cookie', cookie.value)\n    await syncAccounts()\n  })\n}\n", "function handleMessage(message: RequestMessage) {\n  const { type } = message\n  switch (type) {\n    case 'getAccounts':\n      return accountService.getAllNames()\n    case 'switchAccount':\n      return accountService.switchTo(message.account)\n    case 'removeAccount':\n      return removeAccount(message.account)\n    case 'clearCookies':\n      return cookie.clear()\n    case 'getAutoSwitchRules':\n      return ruleService.getAll()\n  }\n}\n", "function listenMessage() {\n  browser.runtime.onMessage.addListener(\n    async (request: RequestMessage, _sender): Promise<Response<unknown>> => {\n      try {\n        const data = await handleMessage(request)\n        return { success: true, data }\n      } catch (error: unknown) {\n        return { success: false, error: error as Error }\n      }\n    },\n  )\n}\n", "function interceptRequests() {\n  browser.webRequest.onBeforeSendHeaders.addListener(\n    async (details) => {\n      if (!details.requestHeaders) {\n        return { requestHeaders: details.requestHeaders }\n      }\n\n      const autoSwitchRules = await ruleService.getAll()\n      for (const rule of autoSwitchRules) {\n        const urlPattern = `${rule.urlPattern}|__account__=${rule.account}`\n        if (new RegExp(urlPattern).test(details.url)) {\n          const cookieValue = await buildCookieValue(rule.account)", "      for (const rule of autoSwitchRules) {\n        const urlPattern = `${rule.urlPattern}|__account__=${rule.account}`\n        if (new RegExp(urlPattern).test(details.url)) {\n          const cookieValue = await buildCookieValue(rule.account)\n          if (cookieValue) {\n            for (const header of details.requestHeaders) {\n              if (header.name.toLowerCase() === 'cookie') {\n                header.value = cookieValue\n              }\n            }\n          }\n          console.info('interceptRequests: found an auto switch rule for url', details.url, rule)\n          return { requestHeaders: details.requestHeaders }\n        }\n      }\n\n      return { requestHeaders: details.requestHeaders }\n    },\n    {\n      urls: ['https://github.com/*'],\n      types: RESOURCE_TYPES,\n    },\n    ['blocking', 'requestHeaders'],\n  )\n}\n", "async function init() {\n  await syncAccounts()\n\n  watchAutoSwitchRequests()\n  watchCookies()\n  listenMessage()\n\n  if (!browser.declarativeNetRequest) {\n    interceptRequests()\n  }\n\n  /*\n  chrome.declarativeNetRequest.onRuleMatchedDebug.addListener((info) => {\n    console.info('onRuleMatchedDebug', info)\n  })*/\n}\n\ninit()\n"]}
{"filename": "src/services/account.ts", "chunked_list": ["import browser, { Cookies } from 'webextension-polyfill'\nimport { setBadgeText } from './badge'\nimport cookie from './cookie'\nimport storage from './storage'\n\ntype Cookie = Cookies.Cookie\nexport type Account = {\n  name: string\n  cookies: Cookie[]\n  active: boolean\n  avatarUrl?: string\n  expiresAt?: Date\n}\n", "type Accounts = Record<string, Cookie[]>\n\nasync function getAll(): Promise<Account[]> {\n  const accounts = await storage.get<Accounts>('accounts')\n  if (!accounts) {\n    return []\n  }\n\n  const currentAccount = await browser.cookies.get({\n    url: 'https://github.com',\n    name: 'dotcom_user',\n  })\n\n  const avatarUrls = await storage.get<Record<string, string>>('avatars')\n\n  return Object.entries(accounts).map(([name, cookies]) => {\n    const userSessionCookie = cookies.find(({ name }) => name === 'user_session')\n    return {\n      name,\n      cookies,\n      active: currentAccount?.value === name,\n      avatarUrl: avatarUrls?.[name],\n      expiresAt: userSessionCookie?.expirationDate\n        ? new Date(userSessionCookie.expirationDate * 1000)\n        : undefined,\n    }\n  })\n}\n", "async function getAllNames(): Promise<string[]> {\n  const accounts = await getAll()\n  return accounts.map(({ name }) => name)\n}\n\nasync function find(accountName: string): Promise<Account | undefined> {\n  const accounts = await getAll()\n  return accounts.find((account) => account.name === accountName)\n}\n\nasync function upsert(accountName: string, cookies: Cookie[]) {\n  await storage.update<Accounts>('accounts', (accounts = {}) => {\n    accounts[accountName] = cookies\n    return accounts\n  })\n}\n", "async function upsert(accountName: string, cookies: Cookie[]) {\n  await storage.update<Accounts>('accounts', (accounts = {}) => {\n    accounts[accountName] = cookies\n    return accounts\n  })\n}\n\nasync function switchTo(accountName: string) {\n  await cookie.clear()\n\n  const account = await find(accountName)\n  const cookies = account?.cookies || []", "  for (const cookie of cookies) {\n    const { hostOnly, domain, session, ...rest } = cookie\n    await browser.cookies.set({\n      url: 'https://github.com',\n      domain: hostOnly ? undefined : domain,\n      ...rest,\n    })\n  }\n\n  if (cookies.length) {\n    setBadgeText(accountName.slice(0, 2))\n  } else {\n    setBadgeText('...')\n  }\n}\n", "  if (cookies.length) {\n    setBadgeText(accountName.slice(0, 2))\n  } else {\n    setBadgeText('...')\n  }\n}\n\nasync function remove(accountName: string) {\n  await storage.update<Accounts>('accounts', (accounts) => {\n    if (!accounts) {\n      return\n    }\n\n    delete accounts[accountName]\n    return accounts\n  })\n}\n", "    if (!accounts) {\n      return\n    }\n\n    delete accounts[accountName]\n    return accounts\n  })\n}\n\nasync function saveAvatar(accountName: string, avatarUrl: string) {\n  await storage.update<Record<string, string>>('avatars', (avatars = {}) => {\n    avatars[accountName] = avatarUrl\n    return avatars\n  })\n}\n\nexport default {\n  getAll,\n  getAllNames,\n  find,\n  upsert,\n  switchTo,\n  remove,\n  saveAvatar,\n}\n", "async function saveAvatar(accountName: string, avatarUrl: string) {\n  await storage.update<Record<string, string>>('avatars', (avatars = {}) => {\n    avatars[accountName] = avatarUrl\n    return avatars\n  })\n}\n\nexport default {\n  getAll,\n  getAllNames,\n  find,\n  upsert,\n  switchTo,\n  remove,\n  saveAvatar,\n}\n"]}
{"filename": "src/services/rule.ts", "chunked_list": ["import storage from './storage'\n\nexport type Rule = {\n  id: number\n  urlPattern: string\n  account: string\n}\n\nasync function getAll(): Promise<Rule[]> {\n  const rules = await storage.get<Rule[]>('rules')\n  return rules || []\n}\n", "async function getAll(): Promise<Rule[]> {\n  const rules = await storage.get<Rule[]>('rules')\n  return rules || []\n}\n\nasync function add(rule: Rule) {\n  await storage.update<Rule[]>('rules', (rules = []) => {\n    return [...rules, rule]\n  })\n}\n", "async function update(rule: Rule) {\n  await storage.update<Rule[]>('rules', (rules = []) => {\n    return rules.map((r) => (r.id === rule.id ? rule : r))\n  })\n}\n\nasync function remove(id: number) {\n  await storage.update<Rule[]>('rules', (rules = []) => {\n    return rules.filter((rule) => rule.id !== id)\n  })\n}\n\nexport default {\n  getAll,\n  add,\n  update,\n  remove,\n}\n"]}
{"filename": "src/services/badge.ts", "chunked_list": ["import browser from 'webextension-polyfill'\n\nexport async function setBadgeText(text: string) {\n  const action = browser.action || browser.browserAction\n  await action.setBadgeText({\n    text\n  })\n  await action.setBadgeBackgroundColor({\n    color: '#44b700',\n  })\n  action.setBadgeTextColor({\n    color: '#fff',\n  })\n}\n"]}
{"filename": "src/services/storage.ts", "chunked_list": ["import browser from 'webextension-polyfill'\nasync function set<T>(key: string, value: T) {\n  await browser.storage.local.set({ [key]: value })\n}\n\nasync function get<T>(key: string): Promise<T | undefined> {\n  const { [key]: value } = await browser.storage.local.get(key)\n  return value as T\n}\n\nasync function update<T>(key: string, updater: (value?: T) => T | undefined) {\n  const value = await get<T>(key)\n  await set(key, updater(value))\n}\n", "async function update<T>(key: string, updater: (value?: T) => T | undefined) {\n  const value = await get<T>(key)\n  await set(key, updater(value))\n}\n\nasync function clear() {\n  await browser.storage.local.clear()\n}\n\nexport default {\n  get,\n  set,\n  update,\n  clear,\n}\n"]}
{"filename": "src/services/cookie.ts", "chunked_list": ["import browser from 'webextension-polyfill'\nconst COOKIE_URL = 'https://github.com'\n\nasync function get(name: string) {\n  return browser.cookies.get({ url: COOKIE_URL, name })\n}\n\nasync function getAll() {\n  return browser.cookies.getAll({ url: COOKIE_URL })\n}\n", "async function clear() {\n  const cookies = await getAll()\n  for (const cookie of cookies) {\n    await browser.cookies.remove({ url: COOKIE_URL, name: cookie.name })\n  }\n}\n\nexport default {\n  get,\n  getAll,\n  clear,\n}\n"]}
{"filename": "src/content/injected.ts", "chunked_list": ["type FetchFn = typeof fetch\ntype FetchInput = Parameters<FetchFn>[0]\n\nconst ACCOUNT_PARAM = '__account__'\n\nclass PatchedResponse extends Response {\n  constructor(private readonly response: Response) {\n    super(response.body, response)\n  }\n\n  get url() {\n    const url = new URL(this.response.url, window.location.origin)\n    url.searchParams.delete(ACCOUNT_PARAM)\n    return url.href\n  }\n}\n", "function patchUrl(oldUrl: string | URL) {\n  const account = document.querySelector<HTMLMetaElement>('meta[name=\"user-login\"]')?.content\n  if (!account) {\n    return oldUrl\n  }\n\n  const newUrl = new URL(oldUrl, window.location.origin)\n  newUrl.searchParams.append(ACCOUNT_PARAM, account)\n\n  return newUrl\n}\n", "function patchRequestInfo(input: RequestInfo | URL) {\n  if (input instanceof Request) {\n    return input\n  }\n\n  return patchUrl(input)\n}\n\nfunction patchRequest() {\n  const OriginalRequest = window.Request\n  class PatchedRequest extends OriginalRequest {\n    constructor(input: RequestInfo | URL, init?: RequestInit) {\n      super(patchRequestInfo(input), init)\n    }\n  }\n\n  window.Request = PatchedRequest\n}\n", "function patchRequest() {\n  const OriginalRequest = window.Request\n  class PatchedRequest extends OriginalRequest {\n    constructor(input: RequestInfo | URL, init?: RequestInit) {\n      super(patchRequestInfo(input), init)\n    }\n  }\n\n  window.Request = PatchedRequest\n}\n", "function patchFetch() {\n  const originalFetch = window.fetch\n  const patchedFetch: FetchFn = async (input, options) => {\n    try {\n      const res = await originalFetch(patchRequestInfo(input), options)\n      return new PatchedResponse(res)\n    } catch (err) {\n      console.warn('Failed to fetch:', err)\n      throw err\n    }\n  }\n  window.fetch = patchedFetch\n}\n", "function init() {\n  patchRequest()\n  patchFetch()\n}\n\ninit()\n"]}
{"filename": "src/content/createElement.ts", "chunked_list": ["type Child = Node | string | undefined\n\nexport function createElement(\n  tagName: string,\n  attributes: Record<string, string> | { ns?: string; children?: Child | Child[] },\n) {\n  if (tagName === 'fragment') {\n    const fragment = document.createDocumentFragment()\n    appendChildren(fragment, attributes.children)\n    return fragment\n  }\n\n  const { children, ns, ...rest } = attributes\n  const el = ns ? document.createElementNS(ns, tagName) : document.createElement(tagName)", "  for (const [key, value] of Object.entries(rest)) {\n    el.setAttribute(key, value)\n  }\n\n  appendChildren(el, children)\n  return el\n}\n\nfunction appendChildren(parent: Node, children: Child | Child[] = []) {\n  const childrenArray = Array.isArray(children) ? children : [children]\n  for (const child of childrenArray) {", "function appendChildren(parent: Node, children: Child | Child[] = []) {\n  const childrenArray = Array.isArray(children) ? children : [children]\n  for (const child of childrenArray) {\n    if (typeof child === 'undefined') {\n      continue\n    }\n\n    if (typeof child === 'string') {\n      parent.appendChild(document.createTextNode(child))\n    } else {\n      parent.appendChild(child)\n    }\n  }\n}\n", "export function createRemoveIcon() {\n  return createElement('svg', {\n    ns: 'http://www.w3.org/2000/svg',\n    'aria-hidden': 'true',\n    viewBox: '0 0 16 16',\n    height: '16',\n    width: '16',\n    version: '1.1',\n    'data-view-component': 'true',\n    class: 'octicon octicon-trash',\n    children: createElement('path', {\n      ns: 'http://www.w3.org/2000/svg',\n      d: 'M11 1.75V3h2.25a.75.75 0 0 1 0 1.5H2.75a.75.75 0 0 1 0-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75ZM4.496 6.675l.66 6.6a.25.25 0 0 0 .249.225h5.19a.25.25 0 0 0 .249-.225l.66-6.6a.75.75 0 0 1 1.492.149l-.66 6.6A1.748 1.748 0 0 1 10.595 15h-5.19a1.75 1.75 0 0 1-1.741-1.575l-.66-6.6a.75.75 0 1 1 1.492-.15ZM6.5 1.75V3h3V1.75a.25.25 0 0 0-.25-.25h-2.5a.25.25 0 0 0-.25.25Z',\n    }),\n  })\n}\n"]}
{"filename": "src/content/index.ts", "chunked_list": ["import browser from 'webextension-polyfill'\nimport { isNormalGitHubUrl, removeAccount } from '../shared'\nimport {\n  ClearCookiesMessage,\n  GetAccountsMessage,\n  GetAccountsResponse,\n  GetAutoSwitchRulesMessage,\n  GetAutoSwitchRulesResponse,\n} from '../types'\nimport './index.css'", "} from '../types'\nimport './index.css'\n// Script that will be injected in the main page\nimport { createElement } from './createElement'\nimport injectedScript from './injected?script&module'\nimport { ACCOUNT_ITEM_CLASS, ACCOUNT_REMOVE_CLASS, ADD_ACCOUNT_BUTTON_ID, createAccountItem, createAddAccountLink, createDivider } from './ui'\n\nasync function addSwitchUserMenu(logoutForm: HTMLFormElement) {\n  const currentAccount = document.querySelector<HTMLMetaElement>('meta[name=\"user-login\"]')?.content\n  if (!currentAccount) {\n    console.info('no current account found')\n    return\n  }\n", "  if (!currentAccount) {\n    console.info('no current account found')\n    return\n  }\n\n  if (!document.getElementById(ADD_ACCOUNT_BUTTON_ID)) {\n    // Add the \"Add another account\" menu item and a divider\n    const fragment = createElement('fragment', {\n      children: [\n        createAddAccountLink(),\n        createDivider(),\n      ],\n    })\n\n    // Insert the elements before the logoutForm\n    logoutForm.parentElement?.insertBefore(fragment, logoutForm)\n  }\n\n  const res: GetAccountsResponse = await browser.runtime.sendMessage({\n    type: 'getAccounts',\n  } as GetAccountsMessage)\n", "  if (!res?.success) {\n    return\n  }\n\n  const { data: accounts } = res\n  const addAccountButton = document.getElementById(ADD_ACCOUNT_BUTTON_ID)!\n  for (const account of accounts) {\n    if (account === currentAccount) {\n      continue\n    }\n\n    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`", "    if (!document.getElementById(accountId) && addAccountButton) {\n      const accountWrapper = createAccountItem(account)\n      addAccountButton.parentElement?.insertBefore(accountWrapper, addAccountButton)\n    }\n  }\n}\n\nasync function getAutoSwitchRules() {\n  const res: GetAutoSwitchRulesResponse = await browser.runtime.sendMessage({\n    type: 'getAutoSwitchRules',\n  } as GetAutoSwitchRulesMessage)\n\n  return res?.success ? res.data : []\n}\n", "async function addAccount() {\n  await browser.runtime.sendMessage({ type: 'clearCookies' } as ClearCookiesMessage)\n  const autoSwitchRules = await getAutoSwitchRules()\n\n  window.location.href = isNormalGitHubUrl(window.location.href, autoSwitchRules)\n    ? `/login?return_to=${encodeURIComponent(window.location.href)}`\n    : '/login'\n}\n\nasync function switchAccount(account: string) {\n  await browser.runtime.sendMessage({ type: 'switchAccount', account })\n  const autoSwitchRules = await getAutoSwitchRules()\n", "async function switchAccount(account: string) {\n  await browser.runtime.sendMessage({ type: 'switchAccount', account })\n  const autoSwitchRules = await getAutoSwitchRules()\n\n  if (isNormalGitHubUrl(window.location.href, autoSwitchRules)) {\n    window.location.reload()\n  } else {\n    window.location.href = '/'\n  }\n}\n", "function injectScript() {\n  const script = document.createElement('script')\n  script.src = browser.runtime.getURL(injectedScript)\n  script.type = 'module'\n  document.head.prepend(script)\n}\n\nfunction ready(fn: () => void) {\n  if (document.readyState !== 'loading') {\n    fn()\n    return\n  }\n  document.addEventListener('DOMContentLoaded', fn)\n}\n", "  if (document.readyState !== 'loading') {\n    fn()\n    return\n  }\n  document.addEventListener('DOMContentLoaded', fn)\n}\n\nfunction watchDom() {\n  new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      const isOpen =\n        mutation.type === 'attributes' &&\n        mutation.attributeName === 'open' &&\n        mutation.target instanceof HTMLElement &&\n        mutation.target.hasAttribute('open')\n", "    for (const mutation of mutations) {\n      const isOpen =\n        mutation.type === 'attributes' &&\n        mutation.attributeName === 'open' &&\n        mutation.target instanceof HTMLElement &&\n        mutation.target.hasAttribute('open')\n\n      if (isOpen || (mutation.type === 'childList' && mutation.target instanceof HTMLElement)) {\n        // Find the logout form on GitHub page or Gist page\n        const logoutForm = mutation.target.querySelector<HTMLFormElement>(\n          '.js-loggout-form, #user-links .logout-form, user-drawer-side-panel nav-list .ActionListItem:last-child',\n        )", "        if (logoutForm) {\n          addSwitchUserMenu(logoutForm)\n        }\n      }\n    }\n  }).observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n  })\n}\n", "async function init() {\n  injectScript()\n  ready(watchDom)\n\n  document.addEventListener('click', (event) => {\n    const target = event.target as HTMLElement\n\n    if (target.closest(`.${ADD_ACCOUNT_BUTTON_ID}`)) {\n      // add another account\n      event.preventDefault()\n      addAccount()", "    } else if (target.closest(`.${ACCOUNT_ITEM_CLASS}`)) {\n      // switch to account\n      const closestTarget = target.closest(`.${ACCOUNT_ITEM_CLASS}`) as HTMLElement\n      const { account } = closestTarget.dataset\n      switchAccount(account!)\n    } else if (target.closest(`.${ACCOUNT_REMOVE_CLASS}`)) {\n      // remove account\n      const btn = target.closest(`.${ACCOUNT_REMOVE_CLASS}`) as HTMLElement\n      const { account } = btn.dataset\n      removeAccount(account!).then(() => {\n        btn.parentElement?.remove()\n      })\n    }\n  })\n}\n\ninit()\n"]}
{"filename": "src/content/ui.ts", "chunked_list": ["import { createElement, createRemoveIcon } from './createElement'\n\nexport const ADD_ACCOUNT_BUTTON_ID = 'gh-account-switcher__add-account'\nexport const ACCOUNT_ITEM_CLASS = 'gh-account-switcher__account'\nexport const ACCOUNT_REMOVE_CLASS = 'gh-account-switcher__account-remove'\n\nfunction isNewLook() {\n  return document.querySelector('.AppHeader-user') !== null\n}\n\nfunction uiLook() {\n  return isNewLook() ? newLook : classicLook\n}\n\nconst classicLook = {\n  createDivider() {\n    return createElement('div', {\n      class: 'dropdown-divider'\n    })\n  },\n  createAddAccountLink() {\n    return createElement('a', {\n      id: ADD_ACCOUNT_BUTTON_ID,\n      href: '/login',\n      class: `dropdown-item ${ADD_ACCOUNT_BUTTON_ID}`,\n      children: 'Add another account'\n    })\n  },\n  createAccountItem(account: string) {\n    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n    return createElement('div', {\n      id: accountId,\n      class: 'gh-account-switcher__account-wrapper',\n      children: [\n        createElement('button', {\n          'data-account': account,\n          class: `dropdown-item btn-link ${ACCOUNT_ITEM_CLASS}`,\n          role: 'menuitem',\n          children: [\n            'Switch to ',\n            createElement('b', { children: account }),\n          ],\n        }),\n        createElement('button', {\n          title: 'Remove account',\n          class: `btn-link ${ACCOUNT_REMOVE_CLASS}`,\n          'data-account': account,\n          children: createRemoveIcon(),\n        }),\n      ]\n    })\n  }\n}\n\nconst newLook = {\n  createDivider() {\n    return createElement('li', {\n      class: 'ActionList-sectionDivider'\n    })\n  },\n  createAddAccountLink() {\n    return createElement('li', {\n      id: ADD_ACCOUNT_BUTTON_ID,\n      class: 'ActionListItem',\n      children: [\n        createElement('a', {\n          class: `ActionListContent ${ADD_ACCOUNT_BUTTON_ID}`,\n          href: '/login',\n          children: [\n            createElement('span', {\n              class: 'ActionListItem-label',\n              children: 'Add another account'\n            })\n          ]\n        })\n      ]\n    })\n  },\n  createAccountItem(account: string) {\n    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n    return createElement('li', {\n      id: accountId,\n      class: 'ActionListItem',\n      children: [\n        createElement('button', {\n          'data-account': account,\n          class: `ActionListContent ${ACCOUNT_ITEM_CLASS}`,\n          children: [\n            createElement('span', {\n              class: 'ActionListItem-label',\n              children: [\n                'Switch to ',\n                createElement('b', { children: account }),\n              ]\n            })\n          ]\n        }),\n        createElement('button', {\n          title: 'Remove account',\n          'data-account': account,\n          class: `btn-link color-fg-danger ${ACCOUNT_REMOVE_CLASS}`,\n          children: createRemoveIcon(),\n        })\n      ]\n    })\n  }\n}\n", "function uiLook() {\n  return isNewLook() ? newLook : classicLook\n}\n\nconst classicLook = {\n  createDivider() {\n    return createElement('div', {\n      class: 'dropdown-divider'\n    })\n  },\n  createAddAccountLink() {\n    return createElement('a', {\n      id: ADD_ACCOUNT_BUTTON_ID,\n      href: '/login',\n      class: `dropdown-item ${ADD_ACCOUNT_BUTTON_ID}`,\n      children: 'Add another account'\n    })\n  },\n  createAccountItem(account: string) {\n    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n    return createElement('div', {\n      id: accountId,\n      class: 'gh-account-switcher__account-wrapper',\n      children: [\n        createElement('button', {\n          'data-account': account,\n          class: `dropdown-item btn-link ${ACCOUNT_ITEM_CLASS}`,\n          role: 'menuitem',\n          children: [\n            'Switch to ',\n            createElement('b', { children: account }),\n          ],\n        }),\n        createElement('button', {\n          title: 'Remove account',\n          class: `btn-link ${ACCOUNT_REMOVE_CLASS}`,\n          'data-account': account,\n          children: createRemoveIcon(),\n        }),\n      ]\n    })\n  }\n}\n\nconst newLook = {\n  createDivider() {\n    return createElement('li', {\n      class: 'ActionList-sectionDivider'\n    })\n  },\n  createAddAccountLink() {\n    return createElement('li', {\n      id: ADD_ACCOUNT_BUTTON_ID,\n      class: 'ActionListItem',\n      children: [\n        createElement('a', {\n          class: `ActionListContent ${ADD_ACCOUNT_BUTTON_ID}`,\n          href: '/login',\n          children: [\n            createElement('span', {\n              class: 'ActionListItem-label',\n              children: 'Add another account'\n            })\n          ]\n        })\n      ]\n    })\n  },\n  createAccountItem(account: string) {\n    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n    return createElement('li', {\n      id: accountId,\n      class: 'ActionListItem',\n      children: [\n        createElement('button', {\n          'data-account': account,\n          class: `ActionListContent ${ACCOUNT_ITEM_CLASS}`,\n          children: [\n            createElement('span', {\n              class: 'ActionListItem-label',\n              children: [\n                'Switch to ',\n                createElement('b', { children: account }),\n              ]\n            })\n          ]\n        }),\n        createElement('button', {\n          title: 'Remove account',\n          'data-account': account,\n          class: `btn-link color-fg-danger ${ACCOUNT_REMOVE_CLASS}`,\n          children: createRemoveIcon(),\n        })\n      ]\n    })\n  }\n}\n", "export function createDivider() {\n  const look = uiLook()\n  return look.createDivider();\n}\n\nexport function createAddAccountLink() {\n  const look = uiLook()\n  return look.createAddAccountLink();\n}\n\nexport function createAccountItem(account: string) {\n  const look = uiLook()\n  return look.createAccountItem(account);\n}\n", "export function createAccountItem(account: string) {\n  const look = uiLook()\n  return look.createAccountItem(account);\n}\n"]}
