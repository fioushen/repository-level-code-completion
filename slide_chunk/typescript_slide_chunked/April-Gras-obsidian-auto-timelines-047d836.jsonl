{"filename": "shim.d.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-unused-vars */\ndeclare module \"*.vue\" {\n\timport { ComponentOptions, DefineComponent } from \"vue\";\n\t// const componentOptions: ComponentOptions;\n\t// export default componentOptions;\n\tconst defineComponent: DefineComponent;\n\texport default defineComponent;\n}\n", ""]}
{"filename": "vitest.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\n\nimport { defineConfig } from \"vite\";\nimport { configDefaults } from \"vitest/config\";\nimport Vue from \"@vitejs/plugin-vue\";\nimport TsConfigPath from \"vite-tsconfig-paths\";\n\nexport default defineConfig({\n\tplugins: [Vue(), TsConfigPath()],\n\ttest: {", "\tplugins: [Vue(), TsConfigPath()],\n\ttest: {\n\t\tglobals: true,\n\t\tenvironment: \"happy-dom\",\n\t\tcoverage: {\n\t\t\texclude: [\n\t\t\t\t...configDefaults.exclude,\n\t\t\t\t\"**/components/*\",\n\t\t\t\t\"**/composable/*\",\n\t\t\t\t\"**/views/*\",", "\t\t\t\t\"**/composable/*\",\n\t\t\t\t\"**/views/*\",\n\t\t\t\t\"**/tests/*\",\n\t\t\t],\n\t\t\tprovider: \"istanbul\",\n\t\t\treporter: [\"html\"],\n\t\t},\n\t},\n});\n", "});\n"]}
{"filename": "tests/cardMarkup.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport { SETTINGS_DEFAULT } from \"~/settings\";\nimport {\n\tmockMarkdownCodeBlockTimelineProcessingContext,\n\tmockCardContext,\n} from \"./obsidianMocks\";\nimport {\n\tgetDateText,\n\tcreateCardFromBuiltContext,", "\tgetDateText,\n\tcreateCardFromBuiltContext,\n\tformatBodyForCard,\n} from \"~/cardMarkup\";\n\ndescribe.concurrent(\"Card Markup\", () => {\n\ttest(\"[getDateText] - missing start\", () => {\n\t\texpect(\n\t\t\tgetDateText(\n\t\t\t\t{ startDate: undefined, endDate: undefined },", "\t\t\tgetDateText(\n\t\t\t\t{ startDate: undefined, endDate: undefined },\n\t\t\t\tSETTINGS_DEFAULT\n\t\t\t)\n\t\t).toBe(\"Start date missing\");\n\t});\n\n\ttest(\"[getDateText] - missing end\", () => {\n\t\texpect(\n\t\t\tgetDateText(", "\t\texpect(\n\t\t\tgetDateText(\n\t\t\t\t{ startDate: [1000, 0, 0], endDate: undefined },\n\t\t\t\tSETTINGS_DEFAULT\n\t\t\t)\n\t\t).toBe(\"00/00/1000\");\n\t});\n\n\ttest(\"[getDateText] - missing end\", () => {\n\t\texpect(", "\ttest(\"[getDateText] - missing end\", () => {\n\t\texpect(\n\t\t\tgetDateText(\n\t\t\t\t{ startDate: [1000, 0, 0], endDate: true },\n\t\t\t\tSETTINGS_DEFAULT\n\t\t\t)\n\t\t).toBe(\"From 00/00/1000 to now\");\n\t});\n\n\ttest(\"[createCardFromBuiltContext] - ok\", () => {", "\n\ttest(\"[createCardFromBuiltContext] - ok\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\tconst cardContent = mockCardContext();\n\n\t\texpect(() =>\n\t\t\tcreateCardFromBuiltContext(context, cardContent)\n\t\t).not.toThrowError();\n\n\t\t// @ts-expect-error", "\n\t\t// @ts-expect-error\n\t\tcardContent.body = undefined;\n\t\t// @ts-expect-error\n\t\tcardContent.imageURL = undefined;\n\t\texpect(() =>\n\t\t\tcreateCardFromBuiltContext(context, cardContent)\n\t\t).not.toThrowError();\n\t});\n", "\t});\n\n\ttest(\"[formatBodyForCard] - ok has other timelines\", () => {\n\t\tconst bodyMock = \"Some sample body data\";\n\t\tconst timelineTextMock = \"\\n```aat-vertical\\nother timeline\\n```\";\n\n\t\texpect(\n\t\t\tformatBodyForCard,\n\t\t\t// Add fake note metadata block\n\t\t\t\"---\\n---\\n\" + bodyMock + timelineTextMock", "\t\t\t// Add fake note metadata block\n\t\t\t\"---\\n---\\n\" + bodyMock + timelineTextMock\n\t\t);\n\t});\n});\n"]}
{"filename": "tests/cardDataExtraction.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport { SETTINGS_DEFAULT } from \"~/settings\";\nimport { mockMarkdownCodeBlockTimelineProcessingContext } from \"./obsidianMocks\";\nimport {\n\tgetAbstractDateFromMetadata,\n\tgetBodyFromContextOrDocument,\n\tgetImageUrlFromContextOrDocument,\n\tgetTagsFromMetadataOrTagObject,\n} from \"~/cardDataExtraction\";", "\tgetTagsFromMetadataOrTagObject,\n} from \"~/cardDataExtraction\";\n\nimport type { TFile } from \"obsidian\";\n\ndescribe.concurrent(\"Card Data\", () => {\n\ttest(\"[getAbstractDateFromMetadata] - ok\", () => {\n\t\tconst date = getAbstractDateFromMetadata(\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]", "\t\t\tmockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t);\n\t\texpect(date).toStrictEqual([1000, 1000, 1000]);\n\t});\n\n\ttest(\"[getAbstractDateFromMetadata] - missing frontmatter data\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t] = undefined;\n\n\t\tconst date = getAbstractDateFromMetadata(\n\t\t\tcontext,\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t);\n\n\t\texpect(date).toBeUndefined();\n\t});\n\n\ttest(\"[getAbstractDateFromMetadata] - number frontmatter data\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\n\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t] = undefined;\n\n\t\tconst date = getAbstractDateFromMetadata(\n\t\t\tcontext,\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t);\n\n\t\texpect(date).toBeUndefined();\n\t});\n\n\ttest(\"[getAbstractDateFromMetadata] - number frontmatter data\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t] = 1000;\n\n\t\tconst date = getAbstractDateFromMetadata(\n\t\t\tcontext,\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t);\n\n\t\texpect(date).toStrictEqual([1000, 0, 0]);\n\t});\n\n\ttest(\"[getImageUrlFromContextOrDocument] - ok internal\", () => {\n\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\"![[Picture.png]]\",\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t);\n\n\t\texpect(imageURL).not.toBeNull();\n\t});\n\n\ttest(\"[getImageUrlFromContextOrDocument] - ok external\", () => {\n\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\"![](https://imgur.com/hehe)\",\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t);\n\n\t\texpect(imageURL).not.toBeNull();\n\t});\n\n\ttest(\"[getImageUrlFromContextOrDocument] - ko no picture\", () => {\n\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\"no pictures to be found in here\",\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t);\n\n\t\texpect(imageURL).toBeNull();\n\t});\n\n\ttest(\"[getImageUrlFromContextOrDocument] - ok overrided\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT.metadataKeyEventPictureOverride\n\t\t] = \"picture.png\";\n\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\"no pictures to be found in here\",\n\t\t\tcontext\n\t\t);\n\n\t\texpect(imageURL).not.toBeNull();\n\t});\n\n\ttest(\"[getImageUrlFromContextOrDocument] - ko missing obsidian file\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\tcontext.app.metadataCache.getFirstLinkpathDest = vi.fn(\n\t\t\t(linkpath: string, sourcePath: string): TFile | null => null\n\t\t);\n\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\"![[Picture.png]]\",\n\t\t\tcontext\n\t\t);\n\n\t\texpect(imageURL).toBeNull();\n\t});\n\n\ttest(\"[getBodyFromContextOrDocument]- ko empty body\", () => {\n\t\tconst body = getBodyFromContextOrDocument(\n\t\t\t\"\",\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t);\n\n\t\texpect(body).toBeNull();\n\t});\n\n\ttest(\"[getBodyFromContextOrDocument]- ok empty body / overrided\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\tconst bodyMock = \"Some sample body data\";\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventBodyOverride\"]\n\t\t] = bodyMock;\n\t\tconst body = getBodyFromContextOrDocument(\"\", context);\n\n\t\texpect(body).toBe(bodyMock);\n\t});\n\n\ttest(\"[getBodyFromContextOrDocument]- ok has body / overrided\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\tconst bodyMock = \"Some sample body data\";\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventBodyOverride\"]\n\t\t] = bodyMock;\n\t\tconst body = getBodyFromContextOrDocument(bodyMock + \"body\", context);\n\n\t\texpect(body).toBe(bodyMock);\n\t});\n\n\ttest(\"[getBodyFromContextOrDocument]- ok has only body\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\tconst bodyMock = \"Some sample body data\";\n\n\t\tconst body = getBodyFromContextOrDocument(\n\t\t\t// Add fake note metadata block\n\t\t\t\"---\\n---\\n\" + bodyMock,\n\t\t\tcontext\n\t\t);\n\n\t\texpect(body).toBe(bodyMock);\n\t});\n\ttest(\"[getTagsFromMetadataOrTagObject] - ko empty args\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\tundefined\n\t\t\t)\n\t\t).toStrictEqual([]);\n\t});\n\n\ttest(\"[getTagsFromMetadataOrTagObject] - ok frontmater\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\n\t\tcontext.cachedMetadata.frontmatter.timelines = [\"sample\"];\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\tundefined\n\t\t\t)\n\t\t).toStrictEqual([\"sample\"]);\n\t});\n\n\ttest(\"[getTagsFromMetadataOrTagObject] - ok frontmater\", () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tconst tags = [\n\t\t\t{\n\t\t\t\ttag: \"#sample 2\",\n\t\t\t\tposition: context.cachedMetadata.frontmatter.position,\n\t\t\t},\n\t\t];\n\n\t\tcontext.cachedMetadata.frontmatter.timelines = [\"sample\"];\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\ttags\n\t\t\t)\n\t\t).toStrictEqual([\"sample\"]);\n\t\tcontext.settings.lookForTagsForTimeline = true;\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\ttags\n\t\t\t)\n\t\t).toStrictEqual([\"sample\", \"sample 2\"]);\n\t\tcontext.cachedMetadata.frontmatter.tags = [\"sample 3\"];\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\ttags\n\t\t\t)\n\t\t).toStrictEqual([\"sample\", \"sample 2\", \"sample 3\"]);\n\t\tcontext.cachedMetadata.frontmatter.tags = \"sample 3\";\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\ttags\n\t\t\t)\n\t\t).toStrictEqual([\"sample\", \"sample 2\", \"sample 3\"]);\n\t\tcontext.cachedMetadata.frontmatter.tags = undefined;\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\ttags\n\t\t\t)\n\t\t).toStrictEqual([\"sample\", \"sample 2\"]);\n\t\tcontext.settings.lookForTagsForTimeline = false;\n\t\texpect(\n\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\tcontext.settings,\n\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\ttags\n\t\t\t)\n\t\t).toStrictEqual([\"sample\"]);\n\t});\n});\n"]}
{"filename": "tests/cardData.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport {\n\textractCardData,\n\tgetDataFromNoteMetadata,\n\tgetDataFromNoteBody,\n} from \"~/cardData\";\nimport { SETTINGS_DEFAULT } from \"~/settings\";\nimport {\n\tmockCompleteCardContext,", "import {\n\tmockCompleteCardContext,\n\tmockMarkdownCodeBlockTimelineProcessingContext,\n} from \"./obsidianMocks\";\n\ndescribe.concurrent(\"Card Data\", () => {\n\ttest(\"[extractCardData] - ok no title override\", async () => {\n\t\tconst data = await extractCardData(\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t);", "\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t);\n\n\t\texpect(data.title).toBe(\"basename\");\n\t});\n\n\ttest(\"[extractCardData] - end date is boolean\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT.metadataKeyEventEndDate\n\t\t] = false;\n\t\tconst data = await extractCardData(context);\n\n\t\texpect(data.endDate).toBe(true);\n\t});\n\n\ttest(\"[getDataFromNoteMetadata] - ko no metaData\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\tcontext.cachedMetadata.frontmatter = undefined;\n\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).toBeUndefined();\n\t});\n\n\ttest(\"[getDataFromNoteMetadata] - ko render greenlight is false\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\n\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\n\t\tcontext.cachedMetadata.frontmatter[\n\t\t\tSETTINGS_DEFAULT.metadataKeyEventEndDate\n\t\t] = false;\n\t\tconst data = await extractCardData(context);\n\n\t\texpect(data.endDate).toBe(true);\n\t});\n\n\ttest(\"[getDataFromNoteMetadata] - ko no metaData\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\tcontext.cachedMetadata.frontmatter = undefined;\n\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).toBeUndefined();\n\t});\n\n\ttest(\"[getDataFromNoteMetadata] - ko render greenlight is false\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\n\t\tcontext.cachedMetadata.frontmatter[\"aat-render-enabled\"] = false;\n\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).toBeUndefined();\n\t});\n\n\ttest(\"[getDataFromNoteMetadata] - ko no timeline tags match\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\t// Try with missing timline metadata\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).toBeUndefined();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\n\t\t// Set timeline to nothing\n\t\tcontext.cachedMetadata.frontmatter.timelines = [];\n\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).toBeUndefined();\n\n\t\tcontext.cachedMetadata.frontmatter.timelines = [\"not-timeline\"];\n\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).toBeUndefined();\n\t});\n\n\ttest(\"[getDataFromNoteMetadata] - ok\", async () => {\n\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\tcontext.cachedMetadata.frontmatter.timelines = [\"timline\"];\n\n\t\texpect(\n\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t).not.toBeUndefined();\n\t});\n\n\ttest(\"[getDataFromNoteBody] - ok empty\", async () => {\n\t\tconst {\n\t\t\tcontext,\n\t\t\tcardData: { body },\n\t\t} = mockCompleteCardContext();\n\n\t\texpect(\n\t\t\tawait getDataFromNoteBody(body, context, [\"timeline\"])\n\t\t).toStrictEqual([]);\n\t});\n\n\ttest(\"[getDataFromNoteBody] - ok nothing to parse\", async () => {\n\t\tconst {\n\t\t\tcontext,\n\t\t\tcardData: { body },\n\t\t} = mockCompleteCardContext({\n\t\t\tcontext: mockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\tcardData: {\n\t\t\t\tbody: \"%%aat-inline-event\\n%%\\nsampletext\",\n\t\t\t},\n\t\t});\n\n\t\texpect(\n\t\t\tawait getDataFromNoteBody(body, context, [\"timeline\"])\n\t\t).toStrictEqual([]);\n\t});\n\n\ttest(\"[getDataFromNoteBody] - ok tags are not valid\", async () => {\n\t\tconst {\n\t\t\tcontext,\n\t\t\tcardData: { body },\n\t\t} = mockCompleteCardContext({\n\t\t\tcontext: mockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\tcardData: {\n\t\t\t\tbody: \"'%%aat-inline-event\\naat-event-start-date: 54\\naat-event-end-date: true\\naat-render-enabled: true\\ntimelines: [nottimeline]\\n%%\",\n\t\t\t},\n\t\t});\n\n\t\texpect(\n\t\t\tawait getDataFromNoteBody(body, context, [\"timeline\"])\n\t\t).toStrictEqual([]);\n\t});\n\n\ttest(\"[getDataFromNoteBody] - ok tags are valid\", async () => {\n\t\tconst {\n\t\t\tcontext,\n\t\t\tcardData: { body },\n\t\t} = mockCompleteCardContext({\n\t\t\tcontext: mockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\tcardData: {\n\t\t\t\tbody: \"'%%aat-inline-event\\naat-event-start-date: 54\\naat-event-end-date: true\\naat-render-enabled: true\\ntimelines: [timeline]\\n%%\",\n\t\t\t},\n\t\t});\n\n\t\texpect(\n\t\t\t(await getDataFromNoteBody(body, context, [\"timeline\"])).length\n\t\t).toBe(1);\n\t});\n});\n"]}
{"filename": "tests/settings.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport { vi } from \"vitest\";\nimport { TimelineSettingTab } from \"~/settings\";\nimport AprilsAutomaticTimelinesPlugin from \"~/main\";\nimport manifest from \"~/../manifest.json\";\n\nimport { mockObsidianApp } from \"./obsidianMocks\";\n\nvi.mock(\"vue\", async () => {", "\nvi.mock(\"vue\", async () => {\n\tconst actual = (await vi.importActual(\"vue\")) as Record<string, unknown>;\n\n\treturn {\n\t\t...actual,\n\t\tcreateApp: vi.fn(\n\t\t\t(context: { setup: () => Record<string, unknown> }) => {\n\t\t\t\tconst e = context.setup();\n\n\t\t\t\tfor (const index in e) {\n\t\t\t\t\tconst n = e[index];", "\t\t\t\tconst e = context.setup();\n\n\t\t\t\tfor (const index in e) {\n\t\t\t\t\tconst n = e[index];\n\t\t\t\t\tif (typeof n === \"function\") n();\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tuse: vi.fn(() => ({\n\t\t\t\t\t\tmount: vi.fn(),\n\t\t\t\t\t})),\n\t\t\t\t\tunmount: vi.fn(),\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t\tref: vi.fn(<T>(value: T) => ({ value })),\n\t};\n});\n\nvi.mock(\"vue-i18n\", () => {\n\treturn {\n\t\tcreateI18n: () => ({}),\n\t};\n});\n\ndescribe.concurrent(\"Settings\", () => {\n\ttest(\"Can spawn setting tab\", () => {\n\t\tconst app = mockObsidianApp();\n\t\tconst plugin = new AprilsAutomaticTimelinesPlugin(app, manifest);\n\t\tconst tab = new TimelineSettingTab(app, plugin);\n\n\t\texpect(tab.vueApp).toBeNull();\n\t\ttab.display();\n\t\texpect(tab.vueApp).not.toBeUndefined();\n\t\ttab.hide();\n\t\texpect(tab.vueApp).toBeNull();\n\t\ttab.hide();\n\t\texpect(tab.vueApp).toBeNull();\n\t});\n});\n"]}
{"filename": "tests/abstractDateFormating.test.ts", "chunked_list": ["import \"./obsidianMocks\";\nimport { SETTINGS_DEFAULT } from \"~/settings\";\n\nimport {\n\tapplyConditionBasedFormatting,\n\tformatAbstractDate,\n\tformatDateToken,\n} from \"~/abstractDateFormatting\";\nimport { Condition, DateTokenConfiguration, DateTokenType } from \"~/types\";\nimport {", "import { Condition, DateTokenConfiguration, DateTokenType } from \"~/types\";\nimport {\n\tcreateNumberDateTokenConfiguration,\n\tcreateStringDateTokenConfiguration,\n} from \"~/utils\";\n\ndescribe.concurrent(\"Abstract Date Formatting\", () => {\n\ttest(\"[formatAbstractDate] - boolean date\", () => {\n\t\tconst absctractDateMock = true;\n\t\tconst output = formatAbstractDate(absctractDateMock, SETTINGS_DEFAULT);", "\t\tconst absctractDateMock = true;\n\t\tconst output = formatAbstractDate(absctractDateMock, SETTINGS_DEFAULT);\n\n\t\texpect(output).toBe(\"now\");\n\t});\n\n\ttest(\"[formatAbstractDate] - throws on missing configuration\", () => {\n\t\tconst absctractDateMock = [1000, 0, 0];\n\t\tconst settings = { ...SETTINGS_DEFAULT };\n", "\t\tconst settings = { ...SETTINGS_DEFAULT };\n\n\t\tsettings.dateTokenConfiguration = [];\n\n\t\texpect(() =>\n\t\t\tformatAbstractDate(absctractDateMock, settings)\n\t\t).toThrowError();\n\t});\n\n\ttest(\"[formatAbstractDate] - abstract date\", () => {", "\n\ttest(\"[formatAbstractDate] - abstract date\", () => {\n\t\tconst absctractDateMock = [1000, 0, 0];\n\t\tconst settings = { ...SETTINGS_DEFAULT };\n\n\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\t\"00/00/1000\"\n\t\t);\n\t\tsettings.dateDisplayFormat = \"{month}-{year}-{day}\";\n\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(", "\t\tsettings.dateDisplayFormat = \"{month}-{year}-{day}\";\n\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\t\"00-1000-00\"\n\t\t);\n\t\tsettings.dateDisplayFormat = \"{year} hehe test\";\n\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\t\"1000 hehe test\"\n\t\t);\n\t\tsettings.dateDisplayFormat = \"no template in here\";\n\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(", "\t\tsettings.dateDisplayFormat = \"no template in here\";\n\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\tsettings.dateDisplayFormat\n\t\t);\n\t});\n\n\ttest(\"[formatDateToken] - numerical\", () => {\n\t\tconst configuration = createNumberDateTokenConfiguration({\n\t\t\ttype: DateTokenType.number,\n\t\t});", "\t\t\ttype: DateTokenType.number,\n\t\t});\n\n\t\texpect(formatDateToken(2, configuration)).toBe(\"02\");\n\n\t\tconfiguration.minLeght = 10;\n\t\texpect(formatDateToken(2, configuration)).toBe(\"0000000002\");\n\n\t\tconfiguration.minLeght = -10;\n\t\texpect(formatDateToken(2, configuration)).toBe(\"2\");", "\t\tconfiguration.minLeght = -10;\n\t\texpect(formatDateToken(2, configuration)).toBe(\"2\");\n\t});\n\n\ttest(\"[formatDateToken] - string\", () => {\n\t\tconst configuration = createStringDateTokenConfiguration({\n\t\t\tdictionary: [\"a\", \"b\", \"c\", \"d\"],\n\t\t});\n\n\t\texpect(formatDateToken(2, configuration)).toBe(\"c\");", "\n\t\texpect(formatDateToken(2, configuration)).toBe(\"c\");\n\t});\n\n\ttest(\"[formatdateToken] - ko\", () => {\n\t\tconst configuration =\n\t\t\tcreateNumberDateTokenConfiguration() as DateTokenConfiguration;\n\n\t\t// @ts-expect-error\n\t\tconfiguration.type = \"unvalid type\";", "\t\t// @ts-expect-error\n\t\tconfiguration.type = \"unvalid type\";\n\t\t// @ts-expect-error\n\t\tconfiguration.dictionary = [\"a\", \"b\", \"c\", \"d\"];\n\t\texpect(() => formatDateToken(2, configuration)).toThrowError();\n\t});\n\n\ttest(\"[applyConditionBasedFormatting] - ok skip formatting\", () => {\n\t\tconst input = \"sample input\";\n", "\t\tconst input = \"sample input\";\n\n\t\texpect(\n\t\t\tapplyConditionBasedFormatting(\n\t\t\t\tinput,\n\t\t\t\t0,\n\t\t\t\tcreateNumberDateTokenConfiguration(),\n\t\t\t\tfalse\n\t\t\t)\n\t\t).toBe(input);", "\t\t\t)\n\t\t).toBe(input);\n\t});\n\n\ttest(\"[applyConditionBasedFormatting] - ok no formatting\", () => {\n\t\tconst input = \"sample input\";\n\n\t\texpect(\n\t\t\tapplyConditionBasedFormatting(\n\t\t\t\tinput,", "\t\t\tapplyConditionBasedFormatting(\n\t\t\t\tinput,\n\t\t\t\t0,\n\t\t\t\tcreateNumberDateTokenConfiguration(),\n\t\t\t\ttrue\n\t\t\t)\n\t\t).toBe(input);\n\t});\n\n\ttest(\"[applyConditionBasedFormatting] - ok full conditions exclusive\", () => {", "\n\ttest(\"[applyConditionBasedFormatting] - ok full conditions exclusive\", () => {\n\t\tconst configuration = createNumberDateTokenConfiguration({\n\t\t\tformatting: [\n\t\t\t\t{\n\t\t\t\t\tevaluations: [\n\t\t\t\t\t\t{ condition: Condition.Greater, value: 0 },\n\t\t\t\t\t\t{ condition: Condition.Equal, value: -56 },\n\t\t\t\t\t],\n\t\t\t\t\tconditionsAreExclusive: true,", "\t\t\t\t\t],\n\t\t\t\t\tconditionsAreExclusive: true,\n\t\t\t\t\tformat: \"{value} sample condition formatting\",\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t\tconst input = \"sample\";\n\n\t\texpect(\n\t\t\tapplyConditionBasedFormatting(input, -56, configuration, true)", "\t\texpect(\n\t\t\tapplyConditionBasedFormatting(input, -56, configuration, true)\n\t\t).toBe(`${input} sample condition formatting`);\n\n\t\texpect(\n\t\t\tapplyConditionBasedFormatting(input, 0, configuration, true)\n\t\t).toBe(input);\n\t});\n\n\ttest(\"[applyConditionBasedFormatting] - ok full conditions inclusive\", () => {", "\n\ttest(\"[applyConditionBasedFormatting] - ok full conditions inclusive\", () => {\n\t\tconst configuration = createNumberDateTokenConfiguration({\n\t\t\tformatting: [\n\t\t\t\t{\n\t\t\t\t\tevaluations: [\n\t\t\t\t\t\t{ condition: Condition.Less, value: 0 },\n\t\t\t\t\t\t{ condition: Condition.Equal, value: -56 },\n\t\t\t\t\t],\n\t\t\t\t\tconditionsAreExclusive: false,", "\t\t\t\t\t],\n\t\t\t\t\tconditionsAreExclusive: false,\n\t\t\t\t\tformat: \"{value} sample condition formatting\",\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t\tconst input = \"sample\";\n\n\t\texpect(\n\t\t\tapplyConditionBasedFormatting(input, -56, configuration, true)", "\t\texpect(\n\t\t\tapplyConditionBasedFormatting(input, -56, configuration, true)\n\t\t).toBe(`${input} sample condition formatting`);\n\n\t\texpect(\n\t\t\tapplyConditionBasedFormatting(input, -435, configuration, true)\n\t\t).toBe(input);\n\t});\n});\n", "});\n"]}
{"filename": "tests/rangeMarkup.test.ts", "chunked_list": ["import \"./obsidianMocks\";\nimport { mockHTMLElement, mockRange } from \"./obsidianMocks\";\nimport { vi } from \"vitest\";\n\nimport { renderSingleRange, renderRanges } from \"~/rangeMarkup\";\n\ndescribe.concurrent(\"Range Markup\", () => {\n\ttest(\"[renderSingleRange] - ko missing HTML element\", () => {\n\t\texpect(() =>\n\t\t\trenderSingleRange(mockRange(), 0, mockHTMLElement())", "\t\texpect(() =>\n\t\t\trenderSingleRange(mockRange(), 0, mockHTMLElement())\n\t\t).toThrowError();\n\t});\n\n\ttest(\"[renderSingleRange] - ok\", () => {\n\t\tconst element = mockHTMLElement();\n\t\tconst range = mockRange({\n\t\t\trelatedCardData: {\n\t\t\t\tcontext: {", "\t\t\trelatedCardData: {\n\t\t\t\tcontext: {\n\t\t\t\t\telements: {\n\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n", "\t\t});\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\n\t\tconst output = renderSingleRange(range, 0, mockHTMLElement());\n\t\texpect(output).not.toBeUndefined();\n\n\t\texpect(output.onclick).not.toBeNull();\n\t\texpect(output.onmouseenter).not.toBeNull();\n\t\texpect(output.onmouseover).not.toBeNull();", "\t\texpect(output.onmouseenter).not.toBeNull();\n\t\texpect(output.onmouseover).not.toBeNull();\n\n\t\tconst keepValue = window.document.querySelector;\n\n\t\t// @ts-expect-error\n\t\texpect(() => output.onclick()).not.toThrowError();\n\t\twindow.document.querySelector = vi.fn(mockHTMLElement);\n\t\t// @ts-expect-error\n\t\texpect(() => output.onclick()).not.toThrowError();", "\t\t// @ts-expect-error\n\t\texpect(() => output.onclick()).not.toThrowError();\n\t\t// @ts-expect-error\n\t\texpect(() => output.onmouseleave()).not.toThrowError();\n\t\t// @ts-expect-error\n\t\texpect(() => output.onmouseenter()).not.toThrowError();\n\t\twindow.document.querySelector = keepValue;\n\t});\n\n\ttest(\"[renderRanges] - ko no end date\", () => {", "\n\ttest(\"[renderRanges] - ko no end date\", () => {\n\t\texpect(() =>\n\t\t\trenderRanges([mockRange()], mockHTMLElement())\n\t\t).toThrowError();\n\t});\n\n\ttest(\"[renderRanges] - ok and overflow\", () => {\n\t\tconst element = mockHTMLElement();\n\t\telement.children.item = vi.fn(mockHTMLElement);", "\t\tconst element = mockHTMLElement();\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\n\t\tconst range = mockRange({\n\t\t\trelatedCardData: {\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [0],\n\t\t\t\t\tendDate: [1],\n\t\t\t\t},\n\t\t\t\tcontext: {", "\t\t\t\t},\n\t\t\t\tcontext: {\n\t\t\t\t\telements: {\n\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t\tconst range2 = mockRange({", "\t\t});\n\t\tconst range2 = mockRange({\n\t\t\trelatedCardData: {\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [2],\n\t\t\t\t\tendDate: true,\n\t\t\t\t},\n\t\t\t\tcontext: {\n\t\t\t\t\telements: {\n\t\t\t\t\t\ttimelineRootElement: element,", "\t\t\t\t\telements: {\n\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t\texpect(() =>\n\t\t\trenderRanges(\n\t\t\t\t[", "\t\t\trenderRanges(\n\t\t\t\t[\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,", "\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange,\n\t\t\t\t\trange2,\n\t\t\t\t\trange2,\n\t\t\t\t],\n\t\t\t\tmockHTMLElement()\n\t\t\t)\n\t\t).not.toThrowError();\n\t});", "\t\t).not.toThrowError();\n\t});\n});\n"]}
{"filename": "tests/obsidianMocks.ts", "chunked_list": ["import { mock } from \"vitest-mock-extended\";\nimport { SETTINGS_DEFAULT } from \"~/settings\";\nimport {\n\tTFile as TFileClass,\n\tComponent as ObsidianComponent,\n\tApp as ObsidianApp,\n} from \"obsidian\";\n\nimport type {\n\tApp,", "import type {\n\tApp,\n\tVault,\n\tTFolder,\n\tTFile,\n\tFileStats,\n\tCachedMetadata,\n\tFrontMatterCache,\n} from \"obsidian\";\nimport type { DeepPartial } from \"ts-essentials\";", "} from \"obsidian\";\nimport type { DeepPartial } from \"ts-essentials\";\nimport type {\n\tCardContent,\n\tCompleteCardContext,\n\tMarkdownCodeBlockTimelineProcessingContext,\n\tRange,\n} from \"~/types\";\n\nvi.mock(\"obsidian\", () => {\n\tclass TFile {\n\t\tstat: FileStats;\n\t\tbasename: string;\n\t\textension: string;\n\t\tvault: Vault;\n\t\tpath: string;\n\t\tname: string;\n\t\tparent: TFolder | null;\n\t\tconstructor() {\n\t\t\tthis.stat = mock<FileStats>();\n\t\t\tthis.basename = mock<string>();\n\t\t\tthis.extension = mock<string>();\n\t\t\tthis.vault = mock<Vault>();\n\t\t\tthis.path = mock<string>();\n\t\t\tthis.name = mock<string>();\n\t\t\tthis.parent = mock<TFolder | null>();\n\t\t}\n\t}\n", "\nvi.mock(\"obsidian\", () => {\n\tclass TFile {\n\t\tstat: FileStats;\n\t\tbasename: string;\n\t\textension: string;\n\t\tvault: Vault;\n\t\tpath: string;\n\t\tname: string;\n\t\tparent: TFolder | null;\n\t\tconstructor() {\n\t\t\tthis.stat = mock<FileStats>();\n\t\t\tthis.basename = mock<string>();\n\t\t\tthis.extension = mock<string>();\n\t\t\tthis.vault = mock<Vault>();\n\t\t\tthis.path = mock<string>();\n\t\t\tthis.name = mock<string>();\n\t\t\tthis.parent = mock<TFolder | null>();\n\t\t}\n\t}\n", "\tclass Plugin {\n\t\tcontainerEl: HTMLElement;\n\t\tapp: ObsidianApp;\n\n\t\tconstructor(app: ObsidianApp, manifest: Record<string, unknown>) {\n\t\t\tthis.containerEl = mock<HTMLElement>();\n\t\t\tthis.app = app;\n\t\t\treturn;\n\t\t}\n\n\t\tsaveData = vi.fn();\n\n\t\tloadData = vi.fn(async () => ({ someKey: \"someValue\" }));\n\t\taddSettingTab = vi.fn();\n\t\tregisterMarkdownCodeBlockProcessor = vi.fn();\n\t}\n", "\tclass MarkdownRenderChild {\n\t\tcontainerEl: HTMLElement;\n\n\t\tconstructor(containerEl: HTMLElement) {\n\t\t\tthis.containerEl = containerEl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn {\n\t\tPluginSettingTab: Plugin,\n\t\tTFile: TFile,\n\t\tMarkdownRenderer: {\n\t\t\tasync renderMarkdown(\n\t\t\t\tmarkdown: string,\n\t\t\t\tel: HTMLElement,\n\t\t\t\tsourcePath: string,\n\t\t\t\tcomponent: ObsidianComponent\n\t\t\t): Promise<void> {\n\t\t\t\treturn;\n\t\t\t},\n\t\t},\n\t\tMarkdownRenderChild,\n\t\tPlugin,\n\t};\n});\n\n/**\n * Mock a native HTMLElement object.\n *\n * @returns - The mocked native HTMLElement object.\n */", "export function mockHTMLElement(): HTMLElement {\n\t// @ts-expect-error\n\treturn mock<HTMLElement>({\n\t\tchildren: {\n\t\t\titem: vi\n\t\t\t\t.fn((_: number) => null as Element | null)\n\t\t\t\t.mockImplementationOnce(mockHTMLElement),\n\t\t},\n\t\tcreateDiv: vi.fn(() => {\n\t\t\treturn mockHTMLElement() as HTMLDivElement;\n\t\t}),\n\t\toffsetTop: 0,\n\t\tinnerHeight: 0,\n\t\t// @ts-expect-error\n\t\tcreateEl: vi.fn(\n\t\t\t<K extends keyof HTMLElementTagNameMap>(\n\t\t\t\t_: K,\n\t\t\t\t__?: DomElementInfo | string,\n\t\t\t\t___?: (el: HTMLElementTagNameMap[K]) => void\n\t\t\t): HTMLElementTagNameMap[K] => {\n\t\t\t\treturn mockHTMLElement() as HTMLElementTagNameMap[K];\n\t\t\t}\n\t\t),\n\t\taddClass: vi.fn(() => {\n\t\t\treturn;\n\t\t}),\n\t\tclassList: {\n\t\t\tadd: vi.fn(() => {\n\t\t\t\treturn;\n\t\t\t}),\n\t\t},\n\t});\n}\n\n/**", " * Quickhand function to mock the obsidian `mockGetFileCache` function.\n *\n * @returns - The mocked obsidian `mockGetFileCache` function.\n */\nexport function mockGetFileCache() {\n\treturn vi.fn<[], CachedMetadata | null>(() => {\n\t\treturn {\n\t\t\tfrontmatter: {\n\t\t\t\t...mock<FrontMatterCache>(),\n\t\t\t\ttimelines: [\"timeline\"],\n\t\t\t\t\"aat-render-enabled\": true,\n\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventStartDate]: mock<number>(),\n\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventEndDate]: mock<number>(),\n\t\t\t},\n\t\t};\n\t});\n}\n\n/**", " * Quickhand function to mock a obsidian App Class.\n *\n * @returns - the mocked obsidian App class.\n */\nexport function mockObsidianApp(): App {\n\treturn mock<App>({\n\t\tvault: mockVault(),\n\t\tmetadataCache: {\n\t\t\tgetFileCache: mockGetFileCache().mockReturnValueOnce(null),\n\t\t},\n\t});\n}\n\n/**", " * Quickhand function to mock the obsidian TFile class.\n *\n * @returns - The mocked obsidian TFile.\n */\nexport function mockTFile() {\n\treturn mock<TFile>({\n\t\tvault: {\n\t\t\tcachedRead: vi.fn(async (file: TFile) => {\n\t\t\t\treturn \"---\\n---\\n---\\nSample file data\";\n\t\t\t}),\n\t\t},\n\t});\n}\n\n/**", " * Quickhand function to mock a Obsidian Vault.\n *\n * @returns - The mocked vault.\n */\nexport function mockVault(): Vault {\n\treturn mock<Vault>({\n\t\tgetResourcePath: vi.fn((file: TFile) => {\n\t\t\treturn \"sample\";\n\t\t}),\n\t\tcachedRead: vi.fn(async (file: TFile) => {\n\t\t\treturn \"---\\n---\\n---\\nSample file data\";\n\t\t}),\n\t\tgetMarkdownFiles: vi.fn(() => {\n\t\t\treturn [mockTFile(), mockTFile()];\n\t\t}),\n\t});\n}\n\n/**", " * Quickly mock a MarkdownCodeBlockTimelineProcessingContext. A lot of default are set so inspect the function for further details.\n *\n * @returns - The mocked object.\n */\nexport function mockMarkdownCodeBlockTimelineProcessingContext(): MarkdownCodeBlockTimelineProcessingContext {\n\tconst vault = mockVault();\n\treturn mock<MarkdownCodeBlockTimelineProcessingContext>({\n\t\tapp: {\n\t\t\tvault,\n\t\t\tmetadataCache: {\n\t\t\t\tgetFirstLinkpathDest: vi.fn(\n\t\t\t\t\t(linkpath: string, sourcePath: string): TFile | null => {\n\t\t\t\t\t\treturn new TFileClass();\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t\tfile: {\n\t\t\tbasename: \"basename\",\n\t\t\tvault,\n\t\t},\n\t\telements: {\n\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t},\n\t\tsettings: SETTINGS_DEFAULT,\n\t\tcachedMetadata: {\n\t\t\tfrontmatter: {\n\t\t\t\t\"aat-render-enabled\": true,\n\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventPictureOverride]: undefined,\n\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventBodyOverride]: undefined,\n\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventStartDate]: \"1000-1000-1000\",\n\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventTitleOverride]: undefined,\n\t\t\t},\n\t\t},\n\t});\n}\n\n/**\n * Quickly mock a card context object.\n *\n * @returns - The mocked card content.\n */", "export function mockCardContext() {\n\treturn mock<CardContent>({\n\t\tstartDate: [1000, 0, 0],\n\t\tendDate: true,\n\t\tbody: \"Sample body\",\n\t\timageURL: \"https://sampleURL.png\",\n\t\ttitle: \"Sample title\",\n\t});\n}\n\n/**\n * Mocks a Range object.\n *\n * @param defaultVal - Value override for user defined cases.\n * @returns -  A mocked range object.\n */", "export function mockRange(defaultVal: DeepPartial<Range> = {}): Range {\n\treturn mock<Range>(defaultVal);\n}\n\n/**\n * Mocks the complete card context.\n *\n * @param defaultVal - Value override for user defined cases.\n * @returns -  The complete card context mock object.\n */\nexport function mockCompleteCardContext(\n\tdefaultVal: DeepPartial<CompleteCardContext> = {}\n): CompleteCardContext {\n\treturn mock<CompleteCardContext>(defaultVal);\n}\n", "export function mockCompleteCardContext(\n\tdefaultVal: DeepPartial<CompleteCardContext> = {}\n): CompleteCardContext {\n\treturn mock<CompleteCardContext>(defaultVal);\n}\n"]}
{"filename": "tests/main.test.ts", "chunked_list": ["import \"./obsidianMocks\";\nimport {\n\tmockGetFileCache,\n\tmockHTMLElement,\n\tmockObsidianApp,\n\tmockTFile,\n} from \"./obsidianMocks\";\n\nimport manifest from \"~/../manifest.json\";\nimport { SETTINGS_DEFAULT } from \"~/settings\";", "import manifest from \"~/../manifest.json\";\nimport { SETTINGS_DEFAULT } from \"~/settings\";\n\nimport AprilsAutomaticTimelinesPlugin from \"~/main\";\n\nimport type { Mock } from \"vitest\";\n\ndescribe.concurrent(\"Main\", () => {\n\ttest(\"ok settings call\", async () => {\n\t\tconst app = mockObsidianApp();", "\ttest(\"ok settings call\", async () => {\n\t\tconst app = mockObsidianApp();\n\t\tconst plugin = new AprilsAutomaticTimelinesPlugin(app, manifest);\n\n\t\texpectTypeOf(plugin).toMatchTypeOf<AprilsAutomaticTimelinesPlugin>();\n\t\tlet promise = plugin.loadSettings();\n\t\texpect(() => promise).not.toThrowError();\n\n\t\tawait promise;\n\t\texpect(plugin.loadData).toHaveBeenCalledOnce();", "\t\tawait promise;\n\t\texpect(plugin.loadData).toHaveBeenCalledOnce();\n\t\texpect(Object.keys(plugin.settings)).toContain(\"someKey\");\n\n\t\tpromise = plugin.saveSettings();\n\t\texpect(() => promise).not.toThrowError();\n\t\tawait promise;\n\t\texpect(plugin.saveData).toHaveBeenCalledOnce();\n\t});\n", "\t});\n\n\ttest(\"ok on/un/load\", async () => {\n\t\tconst app = mockObsidianApp();\n\t\tapp.metadataCache.getFileCache = mockGetFileCache()\n\t\t\t.mockImplementationOnce(() => ({\n\t\t\t\t// @ts-expect-error\n\t\t\t\tfrontmatter: {\n\t\t\t\t\ttimelines: [\"timeline\"],\n\t\t\t\t\t\"aat-render-enabled\": true,", "\t\t\t\t\ttimelines: [\"timeline\"],\n\t\t\t\t\t\"aat-render-enabled\": true,\n\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventStartDate]: 87,\n\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventEndDate]: true,\n\t\t\t\t},\n\t\t\t}))\n\t\t\t.mockImplementationOnce(() => ({\n\t\t\t\tfrontmatter: undefined,\n\t\t\t}));\n\t\tconst inlineEventFile = mockTFile();", "\t\t\t}));\n\t\tconst inlineEventFile = mockTFile();\n\n\t\tinlineEventFile.vault.cachedRead = vi.fn(\n\t\t\tasync () =>\n\t\t\t\t\"---\\n---\\n---\\nSample file data%%aat-inline-event\\naat-event-start-date: 54\\naat-event-end-date: true\\naat-render-enabled: true\\ntimelines: [timeline]\\n%%\"\n\t\t);\n\t\tapp.vault.getMarkdownFiles = vi.fn(() => [\n\t\t\tmockTFile(),\n\t\t\tmockTFile(),", "\t\t\tmockTFile(),\n\t\t\tmockTFile(),\n\t\t\tmockTFile(),\n\t\t\tinlineEventFile,\n\t\t]);\n\t\tconst plugin = new AprilsAutomaticTimelinesPlugin(app, manifest);\n\t\tconst spy = vi.spyOn(plugin, \"run\");\n\n\t\texpect(() => plugin.onunload()).not.toThrowError();\n", "\t\texpect(() => plugin.onunload()).not.toThrowError();\n\n\t\tconst promise = plugin.onload();\n\t\texpect(() => promise).not.toThrowError();\n\n\t\tawait promise;\n\t\texpect(\n\t\t\tplugin.registerMarkdownCodeBlockProcessor\n\t\t).toHaveBeenCalledOnce();\n", "\t\t).toHaveBeenCalledOnce();\n\n\t\tconst { mock } = plugin.registerMarkdownCodeBlockProcessor as Mock;\n\n\t\texpect(mock.lastCall[0]).toBe(\"aat-vertical\");\n\t\texpect(mock.lastCall[1]).toBeTypeOf(\"function\");\n\n\t\texpect(() =>\n\t\t\tmock.lastCall[1](\"timeline\", mockHTMLElement(), {\n\t\t\t\tsourcePath: \"sample\",", "\t\t\tmock.lastCall[1](\"timeline\", mockHTMLElement(), {\n\t\t\t\tsourcePath: \"sample\",\n\t\t\t})\n\t\t).not.toThrowError();\n\t\texpect(spy).toHaveBeenCalledOnce();\n\t});\n});\n"]}
{"filename": "tests/utils.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport {\n\tmockHTMLElement,\n\tmockMarkdownCodeBlockTimelineProcessingContext,\n} from \"./obsidianMocks\";\nimport {\n\tcompareAbstractDates,\n\tcreateElementShort,\n\tgetChildAtIndexInHTMLElement,", "\tcreateElementShort,\n\tgetChildAtIndexInHTMLElement,\n\tmeasureTime,\n\tinLerp,\n\tlerp,\n\tfindLastIndex,\n\tisDefinedAsString,\n\tisDefined,\n\tgetMetadataKey,\n\tcreateNumberDateTokenConfiguration,", "\tgetMetadataKey,\n\tcreateNumberDateTokenConfiguration,\n\tcreateStringDateTokenConfiguration,\n\tparseAbstractDate,\n\tevalNumericalCondition,\n\tisDefinedAsBoolean,\n} from \"~/utils\";\nimport { SETTINGS_DEFAULT } from \"~/settings\";\nimport { Condition, DateTokenConfiguration, DateTokenType } from \"~/types\";\n", "import { Condition, DateTokenConfiguration, DateTokenType } from \"~/types\";\n\ndescribe.concurrent(\"Utils\", () => {\n\ttest(\"[compareAbstractDates] - no dates\", () => {\n\t\texpect(compareAbstractDates(undefined, undefined)).toBe(0);\n\t});\n\n\ttest(\"[compareAbstractDates] - only start\", () => {\n\t\texpect(compareAbstractDates([1], undefined)).toBe(1);\n\t});", "\t\texpect(compareAbstractDates([1], undefined)).toBe(1);\n\t});\n\n\ttest(\"[compareAbstractDates] - only end\", () => {\n\t\texpect(compareAbstractDates(undefined, [1])).toBe(-1);\n\t});\n\n\ttest(\"[compareAbstractDates] - start is boolean\", () => {\n\t\texpect(compareAbstractDates(true, [1])).toBe(1);\n\t});", "\t\texpect(compareAbstractDates(true, [1])).toBe(1);\n\t});\n\n\ttest(\"[compareAbstractDates] - end is boolean\", () => {\n\t\texpect(compareAbstractDates([1], true)).toBe(-1);\n\t});\n\n\ttest(\"[compareAbstractDates] - both are boolean\", () => {\n\t\texpect(compareAbstractDates(true, true)).toBe(0);\n\t});", "\t\texpect(compareAbstractDates(true, true)).toBe(0);\n\t});\n\n\ttest(\"[compareAbstractDates] - both are abstract dates but equal - 1 deep\", () => {\n\t\texpect(compareAbstractDates([1], [1])).toBe(0);\n\t});\n\n\ttest(\"[compareAbstractDates] - both are abstract dates but equal - 2 deep\", () => {\n\t\texpect(compareAbstractDates([1, 1], [1, 1])).toBe(0);\n\t});", "\t\texpect(compareAbstractDates([1, 1], [1, 1])).toBe(0);\n\t});\n\n\ttest(\"[compareAbstractDates] - both are abstract dates but equal - 10 deep\", () => {\n\t\texpect(\n\t\t\tcompareAbstractDates([1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1])\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[compareAbstractDates] - a is further in the future - 3 deep\", () => {", "\n\ttest(\"[compareAbstractDates] - a is further in the future - 3 deep\", () => {\n\t\texpect(compareAbstractDates([1, -1, 79], [1, -1, 5])).toBe(1);\n\t});\n\n\ttest(\"[compareAbstractDates] - b is further in the future - 3 deep\", () => {\n\t\texpect(compareAbstractDates([1, -1, 5], [1, -1, 79])).toBe(-1);\n\t});\n\n\ttest(\"[createElementShort] - just the tag\", () => {", "\n\ttest(\"[createElementShort] - just the tag\", () => {\n\t\tconst htmlElementMock = mockHTMLElement();\n\t\tconst output = createElementShort(htmlElementMock, \"div\");\n\n\t\texpect(output).not.toBeUndefined();\n\t\texpect(htmlElementMock.createEl).toHaveBeenCalledOnce();\n\t\texpect(htmlElementMock.createEl).toHaveBeenCalledWith(\"div\");\n\t});\n\n\ttest(\"[createElementShort] - string class addition\", () => {\n\t\tconst htmlElementMock = mockHTMLElement();\n\t\tconst output = createElementShort(htmlElementMock, \"div\", \"hehe\");\n\n\t\texpect(output).not.toBeUndefined();\n\t\texpect(htmlElementMock.createEl).toHaveBeenCalledOnce();\n\t\texpect(htmlElementMock.createEl).toHaveBeenCalledWith(\"div\");\n\t\texpect(output.addClass).toHaveBeenCalledOnce();\n\t\texpect(output.addClass).toHaveBeenCalledWith(\"hehe\");\n\t});\n", "\t});\n\n\ttest(\"[createElementShort] - string class addition\", () => {\n\t\tconst htmlElementMock = mockHTMLElement();\n\t\tconst output = createElementShort(htmlElementMock, \"div\", \"hehe\");\n\n\t\texpect(output).not.toBeUndefined();\n\t\texpect(htmlElementMock.createEl).toHaveBeenCalledOnce();\n\t\texpect(htmlElementMock.createEl).toHaveBeenCalledWith(\"div\");\n\t\texpect(output.addClass).toHaveBeenCalledOnce();\n\t\texpect(output.addClass).toHaveBeenCalledWith(\"hehe\");\n\t});\n", "\ttest(\"[createElementShort] - array class addition\", () => {\n\t\tconst htmlElementMock = mockHTMLElement();\n\t\tconst output = createElementShort(htmlElementMock, \"div\", [\n\t\t\t\"hehe\",\n\t\t\t\"haha\",\n\t\t]);\n\n\t\texpect(output.addClass).toHaveBeenCalledOnce();\n\t\texpect(output.addClass).toHaveBeenCalledWith(\"hehe\", \"haha\");\n\t});\n\n\ttest(\"[createElementShort] - add body but no class\", () => {\n\t\tconst htmlElementMock = mockHTMLElement();\n\t\tconst output = createElementShort(\n\t\t\thtmlElementMock,\n\t\t\t\"div\",\n\t\t\tundefined,\n\t\t\t\"sample content\"\n\t\t);\n\n\t\texpect(output.addClass).not.toHaveBeenCalledOnce();\n\t\texpect(output.innerHTML).toBe(\"sample content\");\n\t});\n\n\ttest(\"[getChildAtIndexInHTMLElement] - ok/ko\", () => {\n\t\tconst htmlElementMock = mockHTMLElement();\n\n\t\texpect(\n\t\t\tgetChildAtIndexInHTMLElement(htmlElementMock, 0)\n\t\t).not.toBeUndefined();\n\n\t\texpect(() =>\n\t\t\tgetChildAtIndexInHTMLElement(htmlElementMock, 1)\n\t\t).toThrowError();\n\t});\n\n\ttest(\"[measureTime] - ok\", () => {\n\t\tconst spyOnTime = vi.spyOn(global.console, \"time\");\n\t\tconst spyOnTimeEnd = vi.spyOn(global.console, \"timeEnd\");\n\t\tconst name = \"timer-name\";\n\t\tconst timer = measureTime(name);\n\n\t\texpect(timer).not.toBeUndefined();\n\t\texpect(spyOnTime).toHaveBeenCalledOnce();\n\t\texpect(spyOnTime).toHaveBeenCalledWith(\n\t\t\t`[April's automatic timelines] - ${name}`\n\t\t);\n\n\t\ttimer();\n\t\texpect(spyOnTimeEnd).toHaveBeenCalledOnce();\n\t});\n\n\ttest(\"[inLerp] - ok\", () => {\n\t\texpect(inLerp(0, 1, 1)).toBe(1);\n\t\texpect(inLerp(0, 10, 1)).toBe(0.1);\n\t\texpect(inLerp(0, 10, 5)).toBe(0.5);\n\t});\n\n\ttest(\"[lerp] - ok\", () => {\n\t\texpect(lerp(0, 1, 1)).toBe(1);\n\t\texpect(lerp(0, 10, 1)).toBe(10);\n\t\texpect(lerp(0, 10, 5)).toBe(50);\n\t});\n\n\ttest(\"[findLastIndex] - ok\", () => {\n\t\tconst arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n", "\t\tfor (let index = 0; index < arr.length - 1; index++)\n\t\t\texpect(findLastIndex(arr, (e) => e === index)).toBe(index);\n\t});\n\n\ttest(\"[findLastIndex] - ko\", () => {\n\t\tconst arr = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n\n\t\texpect(findLastIndex(arr, (e) => e === \"never-found\")).toBe(-1);\n\t\texpect(findLastIndex([] as string[], (e) => e === \"never-found\")).toBe(\n\t\t\t-1\n\t\t);\n\t\texpect(\n\t\t\t// @ts-expect-error\n\t\t\tfindLastIndex(undefined as string[], (e) => e === \"never-found\")\n\t\t).toBe(-1);\n\t});\n\n\ttest(\"[isDefinedAsString] - ok/ko\", () => {\n\t\texpect(isDefinedAsString(\"\")).toBe(true);\n\t\texpect(isDefinedAsString(45)).toBe(false);\n\t});\n\n\ttest(\"[isDefinedAsBoolean] - ok/ko\", () => {\n\t\texpect(isDefinedAsBoolean(true)).toBe(true);\n\t\texpect(isDefinedAsBoolean(false)).toBe(true);\n\t\texpect(isDefinedAsBoolean(45)).toBe(false);\n\t});\n\n\ttest(\"[isDefined] - ok/ko\", () => {\n\t\texpect(isDefined(\"\")).toBe(true);\n\t\texpect(isDefined(45)).toBe(true);\n\t\texpect(isDefined(null)).toBe(true);\n\t\texpect(isDefined({})).toBe(true);\n\t\texpect(isDefined([])).toBe(true);\n\t\texpect(isDefined(new Map())).toBe(true);\n\t\texpect(isDefined(new WeakMap())).toBe(true);\n\t\texpect(isDefined(new WeakSet())).toBe(true);\n\t\texpect(isDefined(new Set())).toBe(true);\n\t\texpect(isDefined(Symbol())).toBe(true);\n\n\t\texpect(isDefined(undefined)).toBe(false);\n\t});\n\n\ttest(\"[getMetadataKey] - ok\", () => {\n\t\tconst { cachedMetadata } =\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\texpect(\n\t\t\tgetMetadataKey(\n\t\t\t\tcachedMetadata,\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate,\n\t\t\t\t\"number\"\n\t\t\t)\n\t\t).toBe(undefined);\n\n\t\texpect(\n\t\t\tgetMetadataKey(\n\t\t\t\tcachedMetadata,\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate,\n\t\t\t\t\"string\"\n\t\t\t)\n\t\t).toBe(\"1000-1000-1000\");\n\t});\n\n\ttest(\"[getMetadataKey] - ok\", () => {\n\t\tconst { cachedMetadata } =\n\t\t\tmockMarkdownCodeBlockTimelineProcessingContext();\n\n\t\tcachedMetadata.frontmatter = undefined;\n\t\texpect(\n\t\t\tgetMetadataKey(\n\t\t\t\tcachedMetadata,\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate,\n\t\t\t\t\"string\"\n\t\t\t)\n\t\t).toBeUndefined();\n\t});\n\n\ttest(\"[createNumberDateTokenConfiguration] - ok\", () => {\n\t\texpect(createNumberDateTokenConfiguration()).toStrictEqual({\n\t\t\tminLeght: 2,\n\t\t\tname: \"\",\n\t\t\tdisplayWhenZero: true,\n\t\t\tformatting: [],\n\t\t\ttype: DateTokenType.number,\n\t\t\thideSign: false,\n\t\t} satisfies DateTokenConfiguration);\n\n\t\texpect(\n\t\t\tcreateNumberDateTokenConfiguration({\n\t\t\t\tname: \"sample\",\n\t\t\t})\n\t\t).toStrictEqual({\n\t\t\tminLeght: 2,\n\t\t\tname: \"sample\",\n\t\t\ttype: DateTokenType.number,\n\t\t\tdisplayWhenZero: true,\n\t\t\thideSign: false,\n\t\t\tformatting: [],\n\t\t} satisfies DateTokenConfiguration);\n\n\t\texpect(\n\t\t\tcreateNumberDateTokenConfiguration({\n\t\t\t\tname: \"sample\",\n\t\t\t\tminLeght: 234,\n\t\t\t})\n\t\t).toStrictEqual({\n\t\t\tminLeght: 234,\n\t\t\tname: \"sample\",\n\t\t\ttype: DateTokenType.number,\n\t\t\tdisplayWhenZero: true,\n\t\t\thideSign: false,\n\t\t\tformatting: [],\n\t\t} satisfies DateTokenConfiguration);\n\t});\n\n\ttest(\"[createStringDateTokenConfiguration] - ok\", () => {\n\t\texpect(createStringDateTokenConfiguration()).toStrictEqual({\n\t\t\tname: \"\",\n\t\t\tdictionary: [\"\"],\n\t\t\ttype: DateTokenType.string,\n\t\t\tformatting: [],\n\t\t} satisfies DateTokenConfiguration);\n\n\t\texpect(\n\t\t\tcreateStringDateTokenConfiguration({\n\t\t\t\tname: \"sample\",\n\t\t\t})\n\t\t).toStrictEqual({\n\t\t\tname: \"sample\",\n\t\t\tdictionary: [\"\"],\n\t\t\ttype: DateTokenType.string,\n\t\t\tformatting: [],\n\t\t} satisfies DateTokenConfiguration);\n\n\t\texpect(\n\t\t\tcreateStringDateTokenConfiguration({\n\t\t\t\tname: \"sample\",\n\t\t\t\tdictionary: [\"a\"],\n\t\t\t})\n\t\t).toStrictEqual({\n\t\t\tname: \"sample\",\n\t\t\tdictionary: [\"a\"],\n\t\t\ttype: DateTokenType.string,\n\t\t\tformatting: [],\n\t\t} satisfies DateTokenConfiguration);\n\t});\n\n\ttest(\"[parseAbstractDate] - ok\", () => {\n\t\tconst date = parseAbstractDate(\n\t\t\t[\"year\", \"month\", \"day\"],\n\t\t\t\"1000-1000-1000\",\n\t\t\tSETTINGS_DEFAULT.dateParserRegex\n\t\t);\n\n\t\texpect(date).toStrictEqual([1000, 1000, 1000]);\n\t});\n\n\ttest(\"[parseAbstractDate] - faulty regex\", () => {\n\t\tconst date = parseAbstractDate(\n\t\t\t[\"year\", \"month\", \"day\"],\n\t\t\t\"1000-1000-1000\",\n\t\t\t\"this-regex-will-not-match\"\n\t\t);\n\n\t\texpect(date).toBeUndefined();\n\t});\n\n\ttest(\"[parseAbstractDate] - partial regex match\", () => {\n\t\tconst date = parseAbstractDate(\n\t\t\t[\"year\", \"month\", \"day\"],\n\t\t\t\"1000-1000-1000\",\n\t\t\t\"(?<year>-?[0-9]*)-\"\n\t\t);\n\n\t\texpect(date).toBeUndefined();\n\t});\n\n\ttest(\"[evalNumericalCondition] - full suite\", () => {\n\t\tconst fn = evalNumericalCondition;\n\n\t\texpect(fn(Condition.Equal, 0, 0)).toBe(true);\n\t\texpect(fn(Condition.Equal, 0, 1)).toBe(false);\n\n\t\texpect(fn(Condition.NotEqual, 0, 0)).toBe(false);\n\t\texpect(fn(Condition.NotEqual, 0, 1)).toBe(true);\n\n\t\texpect(fn(Condition.Greater, 0, 0)).toBe(false);\n\t\texpect(fn(Condition.Greater, 0, 1)).toBe(false);\n\t\texpect(fn(Condition.Greater, 2, 1)).toBe(true);\n\n\t\texpect(fn(Condition.GreaterOrEqual, 0, 1)).toBe(false);\n\t\texpect(fn(Condition.GreaterOrEqual, 0, 0)).toBe(true);\n\t\texpect(fn(Condition.GreaterOrEqual, 1, 0)).toBe(true);\n\n\t\texpect(fn(Condition.Less, 0, 0)).toBe(false);\n\t\texpect(fn(Condition.Less, 1, 0)).toBe(false);\n\t\texpect(fn(Condition.Less, 0, 1)).toBe(true);\n\n\t\texpect(fn(Condition.LessOrEqual, 0, 0)).toBe(true);\n\t\texpect(fn(Condition.LessOrEqual, 1, 0)).toBe(false);\n\t\texpect(fn(Condition.LessOrEqual, 0, 1)).toBe(true);\n\t});\n});\n"]}
{"filename": "tests/rangeData.test.ts", "chunked_list": ["import \"./obsidianMocks\";\nimport { vi } from \"vitest\";\n\nimport { mockCompleteCardContext, mockHTMLElement } from \"./obsidianMocks\";\n\nimport {\n\tfindBoundaries,\n\tgetInLerpValues,\n\tfindEndPositionForDate,\n\tgetAllRangeData,", "\tfindEndPositionForDate,\n\tgetAllRangeData,\n} from \"~/rangeData\";\n\ndescribe.concurrent(\"Range Data\", () => {\n\ttest(\"[findBoundaries] - ko no start\", () => {\n\t\texpect(() =>\n\t\t\tfindBoundaries(\n\t\t\t\t[5],\n\t\t\t\t[mockCompleteCardContext()],", "\t\t\t\t[5],\n\t\t\t\t[mockCompleteCardContext()],\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toThrowError(\n\t\t\t\"No first over found - Can't draw range since there are no other two start date to referrence it's position\"\n\t\t);\n\t});\n", "\t});\n\n\ttest(\"[findBoundaries] - ko no first last under\", () => {\n\t\texpect(() =>\n\t\t\tfindBoundaries(\n\t\t\t\t[5],\n\t\t\t\t[\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [6],", "\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [6],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toThrowError(\n\t\t\t\"Could not find a firstLastUnderIndex, this means this function was called with un rangeable members\"\n\t\t);\n\t});\n\n\ttest(\"[findBoundaries] - ko no end\", () => {\n\t\texpect(() =>\n\t\t\tfindBoundaries(\n\t\t\t\t[5],\n\t\t\t\t[\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [5],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: undefined,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [8],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toThrowError(\"Missing child @ index 2 for element\");\n\t});\n\n\ttest(\"[findBoundaries] - ok\", () => {\n\t\tconst element = mockHTMLElement();\n\t\tconst collection = [\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [2],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [3],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [4],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [6],\n\t\t\t\t},\n\t\t\t}),\n\t\t];\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\texpect(() =>\n\t\t\tfindBoundaries([5], collection, element, 0)\n\t\t).not.toThrowError();\n\t});\n\n\ttest(\"[findBoundaries] - should not offset start position\", () => {\n\t\tconst element = mockHTMLElement();\n\t\tconst collection = [\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [3],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [4],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [6],\n\t\t\t\t},\n\t\t\t}),\n\t\t];\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\texpect(() =>\n\t\t\tfindBoundaries([5], collection, element, 0)\n\t\t).not.toThrowError();\n\t});\n\n\ttest(\"[getInLerpValues] - ok\", () => {\n\t\texpect(\n\t\t\tgetInLerpValues(\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 45],\n\t\t\t\t[]\n\t\t\t)\n\t\t).toStrictEqual([5, 45, undefined]);\n\n\t\texpect(\n\t\t\tgetInLerpValues(\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 45],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 43]\n\t\t\t)\n\t\t).toStrictEqual([5, 45, 43]);\n\n\t\texpect(\n\t\t\tgetInLerpValues(\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 43]\n\t\t\t)\n\t\t).toStrictEqual([0, 1, 1]);\n\t});\n\n\ttest(\"[findEndPositionForDate] - No collection lenght\", () => {\n\t\texpect(\n\t\t\tfindEndPositionForDate(\n\t\t\t\t[1],\n\t\t\t\t[mockCompleteCardContext()],\n\t\t\t\t420,\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toBe(420);\n\t});\n\n\ttest(\"[findEndPositionForDate] - Boundary fetch failure\", () => {\n\t\texpect(\n\t\t\tfindEndPositionForDate(\n\t\t\t\t[1],\n\t\t\t\t[mockCompleteCardContext(), mockCompleteCardContext()],\n\t\t\t\t420,\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toBe(420);\n\t});\n\n\ttest(\"[findEndPositionForDate] - ok\", () => {\n\t\tconst element = mockHTMLElement();\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\texpect(\n\t\t\tfindEndPositionForDate(\n\t\t\t\t[3],\n\t\t\t\t[\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [2],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [4],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\t420,\n\t\t\t\telement,\n\t\t\t\t0\n\t\t\t)\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[getAllRangeData] - ko no collection length\", () => {\n\t\texpect(getAllRangeData([])).toStrictEqual([]);\n\t});\n\n\ttest(\"[getAllRangeData] - ko no start date\", () => {\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t])\n\t\t).toStrictEqual([]);\n\t});\n\n\ttest(\"[getAllRangeData] - ko no end date\", () => {\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(1);\n\t});\n\n\ttest(\"[getAllRangeData] - ok end date under start date\", () => {\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\tendDate: [0],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[getAllRangeData] - ko missing HTMLElements\", () => {\n\t\tconst element = mockHTMLElement();\n\n\t\telement.children.item = vi.fn(() => null);\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[getAllRangeData] - ok end date is infinite\", () => {\n\t\tconst element = mockHTMLElement();\n\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(1);\n\t});\n});\n", "\t\t).toThrowError(\n\t\t\t\"Could not find a firstLastUnderIndex, this means this function was called with un rangeable members\"\n\t\t);\n\t});\n\n\ttest(\"[findBoundaries] - ko no end\", () => {\n\t\texpect(() =>\n\t\t\tfindBoundaries(\n\t\t\t\t[5],\n\t\t\t\t[\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [5],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: undefined,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [8],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toThrowError(\"Missing child @ index 2 for element\");\n\t});\n\n\ttest(\"[findBoundaries] - ok\", () => {\n\t\tconst element = mockHTMLElement();\n\t\tconst collection = [\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [2],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [3],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [4],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [6],\n\t\t\t\t},\n\t\t\t}),\n\t\t];\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\texpect(() =>\n\t\t\tfindBoundaries([5], collection, element, 0)\n\t\t).not.toThrowError();\n\t});\n\n\ttest(\"[findBoundaries] - should not offset start position\", () => {\n\t\tconst element = mockHTMLElement();\n\t\tconst collection = [\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [3],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [4],\n\t\t\t\t},\n\t\t\t}),\n\t\t\tmockCompleteCardContext({\n\t\t\t\tcardData: {\n\t\t\t\t\tstartDate: [6],\n\t\t\t\t},\n\t\t\t}),\n\t\t];\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\texpect(() =>\n\t\t\tfindBoundaries([5], collection, element, 0)\n\t\t).not.toThrowError();\n\t});\n\n\ttest(\"[getInLerpValues] - ok\", () => {\n\t\texpect(\n\t\t\tgetInLerpValues(\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 45],\n\t\t\t\t[]\n\t\t\t)\n\t\t).toStrictEqual([5, 45, undefined]);\n\n\t\texpect(\n\t\t\tgetInLerpValues(\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 45],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 43]\n\t\t\t)\n\t\t).toStrictEqual([5, 45, 43]);\n\n\t\texpect(\n\t\t\tgetInLerpValues(\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 43]\n\t\t\t)\n\t\t).toStrictEqual([0, 1, 1]);\n\t});\n\n\ttest(\"[findEndPositionForDate] - No collection lenght\", () => {\n\t\texpect(\n\t\t\tfindEndPositionForDate(\n\t\t\t\t[1],\n\t\t\t\t[mockCompleteCardContext()],\n\t\t\t\t420,\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toBe(420);\n\t});\n\n\ttest(\"[findEndPositionForDate] - Boundary fetch failure\", () => {\n\t\texpect(\n\t\t\tfindEndPositionForDate(\n\t\t\t\t[1],\n\t\t\t\t[mockCompleteCardContext(), mockCompleteCardContext()],\n\t\t\t\t420,\n\t\t\t\tmockHTMLElement(),\n\t\t\t\t0\n\t\t\t)\n\t\t).toBe(420);\n\t});\n\n\ttest(\"[findEndPositionForDate] - ok\", () => {\n\t\tconst element = mockHTMLElement();\n\n\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\texpect(\n\t\t\tfindEndPositionForDate(\n\t\t\t\t[3],\n\t\t\t\t[\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [2],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [4],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\t420,\n\t\t\t\telement,\n\t\t\t\t0\n\t\t\t)\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[getAllRangeData] - ko no collection length\", () => {\n\t\texpect(getAllRangeData([])).toStrictEqual([]);\n\t});\n\n\ttest(\"[getAllRangeData] - ko no start date\", () => {\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t])\n\t\t).toStrictEqual([]);\n\t});\n\n\ttest(\"[getAllRangeData] - ko no end date\", () => {\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(1);\n\t});\n\n\ttest(\"[getAllRangeData] - ok end date under start date\", () => {\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\tendDate: [0],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[getAllRangeData] - ko missing HTMLElements\", () => {\n\t\tconst element = mockHTMLElement();\n\n\t\telement.children.item = vi.fn(() => null);\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(0);\n\t});\n\n\ttest(\"[getAllRangeData] - ok end date is infinite\", () => {\n\t\tconst element = mockHTMLElement();\n\n\t\texpect(\n\t\t\tgetAllRangeData([\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t]).length\n\t\t).toBe(1);\n\t});\n});\n"]}
{"filename": "tests/timelineMarkup.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport { SETTINGS_DEFAULT } from \"~/settings\";\nimport { setupTimelineCreation } from \"~/timelineMarkup\";\nimport { mockObsidianApp, mockHTMLElement } from \"./obsidianMocks\";\n\ndescribe.concurrent(\"Timeline Markup\", () => {\n\ttest(\"[setupTimelineCreation] - ok\", () => {\n\t\tconst ObsidianAppMock = mockObsidianApp();\n\t\tconst HTMLElementMock = mockHTMLElement();", "\t\tconst ObsidianAppMock = mockObsidianApp();\n\t\tconst HTMLElementMock = mockHTMLElement();\n\t\tconst data = setupTimelineCreation(\n\t\t\tObsidianAppMock,\n\t\t\tHTMLElementMock,\n\t\t\t\"sample\",\n\t\t\tSETTINGS_DEFAULT\n\t\t);\n\n\t\texpect(data.length).toBe(1);", "\n\t\texpect(data.length).toBe(1);\n\t\texpect(ObsidianAppMock.metadataCache.getFileCache).toBeCalledTimes(2);\n\t\texpect(ObsidianAppMock.vault.getMarkdownFiles).toBeCalledTimes(1);\n\t\texpect(data[0].settings).toBe(SETTINGS_DEFAULT);\n\t\texpectTypeOf(\n\t\t\t// @ts-expect-error\n\t\t\tdata[0].cachedMetadata.frontmatter[\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t\t]", "\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t\t]\n\t\t).toMatchTypeOf<number>();\n\t});\n});\n"]}
{"filename": "tests/markdownBlockData.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\nimport { parseMarkdownBlockSource } from \"~/markdownBlockData\";\n\ndescribe.concurrent(\"Markdown block data\", () => {\n\ttest(\"[parseMarkdownBlockSource] - ok no additional settings\", () => {\n\t\tconst { tagsToFind, settingsOverride } = parseMarkdownBlockSource(\n\t\t\t'       only-timeline-name     \\n    asdjaslkdjasldkja  ajds las jd\\n:::Asdsadada2#$@#$\"@#$@#$'\n\t\t);\n", "\t\t);\n\n\t\texpect(tagsToFind).toStrictEqual([\"only-timeline-name\"]);\n\t\texpect(settingsOverride).toStrictEqual({});\n\t});\n\n\ttest(\"[parseMarkdownBlockSource] - ok empty\", () => {\n\t\tconst { tagsToFind, settingsOverride } = parseMarkdownBlockSource(\"\");\n\n\t\texpect(tagsToFind).toStrictEqual([]);", "\n\t\texpect(tagsToFind).toStrictEqual([]);\n\t\texpect(settingsOverride).toStrictEqual({});\n\t});\n\n\ttest(\"[parseMarkdownBlockSource] - ok settings\", () => {\n\t\tconst { tagsToFind, settingsOverride } = parseMarkdownBlockSource(\n\t\t\t\"timeline-name\\ndateDisplayFormat     :     {year}\\n      faultyKey: notValid\\ndateTokenConfiguration: this is a valid key but the override is not supported yet\\napplyAdditonalConditionFormatting: FaLse\\napplyAdditonalConditionFormatting: true\"\n\t\t);\n", "\t\t);\n\n\t\texpect(tagsToFind).toStrictEqual([\"timeline-name\"]);\n\t\texpect(settingsOverride).toStrictEqual({\n\t\t\tdateDisplayFormat: \"{year}\",\n\t\t\tapplyAdditonalConditionFormatting: true,\n\t\t});\n\t});\n\n\ttest(\"[parseMarkdownBlockSource] - ko settings - faulty value for boolean type\", () => {", "\n\ttest(\"[parseMarkdownBlockSource] - ko settings - faulty value for boolean type\", () => {\n\t\texpect(() =>\n\t\t\tparseMarkdownBlockSource(\n\t\t\t\t\"timeline-name\\ndateDisplayFormat     :     {year}\\n      faultyKey: notValid\\ndateTokenConfiguration: this is a valid key but the override is not supported yet\\napplyAdditonalConditionFormatting: notValidValue\"\n\t\t\t)\n\t\t).toThrowError(\"notValidValue is supposed to be a boolean\");\n\t});\n});\n", "});\n"]}
{"filename": "src/rangeData.ts", "chunked_list": ["import {\n\tisDefined,\n\tfindLastIndex,\n\tlerp,\n\tinLerp,\n\tgetChildAtIndexInHTMLElement,\n\tcompareAbstractDates,\n} from \"~/utils\";\n\nimport type { CompleteCardContext, AbstractDate } from \"~/types\";", "\nimport type { CompleteCardContext, AbstractDate } from \"~/types\";\n\n/**\n * Will compute all the data needed to build ranges in the timeline.\n *\n * @param collection - The complete collection of relevant data gathered from notes.\n * @returns the needed  data to build ranges in the timeline.\n */\nexport function getAllRangeData(collection: CompleteCardContext[]) {\n\tif (!collection.length) return [];\n\n\treturn collection.reduce(\n\t\t(accumulator, relatedCardData, index) => {\n\t\t\tconst {\n\t\t\t\tcontext: {\n\t\t\t\t\telements: { timelineRootElement, cardListRootElement },\n\t\t\t\t},\n\t\t\t\tcardData: { startDate, endDate },\n\t\t\t} = relatedCardData;\n", " */\nexport function getAllRangeData(collection: CompleteCardContext[]) {\n\tif (!collection.length) return [];\n\n\treturn collection.reduce(\n\t\t(accumulator, relatedCardData, index) => {\n\t\t\tconst {\n\t\t\t\tcontext: {\n\t\t\t\t\telements: { timelineRootElement, cardListRootElement },\n\t\t\t\t},\n\t\t\t\tcardData: { startDate, endDate },\n\t\t\t} = relatedCardData;\n", "\t\t\tif (!isDefined(startDate) || !isDefined(endDate))\n\t\t\t\treturn accumulator;\n\t\t\tif (\n\t\t\t\tendDate !== true &&\n\t\t\t\tcompareAbstractDates(endDate, startDate) < 0\n\t\t\t)\n\t\t\t\treturn accumulator;\n\n\t\t\tconst timelineLength = timelineRootElement.offsetHeight;\n\t\t\tconst targetCard = cardListRootElement.children.item(\n\t\t\t\tindex\n\t\t\t) as HTMLElement | null;\n\n\t\t\t// Error handling but should not happen", "\t\t\tif (!targetCard) return accumulator;\n\n\t\t\tconst cardRelativeTopPosition = targetCard.offsetTop;\n\t\t\tlet targetPosition: number;\n\n\t\t\tif (endDate === true) targetPosition = timelineLength;\n\t\t\telse\n\t\t\t\ttargetPosition = findEndPositionForDate(\n\t\t\t\t\tendDate,\n\t\t\t\t\tcollection.slice(index),\n\t\t\t\t\ttimelineLength,\n\t\t\t\t\tcardListRootElement,\n\t\t\t\t\tindex\n\t\t\t\t);\n\n\t\t\taccumulator.push({\n\t\t\t\trelatedCardData: {\n\t\t\t\t\t...relatedCardData,\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\t...relatedCardData.cardData,\n\t\t\t\t\t\tendDate,\n\t\t\t\t\t\tstartDate,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttargetPosition,\n\t\t\t\tcardRelativeTopPosition,\n\t\t\t\tindex,\n\t\t\t} as const);\n\t\t\treturn accumulator;\n\t\t},\n\t\t[] as {\n\t\t\treadonly relatedCardData: CompleteCardContext & {\n\t\t\t\tcardData: CompleteCardContext[\"cardData\"] & {\n\t\t\t\t\tstartDate: AbstractDate;\n\t\t\t\t\tendDate: AbstractDate | true;\n\t\t\t\t};\n\t\t\t};\n\t\t\treadonly index: number;\n\t\t\treadonly targetPosition: number;\n\t\t\treadonly cardRelativeTopPosition: number;\n\t\t}[]\n\t);\n}", "export type FnGetRangeData = typeof getAllRangeData;\n\n/**\n * Finds the end position in pixel relative to the top of the timeline root element for the give endDate of a range.\n *\n * @param date - The target endDate to position on the timeline.\n * @param collection - The collection of cards part of the same timeline.\n * @param timelineLength - The length in pixel of the timeline.\n * @param rootElement - The root HTMLElement of the cardList.\n * @param indexOffset  - Since the date is already sorted by date we can save a little time by skipping all the elements before.\n * @returns The expected position relative to the top of the timeline container for this date range.\n */", "export function findEndPositionForDate(\n\tdate: AbstractDate,\n\tcollection: CompleteCardContext[],\n\ttimelineLength: number,\n\trootElement: HTMLElement,\n\tindexOffset: number\n): number {\n\tif (collection.length <= 1) return timelineLength;\n\n\ttry {\n\t\tconst { start, end } = findBoundaries(\n\t\t\tdate,\n\t\t\tcollection,\n\t\t\trootElement,\n\t\t\tindexOffset\n\t\t);\n\t\tconst [inLerpStart, inLerpEnd, targetInLerpDate] = getInLerpValues(\n\t\t\tstart.date,\n\t\t\tend.date,\n\t\t\tdate\n\t\t);\n\t\tconst t = inLerp(inLerpStart, inLerpEnd, targetInLerpDate);\n\n\t\treturn lerp(start.top, end.top, t);", "\ttry {\n\t\tconst { start, end } = findBoundaries(\n\t\t\tdate,\n\t\t\tcollection,\n\t\t\trootElement,\n\t\t\tindexOffset\n\t\t);\n\t\tconst [inLerpStart, inLerpEnd, targetInLerpDate] = getInLerpValues(\n\t\t\tstart.date,\n\t\t\tend.date,\n\t\t\tdate\n\t\t);\n\t\tconst t = inLerp(inLerpStart, inLerpEnd, targetInLerpDate);\n\n\t\treturn lerp(start.top, end.top, t);", "\t} catch (_) {\n\t\treturn timelineLength;\n\t}\n}\n\n/**\n * Gets the values to compute the inlerp needed for range gutter renders.\n *\n * @param a - The start date\n * @param b - The end date\n * @param c - The date in between\n * @returns the first non equal member of a - b when compared from left to right, also returns the same member from c.\n */", "export function getInLerpValues(\n\ta: AbstractDate,\n\tb: AbstractDate,\n\tc: AbstractDate\n): [number, number, number] {\n\tfor (let index = 0; index < a.length; index++) {\n\t\tif (a[index] === b[index]) continue;\n\t\treturn [a[index], b[index], c[index]];\n\t}\n\treturn [0, 1, 1];\n}\n", "type Boundary = { date: AbstractDate; top: number };\n/**\n * Find the position of the last card having a lower start date and the first card with a higher start date relative to the endDate of the evaluated range.\n *\n * @param date - The target endDate to position on the timeline.\n * @param collection - The collection of cards part of the same timeline.\n * @param rootElement - The root HTMLElement of the cardList.\n * @param indexOffset  - Since the date is already sorted by date we can save a little time by skipping all the elements before.\n * @returns The start and end boundaries of the target end date.\n */\nexport function findBoundaries(\n\tdate: AbstractDate,\n\tcollection: CompleteCardContext[],\n\trootElement: HTMLElement,\n\tindexOffset: number\n): { start: Boundary; end: Boundary } {\n\tconst firstOverIndex = collection.findIndex(({ cardData: { startDate } }) =>\n\t\tisDefined(startDate) ? compareAbstractDates(startDate, date) > 0 : false\n\t);\n", "export function findBoundaries(\n\tdate: AbstractDate,\n\tcollection: CompleteCardContext[],\n\trootElement: HTMLElement,\n\tindexOffset: number\n): { start: Boundary; end: Boundary } {\n\tconst firstOverIndex = collection.findIndex(({ cardData: { startDate } }) =>\n\t\tisDefined(startDate) ? compareAbstractDates(startDate, date) > 0 : false\n\t);\n\n\tif (firstOverIndex === -1)\n\t\tthrow new Error(\n\t\t\t\"No first over found - Can't draw range since there are no other two start date to referrence it's position\"\n\t\t);\n\n\tconst firstLastUnderIndex = findLastIndex(\n\t\tcollection,\n\t\t({ cardData: { startDate } }) =>\n\t\t\tisDefined(startDate)\n\t\t\t\t? compareAbstractDates(startDate, date) <= 0\n\t\t\t\t: false\n\t);\n", "\tif (firstOverIndex === -1)\n\t\tthrow new Error(\n\t\t\t\"No first over found - Can't draw range since there are no other two start date to referrence it's position\"\n\t\t);\n\n\tconst firstLastUnderIndex = findLastIndex(\n\t\tcollection,\n\t\t({ cardData: { startDate } }) =>\n\t\t\tisDefined(startDate)\n\t\t\t\t? compareAbstractDates(startDate, date) <= 0\n\t\t\t\t: false\n\t);\n", "\tif (firstLastUnderIndex === -1)\n\t\tthrow new Error(\n\t\t\t\"Could not find a firstLastUnderIndex, this means this function was called with un rangeable members\"\n\t\t);\n\n\tconst lastUnderIndex = collection.findIndex(\n\t\t({ cardData: { startDate } }, index) => {\n\t\t\treturn (\n\t\t\t\tcompareAbstractDates(\n\t\t\t\t\tstartDate,\n\t\t\t\t\tcollection[firstLastUnderIndex].cardData.startDate\n\t\t\t\t) === 0\n\t\t\t);\n\t\t}\n\t);\n", "\tif (lastUnderIndex === -1)\n\t\tthrow new Error(\n\t\t\t\"No last under found - Can't draw range since there are no other two start date to referrence it's position\"\n\t\t);\n\n\tconst startElement = getChildAtIndexInHTMLElement(\n\t\trootElement,\n\t\tlastUnderIndex + indexOffset\n\t);\n\tconst startDate = collection[lastUnderIndex].cardData\n\t\t.startDate as AbstractDate;\n\tconst startIsMoreThanOneCardAway = lastUnderIndex > 1;\n\tconst shouldOffsetStartToBottomOfCard =\n\t\tstartIsMoreThanOneCardAway &&\n\t\tcompareAbstractDates(startDate, date) !== 0;\n\n\treturn {\n\t\tstart: {\n\t\t\ttop:\n\t\t\t\tstartElement.offsetTop +\n\t\t\t\t(shouldOffsetStartToBottomOfCard\n\t\t\t\t\t? startElement.innerHeight\n\t\t\t\t\t: 0),\n\t\t\tdate: startDate,\n\t\t},\n\t\tend: {\n\t\t\ttop: getChildAtIndexInHTMLElement(\n\t\t\t\trootElement,\n\t\t\t\tfirstOverIndex + indexOffset\n\t\t\t).offsetTop,\n\t\t\tdate: collection[firstOverIndex].cardData.startDate as AbstractDate,\n\t\t},\n\t};\n}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { MarkdownPostProcessorContext, Plugin } from \"obsidian\";\n\nimport type { AutoTimelineSettings, CompleteCardContext } from \"~/types\";\nimport { compareAbstractDates, isDefined, measureTime } from \"~/utils\";\nimport { getDataFromNoteMetadata, getDataFromNoteBody } from \"~/cardData\";\nimport { setupTimelineCreation } from \"~/timelineMarkup\";\nimport { createCardFromBuiltContext } from \"~/cardMarkup\";\nimport { getAllRangeData } from \"~/rangeData\";\nimport { renderRanges } from \"~/rangeMarkup\";\nimport { SETTINGS_DEFAULT, TimelineSettingTab } from \"~/settings\";", "import { renderRanges } from \"~/rangeMarkup\";\nimport { SETTINGS_DEFAULT, TimelineSettingTab } from \"~/settings\";\nimport { parseMarkdownBlockSource } from \"./markdownBlockData\";\n\nexport default class AprilsAutomaticTimelinesPlugin extends Plugin {\n\tsettings: AutoTimelineSettings;\n\n\t/**\n\t * The default onload method of a obsidian plugin\n\t * See the official documentation for more details\n\t */\n\tasync onload() {\n\t\tawait this.loadSettings();\n\n\t\tthis.registerMarkdownCodeBlockProcessor(\n\t\t\t\"aat-vertical\",\n\t\t\t(source, element, context) => {\n\t\t\t\tthis.run(source, element, context);\n\t\t\t}\n\t\t);\n\t}\n\n\tonunload() {}\n\n\t/**", "\t * Main runtime function to process a single timeline.\n\t *\n\t * @param source - The content found in the markdown block.\n\t * @param element - The root element of all the timeline.\n\t * @param param2 - The context provided by obsidians `registerMarkdownCodeBlockProcessor()` method.\n\t * @param param2.sourcePath - A string representing the fs path of a note.\n\t */\n\tasync run(\n\t\tsource: string,\n\t\telement: HTMLElement,\n\t\t{ sourcePath }: MarkdownPostProcessorContext\n\t) {\n\t\tconst runtimeTime = measureTime(\"Run time\");\n\t\tconst { app } = this;\n\t\tconst { tagsToFind, settingsOverride } =\n\t\t\tparseMarkdownBlockSource(source);\n\t\tconst finalSettings = { ...this.settings, ...settingsOverride };\n\t\tconst creationContext = setupTimelineCreation(\n\t\t\tapp,\n\t\t\telement,\n\t\t\tsourcePath,\n\t\t\tfinalSettings\n\t\t);\n\t\tconst cardDataTime = measureTime(\"Data fetch\");\n\t\tconst events: CompleteCardContext[] = [];\n", "\t\tfor (const context of creationContext) {\n\t\t\tconst baseData = await getDataFromNoteMetadata(context, tagsToFind);\n\n\t\t\tif (isDefined(baseData)) events.push(baseData);\n\t\t\tif (!finalSettings.lookForInlineEventsInNotes) continue;\n\t\t\tconst body =\n\t\t\t\tbaseData?.cardData.body ||\n\t\t\t\t(await context.file.vault.cachedRead(context.file));\n\t\t\tconst inlineEvents = (\n\t\t\t\tawait getDataFromNoteBody(body, context, tagsToFind)\n\t\t\t).filter(isDefined);\n", "\t\t\tif (!inlineEvents.length) continue;\n\t\t\tevents.push(...inlineEvents);\n\t\t}\n\t\tevents.sort(\n\t\t\t(\n\t\t\t\t{ cardData: { startDate: a, endDate: aE } },\n\t\t\t\t{ cardData: { startDate: b, endDate: bE } }\n\t\t\t) => {\n\t\t\t\tconst score = compareAbstractDates(a, b);\n\n\t\t\t\tif (score) return score;\n\t\t\t\treturn compareAbstractDates(aE, bE);\n\t\t\t}\n\t\t);\n\t\tcardDataTime();\n\n\t\tconst cardRenderTime = measureTime(\"Card Render\");\n\t\tevents.forEach(({ context, cardData }) =>\n\t\t\tcreateCardFromBuiltContext(context, cardData)\n\t\t);\n\t\tcardRenderTime();\n\n\t\tconst rangeDataFecthTime = measureTime(\"Range Data\");\n\t\tconst ranges = getAllRangeData(events);\n\t\trangeDataFecthTime();\n\n\t\tconst rangeRenderTime = measureTime(\"Range Render\");\n\t\trenderRanges(ranges, element);\n\t\trangeRenderTime();\n\n\t\truntimeTime();\n\t}\n\n\t/**\n\t * Loads the saved settings from the local device and sets up the setting tabs in the plugin options.\n\t */\n\tasync loadSettings() {\n\t\tthis.settings = Object.assign(\n\t\t\t{},\n\t\t\tSETTINGS_DEFAULT,\n\t\t\tawait this.loadData()\n\t\t);\n", "\t\t\t\tif (score) return score;\n\t\t\t\treturn compareAbstractDates(aE, bE);\n\t\t\t}\n\t\t);\n\t\tcardDataTime();\n\n\t\tconst cardRenderTime = measureTime(\"Card Render\");\n\t\tevents.forEach(({ context, cardData }) =>\n\t\t\tcreateCardFromBuiltContext(context, cardData)\n\t\t);\n\t\tcardRenderTime();\n\n\t\tconst rangeDataFecthTime = measureTime(\"Range Data\");\n\t\tconst ranges = getAllRangeData(events);\n\t\trangeDataFecthTime();\n\n\t\tconst rangeRenderTime = measureTime(\"Range Render\");\n\t\trenderRanges(ranges, element);\n\t\trangeRenderTime();\n\n\t\truntimeTime();\n\t}\n\n\t/**\n\t * Loads the saved settings from the local device and sets up the setting tabs in the plugin options.\n\t */\n\tasync loadSettings() {\n\t\tthis.settings = Object.assign(\n\t\t\t{},\n\t\t\tSETTINGS_DEFAULT,\n\t\t\tawait this.loadData()\n\t\t);\n", "\t\tfor (\n\t\t\tlet index = 0;\n\t\t\tindex < this.settings.dateTokenConfiguration.length;\n\t\t\tindex++\n\t\t) {\n\t\t\tthis.settings.dateTokenConfiguration[index].formatting =\n\t\t\t\tthis.settings.dateTokenConfiguration[index].formatting || [];\n\t\t}\n\t\tthis.addSettingTab(new TimelineSettingTab(this.app, this));\n\t}\n\n\t/**\n\t * Saves the settings in obsidian.\n\t */\n\tasync saveSettings() {\n\t\tawait this.saveData(this.settings);\n\t}\n}\n"]}
{"filename": "src/markdownBlockData.ts", "chunked_list": ["import { SETTINGS_DEFAULT } from \"~/settings\";\nimport { AutoTimelineSettings } from \"./types\";\nimport { isDefined, isDefinedAsBoolean, isDefinedAsString } from \"./utils\";\n\n/**\n * Fetches the tags to find and timeline specific settings override.\n *\n * @param source - The markdown code block source, a.k.a. the content inside the code block.\n * @returns Partial settings to override the global ones.\n */\nexport function parseMarkdownBlockSource(source: string): {\n\treadonly tagsToFind: string[];\n\treadonly settingsOverride: Partial<AutoTimelineSettings>;\n} {\n\tconst sourceEntries = source.split(\"\\n\");\n", " * @returns Partial settings to override the global ones.\n */\nexport function parseMarkdownBlockSource(source: string): {\n\treadonly tagsToFind: string[];\n\treadonly settingsOverride: Partial<AutoTimelineSettings>;\n} {\n\tconst sourceEntries = source.split(\"\\n\");\n\n\tif (!source.length)\n\t\treturn { tagsToFind: [] as string[], settingsOverride: {} } as const;\n\tconst tagsToFind = sourceEntries[0]\n\t\t.split(SETTINGS_DEFAULT.markdownBlockTagsToFindSeparator)\n\t\t.map((e) => e.trim());\n\n\tsourceEntries.shift();\n\treturn {\n\t\ttagsToFind,\n\t\tsettingsOverride: sourceEntries.reduce((accumulator, element) => {\n\t\t\treturn {\n\t\t\t\t...accumulator,\n\t\t\t\t...parseSingleLine(element),\n\t\t\t};\n\t\t}, {} as Partial<AutoTimelineSettings>),\n\t} as const;\n}\n", "\tif (!source.length)\n\t\treturn { tagsToFind: [] as string[], settingsOverride: {} } as const;\n\tconst tagsToFind = sourceEntries[0]\n\t\t.split(SETTINGS_DEFAULT.markdownBlockTagsToFindSeparator)\n\t\t.map((e) => e.trim());\n\n\tsourceEntries.shift();\n\treturn {\n\t\ttagsToFind,\n\t\tsettingsOverride: sourceEntries.reduce((accumulator, element) => {\n\t\t\treturn {\n\t\t\t\t...accumulator,\n\t\t\t\t...parseSingleLine(element),\n\t\t\t};\n\t\t}, {} as Partial<AutoTimelineSettings>),\n\t} as const;\n}\n", "type OverridableSettingKey = (typeof acceptedSettingsOverride)[number];\nconst acceptedSettingsOverride = [\n\t\"dateDisplayFormat\",\n\t\"applyAdditonalConditionFormatting\",\n] as const;\n\n/**\n * Checks if a given string is part of the settings keys that can be overriden.\n *\n * @param value - A given settings key.\n * @returns the typeguard boolean `true` if the key is indeed overridable.\n */", "function isOverridableSettingsKey(\n\tvalue: string\n): value is OverridableSettingKey {\n\t// @ts-expect-error\n\treturn acceptedSettingsOverride.includes(value);\n}\n\n/**\n * Will apply the needed formatting to a setting value based of it's key.\n *\n * @param key - The settings key.\n * @param value - The value associated to this value.\n * @returns Undefined if unvalid or the actual expected value.\n */", "function formatValueFromKey(\n\tkey: string,\n\tvalue: string\n): AutoTimelineSettings[OverridableSettingKey] | undefined {\n\tif (!isOverridableSettingsKey(key)) return undefined;\n\tif (isDefinedAsString(SETTINGS_DEFAULT[key])) return value;\n\tif (isDefinedAsBoolean(SETTINGS_DEFAULT[key])) {\n\t\tconst validBooleanStrings = [\"true\", \"false\"];\n\n\t\tif (!validBooleanStrings.includes(value.toLocaleLowerCase()))\n\t\t\tthrow new Error(`${value} is supposed to be a boolean`);\n\t\treturn value.toLocaleLowerCase() === \"true\" ? true : false;\n\t}\n\treturn undefined;\n}\n\n/**\n * Parse a single line of the timeline markdown block content.\n *\n * @param line - The line to parse.\n * @returns A potencialy partial settings object.\n */", "\t\tif (!validBooleanStrings.includes(value.toLocaleLowerCase()))\n\t\t\tthrow new Error(`${value} is supposed to be a boolean`);\n\t\treturn value.toLocaleLowerCase() === \"true\" ? true : false;\n\t}\n\treturn undefined;\n}\n\n/**\n * Parse a single line of the timeline markdown block content.\n *\n * @param line - The line to parse.\n * @returns A potencialy partial settings object.\n */", "function parseSingleLine(line: string): Partial<AutoTimelineSettings> {\n\tconst reg = /((?<key>(\\s|\\d|[a-z])*):(?<value>.*))/i;\n\tconst matches = line.match(reg);\n\n\tif (\n\t\t!matches ||\n\t\t!matches.groups ||\n\t\t!isDefinedAsString(matches.groups.key) ||\n\t\t!isDefined(matches.groups.value)\n\t)\n\t\treturn {};\n\n\tconst key = matches.groups.key.trim();\n\tconst value = formatValueFromKey(key, matches.groups.value.trim());\n", "\tif (!isDefined(value)) return {};\n\treturn { [key]: value };\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { SETTINGS_DEFAULT } from \"~/settings\";\nimport { FnGetRangeData } from \"./rangeData\";\nimport { FnExtractCardData, getDataFromNoteMetadata } from \"~/cardData\";\n\nimport type { App, CachedMetadata, TFile } from \"obsidian\";\nimport type { Merge } from \"ts-essentials\";\n\n/**\n * @author https://stackoverflow.com/a/69756175\n */\nexport type PickByType<T, Value> = {\n\t[P in keyof T as T[P] extends Value | undefined ? P : never]: T[P];\n};\n", " * @author https://stackoverflow.com/a/69756175\n */\nexport type PickByType<T, Value> = {\n\t[P in keyof T as T[P] extends Value | undefined ? P : never]: T[P];\n};\n\nexport type AutoTimelineSettings = typeof SETTINGS_DEFAULT;\n/**\n * The main bundle of data needed to build a timeline.\n */\nexport interface MarkdownCodeBlockTimelineProcessingContext {\n\t/**\n\t * Obsidian application context.\n\t */\n\tapp: App;\n\t/**\n\t * The plugins settings\n\t */\n\tsettings: AutoTimelineSettings;\n\t/**\n\t * The formatted metadata of a single note.\n\t */\n\tcachedMetadata: CachedMetadata;\n\t/**\n\t * The file data of a single note.\n\t */\n\tfile: TFile;\n\t/**\n\t * The filepath of a single timeline.\n\t */\n\ttimelineFile: string;\n\t/**\n\t * Shorthand access to HTMLElements for the range timelines and the card list.\n\t */\n\telements: {\n\t\ttimelineRootElement: HTMLElement;\n\t\tcardListRootElement: HTMLElement;\n\t};\n}\n\n/**\n * The context extracted from a single note to create a single card in the timeline combined with the more general purpise timeline context.\n */", "export interface MarkdownCodeBlockTimelineProcessingContext {\n\t/**\n\t * Obsidian application context.\n\t */\n\tapp: App;\n\t/**\n\t * The plugins settings\n\t */\n\tsettings: AutoTimelineSettings;\n\t/**\n\t * The formatted metadata of a single note.\n\t */\n\tcachedMetadata: CachedMetadata;\n\t/**\n\t * The file data of a single note.\n\t */\n\tfile: TFile;\n\t/**\n\t * The filepath of a single timeline.\n\t */\n\ttimelineFile: string;\n\t/**\n\t * Shorthand access to HTMLElements for the range timelines and the card list.\n\t */\n\telements: {\n\t\ttimelineRootElement: HTMLElement;\n\t\tcardListRootElement: HTMLElement;\n\t};\n}\n\n/**\n * The context extracted from a single note to create a single card in the timeline combined with the more general purpise timeline context.\n */", "export type CompleteCardContext = Exclude<\n\tAwaited<ReturnType<typeof getDataFromNoteMetadata>>,\n\tundefined\n>;\n/**\n * The context extracted from a single note to create a single card in the timeline.\n */\nexport type CardContent = Awaited<ReturnType<FnExtractCardData>>;\n/**\n * The needed data to compute a range in a single timeline.\n */", "export type Range = ReturnType<FnGetRangeData>[number];\n\n/**\n * An abstract representation of a fantasy date.\n * Given the fickle nature of story telling and how people will literally almost never stick to standard date formats\n * We'll organise the dates in segments, let's take for example our human callendar\n * The date will commonly be segmented in 3 parts year, month and day the abstract representation will equate to\n * `[year, month, day]`\n * Now if someone wants to make a more complex date system like `[cycle, moon, phase, day]` we can treat them the same when sorting and performing computing tasks on those dates.\n * The only major limitation to this system is that all the dates must respect the same system.\n */", "export type AbstractDate = number[];\n\n/**\n * Before formatting an abstract date, the end user can configure it's output display\n * This DateToken type helps to determine what's the nature of a given token\n * E.g. should it be displayed as a number or as a string ?\n */\nexport enum DateTokenType {\n\tnumber = \"NUMBER\",\n\tstring = \"STRING\",\n}\nexport const availableDateTokenTypeArray = Object.values(DateTokenType);\n", "export enum Condition {\n\tGreater = \"GREATER\",\n\tLess = \"LESS\",\n\tEqual = \"EQUAL\",\n\tNotEqual = \"NOTEQUAL\",\n\tGreaterOrEqual = \"GREATEROREQUAL\",\n\tLessOrEqual = \"LESSOREQUAL\",\n}\nexport const availableConditionArray = Object.values(Condition);\n\nexport type Evaluation<T extends number = number> = {\n\tcondition: Condition;\n\tvalue: T;\n};", "export type Evaluation<T extends number = number> = {\n\tcondition: Condition;\n\tvalue: T;\n};\nexport type AdditionalDateFormatting<T extends number = number> = {\n\tevaluations: Evaluation<T>[];\n\t/**\n\t * Basically: if `true` the conditions all need to be `true` to return `true`. Else it only need one of the conditions to be checked.\n\t */\n\tconditionsAreExclusive: boolean;\n\t/**\n\t * Use `{value}` to include the pre-formated output of the numerical value held.\n\t */\n\tformat: string;\n};\n\n/**\n * The data used to compute the output of an abstract date based on it's type\n */", "type CommonValues<T extends DateTokenType> = {\n\tname: string;\n\ttype: T;\n\tformatting: AdditionalDateFormatting[];\n};\nexport type DateTokenConfiguration<T extends DateTokenType = DateTokenType> =\n\tT extends DateTokenType.number\n\t\t? NumberSpecific\n\t\t: T extends DateTokenType.string\n\t\t? StringSpecific\n\t\t: StringSpecific | NumberSpecific;\n\n/**\n * Number typed date token.\n */", "type NumberSpecific = Merge<\n\tCommonValues<DateTokenType.number>,\n\t{\n\t\t/**\n\t\t * The minimum ammount of digits when displaying the date\n\t\t */\n\t\tminLeght: number;\n\t\tdisplayWhenZero: boolean;\n\t\thideSign: boolean;\n\t}\n>;\n\n/**\n * String typed date token.\n */", "type StringSpecific = Merge<\n\tCommonValues<DateTokenType.string>,\n\t{\n\t\t/**\n\t\t * The dictionary reference for the token\n\t\t */\n\t\tdictionary: string[];\n\t}\n>;\n"]}
{"filename": "src/rangeMarkup.ts", "chunked_list": ["import {\n\tcreateElementShort,\n\tisDefined,\n\tgetChildAtIndexInHTMLElement,\n\tcompareAbstractDates,\n} from \"~/utils\";\n\nimport type { Range } from \"~/types\";\n\n/**", "\n/**\n * The color palette that obsidian defined in it's css bundle.\n * Useful for applying colors to elements programatically.\n */\nconst AVAILABLE_COLORS = [\n\t\"red\",\n\t\"orange\",\n\t\"yellow\",\n\t\"green\",", "\t\"yellow\",\n\t\"green\",\n\t\"cyan\",\n\t\"blue\",\n\t\"purple\",\n\t\"pink\",\n] as const;\n\n/**\n * Renders the little stripes in the gutter of the timeline.", "/**\n * Renders the little stripes in the gutter of the timeline.\n *\n * @param ranges - A collection of ranges.\n * @param rootElement - The root of all elements for this complete timeline.\n */\nexport function renderRanges(ranges: Range[], rootElement: HTMLElement) {\n\tconst endDates: (number[] | true | undefined)[] = AVAILABLE_COLORS.map(\n\t\t() => undefined\n\t);\n\n\tranges.forEach((range) => {\n\t\tconst {\n\t\t\trelatedCardData: {\n\t\t\t\tcardData: { startDate, endDate },\n\t\t\t},\n\t\t} = range;\n\n\t\tconst offsetIndex = endDates.findIndex(\n\t\t\t(date) =>\n\t\t\t\t!isDefined(date) ||\n\t\t\t\t(date !== true && compareAbstractDates(startDate, date) > 0)\n\t\t);\n\n\t\t// Over the color limit", "\t\tif (offsetIndex === -1) return;\n\n\t\trenderSingleRange(range, offsetIndex, rootElement);\n\t\tendDates[offsetIndex] = endDate;\n\t});\n}\n\n/**\n * Renders a single range element based off the offset computed previously.\n *\n * @param param0 - A single range.\n * @param param0.index - The index of the card.\n * @param param0.targetPosition - The target position of a given range. This determines where the rage should end.\n * @param param0.cardRelativeTopPosition - The ammount of pixel from the top of the timeline relative to a given card.\n * @param param0.relatedCardData - The associated card data.\n * @param param0.relatedCardData.context - The associated runtime context for this card.\n * @param param0.relatedCardData.context.elements - The HTMLElements exposed for this context.\n * @param param0.relatedCardData.context.elements.cardListRootElement - The right side of the timeline, this is where the carads are spawned.\n * @param param0.relatedCardData.context.elements.timelineRootElement - The base layer for the timeline.\n * @param offset - The left offet index for this range.\n * @param rootElelement - The root HTMLElement of the timeline elements.\n *\n * @returns Nothing, but it renders a single range inside it's target element.\n */", "export function renderSingleRange(\n\t{\n\t\trelatedCardData: {\n\t\t\tcontext: {\n\t\t\t\telements: { timelineRootElement, cardListRootElement },\n\t\t\t},\n\t\t},\n\t\ttargetPosition,\n\t\tcardRelativeTopPosition,\n\t\tindex,\n\t}: Range,\n\toffset: number,\n\trootElelement: HTMLElement\n) {\n\tconst el = createElementShort(\n\t\ttimelineRootElement,\n\t\t\"div\",\n\t\t\"aat-range-element\"\n\t);\n\n\tel.style.height = `${targetPosition - cardRelativeTopPosition}px`;\n\tel.style.top = `${cardRelativeTopPosition}px`;\n\tel.style.left = `${offset * 12}px`;\n\tel.style.backgroundColor = `var(--color-${AVAILABLE_COLORS[offset]})`;\n\n\t// Setup highlight link\n\tconst relativeCardClassName = \"aat-highlight-relative-card-to-range\";\n\n\tel.onmouseenter = () => {\n\t\tconst relativeCard = getChildAtIndexInHTMLElement(\n\t\t\tcardListRootElement,\n\t\t\tindex\n\t\t);\n\n\t\trelativeCard.classList.add(relativeCardClassName);\n\t};\n\n\tel.onmouseleave = () => {\n\t\tconst relativeCard = getChildAtIndexInHTMLElement(\n\t\t\tcardListRootElement,\n\t\t\tindex\n\t\t);\n\n\t\trelativeCard.classList.remove(relativeCardClassName);\n\t};\n\n\t// Setup click event\n\tel.onclick = () => {\n\t\tconst el = window.document.querySelector(\n\t\t\t\".markdown-reading-view > .markdown-preview-view\"\n\t\t);\n", "\t\tif (!el) return;\n\n\t\tel.scrollTo({\n\t\t\ttop: cardRelativeTopPosition + rootElelement.offsetTop - 8,\n\t\t\tbehavior: \"smooth\",\n\t\t});\n\t};\n\n\treturn el;\n}\n"]}
{"filename": "src/i18n.config.ts", "chunked_list": ["import { createI18n } from \"vue-i18n\";\nimport en from \"~/locales/en.json\";\n\nexport default () =>\n\tcreateI18n({\n\t\tlocale: \"en\",\n\t\tfallbackLocale: \"en\",\n\t\tmessages: {\n\t\t\ten,\n\t\t},", "\t\t\ten,\n\t\t},\n\t\tallowComposition: true,\n\t});\n"]}
{"filename": "src/cardMarkup.ts", "chunked_list": ["import { MarkdownRenderChild, MarkdownRenderer } from \"obsidian\";\nimport { isDefined, createElementShort } from \"~/utils\";\n\nimport type {\n\tMarkdownCodeBlockTimelineProcessingContext,\n\tCardContent,\n\tAutoTimelineSettings,\n} from \"~/types\";\nimport { formatAbstractDate } from \"./abstractDateFormatting\";\n", "import { formatAbstractDate } from \"./abstractDateFormatting\";\n\n/**\n * Generates a card in the DOM based on given ccontext.\n *\n * @param param0 - The context built for this timeline.\n * @param param0.elements - The HTMLElements exposed for this context.\n * @param param0.elements.cardListRootElement - The right side of the timeline, this is where the carads are spawned.\n * @param param0.file - The target note file.\n * @param param0.settings - The plugin's settings.", " * @param param0.file - The target note file.\n * @param param0.settings - The plugin's settings.\n * @param cardContent - The content of a single timeline card.\n */\nexport function createCardFromBuiltContext(\n\t{\n\t\telements: { cardListRootElement },\n\t\tfile,\n\t\tsettings,\n\t}: MarkdownCodeBlockTimelineProcessingContext,\n\tcardContent: CardContent\n): void {\n\tconst { body, title, imageURL } = cardContent;\n\tconst cardBaseDiv = createElementShort(cardListRootElement, \"a\", [\n\t\t\"internal-link\",\n\t\t\"aat-card\",\n\t]);\n\tcardBaseDiv.setAttribute(\"href\", file.path);\n", "\tif (imageURL) {\n\t\tcreateElementShort(cardBaseDiv, \"img\", \"aat-card-image\").setAttribute(\n\t\t\t\"src\",\n\t\t\timageURL\n\t\t);\n\t\tcardBaseDiv.addClass(\"aat-card-has-image\");\n\t}\n\n\tconst cardTextWraper = createElementShort(\n\t\tcardBaseDiv,\n\t\t\"div\",\n\t\t\"aat-card-text-wraper\"\n\t);\n\n\tconst titleWrap = createElementShort(\n\t\tcardTextWraper,\n\t\t\"header\",\n\t\t\"aat-card-head-wrap\"\n\t);\n\n\tcreateElementShort(titleWrap, \"h2\", \"aat-card-title\", title);\n\n\tcreateElementShort(\n\t\ttitleWrap,\n\t\t\"h4\",\n\t\t\"aat-card-start-date\",\n\t\tgetDateText(cardContent, settings).trim()\n\t);\n\n\tconst markdownTextWrapper = createElementShort(\n\t\tcardTextWraper,\n\t\t\"div\",\n\t\t\"aat-card-body\"\n\t);\n\tconst rendered = new MarkdownRenderChild(markdownTextWrapper);\n\n\trendered.containerEl = markdownTextWrapper;\n\tMarkdownRenderer.renderMarkdown(\n\t\tformatBodyForCard(body),\n\t\tmarkdownTextWrapper,\n\t\tfile.path,\n\t\trendered\n\t);\n}\n\n/**\n * Format the body string of the note data for a single card.\n *\n * @param body - The body string parsed earlier.\n * @returns The formated string ready to be displayed.\n */", "export function formatBodyForCard(body?: string | null): string {\n\tif (!body) return \"No body for this note :(\";\n\n\t// Remove external image links\n\treturn (\n\t\tbody\n\t\t\t.replace(/!\\[.*\\]\\(.*\\)/gi, \"\")\n\t\t\t// Remove tags\n\t\t\t.replace(/#[a-zA-Z\\d-_]*/gi, \"\")\n\t\t\t// Remove internal images ![[Pasted image 20230418232101.png]]\n\t\t\t.replace(/!\\[\\[.*\\]\\]/gi, \"\")\n\t\t\t// Remove other timelines to avoid circular dependencies!\n\t\t\t.replace(/```aat-vertical\\n.*\\n```/gi, \"\")\n\t\t\t// Trim the text\n\t\t\t.trim()\n\t);\n}\n\n/**\n * Get the text displayed in the card where the date should be.\n *\n * @param param0 - The context for a single card.\n * @param param0.startDate - the start date of an event.\n * @param param0.endDate - the end date of an event.\n * @param settings - The settings of the plugin.\n * @returns a formated string representation of the dates included in the card content based off the settings.\n */", "export function getDateText(\n\t{ startDate, endDate }: Pick<CardContent, \"startDate\" | \"endDate\">,\n\tsettings: AutoTimelineSettings\n): string {\n\tif (!isDefined(startDate)) return \"Start date missing\";\n\tconst formatedStart = formatAbstractDate(startDate, settings);\n\tif (!isDefined(endDate)) return formatedStart;\n\n\treturn `From ${formatedStart} to ${formatAbstractDate(endDate, settings)}`;\n}\n"]}
{"filename": "src/timelineMarkup.ts", "chunked_list": ["import type { App } from \"obsidian\";\nimport type {\n\tAutoTimelineSettings,\n\tMarkdownCodeBlockTimelineProcessingContext,\n} from \"~/types\";\n\n/**\n * A preliminary helper to fetch all the needed context to handle the timeline creation.\n *\n * @param app - The app context provided by obsidian.", " *\n * @param app - The app context provided by obsidian.\n * @param element - The root element of this timeline.\n * @param timelineFile - The file path of the timeline.\n * @param settings - The plugin's settings.\n * @returns the nessessary context to build a timeline.\n */\nexport function setupTimelineCreation(\n\tapp: App,\n\telement: HTMLElement,\n\ttimelineFile: string,\n\tsettings: AutoTimelineSettings\n) {\n\tconst { vault, metadataCache } = app;\n\tconst fileArray = vault.getMarkdownFiles();\n\tconst root = element.createDiv();\n\tconst cardListRootElement = root.createDiv();\n\tconst timelineRootElement = root.createDiv();\n\n\telement.classList.add(\"aat-root-container\");\n\troot.classList.add(\"aat-vertical-timeline\");\n\tcardListRootElement.classList.add(\"aat-card-list-root\");\n\ttimelineRootElement.classList.add(\"aat-timeline-root\");\n\tconst dataBundleArray = fileArray.reduce((accumulator, file) => {\n\t\tconst cachedMetadata = metadataCache.getFileCache(file);\n", "\t\tif (cachedMetadata)\n\t\t\taccumulator.push({\n\t\t\t\tapp,\n\t\t\t\tsettings,\n\t\t\t\ttimelineFile,\n\t\t\t\tfile,\n\t\t\t\tcachedMetadata,\n\t\t\t\telements: {\n\t\t\t\t\ttimelineRootElement,\n\t\t\t\t\tcardListRootElement,\n\t\t\t\t},\n\t\t\t});\n\t\treturn accumulator;\n\t}, [] as MarkdownCodeBlockTimelineProcessingContext[]);\n\n\treturn dataBundleArray;\n}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import {\n\tAbstractDate,\n\tDateTokenConfiguration,\n\tMarkdownCodeBlockTimelineProcessingContext,\n\tDateTokenType,\n\tCondition,\n} from \"~/types\";\n\n/**\n * Quick util to read obsidians metadata object with some type safety.\n *\n * @param cachedMetadata - cachedMetadata - Obsidians cachedMetadata object.\n * @param key - the sought after key in the obsidian metadata object.", "/**\n * Quick util to read obsidians metadata object with some type safety.\n *\n * @param cachedMetadata - cachedMetadata - Obsidians cachedMetadata object.\n * @param key - the sought after key in the obsidian metadata object.\n * @param type - The expected type of the key value.\n * @returns The metadata value assigned to the given key or null if unvalidated or missing.\n */\nexport function getMetadataKey<T extends \"string\" | \"number\" | \"boolean\">(\n\tcachedMetadata: MarkdownCodeBlockTimelineProcessingContext[\"cachedMetadata\"],\n\tkey: string,\n\ttype: T\n):\n\t| (T extends \"string\" ? string : T extends \"number\" ? number : boolean)\n\t| undefined {\n\t// Bail if no formatter object or if the key is missing", "export function getMetadataKey<T extends \"string\" | \"number\" | \"boolean\">(\n\tcachedMetadata: MarkdownCodeBlockTimelineProcessingContext[\"cachedMetadata\"],\n\tkey: string,\n\ttype: T\n):\n\t| (T extends \"string\" ? string : T extends \"number\" ? number : boolean)\n\t| undefined {\n\t// Bail if no formatter object or if the key is missing\n\tif (!cachedMetadata.frontmatter) return undefined;\n\n\treturn typeof cachedMetadata.frontmatter[key] === type\n\t\t? cachedMetadata.frontmatter[key]\n\t\t: undefined;\n}\n\n/**\n * Typeguard to check if a value is indeed defined.\n *\n * @param argument a possibly undefined argument.\n * @returns `true` if the element is defined, `false` if not.\n */\nexport const isDefined = <T>(argument: T | undefined): argument is T =>\n\targument !== undefined;\n\n/**\n * Check if a runtime value is defined and is a string.\n *\n * @param argument a possibly undefined argument.\n * @returns `true` if the element is indeed a string, `false` if not.\n */\nexport const isDefinedAsString = (argument: unknown): argument is string =>\n\ttypeof argument === \"string\";\n\n/**\n * Check if a runtime value is defined and is a boolean\n *\n * @param argument a possibly undefined argument.\n * @returns `true` if the element is indeed a boolean, `false` if not.\n */\nexport const isDefinedAsBoolean = (argument: unknown): argument is boolean =>\n\ttypeof argument === \"boolean\";\n\n/**\n * Same as `Array.findIndex()` but going from right to left.\n *\n * @param arr - An array of values", "\tif (!cachedMetadata.frontmatter) return undefined;\n\n\treturn typeof cachedMetadata.frontmatter[key] === type\n\t\t? cachedMetadata.frontmatter[key]\n\t\t: undefined;\n}\n\n/**\n * Typeguard to check if a value is indeed defined.\n *\n * @param argument a possibly undefined argument.\n * @returns `true` if the element is defined, `false` if not.\n */\nexport const isDefined = <T>(argument: T | undefined): argument is T =>\n\targument !== undefined;\n\n/**\n * Check if a runtime value is defined and is a string.\n *\n * @param argument a possibly undefined argument.\n * @returns `true` if the element is indeed a string, `false` if not.\n */\nexport const isDefinedAsString = (argument: unknown): argument is string =>\n\ttypeof argument === \"string\";\n\n/**\n * Check if a runtime value is defined and is a boolean\n *\n * @param argument a possibly undefined argument.\n * @returns `true` if the element is indeed a boolean, `false` if not.\n */\nexport const isDefinedAsBoolean = (argument: unknown): argument is boolean =>\n\ttypeof argument === \"boolean\";\n\n/**\n * Same as `Array.findIndex()` but going from right to left.\n *\n * @param arr - An array of values", " * @param predicate - An evaluation function that works like the one you feed `.findIndex()`\n * @returns `-1` if no index was found, or the last occurence of the predicament.\n */\nexport function findLastIndex<T extends unknown[]>(\n\tarr: T,\n\tpredicate: (arg: T[number]) => boolean\n): number {\n\tconst length = arr ? arr.length : 0;\n\tif (!length) return -1;\n\tlet index = length - 1;\n", "\tif (!length) return -1;\n\tlet index = length - 1;\n\n\twhile (index--) if (predicate(arr[index])) return index;\n\treturn -1;\n}\n\n/**\n * https://en.wikipedia.org/wiki/Linear_interpolation\n *\n * @description A naive implementation of the linear interpolation function.\n * @param a - First point.\n * @param b - Last point.\n * @param t - From 0f to 1f, represent the percent of advancement.\n * @returns the position between `a` and `b` @ `t`.\n */\nexport const lerp = (a: number, b: number, t: number) => a + t * (b - a);\n/**\n * https://en.wikipedia.org/wiki/Linear_interpolation\n *\n * @description The inverse of a lerp.\n * @param a - First point.\n * @param b - Last point.\n * @param v - The desired point to look for.\n * @returns The percent value of advancement for `v`\n */\nexport const inLerp = (a: number, b: number, v: number) => (v - a) / (b - a);\n\n/**\n * Quick util to measure performance.\n *\n * @param str - Label for the timer.\n * @returns the handler that will close the timer.\n */\nexport const measureTime = (str: string) => {\n\tconst value = `[April's automatic timelines] - ${str}`;\n\tconsole.time(value);\n\n\treturn () => {\n\t\tconsole.timeEnd(value);\n\t};\n};\n\n/**", " * Shorthand function to get childs of a given HTML Element.\n *\n * @param el - Target HTMLElement.\n * @param index - The desired child index.\n * @returns - The child at the desired index. If the element is missing the function will throw.\n */\nexport function getChildAtIndexInHTMLElement(\n\tel: HTMLElement,\n\tindex: number\n): HTMLElement {\n\tconst child = el.children.item(index) as HTMLElement | null;\n", "\tif (!child) throw new Error(`Missing child @ index ${index} for element`);\n\treturn child;\n}\n\n/**\n * Shorthand function to create an HTMLElement in a given HTMLElement.\n *\n * @param el - The root element.\n * @param element - The desired HTML tag.\n * @param classes - A single or a collection of tags.\n * @param content - The content to inject inside the created element.\n * @returns The created element.\n */", "export function createElementShort(\n\tel: HTMLElement,\n\telement: keyof HTMLElementTagNameMap,\n\tclasses?: string[] | string,\n\tcontent?: string | number\n) {\n\tconst out = el.createEl(element);\n\n\tif (classes instanceof Array) out.addClass(...classes);\n\telse if (classes) out.addClass(classes);\n\tif (content !== undefined) out.innerHTML = content.toString();\n\treturn out;\n}\n\n/**\n * Compares two Abstract Dates\n *\n * @param a - first Abstract Date\n * @param b - second Abstract Date\n * @returns 0 if they are equal 1 if a > b and -1 if a < b\n */", "\tif (classes instanceof Array) out.addClass(...classes);\n\telse if (classes) out.addClass(classes);\n\tif (content !== undefined) out.innerHTML = content.toString();\n\treturn out;\n}\n\n/**\n * Compares two Abstract Dates\n *\n * @param a - first Abstract Date\n * @param b - second Abstract Date\n * @returns 0 if they are equal 1 if a > b and -1 if a < b\n */", "export function compareAbstractDates(\n\ta: AbstractDate | undefined | true,\n\tb: AbstractDate | undefined | true\n) {\n\t// Since could be numbers we can't check with `!`\n\tif (!isDefined(a) && !isDefined(b)) return 0;\n\tif (!isDefined(a)) return -1;\n\tif (!isDefined(b)) return 1;\n\n\tif (a === true && b !== true) return 1;\n\tif (b === true && a !== true) return -1;", "\tif (a === true && b !== true) return 1;\n\tif (b === true && a !== true) return -1;\n\tif (a === true && b === true) return 0;\n\ta = a as AbstractDate;\n\tb = b as AbstractDate;\n\tfor (let index = 0; index < a.length; index++)\n\t\tif (a[index] !== b[index]) return a[index] > b[index] ? 1 : -1;\n\treturn 0;\n}\n\n/**\n * Typeguard to check if a value is an array of unknowed sub type.\n *\n * @param value unknowed value.\n * @returns `true` if the element is defined as an array, `false` if not.\n */", "export function isDefinedAsArray(value: unknown): value is unknown[] {\n\treturn isDefined(value) && value instanceof Array;\n}\n\n/**\n * Typeguard to check if a value is an object of unknowed key values.\n *\n * @param value unknowed value.\n * @returns `true` if the element is defined as an object, `false` if not.\n */\nexport function isDefinedAsObject(\n\tvalue: unknown\n): value is { [key: string]: unknown } {\n\treturn isDefined(value) && value instanceof Object;\n}\n\n/**\n * Shorthand to quickly get a well typed number date token configuration object.\n *\n * @param defaultValue - Override the values of the return object.\n * @returns DateTokenConfiguration<DateTokenType.number> - A well typed date token configuration object.\n */", "export function isDefinedAsObject(\n\tvalue: unknown\n): value is { [key: string]: unknown } {\n\treturn isDefined(value) && value instanceof Object;\n}\n\n/**\n * Shorthand to quickly get a well typed number date token configuration object.\n *\n * @param defaultValue - Override the values of the return object.\n * @returns DateTokenConfiguration<DateTokenType.number> - A well typed date token configuration object.\n */", "export function createNumberDateTokenConfiguration(\n\tdefaultValue: Partial<DateTokenConfiguration<DateTokenType.number>> = {}\n): DateTokenConfiguration<DateTokenType.number> {\n\treturn {\n\t\tminLeght: 2,\n\t\tname: \"\",\n\t\ttype: DateTokenType.number,\n\t\tdisplayWhenZero: true,\n\t\tformatting: [],\n\t\thideSign: false,\n\t\t...defaultValue,\n\t};\n}\n\n/**\n * Shorthand to quickly get a well typed string date token configuration object.\n *\n * @param defaultValue - Override the values of the return object.\n * @returns DateTokenConfiguration<DateTokenType.string> - A well typed date token configuration object.\n */", "export function createStringDateTokenConfiguration(\n\tdefaultValue: Partial<DateTokenConfiguration<DateTokenType.string>> = {}\n): DateTokenConfiguration<DateTokenType.string> {\n\treturn {\n\t\tname: \"\",\n\t\ttype: DateTokenType.string,\n\t\tdictionary: [\"\"],\n\t\tformatting: [],\n\t\t...defaultValue,\n\t};\n}\n\n/**", " * Narrow type down to specific subtype for DateTokenConfigurations.\n *\n * @param value - Date token configuration.\n * @returns typeguard.\n */\nexport function dateTokenConfigurationIsTypeString(\n\tvalue: DateTokenConfiguration\n): value is DateTokenConfiguration<DateTokenType.string> {\n\treturn value.type === DateTokenType.string;\n}\n\n/**", " * Narrow type down to specific subtype for DateTokenConfigurations.\n *\n * @param value - Date token configuration.\n * @returns typeguard.\n */\nexport function dateTokenConfigurationIsTypeNumber(\n\tvalue: DateTokenConfiguration\n): value is DateTokenConfiguration<DateTokenType.number> {\n\treturn value.type === DateTokenType.number;\n}\n\n/**\n * Parse a string based off user date extract settings.\n *\n * @param groupsToCheck - The token names to check.\n * @param metadataString - The actual extracted data from the frontmatter.\n * @param reg - The user defined regex to apply.\n * @returns The parsed abstract date or nothing.\n */", "export function parseAbstractDate(\n\tgroupsToCheck: string[],\n\tmetadataString: string,\n\treg: RegExp | string\n): AbstractDate | undefined {\n\tconst matches = metadataString.match(reg);\n\n\tif (!matches || !matches.groups) return undefined;\n\n\tconst { groups } = matches;\n\n\tconst output = groupsToCheck.reduce((accumulator, groupName) => {\n\t\tconst value = Number(groups[groupName]);\n\n\t\t// In the case of a faulty regex given by the user in the settings", "\t\tif (!isNaN(value)) accumulator.push(value);\n\t\treturn accumulator;\n\t}, [] as AbstractDate);\n\n\t// Malformed payload bail out\n\tif (output.length !== groupsToCheck.length) return undefined;\n\n\treturn output;\n}\n\n/**\n * Used to quickly assert any programatic conditions configured by the users.\n *\n * @param condition - A specific condition.\n * @param a - Left hand value.\n * @param b - Right hand value.\n * @returns the evaluated boolean.\n */", "export function evalNumericalCondition(\n\tcondition: Condition,\n\ta: number,\n\tb: number\n): boolean {\n\tswitch (condition) {\n\t\tcase Condition.Equal:\n\t\t\treturn a === b;\n\t\tcase Condition.NotEqual:\n\t\t\treturn a !== b;\n\t\tcase Condition.Greater:\n\t\t\treturn a > b;\n\t\tcase Condition.GreaterOrEqual:\n\t\t\treturn a >= b;\n\t\tcase Condition.Less:\n\t\t\treturn a < b;\n\t\tcase Condition.LessOrEqual:\n\t\t\treturn a <= b;\n\t}\n}\n"]}
{"filename": "src/cardData.ts", "chunked_list": ["import { getMetadataKey, isDefined, isDefinedAsObject } from \"~/utils\";\n\nimport type {\n\tMarkdownCodeBlockTimelineProcessingContext,\n\tCompleteCardContext,\n} from \"~/types\";\nimport { parse } from \"yaml\";\nimport {\n\tgetAbstractDateFromMetadata,\n\tgetBodyFromContextOrDocument,", "\tgetAbstractDateFromMetadata,\n\tgetBodyFromContextOrDocument,\n\tgetImageUrlFromContextOrDocument,\n\tgetTagsFromMetadataOrTagObject,\n} from \"./cardDataExtraction\";\n\n/**\n * A un-changeable key used to check if a note is eligeable for render.\n */\nconst RENDER_GREENLIGHT_METADATA_KEY = [\"aat-render-enabled\"];", " */\nconst RENDER_GREENLIGHT_METADATA_KEY = [\"aat-render-enabled\"];\n\n/**\n * Provides additional context for the creation cards in the DOM.\n *\n * @param context - Timeline generic context.\n * @param tagsToFind - The tags to find in a note to match the current timeline.\n * @returns the context or underfined if it could not build it.\n */\nexport async function getDataFromNoteMetadata(\n\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\ttagsToFind: string[]\n) {\n\tconst { cachedMetadata, settings } = context;\n\tconst { frontmatter: metaData, tags } = cachedMetadata;\n", " * @returns the context or underfined if it could not build it.\n */\nexport async function getDataFromNoteMetadata(\n\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\ttagsToFind: string[]\n) {\n\tconst { cachedMetadata, settings } = context;\n\tconst { frontmatter: metaData, tags } = cachedMetadata;\n\n\tif (!metaData) return undefined;\n\tif (!RENDER_GREENLIGHT_METADATA_KEY.some((key) => metaData[key] === true))\n\t\treturn undefined;\n\n\tconst timelineTags = getTagsFromMetadataOrTagObject(\n\t\tsettings,\n\t\tmetaData,\n\t\ttags\n\t);\n", "\tif (!metaData) return undefined;\n\tif (!RENDER_GREENLIGHT_METADATA_KEY.some((key) => metaData[key] === true))\n\t\treturn undefined;\n\n\tconst timelineTags = getTagsFromMetadataOrTagObject(\n\t\tsettings,\n\t\tmetaData,\n\t\ttags\n\t);\n\n\tif (!extractedTagsAreValid(timelineTags, tagsToFind)) return undefined;\n\n\treturn {\n\t\tcardData: await extractCardData(context),\n\t\tcontext,\n\t} as const;\n}\n\n/**\n * Provides additional context for the creation cards in the DOM but reads it from the body\n *\n * @param body - The extracted body for a single event card.\n * @param context - Timeline generic context.\n * @param tagsToFind - The tags to find in a note to match the current timeline.\n * @returns the context or underfined if it could not build it.\n */", "\tif (!extractedTagsAreValid(timelineTags, tagsToFind)) return undefined;\n\n\treturn {\n\t\tcardData: await extractCardData(context),\n\t\tcontext,\n\t} as const;\n}\n\n/**\n * Provides additional context for the creation cards in the DOM but reads it from the body\n *\n * @param body - The extracted body for a single event card.\n * @param context - Timeline generic context.\n * @param tagsToFind - The tags to find in a note to match the current timeline.\n * @returns the context or underfined if it could not build it.\n */", "export async function getDataFromNoteBody(\n\tbody: string | undefined | null,\n\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\ttagsToFind: string[]\n): Promise<CompleteCardContext[]> {\n\tconst { settings } = context;\n\tif (!body) return [];\n\tconst inlineEventBlockRegExp = new RegExp(\n\t\t`%%${settings.noteInlineEventKey}\\n(((\\\\s|\\\\d|[a-z]|-)*):(.*)\\n)*%%`,\n\t\t\"gi\"\n\t);\n\tconst originalFrontmatter = context.cachedMetadata.frontmatter;\n\tconst matches = body.match(inlineEventBlockRegExp);\n", "\tif (!matches) return [];\n\n\tmatches.unshift();\n\tconst output: CompleteCardContext[] = [];\n\n\tfor (const block of matches) {\n\t\tconst sanitizedBlock = block.split(\"\\n\");\n\n\t\tsanitizedBlock.shift();\n\t\tsanitizedBlock.pop();\n\n\t\tconst fakeFrontmatter = parse(sanitizedBlock.join(\"\\n\")); // this actually works lmao\n\t\t// Replace frontmatter with newly built fake one. Just to re-use all the existing code.\n\t\tcontext.cachedMetadata.frontmatter = fakeFrontmatter;", "\t\tif (!isDefinedAsObject(fakeFrontmatter)) continue;\n\n\t\tconst timelineTags = getTagsFromMetadataOrTagObject(\n\t\t\tsettings,\n\t\t\tfakeFrontmatter,\n\t\t\tcontext.cachedMetadata.tags\n\t\t);\n\n\t\tif (!extractedTagsAreValid(timelineTags, tagsToFind)) continue;\n\n\t\tconst matchPositionInBody = body.indexOf(block);\n\t\toutput.push({\n\t\t\tcardData: await extractCardData(\n\t\t\t\tcontext,\n\t\t\t\tmatchPositionInBody !== -1\n\t\t\t\t\t? body.slice(matchPositionInBody + block.length)\n\t\t\t\t\t: undefined\n\t\t\t),\n\t\t\tcontext,\n\t\t});\n\t}\n\tcontext.cachedMetadata.frontmatter = originalFrontmatter;\n\treturn output;\n}\n\n/**\n * Checks if the extracted tags match at least one of the tags to find.\n *\n * @param timelineTags - The extracted tags from the note.\n * @param tagsToFind - The tags to find.\n * @returns `true` if valid.\n */", "\t\tif (!extractedTagsAreValid(timelineTags, tagsToFind)) continue;\n\n\t\tconst matchPositionInBody = body.indexOf(block);\n\t\toutput.push({\n\t\t\tcardData: await extractCardData(\n\t\t\t\tcontext,\n\t\t\t\tmatchPositionInBody !== -1\n\t\t\t\t\t? body.slice(matchPositionInBody + block.length)\n\t\t\t\t\t: undefined\n\t\t\t),\n\t\t\tcontext,\n\t\t});\n\t}\n\tcontext.cachedMetadata.frontmatter = originalFrontmatter;\n\treturn output;\n}\n\n/**\n * Checks if the extracted tags match at least one of the tags to find.\n *\n * @param timelineTags - The extracted tags from the note.\n * @param tagsToFind - The tags to find.\n * @returns `true` if valid.\n */", "function extractedTagsAreValid(\n\ttimelineTags: string[],\n\ttagsToFind: string[]\n): boolean {\n\treturn timelineTags.some((tag) => tagsToFind.includes(tag));\n}\n\n/**\n * Get the content of a card from a note. This function will parse the raw text content of a note and format it.\n *\n * @param context - Timeline generic context.\n * @param rawFileContent - If you already have it, will avoid reading the file again.\n * @returns The extracted data to create a card from a note.\n */", " * Get the content of a card from a note. This function will parse the raw text content of a note and format it.\n *\n * @param context - Timeline generic context.\n * @param rawFileContent - If you already have it, will avoid reading the file again.\n * @returns The extracted data to create a card from a note.\n */\nexport async function extractCardData(\n\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\trawFileContent?: string\n) {\n\tconst { file, cachedMetadata: c, settings } = context;\n\tconst fileTitle =\n\t\tc.frontmatter?.[settings.metadataKeyEventTitleOverride] ||\n\t\tfile.basename;\n\n\trawFileContent = rawFileContent || (await file.vault.cachedRead(file));\n\treturn {\n\t\ttitle: fileTitle as string,\n\t\tbody: getBodyFromContextOrDocument(rawFileContent, context),\n\t\timageURL: getImageUrlFromContextOrDocument(rawFileContent, context),\n\t\tstartDate: getAbstractDateFromMetadata(\n\t\t\tcontext,\n\t\t\tsettings.metadataKeyEventStartDate\n\t\t),\n\t\tendDate:\n\t\t\tgetAbstractDateFromMetadata(\n\t\t\t\tcontext,\n\t\t\t\tsettings.metadataKeyEventEndDate\n\t\t\t) ??\n\t\t\t(isDefined(\n\t\t\t\tgetMetadataKey(c, settings.metadataKeyEventEndDate, \"boolean\")\n\t\t\t)\n\t\t\t\t? true\n\t\t\t\t: undefined),\n\t} as const;\n}", "export type FnExtractCardData = typeof extractCardData;\n"]}
{"filename": "src/cardDataExtraction.ts", "chunked_list": ["import {\n\tisDefinedAsString,\n\tisDefined,\n\tisDefinedAsArray,\n\tgetMetadataKey,\n\tparseAbstractDate,\n} from \"~/utils\";\n\nimport { FrontMatterCache, TagCache, TFile } from \"obsidian\";\nimport type {", "import { FrontMatterCache, TagCache, TFile } from \"obsidian\";\nimport type {\n\tAutoTimelineSettings,\n\tAbstractDate,\n\tMarkdownCodeBlockTimelineProcessingContext,\n} from \"~/types\";\n\n/**\n * Returns a list of tags based off plugin settings, note frontmatter and note tags.\n *", " * Returns a list of tags based off plugin settings, note frontmatter and note tags.\n *\n * @param settings - The plugins settings.\n * @param metaData - The frontematter cache.\n * @param tags - Potencial tags.\n * @returns A list of tags to look for in a note.\n */\nexport function getTagsFromMetadataOrTagObject(\n\tsettings: AutoTimelineSettings,\n\tmetaData: Omit<FrontMatterCache, \"position\">,\n\ttags?: TagCache[]\n): string[] {\n\tlet output = [] as string[];\n\tconst timelineArray = metaData[settings.metadataKeyEventTimelineTag];\n", "\tif (isDefinedAsArray(timelineArray))\n\t\toutput = timelineArray.filter(isDefinedAsString);\n\t// Breakout earlier if we don't check the tags\n\tif (!settings.lookForTagsForTimeline) return output;\n\tif (isDefinedAsArray(tags))\n\t\toutput = output.concat(tags.map(({ tag }) => tag.substring(1)));\n\n\t// Tags in the frontmatter\n\tconst metadataInlineTags = metaData.tags;\n\tif (!isDefined(metadataInlineTags)) return output;\n\tif (isDefinedAsString(metadataInlineTags))\n\t\toutput = output.concat(\n\t\t\tmetadataInlineTags.split(\",\").map((e) => e.trim())\n\t\t);", "\tif (!isDefined(metadataInlineTags)) return output;\n\tif (isDefinedAsString(metadataInlineTags))\n\t\toutput = output.concat(\n\t\t\tmetadataInlineTags.split(\",\").map((e) => e.trim())\n\t\t);\n\tif (isDefinedAsArray(metadataInlineTags))\n\t\toutput = output.concat(metadataInlineTags.filter(isDefinedAsString));\n\t// .substring called to remove the initial `#` in the notes tags\n\treturn output;\n}\n\n/**\n * Extract the body from the raw text of a note.\n * After extraction most markdown tokens will be removed and links will be sanitized aswell and wrapped into bold tags for clearner display.\n *\n * @param rawFileText - The text content of a obsidian note.\n * @param context - Timeline generic context.\n * @returns the body of a given card or null if none was found.\n */", "export function getBodyFromContextOrDocument(\n\trawFileText: string,\n\tcontext: MarkdownCodeBlockTimelineProcessingContext\n): string | null {\n\tconst {\n\t\tcachedMetadata: { frontmatter: metadata },\n\t\tsettings: { metadataKeyEventBodyOverride },\n\t} = context;\n\tconst overrideBody = metadata?.[metadataKeyEventBodyOverride] ?? null;\n\n\tif (!rawFileText.length || overrideBody) return overrideBody;\n\n\tconst rawTextArray = rawFileText.split(\"\\n\");\n\trawTextArray.shift();\n\tconst processedArray = rawTextArray.slice(rawTextArray.indexOf(\"---\") + 1);\n\tconst finalString = processedArray.join(\"\\n\").trim();\n\n\treturn finalString;\n}\n\n/**\n * Extract the first image from the raw markdown in a note.\n *\n * @param rawFileText - The text content of a obsidian note.\n * @param context - Timeline generic context.\n * @returns the URL of the image to be displayed in a card or null if none where found.\n */", "\tif (!rawFileText.length || overrideBody) return overrideBody;\n\n\tconst rawTextArray = rawFileText.split(\"\\n\");\n\trawTextArray.shift();\n\tconst processedArray = rawTextArray.slice(rawTextArray.indexOf(\"---\") + 1);\n\tconst finalString = processedArray.join(\"\\n\").trim();\n\n\treturn finalString;\n}\n\n/**\n * Extract the first image from the raw markdown in a note.\n *\n * @param rawFileText - The text content of a obsidian note.\n * @param context - Timeline generic context.\n * @returns the URL of the image to be displayed in a card or null if none where found.\n */", "export function getImageUrlFromContextOrDocument(\n\trawFileText: string,\n\tcontext: MarkdownCodeBlockTimelineProcessingContext\n): string | null {\n\tconst {\n\t\tcachedMetadata: { frontmatter: metadata },\n\t\tfile: currentFile,\n\t\tapp,\n\t\tsettings: { metadataKeyEventPictureOverride },\n\t} = context;\n\tconst {\n\t\tvault,\n\t\tmetadataCache: { getFirstLinkpathDest },\n\t} = app;\n\tconst override = metadata?.[metadataKeyEventPictureOverride];\n", "\tif (override) return override;\n\tconst internalLinkMatch = rawFileText.match(/!\\[\\[(?<src>.*)\\]\\]/);\n\tconst matchs =\n\t\tinternalLinkMatch || rawFileText.match(/!\\[.*\\]\\((?<src>.*)\\)/);\n\n\tif (!matchs || !matchs.groups || !matchs.groups.src) return null;\n\n\tif (internalLinkMatch) {\n\t\t// https://github.com/obsidianmd/obsidian-releases/pull/1882#issuecomment-1512952295\n\t\tconst file = getFirstLinkpathDest.bind(app.metadataCache)(\n\t\t\tmatchs.groups.src,\n\t\t\tcurrentFile.path\n\t\t) satisfies TFile | null;\n", "\t\tif (file instanceof TFile) return vault.getResourcePath(file);\n\t\t// Thanks https://github.com/joethei\n\t\treturn null;\n\t} else return encodeURI(matchs.groups.src);\n}\n\n/**\n * Given a metadata key it'll try to parse the associated data as an `AbstractDate` and return it\n *\n * @param param0 - Timeline generic context.\n * @param param0.cachedMetadata - The cached metadata from a note.\n * @param param0.settings - the plugin's settings.\n * @param key - The target lookup key in the notes metadata object.\n * @returns the abstract date representation or undefined.\n */", "export function getAbstractDateFromMetadata(\n\t{ cachedMetadata, settings }: MarkdownCodeBlockTimelineProcessingContext,\n\tkey: string\n): AbstractDate | undefined {\n\tconst groupsToCheck = settings.dateParserGroupPriority.split(\",\");\n\tconst numberValue = getMetadataKey(cachedMetadata, key, \"number\");\n\n\tif (isDefined(numberValue)) {\n\t\tconst additionalContentForNumberOnlydate = [\n\t\t\t...Array(Math.max(0, groupsToCheck.length - 1)),\n\t\t].map(() => 0);\n\n\t\treturn [numberValue, ...additionalContentForNumberOnlydate];\n\t}\n\n\tconst stringValue = getMetadataKey(cachedMetadata, key, \"string\");\n", "\tif (!stringValue) return undefined;\n\treturn parseAbstractDate(\n\t\tgroupsToCheck,\n\t\tstringValue,\n\t\tsettings.dateParserRegex\n\t);\n}\n"]}
{"filename": "src/abstractDateFormatting.ts", "chunked_list": ["import {\n\tdateTokenConfigurationIsTypeNumber,\n\tdateTokenConfigurationIsTypeString,\n\tevalNumericalCondition,\n} from \"~/utils\";\n\nimport type {\n\tAutoTimelineSettings,\n\tAbstractDate,\n\tDateTokenConfiguration,", "\tAbstractDate,\n\tDateTokenConfiguration,\n\tDateTokenType,\n\tAdditionalDateFormatting,\n} from \"~/types\";\n\n/**\n * Handy function to format an abstract date based on the current settings.\n *\n * @param date - Target date to format.\n * @param param1 - The settings of the plugin.\n * @param param1.dateDisplayFormat - The target format to displat the date in.\n * @param param1.dateParserGroupPriority - The token priority list for the date format.\n * @param param1.dateTokenConfiguration - The configuration for the given date format.\n * @param param1.applyAdditonalConditionFormatting - The boolean toggle to check or not for additional condition based formattings.\n * @returns the formated representation of a given date based off the plugins settings.\n */", "export function formatAbstractDate(\n\tdate: AbstractDate | boolean,\n\t{\n\t\tdateDisplayFormat,\n\t\tdateParserGroupPriority,\n\t\tdateTokenConfiguration,\n\t\tapplyAdditonalConditionFormatting,\n\t}: Pick<\n\t\tAutoTimelineSettings,\n\t\t| \"dateDisplayFormat\"\n\t\t| \"dateParserGroupPriority\"\n\t\t| \"dateTokenConfiguration\"\n\t\t| \"applyAdditonalConditionFormatting\"\n\t>\n): string {", "\tif (typeof date === \"boolean\") return \"now\";\n\tconst prioArray = dateParserGroupPriority.split(\",\");\n\tlet output = dateDisplayFormat.toString();\n\n\tprioArray.forEach((token, index) => {\n\t\tconst configuration = dateTokenConfiguration.find(\n\t\t\t({ name }) => name === token\n\t\t);\n\n\t\tif (!configuration)\n\t\t\tthrow new Error(\n\t\t\t\t`[April's not so automatic timelines] - No date token configuration found for ${token}, please setup your date tokens correctly`\n\t\t\t);\n\n\t\toutput = output.replace(\n\t\t\t`{${token}}`,\n\t\t\tapplyConditionBasedFormatting(\n\t\t\t\tformatDateToken(date[index], configuration),\n\t\t\t\tdate[index],\n\t\t\t\tconfiguration,\n\t\t\t\tapplyAdditonalConditionFormatting\n\t\t\t)\n\t\t);\n\t});\n\n\treturn output;\n}\n\n/**\n * Shorthand to format a part of an abstract date.\n *\n * @param datePart - fragment of an abstract date.\n * @param configuration - the configuration bound to that date token.\n * @returns the formated token.\n */", "\t\tif (!configuration)\n\t\t\tthrow new Error(\n\t\t\t\t`[April's not so automatic timelines] - No date token configuration found for ${token}, please setup your date tokens correctly`\n\t\t\t);\n\n\t\toutput = output.replace(\n\t\t\t`{${token}}`,\n\t\t\tapplyConditionBasedFormatting(\n\t\t\t\tformatDateToken(date[index], configuration),\n\t\t\t\tdate[index],\n\t\t\t\tconfiguration,\n\t\t\t\tapplyAdditonalConditionFormatting\n\t\t\t)\n\t\t);\n\t});\n\n\treturn output;\n}\n\n/**\n * Shorthand to format a part of an abstract date.\n *\n * @param datePart - fragment of an abstract date.\n * @param configuration - the configuration bound to that date token.\n * @returns the formated token.\n */", "export function formatDateToken(\n\tdatePart: number,\n\tconfiguration: DateTokenConfiguration\n): string {\n\tif (dateTokenConfigurationIsTypeNumber(configuration))\n\t\treturn formatNumberDateToken(datePart, configuration);\n\tif (dateTokenConfigurationIsTypeString(configuration))\n\t\treturn formatStringDateToken(datePart, configuration);\n\tthrow new Error(\n\t\t`[April's not so automatic timelines] - Corrupted date token configuration, please reset settings`\n\t);\n}\n\n/**\n * This functions processes each tokens additional conditional formatting.\n *\n * @param formatedDate - The previously processed date token.\n * @param date - The numerical value of the token.\n * @param configuration - The configuration of the token.\n * @param configuration.formatting - The formatting array bound to a token configuration.\n * @param applyAdditonalConditionFormatting - The boolean toggle to check or not for additional condition based formattings.\n * @returns the fully formated token ready to be inserted in the output string.\n */", "export function applyConditionBasedFormatting(\n\tformatedDate: string,\n\tdate: number,\n\t{ formatting }: DateTokenConfiguration,\n\tapplyAdditonalConditionFormatting: AutoTimelineSettings[\"applyAdditonalConditionFormatting\"]\n): string {\n\tif (!applyAdditonalConditionFormatting) return formatedDate;\n\n\treturn formatting.reduce(\n\t\t(output, { format, conditionsAreExclusive, evaluations }) => {\n\t\t\tconst evaluationRestult = (\n\t\t\t\tconditionsAreExclusive ? evaluations.some : evaluations.every\n\t\t\t).bind(evaluations)(\n\t\t\t\t({\n\t\t\t\t\tcondition,\n\t\t\t\t\tvalue,\n\t\t\t\t}: AdditionalDateFormatting[\"evaluations\"][number]) =>\n\t\t\t\t\tevalNumericalCondition(condition, date, value)\n\t\t\t);\n", "\t\t\tif (evaluationRestult) return format.replace(\"{value}\", output);\n\t\t\treturn output;\n\t\t},\n\t\tformatedDate\n\t);\n}\n\n/**\n * Used to quickly format a fragment of an abstract date based off a number typed date token configuration.\n *\n * @param datePart - fragment of an abstract date.\n * @param param1 - A numerical date token configuration to apply.\n * @param param1.minLeght - the minimal length of a numerical date input.\n * @param param1.hideSign - if `true` the date part will be passed to `Math.abs` before anu further formatting.\n * @returns the formated token.\n */", "function formatNumberDateToken(\n\tdatePart: number,\n\t{ minLeght, hideSign }: DateTokenConfiguration<DateTokenType.number>\n): string {\n\tlet stringifiedToken = Math.abs(datePart).toString();\n\n\tif (minLeght < 0) return stringifiedToken;\n\twhile (stringifiedToken.length < minLeght)\n\t\tstringifiedToken = \"0\" + stringifiedToken;\n\tif (!hideSign && datePart < 0) stringifiedToken = `-${stringifiedToken}`;\n\treturn stringifiedToken;\n}\n\n/**\n * Used to quickly format a fragment of an abstract date based off a string typed date token configuration.\n *\n * @param datePart - fragment of an abstract date.\n * @param param1 - A string typed date token configuration to apply.\n * @param param1.dictionary - the relation dictionary for a date string typed token.\n * @returns the formated token.\n */", "\tif (!hideSign && datePart < 0) stringifiedToken = `-${stringifiedToken}`;\n\treturn stringifiedToken;\n}\n\n/**\n * Used to quickly format a fragment of an abstract date based off a string typed date token configuration.\n *\n * @param datePart - fragment of an abstract date.\n * @param param1 - A string typed date token configuration to apply.\n * @param param1.dictionary - the relation dictionary for a date string typed token.\n * @returns the formated token.\n */", "function formatStringDateToken(\n\tdatePart: number,\n\t{ dictionary }: DateTokenConfiguration<DateTokenType.string>\n): string {\n\treturn dictionary[datePart];\n}\n"]}
{"filename": "src/settings.ts", "chunked_list": ["import { PluginSettingTab } from \"obsidian\";\n\nimport { createApp, ref } from \"vue\";\nimport createVueI18nConfig from \"~/i18n.config\";\n\nimport VApp from \"~/views/App.vue\";\n\nimport type { App as ObsidianApp } from \"obsidian\";\nimport type AprilsAutomaticTimelinesPlugin from \"~/main\";\nimport type { AutoTimelineSettings, DateTokenConfiguration } from \"./types\";\nimport type { App as VueApp } from \"vue\";\nimport { createNumberDateTokenConfiguration } from \"./utils\";\n\n/**\n * Default key value relation for obsidian settings object\n */\nexport const SETTINGS_DEFAULT = {\n\tmetadataKeyEventStartDate: \"aat-event-start-date\",\n\tmetadataKeyEventEndDate: \"aat-event-end-date\",\n\tmetadataKeyEventTitleOverride: \"aat-event-title\",\n\tmetadataKeyEventBodyOverride: \"aat-event-body\",\n\tmetadataKeyEventPictureOverride: \"aat-event-picture\",\n\tmetadataKeyEventTimelineTag: \"timelines\",\n\tnoteInlineEventKey: \"aat-inline-event\",\n\tmarkdownBlockTagsToFindSeparator: \",\",\n\tdateParserRegex: \"(?<year>-?[0-9]*)-(?<month>-?[0-9]*)-(?<day>-?[0-9]*)\",\n\tdateParserGroupPriority: \"year,month,day\",\n\tdateDisplayFormat: \"{day}/{month}/{year}\",\n\tlookForTagsForTimeline: false,\n\tlookForInlineEventsInNotes: true,\n\tapplyAdditonalConditionFormatting: true,\n\tdateTokenConfiguration: [\n\t\tcreateNumberDateTokenConfiguration({ name: \"year\", minLeght: 4 }),\n\t\tcreateNumberDateTokenConfiguration({ name: \"month\" }),\n\t\tcreateNumberDateTokenConfiguration({ name: \"day\" }),\n\t] as DateTokenConfiguration[],\n};\n\nexport const __VUE_PROD_DEVTOOLS__ = true;\n/**\n * Class designed to display the inputs that allow the end user to change the default keys that are looked for when processing metadata in a single note.\n */", "import type AprilsAutomaticTimelinesPlugin from \"~/main\";\nimport type { AutoTimelineSettings, DateTokenConfiguration } from \"./types\";\nimport type { App as VueApp } from \"vue\";\nimport { createNumberDateTokenConfiguration } from \"./utils\";\n\n/**\n * Default key value relation for obsidian settings object\n */\nexport const SETTINGS_DEFAULT = {\n\tmetadataKeyEventStartDate: \"aat-event-start-date\",\n\tmetadataKeyEventEndDate: \"aat-event-end-date\",\n\tmetadataKeyEventTitleOverride: \"aat-event-title\",\n\tmetadataKeyEventBodyOverride: \"aat-event-body\",\n\tmetadataKeyEventPictureOverride: \"aat-event-picture\",\n\tmetadataKeyEventTimelineTag: \"timelines\",\n\tnoteInlineEventKey: \"aat-inline-event\",\n\tmarkdownBlockTagsToFindSeparator: \",\",\n\tdateParserRegex: \"(?<year>-?[0-9]*)-(?<month>-?[0-9]*)-(?<day>-?[0-9]*)\",\n\tdateParserGroupPriority: \"year,month,day\",\n\tdateDisplayFormat: \"{day}/{month}/{year}\",\n\tlookForTagsForTimeline: false,\n\tlookForInlineEventsInNotes: true,\n\tapplyAdditonalConditionFormatting: true,\n\tdateTokenConfiguration: [\n\t\tcreateNumberDateTokenConfiguration({ name: \"year\", minLeght: 4 }),\n\t\tcreateNumberDateTokenConfiguration({ name: \"month\" }),\n\t\tcreateNumberDateTokenConfiguration({ name: \"day\" }),\n\t] as DateTokenConfiguration[],\n};\n\nexport const __VUE_PROD_DEVTOOLS__ = true;\n/**\n * Class designed to display the inputs that allow the end user to change the default keys that are looked for when processing metadata in a single note.\n */", "export class TimelineSettingTab extends PluginSettingTab {\n\tplugin: AprilsAutomaticTimelinesPlugin;\n\tvueApp: VueApp<Element> | null;\n\n\tconstructor(app: ObsidianApp, plugin: AprilsAutomaticTimelinesPlugin) {\n\t\tsuper(app, plugin);\n\t\tthis.plugin = plugin;\n\t\tthis.vueApp = null;\n\t}\n\n\tdisplay(): void {\n\t\tthis.containerEl.empty();\n\n\t\t// TODO Read locale off obsidian.\n\t\tconst i18n = createVueI18nConfig();\n\n\t\tthis.vueApp = createApp({\n\t\t\tcomponents: { VApp },\n\t\t\ttemplate: \"<VApp :value='value' @update:value='save' />\",\n\t\t\tsetup: () => {\n\t\t\t\tconst value = ref(this.plugin.settings);\n\t\t\t\treturn {\n\t\t\t\t\tvalue,\n\t\t\t\t\tsave: async (payload: Partial<AutoTimelineSettings>) => {\n\t\t\t\t\t\tthis.plugin.settings = {\n\t\t\t\t\t\t\t...this.plugin.settings,\n\t\t\t\t\t\t\t...payload,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvalue.value = this.plugin.settings;\n\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t},\n\t\t\tmethods: {},\n\t\t});\n\n\t\tthis.vueApp.use(i18n).mount(this.containerEl);\n\t}\n\n\thide() {", "\t\tif (!this.vueApp) return;\n\t\tthis.vueApp.unmount();\n\t\tthis.vueApp = null;\n\t}\n}\n"]}
{"filename": "src/composable/hasSlot.ts", "chunked_list": ["import { Comment, Text, type Slot, type VNode } from \"vue\";\n\n/**\n * Quick composable to check for a slot when using `defineSlots()`\n *\n * @param slot - A potential Vue slot.\n * @param slotProps - The potencial props associated to that slot.\n * @returns typeguard boolean, `true` if the slot exists.\n */\nexport function hasSlot(slot: Slot | undefined, slotProps = {}): slot is Slot {\n\tif (!slot) return false;\n\n\treturn slot(slotProps).some((vnode: VNode) => {", "export function hasSlot(slot: Slot | undefined, slotProps = {}): slot is Slot {\n\tif (!slot) return false;\n\n\treturn slot(slotProps).some((vnode: VNode) => {\n\t\tif (vnode.type === Comment) return false;\n\n\t\tif (Array.isArray(vnode.children) && !vnode.children.length)\n\t\t\treturn false;\n\n\t\treturn (\n\t\t\tvnode.type !== Text ||\n\t\t\t(typeof vnode.children === \"string\" && vnode.children.trim() !== \"\")\n\t\t);\n\t});\n}\n"]}
