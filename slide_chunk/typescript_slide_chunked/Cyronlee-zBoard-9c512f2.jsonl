{"filename": "fake/build_status.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\nconst repos = Array.from({ length: 9 }).map(() => {\n  return {\n    projectName: faker.word.noun(),\n    branch: faker.helpers.arrayElement(['master', 'release']),\n  };\n});\n\nexport const getBuildStatusFakeData = () => {", "\nexport const getBuildStatusFakeData = () => {\n  return repos.map((repo) => {\n    return {\n      projectName: repo.projectName,\n      branch: repo.branch,\n      status: faker.helpers.arrayElement([\n        'success',\n        'failed',\n        'on_hold',", "        'failed',\n        'on_hold',\n        'running',\n        'canceled',\n        'unauthorized',\n      ]),\n      stopTime: faker.date.recent(1).toISOString(),\n      username: faker.name.fullName(),\n      avatarUrl: faker.image.avatar(),\n      commitSubject: faker.git.commitMessage(),", "      avatarUrl: faker.image.avatar(),\n      commitSubject: faker.git.commitMessage(),\n    };\n  });\n};\n"]}
{"filename": "fake/ticket_status.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\nexport const getTicketStatusFakeData = () => {\n  return Array.from({ length: 20 }).map(() => {\n    return {\n      subject: faker.lorem.sentence(25),\n      status: faker.helpers.arrayElement(['new', 'open', 'pending']),\n      url: faker.internet.url(),\n      created_at: faker.date.recent(1).toISOString(),\n      updated_at: faker.date.recent(1).toISOString(),", "      created_at: faker.date.recent(1).toISOString(),\n      updated_at: faker.date.recent(1).toISOString(),\n    };\n  });\n};\n"]}
{"filename": "fake/project_timeline.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\nexport const getProjectTimelineFakeData = () => {\n  return Array.from({ length: 10 }).map(() => {\n    const startDate = faker.date.between(faker.date.recent(30), faker.date.soon(30));\n    const endDate = faker.date.soon(30, startDate);\n    return {\n      cardNo: faker.random.numeric(6),\n      cardName: faker.lorem.sentence(20),\n      startDate: startDate.toISOString().slice(0, 10),", "      cardName: faker.lorem.sentence(20),\n      startDate: startDate.toISOString().slice(0, 10),\n      endDate: endDate.toISOString().slice(0, 10),\n      color: faker.helpers.arrayElement(['4681c8', 'cf7035', '795fce']),\n      owner: {\n        name: faker.name.fullName(),\n        avatar: faker.image.avatar(),\n      },\n      coOwners: [\n        {", "      coOwners: [\n        {\n          name: faker.name.fullName(),\n          avatar: faker.image.avatar(),\n        },\n      ],\n    };\n  });\n};\n", "};\n"]}
{"filename": "fake/owner_rotation.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\nimport moment from 'moment';\n\nexport const getOwnerRotationFakeData = () => {\n  return Array.from(['STAND UP', 'USER SUPPORT', 'RETRO', 'ALERTS']).map((type) => {\n    return {\n      subject: type,\n      color: faker.helpers.arrayElement(['green', 'cyan', 'blue', 'teal', 'purple', 'pink']),\n      icon: faker.helpers.arrayElement(['email', 'repeat', 'calendar']),\n      members: [", "      icon: faker.helpers.arrayElement(['email', 'repeat', 'calendar']),\n      members: [\n        {\n          name: faker.name.fullName(),\n          startDate: moment().subtract(14, 'days').format('YYYY-MM-DD'),\n          endDate: moment().subtract(8, 'days').format('YYYY-MM-DD'),\n        },\n        {\n          name: faker.name.fullName(),\n          startDate: moment().subtract(7, 'days').format('YYYY-MM-DD'),", "          name: faker.name.fullName(),\n          startDate: moment().subtract(7, 'days').format('YYYY-MM-DD'),\n          endDate: moment().add(7, 'days').format('YYYY-MM-DD'),\n        },\n        {\n          name: faker.name.fullName(),\n          startDate: moment().add(8, 'days').format('YYYY-MM-DD'),\n          endDate: moment().add(14, 'days').format('YYYY-MM-DD'),\n        },\n      ],", "        },\n      ],\n    };\n  });\n};\n"]}
{"filename": "src/middleware.ts", "chunked_list": ["import { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { siteConfig } from '@/../config/site.config';\n\n// This function can be marked `async` if using `await` inside\nexport function middleware(request: NextRequest) {\n  if (request.nextUrl.pathname.startsWith('/login')) {\n    if (!needSitePassword || isAuthenticated(request)) {\n      return toHomePage(request);\n    }\n    return NextResponse.next();\n  }", "  if (!needSitePassword) {\n    return NextResponse.next();\n  }\n  if (isAuthenticated(request)) {\n    return NextResponse.next();\n  }\n  if (request.nextUrl.pathname.startsWith('/api')) {\n    return unauthorizedResponse;\n  }\n  return toLoginPage(request);\n}\n\nconst needSitePassword = siteConfig.enableSitePassword && siteConfig.sitePassword;\n\nconst isAuthenticated = (request: NextRequest) => {\n  const sitePassword = request.cookies.get('site_password')?.value;\n  return sitePassword === siteConfig.sitePassword;\n};\n\nconst toHomePage = (request: NextRequest) => {\n  return NextResponse.redirect(new URL('/', request.url));\n};\n\nconst toLoginPage = (request: NextRequest) => {\n  return NextResponse.redirect(new URL('/login', request.url));\n};\n\nconst unauthorizedResponse = new NextResponse(\n  JSON.stringify({ success: false, message: 'authentication failed' }),\n  {\n    status: 401,\n    headers: { 'content-type': 'application/json' },\n  }\n);\n\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    '/((?!_next/static|_next/image|favicon.ico).*)',\n  ],\n};\n"]}
{"filename": "src/pages/api/github_build_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\nimport { buildStatusConfig } from '@/../config/build_status.config';\n\ninterface workflowRunResponse {\n  total_count: number;\n  workflow_runs: WorkflowRun[];\n}\n\n/**\n * An invocation of a workflow\n */", "interface WorkflowRun {\n  id: number;\n  name?: string | null;\n  head_branch: string | null;\n  head_sha: string;\n  path: string;\n  run_number: number;\n  status: string | null;\n  conclusion: string | null;\n  workflow_id: number;\n  created_at: string;\n  updated_at: string;\n  actor?: SimpleUser;\n  triggering_actor?: SimpleUser;\n  run_started_at?: string;\n  jobs_url: string;\n  head_commit: null | SimpleCommit;\n  display_title: string;\n}\n", "interface SimpleUser {\n  login: string;\n  avatar_url: string;\n  gravatar_id: string | null;\n}\n/**\n * A commit.\n */\ninterface SimpleCommit {\n  id: string;\n  tree_id: string;\n  message: string;\n  timestamp: string;\n  author: {\n    name: string;\n    email: string;\n  } | null;\n  committer: {\n    name: string;\n    email: string;\n  } | null;\n}\n\nconst githubActionsConfig = buildStatusConfig.datasource.github;\n\nconst handler: NextApiHandler = async (req, res) => {\n  getAllGitHubStatus()\n    .then((response) => res.status(200).json(response))", "interface SimpleCommit {\n  id: string;\n  tree_id: string;\n  message: string;\n  timestamp: string;\n  author: {\n    name: string;\n    email: string;\n  } | null;\n  committer: {\n    name: string;\n    email: string;\n  } | null;\n}\n\nconst githubActionsConfig = buildStatusConfig.datasource.github;\n\nconst handler: NextApiHandler = async (req, res) => {\n  getAllGitHubStatus()\n    .then((response) => res.status(200).json(response))", "    .catch((err) => res.status(500).send(err.message));\n};\n\nexport const getAllGitHubStatus = async () => {\n  if (githubActionsConfig.enabled) {\n    return await Promise.all(githubActionsConfig.projects.map((project) => getStatus(project)));\n  }\n  return [];\n};\n\nconst getStatus = async ({\n  projectName,\n  owner,\n  repo,\n  branch,\n  workflowId,\n}: {\n  projectName: string;\n  owner: string;\n  repo: string;\n  branch: string;\n  workflowId: number;\n}) => {\n  const url = `${githubActionsConfig.baseUrl}/repos/${owner}/${repo}/actions/workflows/${workflowId}/runs?per_page=1&branch=${branch}`;\n  const response = await fetch(url, {\n    headers: {\n      Authorization: `Bearer ${githubActionsConfig.apiToken}`,\n    },\n  });\n  let json: workflowRunResponse = await response.json();", "  if (!response.ok) {\n    throw new Error(JSON.stringify(json));\n  }\n  const workflowRun = json.workflow_runs[0];\n  return {\n    platform: 'Github',\n    projectName: projectName,\n    branch: branch,\n    status: workflowRun.status === 'completed' ? workflowRun.conclusion : workflowRun.status,\n    stopTime: workflowRun.updated_at,\n    username: workflowRun.triggering_actor?.login,\n    avatarUrl: workflowRun.triggering_actor?.avatar_url,\n    commitSubject: workflowRun.head_commit?.message,\n  };\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/project_timeline.ts", "chunked_list": ["import { NextApiHandler } from 'next';\nimport moment, { Moment } from 'moment';\nimport { getProjectTimelineFakeData } from '../../../fake/project_timeline.fake';\nimport { delay1s } from '@/lib/delay';\nimport { projectTimelineConfig } from '../../../config/project_timeline.config';\n\ninterface CardTransition {\n  column_id: number;\n  start: string | Moment;\n}\n", "interface TimelineCard {\n  startDate: string;\n  endDate: string;\n  card_id: string;\n  title: string;\n  color: string;\n  column_id: number;\n  owner_user_id: number;\n  co_owner_ids: number[];\n  deadline: string;\n  transitions: CardTransition[];\n}\n", "interface User {\n  name: string;\n  avatar: string;\n}\n\ninterface KanbanUser {\n  user_id: number;\n  username: string;\n  avatar: string;\n  realname: string;\n  is_confirmed: number;\n  is_enabled: number;\n}\n\nconst handler: NextApiHandler = async (req, res) => {\n  const startDate = req.query.start_date as string;\n  const endDate = req.query.end_date as string;\n  getProjectTimeline(startDate, endDate)\n    .then((response) => res.status(200).json(response))", "    .catch((err) => {\n      console.error(err);\n      res.status(500).send(err.message);\n    });\n};\n\nconst kanbanConfig = projectTimelineConfig.datasource.kanbanize;\n\nconst getProjectTimeline = async (startDate: string, endDate: string) => {\n  if (kanbanConfig.enabled) {\n    return await fetchCards(startDate, endDate);\n  }\n  return delay1s(getProjectTimelineFakeData);\n};\n\nconst fetchCards = async (startDate: string, endDate: string) => {\n  const columnIds = kanbanConfig.monitorColumns.map((item) => item.id).join(',');\n  const typeIds = kanbanConfig.monitorCardTypes.map((item) => item.id).join(',');\n  const fields = searchParams.fields.join(',');\n  const expand = searchParams.expand.join(',');\n  const cardsAPI = `${kanbanConfig.baseUrl}/api/v2/cards?board_ids=${kanbanConfig.boardId}&column_ids=${columnIds}&type_ids=${typeIds}&fields=${fields}&expand=${expand}&in_current_position_since_from_date=${startDate}`;\n  const response = await fetch(cardsAPI, {\n    headers: {\n      apikey: kanbanConfig.apikey || '',\n    },\n  });", "  if (kanbanConfig.enabled) {\n    return await fetchCards(startDate, endDate);\n  }\n  return delay1s(getProjectTimelineFakeData);\n};\n\nconst fetchCards = async (startDate: string, endDate: string) => {\n  const columnIds = kanbanConfig.monitorColumns.map((item) => item.id).join(',');\n  const typeIds = kanbanConfig.monitorCardTypes.map((item) => item.id).join(',');\n  const fields = searchParams.fields.join(',');\n  const expand = searchParams.expand.join(',');\n  const cardsAPI = `${kanbanConfig.baseUrl}/api/v2/cards?board_ids=${kanbanConfig.boardId}&column_ids=${columnIds}&type_ids=${typeIds}&fields=${fields}&expand=${expand}&in_current_position_since_from_date=${startDate}`;\n  const response = await fetch(cardsAPI, {\n    headers: {\n      apikey: kanbanConfig.apikey || '',\n    },\n  });", "  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n  const json = await response.json();\n\n  const userIds: number[] = json.data.data.flatMap(\n    ({ owner_user_id, co_owner_ids }: { owner_user_id: number; co_owner_ids: number[] }) => [\n      owner_user_id,\n      ...co_owner_ids,\n    ]\n  );\n  const buildUserInfo = await fetchUserInfo(userIds);\n\n  let cards = json.data.data.map((card: TimelineCard) => buildCardInfo(card, buildUserInfo));\n  return cards.filter(\n    (card: TimelineCard) => card.startDate >= startDate && card.endDate < endDate\n  );\n};\n\nconst buildCardInfo = (card: TimelineCard, buildUserInfo: (userId: number) => User | null) => {\n  const [startDate, endDate] = calculateStartEndDate(card);\n  const getColumnName = (columnId: number) => {\n    return kanbanConfig.monitorColumns.find((c) => c.id === columnId)?.name;\n  };\n  return {\n    cardNo: card.card_id,\n    cardName: card.title,\n    startDate: startDate,\n    endDate: endDate,\n    color: card.color,\n    status: getColumnName(card.column_id),\n    owner: buildUserInfo(card.owner_user_id),\n    coOwners: card.co_owner_ids?.map((id: number) => buildUserInfo(id)),\n  };\n};\n\nconst fetchUserInfo = async (userIds: number[]) => {\n  const uniqueUserIds = [...new Set(userIds)].filter((id) => id).join(',');\n  const userAPI = `${kanbanConfig.baseUrl}/api/v2/users?user_ids=${uniqueUserIds}&fields=user_id,username,realname,avatar`;\n  const response = await fetch(userAPI, {\n    headers: {\n      apikey: kanbanConfig.apikey || '',\n    },\n  });\n  const json = await response.json();\n\n  return (userId: number) => {\n    const user = json.data.find((user: KanbanUser) => user.user_id === userId);\n    return user\n      ? {\n          name: user.realname,\n          avatar: user.avatar,\n        }\n      : null;\n  };\n};\n\nconst calculateStartEndDate = (card: TimelineCard): [startDate: string, endDate: string] => {\n  // Find the first time a card was moved to configured columns\n  const startTime = card.transitions?.find((transition: CardTransition) =>\n    kanbanConfig.startColumns.map(({ id }) => id).includes(transition.column_id)\n  )?.start;\n  let endTime = card.transitions?.find((transition: CardTransition) =>\n    kanbanConfig.endColumns.map(({ id }) => id).includes(transition.column_id)\n  )?.start;\n  endTime =\n    endTime || card.deadline || moment(startTime).add(kanbanConfig.defaultIterationWeeks, 'weeks');\n\n  return [moment(startTime).format('YYYY-MM-DD'), moment(endTime).format('YYYY-MM-DD')];\n};\n\nconst searchParams = {\n  fields: [\n    'card_id',\n    'title',\n    'owner_user_id',\n    'type_id',\n    'size',\n    'priority',\n    'color',\n    'deadline',\n    'is_blocked',\n  ],\n  expand: ['co_owner_ids', 'transitions'],\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/build_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\nimport { delay1s } from '@/lib/delay';\nimport { getBuildStatusFakeData } from '../../../fake/build_status.fake';\nimport { buildStatusConfig } from '../../../config/build_status.config';\nimport { getAllCircleBuildStatus } from '@/pages/api/circle_build_status';\nimport { getAllGitHubStatus } from '@/pages/api/github_build_status';\n\nconst handler: NextApiHandler = async (req, res) => {\n  getCIStatus()\n    .then((response) => res.status(200).json(response))\n    .catch((err) => res.status(500).send(err.message));\n};\n\nconst getCIStatus = async () => {", "  getCIStatus()\n    .then((response) => res.status(200).json(response))\n    .catch((err) => res.status(500).send(err.message));\n};\n\nconst getCIStatus = async () => {\n  if (\n    !buildStatusConfig.datasource.github.enabled &&\n    !buildStatusConfig.datasource.circleCI.enabled\n  ) {\n    return delay1s(getBuildStatusFakeData);\n  }\n  const responses = await Promise.all([getAllCircleBuildStatus(), getAllGitHubStatus()]);\n  return responses.flat();\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/owner_rotation.ts", "chunked_list": ["import { NextApiHandler } from 'next';\nimport { ownerRotationConfig } from '../../../config/owner_rotation.config';\nimport { Member, Rotation } from '@/components/OwnerRotationOverview';\nimport { delay1s } from '@/lib/delay';\nimport { fetchFieldsFromApiTable } from '@/lib/apiTableFetcher';\nimport { fetchFieldsFromGoogleSheet } from '@/lib/googleSheetFetcher';\nimport { getOwnerRotationFakeData } from '../../../fake/owner_rotation.fake';\nimport moment from 'moment';\n\nconst handler: NextApiHandler = async (req, res) => {", "\nconst handler: NextApiHandler = async (req, res) => {\n  getAllOwners()\n    .then((response) => res.status(200).json(response))\n    .catch((err) => res.status(500).send(err.message));\n};\n\nconst getAllOwners = async () => {\n  if (ownerRotationConfig.datasource.localData.enabled) {\n    return ownerRotationConfig.datasource.localData.rotations;\n  }", "  if (ownerRotationConfig.datasource.localData.enabled) {\n    return ownerRotationConfig.datasource.localData.rotations;\n  }\n  if (ownerRotationConfig.datasource.apiTable.enabled) {\n    return await loadDataFromApiTable();\n  }\n  if (ownerRotationConfig.datasource.googleSheet.enabled) {\n    return await loadDataFromGoogleSheet();\n  }\n  return delay1s(getOwnerRotationFakeData);\n};\n\nconst loadDataFromApiTable = async () => {\n  const apiTableConfig = ownerRotationConfig.datasource.apiTable;\n  return await Promise.all(\n    apiTableConfig.rotations.map(async (rotation) => {\n      const tableViewUrl = `${apiTableConfig.baseUrl}${rotation.datasheetId}/records`;\n      let members = await fetchFieldsFromApiTable(tableViewUrl, apiTableConfig.apiKey as string);\n      return {\n        subject: rotation.subject,\n        color: rotation.color,\n        icon: rotation.icon,\n        members: sortMembers(members),\n      };\n    })\n  );\n};\n\nconst loadDataFromGoogleSheet = async () => {\n  const googleSheetConfig = ownerRotationConfig.datasource.googleSheet;\n  return await Promise.all(\n    googleSheetConfig.rotations.map(async (rotation) => {\n      const docUrl = `${googleSheetConfig.baseUrl}${googleSheetConfig.docId}/gviz/tq?`;\n      let members = await fetchFieldsFromGoogleSheet(docUrl, rotation.sheetName);\n      return {\n        subject: rotation.subject,\n        color: rotation.color,\n        icon: rotation.icon,\n        members: sortMembers(members),\n      };\n    })\n  );\n};\n\nconst datePattern = /^\\d{4}-\\d{2}-\\d{2}$/;\n\nconst dateFormat = 'YYYY-MM-DD';\n\nconst isAfter = (date1: string, date2: string) =>\n  moment(date1, dateFormat).isAfter(moment(date2, dateFormat));\n\nconst sortMembers = (rows: { [key: string]: any }[]) => {\n  let members: Member[] = [];", "  if (rows?.every((it) => datePattern.test(it.startDate))) {\n    rows.sort((a, b) => (isAfter(a.startDate, b.startDate) ? 1 : -1));\n    members = rows.map((row) => ({\n      name: row.name,\n      startDate: row.startDate,\n      endDate: row.endDate,\n    }));\n  }\n  return members;\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/ticket_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\nimport { ticketStatusConfig } from '../../../config/ticket_status.config';\nimport { getTicketStatusFakeData } from '../../../fake/ticket_status.fake';\nimport { delay1s } from '@/lib/delay';\nimport { btoa } from 'buffer';\n\ninterface Ticket {\n  subject: string;\n  status: string;\n  url: string;\n  created_at: string;\n  updated_at: string;\n}\n\nconst zendeskConfig = ticketStatusConfig.datasource.zendesk;\n\nconst handler: NextApiHandler = async (req, res) => {\n  getAllBuildStatus()\n    .then((response) => res.status(200).json(response))", "    .catch((err) => res.status(500).send(err.message));\n};\n\nconst getAllBuildStatus = async () => {\n  if (zendeskConfig.enabled) {\n    return await fetchTickets();\n  }\n  return delay1s(getTicketStatusFakeData);\n};\n\nconst fetchTickets = async () => {\n  const emailAddress = zendeskConfig.userEmail;\n  const apiToken = zendeskConfig.apiToken;\n  const basicToken = btoa(`${emailAddress}/token:${apiToken}`);\n  let nextPageUrl = `${zendeskConfig.baseUrl}/api/v2/views/${zendeskConfig.viewId}/tickets?sort_by=updated_at&sort_order=desc`;\n  let allTickets: Ticket[] = [];", "  while (nextPageUrl) {\n    const response = await fetch(nextPageUrl, {\n      headers: {\n        Authorization: `Basic ${basicToken}`,\n      },\n    });\n    if (!response.ok) {\n      throw new Error('failed to fetch zendesk tickets');\n    }\n    const json = await response.json();\n    nextPageUrl = json.next_page;\n    allTickets = allTickets.concat(json.tickets);\n  }\n  return allTickets;\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/hello.ts", "chunked_list": ["// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ntype Data = {\n  name: string;\n};\n\nexport default function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<Data>\n) {\n  res.status(200).json({ name: 'John Doe' });\n}\n"]}
{"filename": "src/pages/api/circle_build_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\nimport _ from 'lodash';\nimport { buildStatusConfig } from '../../../config/build_status.config';\n\ninterface PipelineTriggerActor {\n  login: string;\n  avatar_url: string;\n}\n\ninterface PipelineTrigger {\n  actor: PipelineTriggerActor;\n}\n", "interface PipelineTrigger {\n  actor: PipelineTriggerActor;\n}\n\ninterface PipelineVcsCommit {\n  body: string;\n  subject: string;\n}\n\ninterface PipelineVcs {\n  commit: PipelineVcsCommit;\n}\n", "interface PipelineVcs {\n  commit: PipelineVcsCommit;\n}\n\ninterface Workflow {\n  id: string;\n  created_at: string;\n  status: string;\n}\n\ninterface Workflows {\n  items: Workflow[];\n}\n", "interface Workflows {\n  items: Workflow[];\n}\n\ninterface Pipeline {\n  id: string;\n  updated_at: string;\n  trigger: PipelineTrigger;\n  vcs: PipelineVcs;\n}\n", "interface Pipelines {\n  items: Pipeline[];\n}\n\nconst circleCIConfig = buildStatusConfig.datasource.circleCI;\n\nconst handler: NextApiHandler = async (req, res) => {\n  getAllCircleBuildStatus()\n    .then((response) => res.status(200).json(response))\n    .catch((err) => res.status(500).send(err.message));\n};\n\nexport const getAllCircleBuildStatus = async () => {", "    .catch((err) => res.status(500).send(err.message));\n};\n\nexport const getAllCircleBuildStatus = async () => {\n  if (circleCIConfig.enabled) {\n    return await Promise.all(\n      circleCIConfig.projects.map((project) => {\n        return getBuildStatus(project);\n      })\n    );\n  }\n  return [];\n};\n\nconst getBuildStatus = async ({\n  projectName,\n  projectSlug,\n  branch,\n}: {\n  projectName: string;\n  projectSlug: string;\n  branch: string;\n}) => {\n  const latestPipeline: Pipeline = await getLatestPipeline(projectSlug, branch);\n  const { login, avatar_url } = latestPipeline.trigger.actor;\n  const latestWorkflow: Workflow = await getLatestWorkflow(latestPipeline.id);\n  return {\n    platform: 'CircleCI',\n    projectName: projectName,\n    branch,\n    username: login,\n    avatarUrl: avatar_url,\n    commitSubject: latestPipeline.vcs.commit?.subject || 'automatically triggered',\n    status: latestWorkflow.status,\n    stopTime: latestWorkflow.created_at,\n  };\n};\n\nconst getLatestPipeline = async (projectSlug: string, branch: string): Promise<Pipeline> => {\n  let pipelines: Pipelines = await fetchPipelines(projectSlug, branch);\n  return _.orderBy(pipelines.items, 'updated_at', 'desc')[0];\n};\n\nconst getLatestWorkflow = async (pipelineId: string): Promise<Workflow> => {\n  const workflows = await fetchWorkflows(pipelineId);\n  return _.orderBy(workflows.items, 'created_at', 'desc')[0];\n};\n\nconst fetchPipelines = async (projectSlug: string, branch: string): Promise<Pipelines> => {\n  const url = `https://circleci.com/api/v2/project/${projectSlug}/pipeline?branch=${branch}&circle-token=${circleCIConfig.apiToken}`;\n  const response = await fetch(url);\n  let json: Pipelines = await response.json();", "  if (!response.ok) {\n    throw new Error(JSON.stringify(json));\n  }\n  return json;\n};\n\nconst fetchWorkflows = async (pipelineId: string): Promise<Workflows> => {\n  const url = `https://circleci.com/api/v2/pipeline/${pipelineId}/workflow?circle-token=${circleCIConfig.apiToken}`;\n  const response = await fetch(url);\n  let json: Workflows = await response.json();\n  if (!response.ok) {\n    throw new Error(JSON.stringify(json));\n  }\n  return json;\n};\n\nexport default handler;\n", "  if (!response.ok) {\n    throw new Error(JSON.stringify(json));\n  }\n  return json;\n};\n\nexport default handler;\n"]}
{"filename": "src/lib/apiTableFetcher.ts", "chunked_list": ["interface RecordItem {\n  fields: Object;\n}\n\nexport const fetchFieldsFromApiTable = async (url: string, token: string) => {\n  const response = await fetch(url, {\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n  });\n  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n  const json = await response.json();\n  return json.data?.records?.flatMap((item: RecordItem) => item.fields);\n};\n", "  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n  const json = await response.json();\n  return json.data?.records?.flatMap((item: RecordItem) => item.fields);\n};\n"]}
{"filename": "src/lib/delay.ts", "chunked_list": ["export const delay1s = <T>(func: () => T) =>\n  new Promise<T>((resolve) => setTimeout(() => resolve(func()), 1000));\n"]}
{"filename": "src/lib/customToast.ts", "chunked_list": ["import { useToast as useChakraToast } from '@chakra-ui/toast';\n\nexport const useErrorToast = () => {\n  const toast = useChakraToast();\n\n  return (message: string) => {\n    toast({\n      title: 'Error occurred',\n      duration: 6000,\n      description: message,", "      duration: 6000,\n      description: message,\n      status: 'error',\n      isClosable: true,\n      position: 'bottom-right',\n    });\n  };\n};\n\nexport const useInfoToast = () => {", "\nexport const useInfoToast = () => {\n  const toast = useChakraToast();\n\n  return (title: string, message: string) => {\n    toast({\n      title: title,\n      description: message,\n      status: 'info',\n      isClosable: true,", "      status: 'info',\n      isClosable: true,\n      position: 'top-right',\n    });\n  };\n};\n"]}
{"filename": "src/lib/googleSheetFetcher.ts", "chunked_list": ["interface SheetCol {\n  id: string;\n  label: string;\n  type: string;\n}\n\ninterface SheetRowItem {\n  v: string | number;\n  f?: string;\n}\n", "interface SheetRow {\n  c: SheetRowItem[];\n}\n\ninterface RowObject {\n  [key: string]: any;\n}\n\nconst formatSheetRow = (list: SheetRowItem[]) => {\n  for (let i = list.length - 1; i >= 0; i--) {\n    if (list[i] === null || list[i].v === null) {\n      list.splice(i, 1);\n    }\n  }\n};\n\nexport const fetchFieldsFromGoogleSheet = async (docUrl: string, sheetName: string) => {\n  const query = encodeURIComponent('Select *');\n  const sheetUrl = `${docUrl}&sheet=${sheetName}&tq=${query}`;\n  const response = await fetch(sheetUrl);", "  for (let i = list.length - 1; i >= 0; i--) {\n    if (list[i] === null || list[i].v === null) {\n      list.splice(i, 1);\n    }\n  }\n};\n\nexport const fetchFieldsFromGoogleSheet = async (docUrl: string, sheetName: string) => {\n  const query = encodeURIComponent('Select *');\n  const sheetUrl = `${docUrl}&sheet=${sheetName}&tq=${query}`;\n  const response = await fetch(sheetUrl);", "  if (!response.ok) {\n    throw new Error(await response.text());\n  }\n  const json = await response.text();\n  const res = JSON.parse(json.substring(47).slice(0, -2));\n  let fields = res.table.cols.flatMap((it: SheetCol) => it.label);\n  fields = fields.filter((it: string) => it !== '');\n  let values = res.table.rows.map((it: SheetRow) => it.c);\n  values.forEach((it: SheetRowItem[]) => formatSheetRow(it));\n  let rows: RowObject[] = [];\n  values.forEach((row: SheetRowItem[]) => {\n    let dataRow: RowObject = {};\n    fields.forEach((col: string, index: number) => {\n      dataRow[col] = row[index]?.f ?? row[index]?.v ?? '';\n    });\n    rows.push(dataRow);\n  });\n  return rows;\n};\n"]}
{"filename": "src/theme/theme.ts", "chunked_list": ["import { extendTheme } from '@chakra-ui/react';\n\nconst config = {\n  initialColorMode: 'light',\n  useSystemColorMode: false,\n};\n\nconst theme = extendTheme({\n  config,\n  styles: {", "  config,\n  styles: {\n    global: {\n      body: {\n        transition: 'background-color 200ms linear !important',\n      },\n    },\n  },\n});\n", "});\n\nexport default theme;\n"]}
