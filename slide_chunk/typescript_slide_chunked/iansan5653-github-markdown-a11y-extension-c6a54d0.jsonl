{"filename": "@types/@github/markdownlint-github/index.d.ts", "chunked_list": ["import {Configuration, Rule} from \"markdownlint\";\n\ndeclare const main: Rule[] & {\n  init(overrides: Configuration): Configuration;\n};\nexport default main;\n"]}
{"filename": "src/content-script.ts", "chunked_list": ["import {\n  LintedMarkdownCodeMirrorEditor,\n  LintedMarkdownTextareaEditor,\n} from \"./components/linted-markdown-editor\";\nimport {observeSelector} from \"./utilities/dom/observe-selector\";\n\nconst rootPortal = document.createElement(\"div\");\nrootPortal.style.zIndex = \"999\";\nrootPortal.style.position = \"absolute\";\nrootPortal.style.top = \"0\";", "rootPortal.style.position = \"absolute\";\nrootPortal.style.top = \"0\";\nrootPortal.style.left = \"0\";\ndocument.body.appendChild(rootPortal);\n\nobserveSelector(\n  \"textarea.js-paste-markdown, textarea.CommentBox-input, textarea[aria-label='Markdown value']\",\n  (editor) => {\n    if (!(editor instanceof HTMLTextAreaElement)) return () => {};\n\n    const lintedEditor = new LintedMarkdownTextareaEditor(editor, rootPortal);\n\n    return () => lintedEditor.disconnect();\n  }\n);\n\nobserveSelector(\n  \"file-attachment.js-upload-markdown-image .CodeMirror-code[contenteditable]\",\n  (editor) => {\n    const lintedEditor = new LintedMarkdownCodeMirrorEditor(editor, rootPortal);\n\n    return () => lintedEditor.disconnect();\n  }\n);\n", "    if (!(editor instanceof HTMLTextAreaElement)) return () => {};\n\n    const lintedEditor = new LintedMarkdownTextareaEditor(editor, rootPortal);\n\n    return () => lintedEditor.disconnect();\n  }\n);\n\nobserveSelector(\n  \"file-attachment.js-upload-markdown-image .CodeMirror-code[contenteditable]\",\n  (editor) => {\n    const lintedEditor = new LintedMarkdownCodeMirrorEditor(editor, rootPortal);\n\n    return () => lintedEditor.disconnect();\n  }\n);\n"]}
{"filename": "src/components/lint-error-annotation.ts", "chunked_list": ["import {LintedMarkdownEditor} from \"./linted-markdown-editor\";\nimport {Rect} from \"../utilities/geometry/rect\";\nimport {Vector} from \"../utilities/geometry/vector\";\nimport {getWindowScrollVector, isHighContrastMode} from \"../utilities/dom\";\nimport {NumberRange} from \"../utilities/geometry/number-range\";\nimport {Component} from \"./component\";\nimport {LintError} from \"../utilities/lint-markdown\";\n\nexport class LintErrorAnnotation extends Component {\n  readonly lineNumber: number;\n\n  readonly #container: HTMLElement = document.createElement(\"div\");\n\n  readonly #editor: LintedMarkdownEditor;\n  #elements: readonly HTMLElement[] = [];\n\n  readonly #indexRange: NumberRange;\n\n  constructor(\n    readonly error: LintError,\n    editor: LintedMarkdownEditor,\n    portal: HTMLElement\n  ) {\n    super();\n\n    this.#editor = editor;\n\n    this.lineNumber = error.lineNumber;\n\n    portal.appendChild(this.#container);\n\n    const markdown = editor.value;\n    const [line = \"\", ...prevLines] = markdown\n      .split(\"\\n\")\n      .slice(0, this.lineNumber)\n      .reverse();\n\n    const startCol = (error.errorRange?.[0] ?? 1) - 1;\n    const length = error.errorRange?.[1] ?? line.length - startCol;\n\n    const startIndex = prevLines.reduce(\n      (t, l) => t + l.length + 1 /* +1 for newline char */,\n      startCol\n    );\n    const endIndex = startIndex + length;\n    this.#indexRange = new NumberRange(startIndex, endIndex);\n\n    this.recalculatePosition();\n  }\n\n  disconnect() {\n    super.disconnect();\n    this.#container.remove();\n  }\n\n  getTooltipPosition() {\n    const domRect = this.#elements.at(-1)?.getBoundingClientRect();", "export class LintErrorAnnotation extends Component {\n  readonly lineNumber: number;\n\n  readonly #container: HTMLElement = document.createElement(\"div\");\n\n  readonly #editor: LintedMarkdownEditor;\n  #elements: readonly HTMLElement[] = [];\n\n  readonly #indexRange: NumberRange;\n\n  constructor(\n    readonly error: LintError,\n    editor: LintedMarkdownEditor,\n    portal: HTMLElement\n  ) {\n    super();\n\n    this.#editor = editor;\n\n    this.lineNumber = error.lineNumber;\n\n    portal.appendChild(this.#container);\n\n    const markdown = editor.value;\n    const [line = \"\", ...prevLines] = markdown\n      .split(\"\\n\")\n      .slice(0, this.lineNumber)\n      .reverse();\n\n    const startCol = (error.errorRange?.[0] ?? 1) - 1;\n    const length = error.errorRange?.[1] ?? line.length - startCol;\n\n    const startIndex = prevLines.reduce(\n      (t, l) => t + l.length + 1 /* +1 for newline char */,\n      startCol\n    );\n    const endIndex = startIndex + length;\n    this.#indexRange = new NumberRange(startIndex, endIndex);\n\n    this.recalculatePosition();\n  }\n\n  disconnect() {\n    super.disconnect();\n    this.#container.remove();\n  }\n\n  getTooltipPosition() {\n    const domRect = this.#elements.at(-1)?.getBoundingClientRect();", "    if (domRect)\n      return new Rect(domRect)\n        .asVector(\"bottom-left\")\n        .plus(new Vector(0, 2)) // add some breathing room\n        .plus(getWindowScrollVector());\n  }\n\n  containsPoint(point: Vector) {\n    return this.#elements.some((el) =>\n      // scale slightly so we don't show two tooltips at touching horizontal edges\n      new Rect(el.getBoundingClientRect()).scaleY(0.99).contains(point)\n    );\n  }\n\n  containsIndex(index: number) {\n    return this.#indexRange.contains(index, \"inclusive\");\n  }\n\n  recalculatePosition() {\n    const editorRect = new Rect(this.#editor.getBoundingClientRect());\n    const scrollVector = getWindowScrollVector();\n\n    // The range rectangles are tight around the characters; we'd rather fill the line height if possible\n    const cssLineHeight = this.#editor.getLineHeight();\n\n    const elements: HTMLElement[] = [];\n    // render an annotation element for each line separately", "    for (const rect of this.#editor.getRangeRects(this.#indexRange)) {\n      // suppress when out of bounds\n      if (!rect.isContainedBy(editorRect)) continue;\n\n      // The rects are viewport-relative, but the annotations are absolute positioned\n      // (document-relative) so we have to add the window scroll position\n      const absoluteRect = rect.translate(scrollVector);\n\n      // We want ranges spanning multiple lines to look like one annotation, so we need to\n      // expand them to fill the gap around the lines\n      const lineHeight = cssLineHeight ?? rect.height * 1.2;\n      const scaledRect = absoluteRect.scaleY(lineHeight / absoluteRect.height);\n\n      elements.push(LintErrorAnnotation.#createAnnotationElement(scaledRect));\n    }\n    this.#container.replaceChildren(...elements);\n    this.#elements = elements;\n  }\n\n  static #createAnnotationElement(rect: Rect) {\n    const annotation = document.createElement(\"span\");\n    annotation.style.position = \"absolute\";\n    annotation.style.boxSizing = \"border-box\";\n    // use underline instead of highlight for high contrast", "    if (isHighContrastMode()) {\n      annotation.style.borderBottom = \"3px dashed var(--color-danger-fg)\";\n    } else {\n      annotation.style.backgroundColor = \"var(--color-danger-emphasis)\";\n      annotation.style.opacity = \"0.2\";\n    }\n    annotation.style.pointerEvents = \"none\";\n    annotation.style.top = `${rect.top}px`;\n    annotation.style.left = `${rect.left}px`;\n    annotation.style.width = `${rect.width}px`;\n    annotation.style.height = `${rect.height}px`;\n    return annotation;\n  }\n}\n"]}
{"filename": "src/components/lint-error-tooltip.ts", "chunked_list": ["//@ts-check\n\"use strict\";\n\nimport {Vector} from \"../utilities/geometry/vector\";\nimport {LintError} from \"../utilities/lint-markdown\";\nimport {Component} from \"./component\";\n\nconst WIDTH = 350;\nconst MARGIN = 8;\n\nexport class LintErrorTooltip extends Component {\n  #tooltip = LintErrorTooltip.#createTooltipElement();\n\n  constructor(portal: HTMLElement) {\n    super();\n    this.addEventListener(document, \"keydown\", (e) => this.#onGlobalKeydown(e));\n    this.addEventListener(this.#tooltip, \"mouseout\", () => this.hide());\n    portal.appendChild(this.#tooltip);\n  }\n\n  disconnect() {\n    super.disconnect();\n    this.#tooltip.remove();\n  }\n\n  show(errors: LintError[], {x, y}: Vector) {\n    const prefix = LintErrorTooltip.#createPrefixElement(errors.length);\n\n    // even though typed as required string, sometimes these properties are missing\n    const errorNodes = errors.map((error, i) => [\n      i !== 0 ? LintErrorTooltip.#createSeparatorElement() : \"\",\n      LintErrorTooltip.#createDescriptionElement(error.ruleDescription),\n      error.errorDetail\n        ? LintErrorTooltip.#createDetailsElement(error.errorDetail)\n        : \"\",\n      error.justification\n        ? LintErrorTooltip.#createJustificationElement(error.justification)\n        : \"\",\n      error.ruleNames?.length\n        ? LintErrorTooltip.#createNameElement(\n            error.ruleNames?.slice(0, 2).join(\": \")\n          )\n        : \"\",\n    ]);\n\n    this.#tooltip.replaceChildren(prefix, ...errorNodes.flat());\n\n    this.#tooltip.style.top = `${y}px`;\n\n    {\n      const availableWidth = document.body.clientWidth - 2 * MARGIN;\n      const rightOverflow = Math.max(x + WIDTH - (availableWidth + MARGIN), 0);\n      this.#tooltip.style.left = `${Math.max(x - rightOverflow, MARGIN)}px`;\n      this.#tooltip.style.maxWidth = `${availableWidth}px`;\n    }\n\n    this.#tooltip.removeAttribute(\"hidden\");\n  }\n\n  hide(force = false) {\n    // Don't hide if the mouse enters the tooltip (allowing users to copy text)\n    setTimeout(() => {", "const MARGIN = 8;\n\nexport class LintErrorTooltip extends Component {\n  #tooltip = LintErrorTooltip.#createTooltipElement();\n\n  constructor(portal: HTMLElement) {\n    super();\n    this.addEventListener(document, \"keydown\", (e) => this.#onGlobalKeydown(e));\n    this.addEventListener(this.#tooltip, \"mouseout\", () => this.hide());\n    portal.appendChild(this.#tooltip);\n  }\n\n  disconnect() {\n    super.disconnect();\n    this.#tooltip.remove();\n  }\n\n  show(errors: LintError[], {x, y}: Vector) {\n    const prefix = LintErrorTooltip.#createPrefixElement(errors.length);\n\n    // even though typed as required string, sometimes these properties are missing\n    const errorNodes = errors.map((error, i) => [\n      i !== 0 ? LintErrorTooltip.#createSeparatorElement() : \"\",\n      LintErrorTooltip.#createDescriptionElement(error.ruleDescription),\n      error.errorDetail\n        ? LintErrorTooltip.#createDetailsElement(error.errorDetail)\n        : \"\",\n      error.justification\n        ? LintErrorTooltip.#createJustificationElement(error.justification)\n        : \"\",\n      error.ruleNames?.length\n        ? LintErrorTooltip.#createNameElement(\n            error.ruleNames?.slice(0, 2).join(\": \")\n          )\n        : \"\",\n    ]);\n\n    this.#tooltip.replaceChildren(prefix, ...errorNodes.flat());\n\n    this.#tooltip.style.top = `${y}px`;\n\n    {\n      const availableWidth = document.body.clientWidth - 2 * MARGIN;\n      const rightOverflow = Math.max(x + WIDTH - (availableWidth + MARGIN), 0);\n      this.#tooltip.style.left = `${Math.max(x - rightOverflow, MARGIN)}px`;\n      this.#tooltip.style.maxWidth = `${availableWidth}px`;\n    }\n\n    this.#tooltip.removeAttribute(\"hidden\");\n  }\n\n  hide(force = false) {\n    // Don't hide if the mouse enters the tooltip (allowing users to copy text)\n    setTimeout(() => {", "      if (force || !this.#tooltip.matches(\":hover\"))\n        this.#tooltip.setAttribute(\"hidden\", \"true\");\n    }, 10);\n  }\n\n  #onGlobalKeydown(event: KeyboardEvent) {\n    if (event.key === \"Escape\" && !event.defaultPrevented) this.hide(true);\n  }\n\n  static #createTooltipElement() {\n    const element = document.createElement(\"div\");\n\n    element.setAttribute(\"aria-live\", \"polite\");\n    element.setAttribute(\"hidden\", \"true\");\n\n    element.style.backgroundColor = \"var(--color-canvas-default)\";\n    element.style.padding = \"8px\";\n    element.style.border = \"1px solid var(--color-border-default)\";\n    element.style.borderRadius = \"6px\";\n    element.style.boxShadow = \"var(--color-shadow-medium)\";\n    element.style.boxSizing = \"border-box\";\n    element.style.position = \"absolute\";\n    element.style.width = `${WIDTH}px`;\n    element.style.display = \"flex\";\n    element.style.flexDirection = \"column\";\n    element.style.gap = \"8px\";\n\n    return element;\n  }\n\n  static #createPrefixElement(errorCount: number) {\n    const element = document.createElement(\"span\");\n    element.textContent =\n      errorCount === 1\n        ? \"Markdown problem: \"\n        : `${errorCount} Markdown problems: `;\n    element.style.clipPath = \"circle(0)\";\n    element.style.position = \"absolute\";\n    return element;\n  }\n\n  static #createDescriptionElement(description: string) {\n    const element = document.createElement(\"div\");\n    element.style.fontWeight = \"bold\";\n    element.style.color = \"var(--color-danger-fg)\";\n    element.append(description);\n    return element;\n  }\n\n  static #createDetailsElement(details: string) {\n    const element = document.createElement(\"p\");\n    element.style.fontWeight = \"bold\";\n    element.style.margin = \"0\";\n    element.append(details);\n    return element;\n  }\n\n  static #createJustificationElement(justification: string) {\n    const element = document.createElement(\"p\");\n    element.style.margin = \"0\";\n    element.append(justification);\n    return element;\n  }\n\n  static #createNameElement(name: string) {\n    const element = document.createElement(\"code\");\n    element.style.fontSize = \"12px\";\n    element.style.color = \"var(--color-fg-muted)\";\n    element.style.backgroundColor = \"transparent\";\n    element.append(name);\n    return element;\n  }\n\n  static #createSeparatorElement() {\n    const element = document.createElement(\"hr\");\n    element.style.borderTop = \"1px dashed var(--color-border-default)\";\n    element.style.borderBottom = \"none\";\n    element.style.margin = \"0\";\n    return element;\n  }\n}\n"]}
{"filename": "src/components/linted-markdown-editor.ts", "chunked_list": ["import {\n  CodeMirrorRangeRectCalculator,\n  RangeRectCalculator,\n  TextareaRangeRectCalculator,\n} from \"../utilities/dom/range-rect-calculator\";\nimport {formatList} from \"../utilities/format\";\nimport {lintMarkdown} from \"../utilities/lint-markdown\";\nimport {LintErrorTooltip} from \"./lint-error-tooltip\";\nimport {LintErrorAnnotation} from \"./lint-error-annotation\";\nimport {Vector} from \"../utilities/geometry/vector\";", "import {LintErrorAnnotation} from \"./lint-error-annotation\";\nimport {Vector} from \"../utilities/geometry/vector\";\nimport {NumberRange} from \"../utilities/geometry/number-range\";\nimport {Component} from \"./component\";\n\nexport abstract class LintedMarkdownEditor extends Component {\n  #editor: HTMLElement;\n  #tooltip: LintErrorTooltip;\n  #resizeObserver: ResizeObserver;\n  #rangeRectCalculator: RangeRectCalculator;\n\n  #annotationsPortal = document.createElement(\"div\");\n  #statusContainer = LintedMarkdownEditor.#createStatusContainerElement();\n\n  constructor(\n    element: HTMLElement,\n    portal: HTMLElement,\n    rangeRectCalculator: RangeRectCalculator\n  ) {\n    super();\n\n    this.#editor = element;\n    this.#rangeRectCalculator = rangeRectCalculator;\n\n    portal.append(this.#annotationsPortal, this.#statusContainer);\n\n    this.addEventListener(element, \"focus\", this.onUpdate);\n    this.addEventListener(element, \"blur\", this.#onBlur);\n    this.addEventListener(element, \"mousemove\", this.#onMouseMove);\n    this.addEventListener(element, \"mouseleave\", this.#onMouseLeave);\n\n    // capture ancestor scroll events for nested scroll containers\n    this.addEventListener(document, \"scroll\", this.#onReposition, true);\n\n    // selectionchange can't be bound to the textarea so we have to use the document\n    this.addEventListener(document, \"selectionchange\", this.#onSelectionChange);\n\n    // annotations are document-relative so we need to observe document resize as well\n    this.addEventListener(window, \"resize\", this.#onReposition);\n\n    // this does mean it will run twice when the resize causes a resize of the textarea,\n    // but we also need the resize observer for the textarea because it's user resizable\n    this.#resizeObserver = new ResizeObserver(this.#onReposition);\n    this.#resizeObserver.observe(element);\n\n    this.#tooltip = new LintErrorTooltip(portal);\n  }\n\n  disconnect() {\n    super.disconnect();\n\n    this.#resizeObserver.disconnect();\n    this.#rangeRectCalculator.disconnect();\n    this.#tooltip.disconnect();\n\n    this.#annotationsPortal.remove();\n    this.#statusContainer.remove();\n  }\n\n  /**\n   * Return a list of rects for the given range. If the range extends over multiple lines,\n   * multiple rects will be returned.\n   */\n  getRangeRects(characterIndexes: NumberRange) {\n    return this.#rangeRectCalculator.getClientRects(characterIndexes);\n  }\n\n  getBoundingClientRect() {\n    return this.#editor.getBoundingClientRect();\n  }\n\n  getLineHeight() {\n    const parsed = parseInt(getComputedStyle(this.#editor).lineHeight, 10);\n    return Number.isNaN(parsed) ? undefined : parsed;\n  }\n\n  abstract get value(): string;\n\n  abstract get caretPosition(): number;\n\n  #_annotations: readonly LintErrorAnnotation[] = [];\n\n  set #annotations(annotations: ReadonlyArray<LintErrorAnnotation>) {", "    if (annotations === this.#_annotations) return;\n\n    this.#_annotations = annotations;\n\n    this.#statusContainer.textContent =\n      annotations.length > 0\n        ? `${annotations.length} Markdown problem${\n            annotations.length > 1 ? \"s\" : \"\"\n          } identified: see line${\n            annotations.length > 1 ? \"s\" : \"\"\n          } ${formatList(\n            annotations.map((a) => a.lineNumber.toString()),\n            \"and\"\n          )}`\n        : \"\";\n  }\n\n  get #annotations() {\n    return this.#_annotations;\n  }\n\n  #_tooltipAnnotations: readonly LintErrorAnnotation[] = [];\n\n  set #tooltipAnnotations(annotations: LintErrorAnnotation[]) {", "    if (annotations === this.#_tooltipAnnotations) return;\n\n    this.#_tooltipAnnotations = annotations;\n\n    const position = annotations[0]?.getTooltipPosition();\n    const errors = annotations.map(({error}) => error);\n\n    if (position) this.#tooltip.show(errors, position);\n    else this.#tooltip.hide();\n  }\n\n  protected onUpdate = () => this.#lint();\n\n  #isOnRepositionTick = false;\n  #onReposition = () => {", "    if (this.#isOnRepositionTick) return;\n    this.#isOnRepositionTick = true;\n\n    requestAnimationFrame(() => {\n      this.#recalculateAnnotationPositions();\n      this.#isOnRepositionTick = false;\n    });\n  };\n\n  #onBlur = () => this.#clear();\n\n  #onMouseMove = (event: MouseEvent) =>\n    this.#updatePointerTooltip(new Vector(event.clientX, event.clientY));\n\n  #onMouseLeave = () => (this.#tooltipAnnotations = []);\n\n  #onSelectionChange = () => {\n    // this event only works when applied to the document but we can filter it by detecting focus", "    if (document.activeElement === this.#editor) this.#updateCaretTooltip();\n  };\n\n  #clear() {\n    // the annotations will clean themselves up too but this is slightly faster\n    this.#annotationsPortal.replaceChildren();\n\n    for (const annotation of this.#annotations) annotation.disconnect();\n\n    this.#annotations = [];\n    this.#tooltipAnnotations = [];\n  }\n\n  #lint() {\n    this.#clear();\n\n    // clear() will not hide the tooltip if the mouse is over it, but if the user is typing then they are not trying to copy content\n    this.#tooltip.hide(true);\n", "    if (document.activeElement !== this.#editor) return;\n\n    const errors = lintMarkdown(this.value);\n\n    this.#annotations = errors.map(\n      (error) => new LintErrorAnnotation(error, this, this.#annotationsPortal)\n    );\n  }\n\n  #recalculateAnnotationPositions() {\n    for (const annotation of this.#annotations)\n      annotation.recalculatePosition();\n  }\n\n  #updatePointerTooltip(pointerLocation: Vector) {\n    // can't use mouse events on annotations (the easy way) because they have pointer-events: none\n    this.#tooltipAnnotations = this.#annotations.filter((a) =>\n      a.containsPoint(pointerLocation)\n    );\n  }\n\n  #updateCaretTooltip() {\n    this.#tooltipAnnotations = this.#annotations.filter((a) =>\n      a.containsIndex(this.caretPosition)\n    );\n  }\n\n  static #createStatusContainerElement() {\n    const container = document.createElement(\"p\");\n    container.setAttribute(\"aria-live\", \"polite\");\n    container.style.position = \"absolute\";\n    container.style.clipPath = \"circle(0)\";\n    return container;\n  }\n}\n", "    for (const annotation of this.#annotations)\n      annotation.recalculatePosition();\n  }\n\n  #updatePointerTooltip(pointerLocation: Vector) {\n    // can't use mouse events on annotations (the easy way) because they have pointer-events: none\n    this.#tooltipAnnotations = this.#annotations.filter((a) =>\n      a.containsPoint(pointerLocation)\n    );\n  }\n\n  #updateCaretTooltip() {\n    this.#tooltipAnnotations = this.#annotations.filter((a) =>\n      a.containsIndex(this.caretPosition)\n    );\n  }\n\n  static #createStatusContainerElement() {\n    const container = document.createElement(\"p\");\n    container.setAttribute(\"aria-live\", \"polite\");\n    container.style.position = \"absolute\";\n    container.style.clipPath = \"circle(0)\";\n    return container;\n  }\n}\n", "export class LintedMarkdownTextareaEditor extends LintedMarkdownEditor {\n  readonly #textarea: HTMLTextAreaElement;\n\n  constructor(textarea: HTMLTextAreaElement, portal: HTMLElement) {\n    super(textarea, portal, new TextareaRangeRectCalculator(textarea));\n    this.#textarea = textarea;\n    this.addEventListener(textarea, \"input\", this.onUpdate);\n  }\n\n  get value() {\n    return this.#textarea.value;\n  }\n\n  get caretPosition() {\n    return this.#textarea.selectionEnd !== this.#textarea.selectionStart\n      ? -1\n      : this.#textarea.selectionStart;\n  }\n}\n", "export class LintedMarkdownCodeMirrorEditor extends LintedMarkdownEditor {\n  readonly #element: HTMLElement;\n  readonly #mutationObserver: MutationObserver;\n\n  constructor(element: HTMLElement, portal: HTMLElement) {\n    super(element, portal, new CodeMirrorRangeRectCalculator(element));\n\n    this.#element = element;\n\n    this.#mutationObserver = new MutationObserver(this.onUpdate);\n    this.#mutationObserver.observe(element, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  override disconnect(): void {\n    super.disconnect();\n    this.#mutationObserver.disconnect();\n  }\n\n  get value() {\n    return Array.from(this.#element.querySelectorAll(\".CodeMirror-line\"))\n      .map((line) => line.textContent)\n      .join(\"\\n\");\n  }\n\n  get caretPosition() {\n    const selection = document.getSelection();\n    const range = selection?.getRangeAt(0);", "    if (!range?.collapsed || selection?.rangeCount !== 1) return -1;\n\n    const referenceRange = document.createRange();\n    referenceRange.selectNodeContents(this.#element);\n    referenceRange.setEnd(range.startContainer, range.startOffset);\n\n    return referenceRange.toString().length;\n  }\n}\n"]}
{"filename": "src/components/component.ts", "chunked_list": ["type EventName = keyof GlobalEventHandlersEventMap;\n\ntype EventHandler<Name extends EventName> = (\n  event: GlobalEventHandlersEventMap[Name]\n) => void;\n\ninterface EventDispatcher {\n  addEventListener<Name extends EventName>(\n    name: Name,\n    handler: EventHandler<Name>,\n    capture?: boolean\n  ): void;\n  removeEventListener<Name extends EventName>(\n    name: Name,\n    handler: EventHandler<Name>,\n    capture?: boolean\n  ): void;\n}\n", "type EventListener<in out Name extends EventName> = {\n  target: EventDispatcher;\n  name: Name;\n  capture?: boolean;\n  handler: EventHandler<Name>;\n};\n\nexport type ChildNode = string | Node;\n\nexport abstract class Component {\n  #eventListeners: Array<EventListener<EventName>> = [];\n\n  protected addEventListener<Name extends EventName>(\n    target: EventDispatcher,\n    name: Name,\n    handler: EventHandler<Name>,\n    capture?: boolean\n  ) {\n    target.addEventListener(name, handler, capture);\n    this.#eventListeners.push({\n      target,\n      name,\n      capture,\n      handler,\n    } as EventListener<EventName>);\n  }\n\n  disconnect() {", "export abstract class Component {\n  #eventListeners: Array<EventListener<EventName>> = [];\n\n  protected addEventListener<Name extends EventName>(\n    target: EventDispatcher,\n    name: Name,\n    handler: EventHandler<Name>,\n    capture?: boolean\n  ) {\n    target.addEventListener(name, handler, capture);\n    this.#eventListeners.push({\n      target,\n      name,\n      capture,\n      handler,\n    } as EventListener<EventName>);\n  }\n\n  disconnect() {", "    for (const {target, name, capture, handler} of this.#eventListeners)\n      target.removeEventListener(name, handler, capture);\n\n    this.#eventListeners = [];\n  }\n}\n"]}
{"filename": "src/utilities/lint-markdown.ts", "chunked_list": ["import markdownlint from \"markdownlint\";\nimport markdownlintGitHub from \"@github/markdownlint-github\";\n\nexport interface LintError extends markdownlint.LintError {\n  justification?: string;\n}\n\nexport const lintMarkdown = (markdown: string): LintError[] =>\n  markdownlint\n    .sync({\n      strings: {\n        content: markdown,\n      },\n      config: markdownlintGitHub.init({\n        default: false,\n        \"no-reversed-links\": true,\n        \"no-empty-links\": true,\n        // While enforcing a certain unordered list style can be somewhat helpful for making the Markdown source\n        // easier to read with a screen reader, this rule is ultimately too opinionated and noisy to be worth it,\n        // especially because it conflicts with the editor's bulleted list toolbar button.\n        \"ul-style\": false,\n      }),\n      handleRuleFailures: true,\n      customRules: markdownlintGitHub,\n    })\n    .content?.map((error) => ({\n      ...error,\n      justification: error.ruleNames\n        .map((name) => ruleJustifications[name])\n        .join(\" \"),\n    })) ?? [];\n\nexport const ruleJustifications: Partial<Record<string, string>> = {\n  \"heading-increment\":\n    \"A well-formed heading structure is key for navigating documents using accessibility tools.\",\n  \"fenced-code-language\":\n    \"Syntax highlighting in code blocks makes it easier for sighted readers to understand code.\",\n  \"no-alt-text\":\n    \"Images without alt text are invisible to non-sighted readers.\",\n  \"no-default-alt-text\":\n    \"Default alt text does not help non-sighted readers understand the image.\",\n  \"no-emphasis-as-header\":\n    \"Using headers to separate sections helps readers use accessibility tools to navigate documents.\",\n  \"ol-prefix\":\n    \"When reading Markdown source code, out-of-order lists make it more difficult for non-sighted users to understand how long a list is.\",\n};\n"]}
{"filename": "src/utilities/format.ts", "chunked_list": ["export function formatList(items: string[], conjunction: string) {\n  if (items.length > 2) {\n    items.push(`${conjunction} ${items.pop()}`);\n    return items.join(\", \");\n  } else if (items.length === 2) {\n    const last = items.pop();\n    const secondLast = items.pop();\n    return [secondLast, conjunction, last].join(\" \");\n  } else {\n    return items[0];\n  }\n}\n"]}
{"filename": "src/utilities/dom/observe-selector.ts", "chunked_list": ["/**\n * Watch the document DOM for the selector.\n */\nexport function observeSelector(\n  selector: string,\n  onAdd: (element: HTMLElement) => () => void\n) {\n  const removeHandlers = new Map<HTMLElement, () => void>();\n\n  for (const element of document.querySelectorAll(selector))\n    if (element instanceof HTMLElement)\n      removeHandlers.set(element, onAdd(element));\n\n  const observer = new MutationObserver(() => {\n    const found = new Set<HTMLElement>();\n\n    // handle new elements", "  for (const element of document.querySelectorAll(selector))\n    if (element instanceof HTMLElement)\n      removeHandlers.set(element, onAdd(element));\n\n  const observer = new MutationObserver(() => {\n    const found = new Set<HTMLElement>();\n\n    // handle new elements\n    for (const element of document.querySelectorAll(selector))\n      if (element instanceof HTMLElement) {\n        found.add(element);\n", "    for (const element of document.querySelectorAll(selector))\n      if (element instanceof HTMLElement) {\n        found.add(element);\n\n        if (!removeHandlers.has(element))\n          removeHandlers.set(element, onAdd(element));\n      }\n\n    // handle removed elements\n    for (const [element, onRemove] of removeHandlers.entries())\n      if (!found.has(element)) {\n        onRemove();\n        removeHandlers.delete(element);\n      }\n  });\n\n  observer.observe(document, {\n    childList: true,\n    subtree: true,\n  });\n}\n", "    for (const [element, onRemove] of removeHandlers.entries())\n      if (!found.has(element)) {\n        onRemove();\n        removeHandlers.delete(element);\n      }\n  });\n\n  observer.observe(document, {\n    childList: true,\n    subtree: true,\n  });\n}\n"]}
{"filename": "src/utilities/dom/index.ts", "chunked_list": ["import {Vector} from \"../geometry/vector\";\n\nexport const getWindowScrollVector = () =>\n  new Vector(window.scrollX, window.scrollY);\n\nexport const isHighContrastMode = () => {\n  const documentColorMode = document.documentElement.dataset.colorMode;\n  const resolvedColorMode =\n    documentColorMode === \"auto\"\n      ? window.matchMedia(\"prefers-color-scheme: dark\").matches", "    documentColorMode === \"auto\"\n      ? window.matchMedia(\"prefers-color-scheme: dark\").matches\n        ? \"dark\"\n        : \"light\"\n      : documentColorMode;\n  const resolvedColorScheme =\n    resolvedColorMode === \"dark\"\n      ? document.documentElement.dataset.darkTheme\n      : document.documentElement.dataset.lightTheme;\n", "      : document.documentElement.dataset.lightTheme;\n\n  return (\n    (window.matchMedia(\"(forced-colors: active)\").matches ||\n      resolvedColorScheme?.includes(\"high_contrast\")) ??\n    false\n  );\n};\n", ""]}
{"filename": "src/utilities/dom/range-rect-calculator.ts", "chunked_list": ["import {NumberRange} from \"../geometry/number-range\";\nimport {Rect} from \"../geometry/rect\";\nimport {Vector} from \"../geometry/vector\";\n\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst propertiesToCopy = [\n  \"direction\", // RTL support\n  \"boxSizing\",", "  \"direction\", // RTL support\n  \"boxSizing\",\n  \"width\", // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  \"height\",\n  \"overflowX\",\n  \"overflowY\", // copy the scrollbar for IE\n\n  \"borderTopWidth\",\n  \"borderRightWidth\",\n  \"borderBottomWidth\",", "  \"borderRightWidth\",\n  \"borderBottomWidth\",\n  \"borderLeftWidth\",\n  \"borderStyle\",\n\n  \"paddingTop\",\n  \"paddingRight\",\n  \"paddingBottom\",\n  \"paddingLeft\",\n", "  \"paddingLeft\",\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  \"fontStyle\",\n  \"fontVariant\",\n  \"fontWeight\",\n  \"fontStretch\",\n  \"fontSize\",\n  \"fontSizeAdjust\",\n  \"lineHeight\",", "  \"fontSizeAdjust\",\n  \"lineHeight\",\n  \"fontFamily\",\n\n  \"textAlign\",\n  \"textTransform\",\n  \"textIndent\",\n  \"textDecoration\", // might not make a difference, but better be safe\n\n  \"letterSpacing\",", "\n  \"letterSpacing\",\n  \"wordSpacing\",\n\n  \"tabSize\",\n  \"MozTabSize\" as \"tabSize\", // prefixed version for Firefox <= 52\n] as const satisfies ReadonlyArray<keyof CSSStyleDeclaration>;\n\nexport interface RangeRectCalculator {\n  /**\n   * Return the viewport-relative client rects of the range of characters. If the range\n   * has any line breaks, this will return multiple rects. Will include the start char and\n   * exclude the end char.\n   */\n  getClientRects({start, end}: NumberRange): Rect[];\n  disconnect(): void;\n}\n\n/**\n * The `Range` API doesn't work well with `textarea` elements, so this creates a duplicate\n * element and uses that instead. Provides a limited API wrapping around adjusted `Range`\n * APIs.\n */", "export interface RangeRectCalculator {\n  /**\n   * Return the viewport-relative client rects of the range of characters. If the range\n   * has any line breaks, this will return multiple rects. Will include the start char and\n   * exclude the end char.\n   */\n  getClientRects({start, end}: NumberRange): Rect[];\n  disconnect(): void;\n}\n\n/**\n * The `Range` API doesn't work well with `textarea` elements, so this creates a duplicate\n * element and uses that instead. Provides a limited API wrapping around adjusted `Range`\n * APIs.\n */", "export class TextareaRangeRectCalculator implements RangeRectCalculator {\n  readonly #element: HTMLTextAreaElement;\n  readonly #div: HTMLDivElement;\n  readonly #mutationObserver: MutationObserver;\n  readonly #resizeObserver: ResizeObserver;\n  readonly #range: Range;\n\n  constructor(target: HTMLTextAreaElement) {\n    this.#element = target;\n\n    // The mirror div will replicate the textarea's style\n    const div = document.createElement(\"div\");\n    this.#div = div;\n    document.body.appendChild(div);\n\n    this.#refreshStyles();\n\n    this.#mutationObserver = new MutationObserver(() => this.#refreshStyles());\n    this.#mutationObserver.observe(this.#element, {\n      attributeFilter: [\"style\"],\n    });\n\n    this.#resizeObserver = new ResizeObserver(() => this.#refreshStyles());\n    this.#resizeObserver.observe(this.#element);\n\n    this.#range = document.createRange();\n  }\n\n  /**\n   * Return the viewport-relative client rects of the range. If the range has any line\n   * breaks, this will return multiple rects. Will include the start char and exclude the\n   * end char.\n   */\n  getClientRects({start, end}: NumberRange) {\n    this.#refreshText();\n\n    const textNode = this.#div.childNodes[0];", "    if (!textNode) return [];\n\n    this.#range.setStart(textNode, start);\n    this.#range.setEnd(textNode, end);\n\n    // The div is not in the same place as the textarea so we need to subtract the div\n    // position and add the textarea position\n    const divPosition = new Rect(this.#div.getBoundingClientRect()).asVector();\n    const textareaPosition = new Rect(\n      this.#element.getBoundingClientRect()\n    ).asVector();\n\n    // The div is not scrollable so it does not have scroll adjustment built in\n    const scrollOffset = new Vector(\n      this.#element.scrollLeft,\n      this.#element.scrollTop\n    );\n\n    const netTranslate = divPosition\n      .negate()\n      .plus(textareaPosition)\n      .minus(scrollOffset);\n\n    return Array.from(this.#range.getClientRects()).map((domRect) =>\n      new Rect(domRect).translate(netTranslate)\n    );\n  }\n\n  disconnect() {\n    this.#div.remove();\n  }\n\n  #refreshStyles() {\n    const style = this.#div.style;\n    const textareaStyle = window.getComputedStyle(this.#element);\n\n    // Default wrapping styles\n    style.whiteSpace = \"pre-wrap\";\n    style.wordWrap = \"break-word\";\n\n    // Position off-screen\n    style.position = \"fixed\";\n    style.top = \"0\";\n    style.transform = \"translateY(-100%)\";\n\n    const isFirefox = \"mozInnerScreenX\" in window;\n\n    // Transfer the element's properties to the div", "    for (const prop of propertiesToCopy)\n      if (prop === \"width\" && textareaStyle.boxSizing === \"border-box\") {\n        // With box-sizing: border-box we need to offset the size slightly inwards.  This small difference can compound\n        // greatly in long textareas with lots of wrapping, leading to very innacurate results if not accounted for.\n        // Firefox will return computed styles in floats, like `0.9px`, while chromium might return `1px` for the same element.\n        // Either way we use `parseFloat` to turn `0.9px` into `0.9` and `1px` into `1`\n        const totalBorderWidth =\n          parseFloat(textareaStyle.borderLeftWidth) +\n          parseFloat(textareaStyle.borderRightWidth);\n        // When a vertical scrollbar is present it shrinks the content. We need to account for this by using clientWidth\n        // instead of width in everything but Firefox. When we do that we also have to account for the border width.\n        const width = isFirefox\n          ? parseFloat(textareaStyle.width) - totalBorderWidth\n          : this.#element.clientWidth + totalBorderWidth;\n        style.width = `${width}px`;\n      } else {\n        style[prop] = textareaStyle[prop];\n      }\n", "    if (isFirefox) {\n      // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n      if (this.#element.scrollHeight > parseInt(textareaStyle.height))\n        style.overflowY = \"scroll\";\n    } else {\n      style.overflow = \"hidden\"; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n    }\n  }\n\n  #refreshText() {\n    this.#div.textContent =\n      this.#element instanceof HTMLInputElement\n        ? this.#element.value.replace(/\\s/g, \"\\u00a0\")\n        : this.#element.value;\n  }\n}\n", "export class CodeMirrorRangeRectCalculator implements RangeRectCalculator {\n  readonly #element: HTMLElement;\n  readonly #range: Range;\n\n  constructor(target: HTMLElement) {\n    if (!target.classList.contains(\"CodeMirror-code\"))\n      throw new Error(\n        \"CodeMirrorRangeRectCalculator only works with CodeMirror code editors.\"\n      );\n\n    this.#element = target;\n    this.#range = document.createRange();\n  }\n\n  getClientRects(range: NumberRange): Rect[] {\n    const lineNodes = Array.from(\n      this.#element.querySelectorAll(\".CodeMirror-line\")\n    );\n    const lines = lineNodes.map((line) =>\n      CodeMirrorRangeRectCalculator.#getAllTextNodes(line)\n    );\n\n    const start = CodeMirrorRangeRectCalculator.#getNodeAtOffset(\n      lines,\n      range.start\n    );\n    const end = CodeMirrorRangeRectCalculator.#getNodeAtOffset(\n      lines,\n      range.end\n    );\n", "    if (!start || !end) return [];\n\n    this.#range.setStart(...start);\n    this.#range.setEnd(...end);\n\n    return Array.from(this.#range.getClientRects()).map(\n      (domRect) => new Rect(domRect)\n    );\n  }\n\n  disconnect(): void {}\n\n  static #getAllTextNodes(node: Node): Node[] {\n    const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);\n    const nodes = [];", "    while (walker.nextNode()) nodes.push(walker.currentNode);\n    return nodes;\n  }\n\n  /**\n   * Get the text node containing the offset, and the relative offset into that node.\n   * @param lines Array of nodes for each line\n   * @param offset Offset into the entire text\n   */\n  static #getNodeAtOffset(\n    lines: Node[][],\n    offset: number\n  ): [node: Node, offsetIntoNode: number] | undefined {\n    let prevChars = 0;", "    for (const line of lines) {\n      for (const node of line) {\n        const length = node.textContent?.length ?? 0;\n        if (offset <= prevChars + length) return [node, offset - prevChars];\n        prevChars += length;\n      }\n      prevChars++; // For the newline\n    }\n  }\n}\n"]}
{"filename": "src/utilities/geometry/rect.ts", "chunked_list": ["import {NumberRange} from \"./number-range\";\nimport {Vector} from \"./vector\";\n\ntype RectParams = Pick<DOMRect, \"x\" | \"y\" | \"height\" | \"width\">;\n\n/** Represents a rectangle, typically the bounding box for an HTML element. */\nexport class Rect implements DOMRect {\n  readonly height: number;\n  readonly width: number;\n  readonly x: number;\n  readonly y: number;\n\n  constructor({x, y, height, width}: RectParams) {\n    this.x = x;\n    this.y = y;\n    this.height = height;\n    this.width = width;\n  }\n\n  copy({\n    x = this.x,\n    y = this.y,\n    height = this.height,\n    width = this.width,\n  }: Partial<RectParams>) {\n    return new Rect({x, y, height, width});\n  }\n\n  toJSON() {\n    JSON.stringify({\n      top: this.top,\n      bottom: this.bottom,\n      left: this.left,\n      right: this.right,\n      x: this.x,\n      y: this.y,\n      height: this.height,\n      width: this.width,\n    });\n  }\n\n  /**\n   * Return `true` if `rect` is entirely contained by `otherRect`.\n   */\n  isContainedBy(other: Rect) {\n    return (\n      other.contains(this.asVector(\"top-left\")) &&\n      other.contains(this.asVector(\"bottom-right\"))\n    );\n  }\n\n  contains(point: Vector) {\n    return (\n      this.xRange.contains(point.x, \"inclusive\") &&\n      this.yRange.contains(point.y, \"inclusive\")\n    );\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get right() {\n    return this.left + this.width;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  get bottom() {\n    return this.top + this.height;\n  }\n\n  get xRange() {\n    return new NumberRange(this.left, this.right);\n  }\n\n  get yRange() {\n    return new NumberRange(this.top, this.bottom);\n  }\n\n  asVector(\n    corner:\n      | \"top-left\"\n      | \"top-right\"\n      | \"bottom-left\"\n      | \"bottom-right\" = \"top-left\"\n  ) {\n    switch (corner) {\n      case \"top-left\":\n        return new Vector(this.left, this.top);\n      case \"top-right\":\n        return new Vector(this.right, this.top);\n      case \"bottom-left\":\n        return new Vector(this.left, this.bottom);\n      case \"bottom-right\":\n        return new Vector(this.right, this.bottom);\n    }\n  }\n\n  translate(vector: Vector) {\n    return this.copy(this.asVector().plus(vector));\n  }\n\n  scaleY(factor: number) {\n    const scaledHeight = this.height * factor;\n    const deltaY = (this.height - scaledHeight) / 2;\n    return this.translate(new Vector(0, deltaY)).copy({height: scaledHeight});\n  }\n}\n"]}
{"filename": "src/utilities/geometry/vector.ts", "chunked_list": ["/** Represents a 2D vector or point. */\nexport class Vector {\n  constructor(readonly x: number, readonly y: number) {}\n\n  plus(other: Vector) {\n    return new Vector(this.x + other.x, this.y + other.y);\n  }\n\n  minus(other: Vector) {\n    return this.plus(other.negate());\n  }\n\n  negate() {\n    return new Vector(-this.x, -this.y);\n  }\n}\n"]}
{"filename": "src/utilities/geometry/number-range.ts", "chunked_list": ["export class NumberRange {\n  readonly start: number;\n  readonly end: number;\n\n  constructor(start: number, end: number) {\n    this.start = Math.min(start, end);\n    this.end = Math.max(start, end);\n  }\n\n  contains(\n    value: number,\n    mode:\n      | \"inclusive\"\n      | \"exclusive\"\n      | \"start-inclusive-end-exclusive\"\n      | \"start-exclusive-end-inclusive\"\n  ) {\n    switch (mode) {\n      case \"inclusive\":\n        return value >= this.start && value <= this.end;\n      case \"exclusive\":\n        return value > this.start && value < this.end;\n      case \"start-inclusive-end-exclusive\":\n        return value >= this.start && value < this.end;\n      case \"start-exclusive-end-inclusive\":\n        return value > this.start && value <= this.end;\n    }\n  }\n}\n"]}
