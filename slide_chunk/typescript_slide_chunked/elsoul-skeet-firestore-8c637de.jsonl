{"filename": "release.ts", "chunked_list": ["import * as pjson from './package.json'\nimport * as fsPromise from 'fs/promises'\n\nconsole.log(`updated version to ${pjson.version}`)\n\nconst versionString = `export const VERSION = '${pjson.version}'`\n\nconst fileWrite = async () => {\n  await fsPromise.writeFile('./src/lib/version.ts', versionString, {\n    flag: 'w',", "  await fsPromise.writeFile('./src/lib/version.ts', versionString, {\n    flag: 'w',\n  })\n}\n\nfileWrite()\n"]}
{"filename": "tests/check.test.ts", "chunked_list": ["import { skeetTest } from './jest.setup'\ntest('check', () => {\n  console.log(skeetTest)\n  console.log('OK')\n})\n"]}
{"filename": "tests/jest.setup.ts", "chunked_list": ["export const skeetTest = 'test'\n"]}
{"filename": "dist/esm/index.d.ts", "chunked_list": ["export { createDataRef, createFirestoreDataConverter, getCollectionItem as get, addCollectionItem as add, serverTimestamp, createCollectionRef, addMultipleCollectionItems as adds, queryCollectionItems as query, updateCollectionItem as update, deleteCollectionItem as delete, } from './lib';\nexport { Timestamp, FieldValue } from 'firebase/firestore';\n"]}
{"filename": "dist/esm/utils/time.d.ts", "chunked_list": ["export declare function sleep(ms: number): Promise<unknown>;\nexport declare const utcNow: (formatType?: number) => string;\nexport declare const formatTime: (ms: number) => string;\nexport declare const getTimestamp: () => string;\n"]}
{"filename": "dist/esm/lib/getCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Retrieves a document from Firestore based on the provided document reference.\n *\n * @param dataRef - The document reference pointing to the desired Firestore document.\n *\n * @returns The data of the document as an object of type T.\n *\n * @throws Throws an exception if the document doesn't exist or if there is no data in the document.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import * as admin from 'firebase-admin'\n * import { get } from '@skeet-framework/firestore'\n *\n * const db = admin.firestore();\n *", " * async function run() {\n *   try {\n *     const db = admin.firestore();\n *     const path = 'Users'\n *     const id = 'user123'\n *     const user = await get<User>(db, path, id)\n *     console.log(`Retrieved user: ${user.name}, age: ${user.age}`)\n *   } catch (error) {\n *     console.error(`Error retrieving document: ${error}`)\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const getCollectionItem: <T>(db: firestore.Firestore, collectionPath: string, docId: string) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/deleteCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Deletes a document from the specified collection in Firestore.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection containing the document to be deleted.\n * @param docId - The ID of the document to be deleted.\n *\n * @returns A boolean indicating the success of the delete operation.\n *", " * @returns A boolean indicating the success of the delete operation.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import * as admin from 'firebase-admin'\n * import { delete } from '@skeet-framework/firestore'\n *", " * import { delete } from '@skeet-framework/firestore'\n *\n * const db = admin.firestore();\n *\n * async function run() {\n *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await delete(db, path, docId);\n *     if (success) {\n *       console.log(`Document with ID ${docId} deleted successfully.`);\n *     }", " *     if (success) {\n *       console.log(`Document with ID ${docId} deleted successfully.`);\n *     }\n *   } catch (error) {\n *     console.error(`Error deleting document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const deleteCollectionItem: (db: firestore.Firestore, collectionPath: string, docId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/getFirestoreData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const getFirestoreData: <T>(dataRef: firestore.DocumentReference<T>) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/version.d.ts", "chunked_list": ["export declare const VERSION = \"2.1.1\";\n"]}
{"filename": "dist/esm/lib/createDataRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const createDataRef: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.DocumentReference<T>;\n"]}
{"filename": "dist/esm/lib/updateCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Updates the specified document in the provided Firestore collection with the given data.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection containing the document to be updated.\n * @param docId - The ID of the document to be updated.\n * @param params - The data to update the document with.\n *\n * @returns A boolean indicating the success of the update operation.", " *\n * @returns A boolean indicating the success of the update operation.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { update } from '@skeet-framework/firestore'\n *", " * import { update } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const updatedData: firestore.UpdateData<User> = {\n *   age: 31\n * };\n *\n * async function run() {\n *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await update<User>(db, path, docId, updatedData);", " *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await update<User>(db, path, docId, updatedData);\n *     if (success) {\n *       console.log(`Document with ID ${docId} updated successfully.`);\n *     }\n *   } catch (error) {\n *     console.error(`Error updating document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const updateCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, docId: string, params: firestore.UpdateData<T>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/createFirestoreDataConverter.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const createFirestoreDataConverter: <T extends firestore.DocumentData>() => firestore.FirestoreDataConverter<T>;\n"]}
{"filename": "dist/esm/lib/createCollectionRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nimport { DocumentData } from 'firebase/firestore';\nexport declare const createCollectionRef: <T extends DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.CollectionReference<T>;\n"]}
{"filename": "dist/esm/lib/addMultipleCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Adds multiple documents to the specified collection in Firestore.\n * This function supports batched writes, and if the number of items exceeds the maximum batch size (500),\n * it will split the items into multiple batches and write them sequentially.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection to which the documents will be added.\n * @param items - An array of document data to be added.\n *\n * @returns An array of WriteResult arrays corresponding to each batch.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { adds } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const users: User[] = [\n *   { name: \"John Doe\", age: 30 },\n *   { name: \"Jane Smith\", age: 25 },\n *   // ... more users ...\n * ];\n *", " * async function run() {\n *   try {\n *     const path = 'Users'\n *     const results = await adds<User>(db, path, users);\n *     console.log(`Added ${users.length} users in ${results.length} batches.`);\n *   } catch (error) {\n *     console.error(`Error adding documents: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const addMultipleCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, items: T[]) => Promise<firestore.WriteResult[][]>;\n"]}
{"filename": "dist/esm/lib/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\nexport * from './createDataRef';\nexport * from './createFirestoreDataConverter';\nexport * from './serverTimestamp';\nexport * from './getCollectionItem';\nexport * from './createCollectionRef';\nexport * from './addMultipleCollectionItems';\nexport * from './queryCollectionItems';\nexport * from './updateCollectionItem';\nexport * from './deleteCollectionItem';", "export * from './updateCollectionItem';\nexport * from './deleteCollectionItem';\n"]}
{"filename": "dist/esm/lib/queryCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Represents a condition for querying Firestore collections.\n */\ntype QueryCondition = {\n    field?: string;\n    operator?: firestore.WhereFilterOp;\n    value?: any;\n    orderDirection?: firestore.OrderByDirection;\n    limit?: number;\n};\n/**\n * Queries the specified collection in Firestore based on the provided conditions\n * and returns an array of documents that match the conditions.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection to be queried.\n * @param conditions - An array of conditions to apply to the query.\n *\n * @returns An array of documents from the collection that match the conditions.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { query } from '@skeet-framework/firestore'\n * const db = firestore();\n *\n * // Simple query to get users over 25 years old\n * const simpleConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 }\n * ];\n *\n * // Advanced query to get users over 25 years old, ordered by their names\n * const advancedConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 },\n *   { field: \"name\", orderDirection: \"asc\" }\n * ];\n *\n * // Query to get users over 25 years old and limit the results to 5\n * const limitedConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 },\n *   { limit: 5 }\n * ];\n *", " * async function run() {\n *   try {\n *     const path = 'Users';\n *\n *     // Using the simple conditions\n *     const usersByAge = await query<User>(db, path, simpleConditions);\n *     console.log(`Found ${usersByAge.length} users over 25 years old.`);\n *\n *     // Using the advanced conditions\n *     const orderedUsers = await query<User>(db, path, advancedConditions);\n *     console.log(`Found ${orderedUsers.length} users over 25 years old, ordered by name.`);\n *\n *     // Using the limited conditions\n *     const limitedUsers = await query<User>(db, path, limitedConditions);\n *     console.log(`Found ${limitedUsers.length} users over 25 years old, limited to 5.`);\n *", " *   } catch (error) {\n *     console.error(`Error querying collection: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const queryCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, conditions: QueryCondition[]) => Promise<T[]>;\nexport {};\n"]}
{"filename": "dist/esm/lib/serverTimestamp.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const serverTimestamp: () => firestore.FieldValue;\n"]}
{"filename": "dist/esm/lib/getCollectionItemData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nimport * as admin from 'firebase-admin';\nexport declare const getCollectionItemData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/addCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Adds a new document to the specified collection in Firestore. If an ID is provided, the document will be set with that ID; otherwise, an ID will be automatically generated.\n *\n * @param db - The instance of the Firestore database to interact with.\n * @param collectionPath - The path of the collection where the document will be added or set.\n * @param params - The data of the document to be added or set.\n * @param id - Optional. If provided, the document will be set with this ID. If not, an ID will be automatically generated by Firestore.\n *\n * @returns A reference to the added or set document.", " *\n * @returns A reference to the added or set document.\n *\n * @throws Throws an exception if any error occurs during the document addition or setting process.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { add } from '@skeet-framework/firestore'\n *", " * import { add } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const data: User = {\n *   name: \"John Doe\",\n *   age: 30\n * };\n *\n * async function run() {\n *   try {\n *     const path = 'Users';\n *     // Example without providing an ID:\n *     const docRef1 = await add<User>(db, path, data);\n *     console.log(`Document added with ID: ${docRef1.id}`);\n *\n *     // Example with providing an ID:\n *     const customID = 'custom_user_id';\n *     const docRef2 = await add<User>(db, path, data, customID);\n *     console.log(`Document set with ID: ${docRef2.id}`);", " * async function run() {\n *   try {\n *     const path = 'Users';\n *     // Example without providing an ID:\n *     const docRef1 = await add<User>(db, path, data);\n *     console.log(`Document added with ID: ${docRef1.id}`);\n *\n *     // Example with providing an ID:\n *     const customID = 'custom_user_id';\n *     const docRef2 = await add<User>(db, path, data, customID);\n *     console.log(`Document set with ID: ${docRef2.id}`);", " *   } catch (error) {\n *     console.error(`Error processing document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const addCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, params: T, id?: string) => Promise<firestore.DocumentReference<T>>;\n"]}
{"filename": "dist/esm/lib/getFirestoreModelData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nimport * as admin from 'firebase-admin';\nexport declare const getFirestoreModelData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/crypt/encrypt.d.ts", "chunked_list": ["export declare const encrypt: (data: string, iv: string, password: string, salt: string) => string;\nexport declare const decrypt: (data: string, iv: string, password: string, salt: string) => string;\nexport declare const generateIv: () => string;\n"]}
{"filename": "dist/esm/lib/crypt/index.d.ts", "chunked_list": ["export * from './encrypt';\n"]}
{"filename": "dist/esm/lib/add/addChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addChildCollectionItem` is a function to add an item to a specified child Firestore collection.\n *\n * @template Child - Type of the object to be saved in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * @param {string} childCollectionName - Name of the child Firestore collection.\n * @param {string} parentId - Document ID of the parent collection item.\n * @param {Child} params - Data to be saved in the child Firestore collection.\n * @param {string} [id] - Document ID for the child collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<Child>>} - Reference to the added item in the child collection.\n *\n * @example\n * ```typescript\n * import { addChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'User';\n * const childCollectionName = 'Orders';\n * const parentId = 'XXX';\n *\n * // Retrieve the parent document reference\n * const parentDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n *\n * // Prepare child collection data\n * const orderParams = {\n *   parent: parentDoc.ref,\n *   orderId: '123',\n *   product: 'Some Product',\n *   quantity: 2,\n * }\n *\n * // Add item to the child collection\n * const orderRef = await addChildCollectionItem<Order, User>(\n *   parentCollectionName,\n *   childCollectionName,\n *   parentId,\n *   orderParams,\n *   orderParams.orderId\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, params: Child, id?: string) => Promise<Ref<Child>>;\n"]}
{"filename": "dist/esm/lib/add/addGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addGrandGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grand-grandchild Firestore collection.\n *\n * @template GrandGrandGrandChild - Type of the object to be saved in the grand-grand-grandchild Firestore collection.\n * @template GrandGrandChild - Type of the object in the grand-grandchild Firestore collection.\n * @template GrandChild - Type of the object in the grandchild Firestore collection.\n * @template Child - Type of the object in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * ... [other parameters]\n * @param {GrandGrandGrandChild} params - Data to be saved in the grand-grand-grandchild Firestore collection.\n * @param {string} [id] - Document ID for the grand-grand-grandchild collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<GrandGrandGrandChild>>} - Reference to the added item in the grand-grand-grandchild collection.\n *\n * @example\n * ```typescript\n * import { addGrandGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'Planet';\n * ... [other collection names]\n * const grandGrandGrandChildCollectionName = 'House';\n * const parentId = 'Earth';\n * ... [other IDs]\n * const grandGrandChildId = 'MainStreet';\n *\n * const grandGrandChildDoc = await getGrandGrandChildCollectionItem<Street, City, State, Country>(\n *  parentCollectionName,\n *  childCollectionName,\n *  grandChildCollectionName,\n *  grandGrandChildCollectionName,\n *  parentId,\n *  childId,\n *  grandChildId\n * )\n *\n * const houseParams = {\n *   grandGrandChild: grandGrandChildDoc.ref,\n *   houseNumber: '123',\n *   color: 'Blue',\n *   residents: 4,\n * }\n *\n * const houseRef = await addGrandGrandGrandChildCollectionItem<House, Street, City, State, Country>(\n *   parentCollectionName,\n *   childCollectionName,\n *   ... [other collection names and IDs],\n *   houseParams,\n *   houseParams.houseNumber\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: GrandGrandGrandChild, id?: string) => Promise<Ref<GrandGrandGrandChild>>;\n"]}
{"filename": "dist/esm/lib/add/addGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addGrandChildCollectionItem` is a function to add an item to a specified grandchild Firestore collection.\n *\n * @template GrandChild - Type of the object to be saved in the grandchild Firestore collection.\n * @template Child - Type of the object in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * @param {string} childCollectionName - Name of the child Firestore collection.\n * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n * @param {string} parentId - Document ID of the parent collection item.\n * @param {string} childId - Document ID of the child collection item.\n * @param {GrandChild} params - Data to be saved in the grandchild Firestore collection.\n * @param {string} [id] - Document ID for the grandchild collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<GrandChild>>} - Reference to the added item in the grandchild collection.\n *\n * @example\n * ```typescript\n * import { addGrandChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'User';\n * const childCollectionName = 'Orders';\n * const grandChildCollectionName = 'Items';\n * const parentId = 'XXX';\n * const childId = 'YYY';\n * const userDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n * const orderDoc = await getChildCollectionItem<Order, User>(\n *  parentCollectionName,\n *  childCollectionName,\n *  parentId,\n *  childId\n * )\n *\n * const itemParams = {\n *   child: orderDoc.ref,\n *   itemId: '123',\n *   productName: 'Some Product',\n *   quantity: 2,\n * }\n *\n * const itemRef = await addGrandChildCollectionItem<Item, Order, User>(\n *   parentCollectionName,\n *   childCollectionName,\n *   grandChildCollectionName,\n *   parentId,\n *   childId,\n *   itemParams,\n *   itemParams.itemId\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, params: GrandChild, id?: string) => Promise<Ref<GrandChild>>;\n"]}
{"filename": "dist/esm/lib/add/addGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grandchild Firestore collection.\n *\n * @template GrandGrandChild - Type of the object to be saved in the grand-grandchild Firestore collection.\n * @template GrandChild - Type of the object in the grandchild Firestore collection.\n * @template Child - Type of the object in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * @param {string} childCollectionName - Name of the child Firestore collection.\n * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n * @param {string} grandGrandChildCollectionName - Name of the grand-grandchild Firestore collection.\n * @param {string} parentId - Document ID of the parent collection item.\n * @param {string} childId - Document ID of the child collection item.\n * @param {string} grandChildId - Document ID of the grandchild collection item.\n * @param {GrandGrandChild} params - Data to be saved in the grand-grandchild Firestore collection.\n * @param {string} [id] - Document ID for the grand-grandchild collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<GrandGrandChild>>} - Reference to the added item in the grand-grandchild collection.\n *\n * @example\n * ```typescript\n * import { addGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'Country';\n * const childCollectionName = 'State';\n * const grandChildCollectionName = 'City';\n * const grandGrandChildCollectionName = 'Street';\n * const parentId = 'US';\n * const childId = 'CA';\n * const grandChildId = 'LA';\n * const parentDoc = await getCollectionItem<Country>(parentCollectionName, parentId)\n * const childDoc = await getChildCollectionItem<State, Country>(\n *  parentCollectionName,\n *  childCollectionName,\n *  parentId,\n *  childId\n * )\n * const grandChildDoc = await getGrandChildCollectionItem<City, State, Country>(\n *  parentCollectionName,\n *  childCollectionName,\n *  grandChildCollectionName,\n *  parentId,\n *  childId,\n *  grandChildId\n * )\n *\n * const streetParams = {\n *   grandChild: grandChildDoc.ref,\n *   streetName: 'Sunset Blvd',\n *   zipCode: '90028',\n * }\n *\n * const streetRef = await addGrandGrandChildCollectionItem<Street, City, State, Country>(\n *   parentCollectionName,\n *   childCollectionName,\n *   grandChildCollectionName,\n *   grandGrandChildCollectionName,\n *   parentId,\n *   childId,\n *   grandChildId,\n *   streetParams,\n *   streetParams.streetName\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: GrandGrandChild, id?: string) => Promise<Ref<GrandGrandChild>>;\n"]}
{"filename": "dist/esm/lib/add/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\nexport * from './addChildCollectionItem';\nexport * from './addGrandChildCollectionItem';\nexport * from './addGrandGrandChildCollectionItem';\nexport * from './addGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/add/addCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addCollectionItem` is a function to add an item to a specified Firestore collection.\n *\n * @template T - Type of the object to be saved in Firestore.\n *\n * @param {string} collectionName - Name of the Firestore collection.\n * @param {T} params - Data to be saved in Firestore.\n * @param {string} [id] - Document ID. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<T>>} - Reference to the added item.\n *\n * @example\n * ```typescript\n * import { addCollectionItem } from '@skeet-framework/firestore'\n * import { User } from '@/models'\n *\n * const userParams = {\n *   uid: 'XXX',\n *   email: 'info@epics.dev',\n *   username: 'EpicsDAO',\n * }\n *\n * const userRef = await addCollectionItem<User>('User', userParams, userParams.uid)\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addCollectionItem: <T>(collectionName: string, params: T, id?: string) => Promise<Ref<T>>;\n"]}
{"filename": "dist/esm/lib/typesaurus/index.d.ts", "chunked_list": ["export * from './ref';\n"]}
{"filename": "dist/esm/lib/typesaurus/ref.d.ts", "chunked_list": ["import { Collection } from 'typesaurus';\nexport interface Ref<Model> {\n    __type__: 'ref';\n    collection: Collection<Model>;\n    id: string;\n}\n"]}
{"filename": "dist/esm/lib/query/queryCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryCollectionItem: <Parent>(collectionName: string, queries: Query<Parent, keyof Parent>[]) => Promise<import(\"typesaurus\").Doc<Parent>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, queries: Query<GrandChild, keyof GrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandChild>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string, queries: Query<GrandGrandGrandChild, keyof GrandGrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, queries: Query<GrandGrandChild, keyof GrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandChild>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, queries: Query<Child, keyof Child>[]) => Promise<import(\"typesaurus\").Doc<Child>[]>;\n"]}
{"filename": "dist/esm/lib/query/index.d.ts", "chunked_list": ["export * from './queryCollectionItem';\nexport * from './queryChildCollectionItem';\nexport * from './queryGrandChildCollectionItem';\nexport * from './queryGrandGrandChildCollectionItem';\nexport * from './queryGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/get/getChildCollectionItem.d.ts", "chunked_list": ["export declare const getChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<import(\"typesaurus\").Doc<Child> | null>;\n"]}
{"filename": "dist/esm/lib/get/getCollectionItem.d.ts", "chunked_list": ["export declare const getCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<import(\"typesaurus\").Doc<Parent> | null>;\n"]}
{"filename": "dist/esm/lib/get/getGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandChild> | null>;\n"]}
{"filename": "dist/esm/lib/get/getGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild> | null>;\n"]}
{"filename": "dist/esm/lib/get/index.d.ts", "chunked_list": ["export * from './getCollectionItem';\nexport * from './getChildCollectionItem';\nexport * from './getGrandChildCollectionItem';\nexport * from './getGrandGrandChildCollectionItem';\nexport * from './getGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/get/getGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandChild> | null>;\n"]}
{"filename": "dist/esm/lib/firestore/index.d.ts", "chunked_list": ["export * from './timestamp';\n"]}
{"filename": "dist/esm/lib/firestore/timestamp.d.ts", "chunked_list": ["import { Timestamp as firestoreTimestamp } from '@google-cloud/firestore';\nexport declare class Timestamp extends firestoreTimestamp {\n    constructor(seconds: number, nanoseconds: number);\n}\n"]}
{"filename": "dist/esm/lib/remove/removeGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/removeCollectionItem.d.ts", "chunked_list": ["export declare const removeCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/removeChildCollectionItem.d.ts", "chunked_list": ["export declare const removeChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/removeGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/index.d.ts", "chunked_list": ["export * from './removeCollectionItem';\nexport * from './removeChildCollectionItem';\nexport * from './removeGrandChildCollectionItem';\nexport * from './removeGrandGrandChildCollectionItem';\nexport * from './removeGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/remove/removeGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateChildCollectionItem.d.ts", "chunked_list": ["export declare const updateChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childId: string, params: Partial<Child>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string, params: Partial<GrandGrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: Partial<GrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: Partial<GrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateCollectionItem.d.ts", "chunked_list": ["export declare const updateCollectionItem: <T>(collectionName: string, collectionId: string, params: Partial<T>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/index.d.ts", "chunked_list": ["export * from './updateCollectionItem';\nexport * from './updateChildCollectionItem';\nexport * from './updateGrandChildCollectionItem';\nexport * from './updateGrandGrandChildCollectionItem';\nexport * from './updateGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/index.d.ts", "chunked_list": ["export { createDataRef, createFirestoreDataConverter, getCollectionItem as get, addCollectionItem as add, serverTimestamp, createCollectionRef, addMultipleCollectionItems as adds, queryCollectionItems as query, updateCollectionItem as update, deleteCollectionItem as delete, } from './lib';\nexport { Timestamp, FieldValue } from 'firebase/firestore';\n"]}
{"filename": "dist/cjs/utils/time.d.ts", "chunked_list": ["export declare function sleep(ms: number): Promise<unknown>;\nexport declare const utcNow: (formatType?: number) => string;\nexport declare const formatTime: (ms: number) => string;\nexport declare const getTimestamp: () => string;\n"]}
{"filename": "dist/cjs/lib/getCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Retrieves a document from Firestore based on the provided document reference.\n *\n * @param dataRef - The document reference pointing to the desired Firestore document.\n *\n * @returns The data of the document as an object of type T.\n *\n * @throws Throws an exception if the document doesn't exist or if there is no data in the document.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import * as admin from 'firebase-admin'\n * import { get } from '@skeet-framework/firestore'\n *\n * const db = admin.firestore();\n *", " * async function run() {\n *   try {\n *     const db = admin.firestore();\n *     const path = 'Users'\n *     const id = 'user123'\n *     const user = await get<User>(db, path, id)\n *     console.log(`Retrieved user: ${user.name}, age: ${user.age}`)\n *   } catch (error) {\n *     console.error(`Error retrieving document: ${error}`)\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const getCollectionItem: <T>(db: firestore.Firestore, collectionPath: string, docId: string) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/deleteCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Deletes a document from the specified collection in Firestore.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection containing the document to be deleted.\n * @param docId - The ID of the document to be deleted.\n *\n * @returns A boolean indicating the success of the delete operation.\n *", " * @returns A boolean indicating the success of the delete operation.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import * as admin from 'firebase-admin'\n * import { delete } from '@skeet-framework/firestore'\n *", " * import { delete } from '@skeet-framework/firestore'\n *\n * const db = admin.firestore();\n *\n * async function run() {\n *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await delete(db, path, docId);\n *     if (success) {\n *       console.log(`Document with ID ${docId} deleted successfully.`);\n *     }", " *     if (success) {\n *       console.log(`Document with ID ${docId} deleted successfully.`);\n *     }\n *   } catch (error) {\n *     console.error(`Error deleting document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const deleteCollectionItem: (db: firestore.Firestore, collectionPath: string, docId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/getFirestoreData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const getFirestoreData: <T>(dataRef: firestore.DocumentReference<T>) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/version.d.ts", "chunked_list": ["export declare const VERSION = \"2.1.1\";\n"]}
{"filename": "dist/cjs/lib/createDataRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const createDataRef: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.DocumentReference<T>;\n"]}
{"filename": "dist/cjs/lib/updateCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Updates the specified document in the provided Firestore collection with the given data.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection containing the document to be updated.\n * @param docId - The ID of the document to be updated.\n * @param params - The data to update the document with.\n *\n * @returns A boolean indicating the success of the update operation.", " *\n * @returns A boolean indicating the success of the update operation.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { update } from '@skeet-framework/firestore'\n *", " * import { update } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const updatedData: firestore.UpdateData<User> = {\n *   age: 31\n * };\n *\n * async function run() {\n *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await update<User>(db, path, docId, updatedData);", " *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await update<User>(db, path, docId, updatedData);\n *     if (success) {\n *       console.log(`Document with ID ${docId} updated successfully.`);\n *     }\n *   } catch (error) {\n *     console.error(`Error updating document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const updateCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, docId: string, params: firestore.UpdateData<T>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/createFirestoreDataConverter.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const createFirestoreDataConverter: <T extends firestore.DocumentData>() => firestore.FirestoreDataConverter<T>;\n"]}
{"filename": "dist/cjs/lib/createCollectionRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nimport { DocumentData } from 'firebase/firestore';\nexport declare const createCollectionRef: <T extends DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.CollectionReference<T>;\n"]}
{"filename": "dist/cjs/lib/addMultipleCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Adds multiple documents to the specified collection in Firestore.\n * This function supports batched writes, and if the number of items exceeds the maximum batch size (500),\n * it will split the items into multiple batches and write them sequentially.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection to which the documents will be added.\n * @param items - An array of document data to be added.\n *\n * @returns An array of WriteResult arrays corresponding to each batch.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { adds } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const users: User[] = [\n *   { name: \"John Doe\", age: 30 },\n *   { name: \"Jane Smith\", age: 25 },\n *   // ... more users ...\n * ];\n *", " * async function run() {\n *   try {\n *     const path = 'Users'\n *     const results = await adds<User>(db, path, users);\n *     console.log(`Added ${users.length} users in ${results.length} batches.`);\n *   } catch (error) {\n *     console.error(`Error adding documents: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const addMultipleCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, items: T[]) => Promise<firestore.WriteResult[][]>;\n"]}
{"filename": "dist/cjs/lib/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\nexport * from './createDataRef';\nexport * from './createFirestoreDataConverter';\nexport * from './serverTimestamp';\nexport * from './getCollectionItem';\nexport * from './createCollectionRef';\nexport * from './addMultipleCollectionItems';\nexport * from './queryCollectionItems';\nexport * from './updateCollectionItem';\nexport * from './deleteCollectionItem';", "export * from './updateCollectionItem';\nexport * from './deleteCollectionItem';\n"]}
{"filename": "dist/cjs/lib/queryCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Represents a condition for querying Firestore collections.\n */\ntype QueryCondition = {\n    field?: string;\n    operator?: firestore.WhereFilterOp;\n    value?: any;\n    orderDirection?: firestore.OrderByDirection;\n    limit?: number;\n};\n/**\n * Queries the specified collection in Firestore based on the provided conditions\n * and returns an array of documents that match the conditions.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection to be queried.\n * @param conditions - An array of conditions to apply to the query.\n *\n * @returns An array of documents from the collection that match the conditions.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { query } from '@skeet-framework/firestore'\n * const db = firestore();\n *\n * // Simple query to get users over 25 years old\n * const simpleConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 }\n * ];\n *\n * // Advanced query to get users over 25 years old, ordered by their names\n * const advancedConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 },\n *   { field: \"name\", orderDirection: \"asc\" }\n * ];\n *\n * // Query to get users over 25 years old and limit the results to 5\n * const limitedConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 },\n *   { limit: 5 }\n * ];\n *", " * async function run() {\n *   try {\n *     const path = 'Users';\n *\n *     // Using the simple conditions\n *     const usersByAge = await query<User>(db, path, simpleConditions);\n *     console.log(`Found ${usersByAge.length} users over 25 years old.`);\n *\n *     // Using the advanced conditions\n *     const orderedUsers = await query<User>(db, path, advancedConditions);\n *     console.log(`Found ${orderedUsers.length} users over 25 years old, ordered by name.`);\n *\n *     // Using the limited conditions\n *     const limitedUsers = await query<User>(db, path, limitedConditions);\n *     console.log(`Found ${limitedUsers.length} users over 25 years old, limited to 5.`);\n *", " *   } catch (error) {\n *     console.error(`Error querying collection: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const queryCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, conditions: QueryCondition[]) => Promise<T[]>;\nexport {};\n"]}
{"filename": "dist/cjs/lib/serverTimestamp.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nexport declare const serverTimestamp: () => firestore.FieldValue;\n"]}
{"filename": "dist/cjs/lib/getCollectionItemData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nimport * as admin from 'firebase-admin';\nexport declare const getCollectionItemData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/addCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n/**\n * Adds a new document to the specified collection in Firestore. If an ID is provided, the document will be set with that ID; otherwise, an ID will be automatically generated.\n *\n * @param db - The instance of the Firestore database to interact with.\n * @param collectionPath - The path of the collection where the document will be added or set.\n * @param params - The data of the document to be added or set.\n * @param id - Optional. If provided, the document will be set with this ID. If not, an ID will be automatically generated by Firestore.\n *\n * @returns A reference to the added or set document.", " *\n * @returns A reference to the added or set document.\n *\n * @throws Throws an exception if any error occurs during the document addition or setting process.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { add } from '@skeet-framework/firestore'\n *", " * import { add } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const data: User = {\n *   name: \"John Doe\",\n *   age: 30\n * };\n *\n * async function run() {\n *   try {\n *     const path = 'Users';\n *     // Example without providing an ID:\n *     const docRef1 = await add<User>(db, path, data);\n *     console.log(`Document added with ID: ${docRef1.id}`);\n *\n *     // Example with providing an ID:\n *     const customID = 'custom_user_id';\n *     const docRef2 = await add<User>(db, path, data, customID);\n *     console.log(`Document set with ID: ${docRef2.id}`);", " * async function run() {\n *   try {\n *     const path = 'Users';\n *     // Example without providing an ID:\n *     const docRef1 = await add<User>(db, path, data);\n *     console.log(`Document added with ID: ${docRef1.id}`);\n *\n *     // Example with providing an ID:\n *     const customID = 'custom_user_id';\n *     const docRef2 = await add<User>(db, path, data, customID);\n *     console.log(`Document set with ID: ${docRef2.id}`);", " *   } catch (error) {\n *     console.error(`Error processing document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport declare const addCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, params: T, id?: string) => Promise<firestore.DocumentReference<T>>;\n"]}
{"filename": "dist/cjs/lib/getFirestoreModelData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\nimport * as admin from 'firebase-admin';\nexport declare const getFirestoreModelData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/crypt/encrypt.d.ts", "chunked_list": ["export declare const encrypt: (data: string, iv: string, password: string, salt: string) => string;\nexport declare const decrypt: (data: string, iv: string, password: string, salt: string) => string;\nexport declare const generateIv: () => string;\n"]}
{"filename": "dist/cjs/lib/crypt/index.d.ts", "chunked_list": ["export * from './encrypt';\n"]}
{"filename": "dist/cjs/lib/add/addChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addChildCollectionItem` is a function to add an item to a specified child Firestore collection.\n *\n * @template Child - Type of the object to be saved in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * @param {string} childCollectionName - Name of the child Firestore collection.\n * @param {string} parentId - Document ID of the parent collection item.\n * @param {Child} params - Data to be saved in the child Firestore collection.\n * @param {string} [id] - Document ID for the child collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<Child>>} - Reference to the added item in the child collection.\n *\n * @example\n * ```typescript\n * import { addChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'User';\n * const childCollectionName = 'Orders';\n * const parentId = 'XXX';\n *\n * // Retrieve the parent document reference\n * const parentDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n *\n * // Prepare child collection data\n * const orderParams = {\n *   parent: parentDoc.ref,\n *   orderId: '123',\n *   product: 'Some Product',\n *   quantity: 2,\n * }\n *\n * // Add item to the child collection\n * const orderRef = await addChildCollectionItem<Order, User>(\n *   parentCollectionName,\n *   childCollectionName,\n *   parentId,\n *   orderParams,\n *   orderParams.orderId\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, params: Child, id?: string) => Promise<Ref<Child>>;\n"]}
{"filename": "dist/cjs/lib/add/addGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addGrandGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grand-grandchild Firestore collection.\n *\n * @template GrandGrandGrandChild - Type of the object to be saved in the grand-grand-grandchild Firestore collection.\n * @template GrandGrandChild - Type of the object in the grand-grandchild Firestore collection.\n * @template GrandChild - Type of the object in the grandchild Firestore collection.\n * @template Child - Type of the object in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * ... [other parameters]\n * @param {GrandGrandGrandChild} params - Data to be saved in the grand-grand-grandchild Firestore collection.\n * @param {string} [id] - Document ID for the grand-grand-grandchild collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<GrandGrandGrandChild>>} - Reference to the added item in the grand-grand-grandchild collection.\n *\n * @example\n * ```typescript\n * import { addGrandGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'Planet';\n * ... [other collection names]\n * const grandGrandGrandChildCollectionName = 'House';\n * const parentId = 'Earth';\n * ... [other IDs]\n * const grandGrandChildId = 'MainStreet';\n *\n * const grandGrandChildDoc = await getGrandGrandChildCollectionItem<Street, City, State, Country>(\n *  parentCollectionName,\n *  childCollectionName,\n *  grandChildCollectionName,\n *  grandGrandChildCollectionName,\n *  parentId,\n *  childId,\n *  grandChildId\n * )\n *\n * const houseParams = {\n *   grandGrandChild: grandGrandChildDoc.ref,\n *   houseNumber: '123',\n *   color: 'Blue',\n *   residents: 4,\n * }\n *\n * const houseRef = await addGrandGrandGrandChildCollectionItem<House, Street, City, State, Country>(\n *   parentCollectionName,\n *   childCollectionName,\n *   ... [other collection names and IDs],\n *   houseParams,\n *   houseParams.houseNumber\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: GrandGrandGrandChild, id?: string) => Promise<Ref<GrandGrandGrandChild>>;\n"]}
{"filename": "dist/cjs/lib/add/addGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addGrandChildCollectionItem` is a function to add an item to a specified grandchild Firestore collection.\n *\n * @template GrandChild - Type of the object to be saved in the grandchild Firestore collection.\n * @template Child - Type of the object in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * @param {string} childCollectionName - Name of the child Firestore collection.\n * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n * @param {string} parentId - Document ID of the parent collection item.\n * @param {string} childId - Document ID of the child collection item.\n * @param {GrandChild} params - Data to be saved in the grandchild Firestore collection.\n * @param {string} [id] - Document ID for the grandchild collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<GrandChild>>} - Reference to the added item in the grandchild collection.\n *\n * @example\n * ```typescript\n * import { addGrandChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'User';\n * const childCollectionName = 'Orders';\n * const grandChildCollectionName = 'Items';\n * const parentId = 'XXX';\n * const childId = 'YYY';\n * const userDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n * const orderDoc = await getChildCollectionItem<Order, User>(\n *  parentCollectionName,\n *  childCollectionName,\n *  parentId,\n *  childId\n * )\n *\n * const itemParams = {\n *   child: orderDoc.ref,\n *   itemId: '123',\n *   productName: 'Some Product',\n *   quantity: 2,\n * }\n *\n * const itemRef = await addGrandChildCollectionItem<Item, Order, User>(\n *   parentCollectionName,\n *   childCollectionName,\n *   grandChildCollectionName,\n *   parentId,\n *   childId,\n *   itemParams,\n *   itemParams.itemId\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, params: GrandChild, id?: string) => Promise<Ref<GrandChild>>;\n"]}
{"filename": "dist/cjs/lib/add/addGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grandchild Firestore collection.\n *\n * @template GrandGrandChild - Type of the object to be saved in the grand-grandchild Firestore collection.\n * @template GrandChild - Type of the object in the grandchild Firestore collection.\n * @template Child - Type of the object in the child Firestore collection.\n * @template Parent - Type of the object in the parent Firestore collection.\n *\n * @param {string} parentCollectionName - Name of the parent Firestore collection.\n * @param {string} childCollectionName - Name of the child Firestore collection.\n * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n * @param {string} grandGrandChildCollectionName - Name of the grand-grandchild Firestore collection.\n * @param {string} parentId - Document ID of the parent collection item.\n * @param {string} childId - Document ID of the child collection item.\n * @param {string} grandChildId - Document ID of the grandchild collection item.\n * @param {GrandGrandChild} params - Data to be saved in the grand-grandchild Firestore collection.\n * @param {string} [id] - Document ID for the grand-grandchild collection. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<GrandGrandChild>>} - Reference to the added item in the grand-grandchild collection.\n *\n * @example\n * ```typescript\n * import { addGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n *\n * const parentCollectionName = 'Country';\n * const childCollectionName = 'State';\n * const grandChildCollectionName = 'City';\n * const grandGrandChildCollectionName = 'Street';\n * const parentId = 'US';\n * const childId = 'CA';\n * const grandChildId = 'LA';\n * const parentDoc = await getCollectionItem<Country>(parentCollectionName, parentId)\n * const childDoc = await getChildCollectionItem<State, Country>(\n *  parentCollectionName,\n *  childCollectionName,\n *  parentId,\n *  childId\n * )\n * const grandChildDoc = await getGrandChildCollectionItem<City, State, Country>(\n *  parentCollectionName,\n *  childCollectionName,\n *  grandChildCollectionName,\n *  parentId,\n *  childId,\n *  grandChildId\n * )\n *\n * const streetParams = {\n *   grandChild: grandChildDoc.ref,\n *   streetName: 'Sunset Blvd',\n *   zipCode: '90028',\n * }\n *\n * const streetRef = await addGrandGrandChildCollectionItem<Street, City, State, Country>(\n *   parentCollectionName,\n *   childCollectionName,\n *   grandChildCollectionName,\n *   grandGrandChildCollectionName,\n *   parentId,\n *   childId,\n *   grandChildId,\n *   streetParams,\n *   streetParams.streetName\n * );\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: GrandGrandChild, id?: string) => Promise<Ref<GrandGrandChild>>;\n"]}
{"filename": "dist/cjs/lib/add/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\nexport * from './addChildCollectionItem';\nexport * from './addGrandChildCollectionItem';\nexport * from './addGrandGrandChildCollectionItem';\nexport * from './addGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/add/addCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n/**\n * `addCollectionItem` is a function to add an item to a specified Firestore collection.\n *\n * @template T - Type of the object to be saved in Firestore.\n *\n * @param {string} collectionName - Name of the Firestore collection.\n * @param {T} params - Data to be saved in Firestore.\n * @param {string} [id] - Document ID. If not specified, a random ID is generated.\n *\n * @returns {Promise<Ref<T>>} - Reference to the added item.\n *\n * @example\n * ```typescript\n * import { addCollectionItem } from '@skeet-framework/firestore'\n * import { User } from '@/models'\n *\n * const userParams = {\n *   uid: 'XXX',\n *   email: 'info@epics.dev',\n *   username: 'EpicsDAO',\n * }\n *\n * const userRef = await addCollectionItem<User>('User', userParams, userParams.uid)\n * ```\n *\n * @throws {Error} - If an error occurs during Firestore operations.\n */\nexport declare const addCollectionItem: <T>(collectionName: string, params: T, id?: string) => Promise<Ref<T>>;\n"]}
{"filename": "dist/cjs/lib/typesaurus/index.d.ts", "chunked_list": ["export * from './ref';\n"]}
{"filename": "dist/cjs/lib/typesaurus/ref.d.ts", "chunked_list": ["import { Collection } from 'typesaurus';\nexport interface Ref<Model> {\n    __type__: 'ref';\n    collection: Collection<Model>;\n    id: string;\n}\n"]}
{"filename": "dist/cjs/lib/query/queryCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryCollectionItem: <Parent>(collectionName: string, queries: Query<Parent, keyof Parent>[]) => Promise<import(\"typesaurus\").Doc<Parent>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, queries: Query<GrandChild, keyof GrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandChild>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string, queries: Query<GrandGrandGrandChild, keyof GrandGrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, queries: Query<GrandGrandChild, keyof GrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandChild>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\nexport declare const queryChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, queries: Query<Child, keyof Child>[]) => Promise<import(\"typesaurus\").Doc<Child>[]>;\n"]}
{"filename": "dist/cjs/lib/query/index.d.ts", "chunked_list": ["export * from './queryCollectionItem';\nexport * from './queryChildCollectionItem';\nexport * from './queryGrandChildCollectionItem';\nexport * from './queryGrandGrandChildCollectionItem';\nexport * from './queryGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/get/getChildCollectionItem.d.ts", "chunked_list": ["export declare const getChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<import(\"typesaurus\").Doc<Child> | null>;\n"]}
{"filename": "dist/cjs/lib/get/getCollectionItem.d.ts", "chunked_list": ["export declare const getCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<import(\"typesaurus\").Doc<Parent> | null>;\n"]}
{"filename": "dist/cjs/lib/get/getGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandChild> | null>;\n"]}
{"filename": "dist/cjs/lib/get/getGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild> | null>;\n"]}
{"filename": "dist/cjs/lib/get/index.d.ts", "chunked_list": ["export * from './getCollectionItem';\nexport * from './getChildCollectionItem';\nexport * from './getGrandChildCollectionItem';\nexport * from './getGrandGrandChildCollectionItem';\nexport * from './getGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/get/getGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandChild> | null>;\n"]}
{"filename": "dist/cjs/lib/firestore/index.d.ts", "chunked_list": ["export * from './timestamp';\n"]}
{"filename": "dist/cjs/lib/firestore/timestamp.d.ts", "chunked_list": ["import { Timestamp as firestoreTimestamp } from '@google-cloud/firestore';\nexport declare class Timestamp extends firestoreTimestamp {\n    constructor(seconds: number, nanoseconds: number);\n}\n"]}
{"filename": "dist/cjs/lib/remove/removeGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/removeCollectionItem.d.ts", "chunked_list": ["export declare const removeCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/removeChildCollectionItem.d.ts", "chunked_list": ["export declare const removeChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/removeGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/index.d.ts", "chunked_list": ["export * from './removeCollectionItem';\nexport * from './removeChildCollectionItem';\nexport * from './removeGrandChildCollectionItem';\nexport * from './removeGrandGrandChildCollectionItem';\nexport * from './removeGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/remove/removeGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateChildCollectionItem.d.ts", "chunked_list": ["export declare const updateChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childId: string, params: Partial<Child>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string, params: Partial<GrandGrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: Partial<GrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: Partial<GrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateCollectionItem.d.ts", "chunked_list": ["export declare const updateCollectionItem: <T>(collectionName: string, collectionId: string, params: Partial<T>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/index.d.ts", "chunked_list": ["export * from './updateCollectionItem';\nexport * from './updateChildCollectionItem';\nexport * from './updateGrandChildCollectionItem';\nexport * from './updateGrandGrandChildCollectionItem';\nexport * from './updateGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "src/index.ts", "chunked_list": ["export {\n  createDataRef,\n  createFirestoreDataConverter,\n  getCollectionItem as get,\n  addCollectionItem as add,\n  serverTimestamp,\n  createCollectionRef,\n  addMultipleCollectionItems as adds,\n  queryCollectionItems as query,\n  updateCollectionItem as update,", "  queryCollectionItems as query,\n  updateCollectionItem as update,\n  deleteCollectionItem as delete,\n} from './lib'\nexport { Timestamp, FieldValue } from 'firebase/firestore'\n"]}
{"filename": "src/lib/addCollectionItem.ts", "chunked_list": ["import { createCollectionRef } from './createCollectionRef'\nimport { firestore } from 'firebase-admin'\nimport { serverTimestamp } from './serverTimestamp'\n\n/**\n * Adds a new document to the specified collection in Firestore. If an ID is provided, the document will be set with that ID; otherwise, an ID will be automatically generated.\n *\n * @param db - The instance of the Firestore database to interact with.\n * @param collectionPath - The path of the collection where the document will be added or set.\n * @param params - The data of the document to be added or set.", " * @param collectionPath - The path of the collection where the document will be added or set.\n * @param params - The data of the document to be added or set.\n * @param id - Optional. If provided, the document will be set with this ID. If not, an ID will be automatically generated by Firestore.\n *\n * @returns A reference to the added or set document.\n *\n * @throws Throws an exception if any error occurs during the document addition or setting process.\n *\n * @example\n * ```typescript", " * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { add } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const data: User = {\n *   name: \"John Doe\",\n *   age: 30\n * };", " *   age: 30\n * };\n *\n * async function run() {\n *   try {\n *     const path = 'Users';\n *     // Example without providing an ID:\n *     const docRef1 = await add<User>(db, path, data);\n *     console.log(`Document added with ID: ${docRef1.id}`);\n *\n *     // Example with providing an ID:\n *     const customID = 'custom_user_id';\n *     const docRef2 = await add<User>(db, path, data, customID);\n *     console.log(`Document set with ID: ${docRef2.id}`);", " *   } catch (error) {\n *     console.error(`Error processing document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\n\nexport const addCollectionItem = async <T extends firestore.DocumentData>(\n  db: firestore.Firestore,\n  collectionPath: string,\n  params: T,\n  id?: string\n) => {", "  try {\n    const collectionRef = createCollectionRef<T>(db, collectionPath)\n\n    if (id) {\n      const docRef = collectionRef.doc(id)\n      await docRef.set({\n        ...params,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      })\n\n      return docRef\n    } else {\n      const data = await collectionRef.add({\n        ...params,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      })", "      if (!data) {\n        throw new Error('no data')\n      }\n      return data\n    }\n  } catch (error) {\n    throw new Error(`Error adding document: ${error}`)\n  }\n}\n"]}
{"filename": "src/lib/deleteCollectionItem.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\n/**\n * Deletes a document from the specified collection in Firestore.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection containing the document to be deleted.\n * @param docId - The ID of the document to be deleted.\n *\n * @returns A boolean indicating the success of the delete operation.", " *\n * @returns A boolean indicating the success of the delete operation.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import * as admin from 'firebase-admin'\n * import { delete } from '@skeet-framework/firestore'", " * import * as admin from 'firebase-admin'\n * import { delete } from '@skeet-framework/firestore'\n *\n * const db = admin.firestore();\n *\n * async function run() {\n *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await delete(db, path, docId);\n *     if (success) {\n *       console.log(`Document with ID ${docId} deleted successfully.`);\n *     }", " *     if (success) {\n *       console.log(`Document with ID ${docId} deleted successfully.`);\n *     }\n *   } catch (error) {\n *     console.error(`Error deleting document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport const deleteCollectionItem = async (\n  db: firestore.Firestore,\n  collectionPath: string,\n  docId: string\n): Promise<boolean> => {", "  try {\n    const docRef = db.collection(collectionPath).doc(docId)\n    await docRef.delete()\n    return true\n  } catch (error) {\n    throw new Error(`Error deleting document with ID ${docId}: ${error}`)\n  }\n}\n"]}
{"filename": "src/lib/updateCollectionItem.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\nimport { createFirestoreDataConverter } from './createFirestoreDataConverter'\nimport { serverTimestamp } from './serverTimestamp'\n\n/**\n * Updates the specified document in the provided Firestore collection with the given data.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection containing the document to be updated.\n * @param docId - The ID of the document to be updated.", " * @param collectionPath - The path of the collection containing the document to be updated.\n * @param docId - The ID of the document to be updated.\n * @param params - The data to update the document with.\n *\n * @returns A boolean indicating the success of the update operation.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript", " * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { update } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const updatedData: firestore.UpdateData<User> = {\n *   age: 31\n * };\n *\n * async function run() {", " * };\n *\n * async function run() {\n *   try {\n *     const path = 'Users'\n *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n *     const success = await update<User>(db, path, docId, updatedData);\n *     if (success) {\n *       console.log(`Document with ID ${docId} updated successfully.`);\n *     }\n *   } catch (error) {\n *     console.error(`Error updating document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport const updateCollectionItem = async <T extends firestore.DocumentData>(\n  db: firestore.Firestore,\n  collectionPath: string,\n  docId: string,\n  params: firestore.UpdateData<T>\n): Promise<boolean> => {", " *   } catch (error) {\n *     console.error(`Error updating document: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport const updateCollectionItem = async <T extends firestore.DocumentData>(\n  db: firestore.Firestore,\n  collectionPath: string,\n  docId: string,\n  params: firestore.UpdateData<T>\n): Promise<boolean> => {", "  try {\n    const docRef = db\n      .collection(collectionPath)\n      .doc(docId)\n      .withConverter(createFirestoreDataConverter<T>())\n    await docRef.update({ ...params, updatedAt: serverTimestamp() })\n    return true\n  } catch (error) {\n    throw new Error(`Error updating document with ID ${docId}: ${error}`)\n  }\n}\n"]}
{"filename": "src/lib/queryCollectionItems.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\nimport { createFirestoreDataConverter } from './createFirestoreDataConverter'\n\n/**\n * Represents a condition for querying Firestore collections.\n */\ntype QueryCondition = {\n  field?: string\n  operator?: firestore.WhereFilterOp\n  value?: any\n  orderDirection?: firestore.OrderByDirection // \"asc\" or \"desc\"\n  limit?: number\n}\n\n/**\n * Queries the specified collection in Firestore based on the provided conditions\n * and returns an array of documents that match the conditions.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection to be queried.\n * @param conditions - An array of conditions to apply to the query.\n *\n * @returns An array of documents from the collection that match the conditions.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { query } from '@skeet-framework/firestore'\n * const db = firestore();\n *\n * // Simple query to get users over 25 years old\n * const simpleConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 }\n * ];\n *\n * // Advanced query to get users over 25 years old, ordered by their names\n * const advancedConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 },\n *   { field: \"name\", orderDirection: \"asc\" }\n * ];\n *\n * // Query to get users over 25 years old and limit the results to 5\n * const limitedConditions: QueryCondition[] = [\n *   { field: \"age\", operator: \">\", value: 25 },\n *   { limit: 5 }\n * ];\n *", " * async function run() {\n *   try {\n *     const path = 'Users';\n *\n *     // Using the simple conditions\n *     const usersByAge = await query<User>(db, path, simpleConditions);\n *     console.log(`Found ${usersByAge.length} users over 25 years old.`);\n *\n *     // Using the advanced conditions\n *     const orderedUsers = await query<User>(db, path, advancedConditions);\n *     console.log(`Found ${orderedUsers.length} users over 25 years old, ordered by name.`);\n *\n *     // Using the limited conditions\n *     const limitedUsers = await query<User>(db, path, limitedConditions);\n *     console.log(`Found ${limitedUsers.length} users over 25 years old, limited to 5.`);\n *", " *   } catch (error) {\n *     console.error(`Error querying collection: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport const queryCollectionItems = async <T extends firestore.DocumentData>(\n  db: firestore.Firestore,\n  collectionPath: string,\n  conditions: QueryCondition[]\n): Promise<T[]> => {", "  try {\n    let query: firestore.Query = db\n      .collection(collectionPath)\n      .withConverter(createFirestoreDataConverter<T>())\n\n    for (const condition of conditions) {\n      if (\n        condition.field &&\n        condition.operator &&\n        condition.value !== undefined\n      ) {\n        query = query.where(\n          condition.field,\n          condition.operator,\n          condition.value\n        )\n      }", "      if (condition.field && condition.orderDirection) {\n        query = query.orderBy(condition.field, condition.orderDirection)\n      }\n      if (condition.limit !== undefined) {\n        query = query.limit(condition.limit)\n      }\n    }\n\n    const snapshot = await query.get()\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...(doc.data() as T),\n    }))", "  } catch (error) {\n    throw new Error(`Error querying collection: ${error}`)\n  }\n}\n"]}
{"filename": "src/lib/version.ts", "chunked_list": ["export const VERSION = '2.1.1'"]}
{"filename": "src/lib/addMultipleCollectionItems.ts", "chunked_list": ["import { createCollectionRef } from './createCollectionRef'\nimport { firestore } from 'firebase-admin'\nimport { serverTimestamp } from './serverTimestamp'\n\n/**\n * Adds multiple documents to the specified collection in Firestore.\n * This function supports batched writes, and if the number of items exceeds the maximum batch size (500),\n * it will split the items into multiple batches and write them sequentially.\n *\n * @param db - The instance of the Firestore database to use.\n * @param collectionPath - The path of the collection to which the documents will be added.\n * @param items - An array of document data to be added.\n *\n * @returns An array of WriteResult arrays corresponding to each batch.\n *\n * @throws Throws an exception with an error message if an error occurs.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import { adds } from '@skeet-framework/firestore'\n *\n * const db = firestore();\n * const users: User[] = [\n *   { name: \"John Doe\", age: 30 },\n *   { name: \"Jane Smith\", age: 25 },\n *   // ... more users ...\n * ];\n *", " * async function run() {\n *   try {\n *     const path = 'Users'\n *     const results = await adds<User>(db, path, users);\n *     console.log(`Added ${users.length} users in ${results.length} batches.`);\n *   } catch (error) {\n *     console.error(`Error adding documents: ${error}`);\n *   }\n * }\n *\n * run();\n * ```\n */\nexport const addMultipleCollectionItems = async <\n  T extends firestore.DocumentData\n>(\n  db: firestore.Firestore,\n  collectionPath: string,\n  items: T[]\n): Promise<firestore.WriteResult[][]> => {\n  const MAX_BATCH_SIZE = 500\n\n  const chunkedItems =\n    items.length > 500 ? chunkArray(items, MAX_BATCH_SIZE) : [items]\n\n  const batchResults: firestore.WriteResult[][] = []\n", "  for (const chunk of chunkedItems) {\n    try {\n      const batch = db.batch()\n      const collectionRef = createCollectionRef<T>(db, collectionPath)\n\n      chunk.forEach((item) => {\n        const docRef = collectionRef.doc()\n        batch.set(docRef, {\n          ...item,\n          createdAt: serverTimestamp(),\n          updatedAt: serverTimestamp(),\n        })\n      })\n\n      const writeResults = await batch.commit()\n      batchResults.push(writeResults)", "    } catch (error) {\n      throw new Error(`Error adding a batch of documents: ${error}`)\n    }\n  }\n\n  return batchResults\n}\n\n/**\n * Helper function to divide an array into chunks of a specified size.\n *\n * @param array - The array to be divided.\n * @param size - The size of each chunk.\n *\n * @returns An array of chunked arrays.\n */", " * Helper function to divide an array into chunks of a specified size.\n *\n * @param array - The array to be divided.\n * @param size - The size of each chunk.\n *\n * @returns An array of chunked arrays.\n */\nfunction chunkArray<T>(array: T[], size: number): T[][] {\n  const chunked = []\n  let index = 0\n  while (index < array.length) {\n    chunked.push(array.slice(index, size + index))\n    index += size\n  }\n  return chunked\n}\n", "  while (index < array.length) {\n    chunked.push(array.slice(index, size + index))\n    index += size\n  }\n  return chunked\n}\n"]}
{"filename": "src/lib/serverTimestamp.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\nexport const serverTimestamp = () => {\n  return firestore.FieldValue.serverTimestamp()\n}\n"]}
{"filename": "src/lib/index.ts", "chunked_list": ["export * from './addCollectionItem'\nexport * from './createDataRef'\nexport * from './createFirestoreDataConverter'\nexport * from './serverTimestamp'\nexport * from './getCollectionItem'\nexport * from './createCollectionRef'\nexport * from './addMultipleCollectionItems'\nexport * from './queryCollectionItems'\nexport * from './updateCollectionItem'\nexport * from './deleteCollectionItem'", "export * from './updateCollectionItem'\nexport * from './deleteCollectionItem'\n"]}
{"filename": "src/lib/getCollectionItem.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n/**\n * Retrieves a document from Firestore based on the provided document reference.\n *\n * @param dataRef - The document reference pointing to the desired Firestore document.\n *\n * @returns The data of the document as an object of type T.\n *\n * @throws Throws an exception if the document doesn't exist or if there is no data in the document.\n *\n * @example\n * ```typescript\n * import { firestore } from 'firebase-admin'\n * import * as admin from 'firebase-admin'\n * import { get } from '@skeet-framework/firestore'\n *\n * const db = admin.firestore();\n *", " * async function run() {\n *   try {\n *     const db = admin.firestore();\n *     const path = 'Users'\n *     const id = 'user123'\n *     const user = await get<User>(db, path, id)\n *     console.log(`Retrieved user: ${user.name}, age: ${user.age}`)\n *   } catch (error) {\n *     console.error(`Error retrieving document: ${error}`)\n *   }\n * }\n *\n * run();\n * ```\n */\nexport const getCollectionItem = async <T>(\n  db: firestore.Firestore,\n  collectionPath: string,\n  docId: string\n): Promise<T> => {\n  const dataRef = db\n    .collection(collectionPath)\n    .doc(docId) as FirebaseFirestore.DocumentReference<T>\n  const doc = await dataRef.get()", "  if (!doc.exists) {\n    throw new Error('Document not found at path: ' + dataRef.path)\n  }\n  const data = doc.data()\n  if (!data) throw new Error('Document data not found at path: ' + dataRef.path)\n  return data\n}\n"]}
{"filename": "src/lib/createDataRef.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\nimport { createFirestoreDataConverter } from './createFirestoreDataConverter'\n\nexport const createDataRef = <T extends firestore.DocumentData>(\n  db: firestore.Firestore,\n  collectionPath: string\n) => {\n  return db.doc(collectionPath).withConverter(createFirestoreDataConverter<T>())\n}\n", "}\n"]}
{"filename": "src/lib/createFirestoreDataConverter.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\nexport const createFirestoreDataConverter = <\n  T extends firestore.DocumentData\n>(): firestore.FirestoreDataConverter<T> => {\n  return {\n    toFirestore(data: T): firestore.DocumentData {\n      return data\n    },\n    fromFirestore(snapshot: firestore.QueryDocumentSnapshot): T {", "    },\n    fromFirestore(snapshot: firestore.QueryDocumentSnapshot): T {\n      return snapshot.data() as T\n    },\n  }\n}\n"]}
{"filename": "src/lib/createCollectionRef.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\nimport { createFirestoreDataConverter } from './createFirestoreDataConverter'\nimport { DocumentData } from 'firebase/firestore'\n\nexport const createCollectionRef = <T extends DocumentData>(\n  db: firestore.Firestore,\n  collectionPath: string\n) => {\n  return db\n    .collection(collectionPath)", "  return db\n    .collection(collectionPath)\n    .withConverter(createFirestoreDataConverter<T>())\n}\n"]}
