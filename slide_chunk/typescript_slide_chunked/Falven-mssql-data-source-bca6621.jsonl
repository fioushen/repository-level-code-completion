{"filename": "src/index.ts", "chunked_list": ["export * from './lib/datasource';\nexport * from './lib/executor';\nexport * from './lib/logging';\nexport * from './lib/stored-procedure';\nexport * from './lib/types';\nexport * from './lib/utils';\n"]}
{"filename": "src/lib/datasource/mssql-datasource.ts", "chunked_list": ["import type { Request } from 'mssql';\nimport { type GraphQLResolveInfo } from 'graphql';\n\nimport { DevConsoleLogger, logExecutionBegin, logExecutionEnd, logSafely } from '../logging';\nimport { DatabaseExecutor } from '../executor';\nimport { ConnectionManager } from '../utils';\nimport {\n  StoredProcedureManager,\n  StoredProcedureCacheManager,\n  StoredProcedureMetadataManager,\n} from '../stored-procedure';\nimport type { MSSQLOptions, ILogger, IResolverProcedureResult, InputParameters } from '../types';\n\n/**\n * A GraphQL DataSource backed by a Microsoft SQL Server database.\n * Maintains separate caching for Query and Mutation operations.\n * Maintains a global connection pool cache to reuse connections.\n */", "export class MSSQLDataSource {\n  private readonly _queryOptions: MSSQLOptions;\n  private readonly _mutationOptions: MSSQLOptions;\n\n  private readonly _queryLogger: ILogger;\n  private readonly _mutationLogger: ILogger;\n\n  private readonly _connectionManager: ConnectionManager;\n  private readonly _databaseExecutor: DatabaseExecutor;\n  private readonly _storedProcedureMetadataManager: StoredProcedureMetadataManager;\n  private readonly _storedProcedureCacheManager: StoredProcedureCacheManager;\n  private readonly _storedProcedureManager: StoredProcedureManager;\n\n  /**\n   * Creates a new MSSQLDataSource with the given options.\n   * @param queryOptions The options for Query operations\n   * @param mutationOptions The options for Mutation operations\n   */\n  constructor(\n    queryOptions: MSSQLOptions = MSSQLDataSource.defaultOptions,\n    mutationOptions: MSSQLOptions = MSSQLDataSource.defaultOptions,\n  ) {\n    this._queryOptions = queryOptions;\n    this._mutationOptions = mutationOptions;\n\n    const defaultOptions = MSSQLDataSource.defaultOptions;\n    this._queryLogger =\n      queryOptions.logger !== undefined ? queryOptions.logger : (defaultOptions.logger as ILogger);\n    this._mutationLogger =\n      mutationOptions.logger !== undefined\n        ? mutationOptions.logger\n        : (defaultOptions.logger as ILogger);\n\n    this._connectionManager = new ConnectionManager(\n      this._queryOptions.config,\n      this._mutationOptions.config,\n    );\n\n    this._databaseExecutor = new DatabaseExecutor(this._connectionManager);\n\n    this._storedProcedureMetadataManager = new StoredProcedureMetadataManager(\n      this._databaseExecutor,\n    );\n\n    this._storedProcedureCacheManager = new StoredProcedureCacheManager();\n\n    this._storedProcedureManager = new StoredProcedureManager(\n      this._storedProcedureCacheManager,\n      this._storedProcedureMetadataManager,\n    );\n  }\n\n  /**\n   * Executes a stored procedure for a Query operation with the provided input parameters, and returns the result.", "   * @template T - This type parameter represents the type of the value returned by the resolver procedure.\n   * @param {string} storedProcedureName - The name of the stored procedure to execute.\n   * @param {StoredProcedureInput} input - The input parameters for the stored procedure.\n   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n   * procedure results to the correct schema field names.\n   * @returns A Promise that resolves to the result of the stored procedure execution.\n   */\n  public async executeStoredProcedureQuery<T>(\n    storedProcedureName: string,\n    input: InputParameters,\n    info?: GraphQLResolveInfo,\n  ): Promise<IResolverProcedureResult<T>> {\n    const startTime = performance.now();\n    const logger = this._queryLogger;\n\n    logExecutionBegin(logger, `Stored Procedure Query ${storedProcedureName} with inputs`, input);\n\n    const result = await this._databaseExecutor.executeQueryRequest(\n      async (request: Request): Promise<IResolverProcedureResult<T>> =>\n        await this._storedProcedureManager.executeStoredProcedure<T>(\n          storedProcedureName,\n          input,\n          request,\n          logger,\n          info,\n        ),\n      logger,\n    );\n\n    logExecutionEnd(logger, `Stored Procedure Query ${storedProcedureName}`, startTime);\n    logSafely(logger, 'info', `------------------`);\n\n    return result;\n  }\n\n  /**\n   * Executes a stored procedure for a Mutation operation with the provided input parameters, and returns the result.", "   * @template T - This type parameter represents the type of the value returned by the resolver procedure.\n   * @param {string} storedProcedureName - The name of the stored procedure to execute.\n   * @param {StoredProcedureInput} input - The input parameters for the stored procedure.\n   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n   * procedure results to the correct schema field names.\n   * @returns A Promise that resolves to the result of the stored procedure execution.\n   */\n  public async executeStoredProcedureMutation<T>(\n    storedProcedureName: string,\n    input: InputParameters,\n    info?: GraphQLResolveInfo,\n  ): Promise<IResolverProcedureResult<T>> {\n    const startTime = performance.now();\n    const logger = this._mutationLogger;\n    logExecutionBegin(logger, `Stored Procedure Mutation ${storedProcedureName}`, input);\n    const result = await this._databaseExecutor.executeMutationRequest(\n      async (request: Request): Promise<IResolverProcedureResult<T>> =>\n        await this._storedProcedureManager.executeStoredProcedure(\n          storedProcedureName,\n          input,\n          request,\n          logger,\n          info,\n        ),\n      logger,\n    );\n    logExecutionEnd(logger, `Stored Procedure Mutation ${storedProcedureName}`, startTime);\n    return result;\n  }\n\n  /**\n   * Default options for the Query and Mutation global connection pool cache.\n   */\n  private static get defaultOptions(): MSSQLOptions {\n    return {\n      config: {\n        user: '',\n        password: '',\n        server: '',\n        database: '',\n      },\n      logger: new DevConsoleLogger(),\n    };\n  }\n}\n"]}
{"filename": "src/lib/datasource/index.ts", "chunked_list": ["export * from './mssql-datasource';\n"]}
{"filename": "src/lib/utils/type-map.ts", "chunked_list": ["import {\n  type ISqlTypeFactory,\n  type ISqlTypeFactoryWithLength,\n  type ISqlTypeFactoryWithNoParams,\n  type ISqlTypeFactoryWithPrecisionScale,\n  type ISqlTypeFactoryWithScale,\n  type ISqlTypeFactoryWithTvpType,\n  type ISqlTypeWithLength,\n  type ISqlTypeWithNoParams,\n  type ISqlTypeWithPrecisionScale,\n  type ISqlTypeWithScale,", "  type ISqlTypeWithNoParams,\n  type ISqlTypeWithPrecisionScale,\n  type ISqlTypeWithScale,\n  type ISqlTypeWithTvpType,\n  TYPES,\n  MAX,\n} from 'mssql';\n\nimport type { StoredProcedureParameter } from '../types';\n\ntype TypeFactory<T> = T extends ISqlTypeFactoryWithNoParams\n  ? () => ISqlTypeWithNoParams\n  : T extends ISqlTypeFactoryWithLength\n  ? (length?: number) => ISqlTypeWithLength\n  : T extends ISqlTypeFactoryWithScale\n  ? (scale?: number) => ISqlTypeWithScale\n  : T extends ISqlTypeFactoryWithPrecisionScale\n  ? (precision?: number, scale?: number) => ISqlTypeWithPrecisionScale\n  : T extends ISqlTypeFactoryWithTvpType\n  ? (tvpType?: unknown) => ISqlTypeWithTvpType\n  : never;\n", "type TypeFactory<T> = T extends ISqlTypeFactoryWithNoParams\n  ? () => ISqlTypeWithNoParams\n  : T extends ISqlTypeFactoryWithLength\n  ? (length?: number) => ISqlTypeWithLength\n  : T extends ISqlTypeFactoryWithScale\n  ? (scale?: number) => ISqlTypeWithScale\n  : T extends ISqlTypeFactoryWithPrecisionScale\n  ? (precision?: number, scale?: number) => ISqlTypeWithPrecisionScale\n  : T extends ISqlTypeFactoryWithTvpType\n  ? (tvpType?: unknown) => ISqlTypeWithTvpType\n  : never;\n", "type TypesType = typeof TYPES;\ntype TypesKey = keyof TypesType;\ntype IndexableTypes = {\n  [K in TypesKey]: TypeFactory<TypesType[K]>;\n};\n\nfunction isSqlTypeFactoryWithNoParams(\n  factoryObject: ISqlTypeFactory,\n): factoryObject is ISqlTypeFactoryWithNoParams {\n  return (\n    factoryObject !== undefined &&\n    !('length' in factoryObject) &&\n    !('scale' in factoryObject) &&\n    !('precision' in factoryObject) &&\n    !('tvpType' in factoryObject)\n  );\n}\n", "function isSqlTypeFactoryWithLength(\n  factoryObject: ISqlTypeFactory,\n): factoryObject is ISqlTypeFactoryWithLength {\n  return factoryObject !== undefined && 'length' in factoryObject;\n}\n\nfunction isSqlTypeFactoryWithScale(\n  factoryObject: ISqlTypeFactory,\n): factoryObject is ISqlTypeFactoryWithScale {\n  return factoryObject !== undefined && 'scale' in factoryObject;\n}\n", "function isSqlTypeFactoryWithPrecisionScale(\n  factoryObject: ISqlTypeFactory,\n): factoryObject is ISqlTypeFactoryWithPrecisionScale {\n  return factoryObject !== undefined && 'precision' in factoryObject && 'scale' in factoryObject;\n}\n\nfunction isSqlTypeFactoryWithTvpType(\n  factoryObject: ISqlTypeFactory,\n): factoryObject is ISqlTypeFactoryWithTvpType {\n  return factoryObject !== undefined && 'tvpType' in factoryObject;\n}\n\nconst findPropertyCaseInsensitive = (obj: object, propertyName: string): string | null => {\n  const lowercasePropertyName = propertyName.toLowerCase();", "  for (const key in obj) {\n    if (\n      Object.prototype.hasOwnProperty.call(obj, key) &&\n      key.toLowerCase() === lowercasePropertyName\n    ) {\n      return key;\n    }\n  }\n  return null;\n};\n\nexport const mapDbTypeToDriverType = ({\n  type,\n  length,\n  precision,\n  scale,\n}: Pick<StoredProcedureParameter, 'type' | 'length' | 'precision' | 'scale'>): ISqlTypeFactory => {\n  const types: IndexableTypes = TYPES;\n  const property = findPropertyCaseInsensitive(types, type);", "  if (property !== null) {\n    const typeFactory = types[property as TypesKey];\n    if (isSqlTypeFactoryWithNoParams(typeFactory)) {\n      return typeFactory();\n    } else if (isSqlTypeFactoryWithLength(typeFactory)) {\n      return (typeFactory as ISqlTypeFactoryWithLength)(length === -1 ? MAX : length);\n    } else if (isSqlTypeFactoryWithScale(typeFactory)) {\n      return (typeFactory as ISqlTypeFactoryWithScale)(scale);\n    } else if (isSqlTypeFactoryWithPrecisionScale(typeFactory)) {\n      return (typeFactory as ISqlTypeFactoryWithPrecisionScale)(precision, scale);\n    } else if (isSqlTypeFactoryWithTvpType(typeFactory)) {\n      return TYPES.NVarChar();\n    } else {\n      throw new Error(`Unknown SQL Type ${type}.`);\n    }\n  }\n  return TYPES.NVarChar();\n};\n", "    } else if (isSqlTypeFactoryWithPrecisionScale(typeFactory)) {\n      return (typeFactory as ISqlTypeFactoryWithPrecisionScale)(precision, scale);\n    } else if (isSqlTypeFactoryWithTvpType(typeFactory)) {\n      return TYPES.NVarChar();\n    } else {\n      throw new Error(`Unknown SQL Type ${type}.`);\n    }\n  }\n  return TYPES.NVarChar();\n};\n", "type SqlValue = string | number | boolean | Date | Buffer;\n\nconst isStringOrNumber = (value: SqlValue): value is string | number => {\n  return typeof value === 'string' || typeof value === 'number';\n};\n\nconst isDate = (value: SqlValue): value is Date => {\n  return value instanceof Date;\n};\n\nconst isType = (sqlType: string, typePrefixes: string[]): boolean => {\n  return typePrefixes.some((prefix) => sqlType.startsWith(prefix));\n};\n\nexport const convertSqlValueToJsValue = (value: SqlValue, sqlType: string): unknown => {", "  if (value === 'NULL') {\n    return null;\n  }\n\n  const lowerCaseSqlType = sqlType.toLowerCase();\n\n  if (\n    isType(lowerCaseSqlType, [\n      'varchar',\n      'nvarchar',\n      'char',\n      'nchar',\n      'text',\n      'ntext',\n      'xml',\n      'uniqueidentifier',\n    ])\n  ) {\n    return String(value);\n  }\n", "  if (\n    isType(lowerCaseSqlType, [\n      'int',\n      'smallint',\n      'tinyint',\n      'bigint',\n      'decimal',\n      'numeric',\n      'float',\n      'real',\n      'money',\n      'smallmoney',\n    ])\n  ) {\n    return Number(value);\n  }\n", "  if (isType(lowerCaseSqlType, ['bit'])) {\n    return Boolean(value);\n  }\n\n  if (isType(lowerCaseSqlType, ['date', 'datetime', 'datetime2', 'smalldatetime', 'time'])) {\n    if (isStringOrNumber(value) || isDate(value)) {\n      return new Date(value);\n    }\n    throw new Error('Cannot create a Date from a boolean value.');\n  }\n", "  if (isType(lowerCaseSqlType, ['binary', 'varbinary', 'image'])) {\n    return Buffer.from(value as Buffer);\n  }\n\n  if (isType(lowerCaseSqlType, ['rowversion', 'timestamp'])) {\n    return Buffer.from(value as Buffer);\n  }\n\n  if (isType(lowerCaseSqlType, ['hierarchyid', 'geometry', 'geography'])) {\n    return value;\n  }\n", "  if (isType(lowerCaseSqlType, ['hierarchyid', 'geometry', 'geography'])) {\n    return value;\n  }\n\n  if (isType(lowerCaseSqlType, ['tvp'])) {\n    throw new Error('TVPs are not supported.');\n  }\n\n  if (isType(lowerCaseSqlType, ['udt'])) {\n    throw new Error('UDTs are not supported.');\n  }\n\n  throw new Error(`Unsupported SQL type: ${sqlType}`);\n};\n", "  if (isType(lowerCaseSqlType, ['udt'])) {\n    throw new Error('UDTs are not supported.');\n  }\n\n  throw new Error(`Unsupported SQL type: ${sqlType}`);\n};\n"]}
{"filename": "src/lib/utils/connection-manager.ts", "chunked_list": ["import { ConnectionPool } from 'mssql';\n\nimport type { MSSQLConfig } from '../types';\n\n/**\n * Whether the given config is a string or not.\n * @param config - The config to check\n * @returns Whether the config is a string or not\n */\nexport const isConfigString = (config: MSSQLConfig): config is string => {", " */\nexport const isConfigString = (config: MSSQLConfig): config is string => {\n  return typeof config === 'string';\n};\n\n/**\n * A class for managing the global connection pools for the Query and Mutation data sources.\n */\nexport class ConnectionManager {\n  private static _queryConfig: MSSQLConfig;\n  private static _mutationConfig: MSSQLConfig;\n  private static _globalQueryPool: ConnectionPool | undefined;\n  private static _globalMutationPool: ConnectionPool | undefined;\n\n  /**\n   * Constructs a new ConnectionManager instance.\n   * @param {MSSQLConfig} queryConfig The config to be used for the Query data source\n   * @param {MSSQLConfig} mutationConfig The config to be used for the Mutation data source\n   */\n  constructor(queryConfig: MSSQLConfig, mutationConfig: MSSQLConfig) {", "export class ConnectionManager {\n  private static _queryConfig: MSSQLConfig;\n  private static _mutationConfig: MSSQLConfig;\n  private static _globalQueryPool: ConnectionPool | undefined;\n  private static _globalMutationPool: ConnectionPool | undefined;\n\n  /**\n   * Constructs a new ConnectionManager instance.\n   * @param {MSSQLConfig} queryConfig The config to be used for the Query data source\n   * @param {MSSQLConfig} mutationConfig The config to be used for the Mutation data source\n   */\n  constructor(queryConfig: MSSQLConfig, mutationConfig: MSSQLConfig) {", "    if (ConnectionManager._queryConfig === undefined) {\n      ConnectionManager._queryConfig = queryConfig;\n    }\n    if (ConnectionManager._mutationConfig === undefined) {\n      ConnectionManager._mutationConfig = mutationConfig;\n    }\n  }\n\n  /**\n   * Returns the global query connection pool.\n   */\n  public get queryConnectionPool(): ConnectionPool {", "    if (ConnectionManager._globalQueryPool === undefined) {\n      ConnectionManager._globalQueryPool = this.createConnectionPool(\n        ConnectionManager._queryConfig,\n      );\n    }\n    return ConnectionManager._globalQueryPool;\n  }\n\n  /**\n   * Returns the global mutation connection pool.\n   */\n  public get mutationConnectionPool(): ConnectionPool {", "    if (ConnectionManager._globalMutationPool === undefined) {\n      ConnectionManager._globalMutationPool = this.createConnectionPool(\n        ConnectionManager._mutationConfig,\n      );\n    }\n    return ConnectionManager._globalMutationPool;\n  }\n\n  private createConnectionPool(config: MSSQLConfig): ConnectionPool {\n    return isConfigString(config) ? new ConnectionPool(config) : new ConnectionPool(config);\n  }\n}\n"]}
{"filename": "src/lib/utils/index.ts", "chunked_list": ["export * from './cache-helper';\nexport * from './connection-manager';\nexport * from './type-map';\nexport * from './type-replacer';\n"]}
{"filename": "src/lib/utils/type-replacer.ts", "chunked_list": ["export const replacer = (key: string, value: any): unknown => {\n  if (typeof value === 'bigint') {\n    return { __type: 'BigInt', value: value.toString() };\n  } else if (value instanceof Date) {\n    return { __type: 'Date', value: value.toISOString() };\n  } else if (value instanceof Map) {\n    return { __type: 'Map', value: Array.from(value.entries()) };\n  } else if (value instanceof Set) {\n    return { __type: 'Set', value: Array.from(value.values()) };\n  } else if (value instanceof RegExp) {\n    return { __type: 'RegExp', value: value.toString() };", "  } else if (value instanceof RegExp) {\n    return { __type: 'RegExp', value: value.toString() };\n  } else if (value instanceof Buffer) {\n    return { __type: 'Buffer', value: value.toString('base64') };\n  } else {\n    return value;\n  }\n};\n"]}
{"filename": "src/lib/utils/graphql-helper.ts", "chunked_list": ["import { type GraphQLResolveInfo, type FieldNode, visit } from 'graphql';\n\n/**\n * Find the first node in the GraphQLResolveInfo with the given case insensitive name.\n * @param {GraphQLResolveInfo} info - The GraphQL resolve information object.\n * @param {string} nodeName - The case insensitive name of the node to find.\n * @returns {FieldNode | undefined} - The found node, or undefined if not found.\n */\nexport function findNodeByName(info: GraphQLResolveInfo, nodeName: string): FieldNode | undefined {\n  let targetNode: FieldNode | undefined;\n\n  // Iterate through the fieldNodes, stopping when the target node is found\n  info.fieldNodes.some((fieldNode) =>\n    visit(fieldNode, {\n      Field(node) {\n        // Compare the node's name (case insensitive) to the target nodeName", "export function findNodeByName(info: GraphQLResolveInfo, nodeName: string): FieldNode | undefined {\n  let targetNode: FieldNode | undefined;\n\n  // Iterate through the fieldNodes, stopping when the target node is found\n  info.fieldNodes.some((fieldNode) =>\n    visit(fieldNode, {\n      Field(node) {\n        // Compare the node's name (case insensitive) to the target nodeName\n        if (node.name.value.toLowerCase() === nodeName.toLowerCase()) {\n          targetNode = node;\n          return false; // Stop traversal once the target node is found\n        }\n      },\n    }),\n  );\n\n  return targetNode;\n}\n\n/**\n * Get a dictionary of all subfields of the given target node, where the keys are\n * the lowercase subfield names and the values are the correctly cased names.\n * @param {FieldNode} targetNode - The target node whose subfield names to retrieve.\n * @returns {Record<string, string>} - A dictionary mapping lowercase subfield names to their correctly cased names.\n */", "        if (node.name.value.toLowerCase() === nodeName.toLowerCase()) {\n          targetNode = node;\n          return false; // Stop traversal once the target node is found\n        }\n      },\n    }),\n  );\n\n  return targetNode;\n}\n\n/**\n * Get a dictionary of all subfields of the given target node, where the keys are\n * the lowercase subfield names and the values are the correctly cased names.\n * @param {FieldNode} targetNode - The target node whose subfield names to retrieve.\n * @returns {Record<string, string>} - A dictionary mapping lowercase subfield names to their correctly cased names.\n */", "export function getSelectionSetNames(targetNode: FieldNode): Record<string, string> {\n  const subfieldNames: Record<string, string> = {};\n\n  // If the target node has a selection set, visit its subfields and collect their names\n  if (targetNode.selectionSet !== undefined) {\n    visit(targetNode.selectionSet, {\n      Field(node) {\n        subfieldNames[node.name.value.toLowerCase()] = node.name.value;\n      },\n    });\n  }\n\n  return subfieldNames;\n}\n\n/**\n * Find the first node with the given case insensitive name in the GraphQLResolveInfo\n * and return a dictionary of its subfield names, where the keys are the lowercase\n * subfield names and the values are the correctly cased names.\n * @param {GraphQLResolveInfo} info - The GraphQL resolve information object.\n * @param {string} nodeName - The case insensitive name of the node to find.\n * @returns {Record<string, string>} - A dictionary of subfield names, or an empty dictionary if the node is not found.\n */", "export function getNodeSelectionSetNames(\n  info: GraphQLResolveInfo,\n  nodeName: string,\n): Record<string, string> {\n  const targetNode = findNodeByName(info, nodeName);\n\n  // If the target node is not found, return an empty dictionary\n  if (targetNode === undefined) {\n    return {};\n  }\n\n  // If the target node is found, return its subfield names\n  return getSelectionSetNames(targetNode);\n}\n\n/**\n * Get a dictionary of all field names excluding those of the given nodeName,\n * where the keys are the lowercase sibling field names and the values are the\n * correctly cased names.\n * @param {GraphQLResolveInfo} info - The GraphQL resolve information object.\n * @param {string} nodeName - The case insensitive name of the node to exclude.\n * @returns {Record<string, string>} - A dictionary mapping lowercase sibling field names to their correctly cased names, or an empty dictionary if the node is not found.\n */", "export function getFieldNamesExcludingNode(\n  info: GraphQLResolveInfo,\n  nodeName: string,\n): Record<string, string> {\n  const siblingFields: Record<string, string> = {};\n  info.fieldNodes.forEach((fieldNode) => {\n    visit(fieldNode, {\n      Field(node) {\n        const isTargetNode = node.name.value.toLowerCase() === nodeName.toLowerCase();\n        if (isTargetNode) {\n          return false;\n        } else {\n          siblingFields[node.name.value.toLowerCase()] = node.name.value;\n        }\n      },\n    });\n  });\n  return siblingFields;\n}\n", "        if (isTargetNode) {\n          return false;\n        } else {\n          siblingFields[node.name.value.toLowerCase()] = node.name.value;\n        }\n      },\n    });\n  });\n  return siblingFields;\n}\n"]}
{"filename": "src/lib/utils/cache-helper.ts", "chunked_list": ["import crypto from 'crypto';\n\nimport type { KeyValueCache } from '@apollo/utils.keyvaluecache';\n\nexport class CacheHelper<T> {\n  /**\n   * Constructs a new CacheHelper instance.\n   * @param _cache The cache to be used for storing and retrieving T\n   */\n  constructor(private readonly _cache: KeyValueCache<T>) {}\n\n  /**\n   * Returns the hash of the given key using the SHA1 algorithm.\n   * This is used to generate unique cache keys for storing T.\n   *\n   * @param key The string to be hashed\n   * @returns The hashed key as a base64 string\n   */\n  private hashKey(key: string): string {\n    return crypto.createHash('sha1').update(key).digest('base64');\n  }\n\n  /**\n   * Attempts to retrieve the cached T for the given key.\n   * @param keyToHash The key to be hashed and used to lookup the cached T\n   * @returns The cached T if it exists, otherwise undefined\n   */\n  public async tryGetFromCache(keyToHash: string): Promise<T | undefined> {\n    const key = this.hashKey(keyToHash);\n    return await this._cache.get(key);\n  }\n\n  /**\n   * Caches the given T using the given key.\n   * @param keyToHash The key to be hashed and used to store the T\n   * @param result The result to be cached\n   */\n  public async addToCache(keyToHash: string, obj: T): Promise<void> {\n    const key = this.hashKey(keyToHash);\n    await this._cache.set(key, obj);\n  }\n}\n"]}
{"filename": "src/lib/logging/dev-console-logger.ts", "chunked_list": ["import type { ILogger } from '../types';\n\n/**\n * A logger that logs messages to the console.\n */\nexport class DevConsoleLogger implements ILogger {\n  private readonly _isDev: boolean;\n\n  /**\n   * Creates a new instance of the ConsoleLogger class.\n   */\n  constructor() {\n    this._isDev = process.env.NODE_ENV !== 'production';\n  }\n\n  /**\n   * Logs an informational message to the console.\n   * @param {unknown} message The message to log\n   * @param {unknown[]} optionalParams Optional parameters to log\n   */\n  info(message?: unknown, ...optionalParams: unknown[]): void {", "    if (this._isDev) {\n      console.info(message, ...optionalParams);\n    }\n  }\n\n  /**\n   * Logs an error message to the console.\n   * @param {unknown} message The message to log\n   * @param {unknown[]} optionalParams Optional parameters to log\n   */\n  error(message?: unknown, ...optionalParams: unknown[]): void {\n    console.error(message, ...optionalParams);\n  }\n}\n"]}
{"filename": "src/lib/logging/index.ts", "chunked_list": ["export * from './logging-utils';\nexport * from './dev-console-logger';\n"]}
{"filename": "src/lib/logging/logging-utils.ts", "chunked_list": ["import { performance } from 'perf_hooks';\n\nimport type { ILogger } from '../types';\nimport { replacer } from '../utils';\n\n/**\n * Logs a message using the logger for the given resolver type and method.\n *\n * @param logger The logger to be used\n * @param method The logger method to be used (info, log, warn, error, trace)\n * @param args The arguments to be passed to the logger method\n */\nexport const logSafely = (logger: ILogger, method: keyof ILogger, ...args: unknown[]): void => {", "  if (method !== undefined) {\n    const loggingMethod = logger[method];\n    if (loggingMethod !== undefined) {\n      loggingMethod.bind(logger)(...args);\n    }\n  }\n};\n\n/**\n * Calculates and logs the elapsed time using the given startTime for the specified method name.\n *\n * @param logger The logger to be used\n * @param methodName The method that was executed to be logged\n * @param startTime The start time of the method execution\n */\nexport const logPerformance = (logger: ILogger, methodName: string, startTime: number): void => {\n  const elapsedTime = (performance.now() - startTime).toFixed(2);\n  logSafely(\n    logger,\n    'info',\n    // Blue\n    `\\x1b[34mExecution time for ${methodName}: ${elapsedTime} milliseconds.\\x1b[0m`,\n  );\n};\n\n/**", " * Logs the beginning of a function execution including arguments.\n *\n * @param {ILogger} logger The logger to be used\n * @param {string} fnName The object that was executed to be logged\n * @param {object} fnInput The input to be logged\n */\nexport const logExecutionBegin = (\n  logger: ILogger,\n  fnName: string,\n  fnInput: { toString: () => string },\n  ansiCode: string = '36m', // Cyan\n): void => {\n  logSafely(\n    logger,\n    'info',\n    // Cyan\n    `\\u001b[${ansiCode}Starting execution of ${fnName}: ${JSON.stringify(\n      fnInput,\n      replacer,\n      0,\n    )}\\u001b[0m`,\n  );\n};\n\n/**", " * Logs the end of a function execution including elapsed time.\n *\n * @param {ILogger} logger The logger to be used\n * @param {string} fnName The object that was executed to be logged\n * @param {number} fnStartTime The start time of the method execution\n */\nexport const logExecutionEnd = (\n  logger: ILogger,\n  fnName: string,\n  fnStartTime: number,\n  ansiCode: string = '36m', // Cyan\n): void => {\n  const elapsedTime = (performance.now() - fnStartTime).toFixed(2);\n  logSafely(\n    logger,\n    'info',\n    `\\u001b[${ansiCode}Finished executing ${fnName} completed in ${elapsedTime}ms\\u001b[0m`,\n  );\n};\n"]}
{"filename": "src/lib/executor/database-executor.ts", "chunked_list": ["import { performance } from 'perf_hooks';\n\nimport { type ConnectionPool, Request } from 'mssql';\n\nimport type { ILogger, IDatabaseExecutor } from '../types';\nimport { logPerformance } from '../logging';\nimport { type ConnectionManager } from '../utils';\n\n/**\n * @class\n * @implements {IDatabaseExecutor}\n */", "export class DatabaseExecutor implements IDatabaseExecutor {\n  constructor(private readonly _connectionManager: ConnectionManager) {}\n\n  /**\n   * @inheritdoc\n   */\n  public async executeQueryRequest<T>(\n    requestFn: (request: Request) => Promise<T>,\n    logger: ILogger,\n  ): Promise<T> {\n    return await this.executeRequest(\n      this._connectionManager.queryConnectionPool,\n      requestFn,\n      logger,\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public async executeMutationRequest<T>(\n    requestFn: (request: Request) => Promise<T>,\n    logger: ILogger,\n  ): Promise<T> {\n    return await this.executeRequest(\n      this._connectionManager.mutationConnectionPool,\n      requestFn,\n      logger,\n    );\n  }\n\n  /**", "   * Executes the given request function with a new Request instance\n   * using the appropriate ConnectionPool for the resolver type.\n   * This method ensures the ConnectionPool is connected before\n   * invoking the request function.\n   *\n   * @param {Promise<ConnectionPool>} connectionPool The function to be executed to get the ConnectionPool\n   * @param {(request: Request): Promise<T>} requestFn The function to be executed with the new Request instance\n   * @returns The result of the request function\n   */\n  private async executeRequest<T>(\n    connectionPool: ConnectionPool,\n    requestFn: (request: Request) => Promise<T>,\n    logger: ILogger,\n  ): Promise<T> {\n    const startTime = performance.now();", "    if (!connectionPool.connected) {\n      await connectionPool.connect();\n    }\n    logPerformance(logger, 'connect', startTime);\n\n    return await requestFn(new Request(connectionPool));\n  }\n}\n"]}
{"filename": "src/lib/executor/index.ts", "chunked_list": ["export * from './database-executor';\n"]}
{"filename": "src/lib/stored-procedure/stored-procedure-cache-manager.ts", "chunked_list": ["import { InMemoryLRUCache } from '@apollo/utils.keyvaluecache';\n\nimport { CacheHelper } from '../utils';\n\n/**\n * A class that manages the global cache for stored procedures.\n */\nexport class StoredProcedureCacheManager {\n  private static _globalCache: CacheHelper<object>;\n\n  private static get defaultCache(): InMemoryLRUCache<object> {\n    return new InMemoryLRUCache<object>({\n      // Default TTL is 3600000 ms or 1 hour.\n      ttl: 60 * 60 * 1000,\n      ttlAutopurge: false,\n    });\n  }\n\n  private static get globalCache(): CacheHelper<object> {", "    if (this._globalCache === undefined) {\n      this._globalCache = new CacheHelper(StoredProcedureCacheManager.defaultCache);\n    }\n    return this._globalCache;\n  }\n\n  /**\n   * Attempts to retrieve the cached object from the global cache for the given key.\n   * @param keyToHash The key to be hashed and used to lookup the cached object\n   * @returns The cached object if it exists, otherwise undefined\n   */\n  public async tryGetFromCache(keyToHash: string): Promise<object | undefined> {\n    return await StoredProcedureCacheManager.globalCache.tryGetFromCache(keyToHash);\n  }\n\n  /**\n   * Caches the given result in the global cache using the given key.\n   * @param keyToHash The key to be hashed and used to store the result\n   * @param result The result to be cached\n   */\n  public async addToCache(keyToHash: string, result: object): Promise<void> {\n    await StoredProcedureCacheManager.globalCache.addToCache(keyToHash, result);\n  }\n}\n"]}
{"filename": "src/lib/stored-procedure/stored-procedure-metadata-manager.ts", "chunked_list": ["import { type IResult, type Request } from 'mssql';\n\nimport type { StoredProcedureParameter, StoredProcedureSchema, ILogger } from '../types';\nimport { type DatabaseExecutor } from '../executor';\nimport { convertSqlValueToJsValue } from '../utils';\n\n/**\n * A manager for stored procedure metadata.\n * Handles the retrieval and caching of stored procedure metadata.\n */\nexport class StoredProcedureMetadataManager {\n  /**\n   * Regular expression to extract MSSQL stored procedure names.\n   * See https://regex101.com/r/cMsTyT/1 for this regex.\n   */\n  private static readonly storedProcedureNameRegex =\n    /((?:(?:\\[([\\w\\s]+)\\]|(\\w+))\\.)?(?:\\[([\\w\\s]+)\\]|(\\w+))\\.(?:\\[([\\w\\s]+)\\]|(\\w+)))/i;\n\n  /**\n   * Matches any comments from the Stored Procedure definition.\n   * See https://regex101.com/r/dxA7n0/1 for this regex.\n   */\n  private static readonly commentRegex = /(?:\\s*-{2}.+\\s*$)|(?:\\/\\*([\\s\\S]*?)\\*\\/)/gm;\n\n  /**\n   * Matches the parameters from the Stored Procedure definition.\n   * See https://regex101.com/r/4TaTky/1 for this regex.\n   */\n  private static readonly parameterSectionRegex =\n    /(?<=(?:CREATE|ALTER)\\s+PROCEDURE)\\s+((?:(?:\\[([\\w\\s]+)\\]|(\\w+))\\.)?(?:\\[([\\w\\s]+)\\]|(\\w+))\\.(?:\\[([\\w\\s]+)\\]|(\\w+)))(.*?)(?=(?:AS|FOR\\s+REPLICATION)[^\\w])/is;\n\n  /**\n   * See https://regex101.com/r/iMEaLb/1 for this regex.\n   * Match the individual parameters in the Parameter Definition.\n   */\n  private static readonly parameterDefinitionRegex = /(@[\\w]+)\\s+([^\\s]+)\\s*=\\s*([^, ]*),?/gi;\n\n  constructor(private readonly _databaseExecutor: DatabaseExecutor) {}\n\n  /**\n   * Parses the stored procedure parameter schema into a StoredProcedureParameter array.\n   * @param {string} storedProcedureName - The name of the stored procedure to retrieve the parameter schema for.\n   * @returns A Promise that resolves to the result of the stored procedure execution.\n   */\n  public async getStoredProcedureParameterSchema(\n    storedProcedureName: string,\n    logger: ILogger,\n  ): Promise<IResult<StoredProcedureSchema>> {\n    return await this._databaseExecutor.executeQueryRequest(async (request: Request) => {\n      // Remove square bracket notation if any, and split into schema and name.\n      const schemaAndName = storedProcedureName.replace(/\\[|\\]/g, '').split('.');\n      const result = await request.query<StoredProcedureSchema>(\n        'SELECT ' +\n          'PARAMETER_NAME as name, ' +\n          'DATA_TYPE as type, ' +\n          'PARAMETER_MODE as mode, ' +\n          'CHARACTER_MAXIMUM_LENGTH length, ' +\n          'NUMERIC_PRECISION as precision, ' +\n          'NUMERIC_SCALE as scale ' +\n          'FROM INFORMATION_SCHEMA.PARAMETERS ' +\n          `WHERE SPECIFIC_SCHEMA = '${schemaAndName[0]}' AND SPECIFIC_NAME = '${schemaAndName[1]}';\n            SELECT OBJECT_DEFINITION(OBJECT_ID('${storedProcedureName}')) AS storedProcedureDefinition;`,\n      );\n\n      const recordSetLength = result.recordsets.length as number;", "export class StoredProcedureMetadataManager {\n  /**\n   * Regular expression to extract MSSQL stored procedure names.\n   * See https://regex101.com/r/cMsTyT/1 for this regex.\n   */\n  private static readonly storedProcedureNameRegex =\n    /((?:(?:\\[([\\w\\s]+)\\]|(\\w+))\\.)?(?:\\[([\\w\\s]+)\\]|(\\w+))\\.(?:\\[([\\w\\s]+)\\]|(\\w+)))/i;\n\n  /**\n   * Matches any comments from the Stored Procedure definition.\n   * See https://regex101.com/r/dxA7n0/1 for this regex.\n   */\n  private static readonly commentRegex = /(?:\\s*-{2}.+\\s*$)|(?:\\/\\*([\\s\\S]*?)\\*\\/)/gm;\n\n  /**\n   * Matches the parameters from the Stored Procedure definition.\n   * See https://regex101.com/r/4TaTky/1 for this regex.\n   */\n  private static readonly parameterSectionRegex =\n    /(?<=(?:CREATE|ALTER)\\s+PROCEDURE)\\s+((?:(?:\\[([\\w\\s]+)\\]|(\\w+))\\.)?(?:\\[([\\w\\s]+)\\]|(\\w+))\\.(?:\\[([\\w\\s]+)\\]|(\\w+)))(.*?)(?=(?:AS|FOR\\s+REPLICATION)[^\\w])/is;\n\n  /**\n   * See https://regex101.com/r/iMEaLb/1 for this regex.\n   * Match the individual parameters in the Parameter Definition.\n   */\n  private static readonly parameterDefinitionRegex = /(@[\\w]+)\\s+([^\\s]+)\\s*=\\s*([^, ]*),?/gi;\n\n  constructor(private readonly _databaseExecutor: DatabaseExecutor) {}\n\n  /**\n   * Parses the stored procedure parameter schema into a StoredProcedureParameter array.\n   * @param {string} storedProcedureName - The name of the stored procedure to retrieve the parameter schema for.\n   * @returns A Promise that resolves to the result of the stored procedure execution.\n   */\n  public async getStoredProcedureParameterSchema(\n    storedProcedureName: string,\n    logger: ILogger,\n  ): Promise<IResult<StoredProcedureSchema>> {\n    return await this._databaseExecutor.executeQueryRequest(async (request: Request) => {\n      // Remove square bracket notation if any, and split into schema and name.\n      const schemaAndName = storedProcedureName.replace(/\\[|\\]/g, '').split('.');\n      const result = await request.query<StoredProcedureSchema>(\n        'SELECT ' +\n          'PARAMETER_NAME as name, ' +\n          'DATA_TYPE as type, ' +\n          'PARAMETER_MODE as mode, ' +\n          'CHARACTER_MAXIMUM_LENGTH length, ' +\n          'NUMERIC_PRECISION as precision, ' +\n          'NUMERIC_SCALE as scale ' +\n          'FROM INFORMATION_SCHEMA.PARAMETERS ' +\n          `WHERE SPECIFIC_SCHEMA = '${schemaAndName[0]}' AND SPECIFIC_NAME = '${schemaAndName[1]}';\n            SELECT OBJECT_DEFINITION(OBJECT_ID('${storedProcedureName}')) AS storedProcedureDefinition;`,\n      );\n\n      const recordSetLength = result.recordsets.length as number;", "      if (recordSetLength < 1 || recordSetLength > 2) {\n        throw new Error(\n          `Could not retrieve stored procedure parameter schema from Database for stored procedure ${storedProcedureName}.`,\n        );\n      }\n\n      if (recordSetLength !== 2 || result.recordsets[1].length !== 1) {\n        throw new Error(\n          `Could not retrieve stored procedure definition from Database for stored procedure ${storedProcedureName}.`,\n        );\n      }\n\n      return result;\n    }, logger);\n  }\n\n  /**\n   * Parses the stored procedure parameter schema into a StoredProcedureParameter array.\n   * @param {string} storedProcedureName - The name of the stored procedure to parse the parameter schema for.\n   * @param {IResult<StoredProcedureSchema>} schemaResult - The result of the stored procedure parameter schema query.\n   * @returns A StoredProcedureParameter array.\n   */\n  public parseStoredProcedureParameters(\n    storedProcedureName: string,\n    schemaResult: IResult<StoredProcedureSchema>,\n  ): IterableIterator<StoredProcedureParameter> {\n    const parameterSchemaMap: Map<string, StoredProcedureParameter> =\n      schemaResult.recordsets[0].reduce(\n        (parameterMap: Map<string, StoredProcedureParameter>, item: StoredProcedureParameter) => {\n          parameterMap.set(item.name, item);\n          return parameterMap;\n        },\n        new Map<string, StoredProcedureParameter>(),\n      );\n\n    const storedProcedureDefinition = schemaResult.recordsets[1][0].storedProcedureDefinition;", "    if (storedProcedureDefinition == null) {\n      throw new Error(\n        `Could not parse stored procedure definition for stored procedure ${storedProcedureName}.`,\n      );\n    }\n\n    const commentStrippedStoredProcedureDefinition = storedProcedureDefinition.replace(\n      StoredProcedureMetadataManager.commentRegex,\n      '',\n    );\n    if (commentStrippedStoredProcedureDefinition === '') {\n      throw new Error(\n        `Could not parse stored procedure comments from definition for stored procedure ${storedProcedureName}.`,\n      );\n    }\n\n    const parameterSection = commentStrippedStoredProcedureDefinition.match(\n      StoredProcedureMetadataManager.parameterSectionRegex,\n    );", "    if (commentStrippedStoredProcedureDefinition === '') {\n      throw new Error(\n        `Could not parse stored procedure comments from definition for stored procedure ${storedProcedureName}.`,\n      );\n    }\n\n    const parameterSection = commentStrippedStoredProcedureDefinition.match(\n      StoredProcedureMetadataManager.parameterSectionRegex,\n    );\n    if (parameterSection === null || parameterSection.length !== 9) {\n      throw new Error(\n        `Could not parse stored procedure parameters from definition for stored procedure ${storedProcedureName}.`,\n      );\n    }\n\n    const parameterDefinition = parameterSection[8];\n\n    let parameterDefinitionMatch;", "    if (parameterSection === null || parameterSection.length !== 9) {\n      throw new Error(\n        `Could not parse stored procedure parameters from definition for stored procedure ${storedProcedureName}.`,\n      );\n    }\n\n    const parameterDefinition = parameterSection[8];\n\n    let parameterDefinitionMatch;\n    while (\n      (parameterDefinitionMatch =\n        StoredProcedureMetadataManager.parameterDefinitionRegex.exec(parameterDefinition)) !== null\n    ) {\n      const name = parameterDefinitionMatch[1];\n      const type = parameterDefinitionMatch[2];\n      const defaultValue = parameterDefinitionMatch[3];\n      const parameter = parameterSchemaMap.get(name);", "    while (\n      (parameterDefinitionMatch =\n        StoredProcedureMetadataManager.parameterDefinitionRegex.exec(parameterDefinition)) !== null\n    ) {\n      const name = parameterDefinitionMatch[1];\n      const type = parameterDefinitionMatch[2];\n      const defaultValue = parameterDefinitionMatch[3];\n      const parameter = parameterSchemaMap.get(name);\n      if (parameter !== undefined) {\n        parameter.defaultValue = convertSqlValueToJsValue(defaultValue, type);\n      }\n    }\n\n    return parameterSchemaMap.values();\n  }\n}\n", "      if (parameter !== undefined) {\n        parameter.defaultValue = convertSqlValueToJsValue(defaultValue, type);\n      }\n    }\n\n    return parameterSchemaMap.values();\n  }\n}\n"]}
{"filename": "src/lib/stored-procedure/stored-procedure-manager.ts", "chunked_list": ["import { camelCase } from 'lodash';\nimport { type Request, type IProcedureResult, type IResult, type IRecordSet } from 'mssql';\nimport { type GraphQLResolveInfo } from 'graphql';\n\nimport {\n  type DriverType,\n  type PreparedStoredProcedureParameter,\n  ParameterMode,\n  type StoredProcedureSchema,\n  type StoredProcedureParameter,\n  type ILogger,", "  type StoredProcedureSchema,\n  type StoredProcedureParameter,\n  type ILogger,\n  type InputParameters,\n} from '../types';\nimport { mapDbTypeToDriverType, replacer } from '../utils';\nimport { logExecutionBegin, logPerformance, logSafely } from '../logging';\nimport {\n  type StoredProcedureCacheManager,\n  type StoredProcedureMetadataManager,\n} from '../stored-procedure';", "  type StoredProcedureCacheManager,\n  type StoredProcedureMetadataManager,\n} from '../stored-procedure';\nimport { type IResolverProcedureResult } from '../types/i-resolver-procedure-result';\nimport { getNodeSelectionSetNames, getFieldNamesExcludingNode } from '../utils/graphql-helper';\n\n/**\n * StoredProcedureManager provides methods to interact\n * with a Microsoft SQL Server database for managing stored procedures.\n */\nexport class StoredProcedureManager {\n  /**\n   * Creates a new instance of StoredProcedureManager.\n   */\n  constructor(\n    private readonly _storedProcedureCacheManager: StoredProcedureCacheManager,\n    private readonly _storedProcedureMetadataManager: StoredProcedureMetadataManager,\n  ) {}\n\n  /**\n   * Executes a stored procedure with the provided input parameters, and returns the result.", "export class StoredProcedureManager {\n  /**\n   * Creates a new instance of StoredProcedureManager.\n   */\n  constructor(\n    private readonly _storedProcedureCacheManager: StoredProcedureCacheManager,\n    private readonly _storedProcedureMetadataManager: StoredProcedureMetadataManager,\n  ) {}\n\n  /**\n   * Executes a stored procedure with the provided input parameters, and returns the result.", "   * @template TVal - The type of records in the result set.\n   * @template TRet - The type of the result object to be returned.\n   * @param {string} storedProcedureName - The name of the stored procedure to execute.\n   * @param {StoredProcedureInput} input - The input parameters for the stored procedure.\n   * @param {Request} request - The request to execute the stored procedure.\n   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n   * procedure results to the correct schema field names.\n   * @param {ILogger} logger - The logger to use for logging.\n   * @returns A Promise that resolves to the result of the stored procedure execution.\n   */\n  public async executeStoredProcedure<T>(\n    storedProcedureName: string,\n    input: InputParameters,\n    request: Request,\n    logger: ILogger,\n    info?: GraphQLResolveInfo,\n  ): Promise<IResolverProcedureResult<T>> {\n    let startTime = performance.now();\n    let schema = (await this._storedProcedureCacheManager.tryGetFromCache(storedProcedureName)) as\n      | IResult<StoredProcedureSchema>\n      | undefined;", "    if (schema === undefined) {\n      logSafely(\n        logger,\n        'info',\n        // Yellow\n        `\\x1b[33mCache miss occurred while retrieving the cached schema for ${storedProcedureName}\\x1b[0m`,\n      );\n      schema = await this._storedProcedureMetadataManager.getStoredProcedureParameterSchema(\n        storedProcedureName,\n        logger,\n      );\n      await this._storedProcedureCacheManager.addToCache(storedProcedureName, schema);\n    } else {\n      logSafely(\n        logger,\n        'info',\n        // Green\n        `\\x1b[32mCache hit occurred while retrieving the cached schema for ${storedProcedureName}\\x1b[0m`,\n      );\n    }\n    logPerformance(logger, 'getStoredProcedureParameterSchema', startTime);\n\n    startTime = performance.now();\n    const storedProcedureParameters =\n      this._storedProcedureMetadataManager.parseStoredProcedureParameters(\n        storedProcedureName,\n        schema,\n      );\n    logPerformance(logger, 'parseStoredProcedureParameters', startTime);\n\n    startTime = performance.now();\n    const preparedRequest = this.prepareStoredProcedureRequest(\n      storedProcedureParameters,\n      input,\n      request,\n    );\n    logPerformance(logger, 'prepareStoredProcedureRequest', startTime);\n\n    startTime = performance.now();\n    logExecutionBegin(\n      logger,\n      `Stored Procedure ${storedProcedureName} with parameters`,\n      preparedRequest.parameters,\n      // Green\n      '32m',\n    );\n    const result = await preparedRequest.execute(storedProcedureName);\n\n    startTime = performance.now();\n    const preparedResult = this.prepareStoredProcedureResult(result, info);\n    logPerformance(logger, 'prepareStoredProcedureResult', startTime);\n\n    return preparedResult;\n  }\n\n  private prepareParameters(\n    storedProcedureParameters: IterableIterator<StoredProcedureParameter>,\n    input: InputParameters,\n  ): Map<string, PreparedStoredProcedureParameter> {\n    // We want to use the inferred DB Stored Procedure schema as the source of truth.\n    const preparedParameters = new Map<string, PreparedStoredProcedureParameter>();", "    for (const spParameter of storedProcedureParameters) {\n      const { name, type, length, precision, scale, ...rest } = spParameter;\n      const parameterName = name.slice(1);\n      // Let's use the parameter name in lowercase as the lookup key.\n      preparedParameters.set(parameterName.toLowerCase(), {\n        name: parameterName,\n        type: mapDbTypeToDriverType({\n          type,\n          length,\n          precision,\n          scale,\n        }) as DriverType,\n        value: undefined,\n        ...rest,\n      });\n    }\n\n    // Populate our input values into the request parameters.\n    const inputParameters = input as Record<string, unknown>;", "    for (const inputParameterKey in inputParameters) {\n      const preparedParameter = preparedParameters.get(inputParameterKey.toLowerCase());\n      if (preparedParameter != null) {\n        preparedParameter.value = inputParameters[inputParameterKey];\n      }\n      // We don't care about provided input parameters that are missing in the Stored Procedure definition.\n    }\n\n    return preparedParameters;\n  }\n\n  private getMissingRequiredParameters(\n    parameters: Map<string, PreparedStoredProcedureParameter>,\n  ): PreparedStoredProcedureParameter[] {\n    // Check what required parameters are missing.\n    const missingRequiredParameters = [];", "    for (const parameter of parameters.values()) {\n      // If they have a default value they can be ommitted from the request.\n      if (parameter.defaultValue === undefined && parameter.value === undefined) {\n        missingRequiredParameters.push(parameter);\n      }\n    }\n    return missingRequiredParameters;\n  }\n\n  private addParametersToRequest(\n    parameters: Map<string, PreparedStoredProcedureParameter>,\n    request: Request,\n  ): Request {\n    const preparedRequest = request;", "    for (const parameter of parameters.values()) {\n      const { name, type, mode, value, defaultValue } = parameter;\n      if (defaultValue !== undefined && value === undefined) {\n        continue;\n      }\n\n      const modeEnum = mode;\n      if (modeEnum === ParameterMode.IN) {\n        preparedRequest.input(name, type, value);\n      } else if (modeEnum === ParameterMode.INOUT) {\n        preparedRequest.output(name, type, value);\n      } else {\n        throw new Error(`Unknown parameter mode: ${mode}`);\n      }\n    }\n    return preparedRequest;\n  }\n\n  /**\n   * Prepares the stored procedure request.\n   * @param {IterableIterator<StoredProcedureParameter>} storedProcedureParameters - The stored procedure parameters.\n   * @param {StoredProcedureInput} input - The input object.\n   * @param {Request} request - The request object.\n   * @returns A prepared request object.\n   */\n  private prepareStoredProcedureRequest(\n    storedProcedureParameters: IterableIterator<StoredProcedureParameter>,\n    input: InputParameters,\n    request: Request,\n  ): Request {\n    const parameters = this.prepareParameters(storedProcedureParameters, input);\n\n    const missingRequiredParameters = this.getMissingRequiredParameters(parameters);\n    const missingLength = missingRequiredParameters.length;", "      } else if (modeEnum === ParameterMode.INOUT) {\n        preparedRequest.output(name, type, value);\n      } else {\n        throw new Error(`Unknown parameter mode: ${mode}`);\n      }\n    }\n    return preparedRequest;\n  }\n\n  /**\n   * Prepares the stored procedure request.\n   * @param {IterableIterator<StoredProcedureParameter>} storedProcedureParameters - The stored procedure parameters.\n   * @param {StoredProcedureInput} input - The input object.\n   * @param {Request} request - The request object.\n   * @returns A prepared request object.\n   */\n  private prepareStoredProcedureRequest(\n    storedProcedureParameters: IterableIterator<StoredProcedureParameter>,\n    input: InputParameters,\n    request: Request,\n  ): Request {\n    const parameters = this.prepareParameters(storedProcedureParameters, input);\n\n    const missingRequiredParameters = this.getMissingRequiredParameters(parameters);\n    const missingLength = missingRequiredParameters.length;", "    if (missingLength > 0) {\n      throw new Error(\n        `Missing ${missingLength} required parameters: ${missingRequiredParameters\n          .map((param) => JSON.stringify(param, replacer, 0))\n          .join(', ')}.`,\n      );\n    }\n\n    const preparedRequest = this.addParametersToRequest(parameters, request);\n\n    return preparedRequest;\n  }\n\n  /**\n   * Maps the keys of an object based on the provided mapping.", "   * @template T - The type of the original object.\n   * @param {T} obj - The object whose keys need to be mapped.\n   * @param {Record<string, string>} mapping - A dictionary containing the mapping of the original keys to the new keys.\n   * @returns {T} A new object with the keys mapped according to the provided mapping.\n   */\n  private mapKeysWithMapping<T extends Record<string, unknown>>(\n    obj: T,\n    mapping: Record<string, string>,\n  ): T {\n    const result: Record<string, unknown> = {};\n    for (const key in obj) {\n      const mappedKey = mapping[key.toLowerCase()] ?? camelCase(key);\n      result[mappedKey] = obj[key];\n    }\n    return result as T;\n  }\n\n  /**\n   * Prepares the stored procedure result into a GraphQL result object.\n   * @param {IProcedureResult} result - The stored procedure result.\n   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n   * procedure results to the correct schema field names.\n   * @returns {IResolverProcedureResult} A prepared GraphQL result object.\n   */\n  private prepareStoredProcedureResult<T extends Record<string, unknown>>(\n    result: IProcedureResult<T>,\n    info?: GraphQLResolveInfo,\n  ): IResolverProcedureResult<T> {\n    const { resultSetFields, outputFields } =\n      info !== undefined\n        ? {\n            resultSetFields: getNodeSelectionSetNames(info, 'resultSets'),\n            outputFields: getFieldNamesExcludingNode(info, 'resultSets'),\n          }\n        : { resultSetFields: {}, outputFields: {} };\n\n    const resultSets = result.recordsets.map((recordset: IRecordSet<Record<string, unknown>>) => {\n      return recordset.map((record: Record<string, unknown>) =>\n        this.mapKeysWithMapping(record, resultSetFields),\n      );\n    });\n\n    const output = this.mapKeysWithMapping(result.output, outputFields);\n\n    const preparedResult = {\n      returnValue: result.returnValue,\n      resultSets: resultSets as T[][],\n      rowsAffected: result.rowsAffected,\n      ...output,\n    };\n    return preparedResult;\n  }\n}\n", "    for (const key in obj) {\n      const mappedKey = mapping[key.toLowerCase()] ?? camelCase(key);\n      result[mappedKey] = obj[key];\n    }\n    return result as T;\n  }\n\n  /**\n   * Prepares the stored procedure result into a GraphQL result object.\n   * @param {IProcedureResult} result - The stored procedure result.\n   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n   * procedure results to the correct schema field names.\n   * @returns {IResolverProcedureResult} A prepared GraphQL result object.\n   */\n  private prepareStoredProcedureResult<T extends Record<string, unknown>>(\n    result: IProcedureResult<T>,\n    info?: GraphQLResolveInfo,\n  ): IResolverProcedureResult<T> {\n    const { resultSetFields, outputFields } =\n      info !== undefined\n        ? {\n            resultSetFields: getNodeSelectionSetNames(info, 'resultSets'),\n            outputFields: getFieldNamesExcludingNode(info, 'resultSets'),\n          }\n        : { resultSetFields: {}, outputFields: {} };\n\n    const resultSets = result.recordsets.map((recordset: IRecordSet<Record<string, unknown>>) => {\n      return recordset.map((record: Record<string, unknown>) =>\n        this.mapKeysWithMapping(record, resultSetFields),\n      );\n    });\n\n    const output = this.mapKeysWithMapping(result.output, outputFields);\n\n    const preparedResult = {\n      returnValue: result.returnValue,\n      resultSets: resultSets as T[][],\n      rowsAffected: result.rowsAffected,\n      ...output,\n    };\n    return preparedResult;\n  }\n}\n"]}
{"filename": "src/lib/stored-procedure/index.ts", "chunked_list": ["export * from './stored-procedure-cache-manager';\nexport * from './stored-procedure-manager';\nexport * from './stored-procedure-metadata-manager';\n"]}
{"filename": "src/lib/types/i-stored-procedure-parameter.ts", "chunked_list": ["import type { ParameterMode } from '.';\n\n/**\n * Represents a subset of used metadata for an MSSQL stored procedure parameter.\n * @property {string} name - The name of the parameter. Begins with @.\n * @property {string} type - The MSSQL data type of the parameter.\n * @property {ParameterMode} mode - The MSSQL mode of the parameter. Either 'IN', 'INOUT' or 'UNKNOWN'.\n * @property {unknown} defaultValue - The default value of the parameter, if any, or undefined.\n * @property {number} length - The length of character-based parameters, or undefined.\n * @property {number} precision - The precision of floating point parameters, or undefined.\n * @property {number} scale - The scale of floating point parameters, or undefined.\n */", "export interface StoredProcedureParameter {\n  name: string;\n  type: string;\n  mode: ParameterMode;\n  defaultValue?: unknown;\n  length?: number;\n  precision?: number;\n  scale?: number;\n}\n"]}
{"filename": "src/lib/types/i-resolver-procedure-result.ts", "chunked_list": ["/**\n * Represents a GraphQL resolver stored procedure result.\n * The format of the result is: a single resultSet property, followed by\n * any additional output properties that were returned by the stored procedure.\n */\nexport interface IResolverProcedureResult<T> extends Record<string, unknown> {\n  returnValue?: number;\n  resultSets?: T[][];\n  rowsAffected?: number[];\n}\n"]}
{"filename": "src/lib/types/prepared-stored-procedure-parameter.ts", "chunked_list": ["import type { StoredProcedureParameter, DriverType } from '.';\n\n/**\n * Final parameters that will be passed to the stored procedure request.\n */\nexport type PreparedStoredProcedureParameter = Omit<StoredProcedureParameter, 'type'> & {\n  type: DriverType;\n  value?: unknown;\n};\n"]}
{"filename": "src/lib/types/input-parameters.ts", "chunked_list": ["/**\n * Input parameters that will be prepared and passed to the stored procedure request.\n */\n// export interface InputParameter extends Record<string, unknown> {}\nexport type InputParameters = Record<string, unknown>;\n"]}
{"filename": "src/lib/types/mssql-config.ts", "chunked_list": ["import type { config } from 'mssql';\n\n/**\n * Represents a configuration object for a MSSQL database.\n * Can be an mssql config or Connection String.\n */\nexport type MSSQLConfig = config | string;\n"]}
{"filename": "src/lib/types/driver-type.ts", "chunked_list": ["import type { ISqlType } from 'mssql';\n\n/**\n * Driver types that can be used to specify the type of a stored procedure parameter.\n */\nexport type DriverType = (() => ISqlType) | ISqlType;\n"]}
{"filename": "src/lib/types/i-logger.ts", "chunked_list": ["import type { info } from 'console';\n\n/**\n * A logger that can be used to log messages with different\n * levels of severity for the MSSQLDataSource.\n * @property {Function} [info] - Logs an informational message\n * @property {Function} [log] - Logs a debug message\n * @property {Function} [warn] - Logs a warning message\n * @property {Function} [error] - Logs an error message\n * @property {Function} [trace] - Logs a stack trace", " * @property {Function} [error] - Logs an error message\n * @property {Function} [trace] - Logs a stack trace\n * @property {Function} [performance] - Logs performance information\n */\nexport interface ILogger {\n  info?: typeof console.info;\n  log?: typeof console.log;\n  warn?: typeof console.warn;\n  error?: typeof console.error;\n  trace?: typeof console.trace;\n  performance?: typeof info;\n}\n"]}
{"filename": "src/lib/types/stored-procedure-schema.ts", "chunked_list": ["import type { StoredProcedureParameter } from '.';\n\n/**\n * Represents the result of a stored procedure execution.\n */\nexport type StoredProcedureSchema = [\n  StoredProcedureParameter,\n  {\n    storedProcedureDefinition: string;\n  },\n];\n"]}
{"filename": "src/lib/types/i-mssql-options.ts", "chunked_list": ["import type { MSSQLConfig, ILogger } from '.';\n\n/**\n * The options for configuring the MSSQLDataSource.\n * @property {MSSQLConfig} config - The configuration for the MSSQL connection\n * @property {Logger} [logger] - Optional custom logger\n */\nexport interface MSSQLOptions {\n  config: MSSQLConfig;\n  logger?: ILogger;\n}\n"]}
{"filename": "src/lib/types/index.ts", "chunked_list": ["export * from './driver-type';\nexport * from './i-database-executor';\nexport * from './i-logger';\nexport * from './i-mssql-options';\nexport * from './i-resolver-procedure-result';\nexport * from './i-stored-procedure-parameter';\nexport * from './input-parameters';\nexport * from './mssql-config';\nexport * from './parameter-mode';\nexport * from './prepared-stored-procedure-parameter';", "export * from './parameter-mode';\nexport * from './prepared-stored-procedure-parameter';\nexport * from './stored-procedure-schema';\n"]}
{"filename": "src/lib/types/i-database-executor.ts", "chunked_list": ["import type { Request } from 'mssql';\n\nimport type { ILogger } from '.';\n\nexport interface IDatabaseExecutor {\n  /**\n   * Executes the given request function for a query operation\n   * with a new Request instance using the appropriate ConnectionPool.\n   *\n   * @param {(request: Request) => Promise<T>} requestFn The function to be executed with the new Request instance\n   * @param {ILogger} logger The logger to use for logging\n   * @returns The result of the Query request function\n   */\n  executeQueryRequest: <T>(\n    requestFn: (request: Request) => Promise<T>,\n    logger: ILogger,\n  ) => Promise<T>;\n\n  /**", "   * @param {(request: Request) => Promise<T>} requestFn The function to be executed with the new Request instance\n   * @param {ILogger} logger The logger to use for logging\n   * @returns The result of the Query request function\n   */\n  executeQueryRequest: <T>(\n    requestFn: (request: Request) => Promise<T>,\n    logger: ILogger,\n  ) => Promise<T>;\n\n  /**\n   * Executes the given request function for a mutation operation\n   * with a new Request instance using the appropriate ConnectionPool.\n   *", "   * Executes the given request function for a mutation operation\n   * with a new Request instance using the appropriate ConnectionPool.\n   *\n   * @param {(request: Request) => Promise<T>} requestFn The function to be executed with the new Request instance\n   * @param {ILogger} logger The logger to use for logging\n   * @returns The result of the Mutation request function\n   */\n  executeMutationRequest: <T>(\n    requestFn: (request: Request) => Promise<T>,\n    logger: ILogger,\n  ) => Promise<T>;\n}\n"]}
{"filename": "src/lib/types/parameter-mode.ts", "chunked_list": ["/**\n * In Microsoft SQL Server, parameters are either input/IN parameters\n * (by default, when no keyword is specified) or input-output/INOUT (using the OUTPUT keyword).\n * Unknown parameter modes are not supported.\n * @enum IN - Represents an input parameter\n * @enum INOUT - Represents an input-output parameter\n * @enum UNKNOWN - Represents an unknown parameter\n */\nexport enum ParameterMode {\n  IN = 'IN',\n  OUT = 'OUT',\n  INOUT = 'INOUT',\n}\n", "export enum ParameterMode {\n  IN = 'IN',\n  OUT = 'OUT',\n  INOUT = 'INOUT',\n}\n"]}
