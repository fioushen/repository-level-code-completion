{"filename": "jest.config.ts", "chunked_list": ["import type { Config } from 'jest';\n\nconst config: Config = {\n  preset: 'react-native',\n  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],\n  transformIgnorePatterns: ['./node_modules/(?!@react-native|react-native)'],\n  setupFiles: ['<rootDir>/.jest/jest.setup.ts'],\n  modulePathIgnorePatterns: [\n    '<rootDir>/example/node_modules',\n    '<rootDir>/lib/',", "    '<rootDir>/example/node_modules',\n    '<rootDir>/lib/',\n  ],\n};\n\nexport default config;\n"]}
{"filename": ".jest/jest.setup.ts", "chunked_list": ["import PitchDetectorModule from './__mocks__/PitchDetectorModule'\n\njest.mock('react-native-permissions', () => require('react-native-permissions/mock'));\n\nconst mocks = { PitchDetectorModule }\nObject.keys(mocks).forEach((module => jest.doMock(module, () => mocks[module], { virtual: true })))\n\njest.mock('react-native', () => ({\n    Platform: {\n        OS: 'android',", "    Platform: {\n        OS: 'android',\n        select: jest.fn((data: { android: any, ios: any }) => data.android)\n    },\n    NativeEventEmitter: jest.fn().mockImplementation(() => ({\n        addListener: jest.fn(),\n        emit: jest.fn(),\n        listenerCount: jest.fn(),\n        removeAllListeners: jest.fn(),\n        removeEventListener: jest.fn(),", "        removeAllListeners: jest.fn(),\n        removeEventListener: jest.fn(),\n        removeSubscription: jest.fn(),\n    })),\n    NativeModules: mocks,\n}))\n"]}
{"filename": ".jest/__mocks__/PitchDetectorModule.ts", "chunked_list": ["export default {\n    start: jest.fn(),\n    stop: jest.fn(),\n    isRecording: jest.fn(),\n}"]}
{"filename": "example/src/types/index.ts", "chunked_list": ["import { PermissionStatus, Rationale } from 'react-native-permissions';\n\nexport type TComparableCallback = (status: PermissionStatus) => boolean;\n\nexport type TPermissionsHandlers = {\n  RequestPermission: (\n    rationale?: Rationale,\n    compare?: TComparableCallback\n  ) => Promise<PermissionStatus | boolean | null>;\n  CheckPermission: (\n    compare?: TComparableCallback\n  ) => Promise<PermissionStatus | boolean | null>;\n};\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './internal/pitch-detector';\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["import type { NativeModule, EmitterSubscription } from 'react-native';\nimport type { Float, Int32 } from 'react-native/Libraries/Types/CodegenTypes';\nimport { PermissionStatus, Rationale } from 'react-native-permissions';\n\n/**\n * Permission handler comparable callback\n */\nexport type Comparable = (status: PermissionStatus) => boolean;\n\n/**\n * Permission handler response\n */", "export type Response = Promise<PermissionStatus | boolean | null>;\n\n/**\n * Permission handler\n */\nexport type PermissionsHandlers = {\n  /**\n   * Request permission\n   * @returns Promise<PermissionStatus | boolean | null>\n   */\n  RequestPermission: (rationale?: Rationale, compare?: Comparable) => Response;\n\n  /**\n   * Check permission\n   * @returns Promise<PermissionStatus | boolean | null>\n   */\n  CheckPermission: (compare?: Comparable) => Response;\n};\n", "export enum PitchDetectorErrors {\n  BASE,\n  LINKING_ERROR,\n  PERMISSIONS_ERROR,\n}\n\n/**\n * Event emitter subscription\n */\nexport type Subscription = EmitterSubscription | undefined;\n\n/**\n * Available musical tones.\n * @see `https://en.wikipedia.org/wiki/Musical_tone`\n */", "export type Subscription = EmitterSubscription | undefined;\n\n/**\n * Available musical tones.\n * @see `https://en.wikipedia.org/wiki/Musical_tone`\n */\nexport type Tone =\n  | 'C'\n  | 'C#'\n  | 'D'\n  | 'D#'\n  | 'E'\n  | 'F'\n  | 'F#'\n  | 'G'\n  | 'G#'\n  | 'A'\n  | 'A#'\n  | 'B';\n\n/**\n * Result generated by pitch estimation process.\n */", "export type Data = {\n  /**\n   * Pitch frequency in hertz.\n   */\n  frequency: Float;\n  tone: Tone;\n};\n\n/**\n * A callback function called by event emitted from native side.\n */", " * A callback function called by event emitted from native side.\n */\nexport type Callback = (data: Data) => void;\n\n/**\n * Available pitch estimation algorithm for Android.\n * @see `https://0110.be/releases/TarsosDSP/TarsosDSP-latest/TarsosDSP-latest-Documentation/`\n */\nexport type PitchEstimationAndroidAlgorithm =\n  | 'AMDF'\n  | 'DYNAMIC_WAVELET'\n  | 'FFT_PITCH'\n  | 'FFT_YIN'\n  | 'MPM'\n  | 'YIN';\n\n/**\n * Available pitch estimation algorithm for IOS.\n * @see `https://github.com/vadymmarkov/Beethoven#configuration`\n */", "export type PitchEstimationAndroidAlgorithm =\n  | 'AMDF'\n  | 'DYNAMIC_WAVELET'\n  | 'FFT_PITCH'\n  | 'FFT_YIN'\n  | 'MPM'\n  | 'YIN';\n\n/**\n * Available pitch estimation algorithm for IOS.\n * @see `https://github.com/vadymmarkov/Beethoven#configuration`\n */", "export type PitchEstimationIOSAlgorithm =\n  | 'BARYCENTRIC'\n  | 'HPS'\n  | 'JAINS'\n  | 'MAX_VALUE'\n  | 'QUADRACTIC'\n  | 'QUINNS_FIRST'\n  | 'QUINNS_SECOND'\n  | 'YIN';\n\nexport type PitchDetectorAndroidConfig = {\n  algorithm?: PitchEstimationAndroidAlgorithm;\n  bufferOverLap?: Int32;\n  bufferSize?: Int32;\n  sampleRate?: Float;\n};\n", "export type PitchDetectorAndroidConfig = {\n  algorithm?: PitchEstimationAndroidAlgorithm;\n  bufferOverLap?: Int32;\n  bufferSize?: Int32;\n  sampleRate?: Float;\n};\n\nexport type PitchDetectorIOSConfig = {\n  algorithm?: PitchEstimationIOSAlgorithm;\n  bufferSize?: Int32;\n};\n\n/**\n * Pitch detector configuration.\n */", "export type PitchDetectorConfig = {\n  android?: PitchDetectorAndroidConfig;\n  ios?: PitchDetectorIOSConfig;\n};\n\n/**\n * PitchDetector native module interface\n */\nexport interface NativeModuleImplementation extends NativeModule {\n  /**\n   * Start audio recording and pitch detection with provided configs\n   * @param config\n   * @returns Promise<void>\n   */\n  start: (\n    config: PitchDetectorAndroidConfig | PitchDetectorIOSConfig\n  ) => Promise<void>;\n\n  /**\n   * Stop audio recording and pitch detection\n   * @returns Promise<void>\n   */\n  stop: () => Promise<void>;\n\n  /**\n   * Get current status\n   * @returns Promise<boolean>\n   */\n  isRecording: () => Promise<void>;\n}\n", "export interface NativeModuleImplementation extends NativeModule {\n  /**\n   * Start audio recording and pitch detection with provided configs\n   * @param config\n   * @returns Promise<void>\n   */\n  start: (\n    config: PitchDetectorAndroidConfig | PitchDetectorIOSConfig\n  ) => Promise<void>;\n\n  /**\n   * Stop audio recording and pitch detection\n   * @returns Promise<void>\n   */\n  stop: () => Promise<void>;\n\n  /**\n   * Get current status\n   * @returns Promise<boolean>\n   */\n  isRecording: () => Promise<void>;\n}\n"]}
{"filename": "src/internal/pitch-detector/index.ts", "chunked_list": ["import { NativeModules, NativeEventEmitter, Platform } from 'react-native';\nimport { Permissions } from '../permissions';\nimport { PitchDetectorError } from '../erros';\nimport { merge } from '../utils';\n\nimport {\n  type Callback,\n  type NativeModuleImplementation,\n  type PitchDetectorConfig,\n  type Subscription,\n  type PitchDetectorAndroidConfig,", "  type PitchDetectorConfig,\n  type Subscription,\n  type PitchDetectorAndroidConfig,\n  type PitchDetectorIOSConfig,\n  PitchDetectorErrors,\n} from '../../types';\n\nexport class InternalPitchDetector {\n  private module?: NativeModuleImplementation;\n  private event?: NativeEventEmitter;\n\n  constructor() {\n    this.module = NativeModules?.PitchDetectorModule;\n", "    if (this.module) {\n      this.event = new NativeEventEmitter(this.module);\n    } else {\n      /* istanbul ignore next */\n      throw new PitchDetectorError(PitchDetectorErrors.LINKING_ERROR);\n    }\n  }\n\n  /**\n   * Returns a default PitchDetector configs\n   * @returns PitchDetectorConfig\n   * @example\n   * ```ts\n   * {\n   *  android: {\n   *    algorithm: 'YIN',\n   *    bufferOverLap: 0,\n   *    bufferSize: 1024,\n   *    sampleRate: 22050,\n   *  },\n   *  ios: {\n   *    algorithm: 'YIN',\n   *    bufferSize: 1024,\n   *  }\n   * }\n   */\n  private getDefaultConfig(): PitchDetectorConfig {\n    return {\n      android: {\n        algorithm: 'YIN',\n        bufferOverLap: 0,\n        bufferSize: 1024,\n        sampleRate: 22050,\n      },\n      ios: {\n        algorithm: 'YIN',\n        bufferSize: 1024,\n      },\n    };\n  }\n\n  /**\n   * Get current audio permission\n   * @returns Promise<boolean>\n   */\n  private async hasPermissions(): Promise<boolean> {\n    return !!(await Permissions.audio());\n  }\n\n  /**\n   * Get current status\n   * @returns Promise<boolean>\n   */\n  async isRecording(): Promise<boolean> {", "    try {\n      const status = await this.module?.isRecording();\n      return !!status;\n    } catch (err) {\n      console.warn(err);\n      return false;\n    }\n  }\n\n  /**\n   * Trigger audio recording and pitch detection with provided configs\n   * @param config\n   * @returns Promise<void>\n   */\n  async start(config?: PitchDetectorConfig): Promise<void> {", "    try {\n      const permission = await this.hasPermissions();\n\n      if (!permission) {\n        throw new PitchDetectorError(PitchDetectorErrors.PERMISSIONS_ERROR);\n      }\n\n      const configuration = merge<PitchDetectorConfig>(\n        this.getDefaultConfig(),\n        config ?? {}\n      );\n\n      const params = Platform.select({\n        android: configuration.android as unknown,\n        ios: configuration.ios as unknown,\n      }) as PitchDetectorIOSConfig | PitchDetectorAndroidConfig;\n\n      await this.module?.start(params);", "    } catch (err: unknown) {\n      console.warn(err);\n    }\n  }\n\n  /**\n   * Stop audio recording and pitch detection\n   * @returns Promise<void>\n   */\n  async stop(): Promise<void> {\n    try {\n      await this.module?.stop();", "    try {\n      await this.module?.stop();\n    } catch (err: unknown) {\n      console.warn(err);\n    }\n  }\n\n  /**\n   * Register a event listener\n   */\n  addListener(callback: Callback): Subscription {\n    return this.event?.addListener('data', callback);\n  }\n\n  /**\n   * Method event listeners\n   * @alias removeAllListeners\n   */\n  removeListener(): void {\n    this.event?.removeAllListeners('data');\n  }\n\n  /**\n   * Method remove all event listeners\n   */\n  removeAllListeners(): void {\n    this.event?.removeAllListeners('data');\n  }\n}\n\n/**\n * Export an instance of InternalPitchDetector\n */\nexport const PitchDetector = new InternalPitchDetector();\n"]}
{"filename": "src/internal/pitch-detector/__tests__/pitch-detector.spec.ts", "chunked_list": ["import { NativeModules } from 'react-native';\n\nimport { PitchDetectorErrors } from '../../../types';\nimport { PitchDetectorError } from '../../erros';\n\nimport { Permissions } from '../../permissions';\nimport { PitchDetector } from '..';\n\nconst Module = NativeModules.PitchDetectorModule;\nconst asyncMock = <T>(value: T) => jest.fn().mockResolvedValue(value);", "const Module = NativeModules.PitchDetectorModule;\nconst asyncMock = <T>(value: T) => jest.fn().mockResolvedValue(value);\nconst asyncMockThrow = <T>(error: T) =>\n  jest.fn().mockImplementation(() => {\n    throw error;\n  });\n\ndescribe('PitchDetector', () => {\n  beforeEach(() => jest.clearAllMocks());\n", "  beforeEach(() => jest.clearAllMocks());\n\n  it.each([\n    ['start', 1],\n    ['isRecording', 1],\n    ['stop', 1],\n  ])(\n    'should call %s method %s time(s) from native module',\n    async (method: string, times: number) => {\n      const spy = jest.spyOn(Module, method as any);", "    async (method: string, times: number) => {\n      const spy = jest.spyOn(Module, method as any);\n\n      await Object(PitchDetector)[method]();\n\n      expect(spy).toBeCalledTimes(times);\n    }\n  );\n\n  it.each([", "\n  it.each([\n    ['hasPermissions', 'start'],\n    ['getDefaultConfig', 'start'],\n  ])(\n    'should call %s method when %s method will be called',\n    async (target: string, method: string) => {\n      const spy = jest.spyOn(PitchDetector, target as any);\n\n      await Object(PitchDetector)[method]();", "\n      await Object(PitchDetector)[method]();\n\n      expect(spy).toBeCalledTimes(1);\n    }\n  );\n\n  it('should call audio permission method when start method will be called', async () => {\n    const spy = jest.spyOn(Permissions, 'audio');\n", "    const spy = jest.spyOn(Permissions, 'audio');\n\n    await PitchDetector.start();\n\n    expect(spy).toBeCalledTimes(1);\n  });\n\n  it('should throw error when start method will be called and not have audio record permission', async () => {\n    const error = new PitchDetectorError(PitchDetectorErrors.PERMISSIONS_ERROR);\n    const spy = jest.spyOn(console, 'warn');", "    const error = new PitchDetectorError(PitchDetectorErrors.PERMISSIONS_ERROR);\n    const spy = jest.spyOn(console, 'warn');\n\n    Permissions.audio = asyncMock(false);\n    await PitchDetector.start();\n\n    expect(spy).toBeCalledTimes(1);\n    expect(spy).toHaveBeenCalledWith(error);\n  });\n", "  });\n\n  it.each([\n    ['addListener', 'addListener'],\n    ['removeAllListeners', 'removeAllListeners'],\n    ['removeAllListeners', 'removeListener'],\n  ])(\n    'should call %s method from event emitter when %s method will be called',\n    async (target: string, method: string) => {\n      const spy = jest.spyOn(Object(PitchDetector).event, target as any);", "    async (target: string, method: string) => {\n      const spy = jest.spyOn(Object(PitchDetector).event, target as any);\n\n      await Object(PitchDetector)[method](1);\n\n      expect(spy).toBeCalledTimes(1);\n    }\n  );\n\n  it.each([['start'], ['stop'], ['isRecording']])(", "\n  it.each([['start'], ['stop'], ['isRecording']])(\n    'should throw error when native %s method fail',\n    async (method: string) => {\n      const error = new Error('Some error message');\n      const spy = jest.spyOn(console, 'warn');\n\n      Permissions.audio = asyncMock(true);\n      Object(PitchDetector).module[method] = asyncMockThrow(error);\n", "      Object(PitchDetector).module[method] = asyncMockThrow(error);\n\n      await Object(PitchDetector)[method]();\n\n      expect(spy).toBeCalledTimes(1);\n      expect(spy).toBeCalledWith(error);\n    }\n  );\n});\n", "});\n"]}
{"filename": "src/internal/utils/index.ts", "chunked_list": ["/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item: any) {\n  return Boolean(\n    item &&\n      typeof item === 'object' &&\n      !Array.isArray(item) &&\n      !(item instanceof Date)\n  );\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */", "export function merge<T>(target: any, ...sources: any): T {\n  if (!sources.length) return target;\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        merge(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return merge(target, ...sources);\n}\n"]}
{"filename": "src/internal/utils/__tests__/utils.spec.ts", "chunked_list": ["import { isObject, merge } from '..';\n\ndescribe('Utils', () => {\n  it.each([\n    [false, 'array', []],\n    [false, 'NaN', NaN],\n    [false, 'number', 10],\n    [false, 'symbol', Symbol()],\n    [false, 'date', new Date()],\n    [true, 'object', {}],", "    [false, 'date', new Date()],\n    [true, 'object', {}],\n  ])(\n    'should return %s when isObject function will be called with %s',\n    (expected: boolean, _: string, params: any) => {\n      const result = isObject(params);\n      expect(result).toBe(expected);\n    }\n  );\n\n  it('should not merge when one params is not object', () => {\n    const result = merge({ name: 'F\u00e1bio' }, NaN);\n\n    expect(result).toHaveProperty('name');\n  });\n\n  it('should merge two complex object', () => {\n    const obj1 = {\n      person: {\n        name: 'F\u00e1bio',\n        address: {\n          street: { name: 'Street name', number: 'Street number' },\n          city: { name: 'City name' },\n        },\n      },\n    };\n\n    const obj2 = {\n      person: {\n        age: 29,\n        address: {\n          city: { postalCode: 1212000, name: 'City name 2' },\n          coords: {\n            lat: 0,\n            lgn: 0,\n          },\n        },\n      },\n    };\n\n    const result: any = merge(obj1, obj2);\n\n    expect(result.person).toHaveProperty('name');\n    expect(result.person).toHaveProperty('age');\n\n    expect(result.person.address.street).toHaveProperty('name');\n    expect(result.person.address.street).toHaveProperty('number');\n\n    expect(result.person.address.city).toHaveProperty('name');\n    expect(result.person.address.city).toHaveProperty('postalCode');\n\n    expect(result.person.address.coords).toHaveProperty('lat');\n    expect(result.person.address.coords).toHaveProperty('lgn');\n\n    expect(result.person.address.city.name).toBe(obj2.person.address.city.name);\n  });\n});\n"]}
{"filename": "src/internal/permissions/index.ts", "chunked_list": ["import { Platform } from 'react-native';\nimport {\n  PERMISSIONS,\n  Permission,\n  PermissionStatus,\n  RESULTS,\n} from 'react-native-permissions';\n\nimport Factory from './factory';\n", "import Factory from './factory';\n\nexport const isDenied = (status: PermissionStatus) => status === RESULTS.DENIED;\n\nexport const isGranted = (status: PermissionStatus) =>\n  status === RESULTS.GRANTED;\n\nexport const isBlocked = (status: PermissionStatus) =>\n  status === RESULTS.BLOCKED;\n", "  status === RESULTS.BLOCKED;\n\nexport const isLimited = (status: PermissionStatus) =>\n  status === RESULTS.LIMITED;\n\nexport const isUnavailable = (status: PermissionStatus) =>\n  status === RESULTS.UNAVAILABLE;\n\nexport class Permissions {\n  static async audio() {\n    const MICROPHONE_PERMISSION = Platform.select({\n      android: PERMISSIONS.ANDROID.RECORD_AUDIO,\n      ios: PERMISSIONS.IOS.MICROPHONE,\n    }) as Permission;\n\n    const rationale = {\n      title: 'Acesso ao microfone',\n      message: 'Para que possamos executar',\n      buttonPositive: 'Permitir',\n      buttonNegative: 'Negar',\n    };\n\n    const audio = Factory(MICROPHONE_PERMISSION, 'AUDIO PERMISSION:');\n\n    const denied = await audio.CheckPermission(isDenied);\n    const blocked = await audio.CheckPermission(isBlocked);\n", "export class Permissions {\n  static async audio() {\n    const MICROPHONE_PERMISSION = Platform.select({\n      android: PERMISSIONS.ANDROID.RECORD_AUDIO,\n      ios: PERMISSIONS.IOS.MICROPHONE,\n    }) as Permission;\n\n    const rationale = {\n      title: 'Acesso ao microfone',\n      message: 'Para que possamos executar',\n      buttonPositive: 'Permitir',\n      buttonNegative: 'Negar',\n    };\n\n    const audio = Factory(MICROPHONE_PERMISSION, 'AUDIO PERMISSION:');\n\n    const denied = await audio.CheckPermission(isDenied);\n    const blocked = await audio.CheckPermission(isBlocked);\n", "    if (denied || blocked) {\n      return await audio.RequestPermission(rationale, isGranted);\n    }\n\n    return await audio.CheckPermission(isGranted);\n  }\n}\n"]}
{"filename": "src/internal/permissions/factory/index.ts", "chunked_list": ["import {\n  check,\n  Permission,\n  Rationale,\n  request,\n  RESULTS,\n} from 'react-native-permissions';\n\nimport type { Comparable, PermissionsHandlers, Response } from '../../../types';\n", "import type { Comparable, PermissionsHandlers, Response } from '../../../types';\n\nconst BLOCKED = 'Permission is denied and not requestable anymore';\nconst DENIED = \"Permission hasn't been requested / is denied but requestable\";\nconst GRANTED = 'Permission is granted';\nconst LIMITED = 'Permission is limited: some actions are possible';\nconst UNAVAILABLE = 'This feature is not available.';\n\nconst MESSAGES = new Map<string, string>([\n  [RESULTS.BLOCKED, BLOCKED],", "const MESSAGES = new Map<string, string>([\n  [RESULTS.BLOCKED, BLOCKED],\n  [RESULTS.DENIED, DENIED],\n  [RESULTS.GRANTED, GRANTED],\n  [RESULTS.LIMITED, LIMITED],\n  [RESULTS.UNAVAILABLE, UNAVAILABLE],\n]);\n\nexport default (\n  targetPermission: Permission,", "export default (\n  targetPermission: Permission,\n  TAG: string\n): PermissionsHandlers => {\n  const CheckPermission = async (compare?: Comparable): Response => {\n    try {\n      const result = await check(targetPermission);\n      console.log(TAG, MESSAGES.get(result));\n      return compare ? compare(result) : result;\n    } catch (error: any) {\n      console.log(TAG, error.message);\n      return null;\n    }\n  };\n\n  const RequestPermission = async (\n    rationale?: Rationale,\n    compare?: Comparable\n  ): Response => {", "    } catch (error: any) {\n      console.log(TAG, error.message);\n      return null;\n    }\n  };\n\n  const RequestPermission = async (\n    rationale?: Rationale,\n    compare?: Comparable\n  ): Response => {\n    try {\n      const result = await request(targetPermission, rationale);\n      console.log(TAG, MESSAGES.get(result));\n      return compare ? compare(result) : result;", "    try {\n      const result = await request(targetPermission, rationale);\n      console.log(TAG, MESSAGES.get(result));\n      return compare ? compare(result) : result;\n    } catch (error: any) {\n      console.log(TAG, error.message);\n      return null;\n    }\n  };\n\n  return { CheckPermission, RequestPermission };\n};\n"]}
{"filename": "src/internal/permissions/__tests__/permissions.spec.ts", "chunked_list": ["import { PermissionStatus } from 'react-native-permissions';\nimport {\n  isBlocked,\n  isDenied,\n  isGranted,\n  isLimited,\n  isUnavailable,\n} from '../../permissions';\n\ndescribe('Permissions', () => {", "\ndescribe('Permissions', () => {\n  it.each([\n    ['isBlocked', 'blocked', true, isBlocked],\n    ['isDenied', 'denied', true, isDenied],\n    ['isGranted', 'granted', true, isGranted],\n    ['isLimited', 'limited', true, isLimited],\n    ['isUnavailable', 'unavailable', true, isUnavailable],\n  ])(\n    'should call %s function and return %s',\n    (\n      _: string,\n      params: any,\n      expected: boolean,\n      fn: (status: PermissionStatus) => boolean\n    ) => {\n      const result = fn(params);\n\n      expect(result).toBe(expected);\n    }\n  );\n});\n", "  ])(\n    'should call %s function and return %s',\n    (\n      _: string,\n      params: any,\n      expected: boolean,\n      fn: (status: PermissionStatus) => boolean\n    ) => {\n      const result = fn(params);\n\n      expect(result).toBe(expected);\n    }\n  );\n});\n"]}
{"filename": "src/internal/erros/index.ts", "chunked_list": ["import { Platform } from 'react-native';\nimport { PitchDetectorErrors } from '../../types';\n\nconst base =\n  `The package 'react-native-pitch-detector' find a error. Make sure: \\n\\n` +\n  '- You rebuilt the app after installing the package\\n' +\n  '- You are not using Expo Go\\n';\n\nconst linking =\n  `The package 'react-native-pitch-detector' doesn't seem to be linked. Make sure: \\n\\n` +", "const linking =\n  `The package 'react-native-pitch-detector' doesn't seem to be linked. Make sure: \\n\\n` +\n  Platform.select({\n    ios: \"- You have run 'pod install'\\n\",\n    android: '',\n  }) +\n  '- You rebuilt the app after installing the package\\n' +\n  '- You are not using Expo Go\\n';\n\nconst permission =", "\nconst permission =\n  `The package 'react-native-pitch-detector' need audio record permission. Make sure: \\n\\n` +\n  Platform.select({\n    ios: '- You have added Microphone access permission before start record.',\n    android: `- You have added '<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />' on AndroidManifest.xml and request permission before start record.\\n`,\n  });\n\nexport class PitchDetectorError {\n  constructor(type: PitchDetectorErrors) {\n    if (type === PitchDetectorErrors.LINKING_ERROR) {\n      return new Error(linking);\n    }\n", "export class PitchDetectorError {\n  constructor(type: PitchDetectorErrors) {\n    if (type === PitchDetectorErrors.LINKING_ERROR) {\n      return new Error(linking);\n    }\n\n    if (type === PitchDetectorErrors.PERMISSIONS_ERROR) {\n      return new Error(permission);\n    }\n\n    return new Error(base);\n  }\n}\n"]}
{"filename": "src/internal/erros/__tests__/errors.spec.ts", "chunked_list": ["import { PitchDetectorErrors } from '../../../types';\nimport { PitchDetectorError } from '..';\n\ndescribe('Errors', () => {\n  it('should create base error', () => {\n    const error: any = new PitchDetectorError(PitchDetectorErrors.BASE);\n\n    expect(error?.message).toMatch(/You are not using Expo Go/);\n    expect(error?.message).toMatch(\n      /You rebuilt the app after installing the package/", "    expect(error?.message).toMatch(\n      /You rebuilt the app after installing the package/\n    );\n  });\n\n  it('should create link error', () => {\n    const error: any = new PitchDetectorError(\n      PitchDetectorErrors.LINKING_ERROR\n    );\n", "    );\n\n    expect(error?.message).toMatch(/doesn't seem to be linked/);\n  });\n\n  it('should create permission error', () => {\n    const error: any = new PitchDetectorError(\n      PitchDetectorErrors.PERMISSIONS_ERROR\n    );\n", "    );\n\n    expect(error?.message).toMatch(/need audio record permission/);\n  });\n});\n"]}
