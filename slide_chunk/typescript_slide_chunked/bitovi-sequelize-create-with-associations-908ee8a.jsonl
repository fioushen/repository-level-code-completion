{"filename": "jest-unit-config.ts", "chunked_list": ["import config from \"./jest.config\";\n\nexport default {\n  ...config,\n  testMatch: [\"**/*.test.ts\"],\n};\n"]}
{"filename": "jest-integration-config.ts", "chunked_list": ["import config from \"./jest.config\";\n\nexport default {\n  ...config,\n  testMatch: [\"**/*.spec.ts\"],\n};\n"]}
{"filename": "jest.setup.ts", "chunked_list": ["function toPojo(error: Error) {\n  return Object.entries(error).reduce(\n    (acc, [key, value]) => ({ ...acc, [key]: value }),\n    {},\n  );\n}\n\nexpect.extend({\n  toEqualErrors(actual, expected) {\n    const actualPojos = actual.map(toPojo);\n    const expectedPojos = expected.map(toPojo);\n    const stringifiedActual = JSON.stringify(actualPojos);\n    const stringifiedExpected = JSON.stringify(expectedPojos);\n    const pass = stringifiedActual === stringifiedExpected;\n\n    return {\n      pass,\n      message: pass\n        ? () =>\n            `expected ${stringifiedActual} not to equal ${stringifiedExpected}`\n        : () => `expected ${stringifiedActual} to equal ${stringifiedExpected}`,\n    };\n  },\n});\n"]}
{"filename": "jest.config.ts", "chunked_list": ["import type { JestConfigWithTsJest } from \"ts-jest\";\n\nconst config: JestConfigWithTsJest = {\n  roots: [\"<rootDir>/tests\"],\n  collectCoverageFrom: [\"<rootDir>/src/**/*.ts\"],\n  coverageDirectory: \"coverage\",\n  coverageProvider: \"v8\",\n  coverageReporters: [\"html\", \"text\", \"text-summary\"],\n  setupFilesAfterEnv: [\"./jest.setup.ts\"],\n  testEnvironment: \"node\",", "  setupFilesAfterEnv: [\"./jest.setup.ts\"],\n  testEnvironment: \"node\",\n  transform: { \".+\\\\.ts$\": \"ts-jest\" },\n  testTimeout: 90000,\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 100,\n      lines: 95,\n      statements: 95,", "      lines: 95,\n      statements: 95,\n    },\n  },\n};\n\nexport default config;\n"]}
{"filename": "jest.d.ts", "chunked_list": ["type OwnMatcher<Params extends unknown[]> = (\n  this: jest.MatcherContext,\n  actual: Error[],\n  ...params: Params\n) => jest.CustomMatcherResult;\n\ndeclare global {\n  namespace jest {\n    interface ExpectExtendMap {\n      // A helper for comparing errors array. `toEqual` always returns `true`\n      toEqualErrors: OwnMatcher<[errors: Error[]]>;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars", "    interface ExpectExtendMap {\n      // A helper for comparing errors array. `toEqual` always returns `true`\n      toEqualErrors: OwnMatcher<[errors: Error[]]>;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    interface Matchers<R, T> {\n      toEqualErrors(errors: Error[]): T;\n    }\n  }\n}\n\nexport {};\n"]}
{"filename": "tests/update.spec.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\nimport * as dotenv from \"dotenv\";\nimport { extendSequelize } from \"../src/sequelize/extended\";\nimport type {\n  SingleSkillUserModel,\n  SkillModel,\n  UserModel,\n  UserSkillModel,\n} from \"./types\";\nimport { NotFoundError, UnexpectedValueError } from \"../src/sequelize/types\";", "} from \"./types\";\nimport { NotFoundError, UnexpectedValueError } from \"../src/sequelize/types\";\n\ndotenv.config();\n\ndescribe(\"Update\", () => {\n  let sequelize: Sequelize;\n\n  beforeAll(async () => {\n    extendSequelize(Sequelize);", "  beforeAll(async () => {\n    extendSequelize(Sequelize);\n\n    sequelize = new Sequelize(\"sqlite::memory:\", {\n      logging: false,\n    });\n  });\n\n  afterEach(async () => {\n    await sequelize.drop();", "  afterEach(async () => {\n    await sequelize.drop();\n    jest.clearAllMocks();\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n  });\n\n  it(\"Should update a record with no associations\", async () => {", "\n  it(\"Should update a record with no associations\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n    });", "      age: 33,\n    });\n\n    expect(user).toEqual(expect.objectContaining({ name: \"Justin\", age: 33 }));\n\n    const [updatedCount] = await User.update(\n      { age: 32 },\n      { where: { id: user.id } },\n    );\n", "    );\n\n    expect(updatedCount).toEqual(1);\n\n    const updatedUser = await User.findByPk(user.id);\n\n    expect(updatedUser).toEqual(\n      expect.objectContaining({ name: \"Justin\", age: 32 }),\n    );\n  });", "    );\n  });\n\n  it(\"Should update records associated through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,", "        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",", "    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n", "    });\n\n    await sequelize.sync();\n\n    const justin = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skill: { name: \"Programming\" },\n    });\n", "    });\n\n    const cooking = await Skill.create({ id: 10, name: \"Cooking\" });\n\n    const [updatedCount] = await User.update(\n      { age: 32, skill: { id: cooking.id } },\n      { where: { id: justin.id } },\n    );\n\n    expect(updatedCount).toEqual(1);", "\n    expect(updatedCount).toEqual(1);\n\n    const updatedUser = await User.findByPk(justin.id, { include: [\"skill\"] });\n\n    expect(updatedUser).toEqual(\n      expect.objectContaining({\n        name: \"Justin\",\n        age: 32,\n        skill: expect.objectContaining({ name: \"Cooking\" }),", "        age: 32,\n        skill: expect.objectContaining({ name: \"Cooking\" }),\n      }),\n    );\n\n    expect(await Skill.count()).toEqual(2);\n  });\n\n  it(\"Should update records associated through hasOne - inverse\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(", "  it(\"Should update records associated through hasOne - inverse\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },", "        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n", "    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const justin = await User.create({", "\n    const justin = await User.create({\n      name: \"Justin\",\n      age: 33,\n    });\n\n    const cooking = await Skill.create({\n      id: 10,\n      name: \"Cooking\",\n      user: { name: \"Kevin\", age: 32 },", "      name: \"Cooking\",\n      user: { name: \"Kevin\", age: 32 },\n    });\n\n    const [updatedCount] = await Skill.update(\n      { name: \"Running\", user: { id: justin.id } },\n      { where: { id: cooking.id } },\n    );\n\n    expect(updatedCount).toEqual(1);", "\n    expect(updatedCount).toEqual(1);\n\n    const updatedUser = await User.findByPk(justin.id, { include: [\"skill\"] });\n\n    expect(updatedUser).toEqual(\n      expect.objectContaining({\n        name: \"Justin\",\n        age: 33,\n        skill: expect.objectContaining({ name: \"Running\" }),", "        age: 33,\n        skill: expect.objectContaining({ name: \"Running\" }),\n      }),\n    );\n\n    expect(await Skill.count()).toEqual(1);\n  });\n\n  it(\"Should disassociate records associated through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(", "  it(\"Should disassociate records associated through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },", "        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n", "    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const justin = await User.create({", "\n    const justin = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skill: { name: \"Programming\" },\n    });\n\n    const [updatedCount] = await User.update(\n      { age: 32, skill: null },\n      { where: { id: justin.id } },", "      { age: 32, skill: null },\n      { where: { id: justin.id } },\n    );\n\n    expect(updatedCount).toEqual(1);\n\n    const updatedUser = await User.findByPk(justin.id, { include: [\"skill\"] });\n\n    expect(updatedUser).toEqual(\n      expect.objectContaining({", "    expect(updatedUser).toEqual(\n      expect.objectContaining({\n        name: \"Justin\",\n        age: 32,\n        skill: null,\n      }),\n    );\n\n    expect(await Skill.count()).toEqual(1);\n  });", "    expect(await Skill.count()).toEqual(1);\n  });\n\n  it(\"Should throw with non-existing IDs through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,", "        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",", "    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n", "    });\n\n    await sequelize.sync();\n\n    const justin = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skill: { name: \"Programming\" },\n    });\n", "    });\n\n    await expect(\n      User.update({ age: 32, skill: { id: -1 } }, { where: { id: justin.id } }),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skill/data/id\",\n      }),\n    ]);", "      }),\n    ]);\n  });\n\n  it(\"Should update records associated through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {", "      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {", "\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });", "      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\" },", "      skills: [\n        { name: \"Acting\" },\n        { name: \"Cooking\" },\n        { name: \"Programming\" },\n      ],\n    });\n\n    const [cooking, programming, running] = await Promise.all([\n      Skill.findOne({\n        where: { name: \"Cooking\" },", "      Skill.findOne({\n        where: { name: \"Cooking\" },\n      }),\n      Skill.findOne({\n        where: { name: \"Programming\" },\n      }),\n      Skill.create({\n        name: \"Running\",\n      }),\n    ]);", "      }),\n    ]);\n\n    await User.update(\n      {\n        name: \"Kevin\",\n        age: 32,\n        skills: [\n          { id: cooking?.id },\n          { id: programming?.id },", "          { id: cooking?.id },\n          { id: programming?.id },\n          { id: running?.id },\n        ],\n      },\n      { where: { id: user.id } },\n    );\n\n    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n    const skills = await Skill.findAll();", "    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n    const skills = await Skill.findAll();\n\n    expect(updatedUser).toEqual(\n      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n    );\n    expect(updatedUser?.skills?.map((skill) => skill.name).sort()).toEqual([\n      \"Cooking\",\n      \"Programming\",\n      \"Running\",", "      \"Programming\",\n      \"Running\",\n    ]);\n    expect(skills).toHaveLength(4);\n  });\n\n  it(\"Should update records associated through hasMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {", "      \"User\",\n      {\n        id: {\n          type: DataTypes.INTEGER,\n          primaryKey: true,\n          autoIncrement: true,\n        },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },", "        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: {\n          type: DataTypes.INTEGER,", "        id: {\n          type: DataTypes.INTEGER,\n          primaryKey: true,\n          autoIncrement: true,\n        },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",", "    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const [justin, kevin] = await User.bulkCreate([\n      {\n        name: \"Justin\",", "      {\n        name: \"Justin\",\n        age: 33,\n        skills: [{ name: \"Acting\" }, { name: \"Cooking\" }],\n      },\n      {\n        name: \"Kevin\",\n        age: 32,\n        skills: [{ name: \"Programming\" }],\n      },", "        skills: [{ name: \"Programming\" }],\n      },\n    ]);\n\n    const cookingId = (\n      await Skill.findOne({\n        where: { name: \"Cooking\" },\n      })\n    )?.id;\n", "    )?.id;\n\n    await Skill.update(\n      {\n        name: \"Running\",\n        user: { id: kevin.id },\n      },\n      { where: { id: cookingId } },\n    );\n", "    );\n\n    const [updatedJustin, updatedKevin] = await Promise.all([\n      User.findByPk(justin.id, {\n        include: [\"skills\"],\n      }),\n      User.findByPk(kevin.id, {\n        include: [\"skills\"],\n      }),\n    ]);", "      }),\n    ]);\n\n    expect(updatedJustin).toEqual(\n      expect.objectContaining({ name: \"Justin\", age: 33 }),\n    );\n    expect(updatedKevin).toEqual(\n      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n    );\n    expect(updatedJustin?.skills?.map((skill) => skill.name)).toEqual([", "    );\n    expect(updatedJustin?.skills?.map((skill) => skill.name)).toEqual([\n      \"Acting\",\n    ]);\n    expect(updatedKevin?.skills?.map((skill) => skill.name).sort()).toEqual([\n      \"Programming\",\n      \"Running\",\n    ]);\n\n    expect(await Skill.count()).toEqual(3);", "\n    expect(await Skill.count()).toEqual(3);\n  });\n\n  it(\"Should disassociate records associated through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {", "      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {", "\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });", "      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\" },", "      skills: [\n        { name: \"Acting\" },\n        { name: \"Cooking\" },\n        { name: \"Programming\" },\n      ],\n    });\n\n    await User.update(\n      {\n        name: \"Kevin\",", "      {\n        name: \"Kevin\",\n        age: 32,\n        skills: [],\n      },\n      { where: { id: user.id } },\n    );\n\n    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n    const skills = await Skill.findAll();", "    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n    const skills = await Skill.findAll();\n\n    expect(updatedUser).toEqual(\n      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n    );\n    expect(updatedUser?.skills).toEqual([]);\n    expect(skills).toHaveLength(3);\n  });\n", "  });\n\n  it(\"Should throw with non-existing IDs through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },", "        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",", "      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();", "\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\" },\n        { name: \"Cooking\" },\n        { name: \"Programming\" },", "        { name: \"Cooking\" },\n        { name: \"Programming\" },\n      ],\n    });\n\n    await expect(\n      User.update(\n        {\n          name: \"Kevin\",\n          age: 32,", "          name: \"Kevin\",\n          age: 32,\n          skills: [{ id: -1 }, { id: -2 }],\n        },\n        { where: { id: user.id } },\n      ),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/0/id\",", "        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/0/id\",\n      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/1/id\",\n      }),\n    ]);\n  });\n", "  });\n\n  it(\"Should update records associated through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },", "        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {", "\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",", "      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,", "      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\", through: { selfGranted: true } },\n        { name: \"Cooking\" },\n        { name: \"Programming\", through: { selfGranted: false } },\n      ],\n    });\n\n    const [cooking, programming, running] = await Promise.all([", "\n    const [cooking, programming, running] = await Promise.all([\n      Skill.findOne({\n        where: { name: \"Cooking\" },\n      }),\n      Skill.findOne({\n        where: { name: \"Programming\" },\n      }),\n      Skill.create({\n        name: \"Running\",", "      Skill.create({\n        name: \"Running\",\n      }),\n    ]);\n\n    await User.update(\n      {\n        age: 32,\n        skills: [\n          { id: programming?.id },", "        skills: [\n          { id: programming?.id },\n          { id: cooking?.id },\n          { id: running?.id },\n        ],\n      },\n      { where: { id: user.id } },\n    );\n\n    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });", "\n    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n\n    expect(sequelize.models).toHaveProperty(\"UserSkill\");\n    expect(updatedUser?.skills?.map((skill) => skill.name).sort()).toEqual([\n      \"Cooking\",\n      \"Programming\",\n      \"Running\",\n    ]);\n", "    ]);\n\n    const userSkill = await UserSkill.findAll({\n      attributes: [\"skillId\"],\n      where: { userId: user.id },\n    });\n\n    expect(userSkill.map(({ skillId }) => skillId).sort()).toEqual(\n      [cooking?.id, programming?.id, running?.id].sort(),\n    );", "      [cooking?.id, programming?.id, running?.id].sort(),\n    );\n\n    expect(await Skill.count()).toEqual(4);\n  });\n\n  it(\"Should update records associated through belongsToMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {", "      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(", "\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },", "        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });", "      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();", "\n    await sequelize.sync();\n\n    const programming = await Skill.create({\n      name: \"Programming\",\n      users: [\n        {\n          name: \"Justin\",\n          age: 33,\n          through: { selfGranted: false },", "          age: 33,\n          through: { selfGranted: false },\n        } as UserModel,\n        {\n          name: \"Kevin\",\n          age: 32,\n        } as UserModel,\n      ],\n    });\n", "    });\n\n    const [justin] = await Promise.all([\n      User.findOne({\n        where: { name: \"Justin\", age: 33 },\n      }),\n      User.findOne({\n        where: { name: \"Kevin\", age: 32 },\n      }),\n    ]);", "      }),\n    ]);\n\n    await Skill.update(\n      {\n        name: \"Cooking\",\n        users: [{ id: justin?.id } as UserModel],\n      },\n      { where: { id: programming.id } },\n    );", "      { where: { id: programming.id } },\n    );\n\n    const updatedSkill = await Skill.findByPk(programming.id, {\n      include: [\"users\"],\n    });\n\n    expect(sequelize.models).toHaveProperty(\"UserSkill\");\n    expect(updatedSkill?.users?.map((user) => user?.name).sort()).toEqual([\n      \"Justin\",", "    expect(updatedSkill?.users?.map((user) => user?.name).sort()).toEqual([\n      \"Justin\",\n    ]);\n\n    const userSkill = await UserSkill.findAll({\n      attributes: [\"skillId\"],\n      where: { userId: programming.id },\n    });\n\n    expect(userSkill.map(({ skillId }) => skillId)).toEqual([justin?.id]);", "\n    expect(userSkill.map(({ skillId }) => skillId)).toEqual([justin?.id]);\n\n    expect(await Skill.count()).toEqual(1);\n  });\n\n  it(\"Should disassociate records associated through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {", "      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(", "\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },", "        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });", "      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();", "\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\", through: { selfGranted: true } },\n        { name: \"Cooking\" },\n        { name: \"Programming\", through: { selfGranted: false } },", "        { name: \"Cooking\" },\n        { name: \"Programming\", through: { selfGranted: false } },\n      ],\n    });\n\n    await User.update(\n      {\n        age: 32,\n        skills: [],\n      },", "        skills: [],\n      },\n      { where: { id: user.id } },\n    );\n\n    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n\n    expect(sequelize.models).toHaveProperty(\"UserSkill\");\n    expect(updatedUser?.skills).toEqual([]);\n", "    expect(updatedUser?.skills).toEqual([]);\n\n    const userSkill = await UserSkill.findAll({\n      attributes: [\"skillId\"],\n      where: { userId: user.id },\n    });\n\n    expect(userSkill).toEqual([]);\n\n    expect(await Skill.count()).toEqual(3);", "\n    expect(await Skill.count()).toEqual(3);\n  });\n\n  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {", "      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",", "    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {", "\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    const user = await User.create({", "\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\", through: { selfGranted: true } },\n        { name: \"Cooking\" },\n        { name: \"Programming\", through: { selfGranted: false } },\n      ],\n    });", "      ],\n    });\n\n    await expect(\n      User.update(\n        {\n          age: 32,\n          skills: [{ id: -1 }, { id: -2 }],\n        },\n        { where: { id: user.id } },", "        },\n        { where: { id: user.id } },\n      ),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/0/id\",\n      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",", "      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/1/id\",\n      }),\n    ]);\n  });\n\n  it(\"Should throw a proper error when trying to update without an ID through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",", "    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {", "\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const justin = await User.create({\n      name: \"Justin\",", "    const justin = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skill: { name: \"Programming\" },\n    });\n\n    const cooking = await Skill.create({ id: 10, name: \"Cooking\" });\n\n    await expect(\n      User.update(", "    await expect(\n      User.update(\n        { age: 32, skill: { id: cooking.id } },\n        { where: { name: justin.name } },\n      ),\n    ).rejects.toEqualErrors([\n      new UnexpectedValueError({\n        detail: \"Only updating by the primary key is supported\",\n      }),\n    ]);", "      }),\n    ]);\n  });\n\n  it(\"Should throw a proper error when trying to update without an ID through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {", "      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {", "\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });", "      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Acting\" },", "      skills: [\n        { name: \"Acting\" },\n        { name: \"Cooking\" },\n        { name: \"Programming\" },\n      ],\n    });\n\n    const [cooking, programming, running] = await Promise.all([\n      Skill.findOne({\n        where: { name: \"Cooking\" },", "      Skill.findOne({\n        where: { name: \"Cooking\" },\n      }),\n      Skill.findOne({\n        where: { name: \"Programming\" },\n      }),\n      Skill.create({\n        name: \"Running\",\n      }),\n    ]);", "      }),\n    ]);\n\n    await expect(\n      User.update(\n        {\n          name: \"Kevin\",\n          age: 32,\n          skills: [\n            { id: cooking?.id },", "          skills: [\n            { id: cooking?.id },\n            { id: programming?.id },\n            { id: running?.id },\n          ],\n        },\n        { where: { name: user.name } },\n      ),\n    ).rejects.toEqualErrors([\n      new UnexpectedValueError({", "    ).rejects.toEqualErrors([\n      new UnexpectedValueError({\n        detail: \"Only updating by the primary key is supported\",\n      }),\n    ]);\n  });\n});\n"]}
{"filename": "tests/types.ts", "chunked_list": ["import type {\n  InferAttributes,\n  InferCreationAttributes,\n  CreationOptional,\n  Model,\n} from \"sequelize\";\n\nexport interface SkillModel\n  extends Model<\n    InferAttributes<SkillModel>,\n    InferCreationAttributes<SkillModel>\n  > {\n  id?: CreationOptional<number>;\n  name: string;\n  userId?: number;\n  user?: Partial<UserModel>;\n  through?: { selfGranted: boolean };\n  UserSkill?: { selfGranted: boolean };\n  users?: Partial<UserModel[]>;\n}\n", "export interface UserModel\n  extends Model<\n    InferAttributes<UserModel>,\n    InferCreationAttributes<UserModel>\n  > {\n  id: CreationOptional<number>;\n  name: string;\n  age: number;\n  skills?: Array<Partial<SkillModel>>;\n  UserSkill?: { selfGranted: boolean };\n  through?: { selfGranted: boolean };\n}\n", "export interface SingleSkillUserModel\n  extends Model<\n    InferAttributes<SingleSkillUserModel>,\n    InferCreationAttributes<SingleSkillUserModel>\n  > {\n  id: CreationOptional<number>;\n  name: string;\n  age: number;\n  skill?: Partial<SkillModel> | null;\n}\n", "export interface UserSkillModel\n  extends Model<\n    InferAttributes<UserSkillModel>,\n    InferCreationAttributes<UserSkillModel>\n  > {\n  id: CreationOptional<number>;\n  selfGranted: boolean;\n  userId: number;\n  skillId: number;\n}\n"]}
{"filename": "tests/readme.test.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\nimport type {\n  CreationOptional,\n  InferAttributes,\n  InferCreationAttributes,\n  Model,\n} from \"sequelize\";\nimport * as dotenv from \"dotenv\";\nimport { extendSequelize } from \"../src/sequelize/extended\";\n", "import { extendSequelize } from \"../src/sequelize/extended\";\n\ndotenv.config();\n\ndescribe(\"Readme\", () => {\n  interface SkillModel\n    extends Model<\n      InferAttributes<SkillModel>,\n      InferCreationAttributes<SkillModel>\n    > {\n    id?: CreationOptional<number>;\n    name: string;\n    through?: { selfGranted: boolean };\n  }\n", "  interface UserModel\n    extends Model<\n      InferAttributes<UserModel>,\n      InferCreationAttributes<UserModel>\n    > {\n    id?: CreationOptional<number>;\n    name: string;\n    skills?: SkillModel[];\n  }\n\n  interface UserSkillModel\n    extends Model<\n      InferAttributes<UserSkillModel>,\n      InferCreationAttributes<UserSkillModel>\n    > {\n    id?: CreationOptional<number>;\n    userId?: number;\n    skillId?: number;\n    selfGranted: boolean;\n  }\n\n  let sequelize: Sequelize;\n\n  beforeAll(async () => {\n    extendSequelize(Sequelize);\n\n    sequelize = new Sequelize(\"sqlite::memory:\", {\n      logging: false,\n    });\n  });\n\n  afterEach(async () => {\n    await sequelize.drop();\n    jest.clearAllMocks();\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n  });\n\n  it(\"Should make sure readme example works\", async () => {\n    // define your models\n    const User = sequelize.define<UserModel>(\"User\", {\n      name: DataTypes.STRING,\n    });\n\n    const Skill = sequelize.define<SkillModel>(\"Skill\", {\n      name: DataTypes.STRING,\n    });\n\n    const UserSkill = sequelize.define<UserSkillModel>(\"UserSkill\", {\n      userId: DataTypes.INTEGER,\n      skillId: DataTypes.INTEGER,\n      selfGranted: DataTypes.BOOLEAN,\n    });\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    // create the tables\n    await sequelize.sync();\n\n    // seed some data\n    const cooking = await Skill.create({ name: \"Cooking\" });\n\n    // create a record and associate existing data or create data on the fly\n    const justin = await User.create({\n      name: \"Justin\",\n      skills: [{ name: \"Programming\" }, { id: cooking.id }] as SkillModel[],\n    });\n\n    await User.update(\n      {\n        name: \"Kevin\",\n        skills: [{ id: cooking.id }] as SkillModel[],\n      },\n      { where: { id: justin.id } },\n    );\n\n    await User.bulkCreate([\n      {\n        name: \"John\",\n        skills: [{ id: cooking.id }] as SkillModel[],\n      },\n      {\n        name: \"Jane\",\n        skills: [\n          { name: \"Gaming\", through: { selfGranted: true } },\n        ] as SkillModel[],\n      },\n    ]);\n\n    const users = await User.findAll({\n      include: [\"skills\"],\n      order: [[\"id\", \"ASC\"]],\n    });\n\n    expect(users.map((user) => user.toJSON())).toEqual([\n      {\n        id: 1,\n        name: \"Kevin\",\n        skills: [\n          {\n            id: 1,\n            name: \"Cooking\",\n            UserSkill: {\n              userId: 1,\n              skillId: 1,\n              selfGranted: null,\n              createdAt: expect.any(Date),\n              updatedAt: expect.any(Date),\n            },\n            createdAt: expect.any(Date),\n            updatedAt: expect.any(Date),\n          },\n        ],\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      },\n      {\n        id: 2,\n        name: \"John\",\n        skills: [\n          {\n            id: 1,\n            name: \"Cooking\",\n            UserSkill: {\n              userId: 2,\n              skillId: 1,\n              selfGranted: null,\n              createdAt: expect.any(Date),\n              updatedAt: expect.any(Date),\n            },\n            createdAt: expect.any(Date),\n            updatedAt: expect.any(Date),\n          },\n        ],\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      },\n      {\n        id: 3,\n        name: \"Jane\",\n        skills: [\n          {\n            id: 3,\n            name: \"Gaming\",\n            UserSkill: {\n              userId: 3,\n              skillId: 3,\n              selfGranted: true,\n              createdAt: expect.any(Date),\n              updatedAt: expect.any(Date),\n            },\n            createdAt: expect.any(Date),\n            updatedAt: expect.any(Date),\n          },\n        ],\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      },\n    ]);\n  });\n});\n", "  interface UserSkillModel\n    extends Model<\n      InferAttributes<UserSkillModel>,\n      InferCreationAttributes<UserSkillModel>\n    > {\n    id?: CreationOptional<number>;\n    userId?: number;\n    skillId?: number;\n    selfGranted: boolean;\n  }\n\n  let sequelize: Sequelize;\n\n  beforeAll(async () => {\n    extendSequelize(Sequelize);\n\n    sequelize = new Sequelize(\"sqlite::memory:\", {\n      logging: false,\n    });\n  });\n\n  afterEach(async () => {\n    await sequelize.drop();\n    jest.clearAllMocks();\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n  });\n\n  it(\"Should make sure readme example works\", async () => {\n    // define your models\n    const User = sequelize.define<UserModel>(\"User\", {\n      name: DataTypes.STRING,\n    });\n\n    const Skill = sequelize.define<SkillModel>(\"Skill\", {\n      name: DataTypes.STRING,\n    });\n\n    const UserSkill = sequelize.define<UserSkillModel>(\"UserSkill\", {\n      userId: DataTypes.INTEGER,\n      skillId: DataTypes.INTEGER,\n      selfGranted: DataTypes.BOOLEAN,\n    });\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    // create the tables\n    await sequelize.sync();\n\n    // seed some data\n    const cooking = await Skill.create({ name: \"Cooking\" });\n\n    // create a record and associate existing data or create data on the fly\n    const justin = await User.create({\n      name: \"Justin\",\n      skills: [{ name: \"Programming\" }, { id: cooking.id }] as SkillModel[],\n    });\n\n    await User.update(\n      {\n        name: \"Kevin\",\n        skills: [{ id: cooking.id }] as SkillModel[],\n      },\n      { where: { id: justin.id } },\n    );\n\n    await User.bulkCreate([\n      {\n        name: \"John\",\n        skills: [{ id: cooking.id }] as SkillModel[],\n      },\n      {\n        name: \"Jane\",\n        skills: [\n          { name: \"Gaming\", through: { selfGranted: true } },\n        ] as SkillModel[],\n      },\n    ]);\n\n    const users = await User.findAll({\n      include: [\"skills\"],\n      order: [[\"id\", \"ASC\"]],\n    });\n\n    expect(users.map((user) => user.toJSON())).toEqual([\n      {\n        id: 1,\n        name: \"Kevin\",\n        skills: [\n          {\n            id: 1,\n            name: \"Cooking\",\n            UserSkill: {\n              userId: 1,\n              skillId: 1,\n              selfGranted: null,\n              createdAt: expect.any(Date),\n              updatedAt: expect.any(Date),\n            },\n            createdAt: expect.any(Date),\n            updatedAt: expect.any(Date),\n          },\n        ],\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      },\n      {\n        id: 2,\n        name: \"John\",\n        skills: [\n          {\n            id: 1,\n            name: \"Cooking\",\n            UserSkill: {\n              userId: 2,\n              skillId: 1,\n              selfGranted: null,\n              createdAt: expect.any(Date),\n              updatedAt: expect.any(Date),\n            },\n            createdAt: expect.any(Date),\n            updatedAt: expect.any(Date),\n          },\n        ],\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      },\n      {\n        id: 3,\n        name: \"Jane\",\n        skills: [\n          {\n            id: 3,\n            name: \"Gaming\",\n            UserSkill: {\n              userId: 3,\n              skillId: 3,\n              selfGranted: true,\n              createdAt: expect.any(Date),\n              updatedAt: expect.any(Date),\n            },\n            createdAt: expect.any(Date),\n            updatedAt: expect.any(Date),\n          },\n        ],\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      },\n    ]);\n  });\n});\n"]}
{"filename": "tests/bulk_create.spec.ts", "chunked_list": ["import { Sequelize, DataTypes, Op } from \"sequelize\";\nimport * as dotenv from \"dotenv\";\nimport { extendSequelize } from \"../src/sequelize/extended\";\nimport type {\n  SingleSkillUserModel,\n  SkillModel,\n  UserModel,\n  UserSkillModel,\n} from \"./types\";\nimport { NotFoundError } from \"../src/sequelize/types\";", "} from \"./types\";\nimport { NotFoundError } from \"../src/sequelize/types\";\n\ndotenv.config();\n\ndescribe(\"Bulk Create\", () => {\n  let sequelize: Sequelize;\n\n  beforeAll(async () => {\n    extendSequelize(Sequelize);", "  beforeAll(async () => {\n    extendSequelize(Sequelize);\n\n    sequelize = new Sequelize(\"sqlite::memory:\", {\n      logging: false,\n    });\n  });\n\n  afterEach(async () => {\n    await sequelize.drop();", "  afterEach(async () => {\n    await sequelize.drop();\n    jest.clearAllMocks();\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n  });\n\n  it(\"Should create records with no associations\", async () => {", "\n  it(\"Should create records with no associations\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    await sequelize.sync();\n\n    const users = await User.bulkCreate([\n      {\n        name: \"Justin\",\n        age: 33,", "        name: \"Justin\",\n        age: 33,\n      },\n      {\n        name: \"Kevin\",\n        age: 32,\n      },\n    ]);\n\n    const fetchedUsers = await User.findAll({", "\n    const fetchedUsers = await User.findAll({\n      where: { id: { [Op.in]: users.map((user) => user.id) } },\n    });\n\n    expect(users).toEqual([\n      expect.objectContaining({ name: \"Justin\", age: 33 }),\n      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n    ]);\n    expect(fetchedUsers).toEqual([", "    ]);\n    expect(fetchedUsers).toEqual([\n      expect.objectContaining({ name: \"Justin\", age: 33 }),\n      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n    ]);\n  });\n\n  it(\"Should create records associated through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",", "    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {", "\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const { id: cookingId } = await Skill.create({ name: \"Cooking\" });\n", "    const { id: cookingId } = await Skill.create({ name: \"Cooking\" });\n\n    const users = await User.bulkCreate([\n      {\n        name: \"Justin\",\n        age: 33,\n        skill: { name: \"Programming\" },\n      },\n      {\n        name: \"Kevin\",", "      {\n        name: \"Kevin\",\n        age: 32,\n        skill: { id: cookingId },\n      },\n    ]);\n\n    const usersWithAssociations = await User.findAll({\n      where: { id: { [Op.in]: users.map((user) => user.id) } },\n      include: [\"skill\"],", "      where: { id: { [Op.in]: users.map((user) => user.id) } },\n      include: [\"skill\"],\n    });\n\n    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n    expect(usersWithAssociations[0].age).toEqual(33);\n    expect(usersWithAssociations[0].skill?.name).toEqual(\"Programming\");\n    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skill?.name).toEqual(\"Cooking\");", "    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skill?.name).toEqual(\"Cooking\");\n\n    const programming = await Skill.findByPk(\n      usersWithAssociations[0].skill?.id,\n      {\n        include: [\"user\"],\n      },\n    );\n", "    );\n\n    expect(programming?.user?.id).toEqual(users[0].id);\n    expect(programming?.user?.name).toEqual(\"Justin\");\n    expect(programming?.user?.age).toEqual(33);\n\n    const cooking = await Skill.findByPk(usersWithAssociations[1].skill?.id, {\n      include: [\"user\"],\n    });\n", "    });\n\n    expect(cooking?.user?.id).toEqual(users[1].id);\n    expect(cooking?.user?.name).toEqual(\"Kevin\");\n    expect(cooking?.user?.age).toEqual(32);\n  });\n\n  it(\"Should create records associated through hasOne - inverse\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",", "    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {", "\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const { id: kevinId } = await User.create({ name: \"Kevin\", age: 32 });\n", "    const { id: kevinId } = await User.create({ name: \"Kevin\", age: 32 });\n\n    const skills = await Skill.bulkCreate([\n      {\n        name: \"Programming\",\n        user: {\n          name: \"Justin\",\n          age: 33,\n        },\n      },", "        },\n      },\n      {\n        name: \"Cooking\",\n        user: {\n          id: kevinId,\n        },\n      },\n    ]);\n", "    ]);\n\n    const skillsWithAssociations = await Skill.findAll({\n      where: { id: { [Op.in]: skills.map((skill) => skill.id as number) } },\n      include: [\"user\"],\n    });\n\n    expect(skillsWithAssociations[0].user?.name).toEqual(\"Justin\");\n    expect(skillsWithAssociations[0].user?.age).toEqual(33);\n    expect(skillsWithAssociations[1].user?.name).toEqual(\"Kevin\");", "    expect(skillsWithAssociations[0].user?.age).toEqual(33);\n    expect(skillsWithAssociations[1].user?.name).toEqual(\"Kevin\");\n    expect(skillsWithAssociations[1].user?.age).toEqual(32);\n\n    const users = await User.findAll({\n      where: {\n        id: {\n          [Op.in]: skillsWithAssociations.map(\n            (skill) => skill.user?.id as number,\n          ),", "            (skill) => skill.user?.id as number,\n          ),\n        },\n      },\n      include: [\"skill\"],\n    });\n\n    expect(users[0].name).toEqual(\"Kevin\");\n    expect(users[0].age).toEqual(32);\n    expect(users[0].skill?.id).toEqual(skills[1].id);", "    expect(users[0].age).toEqual(32);\n    expect(users[0].skill?.id).toEqual(skills[1].id);\n    expect(users[0].skill?.name).toEqual(\"Cooking\");\n    expect(users[1].name).toEqual(\"Justin\");\n    expect(users[1].age).toEqual(33);\n    expect(users[1].skill?.id).toEqual(skills[0].id);\n    expect(users[1].skill?.name).toEqual(\"Programming\");\n  });\n\n  it(\"Should throw with non-existing IDs through hasOne\", async () => {", "\n  it(\"Should throw with non-existing IDs through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,", "        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });", "      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n", "    await sequelize.sync();\n\n    await expect(\n      User.bulkCreate([\n        {\n          name: \"Justin\",\n          age: 33,\n          skill: { name: \"Programming\" },\n        },\n        {", "        },\n        {\n          name: \"Kevin\",\n          age: 32,\n          skill: { id: -1 },\n        },\n      ]),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",", "      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/1/relationships/skill/data/id\",\n      }),\n    ]);\n  });\n\n  it(\"Should create records associated through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",", "    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {", "\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const cookingId = (await Skill.create({ name: \"Cooking\" })).id;\n", "    const cookingId = (await Skill.create({ name: \"Cooking\" })).id;\n\n    const users = await User.bulkCreate([\n      {\n        name: \"Justin\",\n        age: 33,\n        skills: [{ name: \"Programming\" }, { id: cookingId }],\n      },\n      {\n        name: \"Kevin\",", "      {\n        name: \"Kevin\",\n        age: 32,\n        skills: [{ name: \"Running\" }],\n      },\n    ]);\n\n    const usersWithAssociations = await User.findAll({\n      where: { id: { [Op.in]: users.map((user) => user.id) } },\n      include: \"skills\",", "      where: { id: { [Op.in]: users.map((user) => user.id) } },\n      include: \"skills\",\n    });\n\n    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n    expect(usersWithAssociations[0].age).toEqual(33);\n    expect(usersWithAssociations[0].skills).toHaveLength(2);\n    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skills).toHaveLength(1);", "    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skills).toHaveLength(1);\n\n    const programming = usersWithAssociations[0].skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n    const cooking = usersWithAssociations[0].skills?.find(\n      ({ name }) => name === \"Cooking\",\n    );\n    const running = usersWithAssociations[1].skills?.find(", "    );\n    const running = usersWithAssociations[1].skills?.find(\n      ({ name }) => name === \"Running\",\n    );\n\n    expect(programming).toBeTruthy();\n    expect(cooking).toBeTruthy();\n    expect(running).toBeTruthy();\n\n    const programmingWithUser = await Skill.findByPk(", "\n    const programmingWithUser = await Skill.findByPk(\n      usersWithAssociations[0].skills?.find(\n        ({ name }) => name === \"Programming\",\n      )?.id,\n      { include: [\"user\"] },\n    );\n\n    expect(programmingWithUser?.name).toEqual(\"Programming\");\n    expect(programmingWithUser?.user?.id).toEqual(users[0].id);", "    expect(programmingWithUser?.name).toEqual(\"Programming\");\n    expect(programmingWithUser?.user?.id).toEqual(users[0].id);\n    expect(programmingWithUser?.user?.name).toEqual(\"Justin\");\n    expect(programmingWithUser?.user?.age).toEqual(33);\n\n    const cookingWithUsers = await Skill.findByPk(\n      usersWithAssociations[0].skills?.find(({ name }) => name === \"Cooking\")\n        ?.id,\n      { include: [\"user\"] },\n    );", "      { include: [\"user\"] },\n    );\n\n    expect(cookingWithUsers?.name).toEqual(\"Cooking\");\n    expect(cookingWithUsers?.user?.id).toEqual(users[0].id);\n    expect(cookingWithUsers?.user?.name).toEqual(\"Justin\");\n    expect(cookingWithUsers?.user?.age).toEqual(33);\n\n    const runningWithUser = await Skill.findByPk(\n      usersWithAssociations[1].skills?.find(({ name }) => name === \"Running\")", "    const runningWithUser = await Skill.findByPk(\n      usersWithAssociations[1].skills?.find(({ name }) => name === \"Running\")\n        ?.id,\n      { include: [\"user\"] },\n    );\n\n    expect(runningWithUser?.name).toEqual(\"Running\");\n    expect(runningWithUser?.user?.id).toEqual(users[1].id);\n    expect(runningWithUser?.user?.name).toEqual(\"Kevin\");\n    expect(runningWithUser?.user?.age).toEqual(32);", "    expect(runningWithUser?.user?.name).toEqual(\"Kevin\");\n    expect(runningWithUser?.user?.age).toEqual(32);\n  });\n\n  it(\"Should create records associated through hasMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {", "      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {", "\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });", "      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const { id: justinId } = await User.create({ name: \"Justin\", age: 33 });\n\n    const skills = await Skill.bulkCreate([\n      {\n        name: \"Programming\",", "      {\n        name: \"Programming\",\n        user: {\n          id: justinId,\n        },\n      },\n      {\n        name: \"Cooking\",\n        user: {\n          id: justinId,", "        user: {\n          id: justinId,\n        },\n      },\n      {\n        name: \"Running\",\n        user: {\n          name: \"Kevin\",\n          age: 32,\n        },", "          age: 32,\n        },\n      },\n    ]);\n\n    const skillsWithAssociations = await Skill.findAll({\n      where: { id: { [Op.in]: skills.map((skill) => skill.id as number) } },\n      include: \"user\",\n    });\n", "    });\n\n    expect(skillsWithAssociations[0].name).toEqual(\"Programming\");\n    expect(skillsWithAssociations[0].user?.name).toEqual(\"Justin\");\n    expect(skillsWithAssociations[0].user?.age).toEqual(33);\n    expect(skillsWithAssociations[1].name).toEqual(\"Cooking\");\n    expect(skillsWithAssociations[1].user?.name).toEqual(\"Justin\");\n    expect(skillsWithAssociations[1].user?.age).toEqual(33);\n    expect(skillsWithAssociations[2].name).toEqual(\"Running\");\n    expect(skillsWithAssociations[2].user?.name).toEqual(\"Kevin\");", "    expect(skillsWithAssociations[2].name).toEqual(\"Running\");\n    expect(skillsWithAssociations[2].user?.name).toEqual(\"Kevin\");\n    expect(skillsWithAssociations[2].user?.age).toEqual(32);\n\n    const usersWithAssociations = await User.findAll({\n      where: {\n        id: {\n          [Op.in]: skillsWithAssociations.map(\n            (skill) => skill.user?.id as number,\n          ),", "            (skill) => skill.user?.id as number,\n          ),\n        },\n      },\n      include: [\"skills\"],\n    });\n\n    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n    expect(usersWithAssociations[0].age).toEqual(33);\n    expect(usersWithAssociations[0].skills).toHaveLength(2);", "    expect(usersWithAssociations[0].age).toEqual(33);\n    expect(usersWithAssociations[0].skills).toHaveLength(2);\n    expect(usersWithAssociations[0].skills?.[0].name).toEqual(\"Programming\");\n    expect(usersWithAssociations[0].skills?.[1].name).toEqual(\"Cooking\");\n    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skills).toHaveLength(1);\n    expect(usersWithAssociations[1].skills?.[0].name).toEqual(\"Running\");\n  });\n", "  });\n\n  it(\"Should throw with non-existing IDs through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },", "        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",", "      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();", "\n    await sequelize.sync();\n\n    await expect(\n      User.bulkCreate([\n        {\n          name: \"Justin\",\n          age: 33,\n          skills: [{ name: \"Programming\" }, { id: -1 }],\n        },", "          skills: [{ name: \"Programming\" }, { id: -1 }],\n        },\n        {\n          name: \"Kevin\",\n          age: 32,\n          skills: [{ name: \"Running\" }, { id: -2 }, { id: -3 }],\n        },\n      ]),\n    ).rejects.toEqualErrors([\n      new NotFoundError({", "    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/0/relationships/skills/data/1/id\",\n      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/1/relationships/skills/data/1/id\",\n      }),\n      new NotFoundError({", "      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/1/relationships/skills/data/2/id\",\n      }),\n    ]);\n  });\n\n  it(\"Should create table and records associated through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(", "  it(\"Should create table and records associated through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,", "        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",", "      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });", "      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    const { id: programmingId } = await Skill.create({ name: \"Programming\" });\n\n    const users = await User.bulkCreate([\n      {\n        name: \"Justin\",", "      {\n        name: \"Justin\",\n        age: 33,\n        skills: [\n          { id: programmingId },\n          { name: \"Cooking\", through: { selfGranted: true } },\n        ],\n      },\n      {\n        name: \"Kevin\",", "      {\n        name: \"Kevin\",\n        age: 32,\n        skills: [{ id: programmingId, through: { selfGranted: false } }],\n      },\n    ]);\n\n    const usersWithAssociations = await User.findAll({\n      where: { id: { [Op.in]: users.map((user) => user.id) } },\n      include: \"skills\",", "      where: { id: { [Op.in]: users.map((user) => user.id) } },\n      include: \"skills\",\n    });\n\n    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n    expect(usersWithAssociations[0].age).toEqual(33);\n    expect(usersWithAssociations[0].skills).toHaveLength(2);\n    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skills).toHaveLength(1);", "    expect(usersWithAssociations[1].age).toEqual(32);\n    expect(usersWithAssociations[1].skills).toHaveLength(1);\n\n    const programming = usersWithAssociations[0].skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n    const cooking = usersWithAssociations[0].skills?.find(\n      ({ name }) => name === \"Cooking\",\n    );\n    const programming2 = usersWithAssociations[1].skills?.find(", "    );\n    const programming2 = usersWithAssociations[1].skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n\n    expect(programming?.UserSkill?.selfGranted).toBeNull();\n    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n    expect(programming2?.UserSkill?.selfGranted).toEqual(false);\n\n    const programmingWithUsers = await Skill.findByPk(", "\n    const programmingWithUsers = await Skill.findByPk(\n      usersWithAssociations[0].skills?.find(\n        ({ name }) => name === \"Programming\",\n      )?.id,\n      { include: [\"users\"] },\n    );\n\n    expect(programmingWithUsers?.name).toEqual(\"Programming\");\n    expect(programmingWithUsers?.users?.[0]?.id).toEqual(users[0].id);", "    expect(programmingWithUsers?.name).toEqual(\"Programming\");\n    expect(programmingWithUsers?.users?.[0]?.id).toEqual(users[0].id);\n    expect(programmingWithUsers?.users?.[0]?.name).toEqual(\"Justin\");\n    expect(programmingWithUsers?.users?.[0]?.age).toEqual(33);\n    expect(programmingWithUsers?.users?.[0]?.UserSkill?.selfGranted).toBeNull();\n    expect(programmingWithUsers?.users?.[1]?.id).toEqual(users[1].id);\n    expect(programmingWithUsers?.users?.[1]?.name).toEqual(\"Kevin\");\n    expect(programmingWithUsers?.users?.[1]?.age).toEqual(32);\n    expect(programmingWithUsers?.users?.[1]?.UserSkill?.selfGranted).toEqual(\n      false,", "    expect(programmingWithUsers?.users?.[1]?.UserSkill?.selfGranted).toEqual(\n      false,\n    );\n\n    const cookingWithUser = await Skill.findByPk(\n      usersWithAssociations[0].skills?.find(({ name }) => name === \"Cooking\")\n        ?.id,\n      { include: [\"users\"] },\n    );\n", "    );\n\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n    expect(cookingWithUser?.users?.[0]?.id).toEqual(users[0].id);\n    expect(cookingWithUser?.users?.[0]?.name).toEqual(\"Justin\");\n    expect(cookingWithUser?.users?.[0]?.age).toEqual(33);\n    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n  });\n\n  it(\"Should create table and records associated through belongsToMany - inverse\", async () => {", "\n  it(\"Should create table and records associated through belongsToMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },", "        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",", "    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,", "      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    const { id: justinId } = await User.create({ name: \"Justin\", age: 33 });\n\n    await Skill.bulkCreate([\n      {", "    await Skill.bulkCreate([\n      {\n        name: \"Programming\",\n        users: [\n          {\n            id: justinId,\n          } as UserModel,\n          {\n            name: \"Kevin\",\n            age: 32,", "            name: \"Kevin\",\n            age: 32,\n            through: { selfGranted: false },\n          } as UserModel,\n        ],\n      },\n      {\n        name: \"Cooking\",\n        users: [\n          {", "        users: [\n          {\n            id: justinId,\n            through: { selfGranted: true },\n          } as UserModel,\n        ],\n      },\n    ]);\n\n    const kevinId = (", "\n    const kevinId = (\n      await User.findOne({\n        where: { name: \"Kevin\", age: 32 },\n      })\n    )?.id;\n\n    const users = await User.findAll({\n      where: { id: { [Op.in]: [justinId, kevinId] as number[] } },\n      include: \"skills\",", "      where: { id: { [Op.in]: [justinId, kevinId] as number[] } },\n      include: \"skills\",\n    });\n\n    expect(users[0].name).toEqual(\"Justin\");\n    expect(users[0].age).toEqual(33);\n    expect(users[0].skills).toHaveLength(2);\n\n    const programming = users[0].skills?.find(\n      ({ name }) => name === \"Programming\",", "    const programming = users[0].skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n    const cooking = users[0].skills?.find(({ name }) => name === \"Cooking\");\n    const programming2 = users[1].skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n\n    expect(programming?.UserSkill?.selfGranted).toBeNull();\n    expect(cooking?.UserSkill?.selfGranted).toEqual(true);", "    expect(programming?.UserSkill?.selfGranted).toBeNull();\n    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n    expect(programming2?.UserSkill?.selfGranted).toEqual(false);\n\n    const programmingWithUsers = await Skill.findByPk(programming?.id, {\n      include: [\"users\"],\n    });\n\n    expect(programmingWithUsers?.name).toEqual(\"Programming\");\n    expect(programmingWithUsers?.users).toHaveLength(2);", "    expect(programmingWithUsers?.name).toEqual(\"Programming\");\n    expect(programmingWithUsers?.users).toHaveLength(2);\n    expect(programmingWithUsers?.users?.[0]?.id).toEqual(kevinId);\n    expect(programmingWithUsers?.users?.[0]?.name).toEqual(\"Kevin\");\n    expect(programmingWithUsers?.users?.[0]?.age).toEqual(32);\n    expect(programmingWithUsers?.users?.[0]?.UserSkill?.selfGranted).toEqual(\n      false,\n    );\n    expect(programmingWithUsers?.users?.[1]?.id).toEqual(justinId);\n    expect(programmingWithUsers?.users?.[1]?.name).toEqual(\"Justin\");", "    expect(programmingWithUsers?.users?.[1]?.id).toEqual(justinId);\n    expect(programmingWithUsers?.users?.[1]?.name).toEqual(\"Justin\");\n    expect(programmingWithUsers?.users?.[1]?.age).toEqual(33);\n    expect(programmingWithUsers?.users?.[1]?.UserSkill?.selfGranted).toBeNull();\n\n    const cookingWithUser = await Skill.findByPk(cooking?.id, {\n      include: [\"users\"],\n    });\n\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");", "\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n    expect(cookingWithUser?.users).toHaveLength(1);\n    expect(cookingWithUser?.users?.[0]?.id).toEqual(justinId);\n    expect(cookingWithUser?.users?.[0]?.name).toEqual(\"Justin\");\n    expect(cookingWithUser?.users?.[0]?.age).toEqual(33);\n    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n  });\n\n  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {", "\n  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },", "        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",", "    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,", "      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    await expect(\n      User.bulkCreate([\n        {\n          name: \"Justin\",", "        {\n          name: \"Justin\",\n          age: 33,\n          skills: [\n            { id: -1 },\n            { name: \"Cooking\", through: { selfGranted: true } },\n          ],\n        },\n        {\n          name: \"Kevin\",", "        {\n          name: \"Kevin\",\n          age: 32,\n          skills: [\n            { id: -2, through: { selfGranted: false } },\n            { id: -3, through: { selfGranted: true } },\n          ],\n        },\n      ]),\n    ).rejects.toEqualErrors([", "      ]),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/0/relationships/skills/data/0/id\",\n      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/1/relationships/skills/data/0/id\",\n      }),", "        pointer: \"/data/1/relationships/skills/data/0/id\",\n      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/1/relationships/skills/data/1/id\",\n      }),\n    ]);\n  });\n});\n", "});\n"]}
{"filename": "tests/extended.spec.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\nimport * as dotenv from \"dotenv\";\nimport { extendSequelize, getLookup } from \"../src/sequelize/extended\";\nimport type {\n  SingleSkillUserModel,\n  SkillModel,\n  UserModel,\n  UserSkillModel,\n} from \"./types\";\n", "} from \"./types\";\n\ndotenv.config();\n\ndescribe(\"Extended\", () => {\n  let sequelize: Sequelize;\n\n  beforeAll(async () => {\n    extendSequelize(Sequelize);\n", "    extendSequelize(Sequelize);\n\n    sequelize = new Sequelize(\"sqlite::memory:\", {\n      logging: false,\n    });\n  });\n\n  afterEach(async () => {\n    await sequelize.drop();\n    jest.clearAllMocks();", "    await sequelize.drop();\n    jest.clearAllMocks();\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n  });\n\n  describe(\"getLookup\", () => {\n    it(\"Should get the associations for one to one\", () => {", "  describe(\"getLookup\", () => {\n    it(\"Should get the associations for one to one\", () => {\n      const User = sequelize.define<SingleSkillUserModel>(\n        \"User\",\n        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n          },", "            autoIncrement: true,\n          },\n          name: DataTypes.STRING,\n          age: DataTypes.INTEGER,\n        },\n        { timestamps: false },\n      );\n\n      const Skill = sequelize.define<SkillModel>(\n        \"Skill\",", "      const Skill = sequelize.define<SkillModel>(\n        \"Skill\",\n        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n          },\n          name: DataTypes.STRING,\n          userId: DataTypes.INTEGER,", "          name: DataTypes.STRING,\n          userId: DataTypes.INTEGER,\n        },\n        { timestamps: false },\n      );\n\n      User.hasOne(Skill, {\n        as: \"skill\",\n        foreignKey: \"userId\",\n      });", "        foreignKey: \"userId\",\n      });\n\n      Skill.belongsTo(User, {\n        as: \"user\",\n        foreignKey: \"userId\",\n      });\n\n      expect(getLookup(sequelize)).toEqual({\n        User: {", "      expect(getLookup(sequelize)).toEqual({\n        User: {\n          skill: {\n            joinTable: undefined,\n            type: \"HasOne\",\n            key: \"userId\",\n            model: \"Skill\",\n          },\n        },\n        Skill: { user: { type: \"BelongsTo\", key: \"userId\", model: \"User\" } },", "        },\n        Skill: { user: { type: \"BelongsTo\", key: \"userId\", model: \"User\" } },\n      });\n    });\n\n    it(\"Should get the associations for one to many\", () => {\n      const User = sequelize.define<UserModel>(\n        \"User\",\n        {\n          id: {", "        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n          },\n          name: DataTypes.STRING,\n          age: DataTypes.INTEGER,\n        },\n        { timestamps: false },", "        },\n        { timestamps: false },\n      );\n\n      const Skill = sequelize.define<SkillModel>(\n        \"Skill\",\n        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,", "            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n          },\n          name: DataTypes.STRING,\n          userId: DataTypes.INTEGER,\n        },\n        { timestamps: false },\n      );\n", "      );\n\n      User.hasMany(Skill, {\n        as: \"skills\",\n        foreignKey: \"userId\",\n      });\n\n      Skill.belongsTo(User, {\n        as: \"user\",\n        foreignKey: \"userId\",", "        as: \"user\",\n        foreignKey: \"userId\",\n      });\n\n      expect(getLookup(sequelize)).toEqual({\n        User: { skills: { type: \"HasMany\", key: \"userId\", model: \"Skill\" } },\n        Skill: { user: { type: \"BelongsTo\", key: \"userId\", model: \"User\" } },\n      });\n    });\n", "    });\n\n    it(\"Should get the associations for many to many\", () => {\n      const User = sequelize.define<UserModel>(\n        \"User\",\n        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,", "            primaryKey: true,\n            autoIncrement: true,\n          },\n          name: DataTypes.STRING,\n          age: DataTypes.INTEGER,\n        },\n        { timestamps: false },\n      );\n\n      const Skill = sequelize.define<SkillModel>(", "\n      const Skill = sequelize.define<SkillModel>(\n        \"Skill\",\n        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n          },\n          name: DataTypes.STRING,", "          },\n          name: DataTypes.STRING,\n        },\n        { timestamps: false },\n      );\n\n      const UserSkill = sequelize.define<UserSkillModel>(\n        \"UserSkill\",\n        {\n          id: {", "        {\n          id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n          },\n          userId: DataTypes.INTEGER,\n          skillId: DataTypes.INTEGER,\n          selfGranted: DataTypes.BOOLEAN,\n        },", "          selfGranted: DataTypes.BOOLEAN,\n        },\n        { timestamps: false },\n      );\n\n      User.belongsToMany(Skill, {\n        as: \"skills\",\n        foreignKey: \"userId\",\n        through: UserSkill,\n      });", "        through: UserSkill,\n      });\n\n      Skill.belongsToMany(User, {\n        as: \"users\",\n        foreignKey: \"skillId\",\n        through: UserSkill,\n      });\n\n      expect(getLookup(sequelize)).toEqual({", "\n      expect(getLookup(sequelize)).toEqual({\n        Skill: {\n          users: {\n            joinTable: expect.any(Function),\n            key: \"skillId\",\n            model: \"User\",\n            type: \"BelongsToMany\",\n          },\n        },", "          },\n        },\n        User: {\n          skills: {\n            joinTable: expect.any(Function),\n            key: \"userId\",\n            model: \"Skill\",\n            type: \"BelongsToMany\",\n          },\n        },", "          },\n        },\n        UserSkill: {},\n      });\n    });\n  });\n});\n"]}
{"filename": "tests/create.spec.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\nimport * as dotenv from \"dotenv\";\nimport { extendSequelize } from \"../src/sequelize/extended\";\nimport type {\n  SingleSkillUserModel,\n  SkillModel,\n  UserModel,\n  UserSkillModel,\n} from \"./types\";\nimport { NotFoundError } from \"../src/sequelize/types\";", "} from \"./types\";\nimport { NotFoundError } from \"../src/sequelize/types\";\n\ndotenv.config();\n\ndescribe(\"Create\", () => {\n  let sequelize: Sequelize;\n\n  beforeAll(async () => {\n    extendSequelize(Sequelize);", "  beforeAll(async () => {\n    extendSequelize(Sequelize);\n\n    sequelize = new Sequelize(\"sqlite::memory:\", {\n      logging: false,\n    });\n  });\n\n  afterEach(async () => {\n    await sequelize.drop();", "  afterEach(async () => {\n    await sequelize.drop();\n    jest.clearAllMocks();\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n  });\n\n  it(\"Should create records with no associations\", async () => {", "\n  it(\"Should create records with no associations\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n    });", "      age: 33,\n    });\n\n    const fetchedUser = await User.findByPk(user.id);\n\n    expect(user).toEqual(expect.objectContaining({ name: \"Justin\", age: 33 }));\n    expect(fetchedUser).toEqual(\n      expect.objectContaining({ name: \"Justin\", age: 33 }),\n    );\n  });", "    );\n  });\n\n  it(\"Should create records associated through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,", "        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",", "    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n", "    });\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 32,\n      skill: { name: \"Programming\" },\n    });\n", "    });\n\n    const userWithAssociations = await User.findByPk(user.id, {\n      include: [\"skill\"],\n    });\n\n    expect(userWithAssociations?.name).toEqual(\"Justin\");\n    expect(userWithAssociations?.age).toEqual(32);\n    expect(userWithAssociations?.skill?.name).toEqual(\"Programming\");\n", "    expect(userWithAssociations?.skill?.name).toEqual(\"Programming\");\n\n    const skill = await Skill.findByPk(userWithAssociations?.skill?.id, {\n      include: [\"user\"],\n    });\n\n    expect(skill?.user?.id).toEqual(user.id);\n    expect(skill?.user?.name).toEqual(\"Justin\");\n    expect(skill?.user?.age).toEqual(32);\n  });", "    expect(skill?.user?.age).toEqual(32);\n  });\n\n  it(\"Should create records associated through hasOne - id\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,", "        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",", "    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n", "    });\n\n    await sequelize.sync();\n\n    const programming = await Skill.create({ name: \"Programming\" });\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 32,\n      skill: { id: programming.id },", "      age: 32,\n      skill: { id: programming.id },\n    });\n\n    const userWithAssociations = await User.findByPk(user.id, {\n      include: [\"skill\"],\n    });\n\n    expect(userWithAssociations?.name).toEqual(\"Justin\");\n    expect(userWithAssociations?.age).toEqual(32);", "    expect(userWithAssociations?.name).toEqual(\"Justin\");\n    expect(userWithAssociations?.age).toEqual(32);\n    expect(userWithAssociations?.skill?.name).toEqual(\"Programming\");\n\n    const skill = await Skill.findByPk(userWithAssociations?.skill?.id, {\n      include: [\"user\"],\n    });\n\n    expect(skill?.user?.id).toEqual(user.id);\n    expect(skill?.user?.name).toEqual(\"Justin\");", "    expect(skill?.user?.id).toEqual(user.id);\n    expect(skill?.user?.name).toEqual(\"Justin\");\n    expect(skill?.user?.age).toEqual(32);\n  });\n\n  it(\"Should create records associated through hasOne - inverse\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",", "    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",", "      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const skill = await Skill.create({\n      name: \"Programming\",\n      user: {\n        name: \"Justin\",", "      user: {\n        name: \"Justin\",\n        age: 32,\n      },\n    });\n\n    const skillWithAssociations = await Skill.findByPk(skill.id, {\n      include: [\"user\"],\n    });\n", "    });\n\n    expect(skillWithAssociations?.user?.name).toEqual(\"Justin\");\n    expect(skillWithAssociations?.user?.age).toEqual(32);\n\n    const user = await User.findByPk(skillWithAssociations?.user?.id, {\n      include: [\"skill\"],\n    });\n\n    expect(user?.name).toEqual(\"Justin\");", "\n    expect(user?.name).toEqual(\"Justin\");\n    expect(user?.age).toEqual(32);\n    expect(user?.skill?.id).toEqual(skill.id);\n    expect(user?.skill?.name).toEqual(\"Programming\");\n  });\n\n  it(\"Should throw with non-existing IDs through hasOne\", async () => {\n    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",", "    const User = sequelize.define<SingleSkillUserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    User.hasOne(Skill, {\n      as: \"skill\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {", "\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    await expect(\n      User.create({", "    await expect(\n      User.create({\n        name: \"Justin\",\n        age: 32,\n        skill: { id: -1 },\n      }),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skill/data/id\",", "        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skill/data/id\",\n      }),\n    ]);\n  });\n\n  it(\"Should create records associated through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {", "      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(", "\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",", "    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const cookingId = (await Skill.create({ name: \"Cooking\" })).id;\n\n    const user = await User.create({", "\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [{ name: \"Programming\" }, { id: cookingId }],\n    });\n\n    const userWithAssociations = await User.findByPk(user.id, {\n      include: \"skills\",\n    });", "      include: \"skills\",\n    });\n\n    expect(userWithAssociations?.name).toEqual(\"Justin\");\n    expect(userWithAssociations?.age).toEqual(33);\n    expect(userWithAssociations?.skills).toHaveLength(2);\n\n    const programming = userWithAssociations?.skills?.find(\n      ({ name }) => name === \"Programming\",\n    );", "      ({ name }) => name === \"Programming\",\n    );\n    const cooking = userWithAssociations?.skills?.find(\n      ({ name }) => name === \"Cooking\",\n    );\n\n    expect(programming).toBeTruthy();\n    expect(cooking).toBeTruthy();\n\n    const programmingWithUser = await Skill.findByPk(", "\n    const programmingWithUser = await Skill.findByPk(\n      userWithAssociations?.skills?.find(({ name }) => name === \"Programming\")\n        ?.id,\n      { include: [\"user\"] },\n    );\n\n    expect(programmingWithUser?.name).toEqual(\"Programming\");\n    expect(programmingWithUser?.user?.id).toEqual(user.id);\n    expect(programmingWithUser?.user?.name).toEqual(user.name);", "    expect(programmingWithUser?.user?.id).toEqual(user.id);\n    expect(programmingWithUser?.user?.name).toEqual(user.name);\n    expect(programmingWithUser?.user?.age).toEqual(user.age);\n\n    const cookingWithUser = await Skill.findByPk(\n      userWithAssociations?.skills?.find(({ name }) => name === \"Cooking\")?.id,\n      { include: [\"user\"] },\n    );\n\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");", "\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n    expect(cookingWithUser?.user?.id).toEqual(user.id);\n    expect(cookingWithUser?.user?.name).toEqual(user.name);\n    expect(cookingWithUser?.user?.age).toEqual(user.age);\n  });\n\n  it(\"Should create records associated through hasMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",", "    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {", "\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    const skill = await Skill.create({\n      name: \"Programming\",", "    const skill = await Skill.create({\n      name: \"Programming\",\n      user: {\n        name: \"Justin\",\n        age: 33,\n      },\n    });\n\n    const skillWithAssociations = await Skill.findByPk(skill.id, {\n      include: \"user\",", "    const skillWithAssociations = await Skill.findByPk(skill.id, {\n      include: \"user\",\n    });\n\n    expect(skillWithAssociations?.name).toEqual(\"Programming\");\n    expect(skillWithAssociations?.user?.name).toEqual(\"Justin\");\n    expect(skillWithAssociations?.user?.age).toEqual(33);\n\n    const userWithAssociations = await User.findByPk(\n      skillWithAssociations?.user?.id,", "    const userWithAssociations = await User.findByPk(\n      skillWithAssociations?.user?.id,\n      {\n        include: [\"skills\"],\n      },\n    );\n\n    expect(userWithAssociations?.name).toEqual(\"Justin\");\n    expect(userWithAssociations?.age).toEqual(33);\n    expect(userWithAssociations?.skills).toHaveLength(1);", "    expect(userWithAssociations?.age).toEqual(33);\n    expect(userWithAssociations?.skills).toHaveLength(1);\n    expect(userWithAssociations?.skills?.[0].name).toEqual(\"Programming\");\n  });\n\n  it(\"Should throw with non-existing IDs through hasMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },", "      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",", "    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        userId: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );\n", "    );\n\n    User.hasMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n    });\n\n    Skill.belongsTo(User, {\n      as: \"user\",\n      foreignKey: \"userId\",", "      as: \"user\",\n      foreignKey: \"userId\",\n    });\n\n    await sequelize.sync();\n\n    await expect(\n      User.create({\n        name: \"Justin\",\n        age: 33,", "        name: \"Justin\",\n        age: 33,\n        skills: [{ name: \"Programming\" }, { id: -1 }, { id: -2 }],\n      }),\n    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/1/id\",\n      }),\n      new NotFoundError({", "      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/2/id\",\n      }),\n    ]);\n  });\n\n  it(\"Should create table and records associated through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(", "  it(\"Should create table and records associated through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,", "        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",", "      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });", "      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    const user = await User.create({\n      name: \"Justin\",\n      age: 33,\n      skills: [\n        { name: \"Programming\" },", "      skills: [\n        { name: \"Programming\" },\n        { name: \"Cooking\", through: { selfGranted: true } },\n      ],\n    });\n\n    const userWithAssociations = await User.findByPk(user.id, {\n      include: \"skills\",\n    });\n", "    });\n\n    expect(userWithAssociations?.name).toEqual(\"Justin\");\n    expect(userWithAssociations?.age).toEqual(33);\n    expect(userWithAssociations?.skills).toHaveLength(2);\n\n    const programming = userWithAssociations?.skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n    const cooking = userWithAssociations?.skills?.find(", "    );\n    const cooking = userWithAssociations?.skills?.find(\n      ({ name }) => name === \"Cooking\",\n    );\n\n    expect(programming?.UserSkill?.selfGranted).toBeNull();\n    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n\n    const programmingWithUser = await Skill.findByPk(\n      userWithAssociations?.skills?.find(({ name }) => name === \"Programming\")", "    const programmingWithUser = await Skill.findByPk(\n      userWithAssociations?.skills?.find(({ name }) => name === \"Programming\")\n        ?.id,\n      { include: [\"users\"] },\n    );\n\n    expect(programmingWithUser?.name).toEqual(\"Programming\");\n    expect(programmingWithUser?.users?.[0]?.id).toEqual(user.id);\n    expect(programmingWithUser?.users?.[0]?.name).toEqual(user.name);\n    expect(programmingWithUser?.users?.[0]?.age).toEqual(user.age);", "    expect(programmingWithUser?.users?.[0]?.name).toEqual(user.name);\n    expect(programmingWithUser?.users?.[0]?.age).toEqual(user.age);\n    expect(programmingWithUser?.users?.[0]?.UserSkill?.selfGranted).toBeNull();\n\n    const cookingWithUser = await Skill.findByPk(\n      userWithAssociations?.skills?.find(({ name }) => name === \"Cooking\")?.id,\n      { include: [\"users\"] },\n    );\n\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");", "\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n    expect(cookingWithUser?.users?.[0]?.id).toEqual(user.id);\n    expect(cookingWithUser?.users?.[0]?.name).toEqual(user.name);\n    expect(cookingWithUser?.users?.[0]?.age).toEqual(user.age);\n    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n  });\n\n  it(\"Should create table and records associated through belongsToMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(", "  it(\"Should create table and records associated through belongsToMany - inverse\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },\n    );", "      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,", "        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",", "      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,\n    });", "      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    await Skill.create({\n      name: \"Programming\",\n      users: [{ name: \"Justin\", age: 33 } as UserModel],\n    });\n", "    });\n\n    const userId = (\n      await User.findOne({\n        where: { name: \"Justin\", age: 33 },\n      })\n    )?.id;\n\n    await Skill.create({\n      name: \"Cooking\",", "    await Skill.create({\n      name: \"Cooking\",\n      users: [\n        {\n          id: userId,\n          through: { selfGranted: true },\n        } as UserModel,\n      ],\n    });\n", "    });\n\n    const user = await User.findByPk(userId, {\n      include: \"skills\",\n    });\n\n    expect(user?.name).toEqual(\"Justin\");\n    expect(user?.age).toEqual(33);\n    expect(user?.skills).toHaveLength(2);\n", "    expect(user?.skills).toHaveLength(2);\n\n    const programming = user?.skills?.find(\n      ({ name }) => name === \"Programming\",\n    );\n    const cooking = user?.skills?.find(({ name }) => name === \"Cooking\");\n\n    expect(programming?.UserSkill?.selfGranted).toBeNull();\n    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n", "    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n\n    const programmingWithUser = await Skill.findByPk(\n      user?.skills?.find(({ name }) => name === \"Programming\")?.id,\n      { include: [\"users\"] },\n    );\n\n    expect(programmingWithUser?.name).toEqual(\"Programming\");\n    expect(programmingWithUser?.users?.[0]?.id).toEqual(userId);\n    expect(programmingWithUser?.users?.[0]?.name).toEqual(user?.name);", "    expect(programmingWithUser?.users?.[0]?.id).toEqual(userId);\n    expect(programmingWithUser?.users?.[0]?.name).toEqual(user?.name);\n    expect(programmingWithUser?.users?.[0]?.age).toEqual(user?.age);\n    expect(programmingWithUser?.users?.[0]?.UserSkill?.selfGranted).toBeNull();\n\n    const cookingWithUser = await Skill.findByPk(\n      user?.skills?.find(({ name }) => name === \"Cooking\")?.id,\n      { include: [\"users\"] },\n    );\n", "    );\n\n    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n    expect(cookingWithUser?.users?.[0]?.id).toEqual(userId);\n    expect(cookingWithUser?.users?.[0]?.name).toEqual(user?.name);\n    expect(cookingWithUser?.users?.[0]?.age).toEqual(user?.age);\n    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n  });\n\n  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {", "\n  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {\n    const User = sequelize.define<UserModel>(\n      \"User\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n        age: DataTypes.INTEGER,\n      },\n      { timestamps: false },", "      },\n      { timestamps: false },\n    );\n\n    const Skill = sequelize.define<SkillModel>(\n      \"Skill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        name: DataTypes.STRING,\n      },", "        name: DataTypes.STRING,\n      },\n      { timestamps: false },\n    );\n\n    const UserSkill = sequelize.define<UserSkillModel>(\n      \"UserSkill\",\n      {\n        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n        userId: DataTypes.INTEGER,\n        skillId: DataTypes.INTEGER,\n        selfGranted: DataTypes.BOOLEAN,\n      },\n      { timestamps: false },\n    );\n\n    User.belongsToMany(Skill, {\n      as: \"skills\",", "    User.belongsToMany(Skill, {\n      as: \"skills\",\n      foreignKey: \"userId\",\n      through: UserSkill,\n    });\n\n    Skill.belongsToMany(User, {\n      as: \"users\",\n      foreignKey: \"skillId\",\n      through: UserSkill,", "      foreignKey: \"skillId\",\n      through: UserSkill,\n    });\n\n    await sequelize.sync();\n\n    await expect(\n      User.create({\n        name: \"Justin\",\n        age: 33,", "        name: \"Justin\",\n        age: 33,\n        skills: [\n          { name: \"Programming\" },\n          { id: -1, through: { selfGranted: true } },\n          { id: -2, through: { selfGranted: false } },\n        ],\n      }),\n    ).rejects.toEqualErrors([\n      new NotFoundError({", "    ).rejects.toEqualErrors([\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/1/id\",\n      }),\n      new NotFoundError({\n        detail: \"Payload must include an ID of an existing 'Skill'.\",\n        pointer: \"/data/relationships/skills/data/2/id\",\n      }),\n    ]);", "      }),\n    ]);\n  });\n});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { extendSequelize } from \"./sequelize/extended\";\n"]}
{"filename": "src/sequelize/extended.ts", "chunked_list": ["import type {\n  Model,\n  CreateOptions,\n  Attributes,\n  UpdateOptions,\n} from \"sequelize\";\nimport type {\n  Col,\n  Fn,\n  Literal,", "  Fn,\n  Literal,\n  MakeNullishOptional,\n} from \"sequelize/types/utils\";\nimport {\n  getValidAttributesAndAssociations,\n  handleBulkCreateAssociations,\n  handleCreateAssociations,\n  handleUpdateAssociations,\n} from \"./associations\";", "  handleUpdateAssociations,\n} from \"./associations\";\nimport { UnexpectedValueError } from \"./types\";\nimport type { IAssociation } from \"./types\";\n\ntype AssociationLookup = Record<string, Record<string, IAssociation>>;\n\nlet associationsLookup: AssociationLookup;\n\nfunction calculateAssociationProp(associations) {\n  const result = {};\n\n  Object.keys(associations).forEach((key) => {\n    const association = {};\n    let propertyName;\n", "function calculateAssociationProp(associations) {\n  const result = {};\n\n  Object.keys(associations).forEach((key) => {\n    const association = {};\n    let propertyName;\n\n    if (associations[key].hasOwnProperty(\"options\")) {\n      const { associationType, target, foreignKey, throughModel } =\n        associations[key];\n      propertyName = key.toLocaleLowerCase();\n      association[propertyName] = {\n        type: associationType,\n        key: foreignKey,\n        model: target.name,\n        joinTable: throughModel,\n      };\n    }\n    result[propertyName] = association[propertyName];\n  });\n\n  return result;\n}", "export function getLookup(sequelize): AssociationLookup {\n  //TODO: Fix associations lookup being static\n  /*  if (!associationsLookup) { */\n  const lookup: any = {};\n  const models = sequelize.models;\n  const modelKeys = Object.keys(models);\n  modelKeys.forEach((key) => {\n    const associations = calculateAssociationProp(models[key].associations);\n    lookup[key] = associations;\n  });\n  associationsLookup = lookup;\n  return associationsLookup;\n}\n\nexport const extendSequelize = (SequelizeClass: any) => {\n  const origCreate = SequelizeClass.Model.create;\n  const origUpdate = SequelizeClass.Model.update;\n  const origBulkCreate = SequelizeClass.Model.bulkCreate;\n\n  SequelizeClass.Model.create = async function <\n    M extends Model,\n    O extends CreateOptions<Attributes<M>> = CreateOptions<Attributes<M>>,\n  >(\n    attributes: MakeNullishOptional<M[\"_creationAttributes\"]> | undefined,\n    options?: O,\n  ) {\n    const { sequelize } = this.options;\n\n    const associations = getLookup(sequelize)[this.name];\n\n    const modelPrimaryKey = this.primaryKeyAttribute;\n    let modelData:\n      | undefined\n      | (O extends { returning: false } | { ignoreDuplicates: true }\n          ? void\n          : M);\n\n    const { externalAssociations, currentModelAttributes } =\n      getValidAttributesAndAssociations(attributes, associations);\n\n    // If there are no associations, create the model with all attributes.", "    if (!externalAssociations.length) {\n      return origCreate.apply(this, [attributes, options]);\n    }\n\n    const transaction =\n      options?.transaction ?? (await this.sequelize.transaction());\n\n    try {\n      // create the model first if it does not exist\n      if (!modelData) {\n        modelData = await origCreate.apply(this, [\n          currentModelAttributes,\n          { transaction },\n        ]);\n      }\n\n      await handleCreateAssociations(\n        this.sequelize,\n        this,\n        externalAssociations,\n        associations as Record<string, IAssociation>,\n        attributes,\n        transaction,\n        modelData?.[modelPrimaryKey],\n        modelPrimaryKey,\n      );\n\n      !options?.transaction && (await transaction.commit());", "      if (!modelData) {\n        modelData = await origCreate.apply(this, [\n          currentModelAttributes,\n          { transaction },\n        ]);\n      }\n\n      await handleCreateAssociations(\n        this.sequelize,\n        this,\n        externalAssociations,\n        associations as Record<string, IAssociation>,\n        attributes,\n        transaction,\n        modelData?.[modelPrimaryKey],\n        modelPrimaryKey,\n      );\n\n      !options?.transaction && (await transaction.commit());", "    } catch (error) {\n      !options?.transaction && (await transaction.rollback());\n      throw error;\n    }\n\n    return modelData;\n  };\n\n  SequelizeClass.Model.bulkCreate = async function <\n    M extends Model,\n    O extends CreateOptions<Attributes<M>> = CreateOptions<Attributes<M>>,\n  >(\n    attributes: Array<MakeNullishOptional<M[\"_creationAttributes\"]>>,\n    options?: O,\n  ) {\n    const { sequelize } = this.options;\n\n    const associations = getLookup(sequelize)[this.name];\n\n    const modelPrimaryKey = this.primaryKeyAttribute;\n\n    let modelData:\n      | undefined\n      | Array<\n          O extends { returning: false } | { ignoreDuplicates: true } ? void : M\n        >;\n\n    const {\n      otherAssociationAttributes,\n      externalAssociations,\n      currentModelAttributes,\n    } = getValidAttributesAndAssociations(attributes, associations);\n\n    // If there are no associations, create the model with all attributes.", "    if (!externalAssociations.length) {\n      return origBulkCreate.apply(this, [attributes, options]);\n    }\n\n    const transaction =\n      options?.transaction ?? (await this.sequelize.transaction());\n\n    try {\n      // create the model first if it does not exist\n      if (!modelData) {\n        modelData = await origBulkCreate.apply(this, [\n          currentModelAttributes,\n          { transaction },\n        ]);\n      }\n\n      const modelIds = modelData?.map((data) =>\n        data.getDataValue(modelPrimaryKey),\n      ) as string[];\n\n      await handleBulkCreateAssociations(\n        this.sequelize,\n        this,\n        externalAssociations,\n        associations as Record<string, IAssociation>,\n        otherAssociationAttributes,\n        transaction,\n        modelIds,\n        modelPrimaryKey,\n      );\n\n      !options?.transaction && (await transaction.commit());", "      if (!modelData) {\n        modelData = await origBulkCreate.apply(this, [\n          currentModelAttributes,\n          { transaction },\n        ]);\n      }\n\n      const modelIds = modelData?.map((data) =>\n        data.getDataValue(modelPrimaryKey),\n      ) as string[];\n\n      await handleBulkCreateAssociations(\n        this.sequelize,\n        this,\n        externalAssociations,\n        associations as Record<string, IAssociation>,\n        otherAssociationAttributes,\n        transaction,\n        modelIds,\n        modelPrimaryKey,\n      );\n\n      !options?.transaction && (await transaction.commit());", "    } catch (error) {\n      !options?.transaction && (await transaction.rollback());\n      throw error;\n    }\n\n    return modelData;\n  };\n  SequelizeClass.Model.update = async function <M extends Model<any, any>>(\n    attributes: {\n      [key in keyof Attributes<M>]?:\n        | Fn\n        | Col\n        | Literal\n        | Attributes<M>[key]\n        | undefined;\n    },\n    ops: Omit<UpdateOptions<Attributes<M>>, \"returning\"> & {\n      returning: Exclude<\n        UpdateOptions<Attributes<M>>[\"returning\"],\n        undefined | false\n      >;\n    },\n  ) {\n    const { sequelize } = this.options;\n    const associations = getLookup(sequelize)[this.name];\n    const modelPrimaryKey = this.primaryKeyAttribute;\n\n    const modelId = ops.where?.[modelPrimaryKey];\n    let modelUpdateData: [affectedCount: number, affectedRows: M[]] | undefined;\n\n    const { externalAssociations, currentModelAttributes } =\n      getValidAttributesAndAssociations(attributes, associations);\n\n    // If there are no associations, create the model with all attributes.", "    if (!externalAssociations.length) {\n      return origUpdate.apply(this, [attributes, ops]);\n    } else if (!modelId) {\n      throw [\n        new UnexpectedValueError({\n          detail: \"Only updating by the primary key is supported\",\n        }),\n      ];\n    }\n\n    const transaction = await this.sequelize.transaction();\n", "    try {\n      if (!modelUpdateData) {\n        modelUpdateData = await origUpdate.apply(this, [\n          currentModelAttributes,\n          {\n            ...ops,\n            transaction,\n          },\n        ]);\n      }\n\n      await handleUpdateAssociations(\n        this.sequelize,\n        this,\n        externalAssociations,\n        associations as Record<string, IAssociation>,\n        attributes,\n        transaction,\n        modelId,\n        modelPrimaryKey,\n      );\n\n      !ops?.transaction && (await transaction.commit());", "    } catch (error) {\n      !ops?.transaction && (await transaction.rollback());\n      throw error;\n    }\n\n    return modelUpdateData;\n  };\n};\n"]}
{"filename": "src/sequelize/constants.ts", "chunked_list": ["export enum codes {\n  ERR_NOT_FOUND = \"not-found\",\n  ERR_SERVER_ERROR = \"server-error\",\n  ERR_UNEXPECTED_VALUE = \"unexpected-value\",\n}\n\nexport enum statusCodes {\n  BAD_REQUEST = 400,\n  NOT_FOUND = 404,\n  INTERNAL_SERVER_ERROR = 500,\n}\n"]}
{"filename": "src/sequelize/associations/sequelize.post.ts", "chunked_list": ["import type { Sequelize, Transaction } from \"sequelize\";\nimport { NotFoundError } from \"../types\";\nimport type { IAssociationBody, JSONAnyObject } from \"../types\";\nimport { pluralize } from \"inflection\";\n\nexport const handleCreateHasOne = async (\n  sequelize: Sequelize,\n  association: IAssociationBody<JSONAnyObject>,\n  model: { name: string; id: string },\n  transaction: Transaction,", "  model: { name: string; id: string },\n  transaction: Transaction,\n  primaryKey = \"id\",\n): Promise<void> => {\n  const modelName = association.details.model;\n  const modelInstance = await sequelize.models[model.name].findByPk(\n    model[primaryKey],\n    {\n      transaction,\n    },", "      transaction,\n    },\n  );\n  if (!modelInstance) {\n    throw [new Error(\"Unable to find created model\")];\n  }\n  let joinId: string | undefined;\n  const isCreate = !association.attributes[primaryKey];\n  if (isCreate) {\n    const model = await sequelize.models[modelName].create(\n      association.attributes,\n      {\n        transaction,\n      },\n    );\n    joinId = model[primaryKey];\n  } else {\n    joinId = association.attributes[primaryKey];\n", "  if (isCreate) {\n    const model = await sequelize.models[modelName].create(\n      association.attributes,\n      {\n        transaction,\n      },\n    );\n    joinId = model[primaryKey];\n  } else {\n    joinId = association.attributes[primaryKey];\n", "    if (!(await sequelize.models[modelName].findByPk(joinId))) {\n      throw [\n        new NotFoundError({\n          detail: `Payload must include an ID of an existing '${modelName}'.`,\n          pointer: `/data/relationships/${modelName.toLowerCase()}/data/id`,\n        }),\n      ];\n    }\n  }\n\n  await modelInstance[`set${modelName}`](joinId, {\n    transaction,\n  });\n};\n\nexport const handleBulkCreateHasOne = async (\n  sequelize: Sequelize,\n  association: IAssociationBody<JSONAnyObject[]>,\n  model: { name: string; id: string[] },\n  transaction: Transaction,\n  primaryKey = \"id\",\n): Promise<void> => {\n  const modelInstances = await sequelize.models[model.name].findAll({\n    where: {\n      [primaryKey]: model.id,\n    },\n    transaction,\n  });\n", "  if (modelInstances.length !== model.id.length) {\n    throw [new Error(\"Not all models were successfully created\")];\n  }\n\n  const modelName = association.details.model;\n\n  await Promise.all(\n    association.attributes.map(async (attribute, index) => {\n      const isCreate = !attribute[primaryKey];\n\n      if (isCreate) {\n        const id = (\n          await sequelize.models[modelName].create(attribute, {\n            transaction,\n          })\n        )\n          .getDataValue(primaryKey)\n          .toString();\n\n        return modelInstances[index][`set${modelName}`](id, {\n          transaction,\n        });\n      }\n", "      if (isCreate) {\n        const id = (\n          await sequelize.models[modelName].create(attribute, {\n            transaction,\n          })\n        )\n          .getDataValue(primaryKey)\n          .toString();\n\n        return modelInstances[index][`set${modelName}`](id, {\n          transaction,\n        });\n      }\n", "      if (\n        !(await sequelize.models[modelName].findByPk(attribute[primaryKey]))\n      ) {\n        throw [\n          new NotFoundError({\n            detail: `Payload must include an ID of an existing '${modelName}'.`,\n            pointer: `/data/${index}/relationships/${modelName.toLowerCase()}/data/id`,\n          }),\n        ];\n      }\n\n      return modelInstances[index][`set${modelName}`](attribute[primaryKey], {\n        transaction,\n      });\n    }),\n  );\n};\n\nexport const handleCreateMany = async (\n  sequelize: Sequelize,\n  association: IAssociationBody<JSONAnyObject[]>,\n  model: { name: string; id: string },\n  transaction: Transaction,\n  primaryKey = \"id\",\n): Promise<void> => {\n  const modelInstance = await sequelize.models[model.name].findByPk(\n    model[primaryKey],\n    {\n      transaction,\n    },\n  );\n", "  if (!modelInstance) {\n    throw [new Error(\"Unable to find created model\")];\n  }\n\n  const modelName = association.details.model;\n\n  const results = await Promise.allSettled(\n    association.attributes.map(async (attribute, index) => {\n      const isCreate = !attribute[primaryKey];\n\n      if (isCreate) {\n        const id = (\n          await sequelize.models[association.details.model].create(\n            { ...attribute, through: undefined },\n            { transaction },\n          )\n        )\n          .getDataValue(primaryKey)\n          .toString();\n\n        return modelInstance[`add${modelName}`](id, {\n          through: attribute.through,\n          transaction,\n        });\n      }\n", "      if (isCreate) {\n        const id = (\n          await sequelize.models[association.details.model].create(\n            { ...attribute, through: undefined },\n            { transaction },\n          )\n        )\n          .getDataValue(primaryKey)\n          .toString();\n\n        return modelInstance[`add${modelName}`](id, {\n          through: attribute.through,\n          transaction,\n        });\n      }\n", "      if (\n        !(await sequelize.models[modelName].findByPk(attribute[primaryKey]))\n      ) {\n        throw new NotFoundError({\n          detail: `Payload must include an ID of an existing '${modelName}'.`,\n          pointer: `/data/relationships/${pluralize(\n            modelName.toLowerCase(),\n          )}/data/${index}/id`,\n        });\n      }\n\n      return modelInstance[`add${modelName}`](attribute[primaryKey], {\n        through: attribute.through,\n        transaction,\n      });\n    }),\n  );\n\n  const errors = results.reduce(\n    (acc, result) =>\n      result.status === \"fulfilled\" ? acc : [...acc, result.reason],\n    [],\n  );\n", "  if (errors.length) throw errors;\n};\n\nexport const handleBulkCreateMany = async (\n  sequelize: Sequelize,\n  association: IAssociationBody<JSONAnyObject[][]>,\n  model: { name: string; id: string[] },\n  transaction: Transaction,\n  primaryKey = \"id\",\n): Promise<void> => {\n  // Create an instance of the model using the id\n  const modelInstances = await sequelize.models[model.name].findAll({\n    where: {\n      [primaryKey]: model.id,\n    },\n    transaction,\n  });\n", "  if (modelInstances.length !== model.id.length) {\n    throw [new Error(\"Not all models were successfully created\")];\n  }\n\n  const modelName = association.details.model;\n\n  const results = await Promise.all(\n    association.attributes.map(async (attributes, index) => {\n      return Promise.allSettled(\n        attributes.map(async (attribute, index2) => {\n          const isCreate = !attribute[primaryKey];\n", "          if (isCreate) {\n            // Create the models first and add their ids to the joinIds.\n            const id = (\n              await sequelize.models[modelName].create(\n                { ...attribute, through: undefined },\n                { transaction },\n              )\n            )\n              .getDataValue(primaryKey)\n              .toString();\n\n            return modelInstances[index][`add${modelName}`](id, {\n              through: attribute.through,\n              transaction,\n            });\n          }\n", "          if (\n            !(await sequelize.models[modelName].findByPk(attribute[primaryKey]))\n          ) {\n            throw new NotFoundError({\n              detail: `Payload must include an ID of an existing '${modelName}'.`,\n              pointer: `/data/${index}/relationships/${pluralize(\n                modelName.toLowerCase(),\n              )}/data/${index2}/id`,\n            });\n          }\n\n          return modelInstances[index][`add${modelName}`](\n            attribute[primaryKey],\n            {\n              through: attribute.through,\n              transaction,\n            },\n          );\n        }),\n      );\n    }),\n  );\n\n  const errors = results\n    .flat()\n    .reduce(\n      (acc, result) =>\n        result.status === \"fulfilled\" ? acc : [...acc, result.reason],\n      [],\n    );\n", "  if (errors.length) throw errors;\n};\n"]}
{"filename": "src/sequelize/associations/sequelize.patch.ts", "chunked_list": ["import { pluralize } from \"inflection\";\nimport { Op } from \"sequelize\";\nimport type { Sequelize, Transaction } from \"sequelize\";\n\nimport { NotFoundError } from \"../types\";\nimport type { IAssociationBody } from \"../types\";\n\nexport const handleUpdateOne = async (\n  sequelize: Sequelize,\n  association: IAssociationBody<Array<Record<string, any>>>,", "  sequelize: Sequelize,\n  association: IAssociationBody<Array<Record<string, any>>>,\n  model: { name: string; id: string },\n  transaction: Transaction,\n  primaryKey = \"id\",\n): Promise<void> => {\n  const modelName = association.details.model;\n  const associatedId = association.attributes?.[primaryKey] || null;\n  const [modelInstance, associatedInstance] = await Promise.all([\n    sequelize.models[model.name].findByPk(model[primaryKey], {", "  const [modelInstance, associatedInstance] = await Promise.all([\n    sequelize.models[model.name].findByPk(model[primaryKey], {\n      transaction,\n    }),\n    associatedId\n      ? sequelize.models[modelName].findByPk(associatedId, {\n          transaction,\n        })\n      : null,\n  ]);", "      : null,\n  ]);\n\n  if (!modelInstance) {\n    throw [new Error(\"Unable to find created model\")];\n  }\n\n  if (associatedId && !associatedInstance) {\n    throw [\n      new NotFoundError({\n        detail: `Payload must include an ID of an existing '${modelName}'.`,\n        pointer: `/data/relationships/${modelName.toLowerCase()}/data/id`,\n      }),\n    ];\n  }\n\n  await modelInstance[`set${modelName}`](associatedId, {\n    transaction,\n  });\n};\n\nexport const handleUpdateMany = async (\n  sequelize: Sequelize,\n  association: IAssociationBody<Array<Record<string, any>>>,\n  model: { name: string; id: string },\n  transaction: Transaction,\n  primaryKey = \"id\",\n): Promise<void> => {\n  const modelName = association.details.model;\n  const associatedIds = association.attributes.map((data) => data[primaryKey]);\n  const [modelInstance, associatedInstances] = await Promise.all([\n    sequelize.models[model.name].findByPk(model[primaryKey], {\n      transaction,\n    }),\n    associatedIds.length\n      ? sequelize.models[modelName].findAll({\n          where: { id: { [Op.in]: associatedIds } },\n          transaction,\n        })\n      : [],\n  ]);\n", "  if (!modelInstance) return;\n\n  if (\n    associatedIds.length &&\n    associatedInstances.length < associatedIds.length\n  ) {\n    throw associatedIds.reduce(\n      (acc, associatedId, index) =>\n        associatedInstances.some(\n          ({ dataValues: { id } }) => id === associatedId,\n        )\n          ? acc\n          : [\n              ...acc,\n              new NotFoundError({\n                detail: `Payload must include an ID of an existing '${modelName}'.`,\n                pointer: `/data/relationships/${pluralize(\n                  modelName.toLowerCase(),\n                )}/data/${index}/id`,\n              }),\n            ],\n      [],\n    );\n  }\n\n  await modelInstance[`set${pluralize(association.details.model)}`](\n    association.attributes.map((data) => data[primaryKey]),\n    {\n      transaction,\n    },\n  );\n};\n"]}
{"filename": "src/sequelize/associations/index.ts", "chunked_list": ["import type {\n  Attributes,\n  ModelStatic,\n  Sequelize,\n  Transaction,\n} from \"sequelize\";\nimport type { IAssociation, JSONAnyObject } from \"../types\";\nimport { handleUpdateMany, handleUpdateOne } from \"./sequelize.patch\";\nimport {\n  handleBulkCreateHasOne,", "import {\n  handleBulkCreateHasOne,\n  handleBulkCreateMany,\n  handleCreateHasOne,\n  handleCreateMany,\n} from \"./sequelize.post\";\n\nexport const getValidAttributesAndAssociations = (\n  attributes: Attributes<any> | Array<Attributes<any>>,\n  associations: Record<string, IAssociation> | undefined,", "  attributes: Attributes<any> | Array<Attributes<any>>,\n  associations: Record<string, IAssociation> | undefined,\n) => {\n  const externalAssociations: string[] = [];\n  let currentModelAttributes = attributes;\n  const otherAssociationAttributes: JSONAnyObject = {};\n\n  if (associations) {\n    const associationsKeys = Object.keys(associations);\n    const attributeKeys = Array.isArray(currentModelAttributes)\n      ? Object.keys(attributes[0])\n      : Object.keys(attributes);\n\n    // GET ALL ASSOCIATION ATTRIBUTES AND SEPARATE THEM FROM DATA LEFT\n    associationsKeys.forEach((association) => {", "      if (attributeKeys.includes(association)) {\n        let data: any;\n        if (Array.isArray(currentModelAttributes)) {\n          data = currentModelAttributes.map((attribute: any) => {\n            const { [association]: _, ...attributesleft } = attribute;\n            const otherAttr = otherAssociationAttributes[association] ?? [];\n            otherAssociationAttributes[association] = [...otherAttr, _];\n            return attributesleft;\n          });\n        } else {\n          const { [association]: _, ...attributesLeft } =\n            currentModelAttributes;\n          data = attributesLeft;\n        }\n        currentModelAttributes = data;\n        externalAssociations.push(association);\n      }\n    });\n  }\n\n  return {\n    otherAssociationAttributes,\n    externalAssociations,\n    currentModelAttributes,\n  };\n};\n\nexport const handleCreateAssociations = async (\n  sequelize: Sequelize,\n  model: ModelStatic<any>,\n  validAssociations: string[],\n  associations: Record<string, IAssociation>,\n  attributes: Attributes<any>,\n  transaction: Transaction,\n  modelId: string,\n  primaryKey = \"id\",\n): Promise<void> => {", "  for (const association of validAssociations) {\n    const associationDetails = associations[association];\n    const associationAttribute = attributes[association];\n\n    switch (associationDetails.type) {\n      case \"BelongsTo\":\n      case \"HasOne\":\n        await handleCreateHasOne(\n          sequelize,\n          {\n            details: associationDetails,\n            attributes: associationAttribute,\n          },\n          { name: model.name, id: modelId },\n          transaction,\n          primaryKey,\n        );\n        break;\n      case \"BelongsToMany\":\n      case \"HasMany\":\n        await handleCreateMany(\n          sequelize,\n          {\n            details: associationDetails,\n            attributes: associationAttribute,\n          },\n          { name: model.name, id: modelId },\n          transaction,\n          primaryKey,\n        );\n        break;\n      default:\n        break;\n    }\n  }\n};\n\nexport const handleBulkCreateAssociations = async (\n  sequelize: Sequelize,\n  model: ModelStatic<any>,\n  validAssociations: string[],\n  associations: Record<string, IAssociation>,\n  attributes: JSONAnyObject,\n  transaction: Transaction,\n  modelIds: string[],\n  primaryKey = \"id\",\n): Promise<void> => {", "  for (const association of validAssociations) {\n    const associationDetails = associations[association];\n    const associationAttribute = attributes[association];\n\n    switch (associationDetails.type) {\n      case \"BelongsTo\":\n      case \"HasOne\":\n        await handleBulkCreateHasOne(\n          sequelize,\n          {\n            details: associationDetails,\n            attributes: associationAttribute,\n          },\n          { name: model.name, id: modelIds },\n          transaction,\n          primaryKey,\n        );\n        break;\n      case \"BelongsToMany\":\n      case \"HasMany\":\n        await handleBulkCreateMany(\n          sequelize,\n          {\n            details: associationDetails,\n            attributes: associationAttribute,\n          },\n          { name: model.name, id: modelIds },\n          transaction,\n          primaryKey,\n        );\n        break;\n      default:\n        break;\n    }\n  }\n};\n\nexport const handleUpdateAssociations = async (\n  sequelize: Sequelize,\n  model: ModelStatic<any>,\n  validAssociations: string[],\n  associations: Record<string, IAssociation>,\n  attributes: Attributes<any>,\n  transaction: Transaction,\n  modelId: string,\n  primaryKey = \"id\",\n): Promise<void> => {", "  for (const association of validAssociations) {\n    const associationDetails = associations[association];\n    const associationAttribute = attributes[association];\n\n    switch (associationDetails.type) {\n      case \"BelongsTo\":\n      case \"HasOne\":\n        await handleUpdateOne(\n          sequelize,\n          {\n            details: associationDetails,\n            attributes: associationAttribute,\n          },\n          {\n            name: model.name,\n            id: modelId,\n          },\n          transaction,\n          primaryKey,\n        );\n        break;\n      case \"HasMany\":\n      case \"BelongsToMany\":\n        await handleUpdateMany(\n          sequelize,\n          {\n            details: associationDetails,\n            attributes: associationAttribute,\n          },\n          {\n            name: model.name,\n            id: modelId,\n          },\n          transaction,\n          primaryKey,\n        );\n        break;\n      default:\n        break;\n    }\n  }\n};\n"]}
{"filename": "src/sequelize/types/HatchifyError.ts", "chunked_list": ["import { codes, statusCodes } from \"../constants\";\n\ninterface Source {\n  pointer?: string;\n  parameter?: string;\n}\n\nexport interface HatchifyErrorOptions {\n  pointer?: string;\n  status: number;\n  code: string;\n  detail?: string;\n  source?: Source;\n  title?: string;\n}\n", "export class HatchifyError extends Error {\n  status: number;\n  code: string;\n  title?: string;\n  detail?: string;\n  source?: Source;\n\n  constructor({\n    status = statusCodes.INTERNAL_SERVER_ERROR,\n    code = codes.ERR_SERVER_ERROR,\n    title = \"Server Error ocurred\",\n    detail,\n    pointer,\n  }: HatchifyErrorOptions) {\n    super();\n    this.status = status;\n    this.code = code;\n    this.title = title;\n    this.detail = detail;\n", "    if (pointer) {\n      this.source = { pointer };\n    }\n  }\n}\n"]}
{"filename": "src/sequelize/types/NotFoundError.ts", "chunked_list": ["import { codes, statusCodes } from \"../constants\";\nimport { HatchifyError } from \"./HatchifyError\";\nimport type { HatchifyErrorOptions } from \"./HatchifyError\";\n\nexport class NotFoundError extends HatchifyError {\n  constructor({\n    detail,\n    pointer,\n  }: Pick<HatchifyErrorOptions, \"detail\" | \"pointer\">) {\n    super({\n      code: codes.ERR_NOT_FOUND,\n      status: statusCodes.NOT_FOUND,\n      title: \"Resource not found.\",\n      detail,\n      pointer,\n    });\n  }\n}\n"]}
{"filename": "src/sequelize/types/JSONAnyObject.ts", "chunked_list": ["export type JSONAnyObject = Record<string, any>;\n"]}
{"filename": "src/sequelize/types/IAssociation.ts", "chunked_list": ["export interface IAssociation {\n  type: string;\n  key: string;\n  model: string;\n  joinTable?: string;\n}\n"]}
{"filename": "src/sequelize/types/index.ts", "chunked_list": ["export * from \"./HatchifyError\";\nexport * from \"./IAssociation\";\nexport * from \"./IAssociationBody\";\nexport * from \"./JSONAnyObject\";\nexport * from \"./NotFoundError\";\nexport * from \"./UnexpectedValueError\";\n"]}
{"filename": "src/sequelize/types/IAssociationBody.ts", "chunked_list": ["import type { IAssociation } from \"./IAssociation\";\n\nexport interface IAssociationBody<T> {\n  attributes: T;\n  details: IAssociation;\n}\n"]}
{"filename": "src/sequelize/types/UnexpectedValueError.ts", "chunked_list": ["import { codes, statusCodes } from \"../constants\";\nimport { HatchifyError } from \"./HatchifyError\";\nimport type { HatchifyErrorOptions } from \"./HatchifyError\";\n\nexport class UnexpectedValueError extends HatchifyError {\n  constructor({ detail }: Pick<HatchifyErrorOptions, \"detail\">) {\n    super({\n      code: codes.ERR_UNEXPECTED_VALUE,\n      status: statusCodes.BAD_REQUEST,\n      title: \"Unexpected Value.\",\n      detail,\n    });\n  }\n}\n"]}
