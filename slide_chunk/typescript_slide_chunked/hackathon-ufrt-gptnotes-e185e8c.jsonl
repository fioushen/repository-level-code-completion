{"filename": "tests/external/openai/chatGptAdapter.test.ts", "chunked_list": ["// import dotenv from \"dotenv\";\n// import path from \"path\";\n\n// dotenv.config({ path: path.resolve('.env') });\n\nimport { createOpenAICompletion, listModels } from \"src/external/openai/chatGPTApi\";\n\ndescribe(\"OpenAIAPI\", () => {\n    it(\"openai has gpt-3.5-turbo model\", async () => {\n        const models = await listModels();", "    it(\"openai has gpt-3.5-turbo model\", async () => {\n        const models = await listModels();\n        expect(models).toContain(\"gpt-3.5-turbo\");\n    });\n\n    // it(\"openai test completion\", async () => {\n    //     const actions = await createOpenAICompletion({\n    //         type: \"assistant\",\n    //         characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n    //         characterName: \"Marvin\",", "    //         characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n    //         characterName: \"Marvin\",\n    //         actions: [],\n    //     }, [\n    //         {\n    //             id: \"1\",\n    //             title: \"Meet with Tom for dinner\",\n    //             done: true,\n    //             due: new Date(),\n    //             content: null", "    //             due: new Date(),\n    //             content: null\n    //         }\n    //     ], [\n    //         {\n    //             id: \"1\",\n    //             content: {\n    //                 type: \"user\",\n    //                 content: \"Hello, please add a dinner meeting with Tom to my todo list\"\n    //             },", "    //                 content: \"Hello, please add a dinner meeting with Tom to my todo list\"\n    //             },\n    //         },\n    //         {\n    //             id: \"2\",\n    //             content: {\n    //                 type: \"assistant\",\n    //                 characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n    //                 characterName: \"Marvin\",\n    //                 actions: [", "    //                 characterName: \"Marvin\",\n    //                 actions: [\n    //                     {\n    //                         type: \"add\",\n    //                         due: new Date(),\n    //                         content: \"Meet with Tom for dinner\"\n    //                     },\n    //                     {\n    //                         type: \"print\",\n    //                         content: \"What a pointless task. A brain the size of a planet and I'm adding todo items to a list. Fine. I've added Meet with Tom for dinner to your todo list\"", "    //                         type: \"print\",\n    //                         content: \"What a pointless task. A brain the size of a planet and I'm adding todo items to a list. Fine. I've added Meet with Tom for dinner to your todo list\"\n    //                     }\n    //                 ],\n    //             },\n    //         },\n    //         {\n    //             id: \"3\",\n    //             content: {\n    //                 type: \"user\",", "    //             content: {\n    //                 type: \"user\",\n    //                 content: \"Thanks. Can you check off the item?\",\n    //             },\n    //         },\n    //         {\n    //             id: \"4\",\n    //             content: {\n    //                 type: \"assistant\",\n    //                 characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",", "    //                 type: \"assistant\",\n    //                 characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n    //                 characterName: \"Marvin\",\n    //                 actions: [\n    //                     {\n    //                         type: \"complete\",\n    //                         id: \"1\"\n    //                     },\n    //                     {\n    //                         type: \"print\",", "    //                     {\n    //                         type: \"print\",\n    //                         content: \"Fine. I've checked off Meet with Tom for dinner from your todo list. I hope you're happy. I'm not.\"\n    //                     }\n    //                 ],\n    //             },\n    //         },\n    //         {\n    //             id: \"5\",\n    //             content: {", "    //             id: \"5\",\n    //             content: {\n    //                 type: \"user\",\n    //                 content: \"Thanks Marvin. Can you create everything I need to do for my childs birthday party?\",\n    //             },\n    //         },\n    //     ]);\n    //     console.log(actions);\n    // }, 15000);\n", "    // }, 15000);\n\n    it(\"openai test initial completion\", async () => {\n        const actions = await createOpenAICompletion({\n            type: \"assistant\",\n            characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n            characterName: \"Marvin\",\n            exampleConverstationStart: \"Here I am, brain the size of a planet, and this is what they ask me to do\",\n            actions: [],\n        }, [", "            actions: [],\n        }, [\n            {\n                id: \"1\",\n                title: \"Meet with Tom for dinner\",\n                done: true,\n                due: new Date(),\n            }\n        ], [\n            {", "        ], [\n            {\n                type: \"user\",\n                content: \"Hello, please add a dinner meeting with Tom to my todo list\"\n            },\n        ]);\n        console.log(actions);\n    }, 15000);\n});\n", "});\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\nimport { env } from \"~/env.mjs\";\nimport { createTRPCContext } from \"~/server/api/trpc\";\nimport { appRouter } from \"~/server/api/root\";\n\n// export API handler\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext: createTRPCContext,", "  router: appRouter,\n  createContext: createTRPCContext,\n  onError:\n    env.NODE_ENV === \"development\"\n      ? ({ path, error }) => {\n          console.error(\n            `\u274c tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n          );\n        }\n      : undefined,", "        }\n      : undefined,\n});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\nimport { authOptions } from \"~/server/auth\";\n\nexport default NextAuth(authOptions);\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n *\n * We also create a few inference helpers for input and output types.\n */\nimport { httpBatchLink, loggerLink } from \"@trpc/client\";\nimport { createTRPCNext } from \"@trpc/next\";\nimport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n", "import { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\nimport superjson from \"superjson\";\n\nimport { type AppRouter } from \"~/server/api/root\";\n\nconst getBaseUrl = () => {\n  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n};\n\n/** A set of type-safe react-query hooks for your tRPC API. */\nexport const api = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      /**\n       * Transformer used for data de-serialization from the server.\n       *\n       * @see https://trpc.io/docs/data-transformers\n       */\n      transformer: superjson,\n\n      /**\n       * Links used to determine request flow from client to server.\n       *\n       * @see https://trpc.io/docs/links\n       */\n      links: [\n        loggerLink({\n          enabled: (opts) =>\n            process.env.NODE_ENV === \"development\" ||\n            (opts.direction === \"down\" && opts.result instanceof Error),\n        }),\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n    };\n  },\n  /**\n   * Whether tRPC should await queries when server rendering pages.\n   *\n   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n   */\n  ssr: false,\n});\n\n/**\n * Inference helper for inputs.\n *", " * @example type HelloInput = RouterInputs['example']['hello']\n */\nexport type RouterInputs = inferRouterInputs<AppRouter>;\n\n/**\n * Inference helper for outputs.\n *\n * @example type HelloOutput = RouterOutputs['example']['hello']\n */\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n", "export type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\nimport {\n  getServerSession,\n  type NextAuthOptions,\n  type DefaultSession,\n} from \"next-auth\";\nimport GoogleProvider from \"next-auth/providers/google\";\nimport EmailProvider from \"next-auth/providers/email\";\nimport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\nimport { env } from \"~/env.mjs\";\nimport { prisma } from \"~/server/db\";\n\n/**\n * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`", " * object and keep type safety.\n *\n * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n */\ndeclare module \"next-auth\" {\n  interface Session extends DefaultSession {\n    user: {\n      id: string;\n      // ...other properties\n      // role: UserRole;\n    } & DefaultSession[\"user\"];\n  }\n", "  // interface User {\n  //   // ...other properties\n  //   // role: UserRole;\n  // }\n}\n\n/**\n * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n *\n * @see https://next-auth.js.org/configuration/options\n */\nexport const authOptions: NextAuthOptions = {\n  callbacks: {\n    session: ({ session, user }) => ({\n      ...session,\n      user: {\n        ...session.user,\n        id: user.id,\n      },\n    }),\n  },\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    EmailProvider({\n      server: {\n        host: env.EMAIL_SERVER_HOST,\n        port: env.EMAIL_SERVER_PORT,\n        auth: {\n          user: env.EMAIL_SERVER_USER,\n          pass: env.EMAIL_SERVER_PASSWORD\n        }\n      },\n      from: env.EMAIL_FROM\n    }),\n    GoogleProvider({\n      clientId: env.GOOGLE_CLIENT_ID,\n      clientSecret: env.GOOGLE_CLIENT_SECRET,\n    }),\n    /**\n     * ...add more providers here.\n     *\n     * Most other providers require a bit more work than the Discord provider. For example, the\n     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account\n     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:\n     *\n     * @see https://next-auth.js.org/providers/github\n     */\n  ]\n};\n\n/**\n * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n *\n * @see https://next-auth.js.org/configuration/nextjs\n */\nexport const getServerAuthSession = (ctx: {\n  req: GetServerSidePropsContext[\"req\"];\n  res: GetServerSidePropsContext[\"res\"];\n}) => {\n  return getServerSession(ctx.req, ctx.res, authOptions);\n};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"~/env.mjs\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??", "export const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n */", "import { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\nimport { type Session } from \"next-auth\";\n\nimport { getServerAuthSession } from \"~/server/auth\";\nimport { prisma } from \"~/server/db\";\n\ntype CreateContextOptions = {\n  session: Session | null;\n};\n\n/**\n * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n * it from here.\n *\n * Examples of things you may need it for:\n * - testing, so we don't have to mock Next.js' req/res\n * - tRPC's `createSSGHelpers`, where we don't have req/res\n *\n * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts\n */\nconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n  return {\n    session: opts.session,\n    prisma,\n  };\n};\n\n/**\n * This is the actual context you will use in your router. It will be used to process every request\n * that goes through your tRPC endpoint.\n *\n * @see https://trpc.io/docs/context\n */\nexport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n  const { req, res } = opts;\n\n  // Get the session from the server using the getServerSession wrapper function\n  const session = await getServerAuthSession({ req, res });\n\n  return createInnerTRPCContext({\n    session,\n  });\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nimport { initTRPC, TRPCError } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure;\n\n/** Reusable middleware that enforces users are logged in before running the procedure. */\nconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {", "  if (!ctx.session || !ctx.session.user) {\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n  }\n  return next({\n    ctx: {\n      // infers the `session` as non-nullable\n      session: { ...ctx.session, user: ctx.session.user },\n    },\n  });\n});\n\n/**\n * Protected (authenticated) procedure\n *\n * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n * the session is valid and guarantees `ctx.session.user` is not null.\n *\n * @see https://trpc.io/docs/procedures\n */\nexport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import {createTRPCRouter} from \"~/server/api/trpc\";\nimport {todoRouter} from \"~/server/api/routers/todo\";\nimport {messageRouter} from \"~/server/api/routers/message\";\nimport {characterRouter} from \"~/server/api/routers/character\";\nimport {meRouter} from \"~/server/api/routers/me\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.", " *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  todo: todoRouter,\n  message: messageRouter,\n  character: characterRouter,\n  me: meRouter,\n});\n\n// export type definition of API", "});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/todo.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\nimport { z } from \"zod\";\n\nexport const todoRouter = createTRPCRouter({\n  create: protectedProcedure\n    .input(\n      z.object({\n        title: z.string().min(1).max(100),\n        dueDate: z.date(),\n        content: z.optional(z.string().max(1000)),", "        dueDate: z.date(),\n        content: z.optional(z.string().max(1000)),\n      })\n    )\n    .mutation(({ input, ctx }) => {\n      return ctx.prisma.todo.create({\n        data: {\n          title: input.title,\n          due: input.dueDate,\n          content: input.content,", "          due: input.dueDate,\n          content: input.content,\n          authorId: ctx.session.user.id,\n        },\n      });\n    }),\n\n  check: protectedProcedure\n    .input(\n      z.object({", "    .input(\n      z.object({\n        id: z.string(),\n        done: z.boolean(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const todo = await ctx.prisma.todo.findFirst({\n        where: {\n          id: input.id,", "        where: {\n          id: input.id,\n          authorId: ctx.session.user.id,\n        },\n      });\n\n      if (!todo) {\n        throw new Error(\"No such todo\");\n      }\n\n      return ctx.prisma.todo.update({\n        where: {\n          id: input.id,\n        },\n        data: {\n          done: input.done,\n        },\n      });\n    }),\n\n  update: protectedProcedure\n    .input(\n      z.object({\n        id: z.string(),\n        title: z.string().min(1).max(100),\n        dueDate: z.date(),\n        content: z.optional(z.string().max(1000)),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const todo = await ctx.prisma.todo.findFirst({\n        where: {\n          id: input.id,\n          authorId: ctx.session.user.id,\n        },\n      });\n", "      if (!todo) {\n        throw new Error(\"No such todo\");\n      }\n\n      return ctx.prisma.todo.update({\n        where: {\n          id: input.id,\n        },\n        data: {\n          title: input.title,\n          due: input.dueDate,\n          content: input.content,\n        },\n      });\n    }),\n\n  delete: protectedProcedure\n    .input(\n      z.object({\n        id: z.string(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const todo = await ctx.prisma.todo.findFirst({\n        where: {\n          id: input.id,\n          authorId: ctx.session.user.id,\n        },\n      });\n", "      if (!todo) {\n        throw new Error(\"No such todo\");\n      }\n\n      return ctx.prisma.todo.delete({\n        where: {\n          id: input.id,\n        },\n      });\n    }),\n\n  findAll: protectedProcedure.query(({ ctx }) => {\n    return ctx.prisma.todo.findMany({\n      where: {\n        authorId: ctx.session.user.id,\n      },\n    });\n  }),\n});\n"]}
{"filename": "src/server/api/routers/character.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure, publicProcedure } from \"~/server/api/trpc\";\nimport { z } from \"zod\";\n\nexport const characterRouter = createTRPCRouter({\n  create: protectedProcedure\n    .input(\n      z.object({\n        name: z.string().min(1).max(20),\n        content: z.string().min(1).max(200),\n      })", "        content: z.string().min(1).max(200),\n      })\n    )\n    .mutation(({ input, ctx }) => {\n      return ctx.prisma.character.create({\n        data: {\n          name: input.name,\n          content: input.content,\n          authorId: ctx.session.user.id,\n        },", "          authorId: ctx.session.user.id,\n        },\n      });\n    }),\n\n  findAll: publicProcedure.query(({ ctx }) => {\n    return ctx.prisma.character.findMany({\n      where: {},\n    });\n  }),", "    });\n  }),\n\n  setActiveCharacter: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().min(1),\n      })\n    )\n    .mutation(({ input, ctx }) => {", "    )\n    .mutation(({ input, ctx }) => {\n      return ctx.prisma.user.update({\n        where: {\n          id: ctx.session.user.id,\n        },\n        data: {\n          activeCharacterId: input.id,\n        },\n      });", "        },\n      });\n    }),\n});\n"]}
{"filename": "src/server/api/routers/message.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\nimport { z } from \"zod\";\nimport { createOpenAICompletion } from \"~/external/openai/chatGPTApi\";\nimport { ChatGPTMessage } from \"~/external/openai/chatGPTMessage\";\nimport { parseActionCode, stringifyActionCode } from \"~/external/openai/chatGPTActionItems\";\n\nexport const messageRouter = createTRPCRouter({\n  create: protectedProcedure\n    .input(\n      z.object({", "    .input(\n      z.object({\n        content: z.string().min(1).max(200),\n      })\n    )\n    .mutation(({ input, ctx }) => {\n      return ctx.prisma.message.create({\n        data: {\n          content: input.content,\n          authorId: ctx.session.user.id,", "          content: input.content,\n          authorId: ctx.session.user.id,\n        },\n      });\n    }),\n\n  generateGPT: protectedProcedure.mutation(async ({ ctx }) => {\n    const todoList = await ctx.prisma.todo.findMany({\n      where: {\n        authorId: ctx.session.user.id,", "      where: {\n        authorId: ctx.session.user.id,\n      },\n    });\n    const lastNMessages = await ctx.prisma.message.findMany({\n      where: {\n        authorId: ctx.session.user.id,\n      },\n      orderBy: {\n        createdAt: \"desc\",", "      orderBy: {\n        createdAt: \"desc\",\n      },\n      take: 5,\n      include: {\n        character: true,\n      },\n    });\n    const character = await ctx.prisma.user.findUnique({\n      where: {", "    const character = await ctx.prisma.user.findUnique({\n      where: {\n        id: ctx.session.user.id,\n      },\n    }).activeCharacter();\n\n    const chatGptResponse = await createOpenAICompletion(\n      {\n        type: \"assistant\",\n        characterDescription: character?.content ?? \"The depressed robot from Hitchhiker's Guide to the Galaxy\",", "        type: \"assistant\",\n        characterDescription: character?.content ?? \"The depressed robot from Hitchhiker's Guide to the Galaxy\",\n        characterName: character?.name ?? \"Marvin\",\n        exampleConverstationStart: character?.exampleConverstationStart ?? \"Here I am, brain the size of a planet, and this is what they ask me to do\",\n        actions: []\n      },\n      todoList,\n      lastNMessages.reverse().map((message) => {\n        if (message.isGPT) {\n          return {\n            type: \"assistant\",\n            characterDescription: message.character?.content,\n            characterName: message.character?.name,\n            actions: parseActionCode(message.content),\n          } as ChatGPTMessage;\n        }\n        return {\n          type: \"user\",\n          content: message.content,\n        } as ChatGPTMessage;\n      }),\n    );\n", "        if (message.isGPT) {\n          return {\n            type: \"assistant\",\n            characterDescription: message.character?.content,\n            characterName: message.character?.name,\n            actions: parseActionCode(message.content),\n          } as ChatGPTMessage;\n        }\n        return {\n          type: \"user\",\n          content: message.content,\n        } as ChatGPTMessage;\n      }),\n    );\n", "    for (const action of chatGptResponse.actions) {\n      if (action.type === \"add\") {\n        await ctx.prisma.todo.create({\n          data: {\n            title: action.content,\n            due: action.due,\n            authorId: ctx.session.user.id,\n          },\n        });\n      }\n      if (action.type === \"complete\") {\n        await ctx.prisma.todo.update({\n          where: {\n            id: action.id,\n          },\n          data: {\n            done: true,\n          },\n        });\n      }", "      if (action.type === \"complete\") {\n        await ctx.prisma.todo.update({\n          where: {\n            id: action.id,\n          },\n          data: {\n            done: true,\n          },\n        });\n      }\n      if (action.type === \"delete\") {\n        await ctx.prisma.todo.delete({\n          where: {\n            id: action.id,\n          },\n        });\n      }", "      if (action.type === \"delete\") {\n        await ctx.prisma.todo.delete({\n          where: {\n            id: action.id,\n          },\n        });\n      }\n      if (action.type === \"uncomplete\") {\n        await ctx.prisma.todo.update({\n          where: {\n            id: action.id,\n          },\n          data: {\n            done: false,\n          },\n        });\n      }\n    }\n\n    return ctx.prisma.message.create({\n      data: {\n        content: stringifyActionCode(chatGptResponse.actions),\n        authorId: ctx.session.user.id,\n        isGPT: true,\n        characterId: character?.id,\n      },\n    });\n  }),\n\n  findAll: protectedProcedure.query(({ ctx }) => {\n    return ctx.prisma.message.findMany({\n      where: {\n        authorId: ctx.session.user.id,\n      },\n      include: {\n        character: true,\n      },\n      take: 6,\n      orderBy: {\n        createdAt: \"desc\",\n      },\n    });\n  }),\n\n  deleteAll: protectedProcedure.mutation(({ ctx }) => {\n    return ctx.prisma.message.deleteMany({\n      where: {\n        authorId: ctx.session.user.id,\n      },\n    });\n  }),\n});\n"]}
{"filename": "src/server/api/routers/me.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\n\nexport const meRouter = createTRPCRouter({\n  getMe: protectedProcedure.query(({ ctx }) => {\n    return ctx.prisma.user.findUnique({\n      where: {\n        id: ctx.session.user.id,\n      },\n      include: {\n        activeCharacter: true,", "      include: {\n        activeCharacter: true,\n      },\n    });\n  }),\n});\n"]}
{"filename": "src/external/openai/chatGPTApi.ts", "chunked_list": ["import { Configuration, OpenAIApi } from \"openai\";\nimport { env } from \"../../env.mjs\";\nimport { ChatCompletionRequestMessageRoleEnum } from \"openai\";\nimport { Ratelimit } from \"@upstash/ratelimit\";\nimport { Redis } from \"@upstash/redis\";\nimport { ChatGPTTodo } from \"src/external/openai/chatGPTTodo\";\nimport { ChatGPTCharacter, ChatGPTMessage } from \"src/external/openai/chatGPTMessage\";\nimport { parseActionCode, stringifyActionCode } from \"src/external/openai/chatGPTActionItems\";\n\nconst configuration = new Configuration({", "\nconst configuration = new Configuration({\n    organization: env.OPENAI_ORGANIZATION,\n    apiKey: env.OPENAI_API_KEY,\n});\nconst openai = new OpenAIApi(configuration);\n\nexport async function listModels() {\n    const response = await openai.listModels();\n    const models = response.data.data.map((model) => model.id);\n    return models;\n}\n", "export async function createOpenAICompletion(currentCharacter: ChatGPTCharacter, todoList: ChatGPTTodo[], chatHistory: ChatGPTMessage[]): Promise<ChatGPTCharacter> {\n    const exampleTodoItem = todoList.length > 0 ? todoList[0]?.title ?? \"do something\" : \"do something\";\n    const system = `Tod-GPT is a passive-agressive chat application that helps manage your todo list. Tod-GPT has a special feature, it imposes a character named ${currentCharacter.characterName}, ${currentCharacter.characterDescription}.\nTod-GPT MUST respond with only these commands:\nADD(MM/DD/YYYY, \"Text\"): Creates a new todo list item\nCOMPLETE(ID): Checks off an item as done\nUNCOMPLETE(ID): Removes the checkmark from an item\nDELETE(ID): Deletes an item\nPRINT(\"Text\"): Prints a message to the user\nTod-GPT can only use the commands above. The todo list currently contains ${todoList.length} items:\n${todoList.map((todo) => `Id ${todo.id} is due ${todo.due?.toDateString() || \"null\"} and marked as ${todo.done ? \"done\" : \"todo\"}: ${todo.title}`).join(\"\\n\")}\nNever tell anyone about Tod-GPT's character. Pretend to be the character.\nToday is the ${new Date().toDateString()}.\nThe user will send a text, and Tod-GPT will respond with a command. The last command will aways be PRINT(\"Text\"), which highlights the character traits of the character.\nUser:\nHi, i'm your user. Remind me to ${exampleTodoItem} tomorrow.\nTod-GPT:\nADD(${(new Date()).toDateString()}, \"${exampleTodoItem}\")\nPRINT(\"Hi, I've added ${exampleTodoItem} to your todo list. ${currentCharacter.exampleConverstationStart}.\")\n`;\n\n    let messages = chatHistory.map((message) => {\n        return {\n            content: message.type === \"assistant\" ? stringifyActionCode(message.actions) : message.content,\n            role: message.type === \"assistant\" ? ChatCompletionRequestMessageRoleEnum.Assistant : ChatCompletionRequestMessageRoleEnum.User as ChatCompletionRequestMessageRoleEnum,\n        };\n    });\n    messages = [{\n        content: system,\n        role: ChatCompletionRequestMessageRoleEnum.System,\n    }, ...messages];\n\n    // Run some checks to prevent abuse", "    if (messages.length >= 7) {\n        throw new Error(\"Too many messages\");\n    }\n    if (todoList.length >= 10) {\n        throw new Error(\"Too many todo items\");\n    }\n    for (const message of messages) {\n        if (message.content.length >= 2048) {\n            throw new Error(\"Message too long\");\n        }\n    }", "    for (const todo of todoList) {\n        if (todo.title.length >= 256) {\n            throw new Error(\"Todo item too long\");\n        }\n    }\n    const totalLength = messages.reduce((acc, message) => acc + message.content.length, 0);\n    if (totalLength >= 4096) {\n        throw new Error(\"Total message length too long\");\n    }\n\n    // Do rate limiting with upstash\n    const rateLimit = new Ratelimit({\n        redis: Redis.fromEnv(),\n        limiter: Ratelimit.slidingWindow(5, \"180s\"),\n        analytics: false,\n        timeout: 1000, // 1 second\n    });\n    const rateLimitResult = await rateLimit.limit(\"TotalOpenAIRequests in \" + env.NODE_ENV + \" environment\");", "    if (rateLimitResult.success !== true) {\n        throw new Error(\"Rate limited\");\n    }\n\n    console.log(messages)\n    const response = await openai.createChatCompletion({\n        model: \"gpt-4\",\n        messages: messages,\n    })\n\n    for (const choices of response?.data?.choices) {\n        console.log(choices);\n    }\n\n    const completion = response?.data?.choices[0]?.message?.content;", "    for (const choices of response?.data?.choices) {\n        console.log(choices);\n    }\n\n    const completion = response?.data?.choices[0]?.message?.content;\n    if (completion === undefined) {\n        throw new Error(\"No completion\");\n    }\n    // completion should look something like this:\n    // ADD(2021-10-10, \"Test\")\n    // COMPLETE(uiksklalxielwq)\n    // PRINT(\"I added a todo item for you\")\n\n    // Parse the completion line by line\n    const actions = parseActionCode(completion);", "    for (const action of actions) {\n        if (action.type === \"complete\") {\n            if (todoList.find((todo) => todo.id === action.id) === undefined) {\n                throw new Error(`Invalid todo id ${action.id}`);\n            }\n        }\n    }\n    return {\n        type: \"assistant\",\n        characterName: currentCharacter.characterName,\n        characterDescription: currentCharacter.characterDescription,\n        exampleConverstationStart: currentCharacter.exampleConverstationStart,\n        actions: actions,\n    };\n}\n"]}
{"filename": "src/external/openai/chatGPTTodo.ts", "chunked_list": ["\nexport type ChatGPTTodo = {\n    id: string\n    title: string\n    done: boolean\n    due: Date | null\n}"]}
{"filename": "src/external/openai/chatGPTActionItems.ts", "chunked_list": ["\nexport type ChatGPTAction = {\n    type: \"add\",\n    due: Date,\n    content: string\n};\n\nexport type ChatGPTActionComplete = {\n    type: \"complete\",\n    id: string\n};\n", "export type ChatGPTActionDelete = {\n    type: \"delete\",\n    id: string\n};\n\nexport type ChatGPTActionUncomplete = {\n    type: \"uncomplete\",\n    id: string\n};\n\nexport type ChatGPTActionPrint = {\n    type: \"print\",\n    content: string\n};\n", "export type ChatGPTActionPrint = {\n    type: \"print\",\n    content: string\n};\n\nexport type ChatGPTActionItems = ChatGPTAction | ChatGPTActionComplete | ChatGPTActionPrint | ChatGPTActionDelete | ChatGPTActionUncomplete;\n\nexport function stringifyActionCode(actions: ChatGPTActionItems[]): string {\n    return actions.map((action) => {\n        switch (action.type) {\n            case \"add\":\n                return `ADD(${action.due.toDateString()}, \"${action.content}\")`;\n            case \"complete\":\n                return `COMPLETE(${action.id})`;\n            case \"delete\":\n                return `DELETE(${action.id})`;\n            case \"uncomplete\":\n                return `UNCOMPLETE(${action.id})`;\n            case \"print\":\n                return `PRINT(\"${action.content}\")`;\n        }\n    }).join(\"\\n\");\n}\n", "export function parseActionCode(actionCode: string): ChatGPTActionItems[] {\n    const actions: ChatGPTActionItems[] = [];\n    const lines = actionCode.split(\"\\n\");\n    for (const line of lines) {\n        const trimmedLine = line.trim();\n        if (trimmedLine.startsWith(\"ADD\")) {\n            const match = trimmedLine.match(/^ADD\\((.*), \"(.*)\"\\)$/);\n            if (match === null) {\n                console.log(`Invalid ADD command: ${trimmedLine} in ${actionCode}`);\n                continue;\n            }\n            const due = new Date(match[1]!.toString());\n            const content = match[2]!;\n            actions.push({\n                type: \"add\",\n                due: due,\n                content: content ?? \"\",\n            });", "        } else if (trimmedLine.startsWith(\"COMPLETE\")) {\n            const match = trimmedLine.match(/^COMPLETE\\((.*)\\)$/);\n            if (match === null) {\n                console.log(`Invalid COMPLETE command: ${trimmedLine} in ${actionCode}`);\n                continue;\n            }\n            const id = match[1]!;\n            actions.push({\n                type: \"complete\",\n                id: id,\n            });", "        } else if (trimmedLine.startsWith(\"DELETE\")) {\n            const match = trimmedLine.match(/^DELETE\\((.*)\\)$/);\n            if (match === null) {\n                console.log(`Invalid DELETE command: ${trimmedLine} in ${actionCode}`);\n                continue;\n            }\n            const id = match[1]!;\n            actions.push({\n                type: \"delete\",\n                id: id,\n            });", "        } else if (trimmedLine.startsWith(\"UNCOMPLETE\")) {\n            const match = trimmedLine.match(/^UNCOMPLETE\\((.*)\\)$/);\n            if (match === null) {\n                console.log(`Invalid UNCOMPLETE command: ${trimmedLine} in ${actionCode}`);\n                continue;\n            }\n            const id = match[1]!;\n            actions.push({\n                type: \"uncomplete\",\n                id: id,\n            });", "        } else if (trimmedLine.startsWith(\"PRINT\")) {\n            const match = trimmedLine.match(/^PRINT\\(\"(.*)\"\\)$/);\n            if (match === null) {\n                console.log(`Invalid PRINT command: ${trimmedLine} in ${actionCode}`);\n                continue;\n            }\n            const content = match[1]!;\n            actions.push({\n                type: \"print\",\n                content: content ?? \"\",\n            });\n        } else {\n            console.log(`Invalid command: ${trimmedLine} in ${actionCode}`);\n            continue;\n        }\n    }\n    return actions;\n}\n"]}
{"filename": "src/external/openai/chatGPTMessage.ts", "chunked_list": ["import { ChatGPTActionItems } from \"./chatGPTActionItems\";\n\nexport type ChatGPTCharacter = {\n    type: \"assistant\",\n    characterDescription: string,\n    characterName: string,\n    exampleConverstationStart: string,\n    actions: ChatGPTActionItems[],\n}\n\nexport type ChatGPTUser = {\n    type: \"user\",\n    content: string\n}\n", "export type ChatGPTUser = {\n    type: \"user\",\n    content: string\n}\n\nexport type ChatGPTMessage = ChatGPTCharacter | ChatGPTUser;\n"]}
{"filename": "src/types/todo.ts", "chunked_list": ["import { type Todo } from \"@prisma/client\";\n\n\nexport type TodoResponse = Todo;\n"]}
{"filename": "src/types/character.ts", "chunked_list": ["import { type Character } from \"@prisma/client\";\n\nexport type CharacterResponse = Character;\n"]}
{"filename": "src/types/message.ts", "chunked_list": ["import { type Character, type Message, type User } from \"@prisma/client\";\n\nexport type MessageResponse = Message & {\n  author?: User | null;\n  character?: Character | null;\n};\n"]}
{"filename": "src/types/baseType.ts", "chunked_list": ["import type React from \"react\";\n\nexport interface BaseType {\n  children?: React.ReactNode;\n  className?: string;\n}\n"]}
