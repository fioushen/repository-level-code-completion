{"filename": "test/setupTests.ts", "chunked_list": ["import \"@testing-library/jest-dom\";\n"]}
{"filename": "test/utils.ts", "chunked_list": ["export function setupBasicPage() {\n  document.body.innerHTML = `\n  <nav>Nav Text</nav>\n  <section>\n    <h1>Section Heading 1</h1>\n    <p>Section Text</p>\n    <article>\n      <header>\n        <h1>Article Header Heading 1</h1>\n        <p>Article Header Text</p>\n      </header>\n      <p>Article Text</p>\n    </article> \n  </section>\n  <footer>Footer</footer>\n  `;\n}\n"]}
{"filename": "test/int/ariaActiveDescendantCombobox.int.test.ts", "chunked_list": ["import { setupComboboxWithListAutocomplete } from \"./comboboxWithListAutocomplete\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"Aria Active Descendant\", () => {\n  let teardown;\n\n  beforeEach(() => {\n    teardown = setupComboboxWithListAutocomplete();\n  });\n", "  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n    teardown();\n  });\n\n  it(\"should handle an editable combobox with list autocomplete\", async () => {\n    await virtual.start({ container: document.body });", "  it(\"should handle an editable combobox with list autocomplete\", async () => {\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.type(\"nebr\");\n    await virtual.press(\"ArrowDown\");\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"State\",", "      \"document\",\n      \"State\",\n      \"combobox, State, autocomplete in list, not expanded, has popup listbox, 1 control\",\n      \"combobox, State, nebr, autocomplete in list, expanded, has popup listbox, 1 control\",\n      \"combobox, State, nebr, active descendant Nebraska, autocomplete in list, expanded, has popup listbox, 1 control\",\n    ]);\n\n    await virtual.stop();\n  });\n});", "  });\n});\n"]}
{"filename": "test/int/moveToRole.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\nconst quickNavigationRoles = [\n  \"banner\",\n  \"complementary\",\n  \"contentinfo\",\n  \"figure\",\n  \"form\",\n  \"main\",\n  \"navigation\",", "  \"main\",\n  \"navigation\",\n  \"region\",\n  \"search\",\n];\n\nconst quickNavigationRolesWithLandmark = [...quickNavigationRoles, \"landmark\"];\n\ndescribe(\"Move To Role\", () => {\n  afterEach(async () => {", "describe(\"Move To Role\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  describe(\"moveToNextRole\", () => {\n    describe(\"when there are matching roles in the container\", () => {\n      beforeEach(async () => {\n        document.body.innerHTML = quickNavigationRoles", "      beforeEach(async () => {\n        document.body.innerHTML = quickNavigationRoles\n          .map(\n            (role) =>\n              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n          )\n          .join(\"\");\n\n        await virtual.start({ container: document.body });\n      });", "        await virtual.start({ container: document.body });\n      });\n\n      it.each(quickNavigationRoles)(\n        \"should let you navigate to the next %s\",\n        async (role) => {\n          await virtual.perform(\n            virtual.commands[\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              `moveToNext${role.at(0)!.toUpperCase()}${role.slice(1)}`", "              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              `moveToNext${role.at(0)!.toUpperCase()}${role.slice(1)}`\n            ]\n          );\n          await virtual.next();\n          await virtual.next();\n\n          expect(await virtual.spokenPhraseLog()).toEqual([\n            \"document\",\n            `${role}, Accessible name`,", "            \"document\",\n            `${role}, Accessible name`,\n            `Node with role: ${role}`,\n            `end of ${role}, Accessible name`,\n          ]);\n        }\n      );\n    });\n\n    describe(\"when there are no matching roles in the container\", () => {", "\n    describe(\"when there are no matching roles in the container\", () => {\n      beforeEach(async () => {\n        document.body.innerHTML = \"\";\n\n        await virtual.start({ container: document.body });\n      });\n\n      it.each(quickNavigationRoles)(\n        \"should gracefully handle being asked to move to the next %s\",", "      it.each(quickNavigationRoles)(\n        \"should gracefully handle being asked to move to the next %s\",\n        async (role) => {\n          await virtual.perform(\n            virtual.commands[\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              `moveToNext${role.at(0)!.toUpperCase()}${role.slice(1)}`\n            ]\n          );\n", "          );\n\n          expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n        }\n      );\n    });\n  });\n\n  describe(\"moveToPreviousRole\", () => {\n    describe(\"when there are matching roles in the container\", () => {", "  describe(\"moveToPreviousRole\", () => {\n    describe(\"when there are matching roles in the container\", () => {\n      beforeEach(async () => {\n        document.body.innerHTML = quickNavigationRoles\n          .map(\n            (role) =>\n              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n          )\n          .join(\"\");\n", "          .join(\"\");\n\n        await virtual.start({ container: document.body });\n      });\n\n      it.each(quickNavigationRoles)(\n        \"should let you navigate to the previous %s\",\n        async (role) => {\n          await virtual.perform(\n            virtual.commands[", "          await virtual.perform(\n            virtual.commands[\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              `moveToPrevious${role.at(0)!.toUpperCase()}${role.slice(1)}`\n            ]\n          );\n          await virtual.next();\n          await virtual.next();\n\n          expect(await virtual.spokenPhraseLog()).toEqual([", "\n          expect(await virtual.spokenPhraseLog()).toEqual([\n            \"document\",\n            `${role}, Accessible name`,\n            `Node with role: ${role}`,\n            `end of ${role}, Accessible name`,\n          ]);\n        }\n      );\n    });", "      );\n    });\n\n    describe(\"when there are no matching roles in the container\", () => {\n      beforeEach(async () => {\n        document.body.innerHTML = \"\";\n\n        await virtual.start({ container: document.body });\n      });\n", "      });\n\n      it.each(quickNavigationRoles)(\n        \"should gracefully handle being asked to move to the previous %s\",\n        async (role) => {\n          await virtual.perform(\n            virtual.commands[\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              `moveToPrevious${role.at(0)!.toUpperCase()}${role.slice(1)}`\n            ]", "              `moveToPrevious${role.at(0)!.toUpperCase()}${role.slice(1)}`\n            ]\n          );\n\n          expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n        }\n      );\n    });\n  });\n", "  });\n\n  describe(\"landmark\", () => {\n    describe(\"when there are matching roles in the container\", () => {\n      beforeEach(async () => {\n        document.body.innerHTML = quickNavigationRolesWithLandmark\n          .map(\n            (role) =>\n              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n          )", "              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n          )\n          .join(\"\");\n\n        await virtual.start({ container: document.body });\n      });\n\n      it(\"should let you navigate to the next landmark\", async () => {\n        await Promise.all(\n          quickNavigationRoles.map(() =>", "        await Promise.all(\n          quickNavigationRoles.map(() =>\n            virtual.perform(virtual.commands.moveToNextLandmark)\n          )\n        );\n\n        expect(await virtual.spokenPhraseLog()).toEqual([\n          \"document\",\n          ...quickNavigationRoles.map((role) => `${role}, Accessible name`),\n        ]);", "          ...quickNavigationRoles.map((role) => `${role}, Accessible name`),\n        ]);\n      });\n\n      it(\"should let you navigate to the previous landmark\", async () => {\n        await Promise.all(\n          quickNavigationRoles.map(() =>\n            virtual.perform(virtual.commands.moveToPreviousLandmark)\n          )\n        );", "          )\n        );\n\n        expect(await virtual.spokenPhraseLog()).toEqual([\n          \"document\",\n          ...quickNavigationRoles\n            .slice()\n            .reverse()\n            .map((role) => `${role}, Accessible name`),\n        ]);", "            .map((role) => `${role}, Accessible name`),\n        ]);\n      });\n    });\n\n    describe(\"when there are no matching roles in the container\", () => {\n      beforeEach(async () => {\n        document.body.innerHTML = \"\";\n\n        await virtual.start({ container: document.body });", "\n        await virtual.start({ container: document.body });\n      });\n\n      it(\"should gracefully handle being asked to move to the next landmark\", async () => {\n        await virtual.perform(virtual.commands.moveToNextLandmark);\n\n        expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n      });\n", "      });\n\n      it(\"should gracefully handle being asked to move to the previous landmark\", async () => {\n        await virtual.perform(virtual.commands.moveToPreviousLandmark);\n\n        expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n      });\n    });\n  });\n});", "  });\n});\n"]}
{"filename": "test/int/press.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\nimport { virtual } from \"../../src\";\n\nfunction setupInputPage() {\n  document.body.innerHTML = `\n  <label for=\"input\">Input Some Text</label>\n  <input type=\"text\" id=\"input\" value=\"\" />\n  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n  `;\n}\n\ndescribe(\"press\", () => {\n  beforeEach(() => {\n    setupInputPage();\n  });\n\n  it(\"should press keys on the active element\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.itemText()).toEqual(\"Input Some Text\");\n\n    await virtual.press(\"Shift+a+b+c\");\n    // TODO: FAIL: Testing Library user-event doesn't support modification yet, this should be \"ABC\"\n    expect(getByRole(container, \"textbox\")).toHaveValue(\"abc\");\n    expect(await virtual.itemText()).toEqual(\"Input Some Text, abc\");\n\n    await virtual.stop();\n  });\n\n  it(\"should handle requests to press on hidden container gracefully\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    await virtual.press(\"Shift+a+b+c\");\n\n    expect(await virtual.itemTextLog()).toEqual([]);\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle requests to press on a non-element gracefully\", async () => {\n    const container = document.createTextNode(\"text node\");\n\n    await virtual.start({ container });\n\n    await virtual.press(\"Shift+a+b+c\");\n\n    expect(await virtual.itemTextLog()).toEqual([\"text node\"]);\n    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/implicitAriaStates.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Implicit Aria States\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce implicit aria states as labels\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce implicit aria states as labels\", async () => {\n    document.body.innerHTML = `\n    <div role=\"tab\">A Tab</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"tab, A Tab, not selected\");\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\"tab, A Tab, not selected\");\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/containerHidden.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Container Hidden\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div id=\"container\" style=\"display: none;\">This content is not announced</div>\n    `;\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    await virtual.start({ container: document.querySelector(\"#container\")! });", "    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    await virtual.start({ container: document.querySelector(\"#container\")! });\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n", "  });\n\n  it(\"should not announce anything if the container is itself hidden from screen readers\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([]);\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n  });\n\n  it(\"should handle requests to move next and previous gracefully if the container is itself hidden from screen readers\", async () => {\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n    await virtual.previous();\n    await virtual.previous();\n\n    expect(await virtual.itemTextLog()).toEqual([]);\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n  });\n});\n", "});\n"]}
{"filename": "test/int/jumpToControlledElement.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"jumpToControlledElement\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should jump to a controlled element\", async () => {\n    document.body.innerHTML = `", "  it(\"should jump to a controlled element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"controls-target\">Target</button>\n    <div>content 1</div>\n    <ul id=\"controls-target\">\n      <li>Item 1</li>\n      <li>Item 2</li>\n    </ul>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",", "    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, 1 control\",\n      \"list\",\n      \"listitem\",\n      \"Item 1\",\n    ]);\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n\n  it(\"should jump to the second controlled element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"controls-target1 controls-target2\">Target</button>\n    <div>content 1</div>\n    <ul id=\"controls-target1\">\n      <li>Item 1</li>\n      <li>Item 2</li>", "      <li>Item 1</li>\n      <li>Item 2</li>\n    </ul>\n    <ul id=\"controls-target2\">\n      <li>Item 3</li>\n      <li>Item 4</li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement, {\n      index: 1,\n    });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([", "\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, 2 controls\",\n      \"list\",\n      \"listitem\",\n      \"Item 3\",\n    ]);\n\n    await virtual.stop();", "\n    await virtual.stop();\n  });\n\n  it(\"should jump to a controlled presentation element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"controls-target\">Target</button>\n    <div>content 1</div>\n    <div id=\"controls-target\">content 2</div>\n    `;", "    <div id=\"controls-target\">content 2</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, 1 control\",", "      \"document\",\n      \"button, Target, 1 control\",\n      \"content 2\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should jump to a second controlled presentation element\", async () => {\n    document.body.innerHTML = `", "  it(\"should jump to a second controlled presentation element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"controls-target1 controls-target2\">Target</button>\n    <div>content 1</div>\n    <div id=\"controls-target1\">content 2</div>\n    <div id=\"controls-target2\">content 3</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement, {\n      index: 1,\n    });\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, 2 controls\",\n      \"content 3\",", "      \"button, Target, 2 controls\",\n      \"content 3\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle a non-element container gracefully\", async () => {\n    const container = document.createTextNode(\"text node\");\n", "    const container = document.createTextNode(\"text node\");\n\n    await virtual.start({ container });\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should handle a hidden container gracefully\", async () => {\n    const container = document.createElement(\"div\");\n    container.setAttribute(\"aria-hidden\", \"true\");\n\n    await virtual.start({ container });\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([]);", "\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on a non-element node\", async () => {\n    document.body.innerHTML = `Hello World`;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Hello World\",\n    ]);\n", "    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on an element with no aria-controls\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\">Target</button>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target\",\n    ]);", "      \"button, Target\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on an element with an invalid aria-controls\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"missing-element\">Target</button>\n    `;", "    <button id=\"target\" aria-controls=\"missing-element\">Target</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target\",", "      \"document\",\n      \"button, Target\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on an element with an aria-controls pointing to a hidden element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"hidden-element\">Target</button>", "    document.body.innerHTML = `\n    <button id=\"target\" aria-controls=\"hidden-element\">Target</button>\n    <div id=\"hidden-element\" aria-hidden=\"true\">Hidden</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToControlledElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([", "\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, 1 control\",\n    ]);\n\n    await virtual.stop();\n  });\n});\n", "});\n"]}
{"filename": "test/int/ariaReadonly.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Read only Attribute State\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce that a button with an aria-readonly attribute set to true is 'read only'\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce that a button with an aria-readonly attribute set to true is 'read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <div\n      role=\"textbox\"\n      aria-labelledby=\"label\"\n      aria-readonly=\"true\"\n      id=\"email1\"></div>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, read only\"\n    );\n", "    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with an aria-readonly attribute set to false is 'not read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <div\n      role=\"textbox\"", "    <div\n      role=\"textbox\"\n      aria-labelledby=\"label\"\n      aria-readonly=\"false\"\n      id=\"email1\"></div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, not read only\"\n    );\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should announce that a button with a readonly attribute is 'read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      readonly\n      id=\"email1\"></textarea>\n    `;", "      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, read only\"\n    );", "      \"textbox, Email Address *, read only\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with a readonly attribute set to true is 'read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea", "    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      readonly=\"true\"\n      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, read only\"\n    );\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should announce that a button with a readonly attribute set to false is 'not read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      readonly=\"false\"\n      id=\"email1\"></textarea>\n    `;", "      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, not read only\"\n    );", "      \"textbox, Email Address *, not read only\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with a contenteditable attribute is 'not read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea", "    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      contenteditable\n      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, not read only\"\n    );\n\n    await virtual.stop();\n  });\n  it(\"should announce that a button with a contenteditable attribute set to true is 'not read only'\", async () => {", "  });\n  it(\"should announce that a button with a contenteditable attribute set to true is 'not read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      contenteditable=\"true\"\n      id=\"email1\"></textarea>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, not read only\"\n    );\n", "    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with a contenteditable attribute set to false is 'read only'\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"", "    <textarea\n      aria-labelledby=\"label\"\n      contenteditable=\"false\"\n      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, read only\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should prefer contenteditable over aria-readonly\", async () => {", "\n  it(\"should prefer contenteditable over aria-readonly\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      contenteditable=\"true\"\n      aria-readonly=\"true\"\n      id=\"email1\"></textarea>\n    `;", "      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, not read only\"\n    );", "      \"textbox, Email Address *, not read only\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should prefer readonly over aria-readonly\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea", "    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      readonly=\"true\"\n      aria-readonly=\"false\"\n      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, read only\"\n    );\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n\n  it(\"should prefer readonly over contenteditable\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Email Address *</div>\n    <textarea\n      aria-labelledby=\"label\"\n      readonly=\"true\"\n      contenteditable=\"true\"", "      readonly=\"true\"\n      contenteditable=\"true\"\n      id=\"email1\"></textarea>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(", "\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Email Address *, read only\"\n    );\n\n    await virtual.stop();\n  });\n});\n", ""]}
{"filename": "test/int/click.int.test.ts", "chunked_list": ["import { getByText, queryByText } from \"@testing-library/dom\";\nimport { virtual } from \"../../src\";\n\nfunction setupButtonPage() {\n  document.body.innerHTML = `\n  <p id=\"status\">Not Clicked</p>\n  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n  `;\n\n  const button = document.createElement(\"button\");\n\n  button.addEventListener(\"click\", function (event) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    document.getElementById(\n      \"status\"\n    )!.innerHTML = `Clicked ${event.detail} Time(s)`;\n  });\n\n  button.innerHTML = \"Click Me\";\n\n  document.body.appendChild(button);\n\n  document.body.addEventListener(\"contextmenu\", () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    document.getElementById(\"status\")!.innerHTML = `Right Clicked`;\n  });\n}\n\ndescribe(\"click\", () => {\n  beforeEach(() => {\n    setupButtonPage();\n  });\n\n  it(\"should click\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n", "    while ((await virtual.itemText()) !== \"Click Me\") {\n      await virtual.next();\n    }\n\n    await virtual.click();\n\n    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n    expect(getByText(container, \"Clicked 1 Time(s)\")).toBeInTheDocument();\n\n    await virtual.previous();\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 1 Time(s)\");\n\n    await virtual.stop();\n  });\n\n  it(\"should double click\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n", "    while ((await virtual.itemText()) !== \"Click Me\") {\n      await virtual.next();\n    }\n\n    await virtual.click({ clickCount: 2 });\n\n    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n    expect(getByText(container, \"Clicked 2 Time(s)\")).toBeInTheDocument();\n\n    await virtual.previous();\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 2 Time(s)\");\n\n    await virtual.stop();\n  });\n\n  it(\"should triple click\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n", "    while ((await virtual.itemText()) !== \"Click Me\") {\n      await virtual.next();\n    }\n\n    await virtual.click({ clickCount: 3 });\n\n    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n    expect(getByText(container, \"Clicked 3 Time(s)\")).toBeInTheDocument();\n\n    await virtual.previous();\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 3 Time(s)\");\n\n    await virtual.stop();\n  });\n\n  it(\"should right click\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n", "    while ((await virtual.itemText()) !== \"Click Me\") {\n      await virtual.next();\n    }\n\n    await virtual.click({ button: \"right\" });\n\n    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n    expect(getByText(container, \"Right Clicked\")).toBeInTheDocument();\n\n    await virtual.previous();\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"Right Clicked\");\n\n    await virtual.stop();\n  });\n\n  it(\"should handle requests to click on hidden container gracefully\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    await virtual.click();\n\n    expect(await virtual.itemTextLog()).toEqual([]);\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/invalidStart.test.ts", "chunked_list": ["import {\n  ERR_VIRTUAL_MISSING_CONTAINER,\n  ERR_VIRTUAL_NOT_STARTED,\n} from \"../../src/errors\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"Invalid Start\", () => {\n  beforeEach(() => {\n    document.body.innerHTML = `\n    <div>Some Text</div>", "    document.body.innerHTML = `\n    <div>Some Text</div>\n    `;\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n", "  });\n\n  it(\"should throw if started without a configuration object\", async () => {\n    await expect(async () => await virtual.start()).rejects.toThrowError(\n      ERR_VIRTUAL_MISSING_CONTAINER\n    );\n  });\n\n  it(\"should throw if started without a container in the configuration object\", async () => {\n    await expect(", "  it(\"should throw if started without a container in the configuration object\", async () => {\n    await expect(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      async () => await virtual.start({} as any)\n    ).rejects.toThrowError(ERR_VIRTUAL_MISSING_CONTAINER);\n  });\n\n  it(\"should throw if use a method without starting first\", async () => {\n    await expect(async () => await virtual.next()).rejects.toThrowError(\n      ERR_VIRTUAL_NOT_STARTED", "    await expect(async () => await virtual.next()).rejects.toThrowError(\n      ERR_VIRTUAL_NOT_STARTED\n    );\n  });\n});\n"]}
{"filename": "test/int/act.int.test.ts", "chunked_list": ["import { getByText, queryByText } from \"@testing-library/dom\";\nimport { virtual } from \"../../src\";\n\nfunction setupButtonPage() {\n  document.body.innerHTML = `\n  <p id=\"status\">Not Clicked</p>\n  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n  `;\n\n  const button = document.createElement(\"button\");\n\n  button.addEventListener(\"click\", function (event) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    document.getElementById(\n      \"status\"\n    )!.innerHTML = `Clicked ${event.detail} Time(s)`;\n  });\n\n  button.innerHTML = \"Click Me\";\n\n  document.body.appendChild(button);\n}\n\ndescribe(\"act\", () => {\n  beforeEach(() => {\n    setupButtonPage();\n  });\n\n  it(\"should perform the default action\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n", "    while ((await virtual.itemText()) !== \"Click Me\") {\n      await virtual.next();\n    }\n\n    await virtual.act();\n\n    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n    expect(getByText(container, \"Clicked 1 Time(s)\")).toBeInTheDocument();\n\n    await virtual.previous();\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 1 Time(s)\");\n\n    await virtual.stop();\n  });\n\n  it(\"should handle requests to perform the default action on hidden container gracefully\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    await virtual.act();\n\n    expect(await virtual.itemTextLog()).toEqual([]);\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/inheritedImplicitPresentational.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Inherited Implicit Presentational Role\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should treat children of presentation roles as presentation when there are no exceptions\", async () => {\n    document.body.innerHTML = `", "  it(\"should treat children of presentation roles as presentation when there are no exceptions\", async () => {\n    document.body.innerHTML = `\n    <!-- 1. role=\"presentation\" negates the implicit 'heading' role semantics but does not affect the contents, including the nested hyperlink. -->\n    <h1 role=\"presentation\"> Sample Content <a href=\"...\">let's go!</a> </h1>\n\n    <!-- 2. A span has an implicit 'generic' role and no other attributes important to accessibility, so only its content is exposed, including the hyperlink. -->\n    <span> Sample Content <a href=\"...\">let's go!</a> </span>\n\n    <!-- 3. In the following code sample, the containing img and is appropriately labeled by the caption paragraph. In this example the img element can be marked as presentation because the role and the text alternatives are provided by the containing element. -->\n    <div role=\"img\" aria-labelledby=\"caption\">", "    <!-- 3. In the following code sample, the containing img and is appropriately labeled by the caption paragraph. In this example the img element can be marked as presentation because the role and the text alternatives are provided by the containing element. -->\n    <div role=\"img\" aria-labelledby=\"caption\">\n      <img src=\"example.png\" role=\"presentation\" alt=\"\">\n      <p id=\"caption\">A visible text caption labeling the image.</p>\n    </div>\n\n    <!-- 4. In the following code sample, because the anchor (HTML a element) is acting as the treeitem, the list item (HTML li element) is assigned an explicit WAI-ARIA role of presentation to override the user agent's implicit native semantics for list items. -->\n    <ul role=\"tree\">\n      <li role=\"presentation\">\n        <a role=\"treeitem\" aria-expanded=\"true\">An expanded tree node</a>", "      <li role=\"presentation\">\n        <a role=\"treeitem\" aria-expanded=\"true\">An expanded tree node</a>\n      </li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"Sample Content\",\n      \"let's go!\",\n      \"Sample Content\",\n      \"let's go!\",\n      \"A visible text caption labeling the image.\",\n      \"\",\n      \"An expanded tree node\",\n      \"\",\n      \"\",\n    ]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Sample Content\",\n      \"link, let's go!\",\n      \"Sample Content\",\n      \"link, let's go!\",\n      \"img, A visible text caption labeling the image.\",\n      \"tree, orientated vertically\",\n      \"treeitem, An expanded tree node, expanded, not selected\",\n      \"end of tree, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle inherited implicit presentation role\", async () => {\n    document.body.innerHTML = `\n    <ul role=\"presentation\">\n      <li> Sample Content </li>\n      <li> More Sample Content </li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"Sample Content\",\n      \"let's go!\",\n      \"Sample Content\",\n      \"let's go!\",\n      \"A visible text caption labeling the image.\",\n      \"\",\n      \"An expanded tree node\",\n      \"\",\n      \"\",\n    ]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Sample Content\",\n      \"link, let's go!\",\n      \"Sample Content\",\n      \"link, let's go!\",\n      \"img, A visible text caption labeling the image.\",\n      \"tree, orientated vertically\",\n      \"treeitem, An expanded tree node, expanded, not selected\",\n      \"end of tree, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle inherited implicit presentation role\", async () => {\n    document.body.innerHTML = `\n    <ul role=\"presentation\">\n      <li> Sample Content </li>\n      <li> More Sample Content </li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Sample Content\",\n      \"More Sample Content\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle no implicit roles\", async () => {\n    document.body.innerHTML = `\n    <foo>\n      <foo> Sample Content </foo>\n      <foo> More Sample Content </foo>\n    </foo>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Sample Content\",\n      \"More Sample Content\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/edgeCaseContainer.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Edge Case Container\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should handle edge case containers such as comment nodes gracefully\", async () => {\n    document.body.innerHTML = `", "  it(\"should handle edge case containers such as comment nodes gracefully\", async () => {\n    document.body.innerHTML = `\n    <!-- HTML Comment -->\n    <div>Some Text</div>\n    `;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    await virtual.start({ container: document.body.childNodes[0] as any });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.itemText()).toEqual(\"\");\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"\");\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n});", "  });\n});\n"]}
{"filename": "test/int/noMutationObserver.int.test.ts", "chunked_list": ["(window.MutationObserver as unknown) = undefined;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst { virtual } = require(\"../../src\");\n\ndescribe(\"No Mutation Observer\", () => {\n  it(\"should handle DOM implementations that do not support Mutation Observer\", async () => {\n    document.body.innerHTML = `\n    <div>Some Text</div>\n    `;\n    await virtual.start({ container: document.body });", "    `;\n    await virtual.start({ container: document.body });\n\n    await virtual.next();\n\n    expect(await virtual.itemText()).toEqual(\"Some Text\");\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"Some Text\");\n\n    await virtual.stop();\n", "    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n});\n"]}
{"filename": "test/int/jumpToDetailsElement.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"jumpToDetailsElement\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should jump to a details element\", async () => {\n    document.body.innerHTML = `", "  it(\"should jump to a details element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-details=\"controls-target\">Target</button>\n    <div>content 1</div>\n    <ul id=\"controls-target\">\n      <li>Item 1</li>\n      <li>Item 2</li>\n    </ul>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",", "    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, linked details\",\n      \"list\",\n      \"listitem\",\n      \"Item 1\",\n    ]);\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n\n  it(\"should jump to a details presentation element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-details=\"controls-target\">Target</button>\n    <div>content 1</div>\n    <div id=\"controls-target\">content 2</div>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, linked details\",\n      \"content 2\",", "      \"button, Target, linked details\",\n      \"content 2\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle a non-element container gracefully\", async () => {\n    const container = document.createTextNode(\"text node\");\n", "    const container = document.createTextNode(\"text node\");\n\n    await virtual.start({ container });\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should handle a hidden container gracefully\", async () => {\n    const container = document.createElement(\"div\");\n    container.setAttribute(\"aria-hidden\", \"true\");\n\n    await virtual.start({ container });\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([]);", "\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on a non-element node\", async () => {\n    document.body.innerHTML = `Hello World`;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Hello World\",\n    ]);\n", "    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on an element with no aria-details\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\">Target</button>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target\",\n    ]);", "      \"button, Target\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on an element with an invalid aria-details\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-details=\"missing-element\">Target</button>\n    `;", "    <button id=\"target\" aria-details=\"missing-element\">Target</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target\",", "      \"document\",\n      \"button, Target\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should ignore the command on an element with an aria-details pointing to a hidden element\", async () => {\n    document.body.innerHTML = `\n    <button id=\"target\" aria-details=\"hidden-element\">Target</button>", "    document.body.innerHTML = `\n    <button id=\"target\" aria-details=\"hidden-element\">Target</button>\n    <div id=\"hidden-element\" aria-hidden=\"true\">Hidden</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([", "\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Target, linked details\",\n    ]);\n\n    await virtual.stop();\n  });\n});\n", "});\n"]}
{"filename": "test/int/labelPriorityReplacement.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Label Priority Replacement\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce aria-valuetext in preference to aria-valuenow\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce aria-valuetext in preference to aria-valuenow\", async () => {\n    document.body.innerHTML = `\n    <span id=\"element1\">Pandemic Size:</span>\n    <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuemin=\"1\" aria-valuemax=\"3\" aria-valuenow=\"1\" aria-valuetext=\"small\">\n      <svg width=\"300\" height=\"10\">\n        <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n        <rect height=\"10\" width=\"200\" fill=\"white\" />\n      </svg>\n    </span>\n    `;", "    </span>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"progressbar, Pandemic Size:, current value small, max value 3, min value 1\"\n    );", "      \"progressbar, Pandemic Size:, current value small, max value 3, min value 1\"\n    );\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/allowedAccessibilityChildRoles.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Allowed Accessibility Child Roles\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should handle a direct DOM child\", async () => {\n    document.body.innerHTML = `", "  it(\"should handle a direct DOM child\", async () => {\n    document.body.innerHTML = `\n    <div role=\"listbox\">\n      <div role=\"option\">option text</div>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"listbox, orientated vertically\",\n      \"option, option text, not selected\",\n      \"end of listbox, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle a DOM child with generics intervening\", async () => {\n    document.body.innerHTML = `\n    <div role=\"listbox\">\n      <div>\n        <div role=\"option\">option text</div>\n      </div>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"listbox, orientated vertically\",\n      \"option, option text, not selected\",\n      \"end of listbox, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle a DOM child with generics intervening\", async () => {\n    document.body.innerHTML = `\n    <div role=\"listbox\">\n      <div>\n        <div role=\"option\">option text</div>\n      </div>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"listbox, orientated vertically\",\n      \"option, option text, not selected\",\n      \"end of listbox, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle a direct aria-owns relationship\", async () => {\n    document.body.innerHTML = `\n    <div role=\"listbox\" aria-owns=\"id1\"></div>\n    <div role=\"option\" id=\"id1\">option text</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"listbox, orientated vertically\",\n      \"option, option text, not selected\",\n      \"end of listbox, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle an aria-owns relationship with generics intervening\", async () => {\n    document.body.innerHTML = `\n    <div role=\"listbox\" aria-owns=\"id1\"></div>\n    <div id=\"id1\">\n      <div>\n        <div role=\"option\">option text</div>\n      </div>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"listbox, orientated vertically\",\n      \"option, option text, not selected\",\n      \"end of listbox, orientated vertically\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/disabled.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Disabled Attribute State\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce that a button with an aria-disabled attribute set to true is 'disabled'\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce that a button with an aria-disabled attribute set to true is 'disabled'\", async () => {\n    document.body.innerHTML = `\n    <button aria-disabled=\"true\">Submit</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce a button with an aria-disabled attribute set to false without any disabled state labelling\", async () => {\n    document.body.innerHTML = `\n    <button aria-disabled=\"false\">Submit</button>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"button, Submit, not disabled\"\n    );\n\n    await virtual.stop();", "\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with a disabled attribute\", async () => {\n    document.body.innerHTML = `\n    <button disabled>Submit</button>\n    `;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with a disabled attribute set to true is 'disabled'\", async () => {", "\n  it(\"should announce that a button with a disabled attribute set to true is 'disabled'\", async () => {\n    document.body.innerHTML = `\n    <button disabled=\"true\">Submit</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");", "\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce a button with a disabled attribute set to false without any disabled state labelling\", async () => {\n    document.body.innerHTML = `\n    <button disabled=\"false\">Submit</button>\n    `;", "    <button disabled=\"false\">Submit</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"button, Submit, not disabled\"\n    );\n", "    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce a button without an aria-disabled attribute without any disabled state labelling\", async () => {\n    document.body.innerHTML = `\n    <button>Submit</button>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit\");\n\n    await virtual.stop();\n  });\n});", "  });\n});\n"]}
{"filename": "test/int/checked.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Checked Attribute State\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce that a checkbox with a checked attribute is 'checked'\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce that a checkbox with a checked attribute is 'checked'\", async () => {\n    document.body.innerHTML = `\n    <fieldset>\n      <legend>Choose your monster's features:</legend>\n\n      <div>\n        <input type=\"checkbox\" id=\"scales\" name=\"scales\" checked>\n        <label for=\"scales\">Scales</label>\n      </div>\n", "      </div>\n\n      <div>\n        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>\n      </div>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Scales, checked\");\n\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a checkbox with a checked attribute set to true is 'checked'\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce that a checkbox with a checked attribute set to true is 'checked'\", async () => {\n    document.body.innerHTML = `\n    <fieldset>\n      <legend>Choose your monster's features:</legend>\n\n      <div>\n        <input type=\"checkbox\" id=\"scales\" name=\"scales\" checked=\"true\">\n        <label for=\"scales\">Scales</label>\n      </div>\n", "      </div>\n\n      <div>\n        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>\n      </div>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Scales, checked\");\n\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a checkbox with a checked attribute set to false is 'not checked'\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce that a checkbox with a checked attribute set to false is 'not checked'\", async () => {\n    document.body.innerHTML = `\n    <fieldset>\n      <legend>Choose your monster's features:</legend>\n\n      <div>\n        <input type=\"checkbox\" id=\"scales\" name=\"scales\" checked=\"false\">\n        <label for=\"scales\">Scales</label>\n      </div>\n", "      </div>\n\n      <div>\n        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>\n      </div>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"checkbox, Scales, not checked\"\n    );\n", "    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a checkbox with an aria-checked attribute set to true is 'checked'\", async () => {\n    document.body.innerHTML = `\n    <fieldset>\n      <legend>Choose your monster's features:</legend>\n", "      <legend>Choose your monster's features:</legend>\n\n      <div>\n        <input type=\"checkbox\" id=\"scales\" name=\"scales\" aria-checked=\"true\">\n        <label for=\"scales\">Scales</label>\n      </div>\n\n      <div>\n        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>", "        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>\n      </div>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Scales, checked\");\n\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a checkbox with an aria-checked attribute set to false is 'not checked'\", async () => {\n    document.body.innerHTML = `\n    <fieldset>\n      <legend>Choose your monster's features:</legend>\n", "      <legend>Choose your monster's features:</legend>\n\n      <div>\n        <input type=\"checkbox\" id=\"scales\" name=\"scales\" aria-checked=\"false\">\n        <label for=\"scales\">Scales</label>\n      </div>\n\n      <div>\n        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>", "        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n        <label for=\"horns\">Horns</label>\n      </div>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"checkbox, Scales, not checked\"\n    );\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should handle a checkbox with an aria-checked attribute set to mixed\", async () => {\n    // REF: https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/examples/checkbox-mixed/\n    document.body.innerHTML = `\n    <fieldset class=\"checkbox-mixed\">\n      <legend>\n        Sandwich Condiments\n      </legend>\n      <div role=\"checkbox\"", "      </legend>\n      <div role=\"checkbox\"\n          class=\"group_checkbox\"\n          aria-checked=\"mixed\"\n          aria-controls=\"cond1 cond2 cond3 cond4\"\n          tabindex=\"0\">\n        All condiments\n      </div>\n      <ul class=\"checkboxes\">\n        <li>", "      <ul class=\"checkboxes\">\n        <li>\n          <label>\n            <input type=\"checkbox\" id=\"cond1\">\n            Lettuce\n          </label>\n        </li>\n        <li>\n          <label>\n            <input type=\"checkbox\"", "          <label>\n            <input type=\"checkbox\"\n                  id=\"cond2\"\n                  checked=\"\">\n            Tomato\n          </label>\n        </li>\n        <li>\n          <label>\n            <input type=\"checkbox\" id=\"cond3\">", "          <label>\n            <input type=\"checkbox\" id=\"cond3\">\n            Mustard\n          </label>\n        </li>\n        <li>\n          <label>\n            <input type=\"checkbox\" id=\"cond4\">\n            Sprouts\n          </label>", "            Sprouts\n          </label>\n        </li>\n      </ul>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"checkbox, All condiments, partially checked, 4 controls\"\n    );\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/detection.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Detection\", () => {\n  it(\"should return true for Virtual being a supported screen reader for the OS\", async () => {\n    expect(await virtual.detect()).toBeTruthy();\n  });\n\n  it(\"should return false for Virtual being the default screen reader for the OS\", async () => {\n    expect(await virtual.default()).toBeFalsy();\n  });", "    expect(await virtual.default()).toBeFalsy();\n  });\n});\n"]}
{"filename": "test/int/ariaDetails.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Aria Details\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should handle linked details\", async () => {\n    document.body.innerHTML = `", "  it(\"should handle linked details\", async () => {\n    document.body.innerHTML = `\n    <img src=\"pythagorean.jpg\" alt=\"Pythagorean Theorem\" aria-details=\"det\">\n    <details id=\"det\">\n      <summary>Example</summary>\n      <p>\n        The Pythagorean Theorem is a relationship in Euclidean Geometry between the three sides of\n        a right triangle, where the square of the hypotenuse is the sum of the squares of the two\n        opposing sides.\n      </p>", "        opposing sides.\n      </p>\n      <p>\n        The following drawing illustrates an application of the Pythagorean Theorem when used to\n        construct a skateboard ramp.\n      </p>\n      <object data=\"skatebd-ramp.svg\"  type=\"image/svg+xml\"></object>\n      <p>\n        In this example you will notice a skateboard with a base and vertical board whose width\n        is the width of the ramp. To compute how long the ramp must be, simply calculate the", "        In this example you will notice a skateboard with a base and vertical board whose width\n        is the width of the ramp. To compute how long the ramp must be, simply calculate the\n        base length, square it, sum it with the square of the height of the ramp, and take the\n        square root of the sum.\n      </p>\n    </details>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, Pythagorean Theorem, linked details\",\n    ]);\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n\n  it(\"should gracefully handle an invalid idRef\", async () => {\n    document.body.innerHTML = `\n    <img src=\"pythagorean.jpg\" alt=\"Pythagorean Theorem\" aria-details=\"det\">\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, Pythagorean Theorem\",\n    ]);\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/next.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\nimport { setupBasicPage } from \"../utils\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"next\", () => {\n  beforeEach(async () => {\n    setupBasicPage();\n\n    await virtual.start({ container: document.body });\n  });", "    await virtual.start({ container: document.body });\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should move through the next elements\", async () => {\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"\",\n      \"Nav Text\",\n      \"\",\n      \"\",\n      \"Section Heading 1\",\n      \"Section Text\",\n      \"\",\n      \"\",\n      \"Article Header Heading 1\",\n      \"Article Header Text\",\n      \"\",\n      \"Article Text\",\n      \"\",\n      \"\",\n      \"\",\n      \"Footer\",\n      \"\",\n      \"\",\n    ]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"Nav Text\",\n      \"end of navigation\",\n      \"region\",\n      \"heading, Section Heading 1, level 1\",\n      \"Section Text\",\n      \"article\",\n      \"banner\",\n      \"heading, Article Header Heading 1, level 1\",\n      \"Article Header Text\",\n      \"end of banner\",\n      \"Article Text\",\n      \"end of article\",\n      \"end of region\",\n      \"contentinfo\",\n      \"Footer\",\n      \"end of contentinfo\",\n      \"end of document\",\n    ]);\n  });\n\n  it(\"should handle the current node being removed from the DOM gracefully and set the active element back to the container\", async () => {\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"Nav Text\");\n\n    const currentElement = getByRole(document.body, \"navigation\");\n    document.body.removeChild(currentElement);\n\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"Nav Text\",\n      \"document\",\n    ]);\n  });\n});\n", "\n  it(\"should move through the next elements\", async () => {\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"\",\n      \"Nav Text\",\n      \"\",\n      \"\",\n      \"Section Heading 1\",\n      \"Section Text\",\n      \"\",\n      \"\",\n      \"Article Header Heading 1\",\n      \"Article Header Text\",\n      \"\",\n      \"Article Text\",\n      \"\",\n      \"\",\n      \"\",\n      \"Footer\",\n      \"\",\n      \"\",\n    ]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"Nav Text\",\n      \"end of navigation\",\n      \"region\",\n      \"heading, Section Heading 1, level 1\",\n      \"Section Text\",\n      \"article\",\n      \"banner\",\n      \"heading, Article Header Heading 1, level 1\",\n      \"Article Header Text\",\n      \"end of banner\",\n      \"Article Text\",\n      \"end of article\",\n      \"end of region\",\n      \"contentinfo\",\n      \"Footer\",\n      \"end of contentinfo\",\n      \"end of document\",\n    ]);\n  });\n\n  it(\"should handle the current node being removed from the DOM gracefully and set the active element back to the container\", async () => {\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"Nav Text\");\n\n    const currentElement = getByRole(document.body, \"navigation\");\n    document.body.removeChild(currentElement);\n\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"Nav Text\",\n      \"document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/int/ariaPlaceholder.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Placeholder Attribute Property\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce a non-empty aria-placeholder attribute on an input when there is no value\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce a non-empty aria-placeholder attribute on an input when there is no value\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" aria-placeholder=\"Search...\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Label, placeholder Search...\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce an empty aria-placeholder attribute on an input when there is no value\", async () => {", "\n  it(\"should not announce an empty aria-placeholder attribute on an input when there is no value\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" aria-placeholder=\"\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce an input value in preference to a non-empty aria-placeholder attribute\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce an input value in preference to a non-empty aria-placeholder attribute\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"a11y\" aria-placeholder=\"Search...\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce a non-empty placeholder attribute on an input when there is no value\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>", "    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" placeholder=\"Search...\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(", "\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"textbox, Label, placeholder Search...\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce an empty placeholder attribute on an input when there is no value\", async () => {\n    document.body.innerHTML = `", "  it(\"should not announce an empty placeholder attribute on an input when there is no value\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" placeholder=\"\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce an input value in preference to a non-empty placeholder attribute\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>", "    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"a11y\" placeholder=\"Search...\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");", "\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/previous.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\nimport { setupBasicPage } from \"../utils\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"previous\", () => {\n  beforeEach(async () => {\n    setupBasicPage();\n\n    await virtual.start({ container: document.body });\n  });", "    await virtual.start({ container: document.body });\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should move through previous elements\", async () => {", "\n  it(\"should move through previous elements\", async () => {\n    await virtual.previous();\n\n    while ((await virtual.lastSpokenPhrase()) !== \"document\") {\n      await virtual.previous();\n    }\n\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"\",\n      \"\",\n      \"Footer\",\n      \"\",\n      \"\",\n      \"\",\n      \"Article Text\",\n      \"\",\n      \"Article Header Text\",\n      \"Article Header Heading 1\",\n      \"\",\n      \"\",\n      \"Section Text\",\n      \"Section Heading 1\",\n      \"\",\n      \"\",\n      \"Nav Text\",\n      \"\",\n      \"\",\n    ]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"end of document\",\n      \"end of contentinfo\",\n      \"Footer\",\n      \"contentinfo\",\n      \"end of region\",\n      \"end of article\",\n      \"Article Text\",\n      \"end of banner\",\n      \"Article Header Text\",\n      \"heading, Article Header Heading 1, level 1\",\n      \"banner\",\n      \"article\",\n      \"Section Text\",\n      \"heading, Section Heading 1, level 1\",\n      \"region\",\n      \"end of navigation\",\n      \"Nav Text\",\n      \"navigation\",\n      \"document\",\n    ]);\n  });\n\n  it(\"should handle the current node being removed from the DOM gracefully and set the active element back to the container\", async () => {\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"Nav Text\");\n\n    const currentElement = getByRole(document.body, \"navigation\");\n    document.body.removeChild(currentElement);\n\n    await virtual.previous();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"Nav Text\",\n      \"document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/int/interact.int.test.ts", "chunked_list": ["import { setupBasicPage } from \"../utils\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"interact / stopInteracting\", () => {\n  beforeEach(() => {\n    setupBasicPage();\n  });\n\n  it(\"should not do anything\", async () => {\n    await virtual.start({ container: document.body });", "  it(\"should not do anything\", async () => {\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.interact();\n    await virtual.next();\n    await virtual.stopInteracting();\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",", "    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"Nav Text\",\n      \"end of navigation\",\n    ]);\n  });\n});\n", ""]}
{"filename": "test/int/accessibleValue.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Placeholder Attribute Property\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce a non-empty value on a text input\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce a non-empty value on a text input\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"a11y\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce an empty value on a text input\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>", "    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");", "\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce a missing value on a text input\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\"/>", "    <div id=\"label\">Label</div>\n    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce a value on a checkbox input\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"checkbox\" aria-labelledby=\"label\" id=\"check1\" value=\"forbidden\"/>\n    `;", "    <input type=\"checkbox\" aria-labelledby=\"label\" id=\"check1\" value=\"forbidden\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Label\");\n\n    await virtual.stop();", "\n    await virtual.stop();\n  });\n\n  it(\"should not announce a value on a radio input\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"radio\" aria-labelledby=\"label\" id=\"radio1\" value=\"forbidden\"/>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"radio, Label\");\n\n    await virtual.stop();\n  });", "    await virtual.stop();\n  });\n\n  it(\"should not announce a value on a radio input\", async () => {\n    document.body.innerHTML = `\n    <div id=\"label\">Label</div>\n    <input type=\"radio\" aria-labelledby=\"label\" id=\"radio1\" value=\"forbidden\"/>\n    `;\n\n    await virtual.start({ container: document.body });", "\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"radio, Label\");\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should announce the selected value in a select with options\", async () => {\n    document.body.innerHTML = `\n    <select>\n      <option value=\"first\">First Value</option>\n      <option value=\"second\" selected>Second Value</option>\n      <option value=\"third\">Third Value</option>\n    </select>\n    `;", "    </select>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"combobox, second, not expanded, has popup listbox\"\n    );\n", "    );\n\n    await virtual.stop();\n  });\n\n  it(\"should announce the multiple selected values in a multi-select with options\", async () => {\n    document.body.innerHTML = `\n    <select multiple>\n      <option value=\"first\">First Value</option>\n      <option value=\"second\" selected>Second Value</option>", "      <option value=\"first\">First Value</option>\n      <option value=\"second\" selected>Second Value</option>\n      <option value=\"third\" selected>Third Value</option>\n    </select>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(", "\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"listbox, second; third, orientated vertically\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce empty selected values in a select with options\", async () => {\n    document.body.innerHTML = `", "  it(\"should not announce empty selected values in a select with options\", async () => {\n    document.body.innerHTML = `\n    <select>\n      <option value=\"\" disabled selected>- Select some value - </option>\n      <option value=\"first\">First Value</option>\n      <option value=\"second\">Second Value</option>\n      <option value=\"third\">Third Value</option>\n    </select>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"combobox, not expanded, has popup listbox\"\n    );\n\n    await virtual.stop();", "\n    await virtual.stop();\n  });\n\n  it(\"should announce the value for a progress element\", async () => {\n    document.body.innerHTML = `\n    <label for=\"element1\">Loading:</label>\n    <progress id=\"element1\" max=\"100\" value=\"23\"></progress>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"progressbar, Loading:, 23, max value 100\"\n    );\n", "    );\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce the value for a progress element which has an aria-valuenow\", async () => {\n    document.body.innerHTML = `\n    <label for=\"element1\">Loading:</label>\n    <progress id=\"element1\" max=\"100\" value=\"23\" aria-valuenow=\"24\"></progress>\n    `;", "    <progress id=\"element1\" max=\"100\" value=\"23\" aria-valuenow=\"24\"></progress>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"progressbar, Loading:, max value 100, current value 24%\"\n    );", "      \"progressbar, Loading:, max value 100, current value 24%\"\n    );\n\n    await virtual.stop();\n  });\n\n  it(\"should not announce the value for a progress element which has an aria-valuetext\", async () => {\n    document.body.innerHTML = `\n    <label for=\"element1\">Loading:</label>\n    <progress id=\"element1\" max=\"100\" value=\"23\" aria-valuetext=\"massive\"></progress>", "    <label for=\"element1\">Loading:</label>\n    <progress id=\"element1\" max=\"100\" value=\"23\" aria-valuetext=\"massive\"></progress>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"progressbar, Loading:, current value massive, max value 100\"", "    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"progressbar, Loading:, current value massive, max value 100\"\n    );\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/ariaActiveDescendantMenuButton1.int.test.ts", "chunked_list": ["import { setupActionsMenuButton } from \"./actionsMenuButton\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"Aria Active Descendant Menu Button\", () => {\n  let teardown;\n\n  beforeEach(() => {\n    teardown = setupActionsMenuButton();\n  });\n", "  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n    teardown();\n  });\n\n  it(\"should convey the referenced element as active - applied to the menu role\", async () => {\n    await virtual.start({ container: document.body });", "  it(\"should convey the referenced element as active - applied to the menu role\", async () => {\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.act();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Actions, has popup menu, 1 control\",\n      \"button, Actions, expanded, has popup menu, 1 control\",\n      \"menu, Actions, orientated vertically, active descendant Action 1\",", "      \"button, Actions, expanded, has popup menu, 1 control\",\n      \"menu, Actions, orientated vertically, active descendant Action 1\",\n    ]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/pressed.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Checked Attribute State\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce that a button with an aria-pressed attribute set to true is 'pressed'\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce that a button with an aria-pressed attribute set to true is 'pressed'\", async () => {\n    document.body.innerHTML = `\n    <button aria-pressed=\"true\">Pause</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause, pressed\");\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause, pressed\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce that a button with an aria-pressed attribute set to false is 'not pressed'\", async () => {\n    document.body.innerHTML = `\n    <button aria-pressed=\"false\">Pause</button>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause, not pressed\");\n\n    await virtual.stop();\n  });\n", "  });\n\n  it(\"should announce a button without an aria-pressed attribute without any pressed state labelling\", async () => {\n    document.body.innerHTML = `\n    <button>Pause</button>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause\");\n\n    await virtual.stop();\n  });\n\n  it(\"should handle a button with an aria-pressed attribute set to mixed\", async () => {\n    document.body.innerHTML = `\n    <fieldset class=\"button-mixed\">", "    document.body.innerHTML = `\n    <fieldset class=\"button-mixed\">\n      <legend>\n        Power Plant Controls\n      </legend>\n      <div role=\"button\"\n          class=\"group_button\"\n          aria-pressed=\"mixed\"\n          aria-controls=\"cond1 cond2 cond3\"\n          tabindex=\"0\">", "          aria-controls=\"cond1 cond2 cond3\"\n          tabindex=\"0\">\n        All systems\n      </div>\n      <ul class=\"buttons\">\n        <li>\n          <label>\n            <button id=\"cond1\">\n            Reactor\n          </label>", "            Reactor\n          </label>\n        </li>\n        <li>\n          <label>\n            <button\n                  id=\"cond2\"\n                  aria-pressed=\"\">\n            Coolant\n          </label>", "            Coolant\n          </label>\n        </li>\n        <li>\n          <label>\n            <button id=\"cond3\">\n            Generator\n          </label>\n        </li>\n      </ul>", "        </li>\n      </ul>\n    </fieldset>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\n      \"button, All systems, partially pressed, 3 controls\"\n    );\n\n    await virtual.stop();\n  });\n});\n", "});\n"]}
{"filename": "test/int/ariaOwns.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Aria Owns\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should handle an aria-owns single reference\", async () => {\n    document.body.innerHTML = `", "  it(\"should handle an aria-owns single reference\", async () => {\n    document.body.innerHTML = `\n    <ul id=\"target\">\n        <li aria-owns=\"child\">Fruit</li>\n        <li>Vegetables</li>\n    </ul>\n\n    <ul id=\"child\">\n        <li>Apples</li>\n        <li>Bananas</li>", "        <li>Apples</li>\n        <li>Bananas</li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"list\",\n      \"listitem\",\n      \"Fruit\",\n      \"list\",\n      \"listitem\",\n      \"Apples\",\n      \"end of listitem\",\n      \"listitem\",\n      \"Bananas\",\n      \"end of listitem\",\n      \"end of list\",\n      \"end of listitem\",\n      \"listitem\",\n      \"Vegetables\",\n      \"end of listitem\",\n      \"end of list\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle an aria-owns multiple reference\", async () => {\n    document.body.innerHTML = `\n    <ul id=\"target\">\n      <li aria-owns=\"child1 child2\">Fruit</li>\n      <li>Vegetables</li>\n    </ul>\n\n    <ul id=\"child1\">\n        <li>Apples</li>\n        <li>Bananas</li>\n    </ul>\n\n    <ul id=\"child2\">\n        <li>Blackberries</li>\n        <li>Blueberries</li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"list\",\n      \"listitem\",\n      \"Fruit\",\n      \"list\",\n      \"listitem\",\n      \"Apples\",\n      \"end of listitem\",\n      \"listitem\",\n      \"Bananas\",\n      \"end of listitem\",\n      \"end of list\",\n      \"list\",\n      \"listitem\",\n      \"Blackberries\",\n      \"end of listitem\",\n      \"listitem\",\n      \"Blueberries\",\n      \"end of listitem\",\n      \"end of list\",\n      \"end of listitem\",\n      \"listitem\",\n      \"Vegetables\",\n      \"end of listitem\",\n      \"end of list\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns where used to reorder already owned children\", async () => {\n    document.body.innerHTML = `\n    <div id=\"parent\" aria-owns=\"child1 child4 child2\">\n      <div id=\"child1\">Child 1</div>\n      <div id=\"child2\">Child 2</div>\n      <div id=\"child3\">Child 3</div>\n      <div id=\"child4\">Child 4</div>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Child 3\",\n      \"Child 1\",\n      \"Child 4\",\n      \"Child 2\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns simple circular references gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n    <div id=\"element2\" aria-owns=\"element3\">Element 2</div>\n    <div id=\"element3\" aria-owns=\"element2\">Element 3</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Element 1\",\n      \"Element 2\",\n      \"Element 3\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns only circular references gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n    <div id=\"element2\" aria-owns=\"element1\">Element 2</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    // All elements are \"owned\" by each other, so are ignored in the accessibility tree\n    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"document\"]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns complex circular references gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n    <div id=\"element2\" aria-owns=\"element4 element3\">Element 2</div>\n    <div id=\"element3\">Element 3</div>\n    <div id=\"element4\" aria-owns=\"element5\">Element 4</div>\n    <div id=\"element5\" aria-owns=\"element3\">Element 5</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Element 1\",\n      \"Element 2\",\n      \"Element 4\",\n      \"Element 5\",\n      \"Element 3\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns invalid IDREF gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Element 1\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns invalid IDREFs gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element2 element3\">Element 1</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Element 1\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle aria-owns IDREF for a hidden element gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n    <div id=\"element2\" aria-hidden=\"true\">Element 2</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Element 1\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle trying to find aria-owns on a non-element container\", async () => {\n    const textNode = document.createTextNode(\"text node\");\n\n    await virtual.start({ container: textNode as unknown as HTMLElement });\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n\n    await virtual.stop();\n  });\n\n  it(\"should handle multiple aria-owns for the same IDREF gracefully\", async () => {\n    document.body.innerHTML = `\n    <div id=\"element1\" aria-owns=\"element3\">Element 1</div>\n    <div id=\"element2\" aria-owns=\"element3\">Element 2</div>\n    <div id=\"element3\">Element 3</div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"Element 1\",\n      \"Element 3\",\n      \"Element 2\",\n      \"end of document\",\n    ]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/ariaActiveDescendant.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Aria Active Descendant\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should handle a simple combobox\", async () => {\n    document.body.innerHTML = `", "  it(\"should handle a simple combobox\", async () => {\n    document.body.innerHTML = `\n    <input type=\"text\" aria-activedescendant=\"cb1-opt6\" aria-readonly=\"true\" aria-owns=\"cb1-list\" aria-autocomplete=\"list\" role=\"combobox\" id=\"cb1-edit\">\n    <ul aria-expanded=\"true\" role=\"listbox\" id=\"cb1-list\">\n      <li role=\"option\" id=\"cb1-opt1\">Alabama</li>\n      <li role=\"option\" id=\"cb1-opt2\">Alaska</li>\n      <li role=\"option\" id=\"cb1-opt3\">American Samoa</li>\n      <li role=\"option\" id=\"cb1-opt4\">Arizona</li>\n      <li role=\"option\" id=\"cb1-opt5\">Arkansas</li>\n      <li role=\"option\" id=\"cb1-opt6\">California</li>", "      <li role=\"option\" id=\"cb1-opt5\">Arkansas</li>\n      <li role=\"option\" id=\"cb1-opt6\">California</li>\n      <li role=\"option\" id=\"cb1-opt7\">Colorado</li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([", "\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"combobox, active descendant California, autocomplete in list, read only, not expanded, has popup listbox\",\n    ]);\n\n    await virtual.stop();\n  });\n\n  it(\"should gracefully handle an invalid idRef\", async () => {", "\n  it(\"should gracefully handle an invalid idRef\", async () => {\n    document.body.innerHTML = `\n    <input type=\"text\" aria-activedescendant=\"cb1-opt8\" aria-readonly=\"true\" aria-owns=\"cb1-list\" aria-autocomplete=\"list\" role=\"combobox\" id=\"cb1-edit\">\n    <ul aria-expanded=\"true\" role=\"listbox\" id=\"cb1-list\">\n      <li role=\"option\" id=\"cb1-opt1\">Alabama</li>\n      <li role=\"option\" id=\"cb1-opt2\">Alaska</li>\n      <li role=\"option\" id=\"cb1-opt3\">American Samoa</li>\n      <li role=\"option\" id=\"cb1-opt4\">Arizona</li>\n      <li role=\"option\" id=\"cb1-opt5\">Arkansas</li>", "      <li role=\"option\" id=\"cb1-opt4\">Arizona</li>\n      <li role=\"option\" id=\"cb1-opt5\">Arkansas</li>\n      <li role=\"option\" id=\"cb1-opt6\">California</li>\n      <li role=\"option\" id=\"cb1-opt7\">Colorado</li>\n    </ul>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n", "    await virtual.next();\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"combobox, autocomplete in list, read only, not expanded, has popup listbox\",\n    ]);\n\n    await virtual.stop();\n  });\n});", "  });\n});\n"]}
{"filename": "test/int/ariaActiveDescendantMenuButton2.int.test.ts", "chunked_list": ["import { setupActionsMenuButton } from \"./actionsMenuButton\";\nimport userEvent from \"@testing-library/user-event\";\nimport { virtual } from \"../../src\";\n\ndescribe(\"Aria Active Descendant Menu Button\", () => {\n  let teardown;\n\n  beforeEach(() => {\n    teardown = setupActionsMenuButton();\n  });", "    teardown = setupActionsMenuButton();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n    teardown();\n  });\n\n  it(\"should convey when the referenced element changes - applied to the menu role\", async () => {", "\n  it(\"should convey when the referenced element changes - applied to the menu role\", async () => {\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.press(\"ArrowDown\");\n    await virtual.press(\"ArrowDown\");\n    await virtual.press(\"ArrowDown\");\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",", "    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"button, Actions, has popup menu, 1 control\",\n      \"button, Actions, expanded, has popup menu, 1 control\",\n      \"menu, Actions, orientated vertically, active descendant Action 1\",\n      \"menu, Actions, orientated vertically, active descendant Action 2\",\n      \"menu, Actions, orientated vertically, active descendant Action 3\",\n    ]);\n\n    await virtual.stop();", "\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/ariaRoleDescription.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Aria Role Description\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  it(\"should announce the aria-roledescription in place of the role\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce the aria-roledescription in place of the role\", async () => {\n    document.body.innerHTML = `\n    <div role=\"article\" aria-roledescription=\"slide\" id=\"slide\" aria-labelledby=\"slideheading\">\n      <h1 id=\"slideheading\">Quarterly Report</h1>\n      <!-- remaining slide contents -->\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"slide, Quarterly Report\");\n\n    await virtual.stop();\n  });\n\n  it(\"should announce the aria-roledescription in place of the role\", async () => {\n    document.body.innerHTML = `", "  it(\"should announce the aria-roledescription in place of the role\", async () => {\n    document.body.innerHTML = `\n    <article aria-roledescription=\"slide\" id=\"slide\" aria-labelledby=\"slideheading\">\n      <h1 id=\"slideheading\">Quarterly Report</h1>\n      <!-- remaining slide contents -->\n    </article>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toBe(\"slide, Quarterly Report\");\n\n    await virtual.stop();\n  });\n});\n", ""]}
{"filename": "test/int/ariaFlowTo.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Aria Flow To\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  describe(\"next\", () => {\n    it(\"should let a user navigate to a referenced element\", async () => {", "  describe(\"next\", () => {\n    it(\"should let a user navigate to a referenced element\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-flowto=\"content_2 content_3 content_4\">apple</div>\n      <div id=\"content_2\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n      <div id=\"content_4\">strawberry</div>\n      `;\n\n      await virtual.start({ container: document.body });", "\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n      await virtual.next();\n      await virtual.next();\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement\n      );", "        virtual.commands.moveToNextAlternateReadingOrderElement\n      );\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"3 alternate reading orders, 1 previous alternate reading order\",\n        \"apple\",\n        \"1 previous alternate reading order\",\n        \"banana\",\n        \"1 alternate reading order, 1 previous alternate reading order\",", "        \"banana\",\n        \"1 alternate reading order, 1 previous alternate reading order\",\n        \"3 alternate reading orders, 1 previous alternate reading order\",\n      ]);\n\n      await virtual.stop();\n    });\n\n    it(\"should let a user navigate to any referenced elements\", async () => {\n      document.body.innerHTML = `", "    it(\"should let a user navigate to any referenced elements\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-flowto=\"content_2 content_3 content_4\">apple</div>\n      <div id=\"content_2\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n      <div id=\"content_4\">strawberry</div>\n      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement\n      );\n      await virtual.previous();\n      await virtual.previous();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement,\n        { index: 1 }", "        virtual.commands.moveToNextAlternateReadingOrderElement,\n        { index: 1 }\n      );\n      await virtual.previous();\n      await virtual.previous();\n      await virtual.previous();\n      await virtual.previous();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement,\n        { index: 2 }", "        virtual.commands.moveToNextAlternateReadingOrderElement,\n        { index: 2 }\n      );\n      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"3 alternate reading orders, 1 previous alternate reading order\",\n        \"1 previous alternate reading order\",\n        \"apple\",", "        \"1 previous alternate reading order\",\n        \"apple\",\n        \"3 alternate reading orders, 1 previous alternate reading order\",\n        \"1 alternate reading order, 1 previous alternate reading order\",\n        \"banana\",\n        \"1 previous alternate reading order\",\n        \"apple\",\n        \"3 alternate reading orders, 1 previous alternate reading order\",\n        \"1 previous alternate reading order\",\n        \"strawberry\",", "        \"1 previous alternate reading order\",\n        \"strawberry\",\n      ]);\n\n      await virtual.stop();\n    });\n\n    it(\"should let a user navigate to a referenced element from an owned element\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-owns=\"content_2\">apple</div>", "      document.body.innerHTML = `\n      <div id=\"content_1\" aria-owns=\"content_2\">apple</div>\n      <div id=\"content_2\" aria-flowto=\"content_3\">banana</div>\n      <div id=\"content_3\">orange</div>\n      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n      await virtual.next();", "      await virtual.next();\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement\n      );\n      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"apple\",", "        \"document\",\n        \"apple\",\n        \"1 alternate reading order\",\n        \"banana\",\n        \"1 previous alternate reading order\",\n        \"orange\",\n      ]);\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should gracefully handle no idRefs\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-flowto=\"\">apple</div>\n      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement\n      );\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should gracefully handle invalid idRefs\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-flowto=\"invalid\">apple</div>\n      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement\n      );\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should gracefully handle trying to navigate to a next alternate reading order flow that doesn't exist\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-flowto=\"content_2\">apple</div>\n      <div id=\"content_2\">banana</div>\n      `;\n\n      await virtual.start({ container: document.body });", "\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement,\n        { index: 2 }\n      );\n      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([", "\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"1 alternate reading order\",\n        \"apple\",\n      ]);\n\n      await virtual.stop();\n    });\n", "    });\n\n    it(\"should gracefully handle no attempting to follow next alternate reading order on a non-element node\", async () => {\n      const container = document.createTextNode(\"Hello World\");\n\n      await virtual.start({ container });\n      await virtual.perform(\n        virtual.commands.moveToNextAlternateReadingOrderElement\n      );\n", "      );\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\"Hello World\"]);\n\n      await virtual.stop();\n    });\n  });\n\n  describe(\"previous\", () => {\n    it(\"should let a user navigate to an element that target the current element\", async () => {", "  describe(\"previous\", () => {\n    it(\"should let a user navigate to an element that target the current element\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-flowto=\"content_2 content_3 content_4\">apple</div>\n      <div id=\"content_2\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n      <div id=\"content_4\">strawberry</div>\n      `;\n\n      await virtual.start({ container: document.body });", "\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToPreviousAlternateReadingOrderElement\n      );\n      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",", "      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"3 alternate reading orders, 1 previous alternate reading order\",\n        \"1 alternate reading order, 1 previous alternate reading order\",\n        \"orange\",\n      ]);\n\n      await virtual.stop();\n    });\n", "    });\n\n    it(\"should let a user navigate to any element that target the current element\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\">apple</div>\n      <div id=\"content_2\" aria-flowto=\"content_1\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n      `;\n\n      await virtual.start({ container: document.body });", "\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToPreviousAlternateReadingOrderElement,\n        { index: 1 }\n      );\n      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([", "\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"2 previous alternate reading orders\",\n        \"1 alternate reading order\",\n        \"orange\",\n      ]);\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should let a user navigate to a previous alternate reading order element from an owned element\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\" aria-owns=\"content_2\">apple</div>\n      <div id=\"content_2\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_2\">orange</div>\n      `;\n", "      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToPreviousAlternateReadingOrderElement\n      );\n      await virtual.next();\n", "      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"apple\",\n        \"1 previous alternate reading order\",\n        \"1 alternate reading order\",\n        \"orange\",\n      ]);\n", "      ]);\n\n      await virtual.stop();\n    });\n\n    it(\"should gracefully handle trying to navigate to a previous alternate reading order flow that doesn't exist\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\">apple</div>\n      <div id=\"content_2\" aria-flowto=\"content_1\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>", "      <div id=\"content_2\" aria-flowto=\"content_1\">banana</div>\n      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToPreviousAlternateReadingOrderElement,\n        { index: 2 }\n      );", "        { index: 2 }\n      );\n      await virtual.next();\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\n        \"document\",\n        \"2 previous alternate reading orders\",\n        \"apple\",\n      ]);\n", "      ]);\n\n      await virtual.stop();\n    });\n\n    it(\"should gracefully handle no previous alternate reading order\", async () => {\n      document.body.innerHTML = `\n      <div id=\"content_1\">apple</div>\n      `;\n", "      `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.perform(\n        virtual.commands.moveToPreviousAlternateReadingOrderElement\n      );\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n", "      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n\n      await virtual.stop();\n    });\n\n    it(\"should gracefully handle no attempting to follow previous alternate reading order on a non-element node\", async () => {\n      const container = document.createTextNode(\"Hello World\");\n\n      await virtual.start({ container });\n      await virtual.perform(", "      await virtual.start({ container });\n      await virtual.perform(\n        virtual.commands.moveToPreviousAlternateReadingOrderElement\n      );\n\n      expect(await virtual.spokenPhraseLog()).toEqual([\"Hello World\"]);\n\n      await virtual.stop();\n    });\n  });", "    });\n  });\n});\n"]}
{"filename": "test/int/focus.int.test.ts", "chunked_list": ["import { getByText } from \"@testing-library/dom\";\nimport { virtual } from \"../../src\";\n\nfunction setupFocusChangePage() {\n  document.body.innerHTML = `\n  <div id=\"container\">\n    <button id=\"1\">1</button>\n    <button id=\"2\">2</button>\n    <label for=\"3\">3 label</label>\n    <input id=\"3\" type=\"text\" value=\"3\" />\n    <label for=\"4\">4 label</label>\n    <input id=\"4\" type=\"button\" value=\"4\" />\n    <textarea id=\"5\">5</textarea>\n    <a id=\"6\" href=\"#\">6</a>\n    <button id=\"hidden1\" aria-hidden=\"true\">hidden 1</button>\n  </div>\n  <button id=\"outside1\">outside 1</button>\n  `;\n}\n\ndescribe(\"click\", () => {\n  beforeEach(() => {\n    setupFocusChangePage();\n  });\n\n  it(\"should update the screen reader position when a node not currently active for the screen reader is focussed\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#container\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\n    getByText(container, \"4\").focus();\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 4\");\n\n    await virtual.previous();\n    await virtual.previous();\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"textbox, 3 label, 3\");\n\n    getByText(container, \"6\").focus();\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"link, 6\");\n\n    await virtual.previous();\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"end of textbox\");\n\n    await virtual.stop();\n  });\n\n  it(\"should not shift the screen reader active node if focus shifted outside the container\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#container\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\n    getByText(document.body, \"outside 1\").focus();\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\n    await virtual.stop();\n  });\n\n  it(\"should not shift the screen reader active node if focus shifted to a node hidden from screen readers\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#container\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\n    getByText(document.body, \"hidden 1\").focus();\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/type.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\nimport { virtual } from \"../../src\";\n\nfunction setupInputPage() {\n  document.body.innerHTML = `\n  <label for=\"input\">Input Some Text</label>\n  <input type=\"text\" id=\"input\" value=\"\" />\n  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n  `;\n}\n\ndescribe(\"type\", () => {\n  beforeEach(() => {\n    setupInputPage();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n", "  it(\"should type on the active element\", async () => {\n    const container = document.body;\n\n    await virtual.start({ container });\n\n    await virtual.next();\n    await virtual.next();\n\n    expect(await virtual.itemText()).toEqual(\"Input Some Text\");\n\n    await virtual.type(\"Hello World!\");\n    expect(getByRole(container, \"textbox\")).toHaveValue(\"Hello World!\");\n    expect(await virtual.itemText()).toEqual(\"Input Some Text, Hello World!\");\n\n    await virtual.stop();\n  });\n", "  it(\"should handle requests to type on hidden container gracefully\", async () => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\n    await virtual.start({ container });\n\n    await virtual.type(\"Hello World!\");\n\n    expect(await virtual.itemTextLog()).toEqual([]);\n    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/int/ariaValueNow.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\ndescribe(\"Label Priority Replacement\", () => {\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  describe(\"progressbar\", () => {\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when no range is provided\", async () => {", "  describe(\"progressbar\", () => {\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when no range is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>", "        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, current value 1%\"", "      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, current value 1%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when only aria-valuemin is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>", "      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n", "    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, min value 1, current value 1%\"\n      );\n", "      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when only aria-valuemax is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">", "      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, current value 1%\"\n      );\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when only min is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" min=\"1\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n", "      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, min value 1, current value 1%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when only max is provided\", async () => {", "\n    it(\"should announce aria-valuenow on progressbar roles as a percentage when only max is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" max=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>", "        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, current value 1%\"", "      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, current value 1%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>", "      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n", "    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, min value 1, current value 0%\"\n      );\n", "      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a non-zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">", "      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, min value 1, current value 50%\"\n      );\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a non-zero percentage rounded to at most 2 decimal places\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"0\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n", "      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, min value 0, current value 66.67%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on progressbar roles as a percentage of a range spanning across 0\", async () => {", "\n    it(\"should announce aria-valuenow on progressbar roles as a percentage of a range spanning across 0\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"-2\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>", "        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, min value -2, current value 80%\"", "      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"progressbar, Label, max value 3, min value -2, current value 80%\"\n      );\n\n      await virtual.stop();\n    });\n  });\n\n  describe(\"scrollbar\", () => {\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when no range is provided\", async () => {", "  describe(\"scrollbar\", () => {\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when no range is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>", "        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 100, min value 0, current value 1%\"", "      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 100, min value 0, current value 1%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only aria-valuemin is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>", "      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n", "    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 100, min value 1, current value 0%\"\n      );\n", "      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only aria-valuemax is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">", "      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 33.33%\"\n      );\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only min is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" min=\"1\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n", "      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 100, min value 1, current value 0%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only max is provided\", async () => {", "\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only max is provided\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" max=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>", "        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 33.33%\"", "      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 33.33%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>", "      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n", "    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value 1, current value 0%\"\n      );\n", "      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a non-zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">", "      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();", "      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value 1, current value 50%\"\n      );\n\n      await virtual.stop();\n    });", "      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a non-zero percentage rounded to at most 2 decimal places\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"0\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n", "      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 66.67%\"\n      );\n\n      await virtual.stop();\n    });\n\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage of a range spanning across 0\", async () => {", "\n    it(\"should announce aria-valuenow on scrollbar roles as a percentage of a range spanning across 0\", async () => {\n      document.body.innerHTML = `\n      <span id=\"element1\">Label</span>\n      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"-2\" aria-valuemax=\"3\">\n        <svg width=\"300\" height=\"10\">\n          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n          <rect height=\"10\" width=\"200\" fill=\"white\" />\n        </svg>\n      </span>", "        </svg>\n      </span>\n    `;\n\n      await virtual.start({ container: document.body });\n      await virtual.next();\n      await virtual.next();\n\n      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value -2, current value 80%\"", "      expect(await virtual.lastSpokenPhrase()).toBe(\n        \"scrollbar, Label, orientated vertically, max value 3, min value -2, current value 80%\"\n      );\n\n      await virtual.stop();\n    });\n  });\n});\n", ""]}
{"filename": "test/wpt/html-aam/table-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/html-aam/table-roles.html\n */\n\ndescribe(\"HTML-AAM Table Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <table data-testname=\"el-table\" data-expectedrole=\"table\" class=\"ex\">", "    document.body.innerHTML = `\n    <table data-testname=\"el-table\" data-expectedrole=\"table\" class=\"ex\">\n      <caption data-testname=\"el-caption\" data-expectedrole=\"caption\" class=\"ex\">caption</caption>\n      <thead data-testname=\"el-thead\" data-expectedrole=\"rowgroup\" class=\"ex\">\n        <tr data-testname=\"el-tr-thead\" data-expectedrole=\"row\" class=\"ex\">\n          <th data-testname=\"el-th\" data-expectedrole=\"columnheader\" class=\"ex\">a</th>\n          <th>b</th>\n          <th>c</th>\n        </tr>\n      </thead>", "        </tr>\n      </thead>\n      <tbody data-testname=\"el-tbody\" data-expectedrole=\"rowgroup\" class=\"ex\">\n        <tr data-testname=\"el-tr-tbody\" data-expectedrole=\"row\" class=\"ex\">\n          <th data-testname=\"el-th-in-row\" data-expectedrole=\"rowheader\" class=\"ex\">1</th>\n          <td data-testname=\"el-td\" data-expectedrole=\"cell\" class=\"ex\">2</td>\n          <td>3</td>\n        </tr>\n        <tr>\n          <th>4</th>", "        <tr>\n          <th>4</th>\n          <td>5</td>\n          <td>6</td>\n        </tr>\n      </tbody>\n      <tfoot data-testname=\"el-tfoot\" data-expectedrole=\"rowgroup\" class=\"ex\">\n        <tr>\n          <th>x</th>\n          <th>y</th>", "          <th>x</th>\n          <th>y</th>\n          <th>z</th>\n        </tr>\n      </tfoot>\n    </table>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"table, caption\",\n      \"caption\",\n      \"rowgroup\",\n      \"row, a b c\",\n      \"columnheader, a\",\n      \"columnheader, b\",\n      \"columnheader, c\",\n      \"end of row, a b c\",\n      \"end of rowgroup\",\n      \"rowgroup\",\n      \"row, 1 2 3\",\n      \"columnheader, 1\",\n      \"cell, 2\",\n      \"cell, 3\",\n      \"end of row, 1 2 3\",\n      \"row, 4 5 6\",\n      \"columnheader, 4\",\n      \"cell, 5\",\n      \"cell, 6\",\n      \"end of row, 4 5 6\",\n      \"end of rowgroup\",\n      \"rowgroup\",\n      \"row, x y z\",\n      \"columnheader, x\",\n      \"columnheader, y\",\n      \"columnheader, z\",\n      \"end of row, x y z\",\n      \"end of rowgroup\",\n      \"end of table, caption\",\n      \"end of document\",\n    ]);\n  });\n});\n", "    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"table, caption\",\n      \"caption\",\n      \"rowgroup\",\n      \"row, a b c\",\n      \"columnheader, a\",\n      \"columnheader, b\",\n      \"columnheader, c\",\n      \"end of row, a b c\",\n      \"end of rowgroup\",\n      \"rowgroup\",\n      \"row, 1 2 3\",\n      \"columnheader, 1\",\n      \"cell, 2\",\n      \"cell, 3\",\n      \"end of row, 1 2 3\",\n      \"row, 4 5 6\",\n      \"columnheader, 4\",\n      \"cell, 5\",\n      \"cell, 6\",\n      \"end of row, 4 5 6\",\n      \"end of rowgroup\",\n      \"rowgroup\",\n      \"row, x y z\",\n      \"columnheader, x\",\n      \"columnheader, y\",\n      \"columnheader, z\",\n      \"end of row, x y z\",\n      \"end of rowgroup\",\n      \"end of table, caption\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/html-aam/roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/html-aam/roles.html\n */\n\ndescribe(\"HTML-AAM Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <!-- Most test names correspond to unique ID defined in the https://w3c.github.io/html-aam/ spec. -->", "    document.body.innerHTML = `\n    <!-- Most test names correspond to unique ID defined in the https://w3c.github.io/html-aam/ spec. -->\n\n    <a href=\"#\" data-testname=\"el-a\" data-expectedrole=\"link\" class=\"ex\">x</a>\n    <a data-testname=\"el-a-no-href\" data-expectedrole=\"generic\" class=\"ex\">x</a>\n    <!-- todo: abbr -->\n    <address data-testname=\"el-address\" data-expectedrole=\"group\" class=\"ex\">x</address>\n    <!-- area -> ./fragile/area-role.html -->\n    <article data-testname=\"el-article\" data-expectedrole=\"article\" class=\"ex\">x</article>\n", "    <article data-testname=\"el-article\" data-expectedrole=\"article\" class=\"ex\">x</article>\n\n    <!-- el-aside -->\n    <nav>\n      <aside data-testname=\"el-aside-in-section-with-name\" data-expectedrole=\"complementary\" aria-label=\"x\" class=\"ex\">x</aside>\n      <aside data-testname=\"el-aside-in-section-without-name\" data-expectedrole=\"generic\" class=\"ex\">x</aside>\n    </nav>\n    <aside data-testname=\"el-aside-ancestorbodymain\" data-expectedrole=\"complementary\" class=\"ex\">x</aside>\n\n    <!-- todo: audio -->", "\n    <!-- todo: audio -->\n    <!-- todo: autonomous custom element -->\n    <b data-testname=\"el-b\" data-expectedrole=\"generic\" class=\"ex\">x</b>\n    <!-- base (not mapped) -->\n    <bdi data-testname=\"el-bdi\" data-expectedrole=\"generic\" class=\"ex\">x</bdi>\n    <bdo data-testname=\"el-bdo\" data-expectedrole=\"generic\" class=\"ex\">x</bdo>\n    <blockquote data-testname=\"el-blockquote\" data-expectedrole=\"blockquote\" class=\"ex\">x</blockquote>\n    <!-- todo: body -->\n    <!-- br (not mapped) -->", "    <!-- todo: body -->\n    <!-- br (not mapped) -->\n    <button data-testname=\"el-button\" data-expectedrole=\"button\" class=\"ex\">x</button>\n    <!-- todo: canvas -->\n    <!-- caption -> ./table-roles.html -->\n    <!-- todo: cite -->\n    <code data-testname=\"el-code\" data-expectedrole=\"code\" class=\"ex\">x</code>\n    <!-- todo: col -->\n    <!-- todo: colgroup -->\n    <data value=\"1\" data-testname=\"el-data\" data-expectedrole=\"generic\" class=\"ex\">x</data>", "    <!-- todo: colgroup -->\n    <data value=\"1\" data-testname=\"el-data\" data-expectedrole=\"generic\" class=\"ex\">x</data>\n    <!-- todo: datalist -->\n\n    <!-- el-dd -->\n    <dl>\n      <dt>x</dt>\n      <dd data-testname=\"el-dd\" data-expectedrole=\"definition\" class=\"ex\">x</dd>\n    </dl>\n", "    </dl>\n\n    <del data-testname=\"el-del\" data-expectedrole=\"deletion\" class=\"ex\">x</del>\n    <details data-testname=\"el-details\" data-expectedrole=\"group\" class=\"ex\"><summary>x</summary>x</details>\n    <dfn data-testname=\"el-dfn\" data-expectedrole=\"term\" class=\"ex\">x</dfn>\n    <div open data-testname=\"el-div\" data-expectedrole=\"generic\" class=\"ex\">x</div>\n    <!-- todo: dl -->\n\n    <!-- el-dt -->\n    <dl>", "    <!-- el-dt -->\n    <dl>\n      <dt data-testname=\"el-dt\" data-expectedrole=\"term\" class=\"ex\">x</dt>\n      <dd>x</dd>\n    </dl>\n\n    <em data-testname=\"el-em\" data-expectedrole=\"emphasis\" class=\"ex\">x</em>\n    <!-- todo: embed -->\n    <fieldset data-testname=\"el-fieldset\" data-expectedrole=\"group\" class=\"ex\"><legend>x</legend><input></fieldset>\n    <!-- todo: figcaption -->", "    <fieldset data-testname=\"el-fieldset\" data-expectedrole=\"group\" class=\"ex\"><legend>x</legend><input></fieldset>\n    <!-- todo: figcaption -->\n    <figure data-testname=\"el-figure\" data-expectedrole=\"figure\" class=\"ex\"><img src=\"#\" alt=\"x\"><figcaption>x</figcaption></figure>\n\n    <!-- el-footer -->\n    <nav>\n      <footer data-testname=\"el-footer\" data-expectedrole=\"generic\" aria-label=\"x\" class=\"ex\">x</aside>\n    </nav>\n    <footer data-testname=\"el-footer-ancestorbody\" data-expectedrole=\"contentinfo\" class=\"ex\">x</footer>\n", "    <footer data-testname=\"el-footer-ancestorbody\" data-expectedrole=\"contentinfo\" class=\"ex\">x</footer>\n\n    <form data-testname=\"el-form\" data-expectedrole=\"form\" class=\"ex\"><input></form>\n    <!-- todo: form-associated custom element -->\n\n    <!-- el-h1-h6 -->\n    <h1 data-testname=\"el-h1\" data-expectedrole=\"heading\" class=\"ex\">x</h1>\n    <h2 data-testname=\"el-h2\" data-expectedrole=\"heading\" class=\"ex\">x</h2>\n    <h3 data-testname=\"el-h3\" data-expectedrole=\"heading\" class=\"ex\">x</h3>\n    <h4 data-testname=\"el-h4\" data-expectedrole=\"heading\" class=\"ex\">x</h4>", "    <h3 data-testname=\"el-h3\" data-expectedrole=\"heading\" class=\"ex\">x</h3>\n    <h4 data-testname=\"el-h4\" data-expectedrole=\"heading\" class=\"ex\">x</h4>\n    <h5 data-testname=\"el-h5\" data-expectedrole=\"heading\" class=\"ex\">x</h5>\n    <h6 data-testname=\"el-h6\" data-expectedrole=\"heading\" class=\"ex\">x</h6>\n\n    <!-- head (not mapped) -->\n\n    <!-- el-header -->\n    <nav>\n      <header data-testname=\"el-header\" data-expectedrole=\"generic\" aria-label=\"x\" class=\"ex\">x</header>", "    <nav>\n      <header data-testname=\"el-header\" data-expectedrole=\"generic\" aria-label=\"x\" class=\"ex\">x</header>\n    </nav>\n    <header data-testname=\"el-header-ancestorbody\" data-expectedrole=\"banner\" class=\"ex\">x</header>\n\n    <hgroup data-testname=\"el-hgroup\" data-expectedrole=\"group\" class=\"ex\"><h1>x</h1></hgroup>\n    <hr data-testname=\"el-hr\" data-expectedrole=\"separator\" class=\"ex\">\n    <!-- todo: html -->\n    <i data-testname=\"el-i\" data-expectedrole=\"generic\" class=\"ex\">x</i>\n    <!-- todo: iframe -->", "    <i data-testname=\"el-i\" data-expectedrole=\"generic\" class=\"ex\">x</i>\n    <!-- todo: iframe -->\n    <img src=\"#\" alt=\"x\" data-testname=\"el-img\" data-expectedrole=\"image\" class=\"ex\">\n\n    <!-- Implementations might also be valid if ignored rather than returning 'none' for the following images. -->\n    <img src=\"#\" alt data-testname=\"el-img-alt-no-value\" data-expectedrole=\"none\" class=\"ex\">\n    <img src=\"#\" alt=\"\" data-testname=\"el-img-empty-alt\" data-expectedrole=\"none\" class=\"ex\">\n\n    <input type=\"button\" value=\"x\" data-testname=\"el-input-button\" data-expectedrole=\"button\" class=\"ex\">\n    <input type=\"checkbox\" data-testname=\"el-input-checkbox\" data-expectedrole=\"checkbox\" class=\"ex\">", "    <input type=\"button\" value=\"x\" data-testname=\"el-input-button\" data-expectedrole=\"button\" class=\"ex\">\n    <input type=\"checkbox\" data-testname=\"el-input-checkbox\" data-expectedrole=\"checkbox\" class=\"ex\">\n    <!-- todo: input type=\"color\" -->\n    <!-- todo: input type=\"date\" -->\n    <!-- todo: input type=\"datetime\" -->\n    <!-- todo: input type=\"datetime-local\" -->\n    <input type=\"email\" data-testname=\"el-input-email\" data-expectedrole=\"textbox\" class=\"ex\">\n    <!-- todo: input type=\"file\" -->\n    <!-- input type=\"hidden\" (not mapped) -->\n    <!-- todo: input type=\"month\" -->", "    <!-- input type=\"hidden\" (not mapped) -->\n    <!-- todo: input type=\"month\" -->\n\n    <!-- Blocked: HTML-AAM Issue #467 -->\n    <!-- <input type=\"number\" data-testname=\"el-input-number\" data-expectedrole=\"spinbutton\" class=\"ex\"> -->\n\n    <!-- todo: input type=\"password\" -->\n    <input type=\"radio\" data-testname=\"el-input-radio\" data-expectedrole=\"radio\" class=\"ex\">\n    <input type=\"range\" data-testname=\"el-input-range\" data-expectedrole=\"slider\" class=\"ex\">\n    <input type=\"reset\" value=\"x\" data-testname=\"el-input-reset\" data-expectedrole=\"button\" class=\"ex\">", "    <input type=\"range\" data-testname=\"el-input-range\" data-expectedrole=\"slider\" class=\"ex\">\n    <input type=\"reset\" value=\"x\" data-testname=\"el-input-reset\" data-expectedrole=\"button\" class=\"ex\">\n    <input type=\"search\" data-testname=\"el-input-search\" data-expectedrole=\"searchbox\" class=\"ex\">\n    <input type=\"submit\" value=\"x\" data-testname=\"el-input-submit\" data-expectedrole=\"button\" class=\"ex\">\n    <input type=\"tel\" data-testname=\"el-input-tel\" data-expectedrole=\"textbox\" class=\"ex\">\n    <input type=\"text\" data-testname=\"el-input-text\" data-expectedrole=\"textbox\" class=\"ex\">\n    <!-- todo: input (type attribute in the Text, Search, Telephone, URL, or E-mail states with a suggestions source element) -->\n    <!-- todo: input type=\"time\" -->\n    <input type=\"url\" data-testname=\"el-input-url\" data-expectedrole=\"textbox\" class=\"ex\">\n    <!-- todo: input type=\"week\" -->\n    <ins data-testname=\"el-ins\" data-expectedrole=\"insertion\" class=\"ex\">x</ins>\n    <!-- todo: kbd -->\n    <!-- todo: label -->\n    <!-- todo: legend -->\n\n    <!-- el-li -->\n    <li data-testname=\"el-li-orphaned\" data-expectedrole=\"generic\" class=\"ex\">x</li>\n    <ul><li data-testname=\"el-li-in-ul\" data-expectedrole=\"listitem\" class=\"ex\">x</li><li>x</li></ul>\n    <ol><li data-testname=\"el-li-in-ol\" data-expectedrole=\"listitem\" class=\"ex\">x</li><li>x</li></ol>\n\n    <!-- link (not mapped) -->\n    <main data-testname=\"el-main\" data-expectedrole=\"main\" class=\"ex\">x</main>\n    <!-- map (not mapped) -->\n    <mark data-testname=\"el-mark\" data-expectedrole=\"mark\" class=\"ex\">x</mark>\n    <!-- todo: math -->\n    <menu data-testname=\"el-menu\" data-expectedrole=\"list\" class=\"ex\"><li>x</li></menu>\n    <!-- meta (not mapped) -->\n    <meter data-testname=\"el-meter\" data-expectedrole=\"meter\" class=\"ex\" min=\"0\" max=\"100\" low=\"20\" high=\"80\" optimum=\"60\" value=\"50\">x</meter>\n    <nav data-testname=\"el-nav\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <!-- noscript (not mapped) -->\n    <!-- object (not mapped) -->\n    <ol data-testname=\"el-ol\" data-expectedrole=\"list\" class=\"ex\"><li>x</li><li>x</li></ol>\n\n    <!-- optgroup -> ./fragile/optgroup-role.html -->\n\n    <!-- option -->\n    <select>\n      <option data-testname=\"el-option\" data-expectedrole=\"option\" class=\"ex\">x</option>\n      <option>x</option>\n    </select>\n\n    <output data-testname=\"el-output\" data-expectedrole=\"status\" class=\"ex\">x</output>\n    <p data-testname=\"el-p\" data-expectedrole=\"paragraph\" class=\"ex\">x</p>\n    <!-- param (not mapped) -->\n    <!-- todo: picture -->\n    <pre data-testname=\"el-pre\" data-expectedrole=\"generic\" class=\"ex\">x</pre>\n    <progress data-testname=\"el-progress\" data-expectedrole=\"progressbar\" class=\"ex\">x</progress>\n    <q data-testname=\"el-q\" data-expectedrole=\"generic\" class=\"ex\">x</q>\n    <!-- todo: rp -> /ruby-aam? -->\n    <!-- todo: rt -> /ruby-aam? -->\n    <!-- todo: ruby -> /ruby-aam? -->\n    <s data-testname=\"el-s\" data-expectedrole=\"deletion\" class=\"ex\">x</s>\n    <samp data-testname=\"el-samp\" data-expectedrole=\"generic\" class=\"ex\">x</samp>\n    <!-- script (not mapped) -->\n    <search data-testname=\"el-search\" data-expectedrole=\"search\" class=\"ex\">x</search>\n\n    <!-- el-section -->\n    <section data-testname=\"el-section\" aria-label=\"x\" data-expectedrole=\"region\" class=\"ex\">x</section>\n    <section data-testname=\"el-section-no-name\" data-expectedrole=\"generic\" class=\"ex\">x</section>\n\n    <!-- Blocked: HTML-AAM Issue #467 -->\n    <!-- <select data-testname=\"el-select-combobox\" data-expectedrole=\"combobox\" class=\"ex\"><option>a1</option><option>a2</option></select>-->\n\n    <select data-testname=\"el-select-listbox\" size=\"2\" data-expectedrole=\"listbox\" class=\"ex\"><option>b1</option><option>b2</option></select>\n\n    <!-- slot (not mapped) -->\n    <small data-testname=\"el-small\" data-expectedrole=\"generic\" class=\"ex\">x</small>\n    <!-- source (not mapped) -->\n    <span data-testname=\"el-span\" data-expectedrole=\"generic\" class=\"ex\">x</span>\n    <strong data-testname=\"el-strong\" data-expectedrole=\"strong\" class=\"ex\">x</strong>\n    <!-- style (not mapped) -->\n    <sub data-testname=\"el-sub\" data-expectedrole=\"subscript\" class=\"ex\">x</sub>\n    <!-- todo: summary -->\n    <sup data-testname=\"el-sup\" data-expectedrole=\"superscript\" class=\"ex\">x</sup>\n    <!-- todo: svg (see /graphics-aam and /svg-aam tests) -->\n    <!-- table -> ./table-roles.html -->\n    <!-- tbody -> ./table-roles.html -->\n    <!-- td -> ./table-roles.html -->\n    <!-- template (not mapped) -->\n    <!-- tfoot -> ./table-roles.html -->\n    <!-- th -> ./table-roles.html -->\n    <!-- thead -> ./table-roles.html -->\n    <time data-testname=\"el-time\" data-expectedrole=\"time\" class=\"ex\">x</time>\n    <!-- title (not mapped) -->\n    <!-- tr -> ./table-roles.html -->\n    <textarea data-testname=\"el-textarea\" data-expectedrole=\"textbox\" class=\"ex\">x</textarea>\n    <!-- track (not mapped) -->\n    <u data-testname=\"el-u\" data-expectedrole=\"generic\" class=\"ex\">x</u>\n    <ul data-testname=\"el-ul\" data-expectedrole=\"list\" class=\"ex\"><li>x</li><li>x</li></ul>\n    <!-- var (not mapped) -->\n    <!-- todo: video -->\n    <!-- wbr (not mapped) -->\n    `;\n\n    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"link, x\",\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // TODO: FAIL address should have role group\n      \"article\",\n      \"x\",\n      \"end of article\",\n      \"navigation\",\n      \"complementary, x\",\n      \"complementary\",\n      \"x\",\n      \"end of complementary\",\n      \"end of navigation\",\n      \"complementary\",\n      \"x\",\n      \"end of complementary\",\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // TODO: FAIL blockquote should have role blockquote\n      \"button, x\",\n      \"x\", // TODO: FAIL code should have role code\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"term\",\n      \"x\",\n      \"end of term\",\n      \"definition\",\n      \"x\",\n      \"end of definition\",\n      \"x\", // TODO: FAIL del should have role deletion\n      \"group\",\n      \"button, x\",\n      \"x\",\n      \"end of group\",\n      \"term\",\n      \"x\",\n      \"end of term\",\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"term\",\n      \"x\",\n      \"end of term\",\n      \"definition\",\n      \"x\",\n      \"end of definition\",\n      \"x\", // TODO: FAIL em should have role emphasis\n      \"group, x\",\n      \"figure\",\n      \"img, x\",\n      \"x\",\n      \"end of figure\",\n      \"navigation\",\n      \"contentinfo, x\",\n      \"end of navigation\",\n      \"contentinfo\",\n      \"x\",\n      \"end of contentinfo\",\n      \"form\",\n      \"textbox\",\n      \"end of form\",\n      \"heading, x, level 1\",\n      \"heading, x, level 2\",\n      \"heading, x, level 3\",\n      \"heading, x, level 4\",\n      \"heading, x, level 5\",\n      \"heading, x, level 6\",\n      \"navigation\",\n      \"banner, x\", // TODO: FAIL header role should be generic\n      \"end of navigation\",\n      \"banner\",\n      \"x\",\n      \"end of banner\",\n      \"heading, x, level 1\", // TODO: FAIL hgroup missing role\n      \"separator, orientated horizontally, max value 100, min value 0\",\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"img, x\", // TODO: FAIL img role should be image\n      // PASS on missing img entry\n      // PASS on missing img entry\n      \"button, x\",\n      \"checkbox\",\n      \"textbox\",\n      \"radio\",\n      \"slider, 50, orientated horizontally, max value 100, min value 0\",\n      \"button, x\",\n      \"searchbox\",\n      \"button, x\",\n      \"textbox\",\n      \"textbox\",\n      \"textbox\",\n      \"x\", // TODO: FAIL ins missing insertion role\n      \"listitem\", // TODO: FAIL orphaned li should not be announced\n      \"x\",\n      \"end of listitem\",\n      \"list\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n      \"list\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n      \"main\",\n      \"x\",\n      \"end of main\",\n      \"x\", // TODO: FAIL mark should have mark role\n      \"list\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n      \"x\", // TODO: FAIL meter should have meter role\n      \"navigation\",\n      \"x\",\n      \"end of navigation\",\n      \"list\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n      \"combobox, x, not expanded, has popup listbox\",\n      \"option, x, not selected\",\n      \"option, x, not selected\",\n      \"end of combobox, x, not expanded, has popup listbox\",\n      \"status\",\n      \"x\",\n      \"end of status\",\n      \"x\", // TODO: FAIL p should have paragraph role\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"progressbar, 0\",\n      \"x\",\n      \"end of progressbar, 0\",\n      \"x\",\n      \"x\", // TODO: FAIL s should have deletion role\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // TODO: FAIL search should have search role\n      \"region, x\",\n      \"region\", // TODO: FAIL section with no name should be generic\n      \"x\",\n      \"end of region\",\n      \"listbox, orientated vertically\",\n      \"option, b1, not selected\",\n      \"option, b2, not selected\",\n      \"end of listbox, orientated vertically\",\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"x\", // TODO: FAIL strong should have strong role\n      \"x\", // TODO: FAIL sub should have subscript role\n      \"x\", // TODO: FAIL sup should have superscript role\n      \"x\", // TODO: FAIL time should have time role\n      \"textbox\",\n      \"x\",\n      \"end of textbox\",\n      \"x\", // WONTFIX generic ignored by screen readers\n      \"list\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/fallback-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/fallback-roles.html\n *\n * Verifies Fallback Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n * 9.1 Roles - handling author errors\n */\n\ndescribe(\"Fallback Role Verification Tests\", () => {", "\ndescribe(\"Fallback Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <navigation role=\"region group\" data-testname=\"fallback role w/ region with no label\" data-expectedrole=\"group\" class=\"ex\">x</navigation>\n    <navigation role=\"region group\" data-testname=\"fallback role w/ region with label\" aria-label=\"x\" data-expectedrole=\"region\" class=\"ex\">x</navigation>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();", "    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    // Group\n    await virtual.next();\n    await virtual.next();\n\n    // Region\n    await virtual.next();\n  });", "    await virtual.next();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {", "\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"group\",\n      \"x\",\n      \"end of group\",\n      \"region, x\",\n    ]);\n  });", "    ]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/list-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/list-roles.html\n *\n * Verifies Invalid Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n * 9.1 Roles - handling author errors\n */\n\ndescribe(\"List-related Role Verification Tests\", () => {", "\ndescribe(\"List-related Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div role=\"list\" data-testname=\"first simple list\" data-expectedrole=\"list\" class=\"ex\">\n      <div role=\"listitem\" data-testname=\"first simple listitem\" data-expectedrole=\"listitem\" class=\"ex\">x</div>\n      <div role=\"listitem\" data-testname=\"last simple listitem\" data-expectedrole=\"listitem\" class=\"ex\">x</div>\n    </div>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";", "\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"list\",\n      \"listitem\",\n      \"x\",", "      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n    ]);\n  });\n});", "  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/region-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/region-roles.html\n *\n * Verifies Invalid Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n * 9.1 Roles - handling author errors\n */\n\ndescribe(\"Region Role Verification Tests\", () => {", "\ndescribe(\"Region Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <!-- no label -->\n    <nav role=\"region\" data-testname=\"region without label\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\n    <!-- w/ label -->\n    <nav role=\"region\" data-testname=\"region with label\" data-expectedrole=\"region\" aria-label=\"x\" class=\"ex\">x</nav>\n    `;", "    <nav role=\"region\" data-testname=\"region with label\" data-expectedrole=\"region\" aria-label=\"x\" class=\"ex\">x</nav>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n\n    // Navigation\n    await virtual.next();\n    await virtual.next();\n", "    await virtual.next();\n\n    // Region\n    await virtual.next();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";", "\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"x\",\n      \"end of navigation\",", "      \"x\",\n      \"end of navigation\",\n      \"region, x\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/role_non_conflict_resolution.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/role_none_conflict_resolution.html\n *\n * Verifies https://w3c.github.io/aria/#conflict_resolution_presentation_none\n * conflict resolution requirements for the ARIA none and presentation roles.\n */\n\ndescribe(\"Role None Conflict Resolution Verification Tests\", () => {", "\ndescribe(\"Role None Conflict Resolution Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <!-- none with label(global) on header -->\n    <h1 role=\"none\" data-testname=\"heading role none with global attr aria-label\" data-expectedrole=\"heading\" aria-label=\"x\" class=\"ex\">x</h1>\n\n    <!-- none with label(global) on paragraph -->\n    <p role=\"none\" data-testname=\"p role none with global attr aria-label (prohibited role)\" data-expectedrole=\"paragraph\" aria-label=\"x\" class=\"ex\">x</p>\n    <p role=\"none\" data-testname=\"p role none without global attr aria-label (prohibited role)\" data-expectedrole=\"none\" class=\"ex\">x</p>", "    <p role=\"none\" data-testname=\"p role none with global attr aria-label (prohibited role)\" data-expectedrole=\"paragraph\" aria-label=\"x\" class=\"ex\">x</p>\n    <p role=\"none\" data-testname=\"p role none without global attr aria-label (prohibited role)\" data-expectedrole=\"none\" class=\"ex\">x</p>\n\n    <!-- none with focusable header -->\n    <h1 role=\"none\" data-testname=\"focusable heading role none with tabindex=0\" data-expectedrole=\"heading\" tabindex=\"0\" class=\"ex\">x</h1>\n    <h1 role=\"none\" data-testname=\"focusable heading role none with tabindex=-1\" data-expectedrole=\"heading\" tabindex=\"-1\" class=\"ex\">x</h1>\n    <h1 role=\"none\" data-testname=\"non-focusable heading role none\" data-expectedrole=\"none\" class=\"ex\">x</h1>\n\n    <!-- none with non-global-->\n    <h1 role=\"none\" data-testname=\"none with non-global\" data-expectedrole=\"none\" class=\"ex\" aria-level=\"2\"> Sample Content </h1>", "    <!-- none with non-global-->\n    <h1 role=\"none\" data-testname=\"none with non-global\" data-expectedrole=\"none\" class=\"ex\" aria-level=\"2\"> Sample Content </h1>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n  });\n", "  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([", "  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"heading, x, level 1\",\n      /**\n       * Invalid as of Aria 1.2, see https://www.w3.org/TR/wai-aria-1.2/#paragraph.\n       * Awaiting new release of dom-accessibility-api / aria-query dependencies\n       * \"paragraph, x\"\n       */\n      \"x\",", "       */\n      \"x\",\n      \"x\",\n      \"heading, level 1\",\n      \"x\",\n      \"end of heading, level 1\",\n      \"heading, level 1\",\n      \"x\",\n      \"end of heading, level 1\",\n      \"x\",", "      \"end of heading, level 1\",\n      \"x\",\n      \"Sample Content\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/invalid-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/invalid-roles.html\n *\n * Verifies Invalid Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n * 9.1 Roles - handling author errors\n */\n\ndescribe(\"Invalid Role Verification Tests\", () => {", "\ndescribe(\"Invalid Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <nav role=\"foo\" data-testname=\"invalid role name foo\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"foo bar\" data-testname=\"multiple invalid role names\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    for (let i = 0; i < document.body.querySelectorAll(\"nav\").length * 3; i++) {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    const expected = [\n      ...new Array(document.body.querySelectorAll(\"nav\").length),\n    ].flatMap(() => [\"navigation\", \"x\", \"end of navigation\"]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", ...expected]);\n  });\n});\n", "    await virtual.start({ container: document.body });\n\n    for (let i = 0; i < document.body.querySelectorAll(\"nav\").length * 3; i++) {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    const expected = [\n      ...new Array(document.body.querySelectorAll(\"nav\").length),\n    ].flatMap(() => [\"navigation\", \"x\", \"end of navigation\"]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", ...expected]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/basic.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/basic.html\n */\n\ndescribe(\"Basic Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div id='d' style='height: 100px; width: 100px' role=\"group\" aria-label=\"test label\"></div>", "    document.body.innerHTML = `\n    <div id='d' style='height: 100px; width: 100px' role=\"group\" aria-label=\"test label\"></div>\n    <h1 id=\"h\">test heading</h1>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n  });\n\n  afterEach(async () => {", "\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests explicit role\", async () => {\n    expect(await virtual.lastSpokenPhrase()).toEqual(\"group, test label\");\n  });", "    expect(await virtual.lastSpokenPhrase()).toEqual(\"group, test label\");\n  });\n\n  test(\"tests implicit role\", async () => {\n    await virtual.next();\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\n      \"heading, test heading, level 1\"\n    );\n  });", "    );\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/synonym-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/synonym-roles.html\n *\n * spec resolution https://github.com/w3c/core-aam/issues/166\n */\n\ndescribe(\"Synonym Role Verification Tests\", () => {\n  beforeEach(async () => {", "describe(\"Synonym Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div role=\"none\" id=\"none\" data-expectedrole=\"none\" data-testname=\"none role == computedrole none\" class=\"ex\">x</div><!-- preferred -->\n    <div role=\"presentation\" id=\"presentation\" data-expectedrole=\"none\" data-testname=\"synonym presentation role == computedrole none\" class=\"ex\">x</div><!-- synonym -->\n\n    <!-- image role due ARIA 1.3 -->\n    <!-- <div role=\"image\" id=\"image\" data-expectedrole=\"image\" data-testname=\"image role == computedrole image\" class=\"ex\">x</div> --> <!-- preferred -->\n    <div role=\"img\" id=\"img\" data-expectedrole=\"image\" data-testname=\"synonym img role == computedrole image\" class=\"ex\">x</div><!-- synonym -->\n", "    <div role=\"img\" id=\"img\" data-expectedrole=\"image\" data-testname=\"synonym img role == computedrole image\" class=\"ex\">x</div><!-- synonym -->\n\n    <!-- \\`directory\\` synonym deprecated in ARIA 1.2; these examples should all return computedrole \\`list\\` -->\n    <ul role=\"list\" id=\"list2\" data-expectedrole=\"list\" data-testname=\"list role == computedrole list\" class=\"ex\"><li>x</li></ul>\n    <ul role=\"directory\" id=\"directory\" data-expectedrole=\"list\" data-testname=\"directory role == computedrole list\" class=\"ex\"><li>x</li></ul>\n    <div role=\"directory\" id=\"div\" data-expectedrole=\"list\" data-testname=\"div w/directory role == computedrole list\" class=\"ex\"><div role=\"listitem\">x</div></div>\n    `;\n\n    await virtual.start({ container: document.body });\n", "    await virtual.start({ container: document.body });\n\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();", "  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"x\",", "      \"document\",\n      \"x\",\n      \"x\",\n      \"img\",\n      \"x\",\n      \"end of img\",\n      \"list\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",", "      \"x\",\n      \"end of listitem\",\n      \"end of list\",\n      /**\n       * `directory` alias deprecated in https://www.w3.org/TR/wai-aria-1.2/#directory\n       */\n      \"directory\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",", "      \"x\",\n      \"end of listitem\",\n      \"end of directory\",\n      \"directory\",\n      \"listitem\",\n      \"x\",\n      \"end of listitem\",\n      \"end of directory\",\n    ]);\n  });", "    ]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/abstract-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/abstract-roles.html\n *\n * Verifies https://w3c.github.io/aria/#document-handling_author-errors_roles\n * 9.1 Roles - handling author errors\n */\n\ndescribe(\"Abstract Role Verification Tests\", () => {", "\ndescribe(\"Abstract Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <nav role=\"command\" data-testname=\"command role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"composite\" data-testname=\"composite role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"input\" data-testname=\"input role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"landmark\" data-testname=\"landmark role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"range\" data-testname=\"range role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"roletype\" data-testname=\"roletype role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>", "    <nav role=\"range\" data-testname=\"range role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"roletype\" data-testname=\"roletype role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"section\" data-testname=\"section role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"sectionhead\" data-testname=\"sectionhead role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"select\" data-testname=\"select role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"structure\" data-testname=\"structure role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"widget\" data-testname=\"widget role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    <nav role=\"window\" data-testname=\"window role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    `;\n", "    `;\n\n    await virtual.start({ container: document.body });\n\n    for (let i = 0; i < document.body.querySelectorAll(\"nav\").length * 3; i++) {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {\n    const expected = [\n      ...new Array(document.body.querySelectorAll(\"nav\").length),\n    ].flatMap(() => [\"navigation\", \"x\", \"end of navigation\"]);\n\n    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", ...expected]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/form-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/form-roles.html\n *\n * Verifies https://w3c.github.io/aria/#document-handling_author-errors_roles\n * 9.1 Roles - handling author errors and the form role.\n */\n\ndescribe(\"Form Role Verification Tests\", () => {", "\ndescribe(\"Form Role Verification Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <!-- no label -->\n    <nav role=\"form\" data-testname=\"form without label\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n    \n    <!-- w/ label -->\n    <nav role=\"form\" data-testname=\"form with label\" data-expectedrole=\"form\" aria-label=\"x\" class=\"ex\">x</nav>\n    `;", "    <nav role=\"form\" data-testname=\"form with label\" data-expectedrole=\"form\" aria-label=\"x\" class=\"ex\">x</nav>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n    await virtual.next();\n  });", "    await virtual.next();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"verifies roles\", async () => {", "\n  test(\"verifies roles\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"navigation\",\n      \"x\",\n      \"end of navigation\",\n      \"form, x\",\n    ]);\n  });", "    ]);\n  });\n});\n"]}
{"filename": "test/wpt/wai-aria/role/roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/roles.html\n *\n * Tests simple role assignment: <div role=\"alert\">x</div>\n *\n * - Nested role structures (table>row>cell, etc) and Abstract roles (e.g.\n *   widget, composite) are commented with pointers to a separate test file.\n *", " *   widget, composite) are commented with pointers to a separate test file.\n *\n * - ARIA extension specs (e.g. doc-*, graphics-*) are commented with pointers\n *   to a separate spec directory.\n */\n\n/**\n * https://w3c.github.io/aria/#namefromcontent\n */\nfunction allowsNameFromContent(node: Element): boolean {\n  return [\n    \"button\",\n    \"cell\",\n    \"checkbox\",\n    \"columnheader\",\n    \"gridcell\",\n    \"heading\",\n    \"label\",\n    \"legend\",\n    \"link\",\n    \"menuitem\",\n    \"menuitemcheckbox\",\n    \"menuitemradio\",\n    \"option\",\n    \"radio\",\n    \"row\",\n    \"rowheader\",\n    \"switch\",\n    \"tab\",\n    \"tooltip\",\n    \"treeitem\",\n  ].includes(node.getAttribute(\"role\") ?? \"\");\n}\n", " */\nfunction allowsNameFromContent(node: Element): boolean {\n  return [\n    \"button\",\n    \"cell\",\n    \"checkbox\",\n    \"columnheader\",\n    \"gridcell\",\n    \"heading\",\n    \"label\",\n    \"legend\",\n    \"link\",\n    \"menuitem\",\n    \"menuitemcheckbox\",\n    \"menuitemradio\",\n    \"option\",\n    \"radio\",\n    \"row\",\n    \"rowheader\",\n    \"switch\",\n    \"tab\",\n    \"tooltip\",\n    \"treeitem\",\n  ].includes(node.getAttribute(\"role\") ?? \"\");\n}\n", "function defaultAriaAttributes(role) {\n  switch (role) {\n    case \"combobox\": {\n      return \", not expanded, has popup listbox\";\n    }\n    case \"heading\": {\n      return \", level 2\";\n    }\n    case \"meter\": {\n      return \", max value 100, min value 0\";\n    }\n    case \"scrollbar\": {\n      return \", orientated vertically, max value 100, min value 0\";\n    }\n    case \"separator\": {\n      return \", orientated horizontally, max value 100, min value 0\";\n    }\n    case \"slider\": {\n      return \", orientated horizontally, max value 100, min value 0\";\n    }\n    case \"spinbutton\": {\n      return \", 0\";\n    }\n    case \"toolbar\": {\n      return \", orientated horizontally\";\n    }\n  }\n\n  return \"\";\n}\n\ndescribe(\"Simple Core ARIA Role Verification Tests\", () => {\n  test.each([\n    \"alert\",\n    \"alertdialog\",\n    \"application\",\n    \"article\",\n    // \"associationlist\" [AT-RISK: ARIA #1662] or possibly -> ./list-roles.html\n    // \"associationlistitemkey\" [AT-RISK: ARIA #1662] or possibly -> ./list-roles.html\n    // \"associationlistitemvalue\" [AT-RISK: ARIA #1662] or possibly -> ./list-roles.html\n    \"banner\",\n    \"blockquote\",\n    \"button\",\n    \"caption\",\n    // \"cell\" -> ./grid-roles.html\n    \"checkbox\",\n    \"code\",\n    // \"columnheader\" -> ./grid-roles.html\n    \"combobox\",\n    // \"command\" -> ./abstract-roles.html\n    // \"comment\" -> [AT-RISK: ARIA #1885]\n    \"complementary\",\n    // \"composite\" -> ./abstract-roles.html\n    \"contentinfo\",\n    \"definition\",\n    \"deletion\",\n    \"dialog\",\n    // \"directory\" -> FAIL. WONTFIX. Deprecated in ARIA 1.2; re-mapped to list role.\n    \"document\",\n    // doc-* roles -> TBD /dpub-aria or /dpub-aam\n    \"emphasis\",\n    \"feed\",\n    \"figure\",\n    // form -> ./form-roles.html\n    // \"generic\", -> FAIL. WONTFIX. Screen Readers don't announce the generic role.\n    // graphics-* roles -> /graphics-aria\n    // \"grid\" -> ./grid-roles.html\n    // \"gridcell\" -> ./grid-roles.html\n    \"group\",\n    \"heading\",\n    // \"image\" -> ./synonym-roles.html\n    // \"img\" -> ./synonym-roles.html\n    // \"input\" -> ./abstract-roles.html\n    \"insertion\",\n    // \"landmark\" -> ./abstract-roles.html\n    \"link\",\n    // \"list\" -> ./list-roles.html\n    // \"listitem\" -> ./list-roles.html\n    // \"listitemkey\" [See: ARIA #1662] or possibly -> ./list-roles.html\n    // \"listitemvalue\" [See: ARIA #1662] or possibly -> ./list-roles.html\n    // \"listbox\" -> ./listbox-roles.html\n    \"log\",\n    \"main\",\n    \"marquee\",\n    \"math\",\n    // \"menu\" -> ./menu-roles.html\n    // \"menuitem\" -> ./menu-roles.html\n    // \"menuitemcheckbox\" -> ./menu-roles.html\n    // \"menuitemradio\" -> ./menu-roles.html\n    // \"menubar\" -> ./menu-roles.html\n    \"meter\",\n    \"navigation\",\n    // \"none\" -> ./synonym-roles.html\n    \"note\",\n    // \"option\" -> ./listbox-roles.html\n    \"paragraph\",\n    // \"presentation\" -> ./synonym-roles.html\n    \"progressbar\",\n    \"radio\",\n    \"radiogroup\",\n    // \"range\" -> ./abstract-roles.html\n    // \"region\" -> ./region-roles.html\n    // \"roletype\" -> ./abstract-roles.html\n    // \"row\" -> ./grid-roles.html\n    // \"rowgroup\" -> ./grid-roles.html\n    // \"rowheader\" -> ./grid-roles.html\n    \"scrollbar\",\n    \"search\",\n    \"searchbox\",\n    // \"section\" -> ./abstract-roles.html\n    // \"sectionhead\" -> ./abstract-roles.html\n    // \"select\" -> ./abstract-roles.html\n    \"separator\",\n    \"slider\",\n    \"spinbutton\",\n    \"status\",\n    \"strong\",\n    // \"structure\" -> ./abstract-roles.html\n    \"subscript\",\n    /**\n     * Will be part of WAI-ARIA 1.3, which is still being drafted.\n     * REF: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/suggestion_role\n     */\n    // \"suggestion\",\n    \"superscript\",\n    \"switch\",\n    // \"tab\" -> ./tab-roles.html\n    // \"table\" -> ./grid-roles.html\n    // \"tablist\" -> ./tab-roles.html\n    // \"tabpanel\" -> ./tab-roles.html\n    \"term\",\n    \"textbox\",\n    \"time\",\n    \"timer\",\n    \"toolbar\",\n    \"tooltip\",\n    // \"tree\" -> ./tree-roles.html\n    // \"treeitem\" -> ./tree-roles.html\n    // \"treegrid\" -> ./treegrid-roles.html\n    // \"widget\" -> ./abstract-roles.html\n    // \"window\" -> ./abstract-roles.html\n  ])(\"%s\", async (role) => {\n    const container = document.createElement(\"div\");\n    container.appendChild(document.createTextNode(\"x\"));\n    container.setAttribute(\"role\", role);\n    container.id = `role_${role}`;\n\n    await virtual.start({ container });\n\n    expect(await virtual.lastSpokenPhrase()).toEqual(\n      `${role}${\n        allowsNameFromContent(container) ? \", x\" : \"\"\n      }${defaultAriaAttributes(role)}`\n    );\n\n    await virtual.stop();\n  });\n});\n"]}
{"filename": "test/wpt/accname/basic.int.test.ts", "chunked_list": ["import { virtual } from \"../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/basic.html\n */\n\ndescribe(\"Basic Tests\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div id='d' style='height: 100px; width: 100px' role=\"group\" aria-label=\"test label\"></div>", "    document.body.innerHTML = `\n    <div id='d' style='height: 100px; width: 100px' role=\"group\" aria-label=\"test label\"></div>\n    <h1 id=\"h\">test heading</h1>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n  });\n\n  afterEach(async () => {", "\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests label accessible name\", async () => {\n    expect(await virtual.itemText()).toEqual(\"test label\");\n  });", "    expect(await virtual.itemText()).toEqual(\"test label\");\n  });\n\n  test(\"tests heading accessible name\", async () => {\n    await virtual.next();\n\n    expect(await virtual.itemText()).toEqual(\"test heading\");\n  });\n});\n", "});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_664-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_664-manual.html\n */\n\ndescribe(\"Description test case 664\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div>", "    document.body.innerHTML = `\n    <div>\n      <img id=\"test\" aria-describedby=\"ID1\" src=\"test.png\">\n    </div>\n    <div id=\"ID1\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n", "\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_665-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_665-manual.html\n */\n\ndescribe(\"Description test case 665\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div>", "    document.body.innerHTML = `\n    <div>\n      <img id=\"test\" aria-describedby=\"ID1\" src=\"test.png\">\n    </div>\n    <div id=\"ID1\" style=\"display:none\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n    await virtual.next();\n    await virtual.next();", "    await virtual.next();\n    await virtual.next();\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {", "\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, foo\",\n      \"end of document\",\n    ]);\n  });\n});\n", "});\n"]}
{"filename": "test/wpt/accname/manual/description_title-same-element-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_title-same-element-manual.html\n */\n\ndescribe(\"Description title-same-element\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div><input aria-label=\"Name\" id=\"test\" title=\"Title\" aria-describedby=\"ID1\" type=\"text\"></div>", "    document.body.innerHTML = `\n    <div><input aria-label=\"Name\" id=\"test\" title=\"Title\" aria-describedby=\"ID1\" type=\"text\"></div>\n    <div id=\"ID1\">Description</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"textbox, Name, Description\",\n      \"Description\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_666-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_666-manual.html\n */\n\ndescribe(\"Description test case 666\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div>", "    document.body.innerHTML = `\n    <div>\n      <img id=\"test\" aria-describedby=\"ID1\" src=\"test.png\">\n    </div>\n    <div id=\"ID1\" role=\"presentation\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n", "\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_broken_reference-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_broken_reference-manual.html\n */\n\ndescribe(\"Description test case broken reference\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">", "    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, test\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_one_valid_reference-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_one_valid_reference-manual.html\n */\n\ndescribe(\"Description test case one valid reference\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1 t2 t3\">", "    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1 t2 t3\">\n    <div id=\"t2\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, test, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_838-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_838-manual.html\n */\n\ndescribe(\"Description test case 838\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">", "    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n    <div id=\"t1\" style=\"visibility:hidden\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, test, foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_773-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_773-manual.html\n */\n\ndescribe(\"Description test case 773\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">", "    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n    <div id=\"t1\" style=\"display:none\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, test, foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_557-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_557-manual.html\n */\n\ndescribe(\"Description test case 557\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img id=\"test\" src=\"foo.jpg\" aria-label=\"1\" alt=\"a\" title=\"t\"/>", "    document.body.innerHTML = `\n    <img id=\"test\" src=\"foo.jpg\" aria-label=\"1\" alt=\"a\" title=\"t\"/>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, 1, t\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_link-with-label-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_link-with-label-manual.html\n */\n\ndescribe(\"Description link-with-label\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <a id=\"test\" href=\"#\" aria-label=\"California\" title=\"San Francisco\" >United States</a>", "    document.body.innerHTML = `\n    <a id=\"test\" href=\"#\" aria-label=\"California\" title=\"San Francisco\" >United States</a>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"link, California, San Francisco\",\n      \"United States\",\n      \"end of link, California, San Francisco\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_772-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_772-manual.html\n */\n\ndescribe(\"Description test case 772\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">", "    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n    <div id=\"t1\">foo</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, test, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_774-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_774-manual.html\n */\n\ndescribe(\"Description test case 774\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">", "    document.body.innerHTML = `\n    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n    <span id=\"t1\" role=\"presentation\">foo</span>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"img, test, foo\",\n      \"foo\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_from_content_of_describedby_element-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_from_content_of_describedby_element-manual.html\n */\n\ndescribe(\"Description from content of describedby element\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <style>", "    document.body.innerHTML = `\n    <style>\n      .hidden { display: none; }\n    </style>\n    <input id=\"test\" type=\"text\" aria-label=\"Important stuff\" aria-describedby=\"descId\" />\n    <div>\n      <div id=\"descId\">\n        <span aria-hidden=\"true\"><i> Hello, </i></span>\n        <span>My</span> name is\n        <div><img src=\"file.jpg\" title=\"Bryan\" alt=\"\" role=\"presentation\" /></div>", "        <span>My</span> name is\n        <div><img src=\"file.jpg\" title=\"Bryan\" alt=\"\" role=\"presentation\" /></div>\n        <span role=\"presentation\" aria-label=\"Eli\">\n          <span aria-label=\"Garaventa\">Zambino</span>\n        </span>\n        <span>the weird.</span>\n        (QED)\n        <span class=\"hidden\"><i><b>and don't you forget it.</b></i></span>\n        <table>\n          <tr>", "        <table>\n          <tr>\n            <td>Where</td>\n            <td style=\"visibility:hidden;\"><div>in</div></td>\n            <td><div style=\"display:none;\">the world</div></td>\n            <td>are my marbles?</td>\n          </tr>\n        </table>\n      </div>\n    </div>", "      </div>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      // TODO: FAIL incorrectly using Zambino where it should be using Eli\n      // Needs fix in https://github.com/eps1lon/dom-accessibility-api\n      \"textbox, Important stuff, My name is Zambino the weird. (QED) Where are my marbles?\",\n      \"My\",\n      \"name is\",\n      \"Bryan\",\n      \"Eli\",\n      \"Garaventa\",\n      \"Zambino\",\n      \"the weird.\",\n      \"(QED)\",\n      \"table\",\n      \"rowgroup\",\n      \"row, Where are my marbles?\",\n      \"cell, Where\",\n      \"cell\",\n      \"cell, are my marbles?\",\n      \"end of row, Where are my marbles?\",\n      \"end of rowgroup\",\n      \"end of table\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/manual/description_1.0_combobox-focusable-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_1.0_combobox-focusable-manual.html\n */\n\ndescribe(\"Description 1.0 combobox-focusable\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div id=\"test\" role=\"combobox\" tabindex=\"0\" title=\"Choose your language.\">", "    document.body.innerHTML = `\n    <div id=\"test\" role=\"combobox\" tabindex=\"0\" title=\"Choose your language.\">\n      <span> English </span>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"combobox, Choose your language., not expanded, has popup listbox\",\n      \"English\",\n      \"end of combobox, Choose your language., not expanded, has popup listbox\",\n      \"end of document\",\n    ]);\n  });\n});\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests description\", async () => {\n    expect(await virtual.spokenPhraseLog()).toEqual([\n      \"document\",\n      \"combobox, Choose your language., not expanded, has popup listbox\",\n      \"English\",\n      \"end of combobox, Choose your language., not expanded, has popup listbox\",\n      \"end of document\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_hidden_not_referenced.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_hidden_not_referenced.html\n */\n\ndescribe(\"Name Comp: Hidden Not Referenced\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <h2 class=\"ex\" data-expectedlabel=\"heading label\" data-testname=\"heading with interior hidden node\">", "    document.body.innerHTML = `\n    <h2 class=\"ex\" data-expectedlabel=\"heading label\" data-testname=\"heading with interior hidden node\">\n      heading\n      <span hidden>bogus</span>\n      label\n    </h2>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"heading label\",\n      \"heading\", // TODO: this isn't ideal, probably should just omit the contents as it matches the parent (but slight owing to the bogus element)\n      \"label\",\n      \"heading label\",\n      \"\",\n    ]);\n  });\n});\n", "    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"heading label\",\n      \"heading\", // TODO: this isn't ideal, probably should just omit the contents as it matches the parent (but slight owing to the bogus element)\n      \"label\",\n      \"heading label\",\n      \"\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_embedded_control.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_embedded_control.html\n */\n\ndescribe(\"Name Comp: Embedded Control\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <label>", "    document.body.innerHTML = `\n    <label>\n      <input type=\"checkbox\" data-expectedlabel=\"Flash the screen 3 times\" data-testname=\"checkbox label with embedded textfield\" class=\"ex\">\n      Flash the screen\n      <input value=\"3\" aria-label=\"number of times\" data-expectedlabel=\"number of times\" data-testname=\"label of embedded textfield inside checkbox label\" class=\"ex\"> times\n    </label>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"Flash the screen 3 times\",\n      \"Flash the screen\",\n      \"number of times, 3\",\n      \"times\",\n      \"\",\n    ]);\n  });\n});\n", "    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"Flash the screen 3 times\",\n      \"Flash the screen\",\n      \"number of times, 3\",\n      \"times\",\n      \"\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_labelledby.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_labelledby.html\n */\n\ndescribe(\"Name Comp: Labelledby\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div role=\"group\" aria-labelledby=\"h\" class=\"ex\" data-expectedlabel=\"div group label\" data-testname=\"div group explicitly labelledby heading\">", "    document.body.innerHTML = `\n    <div role=\"group\" aria-labelledby=\"h\" class=\"ex\" data-expectedlabel=\"div group label\" data-testname=\"div group explicitly labelledby heading\">\n      <h2 id=\"h\">div group label</h2>\n      <p>text inside div group</p>\n    </div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"div group label\",\n      \"div group label\",\n      \"text inside div group\",\n      \"div group label\",\n      \"\",\n    ]);\n  });\n});\n", "\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"div group label\",\n      \"div group label\",\n      \"text inside div group\",\n      \"div group label\",\n      \"\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_host_language_label.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_host_language_label.html\n */\n\ndescribe(\"Name Comp: Host Language Label\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <label for=\"t\">label</label>", "    document.body.innerHTML = `\n    <label for=\"t\">label</label>\n    <input id=\"t\" data-expectedlabel=\"label\" data-testname=\"host language: label[for] input[type=text]\" class=\"ex\">\n    <!-- Todo: test all remaining input types with label[for] -->\n\n    <label>\n      <input type=\"checkbox\" data-expectedlabel=\"label\" data-testname=\"host language: label input[type=checkbox] encapsulation\" class=\"ex\">\n      label\n    </label>\n    <!-- Todo: test all remaining input types with label encapsulation -->", "    </label>\n    <!-- Todo: test all remaining input types with label encapsulation -->\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"label\",\n      \"label\",\n      \"label\",\n      \"label\",\n      \"\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_name_from_content.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_name_from_content.html\n */\n\ndescribe(\"Name Comp: Name From Content\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <h1 data-expectedlabel=\"label\" data-testname=\"heading name from content\" class=\"ex\">label</h1>", "    document.body.innerHTML = `\n    <h1 data-expectedlabel=\"label\" data-testname=\"heading name from content\" class=\"ex\">label</h1>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\"\", \"label\", \"\"]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_label.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_label.html\n */\n\ndescribe(\"Name Comp: Label\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <div aria-label=\"label\" data-expectedlabel=\"label\" data-testname=\"label valid on group\" role=\"group\" class=\"ex\">x</div>", "    document.body.innerHTML = `\n    <div aria-label=\"label\" data-expectedlabel=\"label\" data-testname=\"label valid on group\" role=\"group\" class=\"ex\">x</div>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"label\",\n      \"x\",\n      \"label\",\n      \"\",\n    ]);\n  });\n});\n"]}
{"filename": "test/wpt/accname/name/comp_text_node.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\n/**\n * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_text_node.html\n */\n\ndescribe(\"Name Comp: Text Node\", () => {\n  beforeEach(async () => {\n    document.body.innerHTML = `\n    <!-- Skipped (class=\"ex\" removed) until https://github.com/w3c/accname/issues/193 is resolved -->", "    document.body.innerHTML = `\n    <!-- Skipped (class=\"ex\" removed) until https://github.com/w3c/accname/issues/193 is resolved -->\n    <h2 class=\"ex-skipped\" data-expectedlabel=\"heading label\" data-testname=\"heading with text/comment/text nodes, no space\">\n      heading<!-- with non-text node splitting concatenated text nodes -->label<!-- [sic] no extra spaces around first comment -->\n    </h2>\n\n\n    <h2 class=\"ex\" data-expectedlabel=\"heading label\" data-testname=\"heading with text/comment/text nodes, with space\">\n      heading\n      <!-- comment node between text nodes with leading/trailing whitespace -->", "      heading\n      <!-- comment node between text nodes with leading/trailing whitespace -->\n      label\n    </h2>\n    `;\n\n    await virtual.start({ container: document.body });\n\n    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"headinglabel\", // TODO: FAIL should have whitespace\n      \"heading label\",\n      \"heading\", // TODO: FAIL should be same node\n      \"label\",\n      \"heading label\",\n      \"\",\n    ]);\n  });\n});\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n      await virtual.next();\n    }\n  });\n\n  afterEach(async () => {\n    await virtual.stop();\n\n    document.body.innerHTML = \"\";\n  });\n\n  test(\"tests accessible name\", async () => {\n    expect(await virtual.itemTextLog()).toEqual([\n      \"\",\n      \"headinglabel\", // TODO: FAIL should have whitespace\n      \"heading label\",\n      \"heading\", // TODO: FAIL should be same node\n      \"label\",\n      \"heading label\",\n      \"\",\n    ]);\n  });\n});\n"]}
{"filename": "src/getItemText.ts", "chunked_list": ["import { AccessibilityNode } from \"./createAccessibilityTree\";\n\nexport const getItemText = (\n  accessibilityNode: Pick<\n    AccessibilityNode,\n    \"accessibleName\" | \"accessibleValue\"\n  >\n) => {\n  const { accessibleName, accessibleValue } = accessibilityNode;\n  const announcedValue =", "  const { accessibleName, accessibleValue } = accessibilityNode;\n  const announcedValue =\n    accessibleName === accessibleValue ? \"\" : accessibleValue;\n\n  return [accessibleName, announcedValue].filter(Boolean).join(\", \");\n};\n"]}
{"filename": "src/getSpokenPhrase.ts", "chunked_list": ["import { AccessibilityNode } from \"./createAccessibilityTree\";\n\nexport const getSpokenPhrase = (accessibilityNode: AccessibilityNode) => {\n  const {\n    accessibleAttributeLabels,\n    accessibleDescription,\n    accessibleName,\n    accessibleValue,\n    spokenRole,\n  } = accessibilityNode;", "    spokenRole,\n  } = accessibilityNode;\n\n  const announcedValue =\n    accessibleName === accessibleValue ? \"\" : accessibleValue;\n\n  return [\n    spokenRole,\n    accessibleName,\n    announcedValue,", "    accessibleName,\n    announcedValue,\n    accessibleDescription,\n    ...accessibleAttributeLabels,\n  ]\n    .filter(Boolean)\n    .join(\", \");\n};\n", ""]}
{"filename": "src/Virtual.ts", "chunked_list": ["import {\n  AccessibilityNode,\n  createAccessibilityTree,\n} from \"./createAccessibilityTree\";\nimport {\n  CommandOptions,\n  MacOSModifiers,\n  ScreenReader,\n  WindowsModifiers,\n} from \"@guidepup/guidepup\";", "  WindowsModifiers,\n} from \"@guidepup/guidepup\";\nimport { commands, VirtualCommandKey, VirtualCommands } from \"./commands\";\nimport {\n  ERR_VIRTUAL_MISSING_CONTAINER,\n  ERR_VIRTUAL_NOT_STARTED,\n} from \"./errors\";\nimport { getItemText } from \"./getItemText\";\nimport { getSpokenPhrase } from \"./getSpokenPhrase\";\nimport { isElement } from \"./isElement\";", "import { getSpokenPhrase } from \"./getSpokenPhrase\";\nimport { isElement } from \"./isElement\";\nimport userEvent from \"@testing-library/user-event\";\nimport { VirtualCommandArgs } from \"./commands/types\";\n\nexport interface StartOptions extends CommandOptions {\n  /**\n   * The bounding HTML element to use the Virtual Screen Reader in.\n   *\n   * To use the entire page pass `document.body`.\n   */\n  container: Node;\n}\n\nconst defaultUserEventOptions = {\n  delay: null,\n  skipHover: true,\n};\n\n/**\n * TODO: handle live region roles:\n *\n * - alert\n * - log\n * - marquee\n * - status\n * - timer\n * - alertdialog\n *\n * And handle live region attributes:\n *\n * - aria-atomic\n * - aria-busy\n * - aria-live\n * - aria-relevant\n *\n * When live regions are marked as polite, assistive technologies SHOULD\n * announce updates at the next graceful opportunity, such as at the end of\n * speaking the current sentence or when the user pauses typing. When live\n * regions are marked as assertive, assistive technologies SHOULD notify the\n * user immediately.\n *\n * REF:\n *\n * - https://w3c.github.io/aria/#live_region_roles\n * - https://w3c.github.io/aria/#window_roles\n * - https://w3c.github.io/aria/#attrs_liveregions\n * - https://w3c.github.io/aria/#aria-live\n */\n\n/**\n * TODO: When a modal element is displayed, assistive technologies SHOULD\n * navigate to the element unless focus has explicitly been set elsewhere. Some\n * assistive technologies limit navigation to the modal element's contents. If\n * focus moves to an element outside the modal element, assistive technologies\n * SHOULD NOT limit navigation to the modal element.\n *\n * REF: https://w3c.github.io/aria/#aria-modal\n */\n\nconst observeDOM = (function () {\n  const MutationObserver = window.MutationObserver;\n", "  return function observeDOM(\n    node: Node,\n    onChange: MutationCallback\n  ): () => void {\n    if (!isElement(node)) {\n      return;\n    }\n\n    if (MutationObserver) {\n      const mutationObserver = new MutationObserver(onChange);\n\n      mutationObserver.observe(node, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n      });\n\n      return () => {\n        mutationObserver.disconnect();\n      };\n    }\n\n    return () => {\n      // gracefully fallback to not supporting Accessibility Tree refreshes if\n      // the DOM changes.\n    };\n  };\n})();\n", "    if (MutationObserver) {\n      const mutationObserver = new MutationObserver(onChange);\n\n      mutationObserver.observe(node, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n      });\n\n      return () => {\n        mutationObserver.disconnect();\n      };\n    }\n\n    return () => {\n      // gracefully fallback to not supporting Accessibility Tree refreshes if\n      // the DOM changes.\n    };\n  };\n})();\n", "async function tick() {\n  return await new Promise<void>((resolve) => setTimeout(() => resolve()));\n}\n\n/**\n * TODO: When an assistive technology reading cursor moves from one article to\n * another, assistive technologies SHOULD set user agent focus on the article\n * that contains the reading cursor. If the reading cursor lands on a focusable\n * element inside the article, the assistive technology MAY set focus on that\n * element in lieu of setting focus on the containing article.\n *\n * REF: https://w3c.github.io/aria/#feed\n */\n", "export class Virtual implements ScreenReader {\n  #activeNode: AccessibilityNode | null = null;\n  #container: Node | null = null;\n  #itemTextLog: string[] = [];\n  #spokenPhraseLog: string[] = [];\n  #treeCache: AccessibilityNode[] | null = null;\n  #disconnectDOMObserver: () => void | null = null;\n\n  #checkContainer() {\n    if (!this.#container) {\n      throw new Error(ERR_VIRTUAL_NOT_STARTED);\n    }\n  }\n\n  #getAccessibilityTree() {", "    if (!this.#container) {\n      throw new Error(ERR_VIRTUAL_NOT_STARTED);\n    }\n  }\n\n  #getAccessibilityTree() {\n    if (!this.#treeCache) {\n      this.#treeCache = createAccessibilityTree(this.#container);\n      this.#attachFocusListeners();\n    }\n\n    return this.#treeCache;\n  }\n\n  #invalidateTreeCache() {\n    this.#detachFocusListeners();\n    this.#treeCache = null;\n  }\n\n  #attachFocusListeners() {\n    this.#getAccessibilityTree().forEach((treeNode) => {\n      treeNode.node.addEventListener(\n        \"focus\",\n        this.#handleFocusChange.bind(this)\n      );\n    });\n  }\n\n  #detachFocusListeners() {\n    this.#getAccessibilityTree().forEach((treeNode) => {\n      treeNode.node.removeEventListener(\n        \"focus\",\n        this.#handleFocusChange.bind(this)\n      );\n    });\n  }\n\n  async #handleFocusChange({ target }: FocusEvent) {\n    await tick();\n\n    this.#invalidateTreeCache();\n    const tree = this.#getAccessibilityTree();\n    const nextIndex = tree.findIndex(({ node }) => node === target);\n    const newActiveNode = tree.at(nextIndex);\n\n    this.#updateState(newActiveNode, true);\n  }\n\n  #focusActiveElement() {", "    if (!this.#activeNode || !isElement(this.#activeNode.node)) {\n      return;\n    }\n\n    this.#activeNode.node.focus();\n  }\n\n  #updateState(accessibilityNode: AccessibilityNode, ignoreIfNoChange = false) {\n    const spokenPhrase = getSpokenPhrase(accessibilityNode);\n    const itemText = getItemText(accessibilityNode);\n\n    this.#activeNode = accessibilityNode;\n", "    if (\n      ignoreIfNoChange &&\n      spokenPhrase === this.#spokenPhraseLog.at(-1) &&\n      itemText === this.#itemTextLog.at(-1)\n    ) {\n      return;\n    }\n\n    this.#itemTextLog.push(itemText);\n    this.#spokenPhraseLog.push(spokenPhrase);\n  }\n\n  async #refreshState(ignoreIfNoChange) {\n    await tick();\n\n    this.#invalidateTreeCache();\n    const tree = this.#getAccessibilityTree();\n    const currentIndex = this.#getCurrentIndexByNode(tree);\n    const newActiveNode = tree.at(currentIndex);\n\n    this.#updateState(newActiveNode, ignoreIfNoChange);\n  }\n\n  #getCurrentIndex(tree: AccessibilityNode[]) {\n    return tree.findIndex(\n      ({\n        accessibleDescription,\n        accessibleName,\n        accessibleValue,\n        node,\n        role,\n        spokenRole,\n      }) =>\n        accessibleDescription === this.#activeNode?.accessibleDescription &&\n        accessibleName === this.#activeNode?.accessibleName &&\n        accessibleValue === this.#activeNode?.accessibleValue &&\n        node === this.#activeNode?.node &&\n        role === this.#activeNode?.role &&\n        spokenRole === this.#activeNode?.spokenRole\n    );\n  }\n\n  #getCurrentIndexByNode(tree: AccessibilityNode[]) {\n    return tree.findIndex(({ node }) => node === this.#activeNode?.node);\n  }\n\n  /**\n   * Getter for screen reader commands.\n   *\n   * Use with `await virtual.perform(command)`.\n   */\n  get commands() {\n    return Object.fromEntries<VirtualCommandKey>(\n      Object.keys(commands).map((command: VirtualCommandKey) => [\n        command,\n        command,\n      ])\n    ) as { [K in VirtualCommandKey]: K };\n  }\n\n  /**\n   * Detect whether the screen reader is supported for the current OS.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async detect() {\n    return true;\n  }\n\n  /**\n   * Detect whether the screen reader is the default screen reader for the current OS.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async default() {\n    return false;\n  }\n\n  /**\n   * Turn the screen reader on.\n   *\n   * @param {object} [options] Additional options.\n   */\n  async start({ container }: StartOptions = { container: null }) {", "    if (!container) {\n      throw new Error(ERR_VIRTUAL_MISSING_CONTAINER);\n    }\n\n    this.#container = container;\n\n    this.#disconnectDOMObserver = observeDOM(\n      container,\n      this.#invalidateTreeCache.bind(this)\n    );\n\n    const tree = this.#getAccessibilityTree();\n", "    if (!tree.length) {\n      return;\n    }\n\n    this.#updateState(tree[0]);\n\n    return;\n  }\n\n  /**\n   * Turn the screen reader off.\n   */\n  async stop() {\n    this.#disconnectDOMObserver?.();\n    this.#invalidateTreeCache();\n\n    this.#activeNode = null;\n    this.#container = null;\n    this.#itemTextLog = [];\n    this.#spokenPhraseLog = [];\n\n    return;\n  }\n\n  /**\n   * Move the screen reader cursor to the previous location.\n   */\n  async previous() {\n    this.#checkContainer();\n    await tick();\n\n    const tree = this.#getAccessibilityTree();\n", "    if (!tree.length) {\n      return;\n    }\n\n    const currentIndex = this.#getCurrentIndex(tree);\n    const nextIndex = currentIndex === -1 ? 0 : currentIndex - 1;\n    const newActiveNode = tree.at(nextIndex);\n\n    this.#updateState(newActiveNode);\n\n    return;\n  }\n\n  /**\n   * Move the screen reader cursor to the next location.\n   */\n  async next() {\n    this.#checkContainer();\n    await tick();\n\n    const tree = this.#getAccessibilityTree();\n", "    if (!tree.length) {\n      return;\n    }\n\n    const currentIndex = this.#getCurrentIndex(tree);\n    const nextIndex =\n      currentIndex === -1 || currentIndex === tree.length - 1\n        ? 0\n        : currentIndex + 1;\n    const newActiveNode = tree.at(nextIndex);\n\n    this.#updateState(newActiveNode);\n\n    return;\n  }\n\n  /**\n   * Perform the default action for the item in the screen reader cursor.\n   */\n  async act() {\n    this.#checkContainer();\n    await tick();\n", "    if (!this.#activeNode) {\n      return;\n    }\n\n    const target = this.#activeNode.node as HTMLElement;\n\n    // TODO: verify that is appropriate for all default actions\n    await userEvent.click(target, defaultUserEventOptions);\n\n    return;\n  }\n\n  /**\n   * Interact with the item under the screen reader cursor.\n   */\n  async interact() {\n    this.#checkContainer();\n\n    return;\n  }\n\n  /**\n   * Stop interacting with the current item.\n   */\n  async stopInteracting() {\n    this.#checkContainer();\n\n    return;\n  }\n\n  /**\n   * Press a key on the active item.\n   *\n   * `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)\n   * value or a single character to generate the text for. A superset of the `key` values can be found\n   * [on the MDN key values page](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:\n   *\n   * `F1` - `F20`, `Digit0` - `Digit9`, `KeyA` - `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n   * `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.\n   *\n   * Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta` (OS permitting).\n   *", "   * Holding down `Shift` will type the text that corresponds to the `key` in the upper case.\n   *\n   * If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective\n   * texts.\n   *\n   * Shortcuts such as `key: \"Control+f\"` or `key: \"Control+Shift+f\"` are supported as well. When specified with the\n   * modifier, modifier is pressed and being held while the subsequent key is being pressed.\n   *\n   * ```ts\n   * await virtual.press(\"Control+f\");\n   * ```\n   *\n   * @param {string} key Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n   */\n  async press(key: string) {\n    this.#checkContainer();\n    await tick();\n", "    if (!this.#activeNode) {\n      return;\n    }\n\n    const rawKeys = key.replaceAll(\"{\", \"{{\").replaceAll(\"[\", \"[[\").split(\"+\");\n    const modifiers = [];\n    const keys = [];\n\n    rawKeys.forEach((rawKey) => {\n      if (\n        typeof MacOSModifiers[rawKey] !== \"undefined\" ||\n        typeof WindowsModifiers[rawKey] !== \"undefined\"\n      ) {\n        modifiers.push(rawKey);\n      } else {\n        keys.push(rawKey);\n      }\n    });\n\n    const keyboardCommand = [\n      ...modifiers.map((modifier) => `{${modifier}>}`),\n      ...keys.map((key) => `{${key}}`),\n      ...modifiers.reverse().map((modifier) => `{/${modifier}}`),\n    ].join(\"\");\n\n    this.#focusActiveElement();\n    await userEvent.keyboard(keyboardCommand, defaultUserEventOptions);\n    await this.#refreshState(true);\n\n    return;\n  }\n\n  /**\n   * Type text into the active item.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use `virtual.press(key)`.\n   *\n   * ```ts\n   * await virtual.type(\"my-username\");\n   * await virtual.press(\"Enter\");\n   * ```\n   *", "      if (\n        typeof MacOSModifiers[rawKey] !== \"undefined\" ||\n        typeof WindowsModifiers[rawKey] !== \"undefined\"\n      ) {\n        modifiers.push(rawKey);\n      } else {\n        keys.push(rawKey);\n      }\n    });\n\n    const keyboardCommand = [\n      ...modifiers.map((modifier) => `{${modifier}>}`),\n      ...keys.map((key) => `{${key}}`),\n      ...modifiers.reverse().map((modifier) => `{/${modifier}}`),\n    ].join(\"\");\n\n    this.#focusActiveElement();\n    await userEvent.keyboard(keyboardCommand, defaultUserEventOptions);\n    await this.#refreshState(true);\n\n    return;\n  }\n\n  /**\n   * Type text into the active item.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use `virtual.press(key)`.\n   *\n   * ```ts\n   * await virtual.type(\"my-username\");\n   * await virtual.press(\"Enter\");\n   * ```\n   *", "   * @param {string} text Text to type into the active item.\n   */\n  async type(text: string) {\n    this.#checkContainer();\n    await tick();\n\n    if (!this.#activeNode) {\n      return;\n    }\n\n    const target = this.#activeNode.node as HTMLElement;\n    await userEvent.type(target, text, defaultUserEventOptions);\n    await this.#refreshState(true);\n\n    return;\n  }\n\n  /**\n   * Perform a screen reader command.\n   *\n   * @param {string} command Screen reader command.\n   * @param {object} [options] Command options.\n   */\n  async perform<\n    T extends VirtualCommandKey,\n    K extends Omit<Parameters<VirtualCommands[T]>[0], keyof VirtualCommandArgs>\n  >(command: T, options?: { [L in keyof K]: K[L] } & CommandOptions) {\n    this.#checkContainer();\n    await tick();\n\n    const tree = this.#getAccessibilityTree();\n", "    if (!tree.length) {\n      return;\n    }\n\n    const currentIndex = this.#getCurrentIndex(tree);\n    const nextIndex = commands[command]?.({\n      ...options,\n      container: this.#container,\n      currentIndex,\n      tree,\n    });\n", "    if (typeof nextIndex !== \"number\") {\n      return;\n    }\n\n    const newActiveNode = tree.at(nextIndex);\n    this.#updateState(newActiveNode);\n\n    return;\n  }\n\n  /**\n   * Click the mouse.\n   *\n   * @param {object} [options] Click options.\n   */\n  async click({ button = \"left\", clickCount = 1 } = {}) {\n    this.#checkContainer();\n    await tick();\n", "    if (!this.#activeNode) {\n      return;\n    }\n\n    const key = `[Mouse${button[0].toUpperCase()}${button.slice(1)}]`;\n    const keys = key.repeat(clickCount);\n    const target = this.#activeNode.node as HTMLElement;\n\n    await userEvent.pointer(\n      [{ target }, { keys, target }],\n      defaultUserEventOptions\n    );\n\n    return;\n  }\n\n  /**\n   * Get the last spoken phrase.\n   *\n   * @returns {Promise<string>} The last spoken phrase.\n   */\n  async lastSpokenPhrase() {\n    this.#checkContainer();\n    await tick();\n\n    return this.#spokenPhraseLog.at(-1) ?? \"\";\n  }\n\n  /**\n   * Get the text of the item in the screen reader cursor.\n   *\n   * @returns {Promise<string>} The item's text.\n   */\n  async itemText() {\n    this.#checkContainer();\n    await tick();\n\n    return this.#itemTextLog.at(-1) ?? \"\";\n  }\n\n  /**\n   * Get the log of all spoken phrases for this screen reader instance.\n   *\n   * @returns {Promise<string[]>} The spoken phrase log.\n   */\n  async spokenPhraseLog() {\n    this.#checkContainer();\n\n    await tick();\n\n    return this.#spokenPhraseLog;\n  }\n\n  /**\n   * Get the log of all visited item text for this screen reader instance.\n   *\n   * @returns {Promise<string[]>} The item text log.\n   */\n  async itemTextLog() {\n    this.#checkContainer();\n\n    await tick();\n\n    return this.#itemTextLog;\n  }\n}\n"]}
{"filename": "src/getNodeByIdRef.ts", "chunked_list": ["import { isElement } from \"./isElement\";\n\nexport function getNodeByIdRef({ container, idRef }) {\n  if (!isElement(container) || !idRef) {\n    return null;\n  }\n\n  return container.querySelector(`#${idRef}`);\n}\n"]}
{"filename": "src/errors.ts", "chunked_list": ["export const ERR_NOT_IMPLEMENTED = \"Not implemented\";\nexport const ERR_VIRTUAL_MISSING_CONTAINER = \"A container was not provided\";\nexport const ERR_VIRTUAL_NOT_STARTED = \"Virtual screen reader was not started\";\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { StartOptions, Virtual } from \"./Virtual\";\n\nexport const virtual = new Virtual();\n\ntype _Virtual = typeof virtual;\n\nexport { StartOptions, _Virtual as Virtual };\n"]}
{"filename": "src/createAccessibilityTree.ts", "chunked_list": ["import { getIdRefsByAttribute } from \"./getIdRefsByAttribute\";\nimport { getNodeAccessibilityData } from \"./getNodeAccessibilityData\";\nimport { getNodeByIdRef } from \"./getNodeByIdRef\";\nimport { HTMLElementWithValue } from \"./getNodeAccessibilityData/getAccessibleValue\";\nimport { isElement } from \"./isElement\";\nimport { isInaccessible } from \"dom-accessibility-api\";\n\nexport interface AccessibilityNode {\n  accessibleAttributeLabels: string[];\n  accessibleDescription: string;\n  accessibleName: string;\n  accessibleValue: string;\n  allowedAccessibilityChildRoles: string[][];\n  alternateReadingOrderParents: Node[];\n  childrenPresentational: boolean;\n  node: Node;\n  parent: Node | null;\n  role: string;\n  spokenRole: string;\n}\n", "interface AccessibilityNodeTree extends AccessibilityNode {\n  children: AccessibilityNodeTree[];\n}\n\ninterface AccessibilityContext {\n  alternateReadingOrderMap: Map<Node, Set<Node>>;\n  container: Node;\n  ownedNodes: Set<Node>;\n  visitedNodes: Set<Node>;\n}\n", "function addAlternateReadingOrderNodes(\n  node: Element,\n  alternateReadingOrderMap: Map<Node, Set<Node>>,\n  container: Element\n) {\n  const idRefs = getIdRefsByAttribute({\n    attributeName: \"aria-flowto\",\n    node,\n  });\n\n  idRefs.forEach((idRef) => {\n    const childNode = getNodeByIdRef({ container, idRef });\n", "    if (!childNode) {\n      return;\n    }\n\n    const currentParentNodes =\n      alternateReadingOrderMap.get(childNode) ?? new Set<Node>();\n\n    currentParentNodes.add(node);\n\n    alternateReadingOrderMap.set(childNode, currentParentNodes);\n  });\n}\n", "function mapAlternateReadingOrder(node: Node) {\n  const alternateReadingOrderMap = new Map<Node, Set<Node>>();\n\n  if (!isElement(node)) {\n    return alternateReadingOrderMap;\n  }\n\n  node\n    .querySelectorAll(\"[aria-flowto]\")\n    .forEach((parentNode) =>\n      addAlternateReadingOrderNodes(parentNode, alternateReadingOrderMap, node)\n    );\n\n  return alternateReadingOrderMap;\n}\n", "function addOwnedNodes(\n  node: Element,\n  ownedNodes: Set<Node>,\n  container: Element\n) {\n  const idRefs = getIdRefsByAttribute({\n    attributeName: \"aria-owns\",\n    node,\n  });\n\n  idRefs.forEach((idRef) => {\n    const ownedNode = getNodeByIdRef({ container, idRef });\n", "    if (!!ownedNode && !ownedNodes.has(ownedNode)) {\n      ownedNodes.add(ownedNode);\n    }\n  });\n}\n\nfunction getAllOwnedNodes(node: Node) {\n  const ownedNodes = new Set<Node>();\n\n  if (!isElement(node)) {\n    return ownedNodes;\n  }\n\n  node\n    .querySelectorAll(\"[aria-owns]\")\n    .forEach((owningNode) => addOwnedNodes(owningNode, ownedNodes, node));\n\n  return ownedNodes;\n}\n", "  if (!isElement(node)) {\n    return ownedNodes;\n  }\n\n  node\n    .querySelectorAll(\"[aria-owns]\")\n    .forEach((owningNode) => addOwnedNodes(owningNode, ownedNodes, node));\n\n  return ownedNodes;\n}\n", "function getOwnedNodes(node: Node, container: Node) {\n  const ownedNodes = new Set<Node>();\n\n  if (!isElement(node) || !isElement(container)) {\n    return ownedNodes;\n  }\n\n  addOwnedNodes(node, ownedNodes, container);\n\n  return ownedNodes;\n}\n", "function isHiddenFromAccessibilityTree(node: Node) {\n  if (!node) {\n    return true;\n  }\n\n  if (node.nodeType === Node.TEXT_NODE && !!node.textContent.trim()) {\n    return false;\n  }\n\n  return !isElement(node) || isInaccessible(node);\n}\n", "function shouldIgnoreChildren(tree: AccessibilityNodeTree) {\n  const { accessibleName, node } = tree;\n\n  if (!accessibleName) {\n    return false;\n  }\n\n  return (\n    // TODO: improve comparison on whether the children are superfluous\n    // to include.\n    accessibleName ===\n    (\n      node.textContent ||\n      `${(node as HTMLElementWithValue).value}` ||\n      \"\"\n    )?.trim()\n  );\n}\n", "function flattenTree(tree: AccessibilityNodeTree): AccessibilityNode[] {\n  const { children, ...treeNode } = tree;\n  const isAnnounced =\n    !!treeNode.accessibleName ||\n    !!treeNode.accessibleDescription ||\n    treeNode.accessibleAttributeLabels.length > 0 ||\n    !!treeNode.spokenRole;\n\n  const ignoreChildren = shouldIgnoreChildren(tree);\n\n  const flattenedTree = ignoreChildren\n    ? []\n    : [...children.flatMap((child) => flattenTree(child))];\n\n  const isRoleContainer =\n    !!flattenedTree.length && !ignoreChildren && !!treeNode.spokenRole;\n", "  if (isAnnounced) {\n    flattenedTree.unshift(treeNode);\n  }\n\n  if (isRoleContainer) {\n    flattenedTree.push({\n      accessibleAttributeLabels: treeNode.accessibleAttributeLabels,\n      accessibleDescription: treeNode.accessibleDescription,\n      accessibleName: treeNode.accessibleName,\n      accessibleValue: treeNode.accessibleValue,\n      allowedAccessibilityChildRoles: treeNode.allowedAccessibilityChildRoles,\n      alternateReadingOrderParents: treeNode.alternateReadingOrderParents,\n      childrenPresentational: treeNode.childrenPresentational,\n      node: treeNode.node,\n      parent: treeNode.parent,\n      role: treeNode.role,\n      spokenRole: `end of ${treeNode.spokenRole}`,\n    });\n  }\n\n  return flattenedTree;\n}\n", "function growTree(\n  node: Node,\n  tree: AccessibilityNodeTree,\n  {\n    alternateReadingOrderMap,\n    container,\n    ownedNodes,\n    visitedNodes,\n  }: AccessibilityContext\n): AccessibilityNodeTree {\n  /**\n   * Authors MUST NOT create circular references with aria-owns. In the case of\n   * authoring error with aria-owns, the user agent MAY ignore some aria-owns\n   * element references in order to build a consistent model of the content.\n   *\n   * REF: https://w3c.github.io/aria/#aria-owns\n   */", "  if (visitedNodes.has(node)) {\n    return tree;\n  }\n\n  visitedNodes.add(node);\n\n  node.childNodes.forEach((childNode) => {\n    if (isHiddenFromAccessibilityTree(childNode)) {\n      return;\n    }\n\n    // REF: https://github.com/w3c/aria/issues/1817#issuecomment-1261602357", "    if (ownedNodes.has(childNode)) {\n      return;\n    }\n\n    const alternateReadingOrderParents = alternateReadingOrderMap.has(childNode)\n      ? Array.from(alternateReadingOrderMap.get(childNode))\n      : [];\n\n    const {\n      accessibleAttributeLabels,\n      accessibleDescription,\n      accessibleName,\n      accessibleValue,\n      allowedAccessibilityChildRoles,\n      childrenPresentational,\n      role,\n      spokenRole,\n    } = getNodeAccessibilityData({\n      allowedAccessibilityRoles: tree.allowedAccessibilityChildRoles,\n      alternateReadingOrderParents,\n      container,\n      node: childNode,\n      inheritedImplicitPresentational: tree.childrenPresentational,\n    });\n\n    tree.children.push(\n      growTree(\n        childNode,\n        {\n          accessibleAttributeLabels,\n          accessibleDescription,\n          accessibleName,\n          accessibleValue,\n          allowedAccessibilityChildRoles,\n          alternateReadingOrderParents,\n          children: [],\n          childrenPresentational,\n          node: childNode,\n          parent: node,\n          role,\n          spokenRole,\n        },\n        { alternateReadingOrderMap, container, ownedNodes, visitedNodes }\n      )\n    );\n  });\n\n  /**\n   * If an element has both aria-owns and DOM children then the order of the\n   * child elements with respect to the parent/child relationship is the DOM\n   * children first, then the elements referenced in aria-owns. If the author\n   * intends that the DOM children are not first, then list the DOM children in\n   * aria-owns in the desired order. Authors SHOULD NOT use aria-owns as a\n   * replacement for the DOM hierarchy. If the relationship is represented in\n   * the DOM, do not use aria-owns.\n   *\n   * REF: https://w3c.github.io/aria/#aria-owns\n   */\n  const ownedChildNodes = getOwnedNodes(node, container);\n\n  ownedChildNodes.forEach((childNode) => {", "    if (isHiddenFromAccessibilityTree(childNode)) {\n      return;\n    }\n\n    const alternateReadingOrderParents = alternateReadingOrderMap.has(childNode)\n      ? Array.from(alternateReadingOrderMap.get(childNode))\n      : [];\n\n    const {\n      accessibleAttributeLabels,\n      accessibleDescription,\n      accessibleName,\n      accessibleValue,\n      allowedAccessibilityChildRoles,\n      childrenPresentational,\n      role,\n      spokenRole,\n    } = getNodeAccessibilityData({\n      allowedAccessibilityRoles: tree.allowedAccessibilityChildRoles,\n      alternateReadingOrderParents,\n      container,\n      node: childNode,\n      inheritedImplicitPresentational: tree.childrenPresentational,\n    });\n\n    tree.children.push(\n      growTree(\n        childNode,\n        {\n          accessibleAttributeLabels,\n          accessibleDescription,\n          accessibleName,\n          accessibleValue,\n          allowedAccessibilityChildRoles,\n          alternateReadingOrderParents,\n          children: [],\n          childrenPresentational,\n          node: childNode,\n          parent: node,\n          role,\n          spokenRole,\n        },\n        { alternateReadingOrderMap, container, ownedNodes, visitedNodes }\n      )\n    );\n  });\n\n  return tree;\n}\n", "export function createAccessibilityTree(node: Node) {\n  if (isHiddenFromAccessibilityTree(node)) {\n    return [];\n  }\n\n  const alternateReadingOrderMap = mapAlternateReadingOrder(node);\n  const ownedNodes = getAllOwnedNodes(node);\n  const visitedNodes = new Set<Node>();\n\n  const {\n    accessibleAttributeLabels,\n    accessibleDescription,\n    accessibleName,\n    accessibleValue,\n    allowedAccessibilityChildRoles,\n    childrenPresentational,\n    role,\n    spokenRole,\n  } = getNodeAccessibilityData({\n    allowedAccessibilityRoles: [],\n    alternateReadingOrderParents: [],\n    container: node,\n    node,\n    inheritedImplicitPresentational: false,\n  });\n\n  const tree = growTree(\n    node,\n    {\n      accessibleAttributeLabels,\n      accessibleDescription,\n      accessibleName,\n      accessibleValue,\n      allowedAccessibilityChildRoles,\n      alternateReadingOrderParents: [],\n      children: [],\n      childrenPresentational,\n      node,\n      parent: null,\n      role,\n      spokenRole,\n    },\n    {\n      alternateReadingOrderMap,\n      container: node,\n      ownedNodes,\n      visitedNodes,\n    }\n  );\n\n  return flattenTree(tree);\n}\n"]}
{"filename": "src/getIdRefsByAttribute.ts", "chunked_list": ["export function getIdRefsByAttribute({ attributeName, node }) {\n  return (node.getAttribute(attributeName) ?? \"\")\n    .trim()\n    .split(\" \")\n    .filter(Boolean);\n}\n"]}
{"filename": "src/isElement.ts", "chunked_list": ["export function isElement(node: Node): node is HTMLElement {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n"]}
{"filename": "src/commands/jumpToControlledElement.ts", "chunked_list": ["import { getNextIndexByIdRefsAttribute } from \"./getNextIndexByIdRefsAttribute\";\nimport { VirtualCommandArgs } from \"./types\";\n\nexport interface JumpToControlledElementCommandArgs extends VirtualCommandArgs {\n  index?: number;\n}\n\n/**\n * aria-controls:\n *\n * Identifies the element (or elements) whose contents or presence\n * are controlled by the current element. See related aria-owns.\n *\n * REF: https://w3c.github.io/aria/#aria-controls\n *\n * MUST requirement:\n *\n * The controlled element might not be close to the element with\n * aria-controls and the user might find it convenient to jump directly to\n * the controlled element.\n *\n * REF: https://a11ysupport.io/tech/aria/aria-controls_attribute\n */", "export function jumpToControlledElement({\n  index = 0,\n  container,\n  currentIndex,\n  tree,\n}: JumpToControlledElementCommandArgs) {\n  return getNextIndexByIdRefsAttribute({\n    attributeName: \"aria-controls\",\n    index,\n    container,\n    currentIndex,\n    tree,\n  });\n}\n"]}
{"filename": "src/commands/getElementNode.ts", "chunked_list": ["import { AccessibilityNode } from \"../createAccessibilityTree\";\nimport { isElement } from \"../isElement\";\n\nexport function getElementNode(accessibilityNode: AccessibilityNode) {\n  const { node } = accessibilityNode;\n\n  if (node && isElement(node)) {\n    return node;\n  }\n\n  return accessibilityNode.parent;\n}\n"]}
{"filename": "src/commands/moveToPreviousAlternateReadingOrderElement.ts", "chunked_list": ["import { isElement } from \"../isElement\";\nimport { VirtualCommandArgs } from \"./types\";\n\nexport interface MoveToNextAlternateReadingOrderElement\n  extends VirtualCommandArgs {\n  index?: number;\n}\n\n/**\n * aria-flowto:\n *\n * However, when aria-flowto is provided with multiple ID\n * references, assistive technologies SHOULD present the referenced\n * elements as path choices.\n *\n * In the case of one or more ID references, user agents or assistive\n * technologies SHOULD give the user the option of navigating to any of the\n * targeted elements. The name of the path can be determined by the name of\n * the target element of the aria-flowto attribute. Accessibility APIs can\n * provide named path relationships.\n *\n * REF: https://w3c.github.io/aria/#aria-flowto\n *\n * MUST requirements:\n *\n * The reading order goes both directions, and a user needs to be aware of the\n * alternate reading order so that they can invoke the functionality.\n *\n * The reading order goes both directions, and a user needs to be able to\n * travel backwards through their chosen reading order.\n *\n * REF: https://a11ysupport.io/tech/aria/aria-flowto_attribute\n */", "export function moveToPreviousAlternateReadingOrderElement({\n  index = 0,\n  container,\n  currentIndex,\n  tree,\n}: MoveToNextAlternateReadingOrderElement) {\n  if (!isElement(container)) {\n    return;\n  }\n\n  const { alternateReadingOrderParents } = tree.at(currentIndex);\n  const targetNode = alternateReadingOrderParents[index];\n", "  if (!targetNode) {\n    return;\n  }\n\n  return tree.findIndex(({ node }) => node === targetNode);\n}\n"]}
{"filename": "src/commands/getNextIndexByRole.ts", "chunked_list": ["import { VirtualCommandArgs } from \"./types\";\n\nexport type GetNextIndexByRoleArgs = Omit<VirtualCommandArgs, \"container\">;\n\nexport function getNextIndexByRole(roles: Readonly<string[]>) {\n  return function getNextIndex({ currentIndex, tree }: GetNextIndexByRoleArgs) {\n    const reorderedTree = tree\n      .slice(currentIndex + 1)\n      .concat(tree.slice(0, currentIndex + 1));\n\n    const accessibilityNode = reorderedTree.find(\n      (node) =>\n        roles.includes(node.role) && !node.spokenRole.startsWith(\"end of\")\n    );\n", "    if (!accessibilityNode) {\n      return null;\n    }\n\n    return tree.findIndex((node) => node === accessibilityNode);\n  };\n}\n"]}
{"filename": "src/commands/types.ts", "chunked_list": ["import { AccessibilityNode } from \"../createAccessibilityTree\";\n\nexport interface VirtualCommandArgs {\n  currentIndex: number;\n  container: Node;\n  tree: AccessibilityNode[];\n}\n"]}
{"filename": "src/commands/getPreviousIndexByRole.ts", "chunked_list": ["import { VirtualCommandArgs } from \"./types\";\n\nexport type GetPreviousIndexByRoleArgs = Omit<VirtualCommandArgs, \"container\">;\n\nexport function getPreviousIndexByRole(roles: Readonly<string[]>) {\n  return function getPreviousIndex({\n    currentIndex,\n    tree,\n  }: GetPreviousIndexByRoleArgs) {\n    const reorderedTree = tree\n      .slice(0, currentIndex)\n      .reverse()\n      .concat(tree.slice(currentIndex).reverse());\n\n    const accessibilityNode = reorderedTree.find(\n      (node) =>\n        roles.includes(node.role) && !node.spokenRole.startsWith(\"end of\")\n    );\n", "    if (!accessibilityNode) {\n      return null;\n    }\n\n    return tree.findIndex((node) => node === accessibilityNode);\n  };\n}\n"]}
{"filename": "src/commands/jumpToDetailsElement.ts", "chunked_list": ["import { getNextIndexByIdRefsAttribute } from \"./getNextIndexByIdRefsAttribute\";\nimport { VirtualCommandArgs } from \"./types\";\n\n/**\n * aria-details:\n *\n * REF: https://w3c.github.io/aria/#aria-details\n *\n * SHOULD requirement:\n *", " * SHOULD requirement:\n *\n * If the details are not adjacent to the element with aria-details, it might\n * be helpful to jump directly to the reference or have it conveyed.\n *\n * REF: https://a11ysupport.io/tech/aria/aria-details_attribute\n */\nexport function jumpToDetailsElement({\n  container,\n  currentIndex,\n  tree,\n}: VirtualCommandArgs) {\n  return getNextIndexByIdRefsAttribute({\n    attributeName: \"aria-details\",\n    index: 0,\n    container,\n    currentIndex,\n    tree,\n  });\n}\n"]}
{"filename": "src/commands/index.ts", "chunked_list": ["import { getNextIndexByRole } from \"./getNextIndexByRole\";\nimport { getPreviousIndexByRole } from \"./getPreviousIndexByRole\";\nimport { jumpToControlledElement } from \"./jumpToControlledElement\";\nimport { jumpToDetailsElement } from \"./jumpToDetailsElement\";\nimport { moveToNextAlternateReadingOrderElement } from \"./moveToNextAlternateReadingOrderElement\";\nimport { moveToPreviousAlternateReadingOrderElement } from \"./moveToPreviousAlternateReadingOrderElement\";\nimport { VirtualCommandArgs } from \"./types\";\n\nconst quickLandmarkNavigationRoles = [\n  /**", "const quickLandmarkNavigationRoles = [\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role banner.\n   *\n   * REF: https://w3c.github.io/aria/#banner\n   */\n  \"banner\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role complementary.\n   *\n   * REF: https://w3c.github.io/aria/#complementary\n   */\n  \"complementary\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role contentinfo.\n   *\n   * REF: https://w3c.github.io/aria/#contentinfo\n   */\n  \"contentinfo\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * figures.\n   *\n   * REF: https://w3c.github.io/aria/#figure\n   */\n  \"figure\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role form.\n   *\n   * REF: https://w3c.github.io/aria/#form\n   */\n  \"form\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role main.\n   *\n   * REF: https://w3c.github.io/aria/#main\n   */\n  \"main\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role navigation.\n   *\n   * REF: https://w3c.github.io/aria/#navigation\n   */\n  \"navigation\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role region.\n   *\n   * REF: https://w3c.github.io/aria/#region\n   */\n  \"region\",\n\n  /**", "\n  /**\n   * Assistive technologies SHOULD enable users to quickly navigate to\n   * elements with role search.\n   *\n   * REF: https://w3c.github.io/aria/#search\n   */\n  \"search\",\n] as const;\n", "] as const;\n\nconst quickLandmarkNavigationCommands = quickLandmarkNavigationRoles.reduce<\n  Record<string, unknown>\n>((accumulatedCommands, role) => {\n  const moveToNextCommand = `moveToNext${role.at(0).toUpperCase()}${role.slice(\n    1\n  )}`;\n  const moveToPreviousCommand = `moveToPrevious${role\n    .at(0)", "  const moveToPreviousCommand = `moveToPrevious${role\n    .at(0)\n    .toUpperCase()}${role.slice(1)}`;\n\n  return {\n    ...accumulatedCommands,\n    [moveToNextCommand]: getNextIndexByRole([role]),\n    [moveToPreviousCommand]: getPreviousIndexByRole([role]),\n  };\n}, {}) as {", "  };\n}, {}) as {\n  [K in\n    | `moveToNext${Capitalize<(typeof quickLandmarkNavigationRoles)[number]>}`\n    | `moveToPrevious${Capitalize<\n        (typeof quickLandmarkNavigationRoles)[number]\n      >}`]: (args: VirtualCommandArgs) => number | null;\n};\n\nexport const commands = {", "\nexport const commands = {\n  jumpToControlledElement,\n  jumpToDetailsElement,\n  moveToNextAlternateReadingOrderElement,\n  moveToPreviousAlternateReadingOrderElement,\n  ...quickLandmarkNavigationCommands,\n  moveToNextLandmark: getNextIndexByRole(quickLandmarkNavigationRoles),\n  moveToPreviousLandmark: getPreviousIndexByRole(quickLandmarkNavigationRoles),\n};", "  moveToPreviousLandmark: getPreviousIndexByRole(quickLandmarkNavigationRoles),\n};\n\nexport type VirtualCommands = {\n  [K in keyof typeof commands]: (typeof commands)[K];\n};\nexport type VirtualCommandKey = keyof VirtualCommands;\n"]}
{"filename": "src/commands/moveToNextAlternateReadingOrderElement.ts", "chunked_list": ["import { getNextIndexByIdRefsAttribute } from \"./getNextIndexByIdRefsAttribute\";\nimport { VirtualCommandArgs } from \"./types\";\n\nexport interface MoveToNextAlternateReadingOrderElement\n  extends VirtualCommandArgs {\n  index?: number;\n}\n\n/**\n * aria-flowto:\n *\n * However, when aria-flowto is provided with multiple ID\n * references, assistive technologies SHOULD present the referenced\n * elements as path choices.\n *\n * In the case of one or more ID references, user agents or assistive\n * technologies SHOULD give the user the option of navigating to any of the\n * targeted elements. The name of the path can be determined by the name of\n * the target element of the aria-flowto attribute. Accessibility APIs can\n * provide named path relationships.\n *\n * REF: https://w3c.github.io/aria/#aria-flowto\n *\n * MUST requirements:\n *\n * A user needs to understand that the current element flows to another element\n * so that they can invoke the functionality.\n *\n * A user needs to be able to follow the alternate reading order.\n *\n * REF: https://a11ysupport.io/tech/aria/aria-flowto_attribute\n */", "export function moveToNextAlternateReadingOrderElement({\n  index,\n  container,\n  currentIndex,\n  tree,\n}: MoveToNextAlternateReadingOrderElement) {\n  return getNextIndexByIdRefsAttribute({\n    attributeName: \"aria-flowto\",\n    index,\n    container,\n    currentIndex,\n    tree,\n  });\n}\n"]}
{"filename": "src/commands/getNextIndexByIdRefsAttribute.ts", "chunked_list": ["import { getElementNode } from \"./getElementNode\";\nimport { getIdRefsByAttribute } from \"../getIdRefsByAttribute\";\nimport { getNodeByIdRef } from \"../getNodeByIdRef\";\nimport { isElement } from \"../isElement\";\nimport { VirtualCommandArgs } from \"./types\";\n\nexport interface GetNextIndexByIdRefsAttributeArgs extends VirtualCommandArgs {\n  attributeName: string;\n  index?: number;\n}\n", "export function getNextIndexByIdRefsAttribute({\n  attributeName,\n  index = 0,\n  container,\n  currentIndex,\n  tree,\n}: GetNextIndexByIdRefsAttributeArgs) {\n  if (!isElement(container)) {\n    return;\n  }\n\n  const currentAccessibilityNode = tree.at(currentIndex);\n  const currentNode = getElementNode(currentAccessibilityNode);\n\n  const idRefs = getIdRefsByAttribute({\n    attributeName,\n    node: currentNode,\n  });\n\n  const idRef = idRefs[index];\n  const targetNode = getNodeByIdRef({ container, idRef });\n", "  if (!targetNode) {\n    return;\n  }\n\n  const nodeIndex = tree.findIndex(({ node }) => node === targetNode);\n\n  if (nodeIndex !== -1) {\n    return nodeIndex;\n  }\n\n  const nodeIndexByParent = tree.findIndex(\n    ({ parent }) => parent === targetNode\n  );\n", "  if (nodeIndexByParent !== -1) {\n    return nodeIndexByParent;\n  }\n\n  return;\n}\n"]}
{"filename": "src/getNodeAccessibilityData/getRole.ts", "chunked_list": ["import { getRole as getImplicitRole } from \"dom-accessibility-api\";\nimport { getRoles } from \"@testing-library/dom\";\nimport { isElement } from \"../isElement\";\nimport { roles } from \"aria-query\";\n\nexport const presentationRoles = [\"presentation\", \"none\"];\n\nconst allowedNonAbstractRoles = roles\n  .entries()\n  .filter(([, { abstract }]) => !abstract)", "  .entries()\n  .filter(([, { abstract }]) => !abstract)\n  .map(([key]) => key) as string[];\n\nconst rolesRequiringName = [\"form\", \"region\"];\n\nexport const globalStatesAndProperties = [\n  \"aria-atomic\",\n  \"aria-braillelabel\",\n  \"aria-brailleroledescription\",", "  \"aria-braillelabel\",\n  \"aria-brailleroledescription\",\n  \"aria-busy\",\n  \"aria-controls\",\n  \"aria-describedby\",\n  \"aria-description\",\n  \"aria-details\",\n  \"aria-dropeffect\",\n  \"aria-flowto\",\n  \"aria-grabbed\",", "  \"aria-flowto\",\n  \"aria-grabbed\",\n  \"aria-hidden\",\n  \"aria-keyshortcuts\",\n  \"aria-label\",\n  \"aria-labelledby\",\n  \"aria-live\",\n  \"aria-owns\",\n  \"aria-relevant\",\n  \"aria-roledescription\",", "  \"aria-relevant\",\n  \"aria-roledescription\",\n];\n\nconst FOCUSABLE_SELECTOR = [\n  \"input:not([type=hidden]):not([disabled])\",\n  \"button:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\",\n  '[contenteditable=\"\"]',", "  \"textarea:not([disabled])\",\n  '[contenteditable=\"\"]',\n  '[contenteditable=\"true\"]',\n  \"a[href]\",\n  \"[tabindex]:not([disabled])\",\n].join(\", \");\n\nfunction isFocusable(node: HTMLElement) {\n  return node.matches(FOCUSABLE_SELECTOR);\n}\n", "function hasGlobalStateOrProperty(node: HTMLElement) {\n  return globalStatesAndProperties.some((global) => node.hasAttribute(global));\n}\n\nfunction getExplicitRole({\n  accessibleName,\n  allowedAccessibilityRoles,\n  inheritedImplicitPresentational,\n  node,\n}: {\n  accessibleName: string;\n  allowedAccessibilityRoles: string[][];\n  inheritedImplicitPresentational: boolean;\n  node: HTMLElement;\n}) {\n  const rawRoles = node.getAttribute(\"role\")?.trim().split(\" \") ?? [];\n\n  const authorErrorFilteredRoles = rawRoles\n    /**\n     * As stated in the Definition of Roles section, it is considered an\n     * authoring error to use abstract roles in content.\n     * User agents MUST NOT map abstract roles via the standard role mechanism\n     * of the accessibility API.\n     *\n     * REF: https://w3c.github.io/aria/#document-handling_author-errors_roles\n     */\n    .filter((role) => allowedNonAbstractRoles.includes(role))\n    /**\n     * Certain landmark roles require names from authors. In situations where\n     * an author has not specified names for these landmarks, it is\n     * considered an authoring error. The user agent MUST treat such elements\n     * as if no role had been provided. If a valid fallback role had been\n     * specified, or if the element had an implicit ARIA role, then user\n     * agents would continue to expose that role, instead. Instances of such\n     * roles are as follows:\n     *\n     * - form\n     * - region\n     *\n     * REF: https://w3c.github.io/aria/#document-handling_author-errors_roles\n     */\n    .filter((role) => !!accessibleName || !rolesRequiringName.includes(role));\n\n  /**\n   * If an allowed child element has an explicit non-presentational role, user\n   * agents MUST ignore an inherited presentational role and expose the element\n   * with its explicit role. If the action of exposing the explicit role causes\n   * the accessibility tree to be malformed, the expected results are\n   * undefined.\n   *\n   * See also \"Children Presentational: True\".\n   *\n   * REF:\n   *\n   * - https://w3c.github.io/aria/#conflict_resolution_presentation_none\n   * - https://w3c.github.io/aria/#tree_exclusion\n   * - https://w3c.github.io/aria/#mustContain\n   */\n\n  const isExplicitAllowedChildElement = allowedAccessibilityRoles.some(\n    ([allowedExplicitRole]) =>\n      authorErrorFilteredRoles?.[0] === allowedExplicitRole\n  );\n", "  if (inheritedImplicitPresentational && !isExplicitAllowedChildElement) {\n    authorErrorFilteredRoles.unshift(\"none\");\n  }\n\n  if (!authorErrorFilteredRoles?.length) {\n    return \"\";\n  }\n\n  const filteredRoles = authorErrorFilteredRoles\n    /**\n     * If an element is focusable, user agents MUST ignore the\n     * presentation/none role and expose the element with its implicit role, in\n     * order to ensure that the element is operable.\n     *\n     * If an element has global WAI-ARIA states or properties, user agents MUST\n     * ignore the presentation role and instead expose the element's implicit\n     * role. However, if an element has only non-global, role-specific WAI-ARIA\n     * states or properties, the element MUST NOT be exposed unless the\n     * presentational role is inherited and an explicit non-presentational role\n     * is applied.\n     *\n     * REF: https://w3c.github.io/aria/#conflict_resolution_presentation_none\n     */\n    .filter((role) => {", "      if (!presentationRoles.includes(role)) {\n        return true;\n      }\n\n      if (hasGlobalStateOrProperty(node) || isFocusable(node)) {\n        return false;\n      }\n\n      return true;\n    });\n\n  return filteredRoles?.[0] ?? \"\";\n}\n", "export function getRole({\n  accessibleName,\n  allowedAccessibilityRoles,\n  inheritedImplicitPresentational,\n  node,\n}: {\n  accessibleName: string;\n  allowedAccessibilityRoles: string[][];\n  inheritedImplicitPresentational: boolean;\n  node: Node;\n}) {", "  if (!isElement(node)) {\n    return { explicitRole: \"\", implicitRole: \"\", role: \"\" };\n  }\n\n  const target = node.cloneNode() as HTMLElement;\n  const explicitRole = getExplicitRole({\n    accessibleName,\n    allowedAccessibilityRoles,\n    inheritedImplicitPresentational,\n    node: target,\n  });\n\n  target.removeAttribute(\"role\");\n\n  let implicitRole = getImplicitRole(target) ?? \"\";\n", "  if (!implicitRole) {\n    // TODO: remove this fallback post https://github.com/eps1lon/dom-accessibility-api/pull/937\n    implicitRole = Object.keys(getRoles(target))?.[0] ?? \"\";\n  }\n\n  if (explicitRole) {\n    return { explicitRole, implicitRole, role: explicitRole };\n  }\n\n  return {\n    explicitRole,\n    implicitRole,\n    role: implicitRole,\n  };\n}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleName.ts", "chunked_list": ["import { computeAccessibleName } from \"dom-accessibility-api\";\nimport { isElement } from \"../isElement\";\n\nexport function getAccessibleName(node: Node) {\n  return isElement(node)\n    ? computeAccessibleName(node).trim()\n    : node.textContent.trim();\n}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleDescription.ts", "chunked_list": ["import { computeAccessibleDescription } from \"dom-accessibility-api\";\nimport { isElement } from \"../isElement\";\n\nexport function getAccessibleDescription(node: Node) {\n  return isElement(node) ? computeAccessibleDescription(node).trim() : \"\";\n}\n"]}
{"filename": "src/getNodeAccessibilityData/index.ts", "chunked_list": ["import { ARIARoleDefinitionKey, roles } from \"aria-query\";\nimport { getRole, presentationRoles } from \"./getRole\";\nimport { getAccessibleAttributeLabels } from \"./getAccessibleAttributeLabels\";\nimport { getAccessibleDescription } from \"./getAccessibleDescription\";\nimport { getAccessibleName } from \"./getAccessibleName\";\nimport { getAccessibleValue } from \"./getAccessibleValue\";\nimport { isElement } from \"../isElement\";\n\nconst childrenPresentationalRoles = roles\n  .entries()", "const childrenPresentationalRoles = roles\n  .entries()\n  .filter(([, { childrenPresentational }]) => childrenPresentational)\n  .map(([key]) => key) as string[];\n\nconst getSpokenRole = ({ isGeneric, isPresentational, node, role }) => {\n  if (isPresentational || isGeneric) {\n    return \"\";\n  }\n\n  if (isElement(node)) {\n    /**\n     * Assistive technologies SHOULD use the value of aria-roledescription when\n     * presenting the role of an element, but SHOULD NOT change other\n     * functionality based on the role of an element that has a value for\n     * aria-roledescription. For example, an assistive technology that provides\n     * functions for navigating to the next region or button SHOULD allow those\n     * functions to navigate to regions and buttons that have an\n     * aria-roledescription.\n     *\n     * REF: https://w3c.github.io/aria/#aria-roledescription\n     */\n    const roledescription = node.getAttribute(\"aria-roledescription\");\n", "  if (isElement(node)) {\n    /**\n     * Assistive technologies SHOULD use the value of aria-roledescription when\n     * presenting the role of an element, but SHOULD NOT change other\n     * functionality based on the role of an element that has a value for\n     * aria-roledescription. For example, an assistive technology that provides\n     * functions for navigating to the next region or button SHOULD allow those\n     * functions to navigate to regions and buttons that have an\n     * aria-roledescription.\n     *\n     * REF: https://w3c.github.io/aria/#aria-roledescription\n     */\n    const roledescription = node.getAttribute(\"aria-roledescription\");\n", "    if (roledescription) {\n      return roledescription;\n    }\n  }\n\n  return role;\n};\n\nexport function getNodeAccessibilityData({\n  allowedAccessibilityRoles,\n  alternateReadingOrderParents,\n  container,\n  inheritedImplicitPresentational,\n  node,\n}: {\n  allowedAccessibilityRoles: string[][];\n  alternateReadingOrderParents: Node[];\n  container: Node;\n  inheritedImplicitPresentational: boolean;\n  node: Node;\n}) {\n  const accessibleDescription = getAccessibleDescription(node);\n  const accessibleName = getAccessibleName(node);\n  const accessibleValue = getAccessibleValue(node);\n\n  const { explicitRole, implicitRole, role } = getRole({\n    accessibleName,\n    allowedAccessibilityRoles,\n    inheritedImplicitPresentational,\n    node,\n  });\n\n  const accessibleAttributeLabels = getAccessibleAttributeLabels({\n    accessibleValue,\n    alternateReadingOrderParents,\n    container,\n    node,\n    role,\n  });\n\n  const amendedAccessibleDescription =\n    accessibleDescription === accessibleName ? \"\" : accessibleDescription;\n\n  const isExplicitPresentational = presentationRoles.includes(explicitRole);\n  const isPresentational = presentationRoles.includes(role);\n  const isGeneric = role === \"generic\";\n\n  const spokenRole = getSpokenRole({\n    isGeneric,\n    isPresentational,\n    node,\n    role,\n  });\n\n  const { requiredOwnedElements: allowedAccessibilityChildRoles } = (roles.get(\n    role as ARIARoleDefinitionKey\n  ) as unknown as {\n    requiredOwnedElements: string[][];\n  }) ?? { requiredOwnedElements: [] };\n\n  const { requiredOwnedElements: implicitAllowedAccessibilityChildRoles } =\n    (roles.get(implicitRole as ARIARoleDefinitionKey) as unknown as {\n      requiredOwnedElements: string[][];\n    }) ?? { requiredOwnedElements: [] };\n\n  /**\n   * Any descendants of elements that have the characteristic \"Children\n   * Presentational: True\" unless the descendant is not allowed to be\n   * presentational because it meets one of the conditions for exception\n   * described in Presentational Roles Conflict Resolution. However, the text\n   * content of any excluded descendants is included.\n   *\n   * REF: https://w3c.github.io/aria/#tree_exclusion\n   */\n  const isChildrenPresentationalRole =\n    childrenPresentationalRoles.includes(role);\n\n  /**\n   * When an explicit or inherited role of presentation is applied to an\n   * element with the implicit semantic of a WAI-ARIA role that has Allowed\n   * Accessibility Child Roles, in addition to the element with the explicit\n   * role of presentation, the user agent MUST apply an inherited role of\n   * presentation to any owned elements that do not have an explicit role\n   * defined. Also, when an explicit or inherited role of presentation is\n   * applied to a host language element which has specifically allowed children\n   * as defined by the host language specification, in addition to the element\n   * with the explicit role of presentation, the user agent MUST apply an\n   * inherited role of presentation to any specifically allowed children that\n   * do not have an explicit role defined.\n   *\n   * REF: https://w3c.github.io/aria/#presentational-role-inheritance\n   */\n  const isExplicitOrInheritedPresentation =\n    isExplicitPresentational || inheritedImplicitPresentational;\n  const isElementWithImplicitAllowedAccessibilityChildRoles =\n    !!implicitAllowedAccessibilityChildRoles.length;\n  const childrenInheritPresentationExceptAllowedRoles =\n    isExplicitOrInheritedPresentation &&\n    isElementWithImplicitAllowedAccessibilityChildRoles;\n\n  const childrenPresentational =\n    isChildrenPresentationalRole ||\n    childrenInheritPresentationExceptAllowedRoles;\n\n  return {\n    accessibleAttributeLabels,\n    accessibleDescription: amendedAccessibleDescription,\n    accessibleName,\n    accessibleValue,\n    allowedAccessibilityChildRoles,\n    childrenPresentational,\n    role,\n    spokenRole,\n  };\n}\n", "export function getNodeAccessibilityData({\n  allowedAccessibilityRoles,\n  alternateReadingOrderParents,\n  container,\n  inheritedImplicitPresentational,\n  node,\n}: {\n  allowedAccessibilityRoles: string[][];\n  alternateReadingOrderParents: Node[];\n  container: Node;\n  inheritedImplicitPresentational: boolean;\n  node: Node;\n}) {\n  const accessibleDescription = getAccessibleDescription(node);\n  const accessibleName = getAccessibleName(node);\n  const accessibleValue = getAccessibleValue(node);\n\n  const { explicitRole, implicitRole, role } = getRole({\n    accessibleName,\n    allowedAccessibilityRoles,\n    inheritedImplicitPresentational,\n    node,\n  });\n\n  const accessibleAttributeLabels = getAccessibleAttributeLabels({\n    accessibleValue,\n    alternateReadingOrderParents,\n    container,\n    node,\n    role,\n  });\n\n  const amendedAccessibleDescription =\n    accessibleDescription === accessibleName ? \"\" : accessibleDescription;\n\n  const isExplicitPresentational = presentationRoles.includes(explicitRole);\n  const isPresentational = presentationRoles.includes(role);\n  const isGeneric = role === \"generic\";\n\n  const spokenRole = getSpokenRole({\n    isGeneric,\n    isPresentational,\n    node,\n    role,\n  });\n\n  const { requiredOwnedElements: allowedAccessibilityChildRoles } = (roles.get(\n    role as ARIARoleDefinitionKey\n  ) as unknown as {\n    requiredOwnedElements: string[][];\n  }) ?? { requiredOwnedElements: [] };\n\n  const { requiredOwnedElements: implicitAllowedAccessibilityChildRoles } =\n    (roles.get(implicitRole as ARIARoleDefinitionKey) as unknown as {\n      requiredOwnedElements: string[][];\n    }) ?? { requiredOwnedElements: [] };\n\n  /**\n   * Any descendants of elements that have the characteristic \"Children\n   * Presentational: True\" unless the descendant is not allowed to be\n   * presentational because it meets one of the conditions for exception\n   * described in Presentational Roles Conflict Resolution. However, the text\n   * content of any excluded descendants is included.\n   *\n   * REF: https://w3c.github.io/aria/#tree_exclusion\n   */\n  const isChildrenPresentationalRole =\n    childrenPresentationalRoles.includes(role);\n\n  /**\n   * When an explicit or inherited role of presentation is applied to an\n   * element with the implicit semantic of a WAI-ARIA role that has Allowed\n   * Accessibility Child Roles, in addition to the element with the explicit\n   * role of presentation, the user agent MUST apply an inherited role of\n   * presentation to any owned elements that do not have an explicit role\n   * defined. Also, when an explicit or inherited role of presentation is\n   * applied to a host language element which has specifically allowed children\n   * as defined by the host language specification, in addition to the element\n   * with the explicit role of presentation, the user agent MUST apply an\n   * inherited role of presentation to any specifically allowed children that\n   * do not have an explicit role defined.\n   *\n   * REF: https://w3c.github.io/aria/#presentational-role-inheritance\n   */\n  const isExplicitOrInheritedPresentation =\n    isExplicitPresentational || inheritedImplicitPresentational;\n  const isElementWithImplicitAllowedAccessibilityChildRoles =\n    !!implicitAllowedAccessibilityChildRoles.length;\n  const childrenInheritPresentationExceptAllowedRoles =\n    isExplicitOrInheritedPresentation &&\n    isElementWithImplicitAllowedAccessibilityChildRoles;\n\n  const childrenPresentational =\n    isChildrenPresentationalRole ||\n    childrenInheritPresentationExceptAllowedRoles;\n\n  return {\n    accessibleAttributeLabels,\n    accessibleDescription: amendedAccessibleDescription,\n    accessibleName,\n    accessibleValue,\n    allowedAccessibilityChildRoles,\n    childrenPresentational,\n    role,\n    spokenRole,\n  };\n}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleValue.ts", "chunked_list": ["import { isElement } from \"../isElement\";\n\nexport type HTMLElementWithValue =\n  | HTMLButtonElement\n  | HTMLDataElement\n  | HTMLInputElement\n  | HTMLLIElement\n  | HTMLMeterElement\n  | HTMLOptionElement\n  | HTMLProgressElement\n  | HTMLParamElement;\n\nconst ignoredInputTypes = [\"checkbox\", \"radio\"];\nconst allowedLocalNames = [\n  \"button\",\n  \"data\",\n  \"input\",\n  // \"li\",\n  \"meter\",\n  \"option\",\n  \"progress\",\n  \"param\",\n];\n", "function getSelectValue(node: HTMLSelectElement) {\n  const selectedOptions = [...node.options].filter(\n    (optionElement) => optionElement.selected\n  );\n\n  if (node.multiple) {\n    return [...selectedOptions]\n      .map((optionElement) => getValue(optionElement))\n      .join(\"; \");\n  }\n", "  if (selectedOptions.length === 0) {\n    return \"\";\n  }\n\n  return getValue(selectedOptions[0]);\n}\n\nfunction getInputValue(node: HTMLInputElement) {\n  if (ignoredInputTypes.includes(node.type)) {\n    return \"\";\n  }\n\n  return getValue(node);\n}\n", "  if (ignoredInputTypes.includes(node.type)) {\n    return \"\";\n  }\n\n  return getValue(node);\n}\n\nfunction getValue(node: HTMLElementWithValue) {\n  if (!allowedLocalNames.includes(node.localName)) {\n    return \"\";\n  }\n", "  if (!allowedLocalNames.includes(node.localName)) {\n    return \"\";\n  }\n\n  if (\n    node.getAttribute(\"aria-valuetext\") ||\n    node.getAttribute(\"aria-valuenow\")\n  ) {\n    return \"\";\n  }\n\n  return typeof node.value === \"number\" ? `${node.value}` : node.value;\n}\n", "export function getAccessibleValue(node: Node) {\n  if (!isElement(node)) {\n    return \"\";\n  }\n\n  switch (node.localName) {\n    case \"input\": {\n      return getInputValue(node as HTMLInputElement);\n    }\n    case \"select\": {\n      return getSelectValue(node as HTMLSelectElement);\n    }\n  }\n\n  return getValue(node as HTMLElementWithValue);\n}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromAriaAttribute.ts", "chunked_list": ["import { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\nexport const getLabelFromAriaAttribute = ({\n  attributeName,\n  container,\n  node,\n}: {\n  attributeName: string;\n  container: Node;\n  node: HTMLElement;", "  container: Node;\n  node: HTMLElement;\n}) => {\n  const attributeValue = node.getAttribute(attributeName);\n\n  return {\n    label: mapAttributeNameAndValueToLabel({\n      attributeName,\n      attributeValue,\n      container,", "      attributeValue,\n      container,\n    }),\n    value: attributeValue,\n  };\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/mapAttributeNameAndValueToLabel.ts", "chunked_list": ["import { getAccessibleName } from \"../getAccessibleName\";\nimport { getAccessibleValue } from \"../getAccessibleValue\";\nimport { getItemText } from \"../../getItemText\";\nimport { getNodeByIdRef } from \"../../getNodeByIdRef\";\n\nenum State {\n  BUSY = \"busy\",\n  CHECKED = \"checked\",\n  CURRENT = \"current item\",\n  DISABLED = \"disabled\",\n  EXPANDED = \"expanded\",\n  INVALID = \"invalid\",\n  MODAL = \"modal\",\n  MULTI_SELECTABLE = \"multi-selectable\",\n  PARTIALLY_CHECKED = \"partially checked\",\n  PARTIALLY_PRESSED = \"partially pressed\",\n  PRESSED = \"pressed\",\n  READ_ONLY = \"read only\",\n  REQUIRED = \"required\",\n  SELECTED = \"selected\",\n}\n\n// https://w3c.github.io/aria/#state_prop_def\nconst ariaPropertyToVirtualLabelMap: Record<\n  string,\n  ((...args: unknown[]) => string) | null\n> = {\n  \"aria-activedescendant\": idRef(\"active descendant\"),\n  \"aria-atomic\": null, // Handled by live region logic\n  \"aria-autocomplete\": token({\n    inline: \"autocomplete inlined\",\n    list: \"autocomplete in list\",\n    both: \"autocomplete inlined and in list\",\n    none: \"no autocomplete\",\n  }),\n  \"aria-braillelabel\": null, // Currently won't do - not implementing a braille screen reader\n  \"aria-brailleroledescription\": null, // Currently won't do - not implementing a braille screen reader\n  \"aria-busy\": state(State.BUSY),\n  \"aria-checked\": tristate(State.CHECKED, State.PARTIALLY_CHECKED),\n  \"aria-colcount\": integer(\"column count\"),\n  \"aria-colindex\": integer(\"column index\"),\n  \"aria-colindextext\": string(\"column index\"),\n  \"aria-colspan\": integer(\"column span\"),\n  \"aria-controls\": idRefs(\"control\", \"controls\"), // Handled by virtual.perform()\n  \"aria-current\": token({\n    page: \"current page\",\n    step: \"current step\",\n    location: \"current location\",\n    date: \"current date\",\n    time: \"current time\",\n    true: State.CURRENT,\n    false: `not ${State.CURRENT}`,\n  }),\n  \"aria-describedby\": null, // Handled by accessible description\n  \"aria-description\": null, // Handled by accessible description\n  \"aria-details\": idRefs(\"linked details\", \"linked details\", false),\n  \"aria-disabled\": state(State.DISABLED),\n  \"aria-dropeffect\": null, // Deprecated in WAI-ARIA 1.1\n  \"aria-errormessage\": null, // TODO: decide what to announce here\n  \"aria-expanded\": state(State.EXPANDED),\n  \"aria-flowto\": idRefs(\"alternate reading order\", \"alternate reading orders\"), // Handled by virtual.perform()\n  \"aria-grabbed\": null, // Deprecated in WAI-ARIA 1.1\n  \"aria-haspopup\": token({\n    /**\n     * Assistive technologies SHOULD NOT expose the aria-haspopup property if\n     * it has a value of false.\n     *\n     * REF: // https://w3c.github.io/aria/#aria-haspopup\n     */\n    false: null,\n    true: \"has popup menu\",\n    menu: \"has popup menu\",\n    listbox: \"has popup listbox\",\n    tree: \"has popup tree\",\n    grid: \"has popup grid\",\n    dialog: \"has popup dialog\",\n  }),\n  \"aria-hidden\": null, // Excluded from accessibility tree\n  \"aria-invalid\": token({\n    grammar: \"grammatical error detected\",\n    false: `not ${State.INVALID}`,\n    spelling: \"spelling error detected\",\n    true: State.INVALID,\n  }),\n  \"aria-keyshortcuts\": string(\"key shortcuts\"),\n  \"aria-label\": null, // Handled by accessible name\n  \"aria-labelledby\": null, // Handled by accessible name\n  \"aria-level\": integer(\"level\"),\n  \"aria-live\": null, // Handled by live region logic\n  \"aria-modal\": state(State.MODAL),\n  \"aria-multiselectable\": state(State.MULTI_SELECTABLE),\n  \"aria-orientation\": token({\n    horizontal: \"orientated horizontally\",\n    vertical: \"orientated vertically\",\n  }),\n  \"aria-owns\": null, // Handled by accessibility tree construction\n  \"aria-placeholder\": string(\"placeholder\"),\n  \"aria-posinset\": integer(\"item set position\"),\n  \"aria-pressed\": tristate(State.PRESSED, State.PARTIALLY_PRESSED),\n  \"aria-readonly\": state(State.READ_ONLY),\n  \"aria-relevant\": null, // Handled by live region logic\n  \"aria-required\": state(State.REQUIRED),\n  \"aria-roledescription\": null, // Handled by accessible description\n  \"aria-rowcount\": integer(\"row count\"),\n  \"aria-rowindex\": integer(\"row index\"),\n  \"aria-rowindextext\": string(\"row index\"),\n  \"aria-rowspan\": integer(\"row span\"),\n  \"aria-selected\": state(State.SELECTED),\n  \"aria-setsize\": integer(\"item set size\"),\n  \"aria-sort\": token({\n    ascending: \"sorted in ascending order\",\n    descending: \"sorted in descending order\",\n    none: \"no defined sort order\",\n    other: \"non ascending / descending sort order applied\",\n  }),\n  \"aria-valuemax\": number(\"max value\"),\n  \"aria-valuemin\": number(\"min value\"),\n  \"aria-valuenow\": number(\"current value\"),\n  \"aria-valuetext\": string(\"current value\"),\n};\n", "interface MapperArgs {\n  attributeValue: string;\n  container?: Node;\n  negative?: boolean;\n}\n\nfunction state(stateValue: State) {\n  return function stateMapper({ attributeValue, negative }: MapperArgs) {\n    if (negative) {\n      return attributeValue !== \"false\" ? `not ${stateValue}` : stateValue;\n    }\n\n    return attributeValue !== \"false\" ? stateValue : `not ${stateValue}`;\n  };\n}\n", "    if (negative) {\n      return attributeValue !== \"false\" ? `not ${stateValue}` : stateValue;\n    }\n\n    return attributeValue !== \"false\" ? stateValue : `not ${stateValue}`;\n  };\n}\n\nfunction idRefs(\n  propertyDescriptionSuffixSingular: string,\n  propertyDescriptionSuffixPlural: string,\n  printCount = true\n) {", "function idRefs(\n  propertyDescriptionSuffixSingular: string,\n  propertyDescriptionSuffixPlural: string,\n  printCount = true\n) {\n  return function mapper({ attributeValue, container }: MapperArgs) {\n    const idRefsCount = attributeValue\n      .trim()\n      .split(\" \")\n      .filter((idRef) => !!getNodeByIdRef({ container, idRef })).length;\n", "    if (idRefsCount === 0) {\n      return \"\";\n    }\n\n    return `${printCount ? `${idRefsCount} ` : \"\"}${\n      idRefsCount === 1\n        ? propertyDescriptionSuffixSingular\n        : propertyDescriptionSuffixPlural\n    }`;\n  };\n}\n", "function idRef(propertyName: string) {\n  return function mapper({ attributeValue: idRef, container }: MapperArgs) {\n    const node = getNodeByIdRef({ container, idRef });\n\n    if (!node) {\n      return \"\";\n    }\n\n    const accessibleName = getAccessibleName(node);\n    const accessibleValue = getAccessibleValue(node);\n    const itemText = getItemText({ accessibleName, accessibleValue });\n\n    return concat(propertyName)({ attributeValue: itemText });\n  };\n}\n", "function tristate(stateValue: State, mixedValue: State) {\n  return function stateMapper({ attributeValue }: MapperArgs) {\n    if (attributeValue === \"mixed\") {\n      return mixedValue;\n    }\n\n    return attributeValue !== \"false\" ? stateValue : `not ${stateValue}`;\n  };\n}\n\nfunction token(tokenMap: Record<string, string>) {", "function token(tokenMap: Record<string, string>) {\n  return function tokenMapper({ attributeValue }: MapperArgs) {\n    return tokenMap[attributeValue];\n  };\n}\n\nfunction concat(propertyName: string) {\n  return function mapper({ attributeValue }: MapperArgs) {\n    return attributeValue ? `${propertyName} ${attributeValue}` : \"\";\n  };\n}\n", "function integer(propertyName: string) {\n  return concat(propertyName);\n}\n\nfunction number(propertyName: string) {\n  return concat(propertyName);\n}\n\nfunction string(propertyName: string) {\n  return concat(propertyName);\n}\n\nexport const mapAttributeNameAndValueToLabel = ({\n  attributeName,\n  attributeValue,\n  container,\n  negative = false,\n}: {\n  attributeName: string;\n  attributeValue: string | null;\n  container: Node;\n  negative?: boolean;\n}) => {", "function string(propertyName: string) {\n  return concat(propertyName);\n}\n\nexport const mapAttributeNameAndValueToLabel = ({\n  attributeName,\n  attributeValue,\n  container,\n  negative = false,\n}: {\n  attributeName: string;\n  attributeValue: string | null;\n  container: Node;\n  negative?: boolean;\n}) => {", "  if (typeof attributeValue !== \"string\") {\n    return null;\n  }\n\n  const mapper = ariaPropertyToVirtualLabelMap[attributeName];\n\n  return mapper?.({ attributeValue, container, negative }) ?? null;\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/postProcessLabels.ts", "chunked_list": ["import { postProcessAriaValueNow } from \"./postProcessAriaValueNow\";\n\nconst priorityReplacementMap: [string, string][] = [\n  [\"aria-colindextext\", \"aria-colindex\"],\n  [\"aria-rowindextext\", \"aria-rowindex\"],\n  /**\n   * If aria-valuetext is specified, assistive technologies SHOULD render that\n   * value instead of the value of aria-valuenow.\n   *\n   * REF: https://w3c.github.io/aria/#aria-valuetext", "   *\n   * REF: https://w3c.github.io/aria/#aria-valuetext\n   */\n  [\"aria-valuetext\", \"aria-valuenow\"],\n];\n\nexport const postProcessLabels = ({\n  labels,\n  role,\n}: {", "  role,\n}: {\n  labels: Record<string, { label: string; value: string }>;\n  role: string;\n}) => {\n  for (const [preferred, dropped] of priorityReplacementMap) {\n    if (labels[preferred] && labels[dropped]) {\n      labels[dropped].value = \"\";\n    }\n  }\n", "  if (labels[\"aria-valuenow\"]) {\n    labels[\"aria-valuenow\"].label = postProcessAriaValueNow({\n      value: labels[\"aria-valuenow\"].value,\n      min: labels[\"aria-valuemin\"]?.value,\n      max: labels[\"aria-valuemax\"]?.value,\n      role,\n    });\n  }\n\n  return Object.values(labels).map(({ label }) => label);\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromHtmlEquivalentAttribute.ts", "chunked_list": ["import { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\n// REF: https://www.w3.org/TR/html-aria/#docconformance-attr\nconst ariaToHTMLAttributeMapping: Record<\n  string,\n  Array<{ name: string; negative?: boolean }>\n> = {\n  \"aria-checked\": [{ name: \"checked\" }],\n  \"aria-disabled\": [{ name: \"disabled\" }],\n  // \"aria-hidden\": [{ name: \"hidden\" }],", "  \"aria-disabled\": [{ name: \"disabled\" }],\n  // \"aria-hidden\": [{ name: \"hidden\" }],\n  \"aria-placeholder\": [{ name: \"placeholder\" }],\n  \"aria-valuemax\": [{ name: \"max\" }],\n  \"aria-valuemin\": [{ name: \"min\" }],\n  \"aria-readonly\": [\n    { name: \"readonly\" },\n    { name: \"contenteditable\", negative: true },\n  ],\n  \"aria-required\": [{ name: \"required\" }],", "  ],\n  \"aria-required\": [{ name: \"required\" }],\n  \"aria-colspan\": [{ name: \"colspan\" }],\n  \"aria-rowspan\": [{ name: \"rowspan\" }],\n};\n\nexport const getLabelFromHtmlEquivalentAttribute = ({\n  attributeName,\n  container,\n  node,", "  container,\n  node,\n}: {\n  attributeName: string;\n  container: Node;\n  node: HTMLElement;\n}) => {\n  const htmlAttribute = ariaToHTMLAttributeMapping[attributeName];\n\n  if (!htmlAttribute?.length) {\n    return { label: \"\", value: \"\" };\n  }\n", "\n  if (!htmlAttribute?.length) {\n    return { label: \"\", value: \"\" };\n  }\n\n  for (const { name, negative = false } of htmlAttribute) {\n    const attributeValue = node.getAttribute(name);\n    const label = mapAttributeNameAndValueToLabel({\n      attributeName,\n      attributeValue,\n      container,\n      negative,\n    });\n", "    if (label) {\n      return { label, value: attributeValue };\n    }\n  }\n\n  return { label: \"\", value: \"\" };\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getAttributesByRole.ts", "chunked_list": ["import { ARIAPropertyMap, ARIARoleDefinitionKey, roles } from \"aria-query\";\nimport { globalStatesAndProperties } from \"../getRole\";\n\nconst ignoreAttributesWithAccessibleValue = [\"aria-placeholder\"];\n\nexport const getAttributesByRole = ({\n  accessibleValue,\n  role,\n}: {\n  accessibleValue: string;", "}: {\n  accessibleValue: string;\n  role: string;\n}) => {\n  const {\n    props: implicitRoleAttributes = {},\n    prohibitedProps: prohibitedAttributes = [],\n  } = (roles.get(role as ARIARoleDefinitionKey) ?? {}) as {\n    props: ARIAPropertyMap;\n    prohibitedProps: string[];", "    props: ARIAPropertyMap;\n    prohibitedProps: string[];\n  };\n\n  const uniqueAttributes = Array.from(\n    new Set([\n      ...Object.keys(implicitRoleAttributes),\n      ...globalStatesAndProperties,\n    ])\n  )", "    ])\n  )\n    .filter((attribute) => !prohibitedAttributes.includes(attribute))\n    .filter(\n      (attribute) =>\n        !accessibleValue ||\n        !ignoreAttributesWithAccessibleValue.includes(attribute)\n    );\n\n  return uniqueAttributes.map((attribute) => [", "\n  return uniqueAttributes.map((attribute) => [\n    attribute,\n    implicitRoleAttributes[attribute] ?? null,\n  ]);\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromImplicitHtmlElementValue.ts", "chunked_list": ["import { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\nconst mapLocalNameToImplicitValue = {\n  \"aria-level\": {\n    h1: \"1\",\n    h2: \"2\",\n    h3: \"3\",\n    h4: \"4\",\n    h5: \"5\",\n    h6: \"6\",", "    h5: \"5\",\n    h6: \"6\",\n  },\n};\n\nexport const getLabelFromImplicitHtmlElementValue = ({\n  attributeName,\n  container,\n  node,\n}: {", "  node,\n}: {\n  attributeName: string;\n  container: Node;\n  node: HTMLElement;\n}) => {\n  const { localName } = node;\n  const implicitValue = mapLocalNameToImplicitValue[attributeName]?.[localName];\n\n  return {", "\n  return {\n    label: mapAttributeNameAndValueToLabel({\n      attributeName,\n      attributeValue: implicitValue,\n      container,\n    }),\n    value: implicitValue,\n  };\n};", "  };\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/index.ts", "chunked_list": ["import { getAttributesByRole } from \"./getAttributesByRole\";\nimport { getLabelFromAriaAttribute } from \"./getLabelFromAriaAttribute\";\nimport { getLabelFromHtmlEquivalentAttribute } from \"./getLabelFromHtmlEquivalentAttribute\";\nimport { getLabelFromImplicitHtmlElementValue } from \"./getLabelFromImplicitHtmlElementValue\";\nimport { isElement } from \"../../isElement\";\nimport { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\nimport { postProcessLabels } from \"./postProcessLabels\";\n\nexport const getAccessibleAttributeLabels = ({\n  accessibleValue,", "export const getAccessibleAttributeLabels = ({\n  accessibleValue,\n  alternateReadingOrderParents,\n  container,\n  node,\n  role,\n}: {\n  accessibleValue: string;\n  alternateReadingOrderParents: Node[];\n  container: Node;", "  alternateReadingOrderParents: Node[];\n  container: Node;\n  node: Node;\n  role: string;\n}): string[] => {\n  if (!isElement(node)) {\n    return [];\n  }\n\n  const labels: Record<string, { label: string; value: string }> = {};\n  const attributes = getAttributesByRole({ accessibleValue, role });\n\n  attributes.forEach(([attributeName, implicitAttributeValue]) => {\n    const {\n      label: labelFromHtmlEquivalentAttribute,\n      value: valueFromHtmlEquivalentAttribute,\n    } = getLabelFromHtmlEquivalentAttribute({\n      attributeName,\n      container,\n      node,\n    });\n", "    if (labelFromHtmlEquivalentAttribute) {\n      labels[attributeName] = {\n        label: labelFromHtmlEquivalentAttribute,\n        value: valueFromHtmlEquivalentAttribute,\n      };\n\n      return;\n    }\n\n    const { label: labelFromAriaAttribute, value: valueFromAriaAttribute } =\n      getLabelFromAriaAttribute({\n        attributeName,\n        container,\n        node,\n      });\n", "    if (labelFromAriaAttribute) {\n      labels[attributeName] = {\n        label: labelFromAriaAttribute,\n        value: valueFromAriaAttribute,\n      };\n\n      return;\n    }\n\n    const {\n      label: labelFromImplicitHtmlElementValue,\n      value: valueFromImplicitHtmlElementValue,\n    } = getLabelFromImplicitHtmlElementValue({\n      attributeName,\n      container,\n      node,\n    });\n", "    if (labelFromImplicitHtmlElementValue) {\n      labels[attributeName] = {\n        label: labelFromImplicitHtmlElementValue,\n        value: valueFromImplicitHtmlElementValue,\n      };\n\n      return;\n    }\n\n    const labelFromImplicitAriaAttributeValue = mapAttributeNameAndValueToLabel(\n      {\n        attributeName,\n        attributeValue: implicitAttributeValue,\n        container,\n      }\n    );\n", "    if (labelFromImplicitAriaAttributeValue) {\n      labels[attributeName] = {\n        label: labelFromImplicitAriaAttributeValue,\n        value: implicitAttributeValue,\n      };\n\n      return;\n    }\n  });\n\n  const processedLabels = postProcessLabels({ labels, role }).filter(Boolean);\n\n  /**\n   * aria-flowto MUST requirements:\n   *\n   * The reading order goes both directions, and a user needs to be aware of the\n   * alternate reading order so that they can invoke the functionality.\n   *\n   * The reading order goes both directions, and a user needs to be able to\n   * travel backwards through their chosen reading order.\n   *\n   * REF: https://a11ysupport.io/tech/aria/aria-flowto_attribute\n   */", "  if (alternateReadingOrderParents.length > 0) {\n    processedLabels.push(\n      `${alternateReadingOrderParents.length} previous alternate reading ${\n        alternateReadingOrderParents.length === 1 ? \"order\" : \"orders\"\n      }`\n    );\n  }\n\n  return processedLabels;\n};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/postProcessAriaValueNow.ts", "chunked_list": ["const percentageBasedValueRoles = [\"progressbar\", \"scrollbar\"];\n\nconst isNumberLike = (value: string) => {\n  return !isNaN(parseFloat(value));\n};\n\nconst toNumber = (value: string) => parseFloat(value);\nconst toPercentageLabel = (value: number | string) => `current value ${value}%`;\n\n/**", "\n/**\n * If aria-valuetext is specified, assistive technologies render that instead\n * of the value of aria-valuenow.\n *\n * REF: https://w3c.github.io/aria/#aria-valuenow\n */\nexport const postProcessAriaValueNow = ({\n  max,\n  min,", "  max,\n  min,\n  role,\n  value,\n}: {\n  max: string;\n  min: string;\n  role: string;\n  value: string;\n}) => {\n  if (!percentageBasedValueRoles.includes(role)) {\n    return value;\n  }\n", "  value: string;\n}) => {\n  if (!percentageBasedValueRoles.includes(role)) {\n    return value;\n  }\n\n  if (!isNumberLike(value)) {\n    return value;\n  }\n\n  /**\n   * For progressbar elements and scrollbar elements, assistive technologies\n   * SHOULD render the value to users as a percent, calculated as a position\n   * on the range from aria-valuemin to aria-valuemax if both are defined,\n   * otherwise the actual value with a percent indicator. For elements with\n   * role slider and spinbutton, assistive technologies SHOULD render the\n   * actual value to users.\n   *\n   * REF: https://w3c.github.io/aria/#aria-valuenow\n   */\n", "  if (isNumberLike(max) && isNumberLike(min)) {\n    const percentage = +(\n      ((toNumber(value) - toNumber(min)) / (toNumber(max) - toNumber(min))) *\n      100\n    ).toFixed(2);\n\n    return toPercentageLabel(percentage);\n  }\n\n  return toPercentageLabel(value);\n};\n"]}
