{"filename": "image-data.d.ts", "chunked_list": ["export * from './dist/image-data'"]}
{"filename": "web.d.ts", "chunked_list": ["export * from './dist/web'"]}
{"filename": "base.d.ts", "chunked_list": ["export * from './dist/base'"]}
{"filename": "src/api.ts", "chunked_list": ["export const VALID_INPUTS = [ 'w', 's', 'a', 'd', 'i', 'j', 'k', 'l' ] as const\nexport type InputKey = typeof VALID_INPUTS[number]\n\nexport interface AddTextOptions {\n\tx?: number\n\ty?: number\n\tcolor?: string\n}\n\nexport declare class SpriteType {\n\ttype: string\n\tx: number\n\ty: number\n\treadonly dx: number\n\treadonly dy: number\n\tremove(): void\n}\n", "export declare class SpriteType {\n\ttype: string\n\tx: number\n\ty: number\n\treadonly dx: number\n\treadonly dy: number\n\tremove(): void\n}\n\nexport type Rgba = [number, number, number, number]\n", "export type Rgba = [number, number, number, number]\n\nexport interface TextElement {\n\tx: number\n\ty: number\n\tcolor: Rgba\n\tcontent: string\n}\n\nexport interface GameState {\n\tlegend: [string, string][]\n\ttexts: TextElement[]\n\tdimensions: {\n\t\twidth: number\n\t\theight: number\n\t}\n\tsprites: SpriteType[]\n\tsolids: string[]\n\tpushable: Record<string, string[]>\n\tbackground: string | null\n}\n", "export interface GameState {\n\tlegend: [string, string][]\n\ttexts: TextElement[]\n\tdimensions: {\n\t\twidth: number\n\t\theight: number\n\t}\n\tsprites: SpriteType[]\n\tsolids: string[]\n\tpushable: Record<string, string[]>\n\tbackground: string | null\n}\n", "export interface PlayTuneRes {\n\tend(): void\n\tisPlaying(): boolean\n}\n\nexport const tones: Record<string, number> = {\n\t'B0': 31,\n\t'C1': 33,\n\t'C#1': 35,\n\t'D1': 37,\n\t'D#1': 39,\n\t'E1': 41,\n\t'F1': 44,\n\t'F#1': 46,\n\t'G1': 49,\n\t'G#1': 52,\n\t'A1': 55,\n\t'A#1': 58,\n\t'B1': 62,\n\t'C2': 65,\n\t'C#2': 69,\n\t'D2': 73,\n\t'D#2': 78,\n\t'E2': 82,\n\t'F2': 87,\n\t'F#2': 93,\n\t'G2': 98,\n\t'G#2': 104,\n\t'A2': 110,\n\t'A#2': 117,\n\t'B2': 123,\n\t'C3': 131,\n\t'C#3': 139,\n\t'D3': 147,\n\t'D#3': 156,\n\t'E3': 165,\n\t'F3': 175,\n\t'F#3': 185,\n\t'G3': 196,\n\t'G#3': 208,\n\t'A3': 220,\n\t'A#3': 233,\n\t'B3': 247,\n\t'C4': 262,\n\t'C#4': 277,\n\t'D4': 294,\n\t'D#4': 311,\n\t'E4': 330,\n\t'F4': 349,\n\t'F#4': 370,\n\t'G4': 392,\n\t'G#4': 415,\n\t'A4': 440,\n\t'A#4': 466,\n\t'B4': 494,\n\t'C5': 523,\n\t'C#5': 554,\n\t'D5': 587,\n\t'D#5': 622,\n\t'E5': 659,\n\t'F5': 698,\n\t'F#5': 740,\n\t'G5': 784,\n\t'G#5': 831,\n\t'A5': 880,\n\t'A#5': 932,\n\t'B5': 988,\n\t'C6': 1047,\n\t'C#6': 1109,\n\t'D6': 1175,\n\t'D#6': 1245,\n\t'E6': 1319,\n\t'F6': 1397,\n\t'F#6': 1480,\n\t'G6': 1568,\n\t'G#6': 1661,\n\t'A6': 1760,\n\t'A#6': 1865,\n\t'B6': 1976,\n\t'C7': 2093,\n\t'C#7': 2217,\n\t'D7': 2349,\n\t'D#7': 2489,\n\t'E7': 2637,\n\t'F7': 2794,\n\t'F#7': 2960,\n\t'G7': 3136,\n\t'G#7': 3322,\n\t'A7': 3520,\n\t'A#7': 3729,\n\t'B7': 3951,\n\t'C8': 4186,\n\t'C#8': 4435,\n\t'D8': 4699,\n\t'D#8': 4978\n}\n\nexport const instruments = [ 'sine', 'triangle', 'square', 'sawtooth' ] as const", "export type InstrumentType = typeof instruments[number]\n\t\nexport const instrumentKey: Record<string, InstrumentType> = {\n\t'~': 'sine',\n\t'-': 'square',\n\t'^': 'triangle',\n\t'/': 'sawtooth'\n}\nexport const reverseInstrumentKey = Object.fromEntries(\n\tObject.entries(instrumentKey).map(([ k, v ]) => [ v, k ])\n) as Record<InstrumentType, string>\n", "export type Tune = [number, ...(InstrumentType | number | string)[]][]\n\nexport interface FullSprigAPI {\n\tmap(template: TemplateStringsArray, ...params: string[]): string\n\tbitmap(template: TemplateStringsArray, ...params: string[]): string\n\tcolor(template: TemplateStringsArray, ...params: string[]): string\n\ttune(template: TemplateStringsArray, ...params: string[]): string\n\n\tsetMap(string: string): void\n\taddText(str: string, opts?: AddTextOptions): void\n\tclearText(): void\n\taddSprite(x: number, y: number, type: string): void\n\tgetGrid(): SpriteType[][]\n\tgetTile(x: number, y: number): SpriteType[]\n\ttilesWith(...matchingTypes: string[]): SpriteType[][]\n\tclearTile(x: number, y: number): void\n\tsetSolids(types: string[]): void\n\tsetPushables(map: Record<string, string[]>): void\n\tsetBackground(type: string): void\n\tgetFirst(type: string): SpriteType | undefined\n\tgetAll(type: string): SpriteType[]\n\twidth(): number\n\theight(): number\n\n\tsetLegend(...bitmaps: [string, string][]): void\n\tonInput(key: InputKey, fn: () => void): void \n\tafterInput(fn: () => void): void\n\tplayTune(text: string, n?: number): PlayTuneRes\n\n\tsetTimeout(fn: TimerHandler, ms: number): number\n\tsetInterval(fn: TimerHandler, ms: number): number\n\tclearTimeout(id: number): void\n\tclearInterval(id: number): void\n}"]}
{"filename": "src/base/tune.ts", "chunked_list": ["/*\nsong form\n\n[\n\t[duration, instrument, pitch, duration, ...],\n]\n\nSyntax:\n500: 64.4~500 + c5~1000\n[500, 'sine', 64.4, 500, 'sine', 'c5', 1000]", "500: 64.4~500 + c5~1000\n[500, 'sine', 64.4, 500, 'sine', 'c5', 1000]\nComma between each tune element. Whitespace ignored.\n*/\n\nimport { type Tune, instrumentKey, InstrumentType, reverseInstrumentKey } from '../api.js'\n\t\nexport const textToTune = (text: string): Tune => {\n\tconst elements = text.replace(/\\s/g, '').split(',')\n\tconst tune = []\n\t", "\tfor (const element of elements) {\n\t\tif (!element) continue\n\t\tconst [durationRaw, notesRaw] = element.split(':')\n\t\tconst duration = Math.round(parseInt(durationRaw ?? '0', 10))\n\t\tconst notes = (notesRaw || '').split('+').map((noteRaw) => {\n\t\t\tif (!noteRaw) return []\n\t\t\tconst [, pitchRaw, instrumentRaw, durationRaw] = noteRaw.match(/^(.+)([~\\-^\\/])(.+)$/)!\n\t\t\treturn [\n\t\t\t\tinstrumentKey[instrumentRaw!] ?? 'sine',\n\t\t\t\tisNaN(parseInt(pitchRaw ?? '', 10)) ? pitchRaw! : parseInt(pitchRaw!, 10),\n\t\t\t\tparseInt(durationRaw ?? '0', 10)\n\t\t\t]\n\t\t})\n\t\ttune.push([duration, ...notes].flat())\n\t}\n\t\n\treturn tune as Tune\n}\n\t\nexport const tuneToText = (tune: Tune): string => {\n\tconst groupNotes = (notes: (number | string)[]) => {\n\t\tconst groups = []", "\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\tif (i % 3 === 0) {\n\t\t\t\tgroups.push([notes[i]!])\n\t\t\t} else {\n\t\t\t\tgroups[groups.length-1]!.push(notes[i]!)\n\t\t\t}\n\t\t}\n\t\treturn groups\n\t}\n\t\n\tconst notesToString = ([duration, ...notes]: Tune[number]) => (\n\t\tnotes.length === 0 \n\t\t\t? duration \n\t\t\t: `${duration}: ${groupNotes(notes).map(notesToStringHelper).join(' + ')}`\n\t)\n\t\n\tconst notesToStringHelper = ([instrument, duration, note]: (number | string)[]) => (\n\t\t`${duration}${reverseInstrumentKey[instrument as InstrumentType]}${note}`\n\t)\n\t\n\treturn tune.map(notesToString).join(',\\n')\n}"]}
{"filename": "src/base/palette.ts", "chunked_list": ["import type { Rgba } from '../api.js'\n\nexport type PaletteItem = [string, Rgba]\nexport const palette: PaletteItem[] = [\n\t// Grey\n\t['0', [0, 0, 0, 255]],\n\t['L', [73, 80, 87, 255]],\n\t['1', [145, 151, 156, 255]],\n\t['2', [248, 249, 250, 255]],\n\n\t// Red\n\t['3', [235, 44, 71, 255]],\n\t['C', [139, 65, 46, 255]],\n\n\t// Blue\n\t['7', [25, 177, 248, 255]],\n\t['5', [19, 21, 224, 255]],\n\n\t// Yellow\n\t['6', [254, 230, 16, 255]],\n\t['F', [149, 140, 50, 255]],\n\n\t// Green\n\t['4', [45, 225, 62, 255]],\n\t['D', [29, 148, 16, 255]],\n\t\n\t// Pink and purple\n\t['8', [245, 109, 187, 255]],\n\t['H', [170, 58, 197, 255]],\n\n\t// Orange\n\t['9', [245, 113, 23, 255]],\n\n\t// Transparent\n\t['.', [0, 0, 0, 0]]\n]\nexport const transparent: PaletteItem = palette.at(-1)!\n\nexport const hexToRgba = (hex: string): Rgba => {\n\tconst [ r, g, b, a ] = hex.match(/\\w\\w/g)?.map((x) => parseInt(x, 16)) ?? []\n\treturn [ r!, g!, b!, a ?? 255 ]\n}\n\nexport const rgbaToHex = (rgba: Rgba): string => {\n\treturn '#' + rgba.map(n => n.toString(16).padStart(2, '0')).join('')\n}"]}
{"filename": "src/base/text.ts", "chunked_list": ["import type { Rgba, TextElement } from '../api.js'\n\nexport function composeText(texts: TextElement[]): { char: string, color: Rgba }[][] {\n\tconst emptyCell = () => ({ char: ' ', color: [0, 0, 0, 0] as Rgba })\n\tconst range = <T>(length: number, fn: () => T): T[] => Array.from({ length }, fn)\n\tconst gridFromSize = (w: number, h: number) => range(h, () => range(w, emptyCell))\n\tconst CHARS_MAX_X = 20\n\tconst CHARS_MAX_Y = 16\n\n\tconst grid = gridFromSize(CHARS_MAX_X, CHARS_MAX_Y)\n", "\tfor (const { x: sx, y: sy, content, color } of texts) {\n\t\tlet y = sy\n\t\tfor (const line of content.split('\\n')) {\n\t\t\tlet x = sx\n\t\t\tfor (const char of line.split('')) {\n\t\t\t\tif (\" !\\\"#%&\\'()*+,./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\^_-`abcdefghijklmnopqrstuvwxyz|~\u00a6\u00a7\u00a8\u00a9\u00ac\u00ae\u00af\u00b0\u00b1\u00b4\u00b6\u00b7\u00b8\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff\u0100\u0101\u0102\u0103\u0104\u0105\u0106\u0107\u010a\u010b\u010c\u010d\u010e\u0110\u0111\u0112\u0113\u0116\u0117\u0118\u0119\u011a\u011b\u011e\u011f\u0120\u0121\u0126\u0127\u012a\u012b\u012e\u012f\u0130\u0131\u0143\u0144\u0147\u0148\u014c\u014d\u0152\u0153\u015e\u015f\u0168\u0169\u016a\u016b\u016e\u016f\u0172\u0173\u0174\u0175\u0176\u0177\u0178\u01cd\u01ce\u01cf\u01d0\u01d1\u01d2\u01d3\u01d4\u02c6\u02c7\u02d8\u02d9\u02da\u02db\u02dc\u02dd\u1e80\u1e81\u1e82\u1e83\u1e84\u1e85\u1ef2\u1ef3\u2020\u2021\u2022\u2026\u2030\u2044\u2122\u2202\u2205\u220f\u2211\u2212\u221a\u221e\u222b\u2248\u2260\u2264\u2265\u25ca\".indexOf(char) === -1)\n\t\t\t\t\tthrow new Error(`Character ${char} is not in the font. It will be rendered incorrectly.`)\n\t\t\t\tif (x <= CHARS_MAX_X && y < CHARS_MAX_Y)\n\t\t\t\t\tgrid[y]![x++] = {color: color, char}\n\t\t\t}\n\t\t\ty++\n\t\t}\n\t}\n\n\treturn grid\n}\n"]}
{"filename": "src/base/font.ts", "chunked_list": ["export const font = [\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xFF, // 00\n\t0x00, 0x00, 0x22, 0x72, 0x22, 0x3E, 0x00, 0x00, // 01\n\t0x00, 0x00, 0x12, 0x32, 0x7E, 0x32, 0x12, 0x00, // 02\n\t0x7E, 0x81, 0xB9, 0xA5, 0xB9, 0xA5, 0xB9, 0x81, // 03\n\t0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, // 04\n\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // 05\n\t0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, // 06\n\t0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x00, 0x00, // 07\n\t0x00, 0x10, 0x30, 0x7E, 0x30, 0x10, 0x00, 0x00, // 08", "\t0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x00, 0x00, // 07\n\t0x00, 0x10, 0x30, 0x7E, 0x30, 0x10, 0x00, 0x00, // 08\n\t0x00, 0x08, 0x0C, 0x7E, 0x0C, 0x08, 0x00, 0x00, // 09\n\t0x00, 0x10, 0x10, 0x10, 0x7C, 0x38, 0x10, 0x00, // 0A\n\t0x08, 0x1C, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x00, // 0B\n\t0x38, 0x30, 0x28, 0x08, 0x08, 0x08, 0x3E, 0x00, // 0C\n\t0x00, 0x00, 0x12, 0x32, 0x7E, 0x30, 0x10, 0x00, // 0D\n\t0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, // 0E\n\t0x3E, 0x7C, 0x7C, 0x3E, 0x3E, 0x7C, 0xF8, 0xF8, // 0F\n\t0x38, 0x30, 0x28, 0x04, 0x04, 0x04, 0x04, 0x00, // 10", "\t0x3E, 0x7C, 0x7C, 0x3E, 0x3E, 0x7C, 0xF8, 0xF8, // 0F\n\t0x38, 0x30, 0x28, 0x04, 0x04, 0x04, 0x04, 0x00, // 10\n\t0x7F, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x08, 0x00, // 11\n\t0x00, 0x08, 0x08, 0x08, 0x2A, 0x1C, 0x08, 0x7F, // 12\n\t0x7E, 0x81, 0x9D, 0xA1, 0xB9, 0x85, 0x85, 0xB9, // 13\n\t0x00, 0x3C, 0x42, 0x5A, 0x5A, 0x42, 0x3C, 0x00, // 14\n\t0x88, 0x44, 0x22, 0x11, 0x88, 0x44, 0x22, 0x11, // 15\n\t0x00, 0x7F, 0x22, 0x72, 0x27, 0x22, 0x7F, 0x00, // 16\n\t0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88, // 17\n\t0x00, 0x01, 0x09, 0x0D, 0x7F, 0x0D, 0x09, 0x01, // 18", "\t0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88, // 17\n\t0x00, 0x01, 0x09, 0x0D, 0x7F, 0x0D, 0x09, 0x01, // 18\n\t0x00, 0x90, 0xB0, 0xFE, 0xB0, 0x90, 0x00, 0x00, // 19\n\t0x00, 0x08, 0x7C, 0x06, 0x7C, 0x08, 0x00, 0x00, // 1A\n\t0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, // 1B\n\t0x7E, 0x81, 0xA1, 0xA1, 0xA1, 0xA1, 0xBD, 0x81, // 1C\n\t0x7E, 0x81, 0xB9, 0xA5, 0xB9, 0xA5, 0xA5, 0x81, // 1D\n\t0x7E, 0x81, 0x99, 0xA1, 0xA1, 0xA1, 0x99, 0x81, // 1E\n\t0x00, 0x10, 0x3E, 0x60, 0x3E, 0x10, 0x00, 0x00, // 1F\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 20", "\t0x00, 0x10, 0x3E, 0x60, 0x3E, 0x10, 0x00, 0x00, // 1F\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 20\n\t0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x00, // 21\n\t0x77, 0x33, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, // 22\n\t0x36, 0x36, 0xFE, 0x6C, 0xFE, 0xD8, 0xD8, 0x00, // 23\n\t0x18, 0x3E, 0x6C, 0x3E, 0x1B, 0x1B, 0x7E, 0x18, // 24\n\t0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, // 25\n\t0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, // 26\n\t0x1C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, // 27\n\t0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, // 28", "\t0x1C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, // 27\n\t0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, // 28\n\t0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00, // 29\n\t0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, // 2A\n\t0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00, // 2B\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x0C, 0x18, // 2C\n\t0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, // 2D\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, // 2E\n\t0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, // 2F\n\t0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, // 30", "\t0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, // 2F\n\t0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, // 30\n\t0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, // 31\n\t0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, // 32\n\t0xFC, 0x18, 0x30, 0x78, 0x0C, 0xCC, 0x78, 0x00, // 33\n\t0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, // 34\n\t0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00, // 35\n\t0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, // 36\n\t0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, // 37\n\t0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, // 38", "\t0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, // 37\n\t0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, // 38\n\t0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00, // 39\n\t0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, // 3A\n\t0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, // 3B\n\t0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, // 3C\n\t0x00, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x00, // 3D\n\t0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, // 3E\n\t0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00, // 3F\n\t0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, // 40", "\t0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00, // 3F\n\t0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, // 40\n\t0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00, // 41\n\t0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, // 42\n\t0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, // 43\n\t0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, // 44\n\t0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, // 45\n\t0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, // 46\n\t0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3C, 0x00, // 47\n\t0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, // 48", "\t0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3C, 0x00, // 47\n\t0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, // 48\n\t0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, // 49\n\t0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, // 4A\n\t0xE6, 0x66, 0x6C, 0x70, 0x6C, 0x66, 0xE6, 0x00, // 4B\n\t0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, // 4C\n\t0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00, // 4D\n\t0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, // 4E\n\t0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, // 4F\n\t0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, // 50", "\t0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, // 4F\n\t0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, // 50\n\t0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00, // 51\n\t0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, // 52\n\t0x7C, 0xC6, 0xF0, 0x3C, 0x0E, 0xC6, 0x7C, 0x00, // 53\n\t0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, // 54\n\t0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 55\n\t0xCC, 0xCC, 0xCC, 0x78, 0x78, 0x30, 0x30, 0x00, // 56\n\t0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, // 57\n\t0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, // 58", "\t0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, // 57\n\t0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, // 58\n\t0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00, // 59\n\t0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, // 5A\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 5B\n\t0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, // 5C\n\t0x00, 0xFE, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, // 5D\n\t0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, // 5E\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, // 5F\n\t0x3C, 0x42, 0x99, 0xA1, 0xA1, 0x99, 0x42, 0x3C, // 60", "\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, // 5F\n\t0x3C, 0x42, 0x99, 0xA1, 0xA1, 0x99, 0x42, 0x3C, // 60\n\t0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, // 61\n\t0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00, // 62\n\t0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00, // 63\n\t0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 64\n\t0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, // 65\n\t0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, // 66\n\t0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 67\n\t0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, // 68", "\t0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 67\n\t0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, // 68\n\t0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0xFC, 0x00, // 69\n\t0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, // 6A\n\t0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00, // 6B\n\t0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, // 6C\n\t0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, // 6D\n\t0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, // 6E\n\t0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 6F\n\t0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, // 70", "\t0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 6F\n\t0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, // 70\n\t0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E, // 71\n\t0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, // 72\n\t0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00, // 73\n\t0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, // 74\n\t0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 75\n\t0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, // 76\n\t0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00, // 77\n\t0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, // 78", "\t0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00, // 77\n\t0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, // 78\n\t0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 79\n\t0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, // 7A\n\t0x6C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, // 7B\n\t0xCC, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 7C\n\t0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 7D\n\t0x3C, 0x66, 0x66, 0x6C, 0x66, 0x66, 0x6C, 0xF0, // 7E\n\t0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF, // 7F\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x00, // 80", "\t0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF, // 7F\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x00, // 80\n\t0xFF, 0xFF, 0xDD, 0x8D, 0xDD, 0xC1, 0xFF, 0xFF, // 81\n\t0xFF, 0xFF, 0xED, 0xCD, 0x81, 0xCD, 0xED, 0xFF, // 82\n\t0x81, 0x7E, 0x46, 0x5A, 0x46, 0x5A, 0x46, 0x7E, // 83\n\t0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, // 84\n\t0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, // 85\n\t0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, // 86\n\t0xFF, 0xFF, 0xC3, 0xBD, 0xBD, 0x81, 0xFF, 0xFF, // 87\n\t0xFF, 0xEF, 0xCF, 0x81, 0xCF, 0xEF, 0xFF, 0xFF, // 88", "\t0xFF, 0xFF, 0xC3, 0xBD, 0xBD, 0x81, 0xFF, 0xFF, // 87\n\t0xFF, 0xEF, 0xCF, 0x81, 0xCF, 0xEF, 0xFF, 0xFF, // 88\n\t0xFF, 0xF7, 0xF3, 0x81, 0xF3, 0xF7, 0xFF, 0xFF, // 89\n\t0xFF, 0xEF, 0xEF, 0xEF, 0x83, 0xC7, 0xEF, 0xFF, // 8A\n\t0xF7, 0xE3, 0xC1, 0xF7, 0xF7, 0xF7, 0xF7, 0xFF, // 8B\n\t0xC7, 0xCF, 0xD7, 0xF7, 0xF7, 0xF7, 0xC1, 0xFF, // 8C\n\t0xFF, 0xFF, 0xED, 0xCD, 0x81, 0xCF, 0xEF, 0xFF, // 8D\n\t0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, // 8E\n\t0xC1, 0x83, 0x83, 0xC1, 0xC1, 0x83, 0x07, 0x07, // 8F\n\t0xC7, 0xCF, 0xD7, 0xFB, 0xFB, 0xFB, 0xFB, 0xFF, // 90", "\t0xC1, 0x83, 0x83, 0xC1, 0xC1, 0x83, 0x07, 0x07, // 8F\n\t0xC7, 0xCF, 0xD7, 0xFB, 0xFB, 0xFB, 0xFB, 0xFF, // 90\n\t0x80, 0xF7, 0xE3, 0xD5, 0xF7, 0xF7, 0xF7, 0xFF, // 91\n\t0xFF, 0xF7, 0xF7, 0xF7, 0xD5, 0xE3, 0xF7, 0x80, // 92\n\t0x81, 0x7E, 0x62, 0x5E, 0x46, 0x7A, 0x7A, 0x46, // 93\n\t0xFF, 0xC3, 0xBD, 0xA5, 0xA5, 0xBD, 0xC3, 0xFF, // 94\n\t0x77, 0xBB, 0xDD, 0xEE, 0x77, 0xBB, 0xDD, 0xEE, // 95\n\t0xFF, 0x80, 0xDD, 0x8D, 0xD8, 0xDD, 0x80, 0xFF, // 96\n\t0xEE, 0xDD, 0xBB, 0x77, 0xEE, 0xDD, 0xBB, 0x77, // 97\n\t0xFF, 0xFE, 0xF6, 0xF2, 0x80, 0xF2, 0xF6, 0xFE, // 98", "\t0xEE, 0xDD, 0xBB, 0x77, 0xEE, 0xDD, 0xBB, 0x77, // 97\n\t0xFF, 0xFE, 0xF6, 0xF2, 0x80, 0xF2, 0xF6, 0xFE, // 98\n\t0xFF, 0x6F, 0x4F, 0x01, 0x4F, 0x6F, 0xFF, 0xFF, // 99\n\t0xFF, 0xF7, 0x83, 0xF9, 0x83, 0xF7, 0xFF, 0xFF, // 9A\n\t0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC, // 9B\n\t0x81, 0x7E, 0x5E, 0x5E, 0x5E, 0x5E, 0x42, 0x7E, // 9C\n\t0x81, 0x7E, 0x46, 0x5A, 0x46, 0x5A, 0x5A, 0x7E, // 9D\n\t0x81, 0x7E, 0x66, 0x5E, 0x5E, 0x5E, 0x66, 0x7E, // 9E\n\t0xFF, 0xEF, 0xC1, 0x9F, 0xC1, 0xEF, 0xFF, 0xFF, // 9F\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A0", "\t0xFF, 0xEF, 0xC1, 0x9F, 0xC1, 0xEF, 0xFF, 0xFF, // 9F\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A0\n\t0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xCF, 0xFF, // A1\n\t0x88, 0xCC, 0x99, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A2\n\t0xC9, 0xC9, 0x01, 0x93, 0x01, 0x27, 0x27, 0xFF, // A3\n\t0xE7, 0xC1, 0x93, 0xC1, 0xE4, 0xE4, 0x81, 0xE7, // A4\n\t0xFF, 0x39, 0x33, 0xE7, 0xCF, 0x99, 0x39, 0xFF, // A5\n\t0xC7, 0x93, 0xC7, 0x89, 0x23, 0x33, 0x89, 0xFF, // A6\n\t0xE3, 0xF3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A7\n\t0xE7, 0xCF, 0x9F, 0x9F, 0x9F, 0xCF, 0xE7, 0xFF, // A8", "\t0xE3, 0xF3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A7\n\t0xE7, 0xCF, 0x9F, 0x9F, 0x9F, 0xCF, 0xE7, 0xFF, // A8\n\t0x9F, 0xCF, 0xE7, 0xE7, 0xE7, 0xCF, 0x9F, 0xFF, // A9\n\t0xFF, 0x99, 0xC3, 0x00, 0xC3, 0x99, 0xFF, 0xFF, // AA\n\t0xFF, 0xCF, 0xCF, 0x03, 0xCF, 0xCF, 0xFF, 0xFF, // AB\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xF3, 0xE7, // AC\n\t0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, // AD\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xFF, // AE\n\t0xF9, 0xF3, 0xE7, 0xCF, 0x9F, 0x3F, 0x7F, 0xFF, // AF\n\t0x83, 0x39, 0x31, 0x21, 0x09, 0x19, 0x83, 0xFF, // B0", "\t0xF9, 0xF3, 0xE7, 0xCF, 0x9F, 0x3F, 0x7F, 0xFF, // AF\n\t0x83, 0x39, 0x31, 0x21, 0x09, 0x19, 0x83, 0xFF, // B0\n\t0xCF, 0x8F, 0xCF, 0xCF, 0xCF, 0xCF, 0x03, 0xFF, // B1\n\t0x87, 0x33, 0xF3, 0xC7, 0x9F, 0x33, 0x03, 0xFF, // B2\n\t0x03, 0xE7, 0xCF, 0x87, 0xF3, 0x33, 0x87, 0xFF, // B3\n\t0xE3, 0xC3, 0x93, 0x33, 0x01, 0xF3, 0xE1, 0xFF, // B4\n\t0x03, 0x3F, 0x07, 0xF3, 0xF3, 0x33, 0x87, 0xFF, // B5\n\t0xC7, 0x9F, 0x3F, 0x07, 0x33, 0x33, 0x87, 0xFF, // B6\n\t0x03, 0x33, 0xF3, 0xE7, 0xCF, 0xCF, 0xCF, 0xFF, // B7\n\t0x87, 0x33, 0x33, 0x87, 0x33, 0x33, 0x87, 0xFF, // B8", "\t0x03, 0x33, 0xF3, 0xE7, 0xCF, 0xCF, 0xCF, 0xFF, // B7\n\t0x87, 0x33, 0x33, 0x87, 0x33, 0x33, 0x87, 0xFF, // B8\n\t0x87, 0x33, 0x33, 0x83, 0xF3, 0xE7, 0x8F, 0xFF, // B9\n\t0xFF, 0xFF, 0xCF, 0xCF, 0xFF, 0xCF, 0xCF, 0xFF, // BA\n\t0xFF, 0xFF, 0xCF, 0xCF, 0xFF, 0xCF, 0xCF, 0x9F, // BB\n\t0xE7, 0xCF, 0x9F, 0x3F, 0x9F, 0xCF, 0xE7, 0xFF, // BC\n\t0xFF, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, // BD\n\t0x9F, 0xCF, 0xE7, 0xF3, 0xE7, 0xCF, 0x9F, 0xFF, // BE\n\t0x87, 0x33, 0xF3, 0xE7, 0xCF, 0xFF, 0xCF, 0xFF, // BF\n\t0x83, 0x39, 0x21, 0x21, 0x21, 0x3F, 0x87, 0xFF, // C0", "\t0x87, 0x33, 0xF3, 0xE7, 0xCF, 0xFF, 0xCF, 0xFF, // BF\n\t0x83, 0x39, 0x21, 0x21, 0x21, 0x3F, 0x87, 0xFF, // C0\n\t0xCF, 0x87, 0x33, 0x33, 0x03, 0x33, 0x33, 0xFF, // C1\n\t0x03, 0x99, 0x99, 0x83, 0x99, 0x99, 0x03, 0xFF, // C2\n\t0xC3, 0x99, 0x3F, 0x3F, 0x3F, 0x99, 0xC3, 0xFF, // C3\n\t0x07, 0x93, 0x99, 0x99, 0x99, 0x93, 0x07, 0xFF, // C4\n\t0x01, 0x9D, 0x97, 0x87, 0x97, 0x9D, 0x01, 0xFF, // C5\n\t0x01, 0x9D, 0x97, 0x87, 0x97, 0x9F, 0x0F, 0xFF, // C6\n\t0xC3, 0x99, 0x3F, 0x3F, 0x31, 0x99, 0xC3, 0xFF, // C7\n\t0x33, 0x33, 0x33, 0x03, 0x33, 0x33, 0x33, 0xFF, // C8", "\t0xC3, 0x99, 0x3F, 0x3F, 0x31, 0x99, 0xC3, 0xFF, // C7\n\t0x33, 0x33, 0x33, 0x03, 0x33, 0x33, 0x33, 0xFF, // C8\n\t0x87, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x87, 0xFF, // C9\n\t0xE1, 0xF3, 0xF3, 0xF3, 0x33, 0x33, 0x87, 0xFF, // CA\n\t0x19, 0x99, 0x93, 0x8F, 0x93, 0x99, 0x19, 0xFF, // CB\n\t0x0F, 0x9F, 0x9F, 0x9F, 0x9D, 0x99, 0x01, 0xFF, // CC\n\t0x39, 0x11, 0x01, 0x29, 0x39, 0x39, 0x39, 0xFF, // CD\n\t0x39, 0x19, 0x09, 0x21, 0x31, 0x39, 0x39, 0xFF, // CE\n\t0xC7, 0x93, 0x39, 0x39, 0x39, 0x93, 0xC7, 0xFF, // CF\n\t0x03, 0x99, 0x99, 0x83, 0x9F, 0x9F, 0x0F, 0xFF, // D0", "\t0xC7, 0x93, 0x39, 0x39, 0x39, 0x93, 0xC7, 0xFF, // CF\n\t0x03, 0x99, 0x99, 0x83, 0x9F, 0x9F, 0x0F, 0xFF, // D0\n\t0x87, 0x33, 0x33, 0x33, 0x23, 0x87, 0xE3, 0xFF, // D1\n\t0x03, 0x99, 0x99, 0x83, 0x93, 0x99, 0x19, 0xFF, // D2\n\t0x83, 0x39, 0x0F, 0xC3, 0xF1, 0x39, 0x83, 0xFF, // D3\n\t0x03, 0x4B, 0xCF, 0xCF, 0xCF, 0xCF, 0x87, 0xFF, // D4\n\t0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x87, 0xFF, // D5\n\t0x33, 0x33, 0x33, 0x87, 0x87, 0xCF, 0xCF, 0xFF, // D6\n\t0x39, 0x39, 0x39, 0x29, 0x01, 0x11, 0x39, 0xFF, // D7\n\t0x39, 0x39, 0x93, 0xC7, 0x93, 0x39, 0x39, 0xFF, // D8", "\t0x39, 0x39, 0x39, 0x29, 0x01, 0x11, 0x39, 0xFF, // D7\n\t0x39, 0x39, 0x93, 0xC7, 0x93, 0x39, 0x39, 0xFF, // D8\n\t0x33, 0x33, 0x33, 0x87, 0xCF, 0xCF, 0x87, 0xFF, // D9\n\t0x01, 0x39, 0x73, 0xE7, 0xCD, 0x99, 0x01, 0xFF, // DA\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // DB\n\t0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, // DC\n\t0xFF, 0x01, 0xF9, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, // DD\n\t0xEF, 0xC7, 0x93, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, // DE\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, // DF\n\t0xC3, 0xBD, 0x66, 0x5E, 0x5E, 0x66, 0xBD, 0xC3, // E0", "\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, // DF\n\t0xC3, 0xBD, 0x66, 0x5E, 0x5E, 0x66, 0xBD, 0xC3, // E0\n\t0xFF, 0xFF, 0x87, 0xF3, 0x83, 0x33, 0x89, 0xFF, // E1\n\t0x1F, 0x9F, 0x83, 0x99, 0x99, 0x99, 0x23, 0xFF, // E2\n\t0xFF, 0xFF, 0x87, 0x33, 0x3F, 0x33, 0x87, 0xFF, // E3\n\t0xE3, 0xF3, 0x83, 0x33, 0x33, 0x33, 0x89, 0xFF, // E4\n\t0xFF, 0xFF, 0x87, 0x33, 0x03, 0x3F, 0x87, 0xFF, // E5\n\t0xC7, 0x93, 0x9F, 0x0F, 0x9F, 0x9F, 0x0F, 0xFF, // E6\n\t0xFF, 0xFF, 0x89, 0x33, 0x33, 0x83, 0xF3, 0x07, // E7\n\t0x1F, 0x9F, 0x93, 0x89, 0x99, 0x99, 0x19, 0xFF, // E8", "\t0xFF, 0xFF, 0x89, 0x33, 0x33, 0x83, 0xF3, 0x07, // E7\n\t0x1F, 0x9F, 0x93, 0x89, 0x99, 0x99, 0x19, 0xFF, // E8\n\t0xCF, 0xFF, 0x8F, 0xCF, 0xCF, 0xCF, 0x03, 0xFF, // E9\n\t0xF3, 0xFF, 0xE3, 0xF3, 0xF3, 0x33, 0x33, 0x87, // EA\n\t0x1F, 0x9F, 0x99, 0x93, 0x87, 0x93, 0x19, 0xFF, // EB\n\t0x8F, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x03, 0xFF, // EC\n\t0xFF, 0xFF, 0x33, 0x01, 0x01, 0x29, 0x39, 0xFF, // ED\n\t0xFF, 0xFF, 0x07, 0x33, 0x33, 0x33, 0x33, 0xFF, // EE\n\t0xFF, 0xFF, 0x87, 0x33, 0x33, 0x33, 0x87, 0xFF, // EF\n\t0xFF, 0xFF, 0x23, 0x99, 0x99, 0x83, 0x9F, 0x0F, // F0", "\t0xFF, 0xFF, 0x87, 0x33, 0x33, 0x33, 0x87, 0xFF, // EF\n\t0xFF, 0xFF, 0x23, 0x99, 0x99, 0x83, 0x9F, 0x0F, // F0\n\t0xFF, 0xFF, 0x89, 0x33, 0x33, 0x83, 0xF3, 0xE1, // F1\n\t0xFF, 0xFF, 0x23, 0x89, 0x99, 0x9F, 0x0F, 0xFF, // F2\n\t0xFF, 0xFF, 0x83, 0x3F, 0x87, 0xF3, 0x07, 0xFF, // F3\n\t0xEF, 0xCF, 0x83, 0xCF, 0xCF, 0xCB, 0xE7, 0xFF, // F4\n\t0xFF, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x89, 0xFF, // F5\n\t0xFF, 0xFF, 0x33, 0x33, 0x33, 0x87, 0xCF, 0xFF, // F6\n\t0xFF, 0xFF, 0x39, 0x29, 0x01, 0x01, 0x93, 0xFF, // F7\n\t0xFF, 0xFF, 0x39, 0x93, 0xC7, 0x93, 0x39, 0xFF, // F8", "\t0xFF, 0xFF, 0x39, 0x29, 0x01, 0x01, 0x93, 0xFF, // F7\n\t0xFF, 0xFF, 0x39, 0x93, 0xC7, 0x93, 0x39, 0xFF, // F8\n\t0xFF, 0xFF, 0x33, 0x33, 0x33, 0x83, 0xF3, 0x07, // F9\n\t0xFF, 0xFF, 0x03, 0x67, 0xCF, 0x9B, 0x03, 0xFF, // FA\n\t0x93, 0xFF, 0x87, 0xF3, 0x83, 0x33, 0x89, 0xFF, // FB\n\t0x33, 0xFF, 0x87, 0x33, 0x33, 0x33, 0x87, 0xFF, // FC\n\t0x33, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x89, 0xFF, // FD\n\t0xC3, 0x99, 0x99, 0x93, 0x99, 0x99, 0x93, 0x0F, // FE\n\t0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00, // FF\n]", "\t0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00, // FF\n]"]}
{"filename": "src/base/index.ts", "chunked_list": ["import type { AddTextOptions, FullSprigAPI, GameState, SpriteType } from '../api.js'\nimport { palette } from './palette.js'\n\nexport * from './font.js'\nexport * from './palette.js'\nexport * from './text.js'\nexport * from './tune.js'\n\n// Tagged template literal factory go brrr\nconst _makeTag = <T>(cb: (string: string) => T) => {", "// Tagged template literal factory go brrr\nconst _makeTag = <T>(cb: (string: string) => T) => {\n\treturn (strings: TemplateStringsArray, ...interps: string[]) => {\n\t\tif (typeof strings === 'string') {\n\t\t\tthrow new Error('Tagged template literal must be used like name`text`, instead of name(`text`)')\n\t\t}\n\t\tconst string = strings.reduce((p, c, i) => p + c + (interps[i] ?? ''), '')\n\t\treturn cb(string)\n\t}\n}\n", "export type BaseEngineAPI = Pick<\n\tFullSprigAPI,\n\t| 'setMap'\n\t| 'addText'\n\t| 'clearText'\n\t| 'addSprite'\n\t| 'getGrid'\n\t| 'getTile'\n\t| 'tilesWith'\n\t| 'clearTile'\n\t| 'setSolids'\n\t| 'setPushables'\n\t| 'setBackground'\n\t| 'map'\n\t| 'bitmap'\n\t| 'color'\n\t| 'tune'\n\t| 'getFirst'\n\t| 'getAll'\n\t| 'width'\n\t| 'height'\n>", "export function baseEngine(): { api: BaseEngineAPI, state: GameState } {\n\tconst gameState: GameState = {\n\t\tlegend: [],\n\t\ttexts: [],\n\t\tdimensions: {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t},\n\t\tsprites: [],\n\t\tsolids: [],\n\t\tpushable: {},\n\t\tbackground: null\n\t}\n", "\tclass Sprite implements SpriteType {\n\t\t_type: string\n\t\t_x: number\n\t\t_y: number\n\t\tdx: number\n\t\tdy: number\n\n\t\tconstructor(type: string, x: number, y: number) {\n\t\t\tthis._type = type\n\t\t\tthis._x = x\n\t\t\tthis._y = y\n\t\t\tthis.dx = 0\n\t\t\tthis.dy = 0\n\t\t}\n\n\t\tset type(newType) {\n\t\t\tconst legendDict = Object.fromEntries(gameState.legend)", "\t\t\tif (!(newType in legendDict)) throw new Error(`\"${newType}\" isn\\'t in the legend.`)\n\t\t\tthis.remove()\n\t\t\taddSprite(this._x, this._y, newType)\n\t\t}\n\n\t\tget type() {\n\t\t\treturn this._type\n\t\t}\n\n\t\tset x(newX) {\n\t\t\tconst dx = newX - this.x", "\t\t\tif (_canMoveToPush(this, dx, 0)) this.dx = dx\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x\n\t\t}\n\n\t\tset y(newY) {\n\t\t\tconst dy = newY - this.y\n\t\t\tif (_canMoveToPush(this, 0, dy)) this.dy = dy\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y\n\t\t}\n\n\t\tremove() {\n\t\t\tgameState.sprites = gameState.sprites.filter(s => s !== this)\n\t\t\treturn this\n\t\t}\n\t}\n\n\tconst _canMoveToPush = (sprite: Sprite, dx: number, dy: number): boolean => {\n\t\tconst { x, y, type } = sprite\n\t\tconst { width, height } = gameState.dimensions\n\t\tconst i = (x+dx)+(y+dy)*width\n\n\t\tconst inBounds = (x+dx < width && x+dx >= 0 && y+dy < height && y+dy >= 0)", "\t\t\tif (_canMoveToPush(this, 0, dy)) this.dy = dy\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y\n\t\t}\n\n\t\tremove() {\n\t\t\tgameState.sprites = gameState.sprites.filter(s => s !== this)\n\t\t\treturn this\n\t\t}\n\t}\n\n\tconst _canMoveToPush = (sprite: Sprite, dx: number, dy: number): boolean => {\n\t\tconst { x, y, type } = sprite\n\t\tconst { width, height } = gameState.dimensions\n\t\tconst i = (x+dx)+(y+dy)*width\n\n\t\tconst inBounds = (x+dx < width && x+dx >= 0 && y+dy < height && y+dy >= 0)", "\t\tif (!inBounds) return false\n\n\t\tconst grid = getGrid()\n\n\t\tconst notSolid = !gameState.solids.includes(type)\n\t\tconst noMovement = dx === 0 && dy === 0\n\t\tconst movingToEmpty = i < grid.length && grid[i]!.length === 0\n\n\t\tif (notSolid || noMovement || movingToEmpty) {\n\t\t\tsprite._x += dx\n\t\t\tsprite._y += dy\n\t\t\treturn true\n\t\t}\n\n\t\tlet canMove = true\n\n\t\tconst { pushable }  = gameState\n\n\t\tgrid[i]!.forEach(sprite => {\n\t\t\tconst isSolid = gameState.solids.includes(sprite.type)", "\t\tif (notSolid || noMovement || movingToEmpty) {\n\t\t\tsprite._x += dx\n\t\t\tsprite._y += dy\n\t\t\treturn true\n\t\t}\n\n\t\tlet canMove = true\n\n\t\tconst { pushable }  = gameState\n\n\t\tgrid[i]!.forEach(sprite => {\n\t\t\tconst isSolid = gameState.solids.includes(sprite.type)", "\t\t\tconst isPushable = (type in pushable) && pushable[type]!.includes(sprite.type)\n\n\t\t\tif (isSolid && !isPushable)\n\t\t\t\tcanMove = false\n\n\t\t\tif (isSolid && isPushable) {\n\t\t\t\tcanMove = canMove && _canMoveToPush(sprite as Sprite, dx, dy)\n\t\t\t}\n\t\t})\n\n\t\tif (canMove) {\n\t\t\tsprite._x += dx\n\t\t\tsprite._y += dy\n\t\t}\n\n\t\treturn canMove\n\t}\n\n\tconst getGrid = (): SpriteType[][] => {\n\t\tconst { width, height } = gameState.dimensions\n\n\t\tconst grid: SpriteType[][] = new Array(width*height).fill(0).map(_ => [])\n\t\tgameState.sprites.forEach(s => {\n\t\t\tconst i = s.x+s.y*width\n\t\t\tgrid[i]!.push(s)\n\t\t})\n\n\t\tconst legendIndex = (t: SpriteType) => gameState.legend.findIndex(l => l[0] == t.type)", "\t\tif (canMove) {\n\t\t\tsprite._x += dx\n\t\t\tsprite._y += dy\n\t\t}\n\n\t\treturn canMove\n\t}\n\n\tconst getGrid = (): SpriteType[][] => {\n\t\tconst { width, height } = gameState.dimensions\n\n\t\tconst grid: SpriteType[][] = new Array(width*height).fill(0).map(_ => [])\n\t\tgameState.sprites.forEach(s => {\n\t\t\tconst i = s.x+s.y*width\n\t\t\tgrid[i]!.push(s)\n\t\t})\n\n\t\tconst legendIndex = (t: SpriteType) => gameState.legend.findIndex(l => l[0] == t.type)", "\t\tfor (const tile of grid) tile.sort((a, b) => legendIndex(a) - legendIndex(b))\n\n\t\treturn grid\n\t}\n\n\tconst _checkBounds = (x: number, y: number): void => {\n\t\tconst { width, height } = gameState.dimensions\n\t\tif (x >= width || x < 0 || y < 0 || y >= height) throw new Error(`Sprite out of bounds.`)\n\t}\n\n\tconst _checkLegend = (type: string): void => {", "\t\tif (!(type in Object.fromEntries(gameState.legend)))\n\t\t\tthrow new Error(`Unknown sprite type: ${type}`)\n\t}\n\n\tconst addSprite = (x: number, y: number, type: string): void => {\n\t\tif (type === '.') return\n\n\t\t_checkBounds(x, y)\n\t\t_checkLegend(type)\n\n\t\tconst s = new Sprite(type, x, y)\n\t\tgameState.sprites.push(s)\n\t}\n\t\n\tconst _allEqual = <T>(arr: T[]): boolean => arr.every(val => val === arr[0])\n\n\tconst setMap = (string: string): void => {", "\t\tif (!string) throw new Error('Tried to set empty map.')\n\n\t\tif (string.constructor == Object) throw new Error('setMap() takes a string, not a dict.') // https://stackoverflow.com/a/51285298\n\t\tif (Array.isArray(string)) throw new Error('It looks like you passed an array into setMap(). Did you mean to use something like setMap(levels[level]) instead of setMap(levels)?')\n\t\t\n\t\tconst rows = string.trim().split(\"\\n\").map(x => x.trim())\n\t\tconst rowLengths = rows.map(x => x.length)\n\t\tconst isRect = _allEqual(rowLengths)\n\t\tif (!isRect) throw new Error('Level must be rectangular.')\n\t\tconst w = rows[0]?.length ?? 0\n\t\tconst h = rows.length\n\t\tgameState.dimensions.width = w\n\t\tgameState.dimensions.height = h\n\n\t\tgameState.sprites = []\n\n\t\tconst nonSpace = string.split(\"\").filter(x => x !== \" \" && x !== \"\\n\") // \\S regex was too slow", "\t\tif (!isRect) throw new Error('Level must be rectangular.')\n\t\tconst w = rows[0]?.length ?? 0\n\t\tconst h = rows.length\n\t\tgameState.dimensions.width = w\n\t\tgameState.dimensions.height = h\n\n\t\tgameState.sprites = []\n\n\t\tconst nonSpace = string.split(\"\").filter(x => x !== \" \" && x !== \"\\n\") // \\S regex was too slow\n\t\tfor (let i = 0; i < w*h; i++) {\n\t\t\tconst type = nonSpace[i]!", "\t\tfor (let i = 0; i < w*h; i++) {\n\t\t\tconst type = nonSpace[i]!\n\t\t\tif (type === '.') continue\n\n\t\t\tconst x = i%w \n\t\t\tconst y = Math.floor(i/w)\n\n\t\t\taddSprite(x, y, type)\n\t\t}\n\t}\n\n\tconst clearTile = (x: number, y: number): void => {\n\t\tgameState.sprites = gameState.sprites.filter(s => s.x !== x || s.y !== y)\n\t}\n\n\tconst addText = (str: string, opts: AddTextOptions = {}): void => {\n\t\tconst CHARS_MAX_X = 21\n\t\tconst padLeft = Math.floor((CHARS_MAX_X - str.length)/2)\n", "\t\tif (Array.isArray(opts.color)) throw new Error('addText no longer takes an RGBA color. Please use a Sprig color instead with \\\"{ color: color`` }\\\"')\n\t\tconst [, rgba ] = palette.find(([key]) => key === opts.color) ?? palette.find(([key]) => key === 'L')!\n\n\t\tgameState.texts.push({\n\t\t\tx: opts.x ?? padLeft,\n\t\t\ty: opts.y ?? 0,\n\t\t\tcolor: rgba,\n\t\t\tcontent: str\n\t\t})\n\t}\n\n\tconst clearText = (): void => { gameState.texts = [] }\n\n\tconst getTile = (x: number, y: number): SpriteType[] => {", "\t\tif (y < 0) return []\n\t\tif (x < 0) return []\n\t\tif (y >= gameState.dimensions.height) return []\n\t\tif (x >= gameState.dimensions.width) return []\n\n\t\treturn getGrid()[gameState.dimensions.width*y+x] ?? []\n\t}\n\n\tconst _hasDuplicates = <T>(array: T[]): boolean => (new Set(array)).size !== array.length\n\n\tconst tilesWith = (...matchingTypes: string[]): SpriteType[][] => {\n\t\tconst { width, height } = gameState.dimensions\n\t\tconst tiles: SpriteType[][] = []\n\t\tconst grid = getGrid()", "\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst tile = grid[width*y+x] || []\n\t\t\t\tconst matchIndices = matchingTypes.map(type => {\n\t\t\t\t\treturn tile.map(s => s.type).indexOf(type)\n\t\t\t\t})\n\t\t\t\tif (!_hasDuplicates(matchIndices) && !matchIndices.includes(-1)) tiles.push(tile)\n\t\t\t}\n\t\t}\n\t\treturn tiles\n\t}\n\n\tconst setSolids = (arr: string[]): void => { ", "\t\tif (!Array.isArray(arr)) throw new Error('The sprites passed into setSolids() need to be an array.')\n\t\tgameState.solids = arr \n\t}\n\tconst setPushables = (map: Record<string, string[]>): void => { \n\t\tfor (const key in map) {\n\t\t\tif(key.length != 1) {\n\t\t\t\tthrow new Error('Your sprite name must be wrapped in [] brackets here.');\n\t\t\t}\n\t\t\t_checkLegend(key)\n\t\t}\n\t\tgameState.pushable = map \n\t}\n\n\tconst api: BaseEngineAPI = {\n\t\tsetMap, \n\t\taddText,\n\t\tclearText,\n\t\taddSprite,\n\t\tgetGrid,\n\t\tgetTile,\n\t\ttilesWith,\n\t\tclearTile, \n\t\tsetSolids, \n\t\tsetPushables, \n\t\tsetBackground: (type: string) => { gameState.background = type },\n\t\tmap: _makeTag(text => text),\n\t\tbitmap: _makeTag(text => text),\n\t\tcolor: _makeTag(text => text),\n\t\ttune: _makeTag(text => text),\n\t\tgetFirst: (type: string): SpriteType | undefined => gameState.sprites.find(t => t.type === type), // **\n\t\tgetAll: (type: string): SpriteType[] => type ? gameState.sprites.filter(t => t.type === type) : gameState.sprites, // **\n\t\twidth: () => gameState.dimensions.width,\n\t\theight: () => gameState.dimensions.height\n\t}\n\n\treturn { api, state: gameState }\n}\n"]}
{"filename": "src/image-data/bitmap.ts", "chunked_list": ["import { palette } from '../base/index.js'\n\n// At odds with in-game behavior... doesn't enforce a size with stretching.\nexport const bitmapTextToImageData = (text: string): ImageData => {\n  const rows = text.trim().split(\"\\n\").map(x => x.trim())\n  const rowLengths = rows.map(x => x.length)\n  const isRect = rowLengths.every(val => val === rowLengths[0])\n  if (!isRect) throw new Error(\"Level must be rect.\")\n  const width = rows[0]!.length || 1\n  const height = rows.length || 1\n  const data = new Uint8ClampedArray(width*height*4)\n  \n  const colors = Object.fromEntries(palette)\n  \n  const nonSpace = text.split('').filter(x => x !== ' ' && x !== '\\n') // \\S regex led to massive perf problems", "  for (let i = 0; i < width*height; i++) {\n    const type = nonSpace[i] || \".\"\n  \n    if (!(type in colors)) {\n      const err = `in sprite string: no known color for char \"${type}\"`\n      console.error(err + '\\n' + text)\n      throw new Error(err + ' (invalid sprite in console)')\n    }\n\n    const [ r, g, b, a ] = colors[type] ?? colors['.']!\n    data[i*4] = r\n    data[i*4 + 1] = g\n    data[i*4 + 2] = b\n    data[i*4 + 3] = a\n  }\n\n  return new ImageData(data, width, height)\n}"]}
{"filename": "src/image-data/index.ts", "chunked_list": ["import type { FullSprigAPI, GameState, InputKey } from '../api.js'\nimport { type BaseEngineAPI, baseEngine } from '../base/index.js'\nimport { bitmapTextToImageData } from './bitmap.js'\n\nexport * from './bitmap.js'\n\nexport type ImageDataEngineAPI = BaseEngineAPI & Pick<\n\tFullSprigAPI,\n\t| 'onInput'\n\t| 'afterInput'\n\t| 'setLegend'\n\t| 'setBackground'\n\t| 'setTimeout'\n\t| 'setInterval'\n\t| 'playTune'\n>\nexport const imageDataEngine = (): {\n\tapi: ImageDataEngineAPI,\n\trender(): ImageData,\n\tbutton(key: InputKey): void,\n\tcleanup(): void,\n\tstate: GameState\n} => {\n\tconst game = baseEngine()\n\n\tlet legendImages: Record<string, ImageData> = {}\n\tlet background: string = '.'\n\n\tconst timeouts: number[] = []\n\tconst intervals: number[] = []\n\n\tconst keyHandlers: Record<InputKey, (() => void)[]> = {\n\t\tw: [],\n\t\ts: [],\n\t\ta: [],\n\t\td: [],\n\t\ti: [],\n\t\tj: [],\n\t\tk: [],\n\t\tl: []\n\t}\n\tconst afterInputs: (() => void)[] = []\n\t\n\tconst cleanup = () => {\n\t\ttimeouts.forEach(clearTimeout)\n\t\tintervals.forEach(clearInterval)\n\t}\n\n\tconst api = {\n\t\t...game.api,\n\t\tonInput: (key: InputKey, fn: () => void) => keyHandlers[key].push(fn),\n\t\tafterInput: (fn: () => void) => afterInputs.push(fn),\n\t\tsetLegend: (...bitmaps: [string, string][]) => {\n\t\t\tgame.state.legend = bitmaps\n\t\t\tlegendImages = {}", "\t\t\tfor (const [ id, desc ] of bitmaps)\n\t\t\t\tlegendImages[id] = bitmapTextToImageData(desc)\n\t\t},\n\t\tsetBackground: (kind: string) => background = kind,\n\t\tsetTimeout: (fn: TimerHandler, ms: number) => {\n\t\t\tconst timer = setTimeout(fn, ms)\n\t\t\ttimeouts.push(timer)\n\t\t\treturn timer\n\t\t},\n\t\tsetInterval: (fn: TimerHandler, ms: number) => {\n\t\t\tconst timer = setInterval(fn, ms)\n\t\t\tintervals.push(timer)\n\t\t\treturn timer\n\t\t},\n\t\tplayTune: () => ({ end() {}, isPlaying() { return false } })\n\t}\n\n\treturn {\n\t\tapi,\n\t\tbutton(key: InputKey): void {", "\t\t\tfor (const fn of keyHandlers[key]) fn()\n\t\t\tfor (const fn of afterInputs) fn()\n\t\t\tgame.state.sprites.forEach((s: any) => {\n\t\t\t\ts.dx = 0\n\t\t\t\ts.dy = 0\n\t\t\t})\n\t\t},\n\t\trender(): ImageData {\n\t\t\tconst width = () => game.state.dimensions.width\n\t\t\tconst height = () => game.state.dimensions.height\n\t\t\tconst tSize = () => 16\n\n\t\t\tconst sw = width() * tSize()\n\t\t\tconst sh = height() * tSize()\n\n\t\t\tconst out = new ImageData(sw, sh)\n\t\t\tout.data.fill(255)\n", "\t\t\tfor (const t of game.api.getGrid().flat()) {\n\t\t\t\tconst img = legendImages[t.type ?? background]\n\t\t\t\tif (!img) continue\n\n\t\t\t\tfor (let x = 0; x < tSize(); x++)\n\t\t\t\t\tfor (let y = 0; y < tSize(); y++) {\n\t\t\t\t\t\tconst tx = t.x * tSize() + x\n\t\t\t\t\t\tconst ty = t.y * tSize() + y\n\t\t\t\t\t\tconst src_alpha = img.data[(y * 16 + x) * 4 + 3]\n\t\t\t\t\t\tif (!src_alpha) continue\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 0] = img.data[(y * 16 + x) * 4 + 0]!\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 1] = img.data[(y * 16 + x) * 4 + 1]!\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 2] = img.data[(y * 16 + x) * 4 + 2]!\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 3] = img.data[(y * 16 + x) * 4 + 3]!\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out\n\t\t},\n\t\tcleanup,\n\t\tstate: game.state\n\t}\n}", "\t\t\t\t\t\tif (!src_alpha) continue\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 0] = img.data[(y * 16 + x) * 4 + 0]!\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 1] = img.data[(y * 16 + x) * 4 + 1]!\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 2] = img.data[(y * 16 + x) * 4 + 2]!\n\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 3] = img.data[(y * 16 + x) * 4 + 3]!\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out\n\t\t},\n\t\tcleanup,\n\t\tstate: game.state\n\t}\n}"]}
{"filename": "src/web/tune.ts", "chunked_list": ["import { type InstrumentType, type PlayTuneRes, type Tune, instruments, tones } from '../api.js'\n\nexport function playFrequency(frequency: number, duration: number, instrument: InstrumentType, ctx: AudioContext, dest: AudioNode) {\n\tconst osc = ctx.createOscillator()\n\tconst rampGain = ctx.createGain()\n\n\tosc.connect(rampGain)\n\trampGain.connect(dest)\n\n\tosc.frequency.value = frequency\n\tosc.type = instrument ?? 'sine'\n\tosc.start()\n\n\tconst endTime = ctx.currentTime + duration*2/1000\n\tosc.stop(endTime)\n\t\n\trampGain.gain.setValueAtTime(0, ctx.currentTime)\n\trampGain.gain.linearRampToValueAtTime(.2, ctx.currentTime + duration/5/1000)\n\trampGain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + duration/1000)\n\trampGain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration*2/1000) // does this ramp from the last ramp\n\t\n\tosc.onended = () => {\n\t\tosc.disconnect()\n\t\trampGain.disconnect()\n\t}\n}\n\nconst sleep = async (duration: number) => new Promise(resolve => setTimeout(resolve, duration))", "export async function playTuneHelper(tune: Tune, number: number, playingRef: { playing: boolean }, ctx: AudioContext, dest: AudioNode) {\n\tfor (let i = 0; i < tune.length*number; i++) {\n\t\tconst index = i%tune.length\n\t\tif (!playingRef.playing) break\n\t\tconst noteSet = tune[index]!\n\t\tconst sleepTime = noteSet[0]\n\t\tfor (let j = 1; j < noteSet.length; j += 3) {\n\t\t\tconst instrument = noteSet[j] as InstrumentType\n\t\t\tconst note = noteSet[j+1]!\n\t\t\tconst duration = noteSet[j+2] as number\n\n\t\t\tconst frequency = typeof note === 'string' \n\t\t\t\t? tones[note.toUpperCase()]\n\t\t\t\t: 2**((note-69)/12)*440", "\t\t\tif (instruments.includes(instrument) && frequency !== undefined) playFrequency(frequency, duration, instrument, ctx, dest)\n\t\t}\n\t\tawait sleep(sleepTime)\n\t}\n}\n\nlet audioCtx: AudioContext | null = null\nexport function playTune(tune: Tune, number = 1): PlayTuneRes {\n\tconst playingRef = { playing: true }\n\n\tif (audioCtx === null) audioCtx = new AudioContext()\n\tplayTuneHelper(tune, number, playingRef, audioCtx, audioCtx.destination)\n\n\treturn {\n\t\tend() { playingRef.playing = false },\n\t\tisPlaying() { return playingRef.playing }\n\t}\n}", "\tif (audioCtx === null) audioCtx = new AudioContext()\n\tplayTuneHelper(tune, number, playingRef, audioCtx, audioCtx.destination)\n\n\treturn {\n\t\tend() { playingRef.playing = false },\n\t\tisPlaying() { return playingRef.playing }\n\t}\n}"]}
{"filename": "src/web/text.ts", "chunked_list": ["import type { TextElement } from '../api.js'\nimport { font, composeText } from '../base/index.js'\nimport { makeCanvas } from './util.js'\n\nexport const getTextImg = (texts: TextElement[]): CanvasImageSource => {\n\tconst charGrid = composeText(texts)\n\tconst img = new ImageData(160, 128)\n\timg.data.fill(0)\n\n\tfor (const [i, row] of Object.entries(charGrid)) {\n\t\tlet xt = 0", "\n\tfor (const [i, row] of Object.entries(charGrid)) {\n\t\tlet xt = 0\n\t\tfor (const { char, color } of row) {\n\t\t\tconst cc = char.charCodeAt(0)\n\n\t\t\tlet y = Number(i)*8\n\t\t\tfor (const bits of font.slice(cc*8, (1+cc)*8)) {\n\t\t\t\t\tfor (let x = 0; x < 8; x++) {\n\t\t\t\t\t\tconst val = (bits>>(7-x)) & 1\n\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 0] = val*color[0]\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 1] = val*color[1]\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 2] = val*color[2]\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 3] = val*255\n\t\t\t\t\t}\n\t\t\t\t\ty++\n\t\t\t}\n\t\t\txt += 8\n\t\t}\n\t}\n\n\tconst canvas = makeCanvas(160, 128)\n\tcanvas.getContext('2d')!.putImageData(img, 0, 0)\n\n\treturn canvas\n}", "\t\t\t\t\tfor (let x = 0; x < 8; x++) {\n\t\t\t\t\t\tconst val = (bits>>(7-x)) & 1\n\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 0] = val*color[0]\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 1] = val*color[1]\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 2] = val*color[2]\n\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 3] = val*255\n\t\t\t\t\t}\n\t\t\t\t\ty++\n\t\t\t}\n\t\t\txt += 8\n\t\t}\n\t}\n\n\tconst canvas = makeCanvas(160, 128)\n\tcanvas.getContext('2d')!.putImageData(img, 0, 0)\n\n\treturn canvas\n}"]}
{"filename": "src/web/index.ts", "chunked_list": ["import { type InputKey, type PlayTuneRes, VALID_INPUTS, type FullSprigAPI, type GameState } from '../api.js'\nimport { type BaseEngineAPI, baseEngine, textToTune } from '../base/index.js'\nimport { bitmapTextToImageData } from '../image-data/index.js'\nimport { getTextImg } from './text.js'\nimport { playTune } from './tune.js'\nimport { makeCanvas } from './util.js'\n\nexport * from './text.js'\nexport * from './tune.js'\n\nexport type WebEngineAPI = BaseEngineAPI & Pick<\n\tFullSprigAPI,\n\t| 'setLegend'\n\t| 'onInput'\n\t| 'afterInput'\n\t| 'playTune'\n> & {\n\tgetState(): GameState // For weird backwards-compatibility reasons, not part of API\n}\n", "export type WebEngineAPI = BaseEngineAPI & Pick<\n\tFullSprigAPI,\n\t| 'setLegend'\n\t| 'onInput'\n\t| 'afterInput'\n\t| 'playTune'\n> & {\n\tgetState(): GameState // For weird backwards-compatibility reasons, not part of API\n}\n\nexport function webEngine(canvas: HTMLCanvasElement): {\n\tapi: WebEngineAPI,\n\tstate: GameState,\n\tcleanup(): void\n} {\n\tconst { api, state } = baseEngine()\n\t\n\tconst ctx = canvas.getContext('2d')!\n\tconst offscreenCanvas = makeCanvas(1, 1)\n\tconst offscreenCtx = offscreenCanvas.getContext('2d')!\n\n\tconst _bitmaps: Record<string, CanvasImageSource> = {}\n\tlet _zOrder: string[] = []\n\n\tctx.imageSmoothingEnabled = false\n\n\tconst _gameloop = (): void => {\n\t\tconst { width, height } = state.dimensions", "export function webEngine(canvas: HTMLCanvasElement): {\n\tapi: WebEngineAPI,\n\tstate: GameState,\n\tcleanup(): void\n} {\n\tconst { api, state } = baseEngine()\n\t\n\tconst ctx = canvas.getContext('2d')!\n\tconst offscreenCanvas = makeCanvas(1, 1)\n\tconst offscreenCtx = offscreenCanvas.getContext('2d')!\n\n\tconst _bitmaps: Record<string, CanvasImageSource> = {}\n\tlet _zOrder: string[] = []\n\n\tctx.imageSmoothingEnabled = false\n\n\tconst _gameloop = (): void => {\n\t\tconst { width, height } = state.dimensions", "\t\tif (width === 0 || height === 0) return\n\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\n\t\toffscreenCanvas.width = width*16\n\t\toffscreenCanvas.height = height*16\n\n\t\toffscreenCtx.fillStyle = 'white'\n\t\toffscreenCtx.fillRect(0, 0, width*16, height*16)\n\n\t\tconst grid = api.getGrid()\n", "\t\tfor (let i = 0; i < width * height; i++) {\n\t\t\tconst x = i % width\n\t\t\tconst y = Math.floor(i/width)\n\t\t\tconst sprites = grid[i]!\n\n\t\t\tif (state.background) {\n\t\t\t\tconst imgData = _bitmaps[state.background]!\n\t\t\t\toffscreenCtx.drawImage(imgData, x*16, y*16)\n\t\t\t}\n\n\t\t\tsprites\n\t\t\t\t.sort((a, b) => _zOrder.indexOf(b.type) - _zOrder.indexOf(a.type))\n\t\t\t\t.forEach((sprite) => {\n\t\t\t\t\tconst imgData = _bitmaps[sprite.type]!\n\t\t\t\t\toffscreenCtx.drawImage(imgData, x*16, y*16)\n\t\t\t\t})\n\n\t\t}\n\n\t\tconst scale = Math.min(canvas.width/(width*16), canvas.height/(height*16))\n\t\tconst actualWidth = offscreenCanvas.width*scale\n\t\tconst actualHeight = offscreenCanvas.height*scale\n\t\tctx.drawImage(\n\t\t\toffscreenCanvas, \n\t\t\t(canvas.width-actualWidth)/2, \n\t\t\t(canvas.height-actualHeight)/2, \n\t\t\tactualWidth, \n\t\t\tactualHeight\n\t\t)\n\n\t\tconst textCanvas = getTextImg(state.texts)\n\t\tctx.drawImage(\n\t\t\ttextCanvas, \n\t\t\t0,\n\t\t\t0, \n\t\t\tcanvas.width, \n\t\t\tcanvas.height\n\t\t)\n\n\t\tanimationId = window.requestAnimationFrame(_gameloop)\n\t}\n\tlet animationId = window.requestAnimationFrame(_gameloop)\n\n\tconst setLegend = (...bitmaps: [string, string][]): void => {", "\t\tif (bitmaps.length == 0) throw new Error('There needs to be at least one sprite in the legend.')\n\n\t\tif (!Array.isArray(bitmaps[0])) throw new Error('The sprites passed into setLegend each need to be in square brackets, like setLegend([player, bitmap`...`]).')\n\n\t\tbitmaps.forEach(([ key ]) => {\n\t\t\tif (key === '.') throw new Error(`Can't reassign \".\" bitmap`)\n\t\t\tif (key.length !== 1) throw new Error(`Bitmaps must have one character names`)\n\t\t})\n\n\t\tstate.legend = bitmaps\n\t\t_zOrder = bitmaps.map(x => x[0])\n", "\t\tfor (let i = 0; i < bitmaps.length; i++) {\n\t\t\tconst [ key, value ] = bitmaps[i]!\n\t\t\tconst imgData = bitmapTextToImageData(value)\n\t\t\tconst littleCanvas = makeCanvas(16, 16)\n\t\t\tlittleCanvas.getContext('2d')!.putImageData(imgData, 0, 0)\n\t\t\t_bitmaps[key] = littleCanvas\n\t\t}\n\t}\n\n\tlet tileInputs: Record<InputKey, (() => void)[]> = {\n\t\tw: [],\n\t\ts: [],\n\t\ta: [],\n\t\td: [],\n\t\ti: [],\n\t\tj: [],\n\t\tk: [],\n\t\tl: []\n\t}\n\tconst afterInputs: (() => void)[] = []\n\n\tconst keydown = (e: KeyboardEvent) => {\n\t\tconst key = e.key", "\t\tif (!VALID_INPUTS.includes(key as any)) return\n\n\t\tfor (const validKey of VALID_INPUTS)\n\t\t\tif (key === validKey) tileInputs[key].forEach(fn => fn())\n\n\t\tafterInputs.forEach(f => f())\n\n\t\tstate.sprites.forEach((s: any) => {\n\t\t\ts.dx = 0\n\t\t\ts.dy = 0\n\t\t})\n\n\t\te.preventDefault()\n\t}\n\tcanvas.addEventListener('keydown', keydown)\n\n\tconst onInput = (key: InputKey, fn: () => void): void => {", "\t\tif (!VALID_INPUTS.includes(key))\n\t\t\tthrow new Error(`Unknown input key, \"${key}\": expected one of ${VALID_INPUTS.join(', ')}`)\n\t\ttileInputs[key].push(fn)\n\t}\n\tconst afterInput = (fn: () => void): void => { afterInputs.push(fn) }\n\n\tconst tunes: PlayTuneRes[] = []\n\treturn {\n\t\tapi: {\n\t\t\t...api,\n\t\t\tsetLegend,\n\t\t\tonInput, \n\t\t\tafterInput,\n\t\t\tgetState: () => state,\n\t\t\tplayTune: (text: string, n: number) => {\n\t\t\t\tconst tune = textToTune(text)\n\t\t\t\tconst playTuneRes = playTune(tune, n)\n\t\t\t\ttunes.push(playTuneRes)\n\t\t\t\treturn playTuneRes\n\t\t\t}\n\t\t},\n\t\tstate,\n\t\tcleanup: () => {\n\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\t\t\twindow.cancelAnimationFrame(animationId)\n\t\t\tcanvas.removeEventListener('keydown', keydown)\n\t\t\ttunes.forEach(tune => tune.end())\n\t\t}\n\t}\n}\n"]}
{"filename": "src/web/util.ts", "chunked_list": ["export function makeCanvas(width: number, height: number): HTMLCanvasElement {\n\tconst canvas = document.createElement('canvas')\n\tcanvas.width = width\n\tcanvas.height = height\n\treturn canvas\n}"]}
