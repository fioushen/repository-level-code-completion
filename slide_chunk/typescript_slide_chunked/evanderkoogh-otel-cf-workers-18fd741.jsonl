{"filename": "examples/worker/src/handler.ts", "chunked_list": ["import { trace } from '@opentelemetry/api'\n\nexport interface Env {\n\tOTEL_TEST: KVNamespace\n\tTest_Otel_DO: DurableObjectNamespace\n\t'otel.exporter.headers.x-honeycomb-team': string\n}\n\nconst handleDO = async (request: Request, env: Env): Promise<Response> => {\n\tconst ns = env.Test_Otel_DO\n\tconst id = ns.idFromName('testing')\n\tconst stub = ns.get(id)\n\treturn await stub.fetch('https://does-not-exist.com/blah')\n}\n\nconst handleRest = async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {\n\tawait fetch('https://cloudflare.com')\n\n\tconst cache = await caches.open('stuff')\n\tconst promises = [env.OTEL_TEST.get('non-existant'), cache.match(new Request('https://no-exist.com'))]\n\tawait Promise.all(promises)\n\n\tconst greeting = \"G'day World\"\n\ttrace.getActiveSpan()?.setAttribute('greeting', greeting)\n\tctx.waitUntil(fetch('https://workers.dev'))\n\treturn new Response(`${greeting}!`)\n}\n\nexport default {\n\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n\t\tconst pathname = new URL(request.url).pathname", "\t\tif (pathname === '/do') {\n\t\t\treturn handleDO(request, env)\n\t\t} else if (pathname === '/error') {\n\t\t\tthrow new Error('You asked for it!')\n\t\t} else {\n\t\t\treturn handleRest(request, env, ctx)\n\t\t}\n\t},\n}\n\nexport class OtelDO implements DurableObject {\n\tconstructor(protected state: DurableObjectState, protected env: Env) {\n\t\tstate.blockConcurrencyWhile(async () => {\n\t\t\tawait this.state.storage.getAlarm()\n\t\t})\n\t}\n\tasync fetch(request: Request): Promise<Response> {\n\t\tawait fetch('https://cloudflare.com')\n\t\tawait this.state.storage.put('something', 'else')\n\t\tawait this.state.storage.setAlarm(Date.now() + 1000)\n\t\treturn new Response('Hello World!')\n\t}\n\tasync alarm(): Promise<void> {\n\t\tconsole.log('ding ding!')\n\t\tawait this.state.storage.get('something')\n\t\tawait this.state.storage.get('something_else')\n\t}\n}\n", "export class OtelDO implements DurableObject {\n\tconstructor(protected state: DurableObjectState, protected env: Env) {\n\t\tstate.blockConcurrencyWhile(async () => {\n\t\t\tawait this.state.storage.getAlarm()\n\t\t})\n\t}\n\tasync fetch(request: Request): Promise<Response> {\n\t\tawait fetch('https://cloudflare.com')\n\t\tawait this.state.storage.put('something', 'else')\n\t\tawait this.state.storage.setAlarm(Date.now() + 1000)\n\t\treturn new Response('Hello World!')\n\t}\n\tasync alarm(): Promise<void> {\n\t\tconsole.log('ding ding!')\n\t\tawait this.state.storage.get('something')\n\t\tawait this.state.storage.get('something_else')\n\t}\n}\n"]}
{"filename": "examples/worker/src/index.ts", "chunked_list": ["import { instrument, instrumentDO, ResolveConfigFn } from '../../../src/index'\nimport handler, { Env, OtelDO } from './handler'\n\nconst config: ResolveConfigFn = (env: Env, _trigger) => {\n\treturn {\n\t\texporter: {\n\t\t\turl: 'https://api.honeycomb.io/v1/traces',\n\t\t\theaders: { 'x-honeycomb-team': env['otel.exporter.headers.x-honeycomb-team'] },\n\t\t},\n\t\tservice: {", "\t\t},\n\t\tservice: {\n\t\t\tname: 'greetings',\n\t\t\tversion: '0.1',\n\t\t},\n\t}\n}\n\nconst doConfig: ResolveConfigFn = (env: Env, _trigger) => {\n\treturn {", "const doConfig: ResolveConfigFn = (env: Env, _trigger) => {\n\treturn {\n\t\texporter: {\n\t\t\turl: 'https://api.honeycomb.io/v1/traces',\n\t\t\theaders: { 'x-honeycomb-team': env['otel.exporter.headers.x-honeycomb-team'] },\n\t\t},\n\t\tservice: { name: 'greetings-do' },\n\t}\n}\n", "}\n\nconst TestOtelDO = instrumentDO(OtelDO, doConfig)\n\nexport default instrument(handler, config)\n\nexport { TestOtelDO }\n"]}
{"filename": "examples/queue/src/index.ts", "chunked_list": ["import { instrument, ResolveConfigFn } from '../../../src/index'\n\ninterface QueueData {\n\tpathname: string\n}\nexport interface Env {\n\tQUEUE: Queue<QueueData>\n\tAPI_KEY: string\n}\n\nconst handler: ExportedHandler<Env, QueueData> = {\n\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n\t\tconst url = new URL(request.url)\n\t\tawait env.QUEUE.send({ pathname: url.pathname })\n\t\treturn new Response('Hello World!')\n\t},\n\n\tasync queue(batch: MessageBatch<QueueData>, env: Env, ctx: ExecutionContext) {", "\t\tfor (const message of batch.messages) {\n\t\t\tconsole.log(message.body.pathname)\n\t\t\tmessage.ack()\n\t\t}\n\t},\n}\n\nconst config: ResolveConfigFn = (env: Env, trigger) => {\n\treturn {\n\t\texporter: {\n\t\t\turl: 'https://api.honeycomb.io/v1/traces',\n\t\t\theaders: { 'x-honeycomb-team': env.API_KEY },\n\t\t},\n\t\tservice: {\n\t\t\tname: 'greetings',\n\t\t\tversion: '0.1',\n\t\t},\n\t}\n}\n\nexport default instrument(handler, config)\n"]}
{"filename": "src/spanprocessor.ts", "chunked_list": ["import { Context, Span } from '@opentelemetry/api'\nimport { ReadableSpan, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { Action, State, stateMachine } from 'ts-checked-fsm'\n\nimport { getActiveConfig } from './config.js'\nimport { TailSampleFn } from './sampling.js'\nimport { PostProcessorFn } from './types.js'\n\ntype CompletedTrace = {\n\ttraceId: string\n\tlocalRootSpan: ReadableSpan\n\tcompletedSpans: ReadableSpan[]\n}\n", "\ntype CompletedTrace = {\n\ttraceId: string\n\tlocalRootSpan: ReadableSpan\n\tcompletedSpans: ReadableSpan[]\n}\n\ntype InProgressTrace = {\n\tinProgressSpanIds: Set<string>\n} & CompletedTrace\n", "type InitialState = State<'not_started'>\ntype InProgressTraceState = State<'in_progress', InProgressTrace>\ntype TraceCompleteState = State<'trace_complete', CompletedTrace>\ntype ExportingState = State<'exporting', { promise: Promise<ExportResult> }>\ntype DoneState = State<'done'>\n\ntype StartExportArguments = {\n\texporter: SpanExporter\n\ttailSampler: TailSampleFn\n\tpostProcessor: PostProcessorFn\n}\n", "type StartSpanAction = Action<'startSpan', { span: Span }>\ntype EndSpanAction = Action<'endSpan', { span: ReadableSpan }>\ntype StartExportAction = Action<'startExport', { args: StartExportArguments }>\n\nfunction newTrace(currentState: InitialState, { span }: StartSpanAction): InProgressTraceState {\n\tconst spanId = span.spanContext().spanId\n\treturn {\n\t\t...currentState,\n\t\tstateName: 'in_progress',\n\t\ttraceId: span.spanContext().traceId,\n\t\tlocalRootSpan: span as unknown as ReadableSpan,\n\t\tcompletedSpans: [] as ReadableSpan[],\n\t\tinProgressSpanIds: new Set([spanId]),\n\t} as const\n}\n", "function newSpan(currentState: InProgressTraceState, { span }: StartSpanAction): InProgressTraceState {\n\tconst spanId = span.spanContext().spanId\n\tcurrentState.inProgressSpanIds.add(spanId)\n\treturn { ...currentState }\n}\n\nfunction endSpan(\n\tcurrentState: InProgressTraceState,\n\t{ span }: EndSpanAction\n): InProgressTraceState | TraceCompleteState {\n\tcurrentState.completedSpans.push(span)\n\tcurrentState.inProgressSpanIds.delete(span.spanContext().spanId)", "\tif (currentState.inProgressSpanIds.size === 0) {\n\t\treturn {\n\t\t\tstateName: 'trace_complete',\n\t\t\ttraceId: currentState.traceId,\n\t\t\tlocalRootSpan: currentState.localRootSpan,\n\t\t\tcompletedSpans: currentState.completedSpans,\n\t\t} as const\n\t} else {\n\t\treturn { ...currentState }\n\t}\n}\n", "function startExport(currentState: TraceCompleteState, { args }: StartExportAction): ExportingState | DoneState {\n\tconst { exporter, tailSampler, postProcessor } = args\n\tconst { traceId, localRootSpan, completedSpans: spans } = currentState\n\tconst shouldExport = tailSampler({ traceId, localRootSpan, spans })\n\tif (shouldExport) {\n\t\tconst exportSpans = postProcessor(spans)\n\t\tconst promise = new Promise<ExportResult>((resolve) => {\n\t\t\texporter.export(exportSpans, resolve)\n\t\t})\n\t\treturn { stateName: 'exporting', promise }\n\t} else {\n\t\treturn { stateName: 'done' }\n\t}\n}\n\nconst { nextState } = stateMachine()\n\t.state('not_started')\n\t.state<'in_progress', InProgressTraceState>('in_progress')\n\t.state<'trace_complete', TraceCompleteState>('trace_complete')\n\t.state<'exporting', ExportingState>('exporting')\n\t.state('done')\n\t.transition('not_started', 'in_progress')\n\t.transition('in_progress', 'in_progress')\n\t.transition('in_progress', 'trace_complete')\n\t.transition('trace_complete', 'exporting')\n\t.transition('trace_complete', 'done')\n\t.transition('exporting', 'done')\n\t.action<'startSpan', StartSpanAction>('startSpan')\n\t.action<'endSpan', EndSpanAction>('endSpan')\n\t.action<'startExport', StartExportAction>('startExport')\n\t.action('exportDone')\n\t.actionHandler('not_started', 'startSpan', newTrace)\n\t.actionHandler('in_progress', 'startSpan', newSpan)\n\t.actionHandler('in_progress', 'endSpan', endSpan)\n\t.actionHandler('trace_complete', 'startExport', startExport)\n\t.actionHandler('exporting', 'exportDone', (_c, _a) => {\n\t\treturn { stateName: 'done' } as const\n\t})\n\t.done()\n", "type AnyTraceState = Parameters<typeof nextState>[0]\ntype AnyTraceAction = Parameters<typeof nextState>[1]\n\nexport class BatchTraceSpanProcessor implements SpanProcessor {\n\tprivate traces: Map<string, AnyTraceState> = new Map()\n\tprivate inprogressExports: Map<string, Promise<ExportResult>> = new Map()\n\n\tprivate action(traceId: string, action: AnyTraceAction): AnyTraceState {\n\t\tconst state = this.traces.get(traceId) || { stateName: 'not_started' }\n\t\tconst newState = nextState(state, action)\n\t\tif (newState.stateName === 'done') {\n\t\t\tthis.traces.delete(traceId)\n\t\t} else {\n\t\t\tthis.traces.set(traceId, newState)\n\t\t}\n\t\treturn newState\n\t}\n\n\tprivate export(traceId: string) {\n\t\tconst { exporter, sampling, postProcessor } = getActiveConfig()\n\t\tconst exportArgs = { exporter, tailSampler: sampling.tailSampler, postProcessor }\n\t\tconst newState = this.action(traceId, { actionName: 'startExport', args: exportArgs })", "\t\tif (newState.stateName === 'done') {\n\t\t\tthis.traces.delete(traceId)\n\t\t} else {\n\t\t\tthis.traces.set(traceId, newState)\n\t\t}\n\t\treturn newState\n\t}\n\n\tprivate export(traceId: string) {\n\t\tconst { exporter, sampling, postProcessor } = getActiveConfig()\n\t\tconst exportArgs = { exporter, tailSampler: sampling.tailSampler, postProcessor }\n\t\tconst newState = this.action(traceId, { actionName: 'startExport', args: exportArgs })", "\t\tif (newState.stateName === 'exporting') {\n\t\t\tconst promise = newState.promise\n\t\t\tthis.inprogressExports.set(traceId, promise)\n\t\t\tpromise.then((result) => {\n\t\t\t\tif (result.code === ExportResultCode.FAILED) {\n\t\t\t\t\tconsole.log('Error sending spans to exporter:', result.error)\n\t\t\t\t}\n\t\t\t\tthis.action(traceId, { actionName: 'exportDone' })\n\t\t\t\tthis.inprogressExports.delete(traceId)\n\t\t\t})\n\t\t}\n\t}\n\n\tonStart(span: Span, _parentContext: Context): void {\n\t\tconst traceId = span.spanContext().traceId\n\t\tthis.action(traceId, { actionName: 'startSpan', span })\n\t}\n\n\tonEnd(span: ReadableSpan): void {\n\t\tconst traceId = span.spanContext().traceId\n\t\tconst state = this.action(traceId, { actionName: 'endSpan', span })", "\t\tif (state.stateName === 'trace_complete') {\n\t\t\tthis.export(traceId)\n\t\t}\n\t}\n\n\tasync forceFlush(): Promise<void> {\n\t\tawait Promise.allSettled(this.inprogressExports.values())\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n"]}
{"filename": "src/buffer.ts", "chunked_list": ["//@ts-ignore\nimport { Buffer } from 'node:buffer'\n//@ts-ignore\nglobalThis.Buffer = Buffer\n"]}
{"filename": "src/wrap.ts", "chunked_list": ["const unwrapSymbol = Symbol('unwrap')\n\ntype Wrapped<T> = { [unwrapSymbol]: T } & T\n\nexport function isWrapped<T>(item: T): item is Wrapped<T> {\n\treturn !!(item as Wrapped<T>)[unwrapSymbol]\n}\n\nexport function wrap<T extends object>(item: T, handler: ProxyHandler<T>, autoPassthrough: boolean = true): T {\n\tif (isWrapped(item)) {\n\t\treturn item\n\t}\n\tconst proxyHandler = Object.assign({}, handler)\n\tproxyHandler.get = (target, prop, receiver) => {", "export function wrap<T extends object>(item: T, handler: ProxyHandler<T>, autoPassthrough: boolean = true): T {\n\tif (isWrapped(item)) {\n\t\treturn item\n\t}\n\tconst proxyHandler = Object.assign({}, handler)\n\tproxyHandler.get = (target, prop, receiver) => {\n\t\tif (prop === unwrapSymbol) {\n\t\t\treturn item\n\t\t} else {\n\t\t\tif (handler.get) {\n\t\t\t\treturn handler.get(target, prop, receiver)", "\t\t\tif (handler.get) {\n\t\t\t\treturn handler.get(target, prop, receiver)\n\t\t\t} else if (autoPassthrough) {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t}\n\t}\n\tproxyHandler.apply = (target, thisArg, argArray) => {\n\t\tif (handler.apply) {\n\t\t\treturn handler.apply(unwrap(target), unwrap(thisArg), argArray)\n\t\t}\n\t}\n\treturn new Proxy(item, proxyHandler)\n}\n", "\t\tif (handler.apply) {\n\t\t\treturn handler.apply(unwrap(target), unwrap(thisArg), argArray)\n\t\t}\n\t}\n\treturn new Proxy(item, proxyHandler)\n}\n\nexport function unwrap<T extends object>(item: T): T {\n\tif (item && isWrapped(item)) {\n\t\treturn item[unwrapSymbol]\n\t} else {\n\t\treturn item\n\t}\n}\n", "\tif (item && isWrapped(item)) {\n\t\treturn item[unwrapSymbol]\n\t} else {\n\t\treturn item\n\t}\n}\n\nexport function passthroughGet(target: any, prop: string | symbol, thisArg?: any) {\n\tconst value = Reflect.get(unwrap(target), prop)\n\tif (typeof value === 'function') {\n\t\tthisArg = thisArg || unwrap(target)\n\t\tconst bound = value.bind(thisArg)\n\t\treturn bound\n\t} else {\n\t\treturn value\n\t}\n}\n", "\tif (typeof value === 'function') {\n\t\tthisArg = thisArg || unwrap(target)\n\t\tconst bound = value.bind(thisArg)\n\t\treturn bound\n\t} else {\n\t\treturn value\n\t}\n}\n"]}
{"filename": "src/tracer.ts", "chunked_list": ["import {\n\tTracer,\n\tTraceFlags,\n\tSpan,\n\tSpanKind,\n\tSpanOptions,\n\tContext,\n\tcontext as api_context,\n\ttrace,\n} from '@opentelemetry/api'", "\ttrace,\n} from '@opentelemetry/api'\nimport { sanitizeAttributes } from '@opentelemetry/core'\nimport { Resource } from '@opentelemetry/resources'\nimport { SpanProcessor, RandomIdGenerator, ReadableSpan, SamplingDecision } from '@opentelemetry/sdk-trace-base'\n\nimport { SpanImpl } from './span.js'\nimport { getActiveConfig } from './config.js'\n\nexport class WorkerTracer implements Tracer {\n\tprivate readonly _spanProcessor: SpanProcessor\n\tprivate readonly resource: Resource\n\tprivate readonly idGenerator: RandomIdGenerator = new RandomIdGenerator()\n\tconstructor(spanProcessor: SpanProcessor, resource: Resource) {\n\t\tthis._spanProcessor = spanProcessor\n\t\tthis.resource = resource\n\t}\n\n\tget spanProcessor() {\n\t\treturn this._spanProcessor\n\t}\n\n\taddToResource(extra: Resource) {\n\t\tthis.resource.merge(extra)\n\t}\n\n\tstartSpan(name: string, options: SpanOptions = {}, context = api_context.active()): Span {", "\nexport class WorkerTracer implements Tracer {\n\tprivate readonly _spanProcessor: SpanProcessor\n\tprivate readonly resource: Resource\n\tprivate readonly idGenerator: RandomIdGenerator = new RandomIdGenerator()\n\tconstructor(spanProcessor: SpanProcessor, resource: Resource) {\n\t\tthis._spanProcessor = spanProcessor\n\t\tthis.resource = resource\n\t}\n\n\tget spanProcessor() {\n\t\treturn this._spanProcessor\n\t}\n\n\taddToResource(extra: Resource) {\n\t\tthis.resource.merge(extra)\n\t}\n\n\tstartSpan(name: string, options: SpanOptions = {}, context = api_context.active()): Span {", "\t\tif (options.root) {\n\t\t\tcontext = trace.deleteSpan(context)\n\t\t}\n\t\tconst parentSpan = trace.getSpan(context)\n\t\tconst parentSpanContext = parentSpan?.spanContext()\n\t\tconst hasParentContext = parentSpanContext && trace.isSpanContextValid(parentSpanContext)\n\n\t\tconst traceId = hasParentContext ? parentSpanContext.traceId : this.idGenerator.generateTraceId()\n\t\tconst spanKind = options.kind || SpanKind.INTERNAL\n\t\tconst sanitisedAttrs = sanitizeAttributes(options.attributes)\n\n\t\tconst sampler = getActiveConfig().sampling.headSampler\n\t\tconst samplingDecision = sampler.shouldSample(context, traceId, name, spanKind, sanitisedAttrs, [])\n\t\tconst { decision, traceState, attributes: attrs } = samplingDecision\n\t\tconst attributes = Object.assign({}, sanitisedAttrs, attrs)\n\n\t\tconst spanId = this.idGenerator.generateSpanId()\n\t\tconst parentSpanId = hasParentContext ? parentSpanContext.spanId : undefined\n\t\tconst traceFlags = decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE\n\t\tconst spanContext = { traceId, spanId, traceFlags, traceState }\n\n\t\tconst span = new SpanImpl({\n\t\t\tattributes,\n\t\t\tname,\n\t\t\tonEnd: (span) => {\n\t\t\t\tthis.spanProcessor.onEnd(span as unknown as ReadableSpan)\n\t\t\t},\n\t\t\tresource: this.resource,\n\t\t\tspanContext,\n\t\t\tparentSpanId,\n\t\t\tspanKind,\n\t\t\tstartTime: options.startTime,\n\t\t})\n\t\t//Do not get me started on the idosyncracies of the Otel JS libraries.\n\t\t//@ts-ignore\n\t\tthis.spanProcessor.onStart(span, context)\n\t\treturn span\n\t}\n\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, options: SpanOptions, fn: F): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(\n\t\tname: string,\n\t\toptions: SpanOptions,\n\t\tcontext: Context,\n\t\tfn: F\n\t): ReturnType<F>\n\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, ...args: unknown[]): ReturnType<F> {\n\t\tconst options = args.length > 1 ? (args[0] as SpanOptions) : undefined\n\t\tconst parentContext = args.length > 2 ? (args[1] as Context) : api_context.active()\n\t\tconst fn = args[args.length - 1] as F\n\n\t\tconst span = this.startSpan(name, options, parentContext)\n\t\tconst contextWithSpanSet = trace.setSpan(parentContext, span)\n", "\t\treturn api_context.with(contextWithSpanSet, fn, undefined, span)\n\t}\n}\n"]}
{"filename": "src/sampling.ts", "chunked_list": ["import { TraceFlags, SpanStatusCode } from '@opentelemetry/api'\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base'\n\nexport interface LocalTrace {\n\treadonly traceId: string\n\treadonly localRootSpan: ReadableSpan\n\treadonly spans: ReadableSpan[]\n}\n\nexport type TailSampleFn = (traceInfo: LocalTrace) => boolean\n", "export type TailSampleFn = (traceInfo: LocalTrace) => boolean\n\nexport function multiTailSampler(samplers: TailSampleFn[]): TailSampleFn {\n\treturn (traceInfo) => {\n\t\treturn samplers.reduce((result, sampler) => result || sampler(traceInfo), false)\n\t}\n}\n\nexport const isHeadSampled: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan as unknown as ReadableSpan\n\treturn localRootSpan.spanContext().traceFlags === TraceFlags.SAMPLED\n}\n\nexport const isRootErrorSpan: TailSampleFn = (traceInfo) => {\n\tconst localRootSpan = traceInfo.localRootSpan as unknown as ReadableSpan\n\treturn localRootSpan.status.code === SpanStatusCode.ERROR\n}\n"]}
{"filename": "src/sdk.ts", "chunked_list": ["import { propagation } from '@opentelemetry/api'\nimport { W3CTraceContextPropagator } from '@opentelemetry/core'\nimport { Resource } from '@opentelemetry/resources'\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\nimport {\n\tAlwaysOnSampler,\n\tParentBasedSampler,\n\tReadableSpan,\n\tSampler,\n\tSpanExporter,", "\tSampler,\n\tSpanExporter,\n\tTraceIdRatioBasedSampler,\n} from '@opentelemetry/sdk-trace-base'\n\nimport { Initialiser } from './config.js'\nimport { OTLPExporter } from './exporter.js'\nimport { WorkerTracerProvider } from './provider.js'\nimport { isHeadSampled, isRootErrorSpan, multiTailSampler } from './sampling.js'\nimport { BatchTraceSpanProcessor } from './spanprocessor.js'", "import { isHeadSampled, isRootErrorSpan, multiTailSampler } from './sampling.js'\nimport { BatchTraceSpanProcessor } from './spanprocessor.js'\nimport { Trigger, TraceConfig, ResolvedTraceConfig, ExporterConfig, ParentRatioSamplingConfig } from './types.js'\nimport { unwrap } from './wrap.js'\nimport { createFetchHandler, instrumentGlobalFetch } from './instrumentation/fetch.js'\nimport { instrumentGlobalCache } from './instrumentation/cache.js'\nimport { createQueueHandler } from './instrumentation/queue.js'\nimport { DOClass, instrumentDOClass } from './instrumentation/do.js'\n\ntype FetchHandler = ExportedHandlerFetchHandler<unknown, unknown>\ntype QueueHandler = ExportedHandlerQueueHandler\n", "\ntype FetchHandler = ExportedHandlerFetchHandler<unknown, unknown>\ntype QueueHandler = ExportedHandlerQueueHandler\n\nexport type ResolveConfigFn = (env: any, trigger: Trigger) => TraceConfig\nexport type ConfigurationOption = TraceConfig | ResolveConfigFn\n\nexport function isRequest(trigger: Trigger): trigger is Request {\n\treturn trigger instanceof Request\n}\n", "export function isMessageBatch(trigger: Trigger): trigger is MessageBatch {\n\treturn !!(trigger as MessageBatch).ackAll\n}\n\nexport function isAlarm(trigger: Trigger): trigger is 'do-alarm' {\n\treturn trigger === 'do-alarm'\n}\n\nconst createResource = (config: ResolvedTraceConfig): Resource => {\n\tconst workerResourceAttrs = {\n\t\t[SemanticResourceAttributes.CLOUD_PROVIDER]: 'cloudflare',\n\t\t[SemanticResourceAttributes.CLOUD_PLATFORM]: 'cloudflare.workers',\n\t\t[SemanticResourceAttributes.CLOUD_REGION]: 'earth',\n\t\t// [SemanticResourceAttributes.FAAS_NAME]: '//TODO',\n\t\t// [SemanticResourceAttributes.FAAS_VERSION]: '//TODO',\n\t\t[SemanticResourceAttributes.FAAS_MAX_MEMORY]: 128,\n\t\t[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: 'JavaScript',\n\t\t[SemanticResourceAttributes.TELEMETRY_SDK_NAME]: '@microlabs/otel-workers-sdk',\n\t}\n\tconst serviceResource = new Resource({\n\t\t[SemanticResourceAttributes.SERVICE_NAME]: config.service.name,\n\t\t[SemanticResourceAttributes.SERVICE_NAMESPACE]: config.service.namespace,\n\t\t[SemanticResourceAttributes.SERVICE_VERSION]: config.service.version,\n\t})\n\tconst resource = new Resource(workerResourceAttrs)\n\treturn resource.merge(serviceResource)\n}\n", "function isSpanExporter(exporterConfig: ExporterConfig): exporterConfig is SpanExporter {\n\treturn !!(exporterConfig as SpanExporter).export\n}\n\nlet initialised = false\nfunction init(config: ResolvedTraceConfig): void {\n\tif (!initialised) {\n\t\tinstrumentGlobalCache()\n\t\tinstrumentGlobalFetch()\n\t\tpropagation.setGlobalPropagator(new W3CTraceContextPropagator())\n\t\tconst resource = createResource(config)\n\t\tconst spanProcessor = new BatchTraceSpanProcessor()\n\t\tconst provider = new WorkerTracerProvider(spanProcessor, resource)\n\t\tprovider.register()\n\t\tinitialised = true\n\t}\n}\n", "function isSampler(sampler: Sampler | ParentRatioSamplingConfig): sampler is Sampler {\n\treturn !!(sampler as Sampler).shouldSample\n}\n\nfunction createSampler(conf: ParentRatioSamplingConfig): Sampler {\n\tconst ratioSampler = new TraceIdRatioBasedSampler(conf.ratio)\n\tif (typeof conf.acceptRemote === 'boolean' && !conf.acceptRemote) {\n\t\treturn new ParentBasedSampler({\n\t\t\troot: ratioSampler,\n\t\t\tremoteParentSampled: ratioSampler,\n\t\t\tremoteParentNotSampled: ratioSampler,\n\t\t})\n\t} else {\n\t\treturn new ParentBasedSampler({ root: ratioSampler })\n\t}\n}\n", "function parseConfig(supplied: TraceConfig): ResolvedTraceConfig {\n\tconst headSampleConf = supplied.sampling?.headSampler\n\tconst headSampler = headSampleConf\n\t\t? isSampler(headSampleConf)\n\t\t\t? headSampleConf\n\t\t\t: createSampler(headSampleConf)\n\t\t: new AlwaysOnSampler()\n\treturn {\n\t\texporter: isSpanExporter(supplied.exporter) ? supplied.exporter : new OTLPExporter(supplied.exporter),\n\t\tfetch: {\n\t\t\tincludeTraceContext: supplied.fetch?.includeTraceContext ?? true,\n\t\t},\n\t\thandlers: {\n\t\t\tfetch: {\n\t\t\t\tacceptTraceContext: supplied.handlers?.fetch?.acceptTraceContext ?? true,\n\t\t\t},\n\t\t},\n\t\tpostProcessor: supplied.postProcessor || ((spans: ReadableSpan[]) => spans),\n\t\tsampling: {\n\t\t\theadSampler,\n\t\t\ttailSampler: supplied.sampling?.tailSampler || multiTailSampler([isHeadSampled, isRootErrorSpan]),\n\t\t},\n\t\tservice: supplied.service,\n\t}\n}\n", "function createInitialiser(config: ConfigurationOption): Initialiser {\n\tif (typeof config === 'function') {\n\t\treturn (env, trigger) => {\n\t\t\tconst conf = parseConfig(config(env, trigger))\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t} else {\n\t\treturn () => {\n\t\t\tconst conf = parseConfig(config)\n\t\t\tinit(conf)\n\t\t\treturn conf\n\t\t}\n\t}\n}\n", "export function instrument<E, Q, C>(\n\thandler: ExportedHandler<E, Q, C>,\n\tconfig: ConfigurationOption\n): ExportedHandler<E, Q, C> {\n\tconst initialiser = createInitialiser(config)\n\n\tif (handler.fetch) {\n\t\tconst fetcher = unwrap(handler.fetch) as FetchHandler\n\t\thandler.fetch = createFetchHandler(fetcher, initialiser)\n\t}\n", "\tif (handler.queue) {\n\t\tconst queuer = unwrap(handler.queue) as QueueHandler\n\t\thandler.queue = createQueueHandler(queuer, initialiser)\n\t}\n\treturn handler\n}\n\nexport function instrumentDO(doClass: DOClass, config: ConfigurationOption) {\n\tconst initialiser = createInitialiser(config)\n\n\treturn instrumentDOClass(doClass, initialiser)\n}\n\nexport { waitUntilTrace } from './instrumentation/fetch.js'\n"]}
{"filename": "src/span.ts", "chunked_list": ["import {\n\tSpanContext,\n\tLink,\n\tSpanKind,\n\tTimeInput,\n\tException,\n\tAttributes,\n\tHrTime,\n\tSpan,\n\tSpanStatus,", "\tSpan,\n\tSpanStatus,\n\tSpanStatusCode,\n\tAttributeValue,\n} from '@opentelemetry/api'\nimport {\n\thrTimeDuration,\n\tInstrumentationLibrary,\n\tisAttributeKey,\n\tisAttributeValue,", "\tisAttributeKey,\n\tisAttributeValue,\n\tisTimeInput,\n\tsanitizeAttributes,\n} from '@opentelemetry/core'\nimport { IResource } from '@opentelemetry/resources'\nimport { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\ntype OnSpanEnd = (span: Span) => void\n", "\ntype OnSpanEnd = (span: Span) => void\n\ninterface SpanInit {\n\tattributes: unknown\n\tname: string\n\tonEnd: OnSpanEnd\n\tresource: IResource\n\tspanContext: SpanContext\n\tlinks?: Link[]\n\tparentSpanId?: string\n\tspanKind?: SpanKind\n\tstartTime?: TimeInput\n}\n", "function transformExceptionAttributes(exception: Exception): Attributes {\n\tconst attributes: Attributes = {}\n\tif (typeof exception === 'string') {\n\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception\n\t} else {\n\t\tif (exception.code) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString()\n\t\t} else if (exception.name) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name\n\t\t}\n\t\tif (exception.message) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message\n\t\t}", "\t\tif (exception.message) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message\n\t\t}\n\t\tif (exception.stack) {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack\n\t\t}\n\t}\n\treturn attributes\n}\n\nfunction millisToHr(millis: number): HrTime {\n\treturn [Math.trunc(millis / 1000), (millis % 1000) * 1e6]\n}\n", "function millisToHr(millis: number): HrTime {\n\treturn [Math.trunc(millis / 1000), (millis % 1000) * 1e6]\n}\n\nfunction getHrTime(input?: TimeInput): HrTime {\n\tconst now = Date.now()\n\tif (!input) {\n\t\treturn millisToHr(now)\n\t} else if (input instanceof Date) {\n\t\treturn millisToHr(input.getTime())\n\t} else if (typeof input === 'number') {\n\t\t//TODO: do something with performance.now something\n\t\treturn millisToHr(input)\n\t} else {\n\t\tthrow new Error('No valid time')\n\t}\n}\n", "\t} else if (input instanceof Date) {\n\t\treturn millisToHr(input.getTime())\n\t} else if (typeof input === 'number') {\n\t\t//TODO: do something with performance.now something\n\t\treturn millisToHr(input)\n\t} else {\n\t\tthrow new Error('No valid time')\n\t}\n}\n\nexport class SpanImpl implements Span, ReadableSpan {\n\tname: string\n\tprivate readonly _spanContext: SpanContext\n\tprivate readonly onEnd: OnSpanEnd\n\treadonly parentSpanId?: string\n\treadonly kind: SpanKind\n\treadonly attributes: Attributes\n\tstatus: SpanStatus = {\n\t\tcode: SpanStatusCode.UNSET,\n\t}\n\tendTime: HrTime = [0, 0]\n\tprivate _duration: HrTime = [0, 0]\n\treadonly startTime: HrTime\n\treadonly events: TimedEvent[] = []\n\treadonly links: Link[]\n\treadonly resource: IResource\n\tinstrumentationLibrary: InstrumentationLibrary = { name: '@microlabs/otel-cf-workers' }\n\tprivate _ended: boolean = false\n\tprivate _droppedAttributesCount: number = 0\n\tprivate _droppedEventsCount: number = 0\n\tprivate _droppedLinksCount: number = 0\n\n\tconstructor(init: SpanInit) {\n\t\tthis.name = init.name\n\t\tthis._spanContext = init.spanContext\n\t\tthis.parentSpanId = init.parentSpanId\n\t\tthis.kind = init.spanKind || SpanKind.INTERNAL\n\t\tthis.attributes = sanitizeAttributes(init.attributes)\n\t\tthis.startTime = getHrTime(init.startTime)\n\t\tthis.links = init.links || []\n\t\tthis.resource = init.resource\n\t\tthis.onEnd = init.onEnd\n\t}\n\n\tspanContext(): SpanContext {\n\t\treturn this._spanContext\n\t}\n\n\tsetAttribute(key: string, value?: AttributeValue): this {", "export class SpanImpl implements Span, ReadableSpan {\n\tname: string\n\tprivate readonly _spanContext: SpanContext\n\tprivate readonly onEnd: OnSpanEnd\n\treadonly parentSpanId?: string\n\treadonly kind: SpanKind\n\treadonly attributes: Attributes\n\tstatus: SpanStatus = {\n\t\tcode: SpanStatusCode.UNSET,\n\t}\n\tendTime: HrTime = [0, 0]\n\tprivate _duration: HrTime = [0, 0]\n\treadonly startTime: HrTime\n\treadonly events: TimedEvent[] = []\n\treadonly links: Link[]\n\treadonly resource: IResource\n\tinstrumentationLibrary: InstrumentationLibrary = { name: '@microlabs/otel-cf-workers' }\n\tprivate _ended: boolean = false\n\tprivate _droppedAttributesCount: number = 0\n\tprivate _droppedEventsCount: number = 0\n\tprivate _droppedLinksCount: number = 0\n\n\tconstructor(init: SpanInit) {\n\t\tthis.name = init.name\n\t\tthis._spanContext = init.spanContext\n\t\tthis.parentSpanId = init.parentSpanId\n\t\tthis.kind = init.spanKind || SpanKind.INTERNAL\n\t\tthis.attributes = sanitizeAttributes(init.attributes)\n\t\tthis.startTime = getHrTime(init.startTime)\n\t\tthis.links = init.links || []\n\t\tthis.resource = init.resource\n\t\tthis.onEnd = init.onEnd\n\t}\n\n\tspanContext(): SpanContext {\n\t\treturn this._spanContext\n\t}\n\n\tsetAttribute(key: string, value?: AttributeValue): this {", "\t\tif (isAttributeKey(key) && isAttributeValue(value)) {\n\t\t\tthis.attributes[key] = value\n\t\t}\n\t\treturn this\n\t}\n\n\tsetAttributes(attributes: Attributes): this {\n\t\tfor (const [key, value] of Object.entries(attributes)) {\n\t\t\tthis.setAttribute(key, value)\n\t\t}\n\t\treturn this\n\t}\n\n\taddEvent(name: string, attributesOrStartTime?: Attributes | TimeInput, startTime?: TimeInput): this {", "\t\tif (isTimeInput(attributesOrStartTime)) {\n\t\t\tstartTime = attributesOrStartTime\n\t\t\tattributesOrStartTime = undefined\n\t\t}\n\n\t\tconst attributes = sanitizeAttributes(attributesOrStartTime)\n\t\tconst time = getHrTime(startTime)\n\t\tthis.events.push({ name, attributes, time })\n\t\treturn this\n\t}\n\n\tsetStatus(status: SpanStatus): this {\n\t\tthis.status = status\n\t\treturn this\n\t}\n\n\tupdateName(name: string): this {\n\t\tthis.name = name\n\t\treturn this\n\t}\n\n\tend(endTime?: TimeInput): void {", "\t\tif (this._ended) {\n\t\t\treturn\n\t\t}\n\t\tthis._ended = true\n\t\tthis.endTime = getHrTime(endTime)\n\t\tthis._duration = hrTimeDuration(this.startTime, this.endTime)\n\t\tthis.onEnd(this)\n\t}\n\n\tisRecording(): boolean {\n\t\treturn true\n\t}\n\n\trecordException(exception: Exception, time?: TimeInput): void {\n\t\tconst attributes = transformExceptionAttributes(exception)\n\t\tthis.addEvent('exception', attributes, time)\n\t}\n\n\tget duration(): HrTime {\n\t\treturn this._duration\n\t}\n\n\tget ended(): boolean {\n\t\treturn this._ended\n\t}\n\n\tget droppedAttributesCount(): number {\n\t\treturn this._droppedAttributesCount\n\t}\n\n\tget droppedEventsCount(): number {\n\t\treturn this._droppedEventsCount\n\t}\n\n\tget droppedLinksCount(): number {\n\t\treturn this._droppedLinksCount\n\t}\n}\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { context } from '@opentelemetry/api'\nimport { ResolvedTraceConfig, Trigger } from './types.js'\n\nconst configSymbol = Symbol('Otel Workers Tracing Configuration')\n\nexport type Initialiser = (env: Record<string, unknown>, trigger: Trigger) => ResolvedTraceConfig\n\nexport function setConfig(config: ResolvedTraceConfig, ctx = context.active()) {\n\treturn ctx.setValue(configSymbol, config)\n}\n", "export function getActiveConfig(): ResolvedTraceConfig {\n\tconst config = context.active().getValue(configSymbol) as ResolvedTraceConfig\n\treturn config\n}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { ReadableSpan, Sampler, SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { OTLPExporterConfig } from './exporter.js'\nimport { FetchHandlerConfig, FetcherConfig } from './instrumentation/fetch.js'\nimport { TailSampleFn } from './sampling.js'\n\nexport type PostProcessorFn = (spans: ReadableSpan[]) => ReadableSpan[]\n\nexport type ExporterConfig = OTLPExporterConfig | SpanExporter\n\nexport interface HandlerConfig {\n\tfetch?: FetchHandlerConfig\n}\n", "export interface HandlerConfig {\n\tfetch?: FetchHandlerConfig\n}\n\nexport interface ServiceConfig {\n\tname: string\n\tnamespace?: string\n\tversion?: string\n}\n\nexport interface ParentRatioSamplingConfig {\n\tacceptRemote?: boolean\n\tratio: number\n}\n", "export interface ParentRatioSamplingConfig {\n\tacceptRemote?: boolean\n\tratio: number\n}\n\ntype HeadSamplerConf = Sampler | ParentRatioSamplingConfig\nexport interface SamplingConfig<HS extends HeadSamplerConf = HeadSamplerConf> {\n\theadSampler?: HS\n\ttailSampler?: TailSampleFn\n}\n", "export interface TraceConfig<EC extends ExporterConfig = ExporterConfig> {\n\texporter: EC\n\thandlers?: HandlerConfig\n\tfetch?: FetcherConfig\n\tpostProcessor?: PostProcessorFn\n\tsampling?: SamplingConfig\n\tservice: ServiceConfig\n}\n\nexport interface ResolvedTraceConfig extends TraceConfig {\n\texporter: SpanExporter\n\thandlers: Required<HandlerConfig>\n\tfetch: Required<FetcherConfig>\n\tpostProcessor: PostProcessorFn\n\tsampling: Required<SamplingConfig<Sampler>>\n}\n", "export interface ResolvedTraceConfig extends TraceConfig {\n\texporter: SpanExporter\n\thandlers: Required<HandlerConfig>\n\tfetch: Required<FetcherConfig>\n\tpostProcessor: PostProcessorFn\n\tsampling: Required<SamplingConfig<Sampler>>\n}\n\nexport interface DOConstructorTrigger {\n\tid: string\n\tname?: string\n}\n", "export interface DOConstructorTrigger {\n\tid: string\n\tname?: string\n}\n\nexport type Trigger = Request | MessageBatch | DOConstructorTrigger | 'do-alarm'\n"]}
{"filename": "src/exporter.ts", "chunked_list": ["import { createExportTraceServiceRequest } from '@opentelemetry/otlp-transformer'\nimport { ExportServiceError, OTLPExporterError } from '@opentelemetry/otlp-exporter-base'\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core'\nimport { SpanExporter } from '@opentelemetry/sdk-trace-base'\nimport { unwrap } from './wrap.js'\n\nexport interface OTLPExporterConfig {\n\turl: string\n\theaders?: Record<string, string>\n}\n\nconst defaultHeaders: Record<string, string> = {\n\taccept: 'application/json',\n\t'content-type': 'application/json',\n}\n", "export class OTLPExporter implements SpanExporter {\n\tprivate headers: Record<string, string>\n\tprivate url: string\n\tconstructor(config: OTLPExporterConfig) {\n\t\tthis.url = config.url\n\t\tthis.headers = Object.assign({}, defaultHeaders, config.headers)\n\t}\n\n\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\tthis._export(items)\n\t\t\t.then(() => {\n\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t})", "\t\t\t.catch((error: ExportServiceError) => {\n\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error })\n\t\t\t})\n\t}\n\n\tprivate _export(items: any[]): Promise<unknown> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tthis.send(items, resolve, reject)\n\t\t\t} catch (e) {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t})\n\t}\n\n\tsend(items: any[], onSuccess: () => void, onError: (error: OTLPExporterError) => void): void {\n\t\tconst exportMessage = createExportTraceServiceRequest(items, true)\n\t\tconst body = JSON.stringify(exportMessage)\n\t\tconst params: RequestInit = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: this.headers,\n\t\t\tbody,\n\t\t}\n\n\t\tunwrap(fetch)(this.url, params)\n\t\t\t.then((response) => {", "\t\t\t} catch (e) {\n\t\t\t\treject(e)\n\t\t\t}\n\t\t})\n\t}\n\n\tsend(items: any[], onSuccess: () => void, onError: (error: OTLPExporterError) => void): void {\n\t\tconst exportMessage = createExportTraceServiceRequest(items, true)\n\t\tconst body = JSON.stringify(exportMessage)\n\t\tconst params: RequestInit = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: this.headers,\n\t\t\tbody,\n\t\t}\n\n\t\tunwrap(fetch)(this.url, params)\n\t\t\t.then((response) => {", "\t\t\t\tif (response.ok) {\n\t\t\t\t\tonSuccess()\n\t\t\t\t} else {\n\t\t\t\t\tonError(new OTLPExporterError(`Exporter received a statusCode: ${response.status}`))\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tonError(new OTLPExporterError(`Exception during export: ${error.toString()}`, error.code, error.stack))\n\t\t\t})\n\t}\n\n\tasync shutdown(): Promise<void> {}\n}\n"]}
{"filename": "src/provider.ts", "chunked_list": ["import { context, trace, Tracer, TracerOptions, TracerProvider } from '@opentelemetry/api'\n\nimport { SpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { Resource } from '@opentelemetry/resources'\n\nimport { AsyncLocalStorageContextManager } from './context.js'\nimport { WorkerTracer } from './tracer.js'\n\n/**\n * Register this TracerProvider for use with the OpenTelemetry API.", "/**\n * Register this TracerProvider for use with the OpenTelemetry API.\n * Undefined values may be replaced with defaults, and\n * null values will be skipped.\n *\n * @param config Configuration object for SDK registration\n */\nexport class WorkerTracerProvider implements TracerProvider {\n\tprivate spanProcessor: SpanProcessor\n\tprivate resource: Resource\n\tprivate tracers: Record<string, Tracer> = {}\n\n\tconstructor(spanProcessor: SpanProcessor, resource: Resource) {\n\t\tthis.spanProcessor = spanProcessor\n\t\tthis.resource = resource\n\t}\n\n\tgetTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n\t\tconst key = `${name}@${version || ''}:${options?.schemaUrl || ''}`", "\t\tif (!this.tracers[key]) {\n\t\t\tthis.tracers[key] = new WorkerTracer(this.spanProcessor, this.resource)\n\t\t}\n\t\treturn this.tracers[key]\n\t}\n\n\tregister(): void {\n\t\ttrace.setGlobalTracerProvider(this)\n\t\tcontext.setGlobalContextManager(new AsyncLocalStorageContextManager())\n\t}\n}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './buffer.js'\nexport * from './sampling.js'\nexport * from './sdk.js'\nexport * from './span.js'\nexport type * from './types.js'\n"]}
{"filename": "src/context.ts", "chunked_list": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software", " *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextManager, Context, ROOT_CONTEXT } from '@opentelemetry/api'\n//@ts-ignore", "import { ContextManager, Context, ROOT_CONTEXT } from '@opentelemetry/api'\n//@ts-ignore\nimport { AsyncLocalStorage } from 'node:async_hooks'\n//@ts-ignore\nimport { EventEmitter } from 'node:events'\n\ntype Func<T> = (...args: unknown[]) => T\n\n/**\n * Store a map for each event of all original listeners and their \"patched\"\n * version. So when a listener is removed by the user, the corresponding", " * patched function will be also removed.\n */\ninterface PatchMap {\n\t[name: string]: WeakMap<Func<void>, Func<void>>\n}\n\nconst ADD_LISTENER_METHODS = [\n\t'addListener' as const,\n\t'on' as const,\n\t'once' as const,\n\t'prependListener' as const,\n\t'prependOnceListener' as const,\n]\n", "abstract class AbstractAsyncHooksContextManager implements ContextManager {\n\tabstract active(): Context\n\n\tabstract with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F>\n\n\tabstract enable(): this\n\n\tabstract disable(): this\n\n\t/**", "\t * Binds a the certain context or the active one to the target function and then returns the target\n\t * @param context A context (span) to be bind to target\n\t * @param target a function or event emitter. When target or one of its callbacks is called,\n\t *  the provided context will be used as the active context for the duration of the call.\n\t */\n\tbind<T>(context: Context, target: T): T {\n\t\tif (target instanceof EventEmitter) {\n\t\t\treturn this._bindEventEmitter(context, target)\n\t\t}\n\n\t\tif (typeof target === 'function') {\n\t\t\treturn this._bindFunction(context, target)\n\t\t}\n\t\treturn target\n\t}\n\n\tprivate _bindFunction<T extends Function>(context: Context, target: T): T {\n\t\tconst manager = this\n\t\tconst contextWrapper = function (this: never, ...args: unknown[]) {", "\t\tif (typeof target === 'function') {\n\t\t\treturn this._bindFunction(context, target)\n\t\t}\n\t\treturn target\n\t}\n\n\tprivate _bindFunction<T extends Function>(context: Context, target: T): T {\n\t\tconst manager = this\n\t\tconst contextWrapper = function (this: never, ...args: unknown[]) {\n\t\t\treturn manager.with(context, () => target.apply(this, args))\n\t\t}\n\t\tObject.defineProperty(contextWrapper, 'length', {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\twritable: false,\n\t\t\tvalue: target.length,\n\t\t})\n\t\t/**\n\t\t * It isn't possible to tell Typescript that contextWrapper is the same as T\n\t\t * so we forced to cast as any here.\n\t\t */\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\treturn contextWrapper as any\n\t}\n\n\t/**\n\t * By default, EventEmitter call their callback with their context, which we do\n\t * not want, instead we will bind a specific context to all callbacks that\n\t * go through it.\n\t * @param context the context we want to bind\n\t * @param ee EventEmitter an instance of EventEmitter to patch\n\t */\n\tprivate _bindEventEmitter<T extends EventEmitter>(context: Context, ee: T): T {\n\t\tconst map = this._getPatchMap(ee)", "\t\t\treturn manager.with(context, () => target.apply(this, args))\n\t\t}\n\t\tObject.defineProperty(contextWrapper, 'length', {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\twritable: false,\n\t\t\tvalue: target.length,\n\t\t})\n\t\t/**\n\t\t * It isn't possible to tell Typescript that contextWrapper is the same as T\n\t\t * so we forced to cast as any here.\n\t\t */\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\treturn contextWrapper as any\n\t}\n\n\t/**\n\t * By default, EventEmitter call their callback with their context, which we do\n\t * not want, instead we will bind a specific context to all callbacks that\n\t * go through it.\n\t * @param context the context we want to bind\n\t * @param ee EventEmitter an instance of EventEmitter to patch\n\t */\n\tprivate _bindEventEmitter<T extends EventEmitter>(context: Context, ee: T): T {\n\t\tconst map = this._getPatchMap(ee)", "\t\tif (map !== undefined) return ee\n\t\tthis._createPatchMap(ee)\n\n\t\t// patch methods that add a listener to propagate context\n\t\tADD_LISTENER_METHODS.forEach((methodName) => {\n\t\t\tif (ee[methodName] === undefined) return\n\t\t\tee[methodName] = this._patchAddListener(ee, ee[methodName], context)\n\t\t})\n\t\t// patch methods that remove a listener\n\t\tif (typeof ee.removeListener === 'function') {\n\t\t\tee.removeListener = this._patchRemoveListener(ee, ee.removeListener)\n\t\t}", "\t\tif (typeof ee.removeListener === 'function') {\n\t\t\tee.removeListener = this._patchRemoveListener(ee, ee.removeListener)\n\t\t}\n\t\tif (typeof ee.off === 'function') {\n\t\t\tee.off = this._patchRemoveListener(ee, ee.off)\n\t\t}\n\t\t// patch method that remove all listeners\n\t\tif (typeof ee.removeAllListeners === 'function') {\n\t\t\tee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners)\n\t\t}\n\t\treturn ee\n\t}\n\n\t/**\n\t * Patch methods that remove a given listener so that we match the \"patched\"\n\t * version of that listener (the one that propagate context).\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveListener(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\tconst events = contextManager._getPatchMap(ee)?.[event]", "\t\t\tif (events === undefined) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tconst patchedListener = events.get(listener)\n\t\t\treturn original.call(this, event, patchedListener || listener)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods that remove all listeners so we remove our\n\t * internal references for a given event.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t */\n\tprivate _patchRemoveAllListeners(ee: EventEmitter, original: Function) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string) {\n\t\t\tconst map = contextManager._getPatchMap(ee)", "\t\t\tif (map !== undefined) {\n\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\tcontextManager._createPatchMap(ee)\n\t\t\t\t} else if (map[event] !== undefined) {\n\t\t\t\t\tdelete map[event]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original.apply(this, arguments)\n\t\t}\n\t}\n\n\t/**\n\t * Patch methods on an event emitter instance that can add listeners so we\n\t * can force them to propagate a given context.\n\t * @param ee EventEmitter instance\n\t * @param original reference to the patched method\n\t * @param [context] context to propagate when calling listeners\n\t */\n\tprivate _patchAddListener(ee: EventEmitter, original: Function, context: Context) {\n\t\tconst contextManager = this\n\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\t/**\n\t\t\t * This check is required to prevent double-wrapping the listener.\n\t\t\t * The implementation for ee.once wraps the listener and calls ee.on.\n\t\t\t * Without this check, we would wrap that wrapped listener.\n\t\t\t * This causes an issue because ee.removeListener depends on the onceWrapper\n\t\t\t * to properly remove the listener. If we wrap their wrapper, we break\n\t\t\t * that detection.\n\t\t\t */", "\t\t\tif (contextManager._wrapped) {\n\t\t\t\treturn original.call(this, event, listener)\n\t\t\t}\n\t\t\tlet map = contextManager._getPatchMap(ee)\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = contextManager._createPatchMap(ee)\n\t\t\t}\n\t\t\tlet listeners = map[event]\n\t\t\tif (listeners === undefined) {\n\t\t\t\tlisteners = new WeakMap()\n\t\t\t\tmap[event] = listeners\n\t\t\t}\n\t\t\tconst patchedListener = contextManager.bind(context, listener)\n\t\t\t// store a weak reference of the user listener to ours\n\t\t\tlisteners.set(listener, patchedListener)\n\n\t\t\t/**", "\t\t\tif (listeners === undefined) {\n\t\t\t\tlisteners = new WeakMap()\n\t\t\t\tmap[event] = listeners\n\t\t\t}\n\t\t\tconst patchedListener = contextManager.bind(context, listener)\n\t\t\t// store a weak reference of the user listener to ours\n\t\t\tlisteners.set(listener, patchedListener)\n\n\t\t\t/**\n\t\t\t * See comment at the start of this function for the explanation of this property.\n\t\t\t */\n\t\t\tcontextManager._wrapped = true", "\t\t\t * See comment at the start of this function for the explanation of this property.\n\t\t\t */\n\t\t\tcontextManager._wrapped = true\n\t\t\ttry {\n\t\t\t\treturn original.call(this, event, patchedListener)\n\t\t\t} finally {\n\t\t\t\tcontextManager._wrapped = false\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _createPatchMap(ee: EventEmitter): PatchMap {\n\t\tconst map = Object.create(null)\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t;(ee as any)[this._kOtListeners] = map\n\t\treturn map\n\t}\n\tprivate _getPatchMap(ee: EventEmitter): PatchMap | undefined {\n\t\treturn (ee as never)[this._kOtListeners]\n\t}\n\n\tprivate readonly _kOtListeners = Symbol('OtListeners')\n\tprivate _wrapped = false\n}\n", "export class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager {\n\tprivate _asyncLocalStorage: AsyncLocalStorage<Context>\n\n\tconstructor() {\n\t\tsuper()\n\t\tthis._asyncLocalStorage = new AsyncLocalStorage()\n\t}\n\n\tactive(): Context {\n\t\treturn this._asyncLocalStorage.getStore() ?? ROOT_CONTEXT\n\t}\n\n\twith<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\tcontext: Context,\n\t\tfn: F,\n\t\tthisArg?: ThisParameterType<F>,\n\t\t...args: A\n\t): ReturnType<F> {\n\t\tconst cb = thisArg == null ? fn : fn.bind(thisArg)\n\t\treturn this._asyncLocalStorage.run(context, cb as never, ...args)\n\t}\n\n\tenable(): this {\n\t\treturn this\n\t}\n\n\tdisable(): this {\n\t\tthis._asyncLocalStorage.disable()\n\t\treturn this\n\t}\n}\n"]}
{"filename": "src/instrumentation/queue.ts", "chunked_list": ["import { trace, SpanOptions, SpanKind, Attributes, Exception, context as api_context } from '@opentelemetry/api'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { instrumentEnv } from './env.js'\nimport { unwrap, wrap } from '../wrap.js'\n\ntype QueueHandler = ExportedHandlerQueueHandler<unknown, unknown>\nexport type QueueHandlerArgs = Parameters<QueueHandler>\n\nconst traceIdSymbol = Symbol('traceId')\n", "class MessageStatusCount {\n\tsucceeded = 0\n\tfailed = 0\n\treadonly total: number\n\tconstructor(total: number) {\n\t\tthis.total = total\n\t}\n\n\tack() {\n\t\tthis.succeeded = this.succeeded + 1\n\t}\n\n\tackRemaining() {\n\t\tthis.succeeded = this.total - this.failed\n\t}\n\n\tretry() {\n\t\tthis.failed = this.failed + 1\n\t}\n\n\tretryRemaining() {\n\t\tthis.failed = this.total - this.succeeded\n\t}\n\n\ttoAttributes(): Attributes {\n\t\treturn {\n\t\t\t'queue.messages_count': this.total,\n\t\t\t'queue.messages_success': this.succeeded,\n\t\t\t'queue.messages_failed': this.failed,\n\t\t\t'queue.batch_success': this.succeeded === this.total,\n\t\t}\n\t}\n}\n\nconst addEvent = (name: string, msg?: Message) => {\n\tconst attrs: Attributes = {}", "\tif (msg) {\n\t\tattrs['queue.message_id'] = msg.id\n\t\tattrs['queue.message_timestamp'] = msg.timestamp.toISOString()\n\t}\n\ttrace.getActiveSpan()?.addEvent(name, attrs)\n}\n\nconst proxyQueueMessage = <Q>(msg: Message<Q>, count: MessageStatusCount): Message<Q> => {\n\tconst msgHandler: ProxyHandler<Message<Q>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'ack') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageAck', msg)\n\t\t\t\t\t\tcount.ack()\n\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, msg, [])\n\t\t\t\t\t},\n\t\t\t\t})", "\t\t\tif (prop === 'ack') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageAck', msg)\n\t\t\t\t\t\tcount.ack()\n\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, msg, [])\n\t\t\t\t\t},\n\t\t\t\t})", "\t\t\t} else if (prop === 'retry') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('messageRetry', msg)\n\t\t\t\t\t\tcount.retry()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tconst result = Reflect.apply(fnTarget, msg, [])\n\t\t\t\t\t\treturn result\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop, msg)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(msg, msgHandler)\n}\n\nconst proxyMessageBatch = <E, Q>(batch: MessageBatch, count: MessageStatusCount) => {\n\tconst batchHandler: ProxyHandler<MessageBatch> = {\n\t\tget: (target, prop) => {", "\t\t\tif (prop === 'messages') {\n\t\t\t\tconst messages = Reflect.get(target, prop)\n\t\t\t\tconst messagesHandler: ProxyHandler<MessageBatch['messages']> = {\n\t\t\t\t\tget: (target, prop) => {\n\t\t\t\t\t\tif (typeof prop === 'string' && !isNaN(parseInt(prop))) {\n\t\t\t\t\t\t\tconst message = Reflect.get(target, prop)\n\t\t\t\t\t\t\treturn proxyQueueMessage(message, count)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn wrap(messages, messagesHandler)", "\t\t\t} else if (prop === 'ackAll') {\n\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('ackAll')\n\t\t\t\t\t\tcount.ackRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if (prop === 'retryAll') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('retryAll')\n\t\t\t\t\t\tcount.retryRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop)\n\t\t},\n\t}\n\treturn wrap(batch, batchHandler)\n}\n", "\t\t\t} else if (prop === 'retryAll') {\n\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\taddEvent('retryAll')\n\t\t\t\t\t\tcount.retryRemaining()\n\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop)\n\t\t},\n\t}\n\treturn wrap(batch, batchHandler)\n}\n", "export function executeQueueHandler(queueFn: QueueHandler, [batch, env, ctx]: QueueHandlerArgs): Promise<void> {\n\tconst count = new MessageStatusCount(batch.messages.length)\n\tbatch = proxyMessageBatch(batch, count)\n\tconst tracer = trace.getTracer('queueHandler')\n\tconst options: SpanOptions = {\n\t\tattributes: {\n\t\t\t'queue.name': batch.queue,\n\t\t},\n\t\tkind: SpanKind.CONSUMER,\n\t}\n\tconst promise = tracer.startActiveSpan(`queueHandler:${batch.queue}`, options, async (span) => {\n\t\tconst traceId = span.spanContext().traceId\n\t\tapi_context.active().setValue(traceIdSymbol, traceId)", "\t\ttry {\n\t\t\tconst result = queueFn(batch, env, ctx)\n\t\t\tawait span.setAttribute('queue.implicitly_acked', count.total - count.succeeded - count.failed)\n\t\t\tcount.ackRemaining()\n\t\t\tspan.setAttributes(count.toAttributes())\n\t\t\tspan.end()\n\t\t\treturn result\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setAttribute('queue.implicitly_retried', count.total - count.succeeded - count.failed)\n\t\t\tcount.retryRemaining()\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n", "export function createQueueHandler(queueFn: QueueHandler, initialiser: Initialiser) {\n\tconst queueHandler: ProxyHandler<QueueHandler> = {\n\t\tasync apply(target, _thisArg, argArray: Parameters<QueueHandler>): Promise<void> {\n\t\t\tconst [batch, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, batch)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: QueueHandlerArgs = [batch, env, ctx]\n", "\t\t\ttry {\n\t\t\t\tconst args: QueueHandlerArgs = [batch, env, ctx]\n\n\t\t\t\treturn await api_context.with(context, executeQueueHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queueFn, queueHandler)\n}\n", "function instrumentQueueSend(fn: Queue<unknown>['send'], name: string): Queue<unknown>['send'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['send']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`queueSend: ${name}`, async (span) => {\n\t\t\t\tspan.setAttribute('queue.operation', 'send')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n", "function instrumentQueueSendBatch(fn: Queue<unknown>['sendBatch'], name: string): Queue<unknown>['sendBatch'] {\n\tconst tracer = trace.getTracer('queueSender')\n\tconst handler: ProxyHandler<Queue<unknown>['sendBatch']> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\treturn tracer.startActiveSpan(`queueSendBatch: ${name}`, async (span) => {\n\t\t\t\tspan.setAttribute('queue.operation', 'sendBatch')\n\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\tspan.end()\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n", "export function instrumentQueueSender(queue: Queue<unknown>, name: string) {\n\tconst queueHandler: ProxyHandler<Queue<unknown>> = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'send') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSend(sendFn, name)\n\t\t\t} else if (prop === 'sendBatch') {\n\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentQueueSendBatch(sendFn, name)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(queue, queueHandler)\n}\n"]}
{"filename": "src/instrumentation/env.ts", "chunked_list": ["import { wrap } from '../wrap.js'\nimport { instrumentDOBinding } from './do.js'\nimport { instrumentKV } from './kv.js'\nimport { instrumentQueueSender } from './queue.js'\n\nconst isKVNamespace = (item?: unknown): item is KVNamespace => {\n\treturn !!(item as KVNamespace)?.getWithMetadata\n}\n\nconst isQueue = (item?: unknown): item is Queue<unknown> => {", "\nconst isQueue = (item?: unknown): item is Queue<unknown> => {\n\treturn !!(item as Queue<unknown>)?.sendBatch\n}\n\nconst isDurableObject = (item?: unknown): item is DurableObjectNamespace => {\n\treturn !!(item as DurableObjectNamespace)?.idFromName\n}\n\nconst instrumentEnv = (env: Record<string, unknown>): Record<string, unknown> => {", "\nconst instrumentEnv = (env: Record<string, unknown>): Record<string, unknown> => {\n\tconst envHandler: ProxyHandler<Record<string, unknown>> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst item = Reflect.get(target, prop, receiver)\n\t\t\tif (isKVNamespace(item)) {\n\t\t\t\treturn instrumentKV(item, String(prop))\n\t\t\t} else if (isQueue(item)) {\n\t\t\t\treturn instrumentQueueSender(item, String(prop))\n\t\t\t} else if (isDurableObject(item)) {\n\t\t\t\treturn instrumentDOBinding(item, String(prop))\n\t\t\t} else {\n\t\t\t\treturn item\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(env, envHandler)\n}\n\nexport { instrumentEnv }\n", "\t\t\t} else if (isDurableObject(item)) {\n\t\t\t\treturn instrumentDOBinding(item, String(prop))\n\t\t\t} else {\n\t\t\t\treturn item\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(env, envHandler)\n}\n\nexport { instrumentEnv }\n"]}
{"filename": "src/instrumentation/do.ts", "chunked_list": ["import { context as api_context, trace, SpanOptions, SpanKind, Exception, SpanStatusCode } from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { passthroughGet, unwrap, wrap } from '../wrap.js'\nimport {\n\tgetParentContextFromHeaders,\n\tgatherIncomingCfAttributes,\n\tgatherRequestAttributes,\n\tgatherResponseAttributes,\n\tinstrumentFetcher,\n} from './fetch.js'", "\tinstrumentFetcher,\n} from './fetch.js'\nimport { instrumentEnv } from './env.js'\nimport { Initialiser, setConfig } from '../config.js'\nimport { exportSpans } from './common.js'\nimport { instrumentStorage } from './do-storage.js'\nimport { DOConstructorTrigger } from '../types.js'\n\ntype FetchFn = DurableObject['fetch']\ntype AlarmFn = DurableObject['alarm']\ntype Env = Record<string, unknown>\n", "type FetchFn = DurableObject['fetch']\ntype AlarmFn = DurableObject['alarm']\ntype Env = Record<string, unknown>\n\nfunction instrumentBindingStub(stub: DurableObjectStub, nsName: string): DurableObjectStub {\n\tconst stubHandler: ProxyHandler<typeof stub> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\tconst attrs = {\n\t\t\t\t\tname: `durable_object:${nsName}`,\n\t\t\t\t\t'do.namespace': nsName,\n\t\t\t\t\t'do.id': target.id.toString(),\n\t\t\t\t\t'do.id.name': target.id.name,\n\t\t\t\t}\n\t\t\t\treturn instrumentFetcher(fetcher, () => ({ includeTraceContext: true }), attrs)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(stub, stubHandler)\n}\n", "function instrumentBindingGet(getFn: DurableObjectNamespace['get'], nsName: string): DurableObjectNamespace['get'] {\n\tconst getHandler: ProxyHandler<DurableObjectNamespace['get']> = {\n\t\tapply(target, thisArg, argArray) {\n\t\t\tconst stub: DurableObjectStub = Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentBindingStub(stub, nsName)\n\t\t},\n\t}\n\treturn wrap(getFn, getHandler)\n}\n\nexport function instrumentDOBinding(ns: DurableObjectNamespace, nsName: string) {\n\tconst nsHandler: ProxyHandler<typeof ns> = {\n\t\tget(target, prop) {", "export function instrumentDOBinding(ns: DurableObjectNamespace, nsName: string) {\n\tconst nsHandler: ProxyHandler<typeof ns> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'get') {\n\t\t\t\tconst fn = Reflect.get(ns, prop)\n\t\t\t\treturn instrumentBindingGet(fn, nsName)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(ns, nsHandler)\n}\n", "export function instrumentState(state: DurableObjectState) {\n\tconst stateHandler: ProxyHandler<DurableObjectState> = {\n\t\tget(target, prop, receiver) {\n\t\t\tconst result = Reflect.get(target, prop, unwrap(receiver))\n\t\t\tif (prop === 'storage') {\n\t\t\t\treturn instrumentStorage(result)\n\t\t\t} else if (typeof result === 'function') {\n\t\t\t\treturn result.bind(target)\n\t\t\t} else {\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(state, stateHandler)\n}\n\nlet cold_start = true", "export type DOClass = { new (state: DurableObjectState, env: any): DurableObject }\nexport function executeDOFetch(fetchFn: FetchFn, request: Request, id: DurableObjectId): Promise<Response> {\n\tconst spanContext = getParentContextFromHeaders(request.headers)\n\n\tconst tracer = trace.getTracer('DO fetchHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`do.fetchHandler:${name}`, options, spanContext, async (span) => {", "\t\ttry {\n\t\t\tconst response: Response = await fetchFn(request)\n\t\t\tif (response.ok) {\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t}\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\tspan.end()\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n", "\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function executeDOAlarm(alarmFn: NonNullable<AlarmFn>, id: DurableObjectId): Promise<void> {\n\tconst tracer = trace.getTracer('DO alarmHandler')\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`do.alarmHandler:${name}`, async (span) => {\n\t\tspan.setAttribute(SemanticAttributes.FAAS_COLDSTART, cold_start)\n\t\tcold_start = false\n\t\tspan.setAttribute('do.id', id.toString())", "export function executeDOAlarm(alarmFn: NonNullable<AlarmFn>, id: DurableObjectId): Promise<void> {\n\tconst tracer = trace.getTracer('DO alarmHandler')\n\n\tconst name = id.name || ''\n\tconst promise = tracer.startActiveSpan(`do.alarmHandler:${name}`, async (span) => {\n\t\tspan.setAttribute(SemanticAttributes.FAAS_COLDSTART, cold_start)\n\t\tcold_start = false\n\t\tspan.setAttribute('do.id', id.toString())\n\t\tif (id.name) span.setAttribute('do.name', id.name)\n\n\t\ttry {\n\t\t\tawait alarmFn()\n\t\t\tspan.end()", "\t\tif (id.name) span.setAttribute('do.name', id.name)\n\n\t\ttry {\n\t\t\tawait alarmFn()\n\t\t\tspan.end()\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n", "function instrumentFetchFn(fetchFn: FetchFn, initialiser: Initialiser, env: Env, id: DurableObjectId): FetchFn {\n\tconst fetchHandler: ProxyHandler<FetchFn> = {\n\t\tasync apply(target, thisArg, argArray: Parameters<FetchFn>) {\n\t\t\tconst request = argArray[0]\n\t\t\tconst config = initialiser(env, request)\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOFetch, undefined, bound, request, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error", "\t\t\t\treturn await api_context.with(context, executeDOFetch, undefined, bound, request, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\texportSpans()\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n", "function instrumentAlarmFn(alarmFn: AlarmFn, initialiser: Initialiser, env: Env, id: DurableObjectId) {\n\tif (!alarmFn) return undefined\n\n\tconst alarmHandler: ProxyHandler<NonNullable<AlarmFn>> = {\n\t\tasync apply(target, thisArg) {\n\t\t\tconst config = initialiser(env, 'do-alarm')\n\t\t\tconst context = setConfig(config)\n\t\t\ttry {\n\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\treturn await api_context.with(context, executeDOAlarm, undefined, bound, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error", "\t\t\t\treturn await api_context.with(context, executeDOAlarm, undefined, bound, id)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\texportSpans()\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(alarmFn, alarmHandler)\n}\n", "function instrumentDurableObject(doObj: DurableObject, initialiser: Initialiser, env: Env, state: DurableObjectState) {\n\tconst objHandler: ProxyHandler<DurableObject> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'fetch') {\n\t\t\t\tconst fetchFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentFetchFn(fetchFn, initialiser, env, state.id)\n\t\t\t} else if (prop === 'alarm') {\n\t\t\t\tconst alarmFn = Reflect.get(target, prop)\n\t\t\t\treturn instrumentAlarmFn(alarmFn, initialiser, env, state.id)\n\t\t\t} else {\n\t\t\t\tconst result = Reflect.get(target, prop)", "\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tresult.bind(doObj)\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(doObj, objHandler)\n}\n\nexport function instrumentDOClass(doClass: DOClass, initialiser: Initialiser): DOClass {\n\tconst classHandler: ProxyHandler<DOClass> = {\n\t\tconstruct(target, [orig_state, orig_env]: ConstructorParameters<DOClass>) {\n\t\t\tconst trigger: DOConstructorTrigger = {\n\t\t\t\tid: orig_state.id.toString(),\n\t\t\t\tname: orig_state.id.name,\n\t\t\t}\n\t\t\tconst constructorConfig = initialiser(orig_env, trigger)\n\t\t\tconst context = setConfig(constructorConfig)\n\t\t\tconst state = instrumentState(orig_state)\n\t\t\tconst env = instrumentEnv(orig_env)\n\t\t\tconst createDO = () => {\n\t\t\t\treturn new target(state, env)\n\t\t\t}", "export function instrumentDOClass(doClass: DOClass, initialiser: Initialiser): DOClass {\n\tconst classHandler: ProxyHandler<DOClass> = {\n\t\tconstruct(target, [orig_state, orig_env]: ConstructorParameters<DOClass>) {\n\t\t\tconst trigger: DOConstructorTrigger = {\n\t\t\t\tid: orig_state.id.toString(),\n\t\t\t\tname: orig_state.id.name,\n\t\t\t}\n\t\t\tconst constructorConfig = initialiser(orig_env, trigger)\n\t\t\tconst context = setConfig(constructorConfig)\n\t\t\tconst state = instrumentState(orig_state)\n\t\t\tconst env = instrumentEnv(orig_env)\n\t\t\tconst createDO = () => {\n\t\t\t\treturn new target(state, env)\n\t\t\t}", "\t\t\tconst doObj = api_context.with(context, createDO)\n\n\t\t\treturn instrumentDurableObject(doObj, initialiser, env, state)\n\t\t},\n\t}\n\treturn wrap(doClass, classHandler)\n}\n"]}
{"filename": "src/instrumentation/do-storage.ts", "chunked_list": ["import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst StorageAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(argArray, result) {\n\t\tlet attrs = {}\n\t\tif (Array.isArray(argArray[0])) {\n\t\t\tconst keys = argArray[0]\n\t\t\tattrs = {\n\t\t\t\t'do.storage.key': keys[0],\n\t\t\t\t'do.storage.number_of_keys': keys.length,\n\t\t\t\t'do.storage.keys_deleted': result,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'do.storage.key': argArray[0],\n\t\t\t\t'do.storage.success': result,\n\t\t\t}\n\t\t}", "\t\tif (Array.isArray(argArray[0])) {\n\t\t\tconst keys = argArray[0]\n\t\t\tattrs = {\n\t\t\t\t'do.storage.key': keys[0],\n\t\t\t\t'do.storage.number_of_keys': keys.length,\n\t\t\t\t'do.storage.keys_deleted': result,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'do.storage.key': argArray[0],\n\t\t\t\t'do.storage.success': result,\n\t\t\t}\n\t\t}", "\t\tif (argArray.length > 1) {\n\t\t\tObject.assign(attrs, argArray[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tget(argArray) {\n\t\tlet attrs = {}\n\t\tif (Array.isArray(argArray[0])) {\n\t\t\tconst keys = argArray[0]\n\t\t\tattrs = {\n\t\t\t\t'do.storage.key': keys[0],\n\t\t\t\t'do.storage.number_of_keys': keys.length,\n\t\t\t}\n\t\t} else {\n\t\t\tattrs = {\n\t\t\t\t'do.storage.key': argArray[0],\n\t\t\t}\n\t\t}", "\t\tif (argArray.length > 1) {\n\t\t\tObject.assign(attrs, argArray[1])\n\t\t}\n\t\treturn attrs\n\t},\n\tlist(argArray, result: Map<string, unknown>) {\n\t\t// list may be called with no arguments\n\t\tconst attrs: Attributes = {\n\t\t\t'do.storage.number_of_results': result.size,\n\t\t}\n\t\tObject.assign(attrs, argArray[0])\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst attrs = {\n\t\t\t'do.storage.key': argArray[0],\n\t\t}\n", "\t\tif (argArray.length > 2) {\n\t\t\tObject.assign(attrs, argArray[2])\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentStorageFn(fn: Function, operation: string) {\n\tconst tracer = trace.getTracer('do_storage')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes: {\n\t\t\t\t\toperation,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`do:storage:${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrs = StorageAttributes[operation] ? StorageAttributes[operation](argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute('hasResult', !!result)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n", "export function instrumentStorage(storage: DurableObjectStorage): DurableObjectStorage {\n\tconst storageHandler: ProxyHandler<DurableObjectStorage> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentStorageFn(fn, operation)\n\t\t},\n\t}\n\treturn wrap(storage, storageHandler)\n}\n"]}
{"filename": "src/instrumentation/common.ts", "chunked_list": ["import { trace } from '@opentelemetry/api'\nimport { WorkerTracer } from '../tracer.js'\nimport { passthroughGet, wrap } from '../wrap.js'\n\ntype ContextAndTracker = { ctx: ExecutionContext; tracker: PromiseTracker }\ntype WaitUntilFn = ExecutionContext['waitUntil']\n\nexport class PromiseTracker {\n\t_outstandingPromises: Promise<unknown>[] = []\n\n\tget outstandingPromiseCount() {\n\t\treturn this._outstandingPromises.length\n\t}\n\n\ttrack(promise: Promise<unknown>): void {\n\t\tthis._outstandingPromises.push(promise)\n\t}\n\n\tasync wait() {\n\t\tawait allSettledMutable(this._outstandingPromises)\n\t}\n}\n", "function createWaitUntil(fn: WaitUntilFn, context: ExecutionContext, tracker: PromiseTracker): WaitUntilFn {\n\tconst handler: ProxyHandler<WaitUntilFn> = {\n\t\tapply(target, thisArg, argArray) {\n\t\t\ttracker.track(argArray[0])\n\t\t\treturn Reflect.apply(target, context, argArray)\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n\nexport function proxyExecutionContext(context: ExecutionContext): ContextAndTracker {\n\tconst tracker = new PromiseTracker()\n\tconst ctx = new Proxy(context, {\n\t\tget(target, prop) {", "export function proxyExecutionContext(context: ExecutionContext): ContextAndTracker {\n\tconst tracker = new PromiseTracker()\n\tconst ctx = new Proxy(context, {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'waitUntil') {\n\t\t\t\tconst fn = Reflect.get(target, prop)\n\t\t\t\treturn createWaitUntil(fn, context, tracker)\n\t\t\t} else {\n\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t}\n\t\t},\n\t})\n\treturn { ctx, tracker }\n}\n", "export async function exportSpans(tracker?: PromiseTracker) {\n\tconst tracer = trace.getTracer('export')\n\tif (tracer instanceof WorkerTracer) {\n\t\tawait scheduler.wait(1)\n\t\tif (tracker) {\n\t\t\tawait tracker.wait()\n\t\t}\n\t\tawait tracer.spanProcessor.forceFlush()\n\t} else {\n\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n\t}\n}\n\n/** Like `Promise.allSettled`, but handles modifications to the promises array */", "\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n\t}\n}\n\n/** Like `Promise.allSettled`, but handles modifications to the promises array */\nexport async function allSettledMutable(promises: Promise<unknown>[]): Promise<PromiseSettledResult<unknown>[]> {\n\tlet values: PromiseSettledResult<unknown>[]\n\t// when the length of the array changes, there has been a nested call to waitUntil\n\t// and we should await the promises again\n\tdo {\n\t\tvalues = await Promise.allSettled(promises)", "\t} while (values.length !== promises.length)\n\treturn values\n}\n"]}
{"filename": "src/instrumentation/fetch.ts", "chunked_list": ["import {\n\ttrace,\n\tSpanOptions,\n\tSpanKind,\n\tpropagation,\n\tcontext as api_context,\n\tAttributes,\n\tException,\n\tContext,\n\tSpanStatusCode,", "\tContext,\n\tSpanStatusCode,\n} from '@opentelemetry/api'\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\nimport { Initialiser, getActiveConfig, setConfig } from '../config.js'\nimport { wrap } from '../wrap.js'\nimport { instrumentEnv } from './env.js'\nimport { exportSpans, proxyExecutionContext } from './common.js'\nimport { ResolvedTraceConfig } from '../types.js'\n\nexport type IncludeTraceContextFn = (request: Request) => boolean", "import { ResolvedTraceConfig } from '../types.js'\n\nexport type IncludeTraceContextFn = (request: Request) => boolean\nexport interface FetcherConfig {\n\tincludeTraceContext?: boolean | IncludeTraceContextFn\n}\n\nexport type AcceptTraceContextFn = (request: Request) => boolean\nexport interface FetchHandlerConfig {\n\t/**\n\t * Whether to enable context propagation for incoming requests to `fetch`.\n\t * This enables or disables distributed tracing from W3C Trace Context headers.\n\t * @default true\n\t */\n\tacceptTraceContext?: boolean | AcceptTraceContextFn\n}\n", "export interface FetchHandlerConfig {\n\t/**\n\t * Whether to enable context propagation for incoming requests to `fetch`.\n\t * This enables or disables distributed tracing from W3C Trace Context headers.\n\t * @default true\n\t */\n\tacceptTraceContext?: boolean | AcceptTraceContextFn\n}\n\ntype FetchHandler = ExportedHandlerFetchHandler\ntype FetchHandlerArgs = Parameters<FetchHandler>\n", "type FetchHandler = ExportedHandlerFetchHandler\ntype FetchHandlerArgs = Parameters<FetchHandler>\n\nexport function sanitiseURL(url: string): string {\n\tconst u = new URL(url)\n\treturn `${u.protocol}//${u.host}${u.pathname}${u.search}`\n}\n\nconst gatherOutgoingCfAttributes = (cf: RequestInitCfProperties): Attributes => {\n\tconst attrs: Record<string, string | number> = {}\n\tObject.keys(cf).forEach((key) => {\n\t\tconst value = cf[key]", "\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\tattrs[`cf.${key}`] = value\n\t\t} else {\n\t\t\tattrs[`cf.${key}`] = JSON.stringify(value)\n\t\t}\n\t})\n\treturn attrs\n}\n\nexport function gatherRequestAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tconst headers = request.headers\n\t// attrs[SemanticAttributes.HTTP_CLIENT_IP] = '1.1.1.1'\n\tattrs[SemanticAttributes.HTTP_METHOD] = request.method\n\tattrs[SemanticAttributes.HTTP_URL] = sanitiseURL(request.url)\n\tattrs[SemanticAttributes.HTTP_USER_AGENT] = headers.get('user-agent')!\n\tattrs[SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH] = headers.get('content-length')!\n\tattrs['http.request_content-type'] = headers.get('content-type')!\n\tattrs['http.accepts'] = headers.get('accepts')!\n\treturn attrs\n}\n", "export function gatherRequestAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tconst headers = request.headers\n\t// attrs[SemanticAttributes.HTTP_CLIENT_IP] = '1.1.1.1'\n\tattrs[SemanticAttributes.HTTP_METHOD] = request.method\n\tattrs[SemanticAttributes.HTTP_URL] = sanitiseURL(request.url)\n\tattrs[SemanticAttributes.HTTP_USER_AGENT] = headers.get('user-agent')!\n\tattrs[SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH] = headers.get('content-length')!\n\tattrs['http.request_content-type'] = headers.get('content-type')!\n\tattrs['http.accepts'] = headers.get('accepts')!\n\treturn attrs\n}\n", "export function gatherResponseAttributes(response: Response): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs[SemanticAttributes.HTTP_STATUS_CODE] = response.status\n\tattrs[SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = response.headers.get('content-length')!\n\tattrs['http.response_content-type'] = response.headers.get('content-type')!\n\treturn attrs\n}\n\nexport function gatherIncomingCfAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs[SemanticAttributes.HTTP_SCHEME] = request.cf?.httpProtocol as string\n\tattrs['net.colo'] = request.cf?.colo as string\n\tattrs['net.country'] = request.cf?.country as string\n\tattrs['net.request_priority'] = request.cf?.requestPriority as string\n\tattrs['net.tls_cipher'] = request.cf?.tlsCipher as string\n\tattrs['net.tls_version'] = request.cf?.tlsVersion as string\n\tattrs['net.asn'] = request.cf?.asn as number\n\tattrs['net.tcp_rtt'] = request.cf?.clientTcpRtt as number\n\treturn attrs\n}\n", "export function gatherIncomingCfAttributes(request: Request): Attributes {\n\tconst attrs: Record<string, string | number> = {}\n\tattrs[SemanticAttributes.HTTP_SCHEME] = request.cf?.httpProtocol as string\n\tattrs['net.colo'] = request.cf?.colo as string\n\tattrs['net.country'] = request.cf?.country as string\n\tattrs['net.request_priority'] = request.cf?.requestPriority as string\n\tattrs['net.tls_cipher'] = request.cf?.tlsCipher as string\n\tattrs['net.tls_version'] = request.cf?.tlsVersion as string\n\tattrs['net.asn'] = request.cf?.asn as number\n\tattrs['net.tcp_rtt'] = request.cf?.clientTcpRtt as number\n\treturn attrs\n}\n", "export function getParentContextFromHeaders(headers: Headers): Context {\n\treturn propagation.extract(api_context.active(), headers, {\n\t\tget(headers, key) {\n\t\t\treturn headers.get(key) || undefined\n\t\t},\n\t\tkeys(headers) {\n\t\t\treturn [...headers.keys()]\n\t\t},\n\t})\n}\n", "function getParentContextFromRequest(request: Request) {\n\tconst workerConfig = getActiveConfig()\n\tconst acceptTraceContext =\n\t\ttypeof workerConfig.handlers.fetch.acceptTraceContext === 'function'\n\t\t\t? workerConfig.handlers.fetch.acceptTraceContext(request)\n\t\t\t: workerConfig.handlers.fetch.acceptTraceContext ?? true\n\treturn acceptTraceContext ? getParentContextFromHeaders(request.headers) : api_context.active()\n}\n\nexport function waitUntilTrace(fn: () => Promise<any>): Promise<void> {\n\tconst tracer = trace.getTracer('waitUntil')\n\treturn tracer.startActiveSpan('waitUntil', async (span) => {\n\t\tawait fn()\n\t\tspan.end()\n\t})\n}\n\nlet cold_start = true", "export function waitUntilTrace(fn: () => Promise<any>): Promise<void> {\n\tconst tracer = trace.getTracer('waitUntil')\n\treturn tracer.startActiveSpan('waitUntil', async (span) => {\n\t\tawait fn()\n\t\tspan.end()\n\t})\n}\n\nlet cold_start = true\nexport function executeFetchHandler(fetchFn: FetchHandler, [request, env, ctx]: FetchHandlerArgs): Promise<Response> {\n\tconst spanContext = getParentContextFromRequest(request)\n\n\tconst tracer = trace.getTracer('fetchHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t\t[SemanticAttributes.FAAS_EXECUTION]: request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan('fetchHandler', options, spanContext, async (span) => {", "export function executeFetchHandler(fetchFn: FetchHandler, [request, env, ctx]: FetchHandlerArgs): Promise<Response> {\n\tconst spanContext = getParentContextFromRequest(request)\n\n\tconst tracer = trace.getTracer('fetchHandler')\n\tconst attributes = {\n\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t\t[SemanticAttributes.FAAS_EXECUTION]: request.headers.get('cf-ray') ?? undefined,\n\t}\n\tcold_start = false\n\tObject.assign(attributes, gatherRequestAttributes(request))\n\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\tconst options: SpanOptions = {\n\t\tattributes,\n\t\tkind: SpanKind.SERVER,\n\t}\n\n\tconst promise = tracer.startActiveSpan('fetchHandler', options, spanContext, async (span) => {", "\t\ttry {\n\t\t\tconst response: Response = await fetchFn(request, env, ctx)\n\t\t\tif (response.status < 500) {\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t}\n\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\tspan.end()\n\n\t\t\treturn response\n\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n", "\t\t} catch (error) {\n\t\t\tspan.recordException(error as Exception)\n\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\tspan.end()\n\t\t\tthrow error\n\t\t}\n\t})\n\treturn promise\n}\n\nexport function createFetchHandler(fetchFn: FetchHandler, initialiser: Initialiser) {\n\tconst fetchHandler: ProxyHandler<FetchHandler> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<FetchHandler>): Promise<Response> => {\n\t\t\tconst [request, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, request)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n", "export function createFetchHandler(fetchFn: FetchHandler, initialiser: Initialiser) {\n\tconst fetchHandler: ProxyHandler<FetchHandler> = {\n\t\tapply: async (target, _thisArg, argArray: Parameters<FetchHandler>): Promise<Response> => {\n\t\t\tconst [request, orig_env, orig_ctx] = argArray\n\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, request)\n\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\tconst context = setConfig(config)\n\n\t\t\ttry {\n\t\t\t\tconst args: FetchHandlerArgs = [request, env, ctx]", "\t\t\ttry {\n\t\t\t\tconst args: FetchHandlerArgs = [request, env, ctx]\n\t\t\t\treturn await api_context.with(context, executeFetchHandler, undefined, target, args)\n\t\t\t} catch (error) {\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(fetchFn, fetchHandler)\n}\n", "type getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\nexport function instrumentFetcher(\n\tfetchFn: Fetcher['fetch'],\n\tconfigFn: getFetchConfig,\n\tattrs?: Attributes\n): Fetcher['fetch'] {\n\tconst handler: ProxyHandler<typeof fetch> = {\n\t\tapply: (target, thisArg, argArray): ReturnType<typeof fetch> => {\n\t\t\tconst workerConfig = getActiveConfig()\n\t\t\tconst config = configFn(workerConfig)\n\t\t\tconst request = new Request(argArray[0], argArray[1])\n\n\t\t\tconst tracer = trace.getTracer('fetcher')\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\n\t\t\tconst host = new URL(request.url).host\n\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `fetch: ${host}`\n\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\tconst includeTraceContext =\n\t\t\t\t\ttypeof config.includeTraceContext === 'function'\n\t\t\t\t\t\t? config.includeTraceContext(request)\n\t\t\t\t\t\t: config.includeTraceContext", "\t\t\t\tif (includeTraceContext ?? true) {\n\t\t\t\t\tpropagation.inject(api_context.active(), request.headers, {\n\t\t\t\t\t\tset: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tspan.setAttributes(gatherRequestAttributes(request))\n\t\t\t\tif (request.cf) span.setAttributes(gatherOutgoingCfAttributes(request.cf))\n\t\t\t\tconst response: Response = await Reflect.apply(target, thisArg, [request])\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tspan.end()\n\t\t\t\treturn response\n\t\t\t})\n\t\t\treturn promise\n\t\t},\n\t}\n\treturn wrap(fetchFn, handler, true)\n}\n", "export function instrumentGlobalFetch(): void {\n\tglobalThis.fetch = instrumentFetcher(globalThis.fetch, (config) => config.fetch)\n}\n"]}
{"filename": "src/instrumentation/cache.ts", "chunked_list": ["import { SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap.js'\nimport { sanitiseURL } from './fetch.js'\n\ntype CacheFns = Cache[keyof Cache]\n\nconst tracer = trace.getTracer('cache instrumentation')\n\nfunction instrumentFunction<T extends CacheFns>(fn: T, cacheName: string, op: string): T {\n\tconst handler: ProxyHandler<typeof fn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst attributes = {\n\t\t\t\t'cache.name': cacheName,\n\t\t\t\t'http.url': argArray[0].url ? sanitiseURL(argArray[0].url) : undefined,\n\t\t\t\t'cache.operation': op,\n\t\t\t}\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes }\n\t\t\treturn tracer.startActiveSpan(`cache:${cacheName}:${op}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)", "function instrumentFunction<T extends CacheFns>(fn: T, cacheName: string, op: string): T {\n\tconst handler: ProxyHandler<typeof fn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst attributes = {\n\t\t\t\t'cache.name': cacheName,\n\t\t\t\t'http.url': argArray[0].url ? sanitiseURL(argArray[0].url) : undefined,\n\t\t\t\t'cache.operation': op,\n\t\t\t}\n\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes }\n\t\t\treturn tracer.startActiveSpan(`cache:${cacheName}:${op}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)", "\t\t\t\tif (op === 'match') {\n\t\t\t\t\tspan.setAttribute('cache.hit', !result)\n\t\t\t\t}\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, handler)\n}\n", "function instrumentCache(cache: Cache, cacheName: string): Cache {\n\tconst handler: ProxyHandler<typeof cache> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'delete' || prop === 'match' || prop === 'put') {\n\t\t\t\tconst fn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentFunction(fn, cacheName, prop)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\treturn wrap(cache, handler)\n}\n", "function instrumentOpen(openFn: CacheStorage['open']): CacheStorage['open'] {\n\tconst handler: ProxyHandler<typeof openFn> = {\n\t\tasync apply(target, thisArg, argArray) {\n\t\t\tconst cacheName = argArray[0]\n\t\t\tconst cache = await Reflect.apply(target, thisArg, argArray)\n\t\t\treturn instrumentCache(cache, cacheName)\n\t\t},\n\t}\n\treturn wrap(openFn, handler)\n}\n", "function _instrumentGlobalCache() {\n\tconst handler: ProxyHandler<typeof caches> = {\n\t\tget(target, prop) {\n\t\t\tif (prop === 'default') {\n\t\t\t\tconst cache = target.default\n\t\t\t\treturn instrumentCache(cache, 'default')\n\t\t\t} else if (prop === 'open') {\n\t\t\t\tconst openFn = Reflect.get(target, prop).bind(target)\n\t\t\t\treturn instrumentOpen(openFn)\n\t\t\t} else {\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t}\n\t\t},\n\t}\n\t//@ts-ignore\n\tglobalThis.caches = wrap(caches, handler)\n}\n", "export function instrumentGlobalCache() {\n\treturn _instrumentGlobalCache()\n}\n"]}
{"filename": "src/instrumentation/kv.ts", "chunked_list": ["import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\nimport { wrap } from '../wrap.js'\n\ntype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\nconst KVAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\tdelete(argArray) {\n\t\treturn {\n\t\t\t'kv.key': argArray[0],\n\t\t}\n\t},\n\tget(argArray) {\n\t\tconst attrs: Attributes = {\n\t\t\t'kv.key': argArray[0],\n\t\t}\n\t\tconst opts = argArray[1]", "\t\tif (typeof opts === 'string') {\n\t\t\tattrs['type'] = opts\n\t\t} else if (typeof opts === 'object') {\n\t\t\tattrs['type'] = opts.type\n\t\t\tattrs['cacheTtl'] = opts.cacheTtl\n\t\t}\n\t\treturn attrs\n\t},\n\tgetWithMetadata(argArray, result) {\n\t\tconst attrs = this.get(argArray, result)\n\t\tattrs['withMetadata'] = true\n\t\treturn attrs\n\t},\n\tlist(argArray, result) {\n\t\tconst attrs: Attributes = {}\n\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n\t\tconst { cursor, limit, prefix } = opts\n\t\tattrs['kv.list_prefix'] = prefix || undefined\n\t\tattrs['kv.list_request_cursor'] = cursor || undefined\n\t\tattrs['kv.list_limit'] = limit || undefined\n\t\tconst { list_complete } = result as KVNamespaceListResult<any, any>\n\t\tattrs['kv.list_complete'] = limit || undefined", "\t\tif (!list_complete) {\n\t\t\tattrs['kv.list_response_cursor'] = cursor || undefined\n\t\t}\n\t\treturn attrs\n\t},\n\tput(argArray) {\n\t\tconst attrs: Attributes = {\n\t\t\t'kv.key': argArray[0],\n\t\t}\n\t\tif (argArray.length > 2 && argArray[2]) {\n\t\t\tconst { expiration, expirationTtl, metadata } = argArray[2] as KVNamespacePutOptions\n\t\t\tattrs['kv.expiration'] = expiration\n\t\t\tattrs['kv.expirationTtl'] = expirationTtl\n\t\t\tattrs['kv.withMetadata'] = !!metadata\n\t\t}\n\t\treturn attrs\n\t},\n}\n", "\t\tif (argArray.length > 2 && argArray[2]) {\n\t\t\tconst { expiration, expirationTtl, metadata } = argArray[2] as KVNamespacePutOptions\n\t\t\tattrs['kv.expiration'] = expiration\n\t\t\tattrs['kv.expirationTtl'] = expirationTtl\n\t\t\tattrs['kv.withMetadata'] = !!metadata\n\t\t}\n\t\treturn attrs\n\t},\n}\n\nfunction instrumentKVFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('KV')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes: {\n\t\t\t\t\tbinding_type: 'KV',\n\t\t\t\t\tkv_namespace: name,\n\t\t\t\t\toperation,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`kv:${name}:${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrs = KVAttributes[operation] ? KVAttributes[operation](argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute('hasResult', !!result)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n", "function instrumentKVFn(fn: Function, name: string, operation: string) {\n\tconst tracer = trace.getTracer('KV')\n\tconst fnHandler: ProxyHandler<any> = {\n\t\tapply: (target, thisArg, argArray) => {\n\t\t\tconst options: SpanOptions = {\n\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\tattributes: {\n\t\t\t\t\tbinding_type: 'KV',\n\t\t\t\t\tkv_namespace: name,\n\t\t\t\t\toperation,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn tracer.startActiveSpan(`kv:${name}:${operation}`, options, async (span) => {\n\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\tconst extraAttrs = KVAttributes[operation] ? KVAttributes[operation](argArray, result) : {}\n\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\tspan.setAttribute('hasResult', !!result)\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t})\n\t\t},\n\t}\n\treturn wrap(fn, fnHandler)\n}\n", "export function instrumentKV(kv: KVNamespace, name: string): KVNamespace {\n\tconst kvHandler: ProxyHandler<KVNamespace> = {\n\t\tget: (target, prop, receiver) => {\n\t\t\tconst operation = String(prop)\n\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\treturn instrumentKVFn(fn, name, operation)\n\t\t},\n\t}\n\treturn wrap(kv, kvHandler)\n}\n"]}
