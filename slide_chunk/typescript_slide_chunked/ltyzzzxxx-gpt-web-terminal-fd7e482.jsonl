{"filename": "components.d.ts", "chunked_list": ["// generated by unplugin-vue-components\n// We suggest you to commit this file into source control\n// Read more: https://github.com/vuejs/core/pull/3399\nimport '@vue/runtime-core'\n\nexport {}\n\ndeclare module '@vue/runtime-core' {\n  export interface GlobalComponents {\n    ACol: typeof import('ant-design-vue/es')['Col']\n    ACollapse: typeof import('ant-design-vue/es')['Collapse']\n    ACollapsePanel: typeof import('ant-design-vue/es')['CollapsePanel']\n    AInput: typeof import('ant-design-vue/es')['Input']\n    ARow: typeof import('ant-design-vue/es')['Row']\n    ATag: typeof import('ant-design-vue/es')['Tag']\n    ContentOutput: typeof import('./src/components/gpt-terminal/ContentOutput.vue')['default']\n    GptTerminal: typeof import('./src/components/gpt-terminal/GptTerminal.vue')['default']\n    RouterLink: typeof import('vue-router')['RouterLink']\n    RouterView: typeof import('vue-router')['RouterView']\n  }\n}\n", "  export interface GlobalComponents {\n    ACol: typeof import('ant-design-vue/es')['Col']\n    ACollapse: typeof import('ant-design-vue/es')['Collapse']\n    ACollapsePanel: typeof import('ant-design-vue/es')['CollapsePanel']\n    AInput: typeof import('ant-design-vue/es')['Input']\n    ARow: typeof import('ant-design-vue/es')['Row']\n    ATag: typeof import('ant-design-vue/es')['Tag']\n    ContentOutput: typeof import('./src/components/gpt-terminal/ContentOutput.vue')['default']\n    GptTerminal: typeof import('./src/components/gpt-terminal/GptTerminal.vue')['default']\n    RouterLink: typeof import('vue-router')['RouterLink']\n    RouterView: typeof import('vue-router')['RouterView']\n  }\n}\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig, loadEnv } from \"vite\";\nimport vue from \"@vitejs/plugin-vue\";\n// @ts-ignore\nimport Components from \"unplugin-vue-components/vite\";\n// @ts-ignore\nimport { AntDesignVueResolver } from \"unplugin-vue-components/resolvers\";\n\n// https://vitejs.dev/config/\nexport default defineConfig((env) => {\n  const viteEnv = loadEnv(env.mode, process.cwd())", "export default defineConfig((env) => {\n  const viteEnv = loadEnv(env.mode, process.cwd())\n  return {\n    plugins: [\n      vue(),\n      // \u6309\u9700\u52a0\u8f7d ant-design-vue\n      Components({\n        resolvers: [AntDesignVueResolver()],\n      }),\n    ].filter(Boolean),", "      }),\n    ].filter(Boolean),\n    server: {\n      host: '0.0.0.0',\n      port: 3001,\n      open: false,\n      proxy: {\n        '/api': {\n          target: viteEnv.VITE_APP_API_BASE_URL,\n          changeOrigin: true, // \u5141\u8bb8\u8de8\u57df", "          target: viteEnv.VITE_APP_API_BASE_URL,\n          changeOrigin: true, // \u5141\u8bb8\u8de8\u57df\n          rewrite: path => path.replace('/api/', '/'),\n        },\n      },\n    },\n  };\n});"]}
{"filename": "service/tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup'\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  outDir: 'build',\n  target: 'es2020',\n  format: ['esm'],\n  splitting: false,\n  sourcemap: true,\n  minify: false,", "  sourcemap: true,\n  minify: false,\n  shims: true,\n  dts: false,\n})\n"]}
{"filename": "service/src/types.ts", "chunked_list": ["import type { FetchFn } from 'chatgpt'\n\nexport interface RequestProps {\n  prompt: string\n  options?: ChatContext\n  systemMessage: string\n  temperature?: number\n  top_p?: number\n}\n\nexport interface ChatContext {\n  conversationId?: string\n  parentMessageId?: string\n}\n", "export interface ChatContext {\n  conversationId?: string\n  parentMessageId?: string\n}\n\nexport interface ChatGPTUnofficialProxyAPIOptions {\n  accessToken: string\n  apiReverseProxyUrl?: string\n  model?: string\n  debug?: boolean\n  headers?: Record<string, string>\n  fetch?: FetchFn\n}\n", "export interface ModelConfig {\n  apiModel?: ApiModel\n  reverseProxy?: string\n  timeoutMs?: number\n  socksProxy?: string\n  httpsProxy?: string\n  usage?: string\n}\n\nexport type ApiModel = 'ChatGPTAPI' | 'ChatGPTUnofficialProxyAPI' | undefined\n", "export type ApiModel = 'ChatGPTAPI' | 'ChatGPTUnofficialProxyAPI' | undefined\n"]}
{"filename": "service/src/index.ts", "chunked_list": ["import express from 'express'\nimport type { RequestProps } from './types'\nimport type { ChatMessage } from './chatgpt'\nimport { chatConfig, chatReplyProcess, currentModel } from './chatgpt'\nimport { limiter } from './middleware/limiter'\nimport { isNotEmptyString } from './utils/is'\n\nconst app = express()\nconst router = express.Router()\n", "const router = express.Router()\n\napp.use(express.static('public'))\napp.use(express.json())\n\napp.all('*', (_, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*')\n  res.header('Access-Control-Allow-Headers', 'authorization, Content-Type')\n  res.header('Access-Control-Allow-Methods', '*')\n  next()", "  res.header('Access-Control-Allow-Methods', '*')\n  next()\n})\n\nrouter.post('/chat-process', [limiter], async (req, res) => {\n  res.setHeader('Content-type', 'application/octet-stream')\n\n  try {\n    const { prompt, options = {}, systemMessage, temperature, top_p } = req.body as RequestProps\n    let firstChunk = true\n    await chatReplyProcess({\n      message: prompt,\n      lastContext: options,\n      process: (chat: ChatMessage) => {\n        res.write(firstChunk ? JSON.stringify(chat) : `\\n${JSON.stringify(chat)}`)\n        firstChunk = false\n      },\n      systemMessage,\n      temperature,\n      top_p,\n    })\n  }", "  catch (error) {\n    res.write(JSON.stringify(error))\n  }\n  finally {\n    res.end()\n  }\n})\n\nrouter.post('/config', async (req, res) => {\n  try {\n    const response = await chatConfig()\n    res.send(response)\n  }", "  try {\n    const response = await chatConfig()\n    res.send(response)\n  }\n  catch (error) {\n    res.send(error)\n  }\n})\n\napp.use('', router)\napp.use('/api', router)\napp.set('trust proxy', 1)\n\napp.listen(3002, () => globalThis.console.log('Server is running on port 3002'))\n"]}
{"filename": "service/src/utils/index.ts", "chunked_list": ["interface SendResponseOptions<T = any> {\n  type: 'Success' | 'Fail'\n  message?: string\n  data?: T\n}\n\nexport function sendResponse<T>(options: SendResponseOptions<T>) {\n  if (options.type === 'Success') {\n    return Promise.resolve({\n      message: options.message ?? null,\n      data: options.data ?? null,\n      status: options.type,\n    })\n  }\n\n  // eslint-disable-next-line prefer-promise-reject-errors\n  return Promise.reject({\n    message: options.message ?? 'Failed',\n    data: options.data ?? null,\n    status: options.type,\n  })\n}\n"]}
{"filename": "service/src/utils/is.ts", "chunked_list": ["export function isNumber<T extends number>(value: T | unknown): value is number {\n  return Object.prototype.toString.call(value) === '[object Number]'\n}\n\nexport function isString<T extends string>(value: T | unknown): value is string {\n  return Object.prototype.toString.call(value) === '[object String]'\n}\n\nexport function isNotEmptyString(value: any): boolean {\n  return typeof value === 'string' && value.length > 0\n}\n", "export function isNotEmptyString(value: any): boolean {\n  return typeof value === 'string' && value.length > 0\n}\n\nexport function isBoolean<T extends boolean>(value: T | unknown): value is boolean {\n  return Object.prototype.toString.call(value) === '[object Boolean]'\n}\n\nexport function isFunction<T extends (...args: any[]) => any | void | never>(value: T | unknown): value is T {\n  return Object.prototype.toString.call(value) === '[object Function]'\n}\n", "export function isFunction<T extends (...args: any[]) => any | void | never>(value: T | unknown): value is T {\n  return Object.prototype.toString.call(value) === '[object Function]'\n}\n"]}
{"filename": "service/src/chatgpt/types.ts", "chunked_list": ["import type { ChatMessage } from 'chatgpt'\nimport type fetch from 'node-fetch'\n\nexport interface RequestOptions {\n  message: string\n  lastContext?: { conversationId?: string; parentMessageId?: string }\n  process?: (chat: ChatMessage) => void\n  systemMessage?: string\n  temperature?: number\n  top_p?: number\n}\n", "export interface ImageRequestOptions {\n  \n}\n\nexport interface SetProxyOptions {\n  fetch?: typeof fetch\n}\n\nexport interface UsageResponse {\n  total_usage: number\n}\n", "export interface UsageResponse {\n  total_usage: number\n}\n"]}
{"filename": "service/src/chatgpt/index.ts", "chunked_list": ["import * as dotenv from 'dotenv'\nimport 'isomorphic-fetch'\nimport type { ChatGPTAPIOptions, ChatMessage, SendMessageOptions } from 'chatgpt'\nimport { ChatGPTAPI, ChatGPTUnofficialProxyAPI } from 'chatgpt'\nimport { SocksProxyAgent } from 'socks-proxy-agent'\nimport httpsProxyAgent from 'https-proxy-agent'\nimport fetch from 'node-fetch'\nimport { sendResponse } from '../utils'\nimport { isNotEmptyString } from '../utils/is'\nimport type { ApiModel, ChatContext, ChatGPTUnofficialProxyAPIOptions, ModelConfig } from '../types'", "import { isNotEmptyString } from '../utils/is'\nimport type { ApiModel, ChatContext, ChatGPTUnofficialProxyAPIOptions, ModelConfig } from '../types'\nimport type { RequestOptions, SetProxyOptions, UsageResponse } from './types'\n\nconst { HttpsProxyAgent } = httpsProxyAgent\n\ndotenv.config()\n\nconst ErrorCodeMessage: Record<string, string> = {\n  401: '[OpenAI] \u63d0\u4f9b\u9519\u8bef\u7684API\u5bc6\u94a5 | Incorrect API key provided',", "const ErrorCodeMessage: Record<string, string> = {\n  401: '[OpenAI] \u63d0\u4f9b\u9519\u8bef\u7684API\u5bc6\u94a5 | Incorrect API key provided',\n  403: '[OpenAI] \u670d\u52a1\u5668\u62d2\u7edd\u8bbf\u95ee\uff0c\u8bf7\u7a0d\u540e\u518d\u8bd5 | Server refused to access, please try again later',\n  502: '[OpenAI] \u9519\u8bef\u7684\u7f51\u5173 |  Bad Gateway',\n  503: '[OpenAI] \u670d\u52a1\u5668\u7e41\u5fd9\uff0c\u8bf7\u7a0d\u540e\u518d\u8bd5 | Server is busy, please try again later',\n  504: '[OpenAI] \u7f51\u5173\u8d85\u65f6 | Gateway Time-out',\n  500: '[OpenAI] \u670d\u52a1\u5668\u7e41\u5fd9\uff0c\u8bf7\u7a0d\u540e\u518d\u8bd5 | Internal Server Error',\n}\n\nconst timeoutMs: number = !isNaN(+process.env.TIMEOUT_MS) ? +process.env.TIMEOUT_MS : 100 * 1000", "\nconst timeoutMs: number = !isNaN(+process.env.TIMEOUT_MS) ? +process.env.TIMEOUT_MS : 100 * 1000\nconst disableDebug: boolean = process.env.OPENAI_API_DISABLE_DEBUG === 'true'\n\nlet apiModel: ApiModel\nconst model = isNotEmptyString(process.env.OPENAI_API_MODEL) ? process.env.OPENAI_API_MODEL : 'gpt-3.5-turbo'\n\nif (!isNotEmptyString(process.env.OPENAI_API_KEY) && !isNotEmptyString(process.env.OPENAI_ACCESS_TOKEN))\n  throw new Error('Missing OPENAI_API_KEY or OPENAI_ACCESS_TOKEN environment variable')\n\nlet api: ChatGPTAPI | ChatGPTUnofficialProxyAPI\n\n(async () => {\n  // More Info: https://github.com/transitive-bullshit/chatgpt-api\n", "  if (isNotEmptyString(process.env.OPENAI_API_KEY)) {\n    const OPENAI_API_BASE_URL = process.env.OPENAI_API_BASE_URL\n\n    const options: ChatGPTAPIOptions = {\n      apiKey: process.env.OPENAI_API_KEY,\n      completionParams: { model },\n      debug: !disableDebug,\n    }\n\n    // increase max token limit if use gpt-4\n    if (model.toLowerCase().includes('gpt-4')) {\n      // if use 32k model", "    if (model.toLowerCase().includes('gpt-4')) {\n      // if use 32k model\n      if (model.toLowerCase().includes('32k')) {\n        options.maxModelTokens = 32768\n        options.maxResponseTokens = 8192\n      }\n      else {\n        options.maxModelTokens = 8192\n        options.maxResponseTokens = 2048\n      }\n    }", "    else if (model.toLowerCase().includes('gpt-3.5')) {\n      if (model.toLowerCase().includes('16k')) {\n        options.maxModelTokens = 16384\n        options.maxResponseTokens = 4096\n      }\n    }\n\n    if (isNotEmptyString(OPENAI_API_BASE_URL))\n      options.apiBaseUrl = `${OPENAI_API_BASE_URL}/v1`\n\n    setupProxy(options)\n\n    api = new ChatGPTAPI({ ...options })\n    apiModel = 'ChatGPTAPI'\n  }\n  else {\n    const options: ChatGPTUnofficialProxyAPIOptions = {\n      accessToken: process.env.OPENAI_ACCESS_TOKEN,\n      apiReverseProxyUrl: isNotEmptyString(process.env.API_REVERSE_PROXY) ? process.env.API_REVERSE_PROXY : 'https://ai.fakeopen.com/api/conversation',\n      model,\n      debug: !disableDebug,\n    }\n\n    setupProxy(options)\n\n    api = new ChatGPTUnofficialProxyAPI({ ...options })\n    apiModel = 'ChatGPTUnofficialProxyAPI'\n  }\n})()\n", "async function chatReplyProcess(options: RequestOptions) {\n  const { message, lastContext, process, systemMessage, temperature, top_p } = options\n  try {\n    let options: SendMessageOptions = { timeoutMs }\n    globalThis.console.log(systemMessage)\n    if (apiModel === 'ChatGPTAPI') {\n      if (isNotEmptyString(systemMessage)) {\n        options.systemMessage = systemMessage\n        globalThis.console.log(systemMessage)\n      }\n      options.completionParams = { model, temperature, top_p }\n    }\n", "    if (lastContext != null) {\n      if (apiModel === 'ChatGPTAPI')\n        options.parentMessageId = lastContext.parentMessageId\n      else\n        options = { ...lastContext }\n    }\n\n    const response = await api.sendMessage(message, {\n      ...options,\n      onProgress: (partialResponse) => {\n        process?.(partialResponse)\n      },\n    })\n\n    return sendResponse({ type: 'Success', data: response })\n  }", "  catch (error: any) {\n    const code = error.statusCode\n    global.console.log(error)\n    if (Reflect.has(ErrorCodeMessage, code))\n      return sendResponse({ type: 'Fail', message: ErrorCodeMessage[code] })\n    return sendResponse({ type: 'Fail', message: error.message ?? 'Please check the back-end console' })\n  }\n}\n\nasync function fetchUsage() {\n  const OPENAI_API_KEY = process.env.OPENAI_API_KEY\n  const OPENAI_API_BASE_URL = process.env.OPENAI_API_BASE_URL\n", "async function fetchUsage() {\n  const OPENAI_API_KEY = process.env.OPENAI_API_KEY\n  const OPENAI_API_BASE_URL = process.env.OPENAI_API_BASE_URL\n\n  if (!isNotEmptyString(OPENAI_API_KEY))\n    return Promise.resolve('-')\n\n  const API_BASE_URL = isNotEmptyString(OPENAI_API_BASE_URL)\n    ? OPENAI_API_BASE_URL\n    : 'https://api.openai.com'\n\n  const [startDate, endDate] = formatDate()\n\n  // \u6bcf\u6708\u4f7f\u7528\u91cf\n  const urlUsage = `${API_BASE_URL}/v1/dashboard/billing/usage?start_date=${startDate}&end_date=${endDate}`\n\n  const headers = {\n    'Authorization': `Bearer ${OPENAI_API_KEY}`,\n    'Content-Type': 'application/json',\n  }\n\n  const options = {} as SetProxyOptions\n\n  setupProxy(options)\n", "  try {\n    // \u83b7\u53d6\u5df2\u4f7f\u7528\u91cf\n    const useResponse = await options.fetch(urlUsage, { headers })\n    if (!useResponse.ok)\n      throw new Error('\u83b7\u53d6\u4f7f\u7528\u91cf\u5931\u8d25')\n    const usageData = await useResponse.json() as UsageResponse\n    const usage = Math.round(usageData.total_usage) / 100\n    return Promise.resolve(usage ? `$${usage}` : '-')\n  }\n  catch (error) {\n    global.console.log(error)\n    return Promise.resolve('-')\n  }\n}\n", "  catch (error) {\n    global.console.log(error)\n    return Promise.resolve('-')\n  }\n}\n\nfunction formatDate(): string[] {\n  const today = new Date()\n  const year = today.getFullYear()\n  const month = today.getMonth() + 1\n  const lastDay = new Date(year, month, 0)\n  const formattedFirstDay = `${year}-${month.toString().padStart(2, '0')}-01`\n  const formattedLastDay = `${year}-${month.toString().padStart(2, '0')}-${lastDay.getDate().toString().padStart(2, '0')}`\n  return [formattedFirstDay, formattedLastDay]\n}\n", "async function chatConfig() {\n  const usage = await fetchUsage()\n  const reverseProxy = process.env.API_REVERSE_PROXY ?? '-'\n  const httpsProxy = (process.env.HTTPS_PROXY || process.env.ALL_PROXY) ?? '-'\n  const socksProxy = (process.env.SOCKS_PROXY_HOST && process.env.SOCKS_PROXY_PORT)\n    ? (`${process.env.SOCKS_PROXY_HOST}:${process.env.SOCKS_PROXY_PORT}`)\n    : '-'\n  return sendResponse<ModelConfig>({\n    type: 'Success',\n    data: { apiModel, reverseProxy, timeoutMs, socksProxy, httpsProxy, usage },\n  })\n}\n", "function setupProxy(options: SetProxyOptions) {\n  if (isNotEmptyString(process.env.SOCKS_PROXY_HOST) && isNotEmptyString(process.env.SOCKS_PROXY_PORT)) {\n    const agent = new SocksProxyAgent({\n      hostname: process.env.SOCKS_PROXY_HOST,\n      port: process.env.SOCKS_PROXY_PORT,\n      userId: isNotEmptyString(process.env.SOCKS_PROXY_USERNAME) ? process.env.SOCKS_PROXY_USERNAME : undefined,\n      password: isNotEmptyString(process.env.SOCKS_PROXY_PASSWORD) ? process.env.SOCKS_PROXY_PASSWORD : undefined,\n    })\n    options.fetch = (url, options) => {\n      return fetch(url, { agent, ...options })\n    }\n  }", "  else if (isNotEmptyString(process.env.HTTPS_PROXY) || isNotEmptyString(process.env.ALL_PROXY)) {\n    const httpsProxy = process.env.HTTPS_PROXY || process.env.ALL_PROXY\n    if (httpsProxy) {\n      const agent = new HttpsProxyAgent(httpsProxy)\n      options.fetch = (url, options) => {\n        return fetch(url, { agent, ...options })\n      }\n    }\n  }\n  else {\n    options.fetch = (url, options) => {\n      return fetch(url, { ...options })\n    }\n  }\n}\n", "function currentModel(): ApiModel {\n  return apiModel\n}\n\nexport type { ChatContext, ChatMessage }\n\nexport { chatReplyProcess, chatConfig, currentModel }\n"]}
{"filename": "service/src/middleware/limiter.ts", "chunked_list": ["import { rateLimit } from 'express-rate-limit'\nimport { isNotEmptyString } from '../utils/is'\n\nconst MAX_REQUEST_PER_HOUR = process.env.MAX_REQUEST_PER_HOUR\n\nconst maxCount = (isNotEmptyString(MAX_REQUEST_PER_HOUR) && !isNaN(Number(MAX_REQUEST_PER_HOUR)))\n  ? parseInt(MAX_REQUEST_PER_HOUR)\n  : 0 // 0 means unlimited\n\nconst limiter = rateLimit({", "\nconst limiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // Maximum number of accesses within an hour\n  max: maxCount,\n  statusCode: 200, // 200 means success\uff0cbut the message is 'Too many request from this IP in 1 hour'\n  message: async (req, res) => {\n    res.send({ status: 'Fail', message: 'Too many request from this IP in 1 hour', data: null })\n  },\n})\n", "})\n\nexport { limiter }\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport * as VueRouter from \"vue-router\";\nimport routes from \"./configs/routes\";\nimport { createPinia } from \"pinia\";\nimport piniaPluginPersistedstate from \"pinia-plugin-persistedstate\";\nimport 'highlight.js/styles/github.css'\n\nconst app = createApp(App);\n", "const app = createApp(App);\n\n// \u8def\u7531\nconst router = VueRouter.createRouter({\n  history: VueRouter.createWebHashHistory(),\n  routes,\n});\napp.use(router);\n\n// \u72b6\u6001\u7ba1\u7406", "\n// \u72b6\u6001\u7ba1\u7406\nconst pinia = createPinia();\npinia.use(piniaPluginPersistedstate);\napp.use(pinia);\n\napp.mount(\"#app\");\n"]}
{"filename": "src/env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\ndeclare module '*.vue' {\n  import type { DefineComponent } from 'vue'\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}"]}
{"filename": "src/plugins/myAxios.ts", "chunked_list": ["import axios from \"axios\";\n\nlet serverAddress = import.meta.env.VITE_SERVER_ADDRESS\n\nconst myAxios = axios.create({\n  baseURL: `http://${serverAddress}/api`,\n});\n\nmyAxios.defaults.withCredentials = true;\n", "myAxios.defaults.withCredentials = true;\n\nmyAxios.interceptors.request.use(\n  function (config) {\n    return config;\n  },\n  function (error) {\n    return Promise.reject(error);\n  }\n);", "  }\n);\n\nmyAxios.interceptors.response.use(\n  function (response) {\n    return response.data;\n  },\n  function (error) {\n    return Promise.reject(error);\n  }", "    return Promise.reject(error);\n  }\n);\n\nexport default myAxios;\n"]}
{"filename": "src/components/gpt-terminal/hint.ts", "chunked_list": ["import { ref } from \"vue\";\nimport { getUsageStr } from \"../../core/commands/terminal/help/helpUtils\";\nimport { commandMap } from \"../../core/commandRegister\";\nimport _, { trim } from \"lodash\";\n\n/**\n * \u547d\u4ee4\u63d0\u793a\u529f\u80fd\n * @author yupi\n */\nconst useHint = () => {", " */\nconst useHint = () => {\n  const hint = ref(\"\");\n  const setHint = (inputText: string) => {\n    if (!inputText) {\n      hint.value = \"\";\n      return;\n    }\n    const args = trim(inputText).split(\" \");\n    // \u5927\u5c0f\u5199\u65e0\u5173\n    let func = args[0].toLowerCase();\n    // \u524d\u7f00\u5339\u914d\n    const likeKey = Object.keys(commandMap).filter((key) =>\n      key.startsWith(func)\n    )[0];\n    let command = commandMap[likeKey];", "    if (!command) {\n      hint.value = \"\";\n      return;\n    }\n    // \u5b50\u547d\u4ee4\u63d0\u793a\n    if (\n      command.subCommands &&\n      Object.keys(command.subCommands).length > 0 &&\n      args.length > 1\n    ) {\n      hint.value = getUsageStr(command.subCommands[args[1]], command);\n    } else {\n      hint.value = getUsageStr(command);\n    }\n  };\n\n  /**\n   * \u8f93\u5165\u63d0\u793a\u9632\u6296\n   */\n  const debounceSetHint = _.debounce(function (inputText: string) {\n    setHint(inputText);\n  }, 100);\n\n  return {\n    hint,\n    setHint,\n    debounceSetHint,\n  };\n};\n\nexport default useHint;\n"]}
{"filename": "src/components/gpt-terminal/type.d.ts", "chunked_list": ["declare namespace GptTerminal {\n  type OutputStatusType =\n    | \"info\"\n    | \"success\"\n    | \"warning\"\n    | \"error\"\n    | \"system\"\n    | \"loading\";\n\n  // \u8f93\u51fa\u7236\u7c7b\u578b\n  interface OutputType {\n    type: \"command\" | \"text\" | \"component\";\n    text?: string;\n    resultList?: OutputType[];\n    component?: any;\n    status?: OutputStatusType;\n    props?: any;\n    collapsible?: boolean;\n  }\n\n  /**\n   * \u547d\u4ee4\u7c7b\u578b\u8f93\u51fa\n   */", "  interface OutputType {\n    type: \"command\" | \"text\" | \"component\";\n    text?: string;\n    resultList?: OutputType[];\n    component?: any;\n    status?: OutputStatusType;\n    props?: any;\n    collapsible?: boolean;\n  }\n\n  /**\n   * \u547d\u4ee4\u7c7b\u578b\u8f93\u51fa\n   */", "  interface CommandOutputType extends OutputType {\n    type: \"command\";\n    text: string;\n    resultList: OutputType[];\n  }\n\n  /**\n   * \u6587\u672c\u7c7b\u578b\u8f93\u51fa\n   */\n  interface TextOutputType extends OutputType {\n    type: \"text\";\n    text: string;\n  }\n\n  /**\n   * \u7ec4\u4ef6\u7c7b\u578b\u8f93\u51fa\n   */", "  interface TextOutputType extends OutputType {\n    type: \"text\";\n    text: string;\n  }\n\n  /**\n   * \u7ec4\u4ef6\u7c7b\u578b\u8f93\u51fa\n   */\n  interface ComponentOutputType extends OutputType {\n    type: \"component\";\n    component: any;\n    props?: any;\n  }\n\n  /**\n   * \u547d\u4ee4\u8f93\u5165\u7c7b\u578b\n   */", "  interface ComponentOutputType extends OutputType {\n    type: \"component\";\n    component: any;\n    props?: any;\n  }\n\n  /**\n   * \u547d\u4ee4\u8f93\u5165\u7c7b\u578b\n   */\n  interface CommandInputType {\n    text: string;\n    placeholder?: string;\n  }\n\n  /**\n   * GPT \u5bf9\u8bdd\u8bb0\u5f55\u7c7b\u578b\n   */", "  interface CommandInputType {\n    text: string;\n    placeholder?: string;\n  }\n\n  /**\n   * GPT \u5bf9\u8bdd\u8bb0\u5f55\u7c7b\u578b\n   */\n  interface MessageElement {\n    role: string;\n    content: string;\n  }\n  ", "  interface MessageElement {\n    role: string;\n    content: string;\n  }\n  \n  interface MessageType {\n    roleKeyword: string | \"default\";\n    messageElements: MessageElement[];\n  }\n\n  /**\n   * \u7528\u6237\u5c5e\u6027\n   */", "  interface UserType {\n    id: number;\n    username: string;\n    email?: string;\n    creatTime?: date;\n    updateTime?: date;\n  }\n\n  /**\n   * \u7ec8\u7aef\u7c7b\u578b\uff08\u5b9a\u4e49\u4e00\u7ec4\u8bbf\u95ee\u53ca\u64cd\u4f5c\u7ec8\u7aef\u7684\u65b9\u6cd5\uff09\n   */", "  interface TerminalType {\n    // \u662f\u5426\u8fd0\u884c\n    isRunning: boolean;\n    // \u6e05\u5c4f\n    clear: () => void;\n    // \u7acb\u5373\u8f93\u51fa\n    writeOutput: (output: OutputType) => void;\n    // \u7acb\u5373\u8f93\u51fa\u6587\u672c\n    writeTextOutput: (text: string, status?: OutputStatusType) => void;\n    // \u5199\u547d\u4ee4\u6587\u672c\u7ed3\u679c\n    writeTextResult: (text: string, status?: OutputStatusType) => void;\n    // \u5199\u547d\u4ee4\u9519\u8bef\u6587\u672c\u7ed3\u679c\n    writeTextErrorResult: (text: string) => void;\n    // \u5199\u547d\u4ee4\u7b49\u5f85\u72b6\u6001 GPT\n    writeTextLoadingResult: (text: string) => void;\n    // \u5199\u547d\u4ee4\u6210\u529f\u6587\u672c\u7ed3\u679c\n    writeTextSuccessResult: (text: string) => void;\n    // \u5199\u547d\u4ee4\u7ed3\u679c\n    writeResult: (output: OutputType) => void;\n    // \u79fb\u9664 outputList \u6700\u540e\u4e00\u4e2a\u5143\u7d20\n    removeLastOutput: () => void;\n    // \u8f93\u5165\u6846\u805a\u7126\n    focusInput: () => void;\n    // \u83b7\u53d6\u8f93\u5165\u6846\u662f\u5426\u805a\u7126\n    isInputFocused: () => boolean;\n    // \u8bbe\u7f6e\u8f93\u5165\u6846\u7684\u503c\n    setTabCompletion: () => void;\n    // \u63d0\u4ea4\u547d\u4ee4\n    doSubmitCommand: () => void;\n    // \u67e5\u770b\u4e0b\u4e00\u6761\u547d\u4ee4\n    showNextCommand: () => void;\n    // \u67e5\u770b\u4e0a\u4e00\u6761\u547d\u4ee4\n    showPrevCommand: () => void;\n    // \u67e5\u770b\u5386\u53f2\u547d\u4ee4\n    listCommandHistory: () => CommandOutputType[];\n    // \u6298\u53e0 / \u5c55\u5f00\u6240\u6709\u5757\n    toggleAllCollapse: () => void;\n    // \u8bbe\u7f6e\u547d\u4ee4\u662f\u5426\u53ef\u6298\u53e0\n    setCommandCollapsible: (collapsible: boolean) => void;\n    // GPT \u5386\u53f2\u5bf9\u8bdd\u8bb0\u5f55\n    listGptHistory: () => MessageType[];\n    // \u7ec8\u6b62\u5f53\u524d\u547d\u4ee4\u8fd0\u884c\n    terminateCurrentCommand: () => void;\n  }\n}\n"]}
{"filename": "src/components/gpt-terminal/shortcuts.ts", "chunked_list": ["/**\n * \u5feb\u6377\u952e\u7cfb\u7edf\n * @author yupi\n */\nimport TerminalType = GptTerminal.TerminalType;\n\n/**\n * \u6ce8\u518c\u5feb\u6377\u952e\n * @param terminal\n */", " * @param terminal\n */\nexport const registerShortcuts = (terminal: TerminalType) => {\n  document.onkeydown = (e) => {\n    // console.log(e);\n    let key = e.key;\n    // \u81ea\u52a8\u805a\u7126\u8f93\u5165\u6846\n    if (key >= \"a\" && key <= \"z\" && !e.metaKey && !e.shiftKey && !e.ctrlKey) {\n      terminal.focusInput();\n      return;\n    }\n    // \u5339\u914d\u5feb\u6377\u952e\n    let code = e.code;", "    for (const shortcut of shortcutList) {\n      if (\n        code === shortcut.code &&\n        e.ctrlKey == !!shortcut.ctrlKey &&\n        e.metaKey == !!shortcut.metaKey &&\n        e.shiftKey == !!shortcut.shiftKey\n      ) {\n        shortcut.action(e, terminal);\n      }\n    }\n  };\n};\n\n/**\n * \u5feb\u6377\u952e\u7c7b\u578b\n */", "interface ShortcutType {\n  code: string; // \u6309\u952e\u7801\n  desc?: string; // \u529f\u80fd\u63cf\u8ff0\n  keyDesc?: string; // \u6309\u952e\u63cf\u8ff0\n  ctrlKey?: boolean;\n  metaKey?: boolean;\n  shiftKey?: boolean;\n  action: (e: Event, terminal: TerminalType) => void;\n}\n\n/**\n * \u5feb\u6377\u952e\u5217\u8868\n */\nexport const shortcutList: ShortcutType[] = [\n  {\n    desc: \"\u6e05\u5c4f\",\n    code: \"KeyL\",\n    keyDesc: \"Ctrl + L\",\n    ctrlKey: true,\n    action(e, terminal) {\n      e.preventDefault();\n      terminal.clear();\n    },\n  },\n  {\n    desc: \"\u6298\u53e0\",\n    code: \"KeyO\",\n    keyDesc: \"Ctrl + O\",\n    ctrlKey: true,\n    action(e, terminal) {\n      e.preventDefault();\n      terminal.toggleAllCollapse();\n    },\n  },\n  // {\n  //   desc: \"\u7c98\u8d34\",\n  //   code: \"KeyV\",\n  //   keyDesc: \"Ctrl + V\",\n  //   metaKey: true,\n  //   action(e, terminal) {\n  //     terminal.focusInput();\n  //   },\n  // },\n  {\n    desc: \"\u7ec8\u6b62\u547d\u4ee4\",\n    code: \"KeyC\",\n    keyDesc: \"Ctrl + C\",\n    ctrlKey: true,\n    action(e, terminal) {\n      terminal.terminateCurrentCommand();\n    }\n  },\n  {\n    code: \"Tab\",\n    action(e, terminal) {\n      e.preventDefault();", "      if (terminal.isInputFocused()) {\n        terminal.setTabCompletion();\n      } else {\n        terminal.focusInput();\n      }\n    },\n  },\n  {\n    code: \"Backspace\",\n    action(e, terminal) {\n      terminal.focusInput();\n    },\n  },\n  {\n    code: \"Enter\",\n    action(e, terminal) {\n      terminal.focusInput();\n    },\n  },\n  {\n    desc: \"\u67e5\u770b\u4e0a\u4e00\u6761\u547d\u4ee4\",\n    code: \"ArrowUp\",\n    keyDesc: \"\u2191\",\n    action(e, terminal) {\n      e.preventDefault();", "      if (!terminal.isRunning) {\n        terminal.showPrevCommand();\n      }\n    },\n  },\n  {\n    desc: \"\u67e5\u770b\u4e0b\u4e00\u6761\u547d\u4ee4\",\n    code: \"ArrowDown\",\n    keyDesc: \"\u2193\",\n    action(e, terminal) {\n      e.preventDefault();", "      if (!terminal.isRunning) {\n        terminal.showNextCommand();\n      }\n    },\n  },\n];\n"]}
{"filename": "src/components/gpt-terminal/history.ts", "chunked_list": ["import { Ref, ref } from \"vue\";\nimport CommandOutputType = GptTerminal.CommandOutputType;\nimport CommandInputType = GptTerminal.CommandInputType;\n\n/**\n * \u67e5\u770b\u5386\u53f2\u529f\u80fd\n * @param commandList\n * @param inputCommand\n */\nconst useHistory = (", " */\nconst useHistory = (\n  commandList: CommandOutputType[],\n  inputCommand: Ref<CommandInputType>\n) => {\n  /**\n   * \u5f53\u524d\u67e5\u770b\u7684\u547d\u4ee4\u4f4d\u7f6e\n   */\n  const commandHistoryPos = ref(commandList.length);\n", "  const commandHistoryPos = ref(commandList.length);\n\n  const listCommandHistory = () => {\n    return commandList;\n  };\n\n  const showNextCommand = () => {\n    console.log(commandHistoryPos.value, commandList, inputCommand);\n    if (commandHistoryPos.value < commandList.length - 1) {\n      commandHistoryPos.value++;\n      inputCommand.value.text = commandList[commandHistoryPos.value].text;", "    if (commandHistoryPos.value < commandList.length - 1) {\n      commandHistoryPos.value++;\n      inputCommand.value.text = commandList[commandHistoryPos.value].text;\n    } else if (commandHistoryPos.value === commandList.length - 1) {\n      commandHistoryPos.value++;\n      inputCommand.value.text = \"\";\n    }\n  };\n\n  const showPrevCommand = () => {\n    console.log(commandHistoryPos.value, commandList, inputCommand);", "    if (commandHistoryPos.value >= 1) {\n      commandHistoryPos.value--;\n      inputCommand.value.text = commandList[commandHistoryPos.value].text;\n    }\n  };\n\n  return {\n    commandHistoryPos,\n    listCommandHistory,\n    showNextCommand,\n    showPrevCommand,\n  };\n};\n\nexport default useHistory;\n"]}
{"filename": "src/configs/routes.ts", "chunked_list": ["import { RouteRecordRaw } from \"vue-router\";\nimport IndexPage from \"../pages/IndexPage.vue\";\n\nconst route: RouteRecordRaw[] = [{ path: \"/\", component: IndexPage }];\n\nexport default route;\n"]}
{"filename": "src/utils/smartText.ts", "chunked_list": ["/**\n * \u5339\u914d\u7f51\u5740\u6b63\u5219\n */\nconst URL_REG =\n  /(((https?:(?:\\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+(?::\\d+)?|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)/;\n\n/**\n * \u8bc6\u522b\u6587\u672c\u4e2d\u7684\u8d85\u94fe\u63a5\n * @param text\n */", " * @param text\n */\nconst smartText = (text?: string) => {\n  if (!text) {\n    return text;\n  }\n  const reg = new RegExp(URL_REG, \"gi\");\n  return text.replaceAll(reg, \"<a href='$1' target='_blank'>$1</a>\");\n};\n\nexport default smartText;\n"]}
{"filename": "src/utils/request/axios.ts", "chunked_list": ["import axios, { type AxiosResponse } from 'axios'\n// import { useAuthStore } from '@/store'\n\nconst service = axios.create({\n  baseURL: \"/api\",\n})\n\nservice.interceptors.request.use(\n  (config) => {\n    // const token = useAuthStore().token\n    // if (token)\n    //   config.headers.Authorization = `Bearer ${token}`\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error.response)\n  },\n)\n\nservice.interceptors.response.use(\n  (response: AxiosResponse): AxiosResponse => {", "    // if (token)\n    //   config.headers.Authorization = `Bearer ${token}`\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error.response)\n  },\n)\n\nservice.interceptors.response.use(\n  (response: AxiosResponse): AxiosResponse => {", "    if (response.status === 200)\n      return response\n\n    throw new Error(response.status.toString())\n  },\n  (error) => {\n    return Promise.reject(error)\n  },\n)\n\nexport default service\n"]}
{"filename": "src/utils/request/index.ts", "chunked_list": ["import type { AxiosProgressEvent, AxiosResponse, GenericAbortSignal } from 'axios'\nimport request from './axios'\n\nexport interface HttpOption {\n  url: string\n  data?: any\n  method?: string\n  headers?: any\n  onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void\n  signal?: GenericAbortSignal\n  beforeRequest?: () => void\n  afterRequest?: () => void\n}\n", "export interface Response<T = any> {\n  data: T\n  message: string | null\n  status: string\n}\n\nfunction http<T = any>(\n  { url, data, method, headers, onDownloadProgress, signal, beforeRequest, afterRequest }: HttpOption,\n) {\n  const successHandler = (res: AxiosResponse<Response<T>>) => {\n", "    if (res.data.status === 'Success' || typeof res.data === 'string')\n      return res.data\n\n    if (res.data.status === 'Unauthorized') {\n      window.location.reload()\n    }\n\n    return Promise.reject(res.data)\n  }\n\n  const failHandler = (error: Response<Error>) => {\n    afterRequest?.()\n    throw new Error(error?.message || 'Error')\n  }\n\n  beforeRequest?.()\n\n  method = method || 'GET'\n\n  const params = Object.assign(typeof data === 'function' ? data() : data ?? {}, {})\n\n  return method === 'GET'\n    ? request.get(url, { params, signal, onDownloadProgress }).then(successHandler, failHandler)\n    : request.post(url, params, { headers, signal, onDownloadProgress }).then(successHandler, failHandler)\n}\n", "export function get<T = any>(\n  { url, data, method = 'GET', onDownloadProgress, signal, beforeRequest, afterRequest }: HttpOption,\n): Promise<Response<T>> {\n  return http<T>({\n    url,\n    method,\n    data,\n    onDownloadProgress,\n    signal,\n    beforeRequest,\n    afterRequest,\n  })\n}\n", "export function post<T = any>(\n  { url, data, method = 'POST', headers, onDownloadProgress, signal, beforeRequest, afterRequest }: HttpOption,\n): Promise<Response<T>> {\n  return http<T>({\n    url,\n    method,\n    data,\n    headers,\n    onDownloadProgress,\n    signal,\n    beforeRequest,\n    afterRequest,\n  })\n}\n\nexport default post\n"]}
{"filename": "src/core/commandExecutor.ts", "chunked_list": ["import getopts, { ParsedOptions } from \"getopts\";\nimport { commandMap } from \"./commandRegister\";\nimport { CommandOptionType, CommandType } from \"./command\";\nimport TerminalType = GptTerminal.TerminalType;\nimport helpCommand from \"./commands/terminal/help/helpCommand\";\n\nexport const doCommandExecute = async (\n  text: string,\n  terminal: TerminalType,\n  parentCommand?: CommandType", "  terminal: TerminalType,\n  parentCommand?: CommandType\n) => {\n  text = text.trim();\n  if (!text) {\n    return;\n  }\n  const command: CommandType | any = getCommand(terminal, text, parentCommand);\n  console.log(\"command\", command);\n  if (command == \"403\") {\n    terminal.writeTextErrorResult(\"\u8bf7\u767b\u5f55\u540e\u518d\u4f7f\u7528\u6b64\u547d\u4ee4\");\n    return;\n  }", "  if (command == \"403\") {\n    terminal.writeTextErrorResult(\"\u8bf7\u767b\u5f55\u540e\u518d\u4f7f\u7528\u6b64\u547d\u4ee4\");\n    return;\n  }\n  if (!command) {\n    terminal.writeTextErrorResult(\"\u627e\u4e0d\u5230\u547d\u4ee4\");\n    return;\n  }\n  const parsedOptions = doParse(text, command.options);\n  const { _ } = parsedOptions;\n  if (\n    _.length > 0 &&\n    command.subCommands &&\n    Object.keys(command.subCommands).length > 0\n  ) {\n    const subText = text.substring(text.indexOf(\" \") + 1);\n    await doCommandExecute(subText, terminal, command);\n    return;\n  }\n  await doAction(command, parsedOptions, terminal, parentCommand);\n};\n\nconst getCommand = (\n  terminal: TerminalType,\n  text: string,\n  parentCommand?: CommandType\n): CommandType | string => {\n  let func = text.split(\" \", 1)[0];\n  func = func.toLowerCase();\n  let commands = commandMap;", "  if (\n    _.length > 0 &&\n    command.subCommands &&\n    Object.keys(command.subCommands).length > 0\n  ) {\n    const subText = text.substring(text.indexOf(\" \") + 1);\n    await doCommandExecute(subText, terminal, command);\n    return;\n  }\n  await doAction(command, parsedOptions, terminal, parentCommand);\n};\n\nconst getCommand = (\n  terminal: TerminalType,\n  text: string,\n  parentCommand?: CommandType\n): CommandType | string => {\n  let func = text.split(\" \", 1)[0];\n  func = func.toLowerCase();\n  let commands = commandMap;", "  if (\n    parentCommand &&\n    parentCommand.subCommands &&\n    Object.keys(parentCommand.subCommands).length > 0\n  ) {\n    commands = parentCommand.subCommands;\n  }\n  const command = commands[func];\n  console.log(\"getCommand = \", command);\n  return command;\n};\n\nconst doParse = (\n  text: string,\n  commandOptions: CommandOptionType[]\n): getopts.ParsedOptions => {\n  const args: string[] = text.split(\" \").slice(1);\n  const options: getopts.Options = {\n    alias: {},\n    default: {},\n    string: [],\n    boolean: [],\n  };\n  console.log(\"commandOptions\", commandOptions);\n  commandOptions.forEach((commandOption) => {\n    const { alias, key, type, defaultValue } = commandOption;\n    console.log(\"\u89e3\u6790...\");", "    if (alias && options.alias) {\n      console.log(\"alias boolean:\", Boolean(options.alias));\n      console.log(\"alias\u662f\uff1a\", options.alias);\n      options.alias[key] = alias;\n    }\n    options[type]?.push(key);\n    if (defaultValue && options.default) {\n      options.default[key] = defaultValue;\n    }\n  });\n  const parsedOptions = getopts(args, options);\n  console.log(\"parsedOptions = \", parsedOptions);\n  return parsedOptions;\n};\n\nconst doAction = async (\n  command: CommandType,\n  options: ParsedOptions,\n  terminal: TerminalType,\n  parentCommand?: CommandType\n) => {\n  const { help, h } = options;", "  if (command.collapsible || help) {\n    terminal.setCommandCollapsible(true);\n  }\n  if (help || h) {\n    const newOptions = { ...options, _: [command.func] };\n    helpCommand.action(newOptions, terminal, parentCommand);\n    return;\n  }\n  await command.action(options, terminal);\n};\n"]}
{"filename": "src/core/command.d.ts", "chunked_list": ["import { ParsedOptions } from \"getopts\";\nimport TerminalType = GptTerminal.TerminalType;\n\n// \u547d\u4ee4\u7c7b\u578b\ninterface CommandType {\n  func: string; // \u552f\u4e00\u547d\u4ee4\u82f1\u6587\n  name: string; // \u547d\u4ee4\u540d\u79f0\n  desc?: string; // \u547d\u4ee4\u63cf\u8ff0\n  alias?: string[]; // \u547d\u4ee4\u522b\u540d\n  params?: CommandParamsType[]; // \u53c2\u6570\u914d\u7f6e\n  options: CommandOptionType[]; // \u9009\u9879\u914d\u7f6e\n  subCommands?: Record<string, CommandType>; // \u5b50\u547d\u4ee4\n  // \u6267\u884c\u529f\u80fd\n  action: (\n    options: ParsedOptions,\n    terminal: TerminalType,\n    parentCommand?: CommandType\n  ) => void;\n  // \u6267\u884c\u5b50\u529f\u80fd\n  subAction?: (\n    options?: ParsedOptions,\n    terminal: TerminalType,\n    params?: Record<string, T>,\n    parentCommand?: CommandType,\n  ) => void;\n  // \u7ed3\u679c\u662f\u5426\u5141\u8bb8\u6298\u53e0\n  collapsible?: boolean;\n  // \u662f\u5426\u9700\u8981\u7528\u6237\u767b\u5f55\u4e0b\u624d\u53ef\u8bbf\u95ee\n  requireAuth?: boolean | false;\n}\n\n// \u547d\u4ee4\u53c2\u6570\u7c7b\u578b", "interface CommandParamsType {\n  key: string; // \u53c2\u6570\u540d\n  desc?: string; // \u53c2\u6570\u63cf\u8ff0\n  defaultValue?: string | boolean; // \u9ed8\u8ba4\u503c\n  required?: boolean; // \u662f\u5426\u5fc5\u586b\n}\n\n// \u547d\u4ee4\u9009\u9879\u7c7b\u578b\ninterface CommandOptionType {\n  key: string; // \u53c2\u6570\u540d\n  alias?: string[]; // \u522b\u540d\n  desc?: string; // \u63cf\u8ff0\n  type: \"string\" | \"boolean\";\n  defaultValue?: string | boolean; // \u9ed8\u8ba4\u503c\n  required?: boolean; // \u662f\u5426\u5fc5\u586b\n}\n", "interface CommandOptionType {\n  key: string; // \u53c2\u6570\u540d\n  alias?: string[]; // \u522b\u540d\n  desc?: string; // \u63cf\u8ff0\n  type: \"string\" | \"boolean\";\n  defaultValue?: string | boolean; // \u9ed8\u8ba4\u503c\n  required?: boolean; // \u662f\u5426\u5fc5\u586b\n}\n"]}
{"filename": "src/core/commandRegister.ts", "chunked_list": ["import { CommandType } from \"./command\";\nimport clearCommand from \"./commands/terminal/clearCommand\";\nimport historyCommand from \"./commands/terminal/historyCommand\";\nimport helpCommand from \"./commands/terminal/help/helpCommand\";\nimport shortcutCommand from \"./commands/terminal/shortcut/shortcutCommand\";\nimport gptCommands from \"./commands/gpt/gptCommands\";\n\n/**\n * \u547d\u4ee4\u5217\u8868\uff08\u6570\u7ec4\u5143\u7d20\u987a\u5e8f\u4f1a\u5f71\u54cd help \u547d\u4ee4\u7684\u5c55\u793a\u987a\u5e8f\uff09\n */", " * \u547d\u4ee4\u5217\u8868\uff08\u6570\u7ec4\u5143\u7d20\u987a\u5e8f\u4f1a\u5f71\u54cd help \u547d\u4ee4\u7684\u5c55\u793a\u987a\u5e8f\uff09\n */\nconst commandList: CommandType[] = [\n  ...gptCommands,\n  shortcutCommand,\n  clearCommand,\n  historyCommand,\n  helpCommand,\n];\n", "];\n\n/**\n * \u547d\u4ee4\u5b57\u5178\n */\nconst commandMap: Record<string, CommandType> = {};\n\ncommandList.forEach((command) => {\n  commandMap[command.func] = command;\n  command.alias?.forEach((name) => {", "  commandMap[command.func] = command;\n  command.alias?.forEach((name) => {\n    commandMap[name] = command;\n  });\n});\n\nexport { commandList, commandMap };\n"]}
{"filename": "src/core/commands/terminal/clearCommand.ts", "chunked_list": ["import { CommandType } from \"../../command\";\n\nconst clearCommand: CommandType = {\n  func: \"clear\",\n  name: \"\u6e05\u5c4f\",\n  alias: [\"cl\"],\n  options: [],\n  action(options, termial): void {\n    setTimeout(() => {\n      termial.clear();", "    setTimeout(() => {\n      termial.clear();\n    }, 100);\n  },\n};\n\nexport default clearCommand;\n"]}
{"filename": "src/core/commands/terminal/historyCommand.ts", "chunked_list": ["import { CommandType } from \"../../command\";\n\nconst historyCommand: CommandType = {\n  func: \"history\",\n  name: \"\u67e5\u770b\u6267\u884c\u5386\u53f2\",\n  alias: [\"h\"],\n  options: [],\n  collapsible: true,\n  action(options, terminal): void {\n    const commandOutputTypes = terminal.listCommandHistory();", "  action(options, terminal): void {\n    const commandOutputTypes = terminal.listCommandHistory();\n    commandOutputTypes.forEach((command, index) => {\n      terminal.writeTextResult(`${index + 1} ${command.text}`);\n    });\n  },\n};\n\nexport default historyCommand;\n", "export default historyCommand;\n"]}
{"filename": "src/core/commands/terminal/help/helpUtils.ts", "chunked_list": ["import { CommandOptionType, CommandType } from \"../../../command\";\n\nexport const getUsageStr = (\n  command: CommandType,\n  parentCommand?: CommandType\n) => {\n  if (!command) {\n    return \"\";\n  }\n  let str = \"\";\n  if (parentCommand) {\n    str = parentCommand.func + \" \";\n  }\n  str += command.func;", "  if (parentCommand) {\n    str = parentCommand.func + \" \";\n  }\n  str += command.func;\n  if (command.params && command.params.length > 0) {\n    const paramsStrList: string[] = command.params.map((param) => {\n      let word = param.key;\n      if (param.desc) {\n        word = param.desc;\n      }\n      if (param.required) {\n        return `<${word}>`;\n      } else {\n        return `[${word}]`;\n      }\n    });\n    str += \" \" + paramsStrList.join(\" \");\n  }", "      if (param.required) {\n        return `<${word}>`;\n      } else {\n        return `[${word}]`;\n      }\n    });\n    str += \" \" + paramsStrList.join(\" \");\n  }\n  if (command.options?.length > 0) {\n    const optionStrList: string[] = command.options.map((option) => {\n      const optionKey = getOptionKey(option);", "  if (command.options?.length > 0) {\n    const optionStrList: string[] = command.options.map((option) => {\n      const optionKey = getOptionKey(option);\n      if (option.type === \"boolean\") {\n        let word = optionKey;\n        if (option.desc) {\n          word += ` ${option.desc}`;\n        }\n        if (option.required) {\n          return `<${word}>`;\n        } else {\n          return `[${word}]`;\n        }\n      } else {\n        let word = option.key;", "        if (option.required) {\n          return `<${word}>`;\n        } else {\n          return `[${word}]`;\n        }\n      } else {\n        let word = option.key;\n        if (option.desc) {\n          word = option.desc;\n        }\n        if (option.required) {\n          return `<${optionKey} ${word}>`;\n        } else {\n          return `[${optionKey} ${word}]`;\n        }\n      }\n    });\n    str += \" \" + optionStrList.join(\" \");\n  }\n  return str;\n};\n\n/**\n * \u83b7\u53d6\u9009\u9879\u5173\u952e\u8bcd\n * @param option\n */\nexport const getOptionKey = (option: CommandOptionType) => {\n  // \u4f18\u5148\u7528\u7b80\u5199", "        if (option.required) {\n          return `<${optionKey} ${word}>`;\n        } else {\n          return `[${optionKey} ${word}]`;\n        }\n      }\n    });\n    str += \" \" + optionStrList.join(\" \");\n  }\n  return str;\n};\n\n/**\n * \u83b7\u53d6\u9009\u9879\u5173\u952e\u8bcd\n * @param option\n */\nexport const getOptionKey = (option: CommandOptionType) => {\n  // \u4f18\u5148\u7528\u7b80\u5199", "  if (option.alias && option.alias.length > 0) {\n    return \"-\" + option.alias[0];\n  }\n  return \"--\" + option.key;\n};\n\n/**\n * \u83b7\u53d6\u9009\u9879\u5173\u952e\u8bcd\u5217\u8868\n * @param option\n */\nexport const getOptionKeyList = (option: CommandOptionType) => {\n  const list = [];\n  // \u4f18\u5148\u7528\u7b80\u5199", "  if (option.alias && option.alias.length > 0) {\n    list.push(\"-\" + option.alias[0]);\n  }\n  list.push(\"--\" + option.key);\n  return list;\n};\n"]}
{"filename": "src/core/commands/terminal/help/helpCommand.ts", "chunked_list": ["import { CommandType } from \"../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport { commandMap } from \"../../../commandRegister\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n\n/**\n * \u5e2e\u52a9\u547d\u4ee4\n * @author yupi\n */\nconst helpCommand: CommandType = {", " */\nconst helpCommand: CommandType = {\n  func: \"help\",\n  name: \"\u67e5\u770b\u5e2e\u52a9\",\n  alias: [\"man\"],\n  params: [\n    {\n      key: \"commandName\",\n      desc: \"\u547d\u4ee4\u82f1\u6587\u540d\u79f0\",\n    },", "      desc: \"\u547d\u4ee4\u82f1\u6587\u540d\u79f0\",\n    },\n  ],\n  options: [],\n  collapsible: true,\n  action(options, terminal, parentCommand): void {\n    const { _ } = options;\n    if (_.length < 1) {\n      const output: ComponentOutputType = {\n        type: \"component\",\n        component: defineAsyncComponent(() => import(\"./HelpBox.vue\")),\n      };\n      terminal.writeResult(output);\n      return;\n    }\n    const commandName = _[0];\n    let commands = commandMap;", "    if (\n      parentCommand &&\n      parentCommand.subCommands &&\n      Object.keys(parentCommand.subCommands).length > 0\n    ) {\n      commands = parentCommand.subCommands;\n    }\n    const command = commands[commandName];\n    if (!command) {\n      terminal.writeTextErrorResult(\"\u627e\u4e0d\u5230\u6307\u5b9a\u547d\u4ee4\");\n      return;\n    }\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./CommandHelpBox.vue\")),\n      props: {\n        command,\n        parentCommand,\n      },\n    };\n    terminal.writeResult(output);\n  },\n};\n\nexport default helpCommand;\n", "    if (!command) {\n      terminal.writeTextErrorResult(\"\u627e\u4e0d\u5230\u6307\u5b9a\u547d\u4ee4\");\n      return;\n    }\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./CommandHelpBox.vue\")),\n      props: {\n        command,\n        parentCommand,\n      },\n    };\n    terminal.writeResult(output);\n  },\n};\n\nexport default helpCommand;\n"]}
{"filename": "src/core/commands/terminal/shortcut/shortcutCommand.ts", "chunked_list": ["import { CommandType } from \"../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n\n/**\n * \u5feb\u6377\u952e\u547d\u4ee4\n * @author yupi\n */\nconst shortcutCommand: CommandType = {\n  func: \"shortcut\",", "const shortcutCommand: CommandType = {\n  func: \"shortcut\",\n  name: \"\u5feb\u6377\u952e\",\n  desc: \"\u67e5\u770b\u5feb\u6377\u952e\",\n  alias: [],\n  params: [],\n  options: [],\n  collapsible: true,\n  action(options, terminal): void {\n    const output: ComponentOutputType = {", "  action(options, terminal): void {\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./ShortcutBox.vue\")),\n    };\n    terminal.writeResult(output);\n  },\n};\n\nexport default shortcutCommand;", "\nexport default shortcutCommand;\n"]}
{"filename": "src/core/commands/gpt/configStore.ts", "chunked_list": ["import { defineStore } from \"pinia\";\n\ninterface ConfigType {\n  model: string;\n}\n\nexport const useConfigStore = defineStore(\"config\", {\n  state: () => ({\n    config: {} as ConfigType,\n  }),\n  getters: {},\n  persist: {\n    key: \"gpt-config\",\n    storage: window.localStorage,\n  },\n  actions: {\n    changeModel(model: string) {\n      this.config.model = model;\n    },\n  },\n});\n"]}
{"filename": "src/core/commands/gpt/type.d.ts", "chunked_list": ["declare namespace Gpt {\n  interface MessageElement {\n    role: string;\n    content: string;\n  }\n  \n  interface MessageType {\n    roleKeyword: string | \"default\";\n    roleName: string;\n    roleDesc: string;\n    systemMessage: string;\n    parentMessageId: string;\n    messageElements: MessageElement[];\n  }\n}"]}
{"filename": "src/core/commands/gpt/gptCommands.ts", "chunked_list": ["import { CommandType } from \"../../command\";\nimport chatCommand from \"./subCommands/chat/chatCommand\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\nimport roleCommand from \"./subCommands/role/roleCommand\";\nimport historyCommand from \"./subCommands/history/historyCommand\";\nimport diyCommand from \"./subCommands/diy/diyCommand\";\nimport imageCommand from \"./subCommands/image/imageCommand\";\nimport modelCommand from \"./subCommands/model/modelCommand\";\n", "import modelCommand from \"./subCommands/model/modelCommand\";\n\n/**\n * gpt\u547d\u4ee4\n */\nconst gptCommand: CommandType = {\n  func: \"gpt\",\n  name: \"gpt \u673a\u5668\u4eba\",\n  alias: [],\n  subCommands: {", "  alias: [],\n  subCommands: {\n    chat: chatCommand,\n    role: roleCommand,\n    history: historyCommand,\n    diy: diyCommand,\n    // image: imageCommand,\n    // model: modelCommand\n  },\n  options: [],", "  },\n  options: [],\n  async action(options, terminal) {\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(\n        () => import(\"./subCommands/chat/ChatBox.vue\")\n      ),\n      props: {\n        message: \"\u60a8\u597d\uff0c\u6211\u662f \u300cGPT Terminal\u300d \u673a\u5668\u4eba\uff0c\u8bf7\u95ee\u6211\u80fd\u4e3a\u60a8\u505a\u4e9b\u4ec0\u4e48\u5462\uff1f\",", "      props: {\n        message: \"\u60a8\u597d\uff0c\u6211\u662f \u300cGPT Terminal\u300d \u673a\u5668\u4eba\uff0c\u8bf7\u95ee\u6211\u80fd\u4e3a\u60a8\u505a\u4e9b\u4ec0\u4e48\u5462\uff1f\",\n      },\n    };\n    terminal.writeResult(output);\n  },\n};\n\nexport default [gptCommand];\n", "export default [gptCommand];\n"]}
{"filename": "src/core/commands/gpt/messagesStore.ts", "chunked_list": ["import { defineStore } from \"pinia\";\n\nexport const useMessagesStore = defineStore(\"messages\", {\n  state: () => ({\n    messages: [\n      {\n        roleKeyword: \"default\",\n        roleName: \"ChatGPT\",\n        roleDesc: \"\u9ed8\u8ba4\u89d2\u8272\",\n        systemMessage: \"\",", "        roleDesc: \"\u9ed8\u8ba4\u89d2\u8272\",\n        systemMessage: \"\",\n        parentMessageId: \"\",\n        messageElements: [],\n      },\n    ] as Gpt.MessageType[],\n  }),\n  getters: {},\n  persist: {\n    key: \"gpt-messages\",", "  persist: {\n    key: \"gpt-messages\",\n    storage: window.localStorage,\n  },\n  actions: {\n    addRole(\n      roleKeyword: string,\n      roleName: string,\n      roleDesc: string,\n      systemMessage: string", "      roleDesc: string,\n      systemMessage: string\n    ) {\n      const { messages } = this.$state;\n      messages.push({\n        roleKeyword,\n        roleName,\n        roleDesc,\n        systemMessage,\n        parentMessageId: \"\",", "        systemMessage,\n        parentMessageId: \"\",\n        messageElements: [],\n      });\n    },\n    addMessage(\n      msg: Gpt.MessageElement,\n      roleKeyword: string | \"default\",\n      parentMessageId: string\n    ) {", "      parentMessageId: string\n    ) {\n      const { messages } = this.$state;\n      messages.forEach((m) => {\n        if (m.roleKeyword == roleKeyword) {\n          // \u8868\u793a\u5df2\u627e\u5230\n          m.parentMessageId = parentMessageId;\n          if (m.messageElements.length >= 20) {\n            m.messageElements.shift();\n          }\n          m.messageElements.push(msg);\n        }\n      });\n    },\n    clearMessages() {\n      this.$state.messages = [];\n    },\n  },\n});\n"]}
{"filename": "src/core/commands/gpt/subCommands/chat/chatCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\nimport { roleMap } from \"../role/roles\";\n\nconst chatCommand: CommandType = {\n  func: \"chat\",\n  name: \"\u4e0eGPT\u804a\u5929\",\n  params: [\n    {", "  params: [\n    {\n      key: \"message\",\n      desc: \"\u53d1\u9001\u7ed9 GPT \u7684\u5185\u5bb9\",\n      required: true,\n    },\n  ],\n  options: [\n    {\n      key: \"role\",", "    {\n      key: \"role\",\n      desc: \"GPT \u89d2\u8272\u552f\u4e00\u6807\u8bc6\",\n      alias: [\"r\"],\n      type: \"string\",\n      defaultValue: \"default\",\n    },\n    {\n      key: \"temperature\",\n      desc: \"GPT \u91c7\u6837\u6e29\u5ea6\uff0c\u4ecb\u4e8e 0 \uff5e 2 \u4e4b\u95f4\uff0c\u503c\u8d8a\u5927\u8f93\u51fa\u8d8a\u968f\u673a\",", "      key: \"temperature\",\n      desc: \"GPT \u91c7\u6837\u6e29\u5ea6\uff0c\u4ecb\u4e8e 0 \uff5e 2 \u4e4b\u95f4\uff0c\u503c\u8d8a\u5927\u8f93\u51fa\u8d8a\u968f\u673a\",\n      alias: [\"t\"],\n      type: \"string\",\n      defaultValue: \"1\",\n    },\n  ],\n  async action(options, terminal) {\n    const { _, role, temperature } = options;\n    if (_.length < 1) {\n      terminal.writeTextErrorResult(\"\u5185\u5bb9\u4e0d\u53ef\u4e3a\u7a7a\");\n      return;\n    }", "    const { _, role, temperature } = options;\n    if (_.length < 1) {\n      terminal.writeTextErrorResult(\"\u5185\u5bb9\u4e0d\u53ef\u4e3a\u7a7a\");\n      return;\n    }\n    if (temperature) {\n      if (\n        isNaN(temperature) ||\n        Number(temperature) < 0 ||\n        Number(temperature) > 2\n      ) {\n        terminal.writeTextErrorResult(\"temperature \u5fc5\u987b\u4e3a 0 \uff5e 2 \u4e4b\u95f4\u7684\u6574\u6570\");\n        return;\n      }\n    }\n\n    const message = _.join(\" \");\n    // const res: any = await getGptOutput(message, role);\n\n    // console.log(res);\n\n    // console.log(typeof(res))\n\n    // \u8c03\u7528\u63a5\u53e3\u653e\u5728 ChatBox \u5185\u90e8\u53bb\u505a\uff0c\u4f20\u5165 ChatBox\u7684\u53c2\u6570\u4e3a\u7528\u6237\u8f93\u5165\u7684 message\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./ChatBox.vue\")),\n      props: {\n        message: message,\n        role: role,\n        temperature: Number(temperature),\n      },\n    };\n    terminal.writeResult(output);\n", "    // if (res?.code === 0) {\n    //   console.log(\"gpt\u54cd\u5e94\uff1a\", res);\n    //   const output: ComponentOutputType = {\n    //     type: \"component\",\n    //     component: defineAsyncComponent(() => import(\"./ChatBox.vue\")),\n    //     props: {\n    //       message: res.data,\n    //     },\n    //   };\n    //   terminal.writeResult(output);\n    // } else {\n    //   terminal.writeTextErrorResult(res?.message ?? \"GPT\u8bf7\u6c42\u5931\u8d25\");\n    // }\n  },\n};\n\nexport default chatCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/chat/chatApi.ts", "chunked_list": ["import type { AxiosProgressEvent, GenericAbortSignal } from \"axios\";\nimport { post } from \"../../../../../utils/request\";\nimport myAxios from \"../../../../../plugins/myAxios\";\n\nexport const getRoleElementsByKeyword = async (keyword: string) => {\n  return myAxios.post(\"/role/getRoleElementsByKeyword\", {\n    keyword,\n  });\n};\n\nexport function fetchChatAPIProcess<T = any>(params: {\n  prompt: string;\n  options?: { conversationId?: string; parentMessageId?: string };\n  signal?: GenericAbortSignal;\n  systemMessage?: string;\n  temperature?: number;\n  onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void;\n}) {\n  let data: Record<string, any> = {\n    prompt: params.prompt,\n    options: params.options,\n    systemMessage: params.systemMessage,\n    temperature: params.temperature\n  };\n  return post<T>({\n    url: \"/chat-process\",\n    data,\n    signal: params.signal,\n    onDownloadProgress: params.onDownloadProgress,\n  });\n}\n", "};\n\nexport function fetchChatAPIProcess<T = any>(params: {\n  prompt: string;\n  options?: { conversationId?: string; parentMessageId?: string };\n  signal?: GenericAbortSignal;\n  systemMessage?: string;\n  temperature?: number;\n  onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void;\n}) {\n  let data: Record<string, any> = {\n    prompt: params.prompt,\n    options: params.options,\n    systemMessage: params.systemMessage,\n    temperature: params.temperature\n  };\n  return post<T>({\n    url: \"/chat-process\",\n    data,\n    signal: params.signal,\n    onDownloadProgress: params.onDownloadProgress,\n  });\n}\n"]}
{"filename": "src/core/commands/gpt/subCommands/diy/diyCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n\nconst diyCommand: CommandType = {\n  func: \"diy\",\n  name: \"\u81ea\u5b9a\u4e49 GPT \u89d2\u8272\",\n  params: [],\n  requireAuth: true,\n  options: [", "  requireAuth: true,\n  options: [\n    {\n      key: \"keyword\",\n      desc: \"GPT \u89d2\u8272\u552f\u4e00\u6807\u8bc6\",\n      alias: [\"k\"],\n      type: \"string\",\n      required: true,\n    },\n    {", "    },\n    {\n      key: \"name\",\n      desc: \"GPT \u89d2\u8272\u540d\",\n      alias: [\"n\"],\n      type: \"string\",\n      required: true,\n    },\n    {\n      key: \"desc\",", "    {\n      key: \"desc\",\n      desc: \"GPT \u89d2\u8272\u63cf\u8ff0\",\n      alias: [\"d\"],\n      type: \"string\",\n      required: true,\n    },\n  ],\n  async action(options, terminal) {\n    const { keyword, name, desc } = options;", "  async action(options, terminal) {\n    const { keyword, name, desc } = options;\n    // TODO:\u7528\u6237\u81ea\u5b9a\u4e49\u89d2\u8272\u540e\uff0c\u9700\u8981\u5305\u542b\u8fdb\u6765\n    if (!keyword) {\n      terminal.writeTextErrorResult(\"\u89d2\u8272\u552f\u4e00\u6807\u8bc6\u5fc5\u586b\");\n      return;\n    }\n    if (!name) {\n      terminal.writeTextErrorResult(\"\u89d2\u8272\u540d\u79f0\u5fc5\u586b\");\n      return;\n    }", "    if (!desc) {\n      terminal.writeTextErrorResult(\"\u89d2\u8272\u63cf\u8ff0\u5fc5\u586b\");\n      return;\n    }\n    const diyBox: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./DiyBox.vue\")),\n      props: {\n        keyword: keyword,\n        name: name,\n        description: desc,\n      },\n    };\n    terminal.writeResult(diyBox);\n  },\n};\n\nexport default diyCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/role/roles.ts", "chunked_list": ["interface Role {\n  name: string;\n  desc: string;\n}\n\nexport const roleMap: Map<string, Role> = new Map([\n  [\n    \"default\",\n    {\n      name: \"\u9ed8\u8ba4\u89d2\u8272\",\n      desc: \"\u65e0\u4efb\u4f55\u5b9a\u5236\u7684\u666e\u901a GPT \u804a\u5929\u673a\u5668\u4eba\",\n    },\n  ],\n  [\n    \"cli\",\n    {\n      name: \"\u547d\u4ee4\u884c\u7ffb\u8bd1\u89d2\u8272\",\n      desc: \"\u5c06\u4f60\u7684\u81ea\u7136\u8bed\u8a00\u6307\u4ee4\u7ffb\u8bd1\u4e3a Window/Unix \u7ec8\u7aef\u547d\u4ee4\",\n    },\n  ],\n  [\n    \"translator\",\n    {\n      name: \"\u4e2d\u82f1\u6587\u4e92\u8bd1\u89d2\u8272\",\n      desc: \"\u5c06\u4f60\u6240\u53d1\u7684\u5185\u5bb9\u8fdb\u884c\u4e2d\u82f1\u6587\u4e92\u8bd1\",\n    },\n  ],\n  [\n    \"sql\",\n    {\n      name: \"SQL \u7ffb\u8bd1\u89d2\u8272\",\n      desc: \"\u5c06\u4f60\u7684\u81ea\u7136\u8bed\u8a00\u6307\u4ee4\u7ffb\u8bd1\u4e3a SQL \u4ee3\u7801\",\n    },\n  ],\n  [\n    \"ikun\",\n    {\n      name: \"\u5fe0\u5b9e\u7684 IKun\",\n      desc: \"\u5c0f\u9ed1\u5b50\uff5e\"\n    }\n  ]\n]);\n"]}
{"filename": "src/core/commands/gpt/subCommands/role/roleCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n\nconst roleCommand: CommandType = {\n  func: \"role\",\n  name: \"\u67e5\u770b\u6240\u6709 GPT \u89d2\u8272\",\n  params: [],\n  options: [],\n  async action(options, terminal) {", "  options: [],\n  async action(options, terminal) {\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./RoleBox.vue\")),\n    };\n    terminal.writeResult(output);\n    return;\n  },\n};", "  },\n};\n\nexport default roleCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/model/models.ts", "chunked_list": ["export interface Model {\n  key: string;\n  name: string;\n}\n\nexport const modelList: Model[] = [\n  {\n    key: \"gpt-3.5-turbo\",\n    name: \"gpt-3.5-turbo\",\n  },\n  {\n    key: \"gpt-3.5-turbo-16k\",\n    name: \"gpt-3.5-turbo-16k\",\n  },\n  {\n    key: \"gpt-3.5-turbo-0613\",\n    name: \"gpt-3.5-turbo-0613\",\n  },\n  {\n    key: \"gpt-3.5-turbo-16k-0613\",\n    name: \"gpt-3.5-turbo-16k-0613\",\n  },\n  {\n    key: \"gpt-4-0613\",\n    name: \"gpt-4-0613\",\n  },\n  {\n    key: \"gpt-4-32k\",\n    name: \"gpt-4-32k\",\n  },\n  {\n    key: \"gpt-4-32k-0613\",\n    name: \"gpt-4-32k-0613\",\n  }\n]"]}
{"filename": "src/core/commands/gpt/subCommands/model/modelCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n\nconst modelCommand: CommandType = {\n  func: \"model\",\n  name: \"\u9009\u62e9\u5e76\u8bbe\u7f6e GPT \u6a21\u578b\",\n  params: [],\n  options: [],\n  async action(options, terminal) {", "  options: [],\n  async action(options, terminal) {\n    const output: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./ModelSelectBox.vue\")),\n    };\n    terminal.writeResult(output);\n    return;\n  },\n};", "  },\n};\n\nexport default modelCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/image/imageApi.ts", "chunked_list": ["import myAxios from \"../../../../../plugins/myAxios\";\n\nexport const getImage = async (\n  prompt: string,\n  number: number,\n  size: string\n) => {\n  return await myAxios.post(\"/gpt/getImage\", {\n    prompt,\n    number,", "    prompt,\n    number,\n    size,\n  });\n};\n"]}
{"filename": "src/core/commands/gpt/subCommands/image/imageCommand.ts", "chunked_list": ["import { defineAsyncComponent } from \"vue\";\nimport { CommandType } from \"../../../../command\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n\nconst sizeMap: Map<string, string> = new Map([\n  [\"256\", \"256x256\"],\n  [\"512\", \"512x512\"],\n  [\"1024\", \"1024x1024\"],\n]);\n", "]);\n\nconst imageCommand: CommandType = {\n  func: \"image\",\n  name: \"\u667a\u80fd\u751f\u6210\u56fe\u7247\",\n  params: [\n    {\n      key: \"prompt\",\n      desc: \"\u751f\u6210\u56fe\u7247\u7684\u63d0\u793a\u6587\u672c\",\n      required: true,", "      desc: \"\u751f\u6210\u56fe\u7247\u7684\u63d0\u793a\u6587\u672c\",\n      required: true,\n    },\n  ],\n  options: [\n    {\n      key: \"number\",\n      desc: \"\u751f\u6210\u56fe\u7247\u7684\u6570\u91cf\",\n      alias: [\"n\"],\n      type: \"string\",", "      alias: [\"n\"],\n      type: \"string\",\n      required: false,\n    },\n    {\n      key: \"size\",\n      desc: \"\u751f\u6210\u56fe\u7247\u7684\u5c3a\u5bf8\uff0c\u53ef\u9009 256/512/1024\",\n      alias: [\"s\"],\n      type: \"string\",\n      required: false,", "      type: \"string\",\n      required: false,\n    },\n  ],\n  async action(options, terminal) {\n    const { _, number, size } = options;\n    if (_.length < 1) {\n      terminal.writeTextErrorResult(\"\u56fe\u7247\u751f\u6210\u63d0\u793a\u5185\u5bb9\u4e0d\u53ef\u4e3a\u7a7a\");\n      return;\n    }\n    if (number) {", "    if (number) {\n      if (isNaN(number) || Number(number) < 1 || Number(number) > 5) {\n        terminal.writeTextErrorResult(\"\u56fe\u7247\u6570\u91cf\u5fc5\u987b\u4e3a1\uff5e5\u4e4b\u95f4\u7684\u6574\u6570\");\n        return;\n      }\n    }\n    if (size && !sizeMap.has(size)) {\n      terminal.writeTextErrorResult(\"\u56fe\u7247\u5c3a\u5bf8\u683c\u5f0f\u4e0d\u6b63\u786e\");\n      return;\n    }\n    const prompt = _.join(\" \");\n    // const res: any = await getImage(prompt, number, size);", "    // if (res?.code !== 0) {\n    //   terminal.writeTextErrorResult(res.message);\n    //   return;\n    // }\n    const imageBox: ComponentOutputType = {\n      type: \"component\",\n      component: defineAsyncComponent(() => import(\"./ImageBox.vue\")),\n      props: {\n        prompt: prompt,\n        number: Number(number),\n        size: sizeMap.get(size),\n      },\n    };\n    terminal.writeResult(imageBox);\n  },\n};\n\nexport default imageCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/history/historyCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\nimport { defineAsyncComponent } from \"vue\";\nimport ComponentOutputType = GptTerminal.ComponentOutputType;\n// import { useMessagesStore } from \"../../messagesStore\";\n\n// const messagesStore = useMessagesStore();\n// const messages = messagesStore.$state.messages;\n\nconst historyCommand: CommandType = {\n  func: \"history\",", "const historyCommand: CommandType = {\n  func: \"history\",\n  name: \"\u67e5\u770b\u8fc7\u53bb\u63d0\u95ee\u4e0e\u56de\u7b54\u8bb0\u5f55\",\n  params: [],\n  options: [\n    {\n      key: \"position\",\n      desc: \"\u804a\u5929\u8bb0\u5f55\u7f16\u53f7\uff0c\u8f93\u51fa\u76f8\u5bf9\u5e94\u7684\u5355\u6761\u95ee\u7b54\u8bb0\u5f55\",\n      alias: [\"p\"],\n      type: \"string\",", "      alias: [\"p\"],\n      type: \"string\",\n    },\n  ],\n  // \u8f93\u51651\uff0c\u5bf9\u5e940\n  // \u8f93\u51652\uff0c\u5bf9\u5e942\n  // \u8f93\u51653\uff0c\u5bf9\u5e944\n  // \u8f93\u51654\uff0c\u5bf9\u5e946\n  // \u8f93\u51655\uff0c\u5bf9\u5e948\n  async action(options, terminal) {", "  // \u8f93\u51655\uff0c\u5bf9\u5e948\n  async action(options, terminal) {\n    const { position } = options;\n    const messages = terminal.listGptHistory();\n    console.log(\"messages:\", messages);\n    // const len = messages.reduce(\n    //   (acc, cur) => acc + cur.messageElements.length,\n    //   0\n    // );\n    // \u5217\u51fa\u5168\u90e8 gpt \u7528\u6237\u63d0\u95ee\u8bb0\u5f55", "    // );\n    // \u5217\u51fa\u5168\u90e8 gpt \u7528\u6237\u63d0\u95ee\u8bb0\u5f55\n    const allMessages: any = [];\n    messages.forEach((message) => {\n      message?.messageElements?.forEach((e) => {\n        allMessages.push({ ...e, roleKeyword: message.roleKeyword });\n      });\n    });\n    if (!position) {\n      let index = 1;\n      allMessages?.forEach((e: any) => {", "    if (!position) {\n      let index = 1;\n      allMessages?.forEach((e: any) => {\n        if (e.role == \"user\") {\n          terminal.writeTextResult(\n            `${index} gpt chat -r ${e.roleKeyword} ${e.content}`\n          );\n          index += 1;\n        }\n      });\n    } else if (position < 1 || position * 2 > allMessages.length) {\n      terminal.writeTextErrorResult(\"\u8f93\u5165\u5e8f\u53f7\u6709\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\uff5e\");\n    } else {\n      const inputMessage = allMessages[(position - 1) * 2];\n      const gptCommand = `gpt chat -r ${inputMessage.roleKeyword} ${inputMessage.content}`;\n      const outputMessage = allMessages[(position - 1) * 2 + 1];\n      const gptOutput = outputMessage.content;\n      const recordBox: ComponentOutputType = {\n        type: \"component\",\n        component: defineAsyncComponent(() => import(\"./RecordBox.vue\")),\n        props: {\n          gptCommand: gptCommand,\n          gptOutput: gptOutput,\n        },\n      };\n      terminal.writeResult(recordBox);\n    }\n  },\n};\n\nexport default historyCommand;\n", "    } else if (position < 1 || position * 2 > allMessages.length) {\n      terminal.writeTextErrorResult(\"\u8f93\u5165\u5e8f\u53f7\u6709\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\uff5e\");\n    } else {\n      const inputMessage = allMessages[(position - 1) * 2];\n      const gptCommand = `gpt chat -r ${inputMessage.roleKeyword} ${inputMessage.content}`;\n      const outputMessage = allMessages[(position - 1) * 2 + 1];\n      const gptOutput = outputMessage.content;\n      const recordBox: ComponentOutputType = {\n        type: \"component\",\n        component: defineAsyncComponent(() => import(\"./RecordBox.vue\")),\n        props: {\n          gptCommand: gptCommand,\n          gptOutput: gptOutput,\n        },\n      };\n      terminal.writeResult(recordBox);\n    }\n  },\n};\n\nexport default historyCommand;\n"]}
