{"filename": "src/index.ts", "chunked_list": ["#!/usr/bin/env node\n\nconst axios = require(\"axios\");\n\nrequire(\"yargs/yargs\")(process.argv.slice(2))\n  .commandDir(\"commands\", {\n    visit(commandModule: any) {\n      return commandModule.default;\n    },\n  })", "    },\n  })\n  .parserConfiguration({ \"boolean-negation\": false })\n  .demandCommand()\n  .strict()\n  .usage(\n    \"Work seamlessly with Retool from the command line. For feedback and issues visit https://github.com/tryretool/retool-cli.\\n\\nUsage: retool <command> [flags]\"\n  ).argv;\n\n// Setup axios defaults.", "\n// Setup axios defaults.\naxios.defaults.headers.accept = \"application/json\";\naxios.defaults.headers[\"content-type\"] = \"application/json\";\n"]}
{"filename": "src/commands/login.ts", "chunked_list": ["import express from \"express\";\nimport { CommandModule } from \"yargs\";\n\nimport { accessTokenFromCookies, xsrfTokenFromCookies } from \"../utils/cookies\";\nimport {\n  askForCookies,\n  doCredentialsExist,\n  getCredentials,\n  persistCredentials,\n} from \"../utils/credentials\";", "  persistCredentials,\n} from \"../utils/credentials\";\nimport { getRequest, postRequest } from \"../utils/networking\";\nimport { logDAU } from \"../utils/telemetry\";\n\nconst path = require(\"path\");\n\nconst axios = require(\"axios\");\nconst chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");", "const chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\nconst open = require(\"open\");\n\nconst command = \"login\";\nconst describe = \"Log in to Retool.\";\nconst builder = {};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst handler = async function (argv: any) {\n  // Ask user if they want to overwrite existing credentials.\n  if (doCredentialsExist()) {\n    const { overwrite } = await inquirer.prompt([\n      {\n        name: \"overwrite\",\n        message: \"You're already logged in. Do you want to re-authenticate?\",\n        type: \"confirm\",\n      },\n    ]);", "const handler = async function (argv: any) {\n  // Ask user if they want to overwrite existing credentials.\n  if (doCredentialsExist()) {\n    const { overwrite } = await inquirer.prompt([\n      {\n        name: \"overwrite\",\n        message: \"You're already logged in. Do you want to re-authenticate?\",\n        type: \"confirm\",\n      },\n    ]);\n    if (!overwrite) {\n      return;\n    }\n  }\n\n  // Ask user how they want to login.\n  const { loginMethod } = await inquirer.prompt([\n    {\n      name: \"loginMethod\",\n      message: \"How would you like to login?\",\n      type: \"list\",\n      choices: [\n        {\n          name: \"Log in using Google SSO in a web browser\",\n          value: \"browser\",\n        },\n        {\n          name: \"Log in with email and password\",\n          value: \"email\",\n        },\n        {\n          name: \"Log in by pasting in cookies\",\n          value: \"cookies\",\n        },\n        {\n          name: \"Log in to localhost:3000\",\n          value: \"localhost\",\n        },\n      ],\n    },\n  ]);", "    if (!overwrite) {\n      return;\n    }\n  }\n\n  // Ask user how they want to login.\n  const { loginMethod } = await inquirer.prompt([\n    {\n      name: \"loginMethod\",\n      message: \"How would you like to login?\",\n      type: \"list\",\n      choices: [\n        {\n          name: \"Log in using Google SSO in a web browser\",\n          value: \"browser\",\n        },\n        {\n          name: \"Log in with email and password\",\n          value: \"email\",\n        },\n        {\n          name: \"Log in by pasting in cookies\",\n          value: \"cookies\",\n        },\n        {\n          name: \"Log in to localhost:3000\",\n          value: \"localhost\",\n        },\n      ],\n    },\n  ]);", "  if (loginMethod === \"browser\") {\n    await loginViaBrowser();\n  } else if (loginMethod === \"email\") {\n    await loginViaEmail(false);\n  } else if (loginMethod === \"cookies\") {\n    await askForCookies();\n  } else if (loginMethod === \"localhost\") {\n    await loginViaEmail(true);\n  }\n\n  await logDAU();\n};\n\n// Ask the user to input their email and password.\n// Fire off a request to Retool's login & auth endpoints.\n// Persist the credentials.", "async function loginViaEmail(localhost = false) {\n  const { email, password } = await inquirer.prompt([\n    {\n      name: \"email\",\n      message: \"What is your email?\",\n      type: \"input\",\n    },\n    {\n      name: \"password\",\n      message: \"What is your password?\",\n      type: \"password\",\n    },\n  ]);\n\n  const loginOrigin = localhost\n    ? \"http://localhost:3000\"\n    : \"https://login.retool.com\";\n\n  // Step 1: Hit /api/login with email and password.\n  const login = await postRequest(`${loginOrigin}/api/login`, {\n    email,\n    password,\n  });\n  const { authUrl, authorizationToken } = login.data;", "  if (!authUrl || !authorizationToken) {\n    console.log(\"Error logging in, please try again\");\n    return;\n  }\n\n  // Step 2: Hit /auth/saveAuth with authorizationToken.\n  const authResponse = await postRequest(\n    localhost ? `${loginOrigin}${authUrl}` : authUrl,\n    {\n      authorizationToken,\n    },\n    true,\n    {\n      origin: loginOrigin,\n    }\n  );\n  const { redirectUri } = authResponse.data;\n  const redirectUrl = localhost\n    ? new URL(loginOrigin)\n    : redirectUri\n    ? new URL(redirectUri)\n    : undefined;\n  const accessToken = accessTokenFromCookies(\n    authResponse.headers[\"set-cookie\"]\n  );\n  const xsrfToken = xsrfTokenFromCookies(authResponse.headers[\"set-cookie\"]);\n\n  // Step 3: Persist the credentials.", "  if (redirectUrl?.origin && accessToken && xsrfToken) {\n    persistCredentials({\n      origin: redirectUrl.origin,\n      accessToken,\n      xsrf: xsrfToken,\n      firstName: authResponse.data.user?.firstName,\n      lastName: authResponse.data.user?.lastName,\n      email: authResponse.data.user?.email,\n      telemetryEnabled: true,\n    });\n    logSuccess();\n  } else {\n    console.log(\n      \"Error parsing credentials from HTTP Response. Please try again.\"\n    );\n  }\n}\n", "async function loginViaBrowser() {\n  // Start a short lived local server to listen for the SSO response.\n  const app = express();\n\n  // Step 4: Handle the SSO response.\n  // Success scenario format: http://localhost:3020/auth?redirect=https://mycompany.retool.com\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  app.get(\"/auth\", async function (req, res) {\n    let url, accessToken, xsrfToken;\n\n    try {\n      accessToken = decodeURIComponent(req.query.accessToken as string);\n      xsrfToken = decodeURIComponent(req.query.xsrfToken as string);\n      url = new URL(decodeURIComponent(req.query.redirect as string));", "    try {\n      accessToken = decodeURIComponent(req.query.accessToken as string);\n      xsrfToken = decodeURIComponent(req.query.xsrfToken as string);\n      url = new URL(decodeURIComponent(req.query.redirect as string));\n    } catch (e) {\n      console.log(e);\n    }\n\n    if (!accessToken || !xsrfToken || !url) {\n      console.log(\"Error: SSO response missing information. Try again.\");\n      res.sendFile(path.join(__dirname, \"../loginPages/loginFail.html\"));\n      server_online = false;\n      return;\n    }\n\n    axios.defaults.headers[\"x-xsrf-token\"] = xsrfToken;\n    axios.defaults.headers.cookie = `accessToken=${accessToken};`;\n    const userRes = await getRequest(`https://${url.hostname}/api/user`);\n\n    persistCredentials({\n      origin: url.origin,\n      accessToken,\n      xsrf: xsrfToken,\n      firstName: userRes.data.user?.firstName,\n      lastName: userRes.data.user?.lastName,\n      email: userRes.data.user?.email,\n      telemetryEnabled: true,\n    });\n    logSuccess();\n    res.sendFile(path.join(__dirname, \"../loginPages/loginSuccess.html\"));\n    server_online = false;\n  });\n  const server = app.listen(3020);\n\n  // Step 1: Open up the google SSO page in the browser.\n  // Step 2: User accepts the SSO request.\n  open(`https://login.retool.com/googlelogin?retoolCliRedirect=true`);\n  // For local testing:\n  // open(\"http://localhost:3000/googlelogin?retoolCliRedirect=true\");\n  // open(\"https://login.retool-qa.com/googlelogin?retoolCliRedirect=true\");\n  // open(\"https://admin.retool.dev/googlelogin?retoolCliRedirect=true\");\n\n  // Step 3: Keep the server online until localhost:3020/auth is hit.\n  let server_online = true;", "    if (!accessToken || !xsrfToken || !url) {\n      console.log(\"Error: SSO response missing information. Try again.\");\n      res.sendFile(path.join(__dirname, \"../loginPages/loginFail.html\"));\n      server_online = false;\n      return;\n    }\n\n    axios.defaults.headers[\"x-xsrf-token\"] = xsrfToken;\n    axios.defaults.headers.cookie = `accessToken=${accessToken};`;\n    const userRes = await getRequest(`https://${url.hostname}/api/user`);\n\n    persistCredentials({\n      origin: url.origin,\n      accessToken,\n      xsrf: xsrfToken,\n      firstName: userRes.data.user?.firstName,\n      lastName: userRes.data.user?.lastName,\n      email: userRes.data.user?.email,\n      telemetryEnabled: true,\n    });\n    logSuccess();\n    res.sendFile(path.join(__dirname, \"../loginPages/loginSuccess.html\"));\n    server_online = false;\n  });\n  const server = app.listen(3020);\n\n  // Step 1: Open up the google SSO page in the browser.\n  // Step 2: User accepts the SSO request.\n  open(`https://login.retool.com/googlelogin?retoolCliRedirect=true`);\n  // For local testing:\n  // open(\"http://localhost:3000/googlelogin?retoolCliRedirect=true\");\n  // open(\"https://login.retool-qa.com/googlelogin?retoolCliRedirect=true\");\n  // open(\"https://admin.retool.dev/googlelogin?retoolCliRedirect=true\");\n\n  // Step 3: Keep the server online until localhost:3020/auth is hit.\n  let server_online = true;", "  while (server_online) {\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  }\n\n  server.close();\n}\n\nexport function logSuccess() {\n  const credentials = getCredentials();\n  if (credentials?.firstName && credentials.lastName && credentials.email) {\n    console.log(\n      `Logged in as ${chalk.bold(credentials.firstName)} ${chalk.bold(\n        credentials.lastName\n      )} (${credentials.email}) \u2705`\n    );\n  } else {\n    console.log(\"Successfully saved credentials.\");\n  }\n}\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n", "  if (credentials?.firstName && credentials.lastName && credentials.email) {\n    console.log(\n      `Logged in as ${chalk.bold(credentials.firstName)} ${chalk.bold(\n        credentials.lastName\n      )} (${credentials.email}) \u2705`\n    );\n  } else {\n    console.log(\"Successfully saved credentials.\");\n  }\n}\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/rpc.ts", "chunked_list": ["import { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nimport chalk from \"chalk\";\nimport ora from \"ora\";\nimport { CommandModule } from \"yargs\";\n\nimport { getAndVerifyCredentials } from \"../utils/credentials\";\nimport {\n  downloadGithubSubfolder,", "import {\n  downloadGithubSubfolder,\n  saveEnvVariablesToFile,\n} from \"../utils/fileSave\";\nimport { createPlaygroundQuery } from \"../utils/playgroundQuery\";\nimport { createResource } from \"../utils/resources\";\nimport { logDAU } from \"../utils/telemetry\";\n\nconst inquirer = require(\"inquirer\");\n", "const inquirer = require(\"inquirer\");\n\nconst command = \"rpc\";\nconst describe = \"Interface with Retool RPC.\";\nconst builder = {};\nconst handler = async function () {\n  const credentials = getAndVerifyCredentials();\n  const origin = credentials.origin;\n  // fire and forget\n  void logDAU(credentials);", "  // fire and forget\n  void logDAU(credentials);\n\n  console.log(\n    `We'll be showcasing RetoolRPC -- a simple way to connect to Retool from your local codebase. The three things you'll need are: `\n  );\n  console.log(\n    `1. An RPC resource on Retool (we'll create one for you automatically)`\n  );\n  console.log(`2. An access token to connect to Retool`);", "  );\n  console.log(`2. An access token to connect to Retool`);\n  console.log(\n    `3. A running local server that runs the code you want to execute on Retool\\n`\n  );\n  console.log(\"To learn more about RetoolRPC, check out our docs: <DOCS LINK>\");\n  console.log(\"\\nLet's get started! \ud83d\ude80\\n\");\n\n  let resourceName = \"\";\n  let resourceId = 0;", "  let resourceName = \"\";\n  let resourceId = 0;\n\n  await inquirer.prompt([\n    {\n      name: \"resourceDisplayName\",\n      message: \"What would you like the name of your RetoolRPC resource to be?\",\n      type: \"input\",\n      validate: async (displayName: string) => {\n        try {\n          const resource = await createResource({\n            resourceType: \"retoolSdk\",\n            credentials,\n            resourceOptions: {\n              requireExplicitVersion: false,\n            },\n            displayName,\n          });\n          resourceName = resource.name;\n          resourceId = resource.id;\n          return true;", "      validate: async (displayName: string) => {\n        try {\n          const resource = await createResource({\n            resourceType: \"retoolSdk\",\n            credentials,\n            resourceOptions: {\n              requireExplicitVersion: false,\n            },\n            displayName,\n          });\n          resourceName = resource.name;\n          resourceId = resource.id;\n          return true;", "        } catch (error: any) {\n          return (\n            error.response?.data?.message || \"API call failed creating resource\"\n          );\n        }\n      },\n    },\n  ]);\n\n  console.log(\n    `Excellent choice! We've created resource ${resourceName} with that name. Now we'll need an access token.\\n`\n  );\n\n  const { rpcAccessToken } = (await inquirer.prompt([\n    {\n      name: \"rpcAccessToken\",\n      message: `Please enter an RPC access token. You can add a new one here: ${origin}/settings/api`,\n      type: \"password\",\n      validate: (rpcAccessToken: string) => {\n        // TODO: validate with an api call", "        if (rpcAccessToken === \"\") {\n          return \"Please enter a valid RPC access token\";\n        }\n        return true;\n      },\n    },\n  ])) as { rpcAccessToken: string };\n\n  const { languageType } = (await inquirer.prompt([\n    {\n      name: \"languageType\",\n      message:\n        \"Which of the following languages would you like to use for your local codebase?\",\n      type: \"list\",\n      choices: [\n        {\n          name: \"Typescript!\",\n          value: \"typescript\",\n        },\n      ],\n    },\n  ])) as { languageType: string };\n\n  const { destinationPath } = (await inquirer.prompt([\n    {\n      name: \"destinationPath\",\n      message: \"Where would you like to create your local server?\",\n      type: \"input\",\n      default: \"./retool_rpc\",\n    },\n  ])) as { destinationPath: string };\n\n  const githubUrl =\n    \"https://api.github.com/repos/tryretool/retool-examples/tarball/main\";\n  const subfolderPath = \"hello_world/\" + languageType;\n  await downloadGithubSubfolder(githubUrl, subfolderPath, destinationPath);\n\n  const spinner = ora(\n    \"Installing dependencies and creating starter code to connect to Retool...\"\n  ).start();\n\n  const queryResult = await createPlaygroundQuery(resourceId, credentials);\n\n  const envVariables = {\n    RETOOL_SDK_ID: resourceName,\n    RETOOL_SDK_HOST: origin,\n    RETOOL_SDK_API_TOKEN: rpcAccessToken,\n  };\n  saveEnvVariablesToFile(envVariables, destinationPath + \"/.env\");\n\n  await installYarnDependencies(destinationPath);\n\n  spinner.stop();\n\n  console.log(\"We've created your starter code to connect to Retool! \ud83c\udf89\\n\");\n\n  console.log(\n    `Your local code is located at ${destinationPath}/src/index.ts. For Retool to interact with your code, start the server by completing the following steps:`\n  );\n  console.log(`1. cd ${destinationPath}`);\n  console.log(\"2. yarn example\\n\");\n\n  console.log(\n    `${chalk.bold(\n      \"Once your server is running, run the following query in Retool to see how it interacts with your local codebase:\"\n    )} ${credentials.origin}/queryLibrary/${queryResult.id}`\n  );\n};\n", "async function installYarnDependencies(destinationPath: string) {\n  const executeCommand = promisify(exec);\n  try {\n    await executeCommand(\"yarn install\", { cwd: destinationPath });\n  } catch (error: any) {\n    console.error(`Error installing Yarn dependencies: ${error.message}`);\n  }\n}\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/logout.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport { deleteCredentials } from \"../utils/credentials\";\n\nconst command = \"logout\";\nconst describe = \"Log out of Retool.\";\nconst builder = {};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst handler = function (argv: any) {\n  deleteCredentials();", "const handler = function (argv: any) {\n  deleteCredentials();\n  console.log(\"Successfully logged out. \ud83d\udc4b\ud83c\udffb\");\n};\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,", "  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/apps.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport {\n  collectAppName,\n  createApp,\n  createAppForTable,\n  deleteApp,\n  getAppsAndFolders,\n} from \"../utils/apps\";\nimport type { App } from \"../utils/apps\";", "} from \"../utils/apps\";\nimport type { App } from \"../utils/apps\";\nimport { getAndVerifyCredentialsWithRetoolDB } from \"../utils/credentials\";\nimport { dateOptions } from \"../utils/date\";\nimport {\n  collectTableName,\n  fetchTableInfo,\n  verifyTableExists,\n} from \"../utils/table\";\nimport { logDAU } from \"../utils/telemetry\";", "} from \"../utils/table\";\nimport { logDAU } from \"../utils/telemetry\";\n\nconst command = \"apps\";\nconst describe = \"Interface with Retool Apps.\";\nconst builder: CommandModule[\"builder\"] = {\n  create: {\n    alias: \"c\",\n    describe: `Create a new app.`,\n  },", "    describe: `Create a new app.`,\n  },\n  \"create-from-table\": {\n    alias: \"t\",\n    describe: `Create a new app to visualize a Retool DB table.`,\n  },\n  list: {\n    alias: \"l\",\n    describe: `List folders and apps at root level. Optionally provide a folder name to list all apps in that folder. Usage:\n      retool apps -l [folder-name]`,", "    describe: `List folders and apps at root level. Optionally provide a folder name to list all apps in that folder. Usage:\n      retool apps -l [folder-name]`,\n  },\n  \"list-recursive\": {\n    alias: \"r\",\n    describe: `List all apps and folders.`,\n  },\n  delete: {\n    alias: \"d\",\n    describe: `Delete an app. Usage:", "    alias: \"d\",\n    describe: `Delete an app. Usage:\n      retool db -d <app-name>`,\n    type: \"array\",\n  },\n};\nconst handler = async function (argv: any) {\n  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n  // fire and forget\n  void logDAU(credentials);", "  // fire and forget\n  void logDAU(credentials);\n\n  // Handle `retool apps --list [folder-name]`\n  if (argv.list || argv.r) {\n    let { apps, folders } = await getAppsAndFolders(credentials);\n    const rootFolderId = folders?.find(\n      (folder) => folder.name === \"root\" && folder.systemFolder === true\n    )?.id;\n    const trashFolderId = folders?.find(\n      (folder) => folder.name === \"archive\" && folder.systemFolder === true\n    )?.id;\n\n    // Only list apps in the specified folder.", "    if (typeof argv.list === \"string\") {\n      const folderId = folders?.find((folder) => folder.name === argv.list)?.id;\n      if (folderId) {\n        const appsInFolder = apps?.filter((app) => app.folderId === folderId);\n        if (appsInFolder && appsInFolder.length > 0) {\n          printApps(appsInFolder);\n        } else {\n          console.log(`No apps found in ${argv.list}.`);\n        }\n      } else {\n        console.log(`No folder named ${argv.list} found.`);\n      }\n    }\n\n    // List all folders, then all apps in root folder.\n    else {\n      // Filter out undesired folders/apps.\n      folders = folders?.filter((folder) => folder.systemFolder === false);\n      apps = apps?.filter((app) => app.folderId !== trashFolderId);", "      if (!argv.r) {\n        apps = apps?.filter((app) => app.folderId === rootFolderId);\n      }\n\n      // Sort from oldest to newest.\n      folders?.sort((a, b) => {\n        return Date.parse(a.updatedAt) - Date.parse(b.updatedAt);\n      });\n      apps?.sort((a, b) => {\n        return Date.parse(a.updatedAt) - Date.parse(b.updatedAt);\n      });\n", "      if ((!folders || folders.length === 0) && (!apps || apps.length === 0)) {\n        console.log(\"No folders or apps found.\");\n      } else {\n        // List all folders\n        if (folders && folders?.length > 0) {\n          folders.forEach((folder) => {\n            const date = new Date(Date.parse(folder.updatedAt));\n            console.log(\n              `${date.toLocaleString(undefined, dateOptions)}     \ud83d\udcc2     ${\n                folder.name\n              }/`\n            );\n          });\n        }\n        // List all apps in root folder.\n        printApps(apps);\n      }\n    }\n  }\n\n  // Handle `retool apps --create-from-table`", "  else if (argv.t) {\n    const tableName = await collectTableName();\n    await verifyTableExists(tableName, credentials);\n    const tableInfo = await fetchTableInfo(tableName, credentials);\n    if (!tableInfo) {\n      console.error(`Table ${tableName} info not found.`);\n      process.exit(1);\n    }\n    const appName = await collectAppName();\n    // Use the first non-pkey column as the search column.\n    const searchColumnName = tableInfo.fields.find(\n      (field) => field.name !== tableInfo.primaryKeyColumn\n    )?.name;\n\n    await createAppForTable(\n      appName,\n      tableName,\n      searchColumnName || tableInfo.primaryKeyColumn,\n      credentials\n    );\n  }\n\n  // Handle `retool apps --create`", "  else if (argv.create) {\n    const appName = await collectAppName();\n    await createApp(appName, credentials);\n  }\n\n  // Handle `retool apps -d <app-name>`\n  else if (argv.delete) {\n    const appNames = argv.delete;\n    for (const appName of appNames) {\n      await deleteApp(appName, credentials, true);\n    }\n  }\n\n  // No flag specified.\n  else {\n    console.log(\n      \"No flag specified. See `retool apps --help` for available flags.\"\n    );\n  }\n};\n", "    for (const appName of appNames) {\n      await deleteApp(appName, credentials, true);\n    }\n  }\n\n  // No flag specified.\n  else {\n    console.log(\n      \"No flag specified. See `retool apps --help` for available flags.\"\n    );\n  }\n};\n", "function printApps(apps: Array<App> | undefined): void {\n  if (apps && apps?.length > 0) {\n    apps.forEach((app) => {\n      const date = new Date(Date.parse(app.updatedAt));\n      console.log(\n        `${date.toLocaleString(undefined, dateOptions)}     ${\n          app.isGlobalWidget ? \"\ud83d\udd27\" : \"\ud83d\udcbb\"\n        }     ${app.name}`\n      );\n    });\n  }\n}\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/workflows.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport { getAndVerifyCredentialsWithRetoolDB } from \"../utils/credentials\";\nimport { dateOptions } from \"../utils/date\";\nimport { logDAU } from \"../utils/telemetry\";\nimport {\n  Workflow,\n  deleteWorkflow,\n  getWorkflowsAndFolders,\n} from \"../utils/workflows\";", "  getWorkflowsAndFolders,\n} from \"../utils/workflows\";\n\nconst command = \"workflows\";\nconst describe = \"Interface with Retool Workflows.\";\nconst builder: CommandModule[\"builder\"] = {\n  list: {\n    alias: \"l\",\n    describe: `List folders and workflows at root level. Optionally provide a folder name to list all workflows in that folder. Usage:\n    retool workflows -l [folder-name]`,", "    describe: `List folders and workflows at root level. Optionally provide a folder name to list all workflows in that folder. Usage:\n    retool workflows -l [folder-name]`,\n  },\n  \"list-recursive\": {\n    alias: \"r\",\n    describe: `List all apps and workflows.`,\n  },\n  delete: {\n    alias: \"d\",\n    describe: `Delete a workflow. Usage:", "    alias: \"d\",\n    describe: `Delete a workflow. Usage:\n      retool workflows -d <workflow-name>`,\n    type: \"array\",\n  },\n};\nconst handler = async function (argv: any) {\n  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n  // fire and forget\n  void logDAU(credentials);", "  // fire and forget\n  void logDAU(credentials);\n\n  // Handle `retool workflows -l`\n  if (argv.list || argv.r) {\n    let { workflows, folders } = await getWorkflowsAndFolders(credentials);\n    const rootFolderId = folders?.find(\n      (folder) => folder.name === \"root\" && folder.systemFolder === true\n    )?.id;\n    const trashFolderId = folders?.find(\n      (folder) => folder.name === \"archive\" && folder.systemFolder === true\n    )?.id;\n\n    // Only list workflows in the specified folder.", "    if (typeof argv.list === \"string\") {\n      const folderId = folders?.find((folder) => folder.name === argv.list)?.id;\n      if (folderId) {\n        const workflowsInFolder = workflows?.filter(\n          (w) => w.folderId === folderId\n        );\n        if (workflowsInFolder && workflowsInFolder.length > 0) {\n          printWorkflows(workflowsInFolder);\n        } else {\n          console.log(`No workflows found in ${argv.list}.`);\n        }\n      } else {\n        console.log(`No folder named ${argv.list} found.`);\n      }\n    }\n\n    // List all folders, then all workflows in root folder.\n    else {\n      // Filter out undesired folders/workflows.\n      folders = folders?.filter((f) => f.systemFolder === false);\n      workflows = workflows?.filter((w) => w.folderId !== trashFolderId);", "      if (!argv.r) {\n        workflows = workflows?.filter((w) => w.folderId === rootFolderId);\n      }\n\n      // Sort from oldest to newest.\n      folders?.sort((a, b) => {\n        return Date.parse(a.updatedAt) - Date.parse(b.updatedAt);\n      });\n      workflows?.sort((a, b) => {\n        return Date.parse(a.lastDeployedAt) - Date.parse(b.lastDeployedAt);\n      });\n", "      if (\n        (!folders || folders.length === 0) &&\n        (!workflows || workflows.length === 0)\n      ) {\n        console.log(\"No folders or workflows found.\");\n      } else {\n        // List all folders\n        if (folders && folders?.length > 0) {\n          folders.forEach((folder) => {\n            const date = new Date(Date.parse(folder.updatedAt));\n            console.log(\n              `${date.toLocaleString(undefined, dateOptions)}     \ud83d\udcc2     ${\n                folder.name\n              }/`\n            );\n          });\n        }\n        // List all workflows in root folder.\n        printWorkflows(workflows);\n      }\n    }\n  }\n\n  // Handle `retool workflows -d <workflow-name>`", "  else if (argv.delete) {\n    const workflowNames = argv.delete;\n    for (const workflowName of workflowNames) {\n      await deleteWorkflow(workflowName, credentials, true);\n    }\n  }\n\n  // No flag specified.\n  else {\n    console.log(\n      \"No flag specified. See `retool workflows --help` for available flags.\"\n    );\n  }\n};\n", "function printWorkflows(workflows: Array<Workflow> | undefined): void {\n  if (workflows && workflows.length > 0) {\n    workflows.forEach((wf) => {\n      const date = new Date(Date.parse(wf.lastDeployedAt));\n      console.log(\n        `${date.toLocaleString(undefined, dateOptions)}     ${\n          wf.isEnabled ? \"\ud83d\udfe2\" : \"\ud83d\udd34\"\n        }     ${wf.name}`\n      );\n    });\n  }\n}\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/custom_component.ts", "chunked_list": ["import { exec as _exec } from \"child_process\";\nimport util from \"util\";\n\nimport ora from \"ora\";\nimport { CommandModule } from \"yargs\";\n\nimport { logDAU } from \"../utils/telemetry\";\n\nconst exec = util.promisify(_exec);\n", "const exec = util.promisify(_exec);\n\nconst command: CommandModule[\"command\"] = \"custom-component\";\nconst describe: CommandModule[\"describe\"] = \"Interface with custom components.\";\nconst builder: CommandModule[\"builder\"] = {\n  clone: {\n    alias: \"c\",\n    describe: `Clones https://github.com/tryretool/custom-component-guide to the current directory.`,\n    demandOption: true,\n  },", "    demandOption: true,\n  },\n};\nconst handler = async function (argv: any) {\n  // fire and forget\n  void logDAU();\n\n  if (argv.clone) {\n    const spinner = ora(\"Scaffolding a new custom component\").start();\n    await exec(\n      \"git clone https://github.com/tryretool/custom-component-guide.git\"\n    );\n    spinner.stop();\n    console.log(\n      \"Scaffolded a new custom component in the custom-component-guide directory.\"\n    );\n  }\n};\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/scaffold.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport { createAppForTable, deleteApp } from \"../utils/apps\";\nimport {\n  Credentials,\n  getAndVerifyCredentialsWithRetoolDB,\n} from \"../utils/credentials\";\nimport { getRequest, postRequest } from \"../utils/networking\";\nimport {\n  collectColumnNames,", "import {\n  collectColumnNames,\n  collectTableName,\n  createTable,\n  createTableFromCSV,\n  deleteTable,\n  generateDataWithGPT,\n} from \"../utils/table\";\nimport type { DBInfoPayload } from \"../utils/table\";\nimport { logDAU } from \"../utils/telemetry\";", "import type { DBInfoPayload } from \"../utils/table\";\nimport { logDAU } from \"../utils/telemetry\";\nimport { deleteWorkflow, generateCRUDWorkflow } from \"../utils/workflows\";\n\nconst inquirer = require(\"inquirer\");\n\nconst command = \"scaffold\";\nconst describe = \"Scaffold a Retool DB table, CRUD Workflow, and App.\";\nconst builder: CommandModule[\"builder\"] = {\n  name: {", "const builder: CommandModule[\"builder\"] = {\n  name: {\n    alias: \"n\",\n    describe: `Name of table to scaffold. Usage:\n    retool scaffold -n <table_name>`,\n    type: \"string\",\n    nargs: 1,\n  },\n  columns: {\n    alias: \"c\",", "  columns: {\n    alias: \"c\",\n    describe: `Column names in DB to scaffold. Usage:\n    retool scaffold -c <col1> <col2>`,\n    type: \"array\",\n  },\n  delete: {\n    alias: \"d\",\n    describe: `Delete a table, Workflow and App created via scaffold. Usage:\n    retool scaffold -d <db_name>`,", "    describe: `Delete a table, Workflow and App created via scaffold. Usage:\n    retool scaffold -d <db_name>`,\n    type: \"string\",\n    nargs: 1,\n  },\n  \"from-csv\": {\n    alias: \"f\",\n    describe: `Create a table, Workflow and App from a CSV file. Usage:\n    retool scaffold -f <path-to-csv>`,\n    type: \"array\",", "    retool scaffold -f <path-to-csv>`,\n    type: \"array\",\n  },\n  \"no-workflow\": {\n    describe: `Modifier to avoid generating Workflow. Usage:\n    retool scaffold --no-workflow`,\n    type: \"boolean\",\n  },\n};\nconst handler = async function (argv: any) {", "};\nconst handler = async function (argv: any) {\n  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n  // fire and forget\n  void logDAU(credentials);\n\n  // Handle `retool scaffold -d <db_name>`\n  if (argv.delete) {\n    const tableName = argv.delete;\n    const workflowName = `${tableName} CRUD Workflow`;\n\n    // Confirm deletion.\n    const { confirm } = await inquirer.prompt([\n      {\n        name: \"confirm\",\n        message: `Are you sure you want to delete ${tableName} table, CRUD workflow and app?`,\n        type: \"confirm\",\n      },\n    ]);", "    if (!confirm) {\n      process.exit(0);\n    }\n\n    //TODO: Could be parallelized.\n    //TODO: Verify existence before trying to delete.\n    await deleteTable(tableName, credentials, false);\n    await deleteWorkflow(workflowName, credentials, false);\n    await deleteApp(`${tableName} App`, credentials, false);\n  }\n\n  // Handle `retool scaffold -f <path-to-csv>`", "  else if (argv.f) {\n    const csvFileNames = argv.f;\n\n    for (const csvFileName of csvFileNames) {\n      const { tableName, colNames } = await createTableFromCSV(\n        csvFileName,\n        credentials,\n        false,\n        false\n      );\n", "      if (!argv[\"no-workflow\"]) {\n        console.log(\"\\n\");\n        await generateCRUDWorkflow(tableName, credentials);\n      }\n\n      console.log(\"\\n\");\n      const searchColumnName = colNames.length > 0 ? colNames[0] : \"id\";\n      await createAppForTable(\n        `${tableName} App`,\n        tableName,\n        searchColumnName,\n        credentials\n      );\n      console.log(\"\");\n    }\n  }\n\n  // Handle `retool scaffold`\n  else {\n    let tableName = argv.name;\n    let colNames = argv.columns;", "    if (!tableName || tableName.length == 0) {\n      tableName = await collectTableName();\n    }\n    if (!colNames || colNames.length == 0) {\n      colNames = await collectColumnNames();\n    }\n\n    await createTable(tableName, colNames, undefined, credentials, false);\n    // Fire and forget\n    void insertSampleData(tableName, credentials);\n", "    if (!argv[\"no-workflow\"]) {\n      console.log(\"\\n\");\n      await generateCRUDWorkflow(tableName, credentials);\n    }\n\n    console.log(\"\\n\");\n    const searchColumnName = colNames.length > 0 ? colNames[0] : \"id\";\n    await createAppForTable(\n      `${tableName} App`,\n      tableName,\n      searchColumnName,\n      credentials\n    );\n  }\n};\n\nconst insertSampleData = async function (\n  tableName: string,\n  credentials: Credentials\n) {\n  const infoRes = await getRequest(\n    `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`,\n    false\n  );\n  const retoolDBInfo: DBInfoPayload = infoRes.data;\n  const { fields } = retoolDBInfo.tableInfo;\n\n  const generatedData = await generateDataWithGPT(\n    retoolDBInfo,\n    fields,\n    0,\n    credentials,\n    false\n  );", "  if (generatedData) {\n    await postRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n      {\n        kind: \"BulkInsertIntoTable\",\n        tableName: tableName,\n        additions: generatedData,\n      }\n    );\n  }\n};\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/telemetry.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport {\n  getAndVerifyCredentials,\n  persistCredentials,\n} from \"../utils/credentials\";\n\nconst command = \"telemetry\";\nconst describe = \"Configure CLI telemetry.\";\nconst builder = {", "const describe = \"Configure CLI telemetry.\";\nconst builder = {\n  disable: {\n    alias: \"d\",\n    describe: `Disable telemetry.`,\n  },\n  enable: {\n    alias: \"e\",\n    describe: `Enable telemetry.`,\n  },", "    describe: `Enable telemetry.`,\n  },\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst handler = function (argv: any) {\n  const credentials = getAndVerifyCredentials();\n\n  if (argv.disable) {\n    credentials.telemetryEnabled = false;\n    persistCredentials(credentials);\n    console.log(\"Successfully disabled telemetry. \ud83d\udcc9\");", "  } else if (argv.enable) {\n    credentials.telemetryEnabled = true;\n    persistCredentials(credentials);\n    console.log(\"Successfully enabled telemetry. \ud83d\udcc8\");\n  } else {\n    console.log(\n      \"No flag specified. See `retool telemetry --help` for available flags.\"\n    );\n  }\n};\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/whoami.ts", "chunked_list": ["import { ArgumentsCamelCase, CommandModule } from \"yargs\";\n\nimport { getCredentials } from \"../utils/credentials\";\nimport { logDAU } from \"../utils/telemetry\";\n\nconst chalk = require(\"chalk\");\n\nconst command = \"whoami\";\nconst describe = \"Show the current Retool user.\";\nconst builder = {", "const describe = \"Show the current Retool user.\";\nconst builder = {\n  verbose: {\n    alias: \"v\",\n    describe: \"Print additional debugging information.\",\n  },\n};\nconst handler = function (argv: ArgumentsCamelCase) {\n  const credentials = getCredentials();\n  // fire and forget", "  const credentials = getCredentials();\n  // fire and forget\n  void logDAU(credentials);\n\n  if (credentials) {\n    if (\n      !process.env.DEBUG &&\n      !argv.verbose &&\n      credentials.firstName &&\n      credentials.lastName &&\n      credentials.email\n    ) {\n      console.log(\n        `Logged in to ${chalk.bold(credentials.origin)} as ${chalk.bold(\n          credentials.firstName\n        )} ${chalk.bold(credentials.lastName)} (${credentials.email}) \ud83d\ude4c\ud83c\udffb`\n      );\n    } else {\n      console.log(\"You are logged in with credentials:\");\n      console.log(credentials);\n    }\n  } else {\n    console.log(`No credentials found. To log in, run: \\`retool login\\``);\n  }\n};\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/db.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport { getAndVerifyCredentialsWithRetoolDB } from \"../utils/credentials\";\nimport { generateData, promptForDataType } from \"../utils/faker\";\nimport { getRequest, postRequest } from \"../utils/networking\";\nimport {\n  DBInfoPayload,\n  collectColumnNames,\n  collectTableName,\n  createTable,", "  collectTableName,\n  createTable,\n  createTableFromCSV,\n  deleteTable,\n  fetchAllTables,\n  generateDataWithGPT,\n  parseDBData,\n  verifyTableExists,\n} from \"../utils/table\";\nimport { logDAU } from \"../utils/telemetry\";", "} from \"../utils/table\";\nimport { logDAU } from \"../utils/telemetry\";\n\nconst chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\nconst ora = require(\"ora\");\n\nconst command = \"db\";\nconst describe = \"Interface with Retool DB.\";\nconst builder: CommandModule[\"builder\"] = {", "const describe = \"Interface with Retool DB.\";\nconst builder: CommandModule[\"builder\"] = {\n  list: {\n    alias: \"l\",\n    describe: \"List all tables in Retool DB.\",\n  },\n  create: {\n    alias: \"c\",\n    describe: `Create a new table.`,\n  },", "    describe: `Create a new table.`,\n  },\n  upload: {\n    alias: \"u\",\n    describe: `Upload a new table from a CSV file. Usage:\n    retool db -u <path-to-csv>`,\n    type: \"string\",\n    nargs: 1,\n  },\n  delete: {", "  },\n  delete: {\n    alias: \"d\",\n    describe: `Delete a table. Usage:\n    retool db -d <table-name>`,\n    type: \"array\",\n  },\n  gendata: {\n    alias: \"g\",\n    describe: `Generate data for a table interactively. Usage:", "    alias: \"g\",\n    describe: `Generate data for a table interactively. Usage:\n    retool db -g <table-name>`,\n    type: \"string\",\n    nargs: 1,\n  },\n  gpt: {\n    describe: `A modifier for gendata that uses GPT. Usage:\n    retool db --gendata <table-name> --gpt`,\n  },", "    retool db --gendata <table-name> --gpt`,\n  },\n};\nconst handler = async function (argv: any) {\n  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n  // fire and forget\n  void logDAU(credentials);\n\n  // Handle `retool db --upload <path-to-csv>`\n  if (argv.upload) {\n    await createTableFromCSV(argv.upload, credentials, true, true);\n  }\n\n  // Handle `retool db --create`", "  // Handle `retool db --upload <path-to-csv>`\n  if (argv.upload) {\n    await createTableFromCSV(argv.upload, credentials, true, true);\n  }\n\n  // Handle `retool db --create`\n  else if (argv.create) {\n    const tableName = await collectTableName();\n    const colNames = await collectColumnNames();\n    await createTable(tableName, colNames, undefined, credentials, true);\n  }\n\n  // Handle `retool db --list`", "  else if (argv.list) {\n    const tables = await fetchAllTables(credentials);\n    if (tables && tables.length > 0) {\n      tables.forEach((table) => {\n        console.log(table.name);\n      });\n    } else {\n      console.log(\"No tables found.\");\n    }\n  }\n\n  // Handle `retool db --delete <table-name>`", "  else if (argv.delete) {\n    const tableNames = argv.delete;\n    for (const tableName of tableNames) {\n      await deleteTable(tableName, credentials, true);\n    }\n  }\n\n  // Handle `retool db --gendata <table-name>`\n  else if (argv.gendata) {\n    // Verify that the provided db name exists.\n    const tableName = argv.gendata;\n    await verifyTableExists(tableName, credentials);\n\n    // Fetch Retool DB schema and data.\n    const spinner = ora(`Fetching ${tableName} metadata`).start();\n    const infoReq = getRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`\n    );\n    const dataReq = postRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/data`,\n      {\n        filters: [],\n        sorting: [],\n      }\n    );\n    const [infoRes, dataRes] = await Promise.all([infoReq, dataReq]);\n    spinner.stop();\n    const retoolDBInfo: DBInfoPayload = infoRes.data;\n    const { fields } = retoolDBInfo.tableInfo;\n    const retoolDBData: string = dataRes.data;\n\n    // Find the max primary key value.\n    // 1. Parse the table data.\n    const parsedDBData = parseDBData(retoolDBData);\n    // 2. Find the index of the primary key column.\n    const primaryKeyColIndex = parsedDBData[0].indexOf(\n      retoolDBInfo.tableInfo.primaryKeyColumn\n    );\n    // 3. Find the max value of the primary key column.\n    const primaryKeyMaxVal = Math.max(\n      ...parsedDBData\n        .slice(1)\n        .map((row) => row[primaryKeyColIndex])\n        .map((id) => parseInt(id)),\n      0\n    );\n\n    let generatedData: { fields: string[]; data: string[][] };\n\n    // Generate data using GPT.", "  else if (argv.gendata) {\n    // Verify that the provided db name exists.\n    const tableName = argv.gendata;\n    await verifyTableExists(tableName, credentials);\n\n    // Fetch Retool DB schema and data.\n    const spinner = ora(`Fetching ${tableName} metadata`).start();\n    const infoReq = getRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`\n    );\n    const dataReq = postRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/data`,\n      {\n        filters: [],\n        sorting: [],\n      }\n    );\n    const [infoRes, dataRes] = await Promise.all([infoReq, dataReq]);\n    spinner.stop();\n    const retoolDBInfo: DBInfoPayload = infoRes.data;\n    const { fields } = retoolDBInfo.tableInfo;\n    const retoolDBData: string = dataRes.data;\n\n    // Find the max primary key value.\n    // 1. Parse the table data.\n    const parsedDBData = parseDBData(retoolDBData);\n    // 2. Find the index of the primary key column.\n    const primaryKeyColIndex = parsedDBData[0].indexOf(\n      retoolDBInfo.tableInfo.primaryKeyColumn\n    );\n    // 3. Find the max value of the primary key column.\n    const primaryKeyMaxVal = Math.max(\n      ...parsedDBData\n        .slice(1)\n        .map((row) => row[primaryKeyColIndex])\n        .map((id) => parseInt(id)),\n      0\n    );\n\n    let generatedData: { fields: string[]; data: string[][] };\n\n    // Generate data using GPT.", "    if (argv.gpt) {\n      spinner.start(\"Generating data using GPT\");\n\n      const gptRes = await generateDataWithGPT(\n        retoolDBInfo,\n        fields,\n        primaryKeyMaxVal,\n        credentials,\n        true\n      );\n      //Shouldn't happen, generateDataWithGPT should exit on failure.", "      if (!gptRes) {\n        process.exit(1);\n      }\n      generatedData = gptRes;\n\n      spinner.stop();\n    }\n    // Generate data using faker.\n    else {\n      // Ask how many rows to generate.\n      const MAX_BATCH_SIZE = 2500;\n      const { rowCount } = await inquirer.prompt([\n        {\n          name: \"rowCount\",\n          message: \"How many rows to generate?\",\n          type: \"input\",\n        },\n      ]);", "      if (Number.isNaN(parseInt(rowCount))) {\n        console.log(`Error: Must provide a number.`);\n        return;\n      }\n      if (rowCount < 0) {\n        console.log(`Error: Cannot generate <1 rows.`);\n        return;\n      }\n      if (rowCount > MAX_BATCH_SIZE) {\n        console.log(\n          `Error: Cannot generate more than ${MAX_BATCH_SIZE} rows at a time.`\n        );\n        return;\n      }\n", "      if (rowCount > MAX_BATCH_SIZE) {\n        console.log(\n          `Error: Cannot generate more than ${MAX_BATCH_SIZE} rows at a time.`\n        );\n        return;\n      }\n\n      // Ask what type of data to generate for each column.\n      for (let i = 0; i < fields.length; i++) {\n        if (fields[i].name === retoolDBInfo.tableInfo.primaryKeyColumn)\n          continue;\n\n        fields[i].generatedColumnType = await promptForDataType(fields[i].name);\n      }\n\n      // Generate mock data.\n      generatedData = await generateData(\n        fields,\n        rowCount,\n        retoolDBInfo.tableInfo.primaryKeyColumn,\n        primaryKeyMaxVal\n      );\n    }\n\n    // Insert to Retool DB.\n    const bulkInsertRes = await postRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n      {\n        kind: \"BulkInsertIntoTable\",\n        tableName: tableName,\n        additions: generatedData,\n      }\n    );", "      for (let i = 0; i < fields.length; i++) {\n        if (fields[i].name === retoolDBInfo.tableInfo.primaryKeyColumn)\n          continue;\n\n        fields[i].generatedColumnType = await promptForDataType(fields[i].name);\n      }\n\n      // Generate mock data.\n      generatedData = await generateData(\n        fields,\n        rowCount,\n        retoolDBInfo.tableInfo.primaryKeyColumn,\n        primaryKeyMaxVal\n      );\n    }\n\n    // Insert to Retool DB.\n    const bulkInsertRes = await postRequest(\n      `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n      {\n        kind: \"BulkInsertIntoTable\",\n        tableName: tableName,\n        additions: generatedData,\n      }\n    );", "    if (bulkInsertRes.data.success) {\n      console.log(\"Successfully inserted data. \ud83e\udd18\ud83c\udffb\");\n      console.log(\n        `\\n${chalk.bold(\"View in browser:\")} ${\n          credentials.origin\n        }/resources/data/${\n          credentials.retoolDBUuid\n        }/${tableName}?env=production`\n      );\n    } else {\n      console.log(\"Error inserting data.\");\n      console.log(bulkInsertRes.data);\n    }\n  }\n\n  // No flag specified.\n  else {\n    console.log(\n      \"No flag specified. See `retool db --help` for available flags.\"\n    );\n  }\n};\n\nconst commandModule: CommandModule = {\n  command,\n  describe,\n  builder,\n  handler,\n};\n\nexport default commandModule;\n"]}
{"filename": "src/commands/signup.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\nimport { logSuccess } from \"./login\";\nimport { accessTokenFromCookies, xsrfTokenFromCookies } from \"../utils/cookies\";\nimport { doCredentialsExist, persistCredentials } from \"../utils/credentials\";\nimport { getRequest, postRequest } from \"../utils/networking\";\nimport { logDAU } from \"../utils/telemetry\";\nimport { isEmailValid } from \"../utils/validation\";\n\nconst axios = require(\"axios\");", "\nconst axios = require(\"axios\");\nconst inquirer = require(\"inquirer\");\nconst ora = require(\"ora\");\n\nconst command = \"signup\";\nconst describe = \"Create a Retool account.\";\nconst builder = {};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst handler = async function (argv: any) {", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst handler = async function (argv: any) {\n  // Ask user if they want to overwrite existing credentials.\n  if (doCredentialsExist()) {\n    const { overwrite } = await inquirer.prompt([\n      {\n        name: \"overwrite\",\n        message:\n          \"You're already logged in. Do you want to log out and create a new account?\",\n        type: \"confirm\",\n      },\n    ]);", "    if (!overwrite) {\n      return;\n    }\n  }\n\n  // Step 1: Collect a valid email/password.\n  let email, password, name, org;\n  while (!email) {\n    email = await collectEmail();\n  }\n  while (!password) {\n    password = await colllectPassword();\n  }\n\n  // Step 2: Call signup endpoint, get cookies.\n  const spinner = ora(\n    \"Verifying that the email and password are valid on the server\"\n  ).start();\n  const signupResponse = await postRequest(\n    `https://login.retool.com/api/signup`,\n    {\n      email,\n      password,\n      planKey: \"free\",\n    }\n  );\n  spinner.stop();\n\n  const accessToken = accessTokenFromCookies(\n    signupResponse.headers[\"set-cookie\"]\n  );\n  const xsrfToken = xsrfTokenFromCookies(signupResponse.headers[\"set-cookie\"]);", "  while (!password) {\n    password = await colllectPassword();\n  }\n\n  // Step 2: Call signup endpoint, get cookies.\n  const spinner = ora(\n    \"Verifying that the email and password are valid on the server\"\n  ).start();\n  const signupResponse = await postRequest(\n    `https://login.retool.com/api/signup`,\n    {\n      email,\n      password,\n      planKey: \"free\",\n    }\n  );\n  spinner.stop();\n\n  const accessToken = accessTokenFromCookies(\n    signupResponse.headers[\"set-cookie\"]\n  );\n  const xsrfToken = xsrfTokenFromCookies(signupResponse.headers[\"set-cookie\"]);", "  if (!accessToken || !xsrfToken) {\n    if (process.env.DEBUG) {\n      console.log(signupResponse);\n    }\n    console.log(\n      \"Error creating account, please try again or signup at https://login.retool.com/auth/signup?plan=free.\"\n    );\n    return;\n  }\n\n  axios.defaults.headers[\"x-xsrf-token\"] = xsrfToken;\n  axios.defaults.headers.cookie = `accessToken=${accessToken};`;\n\n  // Step 3: Collect a valid name/org.", "  while (!name) {\n    name = await collectName();\n  }\n  while (!org) {\n    org = await collectOrg();\n  }\n\n  // Step 4: Initialize organization.\n  await postRequest(\n    `https://login.retool.com/api/organization/admin/initializeOrganization`,\n    {\n      subdomain: org,\n    }\n  );\n\n  // Step 5: Persist credentials\n  const origin = `https://${org}.retool.com`;\n  const userRes = await getRequest(`${origin}/api/user`);\n  persistCredentials({\n    origin,\n    accessToken,\n    xsrf: xsrfToken,\n    firstName: userRes.data.user?.firstName,\n    lastName: userRes.data.user?.lastName,\n    email: userRes.data.user?.email,\n    telemetryEnabled: true,\n  });\n  logSuccess();\n  await logDAU();\n};\n", "async function collectEmail(): Promise<string | undefined> {\n  const { email } = await inquirer.prompt([\n    {\n      name: \"email\",\n      message: \"What is your email?\",\n      type: \"input\",\n    },\n  ]);\n  if (!isEmailValid(email)) {\n    console.log(\"Invalid email, try again.\");\n    return;\n  }\n  return email;\n}\n", "  if (!isEmailValid(email)) {\n    console.log(\"Invalid email, try again.\");\n    return;\n  }\n  return email;\n}\n\nasync function colllectPassword(): Promise<string | undefined> {\n  const { password } = await inquirer.prompt([\n    {\n      name: \"password\",\n      message: \"Please create a password (min 8 characters):\",\n      type: \"password\",\n    },\n  ]);\n  const { confirmedPassword } = await inquirer.prompt([\n    {\n      name: \"confirmedPassword\",\n      message: \"Please confirm password:\",\n      type: \"password\",\n    },\n  ]);", "  if (password.length < 8) {\n    console.log(\"Password must be at least 8 characters long, try again.\");\n    return;\n  }\n  if (password !== confirmedPassword) {\n    console.log(\"Passwords do not match, try again.\");\n    return;\n  }\n  return password;\n}\n", "async function collectName(): Promise<string | undefined> {\n  const { name } = await inquirer.prompt([\n    {\n      name: \"name\",\n      message: \"What is your first and last name?\",\n      type: \"input\",\n    },\n  ]);\n  if (!name || name.length === 0) {\n    console.log(\"Invalid name, try again.\");\n    return;\n  }\n  const parts = name.split(\" \");\n  const changeNameResponse = await postRequest(\n    `https://login.retool.com/api/user/changeName`,\n    {\n      firstName: parts[0],\n      lastName: parts[1],\n    },\n    false\n  );", "  if (!name || name.length === 0) {\n    console.log(\"Invalid name, try again.\");\n    return;\n  }\n  const parts = name.split(\" \");\n  const changeNameResponse = await postRequest(\n    `https://login.retool.com/api/user/changeName`,\n    {\n      firstName: parts[0],\n      lastName: parts[1],\n    },\n    false\n  );", "  if (!changeNameResponse) {\n    return;\n  }\n\n  return name;\n}\n\nasync function collectOrg(): Promise<string | undefined> {\n  let { org } = await inquirer.prompt([\n    {\n      name: \"org\",\n      message:\n        \"What is your organization name? Leave blank to generate a random name.\",\n      type: \"input\",\n    },\n  ]);", "  if (!org || org.length === 0) {\n    // Org must start with letter, append a random string after it.\n    // https://stackoverflow.com/a/8084248\n    org = \"z\" + (Math.random() + 1).toString(36).substring(2);\n  }\n\n  const checkSubdomainAvailabilityResponse = await getRequest(\n    `https://login.retool.com/api/organization/admin/checkSubdomainAvailability?subdomain=${org}`,\n    false\n  );\n", "  if (!checkSubdomainAvailabilityResponse.status) {\n    return;\n  }\n\n  return org;\n}\n\nconst commandModule: CommandModule = { command, describe, builder, handler };\nexport default commandModule;\n"]}
{"filename": "src/utils/faker.ts", "chunked_list": ["import { RetoolDBField } from \"./table\";\n\nconst inquirer = require(\"inquirer\");\nconst TreePrompt = require(\"inquirer-tree-prompt\");\n\n// Generate `rowCount` rows for each field in `fields`.\nexport async function generateData(\n  fields: Array<RetoolDBField>,\n  rowCount: number,\n  primaryKeyColumnName: string,\n  primaryKeyMaxVal: number\n): Promise<{\n  data: string[][]; // rows\n  fields: string[]; // column names\n}> {\n  const column_names = fields.map((field) => field.name);\n  const rows: string[][] = [];\n  // Init rows", "  for (let j = 0; j < rowCount; j++) {\n    rows.push([]);\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    for (let j = 0; j < rowCount; j++) {\n      // Handle primary key column.\n      if (fields[i].name === primaryKeyColumnName) {\n        rows[j].push((primaryKeyMaxVal + j + 1).toString());\n      } else {\n        rows[j].push(\n          await generateDataForColumnType(fields[i].generatedColumnType)\n        );\n      }\n    }\n  }\n\n  return {\n    data: rows,\n    fields: column_names,\n  };\n}\n\n// Each colType string is an option in `promptForDataType()`", "async function generateDataForColumnType(\n  colType: string | undefined\n): Promise<string> {\n  // Faker is slow, dynamically import it.\n  return import(\"@faker-js/faker/locale/en_US\").then(({ faker }) => {\n    if (colType === \"First Name\") {\n      return faker.person.firstName();\n    } else if (colType === \"Last Name\") {\n      return faker.person.lastName();\n    } else if (colType === \"Full Name\" || colType === \"Person\") {\n      return faker.person.fullName();", "    } else if (colType === \"Full Name\" || colType === \"Person\") {\n      return faker.person.fullName();\n    } else if (colType === \"Phone Number\") {\n      return faker.phone.number();\n    } else if (colType === \"Email\") {\n      return faker.internet.email();\n    } else if (colType === \"Birthdate\") {\n      return faker.date.birthdate().toString();\n    } else if (colType === \"Gender\") {\n      return faker.person.gender();\n    } else if (colType === \"Street Address\" || colType === \"Location\") {\n      return faker.location.streetAddress();", "    } else if (colType === \"Gender\") {\n      return faker.person.gender();\n    } else if (colType === \"Street Address\" || colType === \"Location\") {\n      return faker.location.streetAddress();\n    } else if (colType === \"City\") {\n      return faker.location.city();\n    } else if (colType === \"State\") {\n      return faker.location.state();\n    } else if (colType === \"Zip Code\") {\n      return faker.location.zipCode();\n    } else if (colType === \"Country\") {\n      return faker.location.country();", "    } else if (colType === \"Zip Code\") {\n      return faker.location.zipCode();\n    } else if (colType === \"Country\") {\n      return faker.location.country();\n    } else if (colType === \"Country Code\") {\n      return faker.location.countryCode();\n    } else if (colType === \"Timezone\") {\n      return faker.location.timeZone();\n    } else if (colType === \"Past\" || colType === \"Date\") {\n      return faker.date.past().toString();\n    } else if (colType === \"Future\") {\n      return faker.date.future().toString();", "    } else if (colType === \"Past\" || colType === \"Date\") {\n      return faker.date.past().toString();\n    } else if (colType === \"Future\") {\n      return faker.date.future().toString();\n    } else if (colType === \"Month\") {\n      return faker.date.month();\n    } else if (colType === \"Weekday\") {\n      return faker.date.weekday();\n    } else if (colType === \"Unix Timestamp\") {\n      return faker.date.past().getTime().toString();\n    } else if (colType === \"Number\" || colType === \"Random\") {\n      return faker.number.int(10000).toString();", "    } else if (colType === \"Unix Timestamp\") {\n      return faker.date.past().getTime().toString();\n    } else if (colType === \"Number\" || colType === \"Random\") {\n      return faker.number.int(10000).toString();\n    } else if (colType === \"String\") {\n      return faker.string.alpha(5);\n    } else if (colType === \"Boolean\") {\n      return faker.datatype.boolean().toString();\n    } else if (colType === \"Word\") {\n      return faker.word.words(1);\n    } else if (colType === \"Lorem Ipsum\") {\n      return faker.lorem.sentence(5);", "    } else if (colType === \"Word\") {\n      return faker.word.words(1);\n    } else if (colType === \"Lorem Ipsum\") {\n      return faker.lorem.sentence(5);\n    } else if (colType === \"Bitcoin Address\") {\n      return faker.finance.bitcoinAddress();\n    } else {\n      return faker.string.alpha(5);\n    }\n  });\n}\n\n// Each option should have a corresponding case in `generateDataForColumnType()`", "export async function promptForDataType(fieldName: string): Promise<string> {\n  inquirer.registerPrompt(\"tree\", TreePrompt);\n  const { generatedType } = await inquirer.prompt([\n    {\n      type: \"tree\",\n      name: \"generatedType\",\n      message: `What type of data to generate for ${fieldName}?`,\n      tree: [\n        {\n          name: \"Person\",\n          children: [\n            \"First Name\",\n            \"Last Name\",\n            \"Full Name\",\n            \"Phone Number\",\n            \"Email\",\n            \"Birthdate\",\n            \"Gender\",\n          ],\n        },\n        {\n          value: \"Location\",\n          children: [\n            \"Street Address\",\n            \"City\",\n            \"State\",\n            \"Zip Code\",\n            \"Country\",\n            \"Country Code\",\n            \"Timezone\",\n          ],\n        },\n        {\n          value: \"Date\",\n          children: [\"Past\", \"Future\", \"Month\", \"Weekday\", \"Unix Timestamp\"],\n        },\n        {\n          value: \"Random\",\n          children: [\n            \"Number\",\n            \"String\",\n            \"Boolean\",\n            \"Word\",\n            \"Lorem Ipsum\",\n            \"Bitcoin Address\",\n          ],\n        },\n      ],\n    },\n  ]);\n  console.log(generatedType);\n  return generatedType;\n}\n"]}
{"filename": "src/utils/table.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\";\n\nimport { parseDBData } from \"./table\";\n\ndescribe(\"parseDBData\", () => {\n  test(\"should transform data into expected format\", () => {\n    const input = `[\"col_1\",\"col_2\",\"col_3\"]\\n[\"val_1\",\"val_2\",\"val_3\"]`;\n    const expectedOutput = [[\"col_1\",\"col_2\",\"col_3\"],[\"val_1\",\"val_2\",\"val_3\"]];\n    expect(parseDBData(input)).toStrictEqual(expectedOutput);\n  });", "    expect(parseDBData(input)).toStrictEqual(expectedOutput);\n  });\n\n  test(\"should preserve brackets and \\\" in data\", () => {\n    const input = `[\"col[]_1\",\"col\"_2\",\"\"col_3]\"]`;\n    const expectedOutput = [[\"col[]_1\",`col\"_2`,`\"col_3]`]];\n    expect(parseDBData(input)).toStrictEqual(expectedOutput);\n  });\n});\n", "});\n"]}
{"filename": "src/utils/cookies.ts", "chunked_list": ["export function accessTokenFromCookies(cookies: string[]): string | undefined {\n  for (const cookie of cookies) {\n    // Matches everything between accessToken= and ;\n    const matches = cookie.match(/accessToken=([^;]+)/);\n    if (matches) {\n      // The first match includes \"accessToken=\", so we want the second match.\n      return matches[1];\n    }\n  }\n}\n", "export function xsrfTokenFromCookies(cookies: string[]): string | undefined {\n  for (const cookie of cookies) {\n    // Matches everything between xsrfToken= and ;\n    const matches = cookie.match(/xsrfToken=([^;]+)/);\n    if (matches) {\n      // The first match includes \"xsrfToken=\", so we want the second match.\n      return matches[1];\n    }\n  }\n}\n"]}
{"filename": "src/utils/puppeteer.ts", "chunked_list": ["import {\n  WorkflowTemplateType,\n  workflowTemplate,\n} from \"../resources/workflowTemplate\";\nimport { getCredentials } from \"../utils/credentials\";\n\n/*\n * CAUTION: Puppeteer import takes ~90ms. Prefer to dynamically import this file.\n */\nconst puppeteer = require(\"puppeteer\");", " */\nconst puppeteer = require(\"puppeteer\");\n\ndeclare global {\n  interface Window {\n    generateWorkflowFromTemplateData: any;\n  }\n}\n\n// https://stackoverflow.com/a/61304202\nconst waitTillHTMLRendered = async (page: any, timeout = 30000) => {\n  const checkDurationMsecs = 1000;\n  const maxChecks = timeout / checkDurationMsecs;\n  let lastHTMLSize = 0;\n  let checkCounts = 1;\n  let countStableSizeIterations = 0;\n  const minStableSizeIterations = 2;\n", "  while (checkCounts++ <= maxChecks) {\n    const html = await page.content();\n    const currentHTMLSize = html.length;\n\n    // Uncomment for debugging\n    // const bodyHTMLSize = await page.evaluate(\n    //   () => document.body.innerHTML.length\n    // );\n    // console.log(\n    //   \"last: \",\n    //   lastHTMLSize,\n    //   \" <> curr: \",\n    //   currentHTMLSize,\n    //   \" body html size: \",\n    //   bodyHTMLSize\n    // );\n", "    if (lastHTMLSize != 0 && currentHTMLSize == lastHTMLSize)\n      countStableSizeIterations++;\n    else countStableSizeIterations = 0; //reset the counter\n\n    // Page rendered fully\n    if (countStableSizeIterations >= minStableSizeIterations) {\n      break;\n    }\n\n    lastHTMLSize = currentHTMLSize;\n    await page.waitForTimeout(checkDurationMsecs);\n  }\n};\n\nexport const generateWorkflowMetadata = async (tableName: string) => {\n  const credentials = getCredentials();", "  if (!credentials) {\n    return;\n  }\n\n  try {\n    // Launch Puppeteer and navigate to subdomain.retool.com/workflows\n    const browser = await puppeteer.launch({\n      headless: \"new\",\n      // Uncomment this line to see the browser in action\n      // headless: false,\n    });\n    const page = await browser.newPage();\n    const domain = new URL(credentials.origin).hostname;\n    const cookies = [\n      {\n        domain,\n        name: \"accessToken\",\n        value: credentials.accessToken,\n      },\n      {\n        domain,\n        name: \"xsrfToken\",\n        value: credentials.xsrf,\n      },\n    ];\n    await page.setCookie(...cookies);\n    await page.goto(`${credentials.origin}/workflows`);\n    await waitTillHTMLRendered(page);\n\n    // Call window.generateWorkflowFromTemplateData() on the page\n    const generatedWorkflowMetadata = await page.evaluate(\n      (\n        tableName: string,\n        workflowTemplate: WorkflowTemplateType,\n        retoolDBUuid: string\n      ) => {\n        // Replaces instances of \"name_placeholder\" with the newly created table name\n        workflowTemplate.map((item) => {", "          if (item.pluginTemplate.template.tableName === \"name_placeholder\") {\n            item.pluginTemplate.template.tableName = `\\\"${tableName}\\\"`;\n          }\n          if (item.pluginTemplate.template.query.includes(\"name_placeholder\")) {\n            item.pluginTemplate.template.query =\n              item.pluginTemplate.template.query.replace(\n                \"name_placeholder\",\n                `\\\"${tableName}\\\"`\n              );\n          }\n\n          // Inject retool DB UUID", "          if (\n            item.block.pluginId === \"createQuery\" ||\n            item.block.pluginId === \"readQuery\" ||\n            item.block.pluginId === \"updateQuery\" ||\n            item.block.pluginId === \"destroyQuery\"\n          ) {\n            item.block.resourceName = retoolDBUuid;\n            item.pluginTemplate.resourceName = retoolDBUuid;\n          }\n        });\n\n        const payload = {\n          name: `${tableName} CRUD Workflow`,\n          templateData: workflowTemplate,\n          resources: [],\n        };\n\n        const workflow = window.generateWorkflowFromTemplateData(payload);\n        return workflow;\n      },\n      tableName,\n      workflowTemplate,\n      credentials.retoolDBUuid\n    );\n\n    await browser.close();\n    return generatedWorkflowMetadata;", "  } catch (error) {\n    console.error(\"Error:\", error);\n  }\n};\n"]}
{"filename": "src/utils/credentials.ts", "chunked_list": ["import { Entry } from \"@napi-rs/keyring\";\n\nimport { getRequest } from \"./networking\";\nimport { isAccessTokenValid, isOriginValid, isXsrfValid } from \"./validation\";\n\nconst axios = require(\"axios\");\nconst inquirer = require(\"inquirer\");\nconst ora = require(\"ora\");\n\nconst RETOOL_CLI_SERVICE_NAME = \"Retool CLI\";", "\nconst RETOOL_CLI_SERVICE_NAME = \"Retool CLI\";\nconst RETOOL_CLI_ACCOUNT_NAME = \"retool-cli-user\";\n\n/*\n * Credential management using keyring-rs. This is a cross-platform library\n * which uses the OS's native credential manager.\n * https://github.com/Brooooooklyn/keyring-node\n * https://github.com/hwchen/keyring-rs\n */", " * https://github.com/hwchen/keyring-rs\n */\n\nexport type Credentials = {\n  origin: string; // The 3 required properties are fetched during login.\n  xsrf: string;\n  accessToken: string;\n  gridId?: string; // The next 3 properties are fetched the first time user interacts with RetoolDB.\n  retoolDBUuid?: string;\n  hasConnectionString?: boolean;\n  firstName?: string; // The next 3 properties are sometimes fetched during login.\n  lastName?: string;\n  email?: string;\n  telemetryEnabled: boolean; // The next 2 properties control telemetry.\n  telemetryLastSent?: number;\n};\n\n// Legacy way of getting credentials.", "export async function askForCookies() {\n  let { origin } = await inquirer.prompt([\n    {\n      name: \"origin\",\n      message: \"What is your Retool origin? (e.g., https://my-org.retool.com).\",\n      type: \"input\",\n    },\n  ]);\n  //Check if last character is a slash. If so, remove it.\n  if (origin[origin.length - 1] === \"/\") {\n    origin = origin.slice(0, -1);\n  }", "  if (origin[origin.length - 1] === \"/\") {\n    origin = origin.slice(0, -1);\n  }\n  if (!isOriginValid(origin)) {\n    console.log(\"Error: Origin is invalid. Remember to include https://.\");\n    process.exit(1);\n  }\n  const { xsrf } = await inquirer.prompt([\n    {\n      name: \"xsrf\",\n      message:\n        \"What is your XSRF token? (e.g., 26725f72-8129-47f7-835a-cba0e5dbcfe6) \\n  Log into Retool, open cookies inspector.\\n  In Chrome, hit \u2318+\u2325+I (Mac) or Ctrl+Shift+I (Windows, Linux) to open dev tools.\\n  Application tab > your-org.retool.com in Cookies menu > double click cookie value and copy it.\",\n      type: \"input\",\n    },\n  ]);", "  if (!isXsrfValid(xsrf)) {\n    console.log(\"Error: XSRF token is invalid.\");\n    process.exit(1);\n  }\n  const { accessToken } = await inquirer.prompt([\n    {\n      name: \"accessToken\",\n      message: `What is your access token? It's also found in the cookies inspector.`,\n      type: \"input\",\n    },\n  ]);", "  if (!isAccessTokenValid(accessToken)) {\n    console.log(\"Error: Access token is invalid.\");\n    process.exit(1);\n  }\n\n  persistCredentials({\n    origin,\n    xsrf,\n    accessToken,\n    telemetryEnabled: true,\n  });\n  console.log(\"Successfully saved credentials.\");\n}\n", "export function persistCredentials(credentials: Credentials) {\n  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n  entry.setPassword(JSON.stringify(credentials));\n}\n\nexport function getCredentials(): Credentials | undefined {\n  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n  const password = entry.getPassword();\n  if (password) {\n    return JSON.parse(password);\n  }\n}\n", "  if (password) {\n    return JSON.parse(password);\n  }\n}\n\nexport function doCredentialsExist(): boolean {\n  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n  const password = entry.getPassword();\n  if (password) {\n    return true;\n  }\n  return false;\n}\n", "  if (password) {\n    return true;\n  }\n  return false;\n}\n\nexport function deleteCredentials() {\n  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n  entry.deletePassword();\n}\n\n// Fetch gridId and retoolDBUuid from Retool. Persist to keychain.", "async function fetchDBCredentials() {\n  const credentials = getCredentials();\n  if (!credentials) {\n    return;\n  }\n\n  // 1. Fetch all resources\n  const resources = await getRequest(`${credentials.origin}/api/resources`);\n\n  // 2. Filter down to Retool DB UUID\n  const retoolDBs = resources?.data?.resources?.filter(\n    (resource: any) => resource.displayName === \"retool_db\"\n  );", "  if (retoolDBs?.length < 1) {\n    console.log(\n      `\\nError: Retool DB not found. Create one at ${credentials.origin}/resources`\n    );\n    return;\n  }\n\n  const retoolDBUuid = retoolDBs[0].name;\n\n  // 3. Fetch Grid Info\n  const grid = await getRequest(\n    `${credentials.origin}/api/grid/retooldb/${retoolDBUuid}?env=production`\n  );\n  persistCredentials({\n    ...credentials,\n    retoolDBUuid,\n    gridId: grid?.data?.gridInfo?.id,\n    hasConnectionString: grid?.data?.gridInfo?.connectionString?.length > 0,\n  });\n}\n", "export async function getAndVerifyCredentialsWithRetoolDB() {\n  const spinner = ora(\"Verifying Retool DB credentials\").start();\n  let credentials = getCredentials();\n  if (!credentials) {\n    spinner.stop();\n    console.log(\n      `Error: No credentials found. To log in, run: \\`retool login\\``\n    );\n    process.exit(1);\n  }\n  axios.defaults.headers[\"x-xsrf-token\"] = credentials.xsrf;\n  axios.defaults.headers.cookie = `accessToken=${credentials.accessToken};`;", "  if (!credentials.gridId || !credentials.retoolDBUuid) {\n    await fetchDBCredentials();\n    credentials = getCredentials();\n    if (!credentials?.gridId || !credentials?.retoolDBUuid) {\n      spinner.stop();\n      console.log(`Error: No Retool DB credentials found.`);\n      process.exit(1);\n    }\n  }\n  spinner.stop();\n  return credentials;\n}\n", "export function getAndVerifyCredentials() {\n  const spinner = ora(\"Verifying Retool credentials\").start();\n  const credentials = getCredentials();\n  if (!credentials) {\n    spinner.stop();\n    console.log(\n      `Error: No credentials found. To log in, run: \\`retool login\\``\n    );\n    process.exit(1);\n  }\n  axios.defaults.headers[\"x-xsrf-token\"] = credentials.xsrf;\n  axios.defaults.headers.cookie = `accessToken=${credentials.accessToken};`;\n  spinner.stop();\n  return credentials;\n}\n"]}
{"filename": "src/utils/apps.ts", "chunked_list": ["import chalk from \"chalk\";\n\nimport { Credentials } from \"./credentials\";\nimport { getRequest, postRequest } from \"./networking\";\n\nconst inquirer = require(\"inquirer\");\nconst ora = require(\"ora\");\n\nexport type App = {\n  uuid: string;\n  name: string;\n  folderId: number;\n  id: string;\n  protected: boolean;\n  updatedAt: string;\n  createdAt: string;\n  isGlobalWidget: boolean; // is a module\n};\n", "export type App = {\n  uuid: string;\n  name: string;\n  folderId: number;\n  id: string;\n  protected: boolean;\n  updatedAt: string;\n  createdAt: string;\n  isGlobalWidget: boolean; // is a module\n};\n", "type Folder = {\n  id: number;\n  parentFolderId: number;\n  name: string;\n  systemFolder: boolean;\n  createdAt: string;\n  updatedAt: string;\n  folderType: string;\n  accessLevel: string;\n};\n", "export async function createApp(\n  appName: string,\n  credentials: Credentials\n): Promise<App | undefined> {\n  const spinner = ora(\"Creating App\").start();\n\n  const createAppResult = await postRequest(\n    `${credentials.origin}/api/pages/createPage`,\n    {\n      pageName: appName,\n      isGlobalWidget: false,\n      isMobileApp: false,\n      multiScreenMobileApp: false,\n    }\n  );\n  spinner.stop();\n\n  const { page } = createAppResult.data;", "  if (!page?.uuid) {\n    console.log(\"Error creating app.\");\n    console.log(createAppResult.data);\n    process.exit(1);\n  } else {\n    console.log(\"Successfully created an App. \ud83c\udf89\");\n    console.log(\n      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/editor/${\n        page.uuid\n      }`\n    );\n    return page;\n  }\n}\n", "export async function createAppForTable(\n  appName: string,\n  tableName: string,\n  columnName: string, //The column to use for search bar.\n  credentials: Credentials\n) {\n  const spinner = ora(\"Creating App\").start();\n\n  const createAppResult = await postRequest(\n    `${credentials.origin}/api/pages/autogeneratePage`,\n    {\n      appName,\n      resourceName: credentials.retoolDBUuid,\n      tableName,\n      columnName,\n    }\n  );\n  spinner.stop();\n\n  const { pageUuid } = createAppResult.data;", "  if (!pageUuid) {\n    console.log(\"Error creating app.\");\n    console.log(createAppResult.data);\n    process.exit(1);\n  } else {\n    console.log(\"Successfully created an App. \ud83c\udf89\");\n    console.log(\n      `${chalk.bold(\"View in browser:\")} ${\n        credentials.origin\n      }/editor/${pageUuid}`\n    );\n  }\n}\n", "export async function deleteApp(\n  appName: string,\n  credentials: Credentials,\n  confirmDeletion: boolean\n) {\n  if (confirmDeletion) {\n    const { confirm } = await inquirer.prompt([\n      {\n        name: \"confirm\",\n        message: `Are you sure you want to delete ${appName}?`,\n        type: \"confirm\",\n      },\n    ]);", "    if (!confirm) {\n      process.exit(0);\n    }\n  }\n\n  // Verify that the provided appName exists.\n  const { apps } = await getAppsAndFolders(credentials);\n  const app = apps?.filter((app) => {\n    if (app.name === appName) {\n      return app;\n    }\n  });", "    if (app.name === appName) {\n      return app;\n    }\n  });\n  if (app?.length != 1) {\n    console.log(`0 or >1 Apps named ${appName} found. \ud83d\ude13`);\n    process.exit(1);\n  }\n\n  // Delete the app.\n  const spinner = ora(\"Deleting App\").start();\n  await postRequest(`${credentials.origin}/api/folders/deletePage`, {\n    pageId: app[0].id,\n  });\n  spinner.stop();\n\n  console.log(`Deleted ${appName} app. \ud83d\uddd1\ufe0f`);\n}\n", "export async function getAppsAndFolders(\n  credentials: Credentials\n): Promise<{ apps?: Array<App>; folders?: Array<Folder> }> {\n  const spinner = ora(`Fetching all apps.`).start();\n\n  const fetchAppsResponse = await getRequest(\n    `${credentials.origin}/api/pages?mobileAppsOnly=false`\n  );\n\n  spinner.stop();\n\n  return {\n    apps: fetchAppsResponse?.data?.pages,\n    folders: fetchAppsResponse?.data?.folders,\n  };\n}\n", "export async function collectAppName(): Promise<string> {\n  const { appName } = await inquirer.prompt([\n    {\n      name: \"appName\",\n      message: \"App name?\",\n      type: \"input\",\n    },\n  ]);\n\n  if (appName.length === 0) {\n    console.log(\"Error: App name cannot be blank.\");\n    process.exit(1);\n  }\n\n  // Remove spaces from app name.\n  return appName.replace(/\\s/g, \"_\");\n}\n", "  if (appName.length === 0) {\n    console.log(\"Error: App name cannot be blank.\");\n    process.exit(1);\n  }\n\n  // Remove spaces from app name.\n  return appName.replace(/\\s/g, \"_\");\n}\n"]}
{"filename": "src/utils/playgroundQuery.ts", "chunked_list": ["import { Credentials } from \"./credentials\";\nimport { postRequest } from \"./networking\";\n\nexport type PlaygroundQuery = {\n  id: number;\n  uuid: string;\n  name: string;\n  description: string;\n  shared: boolean;\n  createdAt: string;\n  updatedAt: string;\n  organizationId: number;\n  ownerId: number;\n  saveId: number;\n  template: Record<string, any>;\n  resourceId: number;\n  resourceUuid: string;\n  adhocResourceType: string;\n};\n", "export async function createPlaygroundQuery(\n  resourceId: number,\n  credentials: Credentials,\n  queryName?: string\n): Promise<PlaygroundQuery> {\n  const createPlaygroundQueryResult = await postRequest(\n    `${credentials.origin}/api/playground`,\n    {\n      name: queryName || \"CLI Generated RPC Query\",\n      description: \"\",\n      shared: false,\n      resourceId,\n      data: {},\n    }\n  );\n\n  const { query } = createPlaygroundQueryResult.data;", "  if (!query?.uuid) {\n    console.log(\"Error creating playground query.\");\n    console.log(createPlaygroundQueryResult.data);\n    process.exit(1);\n  } else {\n    return query;\n  }\n}\n"]}
{"filename": "src/utils/workflows.ts", "chunked_list": ["import { Credentials } from \"./credentials\";\nimport { deleteRequest, getRequest, postRequest } from \"./networking\";\n\nconst chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\nconst ora = require(\"ora\");\n\nexport type Workflow = {\n  id: string; //UUID\n  name: string;\n  folderId: number;\n  isEnabled: boolean;\n  protected: boolean;\n  deployedBy: string;\n  lastDeployedAt: string;\n};\n", "type WorkflowFolder = {\n  id: number;\n  name: string;\n  systemFolder: boolean;\n  parentFolderId: number;\n  createdAt: string;\n  updatedAt: string;\n  folderType: string;\n  accessLevel: string;\n};\n", "export async function getWorkflowsAndFolders(\n  credentials: Credentials\n): Promise<{ workflows?: Array<Workflow>; folders?: Array<WorkflowFolder> }> {\n  const spinner = ora(\"Fetching Workflows\").start();\n  const fetchWorkflowsResponse = await getRequest(\n    `${credentials.origin}/api/workflow`\n  );\n  spinner.stop();\n\n  return {\n    workflows: fetchWorkflowsResponse?.data?.workflowsMetadata,\n    folders: fetchWorkflowsResponse?.data?.workflowFolders,\n  };\n}\n", "export async function deleteWorkflow(\n  workflowName: string,\n  credentials: Credentials,\n  confirmDeletion: boolean\n) {\n  if (confirmDeletion) {\n    const { confirm } = await inquirer.prompt([\n      {\n        name: \"confirm\",\n        message: `Are you sure you want to delete ${workflowName}?`,\n        type: \"confirm\",\n      },\n    ]);", "    if (!confirm) {\n      process.exit(0);\n    }\n  }\n\n  // Verify that the provided workflowName exists.\n  const { workflows } = await getWorkflowsAndFolders(credentials);\n  const workflow = workflows?.filter((workflow) => {\n    if (workflow.name === workflowName) {\n      return workflow;\n    }\n  });", "    if (workflow.name === workflowName) {\n      return workflow;\n    }\n  });\n  if (workflow?.length != 1) {\n    console.log(`0 or >1 Workflows named ${workflowName} found. \ud83d\ude13`);\n    process.exit(1);\n  }\n\n  // Delete the Workflow.\n  const spinner = ora(`Deleting ${workflowName}`).start();\n  await deleteRequest(`${credentials.origin}/api/workflow/${workflow[0].id}`);\n  spinner.stop();\n\n  console.log(`Deleted ${workflowName}. \ud83d\uddd1\ufe0f`);\n}\n\n// Generates a CRUD workflow for tableName from a template.", "export async function generateCRUDWorkflow(\n  tableName: string,\n  credentials: Credentials\n) {\n  let spinner = ora(\"Creating workflow\").start();\n\n  // Generate workflow metadata via puppeteer.\n  // Dynamic import b/c puppeteer is slow.\n  const workflowMeta = await import(\"./puppeteer\").then(\n    async ({ generateWorkflowMetadata }) => {\n      return await generateWorkflowMetadata(tableName);\n    }\n  );\n  const payload = {\n    name: workflowMeta.name,\n    crontab: workflowMeta.crontab,\n    fromTemplate: true,\n    templateData: workflowMeta.templateData,\n    timezone: workflowMeta.timezone,\n    triggerWebhooks: workflowMeta.triggerWebhooks,\n    blockData: workflowMeta.blockData,\n  };\n\n  // Create workflow.\n  const workflow = await postRequest(`${credentials.origin}/api/workflow`, {\n    ...payload,\n  });\n  spinner.stop();", "  if (workflow.data.id) {\n    console.log(\"Successfully created a workflow. \ud83c\udf89\");\n    console.log(\n      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/workflows/${\n        workflow.data.id\n      }`\n    );\n  } else {\n    console.log(\"Error creating workflow: \");\n    console.log(workflow);\n    return;\n  }\n\n  // Enable workflow.\n  spinner = ora(\"Deploying workflow\").start();\n  await postRequest(`${credentials.origin}/api/workflow/${workflow.data.id}`, {\n    isEnabled: true,\n  });\n  spinner.stop();\n  console.log(\"Successfully deployed a workflow. \ud83d\ude80\");", "  if (workflow.data.apiKey) {\n    const curlCommand = `curl -X POST --url \"https://api.retool.com/v1/workflows/${workflow.data.id}/startTrigger?workflowApiKey=${workflow.data.apiKey}\" --data '{\"type\":\"read\"}' -H 'Content-Type: application/json'`;\n    console.log(\n      `Retool Cloud users can ${chalk.bold(\"cURL it:\")} ${curlCommand}`\n    );\n  }\n}\n"]}
{"filename": "src/utils/validation.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\";\n\nimport {\n  isAccessTokenValid,\n  isEmailValid,\n  isOriginValid,\n  isXsrfValid,\n} from \"./validation\";\n\ndescribe(\"isEmailValid\", () => {", "\ndescribe(\"isEmailValid\", () => {\n  test(\"should return true for valid email\", () => {\n    expect(isEmailValid(\"hacker@retool.com\")).toBe(true);\n  });\n\n  test(\"should return false for missing @\", () => {\n    expect(isEmailValid(\"hackerretool.com\")).toBe(false);\n  });\n", "  });\n\n  test(\"should return false for missing user name\", () => {\n    expect(isEmailValid(\"@retool.com\")).toBe(false);\n  });\n\n  test(\"should return false for missing domain name\", () => {\n    expect(isEmailValid(\"hacker@com\")).toBe(false);\n  });\n", "  });\n\n  test(\"should return false for missing domain\", () => {\n    expect(isEmailValid(\"hacker@retool\")).toBe(false);\n  });\n});\n\ndescribe(\"isAccessTokenValid\", () => {\n  test(\"should return true for valid access token\", () => {\n    expect(", "  test(\"should return true for valid access token\", () => {\n    expect(\n      isAccessTokenValid(\n        \"eyJhbGciOiJIUzOOPiIsInR5cCI6IkpXVCJ9.eyJ4c3JmVG9rZW4iOiJjYzRjNmM3MC0wN2ZmLTQzNzktODI5ZS0wZDgyOWE1YjRiZTQiLCJ2ZXJzaW9uIjoiMS4yIiwiaWF0IjoxNjkwODIxMDUxfQ.-BjHNN9N9fDteokZmoIjdL0CbcZnkYKVCYwuzYugTzQ\"\n      )\n    ).toBe(true);\n  });\n\n  test(\"should return false for invalid access token\", () => {\n    expect(isAccessTokenValid(\"asdasdasd\")).toBe(false);", "  test(\"should return false for invalid access token\", () => {\n    expect(isAccessTokenValid(\"asdasdasd\")).toBe(false);\n  });\n});\n\ndescribe(\"isOriginValid\", () => {\n  test(\"should return true for valid https origin\", () => {\n    expect(isOriginValid(\"https://subdomain.retool.com\")).toBe(true);\n  });\n", "  });\n\n  test(\"should return true for valid http origin\", () => {\n    expect(isOriginValid(\"http://subdomain.retool.com\")).toBe(true);\n  });\n\n  test(\"should return false for missing http://\", () => {\n    expect(isOriginValid(\"hacker.retool.com\")).toBe(false);\n  });\n", "  });\n\n  test(\"should return false for ending with /\", () => {\n    expect(isOriginValid(\"http://hacker.retool.com/\")).toBe(false);\n  });\n});\n\ndescribe(\"isXsrfValid\", () => {\n  test(\"should return true for valid xsrf\", () => {\n    expect(isXsrfValid(\"cc4c6c70-07ff-4379-829e-0d829a5b4be4\")).toBe(true);", "  test(\"should return true for valid xsrf\", () => {\n    expect(isXsrfValid(\"cc4c6c70-07ff-4379-829e-0d829a5b4be4\")).toBe(true);\n  });\n\n  test(\"should return false for invalid xsrf\", () => {\n    expect(isXsrfValid(\"asdasdasd\")).toBe(false);\n  });\n});\n", ""]}
{"filename": "src/utils/table.ts", "chunked_list": ["import chalk from \"chalk\";\nimport ora from \"ora\";\nimport untildify from \"untildify\";\n\nimport { logConnectionStringDetails } from \"./connectionString\";\nimport { Credentials } from \"./credentials\";\nimport { getRequest, postRequest } from \"./networking\";\nimport { parseCSV } from \"../utils/csv\";\n\nconst fs = require(\"fs\");", "\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst inquirer = require(\"inquirer\");\n\ntype Table = {\n  name: string;\n};\n\ntype FieldMapping = Array<{\n  csvField: string;\n  dbField: string | undefined;\n  ignored: boolean;\n  dbType?: string;\n}>;\n", "type FieldMapping = Array<{\n  csvField: string;\n  dbField: string | undefined;\n  ignored: boolean;\n  dbType?: string;\n}>;\n\nexport type DBInfoPayload = {\n  success: true;\n  tableInfo: RetoolDBTableInfo;\n};\n", "// This type is returned from Retool table/info API endpoint.\nexport type RetoolDBTableInfo = {\n  fields: Array<RetoolDBField>;\n  primaryKeyColumn: string;\n  totalRowCount: number;\n};\n\n// A \"field\" is a single Retool DB column.\nexport type RetoolDBField = {\n  name: string;\n  type: any; //GridFieldType\n  columnDefault:\n    | {\n        kind: \"NoDefault\";\n      }\n    | {\n        kind: \"LiteralDefault\";\n        value: string;\n      }\n    | {\n        kind: \"ExpressionDefault\";\n        value: string;\n      };\n  generatedColumnType: string | undefined;\n};\n\n// Verify that the table exists in Retool DB, otherwise exit.", "export type RetoolDBField = {\n  name: string;\n  type: any; //GridFieldType\n  columnDefault:\n    | {\n        kind: \"NoDefault\";\n      }\n    | {\n        kind: \"LiteralDefault\";\n        value: string;\n      }\n    | {\n        kind: \"ExpressionDefault\";\n        value: string;\n      };\n  generatedColumnType: string | undefined;\n};\n\n// Verify that the table exists in Retool DB, otherwise exit.", "export async function verifyTableExists(\n  tableName: string,\n  credentials: Credentials\n) {\n  const tables = await fetchAllTables(credentials);\n  if (!tables?.map((table) => table.name).includes(tableName)) {\n    console.log(`No table named ${tableName} found in Retool DB. \ud83d\ude13`);\n    console.log(`Use \\`retool db --list\\` to list all tables.`);\n    console.log(`Use \\`retool db --create\\` to create a new table.`);\n    process.exit(1);\n  }\n}\n\n// Fetches all existing tables from a Retool DB.", "export async function fetchAllTables(\n  credentials: Credentials\n): Promise<Array<Table> | undefined> {\n  const spinner = ora(\"Fetching tables from Retool DB\").start();\n  const fetchDBsResponse = await getRequest(\n    `${credentials.origin}/api/grid/retooldb/${credentials.retoolDBUuid}?env=production`\n  );\n  spinner.stop();\n\n  if (fetchDBsResponse.data) {\n    const { tables } = fetchDBsResponse.data.gridInfo;\n    return tables;\n  }\n}\n\n// Fetches the schema of a table from a Retool DB. Assumes the table exists.", "  if (fetchDBsResponse.data) {\n    const { tables } = fetchDBsResponse.data.gridInfo;\n    return tables;\n  }\n}\n\n// Fetches the schema of a table from a Retool DB. Assumes the table exists.\nexport async function fetchTableInfo(\n  tableName: string,\n  credentials: Credentials\n): Promise<RetoolDBTableInfo | undefined> {\n  const spinner = ora(`Fetching ${tableName} metadata`).start();\n  const infoResponse = await getRequest(\n    `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`\n  );\n  spinner.stop();\n\n  const { tableInfo } = infoResponse.data;", "  if (tableInfo) {\n    return tableInfo;\n  }\n}\n\nexport async function deleteTable(\n  tableName: string,\n  credentials: Credentials,\n  confirmDeletion: boolean\n) {\n  // Verify that the provided table name exists.\n  await verifyTableExists(tableName, credentials);\n", "  if (confirmDeletion) {\n    const { confirm } = await inquirer.prompt([\n      {\n        name: \"confirm\",\n        message: `Are you sure you want to delete the ${tableName} table?`,\n        type: \"confirm\",\n      },\n    ]);\n    if (!confirm) {\n      process.exit(0);\n    }\n  }\n\n  // Delete the table.\n  const spinner = ora(`Deleting ${tableName}`).start();\n  await postRequest(\n    `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n    {\n      kind: \"DeleteTable\",\n      payload: {\n        table: tableName,\n      },\n    }\n  );\n  spinner.stop();\n\n  console.log(`Deleted ${tableName} table. \ud83d\uddd1\ufe0f`);\n}\n", "    if (!confirm) {\n      process.exit(0);\n    }\n  }\n\n  // Delete the table.\n  const spinner = ora(`Deleting ${tableName}`).start();\n  await postRequest(\n    `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n    {\n      kind: \"DeleteTable\",\n      payload: {\n        table: tableName,\n      },\n    }\n  );\n  spinner.stop();\n\n  console.log(`Deleted ${tableName} table. \ud83d\uddd1\ufe0f`);\n}\n", "export async function createTable(\n  tableName: string,\n  headers: string[],\n  rows: string[][] | undefined,\n  credentials: Credentials,\n  printConnectionString: boolean\n) {\n  const spinner = ora(\"Uploading Table\").start();\n  const fieldMapping: FieldMapping = headers.map((header) => ({\n    csvField: header,\n    dbField: header,\n    ignored: false,\n  }));\n\n  // See NewTable.tsx if implementing more complex logic.\n  const payload = {\n    kind: \"CreateTable\",\n    payload: {\n      name: tableName,\n      fieldMapping,\n      data: rows,\n      allowSchemaEditOverride: true,\n      primaryKey: {\n        kind: headers.includes(\"id\") ? \"CustomColumn\" : \"IntegerAutoIncrement\",\n        name: \"id\",\n      },\n    },\n  };\n  const createTableResult = await postRequest(\n    `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n    {\n      ...payload,\n    }\n  );\n  spinner.stop();\n", "  if (!createTableResult.data.success) {\n    console.log(\"Error creating table in RetoolDB.\");\n    console.log(createTableResult.data);\n    process.exit(1);\n  } else {\n    console.log(\n      `Successfully created a table named ${tableName} in RetoolDB. \ud83c\udf89`\n    );\n    if (printConnectionString) {\n      console.log(\"\");\n    }\n    console.log(\n      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/resources/data/${\n        credentials.retoolDBUuid\n      }/${tableName}?env=production`\n    );", "    if (printConnectionString) {\n      console.log(\"\");\n    }\n    console.log(\n      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/resources/data/${\n        credentials.retoolDBUuid\n      }/${tableName}?env=production`\n    );\n    if (credentials.hasConnectionString && printConnectionString) {\n      await logConnectionStringDetails();\n    }\n  }\n}\n", "    if (credentials.hasConnectionString && printConnectionString) {\n      await logConnectionStringDetails();\n    }\n  }\n}\n\nexport async function createTableFromCSV(\n  csvFilePath: string,\n  credentials: Credentials,\n  printConnectionString: boolean,\n  promptForTableName: boolean\n): Promise<{\n  tableName: string;\n  colNames: string[];\n}> {\n  const filePath = untildify(csvFilePath);\n  // Verify file exists, is a csv, and is < 18MB.", "  if (\n    !fs.existsSync(filePath) ||\n    !filePath.endsWith(\".csv\") ||\n    fs.statSync(filePath).size > 18000000\n  ) {\n    console.log(\"The file does not exist, is not a CSV, or is > 18MB.\");\n    process.exit(1);\n  }\n\n  //Default to csv filename if no table name is provided.\n  let tableName = path.basename(filePath).slice(0, -4);", "  if (promptForTableName) {\n    const { inputName } = await inquirer.prompt([\n      {\n        name: \"inputName\",\n        message: \"Table name? If blank, defaults to CSV filename.\",\n        type: \"input\",\n      },\n    ]);\n    if (inputName.length > 0) {\n      tableName = inputName;\n    }\n  }\n  // Remove spaces from table name.\n  tableName = tableName.replace(/\\s/g, \"_\");\n\n  const spinner = ora(\"Parsing CSV\").start();\n  const parseResult = await parseCSV(filePath);\n  spinner.stop();", "    if (inputName.length > 0) {\n      tableName = inputName;\n    }\n  }\n  // Remove spaces from table name.\n  tableName = tableName.replace(/\\s/g, \"_\");\n\n  const spinner = ora(\"Parsing CSV\").start();\n  const parseResult = await parseCSV(filePath);\n  spinner.stop();\n  if (!parseResult.success) {\n    console.log(\"Failed to parse CSV, error:\");\n    console.error(parseResult.error);\n    process.exit(1);\n  }\n\n  const { headers, rows } = parseResult;\n  await createTable(\n    tableName,\n    headers,\n    rows,\n    credentials,\n    printConnectionString\n  );\n  return {\n    tableName,\n    colNames: headers,\n  };\n}\n\n// data param is in format:\n// [\"col_1\",\"col_2\",\"col_3\"]\n// [\"val_1\",\"val_2\",\"val_3\"]\n// transform to:\n// [[\"col_1\",\"col_2\",\"col_3\"],[\"val_1\",\"val_2\",\"val_3\"]]", "  if (!parseResult.success) {\n    console.log(\"Failed to parse CSV, error:\");\n    console.error(parseResult.error);\n    process.exit(1);\n  }\n\n  const { headers, rows } = parseResult;\n  await createTable(\n    tableName,\n    headers,\n    rows,\n    credentials,\n    printConnectionString\n  );\n  return {\n    tableName,\n    colNames: headers,\n  };\n}\n\n// data param is in format:\n// [\"col_1\",\"col_2\",\"col_3\"]\n// [\"val_1\",\"val_2\",\"val_3\"]\n// transform to:\n// [[\"col_1\",\"col_2\",\"col_3\"],[\"val_1\",\"val_2\",\"val_3\"]]", "export function parseDBData(data: string): string[][] {\n  try {\n    const rows = data.trim().split(\"\\n\");\n    rows.forEach(\n      (row, index, arr) => (arr[index] = row.slice(1, -1)) // Remove [] brackets.\n    );\n    const parsedRows: string[][] = [];\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i].split(\",\");\n      row.forEach(\n        (val, index, arr) => (arr[index] = val.slice(1, -1)) // Remove \"\".\n      );\n      parsedRows.push(row);\n    }\n    return parsedRows;", "  } catch (e) {\n    console.log(\"Error parsing table data.\");\n    console.log(e);\n    process.exit(1);\n  }\n}\n\nexport async function generateDataWithGPT(\n  retoolDBInfo: DBInfoPayload,\n  fields: RetoolDBField[],\n  primaryKeyMaxVal: number,\n  credentials: Credentials,\n  exitOnFailure: boolean\n): Promise<\n  | {\n      fields: string[];\n      data: string[][];\n    }\n  | undefined\n> {\n  const genDataRes: {\n    data: {\n      data: string[][];\n    };\n  } = await postRequest(\n    `${credentials.origin}/api/grid/retooldb/generateData`,\n    {\n      fields: retoolDBInfo.tableInfo.fields.map((field) => {\n        return {\n          fieldName: field.name,\n          fieldType: field.type,\n          isPrimaryKey: field.name === retoolDBInfo.tableInfo.primaryKeyColumn,\n        };\n      }),\n    },\n    exitOnFailure\n  );\n\n  const colNames = fields.map((field) => field.name);\n  const generatedRows: string[][] = [];", "  if (!genDataRes || colNames.length !== genDataRes?.data?.data[0]?.length) {\n    if (exitOnFailure) {\n      console.log(\"Error: GPT did not generate data with correct schema.\");\n      process.exit(1);\n    } else {\n      return;\n    }\n  }\n\n  // GPT does not generate primary keys correctly.\n  // Generate them manually by adding the max primary key value to row #.", "  for (let i = 0; i < genDataRes.data.data.length; i++) {\n    const row = genDataRes.data.data[i];\n    for (let j = 0; j < row.length; j++) {\n      if (colNames[j] === retoolDBInfo.tableInfo.primaryKeyColumn) {\n        row[j] = (primaryKeyMaxVal + i + 1).toString();\n      }\n    }\n    generatedRows.push(row);\n  }\n  return {\n    fields: colNames,\n    data: generatedRows,\n  };\n}\n", "export async function collectTableName(): Promise<string> {\n  const { tableName } = await inquirer.prompt([\n    {\n      name: \"tableName\",\n      message: \"Table name?\",\n      type: \"input\",\n    },\n  ]);\n\n  if (tableName.length === 0) {\n    console.log(\"Error: Table name cannot be blank.\");\n    process.exit(1);\n  }\n\n  // Remove spaces from table name.\n  return tableName.replace(/\\s/g, \"_\");\n}\n", "  if (tableName.length === 0) {\n    console.log(\"Error: Table name cannot be blank.\");\n    process.exit(1);\n  }\n\n  // Remove spaces from table name.\n  return tableName.replace(/\\s/g, \"_\");\n}\n\nexport async function collectColumnNames(): Promise<string[]> {\n  const columnNames: string[] = [];\n  let columnName = await collectColumnName();", "export async function collectColumnNames(): Promise<string[]> {\n  const columnNames: string[] = [];\n  let columnName = await collectColumnName();\n  while (columnName.length > 0) {\n    columnNames.push(columnName);\n    columnName = await collectColumnName();\n  }\n  return columnNames;\n}\n\nasync function collectColumnName(): Promise<string> {\n  const { columnName } = await inquirer.prompt([\n    {\n      name: \"columnName\",\n      message: \"Column name? Leave blank to finish.\",\n      type: \"input\",\n    },\n  ]);\n\n  // Remove spaces from column name.\n  return columnName.replace(/\\s/g, \"_\");\n}\n", "async function collectColumnName(): Promise<string> {\n  const { columnName } = await inquirer.prompt([\n    {\n      name: \"columnName\",\n      message: \"Column name? Leave blank to finish.\",\n      type: \"input\",\n    },\n  ]);\n\n  // Remove spaces from column name.\n  return columnName.replace(/\\s/g, \"_\");\n}\n"]}
{"filename": "src/utils/csv.ts", "chunked_list": ["const fs = require(\"fs\");\n\nconst csvParser = require(\"csv-parser\");\n\nexport type ParseResult =\n  | {\n      success: true;\n      headers: string[];\n      rows: string[][];\n    }\n  | { success: false; error: string };\n", "export async function parseCSV(csvFile: string): Promise<ParseResult> {\n  return new Promise<ParseResult>((resolve) => {\n    const rows: string[][] = [];\n    let headers: string[] = [];\n    let firstRow = true;\n\n    fs.createReadStream(csvFile)\n      .pipe(\n        csvParser({\n          skipEmptyLines: true, // Doesn't seem to work\n        })\n      )\n      .on(\"error\", (error: Error) => {\n        resolve({ success: false, error: error.message });\n      })\n      .on(\"data\", (row: any) => {", "        if (Object.keys(row).length > 0) {\n          if (firstRow) {\n            headers = Object.keys(row);\n            firstRow = false;\n          }\n          rows.push(Object.values(row));\n        }\n      })\n      .on(\"end\", () => {\n        resolve({ success: true, headers, rows });\n      });\n  });\n}\n"]}
{"filename": "src/utils/cookies.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\";\n\nimport { accessTokenFromCookies, xsrfTokenFromCookies } from \"./cookies\";\n\nconst cookies = [\n    \"accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVPL8.eyJ4c3JmVG9rZW4iOiI0NWQ1ZmQ0MC00ODI5LTQ0ZmYtOWViYy1mYzk0ZGE1ZDkzN2MiLCJ2ZXJzaW9uIjoiMS4yIiwiaWF0IjoxNjkwOTEwODcwfQ.rjtgus6ml0D3wNG7QRZvSEtU0BDU5bGlJZvPc-PU-o0; Max-Age=604800; Path=/; Expires=Tue, 08 Aug 2023 17:27:50 GMT; HttpOnly; Secure; SameSite=None\",\n    \"xsrfToken=45d5fd40-4829-44ff-9ebc-fc94da5d654w; Max-Age=604800; Path=/; Expires=Tue, 08 Aug 2023 17:27:50 GMT; Secure; SameSite=None\",\n    \"xsrfTokenSameSite=45d5fd40-4829-44ff-9ebc-fc94da5d654w; Max-Age=604800; Path=/; Expires=Tue, 08 Aug 2023 17:27:50 GMT; HttpOnly; Secure; SameSite=Strict\",\n]\n", "]\n\ndescribe(\"accessTokenFromCookies\", () => {\n    test(\"should return cookie from valid response\", () => {\n      expect(accessTokenFromCookies(cookies)).toBe(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVPL8.eyJ4c3JmVG9rZW4iOiI0NWQ1ZmQ0MC00ODI5LTQ0ZmYtOWViYy1mYzk0ZGE1ZDkzN2MiLCJ2ZXJzaW9uIjoiMS4yIiwiaWF0IjoxNjkwOTEwODcwfQ.rjtgus6ml0D3wNG7QRZvSEtU0BDU5bGlJZvPc-PU-o0\");\n    });\n\n    test(\"should return undefined from invalid response\", () => {\n        expect(accessTokenFromCookies([])).toBe(undefined);\n    });", "        expect(accessTokenFromCookies([])).toBe(undefined);\n    });\n});\n\ndescribe (\"xsrfTokenFromCookies\", () => {\n    test(\"should return cookie from valid response\", () => {\n        expect(xsrfTokenFromCookies(cookies)).toBe(\"45d5fd40-4829-44ff-9ebc-fc94da5d654w\");\n    });\n\n    test(\"should return undefined from invalid response\", () => {", "\n    test(\"should return undefined from invalid response\", () => {\n        expect(xsrfTokenFromCookies([])).toBe(undefined);\n    });\n});\n"]}
{"filename": "src/utils/fileSave.ts", "chunked_list": ["import * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport * as tar from \"tar\";\n\nconst axios = require(\"axios\");\nconst inquirer = require(\"inquirer\");\n\n// url should be a tarfile link like https://api.github.com/repos/tryretool/retool-examples/tarball/main\n// subfolderPath should be a path to a subfolder within the tarfile, e.g. hello_world/typescript", "// url should be a tarfile link like https://api.github.com/repos/tryretool/retool-examples/tarball/main\n// subfolderPath should be a path to a subfolder within the tarfile, e.g. hello_world/typescript\n// destinationPath should be a path to a folder where the contents of the github subfolder will be extracted\nexport async function downloadGithubSubfolder(\n  githubUrl: string,\n  subfolderPath: string,\n  destinationPath: string\n) {\n  try {\n    const url = `${githubUrl}?path=${subfolderPath}`;\n    const response = await axios.get(url, { responseType: \"arraybuffer\" });\n\n    // Delete the directory if it already exists", "  try {\n    const url = `${githubUrl}?path=${subfolderPath}`;\n    const response = await axios.get(url, { responseType: \"arraybuffer\" });\n\n    // Delete the directory if it already exists\n    if (fs.existsSync(destinationPath)) {\n      const { proceedWithDirectoryCreation } = (await inquirer.prompt([\n        {\n          name: \"proceedWithDirectoryCreation\",\n          message:\n            \"It looks like this directory already exists, can we delete it and continue? (Y/N)\",\n          type: \"input\",\n        },\n      ])) as { proceedWithDirectoryCreation: string };", "      if (proceedWithDirectoryCreation.toLowerCase() !== \"y\") {\n        console.log(\"Aborting...\");\n        process.exit(1);\n      }\n      await fs.promises.rm(destinationPath, { recursive: true });\n    }\n\n    fs.mkdirSync(destinationPath, { recursive: true });\n\n    const tarballPath = path.join(destinationPath, \"tarball.tar.gz\");\n    fs.writeFileSync(tarballPath, response.data);\n\n    await tar.x({\n      file: tarballPath,\n      cwd: destinationPath,\n      strip: subfolderPath.split(\"/\").length + 1, // remove the top-level directories\n    });\n\n    fs.unlinkSync(tarballPath);", "  } catch (error: any) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\nexport function saveEnvVariablesToFile(\n  envVariables: Record<string, string>,\n  filePath: string\n) {\n  try {\n    const envContent = Object.entries(envVariables)\n      .map(([key, value]) => `${key}=${value}`)\n      .join(\"\\n\");\n\n    fs.writeFileSync(filePath, envContent);", "  try {\n    const envContent = Object.entries(envVariables)\n      .map(([key, value]) => `${key}=${value}`)\n      .join(\"\\n\");\n\n    fs.writeFileSync(filePath, envContent);\n  } catch (error: any) {\n    console.error(\"Error saving environment variables:\", error.message);\n  }\n}\n"]}
{"filename": "src/utils/telemetry.ts", "chunked_list": ["import { Credentials, getCredentials, persistCredentials } from \"./credentials\";\nimport { postRequest } from \"./networking\";\n// @ts-ignore\nimport { version } from \"../../package.json\";\n\nexport async function logDAU(\n  credentials?: Credentials,\n  persistCreds = true\n): Promise<boolean> {\n  credentials = credentials || getCredentials();\n  const twelveHours = 12 * 60 * 60 * 1000;\n\n  // Don't send telemetry if user has opted out or if we've already sent telemetry in the last 12 hours.", "  if (\n    !credentials ||\n    credentials.telemetryEnabled !== true ||\n    (credentials.telemetryLastSent &&\n      Date.now() - credentials.telemetryLastSent < twelveHours)\n  ) {\n    return false;\n  }\n\n  const payload = {\n    \"CLI Version\": version,\n    email: credentials.email,\n    origin: credentials.origin,\n    os: process.platform,\n  };\n\n  // Send a POST request to Retool's telemetry endpoint.\n  const res = await postRequest(`https://p.retool.com/v2/p`, {\n    event: \"CLI DAU\",\n    properties: payload,\n  });\n", "  if (res.status === 200) {\n    // Update the last time we sent telemetry.\n    credentials.telemetryLastSent = Date.now();\n    if (persistCreds) {\n      persistCredentials(credentials);\n    }\n    return true;\n  }\n\n  return false;\n}\n"]}
{"filename": "src/utils/validation.ts", "chunked_list": ["/* eslint-disable */\nconst emailRegex =\n  /^[-!#$%&'*+\\/0-9=?A-Z^_a-z{|}~](\\.?[-!#$%&'*+\\/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\\.?[a-zA-Z0-9])*\\.[a-zA-Z](-?[a-zA-Z0-9])+$/;\n/* eslint-enable */\n\n//https://stackoverflow.com/questions/52456065/how-to-format-and-validate-email-node-js\nexport function isEmailValid(email: string) {\n  if (!email) return false;\n  if (email.length > 254) return false;\n  if (!emailRegex.test(email)) return false;\n\n  // Further checking of some things regex can't handle\n  const parts = email.split(\"@\");", "  if (email.length > 254) return false;\n  if (!emailRegex.test(email)) return false;\n\n  // Further checking of some things regex can't handle\n  const parts = email.split(\"@\");\n  if (parts[0].length > 64) return false;\n\n  const domainParts = parts[1].split(\".\");\n  if (\n    domainParts.some(function (part) {\n      return part.length > 63;\n    })\n  )\n    return false;\n\n  return true;\n}\n", "  if (\n    domainParts.some(function (part) {\n      return part.length > 63;\n    })\n  )\n    return false;\n\n  return true;\n}\n\nexport function isOriginValid(origin: string) {\n  // https://www.regextester.com/23\n  const hostnameRegEx =\n    /^(https?:\\/\\/)(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;", "export function isOriginValid(origin: string) {\n  // https://www.regextester.com/23\n  const hostnameRegEx =\n    /^(https?:\\/\\/)(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n  if (origin.match(hostnameRegEx)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isXsrfValid(xsrf: string) {\n  // https://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid\n  const uuidRegEx =\n    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;", "export function isXsrfValid(xsrf: string) {\n  // https://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid\n  const uuidRegEx =\n    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;\n  if (xsrf.match(uuidRegEx)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isAccessTokenValid(accessToken: string) {\n  // https://stackoverflow.com/questions/61802832/regex-to-match-jwt\n  const jwtRegEx = /^[\\w-]+\\.[\\w-]+\\.[\\w-]+$/;", "export function isAccessTokenValid(accessToken: string) {\n  // https://stackoverflow.com/questions/61802832/regex-to-match-jwt\n  const jwtRegEx = /^[\\w-]+\\.[\\w-]+\\.[\\w-]+$/;\n  if (accessToken.match(jwtRegEx)) {\n    return true;\n  }\n  return false;\n}\n"]}
{"filename": "src/utils/telemetry.test.ts", "chunked_list": ["import { describe, expect, jest, test } from \"@jest/globals\";\nimport axios from \"axios\";\n\nimport { logDAU } from \"./telemetry\";\n\njest.mock(\"axios\");\n\ndescribe(\"telemetry\", () => {\n  test(\"should not log anything if telemetryEnabled is false \", async () => {\n    const creds = {", "  test(\"should not log anything if telemetryEnabled is false \", async () => {\n    const creds = {\n      origin: \"\",\n      xsrf: \"\",\n      accessToken: \"\",\n      telemetryEnabled: false,\n    };\n    expect(await logDAU(creds, false)).toBe(false);\n  });\n", "  });\n\n  test(\"should not log anything if telemetry was sent 1 minute ago \", async () => {\n    const creds = {\n      origin: \"\",\n      xsrf: \"\",\n      accessToken: \"\",\n      telemetryEnabled: true,\n      telemetryLastSent: Date.now() - 60 * 1000,\n    };", "      telemetryLastSent: Date.now() - 60 * 1000,\n    };\n    expect(await logDAU(creds, false)).toBe(false);\n  });\n\n  test(\"should not log anything if telemetry was sent 11 hours ago \", async () => {\n    const creds = {\n      origin: \"\",\n      xsrf: \"\",\n      accessToken: \"\",", "      xsrf: \"\",\n      accessToken: \"\",\n      telemetryEnabled: true,\n      telemetryLastSent: Date.now() - 11 * 60 * 60 * 1000,\n    };\n    expect(await logDAU(creds, false)).toBe(false);\n  });\n\n  test(\"should log telemetry if telemetryEnabled is true and telemetryLastSent is undefined\", async () => {\n    const creds = {", "  test(\"should log telemetry if telemetryEnabled is true and telemetryLastSent is undefined\", async () => {\n    const creds = {\n      origin: \"\",\n      xsrf: \"\",\n      accessToken: \"\",\n      telemetryEnabled: true,\n    };\n    // @ts-ignore\n    axios.post = jest.fn().mockReturnValue({ status: 200 });\n    expect(await logDAU(creds, false)).toBe(true);", "    axios.post = jest.fn().mockReturnValue({ status: 200 });\n    expect(await logDAU(creds, false)).toBe(true);\n  });\n\n  test(\"should log telemetry if telemetryEnabled is true and telemetryLastSent is more than 12 hours ago\", async () => {\n    const creds = {\n      origin: \"\",\n      xsrf: \"\",\n      accessToken: \"\",\n      telemetryEnabled: true,", "      accessToken: \"\",\n      telemetryEnabled: true,\n      telemetryLastSent: Date.now() - 13 * 60 * 60 * 1000,\n    };\n    // @ts-ignore\n    axios.post = jest.fn().mockReturnValue({ status: 200 });\n    expect(await logDAU(creds, false)).toBe(true);\n  });\n});\n", "});\n"]}
{"filename": "src/utils/date.ts", "chunked_list": ["import type { DateTimeFormatOptions } from \"intl\";\n\n// 07/19/2023, 09:07:58 PM\nexport const dateOptions: DateTimeFormatOptions = {\n  month: \"2-digit\",\n  day: \"2-digit\",\n  year: \"numeric\",\n  hour: \"2-digit\",\n  minute: \"2-digit\",\n};", "  minute: \"2-digit\",\n};\n"]}
{"filename": "src/utils/resources.ts", "chunked_list": ["import { Credentials } from \"./credentials\";\nimport { getRequest, postRequest } from \"./networking\";\n\nexport type ResourceByEnv = Record<string, Resource>;\n\nexport type Resource = {\n  displayName: string;\n  id: number;\n  name: string;\n  type: string;\n  environment: string;\n  environmentId: string;\n  uuid: string;\n  organizationId: number;\n  resourceFolderId: number;\n};\n", "export async function getResourceByName(\n  resourceName: string,\n  credentials: Credentials\n): Promise<ResourceByEnv> {\n  const getResourceResult = await getRequest(\n    `${credentials.origin}/api/resources/names/${resourceName}`\n  );\n\n  const { resourceByEnv } = getResourceResult.data;\n  if (!resourceByEnv) {\n    console.log(\"Error finding resource by that id.\");\n    console.log(getResourceResult.data);\n    process.exit(1);\n  } else {\n    return resourceByEnv;\n  }\n}\n", "  if (!resourceByEnv) {\n    console.log(\"Error finding resource by that id.\");\n    console.log(getResourceResult.data);\n    process.exit(1);\n  } else {\n    return resourceByEnv;\n  }\n}\n\nexport async function createResource({\n  resourceType,\n  credentials,\n  displayName,\n  resourceFolderId,\n  resourceOptions,\n}: {\n  resourceType: string;\n  credentials: Credentials;\n  displayName?: string;\n  resourceFolderId?: number;\n  resourceOptions?: Record<string, any>;\n}): Promise<Resource> {\n  const createResourceResult = await postRequest(\n    `${credentials.origin}/api/resources/`,\n    {\n      type: resourceType,\n      displayName,\n      resourceFolderId,\n      options: resourceOptions ? resourceOptions : {},\n    },\n    false,\n    {},\n    false\n  );\n  const resource = createResourceResult.data;", "export async function createResource({\n  resourceType,\n  credentials,\n  displayName,\n  resourceFolderId,\n  resourceOptions,\n}: {\n  resourceType: string;\n  credentials: Credentials;\n  displayName?: string;\n  resourceFolderId?: number;\n  resourceOptions?: Record<string, any>;\n}): Promise<Resource> {\n  const createResourceResult = await postRequest(\n    `${credentials.origin}/api/resources/`,\n    {\n      type: resourceType,\n      displayName,\n      resourceFolderId,\n      options: resourceOptions ? resourceOptions : {},\n    },\n    false,\n    {},\n    false\n  );\n  const resource = createResourceResult.data;", "  if (!resource) {\n    throw new Error(\"Error creating resource.\");\n  } else {\n    return resource;\n  }\n}\n"]}
{"filename": "src/utils/networking.ts", "chunked_list": ["const axios = require(\"axios\");\n\n// Convenience function for making network requests. Error handling is centralized here.\n// If nothing is returned, the request failed and the process may exit.\nexport async function postRequest(\n  url: string,\n  body: any,\n  exitOnFailure = true,\n  headers = {},\n  shouldHandleError = true\n) {", "  if (!shouldHandleError) {\n    return await axios.post(\n      url,\n      {\n        ...body,\n      },\n      {\n        headers: {\n          ...headers,\n        },\n      }\n    );\n  } else {", "    try {\n      const response = await axios.post(\n        url,\n        {\n          ...body,\n        },\n        {\n          headers: {\n            ...headers,\n          },\n        }\n      );\n      return response;", "    } catch (error: any) {\n      handleError(error, exitOnFailure, url);\n    }\n  }\n}\n\nexport async function getRequest(url: string, exitOnFailure = true) {\n  try {\n    const response = await axios.get(url);\n    return response;\n  } catch (error: any) {\n    handleError(error, exitOnFailure, url);\n  }\n}\n", "  } catch (error: any) {\n    handleError(error, exitOnFailure, url);\n  }\n}\n\nexport async function deleteRequest(url: string, exitOnFailure = true) {\n  try {\n    const response = await axios.delete(url);\n    return response;\n  } catch (error: any) {\n    handleError(error, exitOnFailure, url);\n  }\n}\n", "  } catch (error: any) {\n    handleError(error, exitOnFailure, url);\n  }\n}\n\nfunction handleError(error: any, exitOnFailure = true, url: string) {\n  if (error.response) {\n    // The request was made, but the server responded with a status code outside the 2xx range\n    console.error(\"\\n\\nHTTP Request Error:\", error.response.data);\n  } else {\n    console.error(\"\\n\\nNetwork error:\", error.toJSON());\n  }", "  if (process.env.DEBUG) {\n    console.error(error);\n  }\n  console.error(`\\nFailed to make request to ${url}.`);\n  if (exitOnFailure) {\n    process.exit(1);\n  }\n}\n"]}
{"filename": "src/utils/connectionString.ts", "chunked_list": ["import { ConnectionStringParser } from \"connection-string-parser\";\n\nimport { getCredentials } from \"./credentials\";\nimport { getRequest } from \"./networking\";\n\nconst chalk = require(\"chalk\");\n\n// Print a psql command to connect to the Retool DB.\n// Connnection string is never persisted, it's fetched when needed.\n// This is done to avoid storing the password in plaintext.\nexport async function logConnectionStringDetails() {\n  const connectionString = await getConnectionString();", "// Connnection string is never persisted, it's fetched when needed.\n// This is done to avoid storing the password in plaintext.\nexport async function logConnectionStringDetails() {\n  const connectionString = await getConnectionString();\n  if (connectionString) {\n    const parsed = new ConnectionStringParser({\n      scheme: \"postgresql\",\n      hosts: [],\n    }).parse(connectionString);\n    console.log(\n      `${chalk.bold(\"Connect via psql:\")} PGPASSWORD=${\n        parsed.password\n      } psql -h ${parsed.hosts[0].host} -U ${parsed.username} ${\n        parsed.endpoint\n      }`\n    );\n    console.log(\n      `${chalk.bold(\"Postgres Connection URL:\")} ${connectionString}`\n    );\n  }\n}\n", "async function getConnectionString(): Promise<string | undefined> {\n  const credentials = getCredentials();\n  if (\n    !credentials ||\n    !credentials.retoolDBUuid ||\n    !credentials.hasConnectionString\n  ) {\n    return;\n  }\n  const grid = await getRequest(\n    `${credentials.origin}/api/grid/retooldb/${credentials.retoolDBUuid}?env=production`,\n    false\n  );\n  return grid.data?.gridInfo?.connectionString;\n}\n"]}
{"filename": "src/resources/workflowTemplate.ts", "chunked_list": ["export type WorkflowTemplateType = typeof workflowTemplate;\nexport const workflowTemplate = [\n  {\n    block: {\n      pluginId: \"startTrigger\",\n      incomingOnSuccessPlugins: [],\n      comment: {\n        body: 'This workflow supports performing CRUD operations on a Retool DB instance. Example valid JSON inputs:\\n\\n{\\n type: \"create\",\\n data:{ col1: \"val1\", col2: \"val2\"}\\n}\\n\\n{\\n type: \"read\"\\n}\\n\\n{\\n type: \"update\",\\n row: id,\\n data:{ col1: \"val1\", col2: \"val2\"}\\n}\\n\\n{\\n type: \"destroy\",\\n row: id\\n}',\n        visible: true,\n        pluginId: \"startTrigger-comment\",\n      },\n      top: 0,\n      left: -432,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"webhook\",\n      blockType: \"webhook\",\n    },\n    pluginTemplate: {\n      id: \"startTrigger\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query: 'return {\\n type: \"read\"\\n}',\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"createQuery\",\n      incomingOnSuccessPlugins: [],\n      top: -640,\n      left: 1040,\n      environment: \"production\",\n      editorType: \"SqlQueryUnified\",\n      resourceName: \"\",\n      blockType: \"default\",\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"switchType\",\n          portId: \"a620f4c4-57db-4732-9176-934bcf9b94a8\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"createQuery\",\n      type: \"datasource\",\n      subtype: \"SqlQueryUnified\",\n      resourceName: null,\n      template: {\n        queryRefreshTime: \"\",\n        records: \"\",\n        lastReceivedFromResourceAt: null,\n        databasePasswordOverride: \"\",\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query: \"\",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        warningCodes: [],\n        data: null,\n        recordId: \"\",\n        importedQueryInputs: {},\n        isImported: false,\n        showSuccessToaster: true,\n        dataArray: [],\n        cacheKeyTtl: \"\",\n        filterBy: \"\",\n        requestSentTimestamp: null,\n        databaseHostOverride: \"\",\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"gui\",\n        queryRunTime: null,\n        actionType: \"INSERT\",\n        changesetObject: \"{{startTrigger.data.data}}\",\n        shouldUseLegacySql: false,\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        databaseNameOverride: \"\",\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        resourceTypeOverride: \"postgresql\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        enableBulkUpdates: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        bulkUpdatePrimaryKey: \"\",\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        tableName: \"name_placeholder\",\n        queryTimeout: \"120000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: true,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        databaseUsernameOverride: \"\",\n        shouldEnableBatchQuerying: false,\n        doNotThrowOnNoOp: false,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"switchType\",\n      incomingOnSuccessPlugins: [],\n      top: 0,\n      left: 528,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"conditional\",\n      options: {\n        conditions: [\n          {\n            id: \"4a38580b-830a-4f7b-9c3f-503bf1a0ed6d\",\n            type: \"if\",\n            statement: 'startTrigger.data.type === \"create\"',\n            outgoingPortId: \"a620f4c4-57db-4732-9176-934bcf9b94a8\",\n          },\n          {\n            id: \"5a1e5f9a-ac0e-4b7d-83d9-2ec42d766fb7\",\n            type: \"if\",\n            statement: 'startTrigger.data.type === \"read\"',\n            outgoingPortId: \"75cf13b9-ac7e-47b2-a48d-518ec1094659\",\n          },\n          {\n            id: \"42309937-c622-40bc-8d17-7b302e063b23\",\n            type: \"if\",\n            statement: 'startTrigger.data.type === \"update\"',\n            outgoingPortId: \"7d59ff82-a70b-4fe8-a6c8-3253898cf1a6\",\n          },\n          {\n            id: \"756ce9dc-9a06-4460-bf83-f4579d255dcc\",\n            type: \"if\",\n            statement: 'startTrigger.data.type === \"destroy\"',\n            outgoingPortId: \"221b4d5d-fb16-4581-9b71-f95ef77c66d0\",\n          },\n          {\n            id: \"41fd9758-049c-47b3-8d32-77c4399808c7\",\n            type: \"else\",\n            statement: \"\",\n            outgoingPortId: \"12676e07-8c10-4bb5-914a-98e6608a386e\",\n          },\n        ],\n      },\n      outgoingPorts: [\n        {\n          id: \"a620f4c4-57db-4732-9176-934bcf9b94a8\",\n          name: \"0\",\n          type: \"conditional\",\n        },\n        {\n          id: \"75cf13b9-ac7e-47b2-a48d-518ec1094659\",\n          name: \"1\",\n          type: \"conditional\",\n        },\n        {\n          id: \"7d59ff82-a70b-4fe8-a6c8-3253898cf1a6\",\n          name: \"2\",\n          type: \"conditional\",\n        },\n        {\n          id: \"221b4d5d-fb16-4581-9b71-f95ef77c66d0\",\n          name: \"3\",\n          type: \"conditional\",\n        },\n        {\n          id: \"12676e07-8c10-4bb5-914a-98e6608a386e\",\n          name: \"4\",\n          type: \"conditional\",\n        },\n      ],\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"filterBadRequest\",\n          portId: \"c7a9d846-836e-4fbd-87af-3d76aa66715c\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"switchType\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"if (startTrigger.data.type === \\\"create\\\") {\\n  executePathAtMostOnce('0')\\n}\\nelse if (startTrigger.data.type === \\\"read\\\") {\\n  executePathAtMostOnce('1')\\n}\\nelse if (startTrigger.data.type === \\\"update\\\") {\\n  executePathAtMostOnce('2')\\n}\\nelse if (startTrigger.data.type === \\\"destroy\\\") {\\n  executePathAtMostOnce('3')\\n}\\nelse { executePathAtMostOnce('4') }\",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"readQuery\",\n      incomingOnSuccessPlugins: [],\n      top: -240,\n      left: 1040,\n      environment: \"production\",\n      editorType: \"SqlQueryUnified\",\n      resourceName: \"\",\n      blockType: \"default\",\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"switchType\",\n          portId: \"75cf13b9-ac7e-47b2-a48d-518ec1094659\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"readQuery\",\n      type: \"datasource\",\n      subtype: \"SqlQueryUnified\",\n      resourceName: null,\n      template: {\n        queryRefreshTime: \"\",\n        records: \"\",\n        lastReceivedFromResourceAt: null,\n        databasePasswordOverride: \"\",\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query: \"SELECT * from name_placeholder\",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        warningCodes: [],\n        data: null,\n        recordId: \"\",\n        importedQueryInputs: {},\n        isImported: false,\n        showSuccessToaster: true,\n        dataArray: [],\n        cacheKeyTtl: \"\",\n        filterBy: \"\",\n        requestSentTimestamp: null,\n        databaseHostOverride: \"\",\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        actionType: \"\",\n        changesetObject: \"\",\n        shouldUseLegacySql: false,\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        databaseNameOverride: \"\",\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        resourceTypeOverride: \"postgresql\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        enableBulkUpdates: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        bulkUpdatePrimaryKey: \"\",\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        tableName: \"name_placeholder\",\n        queryTimeout: \"120000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        databaseUsernameOverride: \"\",\n        shouldEnableBatchQuerying: false,\n        doNotThrowOnNoOp: false,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"updateQuery\",\n      incomingOnSuccessPlugins: [],\n      top: 144,\n      left: 1056,\n      environment: \"production\",\n      editorType: \"SqlQueryUnified\",\n      resourceName: \"\",\n      blockType: \"default\",\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"switchType\",\n          portId: \"7d59ff82-a70b-4fe8-a6c8-3253898cf1a6\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"updateQuery\",\n      type: \"datasource\",\n      subtype: \"SqlQueryUnified\",\n      resourceName: null,\n      template: {\n        queryRefreshTime: \"\",\n        records: \"\",\n        lastReceivedFromResourceAt: null,\n        databasePasswordOverride: \"\",\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query: \"-- Delete query goes here\",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        warningCodes: [],\n        data: null,\n        recordId: \"\",\n        importedQueryInputs: {},\n        isImported: false,\n        showSuccessToaster: true,\n        dataArray: [],\n        cacheKeyTtl: \"\",\n        filterBy:\n          '[{\"key\":\"id\",\"value\":\"{{startTrigger.data.row}}\",\"operation\":\"=\"}]',\n        requestSentTimestamp: null,\n        databaseHostOverride: \"\",\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"gui\",\n        queryRunTime: null,\n        actionType: \"UPDATE_BY\",\n        changesetObject: \"{{startTrigger.data.data}}\",\n        shouldUseLegacySql: false,\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        databaseNameOverride: \"\",\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        resourceTypeOverride: \"postgresql\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        enableBulkUpdates: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        bulkUpdatePrimaryKey: \"\",\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        tableName: \"name_placeholder\",\n        queryTimeout: \"120000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: true,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        databaseUsernameOverride: \"\",\n        shouldEnableBatchQuerying: false,\n        doNotThrowOnNoOp: false,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"createReturn\",\n      incomingOnSuccessPlugins: [\"createQuery\"],\n      top: -640,\n      left: 1472,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"webhookReturn\",\n      options: {\n        body: \"{\\n  data: createQuery.data,\\n  error: createQuery.error\\n }\",\n        status: \"200\",\n      },\n    },\n    pluginTemplate: {\n      id: \"createReturn\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: createQuery.data,\\n  error: createQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of createReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"readReturn\",\n      incomingOnSuccessPlugins: [\"readQuery\"],\n      top: -240,\n      left: 1488,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"webhookReturn\",\n      options: {\n        body: \"{\\n  data: readQuery.data,\\n  error: readQuery.error\\n }\",\n        status: \"200\",\n      },\n    },\n    pluginTemplate: {\n      id: \"readReturn\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: readQuery.data,\\n  error: readQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of readReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"updateReturn\",\n      incomingOnSuccessPlugins: [\"updateQuery\"],\n      top: 144,\n      left: 1504,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"webhookReturn\",\n      options: {\n        body: \"{\\n  data: updateQuery.data,\\n  error: updateQuery.error\\n }\",\n        status: \"200\",\n      },\n    },\n    pluginTemplate: {\n      id: \"updateReturn\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: updateQuery.data,\\n  error: updateQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of updateReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"invalidType\",\n      incomingOnSuccessPlugins: [],\n      top: 880,\n      left: 1056,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"webhookReturn\",\n      options: {", "        body: '{\\n  success:false,\\n  mesage:\"Invalid type in request body\"\\n}',\n        status: \"400\",\n      },\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"switchType\",\n          portId: \"12676e07-8c10-4bb5-914a-98e6608a386e\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"invalidType\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 400\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  success:false,\\n  mesage:\\\"Invalid type in request body\\\"\\n}\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of missingTypeReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"destroyQuery\",\n      incomingOnSuccessPlugins: [],\n      top: 512,\n      left: 1056,\n      environment: \"production\",\n      editorType: \"SqlQueryUnified\",\n      resourceName: \"\",\n      blockType: \"default\",\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"switchType\",\n          portId: \"221b4d5d-fb16-4581-9b71-f95ef77c66d0\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"destroyQuery\",\n      type: \"datasource\",\n      subtype: \"SqlQueryUnified\",\n      resourceName: null,\n      template: {\n        queryRefreshTime: \"\",\n        records: \"\",\n        lastReceivedFromResourceAt: null,\n        databasePasswordOverride: \"\",\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:\n          'delete from name_placeholder where \"id\" = {{startTrigger.data.row}}',\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        warningCodes: [],\n        data: null,\n        recordId: \"\",\n        importedQueryInputs: {},\n        isImported: false,\n        showSuccessToaster: true,\n        dataArray: [],\n        cacheKeyTtl: \"\",\n        filterBy:\n          '[{\"key\":\"id\",\"value\":\"{{startTrigger.data.row}}\",\"operation\":\"=\"}]',\n        requestSentTimestamp: null,\n        databaseHostOverride: \"\",\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        actionType: \"DELETE_BY\",\n        changesetObject: \"\",\n        shouldUseLegacySql: false,\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        databaseNameOverride: \"\",\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        resourceTypeOverride: \"postgresql\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        enableBulkUpdates: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        bulkUpdatePrimaryKey: \"\",\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        tableName: \"name_placeholder\",\n        queryTimeout: \"120000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        databaseUsernameOverride: \"\",\n        shouldEnableBatchQuerying: false,\n        doNotThrowOnNoOp: true,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"destroyReturn\",\n      incomingOnSuccessPlugins: [\"destroyQuery\"],\n      top: 512,\n      left: 1504,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"webhookReturn\",\n      options: {\n        body: \"{\\n  data: destroyQuery.data,\\n  error: destroyQuery.error\\n }\",\n        status: \"200\",\n      },\n    },\n    pluginTemplate: {\n      id: \"destroyReturn\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: destroyQuery.data,\\n  error: destroyQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of destroyReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"filterBadRequest\",\n      incomingOnSuccessPlugins: [\"startTrigger\"],\n      top: 0,\n      left: 48,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"conditional\",\n      options: {\n        conditions: [\n          {\n            id: \"44af1908-d150-49f9-9f9b-340366665a96\",\n            type: \"if\",\n            statement: \"startTrigger.data?.type\",\n            outgoingPortId: \"c7a9d846-836e-4fbd-87af-3d76aa66715c\",\n          },\n          {\n            id: \"fde78ed6-12ea-4d47-b0ff-31404aa98db2\",\n            type: \"else\",\n            statement: \"\",\n            outgoingPortId: \"861a427e-f1c4-4ba1-8532-52580fc61da9\",\n          },\n        ],\n      },\n      outgoingPorts: [\n        {\n          id: \"c7a9d846-836e-4fbd-87af-3d76aa66715c\",\n          name: \"0\",\n          type: \"conditional\",\n        },\n        {\n          id: \"861a427e-f1c4-4ba1-8532-52580fc61da9\",\n          name: \"1\",\n          type: \"conditional\",\n        },\n      ],\n      incomingPortsPlugins: [],\n    },\n    pluginTemplate: {\n      id: \"filterBadRequest\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"if (startTrigger.data?.type) {\\n  executePathAtMostOnce('0')\\n}\\nelse { executePathAtMostOnce('1') }\",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n  {\n    block: {\n      pluginId: \"missingType\",\n      incomingOnSuccessPlugins: [],\n      top: 512,\n      left: 512,\n      environment: \"production\",\n      editorType: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      blockType: \"webhookReturn\",\n      options: {", "        body: '{\\n  success:false,\\n  mesage:\"Missing type in request body\"\\n}',\n        status: \"400\",\n      },\n      incomingPortsPlugins: [\n        {\n          blockPluginId: \"filterBadRequest\",\n          portId: \"861a427e-f1c4-4ba1-8532-52580fc61da9\",\n        },\n      ],\n    },\n    pluginTemplate: {\n      id: \"missingType\",\n      type: \"datasource\",\n      subtype: \"JavascriptQuery\",\n      resourceName: \"JavascriptQuery\",\n      template: {\n        queryRefreshTime: \"\",\n        lastReceivedFromResourceAt: null,\n        queryDisabledMessage: \"\",\n        servedFromCache: false,\n        offlineUserQueryInputs: \"\",\n        successMessage: \"\",\n        queryDisabled: \"\",\n        playgroundQuerySaveId: \"latest\",\n        workflowParams: null,\n        resourceNameOverride: \"\",\n        runWhenModelUpdates: false,\n        workflowRunId: null,\n        showFailureToaster: true,\n        query:", "          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 400\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  success:false,\\n  mesage:\\\"Missing type in request body\\\"\\n}\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of missingType'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n        playgroundQueryUuid: \"\",\n        playgroundQueryId: null,\n        error: null,\n        workflowRunBodyType: \"raw\",\n        privateParams: [],\n        runWhenPageLoadsDelay: \"\",\n        data: null,\n        importedQueryInputs: {},\n        _additionalScope: [],\n        isImported: false,\n        showSuccessToaster: true,\n        cacheKeyTtl: \"\",\n        requestSentTimestamp: null,\n        metadata: null,\n        workflowActionType: null,\n        editorMode: \"sql\",\n        queryRunTime: null,\n        changesetObject: \"\",\n        errorTransformer:\n          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n        finished: null,\n        confirmationMessage: null,\n        isFetching: false,\n        changeset: \"\",\n        rawData: null,\n        queryTriggerDelay: \"0\",\n        watchedParams: [],\n        enableErrorTransformer: false,\n        showLatestVersionUpdatedWarning: false,\n        timestamp: 0,\n        evalType: \"script\",\n        importedQueryDefaults: {},\n        enableTransformer: false,\n        showUpdateSetValueDynamicallyToggle: true,\n        runWhenPageLoads: false,\n        transformer:\n          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n        events: [],\n        queryTimeout: \"10000\",\n        workflowId: null,\n        requireConfirmation: false,\n        queryFailureConditions: \"\",\n        changesetIsObject: false,\n        enableCaching: false,\n        allowedGroups: [],\n        workflowBlockPluginId: null,\n        offlineQueryType: \"None\",\n        queryThrottleTime: \"750\",\n        updateSetValueDynamically: false,\n        notificationDuration: \"\",\n      },\n    },\n  },\n];\n"]}
